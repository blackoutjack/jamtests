function v1409(){function v1408(soruceFiles){function v1407(sf){JAM.call(resolvedFiles.push,resolvedFiles,[sf.path]);addWatcher(sf.path)}function onWatchedFileChange(){function v1406(f){var v1412=_this.ioHost;return JAM.call(v1412.printLine,v1412,["    "+f])}function v1405(sf){return JAM.call(newFiles.push,newFiles,[sf.path])}_this.compilationEnvironment.code=soruceFiles;var v1416=_this,v12376;v12376=_this.compilationSettings.resolve?_this.resolve():_this.compilationEnvironment;v1416.resolvedEnvironment=
v12376;var v1416=resolvedFiles,newFiles=[];_this.resolvedEnvironment.code.forEach(v1405);var newFiles=newFiles.sort(),i=0;v12376=0;var v12378=i<v1416.length;for(v12378&&(v12378=v12376<newFiles.length);v12378;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v12378=v1416[i];introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v1419=newFiles[v12376];v12378=v12378.localeCompare(v1419);if(0==v12378)i+=1,v12376+=1;else if(0>v12378){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v12378=
v1416[i];removeWatcher(v12378);i+=1}else{introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v12378=newFiles[v12376];addWatcher(v12378);v12376+=1}(v12378=i<v1416.length)&&(v12378=v12376<newFiles.length)}for(v12378=i<v1416.length;v12378;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v12378=v1416[i];removeWatcher(v12378);i+=1;v12378=i<v1416.length}i=v12376;for(v1416=i<newFiles.length;v1416;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v1416=newFiles[i];
addWatcher(v1416);i+=1;v1416=i<newFiles.length}resolvedFiles=newFiles;v1416=_this.ioHost;JAM.call(v1416.printLine,v1416,[""]);v1416=_this.ioHost;JAM.call(v1416.printLine,v1416,["Recompiling ("+new Date+"): "]);resolvedFiles.forEach(v1406);v1416=_this.compile();v1416||(v1416=_this.hasResolveErrors);v1416||_this.compilationSettings.exec&&_this.run()}function removeWatcher(filename){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v1436=watchers[filename];if(v1436){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v1436=
watchers[filename];v1436.close();delete watchers[filename]}else throw Error("Cannot stop watching file, it is not being watched.");}function addWatcher(filename){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v12387=watchers[filename];if(v12387)throw Error("Cannot watch file, it is already watched.");v12387=_this.ioHost;v12387=JAM.call(v12387.watchFile,v12387,[filename,onWatchedFileChange]);JAM.set(watchers,filename,v12387)}var _this=this;if(this.ioHost.watchFile){var resolvedFiles=
[],watchers={};this.ioHost.stderr=this.ioHost.stdout;this.resolvedEnvironment.code.forEach(v1407);resolvedFiles.sort()}else{var v1439=this.ioHost;JAM.call(v1439.printLine,v1439,["Error: Current host does not support -w[atch] option"])}}function v1404(){if(!this.printedVersion){var v1443=this.ioHost;JAM.call(v1443.printLine,v1443,["Version "+this.compilerVersion]);this.printedVersion=!0}}function v1403(){function v1402(){_this.printVersion()}function v1401(){_this.compilationSettings.useCaseSensitiveFileResolution=
!0}function v1400(){_this.printVersion();opts.printUsage();printedUsage=!0}function v1399(type){type=type.toLowerCase();var v12393="commonjs"===type;v12393||(v12393="node"===type);v12393?TypeScript.moduleGenTarget=TypeScript.ModuleGenTarget.Synchronous:"amd"===type?TypeScript.moduleGenTarget=TypeScript.ModuleGenTarget.Asynchronous:(v12393=_this.ioHost,JAM.call(v12393.printLine,v12393,["Module code generation '"+type+"' not supported.  Using default 'commonjs' code generation"]))}function v1398(type){type=
type.toLowerCase();if("es3"===type)_this.compilationSettings.codeGenTarget=TypeScript.CodeGenTarget.ES3;else if("es5"===type)_this.compilationSettings.codeGenTarget=TypeScript.CodeGenTarget.ES5;else{var v1455=_this.ioHost;JAM.call(v1455.printLine,v1455,["ECMAScript target version '"+type+"' not supported.  Using default 'ES3' code generation"])}}function v1397(){_this.compilationSettings.inferPropertiesFromThisAssignment=!0}function v1396(){_this.compilationSettings.useDefaultLib=!1}function v1395(){TypeScript.optimizeModuleCodeGen=
!1}function v1394(){_this.compilationSettings.canCallDefinitionSignature=!0}function v1393(){TypeScript.CompilerDiagnostics.debug=!0}function v1392(){_this.compilationSettings.resolve=!1;_this.compilationSettings.preprocess=!1}function v1391(){_this.compilationSettings.errorOnWith=!1}function v1390(){_this.compilationSettings.controlFlow=!0;_this.compilationSettings.controlFlowUseDef=!0}function v1389(){_this.compilationSettings.controlFlow=!0;_this.compilationSettings.printControlFlow=!0}function v1388(){_this.compilationSettings.controlFlow=
!0}function v1387(){_this.compilationSettings.emitComments=!0}function v1386(){_this.compilationSettings.errorRecovery=!0}function v1385(){_this.compilationSettings.propagateConstants=!0}function v1384(){_this.compilationSettings.minWhitespace=!0}function v1383(){_this.compilationSettings.parseOnly=!0}function v1382(){_this.compilationSettings.exec=!0}function v1381(){_this.compilationSettings.watch=!0}function v1380(){_this.compilationSettings.generateDeclarationFiles=!0}function v1379(){_this.compilationSettings.mapSourceFiles=
!0}function v1378(str){var v1480=_this.compilationSettings;JAM.call(v1480.setStyleOptions,v1480,[str])}function v1377(str){_this.compilationSettings.outputOption=str}function v1376(s){var v1482=_this.ioHost;JAM.call(v1482.printLine,v1482,[s])}var _this=this;TypeScript.CompilerDiagnostics.diagnosticWriter={Alert:v1376};var code,opts=JAM.new(OptionsParser,[this.ioHost]);JAM.call(opts.option,opts,["out",{usage:"Concatenate and emit output to single file | Redirect output structure to the directory",
type:"file|directory",set:v1377}]);JAM.call(opts.option,opts,["style",{usage:'Select style checking options (examples --style requireSemi:off or --style "eqeqeq;bitwise:off")',experimental:!0,set:v1378}]);JAM.call(opts.flag,opts,["sourcemap",{usage:"Generates corresponding .map file",set:v1379}]);JAM.call(opts.flag,opts,["declaration",{usage:"Generates corresponding .d.ts file",set:v1380}]);this.ioHost.watchFile&&JAM.call(opts.flag,opts,["watch",{usage:"Watch output files",set:v1381},"w"]);JAM.call(opts.flag,
opts,["exec",{usage:"Execute the script after compilation",set:v1382},"e"]);JAM.call(opts.flag,opts,["parse",{usage:"Parse only",experimental:!0,set:v1383}]);JAM.call(opts.flag,opts,["minw",{usage:"Minimize whitespace",experimental:!0,set:v1384},"mw"]);JAM.call(opts.flag,opts,["const",{usage:"Propagate constants to emitted code",experimental:!0,set:v1385}]);JAM.call(opts.flag,opts,["errorrecovery",{usage:"Enable error recovery",experimental:!0,set:v1386},"er"]);JAM.call(opts.flag,opts,["comments",
{usage:"Emit comments to output",set:v1387},"c"]);JAM.call(opts.flag,opts,["cflow",{usage:"Control flow",experimental:!0,set:v1388}]);JAM.call(opts.flag,opts,["cflowp",{usage:"Print control flow",experimental:!0,set:v1389}]);JAM.call(opts.flag,opts,["cflowu",{usage:"Print Use Def control flow",experimental:!0,set:v1390}]);JAM.call(opts.flag,opts,["noerroronwith",{usage:"Allow with statements",experimental:!0,set:v1391}]);JAM.call(opts.flag,opts,["noresolve",{usage:"Skip resolution and preprocessing",
experimental:!0,set:v1392}]);JAM.call(opts.flag,opts,["debug",{usage:"Print debug output",experimental:!0,set:v1393}]);JAM.call(opts.flag,opts,["canCallDefinitionSignature",{usage:"Allows you to call the definition signature of an overload group",experimental:!0,set:v1394}]);JAM.call(opts.flag,opts,["nooptimizemodules",{usage:"Do not optimize module codegen",experimental:!0,set:v1395}]);JAM.call(opts.flag,opts,["nolib",{usage:"Do not include a default lib.d.ts with global declarations",set:v1396}]);
JAM.call(opts.flag,opts,["inferProperties",{usage:"Infer class properties from top-level assignments to 'this'",experimental:!0,set:v1397}]);JAM.call(opts.option,opts,["target",{usage:'Specify ECMAScript target version: "ES3" (default), or "ES5"',type:"VER",set:v1398}]);JAM.call(opts.option,opts,["module",{usage:'Specify module code generation: "commonjs" (default) or "amd"',type:"kind",set:v1399}]);var printedUsage=!1;JAM.call(opts.flag,opts,["help",{usage:"Print this message",set:v1400},"h"]);JAM.call(opts.flag,
opts,["useCaseSensitiveFileResolution",{usage:"Force file resolution to be case sensitive",experimental:!0,set:v1401}]);JAM.call(opts.flag,opts,["version",{usage:"Print the compiler's version: "+this.compilerVersion,set:v1402},"v"]);JAM.call(opts.parse,opts,[this.ioHost.arguments]);if(this.compilationSettings.useDefaultLib){var compilerFilePath=this.ioHost.getExecutingFilePath();code=this.ioHost;compilerFilePath=JAM.call(code.dirName,code,[compilerFilePath]);code=this.ioHost;compilerFilePath=JAM.call(code.resolvePath,
code,[compilerFilePath+"/lib.d.ts"]);code=JAM.new(TypeScript.SourceUnit,[compilerFilePath,null]);compilerFilePath=this.compilationEnvironment.code;JAM.call(compilerFilePath.push,compilerFilePath,[code])}compilerFilePath=0;for(code=compilerFilePath<opts.unnamed.length;code;){code=TypeScript.SourceUnit;var v12404=opts.unnamed;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v12404=v12404[compilerFilePath];code=JAM.new(code,[v12404,null]);v12404=this.compilationEnvironment.code;JAM.call(v12404.push,
v12404,[code]);compilerFilePath+=1;code=compilerFilePath<opts.unnamed.length}compilerFilePath=this.compilationEnvironment.code.length;code=this.compilationSettings.useDefaultLib?1:0;compilerFilePath==code?((compilerFilePath=!printedUsage)&&(compilerFilePath=!this.printedVersion),compilerFilePath&&(this.printVersion(),opts.printUsage(),compilerFilePath=this.ioHost,JAM.call(compilerFilePath.quit,compilerFilePath,[1]))):(compilerFilePath=[],this.compilationSettings.watch&&(compilerFilePath=this.compilationEnvironment.code.slice(0)),
this.resolvedEnvironment=code=this.compilationSettings.resolve?this.resolve():this.compilationEnvironment,code=this.compile(),code||(code=this.hasResolveErrors),code||this.compilationSettings.exec&&this.run(),this.compilationSettings.watch?JAM.call(this.watchFiles,this,[compilerFilePath]):(compilerFilePath=this.ioHost,code=code?1:0,JAM.call(compilerFilePath.quit,compilerFilePath,[code])))}function v1375(){for(var i=0,v1542=i<this.compilationEnvironment.code.length;v1542;){v1542=this.compilationEnvironment.code;
introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v1542=v1542[i];v1542=v1542.path;JAM.call(TypeScript.isTSFile,TypeScript,[v1542])?v1542=v1542.replace(/\.ts$/,".js"):JAM.call(TypeScript.isSTRFile,TypeScript,[v1542])&&(v1542=v1542.replace(/\.str$/,".js"));var v12419=this.ioHost;if(JAM.call(v12419.fileExists,v12419,[v1542])){var v12419=this.ioHost,v12419=JAM.call(v12419.readFile,v12419,[v1542]),v1540=this.ioHost;JAM.call(v1540.run,v1540,[v12419,v1542])}i+=1;v1542=i<this.compilationEnvironment.code.length}}
function v1374(){function v1373(fileName,useUTF8){return JAM.call(IOUtils.createFileAndFolderStructure,IOUtils,[_this.ioHost,fileName,useUTF8])}function v1372(minChar,charLen,message,unitIndex){compiler.errorReporter.hasErrors=!0;charLen=_this.resolvedEnvironment.code;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)unitIndex=charLen[unitIndex];unitIndex=unitIndex.path;charLen={line:-1,col:-1};var v1546=compiler.parser;JAM.call(v1546.getSourceLineCol,v1546,[charLen,minChar]);minChar=
unitIndex+" ("+charLen.line+","+(charLen.col+1)+"): "+message;if(_this.compilationSettings.errorRecovery)message=_this.ioHost.stderr,JAM.call(message.WriteLine,message,[minChar]);else throw new SyntaxError(minChar);}function consumeUnit(code){var addAsResident=!1;try{if(!_this.compilationSettings.resolve){var v1550=code,v12426=_this.ioHost,v26770=JAM.call(v12426.readFile,v12426,[code.path]);v1550.content=v26770;if(_this.compilationSettings.generateDeclarationFiles){var v1551=TypeScript.CompilerDiagnostics;
JAM.call(v1551.assert,v1551,[null==code.referencedFiles,"With no resolve option, referenced files need to null"]);var v1550=code,v26771=JAM.call(TypeScript.getReferencedFiles,TypeScript,[code]);v1550.referencedFiles=v26771}}if(code.content)if(_this.compilationSettings.parseOnly)JAM.call(compiler.parseUnit,compiler,[code.content,code.path]);else{if(_this.compilationSettings.errorRecovery){var v1558=compiler.parser;JAM.call(v1558.setErrorRecovery,v1558,[_this.ioHost.stderr])}JAM.call(compiler.addUnit,
compiler,[code.content,code.path,addAsResident,code.referencedFiles])}}catch(err){compiler.errorReporter.hasErrors=!0,code=_this.ioHost.stderr,JAM.call(code.WriteLine,code,[err.message])}}var _this=this,compiler;compiler=JAM.new(TypeScript.TypeScriptCompiler,[this.ioHost.stderr,new TypeScript.NullLogger,this.compilationSettings]);JAM.call(compiler.setErrorOutput,compiler,[this.ioHost.stderr]);JAM.call(compiler.setErrorCallback,compiler,[v1372]);this.compilationSettings.emitComments&&compiler.emitCommentsToOutput();
for(var iCode=0,v1577=iCode<this.resolvedEnvironment.code.length;v1577;){(v1577=!this.compilationSettings.parseOnly)||(v1577=0<iCode);if(v1577){v1577=this.resolvedEnvironment.code;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v1577=v1577[iCode];consumeUnit(v1577)}iCode+=1;v1577=iCode<this.resolvedEnvironment.code.length}iCode={createFile:v1373,directoryExists:this.ioHost.directoryExists,fileExists:this.ioHost.fileExists,resolvePath:this.ioHost.resolvePath};try{this.compilationSettings.parseOnly?
JAM.call(compiler.emitAST,compiler,[iCode]):(compiler.typeCheck(),JAM.call(compiler.emit,compiler,[iCode]),compiler.emitDeclarations())}catch(err$$0){if(compiler.errorReporter.hasErrors=!0,"EmitError"!=err$$0.message)throw err$$0;}return compiler.errorReporter.hasErrors}function v1371(){var resolver=JAM.new(TypeScript.CodeResolver,[this.compilationEnvironment]),commandLineHost=JAM.new(CommandLineHost,[this.compilationSettings]),resolver=JAM.call(commandLineHost.resolveCompilationEnvironment,commandLineHost,
[this.compilationEnvironment,resolver,!0]);this.hasResolveErrors=!1;for(var i=0,v1596=i<this.compilationEnvironment.code.length;v1596;){v1596=this.compilationEnvironment.code;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v1596=v1596[i];if(!JAM.call(commandLineHost.isResolved,commandLineHost,[v1596.path])){this.hasResolveErrors=!0;v1596=this.compilationEnvironment.code;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v1596=v1596[i];var v1596=v1596.path,v12450=!JAM.call(TypeScript.isSTRFile,
TypeScript,[v1596]);v12450&&(v12450=!JAM.call(TypeScript.isDSTRFile,TypeScript,[v1596]))&&(v12450=!JAM.call(TypeScript.isTSFile,TypeScript,[v1596]))&&(v12450=!JAM.call(TypeScript.isDTSFile,TypeScript,[v1596]));v12450?(v12450=this.ioHost.stderr,JAM.call(v12450.WriteLine,v12450,['Unknown extension for file: "'+v1596+'". Only .ts and .d.ts extensions are allowed.'])):(v12450=this.ioHost.stderr,JAM.call(v12450.WriteLine,v12450,['Error reading file "'+v1596+'": File not found']))}i+=1;v1596=i<this.compilationEnvironment.code.length}return resolver}
function BatchCompiler(ioHost){this.ioHost=ioHost;this.resolvedEnvironment=null;this.hasResolveErrors=!1;this.compilerVersion="0.8.2.0";this.printedVersion=!1;this.compilationSettings=ioHost=new TypeScript.CompilationSettings;this.compilationEnvironment=ioHost=JAM.new(TypeScript.CompilationEnvironment,[this.compilationSettings,this.ioHost])}BatchCompiler.prototype.resolve=v1371;BatchCompiler.prototype.compile=v1374;BatchCompiler.prototype.run=v1375;BatchCompiler.prototype.batchCompile=v1403;BatchCompiler.prototype.printVersion=
v1404;BatchCompiler.prototype.watchFiles=v1408;return BatchCompiler}
function v1370(){function v1369(preEnv,resolver,traceDependencies){function v1368(path,code){var pathId=JAM.call(_this.getPathIdentifier,_this,[path]),v18860=_this.resolvedPaths;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v18860=v18860[pathId];v18860||(v18860=resolvedEnv.code,JAM.call(v18860.push,v18860,[code]),JAM.set(_this.resolvedPaths,pathId,!0))}function postResolutionError(errorFile,errorMessage){var v1610=TypeScript.CompilerDiagnostics,v12457="Could not resolve file '"+
errorFile+"'",v18862;v18862=""==errorMessage?"":": "+errorMessage;JAM.call(v1610.debugPrint,v1610,[v12457+v18862])}var _this=this,resolvedEnv=JAM.new(TypeScript.CompilationEnvironment,[preEnv.compilationSettings,preEnv.ioHost]);traceDependencies=preEnv.code.length;for(var path$$0="",resolutionDispatcher={postResolutionError:postResolutionError,postResolution:v1368},i=0,path$$0=i<traceDependencies;path$$0;){var path$$0=preEnv.ioHost,v22843=preEnv.code;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v22843=
v22843[i];var path$$0=JAM.call(TypeScript.switchToForwardSlashes,TypeScript,[JAM.call(path$$0.resolvePath,path$$0,[v22843.path])]),v22843=this.pathMap,v18864=preEnv.code;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v18864=v18864[i];JAM.set(v22843,v18864.path,path$$0);JAM.call(resolver.resolveCode,resolver,[path$$0,"",!1,resolutionDispatcher]);i+=1;path$$0=i<traceDependencies}return resolvedEnv}function v1367(path){var v12462=this.resolvedPaths,v22844=this.pathMap;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)path=
v22844[path];path=JAM.call(this.getPathIdentifier,this,[path]);introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v12462=v12462[path];return void 0!=v12462}function v1366(path){return path=this.compilationSettings.useCaseSensitiveFileResolution?path:path.toLocaleUpperCase()}function CommandLineHost(compilationSettings){this.compilationSettings=compilationSettings;this.pathMap={};this.resolvedPaths={}}CommandLineHost.prototype.getPathIdentifier=v1366;CommandLineHost.prototype.isResolved=
v1367;CommandLineHost.prototype.resolveCompilationEnvironment=v1369;return CommandLineHost}
function v1365(){function v1364(args){for(var position=0,v1635=position<args.length;v1635;){v1635=position;position+=1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var current=args[v1635];var match=current.match(/^(--?|@)(.*)/),v1635=null;match?"@"===match[1]?(v1635=this.host,JAM.call(this.parseString,this,[JAM.call(v1635.readFile,v1635,[match[2]])])):(current=match[2],match=JAM.call(this.findOption,this,[current]),null===match?(v1635=this.host,JAM.call(v1635.printLine,v1635,["Unknown option '"+
current+"'"]),v1635=this.host,JAM.call(v1635.printLine,v1635,["Use the '--help' flag to see options"])):(match.flag||(v1635=position,position+=1,v1635=args[v1635]),JAM.call(match.set,match,[v1635]))):(v1635=this.unnamed,JAM.call(v1635.push,v1635,[current]));v1635=position<args.length}}function v1363(argString){var position=0;argString=argString.match(/\s+|"|[^\s"]+/g);for(var args=[],currentArg="",v1645=position<argString.length;v1645;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v1645=
argString[position];if('"'===v1645){v1645="";position+=1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var token=argString[position];var v12473=token;for(v12473&&(v12473='"'!==token);v12473;)position+=1,v1645+=token,(v12473=token=argString[position])&&(v12473='"'!==token);position+=1;currentArg+=v1645}else v1645.match(/\s/)?(0<currentArg.length&&(JAM.call(args.push,args,[currentArg]),currentArg=""),position+=1):(position+=1,currentArg+=v1645);v1645=position<argString.length}0<currentArg.length&&
JAM.call(args.push,args,[currentArg]);JAM.call(this.parse,this,[args])}function v1362(name,config,short){config||(config=short,short=null);config.name=name;config.short=short;config.flag=!0;name=this.options;JAM.call(name.push,name,[config])}function v1361(name,config,short){config||(config=short,short=null);config.name=name;config.short=short;config.flag=!1;name=this.options;JAM.call(name.push,name,[config])}function v1360(){function v1359(a,b){var aName=a.name.toLowerCase(),bName=b.name.toLowerCase();
return aName>bName?1:aName<bName?-1:0}var v1655=this.host;JAM.call(v1655.printLine,v1655,["Syntax:   tsc [options] [file ..]"]);v1655=this.host;JAM.call(v1655.printLine,v1655,[""]);v1655=this.host;JAM.call(v1655.printLine,v1655,["Examples: tsc hello.ts"]);v1655=this.host;JAM.call(v1655.printLine,v1655,["          tsc --out foo.js foo.ts"]);v1655=this.host;JAM.call(v1655.printLine,v1655,["          tsc @args.txt"]);v1655=this.host;JAM.call(v1655.printLine,v1655,[""]);v1655=this.host;JAM.call(v1655.printLine,
v1655,["Options:"]);var v1655=[],maxLength=0,v26774=this.options.sort(v1359);this.options=v26774;for(var v26774=0,v1670=v26774<this.options.length;v1670;){v1670=this.options;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v1670=v1670[v26774];if(!v1670.experimental){if(!v1670.usage)break;var usageString="  ",v1666;v1666=v1670.type?" "+v1670.type.toUpperCase():"";v1670.short&&(usageString+=this.DEFAULT_SHORT_FLAG+v1670.short+v1666+", ");usageString+=this.DEFAULT_LONG_FLAG+v1670.name+
v1666;JAM.call(v1655.push,v1655,[[usageString,v1670.usage]]);usageString.length>maxLength&&(maxLength=usageString.length)}v26774+=1;v1670=v26774<this.options.length}JAM.call(v1655.push,v1655,[["  @<file>","Insert command line options and files from a file."]]);v26774=0;for(v1670=v26774<v1655.length;v1670;){v1670=this.host;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)usageString=v1655[v26774];usageString=usageString[0];introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v1666=
v1655[v26774];usageString+=Array(maxLength-v1666[0].length+3).join(" ");introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v1666=v1655[v26774];JAM.call(v1670.printLine,v1670,[usageString+v1666[1]]);v26774+=1;v1670=v26774<v1655.length}}function v1358(arg){for(var i=0,v1677=i<this.options.length;v1677;){v1677=this.options;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v1677=v1677[i];v1677=arg===v1677.short;if(!v1677){v1677=this.options;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v1677=
v1677[i];v1677=arg===v1677.name}if(v1677){arg=this.options;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return arg[i]}i+=1;v1677=i<this.options.length}return null}function OptionsParser(host){this.host=host;this.DEFAULT_SHORT_FLAG="-";this.DEFAULT_LONG_FLAG="--";this.unnamed=[];this.options=[]}OptionsParser.prototype.findOption=v1358;OptionsParser.prototype.printUsage=v1360;OptionsParser.prototype.option=v1361;OptionsParser.prototype.flag=v1362;OptionsParser.prototype.parseString=
v1363;OptionsParser.prototype.parse=v1364;return OptionsParser}
function v1357(){function getWindowsScriptHostIO(){function v1331(exitCode){"undefined"===typeof exitCode&&(exitCode=0);try{JAM.call(WScript.Quit,WScript,[exitCode])}catch(e){}}function v1330(){return WScript.ScriptFullName}function v1329(source,filename){try{JAM.isEval(eval)?eval("introspect(JAM.policy.pFull) { "+source+" }"):JAM.call(eval,null,[source])}catch(e){JAM.call(IOUtils.throwIOError,IOUtils,["Error while executing file '"+filename+"'.",e])}}function v1328(str){JAM.call(WScript.Echo,WScript,
[str])}function v1327(str){var v1686=WScript.StdOut;JAM.call(v1686.Write,v1686,[str])}function v1326(path,spec,options){function filesInFolder(folder,root){var paths=[],fc;if(options.recursive){fc=JAM.new(Enumerator,[folder.subfolders]);for(var v1689=!fc.atEnd();v1689;)paths=paths.concat(filesInFolder(fc.item(),root+"/"+fc.item().Name)),fc.moveNext(),v1689=!fc.atEnd()}fc=JAM.new(Enumerator,[folder.files]);for(v1689=!fc.atEnd();v1689;)(v1689=!spec)||(v1689=fc.item().Name.match(spec)),v1689&&JAM.call(paths.push,
paths,[root+"/"+fc.item().Name]),fc.moveNext(),v1689=!fc.atEnd();return paths}options=options||{};var folder=JAM.call(fso.GetFolder,fso,[path]);return filesInFolder(folder,path)}function v1325(path){try{JAM.call(this.directoryExists,this,[path])||JAM.call(fso.CreateFolder,fso,[path])}catch(e){JAM.call(IOUtils.throwIOError,IOUtils,["Couldn't create directory '"+path+"'.",e])}}function v1324(path){return JAM.call(fso.FolderExists,fso,[path])}function v1323(path,useUTF8){function v1322(){try{JAM.call(streamObj.SaveToFile,
streamObj,[path,2])}catch(saveError){JAM.call(IOUtils.throwIOError,IOUtils,["Couldn't write to file '"+path+"'.",saveError])}finally{0!=streamObj.State&&streamObj.Close(),JAM.call(streamObjectPool.push,streamObjectPool,[streamObj])}}function v1321(str){JAM.call(streamObj.WriteText,streamObj,[str,1])}function v1320(str){JAM.call(streamObj.WriteText,streamObj,[str,0])}try{var streamObj=getStreamObject(),v1699;v1699=useUTF8?"utf-8":"x-ansi";streamObj.Charset=v1699;streamObj.Open();return{Write:v1320,
WriteLine:v1321,Close:v1322}}catch(creationError){JAM.call(IOUtils.throwIOError,IOUtils,["Couldn't write to file '"+path+"'.",creationError])}}function v1319(path){try{JAM.call(fso.FileExists,fso,[path])&&JAM.call(fso.DeleteFile,fso,[path,!0])}catch(e){JAM.call(IOUtils.throwIOError,IOUtils,["Couldn't delete file '"+path+"'.",e])}}function v1318(rootPath,partialFilePath){for(var path=JAM.call(fso.GetAbsolutePathName,fso,[rootPath])+"/"+partialFilePath;;)if(JAM.call(fso.FileExists,fso,[path]))try{var content=
JAM.call(this.readFile,this,[path]);return{content:content,path:path}}catch(err){}else{rootPath=JAM.call(fso.GetParentFolderName,fso,[JAM.call(fso.GetAbsolutePathName,fso,[rootPath])]);if(""==rootPath)return null;path=JAM.call(fso.BuildPath,fso,[rootPath,partialFilePath])}}function v1317(path){return JAM.call(fso.GetParentFolderName,fso,[path])}function v1316(path){return JAM.call(fso.GetAbsolutePathName,fso,[path])}function v1315(path){return JAM.call(fso.FileExists,fso,[path])}function v1314(path,
contents){var file=JAM.call(this.createFile,this,[path]);JAM.call(file.Write,file,[contents]);file.Close()}function v1313(path){try{var streamObj=getStreamObject();streamObj.Open();streamObj.Type=2;streamObj.Charset="x-ansi";JAM.call(streamObj.LoadFromFile,streamObj,[path]);var bomChar=JAM.call(streamObj.ReadText,streamObj,[2]);streamObj.Position=0;var v18886=254==JAM.call(bomChar.charCodeAt,bomChar,[0]);v18886&&(v18886=255==JAM.call(bomChar.charCodeAt,bomChar,[1]));if(!v18886){var v18887=255==JAM.call(bomChar.charCodeAt,
bomChar,[0]);v18887&&(v18887=254==JAM.call(bomChar.charCodeAt,bomChar,[1]));v18886=v18887}if(v18886)streamObj.Charset="unicode";else{var v12514=239==JAM.call(bomChar.charCodeAt,bomChar,[0]);v12514&&(v12514=187==JAM.call(bomChar.charCodeAt,bomChar,[1]));v12514&&(streamObj.Charset="utf-8")}var str=JAM.call(streamObj.ReadText,streamObj,[-1]);streamObj.Close();JAM.call(streamObjectPool.push,streamObjectPool,[streamObj]);return str}catch(err){JAM.call(IOUtils.throwIOError,IOUtils,['Error reading file "'+
path+'".',err])}}function getStreamObject(){return 0<streamObjectPool.length?streamObjectPool.pop():JAM.new(ActiveXObject,["ADODB.Stream"])}for(var fso=JAM.new(ActiveXObject,["Scripting.FileSystemObject"]),streamObjectPool=[],args=[],i=0,v1713=i<WScript.Arguments.length;v1713;){var v1713=args,v1712=i,v12518=WScript.Arguments,v12518=JAM.call(v12518.Item,v12518,[i]);v1713[v1712]=v12518;i+=1;v1713=i<WScript.Arguments.length}return{readFile:v1313,writeFile:v1314,fileExists:v1315,resolvePath:v1316,dirName:v1317,
findFile:v1318,deleteFile:v1319,createFile:v1323,directoryExists:v1324,createDirectory:v1325,dir:v1326,print:v1327,printLine:v1328,arguments:args,stderr:WScript.StdErr,stdout:WScript.StdOut,watchFile:null,run:v1329,getExecutingFilePath:v1330,quit:v1331}}function getNodeIO(){function v1356(){return process.mainModule.filename}function v1355(source,filename){require.main.filename=filename;var v1718=require.main,v26776=JAM.call(_module._nodeModulePaths,_module,[JAM.call(_path.dirname,_path,[JAM.call(_fs.realpathSync,
_fs,[filename])])]);v1718.paths=v26776;v1718=require.main;JAM.call(v1718._compile,v1718,[source,filename])}function v1354(filename,callback){function v1353(){JAM.call(_fs.unwatchFile,_fs,[filename,fileChanged])}function fileChanged(curr,prev){function v1352(){processingChange=!1}if(!firstRun){if(curr.mtime<prev.mtime)return;JAM.call(_fs.unwatchFile,_fs,[filename,fileChanged]);processingChange||(processingChange=!0,JAM.call(callback,null,[filename]),JAM.call(setTimeout,null,[v1352,100]))}firstRun=
!1;JAM.call(_fs.watchFile,_fs,[filename,{persistent:!0,interval:500},fileChanged])}var firstRun=!0,processingChange=!1;fileChanged();return{filename:filename,close:v1353}}function v1351(){}function v1350(str){var v1724=process.stdout;JAM.call(v1724.write,v1724,[str+"\n"])}function v1349(str){var v1726=process.stdout;JAM.call(v1726.write,v1726,[str])}function v1348(){}function v1347(str){var v1727=process.stderr;JAM.call(v1727.write,v1727,[str+"\n"])}function v1346(str){var v1729=process.stderr;JAM.call(v1729.write,
v1729,[str])}function v1345(str){var v1730=process.stdout;JAM.call(v1730.write,v1730,[str+"\n"])}function v1344(str){var v1732=process.stdout;JAM.call(v1732.write,v1732,[str])}function v1343(rootPath,partialFilePath){for(var path=rootPath+"/"+partialFilePath;;)if(JAM.call(_fs.existsSync,_fs,[path]))try{var content=JAM.call(this.readFile,this,[path]);return{content:content,path:path}}catch(err){}else{path=JAM.call(_path.resolve,_path,[rootPath,".."]);if(rootPath===path)return null;rootPath=path;path=
JAM.call(_path.resolve,_path,[rootPath,partialFilePath])}}function v1342(path){return JAM.call(_path.dirname,_path,[path])}function v1341(path){return JAM.call(_path.resolve,_path,[path])}function v1340(path){var v1736=JAM.call(_fs.existsSync,_fs,[path]);v1736&&(v1736=JAM.call(_fs.lstatSync,_fs,[path]).isDirectory());return v1736}function v1339(path){try{JAM.call(this.directoryExists,this,[path])||JAM.call(_fs.mkdirSync,_fs,[path])}catch(e){JAM.call(IOUtils.throwIOError,IOUtils,["Couldn't create directory '"+
path+"'.",e])}}function dir(path,spec,options){function filesInFolder(folder){for(var paths=[],files=JAM.call(_fs.readdirSync,_fs,[folder]),i=0,v1744=i<files.length;v1744;){v1744=folder+"/";introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v12528=files[i];v1744=JAM.call(_fs.statSync,_fs,[v1744+v12528]);(v12528=options.recursive)&&(v12528=v1744.isDirectory());if(v12528){v1744=folder+"/";introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v12528=files[i];paths=paths.concat(filesInFolder(v1744+
v12528))}else{if(v1744=v1744.isFile())if(v1744=!spec,!v1744){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v1744=files[i];v1744=v1744.match(spec)}if(v1744){v1744=folder+"/";introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v12528=files[i];JAM.call(paths.push,paths,[v1744+v12528])}}i+=1;v1744=i<files.length}return paths}options=options||{};return filesInFolder(path)}function v1338(path$$0,useUTF8){function v1337(){JAM.call(_fs.closeSync,_fs,[fd]);fd=null}function v1336(str){JAM.call(_fs.writeSync,
_fs,[fd,str+"\r\n"])}function v1335(str){JAM.call(_fs.writeSync,_fs,[fd,str])}function mkdirRecursiveSync(path){var stats=JAM.call(_fs.statSync,_fs,[path]);stats.isFile()?JAM.call(IOUtils.throwIOError,IOUtils,['"'+path+"\" exists but isn't a directory.",null]):stats.isDirectory()||(mkdirRecursiveSync(JAM.call(_path.dirname,_path,[path])),JAM.call(_fs.mkdirSync,_fs,[path,509]))}mkdirRecursiveSync(JAM.call(_path.dirname,_path,[path$$0]));try{var fd=JAM.call(_fs.openSync,_fs,[path$$0,"w"])}catch(e){JAM.call(IOUtils.throwIOError,
IOUtils,["Couldn't write to file '"+path$$0+"'.",e])}return{Write:v1335,WriteLine:v1336,Close:v1337}}function v1334(path){return JAM.call(_fs.existsSync,_fs,[path])}function v1333(path){try{JAM.call(_fs.unlinkSync,_fs,[path])}catch(e){JAM.call(IOUtils.throwIOError,IOUtils,["Couldn't delete file '"+path+"'.",e])}}function v1332(file){try{var buffer=JAM.call(_fs.readFileSync,_fs,[file]);switch(buffer[0]){case 254:if(255==buffer[1]){for(var i=0,v1755=i+1<buffer.length;v1755;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var temp=
buffer[i];buffer[i]=buffer[i+1];buffer[i+1]=temp;i+=2;v1755=i+1<buffer.length}return JAM.call(buffer.toString,buffer,["ucs2",2])}break;case 255:if(254==buffer[1])return JAM.call(buffer.toString,buffer,["ucs2",2]);break;case 239:if(187==buffer[1])return JAM.call(buffer.toString,buffer,["utf8",3])}return buffer.toString()}catch(e){JAM.call(IOUtils.throwIOError,IOUtils,['Error reading file "'+file+'".',e])}}var _fs=JAM.call(require,null,["fs"]),_path=JAM.call(require,null,["path"]),_module=JAM.call(require,
null,["module"]);return{readFile:v1332,writeFile:_fs.writeFileSync,deleteFile:v1333,fileExists:v1334,createFile:v1338,dir:dir,createDirectory:v1339,directoryExists:v1340,resolvePath:v1341,dirName:v1342,findFile:v1343,print:v1344,printLine:v1345,arguments:process.argv.slice(2),stderr:{Write:v1346,WriteLine:v1347,Close:v1348},stdout:{Write:v1349,WriteLine:v1350,Close:v1351},watchFile:v1354,run:v1355,getExecutingFilePath:v1356,quit:process.exit}}return"function"===typeof ActiveXObject?getWindowsScriptHostIO():
"function"===typeof require?getNodeIO():null}
function v1312(){var IOUtils=v18825;function createDirectoryStructure(ioHost,dirName){if(!JAM.call(ioHost.directoryExists,ioHost,[dirName])){var parentDirectory=JAM.call(ioHost.dirName,ioHost,[dirName]);""!=parentDirectory&&createDirectoryStructure(ioHost,parentDirectory);JAM.call(ioHost.createDirectory,ioHost,[dirName])}}function createFileAndFolderStructure(ioHost,fileName,useUTF8){fileName=JAM.call(ioHost.resolvePath,ioHost,[fileName]);var dirName=JAM.call(ioHost.dirName,ioHost,[fileName]);createDirectoryStructure(ioHost,
dirName);return JAM.call(ioHost.createFile,ioHost,[fileName,useUTF8])}function throwIOError(message,error){var errorMessage=message,v12549=error;v12549&&(v12549=error.message);v12549&&(errorMessage+=" "+error.message);throw Error(errorMessage);}IOUtils.createFileAndFolderStructure=createFileAndFolderStructure;IOUtils.throwIOError=throwIOError}
function v1311(){var TypeScript=v18824;function v1310(){function v1309(s){var v1771=this.logContents;JAM.call(v1771.push,v1771,[s])}function v1308(){return!1}function v1307(){return!1}function v1306(){return!1}function v1305(){return!1}function v1304(){return!1}function BufferedLogger(){this.logContents=[]}BufferedLogger.prototype.information=v1304;BufferedLogger.prototype.debug=v1305;BufferedLogger.prototype.warning=v1306;BufferedLogger.prototype.error=v1307;BufferedLogger.prototype.fatal=v1308;
BufferedLogger.prototype.log=v1309;return BufferedLogger}function v1303(){function v1302(s){var v1778=this.logger;JAM.call(v1778.log,v1778,[s])}function v1301(){return this._fatal}function v1300(){return this._error}function v1299(){return this._warning}function v1298(){return this._debug}function v1297(){return this._information}function LoggerAdapter(logger){this.logger=logger;this._information=logger=this.logger.information();this._debug=logger=this.logger.debug();this._warning=logger=this.logger.warning();
this._error=logger=this.logger.error();this._fatal=logger=this.logger.fatal()}LoggerAdapter.prototype.information=v1297;LoggerAdapter.prototype.debug=v1298;LoggerAdapter.prototype.warning=v1299;LoggerAdapter.prototype.error=v1300;LoggerAdapter.prototype.fatal=v1301;LoggerAdapter.prototype.log=v1302;return LoggerAdapter}function v1296(){function v1295(s){}function v1294(){return!1}function v1293(){return!1}function v1292(){return!1}function v1291(){return!1}function v1290(){return!1}function NullLogger(){}
NullLogger.prototype.information=v1290;NullLogger.prototype.debug=v1291;NullLogger.prototype.warning=v1292;NullLogger.prototype.error=v1293;NullLogger.prototype.fatal=v1294;NullLogger.prototype.log=v1295;return NullLogger}function v1289(CompilerDiagnostics){function Alert(output){if(CompilerDiagnostics.diagnosticWriter){var v1796=CompilerDiagnostics.diagnosticWriter;JAM.call(v1796.Alert,v1796,[output])}}function debugPrint(s){CompilerDiagnostics.debug&&Alert(s)}function assert(condition,s){CompilerDiagnostics.debug&&
(condition||Alert(s))}CompilerDiagnostics.debug=!1;CompilerDiagnostics.diagnosticWriter=null;CompilerDiagnostics.analysisPass=0;CompilerDiagnostics.Alert=Alert;CompilerDiagnostics.debugPrint=debugPrint;CompilerDiagnostics.assert=assert}function timeFunction(logger,funcDescription,func){var start=+new Date;func=func();var end=+new Date;JAM.call(logger.log,logger,[funcDescription+" completed in "+(end-start)+" msec"]);return func}function stringToLiteral(value,length){function addChar(index){var ch=
JAM.call(value.charCodeAt,value,[index]);switch(ch){case 9:result+="\\t";break;case 10:result+="\\n";break;case 11:result+="\\v";break;case 12:result+="\\f";break;case 13:result+="\\r";break;case 34:result+='\\"';break;case 39:result+="\\'";break;case 92:result+="\\";break;default:result+=value.charAt(index)}}var result="",tooLong=value.length>length;if(tooLong){for(var mid=length>>1,tooLong=0,v1805=tooLong<mid;v1805;)addChar(tooLong),tooLong+=1,v1805=tooLong<mid;result+="(...)";tooLong=value.length-
mid;for(mid=tooLong<value.length;mid;)addChar(tooLong),tooLong+=1,mid=tooLong<value.length}else for(length=value.length,tooLong=0,mid=tooLong<length;mid;)addChar(tooLong),tooLong+=1,mid=tooLong<length;return result}var v12556=TypeScript.CompilerDiagnostics;v12556||(v12556=TypeScript.CompilerDiagnostics={});v1289(v12556);v12556=v1296();TypeScript.NullLogger=v12556;v12556=v1303();TypeScript.LoggerAdapter=v12556;v12556=v1310();TypeScript.BufferedLogger=v12556;TypeScript.timeFunction=timeFunction;TypeScript.stringToLiteral=
stringToLiteral}
function v1288(){var TypeScript=v18823;function v1287(){function v1286(enclosingScopeContext,allNames,scope){for(var result=[],enclosingScope=enclosingScopeContext.getScope(),i=0,v1818=i<allNames.length;v1818;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v1818=allNames[i];var v1810=enclosingScopeContext.publicsOnly;v1810&&(v1810=enclosingScopeContext.isMemberCompletion);var publicsOnly=v1810,v1810=JAM.call(scope.find,scope,[v1818,publicsOnly,!1]);null==v1810&&(v1810=JAM.call(scope.find,
scope,[v1818,publicsOnly,!0]));(publicsOnly=v1810)&&(publicsOnly=v1810.flags&TypeScript.SymbolFlags.Private);publicsOnly=publicsOnly?v1810.container==scope.container:!0;v1810?(publicsOnly&&(publicsOnly=!JAM.call(TypeScript.isQuoted,TypeScript,[v1810.name]))&&(publicsOnly=!JAM.call(TypeScript.isRelative,TypeScript,[v1810.name])),publicsOnly&&(publicsOnly=v1810.getType(),publicsOnly=JAM.call(publicsOnly.getScopedTypeName,publicsOnly,[enclosingScope]),JAM.call(result.push,result,[JAM.new(ScopeEntry,
[v1818,publicsOnly,v1810])]))):((v1810="true"==v1818)||(v1810="false"==v1818),v1810&&JAM.call(result.push,result,[JAM.new(ScopeEntry,[v1818,"bool",this.compiler.typeChecker.booleanType.symbol])]));i+=1;v1818=i<allNames.length}return result}function v1285(enclosingScopeContext){var scope=JAM.call(this.getScope,this,[enclosingScopeContext]);if(null==scope)return[];for(var inScopeNames=new TypeScript.StringHashTable,allSymbolNames=JAM.call(scope.getAllSymbolNames,scope,[enclosingScopeContext.isMemberCompletion]),
i=0,v1823=i<allSymbolNames.length;v1823;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v1823=allSymbolNames[i];var v12566=v1823==TypeScript.globalId;v12566||(v12566="_Core"==v1823)||(v12566="_element"==v1823);v12566||JAM.call(inScopeNames.add,inScopeNames,[v1823,""]);i+=1;v1823=i<allSymbolNames.length}allSymbolNames=this.compiler.typeChecker.currentModDecl;this.compiler.typeChecker.currentModDecl=enclosingScopeContext.deepestModuleDecl;enclosingScopeContext=JAM.call(this.getTypeNamesForNames,
this,[enclosingScopeContext,inScopeNames.getAllKeys(),scope]);this.compiler.typeChecker.currentModDecl=allSymbolNames;return enclosingScopeContext}function v1284(enclosingScopeContext){var v12572=enclosingScopeContext.enclosingObjectLit;v12572&&(v12572=enclosingScopeContext.isMemberCompletion);if(v12572)return enclosingScopeContext.getObjectLiteralScope();if(enclosingScopeContext.isMemberCompletion){if(enclosingScopeContext.useFullAst)return v12572=this.compiler.typeFlow,JAM.call(v12572.findMemberScopeAtFullAst,
v12572,[enclosingScopeContext]);v12572=this.compiler.typeFlow;return JAM.call(v12572.findMemberScopeAt,v12572,[enclosingScopeContext])}return enclosingScopeContext.getScope()}function ScopeTraversal(compiler){this.compiler=compiler}ScopeTraversal.prototype.getScope=v1284;ScopeTraversal.prototype.getScopeEntries=v1285;ScopeTraversal.prototype.getTypeNamesForNames=v1286;return ScopeTraversal}function v1283(){function ScopeEntry(name,type,sym){this.name=name;this.type=type;this.sym=sym}return ScopeEntry}
function v1282(){function v1281(fileName,useUTF8){try{var v1836=this.emitSettings.ioHost;return JAM.call(v1836.createFile,v1836,[fileName,useUTF8])}catch(ex){v1836=this.errorReporter,JAM.call(v1836.emitterError,v1836,[null,ex.message])}}function v1280(scripts){for(var i=0,len=scripts.length,v1840=i<len;v1840;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v1840=scripts[i];if(JAM.call(this.outputScriptToUTF8,this,[v1840]))return!0;i+=1;v1840=i<len}return!1}function v1279(script){var v1841=
script.containsUnicodeChar;!v1841&&(v1841=this.emitSettings.emitComments)&&(v1841=script.containsUnicodeCharInComment);return v1841}function v1278(ioHost){function v1277(fileName,wholeFileNameReplaced){return JAM.call(TypeScriptCompiler.mapToFileNameExtension,TypeScriptCompiler,[".txt",fileName,wholeFileNameReplaced])}JAM.call(this.parseEmitOption,this,[ioHost]);var outFile=null,context=null;ioHost=0;for(var len=this.scripts.members.length,v1856=ioHost<len;v1856;){v1856=this.scripts.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v1856=
v1856[ioHost];var v12580=this.emitSettings.outputMany;v12580||(v12580=null==context);if(v12580){outFile=this.units;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)outFile=outFile[ioHost];outFile=outFile.filename;context=v1277;v12580=this.emitSettings;outFile=JAM.call(v12580.mapOutputFileName,v12580,[outFile,context]);outFile=JAM.call(this.createFile,this,[outFile,JAM.call(this.useUTF8ForFile,this,[v1856])]);context=JAM.new(TypeScript.PrintContext,[outFile,this.parser])}v12580=TypeScript.getAstWalkerFactory();
JAM.call(v12580.walk,v12580,[v1856,TypeScript.prePrintAST,TypeScript.postPrintAST,null,context]);if(this.emitSettings.outputMany)try{outFile.Close()}catch(e){v1856=this.errorReporter,JAM.call(v1856.emitterError,v1856,[null,e.message])}ioHost+=1;v1856=ioHost<len}if(!this.emitSettings.outputMany)try{outFile.Close()}catch(e$$0){ioHost=this.errorReporter,JAM.call(ioHost.emitterError,ioHost,[null,e$$0.message])}}function v1276(outputFile){if(this.settings.mapSourceFiles)throw Error("Cannot generate source map");
if(this.settings.generateDeclarationFiles)throw Error("Cannot generate declaration files");if(""!=this.settings.outputOption)throw Error("Cannot parse output option");outputFile=outputFile=JAM.new(TypeScript.Emitter,[this.typeChecker,"stdout",outputFile,this.emitSettings,this.errorReporter]);for(var i=0,len=this.scripts.members.length,v1871=i<len;v1871;){v1871=this.scripts.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v1871=v1871[i];this.typeChecker.locationInfo=v1871.locationInfo;
JAM.call(outputFile.emitJavascript,outputFile,[v1871,TypeScript.TokenID.Comma,!1]);i+=1;v1871=i<len}}function v1275(ioHost){JAM.call(this.parseEmitOption,this,[ioHost]);ioHost=null;for(var i=0,len=this.scripts.members.length,v1876=i<len;v1876;){v1876=this.scripts.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v1876=v1876[i];var v12592=this.emitSettings.outputMany;v12592||(v12592=null==ioHost);v12592?ioHost=JAM.call(this.emitUnit,this,[v1876,!this.emitSettings.outputMany]):
JAM.call(this.emitUnit,this,[v1876,!0,ioHost]);i+=1;v1876=i<len}ioHost&&ioHost.Close()}function v1274(script,reuseEmitter,emitter){if(!JAM.call(script.emitRequired,script,[this.emitSettings]))return null;var fname=script.locationInfo.filename;if(emitter)this.settings.mapSourceFiles&&JAM.call(emitter.setSourceMappings,emitter,[JAM.new(TypeScript.SourceMapper,[fname,emitter.emittingFileName,emitter.outfile,emitter.sourceMapper.sourceMapOut,this.errorReporter])]);else{emitter=this.emitSettings;var outFname=
JAM.call(emitter.mapOutputFileName,emitter,[fname,TypeScriptCompiler.mapToJSFileName]),outFile=JAM.call(this.createFile,this,[outFname,JAM.call(this.useUTF8ForFile,this,[script])]);emitter=JAM.new(TypeScript.Emitter,[this.typeChecker,outFname,outFile,this.emitSettings,this.errorReporter]);this.settings.mapSourceFiles&&JAM.call(emitter.setSourceMappings,emitter,[JAM.new(TypeScript.SourceMapper,[fname,outFname,outFile,JAM.call(this.createFile,this,[outFname+TypeScript.SourceMapper.MapFileExtension,
!1]),this.errorReporter])])}this.typeChecker.locationInfo=script.locationInfo;JAM.call(emitter.emitJavascript,emitter,[script,TypeScript.TokenID.Comma,!1]);if(reuseEmitter)return emitter;emitter.Close();return null}function mapToJSFileName(fileName,wholeFileNameReplaced){return JAM.call(TypeScriptCompiler.mapToFileNameExtension,TypeScriptCompiler,[".js",fileName,wholeFileNameReplaced])}function mapToFileNameExtension(extension,fileName,wholeFileNameReplaced){if(wholeFileNameReplaced)return fileName;
fileName=fileName.split(".");fileName.pop();return fileName.join(".")+extension}function v1273(){if(this.canEmitDeclarations()&&!this.errorReporter.hasErrors&&0!=this.scripts.members.length){for(var declarationEmitter=null,i=0,len=this.scripts.members.length,v1902=i<len;v1902;){v1902=this.scripts.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v1902=v1902[i];var v12611=this.emitSettings.outputMany;v12611||(v12611=null==declarationEmitter);v12611?declarationEmitter=JAM.call(this.emitDeclarationsUnit,
this,[v1902,!this.emitSettings.outputMany]):JAM.call(this.emitDeclarationsUnit,this,[v1902,!0,declarationEmitter]);i+=1;v1902=i<len}declarationEmitter&&declarationEmitter.Close()}}function v1272(script,reuseEmitter,declarationEmitter){if(!JAM.call(this.canEmitDeclarations,this,[script]))return null;if(!declarationEmitter){declarationEmitter=this.emitSettings;declarationEmitter=JAM.call(declarationEmitter.mapOutputFileName,declarationEmitter,[script.locationInfo.filename,TypeScriptCompiler.mapToDTSFileName]);
var declareFile=JAM.call(this.createFile,this,[declarationEmitter,JAM.call(this.useUTF8ForFile,this,[script])]);declarationEmitter=JAM.new(TypeScript.DeclarationEmitter,[this.typeChecker,this.emitSettings,this.errorReporter]);JAM.call(declarationEmitter.setDeclarationFile,declarationEmitter,[declareFile])}JAM.call(declarationEmitter.emitDeclarations,declarationEmitter,[script]);if(reuseEmitter)return declarationEmitter;declarationEmitter.Close();return null}function v1271(script){if(!this.settings.generateDeclarationFiles)return!1;
var v12616=!!script;v12616&&(v12616=script.isDeclareFile,v12616||(v12616=script.isResident)||(v12616=null==script.bod));return v12616?!1:!0}function mapToDTSFileName(fileName,wholeFileNameReplaced){return JAM.call(TypeScript.getDeclareFilePath,TypeScript,[fileName])}function v1270(script){return this.emitSettings.outputMany?JAM.call(this.outputScriptToUTF8,this,[script]):JAM.call(this.outputScriptsToUTF8,this,[this.scripts.members])}function v1269(ioHost){this.emitSettings.ioHost=ioHost;if(""==this.emitSettings.outputOption)this.emitSettings.outputMany=
!0,this.emitSettings.commonDirectoryPath="";else{ioHost=this.emitSettings;var v18927=this.emitSettings.ioHost,v18927=JAM.call(TypeScript.switchToForwardSlashes,TypeScript,[JAM.call(v18927.resolvePath,v18927,[this.emitSettings.outputOption])]);ioHost.outputOption=v18927;ioHost=this.emitSettings.ioHost;JAM.call(ioHost.directoryExists,ioHost,[this.emitSettings.outputOption])?this.emitSettings.outputMany=!0:(ioHost=this.emitSettings.ioHost,JAM.call(ioHost.fileExists,ioHost,[this.emitSettings.outputOption])?
this.emitSettings.outputMany=!1:this.emitSettings.outputMany=!JAM.call(TypeScript.isJSFile,TypeScript,[this.emitSettings.outputOption]));(ioHost=this.isDynamicModuleCompilation())&&(ioHost=!this.emitSettings.outputMany);ioHost&&(ioHost=this.errorReporter,JAM.call(ioHost.emitterError,ioHost,[null,"Cannot compile dynamic modules when emitting into single file"]));this.emitSettings.outputMany&&this.updateCommonDirectoryPath()}}function v1268(){for(var commonComponents=[],commonComponentsLength=-1,i=
0,len=this.scripts.members.length,v1941=i<len;v1941;){v1941=this.scripts.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v1941=v1941[i];if(JAM.call(v1941.emitRequired,v1941,[this.emitSettings]))if(v1941=v1941.locationInfo.filename,v1941=JAM.call(TypeScript.filePathComponents,TypeScript,[v1941]),-1==commonComponentsLength)commonComponents=v1941,commonComponentsLength=commonComponents.length;else{var updatedPath=!1,j=0,v12631=j<commonComponentsLength;for(v12631&&(v12631=j<v1941.length);v12631;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v12631=
commonComponents[j];introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v12633=v1941[j];if(v12631!=v12633){commonComponentsLength=j;updatedPath=!0;if(0==j){commonComponents=this.errorReporter;JAM.call(commonComponents.emitterError,commonComponents,[null,"Cannot find the common subdirectory path for the input files"]);return}break}j+=1;(v12631=j<commonComponentsLength)&&(v12631=j<v1941.length)}(updatedPath=!updatedPath)&&(updatedPath=v1941.length<commonComponentsLength);updatedPath&&
(commonComponentsLength=v1941.length)}i+=1;v1941=i<len}this.emitSettings.commonDirectoryPath=commonComponents.slice(0,commonComponentsLength).join("/")+"/";"/"!=this.emitSettings.outputOption.charAt(this.emitSettings.outputOption.length-1)&&(commonComponents=this.emitSettings,commonComponents.outputOption+="/")}function v1267(){for(var i=0,len=this.scripts.members.length,v1948=i<len;v1948;){v1948=this.scripts.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v1948=v1948[i];var v12640=
!v1948.isDeclareFile;v12640&&(v12640=null!=v1948.topLevelMod);if(v12640)return!0;i+=1;v1948=i<len}return!1}function v1266(){function v1265(){TypeScript.CompilerDiagnostics.analysisPass+=1;JAM.call(_this.initTypeChecker,_this,[_this.errorOutput]);var v1950=_this.persistentTypeState;JAM.call(v1950.setCollectionMode,v1950,[TypeScript.TypeCheckCollectionMode.Transient]);_this.cleanTypesForReTypeCheck();return _this.typeCheck()}var _this=this;return JAM.call(this.timeFunction,this,["reTypeCheck()",v1265])}
function v1264(updateResult){function v1263(){return!1}return JAM.call(this.timeFunction,this,["attemptIncrementalTypeCheck()",v1263])}function v1262(){function v1261(){for(var i=0,len=_this.scripts.members.length,v1956=i<len;v1956;){v1956=_this.scripts.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v1956=v1956[i];if(!v1956.isResident){JAM.call(_this.cleanASTTypesForReTypeCheck,_this,[v1956]);var v1955=_this.typeChecker;JAM.call(v1955.collectTypes,v1955,[v1956])}i+=1;v1956=
i<len}return null}var _this=this;return JAM.call(this.timeFunction,this,["cleanTypesForReTypeCheck()",v1261])}function v1260(ast$$0){function cleanASTType(ast,parent){ast.type=null;if(ast.nodeType==TypeScript.NodeType.VarDecl){var vardecl=ast;vardecl.sym=null}else if(ast.nodeType==TypeScript.NodeType.ArgDecl)vardecl=ast,vardecl.sym=null;else if(ast.nodeType==TypeScript.NodeType.Name)vardecl=ast,vardecl.sym=null;else if(ast.nodeType==TypeScript.NodeType.FuncDecl){vardecl=ast;vardecl.signature=null;
var v1957=vardecl,v26783=[];v1957.freeVariables=v26783;vardecl.symbols=null;vardecl.accessorSymbol=null;vardecl.scopeType=null}else ast.nodeType==TypeScript.NodeType.ModuleDeclaration?(vardecl=ast,vardecl.mod=null):ast.nodeType==TypeScript.NodeType.With?ast.withSym=null:ast.nodeType==TypeScript.NodeType.Catch&&(ast.containedScope=null);return ast}var v1965=TypeScript.getAstWalkerFactory();JAM.call(v1965.walk,v1965,[ast$$0,cleanASTType])}function v1259(){function v1258(){var binder=JAM.new(TypeScript.Binder,
[_this.typeChecker]);_this.typeChecker.units=_this.units;JAM.call(binder.bind,binder,[_this.typeChecker.globalScope,_this.typeChecker.globals]);JAM.call(binder.bind,binder,[_this.typeChecker.globalScope,_this.typeChecker.ambientGlobals]);JAM.call(binder.bind,binder,[_this.typeChecker.globalScope,_this.typeChecker.globalTypes]);JAM.call(binder.bind,binder,[_this.typeChecker.globalScope,_this.typeChecker.ambientGlobalTypes]);var binder=_this,v26784=JAM.new(TypeScript.TypeFlow,[_this.logger,_this.typeChecker.globalScope,
_this.parser,_this.typeChecker]);binder.typeFlow=v26784;var v26784=0,script=null,binder=_this.scripts.members.length,v26784=_this.persistentTypeState;JAM.call(v26784.setCollectionMode,v26784,[TypeScript.TypeCheckCollectionMode.Resident]);v26784=0;for(script=v26784<binder;script;){var script=_this.scripts.members[v26784],v12675=!script.isResident;v12675||(v12675=script.hasBeenTypeChecked);v12675||(v12675=_this.typeFlow,JAM.call(v12675.assignScopes,v12675,[script]),_this.typeFlow.initLibs());v26784+=
1;script=v26784<binder}v26784=0;for(script=v26784<binder;script;)script=_this.scripts.members[v26784],v12675=!script.isResident,v12675||(v12675=script.hasBeenTypeChecked),v12675||(v12675=_this.typeFlow,JAM.call(v12675.typeCheck,v12675,[script]),script.hasBeenTypeChecked=!0),v26784+=1,script=v26784<binder;binder=_this.persistentTypeState;JAM.call(binder.setCollectionMode,binder,[TypeScript.TypeCheckCollectionMode.Transient]);binder=_this.scripts.members.length;v26784=0;for(script=v26784<binder;script;)script=
_this.scripts.members[v26784],script.isResident||(v12675=_this.typeFlow,JAM.call(v12675.assignScopes,v12675,[script]),_this.typeFlow.initLibs()),v26784+=1,script=v26784<binder;v26784=0;for(script=v26784<binder;script;)script=_this.scripts.members[v26784],script.isResident||(v12675=_this.typeFlow,JAM.call(v12675.typeCheck,v12675,[script])),v26784+=1,script=v26784<binder;return null}var _this=this;return JAM.call(this.timeFunction,this,["typeCheck()",v1258])}function v1257(sourceText,filename){var v2002=
this.parser;JAM.call(v2002.setErrorRecovery,v2002,[this.errorOutput]);var v2002=this.parser,v2002=JAM.call(v2002.parse,v2002,[sourceText,filename,0]),index=this.units.length;JAM.set(this.units,index,v2002.locationInfo);index=this.typeChecker;JAM.call(index.collectTypes,index,[v2002]);index=this.scripts;JAM.call(index.append,index,[v2002])}function v1256(prog,filename){return JAM.call(this.parseSourceUnit,this,[JAM.new(TypeScript.StringSourceText,[prog]),filename])}function v1255(sourceText,filename,
keepResident,referencedFiles){function v1254(){var v2010=_this.parser,v2010=JAM.call(v2010.parse,v2010,[sourceText,filename,_this.units.length,TypeScript.AllowedElements.Global]);v2010.referencedFiles=referencedFiles;v2010.isResident=keepResident;var v2013=_this.persistentTypeState,v12685;v12685=keepResident?TypeScript.TypeCheckCollectionMode.Resident:TypeScript.TypeCheckCollectionMode.Transient;JAM.call(v2013.setCollectionMode,v2013,[v12685]);v2013=_this.units.length;JAM.set(_this.units,v2013,v2010.locationInfo);
v2013=_this.typeChecker;JAM.call(v2013.collectTypes,v2013,[v2010]);v2013=_this.scripts;JAM.call(v2013.append,v2013,[v2010]);return v2010}"undefined"===typeof referencedFiles&&(referencedFiles=[]);var _this=this;return JAM.call(this.timeFunction,this,["addSourceUnit("+filename+", "+keepResident+")",v1254])}function v1253(prog,filename,keepResident,referencedFiles){"undefined"===typeof keepResident&&(keepResident=!1);"undefined"===typeof referencedFiles&&(referencedFiles=[]);return JAM.call(this.addSourceUnit,
this,[JAM.new(TypeScript.StringSourceText,[prog]),filename,keepResident,referencedFiles])}function v1252(sourceText,filename,setRecovery){function v1251(){function v1250(minChar,charLen,message,unitIndex){JAM.call(parseErrors.push,parseErrors,[JAM.new(ErrorEntry,[unitIndex,minChar,minChar+charLen,message])])}for(var i=0,len=_this.units.length,v2034=i<len;v2034;){v2034=_this.units;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v2034=v2034[i];if(v2034.filename==filename){len=_this.scripts.members;
introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)len=len[i];if(len.isResident)return JAM.call(UpdateUnitResult.noEdits,UpdateUnitResult,[i]);setRecovery&&(len=_this.parser,JAM.call(len.setErrorRecovery,len,[null]));var parseErrors=[],v2034=v1250;if(len=_this.parser.errorCallback)_this.parser.errorCallback=v2034;v2034=_this.scripts.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v2034=v2034[i];var v2031=_this.parser,i=JAM.call(v2031.parse,v2031,[sourceText,filename,
i]);len&&(_this.parser.errorCallback=len);return i=JAM.call(UpdateUnitResult.unknownEdits,UpdateUnitResult,[v2034,i,parseErrors])}i+=1;v2034=i<len}throw Error('Unknown file "'+filename+'"');}var _this=this;return JAM.call(this.timeFunction,this,["partialUpdateUnit("+filename+")",v1251])}function v1249(updateResult){switch(updateResult.kind){case UpdateUnitKind.NoEdits:return!1;case UpdateUnitKind.Unknown:JAM.set(this.scripts.members,updateResult.unitIndex,updateResult.script2);JAM.set(this.units,
updateResult.unitIndex,updateResult.script2.locationInfo);for(var i=0,len=updateResult.parseErrors.length,v2049=i<len;v2049;){v2049=updateResult.parseErrors;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v2049=v2049[i];if(this.parser.errorCallback){var v2043=this.parser;JAM.call(v2043.errorCallback,v2043,[v2049.minChar,v2049.limChar-v2049.minChar,v2049.message,v2049.unitIndex])}i+=1;v2049=i<len}return!0;case UpdateUnitKind.EditsInsideSingleScope:return i=JAM.new(TypeScript.IncrementalParser,
[this.logger]),JAM.call(i.mergeTrees,i,[updateResult]),!0}}function v1248(sourceText,filename,setRecovery){function v1247(){var updateResult=JAM.call(_this.partialUpdateUnit,_this,[sourceText,filename,setRecovery]);return JAM.call(_this.applyUpdateResult,_this,[updateResult])}var _this=this;return JAM.call(this.timeFunction,this,["updateSourceUnit("+filename+")",v1247])}function v1246(prog,filename,setRecovery){return JAM.call(this.updateSourceUnit,this,[JAM.new(TypeScript.StringSourceText,[prog]),
filename,setRecovery])}function v1245(fn){this.parser.errorCallback=fn}function v1244(){var v26785=JAM.new(TypeScript.EmitOptions,[this.settings]);this.emitSettings=v26785}function v1243(outerr){this.errorOutput=outerr;var v2057=this.errorReporter;JAM.call(v2057.setErrOut,v2057,[outerr]);this.parser.outfile=outerr}function v1242(errorOutput){this.persistentTypeState.refreshPersistentState();this.typeChecker=errorOutput=JAM.new(TypeScript.TypeChecker,[this.persistentTypeState]);this.typeChecker.errorReporter=
this.errorReporter;this.typeChecker.checkControlFlow=this.settings.controlFlow;this.typeChecker.checkControlFlowUseDef=this.settings.controlFlowUseDef;this.typeChecker.printControlFlowGraph=this.settings.printControlFlow;this.typeChecker.errorsOnWith=this.settings.errorOnWith;this.typeChecker.styleSettings=this.settings.styleSettings;this.typeChecker.canCallDefinitionSignature=this.settings.canCallDefinitionSignature;this.errorReporter.checker=this.typeChecker;JAM.call(this.setErrorOutput,this,[this.errorOutput])}
function v1241(funcDescription,func){return JAM.call(TypeScript.timeFunction,TypeScript,[this.logger,funcDescription,func])}function TypeScriptCompiler(errorOutput,logger,settings){"undefined"===typeof logger&&(logger=new TypeScript.NullLogger);"undefined"===typeof settings&&(settings=TypeScript.defaultSettings);this.errorOutput=errorOutput;this.logger=logger;this.settings=settings;this.parser=errorOutput=new TypeScript.Parser;this.typeFlow=null;this.scripts=errorOutput=new TypeScript.ASTList;this.units=
errorOutput=[];this.errorReporter=errorOutput=JAM.new(TypeScript.ErrorReporter,[this.errorOutput]);this.persistentTypeState=errorOutput=JAM.new(TypeScript.PersistentGlobalTypeState,[this.errorReporter]);this.errorReporter.parser=this.parser;JAM.call(this.initTypeChecker,this,[this.errorOutput]);this.parser.style_requireSemi=this.settings.styleSettings.requireSemi;this.parser.style_funcInLoop=this.settings.styleSettings.funcInLoop;this.parser.inferPropertiesFromThisAssignment=this.settings.inferPropertiesFromThisAssignment;
this.emitSettings=errorOutput=JAM.new(TypeScript.EmitOptions,[this.settings]);TypeScript.codeGenTarget=settings.codeGenTarget}TypeScriptCompiler.prototype.timeFunction=v1241;TypeScriptCompiler.prototype.initTypeChecker=v1242;TypeScriptCompiler.prototype.setErrorOutput=v1243;TypeScriptCompiler.prototype.emitCommentsToOutput=v1244;TypeScriptCompiler.prototype.setErrorCallback=v1245;TypeScriptCompiler.prototype.updateUnit=v1246;TypeScriptCompiler.prototype.updateSourceUnit=v1248;TypeScriptCompiler.prototype.applyUpdateResult=
v1249;TypeScriptCompiler.prototype.partialUpdateUnit=v1252;TypeScriptCompiler.prototype.addUnit=v1253;TypeScriptCompiler.prototype.addSourceUnit=v1255;TypeScriptCompiler.prototype.parseUnit=v1256;TypeScriptCompiler.prototype.parseSourceUnit=v1257;TypeScriptCompiler.prototype.typeCheck=v1259;TypeScriptCompiler.prototype.cleanASTTypesForReTypeCheck=v1260;TypeScriptCompiler.prototype.cleanTypesForReTypeCheck=v1262;TypeScriptCompiler.prototype.attemptIncrementalTypeCheck=v1264;TypeScriptCompiler.prototype.reTypeCheck=
v1266;TypeScriptCompiler.prototype.isDynamicModuleCompilation=v1267;TypeScriptCompiler.prototype.updateCommonDirectoryPath=v1268;TypeScriptCompiler.prototype.parseEmitOption=v1269;TypeScriptCompiler.prototype.useUTF8ForFile=v1270;TypeScriptCompiler.mapToDTSFileName=mapToDTSFileName;TypeScriptCompiler.prototype.canEmitDeclarations=v1271;TypeScriptCompiler.prototype.emitDeclarationsUnit=v1272;TypeScriptCompiler.prototype.emitDeclarations=v1273;TypeScriptCompiler.mapToFileNameExtension=mapToFileNameExtension;
TypeScriptCompiler.mapToJSFileName=mapToJSFileName;TypeScriptCompiler.prototype.emitUnit=v1274;TypeScriptCompiler.prototype.emit=v1275;TypeScriptCompiler.prototype.emitToOutfile=v1276;TypeScriptCompiler.prototype.emitAST=v1278;TypeScriptCompiler.prototype.outputScriptToUTF8=v1279;TypeScriptCompiler.prototype.outputScriptsToUTF8=v1280;TypeScriptCompiler.prototype.createFile=v1281;return TypeScriptCompiler}function v1240(){function ErrorEntry(unitIndex,minChar,limChar,message){this.unitIndex=unitIndex;
this.minChar=minChar;this.limChar=limChar;this.message=message}return ErrorEntry}function v1239(){function singleScopeEdits(script1,script2,scope1,scope2,editRange,parseErrors){script1=new UpdateUnitResult(UpdateUnitKind.EditsInsideSingleScope,script1.locationInfo.unitIndex,script1,script2);script1.scope1=scope1;script1.scope2=scope2;script1.editRange=editRange;script1.parseErrors=parseErrors;return script1}function unknownEdits(script1,script2,parseErrors){script1=new UpdateUnitResult(UpdateUnitKind.Unknown,
script1.locationInfo.unitIndex,script1,script2);script1.parseErrors=parseErrors;return script1}function noEdits(unitIndex){return new UpdateUnitResult(UpdateUnitKind.NoEdits,unitIndex,null,null)}function UpdateUnitResult(kind,unitIndex,script1,script2){this.kind=kind;this.unitIndex=unitIndex;this.script1=script1;this.script2=script2;this.editRange=this.scope2=this.scope1=null;this.parseErrors=[]}UpdateUnitResult.noEdits=noEdits;UpdateUnitResult.unknownEdits=unknownEdits;UpdateUnitResult.singleScopeEdits=
singleScopeEdits;return UpdateUnitResult}function v1238(){function v1237(){return"editRange(minChar="+this.minChar+", limChar="+this.limChar+", delta="+this.delta+")"}function v1236(pos){var v12721=this.minChar<=pos;v12721&&(v12721=pos<this.limChar);v12721||(v12721=this.minChar<=pos)&&(v12721=pos<this.limChar+this.delta);return v12721}function v1235(){var v2127=-1===this.minChar;v2127&&(v2127=-1===this.limChar)&&(v2127=-1===this.delta);return v2127}function unknown(){return new ScriptEditRange(-1,
-1,-1)}function ScriptEditRange(minChar,limChar,delta){this.minChar=minChar;this.limChar=limChar;this.delta=delta}ScriptEditRange.unknown=unknown;ScriptEditRange.prototype.isUnknown=v1235;ScriptEditRange.prototype.containsPosition=v1236;ScriptEditRange.prototype.toString=v1237;return ScriptEditRange}function v1234(UpdateUnitKind){UpdateUnitKind._map=[];UpdateUnitKind._map[0]="Unknown";UpdateUnitKind.Unknown=0;UpdateUnitKind._map[1]="NoEdits";UpdateUnitKind.NoEdits=1;UpdateUnitKind._map[2]="EditsInsideSingleScope";
UpdateUnitKind.EditsInsideSingleScope=2}var v12726=TypeScript.UpdateUnitKind;v12726||(v12726=TypeScript.UpdateUnitKind={});v1234(v12726);var UpdateUnitKind=TypeScript.UpdateUnitKind,v12726=v1238();TypeScript.ScriptEditRange=v12726;var UpdateUnitResult=v1239();TypeScript.UpdateUnitResult=UpdateUnitResult;var ErrorEntry=v1240();TypeScript.ErrorEntry=ErrorEntry;var v12726=TypeScript,v26793=new TypeScript.CompilationSettings;v12726.defaultSettings=v26793;v12726=v1282();TypeScript.TypeScriptCompiler=v12726;
var ScopeEntry=v1283();TypeScript.ScopeEntry=ScopeEntry;v12726=v1287();TypeScript.ScopeTraversal=v12726}
function v1233(){var TypeScript=v18822;function v1232(){function v1231(pre,ast){return!JAM.call(TypeScript.hasFlag,TypeScript,[ast.flags,TypeScript.ASTFlags.IsStatement])}function v1230(pre,script){if(pre){if(this.emitOptions.outputMany)for(var i=0,v2144=i<script.referencedFiles.length;v2144;){v2144=script.referencedFiles;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v2144=v2144[i];v2144=v2144.path;if(JAM.call(TypeScript.isRooted,TypeScript,[v2144]))var v2138=this.emitOptions,v2144=
JAM.call(v2138.mapOutputFileName,v2138,[v2144,TypeScript.TypeScriptCompiler.mapToDTSFileName]);else{v2144=script.referencedFiles;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v2144=v2144[i];v2144=JAM.call(TypeScript.getDeclareFilePath,TypeScript,[v2144.path])}v2138=this.declFile;JAM.call(v2138.WriteLine,v2138,['/// <reference path="'+v2144+'" />']);i+=1;v2144=i<script.referencedFiles.length}JAM.call(this.pushDeclarationContainer,this,[script])}else JAM.call(this.popDeclarationContainer,
this,[script]);return!0}function v1229(pre,moduleDecl){if(JAM.call(TypeScript.hasFlag,TypeScript,[moduleDecl.modFlags,TypeScript.ModuleFlags.IsWholeFile])){if(JAM.call(TypeScript.hasFlag,TypeScript,[moduleDecl.modFlags,TypeScript.ModuleFlags.IsDynamic]))if(pre){if(!this.emitOptions.outputMany){this.singleDeclFile=this.declFile;var v2146=TypeScript.CompilerDiagnostics;JAM.call(v2146.assert,v2146,[0==this.indenter.indentAmt,"Indent has to be 0 when outputing new file"]);var v2146=this.emitOptions,v2146=
JAM.call(v2146.mapOutputFileName,v2146,[JAM.call(TypeScript.stripQuotes,TypeScript,[moduleDecl.name.sym.name]),TypeScript.TypeScriptCompiler.mapToDTSFileName]),v2151=moduleDecl.containsUnicodeChar;!v2151&&(v2151=this.emitOptions.emitComments)&&(v2151=moduleDecl.containsUnicodeCharInComment);try{var v12747=this.emitOptions.ioHost,v26794=JAM.new(DeclFileWriter,[JAM.call(v12747.createFile,v12747,[v2146,v2151])]);this.declFile=v26794}catch(ex){v12747=this.errorReporter,JAM.call(v12747.emitterError,v12747,
[null,ex.message])}}JAM.call(this.pushDeclarationContainer,this,[moduleDecl])}else{if(!this.emitOptions.outputMany){v12747=TypeScript.CompilerDiagnostics;JAM.call(v12747.assert,v12747,[this.singleDeclFile!=this.declFile,"singleDeclFile cannot be null as we are going to revert back to it"]);v12747=TypeScript.CompilerDiagnostics;JAM.call(v12747.assert,v12747,[0==this.indenter.indentAmt,"Indent has to be 0 when outputing new file"]);try{this.declFile.Close()}catch(ex$$0){v12747=this.errorReporter,JAM.call(v12747.emitterError,
v12747,[null,ex$$0.message])}this.declFile=this.singleDeclFile}JAM.call(this.popDeclarationContainer,this,[moduleDecl])}return!0}if(moduleDecl.isEnum())return pre&&JAM.call(this.emitEnumSignature,this,[moduleDecl]),!1;if(!JAM.call(this.canEmitPrePostAstSignature,this,[JAM.call(TypeScript.ToDeclFlags,TypeScript,[moduleDecl.modFlags]),moduleDecl,pre]))return!1;pre?(this.emitDottedModuleName()?this.dottedModuleEmit+=".":this.dottedModuleEmit=v12747=JAM.call(this.getDeclFlagsString,this,[JAM.call(TypeScript.ToDeclFlags,
TypeScript,[moduleDecl.modFlags]),"module"]),this.dottedModuleEmit+=moduleDecl.name.text,(v12747=1==moduleDecl.members.members.length)&&(v12747=moduleDecl.members.members[0].nodeType==TypeScript.NodeType.ModuleDeclaration)&&(v12747=!moduleDecl.members.members[0].isEnum())&&(v12747=JAM.call(TypeScript.hasFlag,TypeScript,[moduleDecl.members.members[0].modFlags,TypeScript.ModuleFlags.Exported])),v26794=v12747,v12747=moduleDecl.getDocComments(),v26794&&((v26794=null==v12747)||(v26794=0==v12747.length)),
v12747=this.isDottedModuleName,JAM.call(v12747.push,v12747,[v26794]),JAM.call(this.pushDeclarationContainer,this,[moduleDecl]),v26794||(JAM.call(this.emitDeclarationComments,this,[moduleDecl]),v12747=this.declFile,JAM.call(v12747.Write,v12747,[this.dottedModuleEmit]),v12747=this.declFile,JAM.call(v12747.WriteLine,v12747,[" {"]),this.indenter.increaseIndent())):(this.emitDottedModuleName()||(this.indenter.decreaseIndent(),this.emitIndent(),v12747=this.declFile,JAM.call(v12747.WriteLine,v12747,["}"])),
JAM.call(this.popDeclarationContainer,this,[moduleDecl]),this.isDottedModuleName.pop());return!0}function v1228(moduleDecl){if(!JAM.call(this.canEmitSignature,this,[JAM.call(TypeScript.ToDeclFlags,TypeScript,[moduleDecl.modFlags])]))return!1;JAM.call(this.emitDeclarationComments,this,[moduleDecl]);JAM.call(this.emitDeclFlags,this,[JAM.call(TypeScript.ToDeclFlags,TypeScript,[moduleDecl.modFlags]),"enum"]);var v2184=this.declFile;JAM.call(v2184.WriteLine,v2184,[moduleDecl.name.text+" {"]);this.indenter.increaseIndent();
for(var v2184=moduleDecl.members.members.length,j=1,v2194=j<v2184;v2194;){v2194=moduleDecl.members.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v2194=v2194[j];if(v2194.nodeType==TypeScript.NodeType.VarDecl){JAM.call(this.emitDeclarationComments,this,[v2194]);this.emitIndent();var v2189=this.declFile;JAM.call(v2189.WriteLine,v2189,[v2194.id.text+","])}else v2189=TypeScript.CompilerDiagnostics,JAM.call(v2189.assert,v2189,[v2194.nodeType!=TypeScript.NodeType.Asg,"We want to catch this"]);
j+=1;v2194=j<v2184}this.indenter.decreaseIndent();this.emitIndent();moduleDecl=this.declFile;JAM.call(moduleDecl.WriteLine,moduleDecl,["}"]);return!1}function v1227(pre,importDecl){if(pre){var v12771=this.declarationContainerStack[0];JAM.call(v12771.isExternallyVisibleSymbol,v12771,[importDecl.id.sym])&&(JAM.call(this.emitDeclarationComments,this,[importDecl]),this.emitIndent(),v12771=this.declFile,JAM.call(v12771.Write,v12771,["import "]),v12771=this.declFile,JAM.call(v12771.Write,v12771,[importDecl.id.text+
" = "]),importDecl.isDynamicImport?(v12771=this.declFile,JAM.call(v12771.WriteLine,v12771,["module ("+importDecl.getAliasName()+");"])):(v12771=this.declFile,JAM.call(v12771.WriteLine,v12771,[importDecl.getAliasName()+";"])))}return!1}function v1226(pre,interfaceDecl){if(!JAM.call(this.canEmitPrePostAstSignature,this,[JAM.call(TypeScript.ToDeclFlags,TypeScript,[interfaceDecl.varFlags]),interfaceDecl,pre]))return!1;if(pre){var interfaceName=interfaceDecl.name.text;JAM.call(this.emitDeclarationComments,
this,[interfaceDecl]);JAM.call(this.emitDeclFlags,this,[JAM.call(TypeScript.ToDeclFlags,TypeScript,[interfaceDecl.varFlags]),"interface"]);var v2209=this.declFile;JAM.call(v2209.Write,v2209,[interfaceName]);JAM.call(this.emitBaseList,this,[interfaceDecl.extendsList,"extends"]);interfaceName=this.declFile;JAM.call(interfaceName.WriteLine,interfaceName,[" {"]);this.indenter.increaseIndent();JAM.call(this.pushDeclarationContainer,this,[interfaceDecl])}else this.indenter.decreaseIndent(),JAM.call(this.popDeclarationContainer,
this,[interfaceDecl]),this.emitIndent(),interfaceName=this.declFile,JAM.call(interfaceName.WriteLine,interfaceName,["}"]);return!0}function v1225(pre,classDecl){if(!JAM.call(this.canEmitPrePostAstSignature,this,[JAM.call(TypeScript.ToDeclFlags,TypeScript,[classDecl.varFlags]),classDecl,pre]))return!1;if(pre){var className=classDecl.name.text;JAM.call(this.emitDeclarationComments,this,[classDecl]);JAM.call(this.emitDeclFlags,this,[JAM.call(TypeScript.ToDeclFlags,TypeScript,[classDecl.varFlags]),"class"]);
var v2218=this.declFile;JAM.call(v2218.Write,v2218,[className]);JAM.call(this.emitBaseList,this,[classDecl.extendsList,"extends"]);JAM.call(this.emitBaseList,this,[classDecl.implementsList,"implements"]);className=this.declFile;JAM.call(className.WriteLine,className,[" {"]);JAM.call(this.pushDeclarationContainer,this,[classDecl]);this.indenter.increaseIndent();classDecl.constructorDecl&&JAM.call(this.emitClassMembersFromConstructorDefinition,this,[classDecl.constructorDecl])}else this.indenter.decreaseIndent(),
JAM.call(this.popDeclarationContainer,this,[classDecl]),this.emitIndent(),className=this.declFile,JAM.call(className.WriteLine,className,["}"]);return!0}function v1224(funcDecl){if(funcDecl.arguments){var argsLen=funcDecl.arguments.members.length;funcDecl.variableArgList&&(argsLen-=1);for(var i=0,v2238=i<argsLen;v2238;){v2238=funcDecl.arguments.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v2238=v2238[i];if(JAM.call(TypeScript.hasFlag,TypeScript,[v2238.varFlags,TypeScript.VarFlags.Property])){JAM.call(this.emitDeclarationComments,
this,[v2238]);JAM.call(this.emitDeclFlags,this,[JAM.call(TypeScript.ToDeclFlags,TypeScript,[v2238.varFlags]),"var"]);var v2231=this.declFile;JAM.call(v2231.Write,v2231,[v2238.id.text]);(v2231=v2238.typeExpr)&&(v2231=JAM.call(this.canEmitTypeAnnotationSignature,this,[JAM.call(TypeScript.ToDeclFlags,TypeScript,[v2238.varFlags])]));v2231&&(v2231=this.declFile,JAM.call(v2231.Write,v2231,[": "]),JAM.call(this.emitTypeSignature,this,[v2238.type]));v2238=this.declFile;JAM.call(v2238.WriteLine,v2238,[";"])}i+=
1;v2238=i<argsLen}}}function v1223(funcDecl){var accessorSymbol=funcDecl.accessorSymbol,v12787=accessorSymbol.getter;v12787&&(v12787=accessorSymbol.getter.declAST!=funcDecl);if(v12787)return!1;JAM.call(this.emitDeclarationComments,this,[accessorSymbol]);JAM.call(this.emitDeclFlags,this,[JAM.call(TypeScript.ToDeclFlags,TypeScript,[accessorSymbol.flags]),"var"]);v12787=this.declFile;JAM.call(v12787.Write,v12787,[funcDecl.name.text]);funcDecl=accessorSymbol.getType();JAM.call(this.canEmitTypeAnnotationSignature,
this,[JAM.call(TypeScript.ToDeclFlags,TypeScript,[accessorSymbol.flags])])&&(accessorSymbol=this.declFile,JAM.call(accessorSymbol.Write,accessorSymbol,[" : "]),JAM.call(this.emitTypeSignature,this,[funcDecl]));accessorSymbol=this.declFile;JAM.call(accessorSymbol.WriteLine,accessorSymbol,[";"]);return!1}function v1222(bases,qual){var v12791=bases;v12791&&(v12791=0<bases.members.length);if(v12791){v12791=this.declFile;JAM.call(v12791.Write,v12791,[" "+qual+" "]);for(var v12791=bases.members.length,
i=0,v2254=i<v12791;v2254;){v2254=bases.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v2254=v2254[i];v2254=v2254.type;if(0<i){var v2252=this.declFile;JAM.call(v2252.Write,v2252,[", "])}JAM.call(this.emitTypeSignature,this,[v2254]);i+=1;v2254=i<v12791}}}function v1221(pre,funcDecl){if(!pre)return!1;if(funcDecl.isAccessor())return JAM.call(this.emitPropertyAccessorSignature,this,[funcDecl]);var isInterfaceMember=this.getAstDeclarationContainer().nodeType==TypeScript.NodeType.InterfaceDeclaration;
if(funcDecl.bod){if(funcDecl.isConstructor){var v12795=funcDecl.type.construct;v12795&&(v12795=1<funcDecl.type.construct.signatures.length)}else(v12795=funcDecl.type.call)&&(v12795=1<funcDecl.type.call.signatures.length);if(v12795)return!1}else if((v12795=!isInterfaceMember)&&(v12795=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.Private]))&&(v12795=funcDecl.type.call)&&(v12795=1<funcDecl.type.call.signatures.length),v12795){var v12795=funcDecl.type.call.signatures,
firstSignature=v12795[0].declAST;firstSignature.bod&&(firstSignature=v12795[1].declAST);if(firstSignature!=funcDecl)return!1}if(!JAM.call(this.canEmitSignature,this,[JAM.call(TypeScript.ToDeclFlags,TypeScript,[funcDecl.fncFlags]),!1]))return!1;JAM.call(this.emitDeclarationComments,this,[funcDecl]);funcDecl.isConstructor?(this.emitIndent(),isInterfaceMember=this.declFile,JAM.call(isInterfaceMember.Write,isInterfaceMember,["constructor"])):(v12795=funcDecl.getNameText(),isInterfaceMember?(this.emitIndent(),
funcDecl.isConstructMember()?(isInterfaceMember=this.declFile,JAM.call(isInterfaceMember.Write,isInterfaceMember,["new"])):((isInterfaceMember=!funcDecl.isCallMember())&&(isInterfaceMember=!funcDecl.isIndexerMember()),isInterfaceMember&&(isInterfaceMember=this.declFile,JAM.call(isInterfaceMember.Write,isInterfaceMember,[v12795]),JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.name.flags,TypeScript.ASTFlags.OptionalName])&&(isInterfaceMember=this.declFile,JAM.call(isInterfaceMember.Write,isInterfaceMember,
["? "]))))):(JAM.call(this.emitDeclFlags,this,[JAM.call(TypeScript.ToDeclFlags,TypeScript,[funcDecl.fncFlags]),"function"]),isInterfaceMember=this.declFile,JAM.call(isInterfaceMember.Write,isInterfaceMember,[v12795])));funcDecl.isIndexerMember()?(isInterfaceMember=this.declFile,JAM.call(isInterfaceMember.Write,isInterfaceMember,["["])):(isInterfaceMember=this.declFile,JAM.call(isInterfaceMember.Write,isInterfaceMember,["("]));this.indenter.increaseIndent();if(funcDecl.arguments)for(isInterfaceMember=
funcDecl.arguments.members.length,funcDecl.variableArgList&&(isInterfaceMember-=1),v12795=0,firstSignature=v12795<isInterfaceMember;firstSignature;){firstSignature=funcDecl.arguments.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)firstSignature=firstSignature[v12795];JAM.call(this.emitArgDecl,this,[firstSignature,funcDecl]);v12795<isInterfaceMember-1&&(firstSignature=this.declFile,JAM.call(firstSignature.Write,firstSignature,[", "]));v12795+=1;firstSignature=v12795<isInterfaceMember}if(funcDecl.variableArgList){isInterfaceMember=
funcDecl.arguments.members;v12795=funcDecl.arguments.members.length-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)isInterfaceMember=isInterfaceMember[v12795];1<funcDecl.arguments.members.length?(v12795=this.declFile,JAM.call(v12795.Write,v12795,[", ..."])):(v12795=this.declFile,JAM.call(v12795.Write,v12795,["..."]));JAM.call(this.emitArgDecl,this,[isInterfaceMember,funcDecl])}this.indenter.decreaseIndent();funcDecl.isIndexerMember()?(isInterfaceMember=this.declFile,JAM.call(isInterfaceMember.Write,
isInterfaceMember,["]"])):(isInterfaceMember=this.declFile,JAM.call(isInterfaceMember.Write,isInterfaceMember,[")"]));if(isInterfaceMember=!funcDecl.isConstructor)(isInterfaceMember=funcDecl.returnTypeAnnotation)||(isInterfaceMember=funcDecl.signature.returnType.type!=this.checker.anyType),isInterfaceMember&&(isInterfaceMember=JAM.call(this.canEmitTypeAnnotationSignature,this,[JAM.call(TypeScript.ToDeclFlags,TypeScript,[funcDecl.fncFlags])]));isInterfaceMember&&(isInterfaceMember=this.declFile,JAM.call(isInterfaceMember.Write,
isInterfaceMember,[": "]),JAM.call(this.emitTypeSignature,this,[funcDecl.signature.returnType.type]));isInterfaceMember=this.declFile;JAM.call(isInterfaceMember.WriteLine,isInterfaceMember,[";"]);return!1}function v1220(argDecl,funcDecl){JAM.call(this.emitDeclarationComments,this,[argDecl,!1]);var v2307=this.declFile;JAM.call(v2307.Write,v2307,[argDecl.id.text]);argDecl.isOptionalArg()&&(v2307=this.declFile,JAM.call(v2307.Write,v2307,["?"]));(v2307=argDecl.typeExpr)||(v2307=argDecl.type!=this.checker.anyType);
v2307&&(v2307=JAM.call(this.canEmitTypeAnnotationSignature,this,[JAM.call(TypeScript.ToDeclFlags,TypeScript,[funcDecl.fncFlags])]));v2307&&(v2307=this.declFile,JAM.call(v2307.Write,v2307,[": "]),JAM.call(this.emitTypeSignature,this,[argDecl.type]))}function v1219(pre,block){return block.isStatementBlock?!1:(this.varListCount=pre?block.statements.members.length:0,!0)}function v1218(pre,varDecl){var v12818=pre;v12818&&(v12818=JAM.call(this.canEmitSignature,this,[JAM.call(TypeScript.ToDeclFlags,TypeScript,
[varDecl.varFlags]),!1]));if(v12818){v12818=this.getAstDeclarationContainer().nodeType==TypeScript.NodeType.InterfaceDeclaration;JAM.call(this.emitDeclarationComments,this,[varDecl]);v12818?(this.emitIndent(),v12818=this.declFile,JAM.call(v12818.Write,v12818,[varDecl.id.text]),JAM.call(TypeScript.hasFlag,TypeScript,[varDecl.id.flags,TypeScript.ASTFlags.OptionalName])&&(v12818=this.declFile,JAM.call(v12818.Write,v12818,["?"]))):(0<=this.varListCount&&(JAM.call(this.emitDeclFlags,this,[JAM.call(TypeScript.ToDeclFlags,
TypeScript,[varDecl.varFlags]),"var"]),this.varListCount=-this.varListCount),v12818=this.declFile,JAM.call(v12818.Write,v12818,[varDecl.id.text]));var v12818=null,v12827=varDecl.typeExpr;v12827&&(v12827=varDecl.typeExpr.type);v12827?v12818=varDecl.typeExpr.type:varDecl.sym&&(v12818=varDecl.sym.getType(),v12818==this.checker.anyType&&(v12818=null));(v12827=v12818)&&(v12827=JAM.call(this.canEmitTypeAnnotationSignature,this,[JAM.call(TypeScript.ToDeclFlags,TypeScript,[varDecl.varFlags])]));v12827&&(v12827=
this.declFile,JAM.call(v12827.Write,v12827,[": "]),JAM.call(this.emitTypeSignature,this,[v12818]));0<this.varListCount?this.varListCount-=1:0>this.varListCount&&(this.varListCount+=1);0>this.varListCount?(v12818=this.declFile,JAM.call(v12818.Write,v12818,[", "])):(v12818=this.declFile,JAM.call(v12818.WriteLine,v12818,[";"]))}return!1}function v1217(astOrSymbol,endLine){"undefined"===typeof endLine&&(endLine=!0);if(this.emitOptions.emitComments){var declComments=astOrSymbol.getDocComments();if(0<declComments.length){for(var i=
0,v2344=i<declComments.length;v2344;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v2344=declComments[i];JAM.call(this.emitComment,this,[v2344]);i+=1;v2344=i<declComments.length}endLine?this.declFile.onNewLine||(declComments=this.declFile,JAM.call(declComments.WriteLine,declComments,[""])):this.declFile.onNewLine&&this.emitIndent()}}}function v1216(comment){var text=comment.getText();if(this.declFile.onNewLine)this.emitIndent();else if(!comment.isBlockComment){var v2349=this.declFile;
JAM.call(v2349.WriteLine,v2349,[""]);this.emitIndent()}v2349=this.declFile;JAM.call(v2349.Write,v2349,[text[0]]);for(var v2349=1,v2357=v2349<text.length;v2357;){v2357=this.declFile;JAM.call(v2357.WriteLine,v2357,[""]);this.emitIndent();v2357=this.declFile;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v2356=text[v2349];JAM.call(v2357.Write,v2357,[v2356]);v2349+=1;v2357=v2349<text.length}(text=comment.endsLine)||(text=!comment.isBlockComment);text?(comment=this.declFile,JAM.call(comment.WriteLine,
comment,[""])):(comment=this.declFile,JAM.call(comment.Write,comment,[" "]))}function v1215(type){var containingScope=null,declarationContainerAst=this.getAstDeclarationContainer();switch(declarationContainerAst.nodeType){case TypeScript.NodeType.ModuleDeclaration:case TypeScript.NodeType.InterfaceDeclaration:case TypeScript.NodeType.FuncDecl:declarationContainerAst.type&&(containingScope=declarationContainerAst.type.containedScope);break;case TypeScript.NodeType.Script:declarationContainerAst.bod&&
(containingScope=declarationContainerAst.bod.enclosingScope);break;case TypeScript.NodeType.ClassDeclaration:declarationContainerAst.type&&(containingScope=declarationContainerAst.type.instanceType.containedScope);break;default:declarationContainerAst=TypeScript.CompilerDiagnostics,JAM.call(declarationContainerAst.debugPrint,declarationContainerAst,["Unknown containing scope"])}type=JAM.call(type.getScopedTypeNameEx,type,[containingScope]);JAM.call(this.emitTypeNamesMember,this,[type])}function v1214(memberName,
emitIndent){"undefined"===typeof emitIndent&&(emitIndent=!1);if("{ "==memberName.prefix){emitIndent&&this.emitIndent();var v2370=this.declFile;JAM.call(v2370.WriteLine,v2370,["{"]);this.indenter.increaseIndent();emitIndent=!0}else""!=memberName.prefix&&(emitIndent&&this.emitIndent(),v2370=this.declFile,JAM.call(v2370.Write,v2370,[memberName.prefix]),emitIndent=!1);if(memberName.isString())emitIndent&&this.emitIndent(),v2370=this.declFile,JAM.call(v2370.Write,v2370,[memberName.text]);else for(var v2370=
memberName,index=0,v2381=index<v2370.entries.length;v2381;){v2381=v2370.entries;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v2381=v2381[index];JAM.call(this.emitTypeNamesMember,this,[v2381,emitIndent]);"; "==v2370.delim&&(v2381=this.declFile,JAM.call(v2381.WriteLine,v2381,[";"]));index+=1;v2381=index<v2370.entries.length}"}"==memberName.suffix&&(this.indenter.decreaseIndent(),this.emitIndent());v2370=this.declFile;JAM.call(v2370.Write,v2370,[memberName.suffix])}function v1213(ast){var v2389=
TypeScript.CompilerDiagnostics;JAM.call(v2389.assert,v2389,[ast!=this.getAstDeclarationContainer(),"Declaration container mismatch"]);this.declarationContainerStack.pop()}function v1212(ast){var v2392=this.declarationContainerStack;JAM.call(v2392.push,v2392,[ast])}function v1211(declFlag){"undefined"===typeof declFlag&&(declFlag=TypeScript.DeclFlags.None);return!JAM.call(TypeScript.hasFlag,TypeScript,[declFlag,TypeScript.DeclFlags.Private])}function v1210(declFlags,typeString){var v2396=this.declFile;
JAM.call(v2396.Write,v2396,[JAM.call(this.getDeclFlagsString,this,[declFlags,typeString])])}function v1209(declFlags,typeString){var result=this.getIndentString(),accessorString="";JAM.call(TypeScript.hasFlag,TypeScript,[declFlags,TypeScript.DeclFlags.GetAccessor])?accessorString="get ":JAM.call(TypeScript.hasFlag,TypeScript,[declFlags,TypeScript.DeclFlags.SetAccessor])&&(accessorString="set ");var container=this.getAstDeclarationContainer(),v12862=container.nodeType==TypeScript.NodeType.ModuleDeclaration;
v12862&&((container=JAM.call(TypeScript.hasFlag,TypeScript,[container.modFlags,TypeScript.ModuleFlags.IsWholeFile]))&&(container=JAM.call(TypeScript.hasFlag,TypeScript,[declFlags,TypeScript.DeclFlags.Exported])),v12862=container);v12862&&(result+="export ");(container=JAM.call(TypeScript.hasFlag,TypeScript,[declFlags,TypeScript.DeclFlags.LocalStatic]))||(container=JAM.call(TypeScript.hasFlag,TypeScript,[declFlags,TypeScript.DeclFlags.Static]));return result=container?result+("static "+accessorString):
JAM.call(TypeScript.hasFlag,TypeScript,[declFlags,TypeScript.DeclFlags.Private])?result+("private "+accessorString):JAM.call(TypeScript.hasFlag,TypeScript,[declFlags,TypeScript.DeclFlags.Public])?result+("public "+accessorString):""==accessorString?result+(typeString+" "):result+accessorString}function v1208(declFlags,astWithPrePostCallback,preCallback){if(this.ignoreCallbackAst)return declFlags=TypeScript.CompilerDiagnostics,JAM.call(declFlags.assert,declFlags,[this.ignoreCallbackAst!=astWithPrePostCallback,
"Ignore Callback AST mismatch"]),this.ignoreCallbackAst=null,!1;var v12871=preCallback;v12871&&(v12871=!JAM.call(this.canEmitSignature,this,[declFlags,!0,preCallback]));return v12871?(this.ignoreCallbackAst=astWithPrePostCallback,!1):!0}function v1207(declFlags,canEmitGlobalAmbientDecl,useDeclarationContainerTop){"undefined"===typeof canEmitGlobalAmbientDecl&&(canEmitGlobalAmbientDecl=!0);"undefined"===typeof useDeclarationContainerTop&&(useDeclarationContainerTop=!0);useDeclarationContainerTop=useDeclarationContainerTop?
this.getAstDeclarationContainer():this.declarationContainerStack[this.declarationContainerStack.length-2];var v12875=useDeclarationContainerTop.nodeType==TypeScript.NodeType.ModuleDeclaration;v12875&&(v12875=!JAM.call(TypeScript.hasFlag,TypeScript,[declFlags,TypeScript.DeclFlags.Exported]));if(v12875)return!1;(canEmitGlobalAmbientDecl=!canEmitGlobalAmbientDecl)&&(canEmitGlobalAmbientDecl=useDeclarationContainerTop.nodeType==TypeScript.NodeType.Script)&&(canEmitGlobalAmbientDecl=JAM.call(TypeScript.hasFlag,
TypeScript,[declFlags,TypeScript.DeclFlags.Ambient]));return canEmitGlobalAmbientDecl?!1:!0}function v1206(){var v2415=this.declFile;JAM.call(v2415.Write,v2415,[this.getIndentString()])}function v1205(declIndent){return this.emitOptions.minWhitespace?"":this.indenter.getIndent()}function v1204(script){var v2420=TypeScript.AstWalkerWithDetailCallback;JAM.call(v2420.walk,v2420,[script,this])}function v1203(){try{this.declFile.Close()}catch(ex){var v2422=this.errorReporter;JAM.call(v2422.emitterError,
v2422,[null,ex.message])}}function v1202(file){this.declFile=file=JAM.new(DeclFileWriter,[file])}function v1201(){var v2424;return v2424=0==this.isDottedModuleName.length?!1:this.isDottedModuleName[this.isDottedModuleName.length-1]}function v1200(){var v2425=this.declarationContainerStack,v2426=this.declarationContainerStack.length-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v2425[v2426]}function DeclarationEmitter(checker,emitOptions,errorReporter){this.checker=checker;
this.emitOptions=emitOptions;this.errorReporter=errorReporter;this.declFile=null;this.indenter=checker=new TypeScript.Indenter;this.declarationContainerStack=[];this.isDottedModuleName=[];this.singleDeclFile=this.ignoreCallbackAst=null;this.varListCount=0}DeclarationEmitter.prototype.getAstDeclarationContainer=v1200;DeclarationEmitter.prototype.emitDottedModuleName=v1201;DeclarationEmitter.prototype.setDeclarationFile=v1202;DeclarationEmitter.prototype.Close=v1203;DeclarationEmitter.prototype.emitDeclarations=
v1204;DeclarationEmitter.prototype.getIndentString=v1205;DeclarationEmitter.prototype.emitIndent=v1206;DeclarationEmitter.prototype.canEmitSignature=v1207;DeclarationEmitter.prototype.canEmitPrePostAstSignature=v1208;DeclarationEmitter.prototype.getDeclFlagsString=v1209;DeclarationEmitter.prototype.emitDeclFlags=v1210;DeclarationEmitter.prototype.canEmitTypeAnnotationSignature=v1211;DeclarationEmitter.prototype.pushDeclarationContainer=v1212;DeclarationEmitter.prototype.popDeclarationContainer=v1213;
DeclarationEmitter.prototype.emitTypeNamesMember=v1214;DeclarationEmitter.prototype.emitTypeSignature=v1215;DeclarationEmitter.prototype.emitComment=v1216;DeclarationEmitter.prototype.emitDeclarationComments=v1217;DeclarationEmitter.prototype.VarDeclCallback=v1218;DeclarationEmitter.prototype.BlockCallback=v1219;DeclarationEmitter.prototype.emitArgDecl=v1220;DeclarationEmitter.prototype.FuncDeclCallback=v1221;DeclarationEmitter.prototype.emitBaseList=v1222;DeclarationEmitter.prototype.emitPropertyAccessorSignature=
v1223;DeclarationEmitter.prototype.emitClassMembersFromConstructorDefinition=v1224;DeclarationEmitter.prototype.ClassDeclarationCallback=v1225;DeclarationEmitter.prototype.InterfaceDeclarationCallback=v1226;DeclarationEmitter.prototype.ImportDeclarationCallback=v1227;DeclarationEmitter.prototype.emitEnumSignature=v1228;DeclarationEmitter.prototype.ModuleDeclarationCallback=v1229;DeclarationEmitter.prototype.ScriptCallback=v1230;DeclarationEmitter.prototype.DefaultCallback=v1231;return DeclarationEmitter}
function v1199(){function v1198(){this.declFile.Close()}function v1197(s){var v2461=this.declFile;JAM.call(v2461.WriteLine,v2461,[s]);this.onNewLine=!0}function v1196(s){var v2462=this.declFile;JAM.call(v2462.Write,v2462,[s]);this.onNewLine=!1}function DeclFileWriter(declFile){this.declFile=declFile;this.onNewLine=!0}DeclFileWriter.prototype.Write=v1196;DeclFileWriter.prototype.WriteLine=v1197;DeclFileWriter.prototype.Close=v1198;return DeclFileWriter}var DeclFileWriter=v1199();TypeScript.DeclFileWriter=
DeclFileWriter;var DeclarationEmitter=v1232();TypeScript.DeclarationEmitter=DeclarationEmitter}
function v1195(){var TypeScript=v18821;function v1194(){function v1193(ast$$0,start,delta){function pre(cur,parent,walker){(parent=-1!==cur.limChar)&&(parent=cur.limChar<start);parent&&(walker.options.goChildren=!1);applyDelta(cur);applyDeltaToComments(cur.preComments);applyDeltaToComments(cur.postComments);return cur}function applyDeltaToComments(comments){var v12884=comments;v12884&&(v12884=0<comments.length);if(v12884)for(var v12884=0,v2471=v12884<comments.length;v2471;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v2471=
comments[v12884];applyDelta(v2471);v12884+=1;v2471=v12884<comments.length}}function applyDelta(ast){var v12887=-1!==ast.minChar;v12887&&(v12887=ast.minChar>=start);v12887&&(ast.minChar+=delta);(v12887=-1!==ast.limChar)&&(v12887=ast.limChar>=start);v12887&&(ast.limChar+=delta)}var v2475=TypeScript.getAstWalkerFactory();JAM.call(v2475.walk,v2475,[ast$$0,pre])}function v1192(script,partial,editRange){script=script.locationInfo.lineMap;partial=partial.locationInfo.lineMap;if(this.logger.information()){var v2478=
this.logger;JAM.call(v2478.log,v2478,["lineMap1 (before):"]);v2478=this.astLogger;JAM.call(v2478.logLinemap,v2478,[script]);v2478=this.logger;JAM.call(v2478.log,v2478,["lineMap2 (quick parse):"]);v2478=this.astLogger;JAM.call(v2478.logLinemap,v2478,[partial]);v2478=this.logger;JAM.call(v2478.log,v2478,["EditRange="+editRange])}for(var i1=2,v2478=2,len1=script.length,len2=partial.length,v2489=i1<len1;v2489;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v2489=script[i1];if(v2489<=
editRange.minChar)i1+=1;else{introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v2489=script[i1];if(v2489>=editRange.limChar){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v2489=script[i1];script[i1]=v2489+editRange.delta;i1+=1}else if(v2478<len2){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v2489=partial[v2478];script.splice(i1,0,v2489+editRange.minChar);i1+=1;len1+=1;v2478+=1}else script.splice(i1,1),len1-=1}v2489=i1<len1}if(v2478<len2){i1=len1-
1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)i1=script[i1];introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v2489=partial[v2478];if(i1>=v2489+editRange.minChar)for(i1=2,(v2489=i1<len1)&&(v2489=v2478<len2);v2489;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v2489=script[i1];introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v19068=partial[v2478];if(v2489<v19068+editRange.minChar)i1+=1;else{introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v2489=
partial[v2478];script.splice(i1,0,v2489+editRange.minChar);i1+=1;len1+=1;v2478+=1}(v2489=i1<len1)&&(v2489=v2478<len2)}for(len1=v2478<len2;len1;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)len1=partial[v2478];JAM.call(script.push,script,[len1+editRange.minChar]);v2478+=1;len1=v2478<len2}}this.logger.information()&&(editRange=this.logger,JAM.call(editRange.log,editRange,["lineMap1 (after merge):"]),editRange=this.astLogger,JAM.call(editRange.logLinemap,editRange,[script]))}function v1191(script,
oldAst,newAst){function pre(cur,parent,walker){if(cur===oldAst)return newAst.preComments=cur.preComments,newAst.postComments=cur.postComments,cur=_this.logger,JAM.call(cur.log,cur,["replaced old AST node with new one in script AST"]),walker.options.stopWalk(),newAst;JAM.call(TypeScript.isValidAstNode,TypeScript,[cur])&&((parent=cur.limChar<oldAst.minChar)||(parent=cur.minChar>oldAst.limChar),parent&&(walker.options.goChildren=!1));return cur}var _this=this,v2506=TypeScript.getAstWalkerFactory();JAM.call(v2506.walk,
v2506,[script,pre])}function v1190(updateResult){function v1189(){var editRange=JAM.new(TypeScript.ScriptEditRange,[updateResult.scope1.minChar,updateResult.scope1.limChar,updateResult.editRange.delta]);JAM.call(_this.applyDeltaPosition,_this,[updateResult.script1,editRange.limChar,editRange.delta]);JAM.call(_this.applyDeltaPosition,_this,[updateResult.script2,0,editRange.minChar]);JAM.call(_this.mergeLocationInfo,_this,[updateResult.script1,updateResult.script2,editRange]);JAM.call(_this.replaceAST,
_this,[updateResult.script1,updateResult.scope1,updateResult.scope2])}var _this=this;JAM.call(TypeScript.timeFunction,TypeScript,[this.logger,"mergeTrees()",v1189])}function v1188(previousScript,scriptId,newSourceText,editRange){function errorCapture(minChar,charLen,message,unitIndex){JAM.call(parseErrors.push,parseErrors,[JAM.new(TypeScript.ErrorEntry,[unitIndex,minChar,minChar+charLen,message])])}var v2523=this.logger;JAM.call(v2523.log,v2523,['attemptIncrementalUpdateUnit("'+scriptId+'")']);if(null===
editRange)throw Error("editRange should be valid");v2523=JAM.call(this.getEnclosingScopeContextIfSingleScopeEdit,this,[previousScript,scriptId,newSourceText,editRange]);if(null===v2523)return null;scriptId=v2523.scopeStartAST.limChar-v2523.scopeStartAST.minChar+editRange.delta;if(scriptId>=newSourceText.getLength()/2)return previousScript=this.logger,JAM.call(previousScript.log,previousScript,["  Bailing out because range of scope to reparse ("+scriptId+" characters) is greater than half the size of the source text"]),
null;var parseErrors=[];newSourceText=JAM.call(TypeScript.quickParse,TypeScript,[this.logger,v2523.scopeStartAST,newSourceText,v2523.scopeStartAST.minChar,v2523.scopeStartAST.minChar+scriptId,errorCapture]);if(newSourceText.endLexState!=TypeScript.LexState.Start)return previousScript=this.logger,JAM.call(previousScript.log,previousScript,["  Bailing out because scope contains unterminated comment"]),null;newSourceText=newSourceText.Script;if(0!==newSourceText.vars.members.length)return previousScript=
this.logger,JAM.call(previousScript.log,previousScript,["  Bailing out because new source text defines variables"]),null;if(1!==newSourceText.bod.members.length)return previousScript=this.logger,JAM.call(previousScript.log,previousScript,["  Bailing out because new source text defines more than one scope (or none)"]),null;var v2523=v2523.scopeStartAST,newScope=newSourceText.bod.members[0];if(v2523.nodeType!=newScope.nodeType)return previousScript=this.logger,JAM.call(previousScript.log,previousScript,
["  Bailing out because new source text does not define the same scope type as the existing scope"]),null;var v12932=!v2523.leftCurlyCount;v12932||(v12932=!v2523.rightCurlyCount);if(v12932)return previousScript=this.logger,JAM.call(previousScript.log,previousScript,["  Bailing out because sopce doesn't have left/right curly count"]),null;if(v2523.leftCurlyCount!==newScope.leftCurlyCount)return previousScript=this.logger,JAM.call(previousScript.log,previousScript,["  Bailing out because new source text contains more (or fewer) left curly braces"]),
null;if(v2523.rightCurlyCount!==newScope.rightCurlyCount)return previousScript=this.logger,JAM.call(previousScript.log,previousScript,["  Bailing out because new source text contains more (or fewer) right curly braces"]),null;if(0!==newScope.minChar)return previousScript=this.logger,JAM.call(previousScript.log,previousScript,["  Bailing out because new function declaration does not start at position 0"]),null;if(newScope.limChar!==scriptId)return previousScript=this.logger,JAM.call(previousScript.log,
previousScript,["  Bailing out because new function declaration does not end at the new end position"]),null;scriptId=TypeScript.UpdateUnitResult;return JAM.call(scriptId.singleScopeEdits,scriptId,[previousScript,newSourceText,v2523,newScope,editRange,parseErrors])}function v1187(previousScript,scriptId,newSourceText,editRange){var v2556=this.logger;JAM.call(v2556.log,v2556,['checkEditsInsideSingleScope("'+scriptId+'")']);if(null===editRange)throw Error("editRange should be valid");if(editRange.isUnknown())return editRange=
this.logger,JAM.call(editRange.log,editRange,["  Bailing out because edit range is unknown"]),null;scriptId=JAM.call(TypeScript.findEnclosingScopeAt,TypeScript,[this.logger,previousScript,newSourceText,editRange.minChar,!1]);previousScript=JAM.call(TypeScript.findEnclosingScopeAt,TypeScript,[this.logger,previousScript,newSourceText,editRange.limChar,!1]);(newSourceText=null==scriptId)||(newSourceText=null==previousScript);if(newSourceText)return editRange=this.logger,JAM.call(editRange.log,editRange,
["  Bailing out because containing scopes cannot be determined"]),null;if(scriptId.scopeStartAST!==previousScript.scopeStartAST)return editRange=this.logger,JAM.call(editRange.log,editRange,["  Bailing out because edit overlaps 2 disctint scopes"]),null;editRange=scriptId.scopeStartAST.limChar-scriptId.scopeStartAST.minChar+editRange.delta;return 0>=editRange?(editRange=this.logger,JAM.call(editRange.log,editRange,["  Bailing out because scope has been entirely removed from new source text"]),null):
scriptId}function IncrementalParser(logger){this.logger=logger;this.astLogger=logger=JAM.new(TypeScript.AstLogger,[this.logger])}IncrementalParser.prototype.getEnclosingScopeContextIfSingleScopeEdit=v1187;IncrementalParser.prototype.attemptIncrementalUpdateUnit=v1188;IncrementalParser.prototype.mergeTrees=v1190;IncrementalParser.prototype.replaceAST=v1191;IncrementalParser.prototype.mergeLocationInfo=v1192;IncrementalParser.prototype.applyDeltaPosition=v1193;return IncrementalParser}var IncrementalParser=
v1194();TypeScript.IncrementalParser=IncrementalParser}
function v1186(){var TypeScript=v18820;function v1185(){function v1184(str){var v2581=this.styleSettings;JAM.call(v2581.parseOptions,v2581,[str])}function CompilationSettings(){var v26799=new StyleSettings;this.styleSettings=v26799;this.exec=this.watch=this.emitComments=this.errorRecovery=this.parseOnly=this.minWhitespace=this.propagateConstants=!1;this.resolve=!0;this.controlFlowUseDef=this.printControlFlow=this.controlFlow=!1;this.preprocess=this.errorOnWith=!0;this.inferPropertiesFromThisAssignment=
this.canCallDefinitionSignature=!1;this.useDefaultLib=!0;this.codeGenTarget=TypeScript.CodeGenTarget.ES3;this.moduleGenTarget=TypeScript.ModuleGenTarget.Synchronous;this.outputOption="";this.useCaseSensitiveFileResolution=this.generateDeclarationFiles=this.mapSourceFiles=!1}CompilationSettings.prototype.setStyleOptions=v1184;return CompilationSettings}function v1183(){function v1182(str){str=str.split(";");for(var i=0,len=str.length,v2589=i<len;v2589;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v2589=
str[i];var val=!0,colonIndex=v2589.lastIndexOf(":");if(0<=colonIndex){var valStr=JAM.call(v2589.substring,v2589,[colonIndex+1]),v2589=JAM.call(v2589.substring,v2589,[0,colonIndex]);"off"==valStr&&(val=!1)}if(!JAM.call(this.setOption,this,[v2589,val]))return!1;i+=1;v2589=i<len}return!0}function v1181(opt,val){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var optExists=this[opt];return void 0!==optExists?(JAM.set(this,opt,val),!0):!1}function StyleSettings(){this.forin=this.eqeqeq=
this.blockInCompoundStmt=this.bitwise=!1;this.emptyBlocks=!0;this.eqnull=this.assignmentInCond=this.requireSemi=this.newMustBeUsed=!1;this.literalSubscript=this.reDeclareLocal=this.funcInLoop=this.innerScopeDeclEscape=this.evalOK=!0;this.implicitAny=!1}StyleSettings.prototype.setOption=v1181;StyleSettings.prototype.parseOptions=v1182;return StyleSettings}function getAdditionalDependencyPath(comment){var amdDependencyRegEx=/^(\/\/\/\s*<amd-dependency\s+path=)('|")(.+?)\2\s*(static=('|")(.+?)\2\s*)*\/>/igm;
return(comment=JAM.call(amdDependencyRegEx.exec,amdDependencyRegEx,[comment]))?comment=comment[3]:null}function getImplicitImport(comment){var implicitImportRegEx=/^(\/\/\/\s*<implicit-import\s*)*\/>/igm;return(comment=JAM.call(implicitImportRegEx.exec,implicitImportRegEx,[comment]))?!0:!1}function getStyleSettings(comment,styleSettings){var styleRegEx=/^(\/\/\/\s*<style\s+)(([a-zA-Z])+=('|").+('|"))\s*\/>/igm;if(styleRegEx=JAM.call(styleRegEx.exec,styleRegEx,[comment])){var settingsRegEx=/^([a-zA-Z]+=['"]on['|"])/igm;
if(styleRegEx=JAM.call(settingsRegEx.exec,settingsRegEx,[styleRegEx[2]]))for(var settingsRegEx=0,v2610=settingsRegEx<styleRegEx.length;v2610;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v2610=styleRegEx[settingsRegEx];var v2610=v2610.split("="),on='"on"';switch(v2610[0]){case "blockInCompoundStmt":styleSettings.blockInCompoundStmt=v2610[1]==on;break;case "eqeqeq":styleSettings.eqeqeq=v2610[1]==on;break;case "forin":styleSettings.forin=v2610[1]==on;break;case "emptyBlocks":styleSettings.emptyBlocks=
v2610[1]==on;break;case "newMustBeUsed":styleSettings.newMustBeUsed=v2610[1]==on;break;case "requireSemi":styleSettings.requireSemi=v2610[1]==on;break;case "assignmentInCond":styleSettings.assignmentInCond=v2610[1]==on;break;case "eqnull":styleSettings.eqnull=v2610[1]==on;break;case "evalOK":styleSettings.evalOK=v2610[1]==on;break;case "innerScopeDeclEscape":styleSettings.innerScopeDeclEscape=v2610[1]==on;break;case "funcInLoop":styleSettings.funcInLoop=v2610[1]==on;break;case "reDeclareLocal":styleSettings.reDeclareLocal=
v2610[1]==on;break;case "literalSubscript":styleSettings.literalSubscript=v2610[1]==on;break;case "implicitAny":styleSettings.implicitAny=v2610[1]==on}settingsRegEx+=1;v2610=settingsRegEx<styleRegEx.length}}}function getReferencedFiles(sourceText){sourceText=preProcessFile(sourceText,null,!1);return sourceText.referencedFiles}function preProcessFile(sourceText,options,readImportFiles){"undefined"===typeof options&&(options=new CompilationSettings);"undefined"===typeof readImportFiles&&(readImportFiles=
!0);var scanner=new TypeScript.Scanner;scanner.resetComments();JAM.call(scanner.setSourceText,scanner,[sourceText,TypeScript.LexMode.File]);var tok=scanner.scan(),comments=[],comment=null,comments=[];sourceText=[];for(var importedFiles=[],isLibFile=!1,comment=tok.tokenId!=TypeScript.TokenID.EndOfFile;comment;)(comment=readImportFiles)&&(comment=tok.tokenId==TypeScript.TokenID.Import),comment&&(tok=scanner.scan(),(comment=tok.tokenId==TypeScript.TokenID.Identifier)||(comment=JAM.call(TypeScript.convertTokToID,
TypeScript,[tok,!1])),comment&&(tok=scanner.scan(),tok.tokenId==TypeScript.TokenID.Equals&&(tok=scanner.scan(),tok.tokenId==TypeScript.TokenID.Module&&(tok=scanner.scan(),tok.tokenId==TypeScript.TokenID.OpenParen&&(tok=scanner.scan(),tok.tokenId==TypeScript.TokenID.StringLiteral&&(comment={minChar:scanner.startPos,limChar:scanner.pos,path:JAM.call(TypeScript.stripQuotes,TypeScript,[JAM.call(TypeScript.switchToForwardSlashes,TypeScript,[tok.getText()])]),isResident:!1},JAM.call(importedFiles.push,
importedFiles,[comment]))))))),tok.tokenId==TypeScript.TokenID.OpenBrace&&JAM.call(comments.push,comments,[tok]),tok.tokenId==TypeScript.TokenID.CloseBrace&&comments.pop(),tok=scanner.scan(),comment=tok.tokenId!=TypeScript.TokenID.EndOfFile;comments=scanner.getComments();readImportFiles=0;for(comment=readImportFiles<comments.length;comment;){comment=comments[readImportFiles];if(!comment.isBlock){JSCompiler_inline_label_getFileReferenceFromReferencePath_29:{var scanner=comment.getText(),tok=/^(\/\/\/\s*<reference\s+path=)('|")(.+?)\2\s*(static=('|")(.+?)\2\s*)*\/>/igm,
match=JAM.call(tok.exec,tok,[scanner]);if(match){var scanner=JAM.call(TypeScript.normalizePath,TypeScript,[match[3]]),tok=JAM.call(TypeScript.normalizePath,TypeScript,[scanner]),v2628=7<=match.length;v2628&&(v2628="true"==match[6]);if(match=v2628)v2628=TypeScript.CompilerDiagnostics,JAM.call(v2628.debugPrint,v2628,[scanner+" is resident"]);scanner={minChar:0,limChar:0,path:JAM.call(TypeScript.switchToForwardSlashes,TypeScript,[tok]),isResident:match}}else scanner=null}scanner&&(scanner.minChar=comment.startPos,
scanner.limChar=scanner.minChar+comment.value.length,JAM.call(sourceText.push,sourceText,[scanner]));options&&(getStyleSettings(comment.getText(),options.styleSettings),scanner=/^(\/\/\/\s*<reference\s+no-default-lib=)('|")(.+?)\2\s*\/>/igm,(comment=JAM.call(scanner.exec,scanner,[comment.getText()]))&&(isLibFile="true"==comment[3]))}readImportFiles+=1;comment=readImportFiles<comments.length}return{settings:options,referencedFiles:sourceText,importedFiles:importedFiles,isLibFile:isLibFile}}var StyleSettings=
v1183();TypeScript.StyleSettings=StyleSettings;var CompilationSettings=v1185();TypeScript.CompilationSettings=CompilationSettings;TypeScript.getAdditionalDependencyPath=getAdditionalDependencyPath;TypeScript.getImplicitImport=getImplicitImport;TypeScript.getStyleSettings=getStyleSettings;TypeScript.getReferencedFiles=getReferencedFiles;TypeScript.preProcessFile=preProcessFile}
function v1180(){var TypeScript=v18819;function v1179(){function v1178(referencePath,parentPath,performSearch,resolutionDispatcher){var resolvedFile={content:"",path:referencePath},ioHost=this.environment.ioHost,isRelativePath=JAM.call(TypeScript.isRelative,TypeScript,[referencePath]),v2641,isRootedPath=v2641=isRelativePath?!1:JAM.call(TypeScript.isRooted,TypeScript,[referencePath]);isRelativePath?v2641=JAM.call(ioHost.resolvePath,ioHost,[parentPath+"/"+referencePath]):(v2641=isRootedPath,v2641||
(v2641=!parentPath)||(v2641=performSearch),v2641=v2641?referencePath:parentPath+"/"+referencePath);var v12978=!JAM.call(TypeScript.isSTRFile,TypeScript,[v2641]);v12978&&(v12978=!JAM.call(TypeScript.isTSFile,TypeScript,[v2641]));v12978&&(v2641+=".ts");v2641=JAM.call(TypeScript.switchToForwardSlashes,TypeScript,[JAM.call(TypeScript.stripQuotes,TypeScript,[v2641])]);var v12978=this.environment.compilationSettings.useCaseSensitiveFileResolution?v2641:v2641.toLocaleUpperCase(),v19108=this.visited;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v19108=
v19108[v12978];if(!v19108){isRelativePath||(isRelativePath=isRootedPath)||(isRelativePath=!performSearch);if(isRelativePath)try{var v2646=TypeScript.CompilerDiagnostics;JAM.call(v2646.debugPrint,v2646,["   Reading code from "+v2641]);try{parentPath=resolvedFile;var v26800=JAM.call(ioHost.readFile,ioHost,[v2641]);parentPath.content=v26800}catch(err){try{JAM.call(TypeScript.isSTRFile,TypeScript,[v2641])?v2641=JAM.call(TypeScript.changePathToTS,TypeScript,[v2641]):JAM.call(TypeScript.isTSFile,TypeScript,
[v2641])&&(v2641=JAM.call(TypeScript.changePathToSTR,TypeScript,[v2641]));var v2651=TypeScript.CompilerDiagnostics;JAM.call(v2651.debugPrint,v2651,["   Reading code from "+v2641]);var v26800=resolvedFile,v26801=JAM.call(ioHost.readFile,ioHost,[v2641]);v26800.content=v26801}catch(err$$0){v2641=JAM.call(TypeScript.changePathToDSTR,TypeScript,[v2641]);var v2654=TypeScript.CompilerDiagnostics;JAM.call(v2654.debugPrint,v2654,["   Reading code from "+v2641]);try{var v26801=resolvedFile,v26802=JAM.call(ioHost.readFile,
ioHost,[v2641]);v26801.content=v26802}catch(err$$1){v2641=JAM.call(TypeScript.changePathToDTS,TypeScript,[v2641]);var v2657=TypeScript.CompilerDiagnostics;JAM.call(v2657.debugPrint,v2657,["   Reading code from "+v2641]);var v26802=resolvedFile,v26803=JAM.call(ioHost.readFile,ioHost,[v2641]);v26802.content=v26803}}}var v2660=TypeScript.CompilerDiagnostics;JAM.call(v2660.debugPrint,v2660,["   Found code at "+v2641]);resolvedFile.path=v2641;JAM.set(this.visited,v12978,!0)}catch(err$$2){v2641=TypeScript.CompilerDiagnostics,
JAM.call(v2641.debugPrint,v2641,["   Did not find code for "+referencePath])}else resolvedFile=JAM.call(ioHost.findFile,ioHost,[parentPath,v2641]),resolvedFile||(JAM.call(TypeScript.isSTRFile,TypeScript,[v2641])?v2641=JAM.call(TypeScript.changePathToTS,TypeScript,[v2641]):JAM.call(TypeScript.isTSFile,TypeScript,[v2641])&&(v2641=JAM.call(TypeScript.changePathToSTR,TypeScript,[v2641])),resolvedFile=JAM.call(ioHost.findFile,ioHost,[parentPath,v2641])),resolvedFile||(v2641=JAM.call(TypeScript.changePathToDTS,
TypeScript,[v2641]),resolvedFile=JAM.call(ioHost.findFile,ioHost,[parentPath,v2641]),resolvedFile||(v2641=JAM.call(TypeScript.changePathToDSTR,TypeScript,[v2641]),resolvedFile=JAM.call(ioHost.findFile,ioHost,[parentPath,v2641]))),resolvedFile?(v2641=resolvedFile,v26803=JAM.call(TypeScript.switchToForwardSlashes,TypeScript,[JAM.call(TypeScript.stripQuotes,TypeScript,[resolvedFile.path])]),v2641.path=v26803,v2641=TypeScript.CompilerDiagnostics,JAM.call(v2641.debugPrint,v2641,[referencePath+" resolved to: "+
resolvedFile.path]),resolvedFile.content=resolvedFile.content,JAM.set(this.visited,v12978,!0)):(v2641=TypeScript.CompilerDiagnostics,JAM.call(v2641.debugPrint,v2641,["Could not find "+referencePath]));if(v2641=resolvedFile)v2641=resolvedFile.content;if(v2641){v26803=JAM.call(ioHost.dirName,ioHost,[resolvedFile.path]);resolvedFile=JAM.new(SourceUnit,[resolvedFile.path,resolvedFile.content]);v2660=JAM.call(TypeScript.preProcessFile,TypeScript,[resolvedFile,this.environment.compilationSettings]);resolvedFile.referencedFiles=
v2660.referencedFiles;v26802=0;for(v2641=v26802<v2660.referencedFiles.length;v2641;){v2641=v2660.referencedFiles;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v2657=v2641[v26802];v2641=JAM.call(TypeScript.isRooted,TypeScript,[v2657.path])?v2657.path:v26803+"/"+v2657.path;v2641=JAM.call(ioHost.resolvePath,ioHost,[v2641]);referencePath==v2641?JAM.call(resolutionDispatcher.postResolutionError,resolutionDispatcher,[v2641,"File contains reference to itself",null]):JAM.call(this.resolveCode,
this,[v2657.path,v26803,!1,resolutionDispatcher]);v26802+=1;v2641=v26802<v2660.referencedFiles.length}v26802=0;for(referencePath=v26802<v2660.importedFiles.length;referencePath;){referencePath=v2660.importedFiles;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)referencePath=referencePath[v26802];JAM.call(this.resolveCode,this,[referencePath.path,v26803,!0,resolutionDispatcher]);v26802+=1;referencePath=v26802<v2660.importedFiles.length}JAM.call(resolutionDispatcher.postResolution,resolutionDispatcher,
[resolvedFile.path,resolvedFile])}}}function CodeResolver(environment){this.environment=environment;this.visited={}}CodeResolver.prototype.resolveCode=v1178;return CodeResolver}function v1177(){function CompilationEnvironment(compilationSettings,ioHost){this.compilationSettings=compilationSettings;this.ioHost=ioHost;this.residentCode=[];this.code=[]}return CompilationEnvironment}function v1176(){function v1175(){return this.content.length}function v1174(start,end){var v2693=this.content;return JAM.call(v2693.substring,
v2693,[start,end])}function SourceUnit(path,content){this.path=path;this.content=content;this.referencedFiles=null}SourceUnit.prototype.getText=v1174;SourceUnit.prototype.getLength=v1175;return SourceUnit}var SourceUnit=v1176();TypeScript.SourceUnit=SourceUnit;var CompilationEnvironment=v1177();TypeScript.CompilationEnvironment=CompilationEnvironment;CompilationEnvironment=v1179();TypeScript.CodeResolver=CompilationEnvironment}
function v1173(){var TypeScript=v18818;function stripQuotes(str){return str.replace('"',"").replace("'","").replace("'","").replace('"',"")}function isQuoted(str){var v2697=-1!=str.indexOf('"');v2697||(v2697=-1!=str.indexOf("'"),v2697||(v2697=-1!=str.indexOf("'"))||(v2697=-1!=str.indexOf('"')));return v2697}function quoteStr(str){return'"'+str+'"'}function swapQuotes(str){-1!=str.indexOf('"')?(str=str.replace('"',"'"),str=str.replace('"',"'")):(str=str.replace("'",'"'),str=str.replace("'",'"'));return str}
function switchToForwardSlashes(path){return path.replace(/\\/g,"/")}function trimModName(modName){var v13001=6<modName.length;v13001&&(v13001=".d.str"==JAM.call(modName.substring,modName,[modName.length-6,modName.length]));if(v13001)return JAM.call(modName.substring,modName,[0,modName.length-6]);(v13001=4<modName.length)&&(v13001=".str"==JAM.call(modName.substring,modName,[modName.length-4,modName.length]));if(v13001)return JAM.call(modName.substring,modName,[0,modName.length-4]);(v13001=5<modName.length)&&
(v13001=".d.ts"==JAM.call(modName.substring,modName,[modName.length-5,modName.length]));if(v13001)return JAM.call(modName.substring,modName,[0,modName.length-5]);(v13001=3<modName.length)&&(v13001=".ts"==JAM.call(modName.substring,modName,[modName.length-3,modName.length]));if(v13001)return JAM.call(modName.substring,modName,[0,modName.length-3]);(v13001=3<modName.length)&&(v13001=".js"==JAM.call(modName.substring,modName,[modName.length-3,modName.length]));return v13001?JAM.call(modName.substring,
modName,[0,modName.length-3]):modName}function getDeclareFilePath(fname){isSTRFile(fname)?fname=changePathToDSTR(fname):(isTSFile(fname),fname=changePathToDTS(fname));return fname}function isFileOfExtension(fname,ext){var invariantFname=fname.toLocaleUpperCase(),invariantExt=ext.toLocaleUpperCase(),extLength=invariantExt.length,v2711=invariantFname.length>extLength;v2711&&(v2711=JAM.call(invariantFname.substring,invariantFname,[invariantFname.length-extLength,invariantFname.length])==invariantExt);
return v2711}function isJSFile(fname){return isFileOfExtension(fname,".js")}function isSTRFile(fname){return isFileOfExtension(fname,".str")}function isTSFile(fname){return isFileOfExtension(fname,".ts")}function isDSTRFile(fname){return isFileOfExtension(fname,".d.str")}function isDTSFile(fname){return isFileOfExtension(fname,".d.ts")}function getPrettyName(modPath,quote,treatAsFileName){"undefined"===typeof quote&&(quote=!0);"undefined"===typeof treatAsFileName&&(treatAsFileName=!1);treatAsFileName=
treatAsFileName?switchToForwardSlashes(modPath):trimModName(stripQuotes(modPath));treatAsFileName=JAM.call(this.getPathComponents,this,[treatAsFileName]);if(treatAsFileName.length)if(quote){modPath=treatAsFileName.length-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)modPath=treatAsFileName[modPath];modPath=quoteStr(modPath)}else modPath=treatAsFileName[treatAsFileName.length-1];return modPath}function getPathComponents(path){return path.split("/")}function getRelativePathToFixedPath(fixedModFilePath,
absoluteModPath){absoluteModPath=switchToForwardSlashes(absoluteModPath);var modComponents=JAM.call(this.getPathComponents,this,[absoluteModPath]),fixedModComponents=JAM.call(this.getPathComponents,this,[fixedModFilePath]),joinStartIndex=0,v13020=joinStartIndex<modComponents.length;for(v13020&&(v13020=joinStartIndex<fixedModComponents.length);v13020;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v13020=fixedModComponents[joinStartIndex];introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v13022=
modComponents[joinStartIndex];if(v13020!=v13022)break;joinStartIndex+=1;(v13020=joinStartIndex<modComponents.length)&&(v13020=joinStartIndex<fixedModComponents.length)}if(0!=joinStartIndex){v13020="";modComponents=modComponents.slice(joinStartIndex,modComponents.length);for(v13022=joinStartIndex<fixedModComponents.length;v13022;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v13022=fixedModComponents[joinStartIndex];""!=v13022&&(v13020+="../");joinStartIndex+=1;v13022=joinStartIndex<
fixedModComponents.length}return v13020+modComponents.join("/")}return absoluteModPath}function quoteBaseName(modPath){var modName=trimModName(stripQuotes(modPath)),path=getRootFilePath(modName);if(""==path)return modPath;modPath=modName.split(path);modName=1<modPath.length?1:0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)modPath=modPath[modName];return quoteStr(modPath)}function changePathToSTR(modPath){return trimModName(stripQuotes(modPath))+".str"}function changePathToDSTR(modPath){return trimModName(stripQuotes(modPath))+
".d.str"}function changePathToTS(modPath){return trimModName(stripQuotes(modPath))+".ts"}function changePathToDTS(modPath){return trimModName(stripQuotes(modPath))+".d.ts"}function isRelative(path){return"."==path.charAt(0)}function isRooted(path){var v2733="\\"==path.charAt(0);v2733||(v2733="/"==path.charAt(0),v2733||(v2733=-1!=path.indexOf(":\\"))||(v2733=-1!=path.indexOf(":/")));return v2733}function getRootFilePath(outFname){if(""==outFname)return outFname;var isPath=-1!=outFname.indexOf("/");
return outFname=isPath?filePath(outFname):""}function filePathComponents(fullPath){fullPath=switchToForwardSlashes(fullPath);fullPath=getPathComponents(fullPath);return fullPath.slice(0,fullPath.length-1)}function filePath(fullPath){fullPath=filePathComponents(fullPath);return fullPath.join("/")+"/"}function normalizeURL(url){var hostDomainAndPortRegex=/^(https?:\/\/[\-\w\.]+(:\d+)?\/)(.*)$/i;return(hostDomainAndPortRegex=JAM.call(hostDomainAndPortRegex.exec,hostDomainAndPortRegex,[url]))?(url=hostDomainAndPortRegex[1],
hostDomainAndPortRegex=hostDomainAndPortRegex[3],url+normalizePath(hostDomainAndPortRegex)):normalizePath(url)}function normalizePath(path){path=switchToForwardSlashes(path);var startedWithSep="/"===path.charAt(0);path=JAM.call(this.getPathComponents,this,[path]);for(var i=0,v2745=i<path.length;v2745;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v2745=path[i];v2745="."===v2745;if(!v2745){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v2745=path[i];v2745=""===v2745}v2745&&
(path.splice(i,1),i-=1);if(v2745=0<i){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v2745=path[i];if(v2745=".."===v2745){v2745=i-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v2745=path[v2745];v2745=".."!==v2745}}v2745&&(path.splice(i-1,2),i-=2);i+=1;v2745=i<path.length}startedWithSep=startedWithSep?"/":"";return startedWithSep+path.join("/")}function normalizeImportPath(path){return normalizePath(path)}TypeScript.stripQuotes=stripQuotes;TypeScript.isQuoted=isQuoted;
TypeScript.quoteStr=quoteStr;TypeScript.swapQuotes=swapQuotes;TypeScript.switchToForwardSlashes=switchToForwardSlashes;TypeScript.trimModName=trimModName;TypeScript.getDeclareFilePath=getDeclareFilePath;TypeScript.isJSFile=isJSFile;TypeScript.isSTRFile=isSTRFile;TypeScript.isTSFile=isTSFile;TypeScript.isDSTRFile=isDSTRFile;TypeScript.isDTSFile=isDTSFile;TypeScript.getPrettyName=getPrettyName;TypeScript.getPathComponents=getPathComponents;TypeScript.getRelativePathToFixedPath=getRelativePathToFixedPath;
TypeScript.quoteBaseName=quoteBaseName;TypeScript.changePathToSTR=changePathToSTR;TypeScript.changePathToDSTR=changePathToDSTR;TypeScript.changePathToTS=changePathToTS;TypeScript.changePathToDTS=changePathToDTS;TypeScript.isRelative=isRelative;TypeScript.isRooted=isRooted;TypeScript.getRootFilePath=getRootFilePath;TypeScript.filePathComponents=filePathComponents;TypeScript.filePath=filePath;TypeScript.normalizeURL=normalizeURL;TypeScript.pathNormalizeRegExp=/\//g;TypeScript.normalizePath=normalizePath;
TypeScript.normalizeImportPath=normalizeImportPath}
function v1172(){var TypeScript=v18817;function v1171(){function TypeLink(){this.ast=this.type=null}return TypeLink}function v1170(_super){function v1169(moduleType){var moduleName=null,moduleName=JAM.call(ModuleType.findDynamicModuleNameInHashTable,ModuleType,[moduleType,this.members.allMembers]);null==moduleName&&(moduleName=JAM.call(ModuleType.findDynamicModuleNameInHashTable,ModuleType,[moduleType,this.ambientMembers.allMembers]));return moduleName}function findDynamicModuleNameInHashTable(moduleType,
members){function v1168(key,s,c){(c=null==moduleName)&&(c=!JAM.call(TypeScript.isQuoted,TypeScript,[key]));c&&(c=s.getType(),c==moduleType&&(moduleName={name:key,symbol:s}))}var moduleName=null;JAM.call(members.map,members,[v1168,null]);return moduleName}function v1167(){return null}function v1166(){return null}function v1165(){return this.ambientEnclosedTypes}function v1164(){return this.enclosedTypes}function v1163(){var v2753=null!=this.members;v2753||(v2753=null!=this.enclosedTypes);return v2753}
function v1162(){return!0}function ModuleType(enclosedTypes,ambientEnclosedTypes){JAM.call(_super.call,_super,[this]);this.enclosedTypes=enclosedTypes;this.ambientEnclosedTypes=ambientEnclosedTypes;this.importedModules=[]}JAM.call(__extends,null,[ModuleType,_super]);ModuleType.prototype.isModuleType=v1162;ModuleType.prototype.hasMembers=v1163;ModuleType.prototype.getAllEnclosedTypes=v1164;ModuleType.prototype.getAllAmbientEnclosedTypes=v1165;ModuleType.prototype.getPublicEnclosedTypes=v1166;ModuleType.prototype.getpublicAmbientEnclosedTypes=
v1167;ModuleType.findDynamicModuleNameInHashTable=findDynamicModuleNameInHashTable;ModuleType.prototype.findDynamicModuleName=v1169;return ModuleType}function v1161(){function v1160(){var v13047=this.elementType;v13047||(v13047=!this.symbol);if(v13047)return[];(v13047=this.isClassInstance())||(v13047=this.isClass());if(v13047)return this.symbol.declAST.nodeType==TypeScript.NodeType.FuncDecl?this.symbol.declAST.classDecl.getDocComments():this.symbol.getDocComments();if(v13047=this.symbol.name)if(v13047=
"_anonymous"!=this.symbol.name)(v13047=null==this.call)&&(v13047=null==this.construct)&&(v13047=null==this.index),v13047||(v13047=this.members);return v13047?this.symbol.getDocComments():[]}function v1159(){return null}function v1158(){return null}function v1157(){return null}function v1156(){return null}function v1155(){return null!=this.members}function v1154(){return!1}function v1153(b,checker,acceptVoid,comparisonInfo){var v13053=this==checker.anyType;v13053||(v13053=b==checker.anyType);if(v13053)return checker.anyType;
if(this==b)return this;(v13053=b==checker.nullType)&&(v13053=this!=checker.nullType);if(v13053)return this;(v13053=this==checker.nullType)&&(v13053=b!=checker.nullType);if(v13053)return b;(v13053=acceptVoid)&&(v13053=b==checker.voidType)&&(v13053=this!=checker.voidType);if(v13053)return this;(v13053=acceptVoid)&&(v13053=this==checker.voidType)&&(v13053=b!=checker.voidType);if(v13053)return b;(v13053=b==checker.undefinedType)&&(v13053=this!=checker.undefinedType);if(v13053)return this;(v13053=this==
checker.undefinedType)&&(v13053=b!=checker.undefinedType);if(v13053)return b;if(v13053=this.elementType)v13053=b.elementType;if(v13053){if(this.elementType==b.elementType)return this;v13053=this.elementType;b=JAM.call(v13053.mergeOrdered,v13053,[b.elementType,checker,acceptVoid,comparisonInfo]);return null==b?JAM.call(checker.makeArrayType,checker,[checker.anyType]):JAM.call(checker.makeArrayType,checker,[b])}return JAM.call(checker.sourceIsSubtypeOfTarget,checker,[this,b,comparisonInfo])?b:JAM.call(checker.sourceIsSubtypeOfTarget,
checker,[b,this,comparisonInfo])?this:null}function v1152(baseType){if(baseType==this)return!0;if(this.extendsList)for(var i=0,len=this.extendsList.length,v2787=i<len;v2787;){v2787=this.extendsList;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v2787=v2787[i];if(JAM.call(v2787.hasBase,v2787,[baseType]))return!0;i+=1;v2787=i<len}return!1}function v1151(pattern,replacement,checker,membersOnly){function v1150(key,s,unused){key=s;key=JAM.call(key.specializeType,key,[pattern,replacement,
checker]);s=result.ambientMembers;JAM.call(s.addPrivateMember,s,[key.name,key])}function v1149(key,s,unused){key=s;key=JAM.call(key.specializeType,key,[pattern,replacement,checker]);s=result.ambientMembers;JAM.call(s.addPublicMember,s,[key.name,key])}function v1148(key,s,unused){key=s;key=JAM.call(key.specializeType,key,[pattern,replacement,checker]);s=result.members;JAM.call(s.addPrivateMember,s,[key.name,key])}function v1147(key,s,unused){key=s;key=JAM.call(key.specializeType,key,[pattern,replacement,
checker]);s=result.members;JAM.call(s.addPublicMember,s,[key.name,key])}if(pattern==this)return replacement;var result=this;if(membersOnly){if(this.isReferenceType()){result=new Type;if(this.members){membersOnly=result;var v26805=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,[new TypeScript.StringHashTable,new TypeScript.StringHashTable])]);membersOnly.members=v26805;membersOnly=this.members.publicMembers;JAM.call(membersOnly.map,membersOnly,[v1147,null]);membersOnly=this.members.privateMembers;
JAM.call(membersOnly.map,membersOnly,[v1148,null])}this.ambientMembers&&(membersOnly=result,v26805=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,[new TypeScript.StringHashTable,new TypeScript.StringHashTable])]),membersOnly.ambientMembers=v26805,membersOnly=this.ambientMembers.publicMembers,JAM.call(membersOnly.map,membersOnly,[v1149,null]),membersOnly=this.ambientMembers.privateMembers,JAM.call(membersOnly.map,membersOnly,[v1150,null]));membersOnly=result;v26805=JAM.call(checker.scopeOf,
checker,[result]);membersOnly.containedScope=v26805;result.memberScope=result.containedScope}}else this.elementType?this.elementType==pattern?result=JAM.call(checker.makeArrayType,checker,[replacement]):this.elementType.elementType==pattern&&(result=JAM.call(checker.makeArrayType,checker,[JAM.call(checker.makeArrayType,checker,[replacement])])):this.call&&(membersOnly=result=new Type,v26805=this.call,v26805=JAM.call(v26805.specializeType,v26805,[pattern,replacement,checker]),membersOnly.call=v26805);
return result}function v1146(){var v2815=this.members;v2815||(v2815=this.extendsList,v2815||(v2815=this.construct,v2815||(v2815=this.call,v2815||(v2815=this.index,v2815||(v2815=this.elementType)))));return v2815}function v1145(flow){if(this==flow.anyType)return null;if(this.isDouble())return flow.numberInterfaceType?flow.numberInterfaceType.memberScope:null;if(this.isBoolean())return flow.booleanInterfaceType?flow.booleanInterfaceType.memberScope:null;if(this==flow.stringType)return flow.stringInterfaceType?
flow.stringInterfaceType.memberScope:null;if(this.elementType){if(flow.arrayInterfaceType){var v2822=this.elementType;flow=JAM.call(v2822.getArrayBase,v2822,[flow.arrayInterfaceType,flow.checker]);return flow.memberScope}return null}return this.memberScope}function v1144(checker){var v13079=this.isClassInstance();v13079||(v13079=this.isClass());v13079&&this.symbol.declAST&&(checker=checker.typeFlow,JAM.call(checker.inScopeTypeCheckDecl,checker,[this.symbol.declAST]))}function v1143(prefix,topLevel,
isElementType,scope){function v1142(key,s,unused){key=s;JAM.call(TypeScript.hasFlag,TypeScript,[key.flags,TypeScript.SymbolFlags.BuiltIn])||(key=JAM.call(key.getTypeNameEx,key,[scope]),(s=key.isArray())&&(s=key.delim==delim),s?JAM.call(allMemberNames.addAll,allMemberNames,[key.entries]):JAM.call(allMemberNames.add,allMemberNames,[key]),memCount+=1,curlies=!0)}if(this.elementType)return topLevel=this.elementType,JAM.call(MemberName.create,MemberName,[JAM.call(topLevel.getMemberTypeNameEx,topLevel,
[prefix,!1,!0,scope]),"","[]"]);var v13085=this.symbol;v13085&&(v13085=this.symbol.name)&&(v13085="_anonymous"!=this.symbol.name)&&((v13085=null==this.call)&&(v13085=null==this.construct)&&(v13085=null==this.index),v13085||(v13085=JAM.call(TypeScript.hasFlag,TypeScript,[this.typeFlags,TypeScript.TypeFlags.BuildingName]),v13085||(v13085=this.members)&&(v13085=!this.isClass())));if(v13085)return topLevel=this.symbol,topLevel=JAM.call(topLevel.scopeRelativeName,topLevel,[scope]),topLevel="null"==topLevel?
"any":topLevel,JAM.call(MemberName.create,MemberName,[topLevel]);v13085=this.members;v13085||(v13085=this.call,v13085||(v13085=this.construct));if(v13085){if(JAM.call(TypeScript.hasFlag,TypeScript,[this.typeFlags,TypeScript.TypeFlags.BuildingName]))return JAM.call(MemberName.create,MemberName,["this"]);this.typeFlags|=TypeScript.TypeFlags.BuildingName;var allMemberNames=new MemberNameArray;isElementType||(isElementType=null!=this.index);var curlies=isElementType,memCount=0,delim="; ";this.members&&
(isElementType=this.members.allMembers,JAM.call(isElementType.map,isElementType,[v1142,null]));isElementType=this.callCount();(v13085=!curlies)&&(v13085=1==isElementType)&&(v13085=topLevel);if(this.call){var v13096=this.call;JAM.call(allMemberNames.addAll,allMemberNames,[JAM.call(v13096.toStrings,v13096,[prefix,v13085,scope])])}this.construct&&(prefix=this.construct,JAM.call(allMemberNames.addAll,allMemberNames,[JAM.call(prefix.toStrings,prefix,["new",v13085,scope])]));this.index&&(prefix=this.index,
JAM.call(allMemberNames.addAll,allMemberNames,[JAM.call(prefix.toStrings,prefix,["",v13085,scope])]));prefix=curlies;prefix||(prefix=1<isElementType)&&(prefix=topLevel);prefix?(allMemberNames.prefix="{ ",allMemberNames.suffix="}",allMemberNames.delim=delim):1<allMemberNames.entries.length&&(allMemberNames.delim=delim);this.typeFlags&=~TypeScript.TypeFlags.BuildingName;(topLevel=0==isElementType)&&(topLevel=0==memCount);return topLevel?JAM.call(MemberName.create,MemberName,["{}"]):allMemberNames}return JAM.call(MemberName.create,
MemberName,["{}"])}function v1141(prefix,topLevel,isElementType,scope){prefix=JAM.call(this.getMemberTypeNameEx,this,[prefix,topLevel,isElementType,scope]);return prefix.toString()}function v1140(){var total=0;this.call&&(total+=this.call.signatures.length);this.construct&&(total+=this.construct.signatures.length);this.index&&(total+=this.index.signatures.length);return total}function v1139(scope){return JAM.call(this.getMemberTypeNameEx,this,["",!0,!1,scope])}function v1138(scope){return JAM.call(this.getMemberTypeName,
this,["",!0,!1,scope])}function v1137(){return JAM.call(this.getMemberTypeName,this,["",!0,!1,null])}function v1136(){return JAM.call(TypeScript.hasFlag,TypeScript,[this.primitiveTypeClass,Primitive.Null])}function v1135(){return JAM.call(TypeScript.hasFlag,TypeScript,[this.primitiveTypeClass,Primitive.Boolean])}function v1134(){return JAM.call(TypeScript.hasFlag,TypeScript,[this.primitiveTypeClass,Primitive.String])}function v1133(){return JAM.call(TypeScript.hasFlag,TypeScript,[this.primitiveTypeClass,
Primitive.Double])}function v1132(){this.typeFlags|=TypeScript.TypeFlags.HasImplementation}function v1131(){return JAM.call(TypeScript.hasFlag,TypeScript,[this.typeFlags,TypeScript.TypeFlags.HasImplementation])}function v1130(){return this.isClass()?this.instanceType:this}function v1129(){var v2872=this.symbol;v2872&&(v2872=!this.elementType)&&(v2872=this.symbol.type.isClass());return v2872}function v1128(){return null!=this.elementType}function v1127(){return null!=this.instanceType}function v1126(arrInstType,
checker){var v2875=this.arrayCache;return JAM.call(v2875.specialize,v2875,[arrInstType,checker])}function v1125(){var v13111=this.extendsList;v13111&&(v13111=0<this.extendsList.length);return v13111?this.extendsList[0]:null}function Type(){this.typeID=currentTypeID;currentTypeID+=1;this.index=this.call=this.construct=null;this.passTypeCreated=TypeScript.CompilerDiagnostics.analysisPass;this.primitiveTypeClass=Primitive.None;this.typeFlags=TypeScript.TypeFlags.None}Type.prototype.baseClass=v1125;Type.prototype.getArrayBase=
v1126;Type.prototype.isClass=v1127;Type.prototype.isArray=v1128;Type.prototype.isClassInstance=v1129;Type.prototype.getInstanceType=v1130;Type.prototype.hasImplementation=v1131;Type.prototype.setHasImplementation=v1132;Type.prototype.isDouble=v1133;Type.prototype.isString=v1134;Type.prototype.isBoolean=v1135;Type.prototype.isNull=v1136;Type.prototype.getTypeName=v1137;Type.prototype.getScopedTypeName=v1138;Type.prototype.getScopedTypeNameEx=v1139;Type.prototype.callCount=v1140;Type.prototype.getMemberTypeName=
v1141;Type.prototype.getMemberTypeNameEx=v1143;Type.prototype.checkDecl=v1144;Type.prototype.getMemberScope=v1145;Type.prototype.isReferenceType=v1146;Type.prototype.specializeType=v1151;Type.prototype.hasBase=v1152;Type.prototype.mergeOrdered=v1153;Type.prototype.isModuleType=v1154;Type.prototype.hasMembers=v1155;Type.prototype.getAllEnclosedTypes=v1156;Type.prototype.getAllAmbientEnclosedTypes=v1157;Type.prototype.getPublicEnclosedTypes=v1158;Type.prototype.getpublicAmbientEnclosedTypes=v1159;Type.prototype.getDocComments=
v1160;return Type}function v1124(_super){function v1123(entries){for(var i=0,v2913=i<entries.length;v2913;){v2913=this.entries;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v2912=entries[i];JAM.call(v2913.push,v2913,[v2912]);i+=1;v2913=i<entries.length}}function v1122(entry){var v2914=this.entries;JAM.call(v2914.push,v2914,[entry])}function v1121(){return!0}function MemberNameArray(){JAM.call(_super.apply,_super,[this,arguments]);this.delim="";this.entries=[]}JAM.call(__extends,
null,[MemberNameArray,_super]);MemberNameArray.prototype.isArray=v1121;MemberNameArray.prototype.add=v1122;MemberNameArray.prototype.addAll=v1123;return MemberNameArray}function v1120(_super){function v1119(){return!0}function MemberNameString(text){JAM.call(_super.call,_super,[this]);this.text=text}JAM.call(__extends,null,[MemberNameString,_super]);MemberNameString.prototype.isString=v1119;return MemberNameString}function v1118(){function create(arg1,arg2,arg3){if("string"==typeof arg1)return JAM.new(MemberNameString,
[arg1]);var result=new MemberNameArray;arg2&&(result.prefix=arg2);arg3&&(result.suffix=arg3);arg2=result.entries;JAM.call(arg2.push,arg2,[arg1]);return result}function memberNameToString(memberName){var result=memberName.prefix;if(memberName.isString())result+=memberName.text;else for(var ar=memberName,index=0,v2921=index<ar.entries.length;v2921;){v2921=ar.entries;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v2921=v2921[index];result+=JAM.call(MemberName.memberNameToString,MemberName,
[v2921]);result+=ar.delim;index+=1;v2921=index<ar.entries.length}return result+=memberName.suffix}function v1117(){return JAM.call(MemberName.memberNameToString,MemberName,[this])}function v1116(){return!1}function v1115(){return!1}function MemberName(){this.suffix=this.prefix=""}MemberName.prototype.isString=v1115;MemberName.prototype.isArray=v1116;MemberName.prototype.toString=v1117;MemberName.memberNameToString=memberNameToString;MemberName.create=create;return MemberName}function v1114(Primitive){Primitive._map=
[];Primitive.None=0;Primitive.Void=1;Primitive.Double=2;Primitive.String=4;Primitive.Boolean=8;Primitive.Any=16;Primitive.Null=32;Primitive.Undefined=64}function getTypeLink(ast,checker,autoVar){var result=new TypeLink;result.ast=ast;(ast=null==ast)&&(ast=autoVar);result.type=ast?checker.anyType:null;return result}var v13123=TypeScript.Primitive;v13123||(v13123=TypeScript.Primitive={});v1114(v13123);var Primitive=TypeScript.Primitive,MemberName=v1118();TypeScript.MemberName=MemberName;var MemberNameString=
v1120(MemberName);TypeScript.MemberNameString=MemberNameString;var MemberNameArray=v1124(MemberName);TypeScript.MemberNameArray=MemberNameArray;var currentTypeID=-1,v13123=v1161();TypeScript.Type=v13123;v13123=v1170(v13123);TypeScript.ModuleType=v13123;var TypeLink=v1171();TypeScript.TypeLink=TypeLink;TypeScript.getTypeLink=getTypeLink}
function v1113(){var TypeScript=v18816;function v1112(){function v1111(enclosingScopeContext){function preFindMemberScopeFullAstFuzy(ast,parent,walker){JAM.call(TypeScript.isValidAstNode,TypeScript,[ast])&&((parent=JAM.call(TypeScript.hasFlag,TypeScript,[ast.flags,matchFlag]))&&(parent=ast.minChar<pos)&&(parent=pos<=ast.limChar),parent&&(astResult=ast),walker=walker.options,(parent=ast.minChar<=pos)&&(parent=pos<=ast.limChar),walker.goChildren=parent);return ast}function preFindMemberScopeFullAst(ast,
parent,walker){if(JAM.call(TypeScript.isValidAstNode,TypeScript,[ast])){if(parent=JAM.call(TypeScript.hasFlag,TypeScript,[ast.flags,matchFlag]))(parent=pos==ast.limChar)||(parent=pos-1==ast.limChar);parent&&(astResult=ast,walker.options.stopWalk());walker=walker.options;(parent=ast.minChar<=pos)&&(parent=pos<=ast.limChar);walker.goChildren=parent}return ast}var matchFlag=TypeScript.ASTFlags.DotLHS,pos=enclosingScopeContext.pos,astResult=null,v2936=TypeScript.getAstWalkerFactory();JAM.call(v2936.walk,
v2936,[enclosingScopeContext.script,preFindMemberScopeFullAst]);null==astResult&&(v2936=TypeScript.getAstWalkerFactory(),JAM.call(v2936.walk,v2936,[enclosingScopeContext.script,preFindMemberScopeFullAstFuzy]));(v2936=astResult)&&(v2936=enclosingScopeContext.enclosingClassDecl)&&(v2936=astResult.type==enclosingScopeContext.enclosingClassDecl.type.instanceType);v2936&&(enclosingScopeContext.publicsOnly=!1);if(enclosingScopeContext=astResult)enclosingScopeContext=astResult.type;return enclosingScopeContext?
(enclosingScopeContext=astResult.type,JAM.call(enclosingScopeContext.getMemberScope,enclosingScopeContext,[this])):null}function v1110(enclosingScopeContext){return JAM.call(this.findMemberScope,this,[enclosingScopeContext,TypeScript.ASTFlags.DotLHS])}function v1109(enclosingScopeContext,matchFlag){var enclosingScope=enclosingScopeContext.getScope(),pos=enclosingScopeContext.pos-enclosingScopeContext.scopeStartAST.minChar,scriptFragment=enclosingScopeContext.getScriptFragment(),pos=JAM.new(TypeScript.MemberScopeContext,
[this,pos,matchFlag]);pos.scope=enclosingScope;if(scriptFragment.nodeType==TypeScript.NodeType.Name)return pos=scriptFragment.type,JAM.call(pos.getMemberScope,pos,[this]);enclosingScope=TypeScript.getAstWalkerFactory();JAM.call(enclosingScope.walk,enclosingScope,[scriptFragment,TypeScript.preFindMemberScope,null,null,pos]);(scriptFragment=pos.ast)&&(scriptFragment=enclosingScopeContext.enclosingClassDecl)&&(scriptFragment=pos.ast.type==enclosingScopeContext.enclosingClassDecl.type.instanceType);scriptFragment&&
(enclosingScopeContext.publicsOnly=!1);return pos.type?(pos=pos.type,JAM.call(pos.getMemberScope,pos,[this])):null}function v1108(ast){var script=ast;this.checker.locationInfo=script.locationInfo;var script=JAM.new(ScopeChain,[this.checker.gloMod,null,this.globalScope]),script=JAM.new(TypeScript.AssignScopeContext,[script,this,[this.checker.currentModDecl]]),v2960=TypeScript.getAstWalkerFactory();JAM.call(v2960.walk,v2960,[ast,TypeScript.preAssignScopes,TypeScript.postAssignScopes,null,script])}function v1107(ast){var callEx=
ast,v13137=this.checker.styleSettings.newMustBeUsed;v13137&&(v13137=ast.nodeType==TypeScript.NodeType.New);v13137?JAM.call(TypeScript.hasFlag,TypeScript,[ast.flags,TypeScript.ASTFlags.IsStatement])&&(v13137=this.checker.errorReporter,JAM.call(v13137.styleError,v13137,[ast,"use of new expression as a statement"])):((v13137=!this.checker.styleSettings.evalOK)&&(v13137=ast.nodeType==TypeScript.NodeType.Call),v13137&&((ast=callEx.target.nodeType==TypeScript.NodeType.Name)&&(ast="eval"==callEx.target.text),
ast&&(ast=this.checker.errorReporter,JAM.call(ast.styleError,ast,[callEx,"eval not permitted"]))));callEx.target.nodeType==TypeScript.NodeType.FuncDecl&&(callEx.target.isInlineCallLiteral=!0);ast=this.inSuperCall;callEx.target.nodeType==TypeScript.NodeType.Super&&(this.inSuperCall=!0);var v13137=callEx,v26809=JAM.call(this.typeCheck,this,[callEx.target]);v13137.target=v26809;JAM.call(this.preTypeCheckCallArgs,this,[callEx.arguments]);v13137=callEx.target;v26809=null==v13137.type;v26809||(v26809=v13137.type==
this.anyType,v26809||(v26809=this.functionInterfaceType)&&(v26809=v13137.type==this.functionInterfaceType));v26809?callEx.type=this.anyType:(v13137=v13137.type,v13137.call?(v13137=JAM.call(this.resolveOverload,this,[callEx,v13137.call]),null==v13137?callEx.type=this.anyType:(callEx.type=v13137.returnType.type,callEx.signature=v13137)):((v26809=callEx.target.nodeType==TypeScript.NodeType.Super)&&(v26809=this.thisFnc)&&(v26809=this.thisFnc.isConstructor)&&(v26809=JAM.call(TypeScript.hasFlag,TypeScript,
[this.thisFnc.fncFlags,TypeScript.FncFlags.ClassMethod])),v26809?(v13137=v13137.symbol.type.construct?JAM.call(this.resolveOverload,this,[callEx,v13137.symbol.type.construct]):null,null==v13137?callEx.type=this.anyType:(callEx.flags|=TypeScript.ASTFlags.ClassBaseConstructorCall,callEx.type=v13137.returnType.type,callEx.signature=v13137)):(callEx.type=this.anyType,v13137=this.checker.errorReporter,JAM.call(v13137.invalidCall,v13137,[callEx,callEx.nodeType,this.scope]))));JAM.call(this.postTypeCheckCallArgs,
this,[callEx]);this.inSuperCall=ast;return callEx}function v1106(callEx){var acceptedTargetType=!1,i=0;if(i=callEx.target)if(i=callEx.target.type)if(i=callEx.signature)i=callEx.arguments;if(i){var sig=callEx.signature;(i=sig)&&(i=callEx.arguments.members.length>=sig.nonOptionalParameterCount);if(i){for(var acceptedTargetType=!0,targetType=null,i=sig.hasVariableArgList?sig.parameters.length-1:sig.parameters.length,nonVarArgActualParamLength=i=callEx.arguments.members.length<i?callEx.arguments.members.length:
i,i=0,targetType=i<nonVarArgActualParamLength;targetType;){targetType=sig.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)targetType=targetType[i];var targetType=targetType.getType(),v19248=callEx.arguments.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v19248=v19248[i];switch(v19248.nodeType){case TypeScript.NodeType.FuncDecl:case TypeScript.NodeType.ObjectLit:case TypeScript.NodeType.ArrayLit:var v19248=this.checker,v2990=this.checker.inProvisionalTypecheckMode(),
v24845=sig.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v24845=v24845[i];var v24845=!v24845.declAST.isParenthesized,v13167=callEx.arguments.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v13167=v13167[i];JAM.call(v19248.typeCheckWithContextualType,v19248,[targetType,v2990,v24845,v13167])}i+=1;targetType=i<nonVarArgActualParamLength}if(sig.hasVariableArgList){i=sig.nonOptionalParameterCount-1;targetType=sig.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)targetType=
targetType[i];if(targetType=targetType.getType())targetType=targetType.elementType;sig=sig.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)i=sig[i];sig=!i.declAST.isParenthesized;i=nonVarArgActualParamLength;for(nonVarArgActualParamLength=i<callEx.arguments.members.length;nonVarArgActualParamLength;){nonVarArgActualParamLength=callEx.arguments.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)nonVarArgActualParamLength=nonVarArgActualParamLength[i];
switch(nonVarArgActualParamLength.nodeType){case TypeScript.NodeType.FuncDecl:case TypeScript.NodeType.ObjectLit:case TypeScript.NodeType.ArrayLit:nonVarArgActualParamLength=this.checker;v19248=this.checker.inProvisionalTypecheckMode();v2990=callEx.arguments.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v2990=v2990[i];JAM.call(nonVarArgActualParamLength.typeCheckWithContextualType,nonVarArgActualParamLength,[targetType,v19248,sig,v2990])}i+=1;nonVarArgActualParamLength=i<
callEx.arguments.members.length}}}}if(acceptedTargetType=!acceptedTargetType)acceptedTargetType=callEx.arguments;if(acceptedTargetType)for(this.checker.killCurrentContextualType(),i=0,acceptedTargetType=i<callEx.arguments.members.length;acceptedTargetType;){acceptedTargetType=callEx.arguments.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)acceptedTargetType=acceptedTargetType[i];switch(acceptedTargetType.nodeType){case TypeScript.NodeType.FuncDecl:case TypeScript.NodeType.ObjectLit:case TypeScript.NodeType.ArrayLit:acceptedTargetType=
callEx.arguments.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)acceptedTargetType=acceptedTargetType[i];JAM.call(this.typeCheck,this,[acceptedTargetType])}i+=1;acceptedTargetType=i<callEx.arguments.members.length}}function v1105(args){if(args)for(var i=0,v3014=i<args.members.length;v3014;){v3014=args.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v3014=v3014[i];switch(v3014.nodeType){case TypeScript.NodeType.FuncDecl:case TypeScript.NodeType.ObjectLit:case TypeScript.NodeType.ArrayLit:i+=
1;v3014=i<args.members.length;continue;default:v3014=args.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v3014=v3014[i];JAM.call(this.typeCheck,this,[v3014])}i+=1;v3014=i<args.members.length}}function v1104(ast){var v3015=ast,v26810=JAM.call(this.typeCheck,this,[ast.target]);v3015.target=v26810;v3015=ast.target;v26810=v3015.type.construct;v26810||(v26810=v3015.type.call);if(v26810)JAM.call(this.preTypeCheckCallArgs,this,[ast.arguments]);else{var v26810=ast,v26811=JAM.call(this.typeCheck,
this,[ast.arguments]);v26810.arguments=v26811}v3015.type==this.anyType?(ast.type=this.anyType,v3015=ast,v26810=JAM.call(this.typeCheck,this,[ast.arguments]),v3015.arguments=v26810):v3015.type.construct?(v3015=JAM.call(this.resolveOverload,this,[ast,v3015.type.construct]),null==v3015?ast.type=this.anyType:(ast.type=v3015.returnType.type==this.voidType?this.anyType:v3015.returnType.type,ast.signature=v3015)):v3015.type.call?(v3015=JAM.call(this.resolveOverload,this,[ast,v3015.type.call]),null==v3015?
ast.type=this.anyType:((v26810=v3015.returnType.type==this.voidType)||(v26810=v3015.returnType.type==this.anyType),v26810?(ast.type=this.anyType,ast.signature=v3015):(v3015=this.checker.errorReporter,JAM.call(v3015.simpleError,v3015,[ast.target,"new expression only valid on constructors"])))):v3015.type.elementType?ast.type=v3015.type:(v3015=this.checker.errorReporter,JAM.call(v3015.invalidCall,v3015,[ast,ast.nodeType,this.scope]),ast.type=this.anyType);JAM.call(this.postTypeCheckCallArgs,this,[ast]);
return ast}function v1103(application,group){var rd=this.resolutionDataCache.getResolutionData(),actuals=rd.actuals,exactCandidates=rd.exactCandidates,conversionCandidates=rd.conversionCandidates,candidate=null,hasOverloads=1<group.signatures.length,comparisonInfo=new TypeScript.TypeComparisonInfo,args=null,target=null,v13202=application.nodeType==TypeScript.NodeType.Call;v13202||(v13202=application.nodeType==TypeScript.NodeType.New);if(v13202){var callEx=application,args=callEx.arguments,target=
callEx.target;if(callEx.arguments)for(var len=callEx.arguments.members.length,v13202=0,v3041=v13202<len;v3041;){v3041=callEx.arguments.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v3041=v3041[v13202];actuals[v13202]=v3041.type;v13202+=1;v3041=v13202<len}}else application.nodeType==TypeScript.NodeType.Index&&(v13202=application,target=v13202.operand1,args=new TypeScript.ASTList,args.members[0]=v13202.operand2,actuals[0]=v13202.operand2.type);v13202=0;callEx=group.signatures.length;
for(len=v13202<callEx;len;){len=group.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)len=len[v13202];(v3041=hasOverloads)&&(v3041=len==group.definitionSignature)&&(v3041=!this.checker.canCallDefinitionSignature);v3041||((v3041=!len.returnType.type)&&(v3041=len.declAST)&&(v3041=len.typeCheckStatus!=TypeScript.TypeCheckStatus.Finished),v3041&&JAM.call(this.typeCheckFunction,this,[len.declAST]),JAM.call(this.tryAddCandidates,this,[len,actuals,exactCandidates,conversionCandidates,
comparisonInfo]));v13202+=1;len=v13202<callEx}if(0==exactCandidates.length)exactCandidates=this.checker,exactCandidates=JAM.call(exactCandidates.getApplicableSignatures,exactCandidates,[conversionCandidates,args,comparisonInfo]),0<exactCandidates.length?(candidate=this.checker,args=JAM.call(candidate.findMostApplicableSignature,candidate,[exactCandidates,args]),args.ambiguous&&(candidate=this.checker.errorReporter,JAM.call(candidate.simpleError,candidate,[target,"Ambiguous call expression - could not choose overload"])),
candidate=args.sig):(args="Supplied parameters do not match any signature of call target",comparisonInfo.message?(exactCandidates=this.checker.errorReporter,JAM.call(exactCandidates.simpleError,exactCandidates,[target,args+":\n\t"+comparisonInfo.message])):(comparisonInfo=this.checker.errorReporter,JAM.call(comparisonInfo.simpleError,comparisonInfo,[target,args])));else if(1<exactCandidates.length){candidate=[];v13202=0;for(comparisonInfo=v13202<exactCandidates.length;comparisonInfo;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)comparisonInfo=
exactCandidates[v13202];candidate[v13202]={signature:comparisonInfo,hadProvisionalErrors:!1};v13202+=1;comparisonInfo=v13202<exactCandidates.length}comparisonInfo=this.checker;args=JAM.call(comparisonInfo.findMostApplicableSignature,comparisonInfo,[candidate,args]);args.ambiguous&&(candidate=this.checker.errorReporter,JAM.call(candidate.simpleError,candidate,[target,"Ambiguous call expression - could not choose overload"]));candidate=args.sig}else candidate=exactCandidates[0];target=this.resolutionDataCache;
JAM.call(target.returnResolutionData,target,[rd]);return candidate}function v1102(signature,actuals,exactCandidates,conversionCandidates,comparisonInfo){var lowerBound=signature.nonOptionalParameterCount,upperBound=signature.parameters.length,formalLen=lowerBound,acceptable=!1;if(lowerBound=actuals.length>=lowerBound)(lowerBound=signature.hasVariableArgList)||(lowerBound=actuals.length<=upperBound);lowerBound&&(formalLen=signature.hasVariableArgList?signature.parameters.length:actuals.length,acceptable=
!0);upperBound=null;lowerBound=acceptable;lowerBound||(lowerBound=signature.hasVariableArgList);if(lowerBound){if(signature.hasVariableArgList){formalLen-=1;upperBound=signature.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)upperBound=upperBound[formalLen];upperBound=upperBound.parameter.typeLink.type;upperBound=upperBound.elementType;acceptable=actuals.length>=formalLen}for(var lowerBound=actuals.length,exact=acceptable,i=0,v3082=i<lowerBound;v3082;){if(i<formalLen){v3082=
signature.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v3082=v3082[i];v3082=v3082.parameter.typeLink.type}else v3082=upperBound;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var typeB=actuals[i];var v13226=!v3082;v13226||(v13226=!typeB,v13226||(v13226=this.checker,v13226=!JAM.call(v13226.typesAreIdentical,v13226,[v3082,typeB])));v13226&&(exact=!1);v13226=this.checker;JAM.call(v13226.sourceIsAssignableToTarget,v13226,[typeB,v3082,comparisonInfo])||(acceptable=
!1);if(!exact&&!acceptable)break;i+=1;v3082=i<lowerBound}exact?JAM.set(exactCandidates,exactCandidates.length,signature):((actuals=acceptable)&&(actuals=0==exactCandidates.length),actuals&&JAM.set(conversionCandidates,conversionCandidates.length,signature))}}function v1101(binex){var v3087=binex,v26813=JAM.call(this.typeCheck,this,[binex.operand1]);v3087.operand1=v26813;v3087=binex;v26813=JAM.call(this.typeCheck,this,[binex.operand2]);v3087.operand2=v26813;binex.type=binex.operand2.type;return binex}
function v1100(binex){var v3090=binex,v26815=JAM.call(this.typeCheck,this,[binex.operand1]);v3090.operand1=v26815;v3090=binex;v26815=JAM.call(this.typeCheck,this,[binex.operand2]);v3090.operand2=v26815;var v3090=binex.operand1.type,v26815=binex.operand2.type,v13234=v3090==this.checker.anyType;v13234||(v13234=v26815==this.checker.anyType);v13234?binex.type=this.checker.anyType:v3090==this.checker.booleanType?binex.type=v26815==this.checker.booleanType?this.checker.booleanType:this.checker.anyType:
v3090==this.checker.numberType?binex.type=v26815==this.checker.numberType?this.checker.numberType:this.checker.anyType:v3090==this.checker.stringType?binex.type=v26815==this.checker.stringType?this.checker.stringType:this.checker.anyType:(v13234=this.checker,JAM.call(v13234.sourceIsSubtypeOfTarget,v13234,[v3090,v26815])?binex.type=v26815:(v13234=this.checker,JAM.call(v13234.sourceIsSubtypeOfTarget,v13234,[v26815,v3090])?binex.type=v3090:binex.type=this.checker.anyType));return binex}function v1099(ast){var v3111=
ast,v26817=JAM.call(this.typeCheck,this,[ast.operand1]);v3111.operand1=v26817;v3111=ast;v26817=JAM.call(this.typeCheck,this,[ast.operand2]);v3111.operand2=v26817;ast.type=ast.operand2.type;return ast}function v1098(ast){var binex=ast,v3114=binex,v26819=JAM.call(this.typeCheck,this,[binex.operand1]);v3114.operand1=v26819;v3114=binex;v26819=JAM.call(this.typeCheck,this,[binex.operand2]);v3114.operand2=v26819;v3114=binex.operand1.type==this.checker.anyType;v3114||(v3114=this.checker,v3114=JAM.call(v3114.sourceIsSubtypeOfTarget,
v3114,[binex.operand1.type,this.objectInterfaceType]));v3114&&(v3114=binex.operand2.type==this.anyType,v3114||(v3114=this.checker,v3114=JAM.call(v3114.sourceIsSubtypeOfTarget,v3114,[binex.operand2.type,this.functionInterfaceType])));v3114||(v3114=this.checker.errorReporter,JAM.call(v3114.simpleError,v3114,[ast,"The instanceof operator requires the left operand to be of type Any or an object type, and the right operand to be of type Any or a subtype of the Function interface type"]));binex.type=this.booleanType;
return binex}function v1097(returnStmt){if(this.thisFnc){var targetType=null;if(this.checker.hasTargetType()){var tcContext=this.checker.currentContextualTypeContext;if(tcContext=tcContext.targetAccessorType)targetType=tcContext;else{var v13251=tcContext=this.checker.currentContextualTypeContext.targetSig;v13251&&(v13251=tcContext.returnType.type!=this.voidType);v13251&&(targetType=tcContext.returnType.type)}}if(returnStmt.returnExpression){tcContext=this.thisFnc;tcContext.fncFlags|=TypeScript.FncFlags.HasReturnExpression;
(tcContext=null==targetType)&&(tcContext=this.thisFnc.returnTypeAnnotation)&&(tcContext=this.thisFnc.returnTypeAnnotation.type)&&(tcContext=this.thisFnc.returnTypeAnnotation.type!=this.voidType);tcContext&&(targetType=this.thisFnc.returnTypeAnnotation.type);tcContext=this.checker;JAM.call(tcContext.typeCheckWithContextualType,tcContext,[targetType,this.checker.inProvisionalTypecheckMode(),null!=targetType,returnStmt.returnExpression]);if(tcContext=this.thisFnc.returnTypeAnnotation)tcContext=this.thisFnc.returnTypeAnnotation.type;
(tcContext=tcContext?this.thisFnc.returnTypeAnnotation.type:targetType)?((targetType=tcContext==this.voidType)&&(targetType=returnStmt.returnExpression.type!=this.voidType),targetType?(targetType=this.checker.errorReporter,JAM.call(targetType.simpleError,targetType,[returnStmt,"Return with value expression in void function"]),returnStmt.type=returnStmt.returnExpression.type):(targetType=returnStmt,v13251=JAM.call(this.cast,this,[returnStmt.returnExpression,tcContext]),targetType.returnExpression=
v13251,returnStmt.type=tcContext)):(targetType&&(returnStmt.returnExpression.type!=this.voidType?(tcContext=returnStmt,targetType=JAM.call(this.cast,this,[returnStmt.returnExpression,targetType]),tcContext.returnExpression=targetType):returnStmt.returnExpression.type=targetType),returnStmt.type=returnStmt.returnExpression.type);JAM.set(this.thisFnc.returnStatementsWithExpressions,this.thisFnc.returnStatementsWithExpressions.length,returnStmt)}else targetType=null==targetType?this.checker.voidType:
targetType,returnStmt.type=targetType}return returnStmt}function v1096(type,ast){var v13267=type;v13267&&(v13267=type.construct)&&(v13267=0<type.construct.signatures.length);if(v13267)for(var v13267=0,v3146=v13267<type.construct.signatures.length;v3146;){v3146=type.construct.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v3146=v3146[v13267];if(v3146.returnType.type==this.checker.voidType){v13267=this.checker.errorReporter;JAM.call(v13267.simpleError,v13267,[ast,"Constructors may not have a return type of 'void'"]);
break}v13267+=1;v3146=v13267<type.construct.signatures.length}}function v1095(arrayLit){function v1094(index){var v13273=elements.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)index=v13273[index];return index.type}function v1093(index,type){var v13274=elements.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v13274=v13274[index];v13274.type=type}function v1092(){return elements.members.length}var elements=arrayLit.operand,elementType=this.anyType,targetElementType=
null,comparisonInfo=new TypeScript.TypeComparisonInfo;comparisonInfo.onlyCaptureFirstError=!0;if(this.checker.hasTargetType()){var targetType=this.checker.currentContextualTypeContext.contextualType;targetType.elementType&&(targetElementType=targetType.elementType)}if(elements){targetType=this.inArrayElementTypeCheck;this.inArrayElementTypeCheck=!0;elementType=this.checker;JAM.call(elementType.typeCheckWithContextualType,elementType,[targetElementType,this.checker.inProvisionalTypecheckMode(),null!=
targetElementType,elements]);this.inArrayElementTypeCheck=targetType;var elementType=elements.members[0].type,collection={getLength:v1092,setTypeAtIndex:v1093,getTypeAtIndex:v1094},v3159=this.checker,elementType=JAM.call(v3159.findBestCommonType,v3159,[elementType,targetElementType,collection,!1,comparisonInfo]),collection=elementType==this.checker.undefinedType;collection||((targetType=!targetType)&&(targetType=elementType==this.nullType),collection=targetType);collection&&(elementType=this.anyType)}elementType?
targetElementType&&(comparisonInfo=this.checker,JAM.call(comparisonInfo.sourceIsAssignableToTarget,comparisonInfo,[elementType,targetElementType])&&(elementType=targetElementType)):(elementType="Incompatible types in array literal expression",comparisonInfo.message?(targetElementType=this.checker.errorReporter,JAM.call(targetElementType.simpleError,targetElementType,[arrayLit,elementType+": "+comparisonInfo.message])):(comparisonInfo=this.checker.errorReporter,JAM.call(comparisonInfo.simpleError,
comparisonInfo,[arrayLit,elementType])),elementType=this.anyType);comparisonInfo=this.checker;elementType=JAM.call(comparisonInfo.makeArrayType,comparisonInfo,[elementType]);arrayLit.type=elementType}function v1091(objectLit){var resultType=new TypeScript.Type,v3169=resultType,v26824=JAM.new(TypeScript.TypeSymbol,[this.checker.anon,objectLit.minChar,objectLit.limChar-objectLit.minChar,this.checker.locationInfo.unitIndex,resultType]);v3169.symbol=v26824;v3169=resultType;v26824=JAM.new(TypeScript.ScopedMembers,
[JAM.new(TypeScript.DualStringHashTable,[new TypeScript.StringHashTable,new TypeScript.StringHashTable])]);v3169.members=v26824;v3169=resultType;v26824=JAM.new(TypeScript.SymbolTableScope,[resultType.members,null,null,null,null]);v3169.memberScope=v26824;v3169=JAM.new(TypeScript.SymbolAggregateScope,[resultType.symbol]);JAM.call(v3169.addParentScope,v3169,[resultType.memberScope]);JAM.call(v3169.addParentScope,v3169,[this.scope]);resultType.containedScope=v3169;var memberDecls=objectLit.operand,v3169=
this.thisType,acceptTargetType=!1,v26824=null;if(this.checker.hasTargetType()){if(acceptTargetType=v26824=this.checker.currentContextualTypeContext.contextualType)if(acceptTargetType=v26824.symbol)acceptTargetType=this.checker,acceptTargetType=!JAM.call(acceptTargetType.typeStatusIsFinished,acceptTargetType,[v26824.symbol.typeCheckStatus]);acceptTargetType&&v26824.symbol.declAST&&JAM.call(this.typeCheck,this,[v26824.symbol.declAST]);acceptTargetType=!0}if(memberDecls)for(var i=0,len=memberDecls.members.length,
v3211=i<len;v3211;){v3211=memberDecls.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var binex=v3211[i];var id=binex.operand1,targetMember=null,fieldSymbol=null;if(id.nodeType==TypeScript.NodeType.Name)v3211=id.text;else if(id.nodeType==TypeScript.NodeType.QString)v3211=id.text,v3211=JAM.call(v3211.substring,v3211,[1,v3211.length-1]);else{resultType=this.checker.errorReporter;JAM.call(resultType.simpleError,resultType,[objectLit,"malformed object literal"]);resultType=this.anyType;
break}var v13307=acceptTargetType;v13307&&(v13307=v26824.memberScope);v13307&&(targetMember=v26824.memberScope,targetMember=JAM.call(targetMember.find,targetMember,[v3211,!1,!1]));(v13307=binex.operand2.nodeType==TypeScript.NodeType.FuncDecl)&&(v13307=binex.operand2.isAccessor());if(v13307){var fieldSymbol=binex.operand2,v13307=resultType.members.publicMembers,v13307=JAM.call(v13307.lookup,v13307,[v3211]),v3190=this.checker,v13307=JAM.call(v3190.createAccessorSymbol,v3190,[fieldSymbol,v13307,resultType,
!0,!1,resultType.memberScope,null]),fieldSymbol=fieldSymbol.accessorSymbol=v13307;id.nodeType==TypeScript.NodeType.Name&&(id.sym=v13307)}v13307=this.checker;v3190=acceptTargetType&&targetMember?targetMember.getType():null;JAM.call(v13307.typeCheckWithContextualType,v13307,[v3190,!1,acceptTargetType,binex.operand2]);acceptTargetType&&targetMember?(v13307=binex.operand2.type==this.anyType,v13307||(v13307=this.checker,v13307=JAM.call(v13307.sourceIsAssignableToTarget,v13307,[binex.operand2.type,targetMember.getType()])),
v13307||(v13307=binex.operand2.nodeType==TypeScript.NodeType.FuncDecl)&&(v13307=binex.operand2.isAccessor())&&(v13307=JAM.call(this.typeFromAccessorFuncDecl,this,[binex.operand2])==targetMember.getType()),v13307&&(v13307=binex.operand1,targetMember=targetMember.getType(),v13307.type=targetMember)):(targetMember=binex.operand2,v13307=binex.operand2.type==this.checker.undefinedType?this.anyType:binex.operand2.type,targetMember.type=v13307);null==fieldSymbol&&(binex=binex.operand2.type,targetMember=
new TypeScript.ValueLocation,fieldSymbol=JAM.new(TypeScript.FieldSymbol,[v3211,id.minChar,this.checker.locationInfo.unitIndex,!0,targetMember]),fieldSymbol.flags|=TypeScript.SymbolFlags.Property,id=targetMember.symbol=fieldSymbol,v13307=this.checker.getTypeCheckFinishedStatus(),id.typeCheckStatus=v13307,id=targetMember,v13307=new TypeScript.TypeLink,id.typeLink=v13307,targetMember.typeLink.type=binex,id=resultType.members.publicMembers,JAM.call(id.add,id,[v3211,fieldSymbol]));fieldSymbol.isObjectLitField=
!0;i+=1;v3211=i<len}this.thisType=v3169;objectLit.type=resultType;v26824&&(objectLit.targetType=v26824)}function v1090(funcDecl){return funcDecl.isAccessor()?JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.GetAccessor])?funcDecl.type.call.signatures[0].returnType.type:funcDecl.type.call.signatures[0].parameters[0].getType():null}function v1089(ifStmt){var v3216=ifStmt,v26830=JAM.call(this.typeCheck,this,[ifStmt.cond]);v3216.cond=v26830;JAM.call(this.typeCheckCondExpr,
this,[ifStmt.cond]);v3216=ifStmt;v26830=JAM.call(this.typeCheck,this,[ifStmt.thenBod]);v3216.thenBod=v26830;v3216=ifStmt;v26830=JAM.call(this.typeCheck,this,[ifStmt.elseBod]);v3216.elseBod=v26830;JAM.call(this.typeCheckCompoundStmtBlock,this,[ifStmt.thenBod,"if statement"]);JAM.call(this.typeCheckCompoundStmtBlock,this,[ifStmt.elseBod,"if statement"]);ifStmt.type=this.voidType;return ifStmt}function v1088(stmts,stmtType){var v13329=this.checker.styleSettings.blockInCompoundStmt;v13329&&(v13329=stmts);
v13329&&stmts.nodeType!=TypeScript.NodeType.Block&&(v13329=this.checker.errorReporter,JAM.call(v13329.styleError,v13329,[stmts,stmtType+" requires a block"]))}function v1087(cond){if(this.checker.styleSettings.assignmentInCond){var v13334=null!==cond;v13334&&(v13334=cond.nodeType>=TypeScript.NodeType.Asg)&&(v13334=cond.nodeType<=TypeScript.NodeType.LastAsg);v13334&&(v13334=this.checker.errorReporter,JAM.call(v13334.simpleError,v13334,[cond,"top-level assignment statement in conditional expression"]))}}
function v1086(doWhileStmt){var v3229=doWhileStmt,v26833=JAM.call(this.typeCheck,this,[doWhileStmt.cond]);v3229.cond=v26833;JAM.call(this.typeCheckCondExpr,this,[doWhileStmt.cond]);v3229=doWhileStmt;v26833=JAM.call(this.typeCheck,this,[doWhileStmt.body]);v3229.body=v26833;JAM.call(this.typeCheckCompoundStmtBlock,this,[doWhileStmt.body,"do while statement"]);doWhileStmt.type=this.voidType;return doWhileStmt}function v1085(whileStmt){var v3233=whileStmt,v26835=JAM.call(this.typeCheck,this,[whileStmt.cond]);
v3233.cond=v26835;JAM.call(this.typeCheckCondExpr,this,[whileStmt.cond]);v3233=whileStmt;v26835=JAM.call(this.typeCheck,this,[whileStmt.body]);v3233.body=v26835;JAM.call(this.typeCheckCompoundStmtBlock,this,[whileStmt.body,"while statement"]);whileStmt.type=this.voidType;return whileStmt}function v1084(forInStmt){var v3237=forInStmt,v26837=JAM.call(this.typeCheck,this,[forInStmt.obj]);v3237.obj=v26837;v3237=forInStmt;v26837=JAM.call(this.cast,this,[JAM.call(this.typeCheck,this,[forInStmt.lval]),this.checker.stringType]);
v3237.lval=v26837;forInStmt.lval.nodeType==TypeScript.NodeType.VarDecl&&(v3237=forInStmt.lval,v3237.typeExpr&&(v26837=this.checker.errorReporter,JAM.call(v26837.simpleError,v26837,[v3237,"Variable declarations for for/in expressions may not contain a type annotation"])),v3237.sym&&(v3237=v3237.sym,JAM.call(v3237.setType,v3237,[this.checker.stringType])));v3237=forInStmt;v26837=JAM.call(this.typeCheck,this,[forInStmt.body]);v3237.body=v26837;JAM.call(this.typeCheckCompoundStmtBlock,this,[forInStmt.body,
"for in statement"]);return forInStmt}function v1083(withStmt){if(this.checker.errorsOnWith){var v3247=this.checker.errorReporter;JAM.call(v3247.simpleError,v3247,[withStmt.expr,"All symbols within a 'with' block will be typed as 'any'"])}var v3247=withStmt,v26840=JAM.call(this.typeCheck,this,[withStmt.expr]);v3247.expr=v26840;this.checker.inWith=!0;v3247=withStmt;v26840=JAM.call(this.typeCheck,this,[withStmt.body]);v3247.body=v26840;JAM.call(this.typeCheckCompoundStmtBlock,this,[withStmt.body,"with statement"]);
this.checker.inWith=!1;return withStmt}function v1082(forStmt){var v3255=forStmt,v26842=JAM.call(this.typeCheck,this,[forStmt.init]);v3255.init=v26842;this.nestingLevel+=1;v3255=forStmt;v26842=JAM.call(this.typeCheck,this,[forStmt.cond]);v3255.cond=v26842;JAM.call(this.typeCheckCondExpr,this,[forStmt.cond]);v3255=forStmt;v26842=JAM.call(this.typeCheck,this,[forStmt.incr]);v3255.incr=v26842;this.nestingLevel-=1;v3255=forStmt;v26842=JAM.call(this.typeCheck,this,[forStmt.body]);v3255.body=v26842;JAM.call(this.typeCheckCompoundStmtBlock,
this,[forStmt.body,"for statement"]);forStmt.type=this.voidType;return forStmt}function v1081(moduleDecl){if(!moduleDecl.mod)return moduleDecl;this.currentScript&&(this.currentScript.requiresGlobal=!0);var mod=moduleDecl.mod,sym=null,prevScope=this.scope,prevThisType=this.thisType,prevCurrentModDecl=this.checker.currentModDecl;this.checker.currentModDecl=moduleDecl;this.thisType=null;this.scope=mod.containedScope;JAM.call(this.typeCheck,this,[moduleDecl.members]);sym=mod.symbol;this.checker.currentModDecl=
prevCurrentModDecl;this.thisType=prevThisType;this.scope=prevScope;moduleDecl.type=mod;sym&&(sym.typeCheckStatus=TypeScript.TypeCheckStatus.Finished);return moduleDecl}function v1080(importDecl){var mod=importDecl.alias.type,sym=null,prevInImportTC=this.inImportTypeCheck;this.inImportTypeCheck=!0;JAM.call(this.typeCheck,this,[importDecl.alias]);mod=importDecl.alias.type;null==mod&&(mod=this.checker.errorReporter,JAM.call(mod.simpleError,mod,[importDecl.alias,"Could not resolve module alias '"+importDecl.id.actualText+
"'"]),mod=this.checker.anyType,importDecl.id.sym.type=mod);importDecl.id.type=mod;sym=mod.symbol;if(mod.isModuleType()){sym.type=mod;if(sym=this.checker.typeFlow.currentScript)if(sym=this.checker.typeFlow.currentScript.topLevelMod)sym=this.checker.typeFlow.currentScript.topLevelMod.mod;sym&&(sym=this.checker.typeFlow.currentScript.topLevelMod.mod.importedModules,JAM.call(sym.push,sym,[importDecl]));importDecl.id.sym.type=mod;if(sym=mod.symbol)sym=mod.symbol.declAST;sym&&(mod=mod.symbol.declAST,mod.modFlags&=
~TypeScript.ModuleFlags.ShouldEmitModuleDecl)}else mod=this.checker.errorReporter,JAM.call(mod.simpleError,mod,[importDecl.alias,"A module cannot be aliased to a non-module type"]);this.inImportTypeCheck=prevInImportTC;return importDecl}function v1079(interfaceDecl){JAM.call(this.typeCheckBases,this,[interfaceDecl.type]);JAM.call(this.typeCheckBaseListPrivacy,this,[interfaceDecl.extendsList,interfaceDecl.type.symbol,!0]);JAM.call(this.typeCheck,this,[interfaceDecl.members]);JAM.call(this.checkBaseTypeMemberInheritance,
this,[interfaceDecl.type,interfaceDecl]);if(interfaceDecl.extendsList)for(var i=0,v3304=i<interfaceDecl.extendsList.members.length;v3304;){v3304=interfaceDecl.extendsList.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v3304=v3304[i];if(v3304.type.call)if(interfaceDecl.type.call){var v3304=interfaceDecl.type.call,v13374=interfaceDecl.type.call.signatures,v25782=interfaceDecl.extendsList.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25782=v25782[i];
v13374=v13374.concat(v25782.type.call.signatures);v3304.signatures=v13374}else{v3304=interfaceDecl.type;v13374=interfaceDecl.extendsList.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v13374=v13374[i];v3304.call=v13374.type.call}v3304=interfaceDecl.extendsList.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v3304=v3304[i];if(v3304.type.construct)if(interfaceDecl.type.construct){v3304=interfaceDecl.type.construct;v13374=interfaceDecl.type.construct.signatures;
v25782=interfaceDecl.extendsList.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25782=v25782[i];v13374=v13374.concat(v25782.type.construct.signatures);v3304.signatures=v13374}else{v3304=interfaceDecl.type;v13374=interfaceDecl.extendsList.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v13374=v13374[i];v3304.construct=v13374.type.construct}v3304=interfaceDecl.extendsList.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v3304=
v3304[i];if(v3304.type.index)if(interfaceDecl.type.index){v3304=interfaceDecl.type.index;v13374=interfaceDecl.type.index.signatures;v25782=interfaceDecl.extendsList.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25782=v25782[i];v13374=v13374.concat(v25782.type.index.signatures);v3304.signatures=v13374}else{v3304=interfaceDecl.type;v13374=interfaceDecl.extendsList.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v13374=v13374[i];v3304.index=v13374.type.index}i+=
1;v3304=i<interfaceDecl.extendsList.members.length}return interfaceDecl}function v1078(type,ast){if(type.call){var v3306=type.call;JAM.call(v3306.typeCheck,v3306,[this.checker,ast,null!=type.construct])}type.construct&&(v3306=type.construct,JAM.call(v3306.typeCheck,v3306,[this.checker,ast,!1]));type.index&&(v3306=type.index,JAM.call(v3306.typeCheck,v3306,[this.checker,ast,!1]))}function v1077(classDecl){var typeSymbol=classDecl.type.symbol;if(typeSymbol.typeCheckStatus==TypeScript.TypeCheckStatus.Finished||
typeSymbol.typeCheckStatus==TypeScript.TypeCheckStatus.Started)return classDecl;typeSymbol.typeCheckStatus=TypeScript.TypeCheckStatus.Started;var v3318=this.checker;JAM.call(v3318.addStartedPTO,v3318,[typeSymbol]);var v3318=this.scope,svClassNode=this.thisClassNode;this.thisClassNode=classDecl;var classType=classDecl.type;JAM.call(this.typeCheckBases,this,[classType.instanceType]);JAM.call(this.typeCheckBaseListPrivacy,this,[classDecl.extendsList,typeSymbol,!0]);JAM.call(this.typeCheckBaseListPrivacy,
this,[classDecl.implementsList,typeSymbol,!1]);var prevThisType=this.thisType;this.thisType=classType.instanceType;this.scope=classType.instanceType.containedScope;if(classDecl.constructorDecl){var ssb=this.scope=classType.instanceType.constructorScope,ssb=ssb.valueMembers.allMembers;JAM.call(this.addConstructorLocalArgs,this,[classDecl.constructorDecl.type.symbol,classDecl.constructorDecl.arguments,ssb,!0])}JAM.call(this.typeCheck,this,[classDecl.members]);typeSymbol.typeCheckStatus=TypeScript.TypeCheckStatus.Finished;
JAM.call(this.checkBaseTypeMemberInheritance,this,[classType,classDecl]);JAM.call(this.checkMembersImplementInterfaces,this,[classType]);JAM.call(this.typeCheckOverloadSignatures,this,[classType,classDecl]);JAM.call(this.typeCheckOverloadSignatures,this,[classType.instanceType,classDecl]);classDecl.constructorDecl||((typeSymbol=classDecl.extendsList)&&(typeSymbol=classDecl.extendsList.members.length)&&(typeSymbol=classDecl.extendsList.members[0].type)&&(typeSymbol=classDecl.extendsList.members[0].type.symbol.type.isClass()),
typeSymbol&&JAM.call(TypeScript.cloneParentConstructGroupForChildType,TypeScript,[classDecl.type,classDecl.extendsList.members[0].type.symbol.type]));this.thisType=prevThisType;this.thisClassNode=svClassNode;this.scope=v3318;return classDecl}function v1076(derivedType,derivedTypeDecl){function v1075(key,s,c){key=s;s=0;for(c=s<len;c;){c=instanceType.extendsList;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)c=c[s];if(null==c.memberScope){var v3338=_this.checker.errorReporter;JAM.call(v3338.simpleError,
v3338,[derivedTypeDecl,"Base type '"+c.symbol.name+"' lacks an implementation."])}else if(c=c.memberScope,c=JAM.call(c.find,c,[key.name,!1,!1])){var v3338=key.getType(),bType=c.getType(),v19382=_this.checker;JAM.call(v19382.sourceIsSubtypeOfTarget,v19382,[v3338,bType])?((v3338=key.kind()==TypeScript.SymbolKind.Type)&&(v3338=c.kind()==TypeScript.SymbolKind.Field),v3338&&(c=_this.checker.errorReporter,JAM.call(c.simpleErrorFromSym,c,[key,"Cannot override field '"+key.name+"' with method"]))):(v3338=
_this.checker.errorReporter,JAM.call(v3338.simpleErrorFromSym,v3338,[key,"Type of overridden member '"+key.name+"' is not subtype of original member defined by type '"+c.container.name+"'"]))}s+=1;c=s<len}}var _this=this,instanceType=derivedType.getInstanceType();if(null!=instanceType.extendsList){var len=instanceType.extendsList.length;if(0<len){var names=new TypeScript.StringHashTable;if(instanceType.isClassInstance())for(var i=0,v3355=i<len;v3355;){v3355=instanceType.extendsList;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v3355=
v3355[i];JAM.call(this.assertUniqueNamesInBaseTypes,this,[names,v3355,derivedTypeDecl,0<i]);i+=1;v3355=i<len}instanceType.members&&(names=instanceType.members.publicMembers,JAM.call(names.map,names,[v1075,null]))}}}function v1074(names,type,classDecl,checkUnique){function v1073(key,s,c){key=s;(s=JAM.call(names.lookup,names,[key.name]))?checkUnique&&(c=_this.checker.errorReporter,JAM.call(c.simpleError,c,[classDecl,"duplicate member name in bases for "+classDecl.name.actualText+": "+type.symbol.name+
" and "+s.container.name+" both contain member with name "+key.name])):JAM.call(names.add,names,[key.name,key])}var _this=this;if(type){if(type.members){var v3364=type.members.publicMembers;JAM.call(v3364.map,v3364,[v1073,null])}if(type.extendsList)for(var v3364=type.extendsList.length,i=0,v3369=i<v3364;v3369;){v3369=type.extendsList;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v3369=v3369[i];if(!(v3369.symbol.flags&TypeScript.SymbolFlags.RecursivelyReferenced)){v3369=type.extendsList;
introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v3369=v3369[i];JAM.call(this.assertUniqueNamesInBaseTypes,this,[names,v3369,classDecl,checkUnique])}i+=1;v3369=i<v3364}}}function v1072(bases){if(null!=bases)for(var basesLen=bases.members.length,i=0,v3375=i<basesLen;v3375;){v3375=bases.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v3375=v3375[i];v3375.nodeType==TypeScript.NodeType.Call&&JAM.call(this.typeCheckNew,this,[v3375]);i+=1;v3375=i<basesLen}}function v1071(implementingType){implementingType=
implementingType.getInstanceType();if(implementingType.implementsList)for(var len=implementingType.implementsList.length,i=0,v3387=i<len;v3387;){v3387=implementingType.implementsList;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var interfaceType=v3387[i];var v3387=new TypeScript.TypeComparisonInfo,v19394=this.checker;JAM.call(v19394.sourceIsSubtypeOfTarget,v19394,[implementingType,interfaceType,v3387])||(interfaceType="Class '"+implementingType.getTypeName()+"' declares interface '"+
interfaceType.getTypeName()+"' but does not implement it",v3387.message?(v19394=this.checker.errorReporter,JAM.call(v19394.simpleErrorFromSym,v19394,[implementingType.symbol,interfaceType+": "+v3387.message])):(v3387=this.checker.errorReporter,JAM.call(v3387.simpleErrorFromSym,v3387,[implementingType.symbol,interfaceType])));i+=1;v3387=i<len}}function v1070(type){var seenInterface=!1,bases=type.extendsList,baseLinks=type.extendsTypeLinks;if(bases){var len=bases.length;0<len&&(type.typeFlags|=TypeScript.TypeFlags.HasBaseType);
for(var i=0,v3413=i<len;v3413;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v3413=bases[i];if(v3413==this.checker.anyType){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v3413=baseLinks[i];v3413.type=null;var v3413=this.checker.errorReporter.errorSink,v3392=TypeScript.CompilerDiagnostics;JAM.call(v3392.assert,v3392,[0==v3413.length,"There shouldnt be any contextual errors when typechecking base type names"]);this.checker.errorReporter.pushToErrorSink=!0;var v3413=
bases,v3392=i,v13435=this.checker;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v13436=baseLinks[i];v13435=JAM.call(v13435.resolveBaseTypeLink,v13435,[v13436,type.containedScope]);v3413[v3392]=v13435;this.checker.errorReporter.pushToErrorSink=!1;this.checker.errorReporter.freeCapturedErrors()}introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v3392=bases[i];introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v3413=baseLinks[i];v3413=v3413.ast;(v13435=
v3392.symbol)&&(v13435="Object"==v3392.symbol.name)&&(v13435=v3392.symbol.container==this.checker.gloMod);v13435&&(type.typeFlags|=TypeScript.TypeFlags.HasBaseTypeOfObject);if(v3392.isClassInstance())type.isClassInstance()?seenInterface&&(v3392=this.checker.errorReporter,JAM.call(v3392.simpleError,v3392,[v3413,"Class may not follow interface as base type"])):(v3392=this.checker.errorReporter,JAM.call(v3392.simpleError,v3392,[v3413,"Interface base type must be interface"]));else if(v3392.isModuleType())v3392=
this.checker.errorReporter,JAM.call(v3392.simpleError,v3392,[v3413,"Types may not be derived from module types"]);else if(v3392.members)seenInterface||(seenInterface=!0);else{type.isClassInstance()?(type=this.checker.errorReporter,JAM.call(type.simpleError,type,[v3413,"Base type must be interface or class"])):(type=this.checker.errorReporter,JAM.call(type.simpleError,type,[v3413,"Interface base type must be interface"]));break}i+=1;v3413=i<len}}}function v1069(funcDecl){function v1068(typeName,isModuleName){return JAM.call(_this.functionReturnTypePrivacyErrorReporter,
_this,[funcDecl,signature,typeName,isModuleName])}function v1067(index){var v13450=funcDecl.returnStatementsWithExpressions;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)index=v13450[index];return index.type}function v1066(index,type){var v13451=funcDecl.returnStatementsWithExpressions;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v13451=v13451[index];v13451.type=type}function v1065(){return funcDecl.returnStatementsWithExpressions.length}function v1064(sym){return sym.kind()==
TypeScript.SymbolKind.Parameter}function v1063(typeName,isModuleName){var v13453=signature.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v13453=v13453[p];return JAM.call(_this.functionArgumentPrivacyErrorReporter,_this,[funcDecl,p,v13453,typeName,isModuleName])}function v1062(typeName,isModuleName){return JAM.call(_this.functionArgumentPrivacyErrorReporter,_this,[funcDecl,p,symbol,typeName,isModuleName])}var _this=this;this.nestingLevel=0;var fnType=funcDecl.type,fgSym=
fnType.symbol,signature=funcDecl.signature,v13454=this.checker;if(JAM.call(v13454.typeStatusIsFinished,v13454,[signature.typeCheckStatus]))return funcDecl;if(signature.typeCheckStatus==TypeScript.TypeCheckStatus.Started){var v13458=!funcDecl.returnTypeAnnotation;if(v13458){var v19404=funcDecl.bod;if(v19404){var v23110=!funcDecl.isSignature();if(v23110){var v24904=!funcDecl.isConstructor;v24904&&(v24904=JAM.call(this.allReturnsAreVoid,this,[funcDecl]));v23110=v24904}v19404=v23110}v13458=v19404}if(v13458)signature.returnType.type=
this.voidType;else if(null==funcDecl.returnTypeAnnotation){if(this.checker.styleSettings.implicitAny){var v3421=this.checker.errorReporter;JAM.call(v3421.styleError,v3421,[funcDecl,"type implicitly set to 'any'"])}signature.returnType.type=this.anyType;fgSym.flags|=TypeScript.SymbolFlags.RecursivelyReferenced}return funcDecl}signature.typeCheckStatus=TypeScript.TypeCheckStatus.Started;var v3429=this.checker;JAM.call(v3429.addStartedPTO,v3429,[signature]);var prevScope=this.scope,prevFnc=this.thisFnc,
prevMethodStatus=this.enclosingFncIsMethod,prevClassNode=this.thisClassNode,v3430=funcDecl.isMethod();v3430||(v3430=funcDecl.isConstructor);this.enclosingFncIsMethod=v3430;this.thisFnc=funcDecl;var container=funcDecl.type.symbol,prevThisType=this.thisType,prevLocationInfo=this.checker.locationInfo,funcTable=null,acceptedContextualType=!1,targetParams=null,targetReturnType=null,v3433=funcDecl.isAccessor();v3433&&(v3433=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.GetAccessor]));
var isGetter=v3433,v3434=funcDecl.isAccessor();v3434&&(v3434=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.SetAccessor]));var isSetter=v3434,v3435,v19409=isGetter||isSetter;v19409&&(v19409=funcDecl.accessorSymbol);var accessorType=v3435=v19409?funcDecl.accessorSymbol.getType():null,prevModDecl=this.checker.currentModDecl,v13471=funcDecl.isConstructor;v13471&&(v13471=!funcDecl.isOverload);if(v13471){if(null==fnType.instanceType){var v3437=this.checker.errorReporter;
JAM.call(v3437.simpleError,v3437,[funcDecl,"Malformed function body (is this a class named the same as an existing interface?)"]);return funcDecl}var ssb=this.scope=fnType.instanceType.constructorScope,funcTable=ssb.valueMembers.allMembers}else{var v19411=funcDecl.isSpecialFn();v19411&&(v19411=!(funcDecl.fncFlags&TypeScript.FncFlags.Signature));var v13474=v19411;v13474||(v13474=funcDecl.isOverload);if(v13474){var funcTable=funcDecl.symbols,v13475=!JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,
TypeScript.FncFlags.Static]);v13475&&(v13475=fnType.containedScope);v13475&&(this.scope=fnType.containedScope)}else{funcDecl.bod&&(this.scope=fnType.containedScope);var v13476=ssb=this.scope;v13476&&(v13476=ssb.valueMembers);v13476&&(funcTable=ssb.valueMembers.allMembers)}}var v13477=funcDecl.isConstructor;if(v13477){var v19414=funcDecl.bod;v19414&&(v19414=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.ClassMethod]));v13477=v19414}if(v13477){var hasBaseType=JAM.call(TypeScript.hasFlag,
TypeScript,[funcDecl.classDecl.type.instanceType.typeFlags,TypeScript.TypeFlags.HasBaseType]),v3449=!hasBaseType;v3449||(v3449=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.classDecl.type.instanceType.typeFlags,TypeScript.TypeFlags.HasBaseTypeOfObject]));var noSuperCallAllowed=v3449,superCallMustBeFirst=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.classDecl.varFlags,TypeScript.VarFlags.ClassSuperMustBeFirstCallInConstructor]),v13485=noSuperCallAllowed;v13485&&(v13485=JAM.call(this.classConstructorHasSuperCall,
this,[funcDecl]));if(v13485){var v3452=this.checker.errorReporter;JAM.call(v3452.simpleError,v3452,[funcDecl,"Calls to 'super' constructor are not allowed in classes that either inherit directly from 'Object' or have no base class"])}else if(hasBaseType)if(superCallMustBeFirst){var v13487=!funcDecl.bod;if(!v13487){var v19419=!funcDecl.bod.members.length;if(!v19419){var v25794=funcDecl.bod.members[0].nodeType==TypeScript.NodeType.Call;v25794&&(v25794=funcDecl.bod.members[0].target.nodeType==TypeScript.NodeType.Super);
var v24911=v25794;if(!v24911){var v25795=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.bod.flags,TypeScript.ASTFlags.StrictMode]);if(v25795){var v26284=1<funcDecl.bod.members.length;if(v26284){var v26524=funcDecl.bod.members[1].nodeType==TypeScript.NodeType.Call;v26524&&(v26524=funcDecl.bod.members[1].target.nodeType==TypeScript.NodeType.Super);v26284=v26524}v25795=v26284}v24911=v25795}v19419=!v24911}v13487=v19419}if(v13487){var v3453=this.checker.errorReporter;JAM.call(v3453.simpleError,v3453,
[funcDecl,"If a derived class contains initialized properties or constructor parameter properties, the first statement in the constructor body must be a call to the super constructor"])}}else if(!JAM.call(this.classConstructorHasSuperCall,this,[funcDecl])){var v3455=this.checker.errorReporter;JAM.call(v3455.simpleError,v3455,[funcDecl,"Constructors for derived classes must contain a call to the class's 'super' constructor"])}}var v13491=funcDecl.isMethod();v13491&&(v13491=funcDecl.type.enclosingType);
if(v13491){var enclosingClassNode=null;funcDecl.type.enclosingType.symbol.declAST.nodeType==TypeScript.NodeType.FuncDecl?enclosingClassNode=funcDecl.type.enclosingType.symbol.declAST.classDecl:funcDecl.type.enclosingType.symbol.declAST.nodeType==TypeScript.NodeType.ClassDeclaration&&(enclosingClassNode=funcDecl.type.enclosingType.symbol.declAST);enclosingClassNode&&(this.thisClassNode=enclosingClassNode)}if(fnType.enclosingType){var enclosingSym=fnType.symbol.container,v13498=enclosingSym;if(v13498){var v19428=
enclosingSym.isType();v19428&&(v19428=enclosingSym.getType().isClass());v13498=v19428}v13498&&(enclosingSym=enclosingSym.container);var v13499=enclosingSym;if(v13499){var v19429=enclosingSym.declAST;v19429&&(v19429=enclosingSym.declAST.nodeType==TypeScript.NodeType.ModuleDeclaration);v13499=v19429}v13499&&(this.checker.currentModDecl=enclosingSym.declAST)}if(0<funcDecl.unitIndex){var v13501=this.checker.units;v13501&&(v13501=funcDecl.unitIndex<this.checker.units.length);if(v13501){var v3469=this.checker,
v13502=this.checker.units,v13503=funcDecl.unitIndex;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v3469.locationInfo=v13502[v13503]}else this.checker.locationInfo=TypeScript.unknownLocationInfo}this.thisType=fnType.enclosingType?fnType.enclosingType:prevThisType;var paramLen=signature.parameters.length,v13504=!funcDecl.isConstructor;if(v13504){var v19435=funcDecl.bod;v19435&&(v19435=!funcDecl.isSignature());v13504=v19435}if(v13504){var tmpParamScope=this.scope,ssb=this.scope,v13505=
!funcDecl.isMethod();v13505&&(v13505=null==funcDecl.returnTypeAnnotation);if(v13505){var v13506=prevScope;if(v13506){var v19438=funcDecl.name;v19438&&(v19438=!funcDecl.name.isMissing());v13506=v19438}if(v13506){var considerSym=JAM.call(prevScope.findAmbient,prevScope,[funcDecl.name.text,!1,!1]),v13508=considerSym;if(v13508){var v19439=considerSym.declAST;v19439&&(v19439=considerSym.declAST.type);v13508=v19439}if(v13508){var v3476=this.checker;JAM.call(v3476.setContextualType,v3476,[considerSym.declAST.type,
!1])}}if(this.checker.hasTargetType()){var candidateTypeContext=this.checker.currentContextualTypeContext,candidateType=candidateTypeContext.contextualType,v13511=this.checker;if(JAM.call(v13511.canContextuallyTypeFunction,v13511,[candidateType,funcDecl,!0])){var v3481,candidateSigs=v3481=candidateType.construct?candidateType.construct:candidateType.call;candidateTypeContext.targetSig=candidateSigs.signatures[0];var candidateParams=candidateTypeContext.targetSig.parameters,targetParams=candidateParams,
targetReturnType=candidateTypeContext.targetSig.returnType.type;candidateTypeContext.targetSig.declAST&&(candidateTypeContext.targetSig.declAST.isConstructor?funcDecl.isTargetTypedAsMethod=!0:candidateTypeContext.targetSig.declAST.isMethod()&&(funcDecl.isTargetTypedAsMethod=!0));fgSym.type=candidateTypeContext.contextualType;acceptedContextualType=!0}else{var v13517=candidateType;v13517&&(v13517=funcDecl.isAccessor());v13517?(accessorType=candidateType,candidateTypeContext.targetAccessorType=accessorType):
this.checker.killCurrentContextualType()}}}var paramTable=ssb.valueMembers,v26850=JAM.new(TypeScript.SymbolScopeBuilder,[paramTable,null,null,null,prevScope,container]);this.scope=v26850;for(var p=0,v3506=p<paramLen;v3506;){var v3494=signature.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var symbol=v3494[p];var ast=symbol.declAST,v13518=this.checker.hasTargetType();if(v13518){var v19443=targetParams;if(v19443){var v23131=this.checker.currentContextualTypeContext.targetSig.hasVariableArgList;
v23131||(v23131=p<targetParams.length);v19443=v23131}v13518=v19443}if(v13518){var candidateTypeContext=this.checker.currentContextualTypeContext,hasVarArgList=candidateTypeContext.targetSig.hasVariableArgList,v3497=ast,v13519,v23132=hasVarArgList;v23132&&(v23132=p>=targetParams.length-1);if(v23132){var v24922=targetParams.length-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v23133=targetParams[v24922];v13519=v23133.getType().elementType}else{introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v19445=
targetParams[p];v13519=v19445.getType()}v3497.type=v13519;var v3498=ast.sym;JAM.call(v3498.setType,v3498,[ast.type]);var v3500=ast.sym,v26851=this.checker.getTypeCheckFinishedStatus();v3500.typeCheckStatus=v26851}else JAM.call(this.typeCheck,this,[ast]);isSetter&&accessorType&&(ast=JAM.call(this.cast,this,[ast,accessorType]));symbol.container=container;JAM.call(this.checkTypePrivacy,this,[symbol.getType(),container,v1062]);var v3504=paramTable.publicMembers;JAM.call(v3504.add,v3504,[symbol.name,symbol]);
p+=1;v3506=p<paramLen}this.scope=tmpParamScope}else{JAM.call(this.typeCheck,this,[funcDecl.arguments]);for(var p=0,v3513=p<paramLen;v3513;){var v23134=signature.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v19447=v23134[p];var v3508=v19447.parameter.typeLink,v19448=funcDecl.arguments.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v13522=v19448[p];v3508.type=v13522.type;var v19449=signature.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v13523=
v19449[p];JAM.call(this.checkTypePrivacy,this,[v13523.getType(),container,v1063]);var v19450=funcDecl.arguments.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v13524=v19450[p];if(v13524.parameterPropertySym){var v19451=funcDecl.arguments.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v13525=v19451[p];var v3510=v13525.parameterPropertySym,v19452=funcDecl.arguments.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v13526=
v19452[p];JAM.call(v3510.setType,v3510,[v13526.type])}p+=1;v3513=p<paramLen}if(funcDecl.fncFlags&TypeScript.FncFlags.IndexerMember){var v13529=!paramLen;v13529||(v13529=1<paramLen);if(v13529){var v3514=this.checker.errorReporter;JAM.call(v3514.simpleError,v3514,[funcDecl,"Index signatures may take one and only one parameter"])}else if(funcDecl.arguments.members[0].type==this.checker.numberType){var v3515=fnType.index;v3515.flags|=TypeScript.SignatureFlags.IsNumberIndexer}else if(funcDecl.arguments.members[0].type==
this.checker.stringType){var v3516=fnType.index;v3516.flags|=TypeScript.SignatureFlags.IsStringIndexer}else{var v3517=this.checker.errorReporter;JAM.call(v3517.simpleError,v3517,[funcDecl.arguments.members[0],"Index signatures may only take 'string' or 'number' as their parameter"])}}}var v13537=funcDecl.bod;v13537&&(v13537=!funcDecl.isSignature());if(v13537){if(funcDecl.isConstructor){JAM.call(this.addConstructorLocalArgs,this,[funcDecl.type.symbol,funcDecl.arguments,funcTable,JAM.call(TypeScript.hasFlag,
TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.ClassMethod])]);var v13542=this.thisClassNode;v13542&&(v13542=this.thisClassNode.extendsList);if(v13542){var tmpScope=this.scope,funcMembers=JAM.new(TypeScript.ScopedMembers,[funcTable]),v26852=JAM.new(TypeScript.FilteredSymbolScopeBuilder,[funcMembers,prevScope,funcDecl.type.symbol,v1064]);this.scope=v26852;JAM.call(this.typeCheckBaseCalls,this,[this.thisClassNode.extendsList]);this.scope=tmpScope}}else JAM.call(this.addFormals,this,[container,signature,
funcTable]);var prevMod=this.checker.currentModDecl,v13545=funcDecl.type;if(v13545){var v19467=funcDecl.type.symbol;if(v19467){var v23144=!funcDecl.isMethod();v23144&&(v23144=funcDecl.type.symbol.declModule);v19467=v23144}v13545=v19467}v13545&&(this.checker.currentModDecl=funcDecl.type.symbol.declModule);if(acceptedContextualType){var v3536=this.checker;JAM.call(v3536.setContextualType,v3536,[null,this.checker.inProvisionalTypecheckMode()])}JAM.call(this.typeCheck,this,[funcDecl.bod]);acceptedContextualType&&
this.checker.unsetContextualType();this.checker.currentModDecl=prevMod;if(this.checker.checkControlFlow){var cfg=funcDecl.buildControlFlow();this.checker.printControlFlowGraph&&JAM.call(cfg.print,cfg,[this.checker.errorReporter.outfile]);JAM.call(cfg.reportUnreachable,cfg,[this.checker.errorReporter]);this.checker.checkControlFlowUseDef&&JAM.call(cfg.useDef,cfg,[this.checker.errorReporter,funcDecl.type.symbol])}if(funcDecl.isConstructor)for(var fns=funcDecl.scopes,fnsLen=fns.members.length,j=0,v3553=
j<fnsLen;v3553;){var v3549=fns.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var fn=v3549[j];if(!fn.isSignature()){var v13556=JAM.call(TypeScript.hasFlag,TypeScript,[fn.fncFlags,TypeScript.FncFlags.Method]);v13556&&(v13556=!JAM.call(TypeScript.hasFlag,TypeScript,[fn.fncFlags,TypeScript.FncFlags.Static]));v13556&&JAM.call(this.checkPromoteFreeVars,this,[fn,funcDecl.type.symbol])}j+=1;v3553=j<fnsLen}}this.scope=prevScope;this.thisFnc=prevFnc;this.thisClassNode=prevClassNode;
this.enclosingFncIsMethod=prevMethodStatus;this.thisType=prevThisType;this.checker.locationInfo=prevLocationInfo;this.checker.currentModDecl=prevModDecl;var v3558=signature,v26853=this.checker.getTypeCheckFinishedStatus();v3558.typeCheckStatus=v26853;if(funcDecl.returnTypeAnnotation){if(JAM.call(this.checkForVoidConstructor,this,[funcDecl.returnTypeAnnotation.type,funcDecl.returnTypeAnnotation]),null==signature.returnType.type){var v3561=this.checker;JAM.call(v3561.resolveTypeLink,v3561,[this.scope,
signature.returnType,!1])}}else targetReturnType&&(signature.returnType.type=targetReturnType);var v13561=!(fgSym.flags&TypeScript.SymbolFlags.RecursivelyReferenced);v13561&&(v13561=0<funcDecl.returnStatementsWithExpressions.length);if(v13561){var collection={getLength:v1065,setTypeAtIndex:v1066,getTypeAtIndex:v1067},bestCommonReturnType=funcDecl.returnStatementsWithExpressions[0].type,v3568=this.checker;if(bestCommonReturnType=JAM.call(v3568.findBestCommonType,v3568,[bestCommonReturnType,null,collection,
!0])){var v3569=signature.returnType,v13563=this.checker,v26854=JAM.call(v13563.widenType,v13563,[bestCommonReturnType]);v3569.type=v26854}else{for(var i=0,v3572=i<funcDecl.returnStatementsWithExpressions.length;v3572;){var v3570=this.checker.errorReporter,v13566=funcDecl.returnStatementsWithExpressions;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v3571=v13566[i];JAM.call(v3570.simpleError,v3570,[v3571,"Incompatible return type"]);i+=1;v3572=i<funcDecl.returnStatementsWithExpressions.length}signature.returnType.type=
this.anyType}}var onlyHasThrow=!1;if(null==signature.returnType.type)if(JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.HasReturnExpression])){if(this.checker.styleSettings.implicitAny){var v3575=this.checker.errorReporter;JAM.call(v3575.styleError,v3575,[funcDecl,"type implicitly set to 'any'"])}signature.returnType.type=this.anyType}else signature.returnType.type=this.voidType;else{var v13573=signature.returnType.type==this.nullType;v13573||(v13573=signature.returnType.type==
this.checker.undefinedType);if(v13573)signature.returnType.type=this.anyType;else{var v13574=signature.returnType.type!=this.voidType;if(v13574){var v19488=signature.returnType.type!=this.checker.undefinedType;v19488&&(v19488=signature.returnType.type!=this.anyType);v13574=v19488}if(v13574){var v13575=!funcDecl.isSignature();if(v13575){var v19490=!funcDecl.isConstructor;if(v19490){var v23160=!JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.HasReturnExpression]);v23160&&
(v23160=!JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.IsFatArrowFunction]));v19490=v23160}v13575=v19490}if(v13575){var v3581=0<funcDecl.bod.members.length;v3581&&(v3581=funcDecl.bod.members[0].nodeType==TypeScript.NodeType.Throw);onlyHasThrow=v3581;if(!onlyHasThrow){var v3582=this.checker.errorReporter,v13580=funcDecl.returnTypeAnnotation;v13580||(v13580=funcDecl);JAM.call(v3582.simpleError,v3582,[v13580,"Function declared a non-void return type, but has no return expression"])}}JAM.call(this.checkTypePrivacy,
this,[signature.returnType.type,container,v1068])}}}if(funcDecl.accessorSymbol){var accessorType=funcDecl.accessorSymbol.getType(),v13582=!onlyHasThrow;if(v13582){var v19495=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.GetAccessor]);v19495&&(v19495=!JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.HasReturnExpression]));v13582=v19495}if(v13582){var v3591=this.checker.errorReporter;JAM.call(v3591.simpleError,v3591,[funcDecl,"Getters must return a value"])}if(accessorType){var v19496=
JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.GetAccessor]);v19496&&(v19496=accessorType!=signature.returnType.type);var v13584=v19496;if(!v13584){var v19497=0<funcDecl.arguments.members.length;v19497&&(v19497=accessorType!=funcDecl.arguments.members[0].type);v13584=v19497}if(v13584){var v3593=this.checker.errorReporter;JAM.call(v3593.simpleError,v3593,[funcDecl,"Getter and setter types do not agree"])}}else if(JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,
TypeScript.FncFlags.GetAccessor])){var v3595=funcDecl.accessorSymbol;JAM.call(v3595.setType,v3595,[signature.returnType.type])}else if(1!=funcDecl.arguments.members.length){var v3597=this.checker.errorReporter;JAM.call(v3597.simpleError,v3597,[funcDecl,"Setters may have one and only one argument"])}else{var v3598=funcDecl.accessorSymbol;JAM.call(v3598.setType,v3598,[funcDecl.arguments.members[0].type])}}JAM.call(this.typeCheckOverloadSignatures,this,[fnType,funcDecl]);return funcDecl}function v1061(funcDecl,
signature,typeName,isModuleName){var reportOnFuncDecl=!1,v13592=null!=funcDecl.returnTypeAnnotation;v13592&&(v13592=funcDecl.returnTypeAnnotation.type==signature.returnType.type);v13592&&JAM.call(this.returnTypePrivacyError,this,[funcDecl.returnTypeAnnotation,funcDecl,typeName,isModuleName]);for(var v13592=0,v3607=v13592<funcDecl.returnStatementsWithExpressions.length;v3607;){v3607=funcDecl.returnStatementsWithExpressions;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v3607=v3607[v13592];
if(v3607.type==signature.returnType.type){v3607=funcDecl.returnStatementsWithExpressions;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v3607=v3607[v13592];JAM.call(this.returnTypePrivacyError,this,[v3607,funcDecl,typeName,isModuleName])}else reportOnFuncDecl=!0;v13592+=1;v3607=v13592<funcDecl.returnStatementsWithExpressions.length}reportOnFuncDecl&&JAM.call(this.returnTypePrivacyError,this,[funcDecl,funcDecl,typeName,isModuleName])}function v1060(astError,funcDecl,typeName,isModuleName){var v3608=
funcDecl.isAccessor();v3608&&(v3608=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.GetAccessor]));var isGetter=v3608;(v3608=funcDecl.isAccessor())&&(v3608=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.SetAccessor]));var isSetter=v3608,isPublicFunc=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.Public]),v3608=funcDecl.type.symbol,isContainerInterface=null!=JAM.call(v3608.getInterfaceDeclFromSymbol,v3608,[this.checker]),
v3608="";isModuleName?(v3608="",JAM.call(TypeScript.isQuoted,TypeScript,[typeName])||(v3608="'"),v3608=" is using inaccessible module "+v3608+typeName+v3608):v3608=" has or is using private type '"+typeName+"'";isContainerInterface?funcDecl.isConstructMember()?(funcDecl=this.checker.errorReporter,JAM.call(funcDecl.simpleError,funcDecl,[astError,"exported interface's constructor return type"+v3608])):funcDecl.isCallMember()?(funcDecl=this.checker.errorReporter,JAM.call(funcDecl.simpleError,funcDecl,
[astError,"exported interface's call return type"+v3608])):funcDecl.isIndexerMember()?(funcDecl=this.checker.errorReporter,JAM.call(funcDecl.simpleError,funcDecl,[astError,"exported interface's indexer return type"+v3608])):(funcDecl=this.checker.errorReporter,JAM.call(funcDecl.simpleError,funcDecl,[astError,"exported interface's function return type"+v3608])):isGetter?(funcDecl=this.checker.errorReporter,typeName=isPublicFunc?"public":"exported",JAM.call(funcDecl.simpleError,funcDecl,[astError,typeName+
" getter return type"+v3608])):isSetter||(funcDecl=this.checker.errorReporter,typeName=isPublicFunc?"public":"exported",JAM.call(funcDecl.simpleError,funcDecl,[astError,typeName+" function return type"+v3608]))}function v1059(funcDecl,p,paramSymbol,typeName,isModuleName){var v3633=funcDecl.isAccessor();v3633&&(v3633=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.GetAccessor]));var isGetter=v3633;(v3633=funcDecl.isAccessor())&&(v3633=JAM.call(TypeScript.hasFlag,TypeScript,
[funcDecl.fncFlags,TypeScript.FncFlags.SetAccessor]));var isSetter=v3633,isPublicFunc=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.Public]),v3633=funcDecl.type.symbol,isContainerInterface=null!=JAM.call(v3633.getInterfaceDeclFromSymbol,v3633,[this.checker]),v3633="";isModuleName?(v3633="",JAM.call(TypeScript.isQuoted,TypeScript,[typeName])||(v3633="'"),v3633=" is using inaccessible module "+v3633+typeName+v3633):v3633=" has or is using private type '"+typeName+"'";
if(!isContainerInterface)if(funcDecl.isConstructor){isPublicFunc=this.checker.errorReporter;funcDecl=funcDecl.arguments.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)p=funcDecl[p];JAM.call(isPublicFunc.simpleError,isPublicFunc,[p,"exported class's constructor parameter '"+paramSymbol.name+"'"+v3633])}else if(isSetter){typeName=this.checker.errorReporter;funcDecl=funcDecl.arguments.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)p=funcDecl[p];funcDecl=
isPublicFunc?"public":"exported";JAM.call(typeName.simpleError,typeName,[p,funcDecl+" setter parameter '"+paramSymbol.name+"'"+v3633])}else{if(!isGetter){typeName=this.checker.errorReporter;funcDecl=funcDecl.arguments.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)p=funcDecl[p];funcDecl=isPublicFunc?"public":"exported";JAM.call(typeName.simpleError,typeName,[p,funcDecl+" function parameter '"+paramSymbol.name+"'"+v3633])}}else if(funcDecl.isConstructMember()){isPublicFunc=
this.checker.errorReporter;funcDecl=funcDecl.arguments.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)p=funcDecl[p];JAM.call(isPublicFunc.simpleError,isPublicFunc,[p,"exported interface's constructor parameter '"+paramSymbol.name+"'"+v3633])}else if(funcDecl.isCallMember()){isPublicFunc=this.checker.errorReporter;funcDecl=funcDecl.arguments.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)p=funcDecl[p];JAM.call(isPublicFunc.simpleError,isPublicFunc,
[p,"exported interface's call parameter '"+paramSymbol.name+"'"+v3633])}else if(!funcDecl.isIndexerMember()){isPublicFunc=this.checker.errorReporter;funcDecl=funcDecl.arguments.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)p=funcDecl[p];JAM.call(isPublicFunc.simpleError,isPublicFunc,[p,"exported interface's function parameter '"+paramSymbol.name+"'"+v3633])}}function v1058(sgroup,declSymbol,errorCallback){if(sgroup)for(var len=sgroup.signatures.length,i=0,v3674=i<sgroup.signatures.length;v3674;){v3674=
sgroup.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v3674=v3674[i];var v13644=1<len;v13644&&(v13644=v3674==sgroup.definitionSignature);if(!v13644){v3674.returnType&&JAM.call(this.checkTypePrivacy,this,[v3674.returnType.type,declSymbol,errorCallback]);for(var v13644=v3674.parameters.length,j=0,v3673=j<v13644;v3673;){v3673=v3674.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v3673=v3673[j];JAM.call(this.checkTypePrivacy,this,[v3673.getType(),
declSymbol,errorCallback]);j+=1;v3673=j<v13644}}i+=1;v3674=i<sgroup.signatures.length}}function v1057(type,declSymbol,errorCallback){function v1056(key,s,unused){key=s;JAM.call(TypeScript.hasFlag,TypeScript,[key.flags,TypeScript.SymbolFlags.BuiltIn])||JAM.call(_this.checkTypePrivacy,_this,[key.getType(),declSymbol,errorCallback])}var _this=this,v19535=type;v19535&&(v19535=type.primitiveTypeClass==TypeScript.Primitive.None);if(v19535){if(type.isArray())return JAM.call(this.checkTypePrivacy,this,[type.elementType,
declSymbol,errorCallback]);if(v19535=type.symbol)if(v19535=type.symbol.name)if(v19535="_anonymous"!=type.symbol.name)(v19535=null==type.call)&&(v19535=null==type.construct)&&(v19535=null==type.index),v19535||(v19535=type.members)&&(v19535=!type.isClass());if(v19535)return JAM.call(this.checkSymbolPrivacy,this,[type.symbol,declSymbol,errorCallback]);type.members&&(v19535=type.members.allMembers,JAM.call(v19535.map,v19535,[v1056,null]));JAM.call(this.checkSignatureGroupPrivacy,this,[type.call,declSymbol,
errorCallback]);JAM.call(this.checkSignatureGroupPrivacy,this,[type.construct,declSymbol,errorCallback]);JAM.call(this.checkSignatureGroupPrivacy,this,[type.index,declSymbol,errorCallback])}}function v1055(typeSymbol,declSymbol,errorCallback){var externalModuleSymbol=null,declSymbolPath=null;if(JAM.call(typeSymbol.isExternallyVisible,typeSymbol,[this.checker])){var typeSymbolPath=typeSymbol.pathToRoot(),declSymbolPath=declSymbol.pathToRoot(),typeSymbolLength=typeSymbolPath.length,declSymbolPathLength=
declSymbolPath.length;if(0<typeSymbolLength){var v24947=typeSymbolLength-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v24947=typeSymbolPath[v24947];if(v24947=v24947.getType().isModuleType()){v24947=typeSymbolLength-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v24947=typeSymbolPath[v24947];if(v24947=v24947.isDynamic){v24947=typeSymbolLength-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v24947=typeSymbolPath[v24947];var v24950=declSymbolPathLength-
1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v24950=declSymbolPath[v24950];v24947=v24947!=v24950}}if(v24947)externalModuleSymbol=typeSymbolPath[typeSymbolLength-1];else if(1<typeSymbolLength){v24947=typeSymbolLength-2;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v24947=typeSymbolPath[v24947];if(v24947=v24947.getType().isModuleType()){v24947=typeSymbolLength-2;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v24947=typeSymbolPath[v24947];if(v24947=
v24947.isDynamic)if(v24947=1==declSymbolPathLength,!v24947){v24947=typeSymbolLength-2;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v24947=typeSymbolPath[v24947];declSymbolPathLength-=2;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)declSymbolPathLength=declSymbolPath[declSymbolPathLength];v24947=v24947!=declSymbolPathLength}}v24947&&(externalModuleSymbol=typeSymbolPath[typeSymbolLength-2])}}if(null==externalModuleSymbol)return}(typeSymbolLength=typeSymbolPath=JAM.call(declSymbol.getInterfaceDeclFromSymbol,
declSymbol,[this.checker]))&&(typeSymbolLength=!JAM.call(TypeScript.hasFlag,TypeScript,[typeSymbolPath.varFlags,TypeScript.VarFlags.Exported]));if(!typeSymbolLength){typeSymbolPath=declSymbol;if(typeSymbolLength=declSymbol.getVarDeclFromSymbol()){if(JAM.call(TypeScript.hasFlag,TypeScript,[typeSymbolLength.varFlags,TypeScript.VarFlags.Private]))return;JAM.call(TypeScript.hasFlag,TypeScript,[typeSymbolLength.varFlags,TypeScript.VarFlags.Public])&&(typeSymbolPath=declSymbol.container)}if(JAM.call(typeSymbolPath.isExternallyVisible,
typeSymbolPath,[this.checker])){declSymbol=typeSymbol.name;if(null!=externalModuleSymbol){declSymbolPath=JAM.call(externalModuleSymbol.getPrettyNameOfDynamicModule,externalModuleSymbol,[declSymbolPath]);if(null!=declSymbolPath){typeSymbol=this.currentScript;JAM.call(typeSymbol.AddExternallyVisibleImportedSymbol,typeSymbol,[declSymbolPath.symbol,this.checker]);return}declSymbol=externalModuleSymbol.prettyName}JAM.call(errorCallback,null,[declSymbol,typeSymbol.name!=declSymbol])}}}function v1054(bases,
declSymbol,extendsList){function v1053(typeName,isModuleName){return JAM.call(_this.baseListPrivacyErrorReporter,_this,[bases,i,declSymbol,extendsList,typeName,isModuleName])}var _this=this;if(bases)for(var basesLen=bases.members.length,i=0,v3709=i<basesLen;v3709;){v3709=bases.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v3709=v3709[i];v3709=!v3709.type;if(!v3709){v3709=bases.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v3709=v3709[i];v3709=v3709.type==
this.checker.anyType}if(!v3709){v3709=bases.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v3709=v3709[i];JAM.call(this.checkSymbolPrivacy,this,[v3709.type.symbol,declSymbol,v1053])}i+=1;v3709=i<basesLen}}function v1052(bases,i,declSymbol,extendsList,typeName,isModuleName){var v19549=bases.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v19549=v19549[i];var baseSymbol=v19549.type.symbol,v19549=declSymbol.declAST.nodeType==TypeScript.NodeType.InterfaceDeclaration?
"interface":"class";extendsList=extendsList?"extends":"implements";baseSymbol=baseSymbol.declAST.nodeType==TypeScript.NodeType.InterfaceDeclaration?"interface":"class";isModuleName?(isModuleName="",JAM.call(TypeScript.isQuoted,TypeScript,[typeName])||(isModuleName="'"),baseSymbol=" "+baseSymbol+" from private module "+isModuleName+typeName+isModuleName):baseSymbol=" private "+baseSymbol+" '"+typeName+"'";typeName=this.checker.errorReporter;bases=bases.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)i=
bases[i];JAM.call(typeName.simpleError,typeName,[i,"exported "+v19549+" '"+declSymbol.name+"' "+extendsList+baseSymbol])}function v1051(funcDecl){function preFindSuperCall(ast,parent,walker){parent=!0;switch(ast.nodeType){case TypeScript.NodeType.FuncDecl:parent=!1;break;case TypeScript.NodeType.Call:var call=ast;call.target.nodeType==TypeScript.NodeType.Super&&(parent=!1,foundSuper=!0)}walker.options.goChildren=parent;return ast}var foundSuper=!1,v3723=TypeScript.getAstWalkerFactory();JAM.call(v3723.walk,
v3723,[funcDecl.bod,preFindSuperCall]);return foundSuper}function v1050(funcDecl){function v1049(ast,parent,walker){parent=!0;switch(ast.nodeType){case TypeScript.NodeType.FuncDecl:parent=!1;break;case TypeScript.NodeType.Return:var returnStmt=ast;returnStmt.returnExpression&&(parent=allReturnsAreVoid=!1)}walker.options.goChildren=parent;walker.options.goNextSibling=parent;return ast}var allReturnsAreVoid=!0;if(null==funcDecl.signature.returnType.type){var preFindReturnExpressionTypes=v1049,v3729=
TypeScript.getAstWalkerFactory();JAM.call(v3729.walk,v3729,[funcDecl.bod,preFindReturnExpressionTypes])}return allReturnsAreVoid}function v1048(funcDecl,constructorSym){for(var freeVars=funcDecl.freeVariables,k=0,len=freeVars.length,v3739=k<len;v3739;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v3739=freeVars[k];var v13676=!v3739.isInstanceProperty();v13676&&(v13676=v3739.container==constructorSym);v13676&&(TypeScript.instanceFilter.reset(),v13676=this.scope,JAM.call(v13676.search,
v13676,[TypeScript.instanceFilter,v3739.name,!1,!1])&&(v13676=this.checker.errorReporter,JAM.call(v13676.simpleError,v13676,[funcDecl,"Constructor-local variable shadows class property '"+v3739.name+"'. To access the class property, use 'self."+v3739.name+"'"])),v13676=this.checker.errorReporter,JAM.call(v13676.simpleError,v13676,[funcDecl,"Constructor-local variables may not be accessed from instance method bodies. Consider changing local variable '"+v3739.name+"' to a class property"]));k+=1;v3739=
k<len}}function v1047(funcDecl){if(!funcDecl.isMethod())for(var freeVars=funcDecl.freeVariables,k=0,len=freeVars.length,v3741=k<len;v3741;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v3741=freeVars[k];if(v3741.isInstanceProperty())return!0;k+=1;v3741=k<len}funcDecl=funcDecl.scopes;freeVars=funcDecl.members.length;k=0;for(len=k<freeVars;len;){len=funcDecl.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)len=len[k];if(JAM.call(this.checkInitSelf,this,[len]))return!0;
k+=1;len=k<freeVars}return!1}function v1046(container,args,table,isClass){if(args)for(var len=args.members.length,i=0,v3761=i<len;v3761;){v3761=args.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v3761=v3761[i];var v13685=null==v3761.sym;v13685||(v13685=isClass)||(v13685=v3761.sym.kind()!=TypeScript.SymbolKind.Field);if(v13685)if(v13685=null,null==(v13685=JAM.call(table.lookup,table,[v3761.id.text]))){JAM.call(this.resolveBoundDecl,this,[v3761]);var v3750=v13685=new TypeScript.ValueLocation,
v26855=new TypeScript.TypeLink;v3750.typeLink=v26855;v3750=JAM.new(TypeScript.ParameterSymbol,[v3761.id.text,v3761.minChar,this.checker.locationInfo.unitIndex,v13685]);v3750.declAST=v3761;v13685.symbol=v3750;v13685.typeLink.type=v3761.type;v13685.symbol.container=container;v3761.sym=v13685.symbol;JAM.call(table.add,table,[v3761.id.text,v3750])}else v3750=v3761,v26855=v13685.getType(),v3750.type=v26855,v3761.sym=v13685;i+=1;v3761=i<len}}function v1045(scope,container,vars,table,isModContainer){for(var len=
vars.members.length,hasArgsDef=!1,i=0,v3787=i<len;v3787;){v3787=vars.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v3787=v3787[i];var v13691=null==v3787.sym;v13691||(v13691=v3787.sym.kind()!=TypeScript.SymbolKind.Field);if(v13691)if(v13691=null,null==(v13691=JAM.call(table.lookup,table,[v3787.id.text]))){var v3765=v13691=new TypeScript.ValueLocation,v26857=new TypeScript.TypeLink;v3765.typeLink=v26857;v3765=null;JAM.call(TypeScript.hasFlag,TypeScript,[v3787.varFlags,TypeScript.VarFlags.Static])?
(v3787.varFlags|=TypeScript.VarFlags.LocalStatic,v3765=JAM.new(TypeScript.FieldSymbol,[v3787.id.text,v3787.minChar,this.checker.locationInfo.unitIndex,!0,v13691])):v3765=JAM.new(TypeScript.VariableSymbol,[v3787.id.text,v3787.minChar,this.checker.locationInfo.unitIndex,v13691]);JAM.call(v3765.transferVarFlags,v3765,[v3787.varFlags]);v13691.symbol=v3765;v3765.declAST=v3787;v13691.typeLink.ast=v3787.typeExpr;v26857=this.checker;JAM.call(v26857.resolveTypeLink,v26857,[scope,v13691.typeLink,!1]);(v26857=
null==v3787.type)&&(v26857=null==v3787.init);v26857&&(v3787.type=this.anyType);v13691.typeLink.type=v3787.type;v13691.symbol.container=container;v3787.sym=v13691.symbol;JAM.call(table.add,table,[v3787.id.text,v3765]);"arguments"==v3787.id.text&&(hasArgsDef=!0)}else v3765=v3787,v26857=v13691.getType(),v3765.type=v26857,v3787.sym=v13691;i+=1;v3787=i<len}isModContainer||hasArgsDef||(isModContainer=container=new TypeScript.ValueLocation,len=new TypeScript.TypeLink,isModContainer.typeLink=len,vars=JAM.new(TypeScript.VariableSymbol,
["arguments",vars.minChar,this.checker.locationInfo.unitIndex,container]),this.iargumentsInterfaceType||((scope=JAM.call(scope.find,scope,["IArguments",!1,!0]))?(scope.flags|=TypeScript.SymbolFlags.CompilerGenerated,this.iargumentsInterfaceType=scope=scope.getType()):this.iargumentsInterfaceType=this.anyType),container.typeLink.type=this.iargumentsInterfaceType,JAM.call(table.add,table,["arguments",vars]))}function v1044(container,signature,table){for(var len=signature.parameters.length,i=0,v3800=
i<len;v3800;){v3800=signature.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v3800=v3800[i];v3800.container=container;JAM.call(table.add,table,[v3800.name,v3800]);i+=1;v3800=i<len}}function v1043(trinex){var v3801=trinex,v26861=JAM.call(this.typeCheck,this,[trinex.operand1]);v3801.operand1=v26861;v3801=trinex;v26861=JAM.call(this.typeCheck,this,[trinex.operand2]);v3801.operand2=v26861;v3801=trinex;v26861=JAM.call(this.typeCheck,this,[trinex.operand3]);v3801.operand3=v26861;
v3801=trinex.operand2.type;v26861=trinex.operand3.type;if(v3801==v26861)trinex.type=v3801;else{var v13713=this.checker;JAM.call(v13713.sourceIsSubtypeOfTarget,v13713,[v3801,v26861])?trinex.type=v26861:(v13713=this.checker,JAM.call(v13713.sourceIsSubtypeOfTarget,v13713,[v26861,v3801])?trinex.type=v3801:(trinex.type=this.anyType,v13713=this.checker.errorReporter,JAM.call(v13713.incompatibleTypes,v13713,[trinex,v3801,v26861,trinex.printLabel(),this.scope])))}return trinex}function v1042(binex,assignment){var v3812=
binex,v26864=JAM.call(this.cast,this,[JAM.call(this.typeCheck,this,[binex.operand1]),this.doubleType]);v3812.operand1=v26864;v3812=binex;v26864=JAM.call(this.cast,this,[JAM.call(this.typeCheck,this,[binex.operand2]),this.doubleType]);v3812.operand2=v26864;(v3812=assignment)&&(v3812=!JAM.call(this.astIsWriteable,this,[binex.operand1]));v3812&&(v3812=this.checker.errorReporter,JAM.call(v3812.valueCannotBeModified,v3812,[binex]));binex.type=this.doubleType;return binex}function v1041(binex){var v3816=
binex,v26866=JAM.call(this.cast,this,[JAM.call(this.typeCheck,this,[binex.operand1]),this.stringType]);v3816.operand1=v26866;v3816=binex;v26866=JAM.call(this.typeCheck,this,[binex.operand2]);v3816.operand2=v26866;(v3816=binex.operand1.type==this.checker.anyType)||(v3816=binex.operand1.type==this.checker.stringType);v3816&&(v3816=binex.operand2.type==this.anyType,v3816||(v3816=this.checker,v3816=JAM.call(v3816.sourceIsSubtypeOfTarget,v3816,[binex.operand2.type,this.objectInterfaceType])));v3816||(v3816=
this.checker.errorReporter,JAM.call(v3816.simpleError,v3816,[binex,"The in operator requires the left operand to be of type Any or the String primitive type, and the right operand to be of type Any or an object type"]));binex.type=this.booleanType;return binex}function v1040(ast){var binex=ast,v3820=binex,v26868=JAM.call(this.typeCheck,this,[binex.operand1]);v3820.operand1=v26868;v3820=binex;v26868=JAM.call(this.typeCheck,this,[binex.operand2]);v3820.operand2=v26868;this.checker.styleSettings.literalSubscript||
binex.operand2.nodeType!=TypeScript.NodeType.QString||(v3820=this.checker.errorReporter,JAM.call(v3820.styleError,v3820,[ast,"use literal subscript ('.') notation instead)"]));v26868=binex.operand1.type;v3820=binex.operand2.type;if(v26868.elementType)ast=v3820==this.checker.anyType,ast||(ast=v3820==this.checker.numberType)||(ast=JAM.call(TypeScript.hasFlag,TypeScript,[v3820.typeFlags,TypeScript.TypeFlags.IsEnum])),ast?binex.type=v26868.elementType:(v3820!=this.checker.stringType&&(v3820=this.checker.errorReporter,
JAM.call(v3820.simpleError,v3820,[binex,"Illegal property access"])),binex.type=this.checker.anyType);else if(v26868.index){var v13736=v3820==this.checker.anyType;v13736||((v13736=v26868.index.flags&TypeScript.SignatureFlags.IsStringIndexer)||(v13736=v26868.index.flags&TypeScript.SignatureFlags.IsNumberIndexer),v13736=!v13736,v13736||((v13736=v26868.index.flags&TypeScript.SignatureFlags.IsStringIndexer)&&(v13736=v3820==this.checker.stringType),v13736||!(v13736=v26868.index.flags&TypeScript.SignatureFlags.IsNumberIndexer)))||
(v13736=v3820==this.checker.numberType)||(v13736=JAM.call(TypeScript.hasFlag,TypeScript,[v3820.typeFlags,TypeScript.TypeFlags.IsEnum]));v13736?(v3820=JAM.call(this.resolveOverload,this,[ast,v26868.index]),binex.type=v3820?v3820.returnType.type:this.checker.anyType):(v3820!=this.checker.stringType&&(v3820=this.checker.errorReporter,JAM.call(v3820.simpleError,v3820,[binex,"Illegal property access"])),binex.type=this.checker.anyType)}else{ast=v26868==this.checker.anyType;ast||(ast=v26868==this.checker.stringType,
ast||(ast=v26868==this.checker.numberType,ast||(ast=v26868==this.checker.booleanType)||(ast=v26868.isReferenceType())));if(v26868=ast)v26868=v3820==this.checker.anyType,v26868||(v26868=v3820==this.checker.stringType,v26868||(v26868=v3820==this.checker.numberType)||(v26868=JAM.call(TypeScript.hasFlag,TypeScript,[v3820.typeFlags,TypeScript.TypeFlags.IsEnum])));v26868||(v3820=this.checker.errorReporter,JAM.call(v3820.simpleError,v3820,[binex,"Illegal property access"]));binex.type=this.checker.anyType}return binex}
function v1039(ast){var applyTargetType=!ast.operand2.isParenthesized,v3847=ast,v26870=JAM.call(this.typeCheck,this,[ast.operand1]);v3847.operand1=v26870;v3847=this.checker;JAM.call(v3847.typeCheckWithContextualType,v3847,[ast.operand1.type,this.checker.inProvisionalTypecheckMode(),applyTargetType,ast.operand2]);var leftType=ast.operand1.type,v3847=ast.operand2.type;JAM.call(this.astIsWriteable,this,[ast.operand1])||(v26870=this.checker.errorReporter,JAM.call(v26870.valueCannotBeModified,v26870,[ast]));
var preserveScope=!1,v26870=null;ast.operand2.type&&(v26870=ast.operand2.type.containedScope,preserveScope=!0);var v3859=ast,v13751=ast.operand2;applyTargetType&&(applyTargetType=!this.checker.inProvisionalTypecheckMode());applyTargetType=JAM.call(this.castWithCoercion,this,[v13751,leftType,applyTargetType,!1]);v3859.operand2=applyTargetType;(applyTargetType=preserveScope)&&(applyTargetType=null==ast.operand2.type.containedScope);applyTargetType&&(ast.operand2.type.containedScope=v26870);ast.type=
v3847;return ast}function v1038(ast){var v3862=ast,v26872=JAM.call(this.typeCheck,this,[ast.operand1]);v3862.operand1=v26872;v3862=ast;v26872=JAM.call(this.typeCheck,this,[ast.operand2]);v3862.operand2=v26872;var v3862=ast.operand1.type,v26872=ast.operand2.type,v23240=this.checker;if(v23240=!JAM.call(v23240.sourceIsAssignableToTarget,v23240,[v3862,v26872]))v23240=this.checker,v23240=!JAM.call(v23240.sourceIsAssignableToTarget,v23240,[v26872,v3862]);v23240&&(v23240=this.checker.errorReporter,JAM.call(v23240.incompatibleTypes,
v23240,[ast,v3862,v26872,ast.printLabel(),this.scope]));ast.type=this.booleanType;return ast}function v1037(ast){var v3870=ast,v26874=JAM.call(this.typeCheck,this,[ast.operand1]);v3870.operand1=v26874;var v3870=ast.operand1.type,leftScope=null;if(v3870){if(v3870==this.anyType)return ast.type=this.anyType,ast;if(v3870==this.stringType)if(this.stringInterfaceType)leftScope=this.stringInterfaceType.memberScope;else return ast.type=this.anyType,ast;else if(v3870==this.doubleType)if(this.numberInterfaceType)leftScope=
this.numberInterfaceType.memberScope;else return ast.type=this.anyType,ast;else if(v3870==this.booleanType)if(this.booleanInterfaceType)leftScope=this.booleanInterfaceType.memberScope;else return ast.type=this.anyType,ast;else if(v26874=v3870.call,v26874||(v26874=v3870.construct),v26874&&(v26874=null==v3870.members),v26874)if(this.functionInterfaceType)leftScope=this.functionInterfaceType.memberScope;else return ast.type=this.anyType,ast;else if(v3870.elementType)if(this.arrayInterfaceType)v26874=
v3870.elementType,v26874=JAM.call(v26874.getArrayBase,v26874,[this.arrayInterfaceType,this.checker]),leftScope=v26874.memberScope;else return ast.type=this.anyType,ast;else leftScope=v3870.memberScope}if(null==leftScope)v3870=this.checker.errorReporter,JAM.call(v3870.expectedClassOrInterface,v3870,[ast]),ast.type=this.anyType;else{var v26874=ast.operand2,v13766=this.thisClassNode;v13766&&(v13766=ast.operand1.type==this.thisClassNode.type.instanceType);v13766||(v13766=this.inTypeRefTypeCheck);v13766=
JAM.call(leftScope.find,leftScope,[v26874.text,!v13766,this.inTypeRefTypeCheck]);if(!v13766){var v13768=this.objectInterfaceType;v13768&&(v13768=v3870);if(v13768&&(v3870.isReferenceType()&&(v13766=this.objectInterfaceType.memberScope,v13766=JAM.call(v13766.find,v13766,[v26874.text,!1,this.inTypeRefTypeCheck])),!v13766)){if(v13768=this.functionInterfaceType)v13768=v3870.call,v13768||(v13768=v3870.construct);v13768&&(v13766=this.functionInterfaceType.memberScope,v13766=JAM.call(v13766.find,v13766,[v26874.text,
!1,this.inTypeRefTypeCheck]))}}(v13768=!v13766)||(v13768=!JAM.call(v13766.visible,v13766,[leftScope,this.checker]));if(v13768)ast.type=this.anyType,null==v13766?(leftScope=this.checker.errorReporter,JAM.call(leftScope.simpleError,leftScope,[v26874,"The property '"+v26874.actualText+"' does not exist on value of type '"+JAM.call(v3870.getScopedTypeName,v3870,[this.scope])+"'"])):this.inTypeRefTypeCheck||(leftScope=this.checker.errorReporter,JAM.call(leftScope.simpleError,leftScope,[ast,"The property '"+
v26874.actualText+" on type '"+JAM.call(v3870.getScopedTypeName,v3870,[this.scope])+"' is not visible"]));else{if(v13766.isVariable()&&v13766.isInferenceSymbol()){v3870=v13766;if(leftScope=v3870.declAST)leftScope=this.checker,leftScope=!JAM.call(leftScope.typeStatusIsFinished,leftScope,[v3870.typeCheckStatus]);leftScope&&JAM.call(this.inScopeTypeCheckDecl,this,[v3870.declAST])}v26874.sym=v13766;v3870=ast;v26874=v13766.getType();v3870.type=v26874}}null==ast.type&&(ast.type=this.anyType);return ast}
function v1036(ast,assignment){var binex=ast,v3920=binex,v26876=JAM.call(this.typeCheck,this,[binex.operand1]);v3920.operand1=v26876;v3920=binex;v26876=JAM.call(this.typeCheck,this,[binex.operand2]);v3920.operand2=v26876;var v3920=binex.operand1.type,v26876=binex.operand2.type,v13782=assignment;v13782&&(v13782=!JAM.call(this.astIsWriteable,this,[binex.operand1]));v13782&&(v13782=this.checker.errorReporter,JAM.call(v13782.valueCannotBeModified,v13782,[binex]));if(v13782=this.checker.styleSettings.bitwise)v13782=
binex.nodeType==TypeScript.NodeType.And,v13782||(v13782=binex.nodeType==TypeScript.NodeType.Or,v13782||(v13782=binex.nodeType==TypeScript.NodeType.AsgAnd)||(v13782=binex.nodeType==TypeScript.NodeType.AsgOr));if(v13782){var v13782=this.checker.errorReporter,v19624=TypeScript.nodeTypeTable,v19625=binex.nodeType;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v19624=v19624[v19625];JAM.call(v13782.styleError,v13782,[ast,"use of "+v19624])}(v13782=null==v3920)||(v13782=null==v26876);if(v13782)return v3920=
this.checker.errorReporter,JAM.call(v3920.simpleError,v3920,[binex,"Could not typecheck arithmetic operation.  Possible recursive typecheck error?"]),binex.type=this.anyType,binex;v13782=binex.nodeType;v19624=this.checker;JAM.call(v19624.isNullOrUndefinedType,v19624,[v3920])&&(v3920=v26876);v19624=this.checker;JAM.call(v19624.isNullOrUndefinedType,v19624,[v26876])&&(v26876=v3920);v19624=this.checker;v3920=JAM.call(v19624.widenType,v19624,[v3920]);v19624=this.checker;v26876=JAM.call(v19624.widenType,
v19624,[v26876]);(v19624=v13782==TypeScript.NodeType.Add)||(v19624=v13782==TypeScript.NodeType.AsgAdd);if(v19624)if((v13782=v3920==this.checker.stringType)||(v13782=v26876==this.checker.stringType),v13782)binex.type=this.checker.stringType;else if((v13782=v3920==this.checker.numberType)&&(v13782=v26876==this.checker.numberType),v13782)binex.type=this.checker.numberType;else{v13782=this.checker;if(v13782=JAM.call(v13782.sourceIsSubtypeOfTarget,v13782,[v3920,this.checker.numberType]))v13782=this.checker,
v13782=JAM.call(v13782.sourceIsSubtypeOfTarget,v13782,[v26876,this.checker.numberType]);v13782?binex.type=this.checker.numberType:((v13782=v3920==this.checker.anyType)||(v13782=v26876==this.checker.anyType),v13782?binex.type=this.checker.anyType:(binex.type=this.anyType,v13782=this.checker.errorReporter,JAM.call(v13782.incompatibleTypes,v13782,[binex,v3920,v26876,binex.printLabel(),this.scope])))}else if((v13782=v3920==this.checker.numberType)&&(v13782=v26876==this.checker.numberType),v13782)binex.type=
this.checker.numberType;else{v13782=this.checker;if(v13782=JAM.call(v13782.sourceIsSubtypeOfTarget,v13782,[v3920,this.checker.numberType]))v13782=this.checker,v13782=JAM.call(v13782.sourceIsSubtypeOfTarget,v13782,[v26876,this.checker.numberType]);v13782?binex.type=this.checker.numberType:((v13782=v3920==this.checker.anyType)||(v13782=v26876==this.checker.anyType),v13782?binex.type=this.checker.numberType:(binex.type=this.anyType,v13782=this.checker.errorReporter,JAM.call(v13782.incompatibleTypes,
v13782,[binex,v3920,v26876,binex.printLabel(),this.scope])))}return binex}function v1035(ast,assignment){var binex=ast,resultType=null,v3956=binex,v26878=JAM.call(this.typeCheck,this,[binex.operand1]);v3956.operand1=v26878;v3956=binex;v26878=JAM.call(this.typeCheck,this,[binex.operand2]);v3956.operand2=v26878;var v3956=binex.operand1.type,v26878=binex.operand2.type,v13803=assignment;v13803&&(v13803=!JAM.call(this.astIsWriteable,this,[binex]));v13803&&(v13803=this.checker.errorReporter,JAM.call(v13803.valueCannotBeModified,
v13803,[binex]));if(this.checker.styleSettings.bitwise){var v13803=this.checker.errorReporter,v19653=TypeScript.nodeTypeTable,v19654=binex.nodeType;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v19653=v19653[v19654];JAM.call(v13803.styleError,v13803,[ast,"use of "+v19653])}v13803=this.checker;if(v13803=JAM.call(v13803.sourceIsSubtypeOfTarget,v13803,[v3956,this.doubleType]))v13803=this.checker,v13803=JAM.call(v13803.sourceIsSubtypeOfTarget,v13803,[v26878,this.doubleType]);v13803?
resultType=this.doubleType:((v13803=v3956==this.booleanType)&&(v13803=v26878==this.booleanType),v13803?resultType=this.booleanType:v3956==this.anyType?(v13803=v26878==this.anyType,v13803||(v13803=v26878==this.doubleType)||(v13803=v26878==this.booleanType),v13803&&(resultType=this.anyType)):v26878==this.anyType&&(v13803=v3956==this.anyType,v13803||(v13803=v3956==this.doubleType)||(v13803=v3956==this.booleanType),v13803&&(resultType=this.anyType)));null==resultType&&(resultType=this.anyType,v13803=
this.checker.errorReporter,JAM.call(v13803.incompatibleTypes,v13803,[binex,v3956,v26878,binex.printLabel(),this.scope]));binex.type=resultType;return binex}function v1034(ast){var unex=ast;if(JAM.call(this.astIsWriteable,this,[unex])){var unex=JAM.call(this.typeCheckUnaryNumberOperator,this,[ast]),v13817=unex.operand.type!=this.checker.numberType;v13817&&(v13817=unex.operand.type!=this.checker.anyType)&&(v13817=!(unex.operand.type.typeFlags&TypeScript.TypeFlags.IsEnum));v13817&&(v13817=this.checker.errorReporter,
JAM.call(v13817.simpleError,v13817,[ast,"'++' and '--' may only be applied to operands of type 'number' or 'any'"]))}else ast=this.checker.errorReporter,JAM.call(ast.valueCannotBeModified,ast,[unex]),unex.type=this.doubleType;return unex}function v1033(ast){return JAM.call(TypeScript.hasFlag,TypeScript,[ast.flags,TypeScript.ASTFlags.Writeable])}function v1032(ast){var v3981=ast,v26880=JAM.call(this.typeCheck,this,[ast.operand]);v3981.operand=v26880;ast.type=this.booleanType;return ast}function v1031(ast){var unex=
ast,v3982=unex,v26881=JAM.call(this.typeCheck,this,[unex.operand]);v3982.operand=v26881;unex.type=this.doubleType;return ast}function v1030(ast){var v3983=ast,v26882=JAM.call(this.typeCheck,this,[ast.operand]);v3983.operand=v26882;ast.type=this.doubleType;return ast}function v1029(script){this.checker.locationInfo=script.locationInfo;this.scope=this.checker.globalScope;script.topLevelMod||JAM.call(this.addLocalsFromScope,this,[this.scope,this.checker.gloMod,script.vars,this.checker.globals,!0]);var v3991=
this.currentScript=script,v26883=JAM.call(this.typeCheck,this,[script.bod]);v3991.bod=v26883;this.currentScript=null;return script}function v1028(ast){function v1027(id){var v3992=_this.scope;return JAM.call(v3992.find,v3992,[id,!1,typespace])}var _this=this,identifier=ast;if(this.checker.inWith)identifier.type=this.anyType;else{var typespace=this.inTypeRefTypeCheck,idText=identifier.text,isDynamicModuleName=JAM.call(TypeScript.isQuoted,TypeScript,[identifier.text]),v3994=this.scope,v3994=JAM.call(v3994.find,
v3994,[idText,!1,typespace]),v13828=null==v3994;v13828&&(v13828=isDynamicModuleName);v13828&&(v3994=this.checker,v3994=JAM.call(v3994.findSymbolForDynamicModule,v3994,[idText,this.currentScript.locationInfo.filename,v1027]));if(v3994){(idText=TypeScript.optimizeModuleCodeGen)&&(idText=v3994)&&(idText=v3994.isType());if(idText){if(isDynamicModuleName=idText=v3994.getType())if(isDynamicModuleName=v3994.aliasLink)isDynamicModuleName=v3994.onlyReferencedAsTypeRef;isDynamicModuleName&&((isDynamicModuleName=
idText=idText.symbol.declAST)&&(isDynamicModuleName=JAM.call(TypeScript.hasFlag,TypeScript,[idText.modFlags,TypeScript.ModuleFlags.IsDynamic])),isDynamicModuleName&&(v3994.onlyReferencedAsTypeRef=this.inTypeRefTypeCheck))}(idText=v3994.declAST)&&(idText=v3994.declAST.nodeType==TypeScript.NodeType.FuncDecl)&&(idText=!v3994.declAST.returnTypeAnnotation)&&(idText=v3994.declAST.signature.typeCheckStatus==TypeScript.TypeCheckStatus.Started);idText&&(idText=v3994.declAST.type.symbol,idText.flags|=TypeScript.SymbolFlags.RecursivelyReferenced,
v3994.declAST.signature.returnType.type=this.anyType);JAM.call(this.setTypeFromSymbol,this,[ast,v3994]);identifier.sym=v3994;this.thisFnc&&((identifier=this.thisFnc.type)&&(identifier=v3994.container!=this.thisFnc.type.symbol),identifier&&JAM.set(this.thisFnc.freeVariables,this.thisFnc.freeVariables.length,v3994))}else identifier.isMissing()||(v3994=this.checker.errorReporter,JAM.call(v3994.unresolvedSymbol,v3994,[identifier,identifier.text])),identifier.type=this.anyType}return ast}function v1026(ast,
symbol){if(symbol.isVariable()){if(symbol.isInferenceSymbol()){var infSym=symbol,v13841=infSym.declAST;v13841&&(v13841=this.checker,v13841=!JAM.call(v13841.typeStatusIsFinished,v13841,[infSym.typeCheckStatus]));v13841&&JAM.call(this.inScopeTypeCheckDecl,this,[infSym.declAST]);this.checker.styleSettings.innerScopeDeclEscape||((v13841=infSym.declAST)&&(v13841=infSym.declAST.nodeType==TypeScript.NodeType.VarDecl),v13841&&this.nestingLevel<infSym.declAST.nestingLevel&&(infSym=this.checker.errorReporter,
JAM.call(infSym.styleError,infSym,[ast,"Illegal reference to a variable defined in more nested scope"])))}infSym=ast;v13841=symbol.getType();infSym.type=v13841;symbol.writeable()||(ast.flags&=~TypeScript.ASTFlags.Writeable)}else symbol.isType()?(infSym=ast,v13841=symbol.getType(),infSym.type=v13841,ast.flags&=~TypeScript.ASTFlags.Writeable):(ast.type=this.anyType,infSym=this.checker.errorReporter,JAM.call(infSym.symbolDoesNotReferToAValue,infSym,[ast,symbol.name]))}function v1025(ast){ast.type=this.anyType;
var illegalThisRef=!1;if(null==this.thisFnc)if(this.thisType){var v13852=this.thisClassNode;v13852&&(v13852=this.thisClassNode.nodeType==TypeScript.NodeType.ClassDeclaration);v13852?illegalThisRef=!0:ast.type=this.thisType}else this.checker.currentModDecl&&(v13852=this.checker.errorReporter,JAM.call(v13852.simpleError,v13852,[ast,"'this' may not be referenced within module bodies"]));else{if(v13852=this.thisClassNode)v13852=JAM.call(TypeScript.hasFlag,TypeScript,[this.thisFnc.fncFlags,TypeScript.FncFlags.IsPropertyBound]),
v13852||(v13852=this.inSuperCall)&&(v13852=JAM.call(TypeScript.hasFlag,TypeScript,[this.thisClassNode.varFlags,TypeScript.VarFlags.ClassSuperMustBeFirstCallInConstructor]));v13852&&(illegalThisRef=!0);v13852=this.thisFnc.isMethod();v13852||(v13852=this.thisFnc.isConstructor,v13852||(v13852=this.thisFnc.isTargetTypedAsMethod));v13852&&((v13852=this.thisType)&&(v13852=!(this.thisFnc.fncFlags&TypeScript.FncFlags.Static)),v13852&&(ast.type=this.thisType))}(v13852=!this.enclosingFncIsMethod)&&(v13852=
this.thisFnc)&&(v13852=JAM.call(TypeScript.hasFlag,TypeScript,[this.thisFnc.fncFlags,TypeScript.FncFlags.IsFatArrowFunction]));if(v13852)if(this.thisFnc.boundToProperty)v13852=this.thisFnc.boundToProperty.sym.container,v13852.declAST.nodeType==TypeScript.NodeType.FuncDecl&&v13852.declAST.setHasSelfReference();else{for(var firstEncFnc=v13852=this.thisFnc.enclosingFnc;v13852;){var v13863=this.thisClassNode;v13863&&(v13863=JAM.call(TypeScript.hasFlag,TypeScript,[v13852.fncFlags,TypeScript.FncFlags.IsPropertyBound]));
v13863&&(illegalThisRef=!0);(v13863=!JAM.call(TypeScript.hasFlag,TypeScript,[v13852.fncFlags,TypeScript.FncFlags.IsFatArrowFunction]))||(v13863=v13852.hasSelfReference());if(v13863){v13852.setHasSelfReference();break}v13852=v13852.enclosingFnc}(v13863=!v13852)&&(v13863=firstEncFnc);v13863?(v13852=firstEncFnc,v13852.setHasSelfReference()):v13852||(this.thisClassNode?(firstEncFnc=this.thisClassNode,firstEncFnc.varFlags|=TypeScript.VarFlags.MustCaptureThis):this.checker.currentModDecl?(firstEncFnc=this.checker.currentModDecl,
firstEncFnc.modFlags|=TypeScript.ModuleFlags.MustCaptureThis):this.checker.mustCaptureGlobalThis=!0);if(firstEncFnc=v13852)firstEncFnc=v13852.isMethod(),firstEncFnc||(firstEncFnc=v13852.isConstructor),firstEncFnc&&(firstEncFnc=this.thisType)&&(firstEncFnc=!JAM.call(TypeScript.hasFlag,TypeScript,[v13852.fncFlags,TypeScript.FncFlags.Static]));firstEncFnc&&(ast.type=this.thisType)}illegalThisRef&&(illegalThisRef=this.checker.errorReporter,JAM.call(illegalThisRef.simpleError,illegalThisRef,[ast,"Keyword 'this' cannot be referenced in initializers in a class body, or in super constructor calls"]));
return ast}function v1024(ast){var v13870=this.thisType;v13870&&((v13870=this.enclosingFncIsMethod)&&(v13870=!this.thisFnc.isStatic()),v13870&&(v13870=this.thisType.baseClass()));if(v13870){var v13870=ast,v26886=this.thisType.baseClass();v13870.type=v26886}else{(v13870=!this.enclosingFncIsMethod)&&(v13870=this.thisType)&&(v13870=this.thisType.baseClass())&&(v13870=this.thisFnc)&&(v13870=JAM.call(TypeScript.hasFlag,TypeScript,[this.thisFnc.fncFlags,TypeScript.FncFlags.IsFatArrowFunction]));if(v13870){v13870=
this.thisFnc.enclosingFnc;for(v26886=JAM.call(TypeScript.hasFlag,TypeScript,[v13870.fncFlags,TypeScript.FncFlags.IsFatArrowFunction]);v26886;)v13870=v13870.enclosingFnc,v26886=JAM.call(TypeScript.hasFlag,TypeScript,[v13870.fncFlags,TypeScript.FncFlags.IsFatArrowFunction]);if(v26886=v13870)v26886=v13870.isMethod(),v26886||(v26886=v13870.isConstructor),v26886&&(v26886=!v13870.isStatic());if(v26886){var v26886=ast,v26887=this.thisType.baseClass();v26886.type=v26887;v13870.setHasSuperReferenceInFatArrowFunction();
return ast}}ast.type=this.anyType;v13870=this.checker.errorReporter;JAM.call(v13870.invalidSuperReference,v13870,[ast])}return ast}function v1023(varDecl,typeName,isModuleName){var typestring="";isModuleName?(typestring="",JAM.call(TypeScript.isQuoted,TypeScript,[typeName])||(typestring="'"),typestring=" is using inaccessible module "+typestring+typeName+typestring):typestring=" has or is using private type '"+typeName+"'";JAM.call(TypeScript.hasFlag,TypeScript,[varDecl.varFlags,TypeScript.VarFlags.Public])?
varDecl.sym.container.declAST.nodeType==TypeScript.NodeType.InterfaceDeclaration?(typeName=this.checker.errorReporter,JAM.call(typeName.simpleError,typeName,[varDecl,"property '"+varDecl.sym.name+"' of exported interface"+typestring])):(typeName=this.checker.errorReporter,JAM.call(typeName.simpleError,typeName,[varDecl,"public member '"+varDecl.sym.name+"' of exported class"+typestring])):(typeName=this.checker.errorReporter,JAM.call(typeName.simpleError,typeName,[varDecl,"exported variable '"+varDecl.sym.name+
"'"+typestring]))}function v1022(varDecl){function v1021(typeName,isModuleName){return JAM.call(_this.varPrivacyErrorReporter,_this,[varDecl,typeName,isModuleName])}function v1020(ast,parent,walker){(parent=ast)&&(parent=ast.nodeType==TypeScript.NodeType.FuncDecl);parent&&(JAM.call(TypeScript.hasFlag,TypeScript,[ast.fncFlags,TypeScript.FncFlags.IsFatArrowFunction])&&(ast.fncFlags|=TypeScript.FncFlags.IsPropertyBound),walker.options.goChildren=!1);return ast}var _this=this,infSym=varDecl.sym;if(null==
infSym)if(varDecl.init){var infSym=varDecl,v26888=JAM.call(this.typeCheck,this,[varDecl.init]);infSym.init=v26888;infSym=varDecl;v26888=this.checker;v26888=JAM.call(v26888.widenType,v26888,[varDecl.init.type]);infSym.type=v26888}else this.checker.styleSettings.implicitAny&&(infSym=this.checker.errorReporter,JAM.call(infSym.styleError,infSym,[varDecl,"type implicitly set to 'any'"])),varDecl.type=this.anyType;else if(infSym.typeCheckStatus==TypeScript.TypeCheckStatus.Started)this.checker.styleSettings.implicitAny&&
(v26888=this.checker.errorReporter,JAM.call(v26888.styleError,v26888,[varDecl,"type implicitly set to 'any'"])),varDecl.type=this.anyType,JAM.call(infSym.setType,infSym,[this.anyType]);else if(infSym.typeCheckStatus==TypeScript.TypeCheckStatus.NotStarted){infSym.typeCheckStatus=TypeScript.TypeCheckStatus.Started;v26888=this.checker;JAM.call(v26888.addStartedPTO,v26888,[infSym]);v26888=!1;if(null==varDecl.type&&varDecl.typeExpr){JAM.call(this.resolveBoundDecl,this,[varDecl]);v26888=!0;varDecl.type=
varDecl.typeExpr.type;var v4090=infSym,v26890=this.checker.getTypeCheckFinishedStatus();v4090.typeCheckStatus=v26890}if(varDecl.init){v26890=JAM.call(TypeScript.hasFlag,TypeScript,[varDecl.varFlags,TypeScript.VarFlags.LocalStatic]);v4090=this.scope;v26888=!varDecl.init.isParenthesized;v26890&&(this.scope=varDecl.sym.container.getType().memberScope);if(v26890=JAM.call(TypeScript.hasFlag,TypeScript,[varDecl.varFlags,TypeScript.VarFlags.Property]))v26890=this.thisClassNode;v26890&&(v26890=TypeScript.getAstWalkerFactory(),
JAM.call(v26890.walk,v26890,[varDecl.init,v1020]));v26890=this.checker;JAM.call(v26890.typeCheckWithContextualType,v26890,[varDecl.type,this.checker.inProvisionalTypecheckMode(),v26888,varDecl.init]);this.scope=v4090;if(varDecl.type){v26890=!1;v4090=null;if(varDecl.init.type&&(v4090=varDecl.init.type.containedScope,v26890=!0,varDecl.init.type==this.voidType)){var v4105=this.checker.errorReporter;JAM.call(v4105.simpleError,v4105,[varDecl,"Cannot assign type 'void' to variable '"+varDecl.id.actualText+
"'"])}var v4105=varDecl,v13921=varDecl.init,v13922=varDecl.type;v26888&&(v26888=!this.checker.inProvisionalTypecheckMode());v26888=JAM.call(this.castWithCoercion,this,[v13921,v13922,v26888,!1]);v4105.init=v26888;(v26888=v26890)&&(v26888=null==varDecl.init.type.containedScope);v26888&&(varDecl.init.type.containedScope=v4090)}else v26888=varDecl,v4090=this.checker,v4090=JAM.call(v4090.widenType,v4090,[varDecl.init.type]),v26888.type=v4090,varDecl.type==this.voidType&&(v26888=this.checker.errorReporter,
JAM.call(v26888.simpleError,v26888,[varDecl,"Cannot assign type 'void' to variable '"+varDecl.id.actualText+"'"]),varDecl.type=this.anyType);JAM.call(infSym.setType,infSym,[varDecl.type])}else v26888||JAM.call(this.resolveBoundDecl,this,[varDecl]);v26888=this.checker.getTypeCheckFinishedStatus();infSym.typeCheckStatus=v26888}else v26888=this.checker,(v26888=JAM.call(v26888.typeStatusIsFinished,v26888,[infSym.typeCheckStatus]))&&(v26888=infSym.declAST!=varDecl),v26888&&varDecl.init&&(v26888=varDecl,
v4090=JAM.call(this.typeCheck,this,[varDecl.init]),v26888.init=v4090,v26888=varDecl,infSym=infSym.getType(),v26888.type=infSym,infSym=varDecl,v26888=JAM.call(this.cast,this,[varDecl.init,varDecl.type]),infSym.init=v26888);if(infSym=varDecl.id)infSym=varDecl.sym;infSym&&(varDecl.id.sym=varDecl.sym);if(infSym=varDecl.sym)infSym=varDecl.sym.container;infSym&&JAM.call(this.checkTypePrivacy,this,[varDecl.sym.getType(),varDecl.sym,v1021]);return varDecl}function v1019(varDecl){if(varDecl.typeExpr){var v13940=
null==varDecl.typeExpr.type;if(!v13940){if(v13940=varDecl.typeExpr.type)if(v13940=varDecl.typeExpr.type==this.anyType)v13940=this.scope;v13940||(v13940=null==varDecl.typeExpr.type.symbol,v13940||(v13940=this.checker,v13940=!JAM.call(v13940.typeStatusIsFinished,v13940,[varDecl.typeExpr.type.symbol.typeCheckStatus])))}v13940&&JAM.call(this.typeCheck,this,[varDecl.typeExpr]);varDecl.type=varDecl.typeExpr.type;varDecl.sym&&(v13940=varDecl.sym,JAM.call(v13940.setType,v13940,[varDecl.type]))}else null==
varDecl.init&&(this.checker.styleSettings.implicitAny&&(v13940=this.checker.errorReporter,JAM.call(v13940.styleError,v13940,[varDecl,"type implicitly set to 'any'"])),varDecl.type=this.anyType,varDecl.sym&&(varDecl.sym.isType()?(v13940=varDecl.sym,v13940.isMethod?(v13940=this.checker.errorReporter,JAM.call(v13940.simpleError,v13940,[varDecl,"Cannot bind method group to variable.  (Did you mean to use 'declare function' instead of 'declare var'?)"])):(v13940=this.checker.errorReporter,JAM.call(v13940.simpleError,
v13940,[varDecl,"Cannot bind type to variable"]))):(v13940=varDecl.sym,JAM.call(v13940.setType,v13940,[varDecl.type]))))}function v1018(varDecl){var sym=varDecl.sym,svThisFnc=this.thisFnc,svThisType=this.thisType,prevMethodStatus=this.enclosingFncIsMethod,prevLocationInfo=this.checker.locationInfo,v13947=sym;v13947&&(v13947=sym.container);if(v13947){var instanceScope=v13947=JAM.call(TypeScript.hasFlag,TypeScript,[varDecl.varFlags,TypeScript.VarFlags.ClassConstructorProperty])?sym.container.getType().constructorScope:
sym.container.instanceScope();(v13947=JAM.call(TypeScript.hasFlag,TypeScript,[varDecl.varFlags,TypeScript.VarFlags.Property]))&&(v13947=sym.container.declAST.nodeType==TypeScript.NodeType.FuncDecl);v13947&&(this.thisFnc=sym.container.declAST);if(instanceScope){v13947=this.scope;this.scope=instanceScope;var instanceScope=sym.container,v13952=this.checker.units;v13952&&(v13952=0<=sym.unitIndex)&&(v13952=sym.unitIndex<this.checker.units.length);if(v13952){var v13952=this.checker,v13953=this.checker.units,
sym=sym.unitIndex;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v13952.locationInfo=v13953[sym]}else this.checker.locationInfo=TypeScript.unknownLocationInfo;for(;instanceScope;){if(instanceScope.kind()==TypeScript.SymbolKind.Type&&(sym=instanceScope,v13952=sym.type,v13952.call&&(this.enclosingFncIsMethod=sym.isMethod),v13952.isClass())){this.thisType=v13952.instanceType;break}instanceScope=instanceScope.container}JAM.call(this.typeCheckBoundDecl,this,[varDecl]);this.scope=v13947}}this.thisFnc=
svThisFnc;this.thisType=svThisType;this.checker.locationInfo=prevLocationInfo;this.enclosingFncIsMethod=prevMethodStatus}function v1017(ast){var v13957=ast.nodeType==TypeScript.NodeType.VarDecl;v13957||(v13957=ast.nodeType==TypeScript.NodeType.ArgDecl);v13957?JAM.call(this.inScopeTypeCheckBoundDecl,this,[ast]):ast.nodeType==TypeScript.NodeType.FuncDecl&&ast.isAccessor()&&JAM.call(this.typeCheckFunction,this,[ast])}function v1016(ast){return ast?JAM.call(ast.typeCheck,ast,[this]):null}function v1015(ast,
enclosingScope){var prevScope=this.scope;this.scope=enclosingScope;for(var svThisFnc=this.thisFnc,svThisType=this.thisType,svThisClassNode=this.thisClassNode,svCurrentModDecl=this.checker.currentModDecl,prevMethodStatus=this.enclosingFncIsMethod,container=this.scope.container,fnc=null;container;){if(container.kind()==TypeScript.SymbolKind.Type){var typeSym=container,type=typeSym.type;type.call&&null==fnc&&(this.enclosingFncIsMethod=typeSym.isMethod,fnc=container.declAST);if(type.isClass()){this.thisType=
type.instanceType;(container=typeSym.declAST)&&(container=typeSym.declAST.nodeType==TypeScript.NodeType.ClassDeclaration);container&&(this.thisClassNode=typeSym.declAST);break}if(type.isModuleType()){this.checker.currentModDecl=typeSym.declAST;break}}container=container.container}this.thisFnc=fnc;fnc=JAM.call(this.typeCheck,this,[ast]);this.thisFnc=svThisFnc;this.thisType=svThisType;this.thisClassNode=svThisClassNode;this.checker.currentModDecl=svCurrentModDecl;this.enclosingFncIsMethod=prevMethodStatus;
this.scope=prevScope;return fnc}function v1014(ast,type,applyCoercion,typeAssertion){var comparisonInfo=new TypeScript.TypeComparisonInfo,v19770=this.checker,v19770=JAM.call(v19770.sourceIsAssignableToTarget,v19770,[ast.type,type,comparisonInfo]);v19770||(typeAssertion&&(typeAssertion=this.checker,typeAssertion=JAM.call(typeAssertion.sourceIsAssignableToTarget,typeAssertion,[type,ast.type,comparisonInfo])),v19770=typeAssertion);v19770?applyCoercion&&(null==type?ast.type=this.anyType:type.isClass()?
ast.type=type.instanceType:ast.type=type):(applyCoercion=this.checker.errorReporter,JAM.call(applyCoercion.incompatibleTypes,applyCoercion,[ast,ast.type,type,null,this.scope,comparisonInfo]));return ast}function v1013(ast,type){return JAM.call(this.castWithCoercion,this,[ast,type,!0,!1])}function v1012(){var v4183=this.globalScope,v13965=v4183=JAM.call(v4183.find,v4183,["Array",!1,!0]);v13965&&(v13965=v4183.kind()==TypeScript.SymbolKind.Type);v13965&&(this.arrayInterfaceType=v4183.type);v4183=this.globalScope;
(v13965=v4183=JAM.call(v4183.find,v4183,["String",!1,!0]))&&(v13965=v4183.kind()==TypeScript.SymbolKind.Type);v13965&&(this.stringInterfaceType=v4183.type);v4183=this.globalScope;(v13965=v4183=JAM.call(v4183.find,v4183,["Object",!1,!0]))&&(v13965=v4183.kind()==TypeScript.SymbolKind.Type);v13965&&(this.objectInterfaceType=v4183.type);v4183=this.globalScope;(v13965=v4183=JAM.call(v4183.find,v4183,["Function",!1,!0]))&&(v13965=v4183.kind()==TypeScript.SymbolKind.Type);v13965&&(this.functionInterfaceType=
v4183.type);v4183=this.globalScope;(v13965=v4183=JAM.call(v4183.find,v4183,["Number",!1,!0]))&&(v13965=v4183.kind()==TypeScript.SymbolKind.Type);v13965&&(this.numberInterfaceType=v4183.type);v4183=this.globalScope;(v13965=v4183=JAM.call(v4183.find,v4183,["Boolean",!1,!0]))&&(v13965=v4183.kind()==TypeScript.SymbolKind.Type);v13965&&(this.booleanInterfaceType=v4183.type);v4183=this.globalScope;(v13965=v4183=JAM.call(v4183.find,v4183,["RegExp",!1,!0]))&&(v13965=v4183.kind()==TypeScript.SymbolKind.Type);
v13965&&(this.regexType=v4183.type)}function TypeFlow(logger,initScope,parser,checker){this.logger=logger;this.initScope=initScope;this.parser=parser;this.checker=checker;this.thisClassNode=this.thisFnc=null;this.enclosingFncIsMethod=!1;this.currentScript=this.iargumentsInterfaceType=this.booleanInterfaceType=this.numberInterfaceType=this.functionInterfaceType=this.objectInterfaceType=this.stringInterfaceType=this.arrayInterfaceType=null;this.inArrayElementTypeCheck=this.inTypeRefTypeCheck=this.inImportTypeCheck=
!1;this.resolutionDataCache=logger=new ResolutionDataCache;this.nestingLevel=0;this.inSuperCall=!1;this.checker.typeFlow=this;this.globalScope=this.scope=this.initScope;this.doubleType=this.checker.numberType;this.booleanType=this.checker.booleanType;this.stringType=this.checker.stringType;this.regexType=this.anyType=this.checker.anyType;this.nullType=this.checker.nullType;this.voidType=this.checker.voidType;logger=this.checker;this.arrayAnyType=logger=JAM.call(logger.makeArrayType,logger,[this.anyType])}
TypeFlow.prototype.initLibs=v1012;TypeFlow.prototype.cast=v1013;TypeFlow.prototype.castWithCoercion=v1014;TypeFlow.prototype.inScopeTypeCheck=v1015;TypeFlow.prototype.typeCheck=v1016;TypeFlow.prototype.inScopeTypeCheckDecl=v1017;TypeFlow.prototype.inScopeTypeCheckBoundDecl=v1018;TypeFlow.prototype.resolveBoundDecl=v1019;TypeFlow.prototype.typeCheckBoundDecl=v1022;TypeFlow.prototype.varPrivacyErrorReporter=v1023;TypeFlow.prototype.typeCheckSuper=v1024;TypeFlow.prototype.typeCheckThis=v1025;TypeFlow.prototype.setTypeFromSymbol=
v1026;TypeFlow.prototype.typeCheckName=v1028;TypeFlow.prototype.typeCheckScript=v1029;TypeFlow.prototype.typeCheckBitNot=v1030;TypeFlow.prototype.typeCheckUnaryNumberOperator=v1031;TypeFlow.prototype.typeCheckLogNot=v1032;TypeFlow.prototype.astIsWriteable=v1033;TypeFlow.prototype.typeCheckIncOrDec=v1034;TypeFlow.prototype.typeCheckBitwiseOperator=v1035;TypeFlow.prototype.typeCheckArithmeticOperator=v1036;TypeFlow.prototype.typeCheckDotOperator=v1037;TypeFlow.prototype.typeCheckBooleanOperator=v1038;
TypeFlow.prototype.typeCheckAsgOperator=v1039;TypeFlow.prototype.typeCheckIndex=v1040;TypeFlow.prototype.typeCheckInOperator=v1041;TypeFlow.prototype.typeCheckShift=v1042;TypeFlow.prototype.typeCheckQMark=v1043;TypeFlow.prototype.addFormals=v1044;TypeFlow.prototype.addLocalsFromScope=v1045;TypeFlow.prototype.addConstructorLocalArgs=v1046;TypeFlow.prototype.checkInitSelf=v1047;TypeFlow.prototype.checkPromoteFreeVars=v1048;TypeFlow.prototype.allReturnsAreVoid=v1050;TypeFlow.prototype.classConstructorHasSuperCall=
v1051;TypeFlow.prototype.baseListPrivacyErrorReporter=v1052;TypeFlow.prototype.typeCheckBaseListPrivacy=v1054;TypeFlow.prototype.checkSymbolPrivacy=v1055;TypeFlow.prototype.checkTypePrivacy=v1057;TypeFlow.prototype.checkSignatureGroupPrivacy=v1058;TypeFlow.prototype.functionArgumentPrivacyErrorReporter=v1059;TypeFlow.prototype.returnTypePrivacyError=v1060;TypeFlow.prototype.functionReturnTypePrivacyErrorReporter=v1061;TypeFlow.prototype.typeCheckFunction=v1069;TypeFlow.prototype.typeCheckBases=v1070;
TypeFlow.prototype.checkMembersImplementInterfaces=v1071;TypeFlow.prototype.typeCheckBaseCalls=v1072;TypeFlow.prototype.assertUniqueNamesInBaseTypes=v1074;TypeFlow.prototype.checkBaseTypeMemberInheritance=v1076;TypeFlow.prototype.typeCheckClass=v1077;TypeFlow.prototype.typeCheckOverloadSignatures=v1078;TypeFlow.prototype.typeCheckInterface=v1079;TypeFlow.prototype.typeCheckImportDecl=v1080;TypeFlow.prototype.typeCheckModule=v1081;TypeFlow.prototype.typeCheckFor=v1082;TypeFlow.prototype.typeCheckWith=
v1083;TypeFlow.prototype.typeCheckForIn=v1084;TypeFlow.prototype.typeCheckWhile=v1085;TypeFlow.prototype.typeCheckDoWhile=v1086;TypeFlow.prototype.typeCheckCondExpr=v1087;TypeFlow.prototype.typeCheckCompoundStmtBlock=v1088;TypeFlow.prototype.typeCheckIf=v1089;TypeFlow.prototype.typeFromAccessorFuncDecl=v1090;TypeFlow.prototype.typeCheckObjectLit=v1091;TypeFlow.prototype.typeCheckArrayLit=v1095;TypeFlow.prototype.checkForVoidConstructor=v1096;TypeFlow.prototype.typeCheckReturn=v1097;TypeFlow.prototype.typeCheckInstOf=
v1098;TypeFlow.prototype.typeCheckCommaOperator=v1099;TypeFlow.prototype.typeCheckLogOr=v1100;TypeFlow.prototype.typeCheckLogAnd=v1101;TypeFlow.prototype.tryAddCandidates=v1102;TypeFlow.prototype.resolveOverload=v1103;TypeFlow.prototype.typeCheckNew=v1104;TypeFlow.prototype.preTypeCheckCallArgs=v1105;TypeFlow.prototype.postTypeCheckCallArgs=v1106;TypeFlow.prototype.typeCheckCall=v1107;TypeFlow.prototype.assignScopes=v1108;TypeFlow.prototype.findMemberScope=v1109;TypeFlow.prototype.findMemberScopeAt=
v1110;TypeFlow.prototype.findMemberScopeAtFullAst=v1111;return TypeFlow}function v1011(){function v1010(rd){rd.actuals.length=0;rd.exactCandidates.length=0;rd.conversionCandidates.length=0;this.nextUp=rd.id}function v1009(){var rd=null;if(this.nextUp<this.cacheSize){var rd=this.rdCache,v4292=this.nextUp;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)rd=rd[v4292]}null==rd&&(this.cacheSize+=1,rd={actuals:[],exactCandidates:[],conversionCandidates:[],id:this.cacheSize},JAM.set(this.rdCache,
this.cacheSize,rd));this.nextUp+=1;return rd}function ResolutionDataCache(){this.cacheSize=16;this.rdCache=[];for(var i=this.nextUp=0,v4303=i<this.cacheSize;v4303;)this.rdCache[i]={actuals:[],exactCandidates:[],conversionCandidates:[],id:i},i+=1,v4303=i<this.cacheSize}ResolutionDataCache.prototype.getResolutionData=v1009;ResolutionDataCache.prototype.returnResolutionData=v1010;return ResolutionDataCache}function v1008(){function v1007(ast){if(this.current){var v4306=this.current.content;JAM.call(v4306.append,
v4306,[ast])}}function v1006(target,isContinue){for(var targetBB=null,i=0,len=this.statementStack.length,v4311=i<len;v4311;){v4311=this.statementStack;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v4311=v4311[i];if(v4311.stmt==target){targetBB=isContinue?v4311.continueBB:v4311.breakBB;break}i+=1;v4311=i<len}targetBB&&(i=this.current,JAM.call(i.addSuccessor,i,[targetBB]));this.setUnreachable()}function v1005(ast){if(null===this.unreachable){var v26899=[];this.unreachable=v26899}JAM.set(this.unreachable,
this.unreachable.length,ast)}function v1004(){this.current=null;this.noContinuation=!0}function v1003(){var v4316=this.current;JAM.call(v4316.addSuccessor,v4316,[this.exit]);this.setUnreachable()}function v1002(){return this.statementStack.pop()}function v1001(stmt,continueBB,breakBB){var v4319=this.statementStack;JAM.call(v4319.push,v4319,[{stmt:stmt,continueBB:continueBB,breakBB:breakBB}])}function v1000(outfile){function node(bb){0>bb.index&&(bb.index=index,index+=1);bb==_this.exit?JAM.call(outfile.WriteLine,
outfile,["Exit block with index "+bb.index]):(JAM.call(outfile.WriteLine,outfile,["Basic block with index "+bb.index]),JAM.call(_this.printBlockContent,_this,[bb,outfile]))}function preEdges(){JAM.call(outfile.Write,outfile,["  Branches to "])}function postEdges(){JAM.call(outfile.WriteLine,outfile,[""])}function edge(node1,node2){0>node2.index&&(node2.index=index,index+=1);JAM.call(outfile.Write,outfile,[node2.index+" "])}var _this=this,index=0;JAM.call(this.bfs,this,[node,edge,preEdges,postEdges]);
if(null!=this.unreachable)for(var i=0,len=this.unreachable.length,v4329=i<len;v4329;){JAM.call(outfile.WriteLine,outfile,["Unreachable basic block ..."]);v4329=this.unreachable;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v4329=v4329[i];JAM.call(this.printAST,this,[v4329,outfile]);i+=1;v4329=i<len}}function v999(er,funcSym){function v998(index){var v4331=useDefContext.uses;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)index=v4331[index];JAM.call(er.simpleError,
er,[index,"use of variable '"+index.actualText+"' that is not definitely assigned"])}function useDefInit(bb){var v4333=bb,v26900=JAM.new(BBUseDefInfo,[bb]);v4333.useDef=v26900;v4333=bb.useDef;JAM.call(v4333.initialize,v4333,[useDefContext]);JAM.set(_this.linearBBs,_this.linearBBs.length,bb)}var _this=this,useDefContext=new UseDefContext;useDefContext.func=funcSym;JAM.call(this.bfs,this,[useDefInit,null,null,null]);var i,bbLen;i=0;bbLen=this.linearBBs.length;for(var v4339=i<bbLen;v4339;){v4339=this.linearBBs;
introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v4339=v4339[i];v4339=v4339.useDef;JAM.call(v4339.initializeGen,v4339,[useDefContext]);v4339=this.linearBBs;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v4339=v4339[i];v4339=v4339.useDef;JAM.call(v4339.initializeKill,v4339,[useDefContext]);i+=1;v4339=i<bbLen}for(v4339=!0;v4339;){v4339=!1;i=0;for(var v4341=i<bbLen;v4341;){v4341=this.linearBBs;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v4341=v4341[i];
(v4341=v4341.useDef.updateTop())||(v4341=v4339);v4339=v4341;i+=1;v4341=i<bbLen}}i=this.entry.useDef.top;JAM.call(i.map,i,[v998])}function v997(nodeFunc,edgeFunc,preEdges,postEdges){var markValue=this.markBase;this.markBase+=1;var q=[];q[q.length]=this.entry;for(var v4351=0<q.length;v4351;){v4351=q.pop();if(!JAM.call(v4351.marked,v4351,[markValue])){v4351.mark();nodeFunc&&JAM.call(nodeFunc,null,[v4351]);var succLen=v4351.successors.length;if(0<succLen){preEdges&&preEdges();for(var succLen=succLen-
1,v4348=0<=succLen;v4348;){v4348=v4351.successors;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v4348=v4348[succLen];JAM.call(v4348.marked,v4348,[this.markBase])||(edgeFunc&&JAM.call(edgeFunc,null,[v4351,v4348]),q[q.length]=v4348);succLen-=1;v4348=0<=succLen}postEdges&&postEdges()}}v4351=0<q.length}}function v996(bb,outfile){for(var content=bb.content,i=0,len=content.members.length,v4354=i<len;v4354;){v4354=content.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v4354=
v4354[i];JAM.call(this.printAST,this,[v4354,outfile]);i+=1;v4354=i<len}}function v995(ast,outfile){var printContext=JAM.new(TypeScript.PrintContext,[outfile,null]);printContext.increaseIndent();var v4356=TypeScript.getAstWalkerFactory();JAM.call(v4356.walk,v4356,[ast,TypeScript.prePrintAST,TypeScript.postPrintAST,null,printContext]);printContext.decreaseIndent()}function v994(er){var v14006=this.unreachable;v14006&&(v14006=0<this.unreachable.length);if(v14006)for(var v14006=this.unreachable.length,
i=0,v4362=i<v14006;v4362;){v4362=this.unreachable;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v4362=v4362[i];v4362.nodeType!=TypeScript.NodeType.EndCode&&JAM.call(er.simpleError,er,[v4362,"unreachable code"]);i+=1;v4362=i<v14006}}function v993(){return this.currentSwitch.pop()}function v992(bb){var v4365=this.currentSwitch;JAM.call(v4365.push,v4365,[bb])}function v991(ast,parent){var v4366=this.walker;return JAM.call(v4366.walk,v4366,[ast,parent])}function ControlFlowContext(current,
exit){this.current=current;this.exit=exit;this.unreachable=this.entry=null;this.noContinuation=!1;var v26901=[];this.statementStack=v26901;this.currentSwitch=v26901=[];this.markBase=0;this.linearBBs=v26901=[];this.entry=this.current}ControlFlowContext.prototype.walk=v991;ControlFlowContext.prototype.pushSwitch=v992;ControlFlowContext.prototype.popSwitch=v993;ControlFlowContext.prototype.reportUnreachable=v994;ControlFlowContext.prototype.printAST=v995;ControlFlowContext.prototype.printBlockContent=
v996;ControlFlowContext.prototype.bfs=v997;ControlFlowContext.prototype.useDef=v999;ControlFlowContext.prototype.print=v1000;ControlFlowContext.prototype.pushStatement=v1001;ControlFlowContext.prototype.popStatement=v1002;ControlFlowContext.prototype.returnStmt=v1003;ControlFlowContext.prototype.setUnreachable=v1004;ControlFlowContext.prototype.addUnreachable=v1005;ControlFlowContext.prototype.unconditionalBranch=v1006;ControlFlowContext.prototype.addContent=v1007;return ControlFlowContext}function v990(){function v989(successor){JAM.set(this.successors,
this.successors.length,successor);JAM.set(successor.predecessors,successor.predecessors.length,this)}function v988(){this.markValue+=1}function v987(markBase){return this.markValue>markBase}function BasicBlock(){var v26904=[];this.predecessors=v26904;this.index=-1;this.markValue=0;this.successors=v26904=[];this.useDef=null;this.content=v26904=new TypeScript.ASTList}BasicBlock.prototype.marked=v987;BasicBlock.prototype.mark=v988;BasicBlock.prototype.addSuccessor=v989;return BasicBlock}function v986(){function v985(b){this.firstBits&=
~b.firstBits;if(this.restOfBits)for(var k=0,len=this.restOfBits.length,v4396=k<len;v4396;){v4396=b.restOfBits;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v4396=v4396[k];var v4395=this.restOfBits;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v19796=v4395[k];v4395[k]=v19796&~v4396;k+=1;v4396=k<len}}function v984(b){if(this.firstBits!=b.firstBits)return!0;if(this.restOfBits)for(var k=0,len=this.restOfBits.length,v4403=k<len;v4403;){v4403=this.restOfBits;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v4403=
v4403[k];var v4401=b.restOfBits;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v4401=v4401[k];if(v4403!=v4401)return!0;k+=1;v4403=k<len}return!1}function v983(b){this.firstBits&=b.firstBits;if(this.restOfBits)for(var k=0,len=this.restOfBits.length,v4409=k<len;v4409;){v4409=this.restOfBits;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v4409=v4409[k];var v4407=b.restOfBits;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v4407=v4407[k];this.restOfBits[k]=
v4409&v4407;k+=1;v4409=k<len}}function v982(b){this.firstBits|=b.firstBits;if(this.restOfBits)for(var k=0,len=this.restOfBits.length,v4415=k<len;v4415;){v4415=this.restOfBits;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v4415=v4415[k];var v4413=b.restOfBits;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v4413=v4413[k];this.restOfBits[k]=v4415|v4413;k+=1;v4415=k<len}}function v981(fn){var k;k=0;for(var v4419=k<BitVector.packBits;v4419;){if(k==this.bitCount)return;
0!=(1<<k&this.firstBits)&&JAM.call(fn,null,[k]);k+=1;v4419=k<BitVector.packBits}if(this.restOfBits){var cumu=BitVector.packBits;k=0;for(var v4419=this.restOfBits.length,v4424=k<v4419;v4424;){v4424=this.restOfBits;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v4424=v4424[k];for(var j=0,v4423=j<BitVector.packBits;v4423;){0!=(1<<j&v4424)&&JAM.call(fn,null,[cumu]);cumu+=1;if(cumu==this.bitCount)return;j+=1;v4423=j<BitVector.packBits}k+=1;v4424=k<v4419}}}function v980(bitIndex,value){if(bitIndex<
BitVector.packBits)this.firstBits=value?this.firstBits|1<<bitIndex:this.firstBits&~(1<<bitIndex);else{var offset=Math.floor(bitIndex/BitVector.packBits)-1,localIndex=bitIndex%BitVector.packBits;if(value){var v4428=this.restOfBits;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v19803=v4428[offset];v4428[offset]=v19803|1<<localIndex}else{v4428=this.restOfBits;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v19803=v4428[offset];v4428[offset]=v19803&~(1<<localIndex)}}}
function BitVector(bitCount){this.bitCount=bitCount;this.firstBits=0;this.restOfBits=null;if(this.bitCount>BitVector.packBits){this.restOfBits=bitCount=[];bitCount=Math.floor(this.bitCount/BitVector.packBits);for(var i=0,v4433=i<bitCount;v4433;)this.restOfBits[i]=0,i+=1,v4433=i<bitCount}}BitVector.packBits=30;BitVector.prototype.set=v980;BitVector.prototype.map=v981;BitVector.prototype.union=v982;BitVector.prototype.intersection=v983;BitVector.prototype.notEq=v984;BitVector.prototype.difference=v985;
return BitVector}function v979(){function v978(sym,bbUses){var v4441=this.symbolMap,v4441=JAM.call(v4441.lookup,v4441,[sym.name]),v4443=this.useIndexBySymbol;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v4441=v4443[v4441];for(var v4443=0,len=v4441.length,v4445=v4443<len;v4445;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v4445=v4441[v4443];JAM.call(bbUses.set,bbUses,[v4445,!0]);v4443+=1;v4445=v4443<len}}function v977(sym){var v4446=sym;v4446&&(v4446=sym.container==
this.func)&&(v4446=sym.kind()==TypeScript.SymbolKind.Variable);return v4446}function v976(ast){JAM.set(this.uses,this.uses.length,ast);return this.uses.length-1}function v975(symIndex,astIndex){var v4450=this.useIndexBySymbol;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v4450=v4450[symIndex];void 0==v4450&&(v4450=[],JAM.set(this.useIndexBySymbol,symIndex,v4450));JAM.set(v4450,v4450.length,astIndex)}function v974(sym){var name=sym.name,v4454=this.symbolMap,v4454=JAM.call(v4454.lookup,
v4454,[name]);null==v4454&&(v4454=this.symbolCount,this.symbolCount+=1,JAM.set(this.symbols,v4454,sym),sym=this.symbolMap,JAM.call(sym.add,sym,[name,v4454]));return v4454}function UseDefContext(){var v26908=[];this.useIndexBySymbol=v26908;this.uses=v26908=[];this.symbols=v26908=[];this.symbolMap=v26908=new TypeScript.StringHashTable;this.symbolCount=0}UseDefContext.prototype.getSymbolIndex=v974;UseDefContext.prototype.addUse=v975;UseDefContext.prototype.getUseIndex=v976;UseDefContext.prototype.isLocalSym=
v977;UseDefContext.prototype.killSymbol=v978;return UseDefContext}function v973(){function v972(useDefContext){var v26912=JAM.new(BitVector,[this.gen.bitCount]);this.kill=v26912;for(var v26912=0,symbolLen=this.defsBySymbol.length,v4471=v26912<symbolLen;v4471;){v4471=this.defsBySymbol;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v4471=v4471[v26912];if(v4471){v4471=useDefContext.useIndexBySymbol;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v4471=v4471[v26912];if(v4471)for(var u=
0,useLen=v4471.length,v4469=u<useLen;v4469;){v4469=this.kill;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v4468=v4471[u];JAM.call(v4469.set,v4469,[v4468,!0]);u+=1;v4469=u<useLen}}v26912+=1;v4471=v26912<symbolLen}}function v971(useDefContext){var symbolLen=this.useIndexBySymbol.length;useDefContext=useDefContext.uses.length;this.gen=useDefContext=JAM.new(BitVector,[useDefContext]);useDefContext=0;for(var v4479=useDefContext<symbolLen;v4479;){v4479=this.useIndexBySymbol;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v4479=
v4479[useDefContext];var v14045=void 0!=v4479;v14045&&(v14045=0<v4479.length);if(v14045)for(var v14045=0,uLen=v4479.length,v4477=v14045<uLen;v4477;){v4477=this.gen;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v4476=v4479[v14045];JAM.call(v4477.set,v4477,[v4476,!0]);v14045+=1;v4477=v14045<uLen}useDefContext+=1;v4479=useDefContext<symbolLen}this.top=this.gen}function v970(useDefContext){function defSym(sym,context){if(JAM.call(context.isLocalSym,context,[sym])){var index=JAM.call(context.getSymbolIndex,
context,[sym]),v4480=_this.useIndexBySymbol,v4481=index,v26914=[];JAM.set(v4480,v4481,v26914);JAM.set(_this.defsBySymbol,index,!0)}}function initUseDefPre(cur,parent,walker){var context=walker.state;null==cur&&(cur=null);if(cur.nodeType==TypeScript.NodeType.VarDecl)walker=cur,(parent=walker.init)||(parent=JAM.call(TypeScript.hasFlag,TypeScript,[walker.varFlags,TypeScript.VarFlags.AutoInit])),parent&&defSym(walker.sym,context);else if(cur.nodeType==TypeScript.NodeType.Name){if(parent)if(parent.nodeType==
TypeScript.NodeType.Asg){if(walker=parent,walker.operand1==cur)return cur}else if(parent.nodeType==TypeScript.NodeType.VarDecl&&(walker=parent,walker.id==cur))return cur;walker=cur;parent=walker.sym;walker=cur;if(JAM.call(context.isLocalSym,context,[parent])){parent=JAM.call(context.getSymbolIndex,context,[parent]);var v19819=_this.useIndexBySymbol;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v19819=v19819[parent];if(void 0==v19819){var v19819=_this.useIndexBySymbol,v4492=parent,
v26915=[];JAM.set(v19819,v4492,v26915)}v19819=_this.useIndexBySymbol;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v19819=v19819[parent];walker=JAM.call(context.getUseIndex,context,[walker]);JAM.call(context.addUse,context,[parent,walker]);JAM.call(v19819.push,v19819,[walker])}}else(parent=cur.nodeType>=TypeScript.NodeType.Asg)&&(parent=cur.nodeType<=TypeScript.NodeType.LastAsg),parent?(walker=cur,(parent=walker.operand1)&&(parent=walker.operand1.nodeType==TypeScript.NodeType.Name),
parent&&(walker=walker.operand1,defSym(walker.sym,context))):cur.nodeType==TypeScript.NodeType.FuncDecl&&(walker.options.goChildren=!1);return cur}var _this=this,options=new TypeScript.AstWalkOptions;options.reverseSiblings=!0;var v4504=TypeScript.getAstWalkerFactory();JAM.call(v4504.walk,v4504,[this.bb.content,initUseDefPre,null,options,useDefContext])}function v969(){for(var temp=JAM.new(BitVector,[this.top.bitCount]),i=0,succLen=this.bb.successors.length,v4511=i<succLen;v4511;){v4511=this.bb.successors;
introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v4511=v4511[i];v4511.useDef&&JAM.call(temp.union,temp,[v4511.useDef.top]);i+=1;v4511=i<succLen}JAM.call(temp.difference,temp,[this.kill]);JAM.call(temp.union,temp,[this.gen]);i=JAM.call(temp.notEq,temp,[this.top]);this.top=temp;return i}function BBUseDefInfo(bb){this.bb=bb;this.defsBySymbol=bb=[];this.useIndexBySymbol=bb=[]}BBUseDefInfo.prototype.updateTop=v969;BBUseDefInfo.prototype.initialize=v970;BBUseDefInfo.prototype.initializeGen=
v971;BBUseDefInfo.prototype.initializeKill=v972;return BBUseDefInfo}function v968(){function ScopeChain(container,previous,scope){this.container=container;this.previous=previous;this.scope=scope}return ScopeChain}var ScopeChain=v968();TypeScript.ScopeChain=ScopeChain;var BBUseDefInfo=v973();TypeScript.BBUseDefInfo=BBUseDefInfo;var UseDefContext=v979();TypeScript.UseDefContext=UseDefContext;var BitVector=v986();TypeScript.BitVector=BitVector;var BasicBlock=v990();TypeScript.BasicBlock=BasicBlock;BasicBlock=
v1008();TypeScript.ControlFlowContext=BasicBlock;var ResolutionDataCache=v1011();TypeScript.ResolutionDataCache=ResolutionDataCache;BasicBlock=v1112();TypeScript.TypeFlow=BasicBlock}
function v967(){var TypeScript=v18815;function v966(){function Continuation(normalBlock){this.normalBlock=normalBlock;this.exceptionBlock=-1}return Continuation}function getBaseTypeLinks(bases,baseTypeLinks){if(bases){var len=bases.members.length;null==baseTypeLinks&&(baseTypeLinks=[]);for(var i=0,v4524=i<len;v4524;){v4524=bases.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v4524=v4524[i];var typeLink=new TypeScript.TypeLink;typeLink.ast=v4524;JAM.set(baseTypeLinks,baseTypeLinks.length,
typeLink);i+=1;v4524=i<len}}return baseTypeLinks}function getBases(type,typeDecl){var v4525=type,v26918=getBaseTypeLinks(typeDecl.extendsList,type.extendsTypeLinks);v4525.extendsTypeLinks=v26918;v4525=type;v26918=getBaseTypeLinks(typeDecl.implementsList,type.implementsTypeLinks);v4525.implementsTypeLinks=v26918}function createNewConstructGroupForType(type){var signature=new TypeScript.Signature,v4528=signature,v26920=new TypeScript.TypeLink;v4528.returnType=v26920;signature.returnType.type=type.instanceType;
signature.parameters=[];v4528=type;v26920=new TypeScript.SignatureGroup;v4528.construct=v26920;type=type.construct;JAM.call(type.addSignature,type,[signature])}function cloneParentConstructGroupForChildType(child,parent){var v4532=child,v26922=new TypeScript.SignatureGroup;v4532.construct=v26922;v26922=null;parent.construct||createNewConstructGroupForType(parent);v4532=0;for(v26922=v4532<parent.construct.signatures.length;v26922;){var v26922=new TypeScript.Signature,v14076=parent.construct.signatures;
introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v14076=v14076[v4532];v26922.parameters=v14076.parameters;v14076=parent.construct.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v14076=v14076[v4532];v26922.nonOptionalParameterCount=v14076.nonOptionalParameterCount;v14076=parent.construct.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v14076=v14076[v4532];v26922.typeCheckStatus=v14076.typeCheckStatus;v14076=parent.construct.signatures;
introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v14076=v14076[v4532];v26922.declAST=v14076.declAST;var v14076=v26922,v26923=new TypeScript.TypeLink;v14076.returnType=v26923;v26922.returnType.type=child.instanceType;v14076=child.construct;JAM.call(v14076.addSignature,v14076,[v26922]);v4532+=1;v26922=v4532<parent.construct.signatures.length}}function findTypeSymbolInScopeChain(name,scopeChain){var v4543=scopeChain.scope,v4543=JAM.call(v4543.find,v4543,[name,!1,!0]),v14082=null==v4543;
v14082&&(v14082=scopeChain.previous);v14082&&(v4543=findTypeSymbolInScopeChain(name,scopeChain.previous));return v4543}function findSymbolFromAlias(alias,context){function v965(id){return context.members?(id=context.members,JAM.call(id.lookup,id,[name])):findTypeSymbolInScopeChain(name,context.topLevelScope)}var symbol=null;switch(alias.nodeType){case TypeScript.NodeType.Name:var name=alias.text,isDynamic=JAM.call(TypeScript.isQuoted,TypeScript,[name]),symbol=v965;isDynamic?(isDynamic=context.tcContext.checker,
symbol=JAM.call(isDynamic.findSymbolForDynamicModule,isDynamic,[name,context.tcContext.script.locationInfo.filename,symbol])):symbol=JAM.call(symbol,null,[name]);break;case TypeScript.NodeType.Dot:var isDynamic=alias,op1Sym=findSymbolFromAlias(isDynamic.operand1,context),v14085=op1Sym;v14085&&(v14085=op1Sym.getType());v14085&&(symbol=findSymbolFromAlias(isDynamic.operand2,context))}symbol&&(isDynamic=symbol.getType())&&(isDynamic=isDynamic.members)&&(context.members=isDynamic.publicMembers);return symbol}
function preCollectImportTypes(ast,parent,context){parent=context.scopeChain;var typeSymbol=null,typeSymbol=null,importDecl=ast,aliasedModSymbol=findSymbolFromAlias(importDecl.alias,{topLevelScope:parent,members:null,tcContext:context}),isGlobal=context.scopeChain.container==context.checker.gloMod;aliasedModSymbol&&(aliasedModSymbol=aliasedModSymbol.getType())&&(typeSymbol=aliasedModSymbol);typeSymbol=JAM.new(TypeScript.TypeSymbol,[importDecl.id.text,importDecl.id.minChar,importDecl.limChar-importDecl.minChar,
context.checker.locationInfo.unitIndex,typeSymbol]);typeSymbol.aliasLink=importDecl;context.scopeChain.moduleDecl&&(typeSymbol.flags|=TypeScript.SymbolFlags.ModuleMember,typeSymbol.declModule=context.scopeChain.moduleDecl);typeSymbol.declAST=importDecl;importDecl.id.sym=typeSymbol;importDecl=parent.scope;JAM.call(importDecl.enter,importDecl,[parent.container,ast,typeSymbol,context.checker.errorReporter,isGlobal,!0,!1]);importDecl=parent.scope;JAM.call(importDecl.enter,importDecl,[parent.container,
ast,typeSymbol,context.checker.errorReporter,isGlobal,!1,!1]);return!0}function preCollectModuleTypes(ast,parent,context){var scopeChain=context.scopeChain;parent=ast;var isAmbient=JAM.call(TypeScript.hasFlag,TypeScript,[parent.modFlags,TypeScript.ModuleFlags.Ambient]),isEnum=JAM.call(TypeScript.hasFlag,TypeScript,[parent.modFlags,TypeScript.ModuleFlags.IsEnum]),isGlobal=context.scopeChain.container==context.checker.gloMod,isExported=JAM.call(TypeScript.hasFlag,TypeScript,[parent.modFlags,TypeScript.ModuleFlags.Exported]),
modName=parent.name.text;JAM.call(TypeScript.isQuoted,TypeScript,[modName]);var v4582=scopeChain.scope,symbol=JAM.call(v4582.findLocal,v4582,[modName,!1,!1]),modType=v4582=null;(v4582=null==symbol)||(v4582=symbol.kind()!=TypeScript.SymbolKind.Type);v4582?(null==modType&&(modType=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,[new TypeScript.StringHashTable,new TypeScript.StringHashTable])]),symbol=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,[new TypeScript.StringHashTable,
new TypeScript.StringHashTable])]),modType=JAM.new(TypeScript.ModuleType,[modType,symbol]),isEnum&&(modType.typeFlags|=TypeScript.TypeFlags.IsEnum),v4582=modType,isEnum=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,[new TypeScript.StringHashTable,new TypeScript.StringHashTable])]),v4582.members=isEnum,v4582=modType,isEnum=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,[new TypeScript.StringHashTable,new TypeScript.StringHashTable])]),v4582.ambientMembers=
isEnum,modType.setHasImplementation()),isEnum=v4582=JAM.new(TypeScript.TypeSymbol,[modName,parent.name.minChar,modName.length,context.checker.locationInfo.unitIndex,modType]),modName=JAM.call(TypeScript.isQuoted,TypeScript,[parent.prettyName]),isEnum.isDynamic=modName,context.scopeChain.moduleDecl&&(v4582.declModule=context.scopeChain.moduleDecl),v4582.declAST=parent,v4582.prettyName=parent.prettyName,isEnum=scopeChain.scope,JAM.call(isEnum.enter,isEnum,[scopeChain.container,ast,v4582,context.checker.errorReporter,
isExported||isGlobal,!0,isAmbient]),isEnum=scopeChain.scope,JAM.call(isEnum.enter,isEnum,[scopeChain.container,ast,v4582,context.checker.errorReporter,isExported||isGlobal,!1,isAmbient]),modType.symbol=v4582):((v4582=symbol)&&(v4582=symbol.declAST)&&(v4582=symbol.declAST.nodeType!=TypeScript.NodeType.ModuleDeclaration),v4582&&(v4582=context.checker.errorReporter,JAM.call(v4582.simpleError,v4582,[parent,"Conflicting symbol name for module '"+modName+"'"])),v4582=symbol,modType=v4582.type.getAllEnclosedTypes().publicMembers,
modType=null==modType?new TypeScript.StringHashTable:modType,modType=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,[modType,new TypeScript.StringHashTable])]),ast=v4582.type.getAllAmbientEnclosedTypes().publicMembers,ast=null==ast?new TypeScript.StringHashTable:ast,symbol=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,[ast,new TypeScript.StringHashTable])]),ast=v4582.type.members.publicMembers,ast=null==ast?new TypeScript.StringHashTable:ast,ast=
JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,[ast,new TypeScript.StringHashTable])]),scopeChain=v4582.type.ambientMembers.publicMembers,scopeChain=null==scopeChain?new TypeScript.StringHashTable:scopeChain,scopeChain=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,[scopeChain,new TypeScript.StringHashTable])]),modType=JAM.new(TypeScript.ModuleType,[modType,symbol]),isEnum&&(modType.typeFlags|=TypeScript.TypeFlags.IsEnum),modType.members=ast,modType.ambientMembers=
scopeChain,modType.setHasImplementation(),modType.symbol=v4582,JAM.call(v4582.addLocation,v4582,[parent.minChar]),isEnum=v4582.expansions,JAM.call(isEnum.push,isEnum,[modType]),isEnum=v4582.expansionsDeclAST,JAM.call(isEnum.push,isEnum,[parent]));context.scopeChain.moduleDecl&&context.scopeChain.moduleDecl.recordNonInterface();isExported&&(v4582.flags|=TypeScript.SymbolFlags.Exported);(isExported=context.scopeChain.moduleDecl)||(isExported=context.scopeChain.container==context.checker.gloMod);isExported&&
(v4582.flags|=TypeScript.SymbolFlags.ModuleMember);parent.mod=modType;JAM.call(TypeScript.pushTypeCollectionScope,TypeScript,[v4582,modType.members,modType.ambientMembers,modType.enclosedTypes,modType.ambientEnclosedTypes,context,null,null,parent]);return!0}function preCollectClassTypes(ast,parent,context){var scopeChain=context.scopeChain;parent=ast;var instanceType,typeSymbol=null,className=parent.name.text,isAmbient=JAM.call(TypeScript.hasFlag,TypeScript,[parent.varFlags,TypeScript.VarFlags.Ambient]),
isExported=JAM.call(TypeScript.hasFlag,TypeScript,[parent.varFlags,TypeScript.VarFlags.Exported]),isGlobal=context.scopeChain.container==context.checker.gloMod;instanceType=!1;typeSymbol=scopeChain.scope;typeSymbol=JAM.call(typeSymbol.findLocal,typeSymbol,[className,!1,!0]);if(!typeSymbol){var v4645=scopeChain.scope,v14158=v4645=JAM.call(v4645.findLocal,v4645,[className,!1,!1]);v14158&&(v14158=v4645.isType())&&(v14158=v4645.declAST)&&(v14158=v4645.declAST.nodeType==TypeScript.NodeType.FuncDecl)&&
(v14158=v4645.declAST.isSignature());v14158&&(typeSymbol=v4645,instanceType=!0,isExported&&(typeSymbol.flags|=TypeScript.SymbolFlags.Exported),isAmbient&&(typeSymbol.flags|=TypeScript.SymbolFlags.Ambient),v4645=context.scopeChain.scope,JAM.call(v4645.enter,v4645,[context.scopeChain.container,ast,typeSymbol,context.checker.errorReporter,isExported||isGlobal,!0,isAmbient]))}if(v4645=typeSymbol)(instanceType=!instanceType)&&(instanceType=typeSymbol.declAST!=parent),v4645=instanceType;v4645&&(typeSymbol=
null);if(null==typeSymbol){scopeChain=scopeChain.scope;v4645=JAM.call(scopeChain.findLocal,scopeChain,[className,!1,!1]);scopeChain=new TypeScript.Type;scopeChain.setHasImplementation();instanceType=new TypeScript.Type;instanceType.setHasImplementation();scopeChain.instanceType=instanceType;typeSymbol=scopeChain;v14158=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,[new TypeScript.StringHashTable,new TypeScript.StringHashTable])]);typeSymbol.members=v14158;typeSymbol=scopeChain;
v14158=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,[new TypeScript.StringHashTable,new TypeScript.StringHashTable])]);typeSymbol.ambientMembers=v14158;var typeSymbol=scopeChain,v14158=parent,context$$0=context,field=new TypeScript.ValueLocation,v4659=field,v26929=new TypeScript.TypeLink;v4659.typeLink=v26929;field.typeLink.ast=v14158;field.typeLink.type=typeSymbol.instanceType;context$$0=JAM.new(TypeScript.FieldSymbol,["prototype",v14158.minChar,context$$0.checker.locationInfo.unitIndex,
!0,field]);context$$0.flags=context$$0.flags|TypeScript.SymbolFlags.Property|TypeScript.SymbolFlags.BuiltIn;field.symbol=context$$0;context$$0.declAST=v14158;typeSymbol=typeSymbol.members;JAM.call(typeSymbol.addPublicMember,typeSymbol,["prototype",context$$0]);typeSymbol=instanceType;v14158=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,[new TypeScript.StringHashTable,new TypeScript.StringHashTable])]);typeSymbol.members=v14158;typeSymbol=instanceType;v14158=JAM.new(TypeScript.ScopedMembers,
[JAM.new(TypeScript.DualStringHashTable,[new TypeScript.StringHashTable,new TypeScript.StringHashTable])]);typeSymbol.ambientMembers=v14158;typeSymbol=JAM.new(TypeScript.TypeSymbol,[className,parent.name.minChar,className.length,context.checker.locationInfo.unitIndex,scopeChain]);typeSymbol.declAST=parent;typeSymbol.instanceType=instanceType;scopeChain.symbol=typeSymbol;instanceType.symbol=typeSymbol;context.scopeChain.moduleDecl&&(context.scopeChain.moduleDecl.recordNonInterface(),typeSymbol.declModule=
context.scopeChain.moduleDecl,typeSymbol.flags|=TypeScript.SymbolFlags.ModuleMember);isExported&&(typeSymbol.flags|=TypeScript.SymbolFlags.Exported);isAmbient&&(typeSymbol.flags|=TypeScript.SymbolFlags.Ambient);ast.type=scopeChain;className=context.scopeChain.scope;JAM.call(className.enter,className,[context.scopeChain.container,ast,typeSymbol,context.checker.errorReporter,isExported||isGlobal,!0,isAmbient]);null==v4645&&(className=context.scopeChain.scope,JAM.call(className.enter,className,[context.scopeChain.container,
ast,typeSymbol,context.checker.errorReporter,isExported||isGlobal,!1,isAmbient]))}else scopeChain=typeSymbol.type,null==scopeChain.instanceType&&(isAmbient=scopeChain,isExported=new TypeScript.Type,isAmbient.instanceType=isExported,scopeChain.instanceType.setHasImplementation(),isAmbient=scopeChain.instanceType,isExported=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,[new TypeScript.StringHashTable,new TypeScript.StringHashTable])]),isAmbient.members=isExported,scopeChain.instanceType.symbol=
scopeChain.symbol,isAmbient=scopeChain,isExported=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,[new TypeScript.StringHashTable,new TypeScript.StringHashTable])]),isAmbient.members=isExported,isAmbient=scopeChain,isExported=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,[new TypeScript.StringHashTable,new TypeScript.StringHashTable])]),isAmbient.ambientMembers=isExported),instanceType=scopeChain.instanceType,ast.type=scopeChain;parent.constructorDecl||
((ast=typeSymbol)&&(ast=typeSymbol.declAST)&&(ast=typeSymbol.declAST.type)&&(ast=typeSymbol.declAST.type.call)&&(ast=!typeSymbol.declAST.isOverload),ast&&(ast=context.checker.errorReporter,JAM.call(ast.duplicateIdentifier,ast,[typeSymbol.declAST,typeSymbol.name])),createNewConstructGroupForType(parent.type));scopeChain.typeFlags|=TypeScript.TypeFlags.IsClass;instanceType.typeFlags|=TypeScript.TypeFlags.IsClass;getBases(instanceType,parent);JAM.call(TypeScript.pushTypeCollectionScope,TypeScript,[typeSymbol,
instanceType.members,instanceType.ambientMembers,null,null,context,instanceType,scopeChain,null]);return!0}function preCollectInterfaceTypes(ast,parent,context){var scopeChain=context.scopeChain,interfaceDecl=ast,interfaceSymbol=null,interfaceType=null;parent=JAM.call(TypeScript.hasFlag,TypeScript,[interfaceDecl.varFlags,TypeScript.VarFlags.Exported]);var isGlobal=context.scopeChain.container==context.checker.gloMod,alreadyInScope=!0,alreadyInScope=!1,interfaceName=interfaceDecl.name.text,interfaceSymbol=
scopeChain.scope,interfaceSymbol=JAM.call(interfaceSymbol.findLocal,interfaceSymbol,[interfaceName,!1,!0]);null==interfaceSymbol?(interfaceType=new TypeScript.Type,interfaceSymbol=JAM.new(TypeScript.TypeSymbol,[interfaceName,interfaceDecl.name.minChar,interfaceName.length,context.checker.locationInfo.unitIndex,interfaceType]),interfaceType.symbol=interfaceSymbol,interfaceName=interfaceType,scopeChain=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,[new TypeScript.StringHashTable,
new TypeScript.StringHashTable])]),interfaceName.members=scopeChain,interfaceName=interfaceType,scopeChain=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,[new TypeScript.StringHashTable,new TypeScript.StringHashTable])]),interfaceName.ambientMembers=scopeChain,interfaceSymbol.declAST=interfaceDecl,interfaceSymbol.declModule=context.scopeChain.moduleDecl):(alreadyInScope=!0,interfaceType=interfaceSymbol.type);interfaceType||(interfaceType=context.checker.anyType);ast.type=
interfaceType;getBases(interfaceType,interfaceDecl);parent&&(interfaceSymbol.flags|=TypeScript.SymbolFlags.Exported);context.scopeChain.moduleDecl&&(interfaceSymbol.flags|=TypeScript.SymbolFlags.ModuleMember);alreadyInScope||(interfaceDecl=context.scopeChain.scope,JAM.call(interfaceDecl.enter,interfaceDecl,[context.scopeChain.container,ast,interfaceSymbol,context.checker.errorReporter,isGlobal||parent,!0,!1]));JAM.call(TypeScript.pushTypeCollectionScope,TypeScript,[interfaceSymbol,interfaceType.members,
interfaceType.ambientMembers,null,null,context,interfaceType,null,null]);return!0}function preCollectArgDeclTypes(ast,parent,context){parent=ast;if(JAM.call(TypeScript.hasFlag,TypeScript,[parent.varFlags,TypeScript.VarFlags.Public|TypeScript.VarFlags.Private])){var field=new TypeScript.ValueLocation,isPrivate=JAM.call(TypeScript.hasFlag,TypeScript,[parent.varFlags,TypeScript.VarFlags.Private]),fieldSymbol=JAM.new(TypeScript.FieldSymbol,[parent.id.text,parent.id.minChar,context.checker.locationInfo.unitIndex,
!JAM.call(TypeScript.hasFlag,TypeScript,[parent.varFlags,TypeScript.VarFlags.Readonly]),field]);JAM.call(fieldSymbol.transferVarFlags,fieldSymbol,[parent.varFlags]);field.symbol=fieldSymbol;fieldSymbol.declAST=ast;parent.parameterPropertySym=fieldSymbol;var v4734=context.scopeChain.scope;JAM.call(v4734.enter,v4734,[context.scopeChain.container,ast,fieldSymbol,context.checker.errorReporter,!isPrivate,!1,!1]);ast=field;context=JAM.call(TypeScript.getTypeLink,TypeScript,[parent.typeExpr,context.checker,
null==parent.init]);ast.typeLink=context;parent.sym=fieldSymbol}return!1}function preCollectVarDeclTypes(ast,parent,context){var scopeChain=context.scopeChain;parent=ast;var isAmbient=JAM.call(TypeScript.hasFlag,TypeScript,[parent.varFlags,TypeScript.VarFlags.Ambient]),isExported=JAM.call(TypeScript.hasFlag,TypeScript,[parent.varFlags,TypeScript.VarFlags.Exported]),isGlobal=context.scopeChain.container==context.checker.gloMod,isProperty=JAM.call(TypeScript.hasFlag,TypeScript,[parent.varFlags,TypeScript.VarFlags.Property]),
isStatic=JAM.call(TypeScript.hasFlag,TypeScript,[parent.varFlags,TypeScript.VarFlags.Static]),isPrivate=JAM.call(TypeScript.hasFlag,TypeScript,[parent.varFlags,TypeScript.VarFlags.Private]),isOptional=JAM.call(TypeScript.hasFlag,TypeScript,[parent.id.flags,TypeScript.ASTFlags.OptionalName]);context.scopeChain.moduleDecl&&context.scopeChain.moduleDecl.recordNonInterface();var v14251=isProperty;v14251||(v14251=isExported,v14251||(v14251=context.scopeChain.container==context.checker.gloMod,v14251||(v14251=
context.scopeChain.moduleDecl)));if(v14251){if(isAmbient&&(scopeChain=scopeChain.scope,scopeChain=JAM.call(scopeChain.findLocal,scopeChain,[parent.id.text,!1,!1])))return parent.sym=scopeChain,!1;if(null==parent.id)return context=context.checker.errorReporter,JAM.call(context.simpleError,context,[parent,"Expected variable identifier at this location"]),!1;v14251=new TypeScript.ValueLocation;scopeChain=JAM.new(TypeScript.FieldSymbol,[parent.id.text,parent.id.minChar,context.checker.locationInfo.unitIndex,
(parent.varFlags&TypeScript.VarFlags.Readonly)==TypeScript.VarFlags.None,v14251]);JAM.call(scopeChain.transferVarFlags,scopeChain,[parent.varFlags]);isOptional&&(scopeChain.flags|=TypeScript.SymbolFlags.Optional);v14251.symbol=scopeChain;scopeChain.declAST=ast;(isOptional=context.scopeChain.moduleDecl)||(isOptional=context.scopeChain.container==context.checker.gloMod);isOptional&&(scopeChain.flags|=TypeScript.SymbolFlags.ModuleMember,scopeChain.declModule=context.scopeChain.moduleDecl);if(isOptional=
JAM.call(TypeScript.hasFlag,TypeScript,[parent.varFlags,TypeScript.VarFlags.Property]))if(isOptional=isStatic)isOptional=context.scopeChain.classType;if(isOptional)isAmbient=context.scopeChain.classType.members.publicMembers,JAM.call(isAmbient.add,isAmbient,[parent.id.text,scopeChain])||(isAmbient=context.checker.errorReporter,JAM.call(isAmbient.duplicateIdentifier,isAmbient,[ast,scopeChain.name])),scopeChain.container=context.scopeChain.classType.symbol;else{var isOptional=context.scopeChain.scope,
v4774=context.scopeChain.container,v4775=context.checker.errorReporter;if(isPrivate=!isPrivate)isProperty||(isExported||(isExported=isGlobal||isStatic),isProperty=isExported),isPrivate=isProperty;JAM.call(isOptional.enter,isOptional,[v4774,ast,scopeChain,v4775,isPrivate,!1,isAmbient])}JAM.call(TypeScript.hasFlag,TypeScript,[parent.varFlags,TypeScript.VarFlags.Exported])&&(scopeChain.flags|=TypeScript.SymbolFlags.Exported);ast=v14251;context=JAM.call(TypeScript.getTypeLink,TypeScript,[parent.typeExpr,
context.checker,null==parent.init]);ast.typeLink=context;parent.sym=scopeChain}return!1}function preCollectFuncDeclTypes(ast,parent,context){var scopeChain=context.scopeChain;context.scopeChain.moduleDecl&&context.scopeChain.moduleDecl.recordNonInterface();parent=ast;var fgSym=null,nameText=parent.getNameText(),isExported=JAM.call(TypeScript.hasFlag,TypeScript,[parent.fncFlags,TypeScript.FncFlags.Exported|TypeScript.FncFlags.ClassPropertyMethodExported]),isStatic=JAM.call(TypeScript.hasFlag,TypeScript,
[parent.fncFlags,TypeScript.FncFlags.Static]);JAM.call(TypeScript.hasFlag,TypeScript,[parent.fncFlags,TypeScript.FncFlags.Private]);var v4789=parent.isConstructMember();v4789||(v4789=parent.isConstructor);var isConstructor=v4789;(v4789=parent.isMethod())&&(v4789=isStatic);v4789||(v4789=parent.isAccessor());v4789&&(v4789=context.scopeChain.classType);var containerSym=v4789=v4789?context.scopeChain.classType.symbol:context.scopeChain.container,containerScope=context.scopeChain.scope;(v4789=parent.name)&&
(v4789=JAM.call(TypeScript.hasFlag,TypeScript,[parent.name.flags,TypeScript.ASTFlags.OptionalName]));var go=!1,foundSymbol=!1,v14293=isConstructor;v14293&&(v14293=JAM.call(TypeScript.hasFlag,TypeScript,[parent.fncFlags,TypeScript.FncFlags.ClassMethod]));v14293&&(containerSym=containerSym.container,containerScope=scopeChain.previous.scope);parent.unitIndex=context.checker.locationInfo.unitIndex;(scopeChain=!parent.isConstructor)&&(scopeChain=containerSym)&&(scopeChain=containerSym.declAST)&&(scopeChain=
containerSym.declAST.nodeType==TypeScript.NodeType.FuncDecl)&&(scopeChain=containerSym.declAST.isConstructor)&&(scopeChain=!parent.isMethod());if(scopeChain)return go;if(JAM.call(TypeScript.hasFlag,TypeScript,[parent.fncFlags,TypeScript.FncFlags.Signature]))isConstructor=context.scopeChain.thisType,(scopeChain=nameText)&&(scopeChain="__missing"!=nameText),scopeChain&&(isStatic?(fgSym=containerSym.type.members.allMembers,fgSym=JAM.call(fgSym.lookup,fgSym,[nameText])):(fgSym=JAM.call(containerScope.findLocal,
containerScope,[nameText,!1,!1]),null==fgSym&&(fgSym=JAM.call(containerScope.findLocal,containerScope,[nameText,!1,!0]))),fgSym&&(foundSymbol=!0,(nameText=!parent.isSignature())&&(nameText=JAM.call(TypeScript.hasFlag,TypeScript,[parent.fncFlags,TypeScript.FncFlags.Ambient])!=JAM.call(TypeScript.hasFlag,TypeScript,[fgSym.flags,TypeScript.SymbolFlags.Ambient])),nameText&&(fgSym=null))),null==fgSym?(parent.isSpecialFn()?(fgSym=context.checker,fgSym=JAM.call(fgSym.createFunctionSignature,fgSym,[parent,
containerSym,containerScope,containerSym,!1]).declAST.type.symbol):(fgSym=context.checker,fgSym=JAM.call(fgSym.createFunctionSignature,fgSym,[parent,containerSym,containerScope,null,!foundSymbol]).declAST.type.symbol),(containerSym=null==fgSym.declAST)||(containerSym=!parent.isSpecialFn()),containerSym&&(fgSym.declAST=ast)):fgSym.kind()==TypeScript.SymbolKind.Type?(ast=context.checker,fgSym=JAM.call(ast.createFunctionSignature,ast,[parent,containerSym,containerScope,fgSym,!1]).declAST.type.symbol):
(ast=context.checker.errorReporter,JAM.call(ast.simpleError,ast,[parent,"Function or method '"+parent.name.actualText+"' already declared as a property"])),(ast=parent.isSpecialFn())&&(ast=!isStatic),ast?(isStatic=isConstructor?isConstructor:fgSym.type,parent.type=isStatic):parent.type=fgSym.type;else{if(nameText){if(isStatic)fgSym=containerSym.type.members.allMembers,fgSym=JAM.call(fgSym.lookup,fgSym,[nameText]);else{if(scopeChain=parent.isConstructor)scopeChain=context.scopeChain.previous;scopeChain&&
(fgSym=context.scopeChain.previous.scope,fgSym=JAM.call(fgSym.findLocal,fgSym,[nameText,!1,!1]));null==fgSym&&(fgSym=JAM.call(containerScope.findLocal,containerScope,[nameText,!1,!1]))}fgSym&&(foundSymbol=!0,(nameText=!isConstructor)&&(nameText=fgSym.declAST.nodeType==TypeScript.NodeType.FuncDecl)&&(nameText=!fgSym.declAST.isAccessor())&&(nameText=!fgSym.declAST.isSignature()),nameText&&(fgSym=null,foundSymbol=!1))}if(nameText=fgSym)if(nameText=!fgSym.isAccessor())if(nameText=fgSym.type)if(nameText=
fgSym.type.construct)if(nameText=fgSym.type.construct.signatures!=[])(nameText=null==fgSym.type.construct.signatures[0].declAST)||(nameText=!JAM.call(TypeScript.hasFlag,TypeScript,[fgSym.type.construct.signatures[0].declAST.fncFlags,TypeScript.FncFlags.Ambient])),nameText&&(nameText=!parent.isConstructor);nameText&&(nameText=context.checker.errorReporter,JAM.call(nameText.simpleError,nameText,[parent,"Functions may not have class overloads"]));(nameText=fgSym)&&(nameText=fgSym.kind()!=TypeScript.SymbolKind.Type)&&
(nameText=parent.isMethod())&&(nameText=!parent.isAccessor())&&(nameText=!parent.isConstructor);nameText&&(nameText=context.checker.errorReporter,JAM.call(nameText.simpleError,nameText,[parent,"Function or method '"+parent.name.actualText+"' already declared as a property"]),fgSym.type=context.checker.anyType);nameText=context.checker;JAM.call(nameText.createFunctionSignature,nameText,[parent,containerSym,containerScope,fgSym,!foundSymbol]);(foundSymbol=!fgSym)||(foundSymbol=fgSym.declAST.nodeType!=
TypeScript.NodeType.FuncDecl);foundSymbol&&(foundSymbol=parent.isAccessor());foundSymbol||(foundSymbol=fgSym)&&(foundSymbol=fgSym.isAccessor());foundSymbol&&(foundSymbol=parent,nameText=context.checker,isConstructor=containerSym.type,(scopeChain=parent.isMethod())&&(scopeChain=isStatic),isStatic=JAM.call(nameText.createAccessorSymbol,nameText,[parent,fgSym,isConstructor,scopeChain,!0,containerScope,containerSym]),foundSymbol.accessorSymbol=isStatic);parent.type.symbol.declAST=ast;parent.isConstructor&&
(go=!0)}if(isExported){parent.type.call&&(isExported=parent.type.symbol,isExported.flags|=TypeScript.SymbolFlags.Exported);if(isExported=fgSym)if(isExported=!fgSym.isAccessor())if(isExported=fgSym.kind()==TypeScript.SymbolKind.Type)isExported=fgSym.type.call;isExported&&(fgSym.flags|=TypeScript.SymbolFlags.Exported)}(isExported=context.scopeChain.moduleDecl)&&(isExported=!parent.isSpecialFn());isExported&&(isExported=parent.type.symbol,isExported.flags|=TypeScript.SymbolFlags.ModuleMember,parent.type.symbol.declModule=
context.scopeChain.moduleDecl);fgSym&&v4789&&(fgSym.flags|=TypeScript.SymbolFlags.Optional);return go}function preCollectTypes(ast,parent,walker){var context=walker.state,go=!1;if(ast.nodeType==TypeScript.NodeType.Script)go=ast,context.script=go,go=!0;else if(ast.nodeType==TypeScript.NodeType.List)go=!0;else if(ast.nodeType==TypeScript.NodeType.ImportDeclaration)go=preCollectImportTypes(ast,parent,context);else if(ast.nodeType==TypeScript.NodeType.With)go=!1;else if(ast.nodeType==TypeScript.NodeType.ModuleDeclaration)go=
preCollectModuleTypes(ast,parent,context);else if(ast.nodeType==TypeScript.NodeType.ClassDeclaration)go=preCollectClassTypes(ast,parent,context);else if(ast.nodeType==TypeScript.NodeType.Block)go=!0;else if(ast.nodeType==TypeScript.NodeType.InterfaceDeclaration)go=preCollectInterfaceTypes(ast,parent,context);else if(ast.nodeType==TypeScript.NodeType.ArgDecl)go=preCollectArgDeclTypes(ast,parent,context);else if(ast.nodeType==TypeScript.NodeType.VarDecl)go=preCollectVarDeclTypes(ast,parent,context);
else if(ast.nodeType==TypeScript.NodeType.FuncDecl)go=preCollectFuncDeclTypes(ast,parent,context);else{if(parent=ast.isStatementOrExpression())parent=context.scopeChain.moduleDecl;parent&&context.scopeChain.moduleDecl.recordNonInterface()}walker.options.goChildren=go;return ast}function postCollectTypes(ast,parent,walker){parent=walker.state;ast.nodeType==TypeScript.NodeType.ModuleDeclaration?JAM.call(TypeScript.popTypeCollectionScope,TypeScript,[parent]):ast.nodeType==TypeScript.NodeType.ClassDeclaration?
JAM.call(TypeScript.popTypeCollectionScope,TypeScript,[parent]):ast.nodeType==TypeScript.NodeType.InterfaceDeclaration&&JAM.call(TypeScript.popTypeCollectionScope,TypeScript,[parent]);return ast}var Continuation=v966();TypeScript.Continuation=Continuation;TypeScript.createNewConstructGroupForType=createNewConstructGroupForType;TypeScript.cloneParentConstructGroupForChildType=cloneParentConstructGroupForChildType;TypeScript.globalId="__GLO";TypeScript.preCollectImportTypes=preCollectImportTypes;TypeScript.preCollectModuleTypes=
preCollectModuleTypes;TypeScript.preCollectClassTypes=preCollectClassTypes;TypeScript.preCollectInterfaceTypes=preCollectInterfaceTypes;TypeScript.preCollectArgDeclTypes=preCollectArgDeclTypes;TypeScript.preCollectVarDeclTypes=preCollectVarDeclTypes;TypeScript.preCollectFuncDeclTypes=preCollectFuncDeclTypes;TypeScript.preCollectTypes=preCollectTypes;TypeScript.postCollectTypes=postCollectTypes}
function v964(){var TypeScript=v18814;function v963(){function v962(sourceSig,targetSig,assignableTo,comparisonCache,comparisonInfo){var v14366=!sourceSig.parameters;v14366||(v14366=!targetSig.parameters);if(v14366)return!1;var v14366=targetSig.hasVariableArgList?targetSig.nonOptionalParameterCount-1:targetSig.nonOptionalParameterCount,v4858;v4858=sourceSig.hasVariableArgList?sourceSig.nonOptionalParameterCount-1:sourceSig.nonOptionalParameterCount;var v14371=v4858>v14366;v14371&&(v14371=!targetSig.hasVariableArgList);
if(v14371)return comparisonInfo&&(comparisonInfo.flags|=TypeScript.TypeRelationshipFlags.SourceSignatureHasTooManyParameters,JAM.call(comparisonInfo.addMessageToFront,comparisonInfo,["Call signature expects "+v14366+" or fewer parameters"])),!1;var v14371=sourceSig.returnType.type,targetReturnType=targetSig.returnType.type;if(targetReturnType!=this.voidType&&!JAM.call(this.sourceIsRelatableToTarget,this,[v14371,targetReturnType,assignableTo,comparisonCache,comparisonInfo]))return comparisonInfo&&
(comparisonInfo.flags|=TypeScript.TypeRelationshipFlags.IncompatibleReturnTypes),!1;if(v14371=v4858<v14366)v14371=sourceSig.hasVariableArgList;for(var v14371=v14371?v14366:v4858,sourceParamType=null,targetParamType=null,iTarget=targetReturnType=0,v4881=targetReturnType<v14371;v4881;){(v4881=!sourceSig.hasVariableArgList)||(v4881=targetReturnType<v4858);if(v4881){sourceParamType=sourceSig.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)sourceParamType=sourceParamType[targetReturnType];
sourceParamType=sourceParamType.parameter.typeLink.type}else if(targetReturnType==v4858){sourceParamType=sourceSig.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)sourceParamType=sourceParamType[targetReturnType];sourceParamType=sourceParamType.parameter.typeLink.type;sourceParamType.elementType&&(sourceParamType=sourceParamType.elementType)}(v4881=iTarget<targetSig.parameters.length)&&(v4881=iTarget<v14366);if(v4881){targetParamType=targetSig.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)targetParamType=
targetParamType[iTarget];targetParamType=targetParamType.parameter.typeLink.type}else if((v4881=targetSig.hasVariableArgList)&&(v4881=iTarget==v14366),v4881){targetParamType=targetSig.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)targetParamType=targetParamType[iTarget];targetParamType=targetParamType.parameter.typeLink.type;targetParamType.elementType&&(targetParamType=targetParamType.elementType)}(v4881=JAM.call(this.sourceIsRelatableToTarget,this,[sourceParamType,targetParamType,
assignableTo,comparisonCache,comparisonInfo]))||(v4881=JAM.call(this.sourceIsRelatableToTarget,this,[targetParamType,sourceParamType,assignableTo,comparisonCache,comparisonInfo]));if(!v4881)return comparisonInfo&&(comparisonInfo.flags|=TypeScript.TypeRelationshipFlags.IncompatibleParameterTypes),!1;targetReturnType+=1;iTarget+=1;v4881=targetReturnType<v14371}return!0}function v961(sourceSG,targetSG,assignableTo,comparisonCache,comparisonInfo){if(sourceSG==targetSG)return!0;if(!sourceSG||!targetSG)return!1;
for(var mSig=null,nSig=null,foundMatch=!1,iMSig=0,mSig=iMSig<targetSG.signatures.length;mSig;){for(var mSig=targetSG.signatures[iMSig],iNSig=0,nSig=iNSig<sourceSG.signatures.length;nSig;){nSig=sourceSG.signatures[iNSig];if(JAM.call(this.signatureIsRelatableToTarget,this,[nSig,mSig,assignableTo,comparisonCache,comparisonInfo])){foundMatch=!0;break}iNSig+=1;nSig=iNSig<sourceSG.signatures.length}if(foundMatch)foundMatch=!1,iMSig+=1,mSig=iMSig<targetSG.signatures.length;else return!1}return!0}function v960(source,
target,assignableTo,comparisonCache,comparisonInfo){if(source==target||!source||!target)return!0;var comboId=source.typeID<<16|target.typeID;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v14401=comparisonCache[comboId];if(void 0!=v14401)return!0;if(assignableTo){if((v14401=source==this.anyType)||(v14401=target==this.anyType),v14401)return!0}else if(target==this.anyType)return!0;if(source==this.undefinedType)return!0;(v14401=source==this.nullType)&&(v14401=target!=this.undefinedType)&&
(v14401=target!=this.voidType);if(v14401)return!0;(v14401=target==this.numberType)&&(v14401=source.typeFlags&TypeScript.TypeFlags.IsEnum);if(v14401)return!0;(v14401=source==this.numberType)&&(v14401=target.typeFlags&TypeScript.TypeFlags.IsEnum);if(v14401)return!0;(v14401=source.typeFlags&TypeScript.TypeFlags.IsEnum)||(v14401=target.typeFlags&TypeScript.TypeFlags.IsEnum);if(v14401)return!1;(v14401=source.isArray())||(v14401=target.isArray());if(v14401){(v14401=source.isArray())&&(v14401=target.isArray());
if(!v14401)return!1;comparisonCache[comboId]=!1;comparisonInfo=JAM.call(this.sourceIsRelatableToTarget,this,[source.elementType,target.elementType,assignableTo,comparisonCache,comparisonInfo]);comparisonCache[comboId]=comparisonInfo?!0:void 0;return comparisonInfo}if(source.primitiveTypeClass!=target.primitiveTypeClass)if(target.primitiveTypeClass==TypeScript.Primitive.None){if(v14401=source==this.numberType)v14401=this.typeFlow.numberInterfaceType;if(v14401)source=this.typeFlow.numberInterfaceType;
else{if(v14401=source==this.stringType)v14401=this.typeFlow.stringInterfaceType;if(v14401)source=this.typeFlow.stringInterfaceType;else{if(source=source==this.booleanType)source=this.typeFlow.booleanInterfaceType;if(source)source=this.typeFlow.booleanInterfaceType;else return!1}}}else return!1;comparisonCache[comboId]=!1;if(JAM.call(source.hasBase,source,[target]))return comparisonCache[comboId]=!0;(v14401=this.typeFlow.objectInterfaceType)&&(v14401=target==this.typeFlow.objectInterfaceType);if(v14401)return!0;
if(v14401=this.typeFlow.functionInterfaceType)v14401=source.call,v14401||(v14401=source.construct),v14401&&(v14401=target==this.typeFlow.functionInterfaceType);if(v14401)return!0;(v14401=target.isClass())||(v14401=target.isClassInstance());if(v14401)return comparisonCache[comboId]=void 0,!1;if(v14401=target.memberScope)v14401=source.memberScope;if(v14401)for(var v14401=target.memberScope,v14401=JAM.call(v14401.getAllValueSymbolNames,v14401,[!0]),mProp=null,nProp=null,mPropType=null,inferenceSymbol=
nProp=null,iMProp=0,mProp=iMProp<v14401.length;mProp;){mProp=target.memberScope;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)mPropType=v14401[iMProp];mProp=JAM.call(mProp.find,mProp,[mPropType,!1,!1]);mPropType=source.memberScope;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)nProp=v14401[iMProp];nProp=JAM.call(mPropType.find,mPropType,[nProp,!1,!1]);(mPropType="arguments"==mProp.name)&&(mPropType=this.typeFlow.iargumentsInterfaceType)&&(mPropType=this.typeFlow.iargumentsInterfaceType.symbol.flags&
TypeScript.SymbolFlags.CompilerGenerated)&&(mPropType=mProp.kind()==TypeScript.SymbolKind.Variable)&&(mPropType=mProp.variable.typeLink.type==this.typeFlow.iargumentsInterfaceType);if(!mPropType){mProp.isInferenceSymbol()&&(inferenceSymbol=mProp,inferenceSymbol.typeCheckStatus==TypeScript.TypeCheckStatus.NotStarted&&(mPropType=this.typeFlow,JAM.call(mPropType.typeCheck,mPropType,[mProp.declAST])));mPropType=mProp.getType();if(!nProp){if(this.typeFlow.objectInterfaceType){nProp=this.typeFlow.objectInterfaceType.memberScope;
introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)inferenceSymbol=v14401[iMProp];nProp=JAM.call(nProp.find,nProp,[inferenceSymbol,!1,!1])}if(!nProp){if(inferenceSymbol=this.typeFlow.functionInterfaceType)inferenceSymbol=mPropType.call,inferenceSymbol||(inferenceSymbol=mPropType.construct);if(inferenceSymbol){nProp=this.typeFlow.functionInterfaceType.memberScope;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)inferenceSymbol=v14401[iMProp];nProp=JAM.call(nProp.find,nProp,
[inferenceSymbol,!1,!1])}if(!nProp)if(mProp.flags&TypeScript.SymbolFlags.Optional){iMProp+=1;mProp=iMProp<v14401.length;continue}else{comparisonCache[comboId]=void 0;if(comparisonInfo){comparisonInfo.flags|=TypeScript.TypeRelationshipFlags.RequiredPropertyIsMissing;comparisonCache="Type '"+source.getTypeName()+"' is missing property '";introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)comboId=v14401[iMProp];JAM.call(comparisonInfo.addMessageToFront,comparisonInfo,[comparisonCache+comboId+
"' from type '"+target.getTypeName()+"'"])}return!1}}}nProp.isInferenceSymbol()&&(inferenceSymbol=nProp,inferenceSymbol.typeCheckStatus==TypeScript.TypeCheckStatus.NotStarted&&(inferenceSymbol=this.typeFlow,JAM.call(inferenceSymbol.typeCheck,inferenceSymbol,[nProp.declAST])));nProp=nProp.getType();if(inferenceSymbol=mPropType)if(inferenceSymbol=nProp){inferenceSymbol=nProp.typeID<<16|mPropType.typeID;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)inferenceSymbol=comparisonCache[inferenceSymbol];
inferenceSymbol=void 0!=inferenceSymbol}if(!inferenceSymbol&&!JAM.call(this.sourceIsRelatableToTarget,this,[nProp,mPropType,assignableTo,comparisonCache,comparisonInfo]))return comparisonCache[comboId]=void 0,comparisonInfo&&(comparisonInfo.flags|=TypeScript.TypeRelationshipFlags.IncompatiblePropertyTypes,JAM.call(comparisonInfo.addMessageToFront,comparisonInfo,["Types of property '"+mProp.name+"' of types '"+source.getTypeName()+"' and '"+target.getTypeName()+"' are incompatible"])),!1}iMProp+=1;
mProp=iMProp<v14401.length}v14401=source.call;v14401||(v14401=target.call);if(v14401&&!JAM.call(this.signatureGroupIsRelatableToTarget,this,[source.call,target.call,assignableTo,comparisonCache,comparisonInfo])){if(comparisonInfo){if(assignableTo=source.call)assignableTo=target.call;assignableTo?JAM.call(comparisonInfo.addMessageToFront,comparisonInfo,["Call signatures of types '"+source.getTypeName()+"' and '"+target.getTypeName()+"' are incompatible"]):(assignableTo=target.call?target.getTypeName():
source.getTypeName(),target=target.call?source.getTypeName():target.getTypeName(),JAM.call(comparisonInfo.setMessage,comparisonInfo,["Type '"+assignableTo+"' requires a call signature, but Type '"+target+"' lacks one"]));comparisonInfo.flags|=TypeScript.TypeRelationshipFlags.IncompatibleSignatures}comparisonCache[comboId]=void 0;return!1}v14401=source.construct;v14401||(v14401=target.construct);if(v14401&&!JAM.call(this.signatureGroupIsRelatableToTarget,this,[source.construct,target.construct,assignableTo,
comparisonCache,comparisonInfo])){if(comparisonInfo){if(assignableTo=source.construct)assignableTo=target.construct;assignableTo?JAM.call(comparisonInfo.addMessageToFront,comparisonInfo,["Construct signatures of types '"+source.getTypeName()+"' and '"+target.getTypeName()+"' are incompatible"]):(assignableTo=target.construct?target.getTypeName():source.getTypeName(),target=target.construct?source.getTypeName():target.getTypeName(),JAM.call(comparisonInfo.setMessage,comparisonInfo,["Type '"+assignableTo+
"' requires a construct signature, but Type '"+target+"' lacks one"]));comparisonInfo.flags|=TypeScript.TypeRelationshipFlags.IncompatibleSignatures}comparisonCache[comboId]=void 0;return!1}if(target.index){if(v14401=!target.index)v14401=this.typeFlow.objectInterfaceType;v14401=v14401?this.typeFlow.objectInterfaceType.index:target.index;if(iMProp=!source.index)iMProp=this.typeFlow.objectInterfaceType;iMProp=iMProp?this.typeFlow.objectInterfaceType.index:source.index;if(!JAM.call(this.signatureGroupIsRelatableToTarget,
this,[iMProp,v14401,assignableTo,comparisonCache,comparisonInfo]))return comparisonInfo&&(JAM.call(comparisonInfo.addMessageToFront,comparisonInfo,["Index signatures of types '"+source.getTypeName()+"' and '"+target.getTypeName()+"' are incompatible"]),comparisonInfo.flags|=TypeScript.TypeRelationshipFlags.IncompatibleSignatures),comparisonCache[comboId]=void 0,!1}return comparisonCache[comboId]=!0}function v959(s1,s2,comparisonInfo){return JAM.call(this.signatureIsRelatableToTarget,this,[s1,s2,!0,
this.assignableCache,comparisonInfo])}function v958(sg1,sg2,comparisonInfo){return JAM.call(this.signatureGroupIsRelatableToTarget,this,[sg1,sg2,!0,this.assignableCache,comparisonInfo])}function v957(source,target,comparisonInfo){return JAM.call(this.sourceIsRelatableToTarget,this,[source,target,!0,this.assignableCache,comparisonInfo])}function v956(s1,s2,comparisonInfo){return JAM.call(this.signatureIsRelatableToTarget,this,[s1,s2,!1,this.subtypeCache,comparisonInfo])}function v955(sg1,sg2,comparisonInfo){return JAM.call(this.signatureGroupIsRelatableToTarget,
this,[sg1,sg2,!1,this.subtypeCache,comparisonInfo])}function v954(source,target,comparisonInfo){return JAM.call(this.sourceIsRelatableToTarget,this,[source,target,!1,this.subtypeCache,comparisonInfo])}function v953(s1,s2){if(s1.hasVariableArgList!=s2.hasVariableArgList||s1.nonOptionalParameterCount!=s2.nonOptionalParameterCount||s1.parameters.length!=s2.parameters.length||!JAM.call(this.typesAreIdentical,this,[s1.returnType.type,s2.returnType.type]))return!1;for(var iParam=0,v4977=iParam<s1.parameters.length;v4977;){v4977=
s1.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v4977=v4977[iParam];var v4977=v4977.parameter.typeLink.type,v26338=s2.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v26338=v26338[iParam];if(!JAM.call(this.typesAreIdentical,this,[v4977,v26338.parameter.typeLink.type]))return!1;iParam+=1;v4977=iParam<s1.parameters.length}return!0}function v952(sg1,sg2){if(sg1==sg2)return!0;var v14481=!sg1;v14481||(v14481=!sg2);if(v14481||sg1.signatures.length!=
sg2.signatures.length)return!1;for(var sig1=null,sig2=null,v14481=!1,iSig1=0,sig1=iSig1<sg1.signatures.length;sig1;){for(var sig1=sg1.signatures[iSig1],iSig2=0,sig2=iSig2<sg2.signatures.length;sig2;){sig2=sg2.signatures[iSig2];if(JAM.call(this.signaturesAreIdentical,this,[sig1,sig2])){v14481=!0;break}iSig2+=1;sig2=iSig2<sg2.signatures.length}if(v14481)v14481=!1,iSig1+=1,sig1=iSig1<sg1.signatures.length;else return!1}return!0}function v951(t1,t2){if(t1==t2)return!0;var v14488=!t1;v14488||(v14488=!t2);
if(v14488)return!1;(v14488=t1.isClass())||(v14488=t1.isClassInstance());if(v14488)return!1;var v14488=t2.typeID<<16|t1.typeID,v14491=this.identicalCache;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v14491=v14491[v14488];if(v14491)return!0;(v14491=t1.typeFlags&TypeScript.TypeFlags.IsEnum)||(v14491=t2.typeFlags&TypeScript.TypeFlags.IsEnum);if(v14491)return!1;(v14491=t1.isArray())||(v14491=t2.isArray());if(v14491){(v14491=t1.isArray())&&(v14491=t2.isArray());if(!v14491)return!1;this.identicalCache[v14488]=
!1;v14491=JAM.call(this.typesAreIdentical,this,[t1.elementType,t2.elementType]);this.subtypeCache[v14488]=v14491?!0:void 0;return v14491}if(t1.primitiveTypeClass!=t2.primitiveTypeClass)return!1;this.identicalCache[v14488]=!1;if(v14491=t1.memberScope)v14491=t2.memberScope;if(v14491){var v14491=t1.memberScope,v14491=JAM.call(v14491.getAllValueSymbolNames,v14491,[!0]).sort(),v14499=t2.memberScope,v14499=JAM.call(v14499.getAllValueSymbolNames,v14499,[!0]).sort();if(v14491.length!=v14499.length)return this.identicalCache[v14488]=
void 0,!1;for(var t1MemberSymbol=null,t2MemberSymbol=null,t2MemberSymbol=t1MemberSymbol=null,iMember=0,t1MemberSymbol=iMember<v14491.length;t1MemberSymbol;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)t1MemberSymbol=v14491[iMember];introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)t2MemberSymbol=v14499[iMember];if(t1MemberSymbol!=t2MemberSymbol)return this.identicalCache[v14488]=void 0,!1;t1MemberSymbol=t1.memberScope;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)t2MemberSymbol=
v14491[iMember];t1MemberSymbol=JAM.call(t1MemberSymbol.find,t1MemberSymbol,[t2MemberSymbol,!1,!1]);t2MemberSymbol=t2.memberScope;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v5011=v14499[iMember];t2MemberSymbol=JAM.call(t2MemberSymbol.find,t2MemberSymbol,[v5011,!1,!1]);if((t1MemberSymbol.flags&TypeScript.SymbolFlags.Optional)!=(t2MemberSymbol.flags&TypeScript.SymbolFlags.Optional))return this.identicalCache[v14488]=void 0,!1;t1MemberSymbol=t1MemberSymbol.getType();t2MemberSymbol=
t2MemberSymbol.getType();if(v5011=t1MemberSymbol)if(v5011=t2MemberSymbol){var v5011=this.identicalCache,v25083=t2MemberSymbol.typeID<<16|t1MemberSymbol.typeID;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v5011=v5011[v25083];v5011=void 0!=v5011}if(!v5011&&!JAM.call(this.typesAreIdentical,this,[t1MemberSymbol,t2MemberSymbol]))return this.identicalCache[v14488]=void 0,!1;iMember+=1;t1MemberSymbol=iMember<v14491.length}}else if(v14491=t1.memberScope,v14491||(v14491=t2.memberScope),
v14491)return this.identicalCache[v14488]=void 0,!1;return JAM.call(this.signatureGroupsAreIdentical,this,[t1.call,t2.call])&&JAM.call(this.signatureGroupsAreIdentical,this,[t1.construct,t2.construct])&&JAM.call(this.signatureGroupsAreIdentical,this,[t1.index,t2.index])?this.identicalCache[v14488]=!0:(this.identicalCache[v14488]=void 0,!1)}function v950(initialType,targetType,collection,acceptVoid,comparisonInfo){var i=0,len=collection.getLength(),nlastChecked=0;targetType&&(initialType=i=initialType?
JAM.call(initialType.mergeOrdered,initialType,[targetType,this,acceptVoid]):targetType);for(var convergenceType=initialType,i=nlastChecked<len;i;){for(var i=0,v5032=i<len;v5032;){if(i!=nlastChecked)if((v5032=convergenceType)&&(v5032=initialType=JAM.call(convergenceType.mergeOrdered,convergenceType,[JAM.call(collection.getTypeAtIndex,collection,[i]),this,acceptVoid,comparisonInfo])),v5032&&(convergenceType=initialType),(v5032=initialType==this.anyType)||(v5032=null==initialType),v5032)break;else targetType&&
JAM.call(collection.setTypeAtIndex,collection,[i,targetType]);i+=1;v5032=i<len}if(convergenceType&&initialType)break;nlastChecked+=1;nlastChecked<len&&(convergenceType=JAM.call(collection.getTypeAtIndex,collection,[nlastChecked]));i=nlastChecked<len}return targetType=acceptVoid?initialType:initialType==this.voidType?null:initialType}function v949(t){var v5037=t==this.undefinedType;v5037||(v5037=t==this.nullType);return v5037}function v948(t){var v14521=t==this.undefinedType;v14521||(v14521=t==this.nullType);
return v14521?this.anyType:t}function v947(targetType,objectLit){if(targetType==this.typeFlow.objectInterfaceType)return!0;var memberDecls=objectLit.operand,v20130=memberDecls;v20130&&(v20130=targetType.memberScope);if(!v20130)return!1;for(var id=null,targetMember=null,id="",v20130={},i=0,id=i<memberDecls.members.length;id;){id=memberDecls.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)id=id[i];id=id.operand1;if(id.nodeType==TypeScript.NodeType.Name)id=id.text;else if(id.nodeType==
TypeScript.NodeType.QString)id=id.text,id=JAM.call(id.substring,id,[1,id.length-1]);else return!1;targetMember=targetType.memberScope;targetMember=JAM.call(targetMember.find,targetMember,[id,!0,!1]);if(!targetMember)return!1;JAM.set(v20130,id,!0);i+=1;id=i<memberDecls.members.length}i=targetType.memberScope;memberDecls=JAM.call(i.getAllValueSymbolNames,i,[!0]);i=0;for(id=i<memberDecls.length;id;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)id=memberDecls[i];targetMember=targetType.memberScope;
id=JAM.call(targetMember.find,targetMember,[id,!0,!1]);introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)targetMember=memberDecls[i];introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)targetMember=v20130[targetMember];(targetMember=!targetMember)&&(targetMember=!JAM.call(TypeScript.hasFlag,TypeScript,[id.flags,TypeScript.SymbolFlags.Optional]));if(targetMember)return!1;i+=1;id=i<memberDecls.length}return!0}function v946(candidateType,funcDecl,beStringent){var v14535=funcDecl.isParenthesized;
if(!v14535&&(v14535=funcDecl.isMethod(),!v14535)){if(v14535=beStringent)v14535=funcDecl.returnTypeAnnotation;v14535||(v14535=funcDecl.isInlineCallLiteral)}if(v14535)return!1;beStringent||(beStringent=this.typeFlow.functionInterfaceType==candidateType);if(!beStringent)return!0;funcDecl.signature||(JAM.call(this.createFunctionSignature,this,[funcDecl,this.typeFlow.scope.container,this.typeFlow.scope,null,null]),v14535=this.typeFlow,JAM.call(v14535.typeCheck,v14535,[funcDecl]));funcDecl=funcDecl.signature;
for(var v14535=funcDecl.parameters.length,i=0,v5062=i<v14535;v5062;){v5062=funcDecl.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v5062=v5062[i];var v5062=v5062.declAST,v14541=beStringent;v14541&&(v14541=v5062.typeExpr);if(v14541)return!1;i+=1;v5062=i<v14535}if(beStringent=candidateType.construct)beStringent=candidateType.call;if(beStringent)return!1;candidateType=candidateType.construct?candidateType.construct:candidateType.call;(beStringent=!candidateType)||(beStringent=
1<candidateType.signatures.length);return beStringent?!1:!0}function v945(signatures,args,comparisonInfo){for(var applicableSigs=[],memberType=null,miss=!1,hadProvisionalErrors=!1,i=0,v5093=i<signatures.length;v5093;){miss=!1;v5093=0;for(memberType=v5093<args.members.length;memberType;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)memberType=signatures[i];if(!(v5093>=memberType.parameters.length)){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)memberType=signatures[i];
memberType=memberType.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)memberType=memberType[v5093];memberType=memberType.getType();introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v23492=signatures[i];if(v23492=v23492.declAST.variableArgList){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v23492=signatures[i];(v23492=v5093>=v23492.nonOptionalParameterCount-1)&&(v23492=memberType.isArray())}v23492&&(memberType=memberType.elementType);if(memberType!=
this.anyType){v23492=args.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v23492=v23492[v5093];if(v23492.nodeType==TypeScript.NodeType.FuncDecl){(v23492=this.typeFlow.functionInterfaceType)&&(v23492=memberType==this.typeFlow.functionInterfaceType);if(v23492){v5093+=1;memberType=v5093<args.members.length;continue}v23492=args.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v23492=v23492[v5093];if(JAM.call(this.canContextuallyTypeFunction,this,[memberType,
v23492,!0])){hadProvisionalErrors=args.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)hadProvisionalErrors=hadProvisionalErrors[v5093];JAM.call(this.typeCheckWithContextualType,this,[memberType,!0,!0,hadProvisionalErrors]);this.cleanStartedPTO();hadProvisionalErrors=this.hadProvisionalErrors();v23492=args.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v23492=v23492[v5093];if(!JAM.call(this.sourceIsAssignableToTarget,this,[v23492.type,memberType,comparisonInfo])){if(comparisonInfo){miss=
"Could not apply type '"+memberType.getTypeName()+"' to argument "+(v5093+1)+", which is of type '";memberType=args.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)memberType=memberType[v5093];JAM.call(comparisonInfo.setMessage,comparisonInfo,[miss+memberType.type.getTypeName()+"'"])}miss=!0}this.resetProvisionalErrors();if(miss)break}else{v23492=args.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v23492=v23492[v5093];if(JAM.call(this.canContextuallyTypeFunction,
this,[memberType,v23492,!1])){var v23492=this.typeFlow,v14558=args.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v14558=v14558[v5093];JAM.call(v23492.typeCheck,v23492,[v14558]);v23492=args.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v23492=v23492[v5093];if(!JAM.call(this.sourceIsAssignableToTarget,this,[v23492.type,memberType,comparisonInfo]))break}else break}}else{v23492=args.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v23492=
v23492[v5093];if(v23492.nodeType==TypeScript.NodeType.ObjectLit){(v23492=this.typeFlow.objectInterfaceType)&&(v23492=memberType==this.typeFlow.objectInterfaceType);if(v23492){v5093+=1;memberType=v5093<args.members.length;continue}hadProvisionalErrors=args.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)hadProvisionalErrors=hadProvisionalErrors[v5093];JAM.call(this.typeCheckWithContextualType,this,[memberType,!0,!0,hadProvisionalErrors]);this.cleanStartedPTO();hadProvisionalErrors=
this.hadProvisionalErrors();v23492=args.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v23492=v23492[v5093];if(!JAM.call(this.sourceIsAssignableToTarget,this,[v23492.type,memberType,comparisonInfo])){if(comparisonInfo){miss="Could not apply type '"+memberType.getTypeName()+"' to argument "+(v5093+1)+", which is of type '";memberType=args.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)memberType=memberType[v5093];JAM.call(comparisonInfo.setMessage,
comparisonInfo,[miss+memberType.type.getTypeName()+"'"])}miss=!0}this.resetProvisionalErrors();if(miss)break}else{v23492=args.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v23492=v23492[v5093];if(v23492.nodeType==TypeScript.NodeType.ArrayLit){(v23492=this.typeFlow.arrayInterfaceType)&&(v23492=memberType==this.typeFlow.arrayInterfaceType);if(v23492){v5093+=1;memberType=v5093<args.members.length;continue}hadProvisionalErrors=args.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)hadProvisionalErrors=
hadProvisionalErrors[v5093];JAM.call(this.typeCheckWithContextualType,this,[memberType,!0,!0,hadProvisionalErrors]);this.cleanStartedPTO();hadProvisionalErrors=this.hadProvisionalErrors();v23492=args.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v23492=v23492[v5093];if(!JAM.call(this.sourceIsAssignableToTarget,this,[v23492.type,memberType,comparisonInfo])){if(comparisonInfo){miss="Could not apply type '"+memberType.getTypeName()+"' to argument "+(v5093+1)+", which is of type '";
memberType=args.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)memberType=memberType[v5093];JAM.call(comparisonInfo.setMessage,comparisonInfo,[miss+memberType.type.getTypeName()+"'"])}break}this.resetProvisionalErrors();if(miss)break}}}}}v5093+=1;memberType=v5093<args.members.length}if(v5093==args.members.length){v5093=applicableSigs.length;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)miss=signatures[i];applicableSigs[v5093]={signature:miss,hadProvisionalErrors:hadProvisionalErrors}}hadProvisionalErrors=
!1;i+=1;v5093=i<signatures.length}return applicableSigs}function v944(signatures,args){function v943(index){return index=index?Q.signature.returnType.type:best.signature.returnType.type}function v942(index,type){}function v941(){return 2}if(1==signatures.length)return{sig:signatures[0].signature,ambiguous:!1};for(var best=signatures[0],Q=null,AType=null,PType=null,QType=null,ambiguous=!1,qSig=1,AType=qSig<signatures.length;AType;){Q=signatures[qSig];ambiguous=ambiguous=0;for((AType=args)&&(AType=
ambiguous<args.members.length);AType;){AType=args.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)AType=AType[ambiguous];AType=AType.type;if(ambiguous<best.signature.parameters.length){PType=best.signature.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)PType=PType[ambiguous];PType=PType.getType()}else{PType=best.signature.parameters;QType=best.signature.parameters.length-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)PType=PType[QType];
PType=PType.getType().elementType}if(ambiguous<Q.signature.parameters.length){QType=Q.signature.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)QType=QType[ambiguous];QType=QType.getType()}else{var QType=Q.signature.parameters,v23519=Q.signature.parameters.length-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)QType=QType[v23519];QType=QType.getType().elementType}if(!JAM.call(this.typesAreIdentical,this,[PType,QType]))if(JAM.call(this.typesAreIdentical,
this,[AType,PType]))break;else if(JAM.call(this.typesAreIdentical,this,[AType,QType])){best=Q;break}else if(JAM.call(this.sourceIsSubtypeOfTarget,this,[PType,QType]))break;else if(JAM.call(this.sourceIsSubtypeOfTarget,this,[QType,PType])){best=Q;break}else if(Q.hadProvisionalErrors)break;else if(best.hadProvisionalErrors){best=Q;break}ambiguous+=1;(AType=args)&&(AType=ambiguous<args.members.length)}(AType=!args)||(AType=ambiguous==args.members.length);AType?(ambiguous={getLength:v941,setTypeAtIndex:v942,
getTypeAtIndex:v943},ambiguous=JAM.call(this.findBestCommonType,this,[best.signature.returnType.type,null,ambiguous,!0]),ambiguous=!ambiguous):ambiguous=!1;qSig+=1;AType=qSig<signatures.length}return{sig:best.signature,ambiguous:ambiguous}}function v940(typeLink,scope){this.resolvingBases=!0;JAM.call(this.resolveTypeLink,this,[scope,typeLink,!0]);this.resolvingBases=!1;var extendsType=null;return extendsType=typeLink.type.isClass()?typeLink.type.instanceType:typeLink.type}function v939(scope,typeLink,
supplyVar){var arrayCount=0;if(null==typeLink.type){var ast=typeLink.ast;if(ast)for(var v5150=null==typeLink.type;v5150;){switch(ast.nodeType){case TypeScript.NodeType.Name:var v5150=ast,symbol=JAM.call(scope.find,scope,[v5150.text,!1,!0]);if(null==symbol)typeLink.type=this.anyType,symbol=this.errorReporter,JAM.call(symbol.unresolvedSymbol,symbol,[v5150,v5150.actualText]);else if(symbol.isType()){if(!JAM.call(symbol.visible,symbol,[scope,this])){var v5117=this.errorReporter;JAM.call(v5117.simpleError,
v5117,[ast,"The symbol '"+v5150.actualText+"' is not visible at this point"])}v5150.sym=symbol;v5150=typeLink;symbol=symbol.getType();v5150.type=symbol;typeLink.type?typeLink.type.isClass()&&(typeLink.type=typeLink.type.instanceType):typeLink.type=this.anyType}else typeLink.type=this.anyType,v5150=this.errorReporter,JAM.call(v5150.simpleError,v5150,[ast,"Expected type"]);break;case TypeScript.NodeType.Dot:v5150=typeLink;symbol=JAM.call(this.resolveTypeMember,this,[scope,ast]);v5150.type=symbol;break;
case TypeScript.NodeType.TypeRef:arrayCount=ast.arrayCount;ast=ast.term;null==ast&&(typeLink.type=this.anyType);break;case TypeScript.NodeType.InterfaceDeclaration:v5117=ast;v5150=new TypeScript.Type;symbol=JAM.new(TypeScript.TypeSymbol,[v5117.name.text,ast.minChar,ast.limChar-ast.minChar,this.locationInfo.unitIndex,v5150]);v5150.symbol=symbol;var v5135=v5150,v26943=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,[new TypeScript.StringHashTable,new TypeScript.StringHashTable])]);
v5135.members=v26943;v5135=v5150;v26943=JAM.new(TypeScript.SymbolTableScope,[v5150.members,null,null,null,symbol]);v5135.containedScope=v26943;v5150.containedScope.container=symbol;v5150.memberScope=v5150.containedScope;for(var v5117=v5117.members,v5117=v5117.members,v5135=v5117.length,v26943=0,v5147=v26943<v5135;v5147;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var propDecl=v5117[v26943];var v5147=null,addMember=!0,id=null;propDecl.nodeType==TypeScript.NodeType.FuncDecl?(id=
propDecl.name,v5147=v5150.members.allMembers,v5147=JAM.call(v5147.lookup,v5147,[propDecl.getNameText()]),addMember=null==v5147,propDecl.isSpecialFn()?(addMember=!1,v5147=JAM.call(this.resolveFuncDecl,this,[propDecl,scope,symbol])):v5147=JAM.call(this.resolveFuncDecl,this,[propDecl,scope,v5147]),propDecl.type=v5147.type):(id=propDecl.id,v5147=JAM.call(this.resolveVarDecl,this,[propDecl,scope]),addMember=!id.isMissing());addMember&&((addMember=id)&&(addMember=JAM.call(TypeScript.hasFlag,TypeScript,
[id.flags,TypeScript.ASTFlags.OptionalName])),addMember&&(v5147.flags|=TypeScript.SymbolFlags.Optional),id=v5150.members.allMembers,JAM.call(id.add,id,[v5147.name,v5147])||(id=this.errorReporter,JAM.call(id.duplicateIdentifier,id,[ast,v5147.name])));v26943+=1;v5147=v26943<v5135}ast.type=v5150;typeLink.type=v5150;break;case TypeScript.NodeType.FuncDecl:v5150=JAM.call(this.resolveFuncDecl,this,[ast,scope,null]);typeLink.type=v5150.type;break;default:typeLink.type=this.anyType,v5150=this.errorReporter,
JAM.call(v5150.simpleError,v5150,[ast,"Expected type"])}v5150=null==typeLink.type}scope=arrayCount;for(arrayCount=0<scope;arrayCount;)arrayCount=typeLink,ast=JAM.call(this.makeArrayType,this,[typeLink.type]),arrayCount.type=ast,scope-=1,arrayCount=0<scope;supplyVar&&(supplyVar=null==typeLink.type);supplyVar&&(typeLink.type=this.anyType);typeLink.ast&&(typeLink.ast.type=typeLink.type)}}function v938(varDecl,scope){var field=new TypeScript.ValueLocation,fieldSymbol=JAM.new(TypeScript.FieldSymbol,[varDecl.id.text,
varDecl.minChar,this.locationInfo.unitIndex,(varDecl.varFlags&TypeScript.VarFlags.Readonly)==TypeScript.VarFlags.None,field]);JAM.call(fieldSymbol.transferVarFlags,fieldSymbol,[varDecl.varFlags]);field.symbol=fieldSymbol;fieldSymbol.declAST=varDecl;var v5164=field,v26946=JAM.call(TypeScript.getTypeLink,TypeScript,[varDecl.typeExpr,this,null==varDecl.init]);v5164.typeLink=v26946;JAM.call(this.resolveTypeLink,this,[scope,field.typeLink,!0]);varDecl.sym=fieldSymbol;varDecl.type=field.typeLink.type;return fieldSymbol}
function v937(funcDecl,scope,fgSym){fgSym=JAM.call(this.createFunctionSignature,this,[funcDecl,scope.container,scope,fgSym,!1]).declAST.type.symbol;var signatures;signatures=funcDecl.isConstructMember()?fgSym.type.construct.signatures:funcDecl.isIndexerMember()?fgSym.type.getInstanceType().index.signatures:fgSym.type.call.signatures;var v5173=signatures.length-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)signatures=signatures[v5173];for(var v5173=signatures.parameters.length,
i=0,v5177=i<v5173;v5177;){v5177=signatures.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v5177=v5177[i];JAM.call(this.resolveTypeLink,this,[scope,v5177.parameter.typeLink,!0]);i+=1;v5177=i<v5173}if(i=v5173)i=funcDecl.variableArgList;if(i){i=signatures.parameters;v5177=v5173-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)i=i[v5177];if(!i.parameter.typeLink.type.elementType){var i=this.errorReporter,v5177=signatures.parameters,v23530=v5173-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v5177=
v5177[v23530];JAM.call(i.simpleErrorFromSym,i,[v5177.parameter.symbol,"... parameter must have array type"]);i=signatures.parameters;v5177=v5173-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)i=i[v5177];i=i.parameter.typeLink;v5177=signatures.parameters;v5173-=1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v5173=v5177[v5173];v5173=JAM.call(this.makeArrayType,this,[v5173.parameter.typeLink.type]);i.type=v5173}}JAM.call(this.resolveTypeLink,this,[scope,signatures.returnType,
funcDecl.isSignature()]);return fgSym}function v936(scope,dotNode){function v935(id){return JAM.call(scope.find,scope,[id,!1,!0])}var lhs=dotNode.operand1,rhs=dotNode.operand2,resultType=this.anyType,lhsType=this.anyType,v14639=lhs;v14639&&(v14639=rhs)&&(v14639=rhs.nodeType==TypeScript.NodeType.Name);if(v14639){if(lhs.nodeType==TypeScript.NodeType.Dot)lhsType=JAM.call(this.resolveTypeMember,this,[scope,lhs]);else if(lhs.nodeType==TypeScript.NodeType.Name){var v14639=lhs,symbol=JAM.call(scope.find,
scope,[v14639.text,!1,!0]);if(null==symbol)symbol=this.errorReporter,JAM.call(symbol.unresolvedSymbol,symbol,[v14639,v14639.actualText]);else if(symbol.isType()){var lhsType=symbol,v14644=lhsType.aliasLink;v14644&&(v14644=!lhsType.type)&&(v14644=lhsType.aliasLink.alias.nodeType==TypeScript.NodeType.Name);if(v14644){var v14644=lhsType.aliasLink.alias.text,modSym=JAM.call(this.findSymbolForDynamicModule,this,[v14644,this.locationInfo.filename,v935]);modSym&&(v14644=lhsType,modSym=modSym.getType(),v14644.type=
modSym)}(v14644=TypeScript.optimizeModuleCodeGen)&&(v14644=symbol);if(v14644){if(modSym=v14644=symbol.getType())if(modSym=lhsType.aliasLink)modSym=lhsType.onlyReferencedAsTypeRef;modSym&&((modSym=v14644=v14644.symbol.declAST)&&(modSym=JAM.call(TypeScript.hasFlag,TypeScript,[v14644.modFlags,TypeScript.ModuleFlags.IsDynamic])),modSym&&(lhsType.onlyReferencedAsTypeRef=!this.resolvingBases))}JAM.call(symbol.visible,symbol,[scope,this])||(lhsType=this.errorReporter,JAM.call(lhsType.simpleError,lhsType,
[lhs,"The symbol '"+v14639.actualText+"' is not visible at this point"]));lhsType=symbol.getType();v14639.sym=symbol}else v14639=this.errorReporter,JAM.call(v14639.simpleError,v14639,[lhs,"Expected type"])}lhsType||(lhsType=this.anyType);lhsType!=this.anyType&&(v14639=rhs,symbol=JAM.call(this.lookupMemberTypeSymbol,this,[lhsType,v14639.text]),null==symbol?(resultType=this.anyType,lhs=this.errorReporter,JAM.call(lhs.simpleError,lhs,[dotNode,"Expected type"])):(resultType=symbol.getType(),JAM.call(symbol.visible,
symbol,[scope,this])||(symbol=this.errorReporter,JAM.call(symbol.simpleError,symbol,[lhs,"The symbol '"+rhs.actualText+"' is not visible at this point"]))),v14639.sym=resultType.symbol)}resultType.isClass()&&(resultType=resultType.instanceType);return resultType}function v934(idText,currentFileName,search){var originalIdText=idText,symbol=JAM.call(search,null,[idText]);if(null==symbol&&(symbol||(idText=JAM.call(TypeScript.swapQuotes,TypeScript,[originalIdText]),symbol=JAM.call(search,null,[idText])),
symbol||(idText=JAM.call(TypeScript.stripQuotes,TypeScript,[originalIdText])+".ts",symbol=JAM.call(search,null,[idText])),symbol||(idText=JAM.call(TypeScript.stripQuotes,TypeScript,[originalIdText])+".str",symbol=JAM.call(search,null,[idText])),symbol||(idText=JAM.call(TypeScript.stripQuotes,TypeScript,[originalIdText])+".d.ts",symbol=JAM.call(search,null,[idText])),symbol||(idText=JAM.call(TypeScript.stripQuotes,TypeScript,[originalIdText])+".d.str",symbol=JAM.call(search,null,[idText])),(idText=
!symbol)&&(idText=!JAM.call(TypeScript.isRelative,TypeScript,[originalIdText])),idText))for(idText=originalIdText,originalIdText=JAM.call(TypeScript.stripQuotes,TypeScript,[idText]),currentFileName=JAM.call(TypeScript.getRootFilePath,TypeScript,[JAM.call(TypeScript.switchToForwardSlashes,TypeScript,[currentFileName])]),(idText=null==symbol)&&(idText=""!=currentFileName);idText;)idText=JAM.call(TypeScript.normalizePath,TypeScript,[currentFileName+originalIdText+".ts"]),symbol=JAM.call(search,null,
[idText]),null==symbol&&(idText=JAM.call(TypeScript.changePathToSTR,TypeScript,[idText]),symbol=JAM.call(search,null,[idText])),null==symbol&&(idText=JAM.call(TypeScript.changePathToDTS,TypeScript,[idText]),symbol=JAM.call(search,null,[idText])),null==symbol&&(idText=JAM.call(TypeScript.changePathToDSTR,TypeScript,[idText]),symbol=JAM.call(search,null,[idText])),null==symbol&&("/"===currentFileName?currentFileName="":((idText=currentFileName=JAM.call(TypeScript.normalizePath,TypeScript,[currentFileName+
".."]))&&(idText="/"!=currentFileName),currentFileName=idText?currentFileName+"/":currentFileName)),(idText=null==symbol)&&(idText=""!=currentFileName);return symbol}function v933(containingType,name){var symbol=null;if(containingType.containedScope)symbol=containingType.containedScope,symbol=JAM.call(symbol.find,symbol,[name,!1,!0]);else if(containingType.members){var symbol=containingType.members.allMembers,symbol=JAM.call(symbol.lookup,symbol,[name]),v14661=null==symbol;v14661&&(v14661=containingType.ambientMembers);
v14661&&(symbol=containingType.ambientMembers.allMembers,symbol=JAM.call(symbol.lookup,symbol,[name]))}if(null==symbol){var typeMembers=containingType.getAllEnclosedTypes(),v14661=containingType.getAllAmbientEnclosedTypes();typeMembers&&(symbol=typeMembers.allMembers,symbol=JAM.call(symbol.lookup,symbol,[name]),(typeMembers=null==symbol)&&(typeMembers=v14661),typeMembers&&(symbol=v14661.allMembers,symbol=JAM.call(symbol.lookup,symbol,[name])))}(v14661=symbol)&&(v14661=symbol.isType());return v14661?
symbol:null}function v932(type){var resultScope=JAM.new(TypeScript.SymbolAggregateScope,[type.symbol]),v14665;if(v14665=type.symbol)v14665=type.symbol.name;v14665=v14665?type.symbol.name:"{}";v14665={base:v14665,baseId:type.typeID};JAM.call(this.addBases,this,[resultScope,type,v14665]);return resultScope}function v931(resultScope,type,baseContext){JAM.call(resultScope.addParentScope,resultScope,[JAM.new(TypeScript.SymbolTableScope,[type.members,type.ambientMembers,type.getAllEnclosedTypes(),type.getAllAmbientEnclosedTypes(),
type.symbol])]);var i=0,parent;if(type.extendsList){var len=type.extendsList.length;for(parent=i<len;parent;){parent=type.extendsList[i];if(baseContext.baseId==parent.typeID){resultScope=this.errorReporter;JAM.call(resultScope.reportErrorFromSym,resultScope,[parent.symbol,"Type '"+baseContext.base+"' is recursively referenced as a base class of itself"]);baseContext=parent.symbol;baseContext.flags|=TypeScript.SymbolFlags.RecursivelyReferenced;break}JAM.call(this.addBases,this,[resultScope,parent,
baseContext]);i+=1;parent=i<len}}}function v930(funcDecl,fgSym,enclosingClass,addToMembers,isClassProperty,scope,container){var accessorSym=null,sig=funcDecl.signature,nameText=funcDecl.name.text,isStatic=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.Static]),isPrivate=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.Private]);if(null==fgSym){fgSym=new TypeScript.ValueLocation;accessorSym=JAM.new(TypeScript.FieldSymbol,[nameText,funcDecl.minChar,
this.locationInfo.unitIndex,!1,fgSym]);fgSym.symbol=accessorSym;accessorSym.declAST=funcDecl;if(JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.GetAccessor])){if(accessorSym.getter){var v5270=this.errorReporter;JAM.call(v5270.simpleError,v5270,[funcDecl,"Redeclaration of property getter"])}accessorSym.getter=sig.declAST.type.symbol}else accessorSym.setter&&(v5270=this.errorReporter,JAM.call(v5270.simpleError,v5270,[funcDecl,"Redeclaration of property setter"])),accessorSym.setter=
sig.declAST.type.symbol;sig=fgSym;fgSym=JAM.call(TypeScript.getTypeLink,TypeScript,[null,this,!1]);sig.typeLink=fgSym;addToMembers?enclosingClass?(scope=enclosingClass.members.publicMembers,JAM.call(scope.add,scope,[nameText,accessorSym])||(scope=this.errorReporter,JAM.call(scope.duplicateIdentifier,scope,[funcDecl,accessorSym.name])),accessorSym.container=enclosingClass.symbol):(enclosingClass=this.errorReporter,JAM.call(enclosingClass.simpleError,enclosingClass,[funcDecl,"Accessor property may not be added in this context"])):
(enclosingClass=this.errorReporter,(nameText=!isPrivate)||(nameText=isStatic),JAM.call(scope.enter,scope,[container,funcDecl,accessorSym,enclosingClass,nameText,!1,!1]));isClassProperty&&(accessorSym.flags|=TypeScript.SymbolFlags.Property);isStatic&&(accessorSym.flags|=TypeScript.SymbolFlags.Static);accessorSym.flags=isPrivate?accessorSym.flags|TypeScript.SymbolFlags.Private:accessorSym.flags|TypeScript.SymbolFlags.Public}else accessorSym=fgSym,isPrivate!=JAM.call(TypeScript.hasFlag,TypeScript,[accessorSym.flags,
TypeScript.SymbolFlags.Private])&&(isClassProperty=this.errorReporter,JAM.call(isClassProperty.simpleError,isClassProperty,[funcDecl,"Getter and setter accessors do not agree in visibility"])),JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.GetAccessor])?(accessorSym.getter&&(isClassProperty=this.errorReporter,JAM.call(isClassProperty.simpleError,isClassProperty,[funcDecl,"Redeclaration of property getter"])),accessorSym.getter=funcDecl.type.symbol):(accessorSym.setter&&
(isClassProperty=this.errorReporter,JAM.call(isClassProperty.simpleError,isClassProperty,[funcDecl,"Redeclaration of property setter"])),accessorSym.setter=funcDecl.type.symbol);return accessorSym}function v929(funcDecl,container,scope,overloadGroupSym,addToScope){var v5294=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.Exported|TypeScript.FncFlags.ClassPropertyMethodExported]);v5294||(v5294=container==this.gloMod);var isExported=v5294,v5294=JAM.call(TypeScript.hasFlag,
TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.Static]),isPrivate=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.Private]),isDefinition=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.Definition]),isAmbient=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.Ambient]),v5303=funcDecl.isConstructMember();v5303||(v5303=funcDecl.isConstructor);var isConstructor=v5303,isGlobal=container==this.gloMod,v5303=new TypeScript.Signature,
isLambda=funcDecl.fncFlags&TypeScript.FncFlags.IsFunctionExpression,v14706=funcDecl.returnTypeAnnotation;v14706||(v14706=isDefinition);v14706?(isDefinition=v5303,v14706=JAM.call(TypeScript.getTypeLink,TypeScript,[funcDecl.returnTypeAnnotation,this,!1]),isDefinition.returnType=v14706):(isDefinition=v5303,v14706=new TypeScript.TypeLink,isDefinition.returnType=v14706,v5303.returnType.type=this.anyType);v5303.hasVariableArgList=funcDecl.variableArgList;isDefinition=JAM.call(this.getParameterList,this,
[funcDecl,container]);v5303.parameters=isDefinition.parameters;v5303.nonOptionalParameterCount=isDefinition.nonOptionalParameterCount;funcDecl.signature=v5303;v5303.declAST=funcDecl;if(isDefinition=overloadGroupSym)if(isDefinition=overloadGroupSym.getType())if(isDefinition=!overloadGroupSym.isAccessor())(isDefinition=funcDecl.isSignature())||(isDefinition=isAmbient==JAM.call(TypeScript.hasFlag,TypeScript,[overloadGroupSym.flags,TypeScript.SymbolFlags.Ambient]));(v14706=isDefinition)&&(v14706=isPrivate!=
JAM.call(TypeScript.hasFlag,TypeScript,[overloadGroupSym.flags,TypeScript.SymbolFlags.Private]));v14706&&(v14706=this.errorReporter,JAM.call(v14706.simpleError,v14706,[funcDecl,"Public/Private visibility of overloads does not agree"]));v14706=isDefinition?overloadGroupSym.getType():new TypeScript.Type;if(isConstructor){if(null==v14706.construct){var v5316=v14706,v26952=new TypeScript.SignatureGroup;v5316.construct=v26952}v5316=v14706.construct;JAM.call(v5316.addSignature,v5316,[v5303]);v14706.construct.hasImplementation=
!funcDecl.isSignature();v14706.construct.hasImplementation&&v14706.setHasImplementation()}else funcDecl.isIndexerMember()?(null==v14706.index&&(v5316=v14706,v26952=new TypeScript.SignatureGroup,v5316.index=v26952,v5316=v14706.index,v5316.flags|=TypeScript.SignatureFlags.IsIndexer),v5316=v14706.index,JAM.call(v5316.addSignature,v5316,[v5303]),v14706.index.hasImplementation=!funcDecl.isSignature(),v14706.index.hasImplementation&&v14706.setHasImplementation()):(null==v14706.call&&(v5316=v14706,v26952=
new TypeScript.SignatureGroup,v5316.call=v26952),v5316=v14706.call,JAM.call(v5316.addSignature,v5316,[v5303]),v14706.call.hasImplementation=!funcDecl.isSignature(),v14706.call.hasImplementation&&v14706.setHasImplementation());var v5316=v14706.instanceType,v5316=null,v26952=!1,v14724=funcDecl.name;v14724&&(v14724=!funcDecl.name.isMissing());v14724?v5316=funcDecl.name.text:funcDecl.hint&&(v5316=funcDecl.hint,v26952=!0);if(null==v14706.symbol){var v14724=v14706,v14726=TypeScript.TypeSymbol,v20247;v20247=
v5316?v5316:this.anon;v14726=JAM.new(v14726,[v20247,funcDecl.minChar,funcDecl.limChar-funcDecl.minChar,this.locationInfo.unitIndex,v14706]);v14724.symbol=v14726;isDefinition||(v14706.symbol.declAST=funcDecl)}v5294&&(v14724=v14706.symbol,v14724.flags|=TypeScript.SymbolFlags.Static);isAmbient&&(v14724=v14706.symbol,v14724.flags|=TypeScript.SymbolFlags.Ambient);isPrivate&&(v14724=v14706.symbol,v14724.flags|=TypeScript.SymbolFlags.Private);v14724=v14706.symbol;v14726=funcDecl.isMethod();v14724.isMethod=
v14726;v14706.symbol.isMethod&&(v14724=v14706.symbol,v14724.flags|=TypeScript.SymbolFlags.Property);funcDecl.type=v14706;if(!isConstructor){if(isConstructor=v5316)(isLambda=!isLambda)&&(isLambda=!funcDecl.isAccessor())&&(isLambda=!v26952),isConstructor=isLambda;if(isConstructor)if(addToScope)if((addToScope=funcDecl.isMethod())&&(addToScope=v5294),addToScope)scope=container.type.members.publicMembers,JAM.call(scope.add,scope,[v5316,v14706.symbol])||(scope=this.errorReporter,JAM.call(scope.duplicateIdentifier,
scope,[funcDecl,v5316])),v14706.symbol.container=container;else{if(addToScope=null==overloadGroupSym,addToScope||(addToScope=overloadGroupSym.declAST)&&(addToScope=!overloadGroupSym.declAST.isOverload)&&(addToScope=container.isType()),addToScope){addToScope=v14706.symbol;isLambda=this.errorReporter;if(isPrivate=!isPrivate)isExported||(isExported=v5294||isGlobal),isPrivate=isExported;JAM.call(scope.enter,scope,[container,funcDecl,addToScope,isLambda,isPrivate,!1,isAmbient])}}else funcDecl.isSpecialFn()||
(v14706.symbol.container=container);else funcDecl.isSpecialFn()||(v14706.symbol.container=container)}if(isDefinition&&(funcDecl=overloadGroupSym?overloadGroupSym.getType():null,container=v14706,container!=funcDecl)){if(null==container.construct){if(overloadGroupSym=funcDecl)overloadGroupSym=funcDecl.construct;overloadGroupSym?container.construct=funcDecl.construct:(overloadGroupSym=container,scope=new TypeScript.SignatureGroup,overloadGroupSym.construct=scope)}else funcDecl&&funcDecl.construct&&container.construct.signatures.concat(funcDecl.construct.signatures);
funcDecl&&(null==container.call?container.call=funcDecl.call:funcDecl.call&&container.call.signatures.concat(funcDecl.call.signatures),!v5294&&(null==container.instanceType&&(container.instanceType=funcDecl.instanceType),v5316=container.instanceType)&&(null==v5316.call?v5316.call=funcDecl.call:funcDecl.call&&v5316.call.signatures.concat(funcDecl.call.signatures)),null==container.index?container.index=funcDecl.index:funcDecl.index&&container.index.signatures.concat(funcDecl.index.signatures))}return v5303}
function v928(funcDecl,container){var args=funcDecl.arguments,parameterTable=null,parameterTable=null,len=args.members.length,nonOptionalParams=0,result=[];if(0<len)for(var parameterTable=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,[new TypeScript.StringHashTable,new TypeScript.StringHashTable])]),parameterTable=JAM.new(TypeScript.SymbolScopeBuilder,[parameterTable,null,null,null,null,container]),i=0,v5397=i<len;v5397;){v5397=args.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v5397=
v5397[i];var paramDef=new TypeScript.ValueLocation,parameterSymbol=JAM.new(TypeScript.ParameterSymbol,[v5397.id.text,v5397.minChar,this.locationInfo.unitIndex,paramDef]);parameterSymbol.declAST=v5397;parameterSymbol.funcDecl=funcDecl;v5397.id.sym=parameterSymbol;v5397.sym=parameterSymbol;paramDef.symbol=parameterSymbol;var v26958=JAM.call(TypeScript.getTypeLink,TypeScript,[v5397.typeExpr,this,!1]);paramDef.typeLink=v26958;JAM.call(parameterTable.enter,parameterTable,[null,v5397,parameterSymbol,this.errorReporter,
!0,!1,!1]);result[result.length]=parameterSymbol;v5397.isOptionalArg()||(nonOptionalParams+=1);i+=1;v5397=i<len}return{parameters:result,nonOptionalParameterCount:nonOptionalParams}}function v927(type){if(null==type.arrayCache){var v5399=type,v26959=new ArrayCache;v5399.arrayCache=v26959;v5399=type.arrayCache;v26959=new TypeScript.Type;v5399.arrayType=v26959;type.arrayCache.arrayType.elementType=type;type.arrayCache.arrayType.symbol=type.symbol}return type.arrayCache.arrayType}function v926(ast){if(ast.nodeType==
TypeScript.NodeType.Script){var script=ast;this.locationInfo=script.locationInfo}var script=JAM.new(TypeScript.ScopeChain,[this.gloMod,null,this.globalScope]),script=JAM.new(TypeScript.TypeCollectionContext,[script,this]),v5410=TypeScript.getAstWalkerFactory();JAM.call(v5410.walk,v5410,[ast,TypeScript.preCollectTypes,TypeScript.postCollectTypes,null,script])}function v925(){for(var i=0,v5415=i<this.provisionalStartedTypecheckObjects.length;v5415;){v5415=this.provisionalStartedTypecheckObjects;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v5415=
v5415[i];if(v5415.typeCheckStatus>=this.typingContextStack.getContextID()){v5415=this.provisionalStartedTypecheckObjects;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v5415=v5415[i];v5415.typeCheckStatus=TypeScript.TypeCheckStatus.NotStarted}i+=1;v5415=i<this.provisionalStartedTypecheckObjects.length}this.provisionalStartedTypecheckObjects=[]}function v924(pto){this.inProvisionalTypecheckMode()&&JAM.set(this.provisionalStartedTypecheckObjects,this.provisionalStartedTypecheckObjects.length,
pto)}function v923(status){var v5419=status==TypeScript.TypeCheckStatus.Finished;v5419||(v5419=this.inProvisionalTypecheckMode())&&(v5419=status==this.typingContextStack.getContextID());return v5419}function v922(){return this.inProvisionalTypecheckMode()?this.typingContextStack.getContextID():TypeScript.TypeCheckStatus.Finished}function v921(){return this.typingContextStack.isProvisional()}function v920(){return this.currentContextualTypeContext}function v919(){var v5424=this.currentContextualTypeContext;
v5424&&(v5424=this.currentContextualTypeContext.contextualType);return v5424}function v918(){this.currentContextualTypeContext=null;this.errorReporter.pushToErrorSink=!1}function v917(){var v26961=this.typingContextStack.getContextualType();this.currentContextualTypeContext=v26961}function v916(contextType,provisional,condition,ast){if(condition){var v14778=this.typingContextStack.isProvisional();v14778||(v14778=provisional);JAM.call(this.setContextualType,this,[contextType,v14778])}contextType=this.typeFlow;
JAM.call(contextType.typeCheck,contextType,[ast]);condition&&this.unsetContextualType()}function v915(){this.typingContextStack.getContextualType()||(this.typingContextStack.hadProvisionalErrors=!1)}function v914(){return this.typingContextStack.hadProvisionalErrors}function v913(){var lastTC=this.typingContextStack.popContextualType(),v26962=this.typingContextStack.getContextualType();this.currentContextualTypeContext=v26962;return lastTC}function v912(type,provisional){var v5434=this.typingContextStack;
JAM.call(v5434.pushContextualType,v5434,[type,provisional]);this.currentContextualTypeContext=v5434=this.typingContextStack.getContextualType()}function v911(style){this.styleSettings=style}function TypeChecker(persistentState){this.persistentState=persistentState;this.errorReporter=null;this.checkControlFlowUseDef=this.printControlFlowGraph=this.checkControlFlow=!1;this.units=this.styleSettings=null;this.anon="_anonymous";this.currentModDecl=this.currentCompareB=this.currentCompareA=this.typeFlow=
this.locationInfo=null;this.inWith=this.inBind=!1;this.errorsOnWith=!0;this.currentContextualTypeContext=null;this.canCallDefinitionSignature=this.resolvingBases=!1;this.assignableCache={};this.subtypeCache={};this.identicalCache={};this.provisionalStartedTypecheckObjects=[];this.mustCaptureGlobalThis=!1;this.voidType=this.persistentState.voidType;this.booleanType=this.persistentState.booleanType;this.numberType=this.persistentState.doubleType;this.stringType=this.persistentState.stringType;this.anyType=
this.persistentState.anyType;this.nullType=this.persistentState.nullType;this.undefinedType=this.persistentState.undefinedType;this.globals=this.persistentState.dualGlobalValues;this.globalTypes=this.persistentState.dualGlobalTypes;this.ambientGlobals=this.persistentState.dualAmbientGlobalValues;this.ambientGlobalTypes=this.persistentState.dualAmbientGlobalTypes;this.gloModType=this.persistentState.mod;this.gloMod=this.persistentState.gloMod;this.wildElm=this.persistentState.wildElm;this.globalScope=
this.persistentState.globalScope;this.typingContextStack=persistentState=JAM.new(ContextualTypingContextStack,[this])}TypeChecker.prototype.setStyleOptions=v911;TypeChecker.prototype.setContextualType=v912;TypeChecker.prototype.unsetContextualType=v913;TypeChecker.prototype.hadProvisionalErrors=v914;TypeChecker.prototype.resetProvisionalErrors=v915;TypeChecker.prototype.typeCheckWithContextualType=v916;TypeChecker.prototype.resetTargetType=v917;TypeChecker.prototype.killCurrentContextualType=v918;
TypeChecker.prototype.hasTargetType=v919;TypeChecker.prototype.getTargetTypeContext=v920;TypeChecker.prototype.inProvisionalTypecheckMode=v921;TypeChecker.prototype.getTypeCheckFinishedStatus=v922;TypeChecker.prototype.typeStatusIsFinished=v923;TypeChecker.prototype.addStartedPTO=v924;TypeChecker.prototype.cleanStartedPTO=v925;TypeChecker.prototype.collectTypes=v926;TypeChecker.prototype.makeArrayType=v927;TypeChecker.prototype.getParameterList=v928;TypeChecker.prototype.createFunctionSignature=v929;
TypeChecker.prototype.createAccessorSymbol=v930;TypeChecker.prototype.addBases=v931;TypeChecker.prototype.scopeOf=v932;TypeChecker.prototype.lookupMemberTypeSymbol=v933;TypeChecker.prototype.findSymbolForDynamicModule=v934;TypeChecker.prototype.resolveTypeMember=v936;TypeChecker.prototype.resolveFuncDecl=v937;TypeChecker.prototype.resolveVarDecl=v938;TypeChecker.prototype.resolveTypeLink=v939;TypeChecker.prototype.resolveBaseTypeLink=v940;TypeChecker.prototype.findMostApplicableSignature=v944;TypeChecker.prototype.getApplicableSignatures=
v945;TypeChecker.prototype.canContextuallyTypeFunction=v946;TypeChecker.prototype.canContextuallyTypeObjectLiteral=v947;TypeChecker.prototype.widenType=v948;TypeChecker.prototype.isNullOrUndefinedType=v949;TypeChecker.prototype.findBestCommonType=v950;TypeChecker.prototype.typesAreIdentical=v951;TypeChecker.prototype.signatureGroupsAreIdentical=v952;TypeChecker.prototype.signaturesAreIdentical=v953;TypeChecker.prototype.sourceIsSubtypeOfTarget=v954;TypeChecker.prototype.signatureGroupIsSubtypeOfTarget=
v955;TypeChecker.prototype.signatureIsSubtypeOfTarget=v956;TypeChecker.prototype.sourceIsAssignableToTarget=v957;TypeChecker.prototype.signatureGroupIsAssignableToTarget=v958;TypeChecker.prototype.signatureIsAssignableToTarget=v959;TypeChecker.prototype.sourceIsRelatableToTarget=v960;TypeChecker.prototype.signatureGroupIsRelatableToTarget=v961;TypeChecker.prototype.signatureIsRelatableToTarget=v962;return TypeChecker}function v910(){function v909(){var v5499;if(this.contextStack.length){v5499=this.contextStack;
var v20280=this.contextStack.length-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v5499=v5499[v20280];v5499=v5499.provisional}else v5499=!1;return v5499}function v908(){var v5500;if(this.contextStack.length){v5500=this.contextStack;var v20283=this.contextStack.length-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v5500=v5500[v20283];v5500=v5500.contextID}else v5500=TypeScript.TypeCheckStatus.Finished;return v5500}function v907(){var v5501;return v5501=this.contextStack.length?
this.contextStack[this.contextStack.length-1]:null}function v906(){var tc=this.contextStack.pop(),v5503=this.checker.errorReporter,v26965=this.isProvisional();v5503.pushToErrorSink=v26965;v5503=this.hadProvisionalErrors;!v5503&&(v5503=tc.provisional)&&(v5503=this.checker.errorReporter.errorSink.length);this.hadProvisionalErrors=v5503;this.checker.errorReporter.freeCapturedErrors();return tc}function v905(type,provisional){var v5506=this.contextStack,v14792=ContextualTypingContextStack.contextID;ContextualTypingContextStack.contextID+=
1;JAM.call(v5506.push,v5506,[JAM.new(ContextualTypeContext,[type,provisional,v14792])]);this.checker.errorReporter.pushToErrorSink=provisional}function ContextualTypingContextStack(checker){this.checker=checker;this.contextStack=[];this.hadProvisionalErrors=!1}ContextualTypingContextStack.contextID=TypeScript.TypeCheckStatus.Finished+1;ContextualTypingContextStack.prototype.pushContextualType=v905;ContextualTypingContextStack.prototype.popContextualType=v906;ContextualTypingContextStack.prototype.getContextualType=
v907;ContextualTypingContextStack.prototype.getContextID=v908;ContextualTypingContextStack.prototype.isProvisional=v909;return ContextualTypingContextStack}function v904(){function ContextualTypeContext(contextualType,provisional,contextID){this.contextualType=contextualType;this.provisional=provisional;this.contextID=contextID;this.targetAccessorType=this.targetThis=this.targetSig=null}return ContextualTypeContext}function v903(){function v902(name,type){var valueLocation=new TypeScript.ValueLocation,
v5516=valueLocation,v26966=new TypeScript.TypeLink;v5516.typeLink=v26966;valueLocation=JAM.new(TypeScript.VariableSymbol,[name,0,-1,valueLocation]);JAM.call(valueLocation.setType,valueLocation,[type]);valueLocation.typeCheckStatus=TypeScript.TypeCheckStatus.Finished;valueLocation.container=this.gloMod;v5516=this.importedGlobalsTable;JAM.call(v5516.addPublicMember,v5516,[name,valueLocation])}function v901(){var v26967=new TypeScript.StringHashTable;this.globals=v26967;this.globalTypes=v26967=new TypeScript.StringHashTable;
this.ambientGlobals=v26967=new TypeScript.StringHashTable;this.ambientGlobalTypes=v26967=new TypeScript.StringHashTable;v26967=this.globalTypes;JAM.call(v26967.add,v26967,[this.voidType.symbol.name,this.voidType.symbol]);v26967=this.globalTypes;JAM.call(v26967.add,v26967,[this.booleanType.symbol.name,this.booleanType.symbol]);v26967=this.globalTypes;JAM.call(v26967.add,v26967,[this.doubleType.symbol.name,this.doubleType.symbol]);v26967=this.globalTypes;JAM.call(v26967.add,v26967,["number",this.doubleType.symbol]);
v26967=this.globalTypes;JAM.call(v26967.add,v26967,[this.stringType.symbol.name,this.stringType.symbol]);v26967=this.globalTypes;JAM.call(v26967.add,v26967,[this.anyType.symbol.name,this.anyType.symbol]);v26967=this.globalTypes;JAM.call(v26967.add,v26967,[this.nullType.symbol.name,this.nullType.symbol]);v26967=this.globalTypes;JAM.call(v26967.add,v26967,[this.undefinedType.symbol.name,this.undefinedType.symbol]);this.dualGlobalValues.secondaryTable=this.globals;this.dualGlobalTypes.secondaryTable=
this.globalTypes;this.dualAmbientGlobalValues.secondaryTable=this.ambientGlobals;this.dualAmbientGlobalTypes.secondaryTable=this.ambientGlobalTypes}function v900(mode){this.residentTypeCheck=this.dualGlobalValues.insertPrimary=this.dualGlobalTypes.insertPrimary=this.dualAmbientGlobalValues.insertPrimary=this.dualAmbientGlobalTypes.insertPrimary=mode==TypeCheckCollectionMode.Resident}function v899(flags,name){var primitive=new TypeScript.Type;primitive.primitiveTypeClass=flags;var symbol=JAM.new(TypeScript.TypeSymbol,
[name,-1,name.length,-1,primitive]);symbol.typeCheckStatus=TypeScript.TypeCheckStatus.Finished;primitive.symbol=symbol;var v5556=this.importedGlobals;JAM.call(v5556.enter,v5556,[null,null,symbol,this.errorReporter,!0,!0,!0]);return primitive}function PersistentGlobalTypeState(errorReporter){this.errorReporter=errorReporter;this.importedGlobalsTable=errorReporter=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,[new TypeScript.StringHashTable,new TypeScript.StringHashTable])]);
this.importedGlobalsTypeTable=errorReporter=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,[new TypeScript.StringHashTable,new TypeScript.StringHashTable])]);this.ambientGlobalTypes=this.ambientGlobals=this.globalTypes=this.globals=null;this.residentGlobalValues=errorReporter=new TypeScript.StringHashTable;this.residentGlobalTypes=errorReporter=new TypeScript.StringHashTable;this.residentGlobalAmbientValues=errorReporter=new TypeScript.StringHashTable;this.residentGlobalAmbientTypes=
errorReporter=new TypeScript.StringHashTable;this.residentTypeCheck=!0;this.wildElm=this.gloMod=this.mod=null;this.importedGlobals=errorReporter=JAM.new(TypeScript.SymbolScopeBuilder,[null,this.importedGlobalsTable,null,this.importedGlobalsTypeTable,null,null]);this.dualGlobalValues=errorReporter=JAM.new(TypeScript.DualStringHashTable,[this.residentGlobalValues,new TypeScript.StringHashTable]);this.dualGlobalTypes=errorReporter=JAM.new(TypeScript.DualStringHashTable,[this.residentGlobalTypes,new TypeScript.StringHashTable]);
this.dualAmbientGlobalValues=errorReporter=JAM.new(TypeScript.DualStringHashTable,[this.residentGlobalAmbientValues,new TypeScript.StringHashTable]);this.dualAmbientGlobalTypes=errorReporter=JAM.new(TypeScript.DualStringHashTable,[this.residentGlobalAmbientTypes,new TypeScript.StringHashTable]);errorReporter=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,[this.dualGlobalValues,new TypeScript.StringHashTable])]);var dualGlobalScopedAmbientMembers=JAM.new(TypeScript.ScopedMembers,
[JAM.new(TypeScript.DualStringHashTable,[this.dualAmbientGlobalValues,new TypeScript.StringHashTable])]),dualGlobalScopedEnclosedTypes=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,[this.dualGlobalTypes,new TypeScript.StringHashTable])]),dualGlobalScopedAmbientEnclosedTypes=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,[this.dualAmbientGlobalTypes,new TypeScript.StringHashTable])]),v26982=JAM.new(TypeScript.SymbolScopeBuilder,[errorReporter,dualGlobalScopedAmbientMembers,
dualGlobalScopedEnclosedTypes,dualGlobalScopedAmbientEnclosedTypes,this.importedGlobals,null]);this.globalScope=v26982;this.voidType=v26982=JAM.call(this.enterPrimitive,this,[TypeScript.Primitive.Void,"void"]);this.booleanType=v26982=JAM.call(this.enterPrimitive,this,[TypeScript.Primitive.Boolean,"bool"]);this.doubleType=v26982=JAM.call(this.enterPrimitive,this,[TypeScript.Primitive.Double,"number"]);v26982=this.importedGlobals.ambientEnclosedTypes;JAM.call(v26982.addPublicMember,v26982,["number",
this.doubleType.symbol]);this.stringType=v26982=JAM.call(this.enterPrimitive,this,[TypeScript.Primitive.String,"string"]);this.anyType=v26982=JAM.call(this.enterPrimitive,this,[TypeScript.Primitive.Any,"any"]);this.nullType=v26982=JAM.call(this.enterPrimitive,this,[TypeScript.Primitive.Null,"null"]);this.undefinedType=v26982=JAM.call(this.enterPrimitive,this,[TypeScript.Primitive.Undefined,"undefined"]);JAM.call(this.setCollectionMode,this,[TypeCheckCollectionMode.Resident]);this.wildElm=v26982=JAM.new(TypeScript.TypeSymbol,
["_element",-1,0,-1,new TypeScript.Type]);v26982=this.importedGlobalsTypeTable;JAM.call(v26982.addPublicMember,v26982,[this.wildElm.name,this.wildElm]);this.mod=dualGlobalScopedEnclosedTypes=JAM.new(TypeScript.ModuleType,[dualGlobalScopedEnclosedTypes,dualGlobalScopedAmbientEnclosedTypes]);this.mod.members=errorReporter;this.mod.ambientMembers=dualGlobalScopedAmbientMembers;this.mod.containedScope=this.globalScope;this.gloMod=errorReporter=JAM.new(TypeScript.TypeSymbol,[TypeScript.globalId,-1,0,-1,
this.mod]);errorReporter=this.mod.members;JAM.call(errorReporter.addPublicMember,errorReporter,[this.gloMod.name,this.gloMod]);JAM.call(this.defineGlobalValue,this,["undefined",this.undefinedType])}PersistentGlobalTypeState.prototype.enterPrimitive=v899;PersistentGlobalTypeState.prototype.setCollectionMode=v900;PersistentGlobalTypeState.prototype.refreshPersistentState=v901;PersistentGlobalTypeState.prototype.defineGlobalValue=v902;return PersistentGlobalTypeState}function v898(TypeCheckCollectionMode){TypeCheckCollectionMode._map=
[];TypeCheckCollectionMode._map[0]="Resident";TypeCheckCollectionMode.Resident=0;TypeCheckCollectionMode._map[1]="Transient";TypeCheckCollectionMode.Transient=1}function v897(){function v896(message){this.message=message}function v895(message){this.onlyCaptureFirstError?JAM.call(this.setMessage,this,[message]):this.message=message=this.message?message+":\n\t"+this.message:message}function TypeComparisonInfo(){this.onlyCaptureFirstError=!1;this.flags=TypeScript.TypeRelationshipFlags.SuccessfulComparison;
this.message=""}TypeComparisonInfo.prototype.addMessageToFront=v895;TypeComparisonInfo.prototype.setMessage=v896;return TypeComparisonInfo}function v894(){function v893(arrInstType,checker){if(null==this.arrayBase){var v26993=JAM.call(arrInstType.specializeType,arrInstType,[checker.wildElm.type,this.arrayType.elementType,checker,!0]);this.arrayBase=v26993}return this.arrayBase}function ArrayCache(){this.arrayBase=null}ArrayCache.prototype.specialize=v893;return ArrayCache}var ArrayCache=v894();TypeScript.ArrayCache=
ArrayCache;var TypeComparisonInfo=v897();TypeScript.TypeComparisonInfo=TypeComparisonInfo;TypeComparisonInfo=TypeScript.TypeCheckCollectionMode;TypeComparisonInfo||(TypeComparisonInfo=TypeScript.TypeCheckCollectionMode={});v898(TypeComparisonInfo);var TypeCheckCollectionMode=TypeScript.TypeCheckCollectionMode,TypeComparisonInfo=v903();TypeScript.PersistentGlobalTypeState=TypeComparisonInfo;var ContextualTypeContext=v904();TypeScript.ContextualTypeContext=ContextualTypeContext;var ContextualTypingContextStack=
v910();TypeScript.ContextualTypingContextStack=ContextualTypingContextStack;TypeComparisonInfo=v963();TypeScript.TypeChecker=TypeComparisonInfo}
function v892(){var TypeScript=v18813;function v891(_super){function v890(){return TokenClass.RegExpLiteral}function v889(){return this.regex.toString()}function RegularExpressionLiteralToken(regex){JAM.call(_super.call,_super,[this,TokenID.RegularExpressionLiteral]);this.regex=regex}JAM.call(__extends,null,[RegularExpressionLiteralToken,_super]);RegularExpressionLiteralToken.prototype.getText=v889;RegularExpressionLiteralToken.prototype.classification=v890;return RegularExpressionLiteralToken}function v888(_super){function v887(){return TokenClass.Comment}
function v886(){return this.value}function CommentToken(tokenID,value,isBlock,startPos,line,endsLine){JAM.call(_super.call,_super,[this,tokenID]);this.value=value;this.isBlock=isBlock;this.startPos=startPos;this.line=line;this.endsLine=endsLine}JAM.call(__extends,null,[CommentToken,_super]);CommentToken.prototype.getText=v886;CommentToken.prototype.classification=v887;return CommentToken}function v885(_super){function v884(){return TokenClass.Whitespace}function v883(){return this.value}function WhitespaceToken(tokenId,
value){JAM.call(_super.call,_super,[this,tokenId]);this.value=value}JAM.call(__extends,null,[WhitespaceToken,_super]);WhitespaceToken.prototype.getText=v883;WhitespaceToken.prototype.classification=v884;return WhitespaceToken}function v882(_super){function v881(){return TokenClass.Identifier}function v880(){return this.value}function IdentifierToken(value,hasEscapeSequence){JAM.call(_super.call,_super,[this,TokenID.Identifier]);this.value=value;this.hasEscapeSequence=hasEscapeSequence}JAM.call(__extends,
null,[IdentifierToken,_super]);IdentifierToken.prototype.getText=v880;IdentifierToken.prototype.classification=v881;return IdentifierToken}function v879(_super){function v878(){return TokenClass.StringLiteral}function v877(){return this.value}function StringLiteralToken(value){JAM.call(_super.call,_super,[this,TokenID.StringLiteral]);this.value=value}JAM.call(__extends,null,[StringLiteralToken,_super]);StringLiteralToken.prototype.getText=v877;StringLiteralToken.prototype.classification=v878;return StringLiteralToken}
function v876(_super){function v875(){return TokenClass.NumberLiteral}function v874(){var v5647;return v5647=this.hasEmptyFraction?this.value.toString()+".0":this.value.toString()}function NumberLiteralToken(value,hasEmptyFraction){JAM.call(_super.call,_super,[this,TokenID.NumberLiteral]);this.value=value;this.hasEmptyFraction=hasEmptyFraction}JAM.call(__extends,null,[NumberLiteralToken,_super]);NumberLiteralToken.prototype.getText=v874;NumberLiteralToken.prototype.classification=v875;return NumberLiteralToken}
function v873(){function v872(){if(this.tokenId<=TokenID.LimKeyword)return TokenClass.Keyword;var tokenInfo=lookupToken(this.tokenId);if(void 0!=tokenInfo){var v14860=tokenInfo.unopNodeType!=TypeScript.NodeType.None;v14860||(v14860=tokenInfo.binopNodeType!=TypeScript.NodeType.None);if(v14860)return TokenClass.Operator}return TokenClass.Punctuation}function v871(){var v14861=TypeScript.tokenTable,v14862=this.tokenId;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v14861=v14861[v14862];
return v14861.text}function v870(line,outfile){JAM.call(outfile.WriteLine,outfile,[this.toString()+",on line"+line])}function v869(){var v14864="token: "+this.tokenId+" "+this.getText()+" (",v20312=TokenID._map,v20313=this.tokenId;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v20312=v20312[v20313];return v14864+v20312+")"}function Token(tokenId){this.tokenId=tokenId}Token.prototype.toString=v869;Token.prototype.print=v870;Token.prototype.getText=v871;Token.prototype.classification=
v872;return Token}function v868(){function SavedToken(tok,minChar,limChar){this.tok=tok;this.minChar=minChar;this.limChar=limChar}return SavedToken}function v867(TokenClass){TokenClass._map=[];TokenClass._map[0]="Punctuation";TokenClass.Punctuation=0;TokenClass._map[1]="Keyword";TokenClass.Keyword=1;TokenClass._map[2]="Operator";TokenClass.Operator=2;TokenClass._map[3]="Comment";TokenClass.Comment=3;TokenClass._map[4]="Whitespace";TokenClass.Whitespace=4;TokenClass._map[5]="Identifier";TokenClass.Identifier=
5;TokenClass._map[6]="NumberLiteral";TokenClass.NumberLiteral=6;TokenClass._map[7]="StringLiteral";TokenClass.StringLiteral=7;TokenClass._map[8]="RegExpLiteral";TokenClass.RegExpLiteral=8}function v866(){function TokenInfo(tokenId,reservation,binopPrecedence,binopNodeType,unopPrecedence,unopNodeType,text,ers){this.tokenId=tokenId;this.reservation=reservation;this.binopPrecedence=binopPrecedence;this.binopNodeType=binopNodeType;this.unopPrecedence=unopPrecedence;this.unopNodeType=unopNodeType;this.text=
text;this.ers=ers}return TokenInfo}function v865(Reservation){Reservation._map=[];Reservation.None=0;Reservation.Javascript=1;Reservation.JavascriptFuture=2;Reservation.TypeScript=4;Reservation.JavascriptFutureStrict=8;Reservation.TypeScriptAndJS=Reservation.Javascript|Reservation.TypeScript;Reservation.TypeScriptAndJSFuture=Reservation.JavascriptFuture|Reservation.TypeScript;Reservation.TypeScriptAndJSFutureStrict=Reservation.JavascriptFutureStrict|Reservation.TypeScript}function v864(OperatorPrecedence){OperatorPrecedence._map=
[];OperatorPrecedence._map[0]="None";OperatorPrecedence.None=0;OperatorPrecedence._map[1]="Comma";OperatorPrecedence.Comma=1;OperatorPrecedence._map[2]="Assignment";OperatorPrecedence.Assignment=2;OperatorPrecedence._map[3]="Conditional";OperatorPrecedence.Conditional=3;OperatorPrecedence._map[4]="LogicalOr";OperatorPrecedence.LogicalOr=4;OperatorPrecedence._map[5]="LogicalAnd";OperatorPrecedence.LogicalAnd=5;OperatorPrecedence._map[6]="BitwiseOr";OperatorPrecedence.BitwiseOr=6;OperatorPrecedence._map[7]=
"BitwiseExclusiveOr";OperatorPrecedence.BitwiseExclusiveOr=7;OperatorPrecedence._map[8]="BitwiseAnd";OperatorPrecedence.BitwiseAnd=8;OperatorPrecedence._map[9]="Equality";OperatorPrecedence.Equality=9;OperatorPrecedence._map[10]="Relational";OperatorPrecedence.Relational=10;OperatorPrecedence._map[11]="Shift";OperatorPrecedence.Shift=11;OperatorPrecedence._map[12]="Additive";OperatorPrecedence.Additive=12;OperatorPrecedence._map[13]="Multiplicative";OperatorPrecedence.Multiplicative=13;OperatorPrecedence._map[14]=
"Unary";OperatorPrecedence.Unary=14;OperatorPrecedence._map[15]="Lim";OperatorPrecedence.Lim=15}function v863(TokenID){TokenID._map=[];TokenID._map[0]="Any";TokenID.Any=0;TokenID._map[1]="Bool";TokenID.Bool=1;TokenID._map[2]="Break";TokenID.Break=2;TokenID._map[3]="Case";TokenID.Case=3;TokenID._map[4]="Catch";TokenID.Catch=4;TokenID._map[5]="Class";TokenID.Class=5;TokenID._map[6]="Const";TokenID.Const=6;TokenID._map[7]="Continue";TokenID.Continue=7;TokenID._map[8]="Debugger";TokenID.Debugger=8;TokenID._map[9]=
"Default";TokenID.Default=9;TokenID._map[10]="Delete";TokenID.Delete=10;TokenID._map[11]="Do";TokenID.Do=11;TokenID._map[12]="Else";TokenID.Else=12;TokenID._map[13]="Enum";TokenID.Enum=13;TokenID._map[14]="Export";TokenID.Export=14;TokenID._map[15]="Extends";TokenID.Extends=15;TokenID._map[16]="Declare";TokenID.Declare=16;TokenID._map[17]="False";TokenID.False=17;TokenID._map[18]="Finally";TokenID.Finally=18;TokenID._map[19]="For";TokenID.For=19;TokenID._map[20]="Function";TokenID.Function=20;TokenID._map[21]=
"Constructor";TokenID.Constructor=21;TokenID._map[22]="Get";TokenID.Get=22;TokenID._map[23]="If";TokenID.If=23;TokenID._map[24]="Implements";TokenID.Implements=24;TokenID._map[25]="Import";TokenID.Import=25;TokenID._map[26]="In";TokenID.In=26;TokenID._map[27]="InstanceOf";TokenID.InstanceOf=27;TokenID._map[28]="Interface";TokenID.Interface=28;TokenID._map[29]="Let";TokenID.Let=29;TokenID._map[30]="Module";TokenID.Module=30;TokenID._map[31]="New";TokenID.New=31;TokenID._map[32]="Number";TokenID.Number=
32;TokenID._map[33]="Null";TokenID.Null=33;TokenID._map[34]="Package";TokenID.Package=34;TokenID._map[35]="Private";TokenID.Private=35;TokenID._map[36]="Protected";TokenID.Protected=36;TokenID._map[37]="Public";TokenID.Public=37;TokenID._map[38]="Return";TokenID.Return=38;TokenID._map[39]="Set";TokenID.Set=39;TokenID._map[40]="Static";TokenID.Static=40;TokenID._map[41]="String";TokenID.String=41;TokenID._map[42]="Super";TokenID.Super=42;TokenID._map[43]="Switch";TokenID.Switch=43;TokenID._map[44]=
"This";TokenID.This=44;TokenID._map[45]="Throw";TokenID.Throw=45;TokenID._map[46]="True";TokenID.True=46;TokenID._map[47]="Try";TokenID.Try=47;TokenID._map[48]="TypeOf";TokenID.TypeOf=48;TokenID._map[49]="Var";TokenID.Var=49;TokenID._map[50]="Void";TokenID.Void=50;TokenID._map[51]="With";TokenID.With=51;TokenID._map[52]="While";TokenID.While=52;TokenID._map[53]="Yield";TokenID.Yield=53;TokenID._map[54]="Semicolon";TokenID.Semicolon=54;TokenID._map[55]="OpenParen";TokenID.OpenParen=55;TokenID._map[56]=
"CloseParen";TokenID.CloseParen=56;TokenID._map[57]="OpenBracket";TokenID.OpenBracket=57;TokenID._map[58]="CloseBracket";TokenID.CloseBracket=58;TokenID._map[59]="OpenBrace";TokenID.OpenBrace=59;TokenID._map[60]="CloseBrace";TokenID.CloseBrace=60;TokenID._map[61]="Comma";TokenID.Comma=61;TokenID._map[62]="Equals";TokenID.Equals=62;TokenID._map[63]="PlusEquals";TokenID.PlusEquals=63;TokenID._map[64]="MinusEquals";TokenID.MinusEquals=64;TokenID._map[65]="AsteriskEquals";TokenID.AsteriskEquals=65;TokenID._map[66]=
"SlashEquals";TokenID.SlashEquals=66;TokenID._map[67]="PercentEquals";TokenID.PercentEquals=67;TokenID._map[68]="AmpersandEquals";TokenID.AmpersandEquals=68;TokenID._map[69]="CaretEquals";TokenID.CaretEquals=69;TokenID._map[70]="BarEquals";TokenID.BarEquals=70;TokenID._map[71]="LessThanLessThanEquals";TokenID.LessThanLessThanEquals=71;TokenID._map[72]="GreaterThanGreaterThanEquals";TokenID.GreaterThanGreaterThanEquals=72;TokenID._map[73]="GreaterThanGreaterThanGreaterThanEquals";TokenID.GreaterThanGreaterThanGreaterThanEquals=
73;TokenID._map[74]="Question";TokenID.Question=74;TokenID._map[75]="Colon";TokenID.Colon=75;TokenID._map[76]="BarBar";TokenID.BarBar=76;TokenID._map[77]="AmpersandAmpersand";TokenID.AmpersandAmpersand=77;TokenID._map[78]="Bar";TokenID.Bar=78;TokenID._map[79]="Caret";TokenID.Caret=79;TokenID._map[80]="And";TokenID.And=80;TokenID._map[81]="EqualsEquals";TokenID.EqualsEquals=81;TokenID._map[82]="ExclamationEquals";TokenID.ExclamationEquals=82;TokenID._map[83]="EqualsEqualsEquals";TokenID.EqualsEqualsEquals=
83;TokenID._map[84]="ExclamationEqualsEquals";TokenID.ExclamationEqualsEquals=84;TokenID._map[85]="LessThan";TokenID.LessThan=85;TokenID._map[86]="LessThanEquals";TokenID.LessThanEquals=86;TokenID._map[87]="GreaterThan";TokenID.GreaterThan=87;TokenID._map[88]="GreaterThanEquals";TokenID.GreaterThanEquals=88;TokenID._map[89]="LessThanLessThan";TokenID.LessThanLessThan=89;TokenID._map[90]="GreaterThanGreaterThan";TokenID.GreaterThanGreaterThan=90;TokenID._map[91]="GreaterThanGreaterThanGreaterThan";
TokenID.GreaterThanGreaterThanGreaterThan=91;TokenID._map[92]="Plus";TokenID.Plus=92;TokenID._map[93]="Minus";TokenID.Minus=93;TokenID._map[94]="Asterisk";TokenID.Asterisk=94;TokenID._map[95]="Slash";TokenID.Slash=95;TokenID._map[96]="Percent";TokenID.Percent=96;TokenID._map[97]="Tilde";TokenID.Tilde=97;TokenID._map[98]="Exclamation";TokenID.Exclamation=98;TokenID._map[99]="PlusPlus";TokenID.PlusPlus=99;TokenID._map[100]="MinusMinus";TokenID.MinusMinus=100;TokenID._map[101]="Dot";TokenID.Dot=101;
TokenID._map[102]="DotDotDot";TokenID.DotDotDot=102;TokenID._map[103]="Error";TokenID.Error=103;TokenID._map[104]="EndOfFile";TokenID.EndOfFile=104;TokenID._map[105]="EqualsGreaterThan";TokenID.EqualsGreaterThan=105;TokenID._map[106]="Identifier";TokenID.Identifier=106;TokenID._map[107]="StringLiteral";TokenID.StringLiteral=107;TokenID._map[108]="RegularExpressionLiteral";TokenID.RegularExpressionLiteral=108;TokenID._map[109]="NumberLiteral";TokenID.NumberLiteral=109;TokenID._map[110]="Whitespace";
TokenID.Whitespace=110;TokenID._map[111]="Comment";TokenID.Comment=111;TokenID._map[112]="Lim";TokenID.Lim=112;TokenID.LimFixed=TokenID.EqualsGreaterThan;TokenID.LimKeyword=TokenID.Yield}function setTokenInfo(tokenId,reservation,binopPrecedence,binopNodeType,unopPrecedence,unopNodeType,text,ers){if(void 0!==tokenId){var v5806=TypeScript.tokenTable,v5807=tokenId;reservation=JAM.new(TokenInfo,[tokenId,reservation,binopPrecedence,binopNodeType,unopPrecedence,unopNodeType,text,ers]);JAM.set(v5806,v5807,
reservation);binopNodeType!=TypeScript.NodeType.None&&(JAM.set(TypeScript.nodeTypeTable,binopNodeType,text),JAM.set(TypeScript.nodeTypeToTokTable,binopNodeType,tokenId));unopNodeType!=TypeScript.NodeType.None&&JAM.set(TypeScript.nodeTypeTable,unopNodeType,text)}}function lookupToken(tokenId){var v5814=TypeScript.tokenTable;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v5814[tokenId]}function initializeStaticTokens(){for(var i=0,v5817=i<=TokenID.LimFixed;v5817;){var v5817=
TypeScript.staticTokens,v5816=i,v26995=JAM.new(Token,[i]);v5817[v5816]=v26995;i+=1;v5817=i<=TokenID.LimFixed}}var v14870=TypeScript.TokenID;v14870||(v14870=TypeScript.TokenID={});v863(v14870);var TokenID=TypeScript.TokenID,v14870=TypeScript,v26996=[];v14870.tokenTable=v26996;v14870=TypeScript;v26996=[];v14870.nodeTypeTable=v26996;v14870=TypeScript;v26996=[];v14870.nodeTypeToTokTable=v26996;v14870=TypeScript;v26996=[];v14870.noRegexTable=v26996;JAM.set(TypeScript.noRegexTable,TokenID.Identifier,!0);
JAM.set(TypeScript.noRegexTable,TokenID.StringLiteral,!0);JAM.set(TypeScript.noRegexTable,TokenID.NumberLiteral,!0);JAM.set(TypeScript.noRegexTable,TokenID.RegularExpressionLiteral,!0);JAM.set(TypeScript.noRegexTable,TokenID.This,!0);JAM.set(TypeScript.noRegexTable,TokenID.PlusPlus,!0);JAM.set(TypeScript.noRegexTable,TokenID.MinusMinus,!0);JAM.set(TypeScript.noRegexTable,TokenID.CloseParen,!0);JAM.set(TypeScript.noRegexTable,TokenID.CloseBracket,!0);JAM.set(TypeScript.noRegexTable,TokenID.CloseBrace,
!0);JAM.set(TypeScript.noRegexTable,TokenID.True,!0);JAM.set(TypeScript.noRegexTable,TokenID.False,!0);v14870=TypeScript.OperatorPrecedence;v14870||(v14870=TypeScript.OperatorPrecedence={});v864(v14870);v14870=TypeScript.OperatorPrecedence;v26996=TypeScript.Reservation;v26996||(v26996=TypeScript.Reservation={});v865(v26996);var v26996=TypeScript.Reservation,TokenInfo=v866();TypeScript.TokenInfo=TokenInfo;setTokenInfo(TokenID.Any,v26996.TypeScript,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,
"any",TypeScript.ErrorRecoverySet.PrimType);setTokenInfo(TokenID.Bool,v26996.TypeScript,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"bool",TypeScript.ErrorRecoverySet.PrimType);setTokenInfo(TokenID.Break,v26996.TypeScriptAndJS,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"break",TypeScript.ErrorRecoverySet.Stmt);setTokenInfo(TokenID.Case,v26996.TypeScriptAndJS,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"case",
TypeScript.ErrorRecoverySet.SCase);setTokenInfo(TokenID.Catch,v26996.TypeScriptAndJS,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"catch",TypeScript.ErrorRecoverySet.Catch);setTokenInfo(TokenID.Class,v26996.TypeScriptAndJSFuture,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"class",TypeScript.ErrorRecoverySet.TypeScriptS);setTokenInfo(TokenID.Const,v26996.TypeScriptAndJSFuture,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,
"const",TypeScript.ErrorRecoverySet.Var);setTokenInfo(TokenID.Continue,v26996.TypeScriptAndJS,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"continue",TypeScript.ErrorRecoverySet.Stmt);setTokenInfo(TokenID.Debugger,v26996.TypeScriptAndJS,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.Debugger,"debugger",TypeScript.ErrorRecoverySet.Stmt);setTokenInfo(TokenID.Default,v26996.TypeScriptAndJS,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,
"default",TypeScript.ErrorRecoverySet.SCase);setTokenInfo(TokenID.Delete,v26996.TypeScriptAndJS,v14870.None,TypeScript.NodeType.None,v14870.Unary,TypeScript.NodeType.Delete,"delete",TypeScript.ErrorRecoverySet.Prefix);setTokenInfo(TokenID.Do,v26996.TypeScriptAndJS,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"do",TypeScript.ErrorRecoverySet.Stmt);setTokenInfo(TokenID.Else,v26996.TypeScriptAndJS,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,
"else",TypeScript.ErrorRecoverySet.Else);setTokenInfo(TokenID.Enum,v26996.TypeScriptAndJSFuture,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"enum",TypeScript.ErrorRecoverySet.TypeScriptS);setTokenInfo(TokenID.Export,v26996.TypeScriptAndJSFuture,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"export",TypeScript.ErrorRecoverySet.TypeScriptS);setTokenInfo(TokenID.Extends,v26996.TypeScriptAndJSFuture,v14870.None,TypeScript.NodeType.None,v14870.None,
TypeScript.NodeType.None,"extends",TypeScript.ErrorRecoverySet.None);setTokenInfo(TokenID.Declare,v26996.TypeScript,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"declare",TypeScript.ErrorRecoverySet.Stmt);setTokenInfo(TokenID.False,v26996.TypeScriptAndJS,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"false",TypeScript.ErrorRecoverySet.RLit);setTokenInfo(TokenID.Finally,v26996.TypeScriptAndJS,v14870.None,TypeScript.NodeType.None,v14870.None,
TypeScript.NodeType.None,"finally",TypeScript.ErrorRecoverySet.Catch);setTokenInfo(TokenID.For,v26996.TypeScriptAndJS,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"for",TypeScript.ErrorRecoverySet.Stmt);setTokenInfo(TokenID.Function,v26996.TypeScriptAndJS,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"function",TypeScript.ErrorRecoverySet.Func);setTokenInfo(TokenID.Constructor,v26996.TypeScriptAndJSFutureStrict,v14870.None,TypeScript.NodeType.None,
v14870.None,TypeScript.NodeType.None,"constructor",TypeScript.ErrorRecoverySet.Func);setTokenInfo(TokenID.Get,v26996.TypeScript,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"get",TypeScript.ErrorRecoverySet.Func);setTokenInfo(TokenID.Set,v26996.TypeScript,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"set",TypeScript.ErrorRecoverySet.Func);setTokenInfo(TokenID.If,v26996.TypeScriptAndJS,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,
"if",TypeScript.ErrorRecoverySet.Stmt);setTokenInfo(TokenID.Implements,v26996.TypeScriptAndJSFutureStrict,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"implements",TypeScript.ErrorRecoverySet.None);setTokenInfo(TokenID.Import,v26996.TypeScriptAndJSFuture,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"import",TypeScript.ErrorRecoverySet.TypeScriptS);setTokenInfo(TokenID.In,v26996.TypeScriptAndJS,v14870.Relational,TypeScript.NodeType.In,v14870.None,
TypeScript.NodeType.None,"in",TypeScript.ErrorRecoverySet.None);setTokenInfo(TokenID.InstanceOf,v26996.TypeScriptAndJS,v14870.Relational,TypeScript.NodeType.InstOf,v14870.None,TypeScript.NodeType.None,"instanceof",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.Interface,v26996.TypeScriptAndJSFutureStrict,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"interface",TypeScript.ErrorRecoverySet.TypeScriptS);setTokenInfo(TokenID.Let,v26996.JavascriptFutureStrict,v14870.None,
TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"let",TypeScript.ErrorRecoverySet.None);setTokenInfo(TokenID.Module,v26996.TypeScript,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"module",TypeScript.ErrorRecoverySet.TypeScriptS);setTokenInfo(TokenID.New,v26996.TypeScriptAndJS,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"new",TypeScript.ErrorRecoverySet.PreOp);setTokenInfo(TokenID.Number,v26996.TypeScript,v14870.None,TypeScript.NodeType.None,
v14870.None,TypeScript.NodeType.None,"number",TypeScript.ErrorRecoverySet.PrimType);setTokenInfo(TokenID.Null,v26996.TypeScriptAndJS,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"null",TypeScript.ErrorRecoverySet.RLit);setTokenInfo(TokenID.Package,v26996.JavascriptFutureStrict,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"package",TypeScript.ErrorRecoverySet.None);setTokenInfo(TokenID.Private,v26996.TypeScriptAndJSFutureStrict,v14870.None,
TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"private",TypeScript.ErrorRecoverySet.TypeScriptS);setTokenInfo(TokenID.Protected,v26996.JavascriptFutureStrict,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"protected",TypeScript.ErrorRecoverySet.None);setTokenInfo(TokenID.Public,v26996.TypeScriptAndJSFutureStrict,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"public",TypeScript.ErrorRecoverySet.TypeScriptS);setTokenInfo(TokenID.Return,
v26996.TypeScriptAndJS,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"return",TypeScript.ErrorRecoverySet.Stmt);setTokenInfo(TokenID.Static,v26996.TypeScriptAndJSFutureStrict,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"static",TypeScript.ErrorRecoverySet.None);setTokenInfo(TokenID.String,v26996.TypeScript,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"string",TypeScript.ErrorRecoverySet.PrimType);setTokenInfo(TokenID.Super,
v26996.TypeScriptAndJSFuture,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"super",TypeScript.ErrorRecoverySet.RLit);setTokenInfo(TokenID.Switch,v26996.TypeScriptAndJS,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"switch",TypeScript.ErrorRecoverySet.Stmt);setTokenInfo(TokenID.This,v26996.TypeScriptAndJS,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"this",TypeScript.ErrorRecoverySet.RLit);setTokenInfo(TokenID.Throw,
v26996.TypeScriptAndJS,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"throw",TypeScript.ErrorRecoverySet.Stmt);setTokenInfo(TokenID.True,v26996.TypeScriptAndJS,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"true",TypeScript.ErrorRecoverySet.RLit);setTokenInfo(TokenID.Try,v26996.TypeScriptAndJS,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"try",TypeScript.ErrorRecoverySet.Stmt);setTokenInfo(TokenID.TypeOf,v26996.TypeScriptAndJS,
v14870.None,TypeScript.NodeType.None,v14870.Unary,TypeScript.NodeType.Typeof,"typeof",TypeScript.ErrorRecoverySet.Prefix);setTokenInfo(TokenID.Var,v26996.TypeScriptAndJS,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"var",TypeScript.ErrorRecoverySet.Var);setTokenInfo(TokenID.Void,v26996.TypeScriptAndJS,v14870.None,TypeScript.NodeType.None,v14870.Unary,TypeScript.NodeType.Void,"void",TypeScript.ErrorRecoverySet.Prefix);setTokenInfo(TokenID.With,v26996.TypeScriptAndJS,v14870.None,
TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.With,"with",TypeScript.ErrorRecoverySet.Stmt);setTokenInfo(TokenID.While,v26996.TypeScriptAndJS,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"while",TypeScript.ErrorRecoverySet.While);setTokenInfo(TokenID.Yield,v26996.JavascriptFutureStrict,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"yield",TypeScript.ErrorRecoverySet.None);setTokenInfo(TokenID.Identifier,v26996.None,v14870.None,TypeScript.NodeType.None,
v14870.None,TypeScript.NodeType.None,"identifier",TypeScript.ErrorRecoverySet.ID);setTokenInfo(TokenID.NumberLiteral,v26996.None,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"numberLiteral",TypeScript.ErrorRecoverySet.Literal);setTokenInfo(TokenID.RegularExpressionLiteral,v26996.None,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"regex",TypeScript.ErrorRecoverySet.RegExp);setTokenInfo(TokenID.StringLiteral,v26996.None,v14870.None,TypeScript.NodeType.None,
v14870.None,TypeScript.NodeType.None,"qstring",TypeScript.ErrorRecoverySet.Literal);setTokenInfo(TokenID.Semicolon,v26996.None,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,";",TypeScript.ErrorRecoverySet.SColon);setTokenInfo(TokenID.CloseParen,v26996.None,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,")",TypeScript.ErrorRecoverySet.RParen);setTokenInfo(TokenID.CloseBracket,v26996.None,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,
"]",TypeScript.ErrorRecoverySet.RBrack);setTokenInfo(TokenID.OpenBrace,v26996.None,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"{",TypeScript.ErrorRecoverySet.LCurly);setTokenInfo(TokenID.CloseBrace,v26996.None,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"}",TypeScript.ErrorRecoverySet.RCurly);setTokenInfo(TokenID.DotDotDot,v26996.None,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"...",TypeScript.ErrorRecoverySet.None);
setTokenInfo(TokenID.Comma,v26996.None,v14870.Comma,TypeScript.NodeType.Comma,v14870.None,TypeScript.NodeType.None,",",TypeScript.ErrorRecoverySet.Comma);setTokenInfo(TokenID.Equals,v26996.None,v14870.Assignment,TypeScript.NodeType.Asg,v14870.None,TypeScript.NodeType.None,"=",TypeScript.ErrorRecoverySet.Asg);setTokenInfo(TokenID.PlusEquals,v26996.None,v14870.Assignment,TypeScript.NodeType.AsgAdd,v14870.None,TypeScript.NodeType.None,"+=",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.MinusEquals,
v26996.None,v14870.Assignment,TypeScript.NodeType.AsgSub,v14870.None,TypeScript.NodeType.None,"-=",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.AsteriskEquals,v26996.None,v14870.Assignment,TypeScript.NodeType.AsgMul,v14870.None,TypeScript.NodeType.None,"*=",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.SlashEquals,v26996.None,v14870.Assignment,TypeScript.NodeType.AsgDiv,v14870.None,TypeScript.NodeType.None,"/=",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.PercentEquals,
v26996.None,v14870.Assignment,TypeScript.NodeType.AsgMod,v14870.None,TypeScript.NodeType.None,"%=",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.AmpersandEquals,v26996.None,v14870.Assignment,TypeScript.NodeType.AsgAnd,v14870.None,TypeScript.NodeType.None,"&=",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.CaretEquals,v26996.None,v14870.Assignment,TypeScript.NodeType.AsgXor,v14870.None,TypeScript.NodeType.None,"^=",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.BarEquals,
v26996.None,v14870.Assignment,TypeScript.NodeType.AsgOr,v14870.None,TypeScript.NodeType.None,"|=",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.LessThanLessThanEquals,v26996.None,v14870.Assignment,TypeScript.NodeType.AsgLsh,v14870.None,TypeScript.NodeType.None,"<<=",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.GreaterThanGreaterThanEquals,v26996.None,v14870.Assignment,TypeScript.NodeType.AsgRsh,v14870.None,TypeScript.NodeType.None,">>=",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.GreaterThanGreaterThanGreaterThanEquals,
v26996.None,v14870.Assignment,TypeScript.NodeType.AsgRs2,v14870.None,TypeScript.NodeType.None,">>>=",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.Question,v26996.None,v14870.Conditional,TypeScript.NodeType.ConditionalExpression,v14870.None,TypeScript.NodeType.None,"?",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.Colon,v26996.None,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,":",TypeScript.ErrorRecoverySet.Colon);setTokenInfo(TokenID.BarBar,v26996.None,
v14870.LogicalOr,TypeScript.NodeType.LogOr,v14870.None,TypeScript.NodeType.None,"||",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.AmpersandAmpersand,v26996.None,v14870.LogicalAnd,TypeScript.NodeType.LogAnd,v14870.None,TypeScript.NodeType.None,"&&",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.Bar,v26996.None,v14870.BitwiseOr,TypeScript.NodeType.Or,v14870.None,TypeScript.NodeType.None,"|",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.Caret,v26996.None,v14870.BitwiseExclusiveOr,
TypeScript.NodeType.Xor,v14870.None,TypeScript.NodeType.None,"^",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.And,v26996.None,v14870.BitwiseAnd,TypeScript.NodeType.And,v14870.None,TypeScript.NodeType.None,"&",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.EqualsEquals,v26996.None,v14870.Equality,TypeScript.NodeType.Eq,v14870.None,TypeScript.NodeType.None,"==",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.ExclamationEquals,v26996.None,v14870.Equality,TypeScript.NodeType.Ne,
v14870.None,TypeScript.NodeType.None,"!=",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.EqualsEqualsEquals,v26996.None,v14870.Equality,TypeScript.NodeType.Eqv,v14870.None,TypeScript.NodeType.None,"===",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.ExclamationEqualsEquals,v26996.None,v14870.Equality,TypeScript.NodeType.NEqv,v14870.None,TypeScript.NodeType.None,"!==",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.LessThan,v26996.None,v14870.Relational,TypeScript.NodeType.Lt,
v14870.None,TypeScript.NodeType.None,"<",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.LessThanEquals,v26996.None,v14870.Relational,TypeScript.NodeType.Le,v14870.None,TypeScript.NodeType.None,"<=",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.GreaterThan,v26996.None,v14870.Relational,TypeScript.NodeType.Gt,v14870.None,TypeScript.NodeType.None,">",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.GreaterThanEquals,v26996.None,v14870.Relational,TypeScript.NodeType.Ge,v14870.None,
TypeScript.NodeType.None,">=",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.LessThanLessThan,v26996.None,v14870.Shift,TypeScript.NodeType.Lsh,v14870.None,TypeScript.NodeType.None,"<<",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.GreaterThanGreaterThan,v26996.None,v14870.Shift,TypeScript.NodeType.Rsh,v14870.None,TypeScript.NodeType.None,">>",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.GreaterThanGreaterThanGreaterThan,v26996.None,v14870.Shift,TypeScript.NodeType.Rs2,
v14870.None,TypeScript.NodeType.None,">>>",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.Plus,v26996.None,v14870.Additive,TypeScript.NodeType.Add,v14870.Unary,TypeScript.NodeType.Pos,"+",TypeScript.ErrorRecoverySet.AddOp);setTokenInfo(TokenID.Minus,v26996.None,v14870.Additive,TypeScript.NodeType.Sub,v14870.Unary,TypeScript.NodeType.Neg,"-",TypeScript.ErrorRecoverySet.AddOp);setTokenInfo(TokenID.Asterisk,v26996.None,v14870.Multiplicative,TypeScript.NodeType.Mul,v14870.None,TypeScript.NodeType.None,
"*",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.Slash,v26996.None,v14870.Multiplicative,TypeScript.NodeType.Div,v14870.None,TypeScript.NodeType.None,"/",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.Percent,v26996.None,v14870.Multiplicative,TypeScript.NodeType.Mod,v14870.None,TypeScript.NodeType.None,"%",TypeScript.ErrorRecoverySet.BinOp);setTokenInfo(TokenID.Tilde,v26996.None,v14870.None,TypeScript.NodeType.None,v14870.Unary,TypeScript.NodeType.Not,"~",TypeScript.ErrorRecoverySet.PreOp);
setTokenInfo(TokenID.Exclamation,v26996.None,v14870.None,TypeScript.NodeType.None,v14870.Unary,TypeScript.NodeType.LogNot,"!",TypeScript.ErrorRecoverySet.PreOp);setTokenInfo(TokenID.PlusPlus,v26996.None,v14870.None,TypeScript.NodeType.None,v14870.Unary,TypeScript.NodeType.IncPre,"++",TypeScript.ErrorRecoverySet.PreOp);setTokenInfo(TokenID.MinusMinus,v26996.None,v14870.None,TypeScript.NodeType.None,v14870.Unary,TypeScript.NodeType.DecPre,"--",TypeScript.ErrorRecoverySet.PreOp);setTokenInfo(TokenID.OpenParen,
v26996.None,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"(",TypeScript.ErrorRecoverySet.LParen);setTokenInfo(TokenID.OpenBracket,v26996.None,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"[",TypeScript.ErrorRecoverySet.LBrack);setTokenInfo(TokenID.Dot,v26996.None,v14870.Unary,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,".",TypeScript.ErrorRecoverySet.Dot);setTokenInfo(TokenID.EndOfFile,v26996.None,v14870.None,TypeScript.NodeType.None,
v14870.None,TypeScript.NodeType.None,"<EOF>",TypeScript.ErrorRecoverySet.EOF);setTokenInfo(TokenID.EqualsGreaterThan,v26996.None,v14870.None,TypeScript.NodeType.None,v14870.None,TypeScript.NodeType.None,"=>",TypeScript.ErrorRecoverySet.None);TypeScript.lookupToken=lookupToken;v14870=TypeScript.TokenClass;v14870||(v14870=TypeScript.TokenClass={});v867(v14870);var TokenClass=TypeScript.TokenClass,v14870=v868();TypeScript.SavedToken=v14870;var Token=v873();TypeScript.Token=Token;v14870=v876(Token);TypeScript.NumberLiteralToken=
v14870;v14870=v879(Token);TypeScript.StringLiteralToken=v14870;v14870=v882(Token);TypeScript.IdentifierToken=v14870;v14870=v885(Token);TypeScript.WhitespaceToken=v14870;v14870=v888(Token);TypeScript.CommentToken=v14870;v14870=v891(Token);TypeScript.RegularExpressionLiteralToken=v14870;v14870=TypeScript;v26996=[];v14870.staticTokens=v26996;TypeScript.initializeStaticTokens=initializeStaticTokens}
function v862(){var TypeScript=v18812;function v861(_super){function v860(name,publicOnly,typespace){var v6614=_super.prototype.findLocal;if((v6614=JAM.call(v6614.call,v6614,[this,name,publicOnly,typespace]))&&!JAM.call(this.filter,this,[v6614]))return null;v6614=_super.prototype.find;return JAM.call(v6614.call,v6614,[this,name,publicOnly,typespace])}function v859(filter,name,publicOnly,typespace){throw Error("please implement");}function v858(name,publicOnly,typespace){var v6617=_super.prototype.findLocal;
return(name=JAM.call(v6617.call,v6617,[this,name,publicOnly,typespace]))&&!JAM.call(this.filter,this,[name])?null:name}function FilteredSymbolScopeBuilder(valueMembers,parent,container,filter){JAM.call(_super.call,_super,[this,valueMembers,null,null,null,parent,container]);this.filter=filter}JAM.call(__extends,null,[FilteredSymbolScopeBuilder,_super]);FilteredSymbolScopeBuilder.prototype.findLocal=v858;FilteredSymbolScopeBuilder.prototype.search=v859;FilteredSymbolScopeBuilder.prototype.find=v860;
return FilteredSymbolScopeBuilder}function v857(_super){function v856(name,publicOnly,typespace){var v6622=this.scope;return JAM.call(v6622.findLocal,v6622,[name,publicOnly,typespace])}function v855(name,publicOnly,typespace){this.filter.reset();var v6624=this.scope;return JAM.call(v6624.search,v6624,[this.filter,name,publicOnly,typespace])}function v854(outfile){var v6626=this.scope;JAM.call(v6626.print,v6626,[outfile])}function FilteredSymbolScope(scope,container,filter){JAM.call(_super.call,_super,
[this,container]);this.scope=scope;this.filter=filter}JAM.call(__extends,null,[FilteredSymbolScope,_super]);FilteredSymbolScope.prototype.print=v854;FilteredSymbolScope.prototype.find=v855;FilteredSymbolScope.prototype.findLocal=v856;return FilteredSymbolScope}function v853(_super){function v852(){return this.valueMembers.allMembers}function v851(container,ast,symbol,errorReporter,insertAsPublic,typespace,ambient){var table=null;(table=insertAsPublic=ambient?typespace?null==this.ambientEnclosedTypes?
null:insertAsPublic?this.ambientEnclosedTypes.publicMembers:this.ambientEnclosedTypes.privateMembers:null==this.ambientValueMembers?null:insertAsPublic?this.ambientValueMembers.publicMembers:this.ambientValueMembers.privateMembers:typespace?null==this.enclosedTypes?null:insertAsPublic?this.enclosedTypes.publicMembers:this.enclosedTypes.privateMembers:null==this.valueMembers?null:insertAsPublic?this.valueMembers.publicMembers:this.valueMembers.privateMembers)?JAM.call(table.add,table,[symbol.name,
symbol])||JAM.call(errorReporter.duplicateIdentifier,errorReporter,[ast,symbol.name]):(ast=TypeScript.CompilerDiagnostics,JAM.call(ast.Alert,ast,["YYYYY"]));symbol.container=container}function v850(name,publicOnly,typespace){var sym=null,v6638;v6638=null==this.valueMembers?null:publicOnly?this.valueMembers.publicMembers:this.valueMembers.allMembers;var v6639;v6639=null==this.ambientValueMembers?null:publicOnly?this.ambientValueMembers.publicMembers:this.ambientValueMembers.allMembers;typespace&&(v6638=
typespace=null==this.enclosedTypes?null:publicOnly?this.enclosedTypes.publicMembers:this.enclosedTypes.allMembers,v6639=publicOnly=null==this.ambientEnclosedTypes?null:publicOnly?this.ambientEnclosedTypes.publicMembers:this.ambientEnclosedTypes.allMembers);return v6638&&null!=(sym=JAM.call(v6638.lookup,v6638,[name]))&&sym||v6639&&null!=(sym=JAM.call(v6639.lookup,v6639,[name]))&&sym?sym:null}function v849(name,publicOnly,typespace){var sym=null,v6644;v6644=null==this.ambientValueMembers?null:publicOnly?
this.ambientValueMembers.publicMembers:this.ambientValueMembers.allMembers;typespace&&(v6644=null==this.ambientEnclosedTypes?null:publicOnly?this.ambientEnclosedTypes.publicMembers:this.ambientEnclosedTypes.allMembers);var v15229=v6644;v15229&&(v15229=null!=(sym=JAM.call(v6644.lookup,v6644,[name])));return v15229?sym:this.parent?(sym=this.parent,JAM.call(sym.findAmbient,sym,[name,publicOnly,typespace])):null}function v848(name,publicOnly,typespace){var sym=null,v6649;v6649=null==this.valueMembers?
null:publicOnly?this.valueMembers.publicMembers:this.valueMembers.allMembers;var v6650;v6650=null==this.ambientValueMembers?null:publicOnly?this.ambientValueMembers.publicMembers:this.ambientValueMembers.allMembers;typespace&&(v6649=null==this.enclosedTypes?null:publicOnly?this.enclosedTypes.publicMembers:this.enclosedTypes.allMembers,v6650=null==this.ambientEnclosedTypes?null:publicOnly?this.ambientEnclosedTypes.publicMembers:this.ambientEnclosedTypes.allMembers);var v15238=v6650;v15238&&(v15238=
null!=(sym=JAM.call(v6650.lookup,v6650,[name])));if(v15238)return sym;(v6650=v6649)&&(v6650=null!=(sym=JAM.call(v6649.lookup,v6649,[name])));return v6650?sym:this.parent?(sym=this.parent,JAM.call(sym.find,sym,[name,publicOnly,typespace])):null}function v847(outfile){function v846(key,s,context){JAM.call(outfile.WriteLine,outfile,["  "+key])}function v845(key,s,context){JAM.call(outfile.WriteLine,outfile,["  "+key])}function v844(key,s,context){JAM.call(outfile.WriteLine,outfile,["  "+key])}function v843(key,
s,context){JAM.call(outfile.WriteLine,outfile,["  "+key])}var v6661=_super.prototype.print;JAM.call(v6661.call,v6661,[this,outfile]);this.ambientValueMembers&&(v6661=this.ambientValueMembers.allMembers,JAM.call(v6661.map,v6661,[v843,null]));this.valueMembers&&(v6661=this.valueMembers.allMembers,JAM.call(v6661.map,v6661,[v844,null]));this.ambientEnclosedTypes&&(v6661=this.ambientEnclosedTypes.allMembers,JAM.call(v6661.map,v6661,[v845,null]));this.enclosedTypes&&(v6661=this.enclosedTypes.allMembers,
JAM.call(v6661.map,v6661,[v846,null]));this.parent&&(v6661=this.parent,JAM.call(v6661.print,v6661,[outfile]))}function v842(filter,name,publicOnly,typespace){var sym=null,v6672;v6672=null==this.valueMembers?null:publicOnly?this.valueMembers.publicMembers:this.valueMembers.allMembers;var v6673;v6673=null==this.ambientValueMembers?null:publicOnly?this.ambientValueMembers.publicMembers:this.ambientValueMembers.allMembers;typespace&&(v6672=null==this.enclosedTypes?null:publicOnly?this.enclosedTypes.publicMembers:
this.enclosedTypes.allMembers,v6673=null==this.ambientEnclosedTypes?null:publicOnly?this.ambientEnclosedTypes.publicMembers:this.ambientEnclosedTypes.allMembers);return v6673&&null!=(sym=JAM.call(v6673.lookup,v6673,[name]))&&JAM.call(filter.update,filter,[sym])||v6672&&null!=(sym=JAM.call(v6672.lookup,v6672,[name]))&&JAM.call(filter.update,filter,[sym])||this.parent&&(sym=this.parent,(sym=JAM.call(sym.search,sym,[filter,name,publicOnly,typespace]))&&JAM.call(filter.update,filter,[sym]))?sym:filter.result}
function v841(members){var result=[];this.ambientValueMembers&&(result=result.concat(this.ambientValueMembers.allMembers.getAllKeys()));this.valueMembers&&(result=result.concat(this.valueMembers.allMembers.getAllKeys()));var v15257=!members;v15257&&(v15257=this.parent);v15257&&(v15257=this.parent,(members=JAM.call(v15257.getAllValueSymbolNames,v15257,[members]))&&(result=result.concat(members)));return result}function v840(members){var result=[];this.ambientEnclosedTypes&&(result=result.concat(this.ambientEnclosedTypes.allMembers.getAllKeys()));
this.enclosedTypes&&(result=result.concat(this.enclosedTypes.allMembers.getAllKeys()));var v15260=!members;v15260&&(v15260=this.parent);v15260&&(v15260=this.parent,(members=JAM.call(v15260.getAllTypeSymbolNames,v15260,[members]))&&(result=result.concat(members)));return result}function v839(members){var result=JAM.call(this.getAllTypeSymbolNames,this,[members]);return result.concat(JAM.call(this.getAllValueSymbolNames,this,[members]))}function v838(){return"builder"}function SymbolScopeBuilder(valueMembers,
ambientValueMembers,enclosedTypes,ambientEnclosedTypes,parent,container){JAM.call(_super.call,_super,[this,container]);this.valueMembers=valueMembers;this.ambientValueMembers=ambientValueMembers;this.enclosedTypes=enclosedTypes;this.ambientEnclosedTypes=ambientEnclosedTypes;this.parent=parent;this.container=container}JAM.call(__extends,null,[SymbolScopeBuilder,_super]);SymbolScopeBuilder.prototype.printLabel=v838;SymbolScopeBuilder.prototype.getAllSymbolNames=v839;SymbolScopeBuilder.prototype.getAllTypeSymbolNames=
v840;SymbolScopeBuilder.prototype.getAllValueSymbolNames=v841;SymbolScopeBuilder.prototype.search=v842;SymbolScopeBuilder.prototype.print=v847;SymbolScopeBuilder.prototype.find=v848;SymbolScopeBuilder.prototype.findAmbient=v849;SymbolScopeBuilder.prototype.findLocal=v850;SymbolScopeBuilder.prototype.enter=v851;SymbolScopeBuilder.prototype.getTable=v852;return SymbolScopeBuilder}function v837(_super){function v836(){return this.valueMembers.publicMembers}function v835(name,publicOnly,typespace){if(name=
JAM.call(this.find,this,[name,publicOnly,typespace]))name.kind()==SymbolKind.Type?(publicOnly=name,publicOnly.type.hasImplementation()||(name=null)):name.container&&name.container.kind()==SymbolKind.Type&&(publicOnly=name.container,publicOnly.type.hasImplementation()||(name=null));return name}function v834(outfile){function v833(key,sym,context){JAM.call(outfile.WriteLine,outfile,["  "+key])}function v832(key,sym,context){JAM.call(outfile.WriteLine,outfile,["  "+key])}function v831(key,sym,context){JAM.call(outfile.WriteLine,
outfile,["  "+key])}function v830(key,sym,context){JAM.call(outfile.WriteLine,outfile,["  "+key])}var v6717=_super.prototype.print;JAM.call(v6717.call,v6717,[this,outfile]);this.ambientValueMembers&&(v6717=this.ambientValueMembers.allMembers,JAM.call(v6717.map,v6717,[v830,null]));this.valueMembers&&(v6717=this.valueMembers.allMembers,JAM.call(v6717.map,v6717,[v831,null]));this.ambientEnclosedTypes&&(v6717=this.ambientEnclosedTypes.allMembers,JAM.call(v6717.map,v6717,[v832,null]));this.enclosedTypes&&
(v6717=this.enclosedTypes.allMembers,JAM.call(v6717.map,v6717,[v833,null]))}function v829(name,publicOnly,typespace){var v6726;v6726=null==this.ambientValueMembers?null:publicOnly?this.ambientValueMembers.publicMembers:this.ambientValueMembers.allMembers;typespace&&(v6726=publicOnly=null==this.ambientEnclosedTypes?null:publicOnly?this.ambientEnclosedTypes.publicMembers:this.ambientEnclosedTypes.allMembers);return v6726&&(name=JAM.call(v6726.lookup,v6726,[name]))?name:null}function v828(name,publicOnly,
typespace){var table=null,ambientTable=null;typespace?(table=null==this.enclosedTypes?null:publicOnly?this.enclosedTypes.publicMembers:this.enclosedTypes.allMembers,publicOnly=null==this.ambientEnclosedTypes?null:publicOnly?this.ambientEnclosedTypes.publicMembers:this.ambientEnclosedTypes.allMembers):(table=null==this.valueMembers?null:publicOnly?this.valueMembers.publicMembers:this.valueMembers.allMembers,publicOnly=null==this.ambientValueMembers?null:publicOnly?this.ambientValueMembers.publicMembers:
this.ambientValueMembers.allMembers);if(ambientTable=publicOnly)if(publicOnly=JAM.call(ambientTable.lookup,ambientTable,[name]))return publicOnly;return table&&(publicOnly=JAM.call(table.lookup,table,[name]))?publicOnly:null}function v827(filter,name,publicOnly,typespace){name=JAM.call(this.find,this,[name,publicOnly,typespace]);JAM.call(filter.update,filter,[name]);return filter.result}function v826(members){members=[];this.ambientValueMembers&&(members=members.concat(this.ambientValueMembers.allMembers.getAllKeys()));
this.valueMembers&&(members=members.concat(this.valueMembers.allMembers.getAllKeys()));return members}function v825(members){members=[];this.ambientEnclosedTypes&&(members=members.concat(this.ambientEnclosedTypes.allMembers.getAllKeys()));this.enclosedTypes&&(members=members.concat(this.enclosedTypes.allMembers.getAllKeys()));return members}function v824(members){var result=JAM.call(this.getAllTypeSymbolNames,this,[members]);return result.concat(JAM.call(this.getAllValueSymbolNames,this,[members]))}
function v823(){return"table"}function SymbolTableScope(valueMembers,ambientValueMembers,enclosedTypes,ambientEnclosedTypes,container){JAM.call(_super.call,_super,[this,container]);this.valueMembers=valueMembers;this.ambientValueMembers=ambientValueMembers;this.enclosedTypes=enclosedTypes;this.ambientEnclosedTypes=ambientEnclosedTypes;this.container=container}JAM.call(__extends,null,[SymbolTableScope,_super]);SymbolTableScope.prototype.printLabel=v823;SymbolTableScope.prototype.getAllSymbolNames=
v824;SymbolTableScope.prototype.getAllTypeSymbolNames=v825;SymbolTableScope.prototype.getAllValueSymbolNames=v826;SymbolTableScope.prototype.search=v827;SymbolTableScope.prototype.find=v828;SymbolTableScope.prototype.findAmbient=v829;SymbolTableScope.prototype.print=v834;SymbolTableScope.prototype.findImplementation=v835;SymbolTableScope.prototype.getTable=v836;return SymbolTableScope}function v822(_super){function v821(parent){if(null==this.parents){var v27001=[];this.parents=v27001}JAM.set(this.parents,
this.parents.length,parent)}function v820(name,publicOnly,typespace){var sym=null,i=0,cache=this.valueAmbientCache;typespace&&(cache=this.typeAmbientCache);(i=cache)&&(i=null!=(sym=JAM.call(cache.lookup,cache,[name])));if(i)return sym;if(this.parents)for(var i=0,v6756=i<this.parents.length;v6756;){sym=this.parents;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)sym=sym[i];if(sym=JAM.call(sym.findAmbient,sym,[name,publicOnly,typespace]))break;i+=1;v6756=i<this.parents.length}null==
cache&&(cache=typespace?this.typeAmbientCache=publicOnly=new TypeScript.StringHashTable:this.valueAmbientCache=publicOnly=new TypeScript.StringHashTable);JAM.call(cache.add,cache,[name,sym]);return sym}function v819(name,publicOnly,typespace){var sym=null,i=0,cache=this.valueCache;typespace&&(cache=this.typeCache);if(i=cache)if(i=null!=(sym=JAM.call(cache.lookup,cache,[name])))publicOnly?(i=JAM.call(TypeScript.hasFlag,TypeScript,[sym.flags,TypeScript.SymbolFlags.Private]),i||(i=sym.declAST)&&(i=sym.declAST.nodeType==
TypeScript.NodeType.FuncDecl)&&(i=JAM.call(TypeScript.hasFlag,TypeScript,[sym.declAST.fncFlags,TypeScript.FncFlags.Private])),i=!i):i=!0;if(i)return sym;if(this.parents)for(var i=0,v6763=i<this.parents.length;v6763;){sym=this.parents;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)sym=sym[i];if(sym=JAM.call(sym.find,sym,[name,publicOnly,typespace]))break;i+=1;v6763=i<this.parents.length}null==cache&&(cache=typespace?this.typeCache=publicOnly=new TypeScript.StringHashTable:this.valueCache=
publicOnly=new TypeScript.StringHashTable);JAM.call(cache.add,cache,[name,sym]);return sym}function v818(name,publicOnly,typespace){var sym=null,i=0,implCache=this.valueImplCache;typespace&&(implCache=this.typeImplCache);if(i=implCache)if(i=null!=(sym=JAM.call(implCache.lookup,implCache,[name])))publicOnly?(i=JAM.call(TypeScript.hasFlag,TypeScript,[sym.flags,TypeScript.SymbolFlags.Private]),i||(i=sym.declAST)&&(i=sym.declAST.nodeType==TypeScript.NodeType.FuncDecl)&&(i=JAM.call(TypeScript.hasFlag,
TypeScript,[sym.declAST.fncFlags,TypeScript.FncFlags.Private])),i=!i):i=!0;if(i)return sym;if(this.parents)for(var i=0,v6770=i<this.parents.length;v6770;){sym=this.parents;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)sym=sym[i];if(sym=JAM.call(sym.findImplementation,sym,[name,publicOnly,typespace]))break;i+=1;v6770=i<this.parents.length}implCache&&(implCache=typespace?this.typeImplCache=publicOnly=new TypeScript.StringHashTable:this.valueImplCache=publicOnly=new TypeScript.StringHashTable);
JAM.call(implCache.add,implCache,[name,sym]);return sym}function v817(outfile){var v6774=_super.prototype.print;JAM.call(v6774.call,v6774,[this,outfile]);if(this.parents)for(var v6774=0,v6776=v6774<this.parents.length;v6776;){v6776=this.parents;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v6776=v6776[v6774];JAM.call(v6776.print,v6776,[outfile]);v6774+=1;v6776=v6774<this.parents.length}}function v816(members){var result=[];if(this.parents)for(var i=0,v6779=i<this.parents.length;v6779;){v6779=
this.parents;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v6779=v6779[i];(v6779=JAM.call(v6779.getAllValueSymbolNames,v6779,[members]))&&(result=result.concat(v6779));i+=1;v6779=i<this.parents.length}return result}function v815(members){var result=[];if(this.parents)for(var i=0,v6782=i<this.parents.length;v6782;){v6782=this.parents;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v6782=v6782[i];(v6782=JAM.call(v6782.getAllTypeSymbolNames,v6782,[members]))&&(result=
result.concat(v6782));i+=1;v6782=i<this.parents.length}return result}function v814(members){var result=[];if(this.parents)for(var i=0,v6785=i<this.parents.length;v6785;){v6785=this.parents;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v6785=v6785[i];(v6785=JAM.call(v6785.getAllSymbolNames,v6785,[members]))&&(result=result.concat(v6785));i+=1;v6785=i<this.parents.length}return result}function v813(filter,name,publicOnly,typespace){if(this.parents)for(var i=0,v6789=i<this.parents.length;v6789;){v6789=
this.parents;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v6789=v6789[i];if((v6789=JAM.call(v6789.search,v6789,[filter,name,publicOnly,typespace]))&&JAM.call(filter.update,filter,[v6789]))return v6789;i+=1;v6789=i<this.parents.length}return filter.result}function v812(){return"agg"}function SymbolAggregateScope(container){JAM.call(_super.call,_super,[this,container]);this.parents=this.typeAmbientCache=this.typeImplCache=this.typeCache=this.valueAmbientCache=this.valueImplCache=
this.valueCache=null;this.container=container}JAM.call(__extends,null,[SymbolAggregateScope,_super]);SymbolAggregateScope.prototype.printLabel=v812;SymbolAggregateScope.prototype.search=v813;SymbolAggregateScope.prototype.getAllSymbolNames=v814;SymbolAggregateScope.prototype.getAllTypeSymbolNames=v815;SymbolAggregateScope.prototype.getAllValueSymbolNames=v816;SymbolAggregateScope.prototype.print=v817;SymbolAggregateScope.prototype.findImplementation=v818;SymbolAggregateScope.prototype.find=v819;SymbolAggregateScope.prototype.findAmbient=
v820;SymbolAggregateScope.prototype.addParentScope=v821;return SymbolAggregateScope}function v811(){function v810(){throw Error("please implement in derived class");}function v809(container,ast,symbol,errorReporter,publicOnly,typespace,ambient){throw Error("please implement in derived class");}function v808(outfile){this.container?JAM.call(outfile.WriteLine,outfile,[this.printLabel()+" scope with container: "+this.container.name+"..."]):JAM.call(outfile.WriteLine,outfile,[this.printLabel()+" scope..."])}
function v807(name,publicOnly,typespace){return null}function v806(name,publicOnly,typespace){return null}function v805(name,publicOnly,typespace){return null}function v804(name,publicOnly,typespace){return null}function v803(filter,name,publicOnly,typespace){return null}function v802(members){return["please","implement","in","derived","classes"]}function v801(members){return["please","implement","in","derived","classes"]}function v800(members){return["please","implement","in","derived","classes"]}
function v799(){return"base"}function SymbolScope(container){this.container=container}SymbolScope.prototype.printLabel=v799;SymbolScope.prototype.getAllSymbolNames=v800;SymbolScope.prototype.getAllTypeSymbolNames=v801;SymbolScope.prototype.getAllValueSymbolNames=v802;SymbolScope.prototype.search=v803;SymbolScope.prototype.findLocal=v804;SymbolScope.prototype.find=v805;SymbolScope.prototype.findImplementation=v806;SymbolScope.prototype.findAmbient=v807;SymbolScope.prototype.print=v808;SymbolScope.prototype.enter=
v809;SymbolScope.prototype.getTable=v810;return SymbolScope}function v798(SymbolKind){SymbolKind._map=[];SymbolKind._map[0]="None";SymbolKind.None=0;SymbolKind._map[1]="Type";SymbolKind.Type=1;SymbolKind._map[2]="Field";SymbolKind.Field=2;SymbolKind._map[3]="Parameter";SymbolKind.Parameter=3;SymbolKind._map[4]="Variable";SymbolKind.Variable=4}function v797(){function v796(key,data){var v6821=this.dualMembers.secondaryTable;return JAM.call(v6821.add,v6821,[key,data])}function v795(key,data){var v6822=
this.dualMembers.primaryTable;return JAM.call(v6822.add,v6822,[key,data])}function ScopedMembers(dualMembers){this.allMembers=this.dualMembers=dualMembers;this.publicMembers=this.dualMembers.primaryTable;this.privateMembers=this.dualMembers.secondaryTable}ScopedMembers.prototype.addPublicMember=v795;ScopedMembers.prototype.addPrivateMember=v796;return ScopedMembers}var ScopedMembers=v797();TypeScript.ScopedMembers=ScopedMembers;ScopedMembers=TypeScript.SymbolKind;ScopedMembers||(ScopedMembers=TypeScript.SymbolKind=
{});v798(ScopedMembers);var SymbolKind=TypeScript.SymbolKind,ScopedMembers=v811();TypeScript.SymbolScope=ScopedMembers;var SymbolAggregateScope=v822(ScopedMembers);TypeScript.SymbolAggregateScope=SymbolAggregateScope;SymbolAggregateScope=v837(ScopedMembers);TypeScript.SymbolTableScope=SymbolAggregateScope;SymbolAggregateScope=v853(ScopedMembers);TypeScript.SymbolScopeBuilder=SymbolAggregateScope;ScopedMembers=v857(ScopedMembers);TypeScript.FilteredSymbolScope=ScopedMembers;ScopedMembers=v861(SymbolAggregateScope);
TypeScript.FilteredSymbolScopeBuilder=ScopedMembers}
function v794(){var TypeScript=v18811;function v793(_super){function v792(){return!0}function v791(type){this.variable.typeLink.type=type}function v790(scope){var v6829=TypeScript.MemberName,v15324=this.getType();return JAM.call(v6829.create,v6829,[JAM.call(v15324.getScopedTypeNameEx,v15324,[scope]),this.name+": ",""])}function v789(){return this.variable.typeLink.type}function v788(){return!0}function v787(){return TypeScript.SymbolKind.Variable}function VariableSymbol(name,location,unitIndex,variable){JAM.call(_super.call,
_super,[this,name,location,name.length,unitIndex]);this.variable=variable}JAM.call(__extends,null,[VariableSymbol,_super]);VariableSymbol.prototype.kind=v787;VariableSymbol.prototype.writeable=v788;VariableSymbol.prototype.getType=v789;VariableSymbol.prototype.getTypeNameEx=v790;VariableSymbol.prototype.setType=v791;VariableSymbol.prototype.isVariable=v792;return VariableSymbol}function v786(_super){function v785(){if(!this.paramDocComment){var parameterComments=[];if(this.funcDecl){var fncDocComments=
this.funcDecl.getDocComments(),v6842=TypeScript.Comment,fncDocComments=JAM.call(v6842.getParameterDocCommentText,v6842,[this.name,fncDocComments]);""!=fncDocComments&&JAM.call(parameterComments.push,parameterComments,[fncDocComments])}fncDocComments=TypeScript.Comment;fncDocComments=JAM.call(fncDocComments.getDocCommentText,fncDocComments,[this.getDocComments()]);""!=fncDocComments&&JAM.call(parameterComments.push,parameterComments,[fncDocComments]);this.paramDocComment=parameterComments=parameterComments.join("\n")}return this.paramDocComment}
function v784(pattern,replacement,checker){var v6850=this.parameter.typeLink.type;pattern=JAM.call(v6850.specializeType,v6850,[pattern,replacement,checker,!1]);return this.parameter.typeLink.type!=pattern?(replacement=new ValueLocation,checker=new ParameterSymbol(this.name,0,checker.locationInfo.unitIndex,replacement),replacement.symbol=checker,JAM.call(checker.setType,checker,[pattern]),checker):this}function v783(){return JAM.call(this.getTypeNameEx,this,[null]).toString()}function v782(scope){var v6855=
TypeScript.MemberName,v15331=this.getType();scope=JAM.call(v15331.getScopedTypeNameEx,v15331,[scope]);var v15331=this.name,v23582;v23582=this.isOptional()?"?":"";return JAM.call(v6855.create,v6855,[scope,v15331+v23582+": ",""])}function v781(){var v15333=this.parameter;v15333&&(v15333=this.parameter.symbol)&&(v15333=this.parameter.symbol.declAST);return v15333?this.parameter.symbol.declAST.isOptional:!1}function v780(){return!0}function v779(type){this.parameter.typeLink.type=type}function v778(){return this.parameter.typeLink.type}
function v777(){return!0}function v776(){return TypeScript.SymbolKind.Parameter}function ParameterSymbol(name,location,unitIndex,parameter){JAM.call(_super.call,_super,[this,name,location,name.length,unitIndex]);this.parameter=parameter;this.funcDecl=this.paramDocComment=null;this.argsOffset=-1;this.name=name;this.location=location}JAM.call(__extends,null,[ParameterSymbol,_super]);ParameterSymbol.prototype.kind=v776;ParameterSymbol.prototype.writeable=v777;ParameterSymbol.prototype.getType=v778;ParameterSymbol.prototype.setType=
v779;ParameterSymbol.prototype.isVariable=v780;ParameterSymbol.prototype.isOptional=v781;ParameterSymbol.prototype.getTypeNameEx=v782;ParameterSymbol.prototype.toString=v783;ParameterSymbol.prototype.specializeType=v784;ParameterSymbol.prototype.getParameterDocComments=v785;return ParameterSymbol}function v775(_super){function v774(){var v15337=null!=this.getter;v15337||(v15337=null!=this.setter);return v15337?(v15337=[],null!=this.getter&&(v15337=v15337.concat(this.getter.getDocComments())),null!=
this.setter&&(v15337=v15337.concat(this.setter.getDocComments())),v15337):null!=this.declAST?this.declAST.getDocComments():[]}function v773(pattern,replacement,checker){var v6881=this.field.typeLink.type;pattern=JAM.call(v6881.specializeType,v6881,[pattern,replacement,checker,!1]);return pattern!=this.field.typeLink.type?(replacement=new ValueLocation,checker=new FieldSymbol(this.name,0,checker.locationInfo.unitIndex,this.canWrite,replacement),checker.flags=this.flags,replacement.symbol=checker,v6881=
new TypeScript.TypeLink,replacement.typeLink=v6881,JAM.call(checker.setType,checker,[pattern]),checker.typeCheckStatus=TypeCheckStatus.Finished,checker):this}function v772(){return JAM.call(this.getTypeNameEx,this,[null]).toString()}function v771(){return!0}function v770(){var v6888=null!=this.getter;v6888||(v6888=null!=this.setter);return v6888}function v769(type){this.field.typeLink.type=type}function v768(){return!0}function v767(scope){var v6890=TypeScript.MemberName,v15351=this.field.typeLink.type;
return JAM.call(v6890.create,v6890,[JAM.call(v15351.getScopedTypeNameEx,v15351,[scope]),this.name+this.getOptionalNameString()+": ",""])}function v766(){return this.field.typeLink.type}function v765(){var v6894;return v6894=this.isAccessor()?null!=this.setter:this.canWrite}function v764(){return TypeScript.SymbolKind.Field}function FieldSymbol(name,location,unitIndex,canWrite,field){JAM.call(_super.call,_super,[this,name,location,name.length,unitIndex]);this.canWrite=canWrite;this.field=field;this.setter=
this.getter=null;this.hasBeenEmitted=!1;this.name=name;this.location=location}JAM.call(__extends,null,[FieldSymbol,_super]);FieldSymbol.prototype.kind=v764;FieldSymbol.prototype.writeable=v765;FieldSymbol.prototype.getType=v766;FieldSymbol.prototype.getTypeNameEx=v767;FieldSymbol.prototype.isMember=v768;FieldSymbol.prototype.setType=v769;FieldSymbol.prototype.isAccessor=v770;FieldSymbol.prototype.isVariable=v771;FieldSymbol.prototype.toString=v772;FieldSymbol.prototype.specializeType=v773;FieldSymbol.prototype.getDocComments=
v774;return FieldSymbol}function v763(_super){function v762(){return!0}function WithSymbol(location,unitIndex,withType){JAM.call(_super.call,_super,[this,"with",location,4,unitIndex,withType])}JAM.call(__extends,null,[WithSymbol,_super]);WithSymbol.prototype.isWith=v762;return WithSymbol}function v761(_super){function v760(){var comments=[];null!=this.declAST&&(comments=comments.concat(this.declAST.getDocComments()));for(var i=0,v6912=i<this.expansionsDeclAST.length;v6912;){v6912=this.expansionsDeclAST;
introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v6912=v6912[i];comments=comments.concat(v6912.getDocComments());i+=1;v6912=i<this.expansionsDeclAST.length}return comments}function v759(scopeSymbolPath){var scopeSymbolPathLength=scopeSymbolPath.length,externalSymbol=null,v15361=0<scopeSymbolPath.length;if(v15361){v15361=scopeSymbolPathLength-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v15361=scopeSymbolPath[v15361];if(v15361=v15361.getType().isModuleType()){v15361=
scopeSymbolPathLength-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v15361=scopeSymbolPath[v15361];v15361=v15361.isDynamic}}if(v15361){if(v15361=1<scopeSymbolPathLength){v15361=scopeSymbolPathLength-2;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v15361=scopeSymbolPath[v15361];if(v15361=v15361.getType().isModuleType()){v15361=scopeSymbolPathLength-2;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v15361=scopeSymbolPath[v15361];v15361=v15361.isDynamic}}if(v15361){externalSymbol=
scopeSymbolPathLength-2;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)externalSymbol=scopeSymbolPath[externalSymbol];externalSymbol=externalSymbol.getType();externalSymbol=JAM.call(externalSymbol.findDynamicModuleName,externalSymbol,[this.type])}if(null==externalSymbol){scopeSymbolPathLength-=1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)scopeSymbolPath=scopeSymbolPath[scopeSymbolPathLength];externalSymbol=scopeSymbolPath.getType();externalSymbol=JAM.call(externalSymbol.findDynamicModuleName,
externalSymbol,[this.type])}}return externalSymbol}function v758(scopeSymbol){var v15365=!!scopeSymbol;v15365&&(v15365=JAM.call(TypeScript.isQuoted,TypeScript,[this.prettyName]))&&(v15365=this.type.isModuleType());return v15365&&(scopeSymbol=scopeSymbol.pathToRoot(),scopeSymbol=JAM.call(this.getPrettyNameOfDynamicModule,this,[scopeSymbol]),null!=scopeSymbol)?scopeSymbol.name:this.prettyName}function v757(pattern,replacement,checker){if(this.type==pattern)return replacement.symbol;var v6922=this.type;
pattern=JAM.call(v6922.specializeType,v6922,[pattern,replacement,checker,!1]);return pattern!=this.type?pattern=new TypeSymbol(this.name,-1,0,-1,pattern):this}function v756(){var v6926=null!=this.declAST;v6926&&(v6926=this.declAST.nodeType==TypeScript.NodeType.FuncDecl);return v6926}function v755(){return null!=this.instanceType}function v754(){var result=this.type.getTypeName();this.name&&(result=this.name+":"+result);return result}function v753(){var v15372=!(this.type.typeFlags&TypeScript.TypeFlags.IsClass);
v15372&&(v15372=this.type.isClass());return v15372?this.type.instanceType.constructorScope:this.type.containedScope}function v752(scope){var v6934=this.type,v15374;v15374=this.name?this.name+this.getOptionalNameString():"";return JAM.call(v6934.getMemberTypeNameEx,v6934,[v15374,!1,!1,scope])}function v751(){return this.type}function v750(){return!0}function v749(){return TypeScript.SymbolKind.Type}function v748(loc){null==this.additionalLocations&&(this.additionalLocations=[]);JAM.set(this.additionalLocations,
this.additionalLocations.length,loc)}function TypeSymbol(locName,location,length,unitIndex,type){JAM.call(_super.call,_super,[this,locName,location,length,unitIndex]);this.type=type;this.expansions=[];this.expansionsDeclAST=[];this.isMethod=this.isDynamic=!1;this.aliasLink=null;this.onlyReferencedAsTypeRef=TypeScript.optimizeModuleCodeGen;this.prettyName=this.name}JAM.call(__extends,null,[TypeSymbol,_super]);TypeSymbol.prototype.addLocation=v748;TypeSymbol.prototype.kind=v749;TypeSymbol.prototype.isType=
v750;TypeSymbol.prototype.getType=v751;TypeSymbol.prototype.getTypeNameEx=v752;TypeSymbol.prototype.instanceScope=v753;TypeSymbol.prototype.toString=v754;TypeSymbol.prototype.isClass=v755;TypeSymbol.prototype.isFunction=v756;TypeSymbol.prototype.specializeType=v757;TypeSymbol.prototype.getPrettyName=v758;TypeSymbol.prototype.getPrettyNameOfDynamicModule=v759;TypeSymbol.prototype.getDocComments=v760;return TypeSymbol}function v747(_super){function v746(varFlags){JAM.call(TypeScript.hasFlag,TypeScript,
[varFlags,TypeScript.VarFlags.Ambient])&&(this.flags|=TypeScript.SymbolFlags.Ambient);JAM.call(TypeScript.hasFlag,TypeScript,[varFlags,TypeScript.VarFlags.Constant])&&(this.flags|=TypeScript.SymbolFlags.Constant);JAM.call(TypeScript.hasFlag,TypeScript,[varFlags,TypeScript.VarFlags.Static])&&(this.flags|=TypeScript.SymbolFlags.Static);JAM.call(TypeScript.hasFlag,TypeScript,[varFlags,TypeScript.VarFlags.Property])&&(this.flags|=TypeScript.SymbolFlags.Property);JAM.call(TypeScript.hasFlag,TypeScript,
[varFlags,TypeScript.VarFlags.Private])&&(this.flags|=TypeScript.SymbolFlags.Private);JAM.call(TypeScript.hasFlag,TypeScript,[varFlags,TypeScript.VarFlags.Public])&&(this.flags|=TypeScript.SymbolFlags.Public);JAM.call(TypeScript.hasFlag,TypeScript,[varFlags,TypeScript.VarFlags.Readonly])&&(this.flags|=TypeScript.SymbolFlags.Readonly);JAM.call(TypeScript.hasFlag,TypeScript,[varFlags,TypeScript.VarFlags.Exported])&&(this.flags|=TypeScript.SymbolFlags.Exported)}function v745(){return!0}function InferenceSymbol(name,
location,length,unitIndex){JAM.call(_super.call,_super,[this,name,location,length,unitIndex]);this.typeCheckStatus=TypeCheckStatus.NotStarted}JAM.call(__extends,null,[InferenceSymbol,_super]);InferenceSymbol.prototype.isInferenceSymbol=v745;InferenceSymbol.prototype.transferVarFlags=v746;return InferenceSymbol}function v744(){function ValueLocation(){}return ValueLocation}function v743(){function v742(){return JAM.call(TypeScript.hasFlag,TypeScript,[this.flags,TypeScript.SymbolFlags.Static])}function v741(){return null!=
this.declAST?this.declAST.getDocComments():[]}function v740(){var v15403=null!=this.declAST;v15403&&(v15403=this.declAST.nodeType==TypeScript.NodeType.VarDecl);return v15403?this.declAST:null}function v739(checker){if(null!=this.declAST){if(this.declAST.nodeType==TypeScript.NodeType.InterfaceDeclaration)return this.declAST;var v15407=null!=this.container;v15407&&((checker=this.container!=checker.gloMod)&&(checker=this.container.declAST.nodeType==TypeScript.NodeType.InterfaceDeclaration),v15407=checker);
if(v15407)return this.container.declAST}return null}function v738(){throw Error("please implement in derived class");}function v737(type){throw Error("please implement in derived class");}function v736(pattern,replacement,checker){throw Error("please implement in derived class");}function v735(outfile){JAM.call(outfile.Write,outfile,[this.toString()])}function v734(){return this.name?this.name:"_anonymous"}function v733(identifier){this.refs||(this.refs=[]);JAM.set(this.refs,this.refs.length,identifier)}
function v732(scope,checker){var v15410=null==checker;v15410||(v15410=this.container==checker.gloMod);if(v15410)return!0;if(JAM.call(TypeScript.hasFlag,TypeScript,[this.flags,TypeScript.SymbolFlags.ModuleMember])){if(JAM.call(TypeScript.hasFlag,TypeScript,[this.flags,TypeScript.SymbolFlags.Exported]))return JAM.call(TypeScript.hasFlag,TypeScript,[this.flags,TypeScript.SymbolFlags.Private])?aEnclosesB(this,scope.container):!0;(v15410=checker)&&(v15410=checker.currentModDecl==this.declModule);v15410||
(v15410=checker.currentModDecl)&&(v15410=checker.currentModDecl.mod)&&(v15410=checker.currentModDecl.mod.symbol)&&(v15410=this.declModule)&&(v15410=this.declModule.mod)&&(v15410=this.declModule.mod.symbol)&&(v15410=aEnclosesB(checker.currentModDecl.mod.symbol,this.declModule.mod.symbol));return v15410}(v15410=this.declAST)&&(v15410=this.declAST.nodeType==TypeScript.NodeType.FuncDecl);var isFunction=v15410;(v15410=isFunction)&&(v15410=this.declAST.isMethod());isFunction&&(isFunction=JAM.call(TypeScript.hasFlag,
TypeScript,[this.declAST.fncFlags,TypeScript.FncFlags.Static]));var v6985=v15410;v6985&&(v6985=JAM.call(TypeScript.hasFlag,TypeScript,[this.declAST.fncFlags,TypeScript.FncFlags.Private]));var v6986=this.isType();v6986&&(v6986=this.aliasLink);var v15426=this.isMember();v15426||(v15410||(v15410=isFunction||v6986),v15426=v15410);return v15426?((v15410=JAM.call(TypeScript.hasFlag,TypeScript,[this.flags,TypeScript.SymbolFlags.Private]))||(v15410=v6985),v15410?((v15410=null==scope.container)&&(v15410=this.container!=
scope.container),v15410?!1:v15410=null==this.container?!0:aEnclosesB(scope.container,this.container)):!0):this.container?aEnclosesB(this,scope.container):!0}function v731(checker){if(this==checker.gloMod)return!0;if(JAM.call(TypeScript.hasFlag,TypeScript,[this.flags,TypeScript.SymbolFlags.Private]))return!1;if(!JAM.call(TypeScript.hasFlag,TypeScript,[this.flags,TypeScript.SymbolFlags.Exported]))return this.container==checker.gloMod;var v6999=this.container;return JAM.call(v6999.isExternallyVisible,
v6999,[checker])}function v730(){var builder=this.name,ancestor=this.container,v15436=ancestor;for(v15436&&(v15436=ancestor.name!=TypeScript.globalId);v15436;)builder=ancestor.name+"."+builder,(v15436=ancestor=ancestor.container)&&(v15436=ancestor.name!=TypeScript.globalId);return builder}function v729(scope){if(null==scope)return JAM.call(this.getPrettyName,this,[null])+this.getOptionalNameString();for(var lca=JAM.call(this.findCommonAncestorPath,this,[scope.container]),builder="",i=0,len=lca.length,
v7009=i<len;v7009;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v7009=lca[i];var v15439;v15439=i==len-1?scope.container:lca[i+1];v7009=JAM.call(v7009.getPrettyName,v7009,[v15439]);builder=v7009+"."+builder;i+=1;v7009=i<len}scope=0==len?scope.container:lca[0];return builder+=JAM.call(this.getPrettyName,this,[scope])+this.getOptionalNameString()}function v728(scopeSymbol){return this.name}function v727(b){if(null==this.container)return[];var aPath=this.container.pathToRoot();b=b?
b.pathToRoot():[];for(var commonNodeIndex=-1,i=0,aLen=aPath.length,v7015=i<aLen;v7015;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v7015=aPath[i];for(var j=0,bLen=b.length,v7013=j<bLen;v7013;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v7013=b[j];if(v7015==v7013){commonNodeIndex=i;break}j+=1;v7013=j<bLen}if(0<=commonNodeIndex)break;i+=1;v7015=i<aLen}return 0<=commonNodeIndex?aPath.slice(0,commonNodeIndex):aPath}function v726(){var path=[],node=this,v15443=
node;for(v15443&&(v15443=node.name!=TypeScript.globalId);v15443;)path[path.length]=node,(v15443=node=node.container)&&(v15443=node.name!=TypeScript.globalId);return path}function v725(){var v7019;return v7019=JAM.call(TypeScript.hasFlag,TypeScript,[this.flags,TypeScript.SymbolFlags.Optional])?"?":""}function v724(scope){scope=TypeScript.MemberName;return JAM.call(scope.create,scope,[this.toString()])}function v723(scope){return JAM.call(this.getTypeNameEx,this,[scope]).toString()}function v722(){var v7023=
JAM.call(TypeScript.hasFlag,TypeScript,[this.flags,TypeScript.SymbolFlags.Property]);v7023&&(v7023=!JAM.call(TypeScript.hasFlag,TypeScript,[this.flags,TypeScript.SymbolFlags.ModuleMember]));return v7023}function v721(){return!1}function v720(){return null}function v719(){return!1}function v718(){return!1}function v717(){return!1}function v716(){return!1}function v715(){return!1}function v714(){return!1}function v713(){return null}function Symbol(name,location,length,unitIndex){this.name=name;this.location=
location;this.length=length;this.unitIndex=unitIndex;this.bound=!1;this.flags=TypeScript.SymbolFlags.None;this.isObjectLitField=!1;this.declModule=this.declAST=null;this.passSymbolCreated=TypeScript.CompilerDiagnostics.analysisPass}Symbol.prototype.instanceScope=v713;Symbol.prototype.isVariable=v714;Symbol.prototype.isMember=v715;Symbol.prototype.isInferenceSymbol=v716;Symbol.prototype.isWith=v717;Symbol.prototype.writeable=v718;Symbol.prototype.isType=v719;Symbol.prototype.getType=v720;Symbol.prototype.isAccessor=
v721;Symbol.prototype.isInstanceProperty=v722;Symbol.prototype.getTypeName=v723;Symbol.prototype.getTypeNameEx=v724;Symbol.prototype.getOptionalNameString=v725;Symbol.prototype.pathToRoot=v726;Symbol.prototype.findCommonAncestorPath=v727;Symbol.prototype.getPrettyName=v728;Symbol.prototype.scopeRelativeName=v729;Symbol.prototype.fullName=v730;Symbol.prototype.isExternallyVisible=v731;Symbol.prototype.visible=v732;Symbol.prototype.addRef=v733;Symbol.prototype.toString=v734;Symbol.prototype.print=v735;
Symbol.prototype.specializeType=v736;Symbol.prototype.setType=v737;Symbol.prototype.kind=v738;Symbol.prototype.getInterfaceDeclFromSymbol=v739;Symbol.prototype.getVarDeclFromSymbol=v740;Symbol.prototype.getDocComments=v741;Symbol.prototype.isStatic=v742;return Symbol}function v712(TypeCheckStatus){TypeCheckStatus._map=[];TypeCheckStatus._map[0]="NotStarted";TypeCheckStatus.NotStarted=0;TypeCheckStatus._map[1]="Started";TypeCheckStatus.Started=1;TypeCheckStatus._map[2]="Finished";TypeCheckStatus.Finished=
2}function aLexicallyEnclosesB(a,b){var v15449=a.declAST;v15449&&(v15449=b)&&(v15449=b.declAST)&&(v15449=a.declAST.nodeType==TypeScript.NodeType.FuncDecl);return v15449?((v15449=a.declAST.minChar<=b.declAST.minChar)&&(v15449=a.declAST.limChar>=b.declAST.limChar),v15449):!1}function aEnclosesB(a,b){for(var v7062=a.container;v7062;){(v7062=a==b)||(v7062=aLexicallyEnclosesB(a.container,b));if(v7062)return!0;a=a.container;v7062=a.container}return!1}var v15455=TypeScript.TypeCheckStatus;v15455||(v15455=
TypeScript.TypeCheckStatus={});v712(v15455);var TypeCheckStatus=TypeScript.TypeCheckStatus;TypeScript.aLexicallyEnclosesB=aLexicallyEnclosesB;TypeScript.aEnclosesB=aEnclosesB;v15455=v743();TypeScript.Symbol=v15455;var ValueLocation=v744();TypeScript.ValueLocation=ValueLocation;v15455=v747(v15455);TypeScript.InferenceSymbol=v15455;var TypeSymbol=v761(v15455);TypeScript.TypeSymbol=TypeSymbol;TypeSymbol=v763(TypeSymbol);TypeScript.WithSymbol=TypeSymbol;TypeSymbol=v775(v15455);TypeScript.FieldSymbol=
TypeSymbol;TypeSymbol=v786(v15455);TypeScript.ParameterSymbol=TypeSymbol;v15455=v793(v15455);TypeScript.VariableSymbol=v15455}
function v711(){var TypeScript=v18810;function v710(){function v709(checker,ast,hasConstruct){if(!this.hasBeenTypechecked){this.hasBeenTypechecked=!0;ast=0;var v15456=this.signatures;v15456&&(v15456=0<(ast=this.signatures.length));if(v15456){for(var v15456=0,v7073=v15456<ast;v7073;){if(v7073=!hasConstruct)if(v7073=!this.definitionSignature){v7073=this.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v7073=v7073[v15456];if(v7073=v7073.declAST){v7073=this.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v7073=
v7073[v15456];if(v7073=v7073.declAST.isOverload){v7073=this.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v7073=v7073[v15456];v7073=!JAM.call(TypeScript.hasFlag,TypeScript,[v7073.declAST.fncFlags,TypeScript.FncFlags.Ambient])}}}if(v7073){var v7073=checker.errorReporter,v20536=this.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v20536=v20536[v15456];JAM.call(v7073.simpleError,v7073,[v20536.declAST,"Overload declaration lacks definition"])}v7073=
this.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v7073=v7073[v15456];if(v7073=v7073.declAST){v7073=this.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v7073=v7073[v15456];if(v7073=v7073.declAST.isConstructor){v7073=this.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v7073=v7073[v15456];if(v7073=v7073.declAST.classDecl){v7073=this.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v7073=v7073[v15456];
v7073=v7073.declAST.classDecl.type.symbol.typeCheckStatus==TypeScript.TypeCheckStatus.NotStarted}}}if(v7073){v7073=checker.typeFlow;v20536=this.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v20536=v20536[v15456];JAM.call(v7073.typeCheck,v7073,[v20536.declAST.classDecl])}v7073=checker.typeFlow;v20536=this.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v20536=v20536[v15456];JAM.call(v7073.typeCheck,v7073,[v20536.declAST]);v15456+=1;v7073=v15456<
ast}JAM.call(this.verifySignatures,this,[checker])}}}function v708(checker){var len=0,v15462=this.signatures;v15462&&(v15462=0<(len=this.signatures.length));if(v15462)for(var v15462=0,v7084=v15462<len;v7084;){for(var v7084=v15462+1,v7079=v7084<len;v7079;){v7079=this.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v7079=v7079[v15462];if(v7079=v7079.declAST){v7079=this.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v7079=v7079[v7084];if(v7079=v7079.declAST){v7079=
this.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v7079=v7079[v15462];if(v7079=!JAM.call(TypeScript.hasFlag,TypeScript,[v7079.declAST.fncFlags,TypeScript.FncFlags.Definition])){v7079=this.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v7079=v7079[v7084];v7079=!JAM.call(TypeScript.hasFlag,TypeScript,[v7079.declAST.fncFlags,TypeScript.FncFlags.Definition])}if(v7079){v7079=this.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v7079=
v7079[v15462];var v25941=this.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25941=v25941[v7084];v7079=JAM.call(checker.signaturesAreIdentical,checker,[v7079,v25941])}}}if(v7079){v7079=checker.errorReporter;v25941=this.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25941=v25941[v15462];var v25941=v25941.declAST,v15465;v15465=this.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v15465=v15465[v15462];if(v15465=v15465.declAST){v15465=
this.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v15465=v15465[v15462];v15465=v15465.declAST.name}if(v15465){v15465=this.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v15465=v15465[v15462];v15465="Signature for '"+v15465.declAST.name.actualText+"' is duplicated"}else v15465="Signature is duplicated";JAM.call(v7079.simpleError,v7079,[v25941,v15465])}v7084+=1;v7079=v7084<len}if(this.definitionSignature){v7084=this.definitionSignature;v7079=
this.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v7079=v7079[v15462];if(!JAM.call(checker.signatureIsAssignableToTarget,checker,[v7084,v7079])){v7084=checker.errorReporter;v7079=this.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v7079=v7079[v15462];JAM.call(v7084.simpleError,v7084,[v7079.declAST,"Overload signature is not compatible with function definition"])}}v15462+=1;v7084=v15462<len}}function v707(pattern,replacement,checker){var result=
new SignatureGroup;if(this.signatures)for(var i=0,len=this.signatures.length,v7088=i<len;v7088;){v7088=this.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v7088=v7088[i];JAM.call(result.addSignature,result,[JAM.call(v7088.specializeType,v7088,[pattern,replacement,checker])]);i+=1;v7088=i<len}return result}function v706(prefix,shortform,scope){var result=[],len=this.signatures.length;1<len&&(shortform=!1);for(var i=0,v7096=i<len;v7096;){if(v7096=1<len){v7096=this.signatures;
introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v7096=v7096[i];v7096=v7096==this.definitionSignature}if(!v7096)if(this.flags&TypeScript.SignatureFlags.IsIndexer){v7096=this.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v7096=v7096[i];JAM.call(result.push,result,[JAM.call(v7096.toStringHelperEx,v7096,[shortform,!0,scope])])}else{v7096=this.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v7096=v7096[i];JAM.call(result.push,result,
[JAM.call(v7096.toStringHelperEx,v7096,[shortform,!1,scope,prefix])])}i+=1;v7096=i<len}return result}function v705(){return this.signatures.toString()}function v704(signature){if(null==this.signatures){var v27010=[];this.signatures=v27010}JAM.set(this.signatures,this.signatures.length,signature);(v27010=signature.declAST)&&(v27010=!signature.declAST.isOverload)&&(v27010=!signature.declAST.isSignature())&&(v27010=!JAM.call(TypeScript.hasFlag,TypeScript,[signature.declAST.fncFlags,TypeScript.FncFlags.Ambient]))&&
(v27010=JAM.call(TypeScript.hasFlag,TypeScript,[signature.declAST.fncFlags,TypeScript.FncFlags.Definition]));v27010&&(this.definitionSignature=signature)}function SignatureGroup(){this.signatures=[];this.hasImplementation=!0;this.definitionSignature=null;this.hasBeenTypechecked=!1;this.flags=TypeScript.SignatureFlags.None}SignatureGroup.prototype.addSignature=v704;SignatureGroup.prototype.toString=v705;SignatureGroup.prototype.toStrings=v706;SignatureGroup.prototype.specializeType=v707;SignatureGroup.prototype.verifySignatures=
v708;SignatureGroup.prototype.typeCheck=v709;return SignatureGroup}function v703(){function v702(shortform,brackets,scope,prefix){"undefined"===typeof prefix&&(prefix="");var builder=new TypeScript.MemberNameArray;builder.prefix=brackets?prefix+"[":prefix+"(";var paramLen=this.parameters.length,len=prefix=this.hasVariableArgList?paramLen-1:paramLen;prefix=0;for(var v7117=prefix<len;v7117;){var v7117=TypeScript.MemberName,v25949=this.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25949=
v25949[prefix];var v25949=v25949.name,v25159;v25159=this.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25159=v25159[prefix];v25159=v25159.isOptional()?"?":"";JAM.call(builder.add,builder,[JAM.call(v7117.create,v7117,[v25949+v25159+": "])]);v7117=this.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v7117=v7117[prefix];v7117=v7117.getType();JAM.call(builder.add,builder,[JAM.call(v7117.getScopedTypeNameEx,v7117,[scope])]);prefix<paramLen-1&&(v7117=
TypeScript.MemberName,JAM.call(builder.add,builder,[JAM.call(v7117.create,v7117,[", "])]));prefix+=1;v7117=prefix<len}if(this.hasVariableArgList){paramLen=TypeScript.MemberName;len=this.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)len=len[prefix];JAM.call(builder.add,builder,[JAM.call(paramLen.create,paramLen,["..."+len.name+": "])]);paramLen=this.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)prefix=paramLen[prefix];prefix=prefix.getType();
JAM.call(builder.add,builder,[JAM.call(prefix.getScopedTypeNameEx,prefix,[scope])])}shortform?brackets?(shortform=TypeScript.MemberName,JAM.call(builder.add,builder,[JAM.call(shortform.create,shortform,["] => "])])):(shortform=TypeScript.MemberName,JAM.call(builder.add,builder,[JAM.call(shortform.create,shortform,[") => "])])):brackets?(shortform=TypeScript.MemberName,JAM.call(builder.add,builder,[JAM.call(shortform.create,shortform,["]: "])])):(shortform=TypeScript.MemberName,JAM.call(builder.add,
builder,[JAM.call(shortform.create,shortform,["): "])]));this.returnType.type?(shortform=this.returnType.type,JAM.call(builder.add,builder,[JAM.call(shortform.getScopedTypeNameEx,shortform,[scope])])):(scope=TypeScript.MemberName,JAM.call(builder.add,builder,[JAM.call(scope.create,scope,["any"])]));return builder}function v701(shortform,brackets,scope){return JAM.call(this.toStringHelperEx,this,[shortform,brackets,scope]).toString()}function v700(){return JAM.call(this.toStringHelper,this,[!1,!1,
null])}function v699(pattern,replacement,checker){var result=new Signature;this.hasVariableArgList&&(result.hasVariableArgList=!0);var v7130=result,v27011=new TypeScript.TypeLink;v7130.returnType=v27011;this.returnType.type?(v7130=result.returnType,v27011=this.returnType.type,v27011=JAM.call(v27011.specializeType,v27011,[pattern,replacement,checker,!1]),v7130.type=v27011):result.returnType.type=checker.anyType;if(this.parameters){result.parameters=[];for(var v7130=0,v27011=this.parameters.length,
v7146=v7130<v27011;v7146;){v7146=this.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var oldSym=v7146[v7130];var v7146=new TypeScript.ValueLocation,paramSym=JAM.new(TypeScript.ParameterSymbol,[oldSym.name,oldSym.location,checker.locationInfo.unitIndex,v7146]);paramSym.declAST=this.declAST;v7146.symbol=paramSym;var v7141=v7146,v27013=new TypeScript.TypeLink;v7141.typeLink=v27013;result.parameters[v7130]=paramSym;(v7141=oldSym.getType())?(oldSym=v7146.typeLink,v7141=JAM.call(v7141.specializeType,
v7141,[pattern,replacement,checker,!1]),oldSym.type=v7141,paramSym.declAST.type=v7146.typeLink.type):v7146.typeLink.type=checker.anyType;v7130+=1;v7146=v7130<v27011}}result.nonOptionalParameterCount=this.nonOptionalParameterCount;result.declAST=this.declAST;return result}function Signature(){this.hasVariableArgList=!1;this.declAST=this.parameters=null;this.typeCheckStatus=TypeScript.TypeCheckStatus.NotStarted;this.nonOptionalParameterCount=0}Signature.prototype.specializeType=v699;Signature.prototype.toString=
v700;Signature.prototype.toStringHelper=v701;Signature.prototype.toStringHelperEx=v702;return Signature}var Signature=v703();TypeScript.Signature=Signature;Signature=v710();TypeScript.SignatureGroup=Signature}
function v698(){var TypeScript=v18809;function v697(){function v696(){if(null==this.scriptFragment){var ast=this.scopeStartAST,minChar=ast.minChar,v7153;v7153=this.isMemberCompletion?this.pos:this.pos+1;this.scriptFragment=JAM.call(TypeScript.quickParse,TypeScript,[this.logger,ast,this.text,minChar,v7153,null]).Script}return this.scriptFragment}function v695(){return this.scopeStartAST.minChar}function v694(){return this.scopeStartAST}function v693(){return this.scopeStartAST.minChar}function v692(){return this.scopeStartAST}
function v691(){return this.objectLiteralScopeGetter()}function v690(){return this.scopeGetter()}function EnclosingScopeContext(logger,script,text,pos,isMemberCompletion){this.logger=logger;this.script=script;this.text=text;this.pos=pos;this.isMemberCompletion=isMemberCompletion;this.scopeStartAST=this.objectLiteralScopeGetter=this.scopeGetter=null;this.skipNextFuncDeclForClass=!1;this.enclosingObjectLit=this.enclosingClassDecl=this.deepestModuleDecl=null;this.publicsOnly=!0;this.useFullAst=!1}EnclosingScopeContext.prototype.getScope=
v690;EnclosingScopeContext.prototype.getObjectLiteralScope=v691;EnclosingScopeContext.prototype.getScopeAST=v692;EnclosingScopeContext.prototype.getScopePosition=v693;EnclosingScopeContext.prototype.getScriptFragmentStartAST=v694;EnclosingScopeContext.prototype.getScriptFragmentPosition=v695;EnclosingScopeContext.prototype.getScriptFragment=v696;return EnclosingScopeContext}function v689(){function MemberScopeContext(flow,pos,matchFlag){this.flow=flow;this.pos=pos;this.matchFlag=matchFlag;this.ast=
this.type=null;this.options=flow=new TypeScript.AstWalkOptions}return MemberScopeContext}function v688(){function TypeCollectionContext(scopeChain,checker){this.scopeChain=scopeChain;this.checker=checker;this.script=null}return TypeCollectionContext}function preFindMemberScope(ast,parent,walker){parent=walker.state;if(walker=JAM.call(TypeScript.hasFlag,TypeScript,[ast.flags,parent.matchFlag]))(walker=0>parent.pos)||(walker=parent.pos==ast.limChar);walker&&(parent.ast=ast,(walker=null==ast.type)&&
(walker=0<=parent.pos),walker&&(walker=parent.flow,JAM.call(walker.inScopeTypeCheck,walker,[ast,parent.scope])),parent.type=ast.type,parent.options.stopWalk());return ast}function pushTypeCollectionScope(container,valueMembers,ambientValueMembers,enclosedTypes,ambientEnclosedTypes,context,thisType,classType,moduleDecl){valueMembers=JAM.new(TypeScript.SymbolScopeBuilder,[valueMembers,ambientValueMembers,enclosedTypes,ambientEnclosedTypes,null,container]);container=JAM.new(TypeScript.ScopeChain,[container,
context.scopeChain,valueMembers]);container.thisType=thisType;container.classType=classType;container.moduleDecl=moduleDecl;context.scopeChain=container}function popTypeCollectionScope(context){context.scopeChain=context.scopeChain.previous}function preFindEnclosingScope(ast,parent,walker){function v687(){var v15507=funcDecl.isConstructor;v15507&&(v15507=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.ClassMethod]));if(v15507){if(v15507=ast.type)v15507=ast.type.enclosingType;
if(v15507)return ast.type.enclosingType.constructorScope}return funcDecl.scopeType?funcDecl.scopeType.containedScope:funcDecl.type?funcDecl.type.containedScope:null}function v686(){var v7182;return v7182=null===ast.type?null:ast.type.containedScope}function v685(){var v7183;return v7183=null===ast.type?null:ast.type.containedScope}function v684(){return objectLit.targetType.memberScope}function v683(){return objectLit.targetType.containedScope}function v682(){var v7186;(v7186=null===ast.type)||(v7186=
null===ast.type.instanceType.containedScope);return v7186=v7186?null:ast.type.instanceType.containedScope}function v681(){var v7187;return v7187=null===script.bod?null:script.bod.enclosingScope}parent=walker.state;var minChar=ast.minChar,limChar=ast.limChar,v15518=ast.nodeType==TypeScript.NodeType.Script;v15518&&(v15518=parent.pos>limChar);v15518&&(limChar=parent.pos);(minChar=minChar<=parent.pos)&&(minChar=limChar>=parent.pos);if(minChar){switch(ast.nodeType){case TypeScript.NodeType.Script:var script=
ast;parent.scopeGetter=v681;parent.scopeStartAST=script;break;case TypeScript.NodeType.ClassDeclaration:parent.scopeGetter=v682;parent.scopeStartAST=ast;parent.enclosingClassDecl=ast;break;case TypeScript.NodeType.ObjectLit:var objectLit=ast;objectLit.targetType&&(parent.scopeGetter=v683,parent.objectLiteralScopeGetter=v684,parent.enclosingObjectLit=objectLit);break;case TypeScript.NodeType.ModuleDeclaration:parent.deepestModuleDecl=ast;parent.scopeGetter=v685;parent.scopeStartAST=ast;break;case TypeScript.NodeType.InterfaceDeclaration:parent.scopeGetter=
v686;parent.scopeStartAST=ast;break;case TypeScript.NodeType.FuncDecl:var funcDecl=ast;parent.skipNextFuncDeclForClass?parent.skipNextFuncDeclForClass=!1:(parent.scopeGetter=v687,parent.scopeStartAST=ast)}walker.options.goChildren=!0}else walker.options.goChildren=!1;return ast}function findEnclosingScopeAt(logger,script,text,pos,isMemberCompletion){logger=JAM.new(EnclosingScopeContext,[logger,script,text,pos,isMemberCompletion]);text=TypeScript.getAstWalkerFactory();JAM.call(text.walk,text,[script,
preFindEnclosingScope,null,null,logger]);return null===logger.scopeStartAST?null:logger}var TypeCollectionContext=v688();TypeScript.TypeCollectionContext=TypeCollectionContext;TypeCollectionContext=v689();TypeScript.MemberScopeContext=TypeCollectionContext;var EnclosingScopeContext=v697();TypeScript.EnclosingScopeContext=EnclosingScopeContext;TypeScript.preFindMemberScope=preFindMemberScope;TypeScript.pushTypeCollectionScope=pushTypeCollectionScope;TypeScript.popTypeCollectionScope=popTypeCollectionScope;
TypeScript.preFindEnclosingScope=preFindEnclosingScope;TypeScript.findEnclosingScopeAt=findEnclosingScopeAt}
function v680(){var TypeScript=v18808;function v679(){function v678(b){return(this.result=b=JAM.call(this.select,this,[this.result,b]))?JAM.call(this.stop,this,[this.result]):!1}function v677(){this.result=null}function ScopeSearchFilter(select,stop){this.select=select;this.stop=stop;this.result=null}ScopeSearchFilter.prototype.reset=v677;ScopeSearchFilter.prototype.update=v678;return ScopeSearchFilter}function v676(){function AssignScopeContext(scopeChain,typeFlow,modDeclChain){this.scopeChain=scopeChain;
this.typeFlow=typeFlow;this.modDeclChain=modDeclChain}return AssignScopeContext}function pushAssignScope(scope,context,type,classType,fnc){scope=JAM.new(TypeScript.ScopeChain,[null,context.scopeChain,scope]);scope.thisType=type;scope.classType=classType;scope.fnc=fnc;context.scopeChain=scope}function popAssignScope(context){context.scopeChain=context.scopeChain.previous}function instanceCompare(a,b){var v15521=null==a;v15521||(v15521=!a.isInstanceProperty());return v15521?b:a}function instanceFilterStop(s){return s.isInstanceProperty()}
function preAssignModuleScopes(ast,context){var moduleDecl=ast,memberScope=null,aggScope=null,v15522=moduleDecl.name;v15522&&(v15522=moduleDecl.mod);v15522&&(moduleDecl.name.sym=moduleDecl.mod.symbol);if(v15522=moduleDecl.mod)memberScope=JAM.new(TypeScript.SymbolTableScope,[v15522.members,v15522.ambientMembers,v15522.enclosedTypes,v15522.ambientEnclosedTypes,v15522.symbol]),v15522.memberScope=memberScope,aggScope=context.modDeclChain,JAM.call(aggScope.push,aggScope,[moduleDecl]),context.typeFlow.checker.currentModDecl=
moduleDecl,aggScope=JAM.new(TypeScript.SymbolAggregateScope,[v15522.symbol]),JAM.call(aggScope.addParentScope,aggScope,[memberScope]),JAM.call(aggScope.addParentScope,aggScope,[context.scopeChain.scope]),pushAssignScope(aggScope,context,null,null,null),v15522.containedScope=aggScope,v15522.symbol&&(memberScope=context.typeFlow,JAM.call(memberScope.addLocalsFromScope,memberScope,[v15522.containedScope,v15522.symbol,moduleDecl.vars,v15522.members.privateMembers,!0]))}function preAssignClassScopes(ast,
context){var classDecl=ast,memberScope=null,aggScope=null;if(memberScope=classDecl.name)memberScope=classDecl.type;memberScope&&(classDecl.name.sym=classDecl.type.symbol);if(classDecl=ast.type){memberScope=context.typeFlow.checker;memberScope=JAM.call(memberScope.scopeOf,memberScope,[classDecl]);aggScope=JAM.new(TypeScript.SymbolAggregateScope,[classDecl.symbol]);JAM.call(aggScope.addParentScope,aggScope,[memberScope]);JAM.call(aggScope.addParentScope,aggScope,[context.scopeChain.scope]);classDecl.containedScope=
aggScope;classDecl.memberScope=memberScope;var instanceType=classDecl.instanceType,memberScope=context.typeFlow.checker,memberScope=JAM.call(memberScope.scopeOf,memberScope,[instanceType]);instanceType.memberScope=memberScope;aggScope=JAM.new(TypeScript.SymbolAggregateScope,[instanceType.symbol]);JAM.call(aggScope.addParentScope,aggScope,[context.scopeChain.scope]);pushAssignScope(aggScope,context,instanceType,classDecl,null);instanceType.containedScope=aggScope}else ast.type=context.typeFlow.anyType}
function preAssignInterfaceScopes(ast,context){var interfaceDecl=ast,memberScope=null,aggScope=null;if(memberScope=interfaceDecl.name)memberScope=interfaceDecl.type;memberScope&&(interfaceDecl.name.sym=interfaceDecl.type.symbol);interfaceDecl=ast.type;memberScope=context.typeFlow.checker;memberScope=JAM.call(memberScope.scopeOf,memberScope,[interfaceDecl]);interfaceDecl.memberScope=memberScope;aggScope=JAM.new(TypeScript.SymbolAggregateScope,[interfaceDecl.symbol]);JAM.call(aggScope.addParentScope,
aggScope,[memberScope]);JAM.call(aggScope.addParentScope,aggScope,[context.scopeChain.scope]);pushAssignScope(aggScope,context,null,null,null);interfaceDecl.containedScope=aggScope}function preAssignWithScopes(ast,context){var withStmt=ast,withType=withStmt.type,members=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,[new TypeScript.StringHashTable,new TypeScript.StringHashTable])]),ambientMembers=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,[new TypeScript.StringHashTable,
new TypeScript.StringHashTable])]),withType=new TypeScript.Type,withSymbol=JAM.new(TypeScript.WithSymbol,[withStmt.minChar,context.typeFlow.checker.locationInfo.unitIndex,withType]);withType.members=members;withType.ambientMembers=ambientMembers;withType.symbol=withSymbol;withType.setHasImplementation();withStmt.type=withType;withStmt=JAM.new(TypeScript.SymbolScopeBuilder,[withType.members,withType.ambientMembers,null,null,context.scopeChain.scope,withType.symbol]);pushAssignScope(withStmt,context,
null,null,null);withType.containedScope=withStmt}function preAssignFuncDeclScopes(ast,context){var funcDecl=ast,container=null,localContainer=null;funcDecl.type&&(localContainer=ast.type.symbol);var isStatic=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.Static]),v7260=isStatic;v7260&&(v7260=null!=context.scopeChain.fnc);var v7260=v7260?context.scopeChain.fnc.type.memberScope:context.scopeChain.scope,v15549=context.scopeChain.thisType;v15549&&((v15549=!funcDecl.isConstructor)||
(v15549=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.ClassMethod])));if(v15549){container=context.scopeChain.thisType;(v7260=!(container.typeFlags&TypeScript.TypeFlags.IsClass))&&(v7260=!JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.ClassMethod]));if(v7260)(v7260=!funcDecl.isMethod())||(v7260=isStatic),v7260=v7260?container.constructorScope:container.containedScope;else{if(v7260=context.scopeChain.previous.scope.container)if(v7260=context.scopeChain.previous.scope.container.declAST)if(v7260=
context.scopeChain.previous.scope.container.declAST.nodeType==TypeScript.NodeType.FuncDecl)v7260=context.scopeChain.previous.scope.container.declAST.isConstructor;if(v7260)v7260=container.constructorScope;else{if(v7260=isStatic)v7260=context.scopeChain.classType;v7260=v7260?context.scopeChain.classType.containedScope:container.containedScope}}container=container.symbol}else{if(v15549=funcDecl.isConstructor)v15549=context.scopeChain.thisType;v15549&&(container=context.scopeChain.thisType.symbol)}(v15549=
null==funcDecl.type)||(v15549=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.type.symbol.flags,TypeScript.SymbolFlags.TypeSetDuringScopeAssignment]));if(v15549){if(v15549=context.scopeChain.fnc)v15549=context.scopeChain.fnc.type;v15549&&(container=context.scopeChain.fnc.type.symbol);var funcScope=null,outerFnc=context.scopeChain.fnc,nameText=v15549=funcDecl.name?funcDecl.name.actualText:null,v15549=null;if(isStatic){if(funcScope=null==outerFnc.type.members)funcScope=container.getType().memberScope;
funcScope&&(outerFnc.type.members=container.type.memberScope.valueMembers);funcScope=context.scopeChain.fnc.type.memberScope;JAM.set(outerFnc.innerStaticFuncs,outerFnc.innerStaticFuncs.length,funcDecl)}else funcScope=context.scopeChain.scope;(outerFnc=nameText)&&(outerFnc="__missing"!=nameText)&&(outerFnc=!funcDecl.isAccessor());outerFnc&&(v15549=JAM.call(funcScope.findLocal,funcScope,[nameText,!1,!1]));nameText=context.typeFlow.checker;JAM.call(nameText.createFunctionSignature,nameText,[funcDecl,
container,funcScope,v15549,null==v15549]);if(nameText=!funcDecl.accessorSymbol)if(nameText=funcDecl.fncFlags&TypeScript.FncFlags.ClassMethod)if(nameText=container)(nameText=!v15549)||(nameText=v15549.declAST.nodeType!=TypeScript.NodeType.FuncDecl),nameText&&(nameText=funcDecl.isAccessor());nameText||(nameText=v15549)&&(nameText=v15549.isAccessor());if(nameText){var nameText=funcDecl,outerFnc=context.typeFlow.checker,v15570=container.getType(),v20616=funcDecl.isMethod();v20616&&(v20616=isStatic);container=
JAM.call(outerFnc.createAccessorSymbol,outerFnc,[funcDecl,v15549,v15570,v20616,!0,funcScope,container]);nameText.accessorSymbol=container}container=funcDecl.type.symbol;container.flags|=TypeScript.SymbolFlags.TypeSetDuringScopeAssignment}if(container=funcDecl.name)container=funcDecl.type;container&&(funcDecl.name.sym=funcDecl.type.symbol);funcDecl.scopeType=funcDecl.type;if(!funcDecl.isOverload){container=new TypeScript.StringHashTable;v15549=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,
[container,new TypeScript.StringHashTable])]);funcScope=new TypeScript.StringHashTable;outerFnc=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,[funcScope,new TypeScript.StringHashTable])]);funcScope=new TypeScript.StringHashTable;nameText=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,[funcScope,new TypeScript.StringHashTable])]);v15570=new TypeScript.StringHashTable;v15570=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,
[v15570,new TypeScript.StringHashTable])]);funcDecl.unitIndex=context.typeFlow.checker.locationInfo.unitIndex;localContainer=JAM.new(TypeScript.SymbolScopeBuilder,[v15549,outerFnc,null,null,v7260,localContainer]);nameText=JAM.new(TypeScript.SymbolScopeBuilder,[nameText,v15570,null,null,v7260,null]);if(v7260=funcDecl.isConstructor)v7260=context.scopeChain.thisType;v7260&&(context.scopeChain.thisType.constructorScope=localContainer);funcDecl.symbols=container;if(!funcDecl.isSpecialFn()){v15549=funcDecl.type;
v7260=funcDecl.signature;funcDecl.isConstructor||(v15549.containedScope=localContainer,localContainer.container=v15549.symbol,v15549.memberScope=nameText,nameText.container=v15549.symbol);funcDecl.enclosingFnc=context.scopeChain.fnc;isStatic=isStatic?context.scopeChain.classType:context.scopeChain.thisType;v15549.enclosingType=isStatic;v15549=ast.type.symbol;if(isStatic=(funcDecl.fncFlags&TypeScript.FncFlags.Signature)==TypeScript.FncFlags.None)isStatic=funcDecl.vars;isStatic&&(isStatic=context.typeFlow,
JAM.call(isStatic.addLocalsFromScope,isStatic,[localContainer,v15549,funcDecl.vars,container,!1]),isStatic=context.typeFlow,JAM.call(isStatic.addLocalsFromScope,isStatic,[nameText,v15549,funcDecl.statics,funcScope,!1]));if(v7260.parameters)for(isStatic=v7260.parameters.length,v15549=0,funcScope=v15549<isStatic;funcScope;){funcScope=v7260.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)funcScope=funcScope[v15549];nameText=context.typeFlow.checker;JAM.call(nameText.resolveTypeLink,
nameText,[localContainer,funcScope.parameter.typeLink,!0]);v15549+=1;funcScope=v15549<isStatic}isStatic=context.typeFlow.checker;JAM.call(isStatic.resolveTypeLink,isStatic,[localContainer,v7260.returnType,funcDecl.isSignature()])}(isStatic=!funcDecl.isConstructor)||(isStatic=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.ClassMethod]));isStatic&&((isStatic=funcDecl.isConstructor)&&(isStatic=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.ClassMethod])),
isStatic=isStatic?context.scopeChain.thisType:null,pushAssignScope(localContainer,context,isStatic,null,funcDecl));(isStatic=funcDecl.name)&&(isStatic=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.IsFunctionExpression]));isStatic&&funcDecl.name.sym&&JAM.call(container.add,container,[funcDecl.name.actualText,funcDecl.name.sym])}}function preAssignCatchScopes(ast,context){var catchBlock=ast;if(catchBlock.param){var catchTable=JAM.new(TypeScript.ScopedMembers,[JAM.new(TypeScript.DualStringHashTable,
[new TypeScript.StringHashTable,new TypeScript.StringHashTable])]),catchTable=JAM.new(TypeScript.SymbolScopeBuilder,[catchTable,null,null,null,context.scopeChain.scope,context.scopeChain.scope.container]);catchBlock.containedScope=catchTable;pushAssignScope(catchTable,context,context.scopeChain.thisType,context.scopeChain.classType,context.scopeChain.fnc)}}function preAssignScopes(ast,parent,walker){parent=walker.state;var go=!0;if(ast)if(ast.nodeType==TypeScript.NodeType.List){var list=ast;list.enclosingScope=
parent.scopeChain.scope}else ast.nodeType==TypeScript.NodeType.ModuleDeclaration?preAssignModuleScopes(ast,parent):ast.nodeType==TypeScript.NodeType.ClassDeclaration?preAssignClassScopes(ast,parent):ast.nodeType==TypeScript.NodeType.InterfaceDeclaration?preAssignInterfaceScopes(ast,parent):ast.nodeType==TypeScript.NodeType.With?preAssignWithScopes(ast,parent):ast.nodeType==TypeScript.NodeType.FuncDecl?preAssignFuncDeclScopes(ast,parent):ast.nodeType==TypeScript.NodeType.Catch?preAssignCatchScopes(ast,
parent):ast.nodeType==TypeScript.NodeType.TypeRef&&(go=!1);walker.options.goChildren=go;return ast}function postAssignScopes(ast,parent,walker){parent=walker.state;var go=!0;if(ast)if(ast.nodeType==TypeScript.NodeType.ModuleDeclaration)popAssignScope(parent),parent.modDeclChain.pop(),1<=parent.modDeclChain.length&&(parent.typeFlow.checker.currentModDecl=parent.modDeclChain[parent.modDeclChain.length-1]);else if(ast.nodeType==TypeScript.NodeType.ClassDeclaration)popAssignScope(parent);else if(ast.nodeType==
TypeScript.NodeType.InterfaceDeclaration)popAssignScope(parent);else if(ast.nodeType==TypeScript.NodeType.With)popAssignScope(parent);else if(ast.nodeType==TypeScript.NodeType.FuncDecl){var funcDecl=ast,v20652=!funcDecl.isConstructor;v20652||(v20652=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.ClassMethod]));v20652&&(v20652=!funcDecl.isOverload);v20652&&popAssignScope(parent)}else ast.nodeType==TypeScript.NodeType.Catch?(funcDecl=ast,funcDecl.param&&popAssignScope(parent)):
go=!1;walker.options.goChildren=go;return ast}var AssignScopeContext=v676();TypeScript.AssignScopeContext=AssignScopeContext;TypeScript.pushAssignScope=pushAssignScope;TypeScript.popAssignScope=popAssignScope;TypeScript.instanceCompare=instanceCompare;TypeScript.instanceFilterStop=instanceFilterStop;var ScopeSearchFilter=v679();TypeScript.ScopeSearchFilter=ScopeSearchFilter;AssignScopeContext=TypeScript;ScopeSearchFilter=JAM.new(ScopeSearchFilter,[instanceCompare,instanceFilterStop]);AssignScopeContext.instanceFilter=
ScopeSearchFilter;TypeScript.preAssignModuleScopes=preAssignModuleScopes;TypeScript.preAssignClassScopes=preAssignClassScopes;TypeScript.preAssignInterfaceScopes=preAssignInterfaceScopes;TypeScript.preAssignWithScopes=preAssignWithScopes;TypeScript.preAssignFuncDeclScopes=preAssignFuncDeclScopes;TypeScript.preAssignCatchScopes=preAssignCatchScopes;TypeScript.preAssignScopes=preAssignScopes;TypeScript.postAssignScopes=postAssignScopes}
function v675(){var TypeScript=v18807;function v674(){function v673(message){this.reportError&&JAM.call(this.reportError,this,[message])}function v672(){var rtok;this.tokenStart();var v27019=this.peekChar();this.ch=v27019;var v7528=this.pos<this.len;start:for(;v7528;){var v20655=this.ch;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v15644=lexIdStartTable[v20655];if(!v15644){var v20656=this.ch==TypeScript.LexCodeBSL;if(!v20656){var v23678=this.ch>=TypeScript.LexCodeASCIIChars;
v23678&&(v23678=LexIsUnicodeIdStart(this.ch));v20656=v23678}v15644=v20656}if(v15644)return this.scanIdentifier();if(this.ch==TypeScript.LexCodeSpace){this.interveningWhitespace||(this.interveningWhitespacePos=this.pos);var v7367=this.ch==TypeScript.LexCodeSpace;do this.nextChar(),v7367=this.ch==TypeScript.LexCodeSpace;while(v7367);if(this.mode==LexMode.Line){var v7368=this.src,whitespaceText=JAM.call(v7368.substring,v7368,[this.startPos,this.pos]);return JAM.new(TypeScript.WhitespaceToken,[TypeScript.TokenID.Whitespace,
whitespaceText])}this.tokenStart();this.interveningWhitespace=!0}else if(this.ch==TypeScript.LexCodeSLH){this.nextChar();var commentText;if(this.ch==TypeScript.LexCodeSLH){this.interveningWhitespace||(this.interveningWhitespacePos=this.pos-1);var commentStartPos=this.pos-1,commentStartLine=this.line;this.finishSinglelineComment();var v7377=this.src;commentText=JAM.call(v7377.substring,v7377,[commentStartPos,this.pos]);var commentToken=JAM.new(TypeScript.CommentToken,[TypeScript.TokenID.Comment,commentText,
!1,commentStartPos,commentStartLine,!1]);if(this.scanComments)return this.startPos=commentStartPos,commentToken;JAM.call(this.pushComment,this,[commentToken]);this.interveningWhitespace=!0}else if(this.ch==TypeScript.LexCodeMUL){this.interveningWhitespace||(this.interveningWhitespacePos=this.pos-1);commentStartPos=this.pos-1;commentStartLine=this.line;this.nextChar();this.finishMultilineComment();var v7385=this.src;commentText=JAM.call(v7385.substring,v7385,[commentStartPos,this.pos]);var endsLine=
JAM.call(this.endsLine,this,[this.peekChar()]),commentToken=JAM.new(TypeScript.CommentToken,[TypeScript.TokenID.Comment,commentText,!0,commentStartPos,commentStartLine,endsLine]);if(this.scanComments)return this.startPos=commentStartPos,commentToken;JAM.call(this.pushComment,this,[commentToken]);this.interveningWhitespace=!0}else{var regexTok=this.speculateRegex();if(regexTok)return regexTok;if(JAM.call(this.peekCharAt,this,[this.pos])==TypeScript.LexCodeEQ){this.nextChar();var v7391=TypeScript.staticTokens,
v7392=TypeScript.TokenID.SlashEquals;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7391[v7392]}else{var v7393=TypeScript.staticTokens,v7394=TypeScript.TokenID.Slash;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7393[v7394]}}}else if(this.ch==TypeScript.LexCodeSMC){this.nextChar();var v7398=TypeScript.staticTokens,v7399=TypeScript.TokenID.Semicolon;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7398[v7399]}else{var v15672=
this.ch==TypeScript.LexCodeAPO;v15672||(v15672=this.ch==TypeScript.LexCodeQUO);if(v15672)return this.scanStringConstant();var v15673=this.ch;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v7522=autoToken[v15673];if(v7522){var v7400=this.ch;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var atok=autoToken[v7400];atok.tokenId==TypeScript.TokenID.OpenBrace?this.leftCurlyCount+=1:atok.tokenId==TypeScript.TokenID.CloseBrace&&(this.rightCurlyCount+=1);this.nextChar();
return atok}var v15680=this.ch>=TypeScript.LexCode_0;v15680&&(v15680=this.ch<=TypeScript.LexCode_9);if(v15680){if(rtok=this.scanNumber())return rtok;this.nextChar();var v7403=TypeScript.staticTokens,v7404=TypeScript.TokenID.Error;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7403[v7404]}else switch(this.ch){case TypeScript.LexCodeTAB:case TypeScript.LexCodeVTAB:this.interveningWhitespace||(this.interveningWhitespacePos=this.pos);if(this.mode==LexMode.Line){var v15685=this.ch==
TypeScript.LexCodeSpace;v15685||(v15685=9==this.ch);var v7406=v15685;do{this.nextChar();var v15686=this.ch==TypeScript.LexCodeSpace;v15686||(v15686=9==this.ch);v7406=v15686}while(v7406);var v7407=this.src,wsText=JAM.call(v7407.substring,v7407,[this.startPos,this.pos]);return JAM.new(TypeScript.WhitespaceToken,[TypeScript.TokenID.Whitespace,wsText])}this.interveningWhitespace=!0;case 255:case 254:case 239:case 187:case 191:case TypeScript.LexCodeLS:case TypeScript.LexCodePS:case TypeScript.LexCodeNWL:case TypeScript.LexCodeRET:if(this.ch==
TypeScript.LexCodeNWL&&(this.newLine(),this.mode==LexMode.Line)){var v7413=TypeScript.staticTokens,v7414=TypeScript.TokenID.EndOfFile;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7413[v7414]}this.interveningWhitespace||(this.interveningWhitespacePos=this.pos);this.nextChar();this.tokenStart();this.interveningWhitespace=!0;break;case TypeScript.LexCodeDOT:if(JAM.call(this.peekCharAt,this,[this.pos+1])==TypeScript.LexCodeDOT)if(JAM.call(this.peekCharAt,this,[this.pos+2])==
TypeScript.LexCodeDOT){JAM.call(this.advanceChar,this,[3]);var v7418=TypeScript.staticTokens,v7419=TypeScript.TokenID.DotDotDot;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7418[v7419]}else{this.nextChar();var v7420=TypeScript.staticTokens,v7421=TypeScript.TokenID.Dot;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7420[v7421]}else{this.nextChar();if(rtok=this.scanFraction())return rtok;var v7423=TypeScript.staticTokens,v7424=TypeScript.TokenID.Dot;
introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7423[v7424]}case TypeScript.LexCodeEQ:if(JAM.call(this.peekCharAt,this,[this.pos+1])==TypeScript.LexCodeEQ)if(JAM.call(this.peekCharAt,this,[this.pos+2])==TypeScript.LexCodeEQ){JAM.call(this.advanceChar,this,[3]);var v7426=TypeScript.staticTokens,v7427=TypeScript.TokenID.EqualsEqualsEquals;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7426[v7427]}else{JAM.call(this.advanceChar,this,[2]);var v7428=TypeScript.staticTokens,
v7429=TypeScript.TokenID.EqualsEquals;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7428[v7429]}else if(JAM.call(this.peekCharAt,this,[this.pos+1])==TypeScript.LexCodeGT){JAM.call(this.advanceChar,this,[2]);var v7431=TypeScript.staticTokens,v7432=TypeScript.TokenID.EqualsGreaterThan;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7431[v7432]}else{this.nextChar();var v7433=TypeScript.staticTokens,v7434=TypeScript.TokenID.Equals;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7433[v7434]}case TypeScript.LexCodeBNG:if(JAM.call(this.peekCharAt,
this,[this.pos+1])==TypeScript.LexCodeEQ)if(JAM.call(this.peekCharAt,this,[this.pos+2])==TypeScript.LexCodeEQ){JAM.call(this.advanceChar,this,[3]);var v7437=TypeScript.staticTokens,v7438=TypeScript.TokenID.ExclamationEqualsEquals;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7437[v7438]}else{JAM.call(this.advanceChar,this,[2]);var v7439=TypeScript.staticTokens,v7440=TypeScript.TokenID.ExclamationEquals;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7439[v7440]}else{this.nextChar();
var v7442=TypeScript.staticTokens,v7443=TypeScript.TokenID.Exclamation;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7442[v7443]}case TypeScript.LexCodePLS:if(JAM.call(this.peekCharAt,this,[this.pos+1])==TypeScript.LexCodeEQ){JAM.call(this.advanceChar,this,[2]);var v7445=TypeScript.staticTokens,v7446=TypeScript.TokenID.PlusEquals;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7445[v7446]}else if(JAM.call(this.peekCharAt,this,[this.pos+1])==TypeScript.LexCodePLS){JAM.call(this.advanceChar,
this,[2]);var v7447=TypeScript.staticTokens,v7448=TypeScript.TokenID.PlusPlus;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7447[v7448]}else{this.nextChar();var v7449=TypeScript.staticTokens,v7450=TypeScript.TokenID.Plus;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7449[v7450]}case TypeScript.LexCodeMIN:if(JAM.call(this.peekCharAt,this,[this.pos+1])==TypeScript.LexCodeEQ){JAM.call(this.advanceChar,this,[2]);var v7453=TypeScript.staticTokens,v7454=
TypeScript.TokenID.MinusEquals;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7453[v7454]}else if(JAM.call(this.peekCharAt,this,[this.pos+1])==TypeScript.LexCodeMIN){JAM.call(this.advanceChar,this,[2]);var v7455=TypeScript.staticTokens,v7456=TypeScript.TokenID.MinusMinus;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7455[v7456]}else{this.nextChar();var v7457=TypeScript.staticTokens,v7458=TypeScript.TokenID.Minus;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7457[v7458]}case TypeScript.LexCodeMUL:if(JAM.call(this.peekCharAt,
this,[this.pos+1])==TypeScript.LexCodeEQ){JAM.call(this.advanceChar,this,[2]);var v7461=TypeScript.staticTokens,v7462=TypeScript.TokenID.AsteriskEquals;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7461[v7462]}else{this.nextChar();var v7463=TypeScript.staticTokens,v7464=TypeScript.TokenID.Asterisk;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7463[v7464]}case TypeScript.LexCodePCT:if(JAM.call(this.peekCharAt,this,[this.pos+1])==TypeScript.LexCodeEQ){JAM.call(this.advanceChar,
this,[2]);var v7466=TypeScript.staticTokens,v7467=TypeScript.TokenID.PercentEquals;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7466[v7467]}else{this.nextChar();var v7468=TypeScript.staticTokens,v7469=TypeScript.TokenID.Percent;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7468[v7469]}case TypeScript.LexCodeLT:if(JAM.call(this.peekCharAt,this,[this.pos+1])==TypeScript.LexCodeLT)if(JAM.call(this.peekCharAt,this,[this.pos+2])==TypeScript.LexCodeEQ){JAM.call(this.advanceChar,
this,[3]);var v7471=TypeScript.staticTokens,v7472=TypeScript.TokenID.LessThanLessThanEquals;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7471[v7472]}else{JAM.call(this.advanceChar,this,[2]);var v7473=TypeScript.staticTokens,v7474=TypeScript.TokenID.LessThanLessThan;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7473[v7474]}else if(JAM.call(this.peekCharAt,this,[this.pos+1])==TypeScript.LexCodeEQ){JAM.call(this.advanceChar,this,[2]);var v7476=TypeScript.staticTokens,
v7477=TypeScript.TokenID.LessThanEquals;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7476[v7477]}else{this.nextChar();var v7478=TypeScript.staticTokens,v7479=TypeScript.TokenID.LessThan;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7478[v7479]}case TypeScript.LexCodeGT:if(JAM.call(this.peekCharAt,this,[this.pos+1])==TypeScript.LexCodeGT)if(JAM.call(this.peekCharAt,this,[this.pos+2])==TypeScript.LexCodeEQ){JAM.call(this.advanceChar,this,[3]);var v7482=
TypeScript.staticTokens,v7483=TypeScript.TokenID.GreaterThanGreaterThanEquals;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7482[v7483]}else if(JAM.call(this.peekCharAt,this,[this.pos+2])==TypeScript.LexCodeGT)if(JAM.call(this.peekCharAt,this,[this.pos+3])==TypeScript.LexCodeEQ){JAM.call(this.advanceChar,this,[4]);var v7484=TypeScript.staticTokens,v7485=TypeScript.TokenID.GreaterThanGreaterThanGreaterThanEquals;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7484[v7485]}else{JAM.call(this.advanceChar,
this,[3]);var v7486=TypeScript.staticTokens,v7487=TypeScript.TokenID.GreaterThanGreaterThanGreaterThan;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7486[v7487]}else{JAM.call(this.advanceChar,this,[2]);var v7489=TypeScript.staticTokens,v7490=TypeScript.TokenID.GreaterThanGreaterThan;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7489[v7490]}else if(JAM.call(this.peekCharAt,this,[this.pos+1])==TypeScript.LexCodeEQ){JAM.call(this.advanceChar,this,[2]);
var v7493=TypeScript.staticTokens,v7494=TypeScript.TokenID.GreaterThanEquals;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7493[v7494]}else{this.nextChar();var v7495=TypeScript.staticTokens,v7496=TypeScript.TokenID.GreaterThan;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7495[v7496]}case TypeScript.LexCodeXOR:if(JAM.call(this.peekCharAt,this,[this.pos+1])==TypeScript.LexCodeEQ){JAM.call(this.advanceChar,this,[2]);var v7499=TypeScript.staticTokens,
v7500=TypeScript.TokenID.CaretEquals;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7499[v7500]}else{this.nextChar();var v7501=TypeScript.staticTokens,v7502=TypeScript.TokenID.Caret;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7501[v7502]}case TypeScript.LexCodeBAR:if(JAM.call(this.peekCharAt,this,[this.pos+1])==TypeScript.LexCodeEQ){JAM.call(this.advanceChar,this,[2]);var v7504=TypeScript.staticTokens,v7505=TypeScript.TokenID.BarEquals;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7504[v7505]}else if(JAM.call(this.peekCharAt,
this,[this.pos+1])==TypeScript.LexCodeBAR){JAM.call(this.advanceChar,this,[2]);var v7506=TypeScript.staticTokens,v7507=TypeScript.TokenID.BarBar;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7506[v7507]}else{this.nextChar();var v7508=TypeScript.staticTokens,v7509=TypeScript.TokenID.Bar;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7508[v7509]}case TypeScript.LexCodeAMP:if(JAM.call(this.peekCharAt,this,[this.pos+1])==TypeScript.LexCodeEQ){JAM.call(this.advanceChar,
this,[2]);var v7512=TypeScript.staticTokens,v7513=TypeScript.TokenID.AmpersandEquals;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7512[v7513]}else if(JAM.call(this.peekCharAt,this,[this.pos+1])==TypeScript.LexCodeAMP){JAM.call(this.advanceChar,this,[2]);var v7514=TypeScript.staticTokens,v7515=TypeScript.TokenID.AmpersandAmpersand;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7514[v7515]}else{this.nextChar();var v7516=TypeScript.staticTokens,v7517=
TypeScript.TokenID.And;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7516[v7517]}default:JAM.call(this.reportScannerError,this,["Invalid character"]),this.nextChar()}}v7528=this.pos<this.len}var v7529=TypeScript.staticTokens,v7530=TypeScript.TokenID.EndOfFile;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7529[v7530]}function v671(){for(var hasEscape=!1,isFirstChar=this.ch==TypeScript.LexCodeBSL;;){var v20704=this.ch;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v20704=
lexIdStartTable[v20704];v20704||(v20704=LexIsDigit(this.ch),v20704||(v20704=this.ch>=TypeScript.LexCodeASCIIChars)&&(v20704=this.isValidUnicodeIdentifierChar()));for(;v20704;){this.nextChar();v20704=this.ch;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v20704=lexIdStartTable[v20704];v20704||(v20704=LexIsDigit(this.ch),v20704||(v20704=this.ch>=TypeScript.LexCodeASCIIChars)&&(v20704=this.isValidUnicodeIdentifierChar()))}if(this.ch==TypeScript.LexCodeBSL){this.nextChar();if(this.ch==
TypeScript.LexCode_u){this.nextChar();hasEscape=0;for(v20704=4>hasEscape;v20704;){if(JAM.call(this.IsHexDigit,this,[this.ch]))this.nextChar();else{JAM.call(this.reportScannerError,this,["Invalid Unicode escape sequence"]);var v7534=TypeScript.staticTokens,isFirstChar=TypeScript.TokenID.Error;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7534[isFirstChar]}hasEscape+=1;v20704=4>hasEscape}hasEscape=this.src;hasEscape=parseInt(JAM.call(hasEscape.substring,hasEscape,[this.pos-
4,this.pos]),16);introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v20704=lexIdStartTable[hasEscape];v20704||((v20704=!isFirstChar)&&(v20704=LexIsDigit(hasEscape)),v20704||!(v20704=hasEscape>=TypeScript.LexCodeASCIIChars))||(v20704=LexIsUnicodeIdStart(hasEscape),v20704||((isFirstChar=!isFirstChar)&&(isFirstChar=LexIsUnicodeDigit(hasEscape)),v20704=isFirstChar));if(!v20704){JAM.call(this.reportScannerError,this,["Invalid identifier character"]);v7534=TypeScript.staticTokens;isFirstChar=
TypeScript.TokenID.Error;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7534[isFirstChar]}hasEscape=!0;isFirstChar=!1;continue}JAM.call(this.reportScannerError,this,["Invalid Unicode escape sequence"]);v7534=TypeScript.staticTokens;isFirstChar=TypeScript.TokenID.Error;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7534[isFirstChar]}break}isFirstChar=this.src;isFirstChar=JAM.call(isFirstChar.substring,isFirstChar,[this.startPos,this.pos]);if(v20704=
!hasEscape)v7534=TypeScript.LexKeywordTable,v20704=null!=(v7534=JAM.call(v7534.lookup,v7534,[isFirstChar]));if(v20704){isFirstChar=TypeScript.staticTokens;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return isFirstChar[v7534]}else return JAM.new(TypeScript.IdentifierToken,[isFirstChar,hasEscape])}function v670(){var endCode=this.ch;this.nextChar();scanStringConstantLoop:for(;;){switch(this.ch){case TypeScript.LexEOF:JAM.call(this.reportScannerError,this,["Unterminated string constant"]);
break scanStringConstantLoop;case TypeScript.LexCodeLS:case TypeScript.LexCodePS:this.seenUnicodeChar=!0;case TypeScript.LexCodeRET:case TypeScript.LexCodeNWL:JAM.call(this.reportScannerError,this,["Unterminated string constant"]);break scanStringConstantLoop;case TypeScript.LexCodeAPO:case TypeScript.LexCodeQUO:if(this.ch==endCode){this.nextChar();break scanStringConstantLoop}break;case TypeScript.LexCodeBSL:switch(this.nextChar(),this.ch){case TypeScript.LexCodeAPO:case TypeScript.LexCodeQUO:case TypeScript.LexCodeBSL:this.nextChar();
continue scanStringConstantLoop;case TypeScript.LexCodeLS:case TypeScript.LexCodePS:this.seenUnicodeChar=!0;case TypeScript.LexCodeRET:case TypeScript.LexCodeNWL:var v15803=this.ch==TypeScript.LexCodeRET;v15803&&(v15803=JAM.call(this.peekCharAt,this,[this.pos+1])==TypeScript.LexCodeNWL);v15803&&this.nextChar();this.nextChar();this.newLine();if(this.mode==LexMode.Line){this.lexState=endCode=endCode==TypeScript.LexCodeAPO?LexState.InMultilineSingleQuoteString:LexState.InMultilineDoubleQuoteString;break scanStringConstantLoop}break;
case TypeScript.LexCode_x:case TypeScript.LexCode_u:v15803=this.ch==TypeScript.LexCode_x?2:4;this.nextChar();for(var i=0,v7558=i<v15803;v7558;){if(JAM.call(this.IsHexDigit,this,[this.ch]))this.nextChar();else{JAM.call(this.reportScannerError,this,["Invalid Unicode escape sequence"]);break}i+=1;v7558=i<v15803}continue scanStringConstantLoop}}this.ch>=TypeScript.LexCodeASCIIChars&&(this.seenUnicodeChar=!0);this.nextChar()}endCode=TypeScript.StringLiteralToken;v15803=this.src;return JAM.new(endCode,
[JAM.call(v15803.substring,v15803,[this.startPos,this.pos])])}function v669(){var v7564=LexIsUnicodeIdStart(this.ch);v7564||(v7564=LexIsUnicodeDigit(this.ch));var v7565=this.seenUnicodeChar;v7565||(v7565=v7564);this.seenUnicodeChar=v7565;return v7564}function v668(){this.prevLine=this.line;var v27020=this.innerScan();this.prevTok=v27020;this.saveScan&&(v27020=this.saveScan,JAM.call(v27020.addToken,v27020,[this.prevTok,this]));return this.prevTok}function v667(){var v15818=this.lexState==LexState.InMultilineComment;
v15818&&(v15818=this.scanComments);if(v15818){this.ch=v15818=this.peekChar();v15818=this.line;this.finishMultilineComment();if(this.startPos<this.pos){var v7569=this.src,v7569=JAM.call(v7569.substring,v7569,[this.startPos,this.pos]);this.tokenStart();return JAM.new(TypeScript.CommentToken,[TypeScript.TokenID.Comment,v7569,!0,this.startPos,v15818,!0])}v15818=TypeScript.staticTokens;v7569=TypeScript.TokenID.EndOfFile;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v15818[v7569]}else{(v15818=
this.lexState==LexState.InMultilineSingleQuoteString)&&(v15818=this.pos<this.len);if(v15818)return this.ch=TypeScript.LexCodeAPO,this.lexState=LexState.Start,this.scanStringConstant();(v15818=this.lexState==LexState.InMultilineDoubleQuoteString)&&(v15818=this.pos<this.len);if(v15818)return this.ch=TypeScript.LexCodeQUO,this.lexState=LexState.Start,this.scanStringConstant()}this.prevLine=this.line;v15818=this.innerScan();v15818.tokenId!=TypeScript.TokenID.Whitespace&&(this.prevTok=v15818);return v15818}
function v666(){var prevLine=this.prevLine,line=this.line,col=this.col,pos=this.pos,startPos=this.startPos,startCol=this.startCol,startLine=this.startLine,ch=this.ch,prevTok=this.prevTok,lexState=this.lexState,interveningWhitespace=this.interveningWhitespace,interveningWhitespacePos=this.interveningWhitespacePos,leftCurlyCount=this.leftCurlyCount,rightCurlyCount=this.rightCurlyCount,seenUnicodeChar=this.seenUnicodeChar,seenUnicodeCharInComment=this.seenUnicodeCharInComment,commentStackLength=this.commentStack.length,
lookAheadToken=this.scan();this.prevLine=prevLine;this.line=line;this.col=col;this.pos=pos;this.startPos=startPos;this.startCol=startCol;this.startLine=startLine;this.ch=ch;this.prevTok=prevTok;this.lexState=lexState;this.interveningWhitespace=interveningWhitespace;this.interveningWhitespacePos=interveningWhitespacePos;this.leftCurlyCount=leftCurlyCount;this.rightCurlyCount=rightCurlyCount;this.seenUnicodeChar=seenUnicodeChar;this.seenUnicodeCharInComment=seenUnicodeCharInComment;this.commentStack.length=
commentStackLength;return lookAheadToken}function v665(){this.pos+=1;this.col+=1;var v27022=this.peekChar();this.ch=v27022}function v664(amt){this.pos+=amt;this.col+=amt;this.ch=amt=this.peekChar()}function v663(){var v7584;return v7584=this.interveningWhitespace?this.interveningWhitespacePos:this.startPos}function v662(){return this.prevLine!=this.startLine}function v661(){var v20732=TypeScript.noRegexTable,v20733=this.prevTok.tokenId;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v20732=
v20732[v20733];if(void 0!=v20732)return null;var v20732=this.pos,v20733=this.col,index=this.findClosingSLH();if(0<index){var v7588=this.src,v7588=JAM.call(v7588.substring,v7588,[v20732,index]),flags="";this.pos=index+1;this.ch=index=this.peekChar();index=this.pos;flags=this.ch==TypeScript.LexCode_i;flags||(flags=this.ch==TypeScript.LexCode_g)||(flags=this.ch==TypeScript.LexCode_m);for(;flags;)this.nextChar(),flags=this.ch==TypeScript.LexCode_i,flags||(flags=this.ch==TypeScript.LexCode_g)||(flags=
this.ch==TypeScript.LexCode_m);if(3<this.pos-index)return null;flags=this.src;flags=JAM.call(flags.substring,flags,[index,this.pos]);index=void 0;try{index=RegExp(v7588,flags)}catch(regexException){}if(index)return this.col=v20733+(this.pos-this.startPos),JAM.new(TypeScript.RegularExpressionLiteralToken,[index])}this.pos=v20732;this.col=v20733;return null}function v660(){var index=this.pos,v7596=this.src,ch2=JAM.call(v7596.charCodeAt,v7596,[index]),prevCh=0,v7596=!1;for((prevCh=!JAM.call(this.endsLine,
this,[ch2]))&&(prevCh=index<this.len);prevCh;){(prevCh=ch2==TypeScript.LexCodeSLH)&&(prevCh=!v7596);if(prevCh)return index;prevCh=ch2;index+=1;v7596=v7596?!1:prevCh==TypeScript.LexCodeBSL;ch2=this.src;ch2=JAM.call(ch2.charCodeAt,ch2,[index]);(prevCh=!JAM.call(this.endsLine,this,[ch2]))&&(prevCh=index<this.len)}return-1}function v659(){var v7601=this.src;return JAM.call(v7601.substring,v7601,[this.startPos,this.pos])}function v658(){for(var v7606=this.pos<this.len;v7606&&!JAM.call(this.endsLine,this,
[this.ch]);)this.ch>=TypeScript.LexCodeASCIIChars&&(this.seenUnicodeCharInComment=!0),this.nextChar(),v7606=this.pos<this.len;this.mode==LexMode.File&&this.tokenStart()}function v657(c){var v7608=c==TypeScript.LexCodeNWL;v7608||(v7608=c==TypeScript.LexCodeRET,v7608||(v7608=c==TypeScript.LexCodeLS)||(v7608=c==TypeScript.LexCodePS));return v7608}function v656(){this.commentStack=[]}function v655(line){var comments=null,v15853=0<this.commentStack.length;for(v15853&&(v15853=this.commentStack[0].line==
line);v15853;)comments=null==comments?[this.commentStack.shift()]:comments.concat([this.commentStack.shift()]),(v15853=0<this.commentStack.length)&&(v15853=this.commentStack[0].line==line);return comments}function v654(){var stack=this.commentStack;this.commentStack=[];return stack}function v653(comment){var v7613=this.commentStack;JAM.call(v7613.push,v7613,[comment])}function v652(){var ch2;this.lexState=LexState.InMultilineComment;for(ch2=this.pos<this.len;ch2;){if(this.ch==TypeScript.LexCodeMUL){if(ch2=
JAM.call(this.peekCharAt,this,[this.pos+1]),ch2==TypeScript.LexCodeSLH)return JAM.call(this.advanceChar,this,[2]),this.mode==LexMode.File&&this.tokenStart(),this.lexState=LexState.Start,!0}else if(this.ch==TypeScript.LexCodeNWL){if(this.newLine(),this.mode==LexMode.Line){this.nextChar();break}}else this.ch>=TypeScript.LexCodeASCIIChars&&(this.seenUnicodeCharInComment=!0);this.nextChar();ch2=this.pos<this.len}return!1}function v651(){this.col=0;this.mode==LexMode.File&&(this.line+=1,JAM.set(this.lineMap,
this.line,this.pos+1))}function v650(){return JAM.call(this.scanDecimalNumber,this,[NumberScanState.InFraction])}function v649(){if(this.peekChar()==TypeScript.LexCode_0)switch(JAM.call(this.peekCharAt,this,[this.pos+1])){case TypeScript.LexCode_x:case TypeScript.LexCode_X:return JAM.call(this.advanceChar,this,[2]),this.scanHexDigits();case TypeScript.LexCode_8:case TypeScript.LexCode_9:case TypeScript.LexCodeDOT:return JAM.call(this.scanDecimalNumber,this,[NumberScanState.Start]);default:return this.scanOctalDigits()}else return JAM.call(this.scanDecimalNumber,
this,[NumberScanState.Start])}function v648(state){for(var atLeastOneDigit=!1,svPos=this.pos,svCol=this.col;;)if(LexIsDigit(this.ch)){var atLeastOneDigit=!0,v15881=this.ch!=TypeScript.LexCode_0;v15881&&(v15881=state==NumberScanState.InEmptyFraction);v15881&&(state=NumberScanState.InFraction);this.nextChar()}else if(this.ch==TypeScript.LexCodeDOT)if(state==NumberScanState.Start)this.nextChar(),state=NumberScanState.InEmptyFraction;else{if(atLeastOneDigit)return atLeastOneDigit=TypeScript.NumberLiteralToken,
svPos=this.src,JAM.new(atLeastOneDigit,[parseFloat(JAM.call(svPos.substring,svPos,[this.startPos,this.pos])),state==NumberScanState.InEmptyFraction]);this.pos=svPos;this.col=svCol;return null}else if((v15881=this.ch==TypeScript.LexCode_e)||(v15881=this.ch==TypeScript.LexCode_E),v15881)if(state==NumberScanState.Start)if(atLeastOneDigit)atLeastOneDigit=!1,this.nextChar(),state=NumberScanState.InExponent;else return this.pos=svPos,this.col=svCol,null;else if((v15881=state==NumberScanState.InFraction)||
(v15881=state==NumberScanState.InEmptyFraction),v15881)this.nextChar(),state=NumberScanState.InExponent,atLeastOneDigit=!1;else{if(atLeastOneDigit)return state=TypeScript.NumberLiteralToken,atLeastOneDigit=this.src,JAM.new(state,[parseFloat(JAM.call(atLeastOneDigit.substring,atLeastOneDigit,[this.startPos,this.pos]))]);this.pos=svPos;this.col=svCol;return null}else if((v15881=this.ch==TypeScript.LexCodePLS)||(v15881=this.ch==TypeScript.LexCodeMIN),v15881)if(state==NumberScanState.InExponent){if(atLeastOneDigit)return this.pos=
svPos,this.col=svCol,null;this.nextChar()}else{(v15881=state==NumberScanState.InEmptyFraction)||(v15881=state==NumberScanState.InFraction);if(v15881)return atLeastOneDigit=TypeScript.NumberLiteralToken,svPos=this.src,JAM.new(atLeastOneDigit,[parseFloat(JAM.call(svPos.substring,svPos,[this.startPos,this.pos])),state==NumberScanState.InEmptyFraction]);if(atLeastOneDigit)return state=TypeScript.NumberLiteralToken,atLeastOneDigit=this.src,JAM.new(state,[parseFloat(JAM.call(atLeastOneDigit.substring,atLeastOneDigit,
[this.startPos,this.pos]))]);this.pos=svPos;this.col=svCol;return null}else{if(atLeastOneDigit)return atLeastOneDigit=TypeScript.NumberLiteralToken,svPos=this.src,JAM.new(atLeastOneDigit,[parseFloat(JAM.call(svPos.substring,svPos,[this.startPos,this.pos])),state==NumberScanState.InEmptyFraction]);this.pos=svPos;this.col=svCol;return null}}function v647(){for(var atLeastOneDigit=!1;;)if(JAM.call(this.IsOctalDigit,this,[this.ch]))this.nextChar(),atLeastOneDigit=!0;else{if(atLeastOneDigit){var atLeastOneDigit=
TypeScript.NumberLiteralToken,v20791=this.src;return JAM.new(atLeastOneDigit,[parseInt(JAM.call(v20791.substring,v20791,[this.startPos,this.pos]))])}return null}}function v646(){for(var atLeastOneDigit=!1;;)if(JAM.call(this.IsHexDigit,this,[this.ch]))this.nextChar(),atLeastOneDigit=!0;else{if(atLeastOneDigit){var atLeastOneDigit=TypeScript.NumberLiteralToken,v20794=this.src;return JAM.new(atLeastOneDigit,[parseInt(JAM.call(v20794.substring,v20794,[this.startPos,this.pos]))])}return null}}function v645(c){var v15903=
c>=TypeScript.LexCode_0;v15903&&(v15903=c<=TypeScript.LexCode_7);v15903||(v15903=c>=TypeScript.LexCode_a)&&(v15903=c<=TypeScript.LexCode_f);return v15903}function v644(c){var v15906=c>=TypeScript.LexCode_0;v15906&&(v15906=c<=TypeScript.LexCode_9);v15906||((v15906=c>=TypeScript.LexCode_A)&&(v15906=c<=TypeScript.LexCode_F),v15906||(v15906=c>=TypeScript.LexCode_a)&&(v15906=c<=TypeScript.LexCode_f));return v15906}function v643(index){if(index<this.len){var v7664=this.src;return JAM.call(v7664.charCodeAt,
v7664,[index])}return TypeScript.LexEOF}function v642(){if(this.pos<this.len){var v7666=this.src;return JAM.call(v7666.charCodeAt,v7666,[this.pos])}return TypeScript.LexEOF}function v641(){this.startPos=this.pos;this.startLine=this.line;this.startCol=this.col;this.interveningWhitespace=!1}function v640(){return this.lexState}function v639(value){this.scanComments=value}function v638(newSrc,textMode){JAM.call(this.setSourceText,this,[JAM.new(StringSourceText,[newSrc]),textMode])}function v637(savedTokens){this.saveScan=
savedTokens}function v636(reportError){this.reportError=reportError}function v635(newSrc,textMode){this.mode=textMode;this.scanComments=this.mode===LexMode.Line;this.startPos=this.interveningWhitespacePos=this.pos=0;this.line=1;this.startCol=this.col=0;this.startLine=this.line;this.len=0;var v27025=JAM.call(newSrc.getText,newSrc,[0,newSrc.getLength()]);this.src=v27025;this.len=this.src.length;this.lineMap=[];this.lineMap[1]=0;this.commentStack=[];this.rightCurlyCount=this.leftCurlyCount=0;this.seenUnicodeCharInComment=
this.seenUnicodeChar=!1}function v634(){return this.prevTok}function Scanner(){this.line=this.prevLine=1;this.len=this.startPos=this.pos=this.col=0;this.lineMap=[];this.ch=TypeScript.LexEOF;this.lexState=LexState.Start;this.mode=LexMode.File;this.scanComments=!0;this.interveningWhitespace=!1;this.rightCurlyCount=this.leftCurlyCount=this.interveningWhitespacePos=0;var v27026=[];this.commentStack=v27026;this.saveScan=null;this.seenUnicodeCharInComment=this.seenUnicodeChar=!1;var v27026=TypeScript.staticTokens,
v7676=TypeScript.TokenID.EndOfFile;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)this.prevTok=v27026[v7676];this.startCol=this.col;this.startLine=this.line;this.lineMap[1]=0;TypeScript.LexKeywordTable||LexInitialize()}Scanner.prototype.previousToken=v634;Scanner.prototype.setSourceText=v635;Scanner.prototype.setErrorHandler=v636;Scanner.prototype.setSaveScan=v637;Scanner.prototype.setText=v638;Scanner.prototype.setScanComments=v639;Scanner.prototype.getLexState=v640;Scanner.prototype.tokenStart=
v641;Scanner.prototype.peekChar=v642;Scanner.prototype.peekCharAt=v643;Scanner.prototype.IsHexDigit=v644;Scanner.prototype.IsOctalDigit=v645;Scanner.prototype.scanHexDigits=v646;Scanner.prototype.scanOctalDigits=v647;Scanner.prototype.scanDecimalNumber=v648;Scanner.prototype.scanNumber=v649;Scanner.prototype.scanFraction=v650;Scanner.prototype.newLine=v651;Scanner.prototype.finishMultilineComment=v652;Scanner.prototype.pushComment=v653;Scanner.prototype.getComments=v654;Scanner.prototype.getCommentsForLine=
v655;Scanner.prototype.resetComments=v656;Scanner.prototype.endsLine=v657;Scanner.prototype.finishSinglelineComment=v658;Scanner.prototype.tokenText=v659;Scanner.prototype.findClosingSLH=v660;Scanner.prototype.speculateRegex=v661;Scanner.prototype.lastTokenHadNewline=v662;Scanner.prototype.lastTokenLimChar=v663;Scanner.prototype.advanceChar=v664;Scanner.prototype.nextChar=v665;Scanner.prototype.getLookAheadToken=v666;Scanner.prototype.scanInLine=v667;Scanner.prototype.scan=v668;Scanner.prototype.isValidUnicodeIdentifierChar=
v669;Scanner.prototype.scanStringConstant=v670;Scanner.prototype.scanIdentifier=v671;Scanner.prototype.innerScan=v672;Scanner.prototype.reportScannerError=v673;return Scanner}function v633(){function v632(){throw Error("Invalid operation.");}function v631(reportError){}function v630(newSrc,textMode){}function v629(){this.commentStack=[]}function v628(line){var comments=null,v15914=0<this.commentStack.length;for(v15914&&(v15914=this.commentStack[0].line==line);v15914;)comments=null==comments?[this.commentStack.shift()]:
comments.concat([this.commentStack.shift()]),(v15914=0<this.commentStack.length)&&(v15914=this.commentStack[0].line==line);return comments}function v627(){var stack=this.commentStack;this.commentStack=[];return stack}function v626(comment){var v7723=this.commentStack;JAM.call(v7723.push,v7723,[comment])}function v625(){return this.prevLine!=this.startLine}function v624(){return null!==this.prevSavedToken?this.prevSavedToken.limChar:0}function v623(offset){var v27027=getLineNumberFromPosition(this.lineMap,
offset);this.line=v27027;this.currentTokenIndex=0;var v27027=this.lineMap,v15920=this.line;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v27027=v27027[v15920];offset-=v27027;v27027=this.lexStateByLine;v15920=this.line;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v27027=v27027[v15920];for((v27027=v27027==LexState.InMultilineComment)&&(v27027=0<this.line);v27027;){this.line-=1;offset=0;v27027=this.lexStateByLine;v15920=this.line;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v27027=
v27027[v15920];(v27027=v27027==LexState.InMultilineComment)&&(v27027=0<this.line)}var v27027=this.lineMap.length-1,v15920=this.tokensByLine,v7733=this.line;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)this.currentTokens=v15920[v7733];for((v15920=0==this.currentTokens.length)&&(v15920=this.line<v27027);v15920;){this.line+=1;offset=this.tokensByLine;v15920=this.line;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)this.currentTokens=offset[v15920];offset=0;(v15920=
0==this.currentTokens.length)&&(v15920=this.line<v27027)}if(this.line<=v27027){if(v27027=this.currentTokenIndex<this.currentTokens.length){v27027=this.currentTokens;v15920=this.currentTokenIndex;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v27027=v27027[v15920];v27027=offset>v27027.limChar}for(;v27027;)if(this.currentTokenIndex+=1,v27027=this.currentTokenIndex<this.currentTokens.length){v27027=this.currentTokens;v15920=this.currentTokenIndex;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v27027=
v27027[v15920];v27027=offset>v27027.limChar}if(this.currentTokenIndex<this.currentTokens.length){offset=this.currentTokens;v27027=this.currentTokenIndex;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)offset=offset[v27027];offset=this.col=offset.minChar;v27027=this.lineMap;v15920=this.line;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v27027=v27027[v15920];return offset+v27027}}return-1}function v622(){this.startLine=this.line;this.startPos=this.col;if(this.currentTokenIndex==
this.currentTokens.length)if(this.line<this.lineMap.length){this.line+=1;this.currentTokenIndex=this.col=0;var v7743=this.tokensByLine,v7744=this.line;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)this.currentTokens=v7743[v7744]}else{v7743=TypeScript.staticTokens;v7744=TypeScript.TokenID.EndOfFile;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7743[v7744]}if(this.currentTokenIndex<this.currentTokens.length){this.prevToken=this.curSavedToken.tok;this.prevSavedToken=
this.curSavedToken;v7743=this.currentTokens;v7744=this.currentTokenIndex;this.currentTokenIndex+=1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)this.curSavedToken=v7743[v7744];v7743=this.curSavedToken.tok;this.pos=this.curSavedToken.limChar;this.col+=this.curSavedToken.limChar-this.curSavedToken.minChar;this.startPos=this.curSavedToken.minChar;this.prevLine=this.line;return v7743}v7743=TypeScript.staticTokens;v7744=TypeScript.TokenID.EndOfFile;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7743[v7744]}
function v621(tok,scanner){var v7758=this.tokens,v7759=this.currentToken;this.currentToken+=1;var v27028=JAM.new(TypeScript.SavedToken,[tok,scanner.startPos,scanner.pos]);JAM.set(v7758,v7759,v27028)}function v620(){this.currentToken=0}function v619(){return this.prevToken}function SavedTokens(){this.prevToken=this.prevSavedToken=this.curSavedToken=this.prevToken=null;this.currentToken=0;var v27029=[];this.tokens=v27029;this.seenUnicodeCharInComment=this.seenUnicodeChar=!1;this.line=this.prevLine=
1;this.col=0;this.lexState=LexState.Start;this.commentStack=v27029=[];this.lineMap=[]}SavedTokens.prototype.previousToken=v619;SavedTokens.prototype.close=v620;SavedTokens.prototype.addToken=v621;SavedTokens.prototype.scan=v622;SavedTokens.prototype.syncToTok=v623;SavedTokens.prototype.lastTokenLimChar=v624;SavedTokens.prototype.lastTokenHadNewline=v625;SavedTokens.prototype.pushComment=v626;SavedTokens.prototype.getComments=v627;SavedTokens.prototype.getCommentsForLine=v628;SavedTokens.prototype.resetComments=
v629;SavedTokens.prototype.setSourceText=v630;SavedTokens.prototype.setErrorHandler=v631;SavedTokens.prototype.getLookAheadToken=v632;return SavedTokens}function v618(){function v617(start,end){var v7774=JAM.call(this.fetchSegment,this,[start,end]);return JAM.call(v7774.substring,v7774,[start,end])}function v616(index){var v7775=JAM.call(this.fetchSegment,this,[index,index+1]);return JAM.call(v7775.charCodeAt,v7775,[index])}function v615(start,end){var v15953=this.agg.seg1.segmentStart<=start;v15953&&
(v15953=end<=this.agg.seg1.segmentEnd);if(v15953)return this.agg.seg1;(v15953=this.agg.seg2.segmentStart<=start)&&(v15953=end<=this.agg.seg1.segmentEnd);if(v15953)return this.agg;var v15953=this.agg.seg1,s=v15953.segmentEnd,e=JAM.call(TypeScript.max,TypeScript,[s+512,end]),e=JAM.call(TypeScript.min,TypeScript,[e,this.len]),v7782=this.sourceText,v7782=JAM.call(v7782.getText,v7782,[s,e]),s=JAM.new(SourceTextSegment,[s,e,v7782]);this.agg.seg2=v15953;this.agg.seg1=s;return this.agg}function v614(a,b){var v7785;
return v7785=a<=b?a:b}function v613(a,b){var v7786;return v7786=a>=b?a:b}function ScannerTextStream(sourceText){this.sourceText=sourceText;this.agg=sourceText=JAM.new(AggerateSourceTextSegment,[ScannerTextStream.emptySegment,ScannerTextStream.emptySegment]);this.len=sourceText=this.sourceText.getLength()}var v7790=ScannerTextStream,v27033=JAM.new(SourceTextSegment,[0,0,""]);v7790.emptySegment=v27033;ScannerTextStream.prototype.max=v613;ScannerTextStream.prototype.min=v614;ScannerTextStream.prototype.fetchSegment=
v615;ScannerTextStream.prototype.charCodeAt=v616;ScannerTextStream.prototype.substring=v617;return ScannerTextStream}function v612(){function v611(start,end){var v15957=this.seg1.segmentStart<=start;v15957&&(v15957=end<=this.seg1.segmentEnd);if(v15957)return v15957=this.seg1.segment,JAM.call(v15957.substring,v15957,[start-this.seg1.segmentStart,end-this.seg1.segmentStart]);var v15957=this.seg2.segment,v15957=JAM.call(v15957.substring,v15957,[start-this.seg2.segmentStart]),v15963=this.seg1.segment;
return v15957+JAM.call(v15963.substring,v15963,[0,end-this.seg1.segmentStart])}function v610(index){var v15965=this.seg1.segmentStart<=index;v15965&&(v15965=index<this.seg1.segmentEnd);if(v15965)return v15965=this.seg1.segment,JAM.call(v15965.charCodeAt,v15965,[index-this.seg1.segmentStart]);v15965=this.seg2.segment;return JAM.call(v15965.charCodeAt,v15965,[index-this.seg2.segmentStart])}function AggerateSourceTextSegment(seg1,seg2){this.seg1=seg1;this.seg2=seg2}AggerateSourceTextSegment.prototype.charCodeAt=
v610;AggerateSourceTextSegment.prototype.substring=v611;return AggerateSourceTextSegment}function v609(){function v608(start,end){var v7809=this.segment;return JAM.call(v7809.substring,v7809,[start-this.segmentStart,end-this.segmentStart])}function v607(index){var v7812=this.segment;return JAM.call(v7812.charCodeAt,v7812,[index-this.segmentStart])}function SourceTextSegment(segmentStart,segmentEnd,segment){this.segmentStart=segmentStart;this.segmentEnd=segmentEnd;this.segment=segment}SourceTextSegment.prototype.charCodeAt=
v607;SourceTextSegment.prototype.substring=v608;return SourceTextSegment}function v606(){function v605(){return this.text.length}function v604(start,end){var v7817=this.text;return JAM.call(v7817.substring,v7817,[start,end])}function StringSourceText(text){this.text=text}StringSourceText.prototype.getText=v604;StringSourceText.prototype.getLength=v605;return StringSourceText}function v603(CommentStyle){CommentStyle._map=[];CommentStyle._map[0]="Line";CommentStyle.Line=0;CommentStyle._map[1]="Block";
CommentStyle.Block=1}function v602(LexMode){LexMode._map=[];LexMode._map[0]="Line";LexMode.Line=0;LexMode._map[1]="File";LexMode.File=1}function v601(LexState){LexState._map=[];LexState._map[0]="Start";LexState.Start=0;LexState._map[1]="InMultilineComment";LexState.InMultilineComment=1;LexState._map[2]="InMultilineSingleQuoteString";LexState.InMultilineSingleQuoteString=2;LexState._map[3]="InMultilineDoubleQuoteString";LexState.InMultilineDoubleQuoteString=3}function v600(NumberScanState){NumberScanState._map=
[];NumberScanState._map[0]="Start";NumberScanState.Start=0;NumberScanState._map[1]="InFraction";NumberScanState.InFraction=1;NumberScanState._map[2]="InEmptyFraction";NumberScanState.InEmptyFraction=2;NumberScanState._map[3]="InExponent";NumberScanState.InExponent=3}function LexLookUpUnicodeMap(code,map){var lo=0,hi=map.length,mid;for(mid=lo+1<hi;mid;){mid=lo+(hi-lo)/2;mid-=mid%2;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v20851=map[mid];if(v20851=v20851<=code){v20851=mid+
1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v20851=map[v20851];v20851=code<=v20851}if(v20851)return!0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v20851=map[mid];code<v20851?hi=mid:lo=mid+2;mid=lo+1<hi}return!1}function LexIsUnicodeDigit(code){return TypeScript.codeGenTarget==TypeScript.CodeGenTarget.ES3?LexLookUpUnicodeMap(code,unicodeES3IdCont):LexLookUpUnicodeMap(code,unicodeES5IdCont)}function LexIsUnicodeIdStart(code){return TypeScript.codeGenTarget==
TypeScript.CodeGenTarget.ES3?LexLookUpUnicodeMap(code,unicodeES3IdStart):LexLookUpUnicodeMap(code,unicodeES5IdStart)}function LexInitialize(){TypeScript.initializeStaticTokens();JAM.set(autoToken,TypeScript.LexCodeLPR,JAM.get(TypeScript.staticTokens,TypeScript.TokenID.OpenParen,JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074));JAM.set(autoToken,TypeScript.LexCodeRPR,JAM.get(TypeScript.staticTokens,TypeScript.TokenID.CloseParen,JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074));JAM.set(autoToken,
TypeScript.LexCodeCMA,JAM.get(TypeScript.staticTokens,TypeScript.TokenID.Comma,JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074));JAM.set(autoToken,TypeScript.LexCodeSMC,JAM.get(TypeScript.staticTokens,TypeScript.TokenID.Semicolon,JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074));JAM.set(autoToken,TypeScript.LexCodeLBR,JAM.get(TypeScript.staticTokens,TypeScript.TokenID.OpenBracket,JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074));JAM.set(autoToken,TypeScript.LexCodeRBR,JAM.get(TypeScript.staticTokens,
TypeScript.TokenID.CloseBracket,JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074));JAM.set(autoToken,TypeScript.LexCodeTIL,JAM.get(TypeScript.staticTokens,TypeScript.TokenID.Tilde,JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074));JAM.set(autoToken,TypeScript.LexCodeQUE,JAM.get(TypeScript.staticTokens,TypeScript.TokenID.Question,JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074));JAM.set(autoToken,TypeScript.LexCodeLC,JAM.get(TypeScript.staticTokens,TypeScript.TokenID.OpenBrace,JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074));
JAM.set(autoToken,TypeScript.LexCodeRC,JAM.get(TypeScript.staticTokens,TypeScript.TokenID.CloseBrace,JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074));JAM.set(autoToken,TypeScript.LexCodeCOL,JAM.get(TypeScript.staticTokens,TypeScript.TokenID.Colon,JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074));var v7849=TypeScript,v27034=new TypeScript.StringHashTable;v7849.LexKeywordTable=v27034;for(var i in TypeScript.TokenID._map)if(i<=TypeScript.TokenID.LimKeyword){v7849=TypeScript.LexKeywordTable;
v27034=TypeScript.TokenID._map;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v27034=v27034[i];JAM.call(v7849.add,v7849,[v27034.toLowerCase(),i])}i=0;for(v7849=i<TypeScript.LexCodeASCIIChars;v7849;)LexIsIdentifierStartChar(i)?lexIdStartTable[i]=!0:lexIdStartTable[i]=!1,i+=1,v7849=i<TypeScript.LexCodeASCIIChars}function LexAdjustIndent(code,indentAmt){var v16011=code==TypeScript.LexCodeLBR;v16011||(v16011=code==TypeScript.LexCodeLC)||(v16011=code==TypeScript.LexCodeLPR);if(v16011)return indentAmt+
1;v16011=code==TypeScript.LexCodeRBR;v16011||(v16011=code==TypeScript.LexCodeRC)||(v16011=code==TypeScript.LexCodeRPR);return v16011?indentAmt-1:indentAmt}function LexIsIdentifierStartChar(code){var v16013=97<=code;v16013&&(v16013=122>=code);v16013||((v16013=65<=code)&&(v16013=90>=code),v16013||(v16013=code==TypeScript.LexCodeDollar)||(v16013=code==TypeScript.LexCodeUnderscore));return v16013}function LexIsDigit(code){var v7859=48<=code;v7859&&(v7859=57>=code);return v7859}function LexIsIdentifierChar(code){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v7860=
lexIdStartTable[code];v7860||(v7860=LexIsDigit(code));return v7860}function LexMatchingOpen(code){return code==TypeScript.LexCodeRBR?TypeScript.LexCodeLBR:code==TypeScript.LexCodeRC?TypeScript.LexCodeLC:code==TypeScript.LexCodeRPR?TypeScript.LexCodeLPR:0}function convertTokToIDName(tok){return convertTokToIDBase(tok,!0,!1)}function convertTokToID(tok,strictMode){return convertTokToIDBase(tok,!1,strictMode)}function convertTokToIDBase(tok,identifierName,strictMode){if(tok.tokenId<=TypeScript.TokenID.LimKeyword)if(tok=
JAM.call(TypeScript.lookupToken,TypeScript,[tok.tokenId]),void 0!=tok){var resFlags=TypeScript.Reservation.Javascript|TypeScript.Reservation.JavascriptFuture;strictMode&&(resFlags|=TypeScript.Reservation.JavascriptFutureStrict);identifierName||(identifierName=!JAM.call(TypeScript.hasFlag,TypeScript,[tok.reservation,resFlags]));if(identifierName)return!0}else return!1;else return!1}function getLineNumberFromPosition(lineMap,position){if(-1===position)return 0;for(var min=0,max=lineMap.length-1,v7875=
min<max;v7875;){v7875=min+max>>1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v16026=lineMap[v7875];if(position<v16026)max=v7875-1;else{min=v7875+1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)min=lineMap[min];min=position<min?max=v7875:v7875+1}v7875=min<max}return min}function getSourceLineColFromMap(lineCol,minChar,lineMap){var line=getLineNumberFromPosition(lineMap,minChar);if(0<line){lineCol.line=line;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)lineMap=
lineMap[line];lineCol.col=minChar-lineMap}}function getLineColumnFromPosition(script,position){var result={line:-1,col:-1};getSourceLineColFromMap(result,position,script.locationInfo.lineMap);0<=result.col&&(result.col+=1);return result}function getPositionFromLineColumn(script,line,column){script=script.locationInfo.lineMap;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)line=script[line];return line+(column-1)}function isPrimitiveTypeToken(token){switch(token.tokenId){case TypeScript.TokenID.Any:case TypeScript.TokenID.Bool:case TypeScript.TokenID.Number:case TypeScript.TokenID.String:return!0}return!1}
function isModifier(token){switch(token.tokenId){case TypeScript.TokenID.Public:case TypeScript.TokenID.Private:case TypeScript.TokenID.Static:return!0}return!1}TypeScript.LexEOF=-1;TypeScript.LexCodeNWL=10;TypeScript.LexCodeRET=13;TypeScript.LexCodeLS=8232;TypeScript.LexCodePS=8233;TypeScript.LexCodeTAB=9;TypeScript.LexCodeVTAB=11;var v7884=TypeScript,v27035=JAM.call("e".charCodeAt,"e",[0]);v7884.LexCode_e=v27035;var v7885=TypeScript,v27036=JAM.call("E".charCodeAt,"E",[0]);v7885.LexCode_E=v27036;
var v7886=TypeScript,v27037=JAM.call("x".charCodeAt,"x",[0]);v7886.LexCode_x=v27037;var v7887=TypeScript,v27038=JAM.call("X".charCodeAt,"X",[0]);v7887.LexCode_X=v27038;var v7888=TypeScript,v27039=JAM.call("a".charCodeAt,"a",[0]);v7888.LexCode_a=v27039;var v7889=TypeScript,v27040=JAM.call("A".charCodeAt,"A",[0]);v7889.LexCode_A=v27040;var v7890=TypeScript,v27041=JAM.call("f".charCodeAt,"f",[0]);v7890.LexCode_f=v27041;var v7891=TypeScript,v27042=JAM.call("F".charCodeAt,"F",[0]);v7891.LexCode_F=v27042;
var v7892=TypeScript,v27043=JAM.call("g".charCodeAt,"g",[0]);v7892.LexCode_g=v27043;var v7893=TypeScript,v27044=JAM.call("m".charCodeAt,"m",[0]);v7893.LexCode_m=v27044;var v7894=TypeScript,v27045=JAM.call("i".charCodeAt,"i",[0]);v7894.LexCode_i=v27045;var v7895=TypeScript,v27046=JAM.call("u".charCodeAt,"u",[0]);v7895.LexCode_u=v27046;var v7896=TypeScript,v27047=JAM.call("0".charCodeAt,"0",[0]);v7896.LexCode_0=v27047;var v7897=TypeScript,v27048=JAM.call("9".charCodeAt,"9",[0]);v7897.LexCode_9=v27048;
var v7898=TypeScript,v27049=JAM.call("8".charCodeAt,"8",[0]);v7898.LexCode_8=v27049;var v7899=TypeScript,v27050=JAM.call("7".charCodeAt,"7",[0]);v7899.LexCode_7=v27050;var v7900=TypeScript,v27051=JAM.call("\\".charCodeAt,"\\",[0]);v7900.LexCodeBSL=v27051;var v7901=TypeScript,v27052=JAM.call("#".charCodeAt,"#",[0]);v7901.LexCodeSHP=v27052;var v7902=TypeScript,v27053=JAM.call("!".charCodeAt,"!",[0]);v7902.LexCodeBNG=v27053;var v7903=TypeScript,v27054=JAM.call('"'.charCodeAt,'"',[0]);v7903.LexCodeQUO=
v27054;var v7904=TypeScript,v27055=JAM.call("'".charCodeAt,"'",[0]);v7904.LexCodeAPO=v27055;var v7905=TypeScript,v27056=JAM.call("%".charCodeAt,"%",[0]);v7905.LexCodePCT=v27056;var v7906=TypeScript,v27057=JAM.call("&".charCodeAt,"&",[0]);v7906.LexCodeAMP=v27057;var v7907=TypeScript,v27058=JAM.call("(".charCodeAt,"(",[0]);v7907.LexCodeLPR=v27058;var v7908=TypeScript,v27059=JAM.call(")".charCodeAt,")",[0]);v7908.LexCodeRPR=v27059;var v7909=TypeScript,v27060=JAM.call("+".charCodeAt,"+",[0]);v7909.LexCodePLS=
v27060;var v7910=TypeScript,v27061=JAM.call("-".charCodeAt,"-",[0]);v7910.LexCodeMIN=v27061;var v7911=TypeScript,v27062=JAM.call("*".charCodeAt,"*",[0]);v7911.LexCodeMUL=v27062;var v7912=TypeScript,v27063=JAM.call("/".charCodeAt,"/",[0]);v7912.LexCodeSLH=v27063;var v7913=TypeScript,v27064=JAM.call("^".charCodeAt,"^",[0]);v7913.LexCodeXOR=v27064;var v7914=TypeScript,v27065=JAM.call(",".charCodeAt,",",[0]);v7914.LexCodeCMA=v27065;var v7915=TypeScript,v27066=JAM.call(".".charCodeAt,".",[0]);v7915.LexCodeDOT=
v27066;var v7916=TypeScript,v27067=JAM.call("<".charCodeAt,"<",[0]);v7916.LexCodeLT=v27067;var v7917=TypeScript,v27068=JAM.call("=".charCodeAt,"=",[0]);v7917.LexCodeEQ=v27068;var v7918=TypeScript,v27069=JAM.call(">".charCodeAt,">",[0]);v7918.LexCodeGT=v27069;var v7919=TypeScript,v27070=JAM.call("?".charCodeAt,"?",[0]);v7919.LexCodeQUE=v27070;var v7920=TypeScript,v27071=JAM.call("[".charCodeAt,"[",[0]);v7920.LexCodeLBR=v27071;var v7921=TypeScript,v27072=JAM.call("]".charCodeAt,"]",[0]);v7921.LexCodeRBR=
v27072;var v7922=TypeScript,v27073=JAM.call("_".charCodeAt,"_",[0]);v7922.LexCodeUSC=v27073;var v7923=TypeScript,v27074=JAM.call("{".charCodeAt,"{",[0]);v7923.LexCodeLC=v27074;var v7924=TypeScript,v27075=JAM.call("}".charCodeAt,"}",[0]);v7924.LexCodeRC=v27075;var v7925=TypeScript,v27076=JAM.call("|".charCodeAt,"|",[0]);v7925.LexCodeBAR=v27076;var v7926=TypeScript,v27077=JAM.call("~".charCodeAt,"~",[0]);v7926.LexCodeTIL=v27077;var v7927=TypeScript,v27078=JAM.call(":".charCodeAt,":",[0]);v7927.LexCodeCOL=
v27078;var v7928=TypeScript,v27079=JAM.call(";".charCodeAt,";",[0]);v7928.LexCodeSMC=v27079;var v7929=TypeScript,v27080=JAM.call("_".charCodeAt,"_",[0]);v7929.LexCodeUnderscore=v27080;var v7930=TypeScript,v27081=JAM.call("$".charCodeAt,"$",[0]);v7930.LexCodeDollar=v27081;TypeScript.LexCodeSpace=32;var v7931=TypeScript,v27082=JAM.call("@".charCodeAt,"@",[0]);v7931.LexCodeAtSign=v27082;TypeScript.LexCodeASCIIChars=128;TypeScript.LexKeywordTable=void 0;var autoToken=Array(TypeScript.LexCodeASCIIChars),
lexIdStartTable=Array(TypeScript.LexCodeASCIIChars),v27446=[170,170,181,181,186,186,192,214,216,246,248,543,546,563,592,685,688,696,699,705,720,721,736,740,750,750,890,890,902,902,904,906,908,908,910,929,931,974,976,983,986,1011,1024,1153,1164,1220,1223,1224,1227,1228,1232,1269,1272,1273,1329,1366,1369,1369,1377,1415,1488,1514,1520,1522,1569,1594,1600,1610,1649,1747,1749,1749,1765,1766,1786,1788,1808,1808,1810,1836,1920,1957,2309,2361,2365,2365,2384,2384,2392,2401,2437,2444,2447,2448,2451,2472,2474,
2480,2482,2482,2486,2489,2524,2525,2527,2529,2544,2545,2565,2570,2575,2576,2579,2600,2602,2608,2610,2611,2613,2614,2616,2617,2649,2652,2654,2654,2674,2676,2693,2699,2701,2701,2703,2705,2707,2728,2730,2736,2738,2739,2741,2745,2749,2749,2768,2768,2784,2784,2821,2828,2831,2832,2835,2856,2858,2864,2866,2867,2870,2873,2877,2877,2908,2909,2911,2913,2949,2954,2958,2960,2962,2965,2969,2970,2972,2972,2974,2975,2979,2980,2984,2986,2990,2997,2999,3001,3077,3084,3086,3088,3090,3112,3114,3123,3125,3129,3168,3169,
3205,3212,3214,3216,3218,3240,3242,3251,3253,3257,3294,3294,3296,3297,3333,3340,3342,3344,3346,3368,3370,3385,3424,3425,3461,3478,3482,3505,3507,3515,3517,3517,3520,3526,3585,3632,3634,3635,3648,3654,3713,3714,3716,3716,3719,3720,3722,3722,3725,3725,3732,3735,3737,3743,3745,3747,3749,3749,3751,3751,3754,3755,3757,3760,3762,3763,3773,3773,3776,3780,3782,3782,3804,3805,3840,3840,3904,3911,3913,3946,3976,3979,4096,4129,4131,4135,4137,4138,4176,4181,4256,4293,4304,4342,4352,4441,4447,4514,4520,4601,4608,
4614,4616,4678,4680,4680,4682,4685,4688,4694,4696,4696,4698,4701,4704,4742,4744,4744,4746,4749,4752,4782,4784,4784,4786,4789,4792,4798,4800,4800,4802,4805,4808,4814,4816,4822,4824,4846,4848,4878,4880,4880,4882,4885,4888,4894,4896,4934,4936,4954,5024,5108,5121,5740,5743,5750,5761,5786,5792,5866,6016,6067,6176,6263,6272,6312,7680,7835,7840,7929,7936,7957,7960,7965,7968,8005,8008,8013,8016,8023,8025,8025,8027,8027,8029,8029,8031,8061,8064,8116,8118,8124,8126,8126,8130,8132,8134,8140,8144,8147,8150,8155,
8160,8172,8178,8180,8182,8188,8319,8319,8450,8450,8455,8455,8458,8467,8469,8469,8473,8477,8484,8484,8486,8486,8488,8488,8490,8493,8495,8497,8499,8505,8544,8579,12293,12295,12321,12329,12337,12341,12344,12346,12353,12436,12445,12446,12449,12538,12540,12542,12549,12588,12593,12686,12704,12727,13312,13312,19893,19893,19968,19968,40869,40869,40960,42124,44032,44032,55203,55203,63744,64045,64256,64262,64275,64279,64285,64285,64287,64296,64298,64310,64312,64316,64318,64318,64320,64321,64323,64324,64326,
64433,64467,64829,64848,64911,64914,64967,65008,65019,65136,65138],v27447=[65140,65140,65142,65276,65313,65338,65345,65370,65382,65470,65474,65479,65482,65487,65490,65495,65498,65500],unicodeES3IdStart=v27446.concat(v27447),unicodeES3IdCont=[768,846,864,866,1155,1158,1425,1441,1443,1465,1467,1469,1471,1471,1473,1474,1476,1476,1611,1621,1632,1641,1648,1648,1750,1756,1759,1764,1767,1768,1770,1773,1776,1785,1809,1809,1840,1866,1958,1968,2305,2307,2364,2364,2366,2381,2385,2388,2402,2403,2406,2415,2433,
2435,2492,2492,2494,2500,2503,2504,2507,2509,2519,2519,2530,2531,2534,2543,2562,2562,2620,2620,2622,2626,2631,2632,2635,2637,2662,2673,2689,2691,2748,2748,2750,2757,2759,2761,2763,2765,2790,2799,2817,2819,2876,2876,2878,2883,2887,2888,2891,2893,2902,2903,2918,2927,2946,2947,3006,3010,3014,3016,3018,3021,3031,3031,3047,3055,3073,3075,3134,3140,3142,3144,3146,3149,3157,3158,3174,3183,3202,3203,3262,3268,3270,3272,3274,3277,3285,3286,3302,3311,3330,3331,3390,3395,3398,3400,3402,3405,3415,3415,3430,3439,
3458,3459,3530,3530,3535,3540,3542,3542,3544,3551,3570,3571,3633,3633,3636,3642,3655,3662,3664,3673,3761,3761,3764,3769,3771,3772,3784,3789,3792,3801,3864,3865,3872,3881,3893,3893,3895,3895,3897,3897,3902,3903,3953,3972,3974,3975,3984,3991,3993,4028,4038,4038,4140,4146,4150,4153,4160,4169,4182,4185,4969,4977,6068,6099,6112,6121,6160,6169,6313,6313,8255,8256,8400,8412,8417,8417,12330,12335,12441,12442,12539,12539,64286,64286,65056,65059,65075,65076,65101,65103,65296,65305,65343,65343,65381,65381],
v27448=[170,170,181,181,186,186,192,214,216,246,248,705,710,721,736,740,748,748,750,750,880,884,886,887,890,893,902,902,904,906,908,908,910,929,931,1013,1015,1153,1162,1319,1329,1366,1369,1369,1377,1415,1488,1514,1520,1522,1568,1610,1646,1647,1649,1747,1749,1749,1765,1766,1774,1775,1786,1788,1791,1791,1808,1808,1810,1839,1869,1957,1969,1969,1994,2026,2036,2037,2042,2042,2048,2069,2074,2074,2084,2084,2088,2088,2112,2136,2208,2208,2210,2220,2308,2361,2365,2365,2384,2384,2392,2401,2417,2423,2425,2431,
2437,2444,2447,2448,2451,2472,2474,2480,2482,2482,2486,2489,2493,2493,2510,2510,2524,2525,2527,2529,2544,2545,2565,2570,2575,2576,2579,2600,2602,2608,2610,2611,2613,2614,2616,2617,2649,2652,2654,2654,2674,2676,2693,2701,2703,2705,2707,2728,2730,2736,2738,2739,2741,2745,2749,2749,2768,2768,2784,2785,2821,2828,2831,2832,2835,2856,2858,2864,2866,2867,2869,2873,2877,2877,2908,2909,2911,2913,2929,2929,2947,2947,2949,2954,2958,2960,2962,2965,2969,2970,2972,2972,2974,2975,2979,2980,2984,2986,2990,3001,3024,
3024,3077,3084,3086,3088,3090,3112,3114,3123,3125,3129,3133,3133,3160,3161,3168,3169,3205,3212,3214,3216,3218,3240,3242,3251,3253,3257,3261,3261,3294,3294,3296,3297,3313,3314,3333,3340,3342,3344,3346,3386,3389,3389,3406,3406,3424,3425,3450,3455,3461,3478,3482,3505,3507,3515,3517,3517,3520,3526,3585,3632,3634,3635,3648,3654,3713,3714,3716,3716,3719,3720,3722,3722,3725,3725,3732,3735,3737,3743,3745,3747,3749,3749,3751,3751,3754,3755,3757,3760,3762,3763,3773,3773,3776,3780,3782,3782,3804,3807,3840,3840,
3904,3911,3913,3948,3976,3980,4096,4138,4159,4159,4176,4181,4186,4189,4193,4193,4197,4198,4206,4208,4213,4225,4238,4238,4256,4293,4295,4295,4301,4301,4304,4346,4348,4680,4682,4685,4688,4694,4696,4696,4698,4701,4704,4744,4746,4749,4752,4784,4786,4789,4792,4798,4800,4800,4802,4805,4808,4822,4824,4880,4882,4885,4888,4954,4992,5007,5024,5108,5121,5740,5743,5759,5761,5786,5792,5866,5870,5872,5888,5900,5902,5905,5920,5937,5952,5969,5984,5996,5998,6E3,6016,6067,6103,6103,6108,6108,6176,6263,6272,6312,6314,
6314,6320,6389,6400,6428,6480,6509,6512,6516,6528,6571,6593,6599,6656,6678,6688,6740,6823,6823,6917,6963,6981,6987,7043,7072,7086,7087,7098,7141,7168,7203,7245,7247,7258,7293,7401,7404,7406,7409,7413,7414,7424,7615,7680,7957,7960,7965,7968,8005,8008,8013,8016,8023,8025,8025,8027,8027,8029,8029,8031,8061,8064,8116,8118,8124,8126,8126,8130,8132,8134,8140,8144,8147,8150,8155,8160,8172,8178,8180,8182,8188,8305,8305,8319,8319,8336,8348,8450,8450,8455,8455],v27449=[8458,8467,8469,8469,8473,8477,8484,8484,
8486,8486,8488,8488,8490,8493,8495,8505,8508,8511,8517,8521,8526,8526,8544,8584,11264,11310,11312,11358,11360,11492,11499,11502,11506,11507,11520,11557,11559,11559,11565,11565,11568,11623,11631,11631,11648,11670,11680,11686,11688,11694,11696,11702,11704,11710,11712,11718,11720,11726,11728,11734,11736,11742,11823,11823,12293,12295,12321,12329,12337,12341,12344,12348,12353,12438,12445,12447,12449,12538,12540,12543,12549,12589,12593,12686,12704,12730,12784,12799,13312,13312,19893,19893,19968,19968,40908,
40908,40960,42124,42192,42237,42240,42508,42512,42527,42538,42539,42560,42606,42623,42647,42656,42735,42775,42783,42786,42888,42891,42894,42896,42899,42912,42922,43E3,43009,43011,43013,43015,43018,43020,43042,43072,43123,43138,43187,43250,43255,43259,43259,43274,43301,43312,43334,43360,43388,43396,43442,43471,43471,43520,43560,43584,43586,43588,43595,43616,43638,43642,43642,43648,43695,43697,43697,43701,43702,43705,43709,43712,43712,43714,43714,43739,43741,43744,43754,43762,43764,43777,43782,43785,
43790,43793,43798,43808,43814,43816,43822,43968,44002,44032,44032,55203,55203,55216,55238,55243,55291,63744,64109,64112,64217,64256,64262,64275,64279,64285,64285,64287,64296,64298,64310,64312,64316,64318,64318,64320,64321,64323,64324,64326,64433,64467,64829,64848,64911,64914,64967,65008,65019,65136,65140,65142,65276,65313,65338,65345,65370,65382,65470,65474,65479,65482,65487,65490,65495,65498,65500],unicodeES5IdStart=v27448.concat(v27449),unicodeES5IdCont=[768,879,1155,1159,1425,1469,1471,1471,1473,
1474,1476,1477,1479,1479,1552,1562,1611,1641,1648,1648,1750,1756,1759,1764,1767,1768,1770,1773,1776,1785,1809,1809,1840,1866,1958,1968,1984,1993,2027,2035,2070,2073,2075,2083,2085,2087,2089,2093,2137,2139,2276,2302,2304,2307,2362,2364,2366,2383,2385,2391,2402,2403,2406,2415,2433,2435,2492,2492,2494,2500,2503,2504,2507,2509,2519,2519,2530,2531,2534,2543,2561,2563,2620,2620,2622,2626,2631,2632,2635,2637,2641,2641,2662,2673,2677,2677,2689,2691,2748,2748,2750,2757,2759,2761,2763,2765,2786,2787,2790,2799,
2817,2819,2876,2876,2878,2884,2887,2888,2891,2893,2902,2903,2914,2915,2918,2927,2946,2946,3006,3010,3014,3016,3018,3021,3031,3031,3046,3055,3073,3075,3134,3140,3142,3144,3146,3149,3157,3158,3170,3171,3174,3183,3202,3203,3260,3260,3262,3268,3270,3272,3274,3277,3285,3286,3298,3299,3302,3311,3330,3331,3390,3396,3398,3400,3402,3405,3415,3415,3426,3427,3430,3439,3458,3459,3530,3530,3535,3540,3542,3542,3544,3551,3570,3571,3633,3633,3636,3642,3655,3662,3664,3673,3761,3761,3764,3769,3771,3772,3784,3789,3792,
3801,3864,3865,3872,3881,3893,3893,3895,3895,3897,3897,3902,3903,3953,3972,3974,3975,3981,3991,3993,4028,4038,4038,4139,4158,4160,4169,4182,4185,4190,4192,4194,4196,4199,4205,4209,4212,4226,4237,4239,4253,4957,4959,5906,5908,5938,5940,5970,5971,6002,6003,6068,6099,6109,6109,6112,6121,6155,6157,6160,6169,6313,6313,6432,6443,6448,6459,6470,6479,6576,6592,6600,6601,6608,6617,6679,6683,6741,6750,6752,6780,6783,6793,6800,6809,6912,6916,6964,6980,6992,7001,7019,7027,7040,7042,7073,7085,7088,7097,7142,7155,
7204,7223,7232,7241,7248,7257,7376,7378,7380,7400,7405,7405,7410,7412,7616,7654,7676,7679,8204,8205,8255,8256,8276,8276,8400,8412,8417,8417,8421,8432,11503,11505,11647,11647,11744,11775,12330,12335,12441,12442,42528,42537,42607,42607,42612,42621,42655,42655,42736,42737,43010,43010,43014,43014,43019,43019,43043,43047,43136,43137,43188,43204,43216,43225,43232,43249,43264,43273,43302,43309,43335,43347,43392,43395,43443,43456,43472,43481,43561,43574,43587,43587,43596,43597,43600,43609,43643,43643,43696,
43696,43698,43700,43703,43704,43710,43711,43713,43713,43755,43759,43765,43766,44003,44010,44012,44013,44016,44025,64286,64286,65024,65039,65056,65062,65075,65076,65101,65103,65296,65305,65343,65343];TypeScript.LexLookUpUnicodeMap=LexLookUpUnicodeMap;TypeScript.LexIsUnicodeDigit=LexIsUnicodeDigit;TypeScript.LexIsUnicodeIdStart=LexIsUnicodeIdStart;TypeScript.LexInitialize=LexInitialize;TypeScript.LexAdjustIndent=LexAdjustIndent;TypeScript.LexIsIdentifierStartChar=LexIsIdentifierStartChar;TypeScript.LexIsDigit=
LexIsDigit;TypeScript.LexIsIdentifierChar=LexIsIdentifierChar;TypeScript.LexMatchingOpen=LexMatchingOpen;var v16032=TypeScript.NumberScanState;v16032||(v16032=TypeScript.NumberScanState={});v600(v16032);var NumberScanState=TypeScript.NumberScanState,v16033=TypeScript.LexState;v16033||(v16033=TypeScript.LexState={});v601(v16033);var LexState=TypeScript.LexState,v16034=TypeScript.LexMode;v16034||(v16034=TypeScript.LexMode={});v602(v16034);var LexMode=TypeScript.LexMode,v16035=TypeScript.CommentStyle;
v16035||(v16035=TypeScript.CommentStyle={});v603(v16035);var StringSourceText=v606();TypeScript.StringSourceText=StringSourceText;var SourceTextSegment=v609();TypeScript.SourceTextSegment=SourceTextSegment;var AggerateSourceTextSegment=v612();TypeScript.AggerateSourceTextSegment=AggerateSourceTextSegment;var ScannerTextStream=v618();TypeScript.ScannerTextStream=ScannerTextStream;var SavedTokens=v633();TypeScript.SavedTokens=SavedTokens;var Scanner=v674();TypeScript.Scanner=Scanner;TypeScript.convertTokToIDName=
convertTokToIDName;TypeScript.convertTokToID=convertTokToID;TypeScript.getLineNumberFromPosition=getLineNumberFromPosition;TypeScript.getSourceLineColFromMap=getSourceLineColFromMap;TypeScript.getLineColumnFromPosition=getLineColumnFromPosition;TypeScript.getPositionFromLineColumn=getPositionFromLineColumn;TypeScript.isPrimitiveTypeToken=isPrimitiveTypeToken;TypeScript.isModifier=isModifier}
function v599(){var TypeScript=v18806;function v598(){function v597(s){this.builder+=s;s=this.outfile;JAM.call(s.WriteLine,s,[this.builder]);this.builder=""}function v596(s){this.builder+=s}function v595(){if(0<this.builder.length){var v7940=TypeScript.CompilerDiagnostics;JAM.call(v7940.Alert,v7940,[this.builder])}var v7940=this.indentStrings,v7944=this.indentAmt;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v7940=v7940[v7944];if(void 0===v7940){for(var v7940="",v7944=0,v7945=v7944<
this.indentAmt;v7945;)v7940+=this.indent1,v7944+=1,v7945=v7944<this.indentAmt;JAM.set(this.indentStrings,this.indentAmt,v7940)}this.builder+=v7940}function v594(){this.indentAmt-=1}function v593(){this.indentAmt+=1}function PrintContext(outfile,parser){this.outfile=outfile;this.parser=parser;this.builder="";this.indent1="  ";this.indentStrings=[];this.indentAmt=0}PrintContext.prototype.increaseIndent=v593;PrintContext.prototype.decreaseIndent=v594;PrintContext.prototype.startLine=v595;PrintContext.prototype.write=
v596;PrintContext.prototype.writeLine=v597;return PrintContext}function prePrintAST(ast,parent,walker){parent=walker.state;JAM.call(ast.print,ast,[parent]);parent.increaseIndent();return ast}function postPrintAST(ast,parent,walker){parent=walker.state;parent.decreaseIndent();return ast}var PrintContext=v598();TypeScript.PrintContext=PrintContext;TypeScript.prePrintAST=prePrintAST;TypeScript.postPrintAST=postPrintAST}
function v592(){var TypeScript=v18805;function v591(){function v590(sourceText,filename,unitIndex,allowedElements){function v589(message){return JAM.call(_this.reportParseError,_this,[message])}"undefined"===typeof allowedElements&&(allowedElements=TypeScript.AllowedElements.Global);var _this=this;this.ambientModule=!1;this.topLevel=!0;this.requiresExtendsBlock=this.hasTopLevelImportOrExport=!1;this.fname=filename;this.currentUnitIndex=unitIndex;this.amdDependencies=[];this.scanner.resetComments();
var v7957=this.scanner;JAM.call(v7957.setErrorHandler,v7957,[v589]);v7957=this.scanner;JAM.call(v7957.setSourceText,v7957,[sourceText,TypeScript.LexMode.File]);sourceText=this.scanner.leftCurlyCount;var v7957=this.scanner.rightCurlyCount,minChar=this.scanner.pos,v27083=this.scanner.scan();this.currentToken=v27083;this.pushDeclLists();v27083=new TypeScript.ASTList;v27083.minChar=minChar;this.state=ParseState.StartScript;var v7965=JAM.call(TypeScript.isDSTRFile,TypeScript,[filename]);v7965||(v7965=
JAM.call(TypeScript.isDTSFile,TypeScript,[filename]));for(this.parsingDeclareFile=v7965;;){JAM.call(this.parseStatementList,this,[TypeScript.ErrorRecoverySet.EOF|TypeScript.ErrorRecoverySet.Func,v27083,!0,!1,allowedElements,TypeScript.Modifiers.None]);if(this.currentToken.tokenId===TypeScript.TokenID.EndOfFile)break;var v7965=TypeScript.tokenTable,v7970=this.currentToken.tokenId;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v7965=v7965[v7970];JAM.call(this.reportParseError,this,
["Unexpected statement block terminator '"+v7965.text+"'"]);this.currentToken=v7965=this.scanner.scan()}this.state=ParseState.EndScript;v27083.limChar=this.scanner.pos;allowedElements=null;if(v7965=TypeScript.moduleGenTarget!=TypeScript.ModuleGenTarget.Local)v7965=this.hasTopLevelImportOrExport;v7965&&(v7965=JAM.call(TypeScript.switchToForwardSlashes,TypeScript,[filename]),allowedElements=JAM.new(TypeScript.Identifier,[v7965]),allowedElements=JAM.new(TypeScript.ModuleDeclaration,[allowedElements,
v27083,this.topVarList(),this.topScopeList(),null]),allowedElements.modFlags|=TypeScript.ModuleFlags.IsDynamic,allowedElements.modFlags|=TypeScript.ModuleFlags.IsWholeFile,allowedElements.modFlags|=TypeScript.ModuleFlags.Exported,this.parsingDeclareFile&&(allowedElements.modFlags|=TypeScript.ModuleFlags.Ambient),allowedElements.minChar=minChar,allowedElements.limChar=this.scanner.pos,v27083=allowedElements,v7965=JAM.call(TypeScript.getPrettyName,TypeScript,[v7965]),v27083.prettyName=v7965,allowedElements.containsUnicodeChar=
this.scanner.seenUnicodeChar,allowedElements.containsUnicodeCharInComment=this.scanner.seenUnicodeCharInComment,allowedElements.amdDependencies=this.amdDependencies,v27083=new TypeScript.ASTList,v27083.minChar=allowedElements.minChar,v27083.limChar=allowedElements.limChar,JAM.call(v27083.append,v27083,[allowedElements]));v7965=JAM.new(TypeScript.Script,[this.topVarList(),this.topScopeList()]);v7965.bod=v27083;this.popDeclLists();v7965.minChar=minChar;v7965.limChar=this.scanner.pos;minChar=v7965;filename=
JAM.new(TypeScript.LocationInfo,[filename,this.scanner.lineMap,unitIndex]);minChar.locationInfo=filename;v7965.leftCurlyCount=this.scanner.leftCurlyCount-sourceText;v7965.rightCurlyCount=this.scanner.rightCurlyCount-v7957;v7965.isDeclareFile=this.parsingDeclareFile;v7965.topLevelMod=allowedElements;v7965.containsUnicodeChar=this.scanner.seenUnicodeChar;v7965.containsUnicodeCharInComment=this.scanner.seenUnicodeCharInComment;v7965.requiresExtendsBlock=this.requiresExtendsBlock;return v7965}function v588(sourceText,
filename,unitIndex){var svGenTarget=TypeScript.moduleGenTarget;try{TypeScript.moduleGenTarget=TypeScript.ModuleGenTarget.Local;var script=JAM.call(this.parse,this,[sourceText,filename,unitIndex,TypeScript.AllowedElements.QuickParse]);return JAM.new(QuickParseResult,[script,this.scanner.lexState])}finally{TypeScript.moduleGenTarget=svGenTarget}}function v587(errorRecoverySet,statements,sourceElms,noLeadingCase,allowedElements,parentModifiers){var directivePrologue=sourceElms;statements.minChar=this.scanner.startPos;
var limChar=this.scanner.pos,innerStmts=(allowedElements&TypeScript.AllowedElements.ModuleDeclarations)==TypeScript.AllowedElements.None,classNope=(allowedElements&TypeScript.AllowedElements.ClassDeclarations)==TypeScript.AllowedElements.None;errorRecoverySet=errorRecoverySet|TypeScript.ErrorRecoverySet.TypeScriptS|TypeScript.ErrorRecoverySet.RCurly;this.state=ParseState.StartStatementList;sourceElms=this.strictMode;for(this.nestingLevel+=1;;){var v16076=this.currentToken.tokenId==TypeScript.TokenID.CloseBrace;
if(!v16076){if(v16076=noLeadingCase)(v16076=this.currentToken.tokenId==TypeScript.TokenID.Case)||(v16076=this.currentToken.tokenId==TypeScript.TokenID.Default);v16076||((v16076=innerStmts)&&(v16076=this.currentToken.tokenId==TypeScript.TokenID.Export),v16076||((v16076=classNope)&&(v16076=this.currentToken.tokenId==TypeScript.TokenID.Class),v16076||(v16076=this.currentToken.tokenId==TypeScript.TokenID.EndOfFile)))}if(v16076){this.state=ParseState.EndStmtList;statements.limChar=limChar;0==statements.members.length?
(errorRecoverySet=statements,statements=this.parseComments(),errorRecoverySet.preComments=statements):(errorRecoverySet=statements,statements=this.parseComments(),errorRecoverySet.postComments=statements);this.strictMode=sourceElms;this.nestingLevel-=1;break}if(v16076=JAM.call(this.parseStatement,this,[errorRecoverySet&~(TypeScript.ErrorRecoverySet.Else|TypeScript.ErrorRecoverySet.RParen|TypeScript.ErrorRecoverySet.Catch|TypeScript.ErrorRecoverySet.Colon),allowedElements,parentModifiers])){var limChar=
v16076,v27089=JAM.call(this.combineComments,this,[v16076.postComments,JAM.call(this.parseCommentsForLine,this,[this.scanner.prevLine])]);limChar.postComments=v27089;JAM.call(statements.append,statements,[v16076]);limChar=v16076.limChar;directivePrologue&&(v16076.nodeType==TypeScript.NodeType.QString?'"use strict"'==v16076.text?(statements.flags|=TypeScript.ASTFlags.StrictMode,this.strictMode=!0):directivePrologue=!1:directivePrologue=!1)}}}function v586(ast){var nt=ast.nodeType,v8011=nt==TypeScript.NodeType.ClassDeclaration;
v8011||(v8011=nt==TypeScript.NodeType.ImportDeclaration,v8011||(v8011=nt==TypeScript.NodeType.InterfaceDeclaration,v8011||(v8011=nt==TypeScript.NodeType.ModuleDeclaration,v8011||(v8011=nt==TypeScript.NodeType.Empty,v8011||(v8011=nt==TypeScript.NodeType.VarDecl,v8011||((v8011=nt==TypeScript.NodeType.Block)&&(v8011=!ast.isStatementBlock),v8011||((nt=nt==TypeScript.NodeType.FuncDecl)&&(nt=ast.isMethod()),v8011=nt)))))));return v8011}function v585(errorRecoverySet,allowedElements,parentModifiers){function isAmbient(){var v8012=
JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Ambient]);v8012||(v8012=JAM.call(TypeScript.hasFlag,TypeScript,[parentModifiers,TypeScript.Modifiers.Ambient]));return v8012}function mayNotBeExported(){JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Exported])&&JAM.call(this.reportError,this,["Statement may not be exported"])}var ast=null,labelList=null,temp,modifiers=TypeScript.Modifiers.None,minChar=this.scanner.startPos,forInOk=!1,needTerminator=!1,
fnOrVar=null,preComments=this.parseComments();for(this.state=ParseState.StartStatement;;){switch(this.currentToken.tokenId){case TypeScript.TokenID.EndOfFile:ast=JAM.new(TypeScript.AST,[TypeScript.NodeType.Error]);ast.minChar=minChar;ast.limChar=this.scanner.pos;break;case TypeScript.TokenID.Function:var v16096=this.parsingDeclareFile;if(!v16096){var v20920=isAmbient();v20920||(v20920=this.ambientModule);v16096=v20920}if(v16096){var v27090=this.scanner.scan();this.currentToken=v27090;fnOrVar=JAM.call(this.parsePropertyDeclaration,
this,[errorRecoverySet|TypeScript.ErrorRecoverySet.SColon,modifiers,!0,!1]);if(fnOrVar.nodeType==TypeScript.NodeType.VarDecl)JAM.call(this.reportParseError,this,["function keyword can only introduce function declaration"]);else{var v16100=fnOrVar.nodeType==TypeScript.NodeType.FuncDecl;v16100&&(v16100=TypeScript.FncFlags.IsFatArrowFunction);v16100&&(needTerminator=!0)}var ast=fnOrVar,v16101=this.parsingDeclareFile;if(!v16101){var v20926=this.ambientModule;v20926&&(v20926=ast.nodeType==TypeScript.NodeType.FuncDecl);
v16101=v20926}v16101&&(ast.fncFlags|=TypeScript.FncFlags.Exported)}else ast=JAM.call(this.parseFncDecl,this,[errorRecoverySet,!0,!1,!1,null,!1,!1,isAmbient(),modifiers,null,!0]),JAM.call(TypeScript.hasFlag,TypeScript,[ast.fncFlags,TypeScript.FncFlags.IsFatArrowFunction])&&(needTerminator=!0),this.ambientModule&&JAM.call(this.reportParseError,this,["function declaration not permitted within ambient module"]),JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Exported])&&(ast.fncFlags|=
TypeScript.FncFlags.Exported);break;case TypeScript.TokenID.Module:if((allowedElements&TypeScript.AllowedElements.ModuleDeclarations)==TypeScript.AllowedElements.None){JAM.call(this.reportParseError,this,["module not allowed in this context"]);var v27091=this.scanner.scan();this.currentToken=v27091;ast=JAM.new(TypeScript.AST,[TypeScript.NodeType.Error]);ast.minChar=minChar;var v8032=ast,v27092=this.scanner.lastTokenLimChar();v8032.limChar=v27092}else ast=JAM.call(this.parseModuleDecl,this,[errorRecoverySet,
modifiers,preComments]),preComments=null;break;case TypeScript.TokenID.Import:if((allowedElements&TypeScript.AllowedElements.ModuleDeclarations)==TypeScript.AllowedElements.None){JAM.call(this.reportParseError,this,["module not allowed in this context"]);var v27093=this.scanner.scan();this.currentToken=v27093;ast=JAM.new(TypeScript.AST,[TypeScript.NodeType.Error]);ast.minChar=minChar;var v8037=ast,v27094=this.scanner.lastTokenLimChar();v8037.limChar=v27094}else JAM.call(TypeScript.hasFlag,TypeScript,
[modifiers,TypeScript.Modifiers.Exported])&&JAM.call(this.reportParseError,this,["export keyword not permitted on import declaration"]),ast=JAM.call(this.parseImportDeclaration,this,[errorRecoverySet,modifiers]),needTerminator=!0;break;case TypeScript.TokenID.Export:if((allowedElements&TypeScript.AllowedElements.ModuleDeclarations)==TypeScript.AllowedElements.None){JAM.call(this.reportParseError,this,["'export' statements are only allowed at the global and module levels"]);var v27095=this.scanner.scan();
this.currentToken=v27095;ast=JAM.new(TypeScript.AST,[TypeScript.NodeType.Error]);ast.minChar=minChar;var v8043=ast,v27096=this.scanner.lastTokenLimChar();v8043.limChar=v27096}this.topLevel&&(this.hasTopLevelImportOrExport=!0);var modifiers=modifiers|TypeScript.Modifiers.Exported,v27097=this.scanner.scan();this.currentToken=v27097;break;case TypeScript.TokenID.Private:var modifiers=modifiers|TypeScript.Modifiers.Private,v27098=this.scanner.scan();this.currentToken=v27098;if(this.parsingClassConstructorDefinition){this.inferPropertiesFromThisAssignment||
JAM.call(this.reportParseError,this,["Property declarations are not permitted within constructor bodies"]);var minChar=this.scanner.pos,v16125=this.inferPropertiesFromThisAssignment;if(v16125){var v20941=this.currentToken.tokenId!=TypeScript.TokenID.This;if(!v20941)var v27099=this.scanner.scan(),v20941=(this.currentToken=v27099).tokenId!=TypeScript.TokenID.Dot;v16125=v20941}if(v16125){JAM.call(this.reportParseError,this,["Expected 'this.' for property declaration"]);var v27100=this.scanner.scan();
this.currentToken=v27100;ast=JAM.new(TypeScript.AST,[TypeScript.NodeType.Error]);ast.minChar=minChar;var v8053=ast,v27101=this.scanner.lastTokenLimChar();v8053.limChar=v27101}else{var v27102=this.scanner.scan();this.currentToken=v27102;var v8055=TypeScript.Identifier,id=JAM.call(v8055.fromToken,v8055,[this.currentToken]);id.minChar=this.scanner.startPos;id.limChar=this.scanner.pos;var v27103=this.scanner.scan();this.currentToken=v27103;ast=JAM.call(this.parseClassMemberVariableDeclaration,this,[id,
minChar,this.parsingClassConstructorDefinition,errorRecoverySet,modifiers])}}else if(this.currentToken.tokenId!=TypeScript.TokenID.Interface){if(this.currentToken.tokenId==TypeScript.TokenID.Get){this.prevIDTok=this.currentToken;var v27104=this.scanner.scan();this.currentToken=v27104;TypeScript.codeGenTarget<TypeScript.CodeGenTarget.ES5&&JAM.call(this.reportParseError,this,["Property accessors are only available when targeting ES5 or greater"]);var v16134=this.currentToken.tokenId==TypeScript.TokenID.Identifier;
v16134||(v16134=JAM.call(TypeScript.convertTokToID,TypeScript,[this.currentToken,this.strictMode]));v16134&&(modifiers|=TypeScript.Modifiers.Getter,this.prevIDTok=null)}else if(this.currentToken.tokenId==TypeScript.TokenID.Set){this.prevIDTok=this.currentToken;var v27105=this.scanner.scan();this.currentToken=v27105;TypeScript.codeGenTarget<TypeScript.CodeGenTarget.ES5&&JAM.call(this.reportParseError,this,["Property accessors are only available when targeting ES5 or greater"]);var v16140=this.currentToken.tokenId==
TypeScript.TokenID.Identifier;v16140||(v16140=JAM.call(TypeScript.convertTokToID,TypeScript,[this.currentToken,this.strictMode]));v16140&&(modifiers|=TypeScript.Modifiers.Setter,this.prevIDTok=null)}var fnOrVar=JAM.call(this.parsePropertyDeclaration,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.SColon,modifiers,isAmbient(),!1]),v16143=fnOrVar.nodeType==TypeScript.NodeType.VarDecl;if(!v16143){var v20965=fnOrVar.nodeType==TypeScript.NodeType.FuncDecl;v20965&&(v20965=JAM.call(TypeScript.hasFlag,
TypeScript,[fnOrVar.fncFlags,TypeScript.FncFlags.IsFatArrowFunction]));v16143=v20965}v16143&&(needTerminator=!0);ast=fnOrVar}break;case TypeScript.TokenID.Public:if(this.parsingClassConstructorDefinition){this.inferPropertiesFromThisAssignment||JAM.call(this.reportParseError,this,["Property declarations are not permitted within constructor bodies"]);var v27106=this.scanner.scan();this.currentToken=v27106;var minChar=this.scanner.pos,modifiers=modifiers|TypeScript.Modifiers.Public,v16146=this.inferPropertiesFromThisAssignment;
if(v16146){var v20968=this.currentToken.tokenId!=TypeScript.TokenID.This;if(!v20968)var v27107=this.scanner.scan(),v20968=(this.currentToken=v27107).tokenId!=TypeScript.TokenID.Dot;v16146=v20968}if(v16146){JAM.call(this.reportParseError,this,["Expected 'this.' for property declaration"]);var v27108=this.scanner.scan();this.currentToken=v27108;ast=JAM.new(TypeScript.AST,[TypeScript.NodeType.Error]);ast.minChar=minChar;var v8081=ast,v27109=this.scanner.lastTokenLimChar();v8081.limChar=v27109}else{var v27110=
this.scanner.scan();this.currentToken=v27110;var v8083=TypeScript.Identifier,id=JAM.call(v8083.fromToken,v8083,[this.currentToken]);id.minChar=this.scanner.startPos;id.limChar=this.scanner.pos;var v27111=this.scanner.scan();this.currentToken=v27111;ast=JAM.call(this.parseClassMemberVariableDeclaration,this,[id,minChar,this.parsingClassConstructorDefinition,errorRecoverySet,modifiers])}}else if((allowedElements&TypeScript.AllowedElements.Properties)==TypeScript.AllowedElements.None){JAM.call(this.reportParseError,
this,["'property' statements are only allowed within classes"]);var v27112=this.scanner.scan();this.currentToken=v27112;ast=JAM.new(TypeScript.AST,[TypeScript.NodeType.Error]);ast.minChar=minChar;var v8093=ast,v27113=this.scanner.lastTokenLimChar();v8093.limChar=v27113}else{var modifiers=modifiers|TypeScript.Modifiers.Public,v27114=this.scanner.scan();this.currentToken=v27114;if(this.currentToken.tokenId==TypeScript.TokenID.Get){this.prevIDTok=this.currentToken;var v27115=this.scanner.scan();this.currentToken=
v27115;TypeScript.codeGenTarget<TypeScript.CodeGenTarget.ES5&&JAM.call(this.reportParseError,this,["Property accessors are only available when targeting ES5 or greater"]);var v16158=this.currentToken.tokenId==TypeScript.TokenID.Identifier;v16158||(v16158=JAM.call(TypeScript.convertTokToID,TypeScript,[this.currentToken,this.strictMode]));v16158&&(modifiers|=TypeScript.Modifiers.Getter,this.prevIDTok=null)}else if(this.currentToken.tokenId==TypeScript.TokenID.Set){this.prevIDTok=this.currentToken;var v27116=
this.scanner.scan();this.currentToken=v27116;TypeScript.codeGenTarget<TypeScript.CodeGenTarget.ES5&&JAM.call(this.reportParseError,this,["Property accessors are only available when targeting ES5 or greater"]);var v16164=this.currentToken.tokenId==TypeScript.TokenID.Identifier;v16164||(v16164=JAM.call(TypeScript.convertTokToID,TypeScript,[this.currentToken,this.strictMode]));v16164&&(modifiers|=TypeScript.Modifiers.Setter,this.prevIDTok=null)}var fnOrVar=JAM.call(this.parsePropertyDeclaration,this,
[errorRecoverySet|TypeScript.ErrorRecoverySet.SColon,modifiers,isAmbient(),!1]),v16167=fnOrVar.nodeType==TypeScript.NodeType.VarDecl;if(!v16167){var v20993=fnOrVar.nodeType==TypeScript.NodeType.FuncDecl;v20993&&(v20993=JAM.call(TypeScript.hasFlag,TypeScript,[fnOrVar.fncFlags,TypeScript.FncFlags.IsFatArrowFunction]));v16167=v20993}v16167&&(needTerminator=!0);ast=fnOrVar}break;case TypeScript.TokenID.Declare:allowedElements&TypeScript.AllowedElements.AmbientDeclarations||JAM.call(this.reportParseError,
this,["Ambient declarations are only allowed at the top-level or module scopes"]);var v16169=!this.parsingDeclareFile;v16169&&(v16169=JAM.call(TypeScript.hasFlag,TypeScript,[parentModifiers,TypeScript.Modifiers.Ambient]));v16169&&JAM.call(this.reportParseError,this,["Duplicate ambient declaration in this context. (Is the enclosing module or class already ambient?)"]);var modifiers=modifiers|TypeScript.Modifiers.Ambient,v27117=this.scanner.scan();this.currentToken=v27117;break;case TypeScript.TokenID.Class:if((allowedElements&
TypeScript.AllowedElements.ClassDeclarations)==TypeScript.AllowedElements.None){JAM.call(this.reportParseError,this,["class not allowed in this context"]);var v27118=this.scanner.scan();this.currentToken=v27118;ast=JAM.new(TypeScript.AST,[TypeScript.NodeType.Error]);ast.minChar=minChar;var v8114=ast,v27119=this.scanner.lastTokenLimChar();v8114.limChar=v27119}else ast=JAM.call(this.parseClassDecl,this,[errorRecoverySet,minChar,modifiers]);break;case TypeScript.TokenID.Interface:if((allowedElements&
TypeScript.AllowedElements.InterfaceDeclarations)==TypeScript.AllowedElements.None){JAM.call(this.reportParseError,this,["interface not allowed in this context"]);var v27120=this.scanner.scan();this.currentToken=v27120;ast=JAM.new(TypeScript.AST,[TypeScript.NodeType.Error]);ast.minChar=minChar;var v8119=ast,v27121=this.scanner.lastTokenLimChar();v8119.limChar=v27121}else ast=JAM.call(this.parseInterfaceDecl,this,[errorRecoverySet,modifiers]);break;case TypeScript.TokenID.Var:var declAst=JAM.call(this.parseVariableDeclaration,
this,[errorRecoverySet|TypeScript.ErrorRecoverySet.StmtStart,modifiers,!0,!1]),ast=declAst.nodeType==TypeScript.NodeType.VarDecl?declAst:JAM.new(TypeScript.Block,[declAst,!1]),needTerminator=!0;break;case TypeScript.TokenID.Static:null==this.currentClassDecl&&JAM.call(this.reportParseError,this,["Statics may only be class members"]);mayNotBeExported();var modifiers=modifiers|TypeScript.Modifiers.Public,v27122=this.scanner.scan();this.currentToken=v27122;if(this.currentToken.tokenId==TypeScript.TokenID.Get){this.prevIDTok=
this.currentToken;var v27123=this.scanner.scan();this.currentToken=v27123;TypeScript.codeGenTarget<TypeScript.CodeGenTarget.ES5&&JAM.call(this.reportParseError,this,["Property accessors are only available when targeting ES5 or greater"]);var v16188=this.currentToken.tokenId==TypeScript.TokenID.Identifier;v16188||(v16188=JAM.call(TypeScript.convertTokToID,TypeScript,[this.currentToken,this.strictMode]));v16188&&(modifiers|=TypeScript.Modifiers.Getter,this.prevIDTok=null)}else if(this.currentToken.tokenId==
TypeScript.TokenID.Set){var v27124=this.scanner.scan();this.currentToken=v27124;TypeScript.codeGenTarget<TypeScript.CodeGenTarget.ES5&&JAM.call(this.reportParseError,this,["Property accessors are only available when targeting ES5 or greater"]);var v16194=this.currentToken.tokenId==TypeScript.TokenID.Identifier;v16194||(v16194=JAM.call(TypeScript.convertTokToID,TypeScript,[this.currentToken,this.strictMode]));v16194&&(modifiers|=TypeScript.Modifiers.Setter)}isAmbient()&&(modifiers|=TypeScript.Modifiers.Ambient);
var v8135=errorRecoverySet|TypeScript.ErrorRecoverySet.SColon,v16198=this.parsingDeclareFile;v16198||(v16198=(modifiers&TypeScript.Modifiers.Ambient)!=TypeScript.Modifiers.None);var fnOrVar=JAM.call(this.parsePropertyDeclaration,this,[v8135,modifiers,v16198,!0]),staticsList=this.topStaticsList(),v16199=staticsList;v16199&&(v16199=fnOrVar.nodeType==TypeScript.NodeType.VarDecl);v16199&&JAM.call(staticsList.append,staticsList,[fnOrVar]);var v16200=fnOrVar.nodeType==TypeScript.NodeType.VarDecl;if(!v16200){var v21033=
fnOrVar.nodeType==TypeScript.NodeType.FuncDecl;v21033&&(v21033=JAM.call(TypeScript.hasFlag,TypeScript,[fnOrVar.fncFlags,TypeScript.FncFlags.IsFatArrowFunction]));v16200=v21033}v16200&&(needTerminator=!0);ast=fnOrVar;break;case TypeScript.TokenID.For:mayNotBeExported();modifiers!=TypeScript.Modifiers.None&&JAM.call(this.reportParseError,this,["syntax error: for statement does not take modifiers"]);minChar=this.scanner.startPos;JAM.call(this.checkNextToken,this,[TypeScript.TokenID.OpenParen,errorRecoverySet|
TypeScript.ErrorRecoverySet.ExprStart|TypeScript.ErrorRecoverySet.Var]);this.state=ParseState.ForInit;forInOk=!0;switch(this.currentToken.tokenId){case TypeScript.TokenID.Var:temp=JAM.call(this.parseVariableDeclaration,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.SColon|TypeScript.ErrorRecoverySet.In,TypeScript.Modifiers.None,!1,!1]);break;case TypeScript.TokenID.Semicolon:temp=null;this.state=ParseState.ForCondStart;break;default:temp=JAM.call(this.parseExpr,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.SColon|
TypeScript.ErrorRecoverySet.In,TypeScript.OperatorPrecedence.None,!1,TypeContext.NoTypes])}this.state=ParseState.ForInitAfterVar;if(this.currentToken.tokenId==TypeScript.TokenID.In){var v16214=null==temp;v16214||(v16214=!forInOk);if(v16214)JAM.call(this.reportParseError,this,["malformed for statement"]),this.errorRecovery&&(JAM.call(this.skip,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.StmtStart]),ast=JAM.new(TypeScript.AST,[TypeScript.NodeType.Empty]),ast.flags|=TypeScript.ASTFlags.Error);
else{var v27125=this.scanner.scan();this.currentToken=v27125;var forInStmt=JAM.new(TypeScript.ForInStatement,[temp,JAM.call(this.parseExpr,this,[TypeScript.ErrorRecoverySet.RParen|errorRecoverySet,TypeScript.OperatorPrecedence.Comma,!1,TypeContext.NoTypes])]);forInStmt.limChar=this.scanner.pos;forInStmt.statement.minChar=minChar;forInStmt.statement.limChar=this.scanner.pos;JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.CloseParen,TypeScript.ErrorRecoverySet.StmtStart|errorRecoverySet]);
JAM.call(this.pushStmt,this,[forInStmt,labelList]);var v8161=forInStmt,v27126=JAM.call(this.parseStatement,this,[errorRecoverySet,allowedElements,parentModifiers]);v8161.body=v27126;this.popStmt();forInStmt.minChar=minChar;ast=forInStmt}}else{var forStmt=JAM.new(TypeScript.ForStatement,[temp]);forStmt.minChar=minChar;JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.Semicolon,errorRecoverySet]);if(this.currentToken.tokenId==TypeScript.TokenID.Semicolon)forStmt.cond=null;else{var v8165=forStmt,
v27127=JAM.call(this.parseExpr,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.SColon|TypeScript.ErrorRecoverySet.RParen,TypeScript.OperatorPrecedence.None,!0,TypeContext.NoTypes]);v8165.cond=v27127;this.currentToken.tokenId!=TypeScript.TokenID.Semicolon&&(JAM.call(this.skip,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.StmtStart]),ast=forStmt,ast.flags|=TypeScript.ASTFlags.Error)}var v27128=this.scanner.scan();this.currentToken=v27128;if(this.currentToken.tokenId==TypeScript.TokenID.CloseParen)forStmt.incr=
null;else{var v8170=forStmt,v27129=JAM.call(this.parseExpr,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.SColon|TypeScript.ErrorRecoverySet.RParen,TypeScript.OperatorPrecedence.None,!0,TypeContext.NoTypes]);v8170.incr=v27129}JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.CloseParen,errorRecoverySet|TypeScript.ErrorRecoverySet.LCurly]);JAM.call(this.pushStmt,this,[forStmt,labelList]);var v8174=forStmt,v27130=JAM.call(this.parseStatement,this,[errorRecoverySet,allowedElements,parentModifiers]);
v8174.body=v27130;this.popStmt();forStmt.limChar=forStmt.body.limChar;ast=forStmt}break;case TypeScript.TokenID.With:TypeScript.codeGenTarget<TypeScript.CodeGenTarget.ES5&&JAM.call(this.reportParseError,this,["'with' statements are only available in ES5 codegen mode or better"]);this.strictMode&&JAM.call(this.reportParseError,this,["'with' statements are not available in strict mode"]);mayNotBeExported();modifiers!=TypeScript.Modifiers.None&&JAM.call(this.reportParseError,this,["'with' statement does not take modifiers"]);
minChar=this.scanner.startPos;JAM.call(this.checkNextToken,this,[TypeScript.TokenID.OpenParen,errorRecoverySet|TypeScript.ErrorRecoverySet.ExprStart|TypeScript.ErrorRecoverySet.Var]);var expr=JAM.call(this.parseExpr,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.Colon,TypeScript.OperatorPrecedence.None,!0,TypeContext.NoTypes]);JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.CloseParen,errorRecoverySet|TypeScript.ErrorRecoverySet.LCurly]);var withStmt=JAM.new(TypeScript.WithStatement,
[expr]),v8189=withStmt,v27131=JAM.call(this.parseStatement,this,[errorRecoverySet,allowedElements,parentModifiers]);v8189.body=v27131;withStmt.minChar=minChar;withStmt.limChar=withStmt.body.limChar;ast=withStmt;break;case TypeScript.TokenID.Switch:mayNotBeExported();modifiers!=TypeScript.Modifiers.None&&JAM.call(this.reportParseError,this,["'switch' statement does not take modifiers"]);JAM.call(this.checkNextToken,this,[TypeScript.TokenID.OpenParen,errorRecoverySet|TypeScript.ErrorRecoverySet.ExprStart]);
var switchStmt=JAM.new(TypeScript.SwitchStatement,[JAM.call(this.parseExpr,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.RParen,TypeScript.OperatorPrecedence.None,!0,TypeContext.NoTypes])]);switchStmt.statement.minChar=minChar;switchStmt.statement.limChar=this.scanner.pos;JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.CloseParen,errorRecoverySet|TypeScript.ErrorRecoverySet.LCurly]);var caseListMinChar=this.scanner.startPos;JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.OpenBrace,
errorRecoverySet|TypeScript.ErrorRecoverySet.SCase]);switchStmt.defaultCase=null;var v8203=switchStmt,v27132=new TypeScript.ASTList;v8203.caseList=v27132;var caseStmt=null;for(JAM.call(this.pushStmt,this,[switchStmt,labelList]);;){var v16265=this.currentToken.tokenId==TypeScript.TokenID.Case;v16265||(v16265=this.currentToken.tokenId==TypeScript.TokenID.Default);if(v16265){var isDefault=this.currentToken.tokenId==TypeScript.TokenID.Default,caseStmt=new TypeScript.CaseStatement;caseStmt.minChar=this.scanner.startPos;
var v27133=this.scanner.scan();this.currentToken=v27133;if(isDefault)switchStmt.defaultCase=caseStmt;else{var v8209=caseStmt,v27134=JAM.call(this.parseExpr,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.Colon,TypeScript.OperatorPrecedence.None,!0,TypeContext.NoTypes]);v8209.expr=v27134}JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.Colon,errorRecoverySet|TypeScript.ErrorRecoverySet.StmtStart]);var v8212=caseStmt,v27135=new TypeScript.ASTList;v8212.body=v27135;JAM.call(this.parseStatementList,
this,[errorRecoverySet|TypeScript.ErrorRecoverySet.RCurly,caseStmt.body,!1,!0,allowedElements,modifiers]);caseStmt.limChar=caseStmt.body.limChar;var v8216=switchStmt.caseList;JAM.call(v8216.append,v8216,[caseStmt])}else break}switchStmt.caseList.minChar=caseListMinChar;switchStmt.caseList.limChar=this.scanner.pos;switchStmt.limChar=switchStmt.caseList.limChar;JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.CloseBrace,errorRecoverySet]);this.popStmt();ast=switchStmt;break;case TypeScript.TokenID.While:mayNotBeExported();
modifiers!=TypeScript.Modifiers.None&&JAM.call(this.reportParseError,this,["'while' statement does not take modifiers"]);minChar=this.scanner.startPos;JAM.call(this.checkNextToken,this,[TypeScript.TokenID.OpenParen,TypeScript.ErrorRecoverySet.ExprStart|errorRecoverySet]);var whileStmt=JAM.new(TypeScript.WhileStatement,[JAM.call(this.parseExpr,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.RParen,TypeScript.OperatorPrecedence.None,!0,TypeContext.NoTypes])]);whileStmt.minChar=minChar;JAM.call(this.checkCurrentToken,
this,[TypeScript.TokenID.CloseParen,errorRecoverySet|TypeScript.ErrorRecoverySet.StmtStart]);JAM.call(this.pushStmt,this,[whileStmt,labelList]);var v8230=whileStmt,v27136=JAM.call(this.parseStatement,this,[errorRecoverySet,allowedElements,parentModifiers]);v8230.body=v27136;whileStmt.limChar=whileStmt.body.limChar;this.popStmt();ast=whileStmt;break;case TypeScript.TokenID.Do:mayNotBeExported();modifiers!=TypeScript.Modifiers.None&&JAM.call(this.reportParseError,this,["'do' statement does not take modifiers"]);
var minChar=this.scanner.startPos,v27137=this.scanner.scan();this.currentToken=v27137;var doStmt=new TypeScript.DoWhileStatement;doStmt.minChar=minChar;JAM.call(this.pushStmt,this,[doStmt,labelList]);var v8236=doStmt,v27138=JAM.call(this.parseStatement,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.While,allowedElements,parentModifiers]);v8236.body=v27138;this.popStmt();var v8237=doStmt,v27139=JAM.new(TypeScript.Identifier,["while"]);v8237.whileAST=v27139;doStmt.whileAST.minChar=this.scanner.startPos;
JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.While,errorRecoverySet|TypeScript.ErrorRecoverySet.LParen]);doStmt.whileAST.limChar=doStmt.whileAST.minChar+5;JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.OpenParen,errorRecoverySet|TypeScript.ErrorRecoverySet.ExprStart]);var v8244=doStmt,v27140=JAM.call(this.parseExpr,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.RParen,TypeScript.OperatorPrecedence.None,!0,TypeContext.NoTypes]);v8244.cond=v27140;doStmt.limChar=this.scanner.pos;
JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.CloseParen,errorRecoverySet]);ast=doStmt;if(this.currentToken.tokenId==TypeScript.TokenID.Semicolon){var v27141=this.scanner.scan();this.currentToken=v27141}break;case TypeScript.TokenID.If:mayNotBeExported();modifiers!=TypeScript.Modifiers.None&&JAM.call(this.reportParseError,this,["if statement does not take modifiers"]);minChar=this.scanner.startPos;JAM.call(this.checkNextToken,this,[TypeScript.TokenID.OpenParen,errorRecoverySet|TypeScript.ErrorRecoverySet.ExprStart]);
var ifStmt=JAM.new(TypeScript.IfStatement,[JAM.call(this.parseExpr,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.LParen,TypeScript.OperatorPrecedence.None,!0,TypeContext.NoTypes])]);ifStmt.minChar=minChar;ifStmt.statement.minChar=minChar;ifStmt.statement.limChar=this.scanner.pos;JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.CloseParen,errorRecoverySet|TypeScript.ErrorRecoverySet.StmtStart]);JAM.call(this.pushStmt,this,[ifStmt,labelList]);var v8259=ifStmt,v27142=JAM.call(this.parseStatement,
this,[TypeScript.ErrorRecoverySet.Else|errorRecoverySet,allowedElements,parentModifiers]);v8259.thenBod=v27142;ifStmt.limChar=ifStmt.thenBod.limChar;if(this.currentToken.tokenId==TypeScript.TokenID.Else){var v27143=this.scanner.scan();this.currentToken=v27143;var v8262=ifStmt,v27144=JAM.call(this.parseStatement,this,[errorRecoverySet,allowedElements,parentModifiers]);v8262.elseBod=v27144;ifStmt.limChar=ifStmt.elseBod.limChar}this.popStmt();ast=ifStmt;break;case TypeScript.TokenID.Try:mayNotBeExported();
modifiers!=TypeScript.Modifiers.None&&JAM.call(this.reportParseError,this,["try statement does not take modifiers"]);minChar=this.scanner.startPos;ast=JAM.call(this.parseTryCatchFinally,this,[errorRecoverySet,parentModifiers,labelList]);break;case TypeScript.TokenID.OpenBrace:mayNotBeExported();modifiers!=TypeScript.Modifiers.None&&JAM.call(this.reportParseError,this,["block does not take modifiers"]);var minChar=this.scanner.startPos,v27145=this.scanner.scan();this.currentToken=v27145;var block=
JAM.new(TypeScript.Block,[new TypeScript.ASTList,!0]);JAM.call(this.pushStmt,this,[block,labelList]);JAM.call(this.parseStatementList,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.RCurly,block.statements,!1,!1,TypeScript.AllowedElements.None,modifiers]);this.popStmt();block.statements.minChar=minChar;block.statements.limChar=this.scanner.pos;block.minChar=block.statements.minChar;block.limChar=block.statements.limChar;JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.CloseBrace,errorRecoverySet]);
ast=block;break;case TypeScript.TokenID.Semicolon:mayNotBeExported();modifiers!=TypeScript.Modifiers.None&&JAM.call(this.reportParseError,this,["modifier can not appear here"]);var ast=JAM.new(TypeScript.AST,[TypeScript.NodeType.Empty]),v27146=this.scanner.scan();this.currentToken=v27146;break;case TypeScript.TokenID.Break:case TypeScript.TokenID.Continue:mayNotBeExported();modifiers!=TypeScript.Modifiers.None&&JAM.call(this.reportParseError,this,["modifiers can not appear before jump statement"]);
var v8285=TypeScript.Jump,v16322;v16322=this.currentToken.tokenId==TypeScript.TokenID.Break?TypeScript.NodeType.Break:TypeScript.NodeType.Continue;var jump=JAM.new(v8285,[v16322]),v27147=this.scanner.scan();this.currentToken=v27147;var v16323=this.currentToken.tokenId==TypeScript.TokenID.Identifier;v16323&&(v16323=!this.scanner.lastTokenHadNewline());if(v16323){var v8288=jump,v27148=this.currentToken.getText();v8288.target=v27148;var v27149=this.scanner.scan();this.currentToken=v27149}JAM.call(this.resolveJumpTarget,
this,[jump]);ast=jump;needTerminator=!0;break;case TypeScript.TokenID.Return:mayNotBeExported();modifiers!=TypeScript.Modifiers.None&&JAM.call(this.reportParseError,this,["modifiers can not appear before return statement"]);this.inFunction||JAM.call(this.reportParseError,this,["return statement outside of function body"]);var minChar=this.scanner.startPos,v27150=this.scanner.scan();this.currentToken=v27150;var retStmt=new TypeScript.ReturnStatement;retStmt.minChar=minChar;var v16327=this.currentToken.tokenId!=
TypeScript.TokenID.Semicolon;if(v16327){var v21122=this.currentToken.tokenId!=TypeScript.TokenID.CloseBrace;v21122&&(v21122=!this.scanner.lastTokenHadNewline());v16327=v21122}if(v16327){var v8296=retStmt,v27151=JAM.call(this.parseExpr,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.SColon,TypeScript.OperatorPrecedence.None,!0,TypeContext.NoTypes]);v8296.returnExpression=v27151}var needTerminator=!0,v8298=retStmt,v27152=this.scanner.lastTokenLimChar();v8298.limChar=v27152;ast=retStmt;break;case TypeScript.TokenID.Throw:mayNotBeExported();
modifiers!=TypeScript.Modifiers.None&&JAM.call(this.reportParseError,this,["modifiers can not appear before a throw statement"]);var minChar=this.scanner.startPos,v27153=this.scanner.scan();this.currentToken=v27153;var v16333=this.currentToken.tokenId!=TypeScript.TokenID.Semicolon;if(v16333){var v21128=this.currentToken.tokenId!=TypeScript.TokenID.CloseBrace;v21128&&(v21128=!this.scanner.lastTokenHadNewline());v16333=v21128}v16333?temp=JAM.call(this.parseExpr,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.SColon,
TypeScript.OperatorPrecedence.None,!0,TypeContext.NoTypes]):(JAM.call(this.reportParseError,this,["throw with no target"]),temp=null);var v8308=ast=JAM.new(TypeScript.UnaryExpression,[TypeScript.NodeType.Throw,temp]),v27154=this.scanner.lastTokenLimChar();v8308.limChar=v27154;needTerminator=!0;break;case TypeScript.TokenID.Enum:var v27155=this.scanner.scan();this.currentToken=v27155;ast=JAM.call(this.parseEnumDecl,this,[errorRecoverySet,modifiers]);ast.minChar=minChar;var v8310=ast,v27156=this.scanner.lastTokenLimChar();
v8310.limChar=v27156;var v16339=this.parsingDeclareFile;if(!v16339){var v21130=this.ambientModule;v21130||(v21130=JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Ambient]));v16339=v21130}v16339&&(ast.modFlags|=TypeScript.ModuleFlags.Ambient);var v16342=this.parsingDeclareFile;if(!v16342){var v21133=this.ambientModule;v21133||(v21133=JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Exported]));v16342=v21133}v16342&&(ast.modFlags|=TypeScript.ModuleFlags.Exported);
break;case TypeScript.TokenID.Debugger:mayNotBeExported();modifiers!=TypeScript.Modifiers.None&&JAM.call(this.reportParseError,this,["modifiers can not appear before debugger statement"]);var minChar=this.scanner.startPos,v27157=this.scanner.scan();this.currentToken=v27157;var debuggerStmt=new TypeScript.DebuggerStatement;debuggerStmt.minChar=minChar;var needTerminator=!0,v8317=debuggerStmt,v27158=this.scanner.lastTokenLimChar();v8317.limChar=v27158;ast=debuggerStmt;break;default:modifiers!=TypeScript.Modifiers.None&&
JAM.call(this.reportParseError,this,["modifiers can not appear before an expression statement or label"]);var minChar=this.scanner.startPos,svPos=this.scanner.pos;temp=JAM.call(this.parseExpr,this,[TypeScript.ErrorRecoverySet.Colon|TypeScript.ErrorRecoverySet.StmtStart|errorRecoverySet,TypeScript.OperatorPrecedence.None,!0,TypeContext.NoTypes]);if(this.scanner.pos==svPos){var v27159=this.scanner.scan();this.currentToken=v27159;ast=temp}else{var v16351=this.currentToken.tokenId==TypeScript.TokenID.Colon;
if(v16351){var v21143=!this.scanner.lastTokenHadNewline();if(v21143){var v23890=temp;v23890&&(v23890=temp.nodeType==TypeScript.NodeType.Name);v21143=v23890}v16351=v21143}if(v16351){null==labelList&&(labelList=new TypeScript.ASTList);JAM.call(labelList.append,labelList,[JAM.new(TypeScript.Label,[temp])]);var v27160=this.scanner.scan();this.currentToken=v27160}else ast=temp,needTerminator=!0}}if(ast)break}if(needTerminator)switch(this.currentToken.tokenId){case TypeScript.TokenID.Semicolon:var v27161=
this.scanner.scan();this.currentToken=v27161;ast.flags|=TypeScript.ASTFlags.ExplicitSemicolon;break;case TypeScript.TokenID.EndOfFile:ast.limChar=this.scanner.pos;case TypeScript.TokenID.CloseBrace:ast.flags|=TypeScript.ASTFlags.AutomaticSemicolon;this.style_requireSemi&&JAM.call(this.reportParseStyleError,this,["no automatic semicolon"]);break;default:this.scanner.lastTokenHadNewline()?(ast.flags|=TypeScript.ASTFlags.AutomaticSemicolon,this.style_requireSemi&&JAM.call(this.reportParseStyleError,
this,["no automatic semicolon"])):JAM.call(this.reportParseError,this,["Expected ';'"])}labelList&&(ast=JAM.new(TypeScript.LabeledStatement,[labelList,ast]));ast.minChar=minChar;var v8339=ast,v27162=JAM.call(TypeScript.max,TypeScript,[ast.limChar,this.scanner.lastTokenLimChar()]);v8339.limChar=v27162;preComments&&(ast.preComments=preComments);var v16363=this.ambientModule;v16363&&(v16363=!JAM.call(this.okAmbientModuleMember,this,[ast]));v16363&&JAM.call(this.reportParseError,this,["statement not permitted within ambient module"]);
ast.flags|=TypeScript.ASTFlags.IsStatement;return ast}function v584(errorRecoverySet,parentModifiers,labelList){var tryPart=JAM.new(TypeScript.Try,[null]),tryMinChar=this.scanner.startPos;JAM.call(this.pushStmt,this,[tryPart,labelList]);JAM.call(this.parseTry,this,[tryPart,errorRecoverySet|TypeScript.ErrorRecoverySet.Catch,parentModifiers]);this.popStmt();var tf=labelList=null;this.currentToken.tokenId==TypeScript.TokenID.Catch&&(tf=JAM.call(this.parseCatch,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.Catch,
parentModifiers]),labelList=JAM.new(TypeScript.TryCatch,[tryPart,tf]),labelList.minChar=tryPart.minChar,labelList.limChar=tf.limChar);if(this.currentToken.tokenId!=TypeScript.TokenID.Finally)return null==labelList?(JAM.call(this.reportParseError,this,["try with neither catch nor finally"]),this.errorRecovery?(tryPart=JAM.new(TypeScript.TryFinally,[tryPart,JAM.new(TypeScript.Finally,[JAM.new(TypeScript.AST,[TypeScript.NodeType.Empty])])]),tryPart.flags|=TypeScript.ASTFlags.Error,tryPart.minChar=this.scanner.startPos,
tryPart.limChar=this.scanner.pos,tryPart):JAM.new(TypeScript.TryFinally,[tryPart,JAM.new(TypeScript.Finally,[JAM.new(TypeScript.AST,[TypeScript.NodeType.Empty])])])):labelList;labelList&&(tryPart=labelList);errorRecoverySet=JAM.call(this.parseFinally,this,[errorRecoverySet,parentModifiers]);tf=JAM.new(TypeScript.TryFinally,[tryPart,errorRecoverySet]);tf.minChar=tryMinChar;tf.limChar=errorRecoverySet.limChar;return tf}function v583(errorRecoverySet,parentModifiers){var finMinChar=this.scanner.startPos,
preComments=this.parseComments(),v27163=this.scanner.scan();this.currentToken=v27163;if(this.currentToken.tokenId!=TypeScript.TokenID.OpenBrace&&(JAM.call(this.reportParseError,this,["Expected '{' to start body of finally statement"]),this.errorRecovery))return JAM.call(this.skip,this,[errorRecoverySet]),finMinChar=JAM.new(TypeScript.Finally,[JAM.new(TypeScript.Statement,[TypeScript.NodeType.Empty])]),finMinChar.flags|=TypeScript.ASTFlags.Error,finMinChar.minChar=this.scanner.startPos,finMinChar.limChar=
this.scanner.pos,finMinChar;v27163=JAM.call(this.parseStatement,this,[errorRecoverySet,TypeScript.AllowedElements.None,parentModifiers]);v27163=JAM.new(TypeScript.Finally,[v27163]);v27163.minChar=finMinChar;v27163.limChar=v27163.body.limChar;v27163.preComments=preComments;finMinChar=v27163;preComments=this.parseComments();finMinChar.postComments=preComments;return v27163}function v582(errorRecoverySet,parentModifiers){var catchMinChar=this.scanner.startPos,preComments=this.parseComments(),v27165=
this.scanner.scan();this.currentToken=v27165;JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.OpenParen,errorRecoverySet|TypeScript.ErrorRecoverySet.ExprStart]);(v27165=this.currentToken.tokenId!=TypeScript.TokenID.Identifier)||(v27165=JAM.call(TypeScript.convertTokToID,TypeScript,[this.currentToken,this.strictMode]));if(v27165&&(JAM.call(this.reportParseError,this,["Expected identifier in catch header"]),this.errorRecovery))return JAM.call(this.skip,this,[errorRecoverySet]),preComments=JAM.new(TypeScript.Catch,
[JAM.new(TypeScript.VarDecl,[new TypeScript.MissingIdentifier,this.nestingLevel]),JAM.new(TypeScript.Statement,[TypeScript.NodeType.Empty])]),preComments.statement.minChar=catchMinChar,preComments.statement.limChar=this.scanner.pos,preComments.minChar=this.scanner.startPos,preComments.limChar=this.scanner.pos,preComments.flags|=TypeScript.ASTFlags.Error,preComments;var v27165=TypeScript.VarDecl,v16396=TypeScript.Identifier,v16396=JAM.new(v27165,[JAM.call(v16396.fromToken,v16396,[this.currentToken]),
this.nestingLevel]);v16396.id.minChar=this.scanner.startPos;v16396.id.limChar=this.scanner.pos;v16396.minChar=v16396.id.minChar;v16396.limChar=v16396.id.limChar;this.currentToken=v27165=this.scanner.scan();v27165=this.scanner.pos;JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.CloseParen,errorRecoverySet|TypeScript.ErrorRecoverySet.StmtStart]);if(this.currentToken.tokenId!=TypeScript.TokenID.OpenBrace&&(JAM.call(this.reportParseError,this,["Expected '{' to start catch body"]),this.errorRecovery))return JAM.call(this.skip,
this,[errorRecoverySet]),preComments=JAM.new(TypeScript.Catch,[JAM.new(TypeScript.VarDecl,[new TypeScript.MissingIdentifier,this.nestingLevel]),JAM.new(TypeScript.Statement,[TypeScript.NodeType.Empty])]),preComments.statement.minChar=catchMinChar,preComments.statement.limChar=v27165,preComments.minChar=this.scanner.startPos,preComments.limChar=this.scanner.pos,preComments.flags|=TypeScript.ASTFlags.Error,preComments;var catchStmt=JAM.call(this.parseStatement,this,[errorRecoverySet,TypeScript.AllowedElements.None,
parentModifiers]),v16396=JAM.new(TypeScript.Catch,[v16396,catchStmt]);v16396.statement.minChar=catchMinChar;v16396.statement.limChar=v27165;v16396.minChar=catchMinChar;v16396.limChar=catchStmt.limChar;v16396.preComments=preComments;catchMinChar=v16396;preComments=this.parseComments();catchMinChar.postComments=preComments;return v16396}function v581(tryNode,errorRecoverySet,parentModifiers){var minChar=this.scanner.startPos,preComments=this.parseComments(),v27168=this.scanner.scan();this.currentToken=
v27168;if(this.currentToken.tokenId!=TypeScript.TokenID.OpenBrace&&(JAM.call(this.reportParseError,this,["Expected '{'"]),this.errorRecovery))return tryNode.minChar=minChar,minChar=tryNode,preComments=this.scanner.lastTokenLimChar(),minChar.limChar=preComments,tryNode.flags|=TypeScript.ASTFlags.Error,tryNode;v27168=tryNode;errorRecoverySet=JAM.call(this.parseStatement,this,[errorRecoverySet,TypeScript.AllowedElements.None,parentModifiers]);v27168.body=errorRecoverySet;tryNode.minChar=minChar;tryNode.limChar=
tryNode.body.limChar;tryNode.preComments=preComments;minChar=tryNode;preComments=this.parseComments();minChar.postComments=preComments;return tryNode}function v580(errorRecoverySet,ast,allowCall,inNew,typeContext,lhsMinChar,lhsLimChar){ast||(ast=JAM.new(TypeScript.AST,[TypeScript.NodeType.EmptyExpr]),ast.isParenthesized=!0);ast.minChar=lhsMinChar;for(ast.limChar=lhsLimChar;;)switch(this.currentToken.tokenId){case TypeScript.TokenID.OpenParen:if(inNew)inNew=ast,lhsLimChar=JAM.call(this.parseArgList,
this,[errorRecoverySet]),inNew.arguments=lhsLimChar,inNew=!1;else{if(!allowCall)return ast;ast=JAM.new(TypeScript.CallExpression,[TypeScript.NodeType.Call,ast,JAM.call(this.parseArgList,this,[errorRecoverySet])]);ast.minChar=lhsMinChar}ast.limChar=this.scanner.pos;JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.CloseParen,errorRecoverySet]);break;case TypeScript.TokenID.OpenBracket:this.currentToken=lhsLimChar=this.scanner.scan();if(this.currentToken.tokenId==TypeScript.TokenID.CloseBracket&&
JAM.call(TypeScript.hasFlag,TypeScript,[typeContext,TypeContext.ArraySuffix])){this.currentToken=lhsLimChar=this.scanner.scan();ast.nodeType==TypeScript.NodeType.TypeRef?(lhsLimChar=ast,lhsLimChar.arrayCount+=1):ast=JAM.new(TypeScript.BinaryExpression,[TypeScript.NodeType.Index,ast,null]);ast.limChar=this.scanner.pos;break}ast=JAM.new(TypeScript.BinaryExpression,[TypeScript.NodeType.Index,ast,JAM.call(this.parseExpr,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.RBrack,TypeScript.OperatorPrecedence.None,
!0,TypeContext.NoTypes])]);ast.minChar=lhsMinChar;ast.limChar=this.scanner.pos;JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.CloseBracket,errorRecoverySet]);break;case TypeScript.TokenID.Dot:lhsLimChar=null;this.currentToken=lhsLimChar=this.scanner.scan();if(void 0===this.currentToken){this.currentToken=lhsLimChar=this.scanner.scan();continue}lhsLimChar=this.currentToken.tokenId==TypeScript.TokenID.Identifier;lhsLimChar||((lhsLimChar=!this.errorRecovery)||(lhsLimChar=!this.scanner.lastTokenHadNewline()),
lhsLimChar&&(lhsLimChar=JAM.call(TypeScript.convertTokToIDName,TypeScript,[this.currentToken])));if(lhsLimChar){ast.flags|=TypeScript.ASTFlags.DotLHS;lhsLimChar=JAM.call(this.createRef,this,[this.currentToken.getText(),this.currentToken.hasEscapeSequence,this.scanner.startPos]);lhsLimChar.limChar=this.scanner.pos;var v27177=this.scanner.scan();this.currentToken=v27177}else{JAM.call(this.reportParseError,this,["Expected identifier following dot"]);if(this.errorRecovery)return JAM.call(this.skip,this,
[errorRecoverySet]),ast.flags=ast.flags|TypeScript.ASTFlags.Error|TypeScript.ASTFlags.DotLHS,ast;lhsLimChar=new TypeScript.MissingIdentifier}ast=JAM.new(TypeScript.BinaryExpression,[TypeScript.NodeType.Dot,ast,lhsLimChar]);ast.minChar=lhsMinChar;lhsLimChar=ast;v27177=this.scanner.lastTokenLimChar();lhsLimChar.limChar=v27177;break;case TypeScript.TokenID.EqualsGreaterThan:ast=JAM.call(this.parseFncDecl,this,[errorRecoverySet,!1,!1,!1,null,!1,!1,!1,TypeScript.Modifiers.None,{preProcessedLambdaArgs:ast},
!1]);ast.fncFlags|=TypeScript.FncFlags.IsFunctionExpression;ast.minChar=lhsMinChar;lhsLimChar=ast;v27177=this.scanner.lastTokenLimChar();lhsLimChar.limChar=v27177;break;default:return ast}}function v579(errorRecoverySet,minPrecedence,allowIn,typeContext,possiblyInLambda){"undefined"===typeof possiblyInLambda&&(possiblyInLambda=!1);var ast=null,tokenInfo=JAM.call(TypeScript.lookupToken,TypeScript,[this.currentToken.tokenId]),canAssign=!0,idHint=null,minChar=this.scanner.startPos,preComments=this.parseComments(),
exprIsAnonLambda=!1;(ast=void 0!=tokenInfo)&&(ast=tokenInfo.unopNodeType!=TypeScript.NodeType.None);if(ast)canAssign=!1,this.currentToken=ast=this.scanner.scan(),typeContext=JAM.call(this.parseExpr,this,[TypeScript.ErrorRecoverySet.BinOp|errorRecoverySet,tokenInfo.unopPrecedence,allowIn,TypeContext.NoTypes]),(ast=tokenInfo.unopNodeType==TypeScript.NodeType.Pos)&&(ast=typeContext.nodeType==TypeScript.NodeType.NumberLit),ast?ast=typeContext:((ast=tokenInfo.unopNodeType==TypeScript.NodeType.Neg)&&(ast=
typeContext.nodeType==TypeScript.NodeType.NumberLit),ast?(ast=typeContext,ast.value=-ast.value,0==ast.value&&(ast.isNegativeZero=!0),ast=typeContext):(ast=JAM.new(TypeScript.UnaryExpression,[tokenInfo.unopNodeType,typeContext]),ast.limChar=typeContext.limChar)),ast.minChar=minChar;else{ast=JAM.call(this.parseTerm,this,[TypeScript.ErrorRecoverySet.BinOp|TypeScript.ErrorRecoverySet.AddOp|errorRecoverySet,!0,typeContext,!1]);if(ast.nodeType==TypeScript.NodeType.Name)idHint=ast,idHint=idHint.actualText;
else if(ast.nodeType==TypeScript.NodeType.Dot){tokenInfo=!1;if(typeContext=this.inferPropertiesFromThisAssignment)(typeContext=this.currentToken.tokenId==TypeScript.TokenID.Colon)||(typeContext=this.currentToken.tokenId==TypeScript.TokenID.Equals),typeContext&&(typeContext=this.parsingClassConstructorDefinition)&&(typeContext=this.nestingLevel==this.currentClassDefinition.constructorNestingLevel)&&(typeContext=ast.operand1.nodeType==TypeScript.NodeType.This);if(typeContext&&ast.operand2.nodeType==
TypeScript.NodeType.Name){typeContext=ast.operand2;var v21216=this.currentClassDefinition.knownMemberNames,v21217=typeContext.actualText;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v21216=v21216[v21217];v21216||(ast=JAM.call(this.parseClassMemberVariableDeclaration,this,[typeContext,ast.minChar,!0,errorRecoverySet,TypeScript.Modifiers.Public]),tokenInfo=!0)}if(!tokenInfo){tokenInfo=ast;for(typeContext=tokenInfo.nodeType==TypeScript.NodeType.Dot;typeContext;)tokenInfo=tokenInfo.operand2,
typeContext=tokenInfo.nodeType==TypeScript.NodeType.Dot;tokenInfo.nodeType==TypeScript.NodeType.Name&&(idHint=tokenInfo,idHint=idHint.actualText)}}if(tokenInfo=!this.scanner.lastTokenHadNewline())(tokenInfo=this.currentToken.tokenId==TypeScript.TokenID.PlusPlus)||(tokenInfo=this.currentToken.tokenId==TypeScript.TokenID.MinusMinus);tokenInfo&&(canAssign=!1,tokenInfo=ast,ast=TypeScript.UnaryExpression,typeContext=this.currentToken.tokenId==TypeScript.TokenID.PlusPlus?TypeScript.NodeType.IncPost:TypeScript.NodeType.DecPost,
ast=JAM.new(ast,[typeContext,tokenInfo]),ast.limChar=this.scanner.pos,ast.minChar=tokenInfo.minChar,this.currentToken=tokenInfo=this.scanner.scan())}for(;;){tokenInfo=JAM.call(TypeScript.lookupToken,TypeScript,[this.currentToken.tokenId]);(typeContext=void 0==tokenInfo)||(typeContext=tokenInfo.binopNodeType==TypeScript.NodeType.None);if(typeContext)break;(typeContext=!allowIn)&&(typeContext=tokenInfo.binopNodeType==TypeScript.NodeType.In);if(typeContext)break;if(tokenInfo.binopPrecedence==TypeScript.OperatorPrecedence.Assignment){if(tokenInfo.binopPrecedence<
minPrecedence)break;canAssign||JAM.call(this.reportParseError,this,["illegal assignment"])}else if(tokenInfo.binopPrecedence<=minPrecedence)break;(canAssign=possiblyInLambda)&&(canAssign=this.currentToken.tokenId==TypeScript.TokenID.Comma)&&(canAssign=this.scanner.getLookAheadToken().tokenId==TypeScript.TokenID.DotDotDot);if(canAssign){exprIsAnonLambda=!0;canAssign=!1;ast=JAM.call(this.parseLambdaExpr,this,[errorRecoverySet,ast,!1,!0]);break}this.currentToken=canAssign=this.scanner.scan();canAssign=
!1;if(tokenInfo.binopNodeType==TypeScript.NodeType.ConditionalExpression){if(tokenInfo=possiblyInLambda)tokenInfo=this.currentToken.tokenId==TypeScript.TokenID.Equals,tokenInfo||(tokenInfo=this.currentToken.tokenId==TypeScript.TokenID.Colon,tokenInfo||(tokenInfo=this.currentToken.tokenId==TypeScript.TokenID.CloseParen)||(tokenInfo=this.currentToken.tokenId==TypeScript.TokenID.Comma));tokenInfo?canAssign=exprIsAnonLambda=!0:(this.prevExpr=ast,tokenInfo=JAM.call(this.parseExpr,this,[errorRecoverySet|
TypeScript.ErrorRecoverySet.Colon,TypeScript.OperatorPrecedence.Assignment,allowIn,TypeContext.NoTypes]),this.prevExpr=null,JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.Colon,errorRecoverySet|TypeScript.ErrorRecoverySet.ExprStart]),typeContext=JAM.call(this.parseExpr,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.BinOp,TypeScript.OperatorPrecedence.Assignment,allowIn,TypeContext.NoTypes]),ast=JAM.new(TypeScript.ConditionalExpression,[ast,tokenInfo,typeContext]))}else tokenInfo=JAM.new(TypeScript.BinaryExpression,
[tokenInfo.binopNodeType,ast,JAM.call(this.parseExpr,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.BinOp,tokenInfo.binopPrecedence,allowIn,TypeContext.NoTypes,possiblyInLambda])]),tokenInfo.operand2.nodeType==TypeScript.NodeType.FuncDecl&&(typeContext=tokenInfo.operand2,typeContext.hint=idHint),tokenInfo.minChar=ast.minChar,idHint=tokenInfo,ast=this.scanner.lastTokenLimChar(),idHint.limChar=ast,idHint=null,ast=tokenInfo}canAssign&&(ast.flags|=TypeScript.ASTFlags.Writeable);exprIsAnonLambda||
(ast.minChar=minChar,errorRecoverySet=ast,minPrecedence=JAM.call(TypeScript.max,TypeScript,[ast.limChar,this.scanner.lastTokenLimChar()]),errorRecoverySet.limChar=minPrecedence,ast.preComments=preComments,preComments=ast,errorRecoverySet=JAM.call(this.parseCommentsForLine,this,[this.scanner.line]),preComments.postComments=errorRecoverySet);return ast}function v578(errorRecoverySet,lambdaArgs,skipNextRParen,expectClosingRParen){errorRecoverySet=JAM.call(this.parseFncDecl,this,[errorRecoverySet,!1,
!1,!1,null,!1,!1,!1,TypeScript.Modifiers.None,{preProcessedLambdaArgs:lambdaArgs},expectClosingRParen]);errorRecoverySet.fncFlags|=TypeScript.FncFlags.IsFunctionExpression;errorRecoverySet.fncFlags|=TypeScript.FncFlags.IsFatArrowFunction;skipNextRParen||(errorRecoverySet.flags|=TypeScript.ASTFlags.SkipNextRParen);skipNextRParen=errorRecoverySet;lambdaArgs=this.scanner.lastTokenLimChar();skipNextRParen.limChar=lambdaArgs;return errorRecoverySet}function v577(errorRecoverySet,allowCall,typeContext,
inCast){var ast=null,sawId=!1,inNew=!1,minChar=this.scanner.startPos,limChar=this.scanner.pos,parseAsLambda=!1,expectlambdaRParen=!1;switch(this.currentToken.tokenId){case TypeScript.TokenID.Number:case TypeScript.TokenID.Bool:case TypeScript.TokenID.Any:case TypeScript.TokenID.String:sawId=TypeScript.Identifier;ast=TypeScript.tokenTable;limChar=this.currentToken.tokenId;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)ast=ast[limChar];sawId=JAM.new(sawId,[ast.text]);ast=JAM.call(TypeScript.hasFlag,
TypeScript,[typeContext,TypeContext.Primitive])?JAM.new(TypeScript.TypeReference,[sawId,0]):sawId;sawId=!0;ast.minChar=minChar;this.currentToken=limChar=this.scanner.scan();limChar=this.scanner.lastTokenLimChar();break;case TypeScript.TokenID.This:ast=JAM.new(TypeScript.AST,[TypeScript.NodeType.This]);ast.minChar=minChar;this.currentToken=limChar=this.scanner.scan();limChar=this.scanner.lastTokenLimChar();break;case TypeScript.TokenID.Super:ast=JAM.new(TypeScript.AST,[TypeScript.NodeType.Super]);
ast.minChar=minChar;this.currentToken=limChar=this.scanner.scan();limChar=this.scanner.lastTokenLimChar();break;case TypeScript.TokenID.True:var ast=JAM.new(TypeScript.AST,[TypeScript.NodeType.True]),v27190=this.scanner.scan();this.currentToken=v27190;ast.minChar=minChar;break;case TypeScript.TokenID.False:ast=JAM.new(TypeScript.AST,[TypeScript.NodeType.False]);this.currentToken=v27190=this.scanner.scan();ast.minChar=minChar;break;case TypeScript.TokenID.Null:ast=JAM.new(TypeScript.AST,[TypeScript.NodeType.Null]);
this.currentToken=v27190=this.scanner.scan();ast.minChar=minChar;break;case TypeScript.TokenID.New:minChar=this.scanner.pos;this.currentToken=v27190=this.scanner.scan();var v27190=JAM.call(this.parseTerm,this,[errorRecoverySet,!1,TypeContext.AllSimpleTypes,inCast]),v16518=v27190.nodeType==TypeScript.NodeType.Error;v16518||(v16518=v27190.nodeType==TypeScript.NodeType.Index)&&(v16518=v27190.operand1.nodeType==TypeScript.NodeType.TypeRef);v16518?JAM.call(this.reportParseError,this,["Cannot invoke 'new' on this expression"]):
(ast=JAM.new(TypeScript.CallExpression,[TypeScript.NodeType.New,v27190,null]),ast.minChar=minChar,limChar=this.scanner.lastTokenLimChar(),inNew=!0);break;case TypeScript.TokenID.Function:minChar=this.scanner.pos,ast=JAM.call(this.parseFncDecl,this,[errorRecoverySet,!1,!1,!1,null,!1,!1,!1,TypeScript.Modifiers.None,null,!0]),ast.fncFlags|=TypeScript.FncFlags.IsFunctionExpression,ast.minChar=minChar,limChar=this.scanner.lastTokenLimChar(),ast.limChar=limChar}null==ast&&((v27190=this.currentToken.tokenId==
TypeScript.TokenID.Identifier)||(v27190=JAM.call(TypeScript.convertTokToID,TypeScript,[this.currentToken,this.strictMode])),v27190&&(sawId=this.currentToken.getText(),ast=JAM.call(this.createRef,this,[sawId,this.currentToken.hasEscapeSequence,minChar]),sawId=!0,ast.minChar=minChar,this.currentToken=limChar=this.scanner.scan(),this.currentToken.tokenId==TypeScript.TokenID.Question&&(ast.flags|=TypeScript.ASTFlags.PossibleOptionalParameter),limChar=this.scanner.lastTokenLimChar()));inCast&&JAM.call(this.checkCurrentToken,
this,[TypeScript.TokenID.GreaterThan,errorRecoverySet]);if(null==ast)switch(this.currentToken.tokenId){case TypeScript.TokenID.OpenParen:minChar=this.scanner.pos;expectlambdaRParen=this.scanner.previousToken().tokenId;this.currentToken=parseAsLambda=this.scanner.scan();parseAsLambda=expectlambdaRParen==TypeScript.TokenID.OpenParen;parseAsLambda||(parseAsLambda=expectlambdaRParen==TypeScript.TokenID.Comma,parseAsLambda||(parseAsLambda=expectlambdaRParen==TypeScript.TokenID.EqualsEquals)||(parseAsLambda=
expectlambdaRParen==TypeScript.TokenID.Colon));(parseAsLambda=expectlambdaRParen=parseAsLambda)&&(parseAsLambda=this.currentToken.tokenId==TypeScript.TokenID.CloseParen);parseAsLambda?(parseAsLambda=!0,expectlambdaRParen=!1,this.currentToken=inCast=this.scanner.scan()):((parseAsLambda=expectlambdaRParen)&&(parseAsLambda=this.currentToken.tokenId==TypeScript.TokenID.DotDotDot),parseAsLambda?parseAsLambda=!0:(ast=JAM.call(this.parseExpr,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.RParen,TypeScript.OperatorPrecedence.None,
!0,TypeContext.NoTypes,expectlambdaRParen]),limChar=this.scanner.lastTokenLimChar(),expectlambdaRParen&&((expectlambdaRParen=ast.nodeType==TypeScript.NodeType.Name)||(expectlambdaRParen=ast.nodeType==TypeScript.NodeType.Comma),expectlambdaRParen&&((expectlambdaRParen=this.currentToken.tokenId==TypeScript.TokenID.Colon)||(expectlambdaRParen=this.currentToken.tokenId==TypeScript.TokenID.Question))),parseAsLambda=expectlambdaRParen),expectlambdaRParen=!0);(inCast=ast)&&(inCast=!parseAsLambda);if(inCast){if(JAM.call(TypeScript.hasFlag,
TypeScript,[ast.flags,TypeScript.ASTFlags.SkipNextRParen])){ast.flags&=~TypeScript.ASTFlags.SkipNextRParen;break}JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.CloseParen,errorRecoverySet]);ast.isParenthesized=!0}break;case TypeScript.TokenID.NumberLiteral:ast=this.currentToken;this.currentToken=limChar=this.scanner.scan();ast=JAM.new(TypeScript.NumberLiteral,[ast.value,ast.hasEmptyFraction]);ast.minChar=minChar;limChar=this.scanner.lastTokenLimChar();break;case TypeScript.TokenID.StringLiteral:ast=
JAM.new(TypeScript.StringLiteral,[this.currentToken.getText()]);this.currentToken=limChar=this.scanner.scan();ast.minChar=minChar;limChar=this.scanner.lastTokenLimChar();break;case TypeScript.TokenID.RegularExpressionLiteral:ast=this.currentToken;ast=JAM.new(TypeScript.RegexLiteral,[ast.regex]);this.currentToken=limChar=this.scanner.scan();ast.minChar=minChar;limChar=this.scanner.lastTokenLimChar();break;case TypeScript.TokenID.OpenBracket:minChar=this.scanner.startPos;this.currentToken=ast=this.scanner.scan();
ast=JAM.call(this.parseArrayLiteral,this,[TypeScript.ErrorRecoverySet.RBrack|errorRecoverySet]);ast.minChar=minChar;limChar=this.scanner.pos;JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.CloseBracket,errorRecoverySet]);break;case TypeScript.TokenID.OpenBrace:minChar=this.scanner.startPos;this.currentToken=ast=this.scanner.scan();inCast=JAM.call(this.parseMemberList,this,[TypeScript.ErrorRecoverySet.RCurly|errorRecoverySet]);JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.CloseBrace,
errorRecoverySet]);ast=JAM.new(TypeScript.UnaryExpression,[TypeScript.NodeType.ObjectLit,inCast]);ast.minChar=minChar;limChar=this.scanner.lastTokenLimChar();inCast.minChar=minChar;inCast.limChar=limChar;break;case TypeScript.TokenID.LessThan:minChar=this.scanner.startPos;this.currentToken=ast=this.scanner.scan();inCast=JAM.call(this.parseTypeReference,this,[TypeScript.ErrorRecoverySet.BinOp,!1]);JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.GreaterThan,errorRecoverySet]);ast=JAM.new(TypeScript.UnaryExpression,
[TypeScript.NodeType.TypeAssertion,JAM.call(this.parseExpr,this,[errorRecoverySet,TypeScript.OperatorPrecedence.Unary,!1,TypeContext.NoTypes])]);ast.castTerm=inCast;break;default:(inCast=this.prevExpr)&&(inCast=JAM.call(TypeScript.hasFlag,TypeScript,[this.prevExpr.flags,TypeScript.ASTFlags.PossibleOptionalParameter])),inCast?(parseAsLambda=!0,ast=this.prevExpr):(JAM.call(this.reportParseError,this,["Check format of expression term"]),this.errorRecovery&&(ast=new TypeScript.MissingIdentifier,ast.minChar=
minChar,ast.flags|=TypeScript.ASTFlags.Error,JAM.call(this.skip,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.Postfix]),(limChar=this.currentToken.tokenId==TypeScript.TokenID.Identifier)||(limChar=JAM.call(TypeScript.convertTokToID,TypeScript,[this.currentToken,this.strictMode])),limChar&&(JAM.call(ast.setText,ast,[this.currentToken.getText(),this.currentToken.hasEscapeSequence]),this.currentToken=limChar=this.scanner.scan()),limChar=this.scanner.lastTokenLimChar()))}parseAsLambda&&(parseAsLambda=
this.currentToken.tokenId==TypeScript.TokenID.Colon,parseAsLambda||(parseAsLambda=this.currentToken.tokenId==TypeScript.TokenID.Comma,parseAsLambda||(parseAsLambda=this.currentToken.tokenId==TypeScript.TokenID.CloseParen)||(parseAsLambda=this.currentToken.tokenId==TypeScript.TokenID.DotDotDot)),parseAsLambda?(ast=JAM.call(this.parseLambdaExpr,this,[errorRecoverySet,ast,!0,expectlambdaRParen]),ast.minChar=minChar,limChar=this.scanner.lastTokenLimChar(),ast.limChar=limChar):ast&&(ast.isParenthesized=
!0));(expectlambdaRParen=sawId)&&(expectlambdaRParen=typeContext!=TypeContext.NoTypes);expectlambdaRParen&&(typeContext|=TypeContext.ArraySuffix);return(errorRecoverySet=JAM.call(this.parsePostfixOperators,this,[errorRecoverySet,ast,allowCall,inNew,typeContext,minChar,limChar]))?((allowCall=sawId)&&(allowCall=errorRecoverySet.nodeType==TypeScript.NodeType.Index),allowCall&&(allowCall=errorRecoverySet,null==allowCall.operand2&&(errorRecoverySet=JAM.call(this.convertToTypeReference,this,[errorRecoverySet]))),
errorRecoverySet.minChar=minChar,minChar=errorRecoverySet,allowCall=JAM.call(TypeScript.max,TypeScript,[errorRecoverySet.limChar,this.scanner.lastTokenLimChar()]),minChar.limChar=allowCall,errorRecoverySet):JAM.new(TypeScript.AST,[TypeScript.NodeType.Error])}function v576(errorRecoverySet){var arrayLiteral=null;return arrayLiteral=JAM.new(TypeScript.UnaryExpression,[TypeScript.NodeType.ArrayLit,JAM.call(this.parseArrayList,this,[errorRecoverySet])])}function v575(errorRecoverySet){var elements=null;
if(this.currentToken.tokenId==TypeScript.TokenID.CloseBracket)return elements;elements=new TypeScript.ASTList;elements.minChar=this.scanner.startPos;for(var arg;;){(arg=this.currentToken.tokenId==TypeScript.TokenID.Comma)||(arg=this.currentToken.tokenId==TypeScript.TokenID.CloseBracket);arg=arg?JAM.new(TypeScript.AST,[TypeScript.NodeType.EmptyExpr]):JAM.call(this.parseExpr,this,[TypeScript.ErrorRecoverySet.Comma|errorRecoverySet,TypeScript.OperatorPrecedence.Comma,!0,TypeContext.NoTypes]);JAM.call(elements.append,
elements,[arg]);if(this.currentToken.tokenId!=TypeScript.TokenID.Comma)break;this.currentToken=arg=this.scanner.scan()}errorRecoverySet=elements;arg=this.scanner.lastTokenLimChar();errorRecoverySet.limChar=arg;return elements}function v574(errorRecoverySet){var elements=new TypeScript.ASTList;if(this.currentToken.tokenId==TypeScript.TokenID.CloseBrace)return elements;for(var idHint=null,memberName=null,memberExpr=null,member=null,minChar=this.scanner.startPos,isSet=!1,skippedTokenForGetSetId=!1,getSetTok=
null,getSetStartPos=0,getSetPos=0;;){memberExpr=!1;(getSetTok=this.currentToken.tokenId==TypeScript.TokenID.Get)||(getSetTok=this.currentToken.tokenId==TypeScript.TokenID.Set);if(getSetTok){var isSet=this.currentToken.tokenId==TypeScript.TokenID.Set,getSetTok=this.currentToken,getSetStartPos=this.scanner.startPos,getSetPos=this.scanner.pos,v27207=this.scanner.scan();this.currentToken=v27207;(v27207=this.currentToken.tokenId==TypeScript.TokenID.Identifier)||(v27207=JAM.call(TypeScript.convertTokToIDName,
TypeScript,[this.currentToken]));v27207?(idHint=isSet?"set":"get",idHint+=this.currentToken.getText(),memberName=TypeScript.Identifier,memberName=JAM.call(memberName.fromToken,memberName,[this.currentToken]),memberName.minChar=this.scanner.startPos,memberExpr=!0,TypeScript.codeGenTarget<TypeScript.CodeGenTarget.ES5&&JAM.call(this.reportParseError,this,["Property accessors are only available when targeting ES5 or greater"])):this.currentToken.tokenId!=TypeScript.TokenID.Colon?JAM.call(this.reportParseError,
this,["Expected identifier, string or number as accessor name"]):(skippedTokenForGetSetId=!0,memberName=TypeScript.Identifier,memberName=JAM.call(memberName.fromToken,memberName,[getSetTok]),memberName.minChar=getSetStartPos,memberName.limChar=getSetPos)}else(getSetTok=this.currentToken.tokenId==TypeScript.TokenID.Identifier)||(getSetTok=JAM.call(TypeScript.convertTokToIDName,TypeScript,[this.currentToken])),getSetTok?(idHint=this.currentToken.getText(),memberName=TypeScript.Identifier,memberName=
JAM.call(memberName.fromToken,memberName,[this.currentToken]),memberName.minChar=this.scanner.startPos,memberName.limChar=this.scanner.pos):this.currentToken.tokenId==TypeScript.TokenID.StringLiteral?(idHint=this.currentToken.getText(),memberName=JAM.new(TypeScript.StringLiteral,[idHint]),memberName.minChar=this.scanner.startPos,memberName.limChar=this.scanner.pos):this.currentToken.tokenId==TypeScript.TokenID.NumberLiteral?(idHint=this.currentToken,idHint=idHint.value.toString(),memberName=JAM.new(TypeScript.StringLiteral,
[idHint]),memberName.minChar=this.scanner.startPos,memberName.limChar=this.scanner.pos):(JAM.call(this.reportParseError,this,["Expected identifier, string or number as member name"]),this.errorRecovery&&(memberName=new TypeScript.MissingIdentifier,memberName.minChar=this.scanner.startPos,memberName.flags|=TypeScript.ASTFlags.Error,JAM.call(this.skip,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.Comma]),getSetTok=memberName,getSetStartPos=this.scanner.lastTokenLimChar(),getSetTok.limChar=getSetStartPos));
skippedTokenForGetSetId?skippedTokenForGetSetId=!1:this.currentToken=getSetTok=this.scanner.scan();this.currentToken.tokenId==TypeScript.TokenID.Question&&(memberName.flags|=TypeScript.ASTFlags.OptionalName,this.currentToken=getSetTok=this.scanner.scan());if(memberExpr){member=new TypeScript.ASTList;JAM.call(this.parseFormalParameterList,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.RParen,member,!1,!0,!1,!isSet,isSet,!1,null,!0]);memberExpr=JAM.call(this.parseFunctionStatements,this,[errorRecoverySet|
TypeScript.ErrorRecoverySet.RCurly,memberName,!1,!0,member,TypeScript.AllowedElements.None,this.scanner.startPos,!1,TypeScript.Modifiers.None]);if(member=isSet)member=memberExpr.returnTypeAnnotation;member&&JAM.call(this.reportParseError,this,["Property setters may not declare a return type"]);member=memberExpr.fncFlags;getSetTok=isSet?TypeScript.FncFlags.SetAccessor:TypeScript.FncFlags.GetAccessor;memberExpr.fncFlags=member|getSetTok;memberExpr.fncFlags|=TypeScript.FncFlags.IsFunctionExpression;
memberExpr.hint=idHint;member=JAM.new(TypeScript.BinaryExpression,[TypeScript.NodeType.Member,memberName,memberExpr]);member.minChar=memberName.minChar;memberExpr.nodeType==TypeScript.NodeType.FuncDecl&&(memberExpr.hint=idHint)}else if(this.currentToken.tokenId==TypeScript.TokenID.Colon)this.currentToken=member=this.scanner.scan(),memberExpr=JAM.call(this.parseExpr,this,[TypeScript.ErrorRecoverySet.Comma|errorRecoverySet,TypeScript.OperatorPrecedence.Comma,!0,TypeContext.NoTypes]),memberExpr.nodeType==
TypeScript.NodeType.TypeRef&&JAM.call(this.reportParseError,this,["Expected 'new' on array declaration in member definition"]),member=JAM.new(TypeScript.BinaryExpression,[TypeScript.NodeType.Member,memberName,memberExpr]),member.minChar=memberName.minChar,memberExpr.nodeType==TypeScript.NodeType.FuncDecl&&(memberExpr.hint=idHint);else if(JAM.call(this.reportParseError,this,["Expected ':' in member definition"]),this.errorRecovery)return JAM.call(this.skip,this,[errorRecoverySet]),elements.flags|=
TypeScript.ASTFlags.Error,elements.minChar=minChar,errorRecoverySet=elements,minChar=this.scanner.lastTokenLimChar(),errorRecoverySet.limChar=minChar,elements;idHint=null;JAM.call(elements.append,elements,[member]);memberExpr=member;getSetTok=this.scanner.lastTokenLimChar();memberExpr.limChar=getSetTok;if(this.currentToken.tokenId!=TypeScript.TokenID.Comma)break;else this.currentToken=memberExpr=this.scanner.scan();if(this.currentToken.tokenId==TypeScript.TokenID.CloseBrace)break}member&&(elements.limChar=
member.limChar);elements.minChar=minChar;return elements}function v573(errorRecoverySet,modifiers,allowIn,isStatic){var isConst=JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Readonly]),minChar=this.scanner.startPos,varDecl=null,declList=null,multivar=!1,v27215=this.scanner.scan();this.currentToken=v27215;for(v27215=this.parseComments();;){(varDecl=this.currentToken.tokenId!=TypeScript.TokenID.Identifier)&&(varDecl=!JAM.call(TypeScript.convertTokToID,TypeScript,[this.currentToken,
this.strictMode]));if(varDecl&&(JAM.call(this.reportParseError,this,["Expected identifier in variable declaration"]),this.errorRecovery))return varDecl=JAM.new(TypeScript.VarDecl,[new TypeScript.MissingIdentifier,this.nestingLevel]),varDecl.minChar=minChar,JAM.call(this.skip,this,[errorRecoverySet]),varDecl.flags|=TypeScript.ASTFlags.Error,errorRecoverySet=varDecl,modifiers=this.scanner.lastTokenLimChar(),errorRecoverySet.limChar=modifiers,varDecl;var varDecl=TypeScript.Identifier,varDecl=JAM.call(varDecl.fromToken,
varDecl,[this.currentToken]),v16641=this.strictMode;v16641&&(v16641="eval"==varDecl.text);v16641&&JAM.call(this.reportParseError,this,["'eval' may not name a variable in strict mode"]);varDecl=JAM.call(this.makeVarDecl,this,[varDecl,this.nestingLevel]);varDecl.id.minChar=this.scanner.startPos;varDecl.id.limChar=this.scanner.pos;varDecl.preComments=v27215;isStatic&&(varDecl.varFlags|=TypeScript.VarFlags.Static);JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Readonly])&&(varDecl.varFlags|=
TypeScript.VarFlags.Readonly);v16641=this.parsingDeclareFile;v16641||(v16641=this.ambientModule)||(v16641=JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Ambient]));v16641&&(varDecl.varFlags|=TypeScript.VarFlags.Ambient);v16641=this.parsingDeclareFile;v16641||(v16641=this.ambientModule)||(v16641=JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Exported]));v16641&&(varDecl.varFlags|=TypeScript.VarFlags.Exported);varDecl.minChar=minChar;declList&&JAM.call(declList.append,
declList,[varDecl]);this.currentToken=minChar=this.scanner.scan();if(this.currentToken.tokenId==TypeScript.TokenID.Colon){this.currentToken=minChar=this.scanner.scan();minChar=this.inFncDecl;this.inFncDecl=!1;var v16641=varDecl,v27219=JAM.call(this.parseTypeReference,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.Asg|TypeScript.ErrorRecoverySet.Comma,!1]);v16641.typeExpr=v27219;this.inFncDecl=minChar}this.currentToken.tokenId==TypeScript.TokenID.Equals?(JAM.call(TypeScript.hasFlag,TypeScript,
[varDecl.varFlags,TypeScript.VarFlags.Ambient])&&JAM.call(this.reportParseError,this,["Ambient variable can not have an initializer"]),this.currentToken=minChar=this.scanner.scan(),minChar=varDecl,v16641=JAM.call(this.parseExpr,this,[TypeScript.ErrorRecoverySet.Comma|errorRecoverySet,TypeScript.OperatorPrecedence.Comma,allowIn,TypeContext.NoTypes]),minChar.init=v16641,varDecl.limChar=varDecl.init.limChar,varDecl.init.nodeType==TypeScript.NodeType.FuncDecl&&(minChar=varDecl.init,minChar.hint=varDecl.id.actualText)):
(isConst&&JAM.call(this.reportParseError,this,["const declaration requires initializer"]),varDecl.limChar=this.scanner.pos);minChar=varDecl;v16641=JAM.call(this.parseCommentsForLine,this,[this.scanner.line]);minChar.postComments=v16641;if(this.currentToken.tokenId!=TypeScript.TokenID.Comma)return declList?(declList.limChar=varDecl.limChar,declList):varDecl;multivar||(declList=new TypeScript.ASTList,declList.minChar=varDecl.minChar,JAM.call(declList.append,declList,[varDecl]),multivar=!0);this.currentToken=
varDecl=this.scanner.scan();minChar=this.scanner.startPos}}function v572(errorRecoverySet,modifiers,requireSignature,isStatic){var text=null,minChar=this.scanner.startPos,nameLimChar=minChar,isNew=!1,isIndexer=!1,wasAccessorID=null!=this.prevIDTok,v8755=JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Getter]);v8755||(v8755=JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Setter]));var v16673=this.parsingDeclareFile;v16673||(v16673=this.ambientModule)||
(v16673=JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Ambient]));v16673&&(requireSignature=!0);(v16673=this.currentToken.tokenId==TypeScript.TokenID.OpenParen)&&(v16673=!wasAccessorID);if(v16673)(wasAccessorID=!requireSignature)&&(wasAccessorID=!isStatic),wasAccessorID&&(JAM.call(this.reportParseError,this,["Expected identifier in property declaration"]),this.errorRecovery&&(JAM.call(this.skip,this,[errorRecoverySet]),text=new TypeScript.MissingIdentifier));else if(this.currentToken.tokenId==
TypeScript.TokenID.New)requireSignature&&(this.currentToken=wasAccessorID=this.scanner.scan(),this.currentToken.tokenId==TypeScript.TokenID.OpenParen&&(isNew=!0)),isNew||(requireSignature||(this.currentToken=text=this.scanner.scan()),text=JAM.new(TypeScript.Identifier,["new"]),text.minChar=this.scanner.pos-3,nameLimChar=text.limChar=this.scanner.pos);else if((v16673=this.currentToken.tokenId==TypeScript.TokenID.OpenBracket)&&(v16673=requireSignature),v16673)isIndexer=!0,text=JAM.new(TypeScript.Identifier,
["__item"]);else if((v16673=this.currentToken.tokenId!=TypeScript.TokenID.Identifier)&&(v16673=!JAM.call(TypeScript.convertTokToIDName,TypeScript,[this.currentToken]))&&(v16673=!wasAccessorID),v16673){if(JAM.call(this.reportParseError,this,["Expected identifier in property declaration"]),this.errorRecovery)return modifiers=this.scanner.startPos,isStatic=this.scanner.pos,JAM.call(this.skip,this,[errorRecoverySet&~TypeScript.ErrorRecoverySet.Comma]),this.scanner.pos==isStatic&&(this.currentToken=isStatic=
this.scanner.scan()),isStatic=JAM.new(TypeScript.VarDecl,[new TypeScript.MissingIdentifier,this.nestingLevel]),isStatic.flags|=TypeScript.ASTFlags.Error,isStatic.minChar=modifiers,modifiers=isStatic,v8755=this.scanner.lastTokenLimChar(),modifiers.limChar=v8755,isStatic}else wasAccessorID?(text=TypeScript.Identifier,text=JAM.call(text.fromToken,text,[this.prevIDTok]),text.minChar=this.scanner.lastTokenLimChar()-3,nameLimChar=text,wasAccessorID=this.scanner.lastTokenLimChar(),nameLimChar.limChar=wasAccessorID,
nameLimChar=text.limChar,TypeScript.codeGenTarget<TypeScript.CodeGenTarget.ES5&&JAM.call(this.reportParseError,this,["Property accessors are only available when targeting ES5 or greater"]),(wasAccessorID=this.currentToken.getText()==text.actualText)&&(wasAccessorID=this.currentToken!=this.prevIDTok),wasAccessorID&&(this.currentToken=wasAccessorID=this.scanner.scan()),this.prevIDTok=null):(text=TypeScript.Identifier,text=JAM.call(text.fromToken,text,[this.currentToken]),text.minChar=this.scanner.startPos,
nameLimChar=text.limChar=this.scanner.pos,this.currentToken=wasAccessorID=this.scanner.scan());this.currentToken.tokenId==TypeScript.TokenID.Question&&((wasAccessorID=this.inInterfaceDecl)&&(wasAccessorID=text),wasAccessorID?text.flags|=TypeScript.ASTFlags.OptionalName:JAM.call(this.reportParseError,this,["Optional properties may only be declared on interface or object types"]),this.currentToken=wasAccessorID=this.scanner.scan());wasAccessorID=this.currentToken.tokenId==TypeScript.TokenID.OpenParen;
wasAccessorID||(wasAccessorID=isIndexer)&&(wasAccessorID=this.currentToken.tokenId==TypeScript.TokenID.OpenBracket);if(wasAccessorID){wasAccessorID=errorRecoverySet|TypeScript.ErrorRecoverySet.RParen;isIndexer&&(wasAccessorID=errorRecoverySet|TypeScript.ErrorRecoverySet.RBrack);errorRecoverySet=!this.inFncDecl;(v16673=this.parsingDeclareFile)||(v16673=JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Ambient]));errorRecoverySet=JAM.call(this.parseFncDecl,this,[wasAccessorID,!0,
requireSignature,errorRecoverySet,text,isIndexer,isStatic,v16673,modifiers,null,!0]);if(errorRecoverySet.nodeType==TypeScript.NodeType.Error)return errorRecoverySet;errorRecoverySet.name&&(errorRecoverySet.name.minChar=minChar,errorRecoverySet.name.limChar=nameLimChar);(modifiers&TypeScript.Modifiers.Public)!=TypeScript.Modifiers.None&&(errorRecoverySet.fncFlags|=TypeScript.FncFlags.Public);(modifiers&TypeScript.Modifiers.Private)!=TypeScript.Modifiers.None&&(errorRecoverySet.fncFlags|=TypeScript.FncFlags.Private);
isStatic&&(errorRecoverySet.fncFlags|=TypeScript.FncFlags.Static);(isStatic=this.parsingDeclareFile)||(isStatic=JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Ambient]));isStatic&&(errorRecoverySet.fncFlags|=TypeScript.FncFlags.Ambient);v8755&&(JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Getter])?(errorRecoverySet.fncFlags|=TypeScript.FncFlags.GetAccessor,errorRecoverySet.hint="get"+errorRecoverySet.name.actualText):(errorRecoverySet.fncFlags|=TypeScript.FncFlags.SetAccessor,
errorRecoverySet.hint="set"+errorRecoverySet.name.actualText),errorRecoverySet.fncFlags|=TypeScript.FncFlags.IsFunctionExpression,modifiers&TypeScript.Modifiers.Ambient&&JAM.call(this.reportParseError,this,["Property accessors may not be declared in ambient types"]));null==text&&(isNew?(errorRecoverySet.fncFlags|=TypeScript.FncFlags.ConstructMember,errorRecoverySet.hint="_construct",errorRecoverySet.classDecl=this.currentClassDecl):(errorRecoverySet.hint="_call",errorRecoverySet.fncFlags|=TypeScript.FncFlags.CallMember));
return errorRecoverySet}text=isNew=JAM.new(TypeScript.VarDecl,[text,this.nestingLevel]);isIndexer=this.parseComments();text.preComments=isIndexer;isNew.minChar=minChar;this.currentToken.tokenId==TypeScript.TokenID.Colon&&(this.currentToken=minChar=this.scanner.scan(),minChar=isNew,text=JAM.call(this.parseTypeReference,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.Asg|TypeScript.ErrorRecoverySet.Comma,!1]),minChar.typeExpr=text,(minChar=isNew.typeExpr)&&(minChar=isNew.typeExpr.nodeType==TypeScript.NodeType.TypeRef),
minChar&&(minChar=isNew.typeExpr,(text=minChar.term)&&(text=minChar.term.nodeType==TypeScript.NodeType.FuncDecl),text&&(minChar.term.preComments=isNew.preComments)));if(this.currentToken.tokenId==TypeScript.TokenID.Equals){if(requireSignature&&(JAM.call(this.reportParseError,this,["context does not permit variable initializer"]),this.errorRecovery))return JAM.call(this.skip,this,[errorRecoverySet]),isNew.flags|=TypeScript.ASTFlags.Error,modifiers=isNew,isStatic=this.scanner.lastTokenLimChar(),modifiers.limChar=
isStatic,isNew;this.currentToken=requireSignature=this.scanner.scan();requireSignature=isNew;errorRecoverySet=JAM.call(this.parseExpr,this,[TypeScript.ErrorRecoverySet.Comma|errorRecoverySet,TypeScript.OperatorPrecedence.Comma,!0,TypeContext.NoTypes]);requireSignature.init=errorRecoverySet;isNew.limChar=isNew.init.limChar;isNew.init.nodeType==TypeScript.NodeType.FuncDecl?(errorRecoverySet=isNew.init,errorRecoverySet.hint=isNew.id.text,errorRecoverySet.boundToProperty=isNew):v8755&&JAM.call(this.reportParseError,
this,["Accessors may only be functions"])}else isNew.limChar=this.scanner.pos;(modifiers&TypeScript.Modifiers.Readonly)!=TypeScript.Modifiers.None&&(isNew.varFlags|=TypeScript.VarFlags.Readonly);isStatic&&(isNew.varFlags|=TypeScript.VarFlags.Static);(modifiers&TypeScript.Modifiers.Public)!=TypeScript.Modifiers.None&&(isNew.varFlags|=TypeScript.VarFlags.Public);(modifiers&TypeScript.Modifiers.Private)!=TypeScript.Modifiers.None&&(isNew.varFlags|=TypeScript.VarFlags.Private);isNew.varFlags|=TypeScript.VarFlags.Property;
return isNew}function v571(id,nest){var varDecl=JAM.new(TypeScript.VarDecl,[id,nest]),currentVarList=this.topVarList();currentVarList&&JAM.call(currentVarList.append,currentVarList,[varDecl]);return varDecl}function v570(errorRecoverySet,modifiers){var leftCurlyCount=this.scanner.leftCurlyCount,rightCurlyCount=this.scanner.rightCurlyCount,v27238=this.scanner.scan();this.currentToken=v27238;var v27238=null,v16764=this.currentToken.tokenId==TypeScript.TokenID.Identifier;v16764||(v16764=!JAM.call(TypeScript.isPrimitiveTypeToken,
TypeScript,[this.currentToken]))&&(v16764=JAM.call(TypeScript.convertTokToID,TypeScript,[this.currentToken,this.strictMode]));v16764?(v27238=TypeScript.Identifier,v27238=JAM.call(v27238.fromToken,v27238,[this.currentToken]),v27238.minChar=this.scanner.startPos,v27238.limChar=this.scanner.pos,this.currentToken=v16764=this.scanner.scan()):(JAM.call(this.reportParseError,this,["interface missing name"]),this.errorRecovery&&(v27238=new TypeScript.MissingIdentifier,v27238.minChar=this.scanner.pos,v27238.limChar=
this.scanner.pos,v27238.flags|=TypeScript.ASTFlags.Error));var extendsList=null,v16764=null;(v16764=this.currentToken.tokenId===TypeScript.TokenID.Extends)||(v16764=this.currentToken.tokenId===TypeScript.TokenID.Implements);v16764&&(this.currentToken.tokenId===TypeScript.TokenID.Implements&&JAM.call(this.reportParseError,this,["Expected 'extends'"]),extendsList=new TypeScript.ASTList,v16764=new TypeScript.ASTList,extendsList.minChar=this.scanner.startPos,JAM.call(this.parseBaseList,this,[extendsList,
v16764,errorRecoverySet,!1]));var membersMinChar=this.scanner.startPos;JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.OpenBrace,errorRecoverySet|TypeScript.ErrorRecoverySet.TypeScriptS]);v16764=new TypeScript.ASTList;v16764.minChar=membersMinChar;membersMinChar=this.inInterfaceDecl;this.inInterfaceDecl=!0;JAM.call(this.parseTypeMemberList,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.RCurly,v16764]);this.inInterfaceDecl=membersMinChar;JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.CloseBrace,
errorRecoverySet]);v27238=JAM.new(TypeScript.InterfaceDeclaration,[v27238,v16764,extendsList,null]);JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Private])&&(v27238.varFlags|=TypeScript.VarFlags.Private);JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Public])&&(v27238.varFlags|=TypeScript.VarFlags.Public);extendsList=this.parsingDeclareFile;extendsList||(extendsList=this.ambientModule)||(extendsList=JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,
TypeScript.Modifiers.Exported]));extendsList&&(v27238.varFlags|=TypeScript.VarFlags.Exported);v27238.limChar=v16764.limChar;v27238.leftCurlyCount=this.scanner.leftCurlyCount-leftCurlyCount;v27238.rightCurlyCount=this.scanner.rightCurlyCount-rightCurlyCount;return v27238}function v569(errorRecoverySet,members){for(errorRecoverySet|=TypeScript.ErrorRecoverySet.TypeScriptS;;){switch(this.currentToken.tokenId){case TypeScript.TokenID.CloseBrace:case TypeScript.TokenID.EndOfFile:members.limChar=this.scanner.pos;
return}var element=JAM.call(this.parseTypeMember,this,[errorRecoverySet]);element&&JAM.call(members.append,members,[element])}}function v568(errorRecoverySet){var minChar=this.scanner.startPos,propertyDecl=JAM.call(this.parsePropertyDeclaration,this,[errorRecoverySet,TypeScript.Modifiers.Public,!0,!1]);propertyDecl&&(propertyDecl.minChar=minChar,propertyDecl.nodeType==TypeScript.NodeType.VarDecl&&JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.Semicolon,errorRecoverySet]));return propertyDecl}
function v567(methodName,minChar,errorRecoverySet,modifiers){var v8877=JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Getter]);v8877||(v8877=JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Setter]));var isStatic=JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Static]),v8879=this.ambientModule;v8879||(v8879=JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Ambient]));errorRecoverySet|=TypeScript.ErrorRecoverySet.RParen;
var v16798=v8877;v16798&&(v16798=modifiers&TypeScript.Modifiers.Ambient);v16798&&JAM.call(this.reportParseError,this,["Property accessors may not be declared in ambient classes"]);errorRecoverySet=JAM.call(this.parseFncDecl,this,[errorRecoverySet,!0,v8879,!0,methodName,!1,isStatic,v8879,modifiers,null,!0]);if(errorRecoverySet.nodeType==TypeScript.NodeType.Error)return errorRecoverySet;errorRecoverySet.minChar=minChar;null!==errorRecoverySet.bod&&(errorRecoverySet.limChar=errorRecoverySet.bod.limChar);
errorRecoverySet.fncFlags=modifiers&TypeScript.Modifiers.Private?errorRecoverySet.fncFlags|TypeScript.FncFlags.Private:errorRecoverySet.fncFlags|TypeScript.FncFlags.Public;isStatic&&(errorRecoverySet.fncFlags|=TypeScript.FncFlags.Static);v8877&&(JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Getter])?(errorRecoverySet.fncFlags|=TypeScript.FncFlags.GetAccessor,errorRecoverySet.hint="get"+errorRecoverySet.name.actualText):(errorRecoverySet.fncFlags|=TypeScript.FncFlags.SetAccessor,
errorRecoverySet.hint="set"+errorRecoverySet.name.actualText),errorRecoverySet.fncFlags|=TypeScript.FncFlags.IsFunctionExpression,TypeScript.codeGenTarget<TypeScript.CodeGenTarget.ES5&&JAM.call(this.reportParseError,this,["Property accessors are only available when targeting ES5 or greater",errorRecoverySet.minChar,errorRecoverySet.limChar]));errorRecoverySet.fncFlags|=TypeScript.FncFlags.ClassMethod;JAM.set(this.currentClassDefinition.knownMemberNames,methodName.actualText,!0);JAM.set(this.currentClassDefinition.members.members,
this.currentClassDefinition.members.members.length,errorRecoverySet);return errorRecoverySet}function v566(text,minChar,isDeclaredInConstructor,errorRecoverySet,modifiers){var varDecl=JAM.new(TypeScript.VarDecl,[text,this.nestingLevel]);varDecl.minChar=minChar;minChar=!1;var v8897=varDecl,v27240=this.parseComments();v8897.preComments=v27240;this.currentToken.tokenId==TypeScript.TokenID.Colon&&(this.currentToken=v8897=this.scanner.scan(),v8897=varDecl,v27240=JAM.call(this.parseTypeReference,this,[errorRecoverySet|
TypeScript.ErrorRecoverySet.Asg|TypeScript.ErrorRecoverySet.Comma,!1]),v8897.typeExpr=v27240,(v8897=varDecl.typeExpr)&&(v8897=varDecl.typeExpr.nodeType==TypeScript.NodeType.TypeRef),v8897&&(v8897=varDecl.typeExpr,(v27240=v8897.term)&&(v27240=v8897.term.nodeType==TypeScript.NodeType.FuncDecl),v27240&&(v8897.term.preComments=varDecl.preComments)));if(this.currentToken.tokenId==TypeScript.TokenID.Equals){(v8897=this.parsingDeclareFile)||(v8897=JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Ambient]));
if(v8897&&(JAM.call(this.reportParseError,this,["context does not permit variable initializer"]),this.errorRecovery))return JAM.call(this.skip,this,[errorRecoverySet]),varDecl.flags|=TypeScript.ASTFlags.Error,text=varDecl,isDeclaredInConstructor=this.scanner.lastTokenLimChar(),text.limChar=isDeclaredInConstructor,varDecl;this.currentToken=v8897=this.scanner.scan();v8897=varDecl;errorRecoverySet=JAM.call(this.parseExpr,this,[TypeScript.ErrorRecoverySet.Comma|errorRecoverySet,TypeScript.OperatorPrecedence.Comma,
!0,TypeContext.NoTypes]);v8897.init=errorRecoverySet;varDecl.limChar=varDecl.init.limChar;modifiers&TypeScript.Modifiers.Static||(errorRecoverySet=this.currentClassDefinition,errorRecoverySet.varFlags|=TypeScript.VarFlags.ClassSuperMustBeFirstCallInConstructor)}else varDecl.limChar=this.scanner.pos;modifiers&TypeScript.Modifiers.Static&&(varDecl.varFlags|=TypeScript.VarFlags.Static,minChar=!0);varDecl.varFlags=(modifiers&TypeScript.Modifiers.Private)!=TypeScript.Modifiers.None?varDecl.varFlags|TypeScript.VarFlags.Private:
varDecl.varFlags|TypeScript.VarFlags.Public;varDecl.varFlags|=TypeScript.VarFlags.Property;isDeclaredInConstructor&&(varDecl.varFlags|=TypeScript.VarFlags.ClassConstructorProperty);(modifiers=!isDeclaredInConstructor)&&(modifiers=!minChar);modifiers&&(varDecl.varFlags|=TypeScript.VarFlags.ClassBodyProperty);JAM.set(this.currentClassDefinition.knownMemberNames,text.actualText,!0);isDeclaredInConstructor||JAM.set(this.currentClassDefinition.members.members,this.currentClassDefinition.members.members.length,
varDecl);text=varDecl;isDeclaredInConstructor=this.parseComments();text.postComments=isDeclaredInConstructor;return varDecl}function v565(minChar,errorRecoverySet,modifiers){this.parsingClassConstructorDefinition=!0;var v8923=this.parsingDeclareFile;v8923||(v8923=JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Ambient]));var args=new TypeScript.ASTList,variableArgList=!1,preComments=this.parseComments(),v27247=this.scanner.scan();this.currentToken=v27247;this.currentToken.tokenId==
TypeScript.TokenID.OpenParen&&(variableArgList=JAM.call(this.parseFormalParameterList,this,[errorRecoverySet,args,!0,v8923,!1,!1,!1,!1,null,!0]));(v27247=v8923)||(v27247=this.currentToken.tokenId==TypeScript.TokenID.Semicolon);if(v27247)for(var i=0,v8935=i<args.members.length;v8935;){v8935=args.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v8935=v8935[i];JAM.call(TypeScript.hasFlag,TypeScript,[v8935.varFlags,TypeScript.VarFlags.Property])&&JAM.call(this.reportParseError,
this,["Overload or ambient signatures may not specify parameter properties",v8935.minChar,v8935.limChar]);i+=1;v8935=i<args.members.length}v27247||(this.currentClassDefinition.constructorNestingLevel=this.nestingLevel+1);minChar=JAM.call(this.parseFunctionStatements,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.RCurly,this.currentClassDefinition.name,!0,!1,args,TypeScript.AllowedElements.Properties,minChar,v27247,modifiers]);minChar.preComments=preComments;(errorRecoverySet=v27247)&&(errorRecoverySet=
!v8923);errorRecoverySet&&(minChar.isOverload=!0);minChar.variableArgList=variableArgList;this.currentClassDecl=null;variableArgList=minChar;errorRecoverySet=JAM.call(this.convertToTypeReference,this,[this.currentClassDefinition.name]);variableArgList.returnTypeAnnotation=errorRecoverySet;minChar.classDecl=this.currentClassDefinition;v8923&&(minChar.fncFlags|=TypeScript.FncFlags.Ambient);v27247&&(minChar.fncFlags|=TypeScript.FncFlags.Signature);(variableArgList=this.ambientModule)||(variableArgList=
JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Exported]));variableArgList&&(minChar.fncFlags|=TypeScript.FncFlags.Exported);this.currentClassDefinition.constructorDecl&&((modifiers=!v8923)&&(modifiers=!this.currentClassDefinition.constructorDecl.isSignature())&&(modifiers=!minChar.isSignature()),modifiers&&JAM.call(this.reportParseError,this,["Duplicate constructor definition"]));v8923||(v8923=!minChar.isSignature());v8923&&(this.currentClassDefinition.constructorDecl=minChar);
minChar.fncFlags|=TypeScript.FncFlags.ClassMethod;JAM.set(this.currentClassDefinition.members.members,this.currentClassDefinition.members.members.length,minChar);this.parsingClassConstructorDefinition=!1;return minChar}function v564(classDecl,errorRecoverySet,parentModifiers){var modifiers=parentModifiers,resetModifiers=!1,membersMinChar=this.scanner.startPos;JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.OpenBrace,errorRecoverySet]);this.nestingLevel+=1;var currentMemberMinChar=this.scanner.startPos,
wasGetOrSetId=!1,v21545=this.currentToken.tokenId==TypeScript.TokenID.CloseBrace;v21545||(v21545=this.currentToken.tokenId==TypeScript.TokenID.EndOfFile);for(v21545=!v21545;v21545;){var v21545=!0,publicOrPrivateFlags=TypeScript.Modifiers.Public|TypeScript.Modifiers.Private;if(this.currentToken.tokenId==TypeScript.TokenID.Get)modifiers&TypeScript.Modifiers.Getter&&JAM.call(this.reportParseError,this,["Duplicate 'get' declaration in class body"]),modifiers&TypeScript.Modifiers.Setter&&JAM.call(this.reportParseError,
this,["Getter already marked as a setter"]),modifiers|=TypeScript.Modifiers.Getter;else if(this.currentToken.tokenId==TypeScript.TokenID.Set)modifiers&TypeScript.Modifiers.Setter&&JAM.call(this.reportParseError,this,["Duplicate 'set' declaration in class body"]),modifiers&TypeScript.Modifiers.Getter&&JAM.call(this.reportParseError,this,["Setter already marked as a getter"]),modifiers|=TypeScript.Modifiers.Setter;else if(this.currentToken.tokenId==TypeScript.TokenID.Private)modifiers&publicOrPrivateFlags&&
JAM.call(this.reportParseError,this,["Multiple modifiers may not be applied to class members"]),modifiers|=TypeScript.Modifiers.Private;else if(this.currentToken.tokenId==TypeScript.TokenID.Public)modifiers&publicOrPrivateFlags&&JAM.call(this.reportParseError,this,["Multiple modifiers may not be applied to class members"]),modifiers|=TypeScript.Modifiers.Public;else if(this.currentToken.tokenId==TypeScript.TokenID.Static)modifiers&TypeScript.Modifiers.Static&&JAM.call(this.reportParseError,this,["Multiple modifiers may not be applied to class members"]),
modifiers|=TypeScript.Modifiers.Static;else if(this.currentToken.tokenId==TypeScript.TokenID.Constructor)modifiers!=parentModifiers&&JAM.call(this.reportParseError,this,["Constructors may not have modifiers"]),JAM.call(this.parseClassConstructorDeclaration,this,[currentMemberMinChar,errorRecoverySet,modifiers]),v21545=!1,resetModifiers=!0;else if(publicOrPrivateFlags=wasGetOrSetId,publicOrPrivateFlags||(publicOrPrivateFlags=this.currentToken.tokenId==TypeScript.TokenID.Identifier)||(publicOrPrivateFlags=
JAM.call(TypeScript.convertTokToIDName,TypeScript,[this.currentToken])),publicOrPrivateFlags)resetModifiers=wasGetOrSetId?modifiers&TypeScript.Modifiers.Getter?"get":"set":this.currentToken.getText(),wasGetOrSetId?resetModifiers=JAM.new(TypeScript.Identifier,[resetModifiers]):(resetModifiers=TypeScript.Identifier,resetModifiers=JAM.call(resetModifiers.fromToken,resetModifiers,[this.currentToken])),resetModifiers.minChar=this.scanner.startPos,resetModifiers.limChar=this.scanner.pos,wasGetOrSetId?(wasGetOrSetId=
modifiers&TypeScript.Modifiers.Getter?TypeScript.Modifiers.Getter:TypeScript.Modifiers.Setter,modifiers^=wasGetOrSetId,wasGetOrSetId=!1):this.currentToken=publicOrPrivateFlags=this.scanner.scan(),this.currentToken.tokenId==TypeScript.TokenID.OpenParen?(JAM.call(this.parseClassMemberFunctionDeclaration,this,[resetModifiers,currentMemberMinChar,errorRecoverySet,modifiers]),v21545=!1):((publicOrPrivateFlags=modifiers&TypeScript.Modifiers.Getter)||(publicOrPrivateFlags=modifiers&TypeScript.Modifiers.Setter),
publicOrPrivateFlags&&JAM.call(this.reportParseError,this,["Property accessors must be functions"]),resetModifiers=JAM.call(this.parseClassMemberVariableDeclaration,this,[resetModifiers,currentMemberMinChar,!1,errorRecoverySet,modifiers]),(publicOrPrivateFlags=resetModifiers.init)&&(publicOrPrivateFlags=resetModifiers.init.nodeType==TypeScript.NodeType.FuncDecl),publicOrPrivateFlags?this.currentToken.tokenId==TypeScript.TokenID.CloseBrace&&(v21545=!1):((publicOrPrivateFlags=resetModifiers.init)&&
(publicOrPrivateFlags=resetModifiers.init.nodeType==TypeScript.NodeType.ObjectLit)&&(publicOrPrivateFlags=this.currentToken.tokenId!=TypeScript.TokenID.Semicolon),publicOrPrivateFlags?(v21545=!1,resetModifiers=resetModifiers.init,resetModifiers.flags|=TypeScript.ASTFlags.AutomaticSemicolon):this.currentToken.tokenId!=TypeScript.TokenID.Semicolon&&(JAM.call(this.reportParseError,this,["Expected ';'"]),v21545=!1))),resetModifiers=!0;else if(this.currentToken.tokenId==TypeScript.TokenID.Super)JAM.call(this.reportParseError,
this,["Base class initializers must be the first statement in a class definition"]);else{if(publicOrPrivateFlags=!wasGetOrSetId)(publicOrPrivateFlags=modifiers&TypeScript.Modifiers.Getter)||(publicOrPrivateFlags=modifiers&TypeScript.Modifiers.Setter),publicOrPrivateFlags&&(publicOrPrivateFlags=this.currentToken.tokenId==TypeScript.TokenID.OpenParen,publicOrPrivateFlags||(publicOrPrivateFlags=this.currentToken.tokenId==TypeScript.TokenID.Equals,publicOrPrivateFlags||(publicOrPrivateFlags=this.currentToken.tokenId==
TypeScript.TokenID.Colon)||(publicOrPrivateFlags=this.currentToken.tokenId==TypeScript.TokenID.Semicolon)));publicOrPrivateFlags?(wasGetOrSetId=!0,v21545=!1):this.currentToken.tokenId!=TypeScript.TokenID.Semicolon&&(JAM.call(this.reportParseError,this,["Unexpected '"+this.currentToken.getText()+"' in class definition"]),resetModifiers=!0)}v21545&&(this.currentToken=v21545=this.scanner.scan(),void 0===this.currentToken&&(this.currentToken=v21545=this.scanner.scan()));resetModifiers&&(modifiers=parentModifiers,
currentMemberMinChar=this.scanner.startPos,resetModifiers=!1);(v21545=this.currentToken.tokenId==TypeScript.TokenID.CloseBrace)||(v21545=this.currentToken.tokenId==TypeScript.TokenID.EndOfFile);v21545=!v21545}errorRecoverySet=this.scanner.pos;this.currentToken.tokenId==TypeScript.TokenID.CloseBrace&&(parentModifiers=classDecl,modifiers=new TypeScript.ASTSpan,parentModifiers.endingToken=modifiers,classDecl.endingToken.minChar=this.scanner.startPos,classDecl.endingToken.limChar=this.scanner.pos,this.currentClassDefinition.members.members.length||
(classDecl=this.currentClassDefinition,parentModifiers=this.parseComments(),classDecl.preComments=parentModifiers),this.currentToken=classDecl=this.scanner.scan());this.nestingLevel-=1;this.currentClassDefinition.members.minChar=membersMinChar;this.currentClassDefinition.members.limChar=errorRecoverySet;this.currentClassDefinition.limChar=errorRecoverySet;this.currentClassDefinition=null}function v563(errorRecoverySet,minChar,modifiers){minChar=this.scanner.leftCurlyCount;var rightCurlyCount=this.scanner.rightCurlyCount;
(modifiers&TypeScript.Modifiers.Readonly)!=TypeScript.Modifiers.None&&JAM.call(this.reportParseError,this,["const modifier is implicit for class"]);var v16954=this.parsingDeclareFile;v16954||(v16954=this.ambientModule);v16954&&(modifiers|=TypeScript.Modifiers.Ambient,modifiers|=TypeScript.Modifiers.Exported);(v16954=this.parsingDeclareFile)||(v16954=(modifiers&TypeScript.Modifiers.Ambient)!=TypeScript.Modifiers.None);var classIsMarkedAsAmbient=v16954,v16954=this.ambientClass;this.ambientClass=classIsMarkedAsAmbient;
this.currentToken=classIsMarkedAsAmbient=this.scanner.scan();var classIsMarkedAsAmbient=null,v16960=this.currentToken.tokenId==TypeScript.TokenID.Identifier;v16960||(v16960=!JAM.call(TypeScript.isPrimitiveTypeToken,TypeScript,[this.currentToken]))&&(v16960=JAM.call(TypeScript.convertTokToID,TypeScript,[this.currentToken,this.strictMode]));v16960?(classIsMarkedAsAmbient=TypeScript.Identifier,classIsMarkedAsAmbient=JAM.call(classIsMarkedAsAmbient.fromToken,classIsMarkedAsAmbient,[this.currentToken]),
classIsMarkedAsAmbient.minChar=this.scanner.startPos,classIsMarkedAsAmbient.limChar=this.scanner.pos,this.currentToken=v16960=this.scanner.scan()):(JAM.call(this.reportParseError,this,["class missing name"]),this.errorRecovery&&(classIsMarkedAsAmbient=new TypeScript.MissingIdentifier,classIsMarkedAsAmbient.minChar=this.scanner.pos,classIsMarkedAsAmbient.limChar=this.scanner.pos,classIsMarkedAsAmbient.flags|=TypeScript.ASTFlags.Error));var implementsList=v16960=null,v16963=this.currentToken.tokenId==
TypeScript.TokenID.Extends;v16963||(v16963=this.currentToken.tokenId==TypeScript.TokenID.Implements);v16963&&(v16960=new TypeScript.ASTList,implementsList=new TypeScript.ASTList,JAM.call(this.parseBaseList,this,[v16960,implementsList,errorRecoverySet,!0]));this.currentClassDefinition=classIsMarkedAsAmbient=JAM.new(TypeScript.ClassDeclaration,[classIsMarkedAsAmbient,new TypeScript.ASTList,v16960,implementsList]);JAM.call(this.parseClassElements,this,[classIsMarkedAsAmbient,errorRecoverySet,modifiers]);
errorRecoverySet=this.ambientModule;errorRecoverySet||(errorRecoverySet=this.parsingDeclareFile)||(errorRecoverySet=JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Exported]));errorRecoverySet&&(classIsMarkedAsAmbient.varFlags|=TypeScript.VarFlags.Exported);(errorRecoverySet=this.ambientModule)||(errorRecoverySet=JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Ambient]));errorRecoverySet&&(classIsMarkedAsAmbient.varFlags|=TypeScript.VarFlags.Ambient);
classIsMarkedAsAmbient.varFlags|=TypeScript.VarFlags.Class;this.ambientClass=v16954;classIsMarkedAsAmbient.leftCurlyCount=this.scanner.leftCurlyCount-minChar;classIsMarkedAsAmbient.rightCurlyCount=this.scanner.rightCurlyCount-rightCurlyCount;return classIsMarkedAsAmbient}function v562(extendsList,implementsList,errorRecoverySet,isClass){for(var keyword=!0,currentList=extendsList;;){keyword&&(this.currentToken.tokenId===TypeScript.TokenID.Implements?currentList=implementsList:((keyword=this.currentToken.tokenId==
TypeScript.TokenID.Extends)&&(keyword=!this.requiresExtendsBlock),keyword&&(this.requiresExtendsBlock=isClass)),this.currentToken=keyword=this.scanner.scan(),keyword=!1);var baseName=null,v16978=this.currentToken.tokenId==TypeScript.TokenID.Identifier;v16978||(v16978=JAM.call(TypeScript.convertTokToID,TypeScript,[this.currentToken,this.strictMode]));v16978?(v16978=this.scanner.startPos,baseName=TypeScript.Identifier,baseName=JAM.call(baseName.fromToken,baseName,[this.currentToken]),baseName.minChar=
v16978,baseName.limChar=this.scanner.pos,baseName=JAM.call(this.parseNamedType,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.LCurly,v16978,baseName,!1])):(JAM.call(this.reportParseError,this,["Expected base name"]),this.errorRecovery&&(baseName=new TypeScript.MissingIdentifier,baseName.minChar=this.scanner.pos,baseName.limChar=this.scanner.pos,baseName.flags|=TypeScript.ASTFlags.Error));this.currentToken.tokenId==TypeScript.TokenID.OpenParen?isClass?JAM.call(this.reportParseError,this,["Base classes may only be initialized via a 'super' call within the constructor body"]):
JAM.call(this.reportParseError,this,["Interfaces may not be extended with a call expression"]):JAM.call(currentList.append,currentList,[baseName]);(baseName=isClass)&&(baseName=currentList==extendsList)&&(baseName=1<extendsList.members.length);baseName&&JAM.call(this.reportParseError,this,["A class may only extend one other class"]);if(this.currentToken.tokenId==TypeScript.TokenID.Comma)this.currentToken=baseName=this.scanner.scan();else if((currentList=this.currentToken.tokenId==TypeScript.TokenID.Extends)||
(currentList=this.currentToken.tokenId==TypeScript.TokenID.Implements),currentList)(currentList=this.currentToken.tokenId==TypeScript.TokenID.Extends)&&(currentList=!this.requiresExtendsBlock),currentList&&(this.requiresExtendsBlock=isClass),currentList=extendsList,keyword=!0;else break}}function v561(errorRecoverySet){var args=new TypeScript.ASTList;args.minChar=this.scanner.startPos;var v27259=this.scanner.scan();this.currentToken=v27259;if(this.currentToken.tokenId!==TypeScript.TokenID.CloseParen)for(;;){if(65535<
args.members.length){JAM.call(this.reportParseError,this,["max number of args exceeded"]);break}v27259=JAM.call(this.parseExpr,this,[TypeScript.ErrorRecoverySet.Comma|errorRecoverySet,TypeScript.OperatorPrecedence.Comma,!0,TypeContext.NoTypes]);JAM.call(args.append,args,[v27259]);if(this.currentToken.tokenId!=TypeScript.TokenID.Comma)break;this.currentToken=v27259=this.scanner.scan()}args.limChar=this.scanner.pos;return args}function v560(ast){var result;switch(ast.nodeType){case TypeScript.NodeType.TypeRef:return ast;
case TypeScript.NodeType.Name:return result=JAM.new(TypeScript.TypeReference,[ast,0]),result.minChar=ast.minChar,result.limChar=ast.limChar,result;case TypeScript.NodeType.Index:return(result=JAM.call(this.convertToTypeReference,this,[ast.operand1]))?(result.arrayCount+=1,result.minChar=ast.minChar,result.limChar=ast.limChar,result):result=JAM.new(TypeScript.AST,[TypeScript.NodeType.Error])}return null}function v559(errorRecoverySet,isDecl,requiresSignature,isMethod,methodName,indexer,isStatic,markedAsAmbient,
modifiers,lambdaArgContext,expectClosingRParen){var leftCurlyCount=this.scanner.leftCurlyCount,rightCurlyCount=this.scanner.rightCurlyCount,prevInConstr=this.parsingClassConstructorDefinition;this.parsingClassConstructorDefinition=!1;var name=null,fnMin=this.scanner.startPos,minChar=this.scanner.pos,prevNestingLevel=this.nestingLevel,preComments=this.parseComments(),isLambda=!!lambdaArgContext;this.nestingLevel=0;var v16998=!this.style_funcInLoop;v16998&&(v16998=this.inLoop());v16998&&JAM.call(this.reportParseStyleError,
this,["function declaration in loop"]);(v16998=!isMethod)&&(v16998=!isStatic)&&(v16998=!indexer)&&(v16998=!lambdaArgContext);if(v16998)if(this.currentToken=methodName=this.scanner.scan(),this.state=ParseState.StartFncDecl,(methodName=this.currentToken.tokenId!=TypeScript.TokenID.Identifier)&&(methodName=!JAM.call(TypeScript.convertTokToID,TypeScript,[this.currentToken,this.strictMode])),methodName){if(isDecl)return JAM.call(this.reportParseError,this,["Function declaration must include identifier"]),
this.nestingLevel=prevNestingLevel,JAM.new(TypeScript.IncompleteAST,[fnMin,this.scanner.pos])}else name=TypeScript.Identifier,name=JAM.call(name.fromToken,name,[this.currentToken]),name.minChar=this.scanner.startPos,name.limChar=this.scanner.pos,this.currentToken=fnMin=this.scanner.scan();else methodName&&(name=methodName);this.state=ParseState.FncDeclName;methodName=new TypeScript.ASTList;var fnMin=v16998=!1,isGetter=JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Getter]),
isSetter=JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Setter]),v17004=this.currentToken.tokenId==TypeScript.TokenID.OpenParen;v17004||((v17004=indexer)&&(v17004=this.currentToken.tokenId==TypeScript.TokenID.OpenBracket),v17004||!(v17004=lambdaArgContext))||(v17004=lambdaArgContext.preProcessedLambdaArgs)||(v17004=this.currentToken.tokenId==TypeScript.TokenID.DotDotDot);v17004&&(v16998=lambdaArgContext?lambdaArgContext.preProcessedLambdaArgs:null,v16998=JAM.call(this.parseFormalParameterList,
this,[errorRecoverySet,methodName,!1,requiresSignature,indexer,isGetter,isSetter,isLambda,v16998,expectClosingRParen]));this.state=ParseState.FncDeclArgs;expectClosingRParen=null;this.currentToken.tokenId==TypeScript.TokenID.Colon&&(this.currentToken=expectClosingRParen=this.scanner.scan(),JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Setter])&&JAM.call(this.reportParseError,this,["Property setters may not declare a return type"]),expectClosingRParen=JAM.call(this.parseTypeReference,
this,[errorRecoverySet,!0]));(modifiers=indexer)&&(modifiers=0==methodName.members.length);modifiers&&JAM.call(this.reportParseError,this,["Index signatures require a parameter type to be specified"]);this.state=ParseState.FncDeclReturnType;isLambda&&(isLambda=this.currentToken.tokenId!=TypeScript.TokenID.EqualsGreaterThan);isLambda&&JAM.call(this.reportParseError,this,["Expected '=>'"]);if(isDecl){(isDecl=this.parsingDeclareFile)||(isDecl=markedAsAmbient);if(markedAsAmbient=!isDecl)markedAsAmbient=
!isMethod,markedAsAmbient||(markedAsAmbient=this.ambientModule,markedAsAmbient||(markedAsAmbient=this.ambientClass,markedAsAmbient||(markedAsAmbient=this.inInterfaceDecl)),markedAsAmbient=!markedAsAmbient),markedAsAmbient&&(markedAsAmbient=this.currentToken.tokenId==TypeScript.TokenID.Semicolon);isDecl=markedAsAmbient}isDecl&&(requiresSignature=fnMin=!0);markedAsAmbient=this.inFncDecl;this.inFncDecl=!0;errorRecoverySet=JAM.call(this.parseFunctionStatements,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.RCurly,
name,!1,isMethod,methodName,TypeScript.AllowedElements.None,minChar,requiresSignature,TypeScript.Modifiers.None]);this.inFncDecl=markedAsAmbient;errorRecoverySet.variableArgList=v16998;errorRecoverySet.isOverload=fnMin;requiresSignature||(errorRecoverySet.fncFlags|=TypeScript.FncFlags.Definition);isStatic&&(errorRecoverySet.fncFlags|=TypeScript.FncFlags.Static);requiresSignature&&(errorRecoverySet.fncFlags|=TypeScript.FncFlags.Signature);indexer&&(errorRecoverySet.fncFlags|=TypeScript.FncFlags.IndexerMember);
errorRecoverySet.returnTypeAnnotation=expectClosingRParen;isMethod&&(errorRecoverySet.fncFlags|=TypeScript.FncFlags.Method,errorRecoverySet.fncFlags|=TypeScript.FncFlags.ClassPropertyMethodExported);errorRecoverySet.leftCurlyCount=this.scanner.leftCurlyCount-leftCurlyCount;errorRecoverySet.rightCurlyCount=this.scanner.rightCurlyCount-rightCurlyCount;this.nestingLevel=prevNestingLevel;this.parsingClassConstructorDefinition=prevInConstr;errorRecoverySet.preComments=preComments;return errorRecoverySet}
function v558(errorRecoverySet,formals,isClassConstr,isSig,isIndexer,isGetter,isSetter,isLambda,preProcessedLambdaArgs,expectClosingRParen){formals.minChar=this.scanner.startPos;if(isIndexer){var v27264=this.scanner.scan();this.currentToken=v27264}else isLambda||JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.OpenParen,errorRecoverySet|TypeScript.ErrorRecoverySet.RParen]);var v27264=!1,firstArg=!0,hasOptional=!1,haveFirstArgID=!1;isLambda&&(isLambda=preProcessedLambdaArgs)&&(isLambda=preProcessedLambdaArgs.nodeType!=
TypeScript.NodeType.EmptyExpr);isLambda&&(hasOptional=JAM.call(this.transformAnonymousArgsIntoFormals,this,[formals,preProcessedLambdaArgs]),haveFirstArgID=!0);for(;;){preProcessedLambdaArgs=!1;isLambda=TypeScript.VarFlags.None;var argMinChar=this.scanner.startPos,v17032=this.inferPropertiesFromThisAssignment;v17032&&(v17032=this.currentToken.tokenId==TypeScript.TokenID.This);v17032&&(isClassConstr||JAM.call(this.reportParseError,this,["Instance property declarations using 'this' may only be used in class constructors"]),
this.currentToken=v17032=this.scanner.scan(),isLambda=isLambda|TypeScript.VarFlags.Public|TypeScript.VarFlags.Property,this.currentClassDefinition&&(v17032=this.currentClassDefinition,v17032.varFlags|=TypeScript.VarFlags.ClassSuperMustBeFirstCallInConstructor));this.currentToken.tokenId==TypeScript.TokenID.Public?(isLambda=isLambda|TypeScript.VarFlags.Public|TypeScript.VarFlags.Property,this.currentClassDefinition&&(v17032=this.currentClassDefinition,v17032.varFlags|=TypeScript.VarFlags.ClassSuperMustBeFirstCallInConstructor)):
this.currentToken.tokenId==TypeScript.TokenID.Private?(isLambda=isLambda|TypeScript.VarFlags.Private|TypeScript.VarFlags.Property,this.currentClassDefinition&&(v17032=this.currentClassDefinition,v17032.varFlags|=TypeScript.VarFlags.ClassSuperMustBeFirstCallInConstructor)):((v17032=this.currentToken.tokenId==TypeScript.TokenID.Static)&&(v17032=isClassConstr),v17032&&(JAM.call(this.reportParseError,this,["Static properties can not be declared as parameter properties"]),this.currentToken=v17032=this.scanner.scan()));
isLambda!=TypeScript.VarFlags.None?(isClassConstr||JAM.call(this.reportParseError,this,["only constructor parameters can be properties"]),this.currentToken=v17032=this.scanner.scan(),JAM.call(TypeScript.isModifier,TypeScript,[this.currentToken])&&(JAM.call(this.reportParseError,this,["Multiple modifiers may not be applied to parameters"]),this.currentToken=v17032=this.scanner.scan()),(v17032=this.inferPropertiesFromThisAssignment)&&(v17032=this.currentToken.tokenId==TypeScript.TokenID.This),v17032&&
(isClassConstr||JAM.call(this.reportParseError,this,["Instance property declarations using 'this' may only be used in class constructors"]),this.currentToken=v17032=this.scanner.scan(),this.currentToken=v17032=this.scanner.scan())):this.currentToken.tokenId==TypeScript.TokenID.DotDotDot&&(v27264=!0,this.currentToken=v17032=this.scanner.scan(),(v17032=this.currentToken.tokenId!=TypeScript.TokenID.Identifier)||(v17032=JAM.call(TypeScript.convertTokToID,TypeScript,[this.currentToken,this.strictMode])),
v17032&&(JAM.call(this.reportParseError,this,["'...' parameters require both a parameter name and an array type annotation to be specified"]),v27264=!1));var argId=null;(v17032=!haveFirstArgID)&&(v17032=this.currentToken.tokenId==TypeScript.TokenID.Identifier);v17032||(v17032=JAM.call(TypeScript.convertTokToID,TypeScript,[this.currentToken,this.strictMode]));v17032&&(v17032=TypeScript.Identifier,argId=JAM.call(v17032.fromToken,v17032,[this.currentToken]),argId.minChar=this.scanner.startPos,argId.limChar=
this.scanner.pos);if(haveFirstArgID||argId){preProcessedLambdaArgs=!0;var type=null,v17032=null;if(v17032=haveFirstArgID)v17032=formals.members.length;v17032?(v17032=formals.members[formals.members.length-1],v17032.isOptional&&(hasOptional=!0)):(v17032=JAM.new(TypeScript.ArgDecl,[argId]),isGetter&&JAM.call(this.reportParseError,this,["Property getters may not take any arguments"]),(argId=isSetter)&&(argId=!firstArg),argId&&JAM.call(this.reportParseError,this,["Property setters may only take one argument"]),
v17032.minChar=argMinChar,firstArg=v17032,argMinChar=this.parseComments(),firstArg.preComments=argMinChar,this.currentToken=firstArg=this.scanner.scan());this.currentToken.tokenId==TypeScript.TokenID.Question&&(hasOptional=v17032.isOptional=!0,this.currentToken=firstArg=this.scanner.scan());this.currentToken.tokenId==TypeScript.TokenID.Colon&&(this.currentToken=firstArg=this.scanner.scan(),type=JAM.call(this.parseTypeReference,this,[errorRecoverySet,!1]));this.currentToken.tokenId==TypeScript.TokenID.Equals&&
(isSig&&JAM.call(this.reportParseError,this,["Arguments in signatures may not have default values"]),hasOptional=!0,this.currentToken=firstArg=this.scanner.scan(),firstArg=v17032,argMinChar=JAM.call(this.parseExpr,this,[TypeScript.ErrorRecoverySet.Comma|errorRecoverySet,TypeScript.OperatorPrecedence.Comma,!1,TypeContext.NoTypes]),firstArg.init=argMinChar);(firstArg=hasOptional)&&(firstArg=!v17032.isOptionalArg())&&(firstArg=!v27264);firstArg&&JAM.call(this.reportParseError,this,["Optional parameters may only be followed by other optional parameters"]);
(firstArg=v27264)&&(firstArg=v17032.isOptionalArg());firstArg&&JAM.call(this.reportParseError,this,["Varargs may not be optional or have default parameters"]);(firstArg=v27264)&&(firstArg=!type);firstArg&&JAM.call(this.reportParseError,this,["'...' parameters require both a parameter name and an array type annotation to be specified"]);firstArg=v17032;argMinChar=this.parseComments();firstArg.postComments=argMinChar;v17032.typeExpr=type;firstArg=v17032;argMinChar=this.scanner.lastTokenLimChar();firstArg.limChar=
argMinChar;v17032.varFlags|=isLambda;haveFirstArgID?haveFirstArgID=!1:JAM.call(formals.append,formals,[v17032])}firstArg=!1;if(this.currentToken.tokenId==TypeScript.TokenID.Comma)preProcessedLambdaArgs&&(preProcessedLambdaArgs=!v27264),preProcessedLambdaArgs?this.currentToken=preProcessedLambdaArgs=this.scanner.scan():(JAM.call(this.reportParseError,this,["Unexpected ',' in argument list"]),this.errorRecovery&&(this.currentToken=preProcessedLambdaArgs=this.scanner.scan()));else break}isIndexer?JAM.call(this.checkCurrentToken,
this,[TypeScript.TokenID.CloseBracket,errorRecoverySet|TypeScript.ErrorRecoverySet.LCurly|TypeScript.ErrorRecoverySet.SColon]):expectClosingRParen&&JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.CloseParen,errorRecoverySet|TypeScript.ErrorRecoverySet.LCurly|TypeScript.ErrorRecoverySet.SColon]);errorRecoverySet=formals;formals=this.scanner.lastTokenLimChar();errorRecoverySet.limChar=formals;return v27264}function v557(formals,argList){function translateBinExOperand(operand){if(operand.nodeType==
TypeScript.NodeType.Comma)return JAM.call(_this.transformAnonymousArgsIntoFormals,_this,[formals,operand]);var v17077=operand.nodeType==TypeScript.NodeType.Name;v17077||(v17077=operand.nodeType==TypeScript.NodeType.Asg);if(v17077){var opArg=v17077=operand.nodeType==TypeScript.NodeType.Asg?operand.operand1:operand,v17077=JAM.new(TypeScript.ArgDecl,[opArg]);v17077.preComments=opArg.preComments;v17077.postComments=opArg.postComments;v17077.minChar=operand.minChar;v17077.limChar=operand.limChar;JAM.call(TypeScript.hasFlag,
TypeScript,[opArg.flags,TypeScript.ASTFlags.PossibleOptionalParameter])&&(v17077.isOptional=!0);operand.nodeType==TypeScript.NodeType.Asg&&(v17077.init=operand.operand2);JAM.call(formals.append,formals,[v17077]);operand=v17077.isOptional;operand||(operand=v17077.init);return operand}JAM.call(_this.reportParseError,_this,["Invalid lambda argument"]);return!1}var _this=this;if(argList){if(argList.nodeType==TypeScript.NodeType.Comma){var commaList=argList;commaList.operand1.isParenthesized&&JAM.call(this.reportParseError,
this,["Invalid lambda argument",commaList.operand1.minChar,commaList.operand1.limChar]);commaList.operand2.isParenthesized&&JAM.call(this.reportParseError,this,["Invalid lambda argument",commaList.operand2.minChar,commaList.operand2.limChar]);var isOptional=translateBinExOperand(commaList.operand1);(commaList=translateBinExOperand(commaList.operand2))||(commaList=isOptional);return isOptional=commaList}return translateBinExOperand(argList)}}function v556(errorRecoverySet,name,isConstructor,isMethod,
args,allowedElements,minChar,requiresSignature,parentModifiers){this.pushDeclLists();var svStmtStack=this.statementInfoStack;this.resetStmtStack();var bod=null,wasShorthand=!1,isAnonLambda=!1;if(requiresSignature)if(isMethod=this.scanner.pos,this.currentToken.tokenId===TypeScript.TokenID.OpenBrace){JAM.call(this.reportParseError,this,["Function declarations are not permitted within interfaces, ambient modules or classes"]);var bod=new TypeScript.ASTList,bodMinChar=this.scanner.startPos;JAM.call(this.parseFunctionBlock,
this,[errorRecoverySet,allowedElements,parentModifiers,bod,bodMinChar]);JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.CloseBrace,errorRecoverySet]);this.currentToken.tokenId===TypeScript.TokenID.Semicolon&&(this.currentToken=bodMinChar=this.scanner.scan())}else JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.Semicolon,errorRecoverySet,"Expected ';'"]);else bod=new TypeScript.ASTList,bodMinChar=this.scanner.startPos,this.currentToken.tokenId==TypeScript.TokenID.EqualsGreaterThan&&
(isMethod&&JAM.call(this.reportParseError,this,["'=>' may not be used for class methods"]),wasShorthand=!0,this.currentToken=isMethod=this.scanner.scan()),(isMethod=wasShorthand)&&(isMethod=this.currentToken.tokenId!=TypeScript.TokenID.OpenBrace),isMethod?(isMethod=JAM.call(this.parseExpr,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.SColon,TypeScript.OperatorPrecedence.Assignment,!0,TypeContext.NoTypes]),allowedElements=new TypeScript.ReturnStatement,allowedElements.returnExpression=isMethod,
allowedElements.minChar=isMethod.minChar,allowedElements.limChar=isMethod.limChar,bod.minChar=bodMinChar,JAM.call(bod.append,bod,[allowedElements])):(isAnonLambda=wasShorthand,JAM.call(this.parseFunctionBlock,this,[errorRecoverySet,allowedElements,parentModifiers,bod,bodMinChar])),isMethod=this.scanner.pos;name=JAM.new(TypeScript.FuncDecl,[name,bod,isConstructor,args,this.topVarList(),this.topScopeList(),this.topStaticsList(),TypeScript.NodeType.FuncDecl]);this.popDeclLists();isConstructor=this.topScopeList();
JAM.call(isConstructor.append,isConstructor,[name]);requiresSignature||((wasShorthand=!wasShorthand)||(wasShorthand=isAnonLambda),wasShorthand?(bod=name,wasShorthand=new TypeScript.ASTSpan,bod.endingToken=wasShorthand,name.endingToken.minChar=this.scanner.startPos,name.endingToken.limChar=this.scanner.pos,JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.CloseBrace,errorRecoverySet]),isAnonLambda&&(name.fncFlags|=TypeScript.FncFlags.IsFatArrowFunction)):(name.fncFlags|=TypeScript.FncFlags.IsFatArrowFunction,
errorRecoverySet=name,isAnonLambda=new TypeScript.ASTSpan,errorRecoverySet.endingToken=isAnonLambda,name.endingToken.minChar=bod.members[0].minChar,name.endingToken.limChar=bod.members[0].limChar));name.minChar=minChar;name.limChar=isMethod;requiresSignature||(name.fncFlags|=TypeScript.FncFlags.Definition);this.statementInfoStack=svStmtStack;return name}function v555(errorRecoverySet,allowedElements,parentModifiers,bod,bodMinChar){this.state=ParseState.StartStatementList;JAM.call(this.checkCurrentToken,
this,[TypeScript.TokenID.OpenBrace,errorRecoverySet|TypeScript.ErrorRecoverySet.StmtStart]);var savedInFunction=this.inFunction;this.inFunction=!0;JAM.call(this.parseStatementList,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.RCurly|TypeScript.ErrorRecoverySet.StmtStart,bod,!0,!1,allowedElements,parentModifiers]);bod.minChar=bodMinChar;bod.limChar=this.scanner.pos;this.inFunction=savedInFunction;errorRecoverySet=new TypeScript.EndCode;errorRecoverySet.minChar=bod.limChar;errorRecoverySet.limChar=
errorRecoverySet.minChar;JAM.call(bod.append,bod,[errorRecoverySet])}function v554(minChar,errorRecoverySet){var v27287=this.scanner.scan();this.currentToken=v27287;v27287=new TypeScript.ASTList;v27287.minChar=minChar;var prevInInterfaceDecl=this.inInterfaceDecl;this.inInterfaceDecl=!0;JAM.call(this.parseTypeMemberList,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.RCurly,v27287]);this.inInterfaceDecl=prevInInterfaceDecl;JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.CloseBrace,errorRecoverySet]);
prevInInterfaceDecl=JAM.new(TypeScript.InterfaceDeclaration,[this.anonId,v27287,null,null]);prevInInterfaceDecl.minChar=minChar;prevInInterfaceDecl.limChar=v27287.limChar;return JAM.call(this.parseTypeReferenceTail,this,[errorRecoverySet,minChar,prevInInterfaceDecl])}function v553(errorRecoverySet,allowVoid){var minChar=this.scanner.startPos,isConstructorMember=!1;switch(this.currentToken.tokenId){case TypeScript.TokenID.Void:allowVoid||JAM.call(this.reportParseError,this,["void not a valid type in this context"]);
case TypeScript.TokenID.Any:case TypeScript.TokenID.Number:case TypeScript.TokenID.Bool:case TypeScript.TokenID.String:var isConstructorMember=TypeScript.tokenTable,v17128=this.currentToken.tokenId;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)isConstructorMember=isConstructorMember[v17128];isConstructorMember=isConstructorMember.text;isConstructorMember=JAM.new(TypeScript.Identifier,[isConstructorMember]);isConstructorMember.minChar=minChar;isConstructorMember.limChar=this.scanner.pos;
this.currentToken=v17128=this.scanner.scan();return JAM.call(this.parseTypeReferenceTail,this,[errorRecoverySet,minChar,isConstructorMember]);case TypeScript.TokenID.Identifier:return isConstructorMember=JAM.call(this.createRef,this,[this.currentToken.getText(),this.currentToken.hasEscapeSequence,minChar]),isConstructorMember.limChar=this.scanner.pos,JAM.call(this.parseNamedType,this,[errorRecoverySet,minChar,isConstructorMember,!0]);case TypeScript.TokenID.OpenBrace:return JAM.call(this.parseObjectType,
this,[minChar,errorRecoverySet]);case TypeScript.TokenID.New:this.currentToken=v17128=this.scanner.scan(),this.currentToken.tokenId!=TypeScript.TokenID.OpenParen?JAM.call(this.reportParseError,this,["Expected '('"]):isConstructorMember=!0;case TypeScript.TokenID.OpenParen:var formals=new TypeScript.ASTList,v17128=JAM.call(this.parseFormalParameterList,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.RParen,formals,!1,!0,!1,!1,!1,!1,null,!0]);JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.EqualsGreaterThan,
errorRecoverySet]);var returnType=JAM.call(this.parseTypeReference,this,[errorRecoverySet,!0]),formals=JAM.new(TypeScript.FuncDecl,[null,null,!1,formals,null,null,null,TypeScript.NodeType.FuncDecl]);formals.returnTypeAnnotation=returnType;formals.variableArgList=v17128;formals.fncFlags|=TypeScript.FncFlags.Signature;isConstructorMember&&(formals.fncFlags|=TypeScript.FncFlags.ConstructMember,formals.hint="_construct",formals.classDecl=null);formals.minChar=minChar;return JAM.call(this.parseTypeReferenceTail,
this,[errorRecoverySet,minChar,formals]);default:return JAM.call(this.reportParseError,this,["Expected type name"]),minChar=JAM.new(TypeScript.TypeReference,[null,0]),minChar.flags|=TypeScript.ASTFlags.Error,minChar.minChar=this.scanner.pos,minChar.limChar=this.scanner.pos,minChar}}function v552(errorRecoverySet,minChar,term,tail){var v27290=this.scanner.scan();this.currentToken=v27290;if(this.currentToken.tokenId==TypeScript.TokenID.Dot){this.currentToken=v27290=this.scanner.scan();v27290=this.currentToken.tokenId==
TypeScript.TokenID.Identifier;v27290||((v27290=!this.errorRecovery)||(v27290=!this.scanner.lastTokenHadNewline()),v27290&&(v27290=JAM.call(TypeScript.convertTokToID,TypeScript,[this.currentToken,this.strictMode])));if(v27290){v27290=TypeScript.Identifier;v27290=JAM.call(v27290.fromToken,v27290,[this.currentToken]);v27290.minChar=this.scanner.startPos;v27290.limChar=this.scanner.pos;var dotNode=JAM.new(TypeScript.BinaryExpression,[TypeScript.NodeType.Dot,term,v27290]);dotNode.minChar=term.minChar;
dotNode.limChar=v27290.limChar;return JAM.call(this.parseNamedType,this,[errorRecoverySet,minChar,dotNode,tail])}JAM.call(this.reportParseError,this,["need identifier after '.'"]);if(this.errorRecovery)return term.flags|=TypeScript.ASTFlags.DotLHS,errorRecoverySet=term,minChar=this.scanner.lastTokenLimChar(),errorRecoverySet.limChar=minChar,term;v27290=new TypeScript.MissingIdentifier;v27290.minChar=this.scanner.pos;v27290.limChar=this.scanner.pos;dotNode=JAM.new(TypeScript.BinaryExpression,[TypeScript.NodeType.Dot,
term,v27290]);dotNode.flags|=TypeScript.ASTFlags.Error;dotNode.minChar=term.minChar;dotNode.limChar=v27290.limChar;return JAM.call(this.parseNamedType,this,[errorRecoverySet,minChar,dotNode,tail])}return tail?JAM.call(this.parseTypeReferenceTail,this,[errorRecoverySet,minChar,term]):term}function v551(errorRecoverySet,minChar,term){term=JAM.new(TypeScript.TypeReference,[term,0]);term.minChar=minChar;for(minChar=this.currentToken.tokenId==TypeScript.TokenID.OpenBracket;minChar;)this.currentToken=minChar=
this.scanner.scan(),term.arrayCount+=1,JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.CloseBracket,errorRecoverySet|TypeScript.ErrorRecoverySet.LBrack]),minChar=this.currentToken.tokenId==TypeScript.TokenID.OpenBracket;errorRecoverySet=term;minChar=this.scanner.lastTokenLimChar();errorRecoverySet.limChar=minChar;return term}function v550(errorRecoverySet,modifiers,preComments){var leftCurlyCount=this.scanner.leftCurlyCount,rightCurlyCount=this.scanner.rightCurlyCount,svAmbient=this.ambientModule,
svTopLevel=this.topLevel;this.topLevel=!1;var v17160=this.parsingDeclareFile;v17160||(v17160=svAmbient)||(v17160=JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Ambient]));v17160&&(this.ambientModule=!0);this.currentToken=v17160=this.scanner.scan();var name=null,enclosedList=null;this.pushDeclLists();var minChar=this.scanner.startPos,v17160=!1,v17161=this.currentToken.tokenId==TypeScript.TokenID.Identifier;v17161||(v17161=this.currentToken.tokenId==TypeScript.TokenID.StringLiteral,
v17161||(v17161=!JAM.call(TypeScript.isPrimitiveTypeToken,TypeScript,[this.currentToken]))&&(v17161=JAM.call(TypeScript.convertTokToID,TypeScript,[this.currentToken,this.strictMode])));v17161?(this.currentToken.getText(),this.currentToken.tokenId==TypeScript.TokenID.StringLiteral&&(v17160=!0,this.ambientModule||JAM.call(this.reportParseError,this,["Only ambient dynamic modules may have string literal names"]),svTopLevel||JAM.call(this.reportParseError,this,["Dynamic modules may not be nested within other modules"])),
name=TypeScript.Identifier,name=JAM.call(name.fromToken,name,[this.currentToken]),name.minChar=this.scanner.startPos,name.limChar=this.scanner.pos,this.currentToken=v17161=this.scanner.scan()):this.currentToken.tokenId==TypeScript.TokenID.OpenBrace&&(JAM.call(this.reportParseError,this,["Module name missing"]),name=JAM.new(TypeScript.Identifier,[""]),name.minChar=minChar,name.limChar=minChar);this.currentToken.tokenId==TypeScript.TokenID.Dot&&(enclosedList=[],JAM.call(this.parseDottedName,this,[enclosedList]));
null==name&&(name=new TypeScript.MissingIdentifier);var v17161=new TypeScript.ASTList,bodyMinChar=this.scanner.startPos;JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.OpenBrace,errorRecoverySet|TypeScript.ErrorRecoverySet.ID]);this.allowImportDeclaration=svTopLevel&&v17160?!0:!1;JAM.call(this.parseStatementList,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.RCurly,v17161,!0,!0,TypeScript.AllowedElements.Global,modifiers]);v17161.minChar=bodyMinChar;v17161.limChar=this.scanner.pos;bodyMinChar=
new TypeScript.ASTSpan;bodyMinChar.minChar=this.scanner.startPos;bodyMinChar.limChar=this.scanner.pos;JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.CloseBrace,errorRecoverySet]);errorRecoverySet=this.scanner.lastTokenLimChar();this.allowImportDeclaration=svTopLevel;var v17174=enclosedList;v17174&&(v17174=0<enclosedList.length);if(v17174){var len=enclosedList.length,v17174=len-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v17174=enclosedList[v17174];v17174=JAM.new(TypeScript.ModuleDeclaration,
[v17174,v17161,this.topVarList(),this.topScopeList(),bodyMinChar]);v17174.preComments=preComments;(preComments=this.parsingDeclareFile)||(preComments=JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Ambient]));preComments&&(v17174.modFlags|=TypeScript.ModuleFlags.Ambient);v17174.modFlags|=TypeScript.ModuleFlags.Exported;v17174.minChar=minChar;v17174.limChar=errorRecoverySet;this.popDeclLists();preComments=len-2;for(len=0<=preComments;len;)len=new TypeScript.ASTList,JAM.call(len.append,
len,[v17174]),v17174=enclosedList[preComments],v17174=JAM.new(TypeScript.ModuleDeclaration,[v17174,len,new TypeScript.ASTList,new TypeScript.ASTList,bodyMinChar]),len.minChar=v17174.minChar=minChar,len.limChar=v17174.limChar=errorRecoverySet,(len=this.parsingDeclareFile)||(len=JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Ambient])),len&&(v17174.modFlags|=TypeScript.ModuleFlags.Ambient),v17174.modFlags|=TypeScript.ModuleFlags.Exported,preComments-=1,len=0<=preComments;len=
new TypeScript.ASTList;JAM.call(len.append,len,[v17174]);len.minChar=minChar;len.limChar=errorRecoverySet;enclosedList=JAM.new(TypeScript.ModuleDeclaration,[name,len,new TypeScript.ASTList,new TypeScript.ASTList,bodyMinChar])}else enclosedList=JAM.new(TypeScript.ModuleDeclaration,[name,v17161,this.topVarList(),this.topScopeList(),bodyMinChar]),enclosedList.preComments=preComments,this.popDeclLists();minChar=this.parsingDeclareFile;minChar||(minChar=svAmbient)||(minChar=JAM.call(TypeScript.hasFlag,
TypeScript,[modifiers,TypeScript.Modifiers.Ambient]));minChar&&(enclosedList.modFlags|=TypeScript.ModuleFlags.Ambient);(minChar=svAmbient)||(minChar=JAM.call(TypeScript.hasFlag,TypeScript,[modifiers,TypeScript.Modifiers.Exported]));minChar&&(enclosedList.modFlags|=TypeScript.ModuleFlags.Exported);v17160&&(enclosedList.modFlags|=TypeScript.ModuleFlags.IsDynamic);this.ambientModule=svAmbient;this.topLevel=svTopLevel;enclosedList.leftCurlyCount=this.scanner.leftCurlyCount-leftCurlyCount;enclosedList.rightCurlyCount=
this.scanner.rightCurlyCount-rightCurlyCount;enclosedList.limChar=v17161.limChar;return enclosedList}function v549(errorRecoverySet,modifiers){var name=null,alias=null,name=null,minChar=this.scanner.startPos,isDynamicImport=!1;this.currentToken=name=this.scanner.scan();(name=this.currentToken.tokenId==TypeScript.TokenID.Identifier)||(name=JAM.call(TypeScript.convertTokToID,TypeScript,[this.currentToken,this.strictMode]));name?(name=TypeScript.Identifier,name=JAM.call(name.fromToken,name,[this.currentToken])):
(JAM.call(this.reportParseError,this,["Expected identifer after 'import'"]),name=new TypeScript.MissingIdentifier);name.minChar=this.scanner.startPos;name.limChar=this.scanner.pos;var v27298=this.scanner.scan();this.currentToken=v27298;JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.Equals,errorRecoverySet|TypeScript.ErrorRecoverySet.ID]);var v27298=this.parseComments(),limChar;(limChar=this.currentToken.tokenId==TypeScript.TokenID.Identifier)||(limChar=JAM.call(TypeScript.convertTokToID,
TypeScript,[this.currentToken,this.strictMode]));if(limChar)if(this.currentToken.tokenId==TypeScript.TokenID.Module){limChar=this.scanner.pos;var v27299=this.scanner.scan();this.currentToken=v27299;this.currentToken.tokenId==TypeScript.TokenID.OpenParen&&(this.currentToken=limChar=this.scanner.scan(),limChar=this.currentToken.tokenId==TypeScript.TokenID.StringLiteral,limChar||(limChar=this.currentToken.tokenId==TypeScript.TokenID.Identifier)||(limChar=JAM.call(TypeScript.convertTokToID,TypeScript,
[this.currentToken,this.strictMode])),limChar&&(this.currentToken.tokenId==TypeScript.TokenID.StringLiteral?(this.topLevel?this.hasTopLevelImportOrExport=!0:this.allowImportDeclaration||JAM.call(this.reportParseError,this,["Import declaration of external module is permitted only in global or top level dynamic modules"]),this.currentToken.getText(),alias=TypeScript.Identifier,alias=JAM.call(alias.fromToken,alias,[this.currentToken]),alias.minChar=this.scanner.startPos,alias.limChar=this.scanner.pos,
JAM.call(this.isValidImportPath,this,[alias.text])||JAM.call(this.reportParseError,this,["Invalid import path"]),isDynamicImport=!0,this.currentToken=limChar=this.scanner.scan()):alias=JAM.call(this.parseExpr,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.SColon,TypeScript.OperatorPrecedence.Assignment,!0,TypeContext.NoTypes]),alias.preComments=v27298),limChar=this.scanner.pos,JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.CloseParen,errorRecoverySet|TypeScript.ErrorRecoverySet.ID]),
alias&&(v27298=alias,v27299=this.parseComments(),v27298.postComments=v27299))}else alias=JAM.call(this.parseExpr,this,[errorRecoverySet|TypeScript.ErrorRecoverySet.SColon,TypeScript.OperatorPrecedence.Assignment,!0,TypeContext.NoTypes]),limChar=this.scanner.pos;else JAM.call(this.reportParseError,this,["Expected module name"]),alias=new TypeScript.MissingIdentifier,alias.minChar=this.scanner.startPos,this.currentToken.tokenId==TypeScript.TokenID.Semicolon?alias.limChar=this.scanner.startPos:(alias.limChar=
this.scanner.pos,this.currentToken=v27298=this.scanner.scan()),alias.flags|=TypeScript.ASTFlags.Error,limChar=alias.limChar;name=JAM.new(TypeScript.ImportDeclaration,[name,alias]);name.isDynamicImport=isDynamicImport;name.minChar=minChar;name.limChar=limChar;return name}function v548(importPath){importPath=JAM.call(TypeScript.stripQuotes,TypeScript,[importPath]);var v17222=!importPath;v17222||(v17222=-1!=importPath.indexOf(":"),v17222||(v17222=-1!=importPath.indexOf("\\"))||(v17222="/"==importPath.charAt(0)));
return v17222?!1:!0}function v547(enclosedList){var v27304=this.scanner.scan();this.currentToken=v27304;(v27304=this.currentToken.tokenId==TypeScript.TokenID.Identifier)||(v27304=JAM.call(TypeScript.convertTokToID,TypeScript,[this.currentToken,this.strictMode]));if(v27304){var v27304=TypeScript.Identifier,v9376=v27304=JAM.call(v27304.fromToken,v27304,[this.currentToken]),v27305=this.parseComments();v9376.preComments=v27305;JAM.set(enclosedList,enclosedList.length,v27304);v27304.minChar=this.scanner.startPos;
v27304.limChar=this.scanner.pos;this.currentToken=v27304=this.scanner.scan();this.currentToken.tokenId==TypeScript.TokenID.Dot&&JAM.call(this.parseDottedName,this,[enclosedList])}else JAM.call(this.reportParseError,this,["need identifier after '.'"])}function v546(errorRecoverySet,modifiers){var leftCurlyCount=this.scanner.leftCurlyCount,rightCurlyCount=this.scanner.rightCurlyCount,name=null,v17226=this.currentToken.tokenId==TypeScript.TokenID.Identifier;v17226||(v17226=JAM.call(TypeScript.convertTokToID,
TypeScript,[this.currentToken,this.strictMode]));v17226?(name=TypeScript.Identifier,name=JAM.call(name.fromToken,name,[this.currentToken]),name.minChar=this.scanner.startPos,name.limChar=this.scanner.pos,this.currentToken=v17226=this.scanner.scan()):(JAM.call(this.reportParseError,this,["Enum declaration requires identifier"]),this.errorRecovery&&(name=new TypeScript.MissingIdentifier,name.minChar=this.scanner.startPos,name.limChar=this.scanner.startPos,name.flags|=TypeScript.ASTFlags.Error));var membersMinChar=
this.scanner.startPos;JAM.call(this.checkCurrentToken,this,[TypeScript.TokenID.OpenBrace,errorRecoverySet|TypeScript.ErrorRecoverySet.ID]);this.pushDeclLists();v17226=new TypeScript.ASTList;v17226.minChar=membersMinChar;membersMinChar=JAM.new(TypeScript.VarDecl,[JAM.new(TypeScript.Identifier,["_map"]),0]);membersMinChar.varFlags|=TypeScript.VarFlags.Exported;membersMinChar.varFlags|=TypeScript.VarFlags.Private;membersMinChar.varFlags=membersMinChar.varFlags|TypeScript.VarFlags.Property|TypeScript.VarFlags.Public;
var v9401=membersMinChar,v27308=JAM.new(TypeScript.UnaryExpression,[TypeScript.NodeType.ArrayLit,null]);v9401.init=v27308;JAM.call(v17226.append,v17226,[membersMinChar]);for(membersMinChar=null;;){var v9401=this.scanner.startPos,limChar,memberName=null,memberValue=null,postComments=v27308=null;(v27308=this.currentToken.tokenId==TypeScript.TokenID.Identifier)||(v27308=JAM.call(TypeScript.convertTokToIDName,TypeScript,[this.currentToken]));if(v27308)v27308=TypeScript.Identifier,memberName=JAM.call(v27308.fromToken,
v27308,[this.currentToken]),memberName.minChar=this.scanner.startPos,memberName.limChar=this.scanner.pos;else if(this.currentToken.tokenId==TypeScript.TokenID.CloseBrace)break;else JAM.call(this.reportParseError,this,["Expected identifer of enum member"]),this.errorRecovery&&(memberName=new TypeScript.MissingIdentifier,memberName.minChar=this.scanner.startPos,memberName.limChar=this.scanner.startPos,memberName.flags|=TypeScript.ASTFlags.Error);limChar=this.scanner.pos;v27308=this.parseComments();
this.currentToken=postComments=this.scanner.scan();postComments=this.parseComments();if(this.currentToken.tokenId==TypeScript.TokenID.Equals)this.currentToken=membersMinChar=this.scanner.scan(),membersMinChar=memberValue=JAM.call(this.parseExpr,this,[errorRecoverySet,TypeScript.OperatorPrecedence.Comma,!0,TypeContext.NoTypes]),limChar=memberValue.limChar;else{var membersMinChar=memberValue=null==membersMinChar?JAM.new(TypeScript.NumberLiteral,[0]):JAM.new(TypeScript.NumberLiteral,[membersMinChar.value+
1]),map=JAM.new(TypeScript.BinaryExpression,[TypeScript.NodeType.Asg,JAM.new(TypeScript.BinaryExpression,[TypeScript.NodeType.Index,JAM.new(TypeScript.Identifier,["_map"]),memberValue]),JAM.new(TypeScript.StringLiteral,['"'+memberName.actualText+'"'])]);JAM.call(v17226.append,v17226,[map])}memberName=JAM.new(TypeScript.VarDecl,[memberName,this.nestingLevel]);memberName.minChar=v9401;memberName.limChar=limChar;memberName.init=memberValue;v9401=memberName;limChar=JAM.new(TypeScript.TypeReference,[JAM.call(this.createRef,
this,[name.actualText,name.hasEscapeSequence,-1]),0]);v9401.typeExpr=limChar;memberName.varFlags=memberName.varFlags|TypeScript.VarFlags.Readonly|TypeScript.VarFlags.Property;memberValue.nodeType==TypeScript.NodeType.NumberLit&&(memberName.varFlags|=TypeScript.VarFlags.Constant);memberName.preComments=v27308;JAM.call(v17226.append,v17226,[memberName]);memberName.postComments=postComments;memberName.varFlags|=TypeScript.VarFlags.Exported;if(this.currentToken.tokenId==TypeScript.TokenID.Comma&&(this.currentToken=
v9401=this.scanner.scan(),v9401=memberName,v27308=JAM.call(this.combineComments,this,[memberName.postComments,JAM.call(this.parseCommentsForLine,this,[this.scanner.prevLine])]),v9401.postComments=v27308,(v9401=this.currentToken.tokenId==TypeScript.TokenID.Identifier)||(v9401=JAM.call(TypeScript.convertTokToIDName,TypeScript,[this.currentToken])),v9401))continue;break}membersMinChar=new TypeScript.ASTSpan;membersMinChar.minChar=this.scanner.startPos;membersMinChar.limChar=this.scanner.pos;JAM.call(this.checkCurrentToken,
this,[TypeScript.TokenID.CloseBrace,errorRecoverySet]);v9401=v17226;v27308=this.scanner.lastTokenLimChar();v9401.limChar=v27308;name=JAM.new(TypeScript.ModuleDeclaration,[name,v17226,this.topVarList(),this.topScopeList(),membersMinChar]);name.modFlags|=TypeScript.ModuleFlags.IsEnum;this.popDeclLists();name.leftCurlyCount=this.scanner.leftCurlyCount-leftCurlyCount;name.rightCurlyCount=this.scanner.rightCurlyCount-rightCurlyCount;return name}function v545(comment1,comment2){return null==comment1?comment2:
null==comment2?comment1:comment1.concat(comment2)}function v544(line){var v9447=this.scanner;line=JAM.call(v9447.getCommentsForLine,v9447,[line]);return JAM.call(this.parseCommentsInner,this,[line])}function v543(){var comments=this.scanner.getComments();return JAM.call(this.parseCommentsInner,this,[comments])}function v542(comments){if(comments){for(var commentASTs=[],i=0,v9450=i<comments.length;v9450;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v9450=comments[i];JAM.call(commentASTs.push,
commentASTs,[JAM.call(this.parseComment,this,[v9450])]);i+=1;v9450=i<comments.length}return commentASTs}return null}function v541(comment){if(comment){var c=JAM.new(TypeScript.Comment,[comment.value,comment.isBlock,comment.endsLine]);c.minChar=comment.startPos;c.limChar=comment.startPos+comment.value.length;var lineCol={line:-1,col:-1};JAM.call(this.getSourceLineCol,this,[lineCol,c.minChar]);c.minLine=lineCol.line;JAM.call(this.getSourceLineCol,this,[lineCol,c.limChar]);c.limLine=lineCol.line;if(lineCol=
!comment.isBlock)if(lineCol=3<comment.value.length)lineCol=comment.value,lineCol="///"==JAM.call(lineCol.substring,lineCol,[0,3]);if(lineCol){if(lineCol=JAM.call(TypeScript.getAdditionalDependencyPath,TypeScript,[comment.value])){var v9460=this.amdDependencies;JAM.call(v9460.push,v9460,[lineCol])}JAM.call(TypeScript.getImplicitImport,TypeScript,[comment.value])&&(this.hasTopLevelImportOrExport=!0)}return c}return null}function v540(){var v9463=this.staticsLists,v9464=this.staticsLists.length-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v9463[v9464]}
function v539(){var v9465=this.scopeLists,v9466=this.scopeLists.length-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v9465[v9466]}function v538(){var v9467=this.varLists,v9468=this.varLists.length-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v9467[v9468]}function v537(){this.staticsLists.pop();this.varLists.pop();this.scopeLists.pop()}function v536(){var v9472=this.staticsLists;JAM.call(v9472.push,v9472,[new TypeScript.ASTList]);v9472=this.varLists;
JAM.call(v9472.push,v9472,[new TypeScript.ASTList]);v9472=this.scopeLists;JAM.call(v9472.push,v9472,[new TypeScript.ASTList])}function v535(tokenId,errorRecoverySet,errorText){"undefined"===typeof errorText&&(errorText=null);if(this.currentToken.tokenId!=tokenId){if(null==errorText){errorText=TypeScript.tokenTable;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)tokenId=errorText[tokenId];tokenId="Expected '"+tokenId.text+"'"}else tokenId=errorText;errorText=tokenId;JAM.call(this.reportParseError,
this,[errorText]);this.errorRecovery&&JAM.call(this.skip,this,[errorRecoverySet])}else this.currentToken=errorRecoverySet=this.scanner.scan()}function v534(errorRecoverySet){errorRecoverySet|=TypeScript.ErrorRecoverySet.EOF;var ersTok=TypeScript.ErrorRecoverySet.None,tokenInfo=JAM.call(TypeScript.lookupToken,TypeScript,[this.currentToken.tokenId]);void 0!=tokenInfo&&(ersTok=tokenInfo.ers);var pendingRightCurlies=0,ersTok=(ersTok&errorRecoverySet)==TypeScript.ErrorRecoverySet.None;ersTok||(ersTok=
this.currentToken.tokenId==TypeScript.TokenID.CloseBrace)&&(ersTok=0<pendingRightCurlies);for(;ersTok;)this.currentToken.tokenId==TypeScript.TokenID.OpenBrace?pendingRightCurlies+=1:this.currentToken.tokenId==TypeScript.TokenID.CloseBrace&&(pendingRightCurlies-=1),this.currentToken=ersTok=this.scanner.scan(),ersTok=TypeScript.ErrorRecoverySet.None,tokenInfo=JAM.call(TypeScript.lookupToken,TypeScript,[this.currentToken.tokenId]),void 0!=tokenInfo&&(ersTok=tokenInfo.ers),ersTok=(ersTok&errorRecoverySet)==
TypeScript.ErrorRecoverySet.None,ersTok||(ersTok=this.currentToken.tokenId==TypeScript.TokenID.CloseBrace)&&(ersTok=0<pendingRightCurlies)}function v533(tokenId,errorRecoverySet,errorText){"undefined"===typeof errorText&&(errorText=null);var v27317=this.scanner.scan();this.currentToken=v27317;JAM.call(this.checkCurrentToken,this,[tokenId,errorRecoverySet,errorText])}function v532(message,startPos,pos){"undefined"===typeof startPos&&(startPos=this.scanner.startPos);"undefined"===typeof pos&&(pos=this.scanner.pos);
pos=JAM.call(Math.max,Math,[1,pos-startPos]);if(this.errorCallback)JAM.call(this.errorCallback,this,[startPos,pos,message,this.currentUnitIndex]);else if(this.errorRecovery)pos={line:-1,col:-1},JAM.call(this.getSourceLineCol,this,[pos,startPos]),this.outfile&&(startPos=this.outfile,JAM.call(startPos.WriteLine,startPos,["// "+this.fname+" ("+pos.line+","+pos.col+"): "+message]));else throw new SyntaxError(this.fname+" ("+this.scanner.line+","+this.scanner.col+"): "+message);}function v531(message){JAM.call(this.reportParseError,
this,["STYLE: "+message])}function v530(text,hasEscapeSequence,minChar){text=JAM.new(TypeScript.Identifier,[text,hasEscapeSequence]);text.minChar=minChar;return text}function v529(lineCol,minChar){JAM.call(TypeScript.getSourceLineColFromMap,TypeScript,[lineCol,minChar,this.scanner.lineMap])}function v528(outfile){this.outfile=outfile;this.errorRecovery=!0}function v527(jump){for(var v9510=TypeScript.AST,v9510=JAM.call(v9510.getResolvedIdentifierName,v9510,[jump.target]),len=this.statementInfoStack.length,
len=len-1,v9525=0<=len;v9525;){v9525=this.statementInfoStack;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v9525=v9525[len];if(jump.target){var v17307=v9525.labels;v17307&&(v17307=0<v9525.labels.members.length);if(v17307)for(var v17307=0,labLen=v9525.labels.members.length,v9518=v17307<labLen;v9518;){v9518=v9525.labels.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v9518=v9518[v17307];if(v9518.id.text==v9510){JAM.call(jump.setResolvedTarget,jump,[this,v9525.stmt]);
return}v17307+=1;v9518=v17307<labLen}}else{if(v9525.stmt.isLoop()){JAM.call(jump.setResolvedTarget,jump,[this,v9525.stmt]);return}(v17307=v9525.stmt.nodeType==TypeScript.NodeType.Switch)&&(v17307=jump.nodeType==TypeScript.NodeType.Break);if(v17307){JAM.call(jump.setResolvedTarget,jump,[this,v9525.stmt]);return}}len-=1;v9525=0<=len}jump.target?JAM.call(this.reportParseError,this,["could not find enclosing statement with label "+jump.target]):jump.nodeType==TypeScript.NodeType.Break?JAM.call(this.reportParseError,
this,["break statement requires enclosing loop or switch"]):JAM.call(this.reportParseError,this,["continue statement requires enclosing loop"])}function v526(){return this.statementInfoStack.pop()}function v525(stmt,labels){var info={stmt:stmt,labels:labels},v9530=this.statementInfoStack;JAM.call(v9530.push,v9530,[info])}function v524(){for(var j=this.statementInfoStack.length-1,v9533=0<=j;v9533;){v9533=this.statementInfoStack;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v9533=
v9533[j];if(v9533.stmt.isLoop())return!0;j-=1;v9533=0<=j}return!1}function v523(){var v27318=[];this.statementInfoStack=v27318}function Parser(){this.varLists=[];this.scopeLists=[];this.staticsLists=[];var v27319=new TypeScript.Scanner;this.scanner=v27319;this.currentToken=null;this.inInterfaceDecl=this.inFunction=this.needTerminator=!1;this.currentClassDecl=null;this.inFncDecl=!1;this.anonId=v27319=JAM.new(TypeScript.Identifier,["_anonymous"]);this.style_requireSemi=!1;this.style_funcInLoop=!0;this.errorRecovery=
this.incremental=!1;this.outfile=void 0;this.errorCallback=null;this.state=ParseState.StartStatementList;this.ambientClass=this.ambientModule=!1;this.allowImportDeclaration=this.topLevel=!0;this.currentUnitIndex=-1;this.prevIDTok=null;this.statementInfoStack=v27319=[];this.strictMode=this.hasTopLevelImportOrExport=!1;this.nestingLevel=0;this.currentClassDefinition=this.prevExpr=null;this.parsingDeclareFile=this.parsingClassConstructorDefinition=!1;this.amdDependencies=[];this.requiresExtendsBlock=
this.inferPropertiesFromThisAssignment=!1;this.fname=""}Parser.prototype.resetStmtStack=v523;Parser.prototype.inLoop=v524;Parser.prototype.pushStmt=v525;Parser.prototype.popStmt=v526;Parser.prototype.resolveJumpTarget=v527;Parser.prototype.setErrorRecovery=v528;Parser.prototype.getSourceLineCol=v529;Parser.prototype.createRef=v530;Parser.prototype.reportParseStyleError=v531;Parser.prototype.reportParseError=v532;Parser.prototype.checkNextToken=v533;Parser.prototype.skip=v534;Parser.prototype.checkCurrentToken=
v535;Parser.prototype.pushDeclLists=v536;Parser.prototype.popDeclLists=v537;Parser.prototype.topVarList=v538;Parser.prototype.topScopeList=v539;Parser.prototype.topStaticsList=v540;Parser.prototype.parseComment=v541;Parser.prototype.parseCommentsInner=v542;Parser.prototype.parseComments=v543;Parser.prototype.parseCommentsForLine=v544;Parser.prototype.combineComments=v545;Parser.prototype.parseEnumDecl=v546;Parser.prototype.parseDottedName=v547;Parser.prototype.isValidImportPath=v548;Parser.prototype.parseImportDeclaration=
v549;Parser.prototype.parseModuleDecl=v550;Parser.prototype.parseTypeReferenceTail=v551;Parser.prototype.parseNamedType=v552;Parser.prototype.parseTypeReference=v553;Parser.prototype.parseObjectType=v554;Parser.prototype.parseFunctionBlock=v555;Parser.prototype.parseFunctionStatements=v556;Parser.prototype.transformAnonymousArgsIntoFormals=v557;Parser.prototype.parseFormalParameterList=v558;Parser.prototype.parseFncDecl=v559;Parser.prototype.convertToTypeReference=v560;Parser.prototype.parseArgList=
v561;Parser.prototype.parseBaseList=v562;Parser.prototype.parseClassDecl=v563;Parser.prototype.parseClassElements=v564;Parser.prototype.parseClassConstructorDeclaration=v565;Parser.prototype.parseClassMemberVariableDeclaration=v566;Parser.prototype.parseClassMemberFunctionDeclaration=v567;Parser.prototype.parseTypeMember=v568;Parser.prototype.parseTypeMemberList=v569;Parser.prototype.parseInterfaceDecl=v570;Parser.prototype.makeVarDecl=v571;Parser.prototype.parsePropertyDeclaration=v572;Parser.prototype.parseVariableDeclaration=
v573;Parser.prototype.parseMemberList=v574;Parser.prototype.parseArrayList=v575;Parser.prototype.parseArrayLiteral=v576;Parser.prototype.parseTerm=v577;Parser.prototype.parseLambdaExpr=v578;Parser.prototype.parseExpr=v579;Parser.prototype.parsePostfixOperators=v580;Parser.prototype.parseTry=v581;Parser.prototype.parseCatch=v582;Parser.prototype.parseFinally=v583;Parser.prototype.parseTryCatchFinally=v584;Parser.prototype.parseStatement=v585;Parser.prototype.okAmbientModuleMember=v586;Parser.prototype.parseStatementList=
v587;Parser.prototype.quickParse=v588;Parser.prototype.parse=v590;return Parser}function v522(){function QuickParseResult(Script,endLexState){this.Script=Script;this.endLexState=endLexState}return QuickParseResult}function v521(ParseState){ParseState._map=[];ParseState._map[0]="None";ParseState.None=0;ParseState._map[1]="StartScript";ParseState.StartScript=1;ParseState._map[2]="StartStatementList";ParseState.StartStatementList=2;ParseState._map[3]="StartStatement";ParseState.StartStatement=3;ParseState._map[4]=
"StartFncDecl";ParseState.StartFncDecl=4;ParseState._map[5]="FncDeclName";ParseState.FncDeclName=5;ParseState._map[6]="FncDeclArgs";ParseState.FncDeclArgs=6;ParseState._map[7]="FncDeclReturnType";ParseState.FncDeclReturnType=7;ParseState._map[8]="ForInit";ParseState.ForInit=8;ParseState._map[9]="ForInitAfterVar";ParseState.ForInitAfterVar=9;ParseState._map[10]="ForCondStart";ParseState.ForCondStart=10;ParseState._map[11]="EndStmtList";ParseState.EndStmtList=11;ParseState._map[12]="EndScript";ParseState.EndScript=
12}function v520(TypeContext){TypeContext._map=[];TypeContext.NoTypes=0;TypeContext.ArraySuffix=1;TypeContext.Primitive=2;TypeContext.Named=4;TypeContext.AllSimpleTypes=TypeContext.Primitive|TypeContext.Named;TypeContext.AllTypes=TypeContext.Primitive|TypeContext.Named|TypeContext.ArraySuffix}function quickParse(logger,scopeStartAST,sourceText,minChar,limChar,errorCapture){scopeStartAST=JAM.call(sourceText.getText,sourceText,[minChar,limChar]);JAM.call(logger.log,logger,["Quick parse range ("+minChar+
","+limChar+'): "'+JAM.call(TypeScript.stringToLiteral,TypeScript,[scopeStartAST,100])+'"']);logger=new Parser;JAM.call(logger.setErrorRecovery,logger,[null]);logger.errorCallback=errorCapture;errorCapture=JAM.new(TypeScript.ClassDeclaration,[null,null,null,null]);logger.currentClassDecl=errorCapture;return errorCapture=JAM.call(logger.quickParse,logger,[JAM.new(TypeScript.StringSourceText,[scopeStartAST]),"",0])}var v17322=TypeScript.TypeContext;v17322||(v17322=TypeScript.TypeContext={});v520(v17322);
var TypeContext=TypeScript.TypeContext,v17322=TypeScript.ParseState;v17322||(v17322=TypeScript.ParseState={});v521(v17322);var ParseState=TypeScript.ParseState,QuickParseResult=v522();TypeScript.QuickParseResult=QuickParseResult;var Parser=v591();TypeScript.Parser=Parser;TypeScript.quickParse=quickParse}
function v519(){var TypeScript=v18804;function v518(){function v517(ast,op,type){JAM.call(this.reportError,this,[ast,"Operator '"+op+"' cannot be applied to type '"+type.getTypeName()+"'"])}function v516(ast){JAM.call(this.simpleError,this,[ast,"Expected var, class, interface, or module"])}function v515(ast,t1,t2,op,scope,comparisonInfo){t1||(t1=this.checker.anyType);t2||(t2=this.checker.anyType);comparisonInfo=comparisonInfo?comparisonInfo.message:"";t1=op?"Operator '"+op+"' cannot be applied to types '"+
JAM.call(t1.getScopedTypeName,t1,[scope])+"' and '"+JAM.call(t2.getScopedTypeName,t2,[scope])+"'":"Cannot convert '"+JAM.call(t1.getScopedTypeName,t1,[scope])+"' to '"+JAM.call(t2.getScopedTypeName,t2,[scope])+"'";t2=comparisonInfo?": "+comparisonInfo:"";JAM.call(this.reportError,this,[ast,t1+t2])}function v514(ast,scope){var v9633=ast.operand1.type,v9633=JAM.call(v9633.getScopedTypeName,v9633,[scope]),v9634=ast.operand2.type,v9634=JAM.call(v9634.getScopedTypeName,v9634,[scope]);JAM.call(this.simpleError,
this,[ast,"Value of type '"+v9633+"' is not indexable by type '"+v9634+"'"])}function v513(ast,nodeType,scope){var targetType=ast.target.type;scope=JAM.call(targetType.getScopedTypeName,targetType,[scope]);(targetType=targetType.construct)&&(targetType=nodeType==TypeScript.NodeType.Call);targetType?JAM.call(this.reportError,this,[ast,"Value of type '"+scope+"' is not callable.  Did you mean to include 'new'?"]):(nodeType=nodeType==TypeScript.NodeType.Call?"callable":"newable",JAM.call(this.reportError,
this,[ast,"Value of type '"+scope+"' is not "+nodeType]))}function v512(ast){JAM.call(this.simpleError,this,[ast,"The left-hand side of an assignment expression must be a variable, property or indexer"])}function v511(ast){JAM.call(this.simpleError,this,[ast,"Keyword 'super' can only be used inside a class instance method"])}function v510(sym,msg){JAM.call(this.reportErrorFromSym,this,[sym,msg])}function v509(ast,msg){JAM.call(this.reportError,this,[ast,msg])}function v508(ast,msg){var bkThrow=this.pushToErrorSink;
this.pushToErrorSink=!1;JAM.call(this.reportError,this,[ast,"STYLE: "+msg]);this.pushToErrorSink=bkThrow}function v507(ast,name){JAM.call(this.reportError,this,[ast,"The name '"+name+"' does not refer to a value"])}function v506(ast,name){JAM.call(this.reportError,this,[ast,"The name '"+name+"' does not exist in the current scope"])}function v505(ast,text,symbol){var defLineCol={line:-1,col:-1},v9644=this.parser;JAM.call(v9644.getSourceLineCol,v9644,[defLineCol,symbol.location]);JAM.call(this.reportError,
this,[ast,"symbol "+text+" defined at ("+defLineCol.line+","+defLineCol.col+")"])}function v504(ast,name){JAM.call(this.reportError,this,[ast,"Duplicate identifier '"+name+"'"])}function v503(ast,message){JAM.call(this.reportError,this,[ast,message]);throw Error("EmitError");}function v502(symbol,message){if(this.pushToErrorSink)JAM.call(this.captureError,this,[message]);else{this.hasErrors=!0;var v17340=this.parser.errorRecovery;v17340&&(v17340=this.parser.errorCallback);v17340?(v17340=this.parser,
JAM.call(v17340.errorCallback,v17340,[symbol.location,symbol.length,message,this.checker.locationInfo.unitIndex])):(JAM.call(this.writePrefixFromSym,this,[symbol]),v17340=this.outfile,JAM.call(v17340.WriteLine,v17340,[message]))}}function v501(ast,message){if(this.pushToErrorSink)JAM.call(this.captureError,this,[message]);else{this.hasErrors=!0;var v17342=ast;v17342&&(v17342=this.parser.errorRecovery)&&(v17342=this.parser.errorCallback);if(v17342){var v17342=ast.limChar-ast.minChar,v9658=this.parser;
JAM.call(v9658.errorCallback,v9658,[ast.minChar,v17342,message,this.checker.locationInfo.unitIndex])}else JAM.call(this.writePrefix,this,[ast]),v17342=this.outfile,JAM.call(v17342.WriteLine,v17342,[message])}}function v500(ast){ast&&(ast.flags|=TypeScript.ASTFlags.Error,this.checker.locationInfo.lineMap&&JAM.call(TypeScript.getSourceLineColFromMap,TypeScript,[this.lineCol,ast.minChar,this.checker.locationInfo.lineMap]))}function v499(symbol){var v17348=symbol;v17348&&(v17348=this.checker.locationInfo.lineMap);
v17348?JAM.call(TypeScript.getSourceLineColFromMap,TypeScript,[this.lineCol,symbol.location,this.checker.locationInfo.lineMap]):(this.lineCol.line=-1,this.lineCol.col=-1);this.emitPrefix()}function v498(ast){ast?JAM.call(this.setError,this,[ast]):(this.lineCol.line=0,this.lineCol.col=0);this.emitPrefix()}function v497(){if(this.emitAsComments){var v9675=this.outfile;JAM.call(v9675.Write,v9675,["// "])}v9675=this.outfile;JAM.call(v9675.Write,v9675,[this.checker.locationInfo.filename+"("+this.lineCol.line+
","+this.lineCol.col+"): "])}function v496(outerr){this.outfile=outerr;this.emitAsComments=!1}function v495(emsg){JAM.set(this.errorSink,this.errorSink.length,emsg)}function v494(){this.errorSink=[]}function v493(){return this.errorSink}function ErrorReporter(outfile){this.outfile=outfile;this.checker=this.parser=null;this.lineCol={line:0,col:0};this.emitAsComments=!0;this.pushToErrorSink=this.hasErrors=!1;this.errorSink=[]}ErrorReporter.prototype.getCapturedErrors=v493;ErrorReporter.prototype.freeCapturedErrors=
v494;ErrorReporter.prototype.captureError=v495;ErrorReporter.prototype.setErrOut=v496;ErrorReporter.prototype.emitPrefix=v497;ErrorReporter.prototype.writePrefix=v498;ErrorReporter.prototype.writePrefixFromSym=v499;ErrorReporter.prototype.setError=v500;ErrorReporter.prototype.reportError=v501;ErrorReporter.prototype.reportErrorFromSym=v502;ErrorReporter.prototype.emitterError=v503;ErrorReporter.prototype.duplicateIdentifier=v504;ErrorReporter.prototype.showRef=v505;ErrorReporter.prototype.unresolvedSymbol=
v506;ErrorReporter.prototype.symbolDoesNotReferToAValue=v507;ErrorReporter.prototype.styleError=v508;ErrorReporter.prototype.simpleError=v509;ErrorReporter.prototype.simpleErrorFromSym=v510;ErrorReporter.prototype.invalidSuperReference=v511;ErrorReporter.prototype.valueCannotBeModified=v512;ErrorReporter.prototype.invalidCall=v513;ErrorReporter.prototype.indexLHS=v514;ErrorReporter.prototype.incompatibleTypes=v515;ErrorReporter.prototype.expectedClassOrInterface=v516;ErrorReporter.prototype.unaryOperatorTypeError=
v517;return ErrorReporter}var ErrorReporter=v518();TypeScript.ErrorReporter=ErrorReporter}
function v492(){var TypeScript=v18803;function v491(){function v490(fileName,useUTF8){try{var v9706=this.emitOptions.ioHost;return JAM.call(v9706.createFile,v9706,[fileName,useUTF8])}catch(ex){v9706=this.errorReporter,JAM.call(v9706.emitterError,v9706,[null,ex.message])}}function shouldCaptureThis(func){var v9709=func.hasSelfReference();v9709||(v9709=func.hasSuperReferenceInFatArrowFunction());return v9709}function v489(){var v17354=this.thisFnc;v17354&&(v17354=!this.thisFnc.isMethod())&&(v17354=
!this.thisFnc.isConstructor);v17354?JAM.call(this.writeToOutput,this,["_this"]):JAM.call(this.writeToOutput,this,["this"])}function v488(callEx){if(callEx.target.nodeType==TypeScript.NodeType.Dot){var dotNode=callEx.target;if(dotNode.operand1.nodeType==TypeScript.NodeType.Super)return JAM.call(this.emitJavascript,this,[dotNode,TypeScript.TokenID.OpenParen,!1]),JAM.call(this.writeToOutput,this,[".call("]),this.emitThis(),(dotNode=callEx.arguments)&&(dotNode=0<callEx.arguments.members.length),dotNode&&
(JAM.call(this.writeToOutput,this,[", "]),JAM.call(this.emitJavascriptList,this,[callEx.arguments,", ",TypeScript.TokenID.Comma,!1,!1,!1])),JAM.call(this.writeToOutput,this,[")"]),!0}return!1}function v487(){JAM.call(this.writeToOutput,this,["_super.prototype"])}function v486(reqInherits){this.prologueEmitted||(reqInherits&&(this.prologueEmitted=!0,JAM.call(this.writeLineToOutput,this,["var __extends = this.__extends || function (d, b) {"]),JAM.call(this.writeLineToOutput,this,["    function __() { this.constructor = d; }"]),
JAM.call(this.writeLineToOutput,this,["    __.prototype = b.prototype;"]),JAM.call(this.writeLineToOutput,this,["    d.prototype = new __();"]),JAM.call(this.writeLineToOutput,this,["};"])),this.checker.mustCaptureGlobalThis&&(this.prologueEmitted=!0,JAM.call(this.writeLineToOutput,this,[this.captureThisStmtString])))}function v485(classDecl){if(!JAM.call(TypeScript.hasFlag,TypeScript,[classDecl.varFlags,TypeScript.VarFlags.Ambient])){var svClassNode=this.thisClassNode,i=0;this.thisClassNode=classDecl;
var className=classDecl.name.actualText;JAM.call(this.emitParensAndCommentsInPlace,this,[classDecl,!0]);var temp=JAM.call(this.setContainer,this,[EmitContainer.Class]);JAM.call(this.recordSourceMappingStart,this,[classDecl]);var v17365=JAM.call(TypeScript.hasFlag,TypeScript,[classDecl.varFlags,TypeScript.VarFlags.Exported]);v17365&&(v17365=classDecl.type.symbol.container==this.checker.gloMod);v17365?JAM.call(this.writeToOutput,this,["this."+className]):JAM.call(this.writeToOutput,this,["var "+className]);
if(v17365=classDecl.extendsList)v17365=classDecl.extendsList.members.length;var baseNameDecl=null,baseNameDecl=null;v17365?JAM.call(this.writeLineToOutput,this,[" = (function (_super) {"]):JAM.call(this.writeLineToOutput,this,[" = (function () {"]);JAM.call(this.recordSourceMappingNameStart,this,[className]);this.indenter.increaseIndent();v17365&&(baseNameDecl=classDecl.extendsList.members[0],baseNameDecl=baseNameDecl.nodeType==TypeScript.NodeType.Call?baseNameDecl.target:baseNameDecl,this.emitIndent(),
JAM.call(this.writeLineToOutput,this,["__extends("+className+", _super);"]));this.emitIndent();if(i=classDecl.constructorDecl)JAM.call(this.emitJavascript,this,[classDecl.constructorDecl,TypeScript.TokenID.OpenParen,!1]);else{var wroteProps=0;JAM.call(this.recordSourceMappingStart,this,[classDecl]);this.indenter.increaseIndent();JAM.call(this.writeToOutput,this,["function "+classDecl.name.actualText+"() {"]);JAM.call(this.recordSourceMappingNameStart,this,["constructor"]);v17365&&(JAM.call(this.writeLineToOutput,
this,[""]),this.emitIndent(),JAM.call(this.writeLineToOutput,this,["_super.apply(this, arguments);"]),wroteProps+=1);classDecl.varFlags&TypeScript.VarFlags.MustCaptureThis&&JAM.call(this.writeCaptureThisStatement,this,[classDecl]);for(var members=this.thisClassNode.members.members,i=0,v9739=i<members.length;v9739;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v9739=members[i];if(v9739.nodeType==TypeScript.NodeType.VarDecl){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v9739=
members[i];var v17378=!JAM.call(TypeScript.hasFlag,TypeScript,[v9739.varFlags,TypeScript.VarFlags.Static]);v17378&&(v17378=v9739.init);v17378&&(JAM.call(this.writeLineToOutput,this,[""]),this.emitIndent(),JAM.call(this.emitJavascriptVarDecl,this,[v9739,TypeScript.TokenID.Tilde]),wroteProps+=1)}i+=1;v9739=i<members.length}wroteProps?(JAM.call(this.writeLineToOutput,this,[""]),this.indenter.decreaseIndent(),this.emitIndent(),JAM.call(this.writeLineToOutput,this,["}"])):(JAM.call(this.writeLineToOutput,
this,[" }"]),this.indenter.decreaseIndent());this.recordSourceMappingNameEnd();JAM.call(this.recordSourceMappingEnd,this,[classDecl])}i=classDecl.members.members.length;wroteProps=0;for(members=wroteProps<i;members;){members=classDecl.members.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)members=members[wroteProps];if(members.nodeType==TypeScript.NodeType.FuncDecl)(v9739=JAM.call(TypeScript.hasFlag,TypeScript,[members.fncFlags,TypeScript.FncFlags.Method]))&&(v9739=!members.isSignature()),
v9739&&(JAM.call(TypeScript.hasFlag,TypeScript,[members.fncFlags,TypeScript.FncFlags.Static])?members.isAccessor()?JAM.call(this.emitPropertyAccessor,this,[members,this.thisClassNode.name.actualText,!1]):(this.emitIndent(),JAM.call(this.recordSourceMappingStart,this,[members]),JAM.call(this.writeToOutput,this,[classDecl.name.actualText+"."+members.name.actualText+" = "]),(v9739=members.name)&&(v9739=!members.name.isMissing()),JAM.call(this.emitInnerFunction,this,[members,v9739,!0,null,JAM.call(Emitter.shouldCaptureThis,
Emitter,[members]),null]),JAM.call(this.writeLineToOutput,this,[";"])):JAM.call(this.emitPrototypeMember,this,[members,className]));else if(members.nodeType==TypeScript.NodeType.VarDecl)v9739=members,JAM.call(TypeScript.hasFlag,TypeScript,[v9739.varFlags,TypeScript.VarFlags.Static])&&v9739.init&&(this.emitIndent(),JAM.call(this.recordSourceMappingStart,this,[v9739]),JAM.call(this.writeToOutput,this,[classDecl.name.actualText+"."+v9739.id.actualText+" = "]),JAM.call(this.emitJavascript,this,[v9739.init,
TypeScript.TokenID.Equals,!1]),JAM.call(this.writeLineToOutput,this,[";"]),JAM.call(this.recordSourceMappingEnd,this,[v9739]));else throw Error("We want to catch this");wroteProps+=1;members=wroteProps<i}this.emitIndent();JAM.call(this.recordSourceMappingStart,this,[classDecl.endingToken]);JAM.call(this.writeLineToOutput,this,["return "+className+";"]);JAM.call(this.recordSourceMappingEnd,this,[classDecl.endingToken]);this.indenter.decreaseIndent();this.emitIndent();JAM.call(this.recordSourceMappingStart,
this,[classDecl.endingToken]);JAM.call(this.writeToOutput,this,["}"]);this.recordSourceMappingNameEnd();JAM.call(this.recordSourceMappingEnd,this,[classDecl.endingToken]);JAM.call(this.recordSourceMappingStart,this,[classDecl]);JAM.call(this.writeToOutput,this,[")("]);v17365&&JAM.call(this.emitJavascript,this,[baseNameDecl,TypeScript.TokenID.Tilde,!1]);JAM.call(this.writeToOutput,this,[");"]);JAM.call(this.recordSourceMappingEnd,this,[classDecl]);(v17365=temp==EmitContainer.Module)||(v17365=temp==
EmitContainer.DynamicModule);v17365&&(v17365=JAM.call(TypeScript.hasFlag,TypeScript,[classDecl.varFlags,TypeScript.VarFlags.Exported]));v17365&&(JAM.call(this.writeLineToOutput,this,[""]),this.emitIndent(),v17365=temp==EmitContainer.Module?this.moduleName:"exports",JAM.call(this.recordSourceMappingStart,this,[classDecl]),JAM.call(this.writeToOutput,this,[v17365+"."+className+" = "+className+";"]),JAM.call(this.recordSourceMappingEnd,this,[classDecl]));this.emitIndent();JAM.call(this.recordSourceMappingEnd,
this,[classDecl]);JAM.call(this.emitParensAndCommentsInPlace,this,[classDecl,!1]);JAM.call(this.setContainer,this,[temp]);this.thisClassNode=svClassNode}}function v484(className,base,classDecl){function v483(key,s,c){key=s;if(s=key.kind()==TypeScript.SymbolKind.Type)s=key.type.call;s&&(JAM.call(this.recordSourceMappingStart,this,[key.declAST]),JAM.call(this.writeLineToOutput,this,[className+".prototype."+key.name+" = "+baseName+".prototype."+key.name+";"]),JAM.call(this.recordSourceMappingEnd,this,
[key.declAST]))}if(base.members){var baseSymbol=base.symbol,baseName=baseSymbol.name;baseSymbol.declModule!=classDecl.type.symbol.declModule&&(baseName=baseSymbol.fullName());baseSymbol=base.members.allMembers;JAM.call(baseSymbol.map,baseSymbol,[v483,null])}if(base.extendsList)for(var baseSymbol=0,len=base.extendsList.length,v9779=baseSymbol<len;v9779;){v9779=base.extendsList;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v9779=v9779[baseSymbol];JAM.call(this.emitAddBaseMethods,this,
[className,v9779,classDecl]);baseSymbol+=1;v9779=baseSymbol<len}}function v482(member,className){if(member.nodeType==TypeScript.NodeType.FuncDecl){var funcDecl=member;funcDecl.isAccessor()?JAM.call(this.emitPropertyAccessor,this,[funcDecl,className,!0]):(this.emitIndent(),JAM.call(this.recordSourceMappingStart,this,[funcDecl]),JAM.call(this.writeToOutput,this,[className+".prototype."+funcDecl.getNameText()+" = "]),JAM.call(this.emitInnerFunction,this,[funcDecl,!1,!0,null,JAM.call(Emitter.shouldCaptureThis,
Emitter,[funcDecl]),null]),JAM.call(this.writeLineToOutput,this,[";"]))}else member.nodeType==TypeScript.NodeType.VarDecl&&(funcDecl=member,funcDecl.init&&(this.emitIndent(),JAM.call(this.recordSourceMappingStart,this,[funcDecl]),JAM.call(this.recordSourceMappingStart,this,[funcDecl.id]),JAM.call(this.writeToOutput,this,[className+".prototype."+funcDecl.id.actualText]),JAM.call(this.recordSourceMappingEnd,this,[funcDecl.id]),JAM.call(this.writeToOutput,this,[" = "]),JAM.call(this.emitJavascript,this,
[funcDecl.init,TypeScript.TokenID.Equals,!1]),JAM.call(this.recordSourceMappingEnd,this,[funcDecl]),JAM.call(this.writeLineToOutput,this,[";"])))}function v481(funcDecl,className,isProto){if(!funcDecl.accessorSymbol.hasBeenEmitted){var accessorSymbol=funcDecl.accessorSymbol;this.emitIndent();JAM.call(this.recordSourceMappingStart,this,[funcDecl]);className="Object.defineProperty("+className;var v26036;v26036=isProto?'.prototype, "':', "';JAM.call(this.writeLineToOutput,this,[className+v26036+funcDecl.name.actualText+
'", {']);this.indenter.increaseIndent();accessorSymbol.getter&&(className=accessorSymbol.getter.declAST,this.emitIndent(),JAM.call(this.recordSourceMappingStart,this,[className]),JAM.call(this.writeToOutput,this,["get: "]),JAM.call(this.emitInnerFunction,this,[className,!1,isProto,null,JAM.call(Emitter.shouldCaptureThis,Emitter,[className]),null]),JAM.call(this.writeLineToOutput,this,[","]));accessorSymbol.setter&&(className=accessorSymbol.setter.declAST,this.emitIndent(),JAM.call(this.recordSourceMappingStart,
this,[className]),JAM.call(this.writeToOutput,this,["set: "]),JAM.call(this.emitInnerFunction,this,[className,!1,isProto,null,JAM.call(Emitter.shouldCaptureThis,Emitter,[className]),null]),JAM.call(this.writeLineToOutput,this,[","]));this.emitIndent();JAM.call(this.writeLineToOutput,this,["enumerable: true,"]);this.emitIndent();JAM.call(this.writeLineToOutput,this,["configurable: true"]);this.indenter.decreaseIndent();this.emitIndent();JAM.call(this.writeLineToOutput,this,["});"]);JAM.call(this.recordSourceMappingEnd,
this,[funcDecl]);accessorSymbol.hasBeenEmitted=!0}}function v480(ast,tokenId,startLine){if(null!=ast){var v17417=startLine;v17417&&(v17417=0<this.indenter.indentAmt)&&(v17417=ast.nodeType!=TypeScript.NodeType.List)&&(v17417=ast.nodeType!=TypeScript.NodeType.Block);if(v17417){if(v17417=ast.nodeType!=TypeScript.NodeType.InterfaceDeclaration)if((v17417=ast.nodeType==TypeScript.NodeType.VarDecl)&&(v17417=(ast.varFlags&TypeScript.VarFlags.Ambient)==TypeScript.VarFlags.Ambient)&&(v17417=null==ast.init),
(v17417=!v17417)&&(v17417=0<=this.varListCount()),v17417&&(v17417=ast.nodeType!=TypeScript.NodeType.EndCode))(v17417=ast.nodeType!=TypeScript.NodeType.FuncDecl)||(v17417=this.emitState.container!=EmitContainer.Constructor);v17417&&this.emitIndent()}JAM.call(ast.emit,ast,[this,tokenId,startLine]);(tokenId=tokenId==TypeScript.TokenID.Semicolon)&&(tokenId=ast.nodeType<TypeScript.NodeType.GeneralNode);tokenId&&JAM.call(this.writeToOutput,this,[";"])}}function v479(ast,delimiter,tokenId,startLine,onlyStatics,
emitClassPropertiesAfterSuperCall,emitPrologue,requiresExtendsBlock){"undefined"===typeof emitClassPropertiesAfterSuperCall&&(emitClassPropertiesAfterSuperCall=!1);"undefined"===typeof emitPrologue&&(emitPrologue=!1);if(null!=ast)if(ast.nodeType!=TypeScript.NodeType.List)JAM.call(this.emitPrologue,this,[emitPrologue]),JAM.call(this.emitJavascript,this,[ast,tokenId,startLine]);else{var list=ast;if(0!=list.members.length){JAM.call(this.emitParensAndCommentsInPlace,this,[ast,!0]);for(var len=list.members.length,
i=0,v9835=i<len;v9835;){emitPrologue&&((v9835=1==i)||(v9835=!JAM.call(TypeScript.hasFlag,TypeScript,[list.flags,TypeScript.ASTFlags.StrictMode])),v9835&&(JAM.call(this.emitPrologue,this,[requiresExtendsBlock]),emitPrologue=!1));(v9835=1==i)&&(v9835=emitClassPropertiesAfterSuperCall);if(v9835){var v17427=v9835=this.thisClassNode.constructorDecl;v17427&&(v17427=v9835.arguments);if(v17427)for(var v17427=v9835.arguments.members.length,iArg=0,v9821=iArg<v17427;v9821;){v9821=v9835.arguments.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v9821=
v9821[iArg];(v9821.varFlags&TypeScript.VarFlags.Property)!=TypeScript.VarFlags.None&&(this.emitIndent(),JAM.call(this.recordSourceMappingStart,this,[v9821]),JAM.call(this.recordSourceMappingStart,this,[v9821.id]),JAM.call(this.writeToOutput,this,["this."+v9821.id.actualText]),JAM.call(this.recordSourceMappingEnd,this,[v9821.id]),JAM.call(this.writeToOutput,this,[" = "]),JAM.call(this.recordSourceMappingStart,this,[v9821.id]),JAM.call(this.writeToOutput,this,[v9821.id.actualText]),JAM.call(this.recordSourceMappingEnd,
this,[v9821.id]),JAM.call(this.writeLineToOutput,this,[";"]),JAM.call(this.recordSourceMappingEnd,this,[v9821]));iArg+=1;v9821=iArg<v17427}v9835=this.thisClassNode.members.members.length;v17427=0;for(iArg=v17427<v9835;iArg;){iArg=this.thisClassNode.members.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)iArg=iArg[v17427];if(iArg.nodeType==TypeScript.NodeType.VarDecl){iArg=this.thisClassNode.members.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)iArg=
iArg[v17427];if(v9821=!JAM.call(TypeScript.hasFlag,TypeScript,[iArg.varFlags,TypeScript.VarFlags.Static]))v9821=iArg.init;v9821&&(this.emitIndent(),JAM.call(this.emitJavascriptVarDecl,this,[iArg,TypeScript.TokenID.Tilde]),JAM.call(this.writeLineToOutput,this,[""]))}v17427+=1;iArg=v17427<v9835}}v9835=list.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v9835=v9835[i];(v17427=v9835.nodeType==TypeScript.NodeType.FuncDecl)&&(v17427=JAM.call(TypeScript.hasFlag,TypeScript,[v9835.fncFlags,
TypeScript.FncFlags.Static]));v17427||(v17427=v9835.nodeType==TypeScript.NodeType.VarDecl)&&(v17427=JAM.call(TypeScript.hasFlag,TypeScript,[v9835.varFlags,TypeScript.VarFlags.Static]));v17427=onlyStatics?!v17427:v17427;if(!v17427)if(JAM.call(this.emitJavascript,this,[v9835,tokenId,startLine]),(v17427=delimiter)&&(v17427=i<len-1),v17427)startLine?JAM.call(this.writeLineToOutput,this,[delimiter]):JAM.call(this.writeToOutput,this,[delimiter]);else{if(v17427=startLine)if(v17427=v9835.nodeType!=TypeScript.NodeType.ModuleDeclaration)if(v17427=
v9835.nodeType!=TypeScript.NodeType.InterfaceDeclaration)(v17427=v9835.nodeType==TypeScript.NodeType.VarDecl)&&(v17427=(v9835.varFlags&TypeScript.VarFlags.Ambient)==TypeScript.VarFlags.Ambient)&&(v17427=null==v9835.init),(v17427=!v17427)&&(v17427=0<=this.varListCount()),v17427&&(v17427=v9835.nodeType!=TypeScript.NodeType.Block,v17427||(v17427=v9835.isStatementBlock),v17427&&(v17427=v9835.nodeType!=TypeScript.NodeType.EndCode)&&(v17427=v9835.nodeType!=TypeScript.NodeType.FuncDecl));v17427&&JAM.call(this.writeLineToOutput,
this,[""])}i+=1;v9835=i<len}JAM.call(this.emitParensAndCommentsInPlace,this,[ast,!1])}}}function v478(){if(null!=this.sourceMapper){var v9838=TypeScript.SourceMapper;JAM.call(v9838.EmitSourceMapping,v9838,[this.allSourceMappers])}try{this.outfile.Close()}catch(ex){v9838=this.errorReporter,JAM.call(v9838.emitterError,v9838,[null,ex.message])}}function v477(ast){var v17447=this.sourceMapper;v17447&&(v17447=JAM.call(TypeScript.isValidAstNode,TypeScript,[ast]));if(v17447){this.sourceMapper.currentMappings.pop();
ast=this.sourceMapper.currentMappings;v17447=this.sourceMapper.currentMappings.length-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)ast=ast[v17447];v17447=ast.length-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)ast=ast[v17447];ast.end.emittedColumn=this.emitState.column;ast.end.emittedLine=this.emitState.line}}function v476(ast){var v17454=this.sourceMapper;v17454&&(v17454=JAM.call(TypeScript.isValidAstNode,TypeScript,[ast]));if(v17454){var lineCol={line:-1,
col:-1},v17454=new TypeScript.SourceMapping;v17454.start.emittedColumn=this.emitState.column;v17454.start.emittedLine=this.emitState.line;JAM.call(TypeScript.getSourceLineColFromMap,TypeScript,[lineCol,ast.minChar,this.checker.locationInfo.lineMap]);v17454.start.sourceColumn=lineCol.col;v17454.start.sourceLine=lineCol.line;JAM.call(TypeScript.getSourceLineColFromMap,TypeScript,[lineCol,ast.limChar,this.checker.locationInfo.lineMap]);v17454.end.sourceColumn=lineCol.col;v17454.end.sourceLine=lineCol.line;
0<this.sourceMapper.currentNameIndex.length&&(v17454.nameIndex=this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length-1]);ast=this.sourceMapper.currentMappings;lineCol=this.sourceMapper.currentMappings.length-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)ast=ast[lineCol];JAM.call(ast.push,ast,[v17454]);ast=this.sourceMapper.currentMappings;JAM.call(ast.push,ast,[v17454.childMappings])}}function v475(){this.sourceMapper&&this.sourceMapper.currentNameIndex.pop()}
function v474(name){if(this.sourceMapper){var finalName=name;if(!name)finalName="";else if(0<this.sourceMapper.currentNameIndex.length){var finalName=this.sourceMapper.names,v22032=this.sourceMapper.currentNameIndex.length-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)finalName=finalName[v22032];finalName=finalName+"."+name}name=this.sourceMapper.names;JAM.call(name.push,name,[finalName]);name=this.sourceMapper.currentNameIndex;JAM.call(name.push,name,[this.sourceMapper.names.length-
1])}}function v473(stmts,emitClassPropertiesAfterSuperCall){"undefined"===typeof emitClassPropertiesAfterSuperCall&&(emitClassPropertiesAfterSuperCall=!1);if(stmts.nodeType!=TypeScript.NodeType.Block)if(stmts.nodeType==TypeScript.NodeType.List){var stmtList=stmts,v17476=2==stmtList.members.length;v17476&&(v17476=stmtList.members[0].nodeType==TypeScript.NodeType.Block)&&(v17476=stmtList.members[1].nodeType==TypeScript.NodeType.EndCode);v17476?(JAM.call(this.emitJavascript,this,[stmtList.members[0],
TypeScript.TokenID.Semicolon,!0]),JAM.call(this.writeLineToOutput,this,[""])):JAM.call(this.emitJavascriptList,this,[stmts,null,TypeScript.TokenID.Semicolon,!0,!1,emitClassPropertiesAfterSuperCall])}else JAM.call(this.emitJavascript,this,[stmts,TypeScript.TokenID.Semicolon,!0]);else JAM.call(this.emitJavascript,this,[stmts,TypeScript.TokenID.Semicolon,!0])}function v472(stmts,emitEmptyBod){if(stmts)if(stmts.nodeType!=TypeScript.NodeType.Block){var v9888=stmts;v9888&&((v9888=stmts.nodeType!=TypeScript.NodeType.List)||
(v9888=0<stmts.members.length));if(emitEmptyBod||v9888)v9888=stmts.nodeType==TypeScript.NodeType.Block,v9888||(v9888=stmts.nodeType==TypeScript.NodeType.List)&&(v9888=1==stmts.members.length)&&(v9888=stmts.members[0].nodeType==TypeScript.NodeType.Block),JAM.call(this.recordSourceMappingStart,this,[stmts]),v9888||(JAM.call(this.writeLineToOutput,this,[" {"]),this.indenter.increaseIndent()),JAM.call(this.emitJavascriptList,this,[stmts,null,TypeScript.TokenID.Semicolon,!0,!1,!1]),v9888||(JAM.call(this.writeLineToOutput,
this,[""]),this.indenter.decreaseIndent(),this.emitIndent(),JAM.call(this.writeToOutput,this,["}"])),JAM.call(this.recordSourceMappingEnd,this,[stmts])}else JAM.call(this.emitJavascript,this,[stmts,TypeScript.TokenID.Semicolon,!0]);else emitEmptyBod&&JAM.call(this.writeToOutput,this,["{ }"])}function v471(name,addThis){var sym=name.sym;JAM.call(this.emitParensAndCommentsInPlace,this,[name,!0]);JAM.call(this.recordSourceMappingStart,this,[name]);if(!name.isMissing()){var v17492=addThis;v17492&&(v17492=
this.emitState.container!=EmitContainer.Args)&&(v17492=sym);if(v17492)if((v17492=sym.container)&&(v17492=sym.container.name!=TypeScript.globalId),v17492)if((v17492=JAM.call(TypeScript.hasFlag,TypeScript,[sym.flags,TypeScript.SymbolFlags.Static]))&&(v17492=JAM.call(TypeScript.hasFlag,TypeScript,[sym.flags,TypeScript.SymbolFlags.Property])),v17492)(v17492=sym.declModule)&&(v17492=JAM.call(TypeScript.hasFlag,TypeScript,[sym.declModule.modFlags,TypeScript.ModuleFlags.IsDynamic])),v17492?JAM.call(this.writeToOutput,
this,["exports."]):JAM.call(this.writeToOutput,this,[sym.container.name+"."]);else if(sym.kind()==TypeScript.SymbolKind.Field)if(v17492=sym,JAM.call(TypeScript.hasFlag,TypeScript,[v17492.flags,TypeScript.SymbolFlags.ModuleMember])){if(v17492=sym.container!=this.checker.gloMod)(v17492=JAM.call(TypeScript.hasFlag,TypeScript,[sym.flags,TypeScript.SymbolFlags.Property]))||(v17492=JAM.call(TypeScript.hasFlag,TypeScript,[sym.flags,TypeScript.SymbolFlags.Exported]));v17492&&(JAM.call(TypeScript.hasFlag,
TypeScript,[sym.declModule.modFlags,TypeScript.ModuleFlags.IsDynamic])?JAM.call(this.writeToOutput,this,["exports."]):JAM.call(this.writeToOutput,this,[sym.container.name+"."]))}else sym.isInstanceProperty()&&(this.emitThis(),JAM.call(this.writeToOutput,this,["."]));else sym.kind()==TypeScript.SymbolKind.Type&&(sym.isInstanceProperty()?(v17492=sym,v17492=v17492.type,(v17492=v17492.call)&&(v17492=!JAM.call(TypeScript.hasFlag,TypeScript,[sym.flags,TypeScript.SymbolFlags.ModuleMember])),v17492&&(this.emitThis(),
JAM.call(this.writeToOutput,this,["."]))):((v17492=sym.unitIndex!=this.checker.locationInfo.unitIndex)||(v17492=!JAM.call(this.declEnclosed,this,[sym.declModule])),v17492&&JAM.call(this.writeToOutput,this,[sym.container.name+"."])));else{if(v17492=sym.container==this.checker.gloMod)if(v17492=JAM.call(TypeScript.hasFlag,TypeScript,[sym.flags,TypeScript.SymbolFlags.Exported]))if(v17492=!JAM.call(TypeScript.hasFlag,TypeScript,[sym.flags,TypeScript.SymbolFlags.Ambient]))(v17492=sym.isType())||(v17492=
sym.isMember()),v17492&&(v17492=sym.declModule)&&(v17492=JAM.call(TypeScript.hasFlag,TypeScript,[sym.declModule.modFlags,TypeScript.ModuleFlags.Ambient])),(v17492=!v17492)&&(v17492=this.emitState.container==EmitContainer.Prog)&&(v17492=sym.declAST.nodeType!=TypeScript.NodeType.FuncDecl);v17492&&JAM.call(this.writeToOutput,this,["this."])}(v17492=sym)&&(v17492=sym.declAST)&&(v17492=sym.declAST.nodeType==TypeScript.NodeType.ModuleDeclaration)&&(v17492=JAM.call(TypeScript.hasFlag,TypeScript,[sym.declAST.modFlags,
TypeScript.ModuleFlags.IsDynamic]));if(v17492)if(v17492=sym.declAST,TypeScript.moduleGenTarget==TypeScript.ModuleGenTarget.Asynchronous)JAM.call(this.writeLineToOutput,this,["__"+this.modAliasId+"__;"]);else{var sym=name.actualText,v9916=v17492.mod.symbol.declAST;v9916&&(v9916=JAM.call(TypeScript.hasFlag,TypeScript,[v17492.mod.symbol.declAST.modFlags,TypeScript.ModuleFlags.Ambient]));(v17492=v9916)||(sym=this.firstModAlias?this.firstModAlias:JAM.call(TypeScript.quoteBaseName,TypeScript,[sym]));v17492||
(sym=JAM.call(TypeScript.isRelative,TypeScript,[JAM.call(TypeScript.stripQuotes,TypeScript,[sym])])?sym:JAM.call(TypeScript.quoteStr,TypeScript,["./"+JAM.call(TypeScript.stripQuotes,TypeScript,[sym])]));JAM.call(this.writeToOutput,this,["require("+sym+")"])}else JAM.call(this.writeToOutput,this,[name.actualText])}JAM.call(this.recordSourceMappingEnd,this,[name]);JAM.call(this.emitParensAndCommentsInPlace,this,[name,!1])}function v470(moduleDecl){if(null==moduleDecl)return!0;for(var i=0,len=this.moduleDeclList.length,
v9927=i<len;v9927;){v9927=this.moduleDeclList;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v9927=v9927[i];if(v9927==moduleDecl)return!0;i+=1;v9927=i<len}return!1}function v469(varDecl,tokenId){if((varDecl.varFlags&TypeScript.VarFlags.Ambient)==TypeScript.VarFlags.Ambient)JAM.call(this.emitAmbientVarDecl,this,[varDecl]),this.onEmitVar();else{var sym=varDecl.sym,hasInitializer=null!=varDecl.init;JAM.call(this.emitParensAndCommentsInPlace,this,[varDecl,!0]);JAM.call(this.recordSourceMappingStart,
this,[varDecl]);var v17524=sym;v17524&&(v17524=sym.isMember())&&(v17524=sym.container)&&(v17524=sym.container.kind()==TypeScript.SymbolKind.Type);if(v17524){var v17524=sym.container.type,v17525=v17524.isClass();v17525&&(v17525=!JAM.call(TypeScript.hasFlag,TypeScript,[sym.flags,TypeScript.SymbolFlags.ModuleMember]));if(v17525)this.emitState.container!=EmitContainer.Args&&(JAM.call(TypeScript.hasFlag,TypeScript,[sym.flags,TypeScript.SymbolFlags.Static])?JAM.call(this.writeToOutput,this,[sym.container.name+
"."]):JAM.call(this.writeToOutput,this,["this."]));else if(v17524.hasImplementation()){if(v17524=!JAM.call(TypeScript.hasFlag,TypeScript,[sym.flags,TypeScript.SymbolFlags.Exported]))(v17524=sym.container==this.checker.gloMod)||(v17524=!JAM.call(TypeScript.hasFlag,TypeScript,[sym.flags,TypeScript.SymbolFlags.Property]));v17524?this.emitVarDeclVar():JAM.call(TypeScript.hasFlag,TypeScript,[varDecl.varFlags,TypeScript.VarFlags.LocalStatic])?JAM.call(this.writeToOutput,this,["."]):this.emitState.container==
EmitContainer.DynamicModule?JAM.call(this.writeToOutput,this,["exports."]):JAM.call(this.writeToOutput,this,[this.moduleName+"."])}else tokenId!=TypeScript.TokenID.OpenParen&&((v17524=JAM.call(TypeScript.hasFlag,TypeScript,[sym.flags,TypeScript.SymbolFlags.Exported]))&&(v17524=sym.container==this.checker.gloMod),v17524?JAM.call(this.writeToOutput,this,["this."]):this.emitVarDeclVar())}else tokenId!=TypeScript.TokenID.OpenParen&&this.emitVarDeclVar();JAM.call(this.recordSourceMappingStart,this,[varDecl.id]);
JAM.call(this.writeToOutput,this,[varDecl.id.actualText]);JAM.call(this.recordSourceMappingEnd,this,[varDecl.id]);hasInitializer&&(JAM.call(this.writeToOutputTrimmable,this,[" = "]),sym=this.varListCountStack,JAM.call(sym.push,sym,[0]),JAM.call(this.emitJavascript,this,[varDecl.init,TypeScript.TokenID.Comma,!1]),this.varListCountStack.pop());this.onEmitVar();tokenId!=TypeScript.TokenID.OpenParen&&(0>this.varListCount()?JAM.call(this.writeToOutput,this,[", "]):tokenId!=TypeScript.TokenID.For&&JAM.call(this.writeToOutputTrimmable,
this,[";"]));JAM.call(this.recordSourceMappingEnd,this,[varDecl]);JAM.call(this.emitParensAndCommentsInPlace,this,[varDecl,!1])}}function v468(){0<this.varListCount()?JAM.call(this.setInVarBlock,this,[this.varListCount()-1]):0>this.varListCount()&&JAM.call(this.setInVarBlock,this,[this.varListCount()+1])}function v467(){0<=this.varListCount()&&(JAM.call(this.writeToOutput,this,["var "]),JAM.call(this.setInVarBlock,this,[-this.varListCount()]));return!0}function v466(){var v9960=this.varListCountStack,
v9961=this.varListCountStack.length-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v9960[v9961]}function v465(varDecl){varDecl.init&&(JAM.call(this.emitParensAndCommentsInPlace,this,[varDecl,!0]),JAM.call(this.recordSourceMappingStart,this,[varDecl]),JAM.call(this.recordSourceMappingStart,this,[varDecl.id]),JAM.call(this.writeToOutput,this,[varDecl.id.actualText]),JAM.call(this.recordSourceMappingEnd,this,[varDecl.id]),JAM.call(this.writeToOutput,this,[" = "]),JAM.call(this.emitJavascript,
this,[varDecl.init,TypeScript.TokenID.Comma,!1]),JAM.call(this.recordSourceMappingEnd,this,[varDecl]),JAM.call(this.writeToOutput,this,[";"]),JAM.call(this.emitParensAndCommentsInPlace,this,[varDecl,!1]))}function v464(funcDecl){var v17554=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.Signature]);v17554||(v17554=funcDecl.isOverload);if(!v17554){var temp,tempFnc=this.thisFnc;this.thisFnc=funcDecl;temp=funcDecl.isConstructor?JAM.call(this.setContainer,this,[EmitContainer.Constructor]):
JAM.call(this.setContainer,this,[EmitContainer.Function]);var bases=null,hasSelfRef=!1,v17554=funcDecl.getNameText();(hasSelfRef=this.emitState.inObjectLiteral)||(hasSelfRef=!funcDecl.isAccessor());hasSelfRef&&((hasSelfRef=temp!=EmitContainer.Constructor)||(hasSelfRef=(funcDecl.fncFlags&TypeScript.FncFlags.Method)==TypeScript.FncFlags.None));if(hasSelfRef){var tempLit=JAM.call(this.setInObjectLiteral,this,[!1]);this.thisClassNode&&(bases=this.thisClassNode.extendsList);hasSelfRef=JAM.call(Emitter.shouldCaptureThis,
Emitter,[funcDecl]);JAM.call(this.recordSourceMappingStart,this,[funcDecl]);var v17556=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.Exported|TypeScript.FncFlags.ClassPropertyMethodExported]);v17556&&(v17556=funcDecl.type.symbol.container==this.checker.gloMod)&&(v17556=!funcDecl.isConstructor);v17556?(JAM.call(this.writeToOutput,this,["this."+v17554+" = "]),JAM.call(this.emitInnerFunction,this,[funcDecl,!1,!1,bases,hasSelfRef,this.thisClassNode])):((v17556=funcDecl.name)&&
(v17556=!funcDecl.name.isMissing()),JAM.call(this.emitInnerFunction,this,[funcDecl,v17556,!1,bases,hasSelfRef,this.thisClassNode]));JAM.call(this.setInObjectLiteral,this,[tempLit])}JAM.call(this.setContainer,this,[temp]);this.thisFnc=tempFnc;JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.Definition])&&(JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.Static])?this.thisClassNode&&(funcDecl.isAccessor()?JAM.call(this.emitPropertyAccessor,this,
[funcDecl,this.thisClassNode.name.actualText,!1]):(this.emitIndent(),JAM.call(this.recordSourceMappingStart,this,[funcDecl]),JAM.call(this.writeLineToOutput,this,[this.thisClassNode.name.actualText+"."+v17554+" = "+v17554+";"]),JAM.call(this.recordSourceMappingEnd,this,[funcDecl]))):((temp=this.emitState.container==EmitContainer.Module)||(temp=this.emitState.container==EmitContainer.DynamicModule),temp&&(temp=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.Exported|TypeScript.FncFlags.ClassPropertyMethodExported])),
temp&&(this.emitIndent(),temp=this.emitState.container==EmitContainer.Module?this.moduleName:"exports",JAM.call(this.recordSourceMappingStart,this,[funcDecl]),JAM.call(this.writeLineToOutput,this,[temp+"."+v17554+" = "+v17554+";"]),JAM.call(this.recordSourceMappingEnd,this,[funcDecl]))))}}function v463(text){JAM.call(this.writeToOutput,this,[text])}function v462(operand1,operand2){var temp=JAM.call(this.setInObjectLiteral,this,[!1]);JAM.call(this.emitJavascript,this,[operand1,TypeScript.TokenID.Tilde,
!1]);JAM.call(this.writeToOutput,this,["["]);JAM.call(this.emitJavascriptList,this,[operand2,", ",TypeScript.TokenID.Comma,!1,!1,!1]);JAM.call(this.writeToOutput,this,["]"]);JAM.call(this.setInObjectLiteral,this,[temp])}function v461(moduleDecl){var modName=moduleDecl.name.actualText;if(JAM.call(TypeScript.isTSFile,TypeScript,[modName])){var v9992=moduleDecl.name;JAM.call(v9992.setText,v9992,[JAM.call(modName.substring,modName,[0,modName.length-3])])}else JAM.call(TypeScript.isSTRFile,TypeScript,
[modName])&&(v9992=moduleDecl.name,JAM.call(v9992.setText,v9992,[JAM.call(modName.substring,modName,[0,modName.length-4])]));if(!JAM.call(TypeScript.hasFlag,TypeScript,[moduleDecl.modFlags,TypeScript.ModuleFlags.Ambient])){var isDynamicMod=JAM.call(TypeScript.hasFlag,TypeScript,[moduleDecl.modFlags,TypeScript.ModuleFlags.IsDynamic]),prevOutFile=this.outfile,prevOutFileName=this.emittingFileName,prevAllSourceMappers=this.allSourceMappers,prevSourceMapper=this.sourceMapper,prevColumn=this.emitState.column,
prevLine=this.emitState.line,modName=JAM.call(this.setContainer,this,[EmitContainer.Module]),v9992=this.moduleName,isExported=JAM.call(TypeScript.hasFlag,TypeScript,[moduleDecl.modFlags,TypeScript.ModuleFlags.Exported]);JAM.set(this.moduleDeclList,this.moduleDeclList.length,moduleDecl);var isWholeFile=JAM.call(TypeScript.hasFlag,TypeScript,[moduleDecl.modFlags,TypeScript.ModuleFlags.IsWholeFile]);this.moduleName=moduleDecl.name.actualText;if(isDynamicMod){var tsModFileName=JAM.call(TypeScript.stripQuotes,
TypeScript,[moduleDecl.name.actualText]),modFilePath=JAM.call(TypeScript.trimModName,TypeScript,[tsModFileName])+".js",v10012=this.emitOptions,modFilePath=JAM.call(v10012.mapOutputFileName,v10012,[modFilePath,TypeScript.TypeScriptCompiler.mapToJSFileName]);this.emitOptions.ioHost&&(JAM.call(TypeScript.switchToForwardSlashes,TypeScript,[modFilePath])!=JAM.call(TypeScript.switchToForwardSlashes,TypeScript,[this.emittingFileName])?(this.emittingFileName=modFilePath,modFilePath=moduleDecl.containsUnicodeChar,
!modFilePath&&(modFilePath=this.emitOptions.emitComments)&&(modFilePath=moduleDecl.containsUnicodeCharInComment),this.outfile=modFilePath=JAM.call(this.createFile,this,[this.emittingFileName,modFilePath]),null!=prevSourceMapper&&(this.allSourceMappers=[],modFilePath=JAM.call(this.createFile,this,[this.emittingFileName+TypeScript.SourceMapper.MapFileExtension,!1]),JAM.call(this.setSourceMappings,this,[JAM.new(TypeScript.SourceMapper,[tsModFileName,this.emittingFileName,this.outfile,modFilePath,this.errorReporter])]),
this.emitState.column=0,this.emitState.line=0)):(tsModFileName=TypeScript.CompilerDiagnostics,JAM.call(tsModFileName.assert,tsModFileName,[this.emitOptions.outputMany,"Cannot have dynamic modules compiling into single file"])));JAM.call(this.setContainer,this,[EmitContainer.DynamicModule]);JAM.call(this.recordSourceMappingStart,this,[moduleDecl]);if(TypeScript.moduleGenTarget==TypeScript.ModuleGenTarget.Asynchronous){for(var tsModFileName='["require", "exports"',modFilePath="require, exports",importStatement=
null,v10012=0,importStatement=v10012<moduleDecl.mod.importedModules.length;importStatement;){var importStatement=moduleDecl.mod.importedModules[v10012],v17595=importStatement.id.sym;v17595&&(v17595=!importStatement.id.sym.onlyReferencedAsTypeRef);v17595&&(v10012<=moduleDecl.mod.importedModules.length-1&&(tsModFileName+=", ",modFilePath+=", "),modFilePath+="__"+importStatement.id.actualText+"__",tsModFileName+=importStatement.firstAliasedModToString());v10012+=1;importStatement=v10012<moduleDecl.mod.importedModules.length}v10012=
0;for(importStatement=v10012<moduleDecl.amdDependencies.length;importStatement;){importStatement=moduleDecl.amdDependencies;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)importStatement=importStatement[v10012];tsModFileName+=', "'+importStatement+'"';v10012+=1;importStatement=v10012<moduleDecl.amdDependencies.length}tsModFileName+="]";JAM.call(this.writeLineToOutput,this,["define("+tsModFileName+", function("+modFilePath+") {"])}}else isExported||(JAM.call(this.recordSourceMappingStart,
this,[moduleDecl]),JAM.call(this.writeToOutput,this,["var "]),JAM.call(this.recordSourceMappingStart,this,[moduleDecl.name]),JAM.call(this.writeToOutput,this,[this.moduleName]),JAM.call(this.recordSourceMappingEnd,this,[moduleDecl.name]),JAM.call(this.writeLineToOutput,this,[";"]),JAM.call(this.recordSourceMappingEnd,this,[moduleDecl]),this.emitIndent()),JAM.call(this.writeToOutput,this,["("]),JAM.call(this.recordSourceMappingStart,this,[moduleDecl]),JAM.call(this.writeToOutput,this,["function ("]),
JAM.call(this.recordSourceMappingStart,this,[moduleDecl.name]),JAM.call(this.writeToOutput,this,[this.moduleName]),JAM.call(this.recordSourceMappingEnd,this,[moduleDecl.name]),JAM.call(this.writeLineToOutput,this,[") {"]);isWholeFile||JAM.call(this.recordSourceMappingNameStart,this,[this.moduleName]);(tsModFileName=!isDynamicMod)||(tsModFileName=TypeScript.moduleGenTarget==TypeScript.ModuleGenTarget.Asynchronous);tsModFileName&&this.indenter.increaseIndent();moduleDecl.modFlags&TypeScript.ModuleFlags.MustCaptureThis&&
JAM.call(this.writeCaptureThisStatement,this,[moduleDecl]);JAM.call(this.emitJavascriptList,this,[moduleDecl.members,null,TypeScript.TokenID.Semicolon,!0,!1,!1]);(tsModFileName=!isDynamicMod)||(tsModFileName=TypeScript.moduleGenTarget==TypeScript.ModuleGenTarget.Asynchronous);tsModFileName&&this.indenter.decreaseIndent();this.emitIndent();if(isDynamicMod)TypeScript.moduleGenTarget==TypeScript.ModuleGenTarget.Asynchronous&&JAM.call(this.writeLineToOutput,this,["})"]),isWholeFile||this.recordSourceMappingNameEnd(),
JAM.call(this.recordSourceMappingEnd,this,[moduleDecl]),this.outfile!=prevOutFile&&(this.Close(),null!=prevSourceMapper&&(this.allSourceMappers=prevAllSourceMappers,this.sourceMapper=prevSourceMapper,this.emitState.column=prevColumn,this.emitState.line=prevLine),this.outfile=prevOutFile,this.emittingFileName=prevOutFileName);else{isDynamicMod=null;if(prevOutFile=moduleDecl.type)if(prevOutFile=moduleDecl.type.symbol.container)prevOutFile=moduleDecl.type.symbol.container.declAST;prevOutFile&&(isDynamicMod=
moduleDecl.type.symbol.container.declAST);(prevOutFile=isDynamicMod)&&(prevOutFile=JAM.call(TypeScript.hasFlag,TypeScript,[isDynamicMod.modFlags,TypeScript.ModuleFlags.IsDynamic]));isDynamicMod=prevOutFile;JAM.call(this.recordSourceMappingStart,this,[moduleDecl.endingToken]);(prevOutFile=modName==EmitContainer.Prog)&&(prevOutFile=isExported);prevOutFile?(JAM.call(this.writeToOutput,this,["}"]),isWholeFile||this.recordSourceMappingNameEnd(),JAM.call(this.recordSourceMappingEnd,this,[moduleDecl.endingToken]),
JAM.call(this.writeLineToOutput,this,[")(this."+this.moduleName+" || (this."+this.moduleName+" = {}));"])):((prevOutFile=isExported)||(prevOutFile=modName==EmitContainer.Prog),prevOutFile?(""!=v9992?(prevOutFile=isDynamicMod?"exports":v9992,prevOutFile+="."):prevOutFile=v9992,JAM.call(this.writeToOutput,this,["}"]),isWholeFile||this.recordSourceMappingNameEnd(),JAM.call(this.recordSourceMappingEnd,this,[moduleDecl.endingToken]),JAM.call(this.writeLineToOutput,this,[")("+prevOutFile+this.moduleName+
" || ("+prevOutFile+this.moduleName+" = {}));"])):((prevOutFile=!isExported)&&(prevOutFile=modName!=EmitContainer.Prog),prevOutFile?(JAM.call(this.writeToOutput,this,["}"]),isWholeFile||this.recordSourceMappingNameEnd(),JAM.call(this.recordSourceMappingEnd,this,[moduleDecl.endingToken]),JAM.call(this.writeLineToOutput,this,[")("+this.moduleName+" || ("+this.moduleName+" = {}));"])):(JAM.call(this.writeToOutput,this,["}"]),isWholeFile||this.recordSourceMappingNameEnd(),JAM.call(this.recordSourceMappingEnd,
this,[moduleDecl.endingToken]),JAM.call(this.writeLineToOutput,this,[")();"]))));JAM.call(this.recordSourceMappingEnd,this,[moduleDecl]);(isWholeFile=modName!=EmitContainer.Prog)&&(isWholeFile=isExported);isWholeFile&&(this.emitIndent(),JAM.call(this.recordSourceMappingStart,this,[moduleDecl]),isDynamicMod?JAM.call(this.writeLineToOutput,this,["var "+this.moduleName+" = exports."+this.moduleName+";"]):JAM.call(this.writeLineToOutput,this,["var "+this.moduleName+" = "+v9992+"."+this.moduleName+";"]),
JAM.call(this.recordSourceMappingEnd,this,[moduleDecl]))}JAM.call(this.setContainer,this,[modName]);this.moduleName=v9992;this.moduleDeclList.length-=1}}function v460(funcDecl,printName,isMember,bases,hasSelfRef,classDecl){var v10078=funcDecl.isConstructor;v10078&&(v10078=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.ClassMethod]));v10078&&(v10078=JAM.call(TypeScript.hasFlag,TypeScript,[this.thisClassNode.type.instanceType.typeFlags,TypeScript.TypeFlags.HasBaseType]))&&
(v10078=!JAM.call(TypeScript.hasFlag,TypeScript,[this.thisClassNode.type.instanceType.typeFlags,TypeScript.TypeFlags.HasBaseTypeOfObject]));v10078&&(v10078=JAM.call(TypeScript.hasFlag,TypeScript,[this.thisClassNode.varFlags,TypeScript.VarFlags.ClassSuperMustBeFirstCallInConstructor]));var v10081=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.IsFunctionExpression]);v10081&&(v10081=!funcDecl.isParenthesized)&&(v10081=!funcDecl.isAccessor())&&((v10081=JAM.call(TypeScript.hasFlag,
TypeScript,[funcDecl.flags,TypeScript.ASTFlags.ExplicitSemicolon]))||(v10081=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.flags,TypeScript.ASTFlags.AutomaticSemicolon])));JAM.call(this.emitParensAndCommentsInPlace,this,[funcDecl,!0]);v10081&&JAM.call(this.writeToOutput,this,["("]);JAM.call(this.recordSourceMappingStart,this,[funcDecl]);var v22180=funcDecl.isAccessor();v22180&&(v22180=funcDecl.accessorSymbol.isObjectLitField);v22180||JAM.call(this.writeToOutput,this,["function "]);printName&&((v22180=
printName=funcDecl.getNameText())&&(v22180=!funcDecl.isAccessor()),v22180&&(funcDecl.name&&JAM.call(this.recordSourceMappingStart,this,[funcDecl.name]),JAM.call(this.writeToOutput,this,[printName]),funcDecl.name&&JAM.call(this.recordSourceMappingEnd,this,[funcDecl.name])));JAM.call(this.writeToOutput,this,["("]);printName=v22180=0;var arg,defaultArgs=[];if(funcDecl.arguments){var tempContainer=JAM.call(this.setContainer,this,[EmitContainer.Args]),v22180=funcDecl.arguments.members.length;funcDecl.variableArgList&&
(v22180-=1);printName=0;for(arg=printName<v22180;arg;)arg=funcDecl.arguments.members[printName],arg.init&&JAM.call(defaultArgs.push,defaultArgs,[arg]),JAM.call(this.emitJavascript,this,[arg,TypeScript.TokenID.OpenParen,!1]),printName<v22180-1&&JAM.call(this.writeToOutput,this,[", "]),printName+=1,arg=printName<v22180;JAM.call(this.setContainer,this,[tempContainer])}JAM.call(this.writeLineToOutput,this,[") {"]);funcDecl.isConstructor?JAM.call(this.recordSourceMappingNameStart,this,["constructor"]):
funcDecl.isGetAccessor()?JAM.call(this.recordSourceMappingNameStart,this,["get_"+funcDecl.getNameText()]):funcDecl.isSetAccessor()?JAM.call(this.recordSourceMappingNameStart,this,["set_"+funcDecl.getNameText()]):JAM.call(this.recordSourceMappingNameStart,this,[funcDecl.getNameText()]);this.indenter.increaseIndent();printName=0;for(v22180=printName<defaultArgs.length;v22180;)arg=defaultArgs[printName],this.emitIndent(),JAM.call(this.recordSourceMappingStart,this,[arg]),JAM.call(this.writeToOutput,
this,["if (typeof "+arg.id.actualText+' === "undefined") { ']),JAM.call(this.recordSourceMappingStart,this,[arg.id]),JAM.call(this.writeToOutput,this,[arg.id.actualText]),JAM.call(this.recordSourceMappingEnd,this,[arg.id]),JAM.call(this.writeToOutput,this,[" = "]),JAM.call(this.emitJavascript,this,[arg.init,TypeScript.TokenID.OpenParen,!1]),JAM.call(this.writeLineToOutput,this,["; }"]),JAM.call(this.recordSourceMappingEnd,this,[arg]),printName+=1,v22180=printName<defaultArgs.length;(printName=funcDecl.isConstructor)&&
(printName=funcDecl.classDecl.varFlags&TypeScript.VarFlags.MustCaptureThis);printName&&JAM.call(this.writeCaptureThisStatement,this,[funcDecl]);(printName=funcDecl.isConstructor)&&(printName=!v10078);if(printName){if(funcDecl.arguments)for(v22180=funcDecl.arguments.members.length,printName=0,defaultArgs=printName<v22180;defaultArgs;)arg=funcDecl.arguments.members[printName],(arg.varFlags&TypeScript.VarFlags.Property)!=TypeScript.VarFlags.None&&(this.emitIndent(),JAM.call(this.recordSourceMappingStart,
this,[arg]),JAM.call(this.recordSourceMappingStart,this,[arg.id]),JAM.call(this.writeToOutput,this,["this."+arg.id.actualText]),JAM.call(this.recordSourceMappingEnd,this,[arg.id]),JAM.call(this.writeToOutput,this,[" = "]),JAM.call(this.recordSourceMappingStart,this,[arg.id]),JAM.call(this.writeToOutput,this,[arg.id.actualText]),JAM.call(this.recordSourceMappingEnd,this,[arg.id]),JAM.call(this.writeLineToOutput,this,[";"]),JAM.call(this.recordSourceMappingEnd,this,[arg])),printName+=1,defaultArgs=
printName<v22180;JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.ClassMethod])||JAM.call(this.emitConstructorCalls,this,[bases,classDecl])}hasSelfRef&&JAM.call(this.writeCaptureThisStatement,this,[funcDecl]);if(funcDecl.variableArgList){v22180=funcDecl.arguments.members.length;bases=funcDecl.arguments.members;hasSelfRef=v22180-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)bases=bases[hasSelfRef];this.emitIndent();JAM.call(this.recordSourceMappingStart,
this,[bases]);JAM.call(this.writeToOutput,this,["var "]);JAM.call(this.recordSourceMappingStart,this,[bases.id]);JAM.call(this.writeToOutput,this,[bases.id.actualText]);JAM.call(this.recordSourceMappingEnd,this,[bases.id]);JAM.call(this.writeLineToOutput,this,[" = [];"]);JAM.call(this.recordSourceMappingEnd,this,[bases]);this.emitIndent();JAM.call(this.writeToOutput,this,["for ("]);JAM.call(this.recordSourceMappingStart,this,[bases]);JAM.call(this.writeToOutput,this,["var _i = 0;"]);JAM.call(this.recordSourceMappingEnd,
this,[bases]);JAM.call(this.writeToOutput,this,[" "]);JAM.call(this.recordSourceMappingStart,this,[bases]);JAM.call(this.writeToOutput,this,["_i < (arguments.length - "+(v22180-1)+")"]);JAM.call(this.recordSourceMappingEnd,this,[bases]);JAM.call(this.writeToOutput,this,["; "]);JAM.call(this.recordSourceMappingStart,this,[bases]);JAM.call(this.writeToOutput,this,["_i++"]);JAM.call(this.recordSourceMappingEnd,this,[bases]);JAM.call(this.writeLineToOutput,this,[") {"]);this.indenter.increaseIndent();
this.emitIndent();JAM.call(this.recordSourceMappingStart,this,[bases]);JAM.call(this.writeToOutput,this,[bases.id.actualText+"[_i] = arguments[_i + "+(v22180-1)+"];"]);JAM.call(this.recordSourceMappingEnd,this,[bases]);JAM.call(this.writeLineToOutput,this,[""]);this.indenter.decreaseIndent();this.emitIndent();JAM.call(this.writeLineToOutput,this,["}"])}(bases=funcDecl.isConstructor)&&(bases=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.ClassMethod]))&&(bases=!v10078);
if(bases)for(bases=this.thisClassNode.members.members.length,printName=0,hasSelfRef=printName<bases;hasSelfRef;){hasSelfRef=this.thisClassNode.members.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)hasSelfRef=hasSelfRef[printName];if(hasSelfRef.nodeType==TypeScript.NodeType.VarDecl){hasSelfRef=this.thisClassNode.members.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)hasSelfRef=hasSelfRef[printName];if(classDecl=!JAM.call(TypeScript.hasFlag,TypeScript,
[hasSelfRef.varFlags,TypeScript.VarFlags.Static]))classDecl=hasSelfRef.init;classDecl&&(this.emitIndent(),JAM.call(this.emitJavascriptVarDecl,this,[hasSelfRef,TypeScript.TokenID.Tilde]),JAM.call(this.writeLineToOutput,this,[""]))}printName+=1;hasSelfRef=printName<bases}JAM.call(this.emitBareJavascriptStatements,this,[funcDecl.bod,v10078]);this.indenter.decreaseIndent();this.emitIndent();JAM.call(this.recordSourceMappingStart,this,[funcDecl.endingToken]);JAM.call(this.writeToOutput,this,["}"]);this.recordSourceMappingNameEnd();
JAM.call(this.recordSourceMappingEnd,this,[funcDecl.endingToken]);JAM.call(this.recordSourceMappingEnd,this,[funcDecl]);v10081&&JAM.call(this.writeToOutput,this,[")"]);JAM.call(this.recordSourceMappingEnd,this,[funcDecl]);JAM.call(this.emitParensAndCommentsInPlace,this,[funcDecl,!1]);if(isMember=!isMember)if(isMember=!JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.IsFunctionExpression]))isMember=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.Definition]),
isMember||(isMember=funcDecl.isConstructor);isMember?JAM.call(this.writeLineToOutput,this,[""]):JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.fncFlags,TypeScript.FncFlags.IsFunctionExpression])&&((isMember=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.flags,TypeScript.ASTFlags.ExplicitSemicolon]))||(isMember=JAM.call(TypeScript.hasFlag,TypeScript,[funcDecl.flags,TypeScript.ASTFlags.AutomaticSemicolon])),isMember&&JAM.call(this.writeLineToOutput,this,[";"]))}function v459(bases,classDecl){if(null!=
bases){var basesLen=bases.members.length;JAM.call(this.recordSourceMappingStart,this,[classDecl]);for(var i=0,v10162=i<basesLen;v10162;){v10162=bases.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10162=v10162[i];var baseSymbol=null,baseSymbol=v10162.nodeType==TypeScript.NodeType.Call?v10162.target.type.symbol:v10162.type.symbol;baseSymbol.declModule!=classDecl.type.symbol.declModule&&baseSymbol.fullName();v10162.nodeType==TypeScript.NodeType.Call?(this.emitIndent(),JAM.call(this.writeToOutput,
this,["_super.call(this"]),(baseSymbol=v10162=v10162.arguments)&&(baseSymbol=0<v10162.members.length),baseSymbol&&(JAM.call(this.writeToOutput,this,[", "]),JAM.call(this.emitJavascriptList,this,[v10162,", ",TypeScript.TokenID.Comma,!1,!1,!1])),JAM.call(this.writeToOutput,this,[")"])):((baseSymbol=v10162.type)&&(baseSymbol=v10162.type.isClassInstance()),baseSymbol&&(this.emitIndent(),JAM.call(this.writeToOutput,this,[classDecl.name.actualText+"._super.constructor"]),JAM.call(this.writeToOutput,this,
[".call(this)"])));i+=1;v10162=i<basesLen}JAM.call(this.recordSourceMappingEnd,this,[classDecl])}}function v458(callNode,target,args){if(!JAM.call(this.emitSuperCall,this,[callNode]))if(JAM.call(TypeScript.hasFlag,TypeScript,[callNode.flags,TypeScript.ASTFlags.ClassBaseConstructorCall]))this.indenter.decreaseIndent(),this.indenter.decreaseIndent(),args=new TypeScript.ASTList,args.members[0]=callNode,JAM.call(this.emitConstructorCalls,this,[args,this.thisClassNode]),this.indenter.increaseIndent(),
this.indenter.increaseIndent();else{var v17688=target.nodeType==TypeScript.NodeType.FuncDecl;v17688&&(v17688=!target.isParenthesized);v17688&&JAM.call(this.writeToOutput,this,["("]);(v17688=callNode.target.nodeType==TypeScript.NodeType.Super)&&(v17688=this.emitState.container==EmitContainer.Constructor);v17688?JAM.call(this.writeToOutput,this,["_super.call"]):JAM.call(this.emitJavascript,this,[target,TypeScript.TokenID.OpenParen,!1]);(v17688=target.nodeType==TypeScript.NodeType.FuncDecl)&&(v17688=
!target.isParenthesized);v17688&&JAM.call(this.writeToOutput,this,[")"]);JAM.call(this.recordSourceMappingStart,this,[args]);JAM.call(this.writeToOutput,this,["("]);(callNode=callNode.target.nodeType==TypeScript.NodeType.Super)&&(callNode=this.emitState.container==EmitContainer.Constructor);if(callNode){JAM.call(this.writeToOutput,this,["this"]);if(callNode=args)callNode=args.members.length;callNode&&JAM.call(this.writeToOutput,this,[", "])}JAM.call(this.emitJavascriptList,this,[args,", ",TypeScript.TokenID.Comma,
!1,!1,!1]);JAM.call(this.writeToOutput,this,[")"]);JAM.call(this.recordSourceMappingEnd,this,[args])}}function v457(dotExpr){if(!this.emitOptions.propagateConstants)return!1;var v17696=dotExpr=dotExpr.operand2;v17696&&(v17696=dotExpr.sym)&&(v17696=dotExpr.sym.isVariable());if(v17696&&JAM.call(TypeScript.hasFlag,TypeScript,[dotExpr.sym.flags,TypeScript.SymbolFlags.Constant])&&dotExpr.sym.declAST){var v17696=dotExpr.sym.declAST,v17700=v17696.init;v17700&&(v17700=v17696.init.nodeType==TypeScript.NodeType.NumberLit);
if(v17700)return v17696=v17696.init,JAM.call(this.writeToOutput,this,[v17696.value.toString()]),v17696=" /* ",v17696+=dotExpr.actualText,v17696+=" */ ",JAM.call(this.writeToOutput,this,[v17696]),!0}return!1}function v456(target,args){JAM.call(this.writeToOutput,this,["new "]);if(target.nodeType==TypeScript.NodeType.TypeRef){var typeRef=target;typeRef.arrayCount?JAM.call(this.writeToOutput,this,["Array()"]):(JAM.call(this.emitJavascript,this,[typeRef.term,TypeScript.TokenID.Tilde,!1]),JAM.call(this.writeToOutput,
this,["()"]))}else JAM.call(this.emitJavascript,this,[target,TypeScript.TokenID.Tilde,!1]),JAM.call(this.recordSourceMappingStart,this,[args]),JAM.call(this.writeToOutput,this,["("]),JAM.call(this.emitJavascriptList,this,[args,", ",TypeScript.TokenID.Comma,!1,!1,!1]),JAM.call(this.writeToOutput,this,[")"]),JAM.call(this.recordSourceMappingEnd,this,[args])}function v455(content){JAM.call(this.writeToOutput,this,["["]);content&&(JAM.call(this.writeLineToOutput,this,[""]),this.indenter.increaseIndent(),
JAM.call(this.emitJavascriptList,this,[content,", ",TypeScript.TokenID.Comma,!0,!1,!1]),this.indenter.decreaseIndent(),this.emitIndent());JAM.call(this.writeToOutput,this,["]"])}function v454(content){JAM.call(this.writeLineToOutput,this,["{"]);this.indenter.increaseIndent();var inObjectLiteral=JAM.call(this.setInObjectLiteral,this,[!0]);JAM.call(this.emitJavascriptList,this,[content,",",TypeScript.TokenID.Comma,!0,!1,!1]);JAM.call(this.setInObjectLiteral,this,[inObjectLiteral]);this.indenter.decreaseIndent();
this.emitIndent();JAM.call(this.writeToOutput,this,["}"])}function v453(ast,pre){var v10198;v10198=pre?ast.preComments:ast.postComments;var v17710=ast.isParenthesized;v17710&&(v17710=!pre);v17710&&JAM.call(this.writeToOutput,this,[")"]);(v17710=this.emitOptions.emitComments)&&(v17710=v10198)&&(v17710=0!=v10198.length);if(v17710)for(var v17710=0,v10201=v17710<v10198.length;v10201;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10201=v10198[v17710];JAM.call(this.emitCommentInPlace,
this,[v10201]);v17710+=1;v10201=v17710<v10198.length}(v10198=ast.isParenthesized)&&(v10198=pre);v10198&&JAM.call(this.writeToOutput,this,["("])}function v452(comment){JAM.call(this.recordSourceMappingStart,this,[comment]);var text=comment.getText(),hadNewLine=!1;if(comment.isBlockComment){0==this.emitState.column&&this.emitIndent();JAM.call(this.writeToOutput,this,[text[0]]);var v17716=1<text.length;v17716||(v17716=comment.endsLine);if(v17716){JAM.call(this.writeLineToOutput,this,[""]);hadNewLine=
1;for(v17716=hadNewLine<text.length;v17716;){this.emitIndent();introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v17716=text[hadNewLine];JAM.call(this.writeLineToOutput,this,[v17716]);hadNewLine+=1;v17716=hadNewLine<text.length}hadNewLine=!0}}else 0==this.emitState.column&&this.emitIndent(),JAM.call(this.writeLineToOutput,this,[text[0]]),hadNewLine=!0;hadNewLine?this.emitIndent():JAM.call(this.writeToOutput,this,[" "]);JAM.call(this.recordSourceMappingEnd,this,[comment])}function v451(){JAM.call(this.writeToOutput,
this,[this.getIndentString()])}function v450(){return this.emitOptions.minWhitespace?"":this.indenter.getIndent()}function v449(c){var temp=this.emitState.container;this.emitState.container=c;return temp}function v448(val){var temp=this.emitState.inObjectLiteral;this.emitState.inObjectLiteral=val;return temp}function v447(count){this.varListCountStack[this.varListCountStack.length-1]=count}function v446(ast){this.emitIndent();JAM.call(this.recordSourceMappingStart,this,[ast]);JAM.call(this.writeToOutput,
this,[this.captureThisStmtString]);JAM.call(this.recordSourceMappingEnd,this,[ast]);JAM.call(this.writeLineToOutput,this,[""])}function v445(s){if(this.emitOptions.minWhitespace){JAM.call(this.writeToOutput,this,[s]);s=JAM.call(s.charCodeAt,s,[s.length-1]);var v22244=s==TypeScript.LexCodeSpace;v22244||(v22244=s==TypeScript.LexCodeSMC)||(v22244=s==TypeScript.LexCodeLBR);v22244||JAM.call(this.writeToOutput,this,[" "])}else v22244=this.outfile,JAM.call(v22244.WriteLine,v22244,[s]),this.emitState.column=
0,this.emitState.line+=1}function v444(s){this.emitOptions.minWhitespace&&(s=s.replace(/[\s]*/g,""));JAM.call(this.writeToOutput,this,[s])}function v443(s){var v10228=this.outfile;JAM.call(v10228.Write,v10228,[s]);v10228=this.emitState;v10228.column+=s.length}function v442(mapper){var v10230=this.allSourceMappers;JAM.call(v10230.push,v10230,[mapper]);this.sourceMapper=mapper}function Emitter(checker,emittingFileName,outfile,emitOptions,errorReporter){this.checker=checker;this.emittingFileName=emittingFileName;
this.outfile=outfile;this.emitOptions=emitOptions;this.errorReporter=errorReporter;this.prologueEmitted=!1;this.thisFnc=this.thisClassNode=null;this.moduleDeclList=[];this.moduleName="";this.emitState=checker=new EmitState;this.indenter=checker=new Indenter;this.ambientModule=!1;this.firstModAlias=this.modAliasId=null;this.allSourceMappers=[];this.sourceMapper=null;this.captureThisStmtString="var _this = this;";this.varListCountStack=[0]}Emitter.prototype.setSourceMappings=v442;Emitter.prototype.writeToOutput=
v443;Emitter.prototype.writeToOutputTrimmable=v444;Emitter.prototype.writeLineToOutput=v445;Emitter.prototype.writeCaptureThisStatement=v446;Emitter.prototype.setInVarBlock=v447;Emitter.prototype.setInObjectLiteral=v448;Emitter.prototype.setContainer=v449;Emitter.prototype.getIndentString=v450;Emitter.prototype.emitIndent=v451;Emitter.prototype.emitCommentInPlace=v452;Emitter.prototype.emitParensAndCommentsInPlace=v453;Emitter.prototype.emitObjectLiteral=v454;Emitter.prototype.emitArrayLiteral=v455;
Emitter.prototype.emitNew=v456;Emitter.prototype.tryEmitConstant=v457;Emitter.prototype.emitCall=v458;Emitter.prototype.emitConstructorCalls=v459;Emitter.prototype.emitInnerFunction=v460;Emitter.prototype.emitJavascriptModule=v461;Emitter.prototype.emitIndex=v462;Emitter.prototype.emitStringLiteral=v463;Emitter.prototype.emitJavascriptFunction=v464;Emitter.prototype.emitAmbientVarDecl=v465;Emitter.prototype.varListCount=v466;Emitter.prototype.emitVarDeclVar=v467;Emitter.prototype.onEmitVar=v468;Emitter.prototype.emitJavascriptVarDecl=
v469;Emitter.prototype.declEnclosed=v470;Emitter.prototype.emitJavascriptName=v471;Emitter.prototype.emitJavascriptStatements=v472;Emitter.prototype.emitBareJavascriptStatements=v473;Emitter.prototype.recordSourceMappingNameStart=v474;Emitter.prototype.recordSourceMappingNameEnd=v475;Emitter.prototype.recordSourceMappingStart=v476;Emitter.prototype.recordSourceMappingEnd=v477;Emitter.prototype.Close=v478;Emitter.prototype.emitJavascriptList=v479;Emitter.prototype.emitJavascript=v480;Emitter.prototype.emitPropertyAccessor=
v481;Emitter.prototype.emitPrototypeMember=v482;Emitter.prototype.emitAddBaseMethods=v484;Emitter.prototype.emitJavascriptClass=v485;Emitter.prototype.emitPrologue=v486;Emitter.prototype.emitSuperReference=v487;Emitter.prototype.emitSuperCall=v488;Emitter.prototype.emitThis=v489;Emitter.shouldCaptureThis=shouldCaptureThis;Emitter.prototype.createFile=v490;return Emitter}function v441(){function v440(){var v10279=Indenter.indentStrings,v10280=this.indentAmt;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10279=
v10279[v10280];if(void 0===v10279){for(var v10279="",v10280=0,v10281=v10280<this.indentAmt;v10281;)v10279+=Indenter.indentStepString,v10280+=Indenter.indentStep,v10281=v10280<this.indentAmt;JAM.set(Indenter.indentStrings,this.indentAmt,v10279)}return v10279}function v439(){this.indentAmt-=Indenter.indentStep}function v438(){this.indentAmt+=Indenter.indentStep}function Indenter(){this.indentAmt=0}Indenter.indentStep=4;Indenter.indentStepString="    ";Indenter.indentStrings=[];Indenter.prototype.increaseIndent=
v438;Indenter.prototype.decreaseIndent=v439;Indenter.prototype.getIndent=v440;return Indenter}function v437(){function v436(fileName,extensionChanger){if(this.outputMany){var updatedFileName=fileName;""!=this.outputOption&&(updatedFileName=fileName.replace(this.commonDirectoryPath,""),updatedFileName=this.outputOption+updatedFileName);return JAM.call(extensionChanger,null,[updatedFileName,!1])}return JAM.call(extensionChanger,null,[this.outputOption,!0])}function EmitOptions(settings){this.ioHost=
null;this.outputMany=!0;this.commonDirectoryPath="";this.minWhitespace=settings.minWhitespace;this.propagateConstants=settings.propagateConstants;this.emitComments=settings.emitComments;this.outputOption=settings.outputOption}EmitOptions.prototype.mapOutputFileName=v436;return EmitOptions}function v435(){function EmitState(){this.line=this.column=0;this.inObjectLiteral=this.pretty=!1;this.container=EmitContainer.Prog}return EmitState}function v434(EmitContainer){EmitContainer._map=[];EmitContainer._map[0]=
"Prog";EmitContainer.Prog=0;EmitContainer._map[1]="Module";EmitContainer.Module=1;EmitContainer._map[2]="DynamicModule";EmitContainer.DynamicModule=2;EmitContainer._map[3]="Class";EmitContainer.Class=3;EmitContainer._map[4]="Constructor";EmitContainer.Constructor=4;EmitContainer._map[5]="Function";EmitContainer.Function=5;EmitContainer._map[6]="Args";EmitContainer.Args=6;EmitContainer._map[7]="Interface";EmitContainer.Interface=7}var v17736=TypeScript.EmitContainer;v17736||(v17736=TypeScript.EmitContainer=
{});v434(v17736);var EmitContainer=TypeScript.EmitContainer,EmitState=v435();TypeScript.EmitState=EmitState;v17736=v437();TypeScript.EmitOptions=v17736;var Indenter=v441();TypeScript.Indenter=Indenter;v17736=v491();TypeScript.Emitter=v17736}
function v433(){var TypeScript=v18802;function v432(){function EmitSourceMapping(allSourceMappers){function v431(sourceMappings){for(var i=0,v10308=i<sourceMappings.length;v10308;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10308=sourceMappings[i];JAM.call(recordSourceMapping,null,[v10308.start,v10308.nameIndex]);JAM.call(recordSourceMappingSiblings,null,[v10308.childMappings]);JAM.call(recordSourceMapping,null,[v10308.end,v10308.nameIndex]);i+=1;v10308=i<sourceMappings.length}}
function v430(mappedPosition,nameIndex){var v17739=null!=recordedPosition;v17739&&(v17739=recordedPosition.emittedColumn==mappedPosition.emittedColumn)&&(v17739=recordedPosition.emittedLine==mappedPosition.emittedLine);if(!v17739){if(prevEmittedLine!==mappedPosition.emittedLine){for(v17739=prevEmittedLine<mappedPosition.emittedLine;v17739;)prevEmittedColumn=0,mappingsString+=";",prevEmittedLine+=1,v17739=prevEmittedLine<mappedPosition.emittedLine;emitComma=!1}else emitComma&&(mappingsString+=",");
var v17739=mappingsString,v17743=TypeScript.Base64VLQFormat;mappingsString=v17739+JAM.call(v17743.encode,v17743,[mappedPosition.emittedColumn-prevEmittedColumn]);prevEmittedColumn=mappedPosition.emittedColumn;v17739=mappingsString;v17743=TypeScript.Base64VLQFormat;mappingsString=v17739+JAM.call(v17743.encode,v17743,[currentSourceIndex-prevSourceIndex]);prevSourceIndex=currentSourceIndex;v17739=mappingsString;v17743=TypeScript.Base64VLQFormat;mappingsString=v17739+JAM.call(v17743.encode,v17743,[mappedPosition.sourceLine-
1-prevSourceLine]);prevSourceLine=mappedPosition.sourceLine-1;v17739=mappingsString;v17743=TypeScript.Base64VLQFormat;mappingsString=v17739+JAM.call(v17743.encode,v17743,[mappedPosition.sourceColumn-prevSourceColumn]);prevSourceColumn=mappedPosition.sourceColumn;0<=nameIndex&&(v17739=mappingsString,v17743=TypeScript.Base64VLQFormat,mappingsString=v17739+JAM.call(v17743.encode,v17743,[namesCount+nameIndex-prevNameIndex]),prevNameIndex=namesCount+nameIndex);emitComma=!0;recordedPosition=mappedPosition}}
var sourceMapper=allSourceMappers[0],v10324=sourceMapper.jsFile;JAM.call(v10324.WriteLine,v10324,["//@ sourceMappingURL="+sourceMapper.jsFileName+SourceMapper.MapFileExtension]);for(var v10324=sourceMapper.sourceMapOut,mappingsString="",tsFiles=[],prevEmittedColumn=0,prevEmittedLine=0,prevSourceColumn=0,prevSourceLine=0,prevSourceIndex=0,prevNameIndex=0,namesList=[],namesCount=0,emitComma=!1,recordedPosition=null,sourceMapperIndex=0,v10332=sourceMapperIndex<allSourceMappers.length;v10332;){var sourceMapper=
allSourceMappers[sourceMapperIndex],currentSourceIndex=tsFiles.length;JAM.call(tsFiles.push,tsFiles,[sourceMapper.tsFileName]);0<sourceMapper.names.length&&(v10332=namesList.push,JAM.call(v10332.apply,v10332,[namesList,sourceMapper.names]));var recordSourceMapping=v430,recordSourceMappingSiblings=v431;JAM.call(recordSourceMappingSiblings,null,[sourceMapper.sourceMappings,-1]);namesCount+=sourceMapper.names.length;sourceMapperIndex+=1;v10332=sourceMapperIndex<allSourceMappers.length}""!=mappingsString&&
JAM.call(v10324.Write,v10324,[JAM.call(JSON2.stringify,JSON2,[{version:3,file:sourceMapper.jsFileName,sources:tsFiles,names:namesList,mappings:mappingsString}])]);try{v10324.Close()}catch(ex){allSourceMappers=sourceMapper.errorReporter,JAM.call(allSourceMappers.emitterError,allSourceMappers,[null,ex.message])}}function SourceMapper(tsFileName,jsFileName,jsFile,sourceMapOut,errorReporter){this.jsFile=jsFile;this.sourceMapOut=sourceMapOut;this.errorReporter=errorReporter;this.sourceMappings=[];this.currentMappings=
[];this.names=[];this.currentNameIndex=[];jsFile=this.currentMappings;JAM.call(jsFile.push,jsFile,[this.sourceMappings]);jsFileName=JAM.call(TypeScript.switchToForwardSlashes,TypeScript,[jsFileName]);this.jsFileName=jsFile=JAM.call(TypeScript.getPrettyName,TypeScript,[jsFileName,!1,!0]);jsFile=jsFileName.lastIndexOf(this.jsFileName);jsFileName=JAM.call(jsFileName.substring,jsFileName,[0,jsFile]);this.tsFileName=tsFileName=JAM.call(TypeScript.getRelativePathToFixedPath,TypeScript,[jsFileName,tsFileName])}
SourceMapper.MapFileExtension=".map";SourceMapper.EmitSourceMapping=EmitSourceMapping;return SourceMapper}function v429(){function SourceMapping(){var v27327=new SourceMapPosition;this.start=v27327;this.end=v27327=new SourceMapPosition;this.nameIndex=-1;this.childMappings=[]}return SourceMapping}function v428(){function SourceMapPosition(){}return SourceMapPosition}var SourceMapPosition=v428();TypeScript.SourceMapPosition=SourceMapPosition;var SourceMapping=v429();TypeScript.SourceMapping=SourceMapping;
SourceMapping=v432();TypeScript.SourceMapper=SourceMapping}
function v427(){function v426(text,reviver){function v425(a){a=JAM.call(a.charCodeAt,a,[0]);return"\\u"+("0000"+JAM.call(a.toString,a,[16])).slice(-4)}function walk(holder,key){var k=null,v;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var value=holder[key];(v=value)&&(v="object"===typeof value);if(v)for(k in value)v=Object.prototype.hasOwnProperty,JAM.call(v.call,v,[value,k])&&(v=walk(value,k),void 0!==v?JAM.set(value,k,v):delete value[k]);return JAM.call(reviver.call,reviver,[holder,
key,value])}var j;text=String(text);cx.lastIndex=0;cx.test(text)&&(text=text.replace(cx,v425));if(/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,"@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:\s*\[)+/g,"")))return j="("+text+")",j=JAM.isEval(eval)?eval("introspect(JAM.policy.pFull) { "+j+" }"):JAM.call(eval,null,[j]),j="function"===typeof reviver?walk({"":j},""):j;throw new SyntaxError("JSON.parse");}function v424(value,
replacer,space){var i;indent=gap="";if("number"===typeof space){i=0;for(var v10348=i<space;v10348;)indent+=" ",i+=1,v10348=i<space}else"string"===typeof space&&(indent=space);if(space=rep=replacer)if(space="function"!==typeof replacer)(space="object"!==typeof replacer)||(space="number"!==typeof replacer.length);if(space)throw Error("JSON.stringify");return str("",{"":value})}function v423(key){return this.valueOf()}function v422(key){return key=isFinite(this.valueOf())?this.getUTCFullYear()+"-"+f(this.getUTCMonth()+
1)+"-"+f(this.getUTCDate())+"T"+f(this.getUTCHours())+":"+f(this.getUTCMinutes())+":"+f(this.getUTCSeconds())+"Z":null}function f(n){return n=10>n?"0"+n:n}function quote(string){function v421(a){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var c=meta[a];"string"===typeof c?a=c:(a=JAM.call(a.charCodeAt,a,[0]),a="\\u"+("0000"+JAM.call(a.toString,a,[16])).slice(-4));return a}escapable.lastIndex=0;return string=escapable.test(string)?'"'+string.replace(escapable,v421)+'"':'"'+string+
'"'}function str(key,holder){var i,k=null,v,length,mind=gap,partial;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var value=holder[key];(partial=value)&&(partial="object"===typeof value)&&(partial="function"===typeof value.toJSON);partial&&(value=JAM.call(value.toJSON,value,[key]));"function"===typeof rep&&(value=JAM.call(rep.call,rep,[holder,key,value]));switch(typeof value){case "string":return quote(value);case "number":return mind=isFinite(value)?String(value):"null";case "boolean":case "null":return String(value);
case "object":if(!value)return"null";gap+=indent;partial=[];i=Object.prototype.toString;if("[object Array]"===JAM.call(i.apply,i,[value,[]])){length=value.length;i=0;for(k=i<length;k;){k=partial;v=i;var v17782=str(i,value);v17782||(v17782="null");k[v]=v17782;i+=1;k=i<length}v=value=0===partial.length?"[]":gap?"[\n"+gap+partial.join(",\n"+gap)+"\n"+mind+"]":"["+partial.join(",")+"]";gap=mind;return v}(i=rep)&&(i="object"===typeof rep);if(i)for(length=rep.length,i=0,k=i<length;k;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)k=
rep[i];if("string"===typeof k){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)k=rep[i];if(v=str(k,value))k=quote(k),v17782=gap?": ":":",JAM.call(partial.push,partial,[k+v17782+v])}i+=1;k=i<length}else for(k in value)if(i=Object.prototype.hasOwnProperty,JAM.call(i.call,i,[value,k])&&(v=str(k,value)))i=quote(k),length=gap?": ":":",JAM.call(partial.push,partial,[i+length+v]);v=value=0===partial.length?"{}":gap?"{\n"+gap+partial.join(",\n"+gap)+"\n"+mind+"}":"{"+partial.join(",")+"}";
gap=mind;return v}}if("function"!==typeof Date.prototype.toJSON){Date.prototype.toJSON=v422;var strProto=String.prototype,numProto=Number.prototype;numProto.JSON=strProto.JSON=Boolean.prototype.toJSON=v423}var cx=/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,escapable=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,gap,indent,meta={"\b":"\\b","\t":"\\t","\n":"\\n",
"\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"},rep;"function"!==typeof JSON2.stringify&&(JSON2.stringify=v424);"function"!==typeof JSON2.parse&&(JSON2.parse=v426)}
function v420(){var TypeScript=v18801;function v419(){function decode(inString){for(var result=0,negative=!1,shift=0,i=0,v10387=i<inString.length;v10387;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10387=inString[i];v10387=JAM.call(Base64Format.decodeChar,Base64Format,[v10387]);0===i?(1===(v10387&1)&&(negative=!0),result=v10387>>1&15):result|=(v10387&31)<<shift;var v22288;v22288=0==i?4:5;shift+=v22288;if(32!==(v10387&32))return result=negative?-result:result,{value:result,rest:inString.substr(i+
1)};i+=1;v10387=i<inString.length}throw Error('Base64 value "'+inString+'" finished with a continuation bit');}function encode(inValue){inValue=0>inValue?(-inValue<<1)+1:inValue<<1;var encodedStr="",v10394=0<inValue;do v10394=inValue&31,inValue>>=5,0<inValue&&(v10394|=32),encodedStr+=JAM.call(Base64Format.encode,Base64Format,[v10394]),v10394=0<inValue;while(v10394);return encodedStr}function Base64VLQFormat(){}Base64VLQFormat.encode=encode;Base64VLQFormat.decode=decode;return Base64VLQFormat}function v418(){function decodeChar(inChar){if(1===
inChar.length)return Base64Format.encodedValues.indexOf(inChar);throw TypeError('"'+inChar+'" must have length 1');}function encode(inValue){if(64>inValue)return Base64Format.encodedValues.charAt(inValue);throw TypeError(inValue+": not a 64 based value");}function Base64Format(){}Base64Format.encodedValues="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";Base64Format.encode=encode;Base64Format.decodeChar=decodeChar;return Base64Format}var Base64Format=v418(),Base64VLQFormat=v419();
TypeScript.Base64VLQFormat=Base64VLQFormat}
function v417(){var TypeScript=v18800;function v416(){function v415(scope,table){function v414(key,sym,binder){JAM.call(binder.bindSymbol,binder,[scope,sym])}JAM.call(table.map,table,[v414,this])}function v413(scope,symbol){function v412(id){return JAM.call(scope.find,scope,[id,!1,!0])}if(!symbol.bound){var prevLocationInfo=this.checker.locationInfo,v17808=this.checker.units;v17808&&(v17808=0<=symbol.unitIndex)&&(v17808=symbol.unitIndex<this.checker.units.length);if(v17808){var v17808=this.checker,
v17809=this.checker.units,v17810=symbol.unitIndex;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v17808.locationInfo=v17809[v17810]}switch(symbol.kind()){case TypeScript.SymbolKind.Type:if(symbol.flags&TypeScript.SymbolFlags.Bound)break;v17808=symbol;v17808.flags|=TypeScript.SymbolFlags.Bound;(v17809=v17808.aliasLink)&&(v17809=!v17808.type)&&(v17809=v17808.aliasLink.alias.nodeType==TypeScript.NodeType.Name);v17809&&(v17809=v17808.aliasLink.alias.text,v17810=this.checker,v17810=JAM.call(v17810.findSymbolForDynamicModule,
v17810,[v17809,this.checker.locationInfo.filename,v412]))&&(v17809=v17808,v17810=v17810.getType(),v17809.type=v17810);(v17809=v17808.type)&&(v17809=v17808.type!=this.checker.gloModType);if(v17809&&(JAM.call(this.bindType,this,[scope,v17808.type,v17808.instanceType]),v17808.type.isModuleType()))for(v17809=0,v17810=v17809<v17808.expansions.length;v17810;){v17810=v17808.expansions;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v17810=v17810[v17809];JAM.call(this.bindType,this,[scope,
v17810,v17808.instanceType]);v17809+=1;v17810=v17809<v17808.expansions.length}break;case TypeScript.SymbolKind.Field:v17808=this.checker;JAM.call(v17808.resolveTypeLink,v17808,[scope,symbol.field.typeLink,!1]);break;case TypeScript.SymbolKind.Parameter:v17808=this.checker,JAM.call(v17808.resolveTypeLink,v17808,[scope,symbol.parameter.typeLink,!0])}this.checker.locationInfo=prevLocationInfo}symbol.bound=!0}function v411(scope,type,instanceType){instanceType&&JAM.call(this.bindType,this,[scope,instanceType,
null]);if(type.hasMembers()){var members=type.members,ambientMembers=type.ambientMembers,typeMembers=type.getAllEnclosedTypes(),ambientTypeMembers=type.getAllAmbientEnclosedTypes(),memberScope=JAM.new(TypeScript.SymbolTableScope,[members,ambientMembers,typeMembers,ambientTypeMembers,type.symbol]),agg=JAM.new(TypeScript.SymbolAggregateScope,[type.symbol]),prevCurrentModDecl=this.checker.currentModDecl,prevBindStatus=this.checker.inBind;JAM.call(agg.addParentScope,agg,[memberScope]);JAM.call(agg.addParentScope,
agg,[scope]);type.isModuleType()&&(this.checker.currentModDecl=type.symbol.declAST,this.checker.inBind=!0);members&&JAM.call(this.bind,this,[agg,type.members.allMembers]);typeMembers&&JAM.call(this.bind,this,[agg,typeMembers.allMembers]);ambientMembers&&JAM.call(this.bind,this,[agg,ambientMembers.allMembers]);ambientTypeMembers&&JAM.call(this.bind,this,[agg,ambientTypeMembers.allMembers]);this.checker.currentModDecl=prevCurrentModDecl;this.checker.inBind=prevBindStatus}type.extendsTypeLinks&&JAM.call(this.resolveBases,
this,[scope,type]);type.construct&&JAM.call(this.resolveSignatureGroup,this,[type.construct,scope,instanceType]);type.call&&JAM.call(this.resolveSignatureGroup,this,[type.call,scope,null]);type.index&&JAM.call(this.resolveSignatureGroup,this,[type.index,scope,null]);type.elementType&&JAM.call(this.bindType,this,[scope,type.elementType,null])}function v410(signatureGroup,scope,instanceType){for(var supplyVar=!signatureGroup.hasImplementation,i=0,len=signatureGroup.signatures.length,v10464=i<len;v10464;){v10464=
signatureGroup.signatures;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var signature=v10464[i];instanceType?signature.returnType.type=instanceType:(v10464=this.checker,JAM.call(v10464.resolveTypeLink,v10464,[scope,signature.returnType,supplyVar]));for(var v10464=signature.parameters.length,j=0,v10457=j<v10464;v10457;){v10457=signature.parameters;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10457=v10457[j];JAM.call(this.bindSymbol,this,[scope,v10457]);j+=1;v10457=
j<v10464}if(signature.hasVariableArgList){signature=signature.parameters;j=v10464-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)signature=signature[j];signature.argsOffset=v10464-1;signature.getType().isArray()||(v10464=this.checker.errorReporter,JAM.call(v10464.simpleErrorFromSym,v10464,[signature,"... parameter must have array type"]),v10464=signature.parameter.typeLink,j=this.checker,signature=JAM.call(j.makeArrayType,j,[signature.parameter.typeLink.type]),v10464.type=signature)}i+=
1;v10464=i<len}}function v409(scope,type){var v10465=type,v27331=JAM.call(this.resolveBaseTypeLinks,this,[type.extendsTypeLinks,scope]);v10465.extendsList=v27331;for(var v27331=0,len=type.extendsList.length,v10465=type.isClassInstance(),v10475=v27331<len;v10475;){v10475=type.extendsList;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10475=v10475[v27331];var baseIsClass=v10475.isClassInstance(),v10475=type.extendsList;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10475=
v10475[v27331];if(v10475!=this.checker.anyType){v10475=type.extendsTypeLinks;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10475=v10475[v27331];v10475=v10475.ast;if(v10465){if(!baseIsClass){var baseIsClass=this.checker.errorReporter,v26088=type.extendsList;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v26088=v26088[v27331];JAM.call(baseIsClass.simpleError,baseIsClass,[v10475,"A class may only extend other classes, "+v26088.symbol.fullName()+" is not a class."])}}else if(baseIsClass){baseIsClass=
this.checker.errorReporter;v26088=type.extendsList;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v26088=v26088[v27331];JAM.call(baseIsClass.simpleError,baseIsClass,[v10475,"An interface may only extend other interfaces, "+v26088.symbol.fullName()+" is a class."])}}v27331+=1;v10475=v27331<len}v27331=type;len=JAM.call(this.resolveBaseTypeLinks,this,[type.implementsTypeLinks,scope]);v27331.implementsList=len;if(type.implementsList)for(v27331=0,len=type.implementsList.length,v10475=
v27331<len;v10475;){v10475=type.implementsList;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)baseIsClass=v10475[v27331];v10475=type.implementsTypeLinks;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10475=v10475[v27331];v10475=v10475.ast;baseIsClass.isClassInstance()&&v10465&&(v26088=this.checker.errorReporter,JAM.call(v26088.simpleError,v26088,[v10475,"A class may only implement an interface; "+baseIsClass.symbol.fullName()+" is a class."]));v27331+=1;v10475=v27331<
len}}function v408(typeLinks,scope){var extendsList=null;if(typeLinks)for(var extendsList=[],i=0,len=typeLinks.length,v10486=i<len;v10486;){var v10486=extendsList,v10485=i,v17847=this.checker;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v17848=typeLinks[i];v17847=JAM.call(v17847.resolveBaseTypeLink,v17847,[v17848,scope]);v10486[v10485]=v17847;i+=1;v10486=i<len}return extendsList}function Binder(checker){this.checker=checker}Binder.prototype.resolveBaseTypeLinks=v408;Binder.prototype.resolveBases=
v409;Binder.prototype.resolveSignatureGroup=v410;Binder.prototype.bindType=v411;Binder.prototype.bindSymbol=v413;Binder.prototype.bind=v415;return Binder}var Binder=v416();TypeScript.Binder=Binder}
function v407(){var TypeScript=v18799;function v406(){function v405(script,position){var lineInfo={line:-1,col:-1};JAM.call(TypeScript.getSourceLineColFromMap,TypeScript,[lineInfo,position,script.locationInfo.lineMap]);-1!==lineInfo.col&&(lineInfo.col+=1);return"("+lineInfo.line+", "+lineInfo.col+")"}function v404(s,targetLength,paddingString,leftPadding){var v10496;v10496=leftPadding?"":s;for(var i=s.length,v10497=i<targetLength;v10497;)v10496+=paddingString,i+=1,v10497=i<targetLength;s=leftPadding?
s:"";return v10496+=s}function v403(linemap){for(var result="[",i=0,v10500=i<linemap.length;v10500;){0<i&&(result+=",");introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10500=linemap[i];result+=v10500;i+=1;v10500=i<linemap.length}result+="]";linemap=this.logger;JAM.call(linemap.log,linemap,["linemap: "+result])}function v402(script,comments,indent){if(null!=comments)for(var i=0,v10505=i<comments.length;v10505;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10505=
comments[i];JAM.call(this.logNode,this,[script,v10505,indent]);i+=1;v10505=i<comments.length}}function v401(script,cur,indent){indent=JAM.call(this.addPadding,this,["",indent,"| ",!0]);indent=indent.concat("+ "+cur.treeViewLabel());indent=JAM.call(this.addPadding,this,[indent,70," ",!1]);indent+=JAM.call(this.addLineColumn,this,[script,cur.minChar]);indent=JAM.call(this.addPadding,this,[indent,80," ",!1]);indent+="=> ";indent+=JAM.call(this.addLineColumn,this,[script,cur.limChar]);indent=JAM.call(this.addPadding,
this,[indent,102," ",!1]);indent=indent.concat("["+JAM.call(this.addPadding,this,[cur.minChar.toString(),1," ",!0])+", "+JAM.call(this.addPadding,this,[cur.limChar.toString(),1," ",!0])+"]");indent=JAM.call(this.addPadding,this,[indent,115," ",!1]);indent=indent.concat("sym="+cur.sym);indent=JAM.call(this.addPadding,this,[indent,135," ",!1]);script=null===cur.type?"null":cur.type.getTypeName();indent=indent.concat("type="+script);script=this.logger;JAM.call(script.log,script,[indent])}function v400(script){function post(cur,
parent){stack.pop();return cur}function pre(cur,parent){JAM.call(stack.push,stack,[cur]);var indent=2*(stack.length-1);JAM.call(_this.logComments,_this,[script,cur.preComments,indent]);JAM.call(_this.logNode,_this,[script,cur,indent]);JAM.call(_this.logComments,_this,[script,cur.postComments,indent]);return cur}var _this=this;JAM.call(this.logLinemap,this,[script.locationInfo.lineMap]);var stack=[],v10519=TypeScript.getAstWalkerFactory();JAM.call(v10519.walk,v10519,[script,pre,post])}function AstLogger(logger){this.logger=
logger}AstLogger.prototype.logScript=v400;AstLogger.prototype.logNode=v401;AstLogger.prototype.logComments=v402;AstLogger.prototype.logLinemap=v403;AstLogger.prototype.addPadding=v404;AstLogger.prototype.addLineColumn=v405;return AstLogger}var AstLogger=v406();TypeScript.AstLogger=AstLogger}
function v399(){var TypeScript=v18798;function v398(GetAstPathOptions){GetAstPathOptions._map=[];GetAstPathOptions.Default=0;GetAstPathOptions.EdgeInclusive=1;GetAstPathOptions.DontPruneSearchBasedOnPosition=2}function v397(){function AstPathContext(){var v27334=new TypeScript.AstPath;this.path=v27334}return AstPathContext}function v396(){function v395(){var v10527=1<=this.count();if(v10527){var v10527=this.asts,v25489=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10527=
v10527[v25489];if(v10527=v10527.nodeType===TypeScript.NodeType.Block){v10527=this.asts;v25489=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10527=v10527[v25489];v10527=!1===v10527.isStatementBlock}}return v10527}function v394(){var v10528=2<=this.count();if(v10528){var v10528=this.asts,v25493=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10528=v10528[v25493];if(v10528=v10528.nodeType===TypeScript.NodeType.List){v10528=this.asts;v25493=this.top-
1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10528=v10528[v25493];if(v10528=v10528.nodeType===TypeScript.NodeType.New){v10528=this.asts;v25493=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10528=v10528[v25493];var v10528=v10528.arguments,v25493=this.asts,v25498=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25493=v25493[v25498];v10528=v10528===v25493}}}return v10528}function v393(){var v10529=2<=this.count();if(v10529){var v10529=
this.asts,v25500=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10529=v10529[v25500];if(v10529=v10529.nodeType===TypeScript.NodeType.List){v10529=this.asts;v25500=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10529=v10529[v25500];if(v10529=v10529.nodeType===TypeScript.NodeType.Call){v10529=this.asts;v25500=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10529=v10529[v25500];var v10529=v10529.arguments,v25500=this.asts,
v25505=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25500=v25500[v25505];v10529=v10529===v25500}}}return v10529}function v392(){var v10530=3<=this.count();if(v10530){var v10530=this.asts,v25507=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10530=v10530[v25507];if(v10530=v10530.nodeType===TypeScript.NodeType.List){v10530=this.asts;v25507=this.top-2;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10530=v10530[v25507];if(v10530=
v10530.nodeType===TypeScript.NodeType.FuncDecl){v10530=this.asts;v25507=this.top-2;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10530=v10530[v25507];var v10530=v10530.arguments,v25507=this.asts,v25512=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25507=v25507[v25512];v10530=v10530===v25507}}}return v10530}function v391(){var v10531=2<=this.count();if(v10531){var v10531=this.asts,v25514=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10531=
v10531[v25514];if(v10531=v10531.nodeType===TypeScript.NodeType.List){v10531=this.asts;v25514=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10531=v10531[v25514];if(v10531=v10531.nodeType===TypeScript.NodeType.FuncDecl){v10531=this.asts;v25514=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10531=v10531[v25514];var v10531=v10531.arguments,v25514=this.asts,v25519=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25514=
v25514[v25519];v10531=v10531===v25514}}}return v10531}function v390(){var v10532=1<=this.count();if(v10532){var v10532=this.asts,v25521=this.top;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10532=v10532[v25521];if(v10532=v10532.nodeType===TypeScript.NodeType.List){v10532=this.asts;v25521=this.top;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10532=v10532[v25521];v10532=1===v10532.members.length}}return v10532}function v389(){return this.isBodyOfCase()}function v388(){var v10533=
2<=this.count();if(v10533){var v10533=this.asts,v25524=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10533=v10533[v25524];if(v10533=v10533.nodeType===TypeScript.NodeType.If){v10533=this.asts;v25524=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10533=v10533[v25524];var v10533=v10533.elseBod,v25524=this.asts,v24490=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25524=v25524[v24490];v10533=v10533==v25524}}return v10533}
function v387(){var v10534=2<=this.count();if(v10534){var v10534=this.asts,v25529=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10534=v10534[v25529];if(v10534=v10534.nodeType===TypeScript.NodeType.If){v10534=this.asts;v25529=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10534=v10534[v25529];var v10534=v10534.thenBod,v25529=this.asts,v24495=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25529=v25529[v24495];v10534=
v10534==v25529}}return v10534}function v386(){var v10535=2<=this.count();if(v10535){var v10535=this.asts,v24497=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10535=v10535[v24497];v10535=v10535.nodeType===TypeScript.NodeType.List}return v10535}function v385(){var v10536=2<=this.count();if(v10536){var v10536=this.asts,v25535=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10536=v10536[v25535];if(v10536=v10536.nodeType===TypeScript.NodeType.Member){v10536=
this.asts;v25535=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10536=v10536[v25535];var v10536=v10536.operand2,v25535=this.asts,v24502=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25535=v25535[v24502];v10536=v10536===v25535}}return v10536}function v384(){var v10537=2<=this.count();if(v10537){var v10537=this.asts,v25540=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10537=v10537[v25540];if(v10537=v10537.nodeType===
TypeScript.NodeType.Member){v10537=this.asts;v25540=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10537=v10537[v25540];var v10537=v10537.operand1,v25540=this.asts,v24507=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25540=v25540[v24507];v10537=v10537===v25540}}return v10537}function v383(){var v10538=2<=this.count();if(v10538){var v10538=this.asts,v25545=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10538=v10538[v25545];
if(v10538=v10538.nodeType===TypeScript.NodeType.ArrayLit){v10538=this.asts;v25545=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10538=v10538[v25545];if(v10538=v10538.nodeType===TypeScript.NodeType.List){v10538=this.asts;v25545=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10538=v10538[v25545];var v10538=v10538.operand,v25545=this.asts,v25550=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25545=v25545[v25550];
v10538=v10538==v25545}}}return v10538}function v382(){var v10539=4<=this.count();if(v10539){var v10539=this.asts,v25552=this.top-3;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10539=v10539[v25552];if(v10539=v10539.nodeType===TypeScript.NodeType.ObjectLit){v10539=this.asts;v25552=this.top-2;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10539=v10539[v25552];if(v10539=v10539.nodeType===TypeScript.NodeType.List){v10539=this.asts;v25552=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10539=
v10539[v25552];if(v10539=v10539.nodeType===TypeScript.NodeType.Member){v10539=this.asts;v25552=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10539=v10539[v25552];if(v10539=v10539.nodeType===TypeScript.NodeType.Name){v10539=this.asts;v25552=this.top-3;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10539=v10539[v25552];var v10539=v10539.operand,v25552=this.asts,v26458=this.top-2;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25552=v25552[v26458];
v10539=v10539==v25552}}}}}return v10539}function v381(){var v10540=3<=this.count();if(v10540){var v10540=this.asts,v25559=this.top-2;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10540=v10540[v25559];if(v10540=v10540.nodeType===TypeScript.NodeType.ObjectLit){v10540=this.asts;v25559=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10540=v10540[v25559];if(v10540=v10540.nodeType===TypeScript.NodeType.List){v10540=this.asts;v25559=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10540=
v10540[v25559];if(v10540=v10540.nodeType===TypeScript.NodeType.Member){v10540=this.asts;v25559=this.top-2;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10540=v10540[v25559];var v10540=v10540.operand,v25559=this.asts,v26149=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25559=v25559[v26149];v10540=v10540==v25559}}}}return v10540}function v380(){var v10541=2<=this.count();if(v10541){var v10541=this.asts,v25567=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10541=
v10541[v25567];if(v10541=v10541.nodeType===TypeScript.NodeType.ObjectLit){v10541=this.asts;v25567=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10541=v10541[v25567];if(v10541=v10541.nodeType===TypeScript.NodeType.List){v10541=this.asts;v25567=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10541=v10541[v25567];var v10541=v10541.operand,v25567=this.asts,v26155=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25567=
v25567[v26155];if(v10541=v10541==v25567){v10541=this.asts;v25567=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10541=v10541[v25567];v10541=0==v10541.members.length}}}}return v10541}function v379(){return this.isListOfObjectLit()}function v378(){var v10542=2<=this.count();if(v10542){var v10542=this.asts,v25574=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10542=v10542[v25574];if(v10542=v10542.nodeType===TypeScript.NodeType.ObjectLit){v10542=
this.asts;v25574=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10542=v10542[v25574];if(v10542=v10542.nodeType===TypeScript.NodeType.List){v10542=this.asts;v25574=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10542=v10542[v25574];var v10542=v10542.operand,v25574=this.asts,v25579=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25574=v25574[v25579];v10542=v10542==v25574}}}return v10542}function v377(){var v10543=
3<=this.count();if(v10543){var v10543=this.asts,v25581=this.top-2;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10543=v10543[v25581];if(v10543=v10543.nodeType===TypeScript.NodeType.Switch){v10543=this.asts;v25581=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10543=v10543[v25581];if(v10543=v10543.nodeType===TypeScript.NodeType.List){v10543=this.asts;v25581=this.top-2;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10543=v10543[v25581];
var v10543=v10543.caseList,v25581=this.asts,v26168=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25581=v25581[v26168];if(v10543=v10543==v25581){v10543=this.asts;v25581=this.top-2;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10543=v10543[v25581];v10543=v10543.defaultCase;v25581=this.asts;v26168=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25581=v25581[v26168];v10543=v10543==v25581}}}}return v10543}function v376(){var v10544=
3<=this.count();if(v10544){var v10544=this.asts,v25589=this.top-2;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10544=v10544[v25589];if(v10544=v10544.nodeType===TypeScript.NodeType.Switch){v10544=this.asts;v25589=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10544=v10544[v25589];if(v10544=v10544.nodeType===TypeScript.NodeType.List){v10544=this.asts;v25589=this.top-2;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10544=v10544[v25589];
var v10544=v10544.caseList,v25589=this.asts,v25594=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25589=v25589[v25594];v10544=v10544==v25589}}}return v10544}function v375(){var v10545=2<=this.count();if(v10545){var v10545=this.asts,v25596=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10545=v10545[v25596];if(v10545=v10545.nodeType===TypeScript.NodeType.Finally){v10545=this.asts;v25596=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10545=
v10545[v25596];var v10545=v10545.body,v25596=this.asts,v24550=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25596=v25596[v24550];v10545=v10545==v25596}}return v10545}function v374(){var v10546=2<=this.count();if(v10546){var v10546=this.asts,v25601=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10546=v10546[v25601];if(v10546=v10546.nodeType===TypeScript.NodeType.With){v10546=this.asts;v25601=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10546=
v10546[v25601];var v10546=v10546.body,v25601=this.asts,v24555=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25601=v25601[v24555];v10546=v10546==v25601}}return v10546}function v373(){var v10547=2<=this.count();if(v10547){var v10547=this.asts,v25606=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10547=v10547[v25606];if(v10547=v10547.nodeType===TypeScript.NodeType.ForIn){v10547=this.asts;v25606=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10547=
v10547[v25606];var v10547=v10547.body,v25606=this.asts,v24560=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25606=v25606[v24560];v10547=v10547==v25606}}return v10547}function v372(){var v10548=2<=this.count();if(v10548){var v10548=this.asts,v25611=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10548=v10548[v25611];if(v10548=v10548.nodeType===TypeScript.NodeType.While){v10548=this.asts;v25611=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10548=
v10548[v25611];var v10548=v10548.body,v25611=this.asts,v24565=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25611=v25611[v24565];v10548=v10548==v25611}}return v10548}function v371(){var v10549=2<=this.count();if(v10549){var v10549=this.asts,v25616=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10549=v10549[v25616];if(v10549=v10549.nodeType===TypeScript.NodeType.DoWhile){v10549=this.asts;v25616=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10549=
v10549[v25616];var v10549=v10549.body,v25616=this.asts,v24570=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25616=v25616[v24570];v10549=v10549==v25616}}return v10549}function v370(){var v10550=2<=this.count();if(v10550){var v10550=this.asts,v25621=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10550=v10550[v25621];if(v10550=v10550.nodeType===TypeScript.NodeType.Catch){v10550=this.asts;v25621=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10550=
v10550[v25621];var v10550=v10550.body,v25621=this.asts,v24575=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25621=v25621[v24575];v10550=v10550==v25621}}return v10550}function v369(){var v10551=2<=this.count();if(v10551){var v10551=this.asts,v25626=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10551=v10551[v25626];if(v10551=v10551.nodeType===TypeScript.NodeType.Try){v10551=this.asts;v25626=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10551=
v10551[v25626];var v10551=v10551.body,v25626=this.asts,v24580=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25626=v25626[v24580];v10551=v10551==v25626}}return v10551}function v368(){var v10552=2<=this.count();if(v10552){var v10552=this.asts,v25631=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10552=v10552[v25631];if(v10552=v10552.nodeType===TypeScript.NodeType.Case){v10552=this.asts;v25631=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10552=
v10552[v25631];var v10552=v10552.body,v25631=this.asts,v24585=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25631=v25631[v24585];v10552=v10552==v25631}}return v10552}function v367(){var v10553=2<=this.count();if(v10553){var v10553=this.asts,v25636=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10553=v10553[v25636];if(v10553=v10553.nodeType===TypeScript.NodeType.For){v10553=this.asts;v25636=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10553=
v10553[v25636];var v10553=v10553.body,v25636=this.asts,v24590=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25636=v25636[v24590];v10553=v10553==v25636}}return v10553}function v366(){var v10554=2<=this.count();if(v10554){var v10554=this.asts,v25641=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10554=v10554[v25641];if(v10554=v10554.nodeType===TypeScript.NodeType.Block){v10554=this.asts;v25641=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10554=
v10554[v25641];var v10554=v10554.statements,v25641=this.asts,v24595=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25641=v25641[v24595];v10554=v10554==v25641}}return v10554}function v365(){var v10555=2<=this.count();if(v10555){var v10555=this.asts,v25646=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10555=v10555[v25646];if(v10555=v10555.nodeType===TypeScript.NodeType.InterfaceDeclaration){v10555=this.asts;v25646=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10555=
v10555[v25646];var v10555=v10555.members,v25646=this.asts,v24600=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25646=v25646[v24600];v10555=v10555==v25646}}return v10555}function v364(){var v10556=2<=this.count();if(v10556){var v10556=this.asts,v25651=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10556=v10556[v25651];if(v10556=v10556.nodeType===TypeScript.NodeType.FuncDecl){v10556=this.asts;v25651=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10556=
v10556[v25651];var v10556=v10556.bod,v25651=this.asts,v24605=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25651=v25651[v24605];v10556=v10556==v25651}}return v10556}function v363(){var v10557=2<=this.count();if(v10557){var v10557=this.asts,v25656=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10557=v10557[v25656];if(v10557=v10557.nodeType===TypeScript.NodeType.ClassDeclaration){v10557=this.asts;v25656=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10557=
v10557[v25656];var v10557=v10557.members,v25656=this.asts,v24610=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25656=v25656[v24610];v10557=v10557==v25656}}return v10557}function v362(){var v10558=2<=this.count();if(v10558){var v10558=this.asts,v25661=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10558=v10558[v25661];if(v10558=v10558.nodeType===TypeScript.NodeType.ModuleDeclaration){v10558=this.asts;v25661=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10558=
v10558[v25661];var v10558=v10558.members,v25661=this.asts,v24615=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25661=v25661[v24615];v10558=v10558==v25661}}return v10558}function v361(){var v10559=2<=this.count();if(v10559){var v10559=this.asts,v25666=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10559=v10559[v25666];if(v10559=v10559.nodeType===TypeScript.NodeType.Switch){v10559=this.asts;v25666=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10559=
v10559[v25666];var v10559=v10559.caseList,v25666=this.asts,v24620=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25666=v25666[v24620];v10559=v10559==v25666}}return v10559}function v360(){var v10560=2<=this.count();if(v10560){var v10560=this.asts,v25671=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10560=v10560[v25671];if(v10560=v10560.nodeType===TypeScript.NodeType.Script){v10560=this.asts;v25671=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10560=
v10560[v25671];var v10560=v10560.bod,v25671=this.asts,v24625=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25671=v25671[v24625];v10560=v10560==v25671}}return v10560}function v359(){var v10561=2<=this.count();if(v10561){var v10561=this.asts,v25676=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10561=v10561[v25676];if(v10561=v10561.nodeType===TypeScript.NodeType.List){v10561=this.asts;v25676=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10561=
v10561[v25676];if(v10561=v10561.nodeType===TypeScript.NodeType.ModuleDeclaration){v10561=this.asts;v25676=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10561=v10561[v25676];var v10561=v10561.members,v25676=this.asts,v26215=this.top-0;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v25676=v25676[v26215];if(v10561=v10561==v25676){v10561=this.asts;v25676=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10561=v10561[v25676];v10561=
JAM.call(TypeScript.hasFlag,TypeScript,[v10561.modFlags,TypeScript.ModuleFlags.IsWholeFile])}}}}return v10561}function v358(){var v10562=1<=this.count();if(v10562){var v10562=this.asts,v25684=this.top;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10562=v10562[v25684];if(v10562=v10562.nodeType===TypeScript.NodeType.ModuleDeclaration){v10562=this.asts;v25684=this.top;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10562=v10562[v25684];v10562=JAM.call(TypeScript.hasFlag,
TypeScript,[v10562.modFlags,TypeScript.ModuleFlags.IsWholeFile])}}return v10562}function v357(){var ast=lastOf(this.asts),v10564=3<=this.count();if(v10564){var v10564=this.asts,v24636=this.top;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10564=v10564[v24636];if(ast=v10564===ast){ast=this.asts;v10564=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)ast=ast[v10564];if(ast=ast.nodeType===TypeScript.NodeType.List){ast=this.asts;v10564=this.top-2;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)ast=
ast[v10564];ast=ast.nodeType===TypeScript.NodeType.InterfaceDeclaration}}v10564=ast}return v10564}function v356(){var ast=lastOf(this.asts),v10566=5<=this.count();if(v10566){var v10566=this.asts,v24642=this.top;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10566=v10566[v24642];if(ast=v10566===ast){ast=this.asts;v10566=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)ast=ast[v10566];if(ast=ast.nodeType===TypeScript.NodeType.List){ast=this.asts;v10566=this.top-
2;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)ast=ast[v10566];if(ast=ast.nodeType===TypeScript.NodeType.FuncDecl){ast=this.asts;v10566=this.top-3;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)ast=ast[v10566];if(ast=ast.nodeType===TypeScript.NodeType.List){ast=this.asts;v10566=this.top-4;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)ast=ast[v10566];if(ast=ast.nodeType===TypeScript.NodeType.ClassDeclaration){ast=this.asts;v10566=this.top-2;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)ast=
ast[v10566];if(ast=ast.isConstructor){ast=this.asts;v10566=this.top-2;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)ast=ast[v10566];ast=ast.arguments;v10566=this.asts;v24642=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10566=v10566[v24642];if(ast=ast===v10566){ast=this.asts;v10566=this.top-4;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)ast=ast[v10566];ast=ast.constructorDecl;v10566=this.asts;v24642=this.top-2;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10566=
v10566[v24642];ast=ast===v10566}}}}}}}v10566=ast}return v10566}function v355(){var ast=lastOf(this.asts),v10568=3<=this.count();if(v10568){var v10568=this.asts,v24647=this.top;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10568=v10568[v24647];if(ast=v10568===ast){ast=this.asts;v10568=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)ast=ast[v10568];if(ast=ast.nodeType===TypeScript.NodeType.List){ast=this.asts;v10568=this.top-2;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)ast=
ast[v10568];ast=ast.nodeType===TypeScript.NodeType.ClassDeclaration}}v10568=ast}return v10568}function v354(){var ast=lastOf(this.asts),v10570=3<=this.count();if(v10570){var v10570=this.asts,v24653=this.top;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10570=v10570[v24653];if(ast=v10570===ast){ast=this.asts;v10570=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)ast=ast[v10570];if(ast=ast.nodeType===TypeScript.NodeType.List){ast=this.asts;v10570=this.top-
2;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)ast=ast[v10570];ast=ast.nodeType===TypeScript.NodeType.ModuleDeclaration}}v10570=ast}return v10570}function v353(){var ast=lastOf(this.asts),v10572=3<=this.count();if(v10572){var v10572=this.asts,v24659=this.top;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10572=v10572[v24659];if(ast=v10572===ast){ast=this.asts;v10572=this.top-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)ast=ast[v10572];if(ast=
ast.nodeType===TypeScript.NodeType.List){ast=this.asts;v10572=this.top-2;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)ast=ast[v10572];ast=ast.nodeType===TypeScript.NodeType.Script}}v10572=ast}return v10572}function v352(){var v17951=null===this.ast();v17951||(v17951=null===this.parent());if(v17951)return!1;(v17951=this.ast().nodeType===TypeScript.NodeType.Name)&&(v17951=this.parent().nodeType===TypeScript.NodeType.FuncDecl)&&(v17951=this.parent().name===this.ast());return v17951}
function v351(){var v17955=null===this.ast();v17955||(v17955=null===this.parent());if(v17955)return!1;(v17955=this.ast().nodeType===TypeScript.NodeType.Name)&&(v17955=this.parent().nodeType===TypeScript.NodeType.ModuleDeclaration)&&(v17955=this.parent().name===this.ast());return v17955}function v350(){var v17959=null===this.ast();v17959||(v17959=null===this.parent());if(v17959)return!1;(v17959=this.ast().nodeType===TypeScript.NodeType.Name)&&(v17959=this.parent().nodeType===TypeScript.NodeType.VarDecl)&&
(v17959=this.parent().id===this.ast());return v17959}function v349(){var v17963=null===this.ast();v17963||(v17963=null===this.parent());if(v17963)return!1;(v17963=this.ast().nodeType===TypeScript.NodeType.Name)&&(v17963=this.parent().nodeType===TypeScript.NodeType.ArgDecl)&&(v17963=this.parent().id===this.ast());return v17963}function v348(){var v17967=null===this.ast();v17967||(v17967=null===this.parent());if(v17967)return!1;(v17967=this.ast().nodeType===TypeScript.NodeType.Name)&&(v17967=this.parent().nodeType===
TypeScript.NodeType.InterfaceDeclaration)&&(v17967=this.parent().name===this.ast());return v17967}function v347(){var v17971=null===this.ast();v17971||(v17971=null===this.parent());if(v17971)return!1;(v17971=this.ast().nodeType===TypeScript.NodeType.Name)&&(v17971=this.parent().nodeType===TypeScript.NodeType.ClassDeclaration)&&(v17971=this.parent().name===this.ast());return v17971}function v346(index){var v10585=this.asts;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v10585[index]}
function v345(){return this.top+1}function v344(){return JAM.call(AstPath.reverseIndexOf,AstPath,[this.asts,this.asts.length-this.top])}function v343(){return JAM.call(AstPath.reverseIndexOf,AstPath,[this.asts,this.asts.length-(this.top+1)])}function v342(){return null==this.ast()?TypeScript.NodeType.None:this.ast().nodeType}function v341(){if(this.top==this.ast.length-1)throw Error("Invalid call to 'down'");this.top+=1}function v340(){if(-1>=this.top)throw Error("Invalid call to 'up'");this.top-=
1}function v339(ast){for(var v10597=this.asts.length>this.count();v10597;)this.asts.pop(),v10597=this.asts.length>this.count();this.top=this.asts.length;v10597=this.asts;JAM.call(v10597.push,v10597,[ast])}function v338(){var head=this.ast();this.up();for(var v10601=this.asts.length>this.count();v10601;)this.asts.pop(),v10601=this.asts.length>this.count();return head}function v337(){function v336(value){return value}var clone=new AstPath,v10602=clone,v17993=this.asts,v17993=JAM.call(v17993.map,v17993,
[v336]);v10602.asts=v17993;clone.top=this.top;return clone}function reverseIndexOf(items,index){var v10603;(v10603=null===items)||(v10603=items.length<=index);return v10603=v10603?null:items[items.length-index-1]}function AstPath(){this.asts=[];this.top=-1}AstPath.reverseIndexOf=reverseIndexOf;AstPath.prototype.clone=v337;AstPath.prototype.pop=v338;AstPath.prototype.push=v339;AstPath.prototype.up=v340;AstPath.prototype.down=v341;AstPath.prototype.nodeType=v342;AstPath.prototype.ast=v343;AstPath.prototype.parent=
v344;AstPath.prototype.count=v345;AstPath.prototype.get=v346;AstPath.prototype.isNameOfClass=v347;AstPath.prototype.isNameOfInterface=v348;AstPath.prototype.isNameOfArgument=v349;AstPath.prototype.isNameOfVariable=v350;AstPath.prototype.isNameOfModule=v351;AstPath.prototype.isNameOfFunction=v352;AstPath.prototype.isChildOfScript=v353;AstPath.prototype.isChildOfModule=v354;AstPath.prototype.isChildOfClass=v355;AstPath.prototype.isArgumentOfClassConstructor=v356;AstPath.prototype.isChildOfInterface=
v357;AstPath.prototype.isTopLevelImplicitModule=v358;AstPath.prototype.isBodyOfTopLevelImplicitModule=v359;AstPath.prototype.isBodyOfScript=v360;AstPath.prototype.isBodyOfSwitch=v361;AstPath.prototype.isBodyOfModule=v362;AstPath.prototype.isBodyOfClass=v363;AstPath.prototype.isBodyOfFunction=v364;AstPath.prototype.isBodyOfInterface=v365;AstPath.prototype.isBodyOfBlock=v366;AstPath.prototype.isBodyOfFor=v367;AstPath.prototype.isBodyOfCase=v368;AstPath.prototype.isBodyOfTry=v369;AstPath.prototype.isBodyOfCatch=
v370;AstPath.prototype.isBodyOfDoWhile=v371;AstPath.prototype.isBodyOfWhile=v372;AstPath.prototype.isBodyOfForIn=v373;AstPath.prototype.isBodyOfWith=v374;AstPath.prototype.isBodyOfFinally=v375;AstPath.prototype.isCaseOfSwitch=v376;AstPath.prototype.isDefaultCaseOfSwitch=v377;AstPath.prototype.isListOfObjectLit=v378;AstPath.prototype.isBodyOfObjectLit=v379;AstPath.prototype.isEmptyListOfObjectLit=v380;AstPath.prototype.isMemberOfObjectLit=v381;AstPath.prototype.isNameOfMemberOfObjectLit=v382;AstPath.prototype.isListOfArrayLit=
v383;AstPath.prototype.isTargetOfMember=v384;AstPath.prototype.isMemberOfMember=v385;AstPath.prototype.isItemOfList=v386;AstPath.prototype.isThenOfIf=v387;AstPath.prototype.isElseOfIf=v388;AstPath.prototype.isBodyOfDefaultCase=v389;AstPath.prototype.isSingleStatementList=v390;AstPath.prototype.isArgumentListOfFunction=v391;AstPath.prototype.isArgumentOfFunction=v392;AstPath.prototype.isArgumentListOfCall=v393;AstPath.prototype.isArgumentListOfNew=v394;AstPath.prototype.isSynthesizedBlock=v395;return AstPath}
function lastOf(items){var v22513=null===items;v22513||(v22513=0===items.length);return items=v22513?null:items[items.length-1]}function max(a,b){var v10664;return v10664=a>=b?a:b}function min(a,b){var v10665;return v10665=a<=b?a:b}function isValidAstNode(ast){if(null===ast)return!1;var v18000=-1===ast.minChar;v18000||(v18000=-1===ast.limChar);return v18000?!1:!0}function getAstPathToPosition(script,pos,options){function pre(cur,parent,walker){if(isValidAstNode(cur)){parent=JAM.call(TypeScript.hasFlag,
TypeScript,[options,GetAstPathOptions.EdgeInclusive]);parent||(parent=cur.nodeType===TypeScript.NodeType.Name)||(parent=pos===script.limChar);var inclusive=parent;parent=cur.minChar;var v10669=cur.limChar,inclusive=inclusive?1:0,v10669=v10669+inclusive;(inclusive=pos>=parent)&&(inclusive=pos<v10669);if(inclusive){var inclusive=ctx.path.ast(),v18006=null==inclusive;v18006||(v18006=cur.minChar>=inclusive.minChar)&&(v18006=cur.limChar<=inclusive.limChar);v18006&&(inclusive=ctx.path,JAM.call(inclusive.push,
inclusive,[cur]))}pos<v10669&&lookInComments(cur.preComments);pos>=parent&&lookInComments(cur.postComments);JAM.call(TypeScript.hasFlag,TypeScript,[options,GetAstPathOptions.DontPruneSearchBasedOnPosition])||(walker=walker.options,(parent=parent<=pos)&&(parent=pos<=v10669),walker.goChildren=parent)}return cur}function lookInComments(comments){var v18009=comments;v18009&&(v18009=0<comments.length);if(v18009)for(var v18009=0,v10688=v18009<comments.length;v10688;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10688=
comments[v18009];v10688=v10688.minChar;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v10683=comments[v18009];v10683=v10683.limChar;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v22526=comments[v18009];v22526.isBlockComment||(v10683+=1);(v10688=pos>=v10688)&&(v10688=pos<v10683);if(v10688){v10688=ctx.path;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v10683=comments[v18009];JAM.call(v10688.push,v10688,[v10683])}v18009+=1;v10688=v18009<comments.length}}
"undefined"===typeof options&&(options=GetAstPathOptions.Default);var ctx=new AstPathContext,v10691=TypeScript.getAstWalkerFactory();JAM.call(v10691.walk,v10691,[script,pre,null,null,ctx]);return ctx.path}function getTokenizationOffset(script,position){function pre(cur,parent,walker){JAM.call(TypeScript.isValidAstNode,TypeScript,[cur])&&(cur.minChar<=position&&(bestOffset=max(bestOffset,cur.minChar)),(parent=cur.minChar>position)||(parent=cur.limChar<bestOffset),parent&&(walker.options.goChildren=
!1));return cur}var bestOffset=0,v10697=TypeScript.getAstWalkerFactory();JAM.call(v10697.walk,v10697,[script,pre]);return bestOffset}function walkAST(ast,callback){function post(cur,parent,walker){parent=walker.state;parent.pop();return cur}function pre(cur,parent,walker){parent=walker.state;JAM.call(parent.push,parent,[cur]);JAM.call(callback,null,[parent,walker]);return cur}var path=new AstPath,v10698=TypeScript.getAstWalkerFactory();JAM.call(v10698.walk,v10698,[ast,pre,post,null,path])}TypeScript.lastOf=
lastOf;TypeScript.max=max;TypeScript.min=min;var AstPath=v396();TypeScript.AstPath=AstPath;TypeScript.isValidAstNode=isValidAstNode;var AstPathContext=v397();TypeScript.AstPathContext=AstPathContext;var v18017=TypeScript.GetAstPathOptions;v18017||(v18017=TypeScript.GetAstPathOptions={});v398(v18017);var GetAstPathOptions=TypeScript.GetAstPathOptions;TypeScript.getAstPathToPosition=getAstPathToPosition;TypeScript.getTokenizationOffset=getTokenizationOffset;TypeScript.walkAST=walkAST}
function v335(){var TypeScript=v18797;function v334(AstWalkerWithDetailCallback){function walk(script,callback){function post(cur,parent){AstWalkerCallback(!1,cur,callback);return cur}function pre(cur,parent){var v10700=walker.options,v27336=AstWalkerCallback(!0,cur,callback);v10700.goChildren=v27336;return cur}var v10701=TypeScript.getAstWalkerFactory(),walker=JAM.call(v10701.getWalker,v10701,[pre,post]);JAM.call(walker.walk,walker,[script,null])}function AstWalkerCallback(pre,ast,callback){var nodeType=
ast.nodeType,v18018=TypeScript.NodeType._map;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)nodeType=v18018[nodeType];nodeType+="Callback";introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v18018=callback[nodeType];return v18018?JAM.call(JAM.get(callback,nodeType,JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074),callback,[pre,ast]):callback.DefaultCallback?JAM.call(callback.DefaultCallback,callback,[pre,ast]):!0}AstWalkerWithDetailCallback.walk=walk}var v18019=TypeScript.AstWalkerWithDetailCallback;
v18019||(v18019=TypeScript.AstWalkerWithDetailCallback={});v334(v18019)}
function v333(){var TypeScript=v18796;function v332(ChildrenWalkers){function walkNone(preAst,parent,walker){}function walkListChildren(preAst,parent,walker){var len=preAst.members.length;if(walker.options.reverseSiblings)for(parent=len-1,len=0<=parent;len;){if(walker.options.goNextSibling){var len=preAst.members,v10708=parent,v22533=preAst.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v22533=v22533[parent];v22533=JAM.call(walker.walk,walker,[v22533,preAst]);len[v10708]=
v22533}parent-=1;len=0<=parent}else for(parent=0,v10708=parent<len;v10708;){if(walker.options.goNextSibling){var v10708=preAst.members,v22533=parent,v22534=preAst.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v22534=v22534[parent];v22534=JAM.call(walker.walk,walker,[v22534,preAst]);v10708[v22533]=v22534}parent+=1;v10708=parent<len}}function walkUnaryExpressionChildren(preAst,parent,walker){if(preAst.castTerm){parent=preAst;var v27339=JAM.call(walker.walk,walker,[preAst.castTerm,
preAst]);parent.castTerm=v27339}preAst.operand&&(parent=preAst,preAst=JAM.call(walker.walk,walker,[preAst.operand,preAst]),parent.operand=preAst)}function walkBinaryExpressionChildren(preAst,parent,walker){if(walker.options.reverseSiblings){if(preAst.operand2){parent=preAst;var v27341=JAM.call(walker.walk,walker,[preAst.operand2,preAst]);parent.operand2=v27341}if(parent=preAst.operand1)parent=walker.options.goNextSibling;parent&&(parent=preAst,preAst=JAM.call(walker.walk,walker,[preAst.operand1,preAst]),
parent.operand1=preAst)}else{preAst.operand1&&(parent=preAst,v27341=JAM.call(walker.walk,walker,[preAst.operand1,preAst]),parent.operand1=v27341);if(parent=preAst.operand2)parent=walker.options.goNextSibling;parent&&(parent=preAst,preAst=JAM.call(walker.walk,walker,[preAst.operand2,preAst]),parent.operand2=preAst)}}function walkTypeReferenceChildren(preAst,parent,walker){preAst.term&&(parent=preAst,preAst=JAM.call(walker.walk,walker,[preAst.term,preAst]),parent.term=preAst)}function walkCallExpressionChildren(preAst,
parent,walker){if(!walker.options.reverseSiblings){parent=preAst;var v27346=JAM.call(walker.walk,walker,[preAst.target,preAst]);parent.target=v27346}if(parent=preAst.arguments)parent=walker.options.goNextSibling;parent&&(parent=preAst,v27346=JAM.call(walker.walk,walker,[preAst.arguments,preAst]),parent.arguments=v27346);if(parent=walker.options.reverseSiblings)parent=walker.options.goNextSibling;parent&&(parent=preAst,preAst=JAM.call(walker.walk,walker,[preAst.target,preAst]),parent.target=preAst)}
function walkTrinaryExpressionChildren(preAst,parent,walker){if(preAst.operand1){parent=preAst;var v27349=JAM.call(walker.walk,walker,[preAst.operand1,preAst]);parent.operand1=v27349}if(parent=preAst.operand2)parent=walker.options.goNextSibling;parent&&(parent=preAst,v27349=JAM.call(walker.walk,walker,[preAst.operand2,preAst]),parent.operand2=v27349);if(parent=preAst.operand3)parent=walker.options.goNextSibling;parent&&(parent=preAst,preAst=JAM.call(walker.walk,walker,[preAst.operand3,preAst]),parent.operand3=
preAst)}function walkFuncDeclChildren(preAst,parent,walker){if(preAst.name){parent=preAst;var v27352=JAM.call(walker.walk,walker,[preAst.name,preAst]);parent.name=v27352}if(parent=preAst.arguments)if(parent=0<preAst.arguments.members.length)parent=walker.options.goNextSibling;parent&&(parent=preAst,v27352=JAM.call(walker.walk,walker,[preAst.arguments,preAst]),parent.arguments=v27352);if(parent=preAst.returnTypeAnnotation)parent=walker.options.goNextSibling;parent&&(parent=preAst,v27352=JAM.call(walker.walk,
walker,[preAst.returnTypeAnnotation,preAst]),parent.returnTypeAnnotation=v27352);if(parent=preAst.bod)if(parent=0<preAst.bod.members.length)parent=walker.options.goNextSibling;parent&&(parent=preAst,preAst=JAM.call(walker.walk,walker,[preAst.bod,preAst]),parent.bod=preAst)}function walkBoundDeclChildren(preAst,parent,walker){if(preAst.id){parent=preAst;var v27356=JAM.call(walker.walk,walker,[preAst.id,preAst]);parent.id=v27356}preAst.init&&(parent=preAst,v27356=JAM.call(walker.walk,walker,[preAst.init,
preAst]),parent.init=v27356);if(parent=preAst.typeExpr)parent=walker.options.goNextSibling;parent&&(parent=preAst,preAst=JAM.call(walker.walk,walker,[preAst.typeExpr,preAst]),parent.typeExpr=preAst)}function walkReturnStatementChildren(preAst,parent,walker){preAst.returnExpression&&(parent=preAst,preAst=JAM.call(walker.walk,walker,[preAst.returnExpression,preAst]),parent.returnExpression=preAst)}function walkForStatementChildren(preAst,parent,walker){if(preAst.init){parent=preAst;var v27360=JAM.call(walker.walk,
walker,[preAst.init,preAst]);parent.init=v27360}if(parent=preAst.cond)parent=walker.options.goNextSibling;parent&&(parent=preAst,v27360=JAM.call(walker.walk,walker,[preAst.cond,preAst]),parent.cond=v27360);if(parent=preAst.incr)parent=walker.options.goNextSibling;parent&&(parent=preAst,v27360=JAM.call(walker.walk,walker,[preAst.incr,preAst]),parent.incr=v27360);if(parent=preAst.body)parent=walker.options.goNextSibling;parent&&(parent=preAst,preAst=JAM.call(walker.walk,walker,[preAst.body,preAst]),
parent.body=preAst)}function walkForInStatementChildren(preAst,parent,walker){parent=preAst;var v27364=JAM.call(walker.walk,walker,[preAst.lval,preAst]);parent.lval=v27364;walker.options.goNextSibling&&(parent=preAst,v27364=JAM.call(walker.walk,walker,[preAst.obj,preAst]),parent.obj=v27364);if(parent=preAst.body)parent=walker.options.goNextSibling;parent&&(parent=preAst,preAst=JAM.call(walker.walk,walker,[preAst.body,preAst]),parent.body=preAst)}function walkIfStatementChildren(preAst,parent,walker){parent=
preAst;var v27367=JAM.call(walker.walk,walker,[preAst.cond,preAst]);parent.cond=v27367;if(parent=preAst.thenBod)parent=walker.options.goNextSibling;parent&&(parent=preAst,v27367=JAM.call(walker.walk,walker,[preAst.thenBod,preAst]),parent.thenBod=v27367);if(parent=preAst.elseBod)parent=walker.options.goNextSibling;parent&&(parent=preAst,preAst=JAM.call(walker.walk,walker,[preAst.elseBod,preAst]),parent.elseBod=preAst)}function walkWhileStatementChildren(preAst,parent,walker){parent=preAst;var v27370=
JAM.call(walker.walk,walker,[preAst.cond,preAst]);parent.cond=v27370;if(parent=preAst.body)parent=walker.options.goNextSibling;parent&&(parent=preAst,preAst=JAM.call(walker.walk,walker,[preAst.body,preAst]),parent.body=preAst)}function walkDoWhileStatementChildren(preAst,parent,walker){parent=preAst;var v27372=JAM.call(walker.walk,walker,[preAst.cond,preAst]);parent.cond=v27372;if(parent=preAst.body)parent=walker.options.goNextSibling;parent&&(parent=preAst,preAst=JAM.call(walker.walk,walker,[preAst.body,
preAst]),parent.body=preAst)}function walkBlockChildren(preAst,parent,walker){preAst.statements&&(parent=preAst,preAst=JAM.call(walker.walk,walker,[preAst.statements,preAst]),parent.statements=preAst)}function walkCaseStatementChildren(preAst,parent,walker){if(preAst.expr){parent=preAst;var v27375=JAM.call(walker.walk,walker,[preAst.expr,preAst]);parent.expr=v27375}if(parent=preAst.body)parent=walker.options.goNextSibling;parent&&(parent=preAst,preAst=JAM.call(walker.walk,walker,[preAst.body,preAst]),
parent.body=preAst)}function walkSwitchStatementChildren(preAst,parent,walker){if(preAst.val){parent=preAst;var v27377=JAM.call(walker.walk,walker,[preAst.val,preAst]);parent.val=v27377}if(parent=preAst.caseList)parent=walker.options.goNextSibling;parent&&(parent=preAst,preAst=JAM.call(walker.walk,walker,[preAst.caseList,preAst]),parent.caseList=preAst)}function walkTryChildren(preAst,parent,walker){preAst.body&&(parent=preAst,preAst=JAM.call(walker.walk,walker,[preAst.body,preAst]),parent.body=preAst)}
function walkTryCatchChildren(preAst,parent,walker){if(preAst.tryNode){parent=preAst;var v27380=JAM.call(walker.walk,walker,[preAst.tryNode,preAst]);parent.tryNode=v27380}if(parent=preAst.catchNode)parent=walker.options.goNextSibling;parent&&(parent=preAst,preAst=JAM.call(walker.walk,walker,[preAst.catchNode,preAst]),parent.catchNode=preAst)}function walkTryFinallyChildren(preAst,parent,walker){if(preAst.tryNode){parent=preAst;var v27382=JAM.call(walker.walk,walker,[preAst.tryNode,preAst]);parent.tryNode=
v27382}if(parent=preAst.finallyNode)parent=walker.options.goNextSibling;parent&&(parent=preAst,preAst=JAM.call(walker.walk,walker,[preAst.finallyNode,preAst]),parent.finallyNode=preAst)}function walkFinallyChildren(preAst,parent,walker){preAst.body&&(parent=preAst,preAst=JAM.call(walker.walk,walker,[preAst.body,preAst]),parent.body=preAst)}function walkCatchChildren(preAst,parent,walker){if(preAst.param){parent=preAst;var v27385=JAM.call(walker.walk,walker,[preAst.param,preAst]);parent.param=v27385}if(parent=
preAst.body)parent=walker.options.goNextSibling;parent&&(parent=preAst,preAst=JAM.call(walker.walk,walker,[preAst.body,preAst]),parent.body=preAst)}function walkRecordChildren(preAst,parent,walker){parent=preAst;var v27387=JAM.call(walker.walk,walker,[preAst.name,preAst]);parent.name=v27387;if(parent=walker.options.goNextSibling)parent=preAst.members;parent&&(parent=preAst,preAst=JAM.call(walker.walk,walker,[preAst.members,preAst]),parent.members=preAst)}function walkNamedTypeChildren(preAst,parent,
walker){walkRecordChildren(preAst,parent,walker)}function walkClassDeclChildren(preAst,parent,walker){walkRecordChildren(preAst,parent,walker);if(parent=walker.options.goNextSibling)parent=preAst.extendsList;if(parent){parent=preAst;var v27389=JAM.call(walker.walk,walker,[preAst.extendsList,preAst]);parent.extendsList=v27389}if(parent=walker.options.goNextSibling)parent=preAst.implementsList;parent&&(parent=preAst,preAst=JAM.call(walker.walk,walker,[preAst.implementsList,preAst]),parent.implementsList=
preAst)}function walkScriptChildren(preAst,parent,walker){preAst.bod&&(parent=preAst,preAst=JAM.call(walker.walk,walker,[preAst.bod,preAst]),parent.bod=preAst)}function walkTypeDeclChildren(preAst,parent,walker){walkRecordChildren(preAst,parent,walker);if(parent=walker.options.goNextSibling)parent=preAst.extendsList;if(parent){parent=preAst;var v27392=JAM.call(walker.walk,walker,[preAst.extendsList,preAst]);parent.extendsList=v27392}if(parent=walker.options.goNextSibling)parent=preAst.implementsList;
parent&&(parent=preAst,preAst=JAM.call(walker.walk,walker,[preAst.implementsList,preAst]),parent.implementsList=preAst)}function walkModuleDeclChildren(preAst,parent,walker){walkRecordChildren(preAst,parent,walker)}function walkImportDeclChildren(preAst,parent,walker){if(preAst.id){parent=preAst;var v27394=JAM.call(walker.walk,walker,[preAst.id,preAst]);parent.id=v27394}preAst.alias&&(parent=preAst,preAst=JAM.call(walker.walk,walker,[preAst.alias,preAst]),parent.alias=preAst)}function walkWithStatementChildren(preAst,
parent,walker){if(preAst.expr){parent=preAst;var v27396=JAM.call(walker.walk,walker,[preAst.expr,preAst]);parent.expr=v27396}if(parent=preAst.body)parent=walker.options.goNextSibling;parent&&(parent=preAst,preAst=JAM.call(walker.walk,walker,[preAst.body,preAst]),parent.body=preAst)}function walkLabelChildren(preAst,parent,walker){}function walkLabeledStatementChildren(preAst,parent,walker){parent=preAst;var v27398=JAM.call(walker.walk,walker,[preAst.labels,preAst]);parent.labels=v27398;walker.options.goNextSibling&&
(parent=preAst,preAst=JAM.call(walker.walk,walker,[preAst.stmt,preAst]),parent.stmt=preAst)}ChildrenWalkers.walkNone=walkNone;ChildrenWalkers.walkListChildren=walkListChildren;ChildrenWalkers.walkUnaryExpressionChildren=walkUnaryExpressionChildren;ChildrenWalkers.walkBinaryExpressionChildren=walkBinaryExpressionChildren;ChildrenWalkers.walkTypeReferenceChildren=walkTypeReferenceChildren;ChildrenWalkers.walkCallExpressionChildren=walkCallExpressionChildren;ChildrenWalkers.walkTrinaryExpressionChildren=
walkTrinaryExpressionChildren;ChildrenWalkers.walkFuncDeclChildren=walkFuncDeclChildren;ChildrenWalkers.walkBoundDeclChildren=walkBoundDeclChildren;ChildrenWalkers.walkReturnStatementChildren=walkReturnStatementChildren;ChildrenWalkers.walkForStatementChildren=walkForStatementChildren;ChildrenWalkers.walkForInStatementChildren=walkForInStatementChildren;ChildrenWalkers.walkIfStatementChildren=walkIfStatementChildren;ChildrenWalkers.walkWhileStatementChildren=walkWhileStatementChildren;ChildrenWalkers.walkDoWhileStatementChildren=
walkDoWhileStatementChildren;ChildrenWalkers.walkBlockChildren=walkBlockChildren;ChildrenWalkers.walkCaseStatementChildren=walkCaseStatementChildren;ChildrenWalkers.walkSwitchStatementChildren=walkSwitchStatementChildren;ChildrenWalkers.walkTryChildren=walkTryChildren;ChildrenWalkers.walkTryCatchChildren=walkTryCatchChildren;ChildrenWalkers.walkTryFinallyChildren=walkTryFinallyChildren;ChildrenWalkers.walkFinallyChildren=walkFinallyChildren;ChildrenWalkers.walkCatchChildren=walkCatchChildren;ChildrenWalkers.walkRecordChildren=
walkRecordChildren;ChildrenWalkers.walkNamedTypeChildren=walkNamedTypeChildren;ChildrenWalkers.walkClassDeclChildren=walkClassDeclChildren;ChildrenWalkers.walkScriptChildren=walkScriptChildren;ChildrenWalkers.walkTypeDeclChildren=walkTypeDeclChildren;ChildrenWalkers.walkModuleDeclChildren=walkModuleDeclChildren;ChildrenWalkers.walkImportDeclChildren=walkImportDeclChildren;ChildrenWalkers.walkWithStatementChildren=walkWithStatementChildren;ChildrenWalkers.walkLabelChildren=walkLabelChildren;ChildrenWalkers.walkLabeledStatementChildren=
walkLabeledStatementChildren}function v331(){function v330(){JAM.set(this.childrenWalkers,TypeScript.NodeType.None,ChildrenWalkers.walkNone);JAM.set(this.childrenWalkers,TypeScript.NodeType.Empty,ChildrenWalkers.walkNone);JAM.set(this.childrenWalkers,TypeScript.NodeType.EmptyExpr,ChildrenWalkers.walkNone);JAM.set(this.childrenWalkers,TypeScript.NodeType.True,ChildrenWalkers.walkNone);JAM.set(this.childrenWalkers,TypeScript.NodeType.False,ChildrenWalkers.walkNone);JAM.set(this.childrenWalkers,TypeScript.NodeType.This,
ChildrenWalkers.walkNone);JAM.set(this.childrenWalkers,TypeScript.NodeType.Super,ChildrenWalkers.walkNone);JAM.set(this.childrenWalkers,TypeScript.NodeType.QString,ChildrenWalkers.walkNone);JAM.set(this.childrenWalkers,TypeScript.NodeType.Regex,ChildrenWalkers.walkNone);JAM.set(this.childrenWalkers,TypeScript.NodeType.Null,ChildrenWalkers.walkNone);JAM.set(this.childrenWalkers,TypeScript.NodeType.ArrayLit,ChildrenWalkers.walkUnaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.ObjectLit,
ChildrenWalkers.walkUnaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Void,ChildrenWalkers.walkUnaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Comma,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Pos,ChildrenWalkers.walkUnaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Neg,ChildrenWalkers.walkUnaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Delete,ChildrenWalkers.walkUnaryExpressionChildren);
JAM.set(this.childrenWalkers,TypeScript.NodeType.Await,ChildrenWalkers.walkUnaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.In,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Dot,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.From,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Is,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,
TypeScript.NodeType.InstOf,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Typeof,ChildrenWalkers.walkUnaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.NumberLit,ChildrenWalkers.walkNone);JAM.set(this.childrenWalkers,TypeScript.NodeType.Name,ChildrenWalkers.walkNone);JAM.set(this.childrenWalkers,TypeScript.NodeType.TypeRef,ChildrenWalkers.walkTypeReferenceChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Index,ChildrenWalkers.walkBinaryExpressionChildren);
JAM.set(this.childrenWalkers,TypeScript.NodeType.Call,ChildrenWalkers.walkCallExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.New,ChildrenWalkers.walkCallExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Asg,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.AsgAdd,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.AsgSub,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,
TypeScript.NodeType.AsgDiv,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.AsgMul,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.AsgMod,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.AsgAnd,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.AsgXor,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,
TypeScript.NodeType.AsgOr,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.AsgLsh,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.AsgRsh,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.AsgRs2,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.ConditionalExpression,ChildrenWalkers.walkTrinaryExpressionChildren);JAM.set(this.childrenWalkers,
TypeScript.NodeType.LogOr,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.LogAnd,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Or,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Xor,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.And,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Eq,
ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Ne,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Eqv,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.NEqv,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Lt,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Le,ChildrenWalkers.walkBinaryExpressionChildren);
JAM.set(this.childrenWalkers,TypeScript.NodeType.Gt,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Ge,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Add,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Sub,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Mul,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,
TypeScript.NodeType.Div,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Mod,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Lsh,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Rsh,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Rs2,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Not,
ChildrenWalkers.walkUnaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.LogNot,ChildrenWalkers.walkUnaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.IncPre,ChildrenWalkers.walkUnaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.DecPre,ChildrenWalkers.walkUnaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.IncPost,ChildrenWalkers.walkUnaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.DecPost,
ChildrenWalkers.walkUnaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.TypeAssertion,ChildrenWalkers.walkUnaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.FuncDecl,ChildrenWalkers.walkFuncDeclChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Member,ChildrenWalkers.walkBinaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.VarDecl,ChildrenWalkers.walkBoundDeclChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.ArgDecl,
ChildrenWalkers.walkBoundDeclChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Return,ChildrenWalkers.walkReturnStatementChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Break,ChildrenWalkers.walkNone);JAM.set(this.childrenWalkers,TypeScript.NodeType.Continue,ChildrenWalkers.walkNone);JAM.set(this.childrenWalkers,TypeScript.NodeType.Throw,ChildrenWalkers.walkUnaryExpressionChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.For,ChildrenWalkers.walkForStatementChildren);JAM.set(this.childrenWalkers,
TypeScript.NodeType.ForIn,ChildrenWalkers.walkForInStatementChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.If,ChildrenWalkers.walkIfStatementChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.While,ChildrenWalkers.walkWhileStatementChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.DoWhile,ChildrenWalkers.walkDoWhileStatementChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Block,ChildrenWalkers.walkBlockChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Case,
ChildrenWalkers.walkCaseStatementChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Switch,ChildrenWalkers.walkSwitchStatementChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Try,ChildrenWalkers.walkTryChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.TryCatch,ChildrenWalkers.walkTryCatchChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.TryFinally,ChildrenWalkers.walkTryFinallyChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Finally,ChildrenWalkers.walkFinallyChildren);
JAM.set(this.childrenWalkers,TypeScript.NodeType.Catch,ChildrenWalkers.walkCatchChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.List,ChildrenWalkers.walkListChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Script,ChildrenWalkers.walkScriptChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.ClassDeclaration,ChildrenWalkers.walkClassDeclChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.InterfaceDeclaration,ChildrenWalkers.walkTypeDeclChildren);JAM.set(this.childrenWalkers,
TypeScript.NodeType.ModuleDeclaration,ChildrenWalkers.walkModuleDeclChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.ImportDeclaration,ChildrenWalkers.walkImportDeclChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.With,ChildrenWalkers.walkWithStatementChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.Label,ChildrenWalkers.walkLabelChildren);JAM.set(this.childrenWalkers,TypeScript.NodeType.LabeledStatement,ChildrenWalkers.walkLabeledStatementChildren);JAM.set(this.childrenWalkers,
TypeScript.NodeType.EBStart,ChildrenWalkers.walkNone);JAM.set(this.childrenWalkers,TypeScript.NodeType.GotoEB,ChildrenWalkers.walkNone);JAM.set(this.childrenWalkers,TypeScript.NodeType.EndCode,ChildrenWalkers.walkNone);JAM.set(this.childrenWalkers,TypeScript.NodeType.Error,ChildrenWalkers.walkNone);JAM.set(this.childrenWalkers,TypeScript.NodeType.Comment,ChildrenWalkers.walkNone);JAM.set(this.childrenWalkers,TypeScript.NodeType.Debugger,ChildrenWalkers.walkNone);for(var e in TypeScript.NodeType._map){var v22566=
this.childrenWalkers;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v22566=v22566[e];if(void 0===v22566)throw Error("initWalkers function is not up to date with enum content!");}}function v329(pre,post,options,state){options||(options=new AstWalkOptions);return JAM.new(AstWalker,[this.childrenWalkers,pre,post,options,state])}function v328(pre,post,options,state){return JAM.call(this.getSlowWalker,this,[pre,post,options,state])}function v327(ast,pre,post,options,state){pre=JAM.call(this.getWalker,
this,[pre,post,options,state]);return JAM.call(pre.walk,pre,[ast,null])}function AstWalkerFactory(){this.childrenWalkers=[];this.initChildrenWalkers()}AstWalkerFactory.prototype.walk=v327;AstWalkerFactory.prototype.getWalker=v328;AstWalkerFactory.prototype.getSlowWalker=v329;AstWalkerFactory.prototype.initChildrenWalkers=v330;return AstWalkerFactory}function v326(){function v325(ast,parent){var preAst=JAM.call(this.pre,this,[ast,parent,this]);void 0===preAst&&(preAst=ast);if(this.options.goChildren){var svGoSib=
this.options.goNextSibling;this.options.goNextSibling=!0;var v11059=this.childrenWalkers;JAM.call(JAM.get(v11059,ast.nodeType,JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074),v11059,[ast,parent,this]);this.options.goNextSibling=svGoSib}else this.options.goChildren=!0;return this.post?(svGoSib=JAM.call(this.post,this,[preAst,parent,this]),void 0===svGoSib&&(svGoSib=preAst),svGoSib):preAst}function AstWalker(childrenWalkers,pre,post,options,state){this.childrenWalkers=childrenWalkers;this.pre=
pre;this.post=post;this.options=options;this.state=state}AstWalker.prototype.walk=v325;return AstWalker}function v324(){function v323(stop){"undefined"===typeof stop&&(stop=!0);this.goChildren=!stop;this.goNextSibling=!stop}function AstWalkOptions(){this.goNextSibling=this.goChildren=!0;this.reverseSiblings=!1}AstWalkOptions.prototype.stopWalk=v323;return AstWalkOptions}function getAstWalkerFactory(){globalAstWalkerFactory||(globalAstWalkerFactory=new AstWalkerFactory);return globalAstWalkerFactory}
var AstWalkOptions=v324();TypeScript.AstWalkOptions=AstWalkOptions;var AstWalker=v326(),AstWalkerFactory=v331();TypeScript.AstWalkerFactory=AstWalkerFactory;var globalAstWalkerFactory;TypeScript.getAstWalkerFactory=getAstWalkerFactory;var ChildrenWalkers,v18230=ChildrenWalkers;v18230||(v18230=ChildrenWalkers={});v332(v18230)}
function v322(){var TypeScript=v18795;function v321(_super){function v320(emitter,tokenId,startLine){JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAM.call(emitter.recordSourceMappingStart,emitter,[this]);JAM.call(emitter.writeLineToOutput,emitter,["debugger;"]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this]);JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function DebuggerStatement(){JAM.call(_super.call,_super,[this,TypeScript.NodeType.Debugger])}JAM.call(__extends,
null,[DebuggerStatement,_super]);DebuggerStatement.prototype.emit=v320;return DebuggerStatement}function v319(_super){function getDocCommentTextOfSignatures(signatures){for(var comments=[],i=0,v11076=i<signatures.length;v11076;){v11076=TypeScript.Comment;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v22568=signatures[i];v11076=JAM.call(v11076.getDocCommentText,v11076,[v22568.declAST.getDocComments()]);""!=v11076&&JAM.call(comments.push,comments,[v11076]);i+=1;v11076=i<signatures.length}return comments.join("\n")}
function getParameterDocCommentText(param,fncDocComments){var v18235=0==fncDocComments.length;v18235||(v18235=!fncDocComments[0].isBlockComment);if(v18235)return"";for(var i=0,v18235=i<fncDocComments.length;v18235;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v18235=fncDocComments[i];for(var v18235=v18235.content,j=v18235.indexOf("@param",0),v11100=0<=j;v11100;)if(j+=6,JAM.call(Comment.isSpaceChar,Comment,[v18235,j])){j=JAM.call(Comment.consumeLeadingSpace,Comment,[v18235,j]);
if(-1==j)break;if(JAM.call(v18235.charCodeAt,v18235,[j])==TypeScript.LexCodeLC){for(var j=j+1,v11100=0,curlies=1,v11085=j<v18235.length;v11085;){v11100=JAM.call(v18235.charCodeAt,v18235,[j]);if(v11100==TypeScript.LexCodeLC)curlies+=1;else{if(v11100==TypeScript.LexCodeRC)if(curlies-=1,0==curlies)break;else{j+=1;v11085=j<v18235.length;continue}if(v11100==TypeScript.LexCodeAtSign)break}j+=1;v11085=j<v18235.length}if(j==v18235.length)break;if(v11100==TypeScript.LexCodeAtSign){j=v18235.indexOf("@param",
j);v11100=0<=j;continue}j=JAM.call(Comment.consumeLeadingSpace,Comment,[v18235,j+1]);if(-1==j)break}(v11100=param!=v18235.substr(j,param.length))||(v11100=!JAM.call(Comment.isSpaceChar,Comment,[v18235,j+param.length]));if(v11100)j=v18235.indexOf("@param",j),v11100=0<=j;else{j=JAM.call(Comment.consumeLeadingSpace,Comment,[v18235,j+param.length]);if(-1==j)return"";i=v18235.indexOf("@",j);i=0>i?v18235.length:i;i=JAM.call(v18235.substring,v18235,[j,i]);v11100=void 0;curlies=JAM.call(v18235.substring,
v18235,[0,j]).lastIndexOf("\n")+1;0!=curlies&&((v11085=curlies<j)&&(v11085="\r"==v18235.charAt(curlies+1)),v11085&&(curlies+=1));curlies=JAM.call(Comment.consumeLeadingSpace,Comment,[v18235,curlies]);(v11085=curlies!=j)&&(v11085="*"==v18235.charAt(curlies));v11085&&(v11100=j-curlies-1);return JAM.call(Comment.cleanJSDocComment,Comment,[i,v11100])}}else j=v18235.indexOf("@param",j),v11100=0<=j;i+=1;v18235=i<fncDocComments.length}return""}function getDocCommentText(comments){for(var docCommentText=
[],c=0,v11104=c<comments.length;v11104;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v11104=comments[c];v11104=v11104.getDocCommentText();""!=v11104&&JAM.call(docCommentText.push,docCommentText,[v11104]);c+=1;v11104=c<comments.length}return docCommentText.join("\n")}function cleanJSDocComment(content,spacesToRemove){var docCommentLines=[];content=content.replace("/**","");var v18258=2<=content.length;v18258&&(v18258="/"==content.charAt(content.length-1))&&(v18258="*"==content.charAt(content.length-
2));v18258&&(content=JAM.call(content.substring,content,[0,content.length-2]));for(var v18258=content.split("\n"),inParamTag=!1,l=0,v11114=l<v18258.length;v11114;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var line=v18258[l];if(v11114=JAM.call(Comment.cleanDocCommentLine,Comment,[line,!0,spacesToRemove])){var docCommentText="",prevPos=v11114.minChar,i=line.indexOf("@",v11114.minChar),v18262=0<=i;for(v18262&&(v18262=i<v11114.limChar);v18262;){var v18262=inParamTag,v18263=line.indexOf("param",
i+1)==i+1;v18263&&(v18263=JAM.call(Comment.isSpaceChar,Comment,[line,i+6]));v18263?(v18262||(docCommentText+=JAM.call(line.substring,line,[prevPos,i])),prevPos=i,inParamTag=!0):v18262&&(prevPos=i,inParamTag=!1);i=line.indexOf("@",i+1);(v18262=0<=i)&&(v18262=i<v11114.limChar)}inParamTag||(docCommentText+=JAM.call(line.substring,line,[prevPos,v11114.limChar]));if(line=JAM.call(Comment.cleanDocCommentLine,Comment,[docCommentText,!1]))void 0==spacesToRemove&&(spacesToRemove=v11114.jsDocSpacesRemoved),
JAM.call(docCommentLines.push,docCommentLines,[docCommentText])}l+=1;v11114=l<v18258.length}return docCommentLines.join("\n")}function cleanDocCommentLine(line,jsDocStyleComment,jsDocLineSpaceToRemove){var nonSpaceIndex=JAM.call(Comment.consumeLeadingSpace,Comment,[line,0]);if(-1!=nonSpaceIndex){var jsDocSpacesRemoved=nonSpaceIndex;jsDocStyleComment&&(jsDocStyleComment="*"==line.charAt(nonSpaceIndex));if(jsDocStyleComment)if(jsDocSpacesRemoved=nonSpaceIndex+1,nonSpaceIndex=JAM.call(Comment.consumeLeadingSpace,
Comment,[line,jsDocSpacesRemoved,jsDocLineSpaceToRemove]),-1!=nonSpaceIndex)jsDocSpacesRemoved=nonSpaceIndex-jsDocSpacesRemoved;else return null;line="\r"==line.charAt(line.length-1)?line.length-1:line.length;return{minChar:nonSpaceIndex,limChar:line,jsDocSpacesRemoved:jsDocSpacesRemoved}}return null}function isSpaceChar(line,index){var length=line.length;if(index<length){var length=JAM.call(line.charCodeAt,line,[index]),v11119=length==TypeScript.LexCodeSpace;v11119||(v11119=length==TypeScript.LexCodeTAB);
return v11119}return index==length}function consumeLeadingSpace(line,startIndex,maxSpacesToRemove){var endIndex=line.length;void 0!=maxSpacesToRemove&&(endIndex=JAM.call(TypeScript.min,TypeScript,[startIndex+maxSpacesToRemove,endIndex]));for(maxSpacesToRemove=startIndex<endIndex;maxSpacesToRemove;){maxSpacesToRemove=JAM.call(line.charCodeAt,line,[startIndex]);var v18276=maxSpacesToRemove!=TypeScript.LexCodeSpace;v18276&&(v18276=maxSpacesToRemove!=TypeScript.LexCodeTAB);if(v18276)return startIndex;
startIndex+=1;maxSpacesToRemove=startIndex<endIndex}return endIndex!=line.length?endIndex:-1}function v318(){if(null==this.docCommentText){var v27400=JAM.call(Comment.cleanJSDocComment,Comment,[this.content]);this.docCommentText=v27400}return this.docCommentText}function v317(){return this.isBlockComment?"*"==this.content.charAt(2):!1}function v316(){if(null==this.text)if(this.isBlockComment){var v27401=this.content.split("\n");this.text=v27401;for(var v27401=0,v11133=v27401<this.text.length;v11133;){var v11133=
this.text,v11132=v27401,v22593=this.text;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v22593=v22593[v27401];v22593=v22593.replace(/^\s+|\s+$/g,"");v11133[v11132]=v22593;v27401+=1;v11133=v27401<this.text.length}}else this.text=[this.content.replace(/^\s+|\s+$/g,"")];return this.text}function Comment(content,isBlockComment,endsLine){JAM.call(_super.call,_super,[this,TypeScript.NodeType.Comment]);this.content=content;this.isBlockComment=isBlockComment;this.endsLine=endsLine;this.docCommentText=
this.text=null}JAM.call(__extends,null,[Comment,_super]);Comment.prototype.getText=v316;Comment.prototype.isDocComment=v317;Comment.prototype.getDocCommentText=v318;Comment.consumeLeadingSpace=consumeLeadingSpace;Comment.isSpaceChar=isSpaceChar;Comment.cleanDocCommentLine=cleanDocCommentLine;Comment.cleanJSDocComment=cleanJSDocComment;Comment.getDocCommentText=getDocCommentText;Comment.getParameterDocCommentText=getParameterDocCommentText;Comment.getDocCommentTextOfSignatures=getDocCommentTextOfSignatures;
return Comment}function v315(_super){function v314(typeFlow){this.body=typeFlow=JAM.call(typeFlow.typeCheck,typeFlow,[this.body]);return this}function v313(context){this.body&&JAM.call(context.walk,context,[this.body,this]);context.walker.options.goChildren=!1;context.noContinuation=!1}function v312(emitter,tokenId,startLine){JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAM.call(emitter.recordSourceMappingStart,emitter,[this]);JAM.call(emitter.writeToOutput,emitter,["finally"]);
JAM.call(emitter.emitJavascript,emitter,[this.body,TypeScript.TokenID.Finally,!1]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this]);JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function Finally(body){JAM.call(_super.call,_super,[this,TypeScript.NodeType.Finally]);this.body=body}JAM.call(__extends,null,[Finally,_super]);Finally.prototype.emit=v312;Finally.prototype.addToControlFlow=v313;Finally.prototype.typeCheck=v314;return Finally}function v311(_super){function v310(typeFlow){var prevScope=
typeFlow.scope;typeFlow.scope=this.containedScope;var v27404=JAM.call(typeFlow.typeCheck,typeFlow,[this.param]);this.param=v27404;var v27404=new TypeScript.ValueLocation,varSym=JAM.new(TypeScript.VariableSymbol,[this.param.id.text,this.param.minChar,typeFlow.checker.locationInfo.unitIndex,v27404]);v27404.symbol=varSym;var varSym=v27404,v27405=new TypeScript.TypeLink;varSym.typeLink=v27405;v27404.typeLink.type=typeFlow.anyType;if(v27405=varSym=typeFlow.thisFnc)v27405=varSym.type;v27404.symbol.container=
v27405?varSym.type.symbol:null;this.param.sym=v27404.symbol;varSym=typeFlow.scope;JAM.call(varSym.enter,varSym,[v27404.symbol.container,this.param,v27404.symbol,typeFlow.checker.errorReporter,!1,!1,!1]);this.body=varSym=JAM.call(typeFlow.typeCheck,typeFlow,[this.body]);typeFlow.checker.inProvisionalTypecheckMode()&&(varSym=typeFlow.scope.getTable(),JAM.set(varSym.secondaryTable.table,v27404.symbol.name,void 0));this.type=typeFlow.voidType;typeFlow.scope=prevScope;return this}function v309(context){if(this.param){JAM.call(context.addContent,
context,[this.param]);var bodBlock=new TypeScript.BasicBlock,v11175=context.current;JAM.call(v11175.addSuccessor,v11175,[bodBlock]);context.current=bodBlock}this.body&&JAM.call(context.walk,context,[this.body,this]);context.noContinuation=!1;context.walker.options.goChildren=!1}function v308(emitter,tokenId,startLine){JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAM.call(emitter.recordSourceMappingStart,emitter,[this]);JAM.call(emitter.writeToOutput,emitter,[" "]);JAM.call(emitter.recordSourceMappingStart,
emitter,[this.statement]);JAM.call(emitter.writeToOutput,emitter,["catch ("]);JAM.call(emitter.emitJavascript,emitter,[this.param,TypeScript.TokenID.OpenParen,!1]);JAM.call(emitter.writeToOutput,emitter,[")"]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this.statement]);JAM.call(emitter.emitJavascript,emitter,[this.body,TypeScript.TokenID.Catch,!1]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this]);JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function Catch(param,body){JAM.call(_super.call,
_super,[this,TypeScript.NodeType.Catch]);this.param=param;this.body=body;var v27407=new ASTSpan;this.statement=v27407;this.containedScope=null;this.param&&(v27407=this.param,v27407.varFlags|=TypeScript.VarFlags.AutoInit)}JAM.call(__extends,null,[Catch,_super]);Catch.prototype.emit=v308;Catch.prototype.addToControlFlow=v309;Catch.prototype.typeCheck=v310;return Catch}function v307(_super){function v306(context){this.body&&JAM.call(context.walk,context,[this.body,this]);context.walker.options.goChildren=
!1;context.noContinuation=!1}function v305(typeFlow){this.body=typeFlow=JAM.call(typeFlow.typeCheck,typeFlow,[this.body]);return this}function v304(emitter,tokenId,startLine){JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAM.call(emitter.recordSourceMappingStart,emitter,[this]);JAM.call(emitter.writeToOutput,emitter,["try "]);JAM.call(emitter.emitJavascript,emitter,[this.body,TypeScript.TokenID.Try,!1]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this]);JAM.call(emitter.emitParensAndCommentsInPlace,
emitter,[this,!1])}function Try(body){JAM.call(_super.call,_super,[this,TypeScript.NodeType.Try]);this.body=body}JAM.call(__extends,null,[Try,_super]);Try.prototype.emit=v304;Try.prototype.typeCheck=v305;Try.prototype.addToControlFlow=v306;return Try}function v303(_super){function v302(typeFlow){var v27409=JAM.call(typeFlow.typeCheck,typeFlow,[this.tryNode]);this.tryNode=v27409;this.catchNode=v27409=JAM.call(typeFlow.typeCheck,typeFlow,[this.catchNode]);this.type=typeFlow.voidType;return this}function v301(context){var beforeTry=
context.current,tryBlock=new TypeScript.BasicBlock;JAM.call(beforeTry.addSuccessor,beforeTry,[tryBlock]);context.current=tryBlock;tryBlock=new TypeScript.BasicBlock;JAM.call(context.pushStatement,context,[this,null,tryBlock]);JAM.call(context.walk,context,[this.tryNode,this]);if(!context.noContinuation&&context.current){var v11207=context.current;JAM.call(v11207.addSuccessor,v11207,[tryBlock])}var v11207=context,v27411=new TypeScript.BasicBlock;v11207.current=v27411;JAM.call(beforeTry.addSuccessor,
beforeTry,[context.current]);JAM.call(context.walk,context,[this.catchNode,this]);context.popStatement();!context.noContinuation&&context.current&&(beforeTry=context.current,JAM.call(beforeTry.addSuccessor,beforeTry,[tryBlock]));context.current=tryBlock;context.walker.options.goChildren=!1}function v300(emitter,tokenId,startLine){JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAM.call(emitter.recordSourceMappingStart,emitter,[this]);JAM.call(emitter.emitJavascript,emitter,[this.tryNode,
TypeScript.TokenID.Try,!1]);JAM.call(emitter.emitJavascript,emitter,[this.catchNode,TypeScript.TokenID.Catch,!1]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this]);JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v299(){return!0}function TryCatch(tryNode,catchNode){JAM.call(_super.call,_super,[this,TypeScript.NodeType.TryCatch]);this.tryNode=tryNode;this.catchNode=catchNode}JAM.call(__extends,null,[TryCatch,_super]);TryCatch.prototype.isCompoundStatement=v299;TryCatch.prototype.emit=
v300;TryCatch.prototype.addToControlFlow=v301;TryCatch.prototype.typeCheck=v302;return TryCatch}function v298(_super){function v297(context){var afterFinally=new TypeScript.BasicBlock;JAM.call(context.walk,context,[this.tryNode,this]);var finBlock=new TypeScript.BasicBlock;if(context.current){var v11229=context.current;JAM.call(v11229.addSuccessor,v11229,[finBlock])}context.current=finBlock;JAM.call(context.pushStatement,context,[this,null,afterFinally]);JAM.call(context.walk,context,[this.finallyNode,
this]);if(finBlock=!context.noContinuation)finBlock=context.current;finBlock&&(finBlock=context.current,JAM.call(finBlock.addSuccessor,finBlock,[afterFinally]));0<afterFinally.predecessors.length?context.current=afterFinally:context.noContinuation=!0;context.popStatement();context.walker.options.goChildren=!1}function v296(typeFlow){var v27412=JAM.call(typeFlow.typeCheck,typeFlow,[this.tryNode]);this.tryNode=v27412;this.finallyNode=v27412=JAM.call(typeFlow.typeCheck,typeFlow,[this.finallyNode]);this.type=
typeFlow.voidType;return this}function v295(emitter,tokenId,startLine){JAM.call(emitter.recordSourceMappingStart,emitter,[this]);JAM.call(emitter.emitJavascript,emitter,[this.tryNode,TypeScript.TokenID.Try,!1]);JAM.call(emitter.emitJavascript,emitter,[this.finallyNode,TypeScript.TokenID.Finally,!1]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this])}function v294(){return!0}function TryFinally(tryNode,finallyNode){JAM.call(_super.call,_super,[this,TypeScript.NodeType.TryFinally]);this.tryNode=
tryNode;this.finallyNode=finallyNode}JAM.call(__extends,null,[TryFinally,_super]);TryFinally.prototype.isCompoundStatement=v294;TryFinally.prototype.emit=v295;TryFinally.prototype.typeCheck=v296;TryFinally.prototype.addToControlFlow=v297;return TryFinally}function v293(_super){function v292(typeFlow){var prevInTCTR=typeFlow.inTypeRefTypeCheck;typeFlow.inTypeRefTypeCheck=!0;var typeLink=JAM.call(TypeScript.getTypeLink,TypeScript,[this,typeFlow.checker,!0]),v11248=typeFlow.checker;JAM.call(v11248.resolveTypeLink,
v11248,[typeFlow.scope,typeLink,!1]);this.term&&JAM.call(typeFlow.typeCheck,typeFlow,[this.term]);JAM.call(typeFlow.checkForVoidConstructor,typeFlow,[typeLink.type,this]);this.type=typeLink.type;this.term&&(this.term.type=this.type);typeFlow.inTypeRefTypeCheck=prevInTCTR;return this}function v291(emitter,tokenId,startLine){throw Error("should not emit a type ref");}function TypeReference(term,arrayCount){JAM.call(_super.call,_super,[this,TypeScript.NodeType.TypeRef]);this.term=term;this.arrayCount=
arrayCount}JAM.call(__extends,null,[TypeReference,_super]);TypeReference.prototype.emit=v291;TypeReference.prototype.typeCheck=v292;return TypeReference}function v290(_super){function v289(context){var execBlock=new TypeScript.BasicBlock,v11259=context.currentSwitch,v11260=context.currentSwitch.length-1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v11259=v11259[v11260];this.expr?(v11260=new TypeScript.BasicBlock,context.current=v11260,JAM.call(v11259.addSuccessor,v11259,[v11260]),
JAM.call(context.addContent,context,[this.expr]),JAM.call(v11260.addSuccessor,v11260,[execBlock])):JAM.call(v11259.addSuccessor,v11259,[execBlock]);context.current=execBlock;this.body&&JAM.call(context.walk,context,[this.body,this]);context.noContinuation=!1;context.walker.options.goChildren=!1}function v288(typeFlow){var v27414=JAM.call(typeFlow.typeCheck,typeFlow,[this.expr]);this.expr=v27414;JAM.call(typeFlow.typeCheck,typeFlow,[this.body]);this.type=typeFlow.voidType;return this}function v287(emitter,
tokenId,startLine){JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAM.call(emitter.recordSourceMappingStart,emitter,[this]);this.expr?(JAM.call(emitter.writeToOutput,emitter,["case "]),JAM.call(emitter.emitJavascript,emitter,[this.expr,TypeScript.TokenID.Identifier,!1])):JAM.call(emitter.writeToOutput,emitter,["default"]);JAM.call(emitter.writeToOutput,emitter,[":"]);(tokenId=1==this.body.members.length)&&(tokenId=this.body.members[0].nodeType==TypeScript.NodeType.Block);tokenId?
JAM.call(emitter.emitJavascriptStatements,emitter,[this.body,!1]):(JAM.call(emitter.writeLineToOutput,emitter,[""]),emitter.indenter.increaseIndent(),JAM.call(emitter.emitBareJavascriptStatements,emitter,[this.body]),emitter.indenter.decreaseIndent());JAM.call(emitter.recordSourceMappingEnd,emitter,[this]);JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function CaseStatement(){JAM.call(_super.call,_super,[this,TypeScript.NodeType.Case]);this.expr=null}JAM.call(__extends,null,[CaseStatement,
_super]);CaseStatement.prototype.emit=v287;CaseStatement.prototype.typeCheck=v288;CaseStatement.prototype.addToControlFlow=v289;return CaseStatement}function v286(_super){function v285(context){var condBlock=context.current;JAM.call(context.addContent,context,[this.val]);var execBlock=new TypeScript.BasicBlock,afterSwitch=new TypeScript.BasicBlock;JAM.call(condBlock.addSuccessor,condBlock,[execBlock]);JAM.call(context.pushSwitch,context,[execBlock]);context.current=execBlock;JAM.call(context.pushStatement,
context,[this,execBlock,afterSwitch]);JAM.call(context.walk,context,[this.caseList,this]);context.popSwitch();context.popStatement();null==this.defaultCase&&JAM.call(condBlock.addSuccessor,condBlock,[afterSwitch]);0<afterSwitch.predecessors.length?(context.noContinuation=!1,context.current=afterSwitch):context.noContinuation=!0;context.walker.options.goChildren=!1}function v284(typeFlow){var len=this.caseList.members.length,v27415=JAM.call(typeFlow.typeCheck,typeFlow,[this.val]);this.val=v27415;for(var v27415=
0,v11293=v27415<len;v11293;){var v11293=this.caseList.members,v11292=v27415,v22606=this.caseList.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v22606=v22606[v27415];v22606=JAM.call(typeFlow.typeCheck,typeFlow,[v22606]);v11293[v11292]=v22606;v27415+=1;v11293=v27415<len}this.defaultCase=len=JAM.call(typeFlow.typeCheck,typeFlow,[this.defaultCase]);this.type=typeFlow.voidType;return this}function v283(emitter,tokenId,startLine){JAM.call(emitter.emitParensAndCommentsInPlace,emitter,
[this,!0]);JAM.call(emitter.recordSourceMappingStart,emitter,[this]);tokenId=JAM.call(emitter.setInObjectLiteral,emitter,[!1]);JAM.call(emitter.recordSourceMappingStart,emitter,[this.statement]);JAM.call(emitter.writeToOutput,emitter,["switch("]);JAM.call(emitter.emitJavascript,emitter,[this.val,TypeScript.TokenID.Identifier,!1]);JAM.call(emitter.writeToOutput,emitter,[")"]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this.statement]);JAM.call(emitter.writeLineToOutput,emitter,[" {"]);emitter.indenter.increaseIndent();
startLine=this.caseList.members.length;for(var i=0,v11303=i<startLine;v11303;){v11303=this.caseList.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v11303=v11303[i];JAM.call(emitter.emitJavascript,emitter,[v11303,TypeScript.TokenID.Case,!0]);i+=1;v11303=i<startLine}emitter.indenter.decreaseIndent();emitter.emitIndent();JAM.call(emitter.writeToOutput,emitter,["}"]);JAM.call(emitter.setInObjectLiteral,emitter,[tokenId]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this]);
JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v282(){return!0}function SwitchStatement(val){JAM.call(_super.call,_super,[this,TypeScript.NodeType.Switch]);this.val=val;this.defaultCase=null;this.statement=val=new ASTSpan}JAM.call(__extends,null,[SwitchStatement,_super]);SwitchStatement.prototype.isCompoundStatement=v282;SwitchStatement.prototype.emit=v283;SwitchStatement.prototype.typeCheck=v284;SwitchStatement.prototype.addToControlFlow=v285;return SwitchStatement}function v281(_super){function v280(typeFlow){return JAM.call(typeFlow.typeCheckWith,
typeFlow,[this])}function v279(emitter,tokenId,startLine){JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAM.call(emitter.recordSourceMappingStart,emitter,[this]);JAM.call(emitter.writeToOutput,emitter,["with ("]);this.expr&&JAM.call(emitter.emitJavascript,emitter,[this.expr,TypeScript.TokenID.With,!1]);JAM.call(emitter.writeToOutput,emitter,[")"]);JAM.call(emitter.emitJavascriptStatements,emitter,[this.body,!0]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this]);JAM.call(emitter.emitParensAndCommentsInPlace,
emitter,[this,!1])}function v278(){return!0}function WithStatement(expr){JAM.call(_super.call,_super,[this,TypeScript.NodeType.With]);this.expr=expr;this.withSym=null}JAM.call(__extends,null,[WithStatement,_super]);WithStatement.prototype.isCompoundStatement=v278;WithStatement.prototype.emit=v279;WithStatement.prototype.typeCheck=v280;return WithStatement}function v277(_super){function v276(context){this.init&&JAM.call(context.addContent,context,[this.init]);var loopHeader=context.current,loopStart=
new TypeScript.BasicBlock,afterLoop=new TypeScript.BasicBlock;JAM.call(loopHeader.addSuccessor,loopHeader,[loopStart]);context.current=loopStart;var loopHeader=null,continueTarget=loopStart,incrBB=null;this.incr&&(continueTarget=incrBB=new TypeScript.BasicBlock);if(this.cond){loopHeader=context.current;JAM.call(context.addContent,context,[this.cond]);var v11325=context,v27419=new TypeScript.BasicBlock;v11325.current=v27419;JAM.call(loopHeader.addSuccessor,loopHeader,[context.current])}this.body&&
(JAM.call(context.pushStatement,context,[this,continueTarget,afterLoop]),JAM.call(context.walk,context,[this.body,this]),context.popStatement());this.incr&&(context.noContinuation?0==incrBB.predecessors.length&&JAM.call(context.addUnreachable,context,[this.incr]):(continueTarget=context.current,JAM.call(continueTarget.addSuccessor,continueTarget,[incrBB]),context.current=incrBB,JAM.call(context.addContent,context,[this.incr])));incrBB=context.current;context.noContinuation||JAM.call(incrBB.addSuccessor,
incrBB,[loopStart]);loopHeader&&(JAM.call(loopHeader.addSuccessor,loopHeader,[afterLoop]),context.noContinuation=!1);0<afterLoop.predecessors.length&&(context.noContinuation=!1,context.current=afterLoop);context.walker.options.goChildren=!1}function v275(typeFlow){return JAM.call(typeFlow.typeCheckFor,typeFlow,[this])}function v274(emitter,tokenId,startLine){JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAM.call(emitter.recordSourceMappingStart,emitter,[this]);tokenId=JAM.call(emitter.setInObjectLiteral,
emitter,[!1]);JAM.call(emitter.writeToOutput,emitter,["for("]);this.init&&(this.init.nodeType!=TypeScript.NodeType.List?JAM.call(emitter.emitJavascript,emitter,[this.init,TypeScript.TokenID.For,!1]):(JAM.call(emitter.setInVarBlock,emitter,[this.init.members.length]),JAM.call(emitter.emitJavascriptList,emitter,[this.init,null,TypeScript.TokenID.For,!1,!1,!1])));JAM.call(emitter.writeToOutput,emitter,["; "]);JAM.call(emitter.emitJavascript,emitter,[this.cond,TypeScript.TokenID.For,!1]);JAM.call(emitter.writeToOutput,
emitter,["; "]);JAM.call(emitter.emitJavascript,emitter,[this.incr,TypeScript.TokenID.For,!1]);JAM.call(emitter.writeToOutput,emitter,[")"]);JAM.call(emitter.emitJavascriptStatements,emitter,[this.body,!0]);JAM.call(emitter.setInObjectLiteral,emitter,[tokenId]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this]);JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v273(){return!0}function ForStatement(init){JAM.call(_super.call,_super,[this,TypeScript.NodeType.For]);this.init=
init}JAM.call(__extends,null,[ForStatement,_super]);ForStatement.prototype.isLoop=v273;ForStatement.prototype.emit=v274;ForStatement.prototype.typeCheck=v275;ForStatement.prototype.addToControlFlow=v276;return ForStatement}function v272(_super){function v271(context){this.lval&&JAM.call(context.addContent,context,[this.lval]);this.obj&&JAM.call(context.addContent,context,[this.obj]);var loopHeader=context.current,loopStart=new TypeScript.BasicBlock,afterLoop=new TypeScript.BasicBlock;JAM.call(loopHeader.addSuccessor,
loopHeader,[loopStart]);context.current=loopStart;this.body&&(JAM.call(context.pushStatement,context,[this,loopStart,afterLoop]),JAM.call(context.walk,context,[this.body,this]),context.popStatement());if(!context.noContinuation){var loopEnd=context.current;JAM.call(loopEnd.addSuccessor,loopEnd,[loopStart])}context.current=afterLoop;context.noContinuation=!1;JAM.call(loopHeader.addSuccessor,loopHeader,[afterLoop]);context.walker.options.goChildren=!1}function v270(typeFlow){if(typeFlow.checker.styleSettings.forin&&
!this.isFiltered()){var v11366=typeFlow.checker.errorReporter;JAM.call(v11366.styleError,v11366,[this,"no hasOwnProperty filter"])}return JAM.call(typeFlow.typeCheckForIn,typeFlow,[this])}function v269(emitter,tokenId,startLine){JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAM.call(emitter.recordSourceMappingStart,emitter,[this]);tokenId=JAM.call(emitter.setInObjectLiteral,emitter,[!1]);JAM.call(emitter.recordSourceMappingStart,emitter,[this.statement]);JAM.call(emitter.writeToOutput,
emitter,["for("]);JAM.call(emitter.emitJavascript,emitter,[this.lval,TypeScript.TokenID.For,!1]);JAM.call(emitter.writeToOutput,emitter,[" in "]);JAM.call(emitter.emitJavascript,emitter,[this.obj,TypeScript.TokenID.For,!1]);JAM.call(emitter.writeToOutput,emitter,[")"]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this.statement]);JAM.call(emitter.emitJavascriptStatements,emitter,[this.body,!0]);JAM.call(emitter.setInObjectLiteral,emitter,[tokenId]);JAM.call(emitter.recordSourceMappingEnd,emitter,
[this]);JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v268(){if(this.body){var singleItem=null;if(this.body.nodeType==TypeScript.NodeType.List){var stmts=this.body;1==stmts.members.length&&(singleItem=stmts.members[0])}else singleItem=this.body;if(null!==singleItem){if(singleItem.nodeType==TypeScript.NodeType.Block){var stmts=singleItem,v18364=null!==stmts.statements;v18364&&(v18364=1==stmts.statements.members.length);v18364&&(singleItem=stmts.statements.members[0])}if(singleItem.nodeType==
TypeScript.NodeType.If&&(singleItem=singleItem.cond,singleItem.nodeType==TypeScript.NodeType.Call&&(stmts=singleItem.target,stmts.nodeType==TypeScript.NodeType.Dot&&((v18364=stmts.operand1.nodeType==TypeScript.NodeType.Name)&&(v18364=this.obj.nodeType==TypeScript.NodeType.Name)&&(v18364=stmts.operand1.actualText==this.obj.actualText),v18364&&(stmts=stmts.operand2,"hasOwnProperty"==stmts.actualText&&(singleItem=singleItem.arguments,(stmts=null!==singleItem)&&(stmts=1==singleItem.members.length),stmts&&
(singleItem=singleItem.members[0],(stmts=singleItem.nodeType==TypeScript.NodeType.Name)&&(stmts=this.lval.nodeType==TypeScript.NodeType.Name),stmts&&this.lval.actualText==singleItem.actualText)))))))return!0}}return!1}function v267(){return!0}function ForInStatement(lval,obj){JAM.call(_super.call,_super,[this,TypeScript.NodeType.ForIn]);this.lval=lval;this.obj=obj;var v27420=new ASTSpan;this.statement=v27420;(v27420=this.lval)&&(v27420=this.lval.nodeType==TypeScript.NodeType.VarDecl);v27420&&(v27420=
this.lval,v27420.varFlags|=TypeScript.VarFlags.AutoInit)}JAM.call(__extends,null,[ForInStatement,_super]);ForInStatement.prototype.isLoop=v267;ForInStatement.prototype.isFiltered=v268;ForInStatement.prototype.emit=v269;ForInStatement.prototype.typeCheck=v270;ForInStatement.prototype.addToControlFlow=v271;return ForInStatement}function v266(_super){function EndCode(){JAM.call(_super.call,_super,[this,TypeScript.NodeType.EndCode])}JAM.call(__extends,null,[EndCode,_super]);return EndCode}function v265(_super){function v264(typeFlow){return JAM.call(typeFlow.typeCheckReturn,
typeFlow,[this])}function v263(context){var v11402=_super.prototype.addToControlFlow;JAM.call(v11402.call,v11402,[this,context]);context.returnStmt()}function v262(emitter,tokenId,startLine){JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAM.call(emitter.recordSourceMappingStart,emitter,[this]);tokenId=JAM.call(emitter.setInObjectLiteral,emitter,[!1]);this.returnExpression?(JAM.call(emitter.writeToOutput,emitter,["return "]),JAM.call(emitter.emitJavascript,emitter,[this.returnExpression,
TypeScript.TokenID.Semicolon,!1]),this.returnExpression.nodeType===TypeScript.NodeType.FuncDecl&&JAM.call(emitter.writeToOutput,emitter,[";"])):JAM.call(emitter.writeToOutput,emitter,["return;"]);JAM.call(emitter.setInObjectLiteral,emitter,[tokenId]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this]);JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function ReturnStatement(){JAM.call(_super.call,_super,[this,TypeScript.NodeType.Return]);this.returnExpression=null}JAM.call(__extends,
null,[ReturnStatement,_super]);ReturnStatement.prototype.emit=v262;ReturnStatement.prototype.addToControlFlow=v263;ReturnStatement.prototype.typeCheck=v264;return ReturnStatement}function v261(_super){function v260(context){var v11411=this.cond;JAM.call(v11411.addToControlFlow,v11411,[context]);var v11411=new TypeScript.BasicBlock,beforeIf=context.current;JAM.call(context.pushStatement,context,[this,beforeIf,v11411]);var hasContinuation=!1,v11413=context,v27421=new TypeScript.BasicBlock;v11413.current=
v27421;JAM.call(beforeIf.addSuccessor,beforeIf,[context.current]);JAM.call(context.walk,context,[this.thenBod,this]);context.noContinuation||(hasContinuation=!0,v11413=context.current,JAM.call(v11413.addSuccessor,v11413,[v11411]));this.elseBod?(v11413=context,v27421=new TypeScript.BasicBlock,v11413.current=v27421,context.noContinuation=!1,JAM.call(beforeIf.addSuccessor,beforeIf,[context.current]),JAM.call(context.walk,context,[this.elseBod,this]),context.noContinuation)?hasContinuation&&(context.noContinuation=
!1):(hasContinuation=!0,beforeIf=context.current,JAM.call(beforeIf.addSuccessor,beforeIf,[v11411])):(JAM.call(beforeIf.addSuccessor,beforeIf,[v11411]),context.noContinuation=!1,hasContinuation=!0);context.popStatement();0<v11411.predecessors.length&&(context.noContinuation=!1,hasContinuation=!0);hasContinuation&&(context.current=v11411);context.walker.options.goChildren=!1}function v259(typeFlow){return JAM.call(typeFlow.typeCheckIf,typeFlow,[this])}function v258(emitter,tokenId,startLine){JAM.call(emitter.emitParensAndCommentsInPlace,
emitter,[this,!0]);JAM.call(emitter.recordSourceMappingStart,emitter,[this]);startLine=JAM.call(emitter.setInObjectLiteral,emitter,[!1]);JAM.call(emitter.recordSourceMappingStart,emitter,[this.statement]);JAM.call(emitter.writeToOutput,emitter,["if("]);JAM.call(emitter.emitJavascript,emitter,[this.cond,TypeScript.TokenID.If,!1]);JAM.call(emitter.writeToOutput,emitter,[")"]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this.statement]);JAM.call(emitter.emitJavascriptStatements,emitter,[this.thenBod,
!0]);if(this.elseBod)if(this.elseBod.nodeType===TypeScript.NodeType.If){JAM.call(emitter.writeToOutput,emitter,[" else "]);var v11431=this.elseBod;JAM.call(v11431.emit,v11431,[emitter,tokenId,!1])}else JAM.call(emitter.writeToOutput,emitter,[" else"]),JAM.call(emitter.emitJavascriptStatements,emitter,[this.elseBod,!0]);JAM.call(emitter.setInObjectLiteral,emitter,[startLine]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this]);JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v257(){return!0}
function IfStatement(cond){JAM.call(_super.call,_super,[this,TypeScript.NodeType.If]);this.cond=cond;this.elseBod=null;this.statement=cond=new ASTSpan}JAM.call(__extends,null,[IfStatement,_super]);IfStatement.prototype.isCompoundStatement=v257;IfStatement.prototype.emit=v258;IfStatement.prototype.typeCheck=v259;IfStatement.prototype.addToControlFlow=v260;return IfStatement}function v256(_super){function v255(context){var loopHeader=context.current,loopStart=new TypeScript.BasicBlock,afterLoop=new TypeScript.BasicBlock;
JAM.call(loopHeader.addSuccessor,loopHeader,[loopStart]);context.current=loopStart;this.body&&(JAM.call(context.pushStatement,context,[this,loopStart,afterLoop]),JAM.call(context.walk,context,[this.body,this]),context.popStatement());context.noContinuation?JAM.call(context.addUnreachable,context,[this.cond]):(loopHeader=context.current,JAM.call(loopHeader.addSuccessor,loopHeader,[loopStart]),JAM.call(context.addContent,context,[this.cond]),context.current=afterLoop,JAM.call(loopHeader.addSuccessor,
loopHeader,[afterLoop]));context.walker.options.goChildren=!1}function v254(typeFlow){return JAM.call(typeFlow.typeCheckDoWhile,typeFlow,[this])}function v253(emitter,tokenId,startLine){JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAM.call(emitter.recordSourceMappingStart,emitter,[this]);tokenId=JAM.call(emitter.setInObjectLiteral,emitter,[!1]);JAM.call(emitter.writeToOutput,emitter,["do"]);JAM.call(emitter.emitJavascriptStatements,emitter,[this.body,!0]);JAM.call(emitter.recordSourceMappingStart,
emitter,[this.whileAST]);JAM.call(emitter.writeToOutput,emitter,["while"]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this.whileAST]);JAM.call(emitter.writeToOutput,emitter,["("]);JAM.call(emitter.emitJavascript,emitter,[this.cond,TypeScript.TokenID.CloseParen,!1]);JAM.call(emitter.writeToOutput,emitter,[")"]);JAM.call(emitter.setInObjectLiteral,emitter,[tokenId]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this]);JAM.call(emitter.writeToOutput,emitter,[";"]);JAM.call(emitter.emitParensAndCommentsInPlace,
emitter,[this,!1])}function v252(){return!0}function DoWhileStatement(){JAM.call(_super.call,_super,[this,TypeScript.NodeType.DoWhile]);this.cond=this.whileAST=this.body=null}JAM.call(__extends,null,[DoWhileStatement,_super]);DoWhileStatement.prototype.isLoop=v252;DoWhileStatement.prototype.emit=v253;DoWhileStatement.prototype.typeCheck=v254;DoWhileStatement.prototype.addToControlFlow=v255;return DoWhileStatement}function v251(_super){function v250(context){var loopHeader=context.current,loopStart=
new TypeScript.BasicBlock,afterLoop=new TypeScript.BasicBlock;JAM.call(loopHeader.addSuccessor,loopHeader,[loopStart]);context.current=loopStart;JAM.call(context.addContent,context,[this.cond]);loopHeader=context.current;if(this.body){var v11461=context,v27424=new TypeScript.BasicBlock;v11461.current=v27424;JAM.call(loopHeader.addSuccessor,loopHeader,[context.current]);JAM.call(context.pushStatement,context,[this,loopStart,afterLoop]);JAM.call(context.walk,context,[this.body,this]);context.popStatement()}context.noContinuation||
(v11461=context.current,JAM.call(v11461.addSuccessor,v11461,[loopStart]));context.current=afterLoop;JAM.call(loopHeader.addSuccessor,loopHeader,[afterLoop]);context.noContinuation=!1;context.walker.options.goChildren=!1}function v249(typeFlow){return JAM.call(typeFlow.typeCheckWhile,typeFlow,[this])}function v248(emitter,tokenId,startLine){JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAM.call(emitter.recordSourceMappingStart,emitter,[this]);tokenId=JAM.call(emitter.setInObjectLiteral,
emitter,[!1]);JAM.call(emitter.writeToOutput,emitter,["while("]);JAM.call(emitter.emitJavascript,emitter,[this.cond,TypeScript.TokenID.While,!1]);JAM.call(emitter.writeToOutput,emitter,[")"]);JAM.call(emitter.emitJavascriptStatements,emitter,[this.body,!1]);JAM.call(emitter.setInObjectLiteral,emitter,[tokenId]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this]);JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v247(){return!0}function WhileStatement(cond){JAM.call(_super.call,
_super,[this,TypeScript.NodeType.While]);this.cond=cond;this.body=null}JAM.call(__extends,null,[WhileStatement,_super]);WhileStatement.prototype.isLoop=v247;WhileStatement.prototype.emit=v248;WhileStatement.prototype.typeCheck=v249;WhileStatement.prototype.addToControlFlow=v250;return WhileStatement}function v246(_super){function v245(emitter,tokenId,startLine){JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAM.call(emitter.recordSourceMappingStart,emitter,[this]);this.nodeType==
TypeScript.NodeType.Break?JAM.call(emitter.writeToOutput,emitter,["break"]):JAM.call(emitter.writeToOutput,emitter,["continue"]);this.target&&JAM.call(emitter.writeToOutput,emitter,[" "+this.target]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this]);JAM.call(emitter.writeToOutput,emitter,[";"]);JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v244(context){var v11478=_super.prototype.addToControlFlow;JAM.call(v11478.call,v11478,[this,context]);JAM.call(context.unconditionalBranch,
context,[this.resolvedTarget,this.nodeType==TypeScript.NodeType.Continue])}function v243(parser,stmt){if(stmt.isLoop())return this.resolvedTarget=stmt,!0;if(this.nodeType===TypeScript.NodeType.Continue)return JAM.call(parser.reportParseError,parser,["continue statement applies only to loops"]),!1;var v18413=stmt.nodeType==TypeScript.NodeType.Switch;v18413||(v18413=this.target);if(v18413)return this.resolvedTarget=stmt,!0;JAM.call(parser.reportParseError,parser,["break statement with no label can apply only to a loop or switch statement"]);
return!1}function v242(){return this.target}function Jump(nodeType){JAM.call(_super.call,_super,[this,nodeType]);this.resolvedTarget=this.target=null}JAM.call(__extends,null,[Jump,_super]);Jump.prototype.hasExplicitTarget=v242;Jump.prototype.setResolvedTarget=v243;Jump.prototype.addToControlFlow=v244;Jump.prototype.emit=v245;return Jump}function v241(_super){function v240(typeFlow){if(!typeFlow.checker.styleSettings.emptyBlocks){var v18415=null===this.statements;v18415||(v18415=0==this.statements.members.length);
v18415&&(v18415=typeFlow.checker.errorReporter,JAM.call(v18415.styleError,v18415,[this,"empty block"]))}JAM.call(typeFlow.typeCheck,typeFlow,[this.statements]);return this}function v239(context){var afterIfNeeded=new TypeScript.BasicBlock;JAM.call(context.pushStatement,context,[this,context.current,afterIfNeeded]);this.statements&&JAM.call(context.walk,context,[this.statements,this]);context.walker.options.goChildren=!1;context.popStatement();if(0<afterIfNeeded.predecessors.length){var v11497=context.current;
JAM.call(v11497.addSuccessor,v11497,[afterIfNeeded]);context.current=afterIfNeeded}}function v238(emitter,tokenId,startLine){JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAM.call(emitter.recordSourceMappingStart,emitter,[this]);this.isStatementBlock?(JAM.call(emitter.writeLineToOutput,emitter,[" {"]),emitter.indenter.increaseIndent()):JAM.call(emitter.setInVarBlock,emitter,[this.statements.members.length]);tokenId=JAM.call(emitter.setInObjectLiteral,emitter,[!1]);this.statements&&
JAM.call(emitter.emitJavascriptList,emitter,[this.statements,null,TypeScript.TokenID.Semicolon,!0,!1,!1]);this.isStatementBlock&&(emitter.indenter.decreaseIndent(),emitter.emitIndent(),JAM.call(emitter.writeToOutput,emitter,["}"]));JAM.call(emitter.setInObjectLiteral,emitter,[tokenId]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this]);JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function Block(statements,isStatementBlock){JAM.call(_super.call,_super,[this,TypeScript.NodeType.Block]);
this.statements=statements;this.isStatementBlock=isStatementBlock}JAM.call(__extends,null,[Block,_super]);Block.prototype.emit=v238;Block.prototype.addToControlFlow=v239;Block.prototype.typeCheck=v240;return Block}function v237(_super){function v236(context){var beforeBB=context.current,bb=new TypeScript.BasicBlock;context.current=bb;JAM.call(beforeBB.addSuccessor,beforeBB,[bb])}function v235(typeFlow){JAM.call(typeFlow.typeCheck,typeFlow,[this.labels]);var v11513=this.stmt;this.stmt=typeFlow=JAM.call(v11513.typeCheck,
v11513,[typeFlow]);return this}function v234(emitter,tokenId,startLine){JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAM.call(emitter.recordSourceMappingStart,emitter,[this]);if(this.labels)for(var labelsLen=this.labels.members.length,i=0,v11516=i<labelsLen;v11516;){v11516=this.labels.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v11516=v11516[i];JAM.call(v11516.emit,v11516,[emitter,tokenId,startLine]);i+=1;v11516=i<labelsLen}startLine=this.stmt;JAM.call(startLine.emit,
startLine,[emitter,tokenId,!0]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this]);JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function LabeledStatement(labels,stmt){JAM.call(_super.call,_super,[this,TypeScript.NodeType.LabeledStatement]);this.labels=labels;this.stmt=stmt}JAM.call(__extends,null,[LabeledStatement,_super]);LabeledStatement.prototype.emit=v234;LabeledStatement.prototype.typeCheck=v235;LabeledStatement.prototype.addToControlFlow=v236;return LabeledStatement}
function v233(_super){function v232(typeFlow){this.type=typeFlow.voidType;return this}function v231(){return this.isLoop()}function v230(){return!0}function v229(){return!1}function Statement(nodeType){JAM.call(_super.call,_super,[this,nodeType]);this.flags|=TypeScript.ASTFlags.IsStatement}JAM.call(__extends,null,[Statement,_super]);Statement.prototype.isLoop=v229;Statement.prototype.isStatementOrExpression=v230;Statement.prototype.isCompoundStatement=v231;Statement.prototype.typeCheck=v232;return Statement}
function v228(_super){function v227(emitter,tokenId,startLine){}function v226(typeFlow){return JAM.call(typeFlow.typeCheckInterface,typeFlow,[this])}function InterfaceDeclaration(name,members,extendsList,implementsList){JAM.call(_super.call,_super,[this,TypeScript.NodeType.InterfaceDeclaration,name,extendsList,implementsList,members])}JAM.call(__extends,null,[InterfaceDeclaration,_super]);InterfaceDeclaration.prototype.typeCheck=v226;InterfaceDeclaration.prototype.emit=v227;return InterfaceDeclaration}
function v225(_super){function v224(emitter,tokenId,startLine){JAM.call(emitter.emitJavascriptClass,emitter,[this])}function v223(typeFlow){return JAM.call(typeFlow.typeCheckClass,typeFlow,[this])}function ClassDeclaration(name,members,extendsList,implementsList){JAM.call(_super.call,_super,[this,TypeScript.NodeType.ClassDeclaration,name,extendsList,implementsList,members]);this.knownMemberNames={};this.constructorDecl=null;this.constructorNestingLevel=0;this.endingToken=null}JAM.call(__extends,null,
[ClassDeclaration,_super]);ClassDeclaration.prototype.typeCheck=v223;ClassDeclaration.prototype.emit=v224;return ClassDeclaration}function v222(_super){function v221(){return JAM.call(TypeScript.hasFlag,TypeScript,[this.varFlags,TypeScript.VarFlags.Ambient])}function v220(){return JAM.call(TypeScript.hasFlag,TypeScript,[this.varFlags,TypeScript.VarFlags.Exported])}function TypeDeclaration(nodeType,name,extendsList,implementsList,members){JAM.call(_super.call,_super,[this,nodeType,name,members]);this.extendsList=
extendsList;this.implementsList=implementsList;this.varFlags=TypeScript.VarFlags.None}JAM.call(__extends,null,[TypeDeclaration,_super]);TypeDeclaration.prototype.isExported=v220;TypeDeclaration.prototype.isAmbient=v221;return TypeDeclaration}function v219(_super){function v218(emitter,tokenId,startLine){JAM.call(TypeScript.hasFlag,TypeScript,[this.modFlags,TypeScript.ModuleFlags.ShouldEmitModuleDecl])||(JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]),JAM.call(emitter.recordSourceMappingStart,
emitter,[this]),JAM.call(emitter.emitJavascriptModule,emitter,[this]),JAM.call(emitter.recordSourceMappingEnd,emitter,[this]),JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1]))}function v217(typeFlow){return JAM.call(typeFlow.typeCheckModule,typeFlow,[this])}function v216(){this.modFlags&=~TypeScript.ModuleFlags.ShouldEmitModuleDecl}function v215(){return JAM.call(TypeScript.hasFlag,TypeScript,[this.modFlags,TypeScript.ModuleFlags.IsEnum])}function v214(){return JAM.call(TypeScript.hasFlag,
TypeScript,[this.modFlags,TypeScript.ModuleFlags.Ambient])}function v213(){return JAM.call(TypeScript.hasFlag,TypeScript,[this.modFlags,TypeScript.ModuleFlags.Exported])}function ModuleDeclaration(name,members,vars,scopes,endingToken){JAM.call(_super.call,_super,[this,TypeScript.NodeType.ModuleDeclaration,name,members]);this.endingToken=endingToken;this.modFlags=TypeScript.ModuleFlags.ShouldEmitModuleDecl;this.amdDependencies=[];this.containsUnicodeCharInComment=this.containsUnicodeChar=!1;this.vars=
vars;this.scopes=scopes;this.prettyName=this.name.actualText}JAM.call(__extends,null,[ModuleDeclaration,_super]);ModuleDeclaration.prototype.isExported=v213;ModuleDeclaration.prototype.isAmbient=v214;ModuleDeclaration.prototype.isEnum=v215;ModuleDeclaration.prototype.recordNonInterface=v216;ModuleDeclaration.prototype.typeCheck=v217;ModuleDeclaration.prototype.emit=v218;return ModuleDeclaration}function v212(_super){function v211(){return!0}function NamedDeclaration(nodeType,name,members){JAM.call(_super.call,
_super,[this,nodeType]);this.name=name;this.members=members;this.rightCurlyCount=this.leftCurlyCount=0}JAM.call(__extends,null,[NamedDeclaration,_super]);NamedDeclaration.prototype.isDeclaration=v211;return NamedDeclaration}function v210(_super){function v209(symbol){for(var i=0,v11558=i<this.externallyVisibleImportedSymbols.length;v11558;){v11558=this.externallyVisibleImportedSymbols;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v11558=v11558[i];if(v11558==symbol)return!0;i+=1;
v11558=i<this.externallyVisibleImportedSymbols.length}return!1}function v208(symbol,checker){if(!JAM.call(this.isExternallyVisibleSymbol,this,[symbol])){var v22660=symbol.getType().symbol;if(!JAM.call(v22660.isExternallyVisible,v22660,[checker])){var v22660="",moduleName=symbol.getType().symbol.prettyName;JAM.call(TypeScript.isQuoted,TypeScript,[moduleName])||(v22660="'");var v11562=checker.errorReporter;JAM.call(v11562.simpleError,v11562,[symbol.declAST,"Externally visible import statement uses non exported module "+
v22660+moduleName+v22660])}v22660=this.externallyVisibleImportedSymbols;JAM.call(v22660.push,v22660,[symbol])}}function v207(emitter,tokenId,startLine){JAM.call(this.emitRequired,this,[emitter.emitOptions])&&(JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this.bod,!0]),JAM.call(emitter.emitJavascriptList,emitter,[this.bod,null,TypeScript.TokenID.Semicolon,!0,!1,!1,!0,this.requiresExtendsBlock]),JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this.bod,!1]))}function v206(emitOptions){if(void 0!=
this.cachedEmitRequired)return this.cachedEmitRequired;var v18448=!this.isDeclareFile;v18448&&(v18448=!this.isResident)&&(v18448=this.bod);if(v18448){for(var v18448=0,len=this.bod.members.length,v11585=v18448<len;v11585;){v11585=this.bod.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v11585=v11585[v18448];if(v11585.nodeType==TypeScript.NodeType.ModuleDeclaration){if(!JAM.call(TypeScript.hasFlag,TypeScript,[v11585.modFlags,TypeScript.ModuleFlags.ShouldEmitModuleDecl|TypeScript.ModuleFlags.Ambient]))return JAM.call(this.setCachedEmitRequired,
this,[!0])}else if(v11585.nodeType==TypeScript.NodeType.ClassDeclaration){if(!JAM.call(TypeScript.hasFlag,TypeScript,[v11585.varFlags,TypeScript.VarFlags.Ambient]))return JAM.call(this.setCachedEmitRequired,this,[!0])}else if(v11585.nodeType==TypeScript.NodeType.VarDecl){if(!JAM.call(TypeScript.hasFlag,TypeScript,[v11585.varFlags,TypeScript.VarFlags.Ambient]))return JAM.call(this.setCachedEmitRequired,this,[!0])}else if(v11585.nodeType==TypeScript.NodeType.FuncDecl){if(!v11585.isSignature())return JAM.call(this.setCachedEmitRequired,
this,[!0])}else{var v18463=v11585.nodeType!=TypeScript.NodeType.InterfaceDeclaration;v18463&&(v18463=v11585.nodeType!=TypeScript.NodeType.Empty);if(v18463)return JAM.call(this.setCachedEmitRequired,this,[!0])}v18448+=1;v11585=v18448<len}if(emitOptions=emitOptions.emitComments)(emitOptions=this.bod.preComments)&&(emitOptions=0<this.bod.preComments.length),emitOptions||(emitOptions=this.bod.postComments)&&(emitOptions=0<this.bod.postComments.length);if(emitOptions)return JAM.call(this.setCachedEmitRequired,
this,[!0])}return JAM.call(this.setCachedEmitRequired,this,[!1])}function v205(){return"Script"}function v204(typeFlow){return JAM.call(typeFlow.typeCheckScript,typeFlow,[this])}function v203(value){return this.cachedEmitRequired=value}function Script(vars,scopes){JAM.call(_super.call,_super,[this,JAM.new(Identifier,["script"]),null,!1,null,vars,scopes,null,TypeScript.NodeType.Script]);this.locationInfo=null;this.referencedFiles=[];this.hasBeenTypeChecked=this.isDeclareFile=this.isResident=this.requiresExtendsBlock=
this.requiresGlobal=!1;this.topLevelMod=null;this.rightCurlyCount=this.leftCurlyCount=0;this.containsUnicodeCharInComment=this.containsUnicodeChar=!1;this.externallyVisibleImportedSymbols=[];this.vars=vars;this.scopes=scopes}JAM.call(__extends,null,[Script,_super]);Script.prototype.setCachedEmitRequired=v203;Script.prototype.typeCheck=v204;Script.prototype.treeViewLabel=v205;Script.prototype.emitRequired=v206;Script.prototype.emit=v207;Script.prototype.AddExternallyVisibleImportedSymbol=v208;Script.prototype.isExternallyVisibleSymbol=
v209;return Script}function v202(){function LocationInfo(filename,lineMap,unitIndex){this.filename=filename;this.lineMap=lineMap;this.unitIndex=unitIndex}return LocationInfo}function v201(_super){function v200(){return(this.fncFlags&TypeScript.FncFlags.Signature)!=TypeScript.FncFlags.None}function v199(){this.fncFlags=TypeScript.FncFlags.None}function v198(){return null==this.name?"funcExpr":"func: "+this.name.actualText}function v197(){return JAM.call(TypeScript.hasFlag,TypeScript,[this.fncFlags,
TypeScript.FncFlags.Static])}function v196(){return JAM.call(TypeScript.hasFlag,TypeScript,[this.fncFlags,TypeScript.FncFlags.Public])}function v195(){return JAM.call(TypeScript.hasFlag,TypeScript,[this.fncFlags,TypeScript.FncFlags.Private])}function v194(){return JAM.call(TypeScript.hasFlag,TypeScript,[this.fncFlags,TypeScript.FncFlags.Exported])}function v193(){return JAM.call(TypeScript.hasFlag,TypeScript,[this.fncFlags,TypeScript.FncFlags.Ambient])}function v192(){return JAM.call(TypeScript.hasFlag,
TypeScript,[this.fncFlags,TypeScript.FncFlags.SetAccessor])}function v191(){return JAM.call(TypeScript.hasFlag,TypeScript,[this.fncFlags,TypeScript.FncFlags.GetAccessor])}function v190(){var v11616=JAM.call(TypeScript.hasFlag,TypeScript,[this.fncFlags,TypeScript.FncFlags.GetAccessor]);v11616||(v11616=JAM.call(TypeScript.hasFlag,TypeScript,[this.fncFlags,TypeScript.FncFlags.SetAccessor]));return v11616}function v189(){return null===this.name}function v188(){var v11618=this.isCallMember();v11618||(v11618=
this.isIndexerMember())||(v11618=this.isConstructMember());return v11618}function v187(){return JAM.call(TypeScript.hasFlag,TypeScript,[this.fncFlags,TypeScript.FncFlags.IndexerMember])}function v186(){return JAM.call(TypeScript.hasFlag,TypeScript,[this.fncFlags,TypeScript.FncFlags.ConstructMember])}function v185(){return JAM.call(TypeScript.hasFlag,TypeScript,[this.fncFlags,TypeScript.FncFlags.CallMember])}function v184(){return(this.fncFlags&TypeScript.FncFlags.Method)!=TypeScript.FncFlags.None}
function v183(){return this.name?this.name.actualText:this.hint}function v182(emitter,tokenId,startLine){JAM.call(emitter.emitJavascriptFunction,emitter,[this])}function v181(typeFlow){return JAM.call(typeFlow.typeCheckFunction,typeFlow,[this])}function v180(){function controlFlowPrefix(ast,parent,walker){JAM.call(ast.addToControlFlow,ast,[walker.state]);return ast}var entry=new TypeScript.BasicBlock,exit=new TypeScript.BasicBlock,entry=JAM.new(TypeScript.ControlFlowContext,[entry,exit]),exit=TypeScript.getAstWalkerFactory(),
exit=JAM.call(exit.getWalker,exit,[controlFlowPrefix,null,null,entry]);entry.walker=exit;JAM.call(exit.walk,exit,[this.bod,this]);return entry}function v179(sym){if(null==this.jumpRefs){var v27426=[];this.jumpRefs=v27426}v27426=JAM.new(Identifier,[sym.name]);JAM.set(this.jumpRefs,this.jumpRefs.length,v27426);v27426.sym=sym;sym=v27426;v27426=JAM.call(this.addCloRef,this,[v27426,null]);sym.cloId=v27426}function v178(id,sym){if(null==this.envids){var v27428=[];this.envids=v27428}JAM.set(this.envids,
this.envids.length,id);v27428=this.enclosingFnc;if(sym){var v18495=v27428;for(v18495&&(v18495=v27428.type.symbol!=sym.container);v18495;)JAM.call(v27428.addJumpRef,v27428,[sym]),(v18495=v27428=v27428.enclosingFnc)&&(v18495=v27428.type.symbol!=sym.container)}return this.envids.length-1}function v177(){this.fncFlags|=TypeScript.FncFlags.HasSuperReferenceInFatArrowFunction}function v176(){return JAM.call(TypeScript.hasFlag,TypeScript,[this.fncFlags,TypeScript.FncFlags.HasSuperReferenceInFatArrowFunction])}
function v175(){this.fncFlags|=TypeScript.FncFlags.HasSelfReference}function v174(){return JAM.call(TypeScript.hasFlag,TypeScript,[this.fncFlags,TypeScript.FncFlags.HasSelfReference])}function v173(){if(null==this.internalNameCache){var extName=this.getNameText();extName||(extName=internalId,internalId+=1);this.internalNameCache="_internal_"+extName}return this.internalNameCache}function v172(){return!0}function FuncDecl(name,bod,isConstructor,args,vars,scopes,statics,nodeType){JAM.call(_super.call,
_super,[this,nodeType]);this.name=name;this.bod=bod;this.isConstructor=isConstructor;this.arguments=args;this.vars=vars;this.scopes=scopes;this.statics=statics;this.hint=null;this.fncFlags=TypeScript.FncFlags.None;this.returnTypeAnnotation=null;this.variableArgList=!1;this.internalNameCache=this.jumpRefs=null;this.tmp1Declared=!1;this.enclosingFnc=null;this.freeVariables=[];this.unitIndex=-1;this.boundToProperty=this.classDecl=null;this.isOverload=!1;this.innerStaticFuncs=[];this.isInlineCallLiteral=
this.isTargetTypedAsMethod=!1;this.accessorSymbol=null;this.rightCurlyCount=this.leftCurlyCount=0;this.returnStatementsWithExpressions=[];this.endingToken=this.scopeType=null}JAM.call(__extends,null,[FuncDecl,_super]);FuncDecl.prototype.isDeclaration=v172;FuncDecl.prototype.internalName=v173;FuncDecl.prototype.hasSelfReference=v174;FuncDecl.prototype.setHasSelfReference=v175;FuncDecl.prototype.hasSuperReferenceInFatArrowFunction=v176;FuncDecl.prototype.setHasSuperReferenceInFatArrowFunction=v177;
FuncDecl.prototype.addCloRef=v178;FuncDecl.prototype.addJumpRef=v179;FuncDecl.prototype.buildControlFlow=v180;FuncDecl.prototype.typeCheck=v181;FuncDecl.prototype.emit=v182;FuncDecl.prototype.getNameText=v183;FuncDecl.prototype.isMethod=v184;FuncDecl.prototype.isCallMember=v185;FuncDecl.prototype.isConstructMember=v186;FuncDecl.prototype.isIndexerMember=v187;FuncDecl.prototype.isSpecialFn=v188;FuncDecl.prototype.isAnonymousFn=v189;FuncDecl.prototype.isAccessor=v190;FuncDecl.prototype.isGetAccessor=
v191;FuncDecl.prototype.isSetAccessor=v192;FuncDecl.prototype.isAmbient=v193;FuncDecl.prototype.isExported=v194;FuncDecl.prototype.isPrivate=v195;FuncDecl.prototype.isPublic=v196;FuncDecl.prototype.isStatic=v197;FuncDecl.prototype.treeViewLabel=v198;FuncDecl.prototype.ClearFlags=v199;FuncDecl.prototype.isSignature=v200;return FuncDecl}function v171(_super){function v170(emitter,tokenId,startLine){JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAM.call(emitter.recordSourceMappingStart,
emitter,[this]);JAM.call(emitter.writeToOutput,emitter,[this.id.actualText]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this]);JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v169(){return"arg: "+this.id.actualText}function v168(){var v11683=this.isOptional;v11683||(v11683=this.init);return v11683}function ArgDecl(id){JAM.call(_super.call,_super,[this,id,TypeScript.NodeType.ArgDecl,0]);this.isOptional=!1;this.parameterPropertySym=null}JAM.call(__extends,null,[ArgDecl,
_super]);ArgDecl.prototype.isOptionalArg=v168;ArgDecl.prototype.treeViewLabel=v169;ArgDecl.prototype.emit=v170;return ArgDecl}function v167(_super){function v166(){return"var "+this.id.actualText}function v165(emitter,tokenId,startLine){JAM.call(emitter.emitJavascriptVarDecl,emitter,[this,tokenId])}function v164(){return JAM.call(TypeScript.hasFlag,TypeScript,[this.varFlags,TypeScript.VarFlags.Static])}function v163(){return JAM.call(TypeScript.hasFlag,TypeScript,[this.varFlags,TypeScript.VarFlags.Exported])}
function v162(){return JAM.call(TypeScript.hasFlag,TypeScript,[this.varFlags,TypeScript.VarFlags.Ambient])}function VarDecl(id,nest){JAM.call(_super.call,_super,[this,id,TypeScript.NodeType.VarDecl,nest])}JAM.call(__extends,null,[VarDecl,_super]);VarDecl.prototype.isAmbient=v162;VarDecl.prototype.isExported=v163;VarDecl.prototype.isStatic=v164;VarDecl.prototype.emit=v165;VarDecl.prototype.treeViewLabel=v166;return VarDecl}function v161(_super){function v160(){return this.treeViewLabel()}function v159(typeFlow){return JAM.call(typeFlow.typeCheckBoundDecl,
typeFlow,[this])}function v158(){return JAM.call(TypeScript.hasFlag,TypeScript,[this.varFlags,TypeScript.VarFlags.Property])}function v157(){return JAM.call(TypeScript.hasFlag,TypeScript,[this.varFlags,TypeScript.VarFlags.Public])}function v156(){return JAM.call(TypeScript.hasFlag,TypeScript,[this.varFlags,TypeScript.VarFlags.Private])}function v155(){return!0}function v154(){return!0}function BoundDecl(id,nodeType,nestingLevel){JAM.call(_super.call,_super,[this,nodeType]);this.id=id;this.nestingLevel=
nestingLevel;this.typeExpr=this.init=null;this.varFlags=TypeScript.VarFlags.None;this.sym=null}JAM.call(__extends,null,[BoundDecl,_super]);BoundDecl.prototype.isDeclaration=v154;BoundDecl.prototype.isStatementOrExpression=v155;BoundDecl.prototype.isPrivate=v156;BoundDecl.prototype.isPublic=v157;BoundDecl.prototype.isProperty=v158;BoundDecl.prototype.typeCheck=v159;BoundDecl.prototype.printLabel=v160;return BoundDecl}function v153(_super){function v152(){if(this.alias.nodeType==TypeScript.NodeType.Name)return this.alias.actualText;
var dotExpr=this.alias,dotExpr=dotExpr.operand1;return dotExpr.actualText}function v151(aliasAST){"undefined"===typeof aliasAST&&(aliasAST=this.alias);return aliasAST.nodeType==TypeScript.NodeType.Name?aliasAST.actualText:JAM.call(this.getAliasName,this,[aliasAST.operand1])+"."+JAM.call(this.getAliasName,this,[aliasAST.operand2])}function v150(typeFlow){return JAM.call(typeFlow.typeCheckImportDecl,typeFlow,[this])}function v149(emitter,tokenId,startLine){tokenId=!this.isDynamicImport;tokenId||(tokenId=
this.id.sym)&&(tokenId=!this.id.sym.onlyReferencedAsTypeRef);if(tokenId){tokenId=emitter.modAliasId;startLine=emitter.firstModAlias;JAM.call(emitter.recordSourceMappingStart,emitter,[this]);JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAM.call(emitter.writeToOutput,emitter,["var "+this.id.actualText+" = "]);emitter.modAliasId=this.id.actualText;var v11724=emitter,v27429=this.firstAliasedModToString();v11724.firstModAlias=v27429;JAM.call(emitter.emitJavascript,emitter,[this.alias,
TypeScript.TokenID.Tilde,!1]);this.isDynamicImport||JAM.call(emitter.writeToOutput,emitter,[";"]);JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this]);emitter.modAliasId=tokenId;emitter.firstModAlias=startLine}}function v148(){return!0}function v147(){return!0}function ImportDeclaration(id,alias){JAM.call(_super.call,_super,[this,TypeScript.NodeType.ImportDeclaration]);this.id=id;this.alias=alias;this.varFlags=TypeScript.VarFlags.None;
this.isDynamicImport=!1}JAM.call(__extends,null,[ImportDeclaration,_super]);ImportDeclaration.prototype.isStatementOrExpression=v147;ImportDeclaration.prototype.isDeclaration=v148;ImportDeclaration.prototype.emit=v149;ImportDeclaration.prototype.typeCheck=v150;ImportDeclaration.prototype.getAliasName=v151;ImportDeclaration.prototype.firstAliasedModToString=v152;return ImportDeclaration}function v146(_super){function ModuleElement(nodeType){JAM.call(_super.call,_super,[this,nodeType])}JAM.call(__extends,
null,[ModuleElement,_super]);return ModuleElement}function v145(_super){function v144(){return this.text}function v143(){return"st: "+this.text}function v142(typeFlow){this.type=typeFlow.stringType;return this}function v141(emitter,tokenId,startLine){JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAM.call(emitter.recordSourceMappingStart,emitter,[this]);JAM.call(emitter.emitStringLiteral,emitter,[this.text]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this]);JAM.call(emitter.emitParensAndCommentsInPlace,
emitter,[this,!1])}function StringLiteral(text){JAM.call(_super.call,_super,[this,TypeScript.NodeType.QString]);this.text=text}JAM.call(__extends,null,[StringLiteral,_super]);StringLiteral.prototype.emit=v141;StringLiteral.prototype.typeCheck=v142;StringLiteral.prototype.treeViewLabel=v143;StringLiteral.prototype.printLabel=v144;return StringLiteral}function v140(_super){function v139(emitter,tokenId,startLine){JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAM.call(emitter.recordSourceMappingStart,
emitter,[this]);JAM.call(emitter.writeToOutput,emitter,[this.regex.toString()]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this]);JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v138(typeFlow){this.type=typeFlow.regexType;return this}function RegexLiteral(regex){JAM.call(_super.call,_super,[this,TypeScript.NodeType.Regex]);this.regex=regex}JAM.call(__extends,null,[RegexLiteral,_super]);RegexLiteral.prototype.typeCheck=v138;RegexLiteral.prototype.emit=v139;return RegexLiteral}
function v137(_super){function v136(){return Math.floor(this.value)!=this.value?this.value.toFixed(2).toString():this.hasEmptyFraction?this.value.toString()+".0":this.value.toString()}function v135(emitter,tokenId,startLine){JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAM.call(emitter.recordSourceMappingStart,emitter,[this]);this.isNegativeZero&&JAM.call(emitter.writeToOutput,emitter,["-"]);JAM.call(emitter.writeToOutput,emitter,[this.value.toString()]);this.hasEmptyFraction&&
JAM.call(emitter.writeToOutput,emitter,[".0"]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this]);JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v134(){return"num: "+this.printLabel()}function v133(typeFlow){this.type=typeFlow.doubleType;return this}function NumberLiteral(value,hasEmptyFraction){JAM.call(_super.call,_super,[this,TypeScript.NodeType.NumberLit]);this.value=value;this.hasEmptyFraction=hasEmptyFraction;this.isNegativeZero=!1}JAM.call(__extends,null,[NumberLiteral,
_super]);NumberLiteral.prototype.typeCheck=v133;NumberLiteral.prototype.treeViewLabel=v134;NumberLiteral.prototype.emit=v135;NumberLiteral.prototype.printLabel=v136;return NumberLiteral}function v132(_super){function v131(emitter,tokenId,startLine){JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAM.call(emitter.recordSourceMappingStart,emitter,[this]);JAM.call(emitter.emitJavascript,emitter,[this.operand1,TypeScript.TokenID.Question,!1]);JAM.call(emitter.writeToOutput,emitter,[" ? "]);
JAM.call(emitter.emitJavascript,emitter,[this.operand2,TypeScript.TokenID.Question,!1]);JAM.call(emitter.writeToOutput,emitter,[" : "]);JAM.call(emitter.emitJavascript,emitter,[this.operand3,TypeScript.TokenID.Question,!1]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this]);JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v130(typeFlow){return JAM.call(typeFlow.typeCheckQMark,typeFlow,[this])}function ConditionalExpression(operand1,operand2,operand3){JAM.call(_super.call,
_super,[this,TypeScript.NodeType.ConditionalExpression]);this.operand1=operand1;this.operand2=operand2;this.operand3=operand3}JAM.call(__extends,null,[ConditionalExpression,_super]);ConditionalExpression.prototype.typeCheck=v130;ConditionalExpression.prototype.emit=v131;return ConditionalExpression}function v129(_super){function v128(emitter,tokenId,startLine){tokenId=TypeScript.nodeTypeToTokTable;startLine=this.nodeType;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)tokenId=tokenId[startLine];
JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAM.call(emitter.recordSourceMappingStart,emitter,[this]);if(void 0!=tokenId){JAM.call(emitter.emitJavascript,emitter,[this.operand1,tokenId,!1]);startLine=TypeScript.tokenTable;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)startLine=startLine[tokenId];if("instanceof"==startLine.text)JAM.call(emitter.writeToOutput,emitter,[" instanceof "]);else{startLine=TypeScript.tokenTable;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)startLine=
startLine[tokenId];if("in"==startLine.text)JAM.call(emitter.writeToOutput,emitter,[" in "]);else{startLine=TypeScript.tokenTable;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)startLine=startLine[tokenId];JAM.call(emitter.writeToOutputTrimmable,emitter,[" "+startLine.text+" "])}}JAM.call(emitter.emitJavascript,emitter,[this.operand2,tokenId,!1])}else switch(this.nodeType){case TypeScript.NodeType.Dot:JAM.call(emitter.tryEmitConstant,emitter,[this])||(JAM.call(emitter.emitJavascript,
emitter,[this.operand1,TypeScript.TokenID.Dot,!1]),JAM.call(emitter.writeToOutput,emitter,["."]),JAM.call(emitter.emitJavascriptName,emitter,[this.operand2,!1]));break;case TypeScript.NodeType.Index:JAM.call(emitter.emitIndex,emitter,[this.operand1,this.operand2]);break;case TypeScript.NodeType.Member:(tokenId=this.operand2.nodeType==TypeScript.NodeType.FuncDecl)&&(tokenId=this.operand2.isAccessor());tokenId?(tokenId=this.operand2,JAM.call(TypeScript.hasFlag,TypeScript,[tokenId.fncFlags,TypeScript.FncFlags.GetAccessor])?
JAM.call(emitter.writeToOutput,emitter,["get "]):JAM.call(emitter.writeToOutput,emitter,["set "]),JAM.call(emitter.emitJavascript,emitter,[this.operand1,TypeScript.TokenID.Colon,!1])):(JAM.call(emitter.emitJavascript,emitter,[this.operand1,TypeScript.TokenID.Colon,!1]),JAM.call(emitter.writeToOutputTrimmable,emitter,[": "]));JAM.call(emitter.emitJavascript,emitter,[this.operand2,TypeScript.TokenID.Comma,!1]);break;case TypeScript.NodeType.Comma:JAM.call(emitter.emitJavascript,emitter,[this.operand1,
TypeScript.TokenID.Comma,!1]);emitter.emitState.inObjectLiteral?JAM.call(emitter.writeLineToOutput,emitter,[", "]):JAM.call(emitter.writeToOutput,emitter,[","]);JAM.call(emitter.emitJavascript,emitter,[this.operand2,TypeScript.TokenID.Comma,!1]);break;case TypeScript.NodeType.Is:throw Error("should be de-sugared during type check");default:throw Error("please implement in derived class");}JAM.call(emitter.recordSourceMappingEnd,emitter,[this]);JAM.call(emitter.emitParensAndCommentsInPlace,emitter,
[this,!1])}function v127(typeFlow){switch(this.nodeType){case TypeScript.NodeType.Dot:return JAM.call(typeFlow.typeCheckDotOperator,typeFlow,[this]);case TypeScript.NodeType.Asg:return JAM.call(typeFlow.typeCheckAsgOperator,typeFlow,[this]);case TypeScript.NodeType.Add:case TypeScript.NodeType.Sub:case TypeScript.NodeType.Mul:case TypeScript.NodeType.Div:case TypeScript.NodeType.Mod:case TypeScript.NodeType.Or:case TypeScript.NodeType.And:return JAM.call(typeFlow.typeCheckArithmeticOperator,typeFlow,
[this,!1]);case TypeScript.NodeType.Xor:return JAM.call(typeFlow.typeCheckBitwiseOperator,typeFlow,[this,!1]);case TypeScript.NodeType.Ne:case TypeScript.NodeType.Eq:var text;if(typeFlow.checker.styleSettings.eqeqeq){text=TypeScript.nodeTypeTable;var v11800=this.nodeType;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)text=text[v11800];v11800=typeFlow.checker.errorReporter;JAM.call(v11800.styleError,v11800,[this,"use of "+text])}else if(typeFlow.checker.styleSettings.eqnull){text=
TypeScript.nodeTypeTable;v11800=this.nodeType;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)text=text[v11800];(v11800=null!==this.operand2)&&(v11800=this.operand2.nodeType==TypeScript.NodeType.Null);v11800&&(v11800=typeFlow.checker.errorReporter,JAM.call(v11800.styleError,v11800,[this,"use of "+text+" to compare with null"]))}case TypeScript.NodeType.Eqv:case TypeScript.NodeType.NEqv:case TypeScript.NodeType.Lt:case TypeScript.NodeType.Le:case TypeScript.NodeType.Ge:case TypeScript.NodeType.Gt:return JAM.call(typeFlow.typeCheckBooleanOperator,
typeFlow,[this]);case TypeScript.NodeType.Index:return JAM.call(typeFlow.typeCheckIndex,typeFlow,[this]);case TypeScript.NodeType.Member:this.type=typeFlow.voidType;break;case TypeScript.NodeType.LogOr:return JAM.call(typeFlow.typeCheckLogOr,typeFlow,[this]);case TypeScript.NodeType.LogAnd:return JAM.call(typeFlow.typeCheckLogAnd,typeFlow,[this]);case TypeScript.NodeType.AsgAdd:case TypeScript.NodeType.AsgSub:case TypeScript.NodeType.AsgMul:case TypeScript.NodeType.AsgDiv:case TypeScript.NodeType.AsgMod:case TypeScript.NodeType.AsgOr:case TypeScript.NodeType.AsgAnd:return JAM.call(typeFlow.typeCheckArithmeticOperator,
typeFlow,[this,!0]);case TypeScript.NodeType.AsgXor:return JAM.call(typeFlow.typeCheckBitwiseOperator,typeFlow,[this,!0]);case TypeScript.NodeType.Lsh:case TypeScript.NodeType.Rsh:case TypeScript.NodeType.Rs2:return JAM.call(typeFlow.typeCheckShift,typeFlow,[this,!1]);case TypeScript.NodeType.AsgLsh:case TypeScript.NodeType.AsgRsh:case TypeScript.NodeType.AsgRs2:return JAM.call(typeFlow.typeCheckShift,typeFlow,[this,!0]);case TypeScript.NodeType.Comma:return JAM.call(typeFlow.typeCheckCommaOperator,
typeFlow,[this]);case TypeScript.NodeType.InstOf:return JAM.call(typeFlow.typeCheckInstOf,typeFlow,[this]);case TypeScript.NodeType.In:return JAM.call(typeFlow.typeCheckInOperator,typeFlow,[this]);case TypeScript.NodeType.From:typeFlow=typeFlow.checker.errorReporter;JAM.call(typeFlow.simpleError,typeFlow,[this,"Illegal use of 'from' keyword in binary expression"]);break;default:throw Error("please implement in derived class");}return this}function BinaryExpression(nodeType,operand1,operand2){JAM.call(_super.call,
_super,[this,nodeType]);this.operand1=operand1;this.operand2=operand2}JAM.call(__extends,null,[BinaryExpression,_super]);BinaryExpression.prototype.typeCheck=v127;BinaryExpression.prototype.emit=v128;return BinaryExpression}function v126(_super){function v125(emitter,tokenId,startLine){JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAM.call(emitter.recordSourceMappingStart,emitter,[this]);this.nodeType==TypeScript.NodeType.New?JAM.call(emitter.emitNew,emitter,[this.target,this.arguments]):
JAM.call(emitter.emitCall,emitter,[this,this.target,this.arguments]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this]);JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v124(typeFlow){return this.nodeType==TypeScript.NodeType.New?JAM.call(typeFlow.typeCheckNew,typeFlow,[this]):JAM.call(typeFlow.typeCheckCall,typeFlow,[this])}function CallExpression(nodeType,target,args){JAM.call(_super.call,_super,[this,nodeType]);this.target=target;this.arguments=args;this.signature=
null;this.minChar=this.target.minChar}JAM.call(__extends,null,[CallExpression,_super]);CallExpression.prototype.typeCheck=v124;CallExpression.prototype.emit=v125;return CallExpression}function v123(_super){function v122(emitter,tokenId,startLine){JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAM.call(emitter.recordSourceMappingStart,emitter,[this]);switch(this.nodeType){case TypeScript.NodeType.IncPost:JAM.call(emitter.emitJavascript,emitter,[this.operand,TypeScript.TokenID.PlusPlus,
!1]);JAM.call(emitter.writeToOutput,emitter,["++"]);break;case TypeScript.NodeType.LogNot:JAM.call(emitter.writeToOutput,emitter,["!"]);JAM.call(emitter.emitJavascript,emitter,[this.operand,TypeScript.TokenID.Exclamation,!1]);break;case TypeScript.NodeType.DecPost:JAM.call(emitter.emitJavascript,emitter,[this.operand,TypeScript.TokenID.MinusMinus,!1]);JAM.call(emitter.writeToOutput,emitter,["--"]);break;case TypeScript.NodeType.ObjectLit:JAM.call(emitter.emitObjectLiteral,emitter,[this.operand]);
break;case TypeScript.NodeType.ArrayLit:JAM.call(emitter.emitArrayLiteral,emitter,[this.operand]);break;case TypeScript.NodeType.Not:JAM.call(emitter.writeToOutput,emitter,["~"]);JAM.call(emitter.emitJavascript,emitter,[this.operand,TypeScript.TokenID.Tilde,!1]);break;case TypeScript.NodeType.Neg:JAM.call(emitter.writeToOutput,emitter,["-"]);this.operand.nodeType==TypeScript.NodeType.Neg&&(this.operand.isParenthesized=!0);JAM.call(emitter.emitJavascript,emitter,[this.operand,TypeScript.TokenID.Minus,
!1]);break;case TypeScript.NodeType.Pos:JAM.call(emitter.writeToOutput,emitter,["+"]);this.operand.nodeType==TypeScript.NodeType.Pos&&(this.operand.isParenthesized=!0);JAM.call(emitter.emitJavascript,emitter,[this.operand,TypeScript.TokenID.Plus,!1]);break;case TypeScript.NodeType.IncPre:JAM.call(emitter.writeToOutput,emitter,["++"]);JAM.call(emitter.emitJavascript,emitter,[this.operand,TypeScript.TokenID.PlusPlus,!1]);break;case TypeScript.NodeType.DecPre:JAM.call(emitter.writeToOutput,emitter,["--"]);
JAM.call(emitter.emitJavascript,emitter,[this.operand,TypeScript.TokenID.MinusMinus,!1]);break;case TypeScript.NodeType.Throw:JAM.call(emitter.writeToOutput,emitter,["throw "]);JAM.call(emitter.emitJavascript,emitter,[this.operand,TypeScript.TokenID.Tilde,!1]);JAM.call(emitter.writeToOutput,emitter,[";"]);break;case TypeScript.NodeType.Typeof:JAM.call(emitter.writeToOutput,emitter,["typeof "]);JAM.call(emitter.emitJavascript,emitter,[this.operand,TypeScript.TokenID.Tilde,!1]);break;case TypeScript.NodeType.Delete:JAM.call(emitter.writeToOutput,
emitter,["delete "]);JAM.call(emitter.emitJavascript,emitter,[this.operand,TypeScript.TokenID.Tilde,!1]);break;case TypeScript.NodeType.Void:JAM.call(emitter.writeToOutput,emitter,["void "]);JAM.call(emitter.emitJavascript,emitter,[this.operand,TypeScript.TokenID.Tilde,!1]);break;case TypeScript.NodeType.TypeAssertion:JAM.call(emitter.emitJavascript,emitter,[this.operand,TypeScript.TokenID.Tilde,!1]);break;default:throw Error("please implement in derived class");}JAM.call(emitter.recordSourceMappingEnd,
emitter,[this]);JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v121(typeFlow){switch(this.nodeType){case TypeScript.NodeType.Not:return JAM.call(typeFlow.typeCheckBitNot,typeFlow,[this]);case TypeScript.NodeType.LogNot:return JAM.call(typeFlow.typeCheckLogNot,typeFlow,[this]);case TypeScript.NodeType.Pos:case TypeScript.NodeType.Neg:return JAM.call(typeFlow.typeCheckUnaryNumberOperator,typeFlow,[this]);case TypeScript.NodeType.IncPost:case TypeScript.NodeType.IncPre:case TypeScript.NodeType.DecPost:case TypeScript.NodeType.DecPre:return JAM.call(typeFlow.typeCheckIncOrDec,
typeFlow,[this]);case TypeScript.NodeType.ArrayLit:JAM.call(typeFlow.typeCheckArrayLit,typeFlow,[this]);break;case TypeScript.NodeType.ObjectLit:JAM.call(typeFlow.typeCheckObjectLit,typeFlow,[this]);break;case TypeScript.NodeType.Throw:var v27430=JAM.call(typeFlow.typeCheck,typeFlow,[this.operand]);this.operand=v27430;this.type=typeFlow.voidType;break;case TypeScript.NodeType.Typeof:this.operand=v27430=JAM.call(typeFlow.typeCheck,typeFlow,[this.operand]);this.type=typeFlow.stringType;break;case TypeScript.NodeType.Delete:this.operand=
v27430=JAM.call(typeFlow.typeCheck,typeFlow,[this.operand]);this.type=typeFlow.booleanType;break;case TypeScript.NodeType.TypeAssertion:this.castTerm=v27430=JAM.call(typeFlow.typeCheck,typeFlow,[this.castTerm]);var v27430=(v27430=!this.operand.isParenthesized)?this.castTerm.type:null,v11862=typeFlow.checker;JAM.call(v11862.typeCheckWithContextualType,v11862,[v27430,typeFlow.checker.inProvisionalTypecheckMode(),!0,this.operand]);JAM.call(typeFlow.castWithCoercion,typeFlow,[this.operand,this.castTerm.type,
!1,!0]);this.type=this.castTerm.type;break;case TypeScript.NodeType.Void:this.operand=v27430=JAM.call(typeFlow.typeCheck,typeFlow,[this.operand]);this.type=typeFlow.checker.undefinedType;break;default:throw Error("please implement in derived class");}return this}function v120(context){var v11871=_super.prototype.addToControlFlow;JAM.call(v11871.call,v11871,[this,context]);this.nodeType==TypeScript.NodeType.Throw&&context.returnStmt()}function UnaryExpression(nodeType,operand){JAM.call(_super.call,
_super,[this,nodeType]);this.operand=operand;this.castTerm=this.targetType=null}JAM.call(__extends,null,[UnaryExpression,_super]);UnaryExpression.prototype.addToControlFlow=v120;UnaryExpression.prototype.typeCheck=v121;UnaryExpression.prototype.emit=v122;return UnaryExpression}function v119(_super){function v118(){return!0}function v117(){return!0}function Expression(nodeType){JAM.call(_super.call,_super,[this,nodeType])}JAM.call(__extends,null,[Expression,_super]);Expression.prototype.isExpression=
v117;Expression.prototype.isStatementOrExpression=v118;return Expression}function v116(_super){function v115(emitter,tokenId,startLine){JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAM.call(emitter.recordSourceMappingStart,emitter,[this]);JAM.call(emitter.recordSourceMappingStart,emitter,[this.id]);JAM.call(emitter.writeToOutput,emitter,[this.id.actualText]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this.id]);JAM.call(emitter.writeLineToOutput,emitter,[":"]);JAM.call(emitter.recordSourceMappingEnd,
emitter,[this]);JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v114(typeFlow){this.type=typeFlow.voidType;return this}function v113(){return this.id.actualText+":"}function Label(id){JAM.call(_super.call,_super,[this,TypeScript.NodeType.Label]);this.id=id}JAM.call(__extends,null,[Label,_super]);Label.prototype.printLabel=v113;Label.prototype.typeCheck=v114;Label.prototype.emit=v115;return Label}function v112(_super){function v111(emitter,tokenId,startLine){}function v110(){return!0}
function MissingIdentifier(){JAM.call(_super.call,_super,[this,"__missing"])}JAM.call(__extends,null,[MissingIdentifier,_super]);MissingIdentifier.prototype.isMissing=v110;MissingIdentifier.prototype.emit=v111;return MissingIdentifier}function v109(_super){function fromToken(token){return new Identifier(token.getText(),token.hasEscapeSequence)}function v108(emitter,tokenId,startLine){JAM.call(emitter.emitJavascriptName,emitter,[this,!0])}function v107(typeFlow){return JAM.call(typeFlow.typeCheckName,
typeFlow,[this])}function v106(){return this.actualText?"id: "+this.actualText:"name node"}function v105(){return"id: "+this.actualText}function v104(){return!0}function v103(){return!1}function v102(actualText,hasEscapeSequence){this.actualText=actualText;if(hasEscapeSequence){var v27435=JAM.call(AST.getResolvedIdentifierName,AST,[actualText]);this.text=v27435}else this.text=actualText}function Identifier(actualText,hasEscapeSequence){JAM.call(_super.call,_super,[this,TypeScript.NodeType.Name]);
this.actualText=actualText;this.hasEscapeSequence=hasEscapeSequence;this.sym=null;this.cloId=-1;JAM.call(this.setText,this,[actualText,hasEscapeSequence])}JAM.call(__extends,null,[Identifier,_super]);Identifier.prototype.setText=v102;Identifier.prototype.isMissing=v103;Identifier.prototype.isLeaf=v104;Identifier.prototype.treeViewLabel=v105;Identifier.prototype.printLabel=v106;Identifier.prototype.typeCheck=v107;Identifier.prototype.emit=v108;Identifier.fromToken=fromToken;return Identifier}function v101(_super){function v100(typeFlow){var len=
this.members.length;typeFlow.nestingLevel+=1;for(var i=0,v11905=i<len;v11905;){v11905=this.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v11905=v11905[i];if(v11905){var v11905=this.members,v11903=i,v22718=this.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v22718=v22718[i];v22718=JAM.call(v22718.typeCheck,v22718,[typeFlow]);v11905[v11903]=v22718}i+=1;v11905=i<len}typeFlow.nestingLevel-=1;return this}function v99(emitter,tokenId,startLine){JAM.call(emitter.recordSourceMappingStart,
emitter,[this]);JAM.call(emitter.emitJavascriptList,emitter,[this,null,TypeScript.TokenID.Semicolon,startLine,!1,!1]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this])}function v98(ast){if(ast.nodeType==TypeScript.NodeType.List)for(var i=0,len=ast.members.length,v11909=i<len;v11909;){v11909=ast.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v11909=v11909[i];JAM.call(this.append,this,[v11909]);i+=1;v11909=i<len}else JAM.call(this.append,this,[ast]);return this}function v97(ast){JAM.set(this.members,
this.members.length,ast);return this}function v96(context){for(var len=this.members.length,i=0,v11918=i<len;v11918;){if(context.noContinuation){len=this.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)i=len[i];JAM.call(context.addUnreachable,context,[i]);break}else{var v11918=this.members,v11916=i,v22720=this.members;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v22720=v22720[i];v22720=JAM.call(context.walk,context,[v22720,this]);v11918[v11916]=v22720}i+=
1;v11918=i<len}context.walker.options.goChildren=!1}function ASTList(){JAM.call(_super.call,_super,[this,TypeScript.NodeType.List]);this.enclosingScope=null;var v27438=[];this.members=v27438}JAM.call(__extends,null,[ASTList,_super]);ASTList.prototype.addToControlFlow=v96;ASTList.prototype.append=v97;ASTList.prototype.appendAll=v98;ASTList.prototype.emit=v99;ASTList.prototype.typeCheck=v100;return ASTList}function v95(_super){function IncompleteAST(min,lim){JAM.call(_super.call,_super,[this,TypeScript.NodeType.Error]);
this.minChar=min;this.limChar=lim}JAM.call(__extends,null,[IncompleteAST,_super]);return IncompleteAST}function v94(_super){function v93(){var v18609=!this.isDeclaration();v18609||(v18609=!this.preComments)||(v18609=0==this.preComments.length);if(v18609)return[];if(!this.docComments){for(var preCommentsLength=this.preComments.length,v18609=[],preCommentsLength=preCommentsLength-1,v11933=0<=preCommentsLength;v11933;){v11933=this.preComments;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v11933=
v11933[preCommentsLength];if(v11933.isDocComment()){var v11933=0<v18609.length?v18609[v18609.length-1]:null,v18614=null==v11933;if(!v18614){v18614=this.preComments;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v18614=v18614[preCommentsLength];v18614=v18614.limLine==v11933.minLine;if(!v18614){v18614=this.preComments;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v18614=v18614[preCommentsLength];v18614=v18614.limLine+1==v11933.minLine}}if(v18614){v11933=this.preComments;
introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v11933=v11933[preCommentsLength];JAM.call(v18609.push,v18609,[v11933]);preCommentsLength-=1;v11933=0<=preCommentsLength;continue}}break}this.docComments=v18609=v18609.reverse()}return this.docComments}function getResolvedIdentifierName(name){if(!name)return"";for(var resolved="",start=0,i=0,v11938=i<=name.length-6;v11938;)(v11938="\\"==name.charAt(i))&&(v11938="u"==name.charAt(i+1)),v11938?(v11938=parseInt(name.substr(i+2,4),16),resolved+=
name.substr(start,i-start),resolved+=String.fromCharCode(v11938),start=i+=6):i+=1,v11938=i<=name.length-6;return resolved+=JAM.call(name.substring,name,[start])}function v92(){var v11939=TypeScript.NodeType._map,v11940=this.nodeType;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v11939[v11940]}function v91(container,freeUses){}function v90(context){context.walker.options.goChildren=!1;JAM.call(context.addContent,context,[this])}function v89(){var v22735=TypeScript.nodeTypeTable,
v22736=this.nodeType;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v22735=v22735[v22736];v22735=void 0!==v22735?TypeScript.nodeTypeTable:TypeScript.NodeType._map;v22736=this.nodeType;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)return v22735[v22736]}function v88(context){context.startLine();var lineCol={line:-1,col:-1},limLineCol={line:-1,col:-1};if(null!==context.parser){var v11947=context.parser;JAM.call(v11947.getSourceLineCol,v11947,[lineCol,this.minChar]);
v11947=context.parser;JAM.call(v11947.getSourceLineCol,v11947,[limLineCol,this.limChar]);JAM.call(context.write,context,["("+lineCol.line+","+lineCol.col+")--("+limLineCol.line+","+limLineCol.col+"): "])}lineCol=this.printLabel();JAM.call(TypeScript.hasFlag,TypeScript,[this.flags,TypeScript.ASTFlags.Error])&&(lineCol+=" (Error)");JAM.call(context.writeLine,context,[lineCol])}function v87(emitter,tokenId,startLine){JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);switch(this.nodeType){case TypeScript.NodeType.This:JAM.call(emitter.recordSourceMappingStart,
emitter,[this]);(tokenId=emitter.thisFnc)&&(tokenId=JAM.call(TypeScript.hasFlag,TypeScript,[emitter.thisFnc.fncFlags,TypeScript.FncFlags.IsFatArrowFunction]));tokenId?JAM.call(emitter.writeToOutput,emitter,["_this"]):JAM.call(emitter.writeToOutput,emitter,["this"]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this]);break;case TypeScript.NodeType.Null:JAM.call(emitter.recordSourceMappingStart,emitter,[this]);JAM.call(emitter.writeToOutput,emitter,["null"]);JAM.call(emitter.recordSourceMappingEnd,
emitter,[this]);break;case TypeScript.NodeType.False:JAM.call(emitter.recordSourceMappingStart,emitter,[this]);JAM.call(emitter.writeToOutput,emitter,["false"]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this]);break;case TypeScript.NodeType.True:JAM.call(emitter.recordSourceMappingStart,emitter,[this]);JAM.call(emitter.writeToOutput,emitter,["true"]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this]);break;case TypeScript.NodeType.Super:JAM.call(emitter.recordSourceMappingStart,emitter,
[this]);emitter.emitSuperReference();JAM.call(emitter.recordSourceMappingEnd,emitter,[this]);break;case TypeScript.NodeType.EndCode:case TypeScript.NodeType.Error:case TypeScript.NodeType.EmptyExpr:break;case TypeScript.NodeType.Empty:JAM.call(emitter.recordSourceMappingStart,emitter,[this]);JAM.call(emitter.recordSourceMappingEnd,emitter,[this]);break;case TypeScript.NodeType.Void:JAM.call(emitter.recordSourceMappingStart,emitter,[this]);JAM.call(emitter.writeToOutput,emitter,["void "]);JAM.call(emitter.recordSourceMappingEnd,
emitter,[this]);break;default:throw Error("please implement in derived class");}JAM.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v86(typeFlow){switch(this.nodeType){case TypeScript.NodeType.Error:case TypeScript.NodeType.EmptyExpr:this.type=typeFlow.anyType;break;case TypeScript.NodeType.This:return JAM.call(typeFlow.typeCheckThis,typeFlow,[this]);case TypeScript.NodeType.Null:this.type=typeFlow.nullType;break;case TypeScript.NodeType.False:case TypeScript.NodeType.True:this.type=
typeFlow.booleanType;break;case TypeScript.NodeType.Super:return JAM.call(typeFlow.typeCheckSuper,typeFlow,[this]);case TypeScript.NodeType.EndCode:case TypeScript.NodeType.Empty:case TypeScript.NodeType.Void:this.type=typeFlow.voidType;break;default:throw Error("please implement in derived class");}return this}function v85(){return!1}function v84(){var v11957=this.isStatementOrExpression();v11957&&(v11957=!this.isCompoundStatement());return v11957}function v83(){return!1}function v82(){return!1}
function v81(){return!1}function AST(nodeType){JAM.call(_super.call,_super,[this]);this.nodeType=nodeType;this.type=null;this.flags=TypeScript.ASTFlags.Writeable;this.passCreated=TypeScript.CompilerDiagnostics.analysisPass;this.docComments=this.postComments=this.preComments=null;this.isParenthesized=!1}JAM.call(__extends,null,[AST,_super]);AST.prototype.isExpression=v81;AST.prototype.isStatementOrExpression=v82;AST.prototype.isCompoundStatement=v83;AST.prototype.isLeaf=v84;AST.prototype.isDeclaration=
v85;AST.prototype.typeCheck=v86;AST.prototype.emit=v87;AST.prototype.print=v88;AST.prototype.printLabel=v89;AST.prototype.addToControlFlow=v90;AST.prototype.netFreeUses=v91;AST.prototype.treeViewLabel=v92;AST.getResolvedIdentifierName=getResolvedIdentifierName;AST.prototype.getDocComments=v93;return AST}function v80(){function ASTSpan(){this.limChar=this.minChar=-1}return ASTSpan}var ASTSpan=v80();TypeScript.ASTSpan=ASTSpan;var AST=v94(ASTSpan);TypeScript.AST=AST;var IncompleteAST=v95(AST);TypeScript.IncompleteAST=
IncompleteAST;var ASTList=v101(AST);TypeScript.ASTList=ASTList;var Identifier=v109(AST);TypeScript.Identifier=Identifier;var MissingIdentifier=v112(Identifier);TypeScript.MissingIdentifier=MissingIdentifier;var Label=v116(AST);TypeScript.Label=Label;var Expression=v119(AST);TypeScript.Expression=Expression;var UnaryExpression=v123(Expression);TypeScript.UnaryExpression=UnaryExpression;var CallExpression=v126(Expression);TypeScript.CallExpression=CallExpression;var BinaryExpression=v129(Expression);
TypeScript.BinaryExpression=BinaryExpression;var ConditionalExpression=v132(Expression);TypeScript.ConditionalExpression=ConditionalExpression;var NumberLiteral=v137(Expression);TypeScript.NumberLiteral=NumberLiteral;var RegexLiteral=v140(Expression);TypeScript.RegexLiteral=RegexLiteral;var StringLiteral=v145(Expression);TypeScript.StringLiteral=StringLiteral;var ModuleElement=v146(AST);TypeScript.ModuleElement=ModuleElement;var ImportDeclaration=v153(ModuleElement);TypeScript.ImportDeclaration=ImportDeclaration;
var BoundDecl=v161(AST);TypeScript.BoundDecl=BoundDecl;var VarDecl=v167(BoundDecl);TypeScript.VarDecl=VarDecl;var ArgDecl=v171(BoundDecl);TypeScript.ArgDecl=ArgDecl;var internalId=0,FuncDecl=v201(AST);TypeScript.FuncDecl=FuncDecl;var LocationInfo=v202();TypeScript.LocationInfo=LocationInfo;var v11973=TypeScript,v27440=JAM.new(LocationInfo,["unknown",null,-1]);v11973.unknownLocationInfo=v27440;var Script=v210(FuncDecl);TypeScript.Script=Script;var NamedDeclaration=v212(ModuleElement);TypeScript.NamedDeclaration=
NamedDeclaration;var ModuleDeclaration=v219(NamedDeclaration);TypeScript.ModuleDeclaration=ModuleDeclaration;var TypeDeclaration=v222(NamedDeclaration);TypeScript.TypeDeclaration=TypeDeclaration;var ClassDeclaration=v225(TypeDeclaration);TypeScript.ClassDeclaration=ClassDeclaration;var InterfaceDeclaration=v228(TypeDeclaration);TypeScript.InterfaceDeclaration=InterfaceDeclaration;var Statement=v233(ModuleElement);TypeScript.Statement=Statement;var LabeledStatement=v237(Statement);TypeScript.LabeledStatement=
LabeledStatement;var Block=v241(Statement);TypeScript.Block=Block;var Jump=v246(Statement);TypeScript.Jump=Jump;var WhileStatement=v251(Statement);TypeScript.WhileStatement=WhileStatement;var DoWhileStatement=v256(Statement);TypeScript.DoWhileStatement=DoWhileStatement;var IfStatement=v261(Statement);TypeScript.IfStatement=IfStatement;var ReturnStatement=v265(Statement);TypeScript.ReturnStatement=ReturnStatement;var EndCode=v266(AST);TypeScript.EndCode=EndCode;var ForInStatement=v272(Statement);TypeScript.ForInStatement=
ForInStatement;var ForStatement=v277(Statement);TypeScript.ForStatement=ForStatement;var WithStatement=v281(Statement);TypeScript.WithStatement=WithStatement;var SwitchStatement=v286(Statement);TypeScript.SwitchStatement=SwitchStatement;var CaseStatement=v290(Statement);TypeScript.CaseStatement=CaseStatement;var TypeReference=v293(AST);TypeScript.TypeReference=TypeReference;var TryFinally=v298(Statement);TypeScript.TryFinally=TryFinally;var TryCatch=v303(Statement);TypeScript.TryCatch=TryCatch;var Try=
v307(Statement);TypeScript.Try=Try;var Catch=v311(Statement);TypeScript.Catch=Catch;var Finally=v315(Statement);TypeScript.Finally=Finally;var Comment$$0=v319(AST);TypeScript.Comment=Comment$$0;var DebuggerStatement=v321(Statement);TypeScript.DebuggerStatement=DebuggerStatement}function v79(d,b){function __(){this.constructor=d}__.prototype=b.prototype;var v11974=d,v27441=new __;v11974.prototype=v27441}
function v78(){var TypeScript=v18793;function v77(){function v76(key,data){var lookupData=JAM.call(this.lookup,this,[key]);if(lookupData)return!1;JAM.set(this.keys,this.keys.length,key);JAM.set(this.values,this.values.length,data);return!0}function v75(key,findValue){var searchArray=this.keys;findValue&&(searchArray=this.values);for(var i=0,v11982=i<searchArray.length;v11982;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v11982=searchArray[i];if(v11982==key){searchArray=this.keys;
introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)searchArray=searchArray[i];v11982=this.values;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)i=v11982[i];return{key:searchArray,data:i}}i+=1;v11982=i<searchArray.length}return null}function SimpleHashTable(){this.keys=[];this.values=[]}SimpleHashTable.prototype.lookup=v75;SimpleHashTable.prototype.add=v76;return SimpleHashTable}function v74(){function v73(key){var current;current=JAM.call(this.hashFn,this,[key]);current%=
this.size;var v11986=this.table;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)current=v11986[current];for(v11986=null!=current;v11986;){if(JAM.call(this.equalsFn,this,[key,current.key]))return current.data;current=current.next;v11986=null!=current}return null}function v72(){return this.itemCount}function v71(key){var current,val=JAM.call(this.hashFn,this,[key]),val=val%this.size,result=null,prevEntry=null;current=this.table;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)current=
current[val];for(var v11993=null!=current;v11993;){if(JAM.call(this.equalsFn,this,[key,current.key])){result=current.data;this.itemCount-=1;prevEntry?prevEntry.next=current.next:JAM.set(this.table,val,current.next);break}prevEntry=current;current=current.next;v11993=null!=current}return result}function v70(key,data){var current,entry=JAM.new(HashEntry,[key,data]),val=JAM.call(this.hashFn,this,[key]),val=val%this.size;current=this.table;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)current=
current[val];for(var v11997=null!=current;v11997;){if(JAM.call(this.equalsFn,this,[key,current.key]))return!1;current=current.next;v11997=null!=current}current=this.table;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)entry.next=current[val];JAM.set(this.table,val,entry);this.itemCount+=1;return!0}function HashTable(size,hashFn,equalsFn){this.size=size;this.hashFn=hashFn;this.equalsFn=equalsFn;this.itemCount=0;this.table=size=[];size=0;for(hashFn=size<this.size;hashFn;)this.table[size]=
null,size+=1,hashFn=size<this.size}HashTable.prototype.add=v70;HashTable.prototype.remove=v71;HashTable.prototype.count=v72;HashTable.prototype.lookup=v73;return HashTable}function v69(){function HashEntry(key,data){this.key=key;this.data=data}return HashEntry}function v68(){function v67(key){var v12006=this.primaryTable,v12006=JAM.call(v12006.lookup,v12006,[key]);if(void 0!=v12006)return v12006;v12006=this.secondaryTable;return JAM.call(v12006.lookup,v12006,[key])}function v66(){return this.primaryTable.count()+
this.secondaryTable.count()}function v65(fn,context){var v18653=this.primaryTable,v18653=JAM.call(v18653.some,v18653,[fn,context]);v18653||(v18653=this.secondaryTable,v18653=JAM.call(v18653.some,v18653,[fn,context]));return v18653}function v64(fn,context){var v18656=this.primaryTable;if(v18656=JAM.call(v18656.every,v18656,[fn,context]))v18656=this.secondaryTable,v18656=JAM.call(v18656.every,v18656,[fn,context]);return v18656}function v63(fn,context){var v12013=this.primaryTable;JAM.call(v12013.map,
v12013,[fn,context]);v12013=this.secondaryTable;JAM.call(v12013.map,v12013,[fn,context])}function v62(key,data){if(this.insertPrimary){var v12015=this.primaryTable;return JAM.call(v12015.addOrUpdate,v12015,[key,data])}v12015=this.secondaryTable;return JAM.call(v12015.addOrUpdate,v12015,[key,data])}function v61(key,data){if(this.insertPrimary){var v12018=this.primaryTable;return JAM.call(v12018.add,v12018,[key,data])}v12018=this.secondaryTable;return JAM.call(v12018.add,v12018,[key,data])}function v60(){return this.primaryTable.getAllKeys().concat(this.secondaryTable.getAllKeys())}
function DualStringHashTable(primaryTable,secondaryTable){this.primaryTable=primaryTable;this.secondaryTable=secondaryTable;this.insertPrimary=!0}DualStringHashTable.prototype.getAllKeys=v60;DualStringHashTable.prototype.add=v61;DualStringHashTable.prototype.addOrUpdate=v62;DualStringHashTable.prototype.map=v63;DualStringHashTable.prototype.every=v64;DualStringHashTable.prototype.some=v65;DualStringHashTable.prototype.count=v66;DualStringHashTable.prototype.lookup=v67;return DualStringHashTable}function v59(){function v58(key){var v12031=
this.table;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)key=v12031[key];return void 0!=key?key:null}function v57(){return this.itemCount}function v56(fn,context){for(var k in this.table){var v12033=this.table;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v12033=v12033[k];if(void 0!=v12033){v12033=this.table;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v12033=v12033[k];if(JAM.call(fn,null,[k,v12033,context]))return!0}}return!1}function v55(fn,
context){for(var k in this.table){var v12037=this.table;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v12037=v12037[k];if(void 0!=v12037){v12037=this.table;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v12037=v12037[k];if(!JAM.call(fn,null,[k,v12037,context]))return!1}}return!0}function v54(fn,context){for(var k in this.table){var v12041=this.table;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v12041=v12041[k];if(void 0!=v12041){v12041=this.table;
introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v12041=v12041[k];JAM.call(fn,null,[k,v12041,context])}}}function v53(key,data){var v22744=this.table;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v22744=v22744[key];if(void 0!=v22744)return JAM.set(this.table,key,data),!1;JAM.set(this.table,key,data);this.itemCount+=1;return!0}function v52(key,data){var v22745=this.table;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v22745=v22745[key];if(void 0!=v22745)return!1;
JAM.set(this.table,key,data);this.itemCount+=1;return!0}function v51(){var result=[],k;for(k in this.table){var v22746=this.table;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v22746=v22746[k];void 0!=v22746&&(result[result.length]=k)}return result}function StringHashTable(){this.itemCount=0;var v27443=new BlockIntrinsics;this.table=v27443}StringHashTable.prototype.getAllKeys=v51;StringHashTable.prototype.add=v52;StringHashTable.prototype.addOrUpdate=v53;StringHashTable.prototype.map=
v54;StringHashTable.prototype.every=v55;StringHashTable.prototype.some=v56;StringHashTable.prototype.count=v57;StringHashTable.prototype.lookup=v58;return StringHashTable}function v50(){function BlockIntrinsics(){this.constructor=this.isPrototypeOf=this.propertyIsEnumerable=this.hasOwnProperty=this.valueOf=this.toLocaleString=this.toString=this.prototype=void 0}return BlockIntrinsics}function numberHashFn(key){var c2=668265261;key=key^61^key>>>16;key+=key<<3;key^=key>>>4;key*=c2;return key^=key>>>
15}function combineHashes(key1,key2){return key2^(key1>>5)+key1}var BlockIntrinsics=v50();TypeScript.BlockIntrinsics=BlockIntrinsics;var StringHashTable=v59();TypeScript.StringHashTable=StringHashTable;StringHashTable=v68();TypeScript.DualStringHashTable=StringHashTable;TypeScript.numberHashFn=numberHashFn;TypeScript.combineHashes=combineHashes;var HashEntry=v69();TypeScript.HashEntry=HashEntry;StringHashTable=v74();TypeScript.HashTable=StringHashTable;StringHashTable=v77();TypeScript.SimpleHashTable=
StringHashTable}
function v49(){var TypeScript=v18792,v12067=TypeScript.NodeType;v12067||(v12067=TypeScript.NodeType={});TypeScript=v12067;TypeScript._map=[];TypeScript._map[0]="None";TypeScript.None=0;TypeScript._map[1]="Empty";TypeScript.Empty=1;TypeScript._map[2]="EmptyExpr";TypeScript.EmptyExpr=2;TypeScript._map[3]="True";TypeScript.True=3;TypeScript._map[4]="False";TypeScript.False=4;TypeScript._map[5]="This";TypeScript.This=5;TypeScript._map[6]="Super";TypeScript.Super=6;TypeScript._map[7]="QString";TypeScript.QString=
7;TypeScript._map[8]="Regex";TypeScript.Regex=8;TypeScript._map[9]="Null";TypeScript.Null=9;TypeScript._map[10]="ArrayLit";TypeScript.ArrayLit=10;TypeScript._map[11]="ObjectLit";TypeScript.ObjectLit=11;TypeScript._map[12]="Void";TypeScript.Void=12;TypeScript._map[13]="Comma";TypeScript.Comma=13;TypeScript._map[14]="Pos";TypeScript.Pos=14;TypeScript._map[15]="Neg";TypeScript.Neg=15;TypeScript._map[16]="Delete";TypeScript.Delete=16;TypeScript._map[17]="Await";TypeScript.Await=17;TypeScript._map[18]=
"In";TypeScript.In=18;TypeScript._map[19]="Dot";TypeScript.Dot=19;TypeScript._map[20]="From";TypeScript.From=20;TypeScript._map[21]="Is";TypeScript.Is=21;TypeScript._map[22]="InstOf";TypeScript.InstOf=22;TypeScript._map[23]="Typeof";TypeScript.Typeof=23;TypeScript._map[24]="NumberLit";TypeScript.NumberLit=24;TypeScript._map[25]="Name";TypeScript.Name=25;TypeScript._map[26]="TypeRef";TypeScript.TypeRef=26;TypeScript._map[27]="Index";TypeScript.Index=27;TypeScript._map[28]="Call";TypeScript.Call=28;
TypeScript._map[29]="New";TypeScript.New=29;TypeScript._map[30]="Asg";TypeScript.Asg=30;TypeScript._map[31]="AsgAdd";TypeScript.AsgAdd=31;TypeScript._map[32]="AsgSub";TypeScript.AsgSub=32;TypeScript._map[33]="AsgDiv";TypeScript.AsgDiv=33;TypeScript._map[34]="AsgMul";TypeScript.AsgMul=34;TypeScript._map[35]="AsgMod";TypeScript.AsgMod=35;TypeScript._map[36]="AsgAnd";TypeScript.AsgAnd=36;TypeScript._map[37]="AsgXor";TypeScript.AsgXor=37;TypeScript._map[38]="AsgOr";TypeScript.AsgOr=38;TypeScript._map[39]=
"AsgLsh";TypeScript.AsgLsh=39;TypeScript._map[40]="AsgRsh";TypeScript.AsgRsh=40;TypeScript._map[41]="AsgRs2";TypeScript.AsgRs2=41;TypeScript._map[42]="ConditionalExpression";TypeScript.ConditionalExpression=42;TypeScript._map[43]="LogOr";TypeScript.LogOr=43;TypeScript._map[44]="LogAnd";TypeScript.LogAnd=44;TypeScript._map[45]="Or";TypeScript.Or=45;TypeScript._map[46]="Xor";TypeScript.Xor=46;TypeScript._map[47]="And";TypeScript.And=47;TypeScript._map[48]="Eq";TypeScript.Eq=48;TypeScript._map[49]="Ne";
TypeScript.Ne=49;TypeScript._map[50]="Eqv";TypeScript.Eqv=50;TypeScript._map[51]="NEqv";TypeScript.NEqv=51;TypeScript._map[52]="Lt";TypeScript.Lt=52;TypeScript._map[53]="Le";TypeScript.Le=53;TypeScript._map[54]="Gt";TypeScript.Gt=54;TypeScript._map[55]="Ge";TypeScript.Ge=55;TypeScript._map[56]="Add";TypeScript.Add=56;TypeScript._map[57]="Sub";TypeScript.Sub=57;TypeScript._map[58]="Mul";TypeScript.Mul=58;TypeScript._map[59]="Div";TypeScript.Div=59;TypeScript._map[60]="Mod";TypeScript.Mod=60;TypeScript._map[61]=
"Lsh";TypeScript.Lsh=61;TypeScript._map[62]="Rsh";TypeScript.Rsh=62;TypeScript._map[63]="Rs2";TypeScript.Rs2=63;TypeScript._map[64]="Not";TypeScript.Not=64;TypeScript._map[65]="LogNot";TypeScript.LogNot=65;TypeScript._map[66]="IncPre";TypeScript.IncPre=66;TypeScript._map[67]="DecPre";TypeScript.DecPre=67;TypeScript._map[68]="IncPost";TypeScript.IncPost=68;TypeScript._map[69]="DecPost";TypeScript.DecPost=69;TypeScript._map[70]="TypeAssertion";TypeScript.TypeAssertion=70;TypeScript._map[71]="FuncDecl";
TypeScript.FuncDecl=71;TypeScript._map[72]="Member";TypeScript.Member=72;TypeScript._map[73]="VarDecl";TypeScript.VarDecl=73;TypeScript._map[74]="ArgDecl";TypeScript.ArgDecl=74;TypeScript._map[75]="Return";TypeScript.Return=75;TypeScript._map[76]="Break";TypeScript.Break=76;TypeScript._map[77]="Continue";TypeScript.Continue=77;TypeScript._map[78]="Throw";TypeScript.Throw=78;TypeScript._map[79]="For";TypeScript.For=79;TypeScript._map[80]="ForIn";TypeScript.ForIn=80;TypeScript._map[81]="If";TypeScript.If=
81;TypeScript._map[82]="While";TypeScript.While=82;TypeScript._map[83]="DoWhile";TypeScript.DoWhile=83;TypeScript._map[84]="Block";TypeScript.Block=84;TypeScript._map[85]="Case";TypeScript.Case=85;TypeScript._map[86]="Switch";TypeScript.Switch=86;TypeScript._map[87]="Try";TypeScript.Try=87;TypeScript._map[88]="TryCatch";TypeScript.TryCatch=88;TypeScript._map[89]="TryFinally";TypeScript.TryFinally=89;TypeScript._map[90]="Finally";TypeScript.Finally=90;TypeScript._map[91]="Catch";TypeScript.Catch=91;
TypeScript._map[92]="List";TypeScript.List=92;TypeScript._map[93]="Script";TypeScript.Script=93;TypeScript._map[94]="ClassDeclaration";TypeScript.ClassDeclaration=94;TypeScript._map[95]="InterfaceDeclaration";TypeScript.InterfaceDeclaration=95;TypeScript._map[96]="ModuleDeclaration";TypeScript.ModuleDeclaration=96;TypeScript._map[97]="ImportDeclaration";TypeScript.ImportDeclaration=97;TypeScript._map[98]="With";TypeScript.With=98;TypeScript._map[99]="Label";TypeScript.Label=99;TypeScript._map[100]=
"LabeledStatement";TypeScript.LabeledStatement=100;TypeScript._map[101]="EBStart";TypeScript.EBStart=101;TypeScript._map[102]="GotoEB";TypeScript.GotoEB=102;TypeScript._map[103]="EndCode";TypeScript.EndCode=103;TypeScript._map[104]="Error";TypeScript.Error=104;TypeScript._map[105]="Comment";TypeScript.Comment=105;TypeScript._map[106]="Debugger";TypeScript.Debugger=106;TypeScript.GeneralNode=TypeScript.FuncDecl;TypeScript.LastAsg=TypeScript.AsgRs2}
function v48(){var TypeScript=v18791;function v47(ModuleGenTarget){ModuleGenTarget._map=[];ModuleGenTarget.Synchronous=0;ModuleGenTarget.Asynchronous=1;ModuleGenTarget.Local=2}function v46(CodeGenTarget){CodeGenTarget._map=[];CodeGenTarget.ES3=0;CodeGenTarget.ES5=1}function v45(TypeRelationshipFlags){TypeRelationshipFlags._map=[];TypeRelationshipFlags.SuccessfulComparison=0;TypeRelationshipFlags.SourceIsNullTargetIsVoidOrUndefined=1;TypeRelationshipFlags.RequiredPropertyIsMissing=2;TypeRelationshipFlags.IncompatibleSignatures=
4;TypeRelationshipFlags.SourceSignatureHasTooManyParameters=3;TypeRelationshipFlags.IncompatibleReturnTypes=16;TypeRelationshipFlags.IncompatiblePropertyTypes=32;TypeRelationshipFlags.IncompatibleParameterTypes=64}function v44(TypeFlags){TypeFlags._map=[];TypeFlags.None=0;TypeFlags.HasImplementation=1;TypeFlags.HasSelfReference=2;TypeFlags.MergeResult=4;TypeFlags.IsEnum=8;TypeFlags.BuildingName=16;TypeFlags.HasBaseType=32;TypeFlags.HasBaseTypeOfObject=64;TypeFlags.IsClass=128}function v43(SignatureFlags){SignatureFlags._map=
[];SignatureFlags.None=0;SignatureFlags.IsIndexer=1;SignatureFlags.IsStringIndexer=2;SignatureFlags.IsNumberIndexer=4}function v42(FncFlags){FncFlags._map=[];FncFlags.None=0;FncFlags.Exported=1;FncFlags.Private=2;FncFlags.Public=4;FncFlags.Ambient=8;FncFlags.Static=16;FncFlags.LocalStatic=32;FncFlags.GetAccessor=64;FncFlags.SetAccessor=128;FncFlags.Definition=256;FncFlags.Signature=512;FncFlags.Method=1024;FncFlags.HasReturnExpression=2048;FncFlags.CallMember=4096;FncFlags.ConstructMember=8192;FncFlags.HasSelfReference=
16384;FncFlags.IsFatArrowFunction=32768;FncFlags.IndexerMember=65536;FncFlags.IsFunctionExpression=131072;FncFlags.ClassMethod=262144;FncFlags.ClassPropertyMethodExported=524288;FncFlags.HasSuperReferenceInFatArrowFunction=1048576;FncFlags.IsPropertyBound=2097152}function v41(VarFlags){VarFlags._map=[];VarFlags.None=0;VarFlags.Exported=1;VarFlags.Private=2;VarFlags.Public=4;VarFlags.Ambient=8;VarFlags.Static=16;VarFlags.LocalStatic=32;VarFlags.GetAccessor=64;VarFlags.SetAccessor=128;VarFlags.AutoInit=
256;VarFlags.Property=512;VarFlags.Readonly=1024;VarFlags.Class=2048;VarFlags.ClassProperty=4096;VarFlags.ClassBodyProperty=8192;VarFlags.ClassConstructorProperty=16384;VarFlags.ClassSuperMustBeFirstCallInConstructor=32768;VarFlags.Constant=65536;VarFlags.MustCaptureThis=131072}function v40(SymbolFlags){SymbolFlags._map=[];SymbolFlags.None=0;SymbolFlags.Exported=1;SymbolFlags.Private=2;SymbolFlags.Public=4;SymbolFlags.Ambient=8;SymbolFlags.Static=16;SymbolFlags.LocalStatic=32;SymbolFlags.GetAccessor=
64;SymbolFlags.SetAccessor=128;SymbolFlags.Property=256;SymbolFlags.Readonly=512;SymbolFlags.ModuleMember=1024;SymbolFlags.InterfaceMember=2048;SymbolFlags.ClassMember=4096;SymbolFlags.BuiltIn=8192;SymbolFlags.TypeSetDuringScopeAssignment=16384;SymbolFlags.Constant=32768;SymbolFlags.Optional=65536;SymbolFlags.RecursivelyReferenced=131072;SymbolFlags.Bound=262144;SymbolFlags.CompilerGenerated=524288}function v39(ModuleFlags){ModuleFlags._map=[];ModuleFlags.None=0;ModuleFlags.Exported=1;ModuleFlags.Private=
2;ModuleFlags.Public=4;ModuleFlags.Ambient=8;ModuleFlags.Static=16;ModuleFlags.LocalStatic=32;ModuleFlags.GetAccessor=64;ModuleFlags.SetAccessor=128;ModuleFlags.IsEnum=256;ModuleFlags.ShouldEmitModuleDecl=512;ModuleFlags.IsWholeFile=1024;ModuleFlags.IsDynamic=2048;ModuleFlags.MustCaptureThis=4096}function v38(DeclFlags){DeclFlags._map=[];DeclFlags.None=0;DeclFlags.Exported=1;DeclFlags.Private=2;DeclFlags.Public=4;DeclFlags.Ambient=8;DeclFlags.Static=16;DeclFlags.LocalStatic=32;DeclFlags.GetAccessor=
64;DeclFlags.SetAccessor=128}function v37(ASTFlags){ASTFlags._map=[];ASTFlags.None=0;ASTFlags.ExplicitSemicolon=1;ASTFlags.AutomaticSemicolon=2;ASTFlags.Writeable=4;ASTFlags.Error=8;ASTFlags.DotLHSPartial=16;ASTFlags.DotLHS=32;ASTFlags.IsStatement=64;ASTFlags.StrictMode=128;ASTFlags.PossibleOptionalParameter=256;ASTFlags.ClassBaseConstructorCall=512;ASTFlags.OptionalName=1024;ASTFlags.SkipNextRParen=2048}function v36(Modifiers){Modifiers._map=[];Modifiers.None=0;Modifiers.Private=1;Modifiers.Public=
2;Modifiers.Readonly=4;Modifiers.Ambient=8;Modifiers.Exported=16;Modifiers.Getter=32;Modifiers.Setter=64;Modifiers.Static=128}function v35(AllowedElements){AllowedElements._map=[];AllowedElements.None=0;AllowedElements.ModuleDeclarations=4;AllowedElements.ClassDeclarations=8;AllowedElements.InterfaceDeclarations=16;AllowedElements.AmbientDeclarations=1024;AllowedElements.Properties=2048;AllowedElements.Global=AllowedElements.ModuleDeclarations|AllowedElements.ClassDeclarations|AllowedElements.InterfaceDeclarations|
AllowedElements.AmbientDeclarations;AllowedElements.QuickParse=AllowedElements.Global|AllowedElements.Properties}function v34(ErrorRecoverySet){ErrorRecoverySet._map=[];ErrorRecoverySet.None=0;ErrorRecoverySet.Comma=1;ErrorRecoverySet.SColon=2;ErrorRecoverySet.Asg=4;ErrorRecoverySet.BinOp=8;ErrorRecoverySet.RBrack=16;ErrorRecoverySet.RCurly=32;ErrorRecoverySet.RParen=64;ErrorRecoverySet.Dot=128;ErrorRecoverySet.Colon=256;ErrorRecoverySet.PrimType=512;ErrorRecoverySet.AddOp=1024;ErrorRecoverySet.LCurly=
2048;ErrorRecoverySet.PreOp=4096;ErrorRecoverySet.RegExp=8192;ErrorRecoverySet.LParen=16384;ErrorRecoverySet.LBrack=32768;ErrorRecoverySet.Scope=65536;ErrorRecoverySet.In=131072;ErrorRecoverySet.SCase=262144;ErrorRecoverySet.Else=524288;ErrorRecoverySet.Catch=1048576;ErrorRecoverySet.Var=2097152;ErrorRecoverySet.Stmt=4194304;ErrorRecoverySet.While=8388608;ErrorRecoverySet.ID=16777216;ErrorRecoverySet.Prefix=33554432;ErrorRecoverySet.Literal=67108864;ErrorRecoverySet.RLit=134217728;ErrorRecoverySet.Func=
268435456;ErrorRecoverySet.EOF=536870912;ErrorRecoverySet.TypeScriptS=1073741824;ErrorRecoverySet.ExprStart=ErrorRecoverySet.SColon|ErrorRecoverySet.AddOp|ErrorRecoverySet.LCurly|ErrorRecoverySet.PreOp|ErrorRecoverySet.RegExp|ErrorRecoverySet.LParen|ErrorRecoverySet.LBrack|ErrorRecoverySet.ID|ErrorRecoverySet.Prefix|ErrorRecoverySet.RLit|ErrorRecoverySet.Func|ErrorRecoverySet.Literal;ErrorRecoverySet.StmtStart=ErrorRecoverySet.ExprStart|ErrorRecoverySet.SColon|ErrorRecoverySet.Var|ErrorRecoverySet.Stmt|
ErrorRecoverySet.While|ErrorRecoverySet.TypeScriptS;ErrorRecoverySet.Postfix=ErrorRecoverySet.Dot|ErrorRecoverySet.LParen|ErrorRecoverySet.LBrack}function hasFlag(val,flag){return 0!=(val&flag)}function ToDeclFlags(fncOrVarOrSymbolOrModuleFlags){return fncOrVarOrSymbolOrModuleFlags}function flagsToString(e,flags){for(var builder="",i=1,v12189=-2147483648>i;v12189;){if(0!=(flags&i))for(var k in e){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v12189=e[k];if(v12189==i){0<builder.length&&
(builder+="|");builder+=k;break}}i<<=1;v12189=-2147483648>i}return builder}TypeScript.hasFlag=hasFlag;var v18683=TypeScript.ErrorRecoverySet;v18683||(v18683=TypeScript.ErrorRecoverySet={});v34(v18683);v18683=TypeScript.AllowedElements;v18683||(v18683=TypeScript.AllowedElements={});v35(v18683);v18683=TypeScript.Modifiers;v18683||(v18683=TypeScript.Modifiers={});v36(v18683);v18683=TypeScript.ASTFlags;v18683||(v18683=TypeScript.ASTFlags={});v37(v18683);v18683=TypeScript.DeclFlags;v18683||(v18683=TypeScript.DeclFlags=
{});v38(v18683);v18683=TypeScript.ModuleFlags;v18683||(v18683=TypeScript.ModuleFlags={});v39(v18683);v18683=TypeScript.SymbolFlags;v18683||(v18683=TypeScript.SymbolFlags={});v40(v18683);v18683=TypeScript.VarFlags;v18683||(v18683=TypeScript.VarFlags={});v41(v18683);v18683=TypeScript.FncFlags;v18683||(v18683=TypeScript.FncFlags={});v42(v18683);v18683=TypeScript.SignatureFlags;v18683||(v18683=TypeScript.SignatureFlags={});v43(v18683);TypeScript.ToDeclFlags=ToDeclFlags;v18683=TypeScript.TypeFlags;v18683||
(v18683=TypeScript.TypeFlags={});v44(v18683);v18683=TypeScript.TypeRelationshipFlags;v18683||(v18683=TypeScript.TypeRelationshipFlags={});v45(v18683);v18683=TypeScript.CodeGenTarget;v18683||(v18683=TypeScript.CodeGenTarget={});v46(v18683);var v18683=TypeScript.CodeGenTarget,v18696=TypeScript.ModuleGenTarget;v18696||(v18696=TypeScript.ModuleGenTarget={});v47(v18696);v18696=TypeScript.ModuleGenTarget;TypeScript.codeGenTarget=v18683.ES3;TypeScript.moduleGenTarget=v18696.Synchronous;TypeScript.optimizeModuleCodeGen=
!0;TypeScript.flagsToString=flagsToString}function v33(s){for(var i=0,v12205=i<s.length;v12205;)v12205=JAM.call(s.charCodeAt,s,[i]),this.cumulative_checksum=this.cumulative_checksum<<1^v12205,i+=1,v12205=i<s.length}function v32(){if(this.checksum!=this.cumulative_checksum)throw Error("Wrong checksum.");this.cumulative_checksum=0}function v31(s){JAM.call(this.Verify,this,[s+"\n"])}function v30(s){JAM.call(this.Verify,this,[s])}
function v29(s){for(var i=0,v12209=i<s.length;v12209;)v12209=JAM.call(s.charCodeAt,s,[i]),this.cumulative_checksum=this.cumulative_checksum<<1^v12209,i+=1,v12209=i<s.length}function v28(){if(this.checksum!=this.cumulative_checksum)throw Error("Wrong checksum.");this.cumulative_checksum=0}function v27(s){JAM.call(this.Verify,this,[s+"\n"])}function v26(s){JAM.call(this.Verify,this,[s])}
function v25(runner){function RunNextSetup(){if(index<length){try{var v18707=suite.benchmarks;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v12212=v18707[index];v12212.Setup()}catch(e){return JAM.call(suite.NotifyError,suite,[e]),null}return RunNextBenchmark}suite.NotifyResult();return null}function RunNextBenchmark(){try{var v18708=suite.benchmarks;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v12214=v18708[index];data=JAM.call(suite.RunSingleBenchmark,
suite,[v12214,data])}catch(e){return JAM.call(suite.NotifyError,suite,[e]),null}return v18708=null==data?RunNextTearDown:RunNextBenchmark()}function RunNextTearDown(){try{var v18710=suite.benchmarks,v18711=index;index+=1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)var v12216=v18710[v18711];v12216.TearDown()}catch(e){return JAM.call(suite.NotifyError,suite,[e]),null}return RunNextSetup}BenchmarkSuite.ResetRNG();this.results=[];this.runner=runner;var length=this.benchmarks.length,
index=0,suite=this,data;return RunNextSetup()}
function v24(benchmark,data$$0){function Measure(data){var elapsed=0,start=new Date,i=0,v18712;for(v18712=doDeterministic?i<benchmark.deterministicIterations:1E3>elapsed;v18712;)benchmark.run(),elapsed=new Date-start,i+=1,v18712=doDeterministic?i<benchmark.deterministicIterations:1E3>elapsed;null!=data&&(data.runs+=i,data.elapsed+=elapsed)}var config=BenchmarkSuite.config,v12221;v12221=void 0!==config.doWarmup?config.doWarmup:benchmark.doWarmup;var doDeterministic=config=void 0!==config.doDeterministic?
config.doDeterministic:benchmark.doDeterministic;(config=!v12221)&&(config=null==data$$0);config&&(data$$0={runs:0,elapsed:0});if(null==data$$0)return Measure(null),{runs:0,elapsed:0};Measure(data$$0);if(data$$0.runs<benchmark.minIterations)return data$$0;config=1E3*data$$0.elapsed/data$$0.runs;v12221=null!=benchmark.rmsResult?benchmark.rmsResult():0;JAM.call(this.NotifyStep,this,[new BenchmarkResult(benchmark,config,v12221)]);return null}
function v23(error){if(this.runner.NotifyError){var v12230=this.runner;JAM.call(v12230.NotifyError,v12230,[this.name,error])}this.runner.NotifyStep&&(error=this.runner,JAM.call(error.NotifyStep,error,[this.name]))}function v22(runner){var v12236=BenchmarkSuite.scores;JAM.call(v12236.push,v12236,[1]);runner.NotifyResult&&JAM.call(runner.NotifyResult,runner,[this.name,"Skipped"])}
function v21(){var mean=JAM.call(BenchmarkSuite.GeometricMeanTime,BenchmarkSuite,[this.results]),mean=this.reference[0]/mean,v12241=BenchmarkSuite.scores;JAM.call(v12241.push,v12241,[mean]);this.runner.NotifyResult&&(mean=JAM.call(BenchmarkSuite.FormatScore,BenchmarkSuite,[100*mean]),v12241=this.runner,JAM.call(v12241.NotifyResult,v12241,[this.name,mean]));2==this.reference.length&&(mean=JAM.call(BenchmarkSuite.GeometricMeanLatency,BenchmarkSuite,[this.results]),0!=mean&&(mean=this.reference[1]/mean,
v12241=BenchmarkSuite.scores,JAM.call(v12241.push,v12241,[mean]),this.runner.NotifyResult&&(mean=JAM.call(BenchmarkSuite.FormatScore,BenchmarkSuite,[100*mean]),v12241=this.runner,JAM.call(v12241.NotifyResult,v12241,[this.name+"Latency",mean]))))}function v20(result){var v12255=this.results;JAM.call(v12255.push,v12255,[result]);this.runner.NotifyStep&&(v12255=this.runner,JAM.call(v12255.NotifyStep,v12255,[result.benchmark.name]))}
function v19(value){return 100<value?value.toFixed(0):value.toPrecision(3)}
function v18(measurements){for(var log=0,hasLatencyResult=!1,i=0,v12261=i<measurements.length;v12261;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v12261=measurements[i];if(0!=v12261.latency){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)hasLatencyResult=measurements[i];log+=JAM.call(Math.log,Math,[hasLatencyResult.latency]);hasLatencyResult=!0}i+=1;v12261=i<measurements.length}return hasLatencyResult?Math.pow(Math.E,log/measurements.length):0}
function v17(measurements){for(var log=0,i=0,v12264=i<measurements.length;v12264;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v12264=measurements[i];log+=JAM.call(Math.log,Math,[v12264.time]);i+=1;v12264=i<measurements.length}return Math.pow(Math.E,log/measurements.length)}
function v16(numbers){for(var log=0,i=0,v12267=i<numbers.length;v12267;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v12267=numbers[i];log+=JAM.call(Math.log,Math,[v12267]);i+=1;v12267=i<numbers.length}return Math.pow(Math.E,log/numbers.length)}
function v15(){for(var result=0,suites=BenchmarkSuite.suites,i=0,v12270=i<suites.length;v12270;){introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v12270=suites[i];result+=v12270.benchmarks.length;i+=1;v12270=i<suites.length}return result}
function v14(runner,skipBenchmarks){function RunStep(){var v18752=continuation;for(v18752||(v18752=index<length);v18752;){if(continuation)continuation=continuation();else{v18752=index;index+=1;introspect(JAM.policy.pC545F199BE443C5FB0DC91C55134FB746FD8B074)v18752=suites[v18752];runner.NotifyStart&&JAM.call(runner.NotifyStart,runner,[v18752.name]);-1<skipBenchmarks.indexOf(v18752.name)?JAM.call(v18752.NotifySkipped,v18752,[runner]):continuation=JAM.call(v18752.RunStep,v18752,[runner])}if(v18752=continuation)if(v18752=
"undefined"!=typeof window)v18752=window.setTimeout;if(v18752){window.setTimeout(RunStep,25);return}(v18752=continuation)||(v18752=index<length)}runner.NotifyScore&&(v18752=JAM.call(BenchmarkSuite.GeometricMean,BenchmarkSuite,[BenchmarkSuite.scores]),v18752=JAM.call(BenchmarkSuite.FormatScore,BenchmarkSuite,[100*v18752]),JAM.call(runner.NotifyScore,runner,[v18752]))}var v12280;skipBenchmarks=v12280="undefined"===typeof skipBenchmarks?[]:skipBenchmarks;var continuation=null,suites=BenchmarkSuite.suites,
length=suites.length;BenchmarkSuite.scores=[];var index=0;RunStep()}function v13(){function v12(){function v11(){seed=seed+2127912214+(seed<<12)&4294967295;seed=(seed^3345072700^seed>>>19)&4294967295;seed=seed+374761393+(seed<<5)&4294967295;seed=(seed+3550635116^seed<<9)&4294967295;seed=seed+4251993797+(seed<<3)&4294967295;seed=(seed^3042594569^seed>>>16)&4294967295;return(seed&268435455)/268435456}var seed=49734321;return v11}var v12288=Math,v27444=v12();v12288.random=v27444}
function v10(s){throw"Alert called with argument: "+s;}function v9(){return this.time}function v8(){var v12289=performance.now;v12289||(v12289=performance.mozNow,v12289||(v12289=performance.msNow,v12289||(v12289=performance.oNow,v12289||(v12289=performance.webkitNow,v12289||(v12289=Date.now)))));return v12289}
function Benchmark(){var name="Typescript",doWarmup=!1,doDeterministic=!0,deterministicIterations=5,run=runTypescript,setup=setupTypescript,tearDown=tearDownTypescript,rmsResult=null,minIterations=1;function v1(){}function v0(){}this.name=name;this.doWarmup=doWarmup;this.doDeterministic=doDeterministic;this.deterministicIterations=deterministicIterations;this.run=run;this.Setup=name=setup?setup:v0;this.TearDown=tearDown=tearDown?tearDown:v1;this.rmsResult=rmsResult=rmsResult?rmsResult:null;this.minIterations=
minIterations=minIterations?minIterations:32}function BenchmarkResult(benchmark,time,latency){this.benchmark=benchmark;this.time=time;this.latency=latency}function BenchmarkSuite(name,reference,benchmarks){this.name=name;this.reference=reference;this.benchmarks=benchmarks;name=BenchmarkSuite.suites;JAM.call(name.push,name,[this])}function setupTypescript(){}function tearDownTypescript(){compiler_input=null}
function runTypescript(){function v5(path){return path}function v4(path){return!1}function v3(path){return!1}function v2(fileName){return outfile}var compiler=createCompiler();JAM.call(compiler.addUnit,compiler,[compiler_input,"compiler_input.ts"]);parseErrors=[];compiler.reTypeCheck();JAM.call(compiler.emit,compiler,[{createFile:v2,fileExists:v3,directoryExists:v4,resolvePath:v5}]);(compiler=192!=parseErrors.length)&&(compiler=193!=parseErrors.length);if(compiler)throw Error("Parse errors.");compiler=
null}function createCompiler(){function v6(start,len,message){JAM.call(parseErrors.push,parseErrors,[{start:start,len:len,message:message}])}var settings=new TypeScript.CompilationSettings;settings.codeGenTarget=TypeScript.CodeGenTarget.ES5;settings=JAM.new(TypeScript.TypeScriptCompiler,[outerr,new TypeScript.NullLogger,settings]);JAM.call(settings.setErrorCallback,settings,[v6]);settings.parser.errorRecovery=!0;settings.typeCheck();return settings}
function ShowBox(name){function v7(entry){name.valueOf()===entry.valueOf()&&(entry=document.getElementById("Box-"+name+"Latency"),entry.style.visibility="visible")}var box=document.getElementById("Box-"+name);box.style.visibility="visible";document.getElementById("progress-bar").style.width=""+100*((completed+=1)/benchmarks)+"%";latencyBenchmarks.forEach(v7)}
function AddResult(name,result){JAM.call(console.log,console,[name+": "+result]);var box=document.getElementById("Result-"+name);JAM.set(box,"innerHTML",result)}function AddError(name,error){JAM.call(console.log,console,[name+": "+error.message]);"TypedArrayUnsupported"==error?AddResult(name,"<b>Unsupported</b>"):"PerformanceNowUnsupported"==error?AddResult(name,"<b>Timer error</b>"):AddResult(name,"<b>Error</b>");success=!1}
function AddScore(score){var status=document.getElementById("main-banner");success?JAM.set(status,"innerHTML","Octane Score: "+score):JAM.set(status,"innerHTML","Octane Score (incomplete): "+score);document.getElementById("progress-bar-container").style.visibility="hidden";document.getElementById("bottom-text").style.visibility="visible";document.getElementById("inside-anchor").removeChild(document.getElementById("bar-appendix"));document.getElementById("alertbox").style.visibility="hidden"}
function Run(){JAM.set(document.getElementById("main-banner"),"innerHTML","Running Octane...");JAM.set(document.getElementById("bar-appendix"),"innerHTML",'<br/><div class="progress progress-striped" id="progress-bar-container" style="visibility:hidden"><div class="bar"style="width: 0%;" id="progress-bar"></div></div>');var anchor=document.getElementById("run-octane"),parent=document.getElementById("main-container");JAM.call(parent.appendChild,parent,[document.getElementById("inside-anchor")]);parent.removeChild(anchor);
JAM.set(document.getElementById("startup-text"),"innerHTML","");document.getElementById("progress-bar-container").style.visibility="visible";JAM.call(BenchmarkSuite.RunSuites,BenchmarkSuite,[{NotifyStart:ShowBox,NotifyError:AddError,NotifyResult:AddResult,NotifyScore:AddScore},skipBenchmarks])}
function CheckCompatibility(){var v12325="undefined"!=typeof Uint8Array;v12325&&(v12325="undefined"!=typeof Float64Array)&&(v12325="undefined"!=typeof(new Uint8Array(0)).subarray);v12325||(JAM.call(console.log,console,["Typed Arrays not supported"]),document.getElementById("alertbox").style.display="block");0<=window.document.URL.indexOf("skip_zlib=1")&&JAM.call(skipBenchmarks.push,skipBenchmarks,["zlib"]);0<=window.document.URL.indexOf("auto=1")&&Run()}
function Load(){JAM.call(setTimeout,null,[CheckCompatibility,200])}var performance=performance||{},v12330=performance,v27445=v8();v12330.now=v27445;BenchmarkResult.prototype.valueOf=v9;BenchmarkSuite.suites=[];BenchmarkSuite.version="9";BenchmarkSuite.config={doWarmup:void 0,doDeterministic:void 0};alert=v10;BenchmarkSuite.ResetRNG=v13;BenchmarkSuite.RunSuites=v14;BenchmarkSuite.CountBenchmarks=v15;BenchmarkSuite.GeometricMean=v16;BenchmarkSuite.GeometricMeanTime=v17;
BenchmarkSuite.GeometricMeanLatency=v18;BenchmarkSuite.FormatScore=v19;BenchmarkSuite.prototype.NotifyStep=v20;BenchmarkSuite.prototype.NotifyResult=v21;BenchmarkSuite.prototype.NotifySkipped=v22;BenchmarkSuite.prototype.NotifyError=v23;BenchmarkSuite.prototype.RunSingleBenchmark=v24;BenchmarkSuite.prototype.RunStep=v25;
var typescript=new BenchmarkSuite("Typescript",[255011322],[new Benchmark]),parseErrors=[],outfile={checksum:-412589664,cumulative_checksum:0,Write:v26,WriteLine:v27,Close:v28,Verify:v29},outerr={checksum:0,cumulative_checksum:0,Write:v30,WriteLine:v31,Close:v32,Verify:v33},v27697='//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nmodule TypeScript {\n    export class AstLogger {\n\n        constructor (public logger: ILogger) { }\n\n        public logScript(script: TypeScript.Script): void {\n            this.logLinemap(script.locationInfo.lineMap);\n\n            var stack: AST[]= [];\n\n            var pre = (cur: TypeScript.AST, parent: TypeScript.AST) => {\n                stack.push(cur);\n                var indent = (stack.length - 1) * 2;\n                this.logComments(script, cur.preComments, indent);\n                this.logNode(script, cur, indent);\n                this.logComments(script, cur.postComments, indent);\n                return cur;\n            }\n\n            var post = (cur: TypeScript.AST, parent: TypeScript.AST) => {\n                stack.pop();\n                return cur;\n            }\n\n            TypeScript.getAstWalkerFactory().walk(script, pre, post);\n        }\n\n\n        public logNode(script: TypeScript.Script, cur: TypeScript.AST, indent: number) {\n            var msg = this.addPadding("", indent, "| ", true);\n\n            msg = msg.concat("+ " + cur.treeViewLabel());\n            msg = this.addPadding(msg, 70, " ", false);\n\n            msg = msg + this.addLineColumn(script, cur.minChar);\n            msg = this.addPadding(msg, 80, " ", false);\n\n            msg = msg + "=> ";\n            msg = msg + this.addLineColumn(script, cur.limChar);\n            msg = this.addPadding(msg, 102, " ", false);\n\n            msg = msg.concat("[" + this.addPadding(cur.minChar.toString(), 1, " ", true) + ", " + this.addPadding(cur.limChar.toString(), 1, " ", true) + "]");\n\n            msg = this.addPadding(msg, 115, " ", false);\n            msg = msg.concat("sym=" + (<any>cur).sym);\n\n            msg = this.addPadding(msg, 135, " ", false);\n            msg = msg.concat("type=" + (cur.type === null ? "null" : cur.type.getTypeName()));\n            this.logger.log(msg);\n        }\n\n        private logComments(script: TypeScript.Script, comments: TypeScript.AST[], indent: number) {\n            if (comments == null)\n                return;\n\n            for (var i = 0; i < comments.length; i++) {\n                this.logNode(script, comments[i], indent);\n            }\n        }\n\n        public logLinemap(linemap: number[]) {\n            var result = "[";\n            for (var i = 0; i < linemap.length; i++) {\n                if (i > 0)\n                    result += ",";\n                result += linemap[i];\n            }\n            result += "]";\n            this.logger.log("linemap: " + result);\n        }\n\n        private addPadding(s: string, targetLength: number, paddingString: string, leftPadding: bool): string {\n            var result = (leftPadding ? "" : s);\n            for (var i = s.length; i < targetLength; i++) {\n                result = result + paddingString;\n            }\n            result = result + (leftPadding ? s : "");\n            return result;\n        }\n\n        private addLineColumn(script: TypeScript.Script, position: number): string {\n            // just for calling getSourceLineColFromMap\n            var lineInfo = {\n                line: -1,\n                col: -1\n            }\n            TypeScript.getSourceLineColFromMap(lineInfo, position, script.locationInfo.lineMap);\n\n            if (lineInfo.col !== -1) {\n                lineInfo.col++; //TODO: function above seems to consider line as 1-based, and column as 0-based\n            }\n\n            return "(" + lineInfo.line + ", " + lineInfo.col + ")";\n        }\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export function lastOf(items: any[]): any {\n        return (items === null || items.length === 0) ? null : items[items.length - 1];\n    }\n\n    export function max(a: number, b: number): number {\n        return a >= b ? a : b;\n    }\n\n    export function min(a: number, b: number): number {\n        return a <= b ? a : b;\n    }\n\n    //\n    // Helper class representing a path from a root ast node to a (grand)child ast node.\n    // This is helpful as our tree don\'t have parents.\n    //\n    export class AstPath {\n        public asts: TypeScript.AST[] = [];\n        public top: number = -1;\n\n        static reverseIndexOf(items: any[], index: number): any {\n            return (items === null || items.length <= index) ? null : items[items.length - index - 1];\n        }\n\n        public clone(): AstPath {\n            var clone = new AstPath();\n            clone.asts = this.asts.map((value) => { return value; });\n            clone.top = this.top;\n            return clone;\n        }\n\n        public pop(): TypeScript.AST {\n            var head = this.ast();\n            this.up();\n\n            while (this.asts.length > this.count()) {\n                this.asts.pop();\n            }\n            return head;\n        }\n\n        public push(ast: TypeScript.AST) {\n            while (this.asts.length > this.count()) {\n                this.asts.pop();\n            }\n            this.top = this.asts.length;\n            this.asts.push(ast);\n        }\n\n        public up() {\n            if (this.top <= -1)\n                throw new Error("Invalid call to \'up\'");\n            this.top--;\n        }\n\n        public down() {\n            if (this.top == this.ast.length - 1)\n                throw new Error("Invalid call to \'down\'");\n            this.top++;\n        }\n\n        public nodeType(): TypeScript.NodeType {\n            if (this.ast() == null)\n                return TypeScript.NodeType.None;\n            return this.ast().nodeType;\n        }\n\n        public ast() {\n            return <TypeScript.AST>AstPath.reverseIndexOf(this.asts, this.asts.length - (this.top + 1));\n        }\n\n        public parent() {\n            return <TypeScript.AST>AstPath.reverseIndexOf(this.asts, this.asts.length - this.top);\n        }\n\n        public count() {\n            return this.top + 1;\n        }\n\n        public get(index: number): TypeScript.AST {\n            return this.asts[index];\n        }\n\n        public isNameOfClass(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === TypeScript.NodeType.Name) &&\n                (this.parent().nodeType === TypeScript.NodeType.ClassDeclaration) &&\n                ((<TypeScript.InterfaceDeclaration>this.parent()).name === this.ast());\n        }\n\n        public isNameOfInterface(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === TypeScript.NodeType.Name) &&\n                (this.parent().nodeType === TypeScript.NodeType.InterfaceDeclaration) &&\n                ((<TypeScript.InterfaceDeclaration>this.parent()).name === this.ast());\n        }\n\n        public isNameOfArgument(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === TypeScript.NodeType.Name) &&\n                (this.parent().nodeType === TypeScript.NodeType.ArgDecl) &&\n                ((<TypeScript.ArgDecl>this.parent()).id === this.ast());\n        }\n\n        public isNameOfVariable(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === TypeScript.NodeType.Name) &&\n                (this.parent().nodeType === Ty',
v27696=v27697+"peScript.NodeType.VarDecl) &&\n                ((<TypeScript.VarDecl>this.parent()).id === this.ast());\n        }\n\n        public isNameOfModule(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === TypeScript.NodeType.Name) &&\n                (this.parent().nodeType === TypeScript.NodeType.ModuleDeclaration) &&\n                ((<TypeScript.ModuleDeclaration>this.parent()).name === this.ast());\n        }\n\n        public isNameOfFunction(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === TypeScript.NodeType.Name) &&\n                (this.parent().nodeType === TypeScript.NodeType.FuncDecl) &&\n                ((<TypeScript.FuncDecl>this.parent()).name === this.ast());\n        }\n\n        public isChildOfScript(): bool {\n            var ast = lastOf(this.asts);\n            return this.count() >= 3 &&\n                this.asts[this.top] === ast &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.Script;\n        }\n\n        public isChildOfModule(): bool {\n            var ast = lastOf(this.asts);\n            return this.count() >= 3 &&\n                this.asts[this.top] === ast &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.ModuleDeclaration;\n        }\n\n        public isChildOfClass(): bool {\n            var ast = lastOf(this.asts);\n            return this.count() >= 3 &&\n                this.asts[this.top] === ast &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.ClassDeclaration;\n        }\n\n        public isArgumentOfClassConstructor(): bool {\n            var ast = lastOf(this.asts);\n            return this.count() >= 5 &&\n                this.asts[this.top] === ast &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.FuncDecl &&\n                this.asts[this.top - 3].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 4].nodeType === TypeScript.NodeType.ClassDeclaration &&\n                ((<TypeScript.FuncDecl>this.asts[this.top - 2]).isConstructor) &&\n                ((<TypeScript.FuncDecl>this.asts[this.top - 2]).arguments === this.asts[this.top - 1]) &&\n                ((<TypeScript.ClassDeclaration>this.asts[this.top - 4]).constructorDecl === this.asts[this.top - 2]);\n        }\n\n        public isChildOfInterface(): bool {\n            var ast = lastOf(this.asts);\n            return this.count() >= 3 &&\n                this.asts[this.top] === ast &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.InterfaceDeclaration;\n        }\n\n        public isTopLevelImplicitModule() {\n            return this.count() >= 1 &&\n                this.asts[this.top].nodeType === TypeScript.NodeType.ModuleDeclaration &&\n                TypeScript.hasFlag((<TypeScript.ModuleDeclaration>this.asts[this.top]).modFlags, TypeScript.ModuleFlags.IsWholeFile);\n        }\n\n        public isBodyOfTopLevelImplicitModule() {\n            return this.count() >= 2 &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ModuleDeclaration &&\n                 (<TypeScript.ModuleDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0] &&\n                TypeScript.hasFlag((<TypeScript.ModuleDeclaration>this.asts[this.top - 1]).modFlags, TypeScript.ModuleFlags.IsWholeFile);\n        }\n\n        public isBodyOfScript(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Script &&\n                 (<TypeScript.Script>this.asts[this.top - 1]).bod == this.asts[this.top - 0];\n        }\n\n        public isBodyOfSwitch(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Switch &&\n                 (<TypeScript.SwitchStatement>this.asts[this.top - 1]).caseList == this.asts[this.top - 0];\n        }\n\n        public isBodyOfModule(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ModuleDeclaration &&\n                 (<TypeScript.ModuleDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0];\n        }\n\n        public isBodyOfClass(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ClassDeclaration &&\n                 (<T",
v27695=v27696+"ypeScript.ClassDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0];\n        }\n\n        public isBodyOfFunction(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.FuncDecl &&\n                 (<TypeScript.FuncDecl>this.asts[this.top - 1]).bod == this.asts[this.top - 0];\n        }\n\n        public isBodyOfInterface(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.InterfaceDeclaration &&\n                 (<TypeScript.InterfaceDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0];\n        }\n\n        public isBodyOfBlock(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Block &&\n                (<TypeScript.Block>this.asts[this.top - 1]).statements == this.asts[this.top - 0];\n        }\n\n        public isBodyOfFor(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.For &&\n                (<TypeScript.ForStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfCase(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Case &&\n                (<TypeScript.CaseStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfTry(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Try &&\n                (<TypeScript.Try>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfCatch(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Catch &&\n                (<TypeScript.Catch>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfDoWhile(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.DoWhile &&\n                (<TypeScript.DoWhileStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfWhile(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.While &&\n                (<TypeScript.WhileStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfForIn(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ForIn &&\n                (<TypeScript.ForInStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfWith(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.With &&\n                (<TypeScript.WithStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfFinally(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Finally &&\n                (<TypeScript.Finally>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isCaseOfSwitch(): bool {\n            return this.count() >= 3 &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.Switch &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                (<TypeScript.SwitchStatement>this.asts[this.top - 2]).caseList == this.asts[this.top - 1];\n        }\n\n        public isDefaultCaseOfSwitch(): bool {\n            return this.count() >= 3 &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.Switch &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                (<TypeScript.SwitchStatement>this.asts[this.top - 2]).caseList == this.asts[this.top - 1] &&\n                (<TypeScript.SwitchStatement>this.asts[this.top - 2]).defaultCase == this.asts[this.top - 0];\n        }\n\n        public isListOfObjectLit(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ObjectLit &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&\n                (<TypeScript.UnaryExpression>this.asts[this.top - 1]).operand == this.asts[this.top - 0];\n        }\n\n        public isBodyOfObjectLit(): bool {\n            return this.isListOfObjectLit();\n        }\n\n        public isEmptyListOfObjectLit(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ObjectLit &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&\n                (<TypeScript.UnaryExpression>this.asts[t",
v27694=v27695+"his.top - 1]).operand == this.asts[this.top - 0] &&\n                (<TypeScript.ASTList>this.asts[this.top - 0]).members.length == 0;\n        }\n\n        public isMemberOfObjectLit(): bool {\n            return this.count() >= 3 &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.ObjectLit &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.Member &&\n                (<TypeScript.UnaryExpression>this.asts[this.top - 2]).operand == this.asts[this.top - 1];\n        }\n\n        public isNameOfMemberOfObjectLit(): bool {\n            return this.count() >= 4 &&\n                this.asts[this.top - 3].nodeType === TypeScript.NodeType.ObjectLit &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Member &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.Name &&\n                (<TypeScript.UnaryExpression>this.asts[this.top - 3]).operand == this.asts[this.top - 2];\n        }\n\n        public isListOfArrayLit(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ArrayLit &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&\n                (<TypeScript.UnaryExpression>this.asts[this.top - 1]).operand == this.asts[this.top - 0];\n        }\n\n        public isTargetOfMember(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Member &&\n                (<TypeScript.BinaryExpression>this.asts[this.top - 1]).operand1 === this.asts[this.top - 0];\n        }\n\n        public isMemberOfMember(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Member &&\n                (<TypeScript.BinaryExpression>this.asts[this.top - 1]).operand2 === this.asts[this.top - 0];\n        }\n\n        public isItemOfList(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List;\n            //(<Tools.ASTList>this.asts[this.top - 1]).operand2 === this.asts[this.top - 0];\n        }\n\n        public isThenOfIf(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.If &&\n                (<TypeScript.IfStatement>this.asts[this.top - 1]).thenBod == this.asts[this.top - 0];\n        }\n\n        public isElseOfIf(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.If &&\n                (<TypeScript.IfStatement>this.asts[this.top - 1]).elseBod == this.asts[this.top - 0];\n        }\n\n        public isBodyOfDefaultCase(): bool {\n            return this.isBodyOfCase();\n        }\n\n        public isSingleStatementList(): bool {\n            return this.count() >= 1 &&\n                this.asts[this.top].nodeType === TypeScript.NodeType.List &&\n                (<TypeScript.ASTList>this.asts[this.top]).members.length === 1;\n        }\n\n        public isArgumentListOfFunction(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.FuncDecl &&\n                (<TypeScript.FuncDecl>this.asts[this.top - 1]).arguments === this.asts[this.top - 0];\n        }\n\n        public isArgumentOfFunction(): bool {\n            return this.count() >= 3 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.FuncDecl &&\n                (<TypeScript.FuncDecl>this.asts[this.top - 2]).arguments === this.asts[this.top - 1];\n        }\n\n        public isArgumentListOfCall(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Call &&\n                (<TypeScript.CallExpression>this.asts[this.top - 1]).arguments === this.asts[this.top - 0];\n        }\n\n        public isArgumentListOfNew(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.New &&\n                (<TypeScript.CallExpression>this.asts[this.top - 1]).arguments === this.asts[this.top - 0];\n        }\n\n        public isSynthesizedBlock(): bool {\n            return this.count() >= 1 &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.Block &&\n                (<TypeScript.Block>this.asts[this.top - 0]).isStatementBlock === false;\n        }\n    }\n\n    export function isValidAstNode(ast: Typ",
v27693=v27694+'eScript.ASTSpan): bool {\n        if (ast === null)\n            return false;\n\n        if (ast.minChar === -1 || ast.limChar === -1)\n            return false;\n\n        return true;\n    }\n\n    export class AstPathContext {\n        public path = new TypeScript.AstPath();\n    }\n\n    export enum GetAstPathOptions {\n        Default = 0,\n        EdgeInclusive = 1,\n        //We need this options dealing with an AST coming from an incomplete AST. For example:\n        //     class foo { // r\n        // If we ask for the AST at the position after the "r" character, we won\'t see we are \n        // inside a comment, because the "class" AST node has a limChar corresponding to the position of \n        // the "{" character, meaning we don\'t traverse the tree down to the stmt list of the class, meaning\n        // we don\'t find the "precomment" attached to the errorneous empty stmt.\n        //TODO: It would be nice to be able to get rid of this.\n        DontPruneSearchBasedOnPosition = 1 << 1,\n    }\n\n    ///\n    /// Return the stack of AST nodes containing "position"\n    ///\n    export function getAstPathToPosition(script: TypeScript.AST, pos: number, options = GetAstPathOptions.Default): TypeScript.AstPath {\n        var lookInComments = (comments: TypeScript.Comment[]) => {\n            if (comments && comments.length > 0) {\n                for (var i = 0; i < comments.length; i++) {\n                    var minChar = comments[i].minChar;\n                    var limChar = comments[i].limChar;\n                    if (!comments[i].isBlockComment) {\n                        limChar++; // For single line comments, include 1 more character (for the newline)\n                    }\n                    if (pos >= minChar && pos < limChar) {\n                        ctx.path.push(comments[i]);\n                    }\n                }\n            }\n        }\n\n        var pre = function (cur: TypeScript.AST, parent: TypeScript.AST, walker: IAstWalker) {\n            if (isValidAstNode(cur)) {\n\n                // Add "cur" to the stack if it contains our position\n                // For "identifier" nodes, we need a special case: A position equal to "limChar" is\n                // valid, since the position corresponds to a caret position (in between characters)\n                // For example:\n                //  bar\n                //  0123\n                // If "position == 3", the caret is at the "right" of the "r" character, which should be considered valid\n                var inclusive =\n                    hasFlag(options, GetAstPathOptions.EdgeInclusive) ||\n                    cur.nodeType === TypeScript.NodeType.Name ||\n                    pos === script.limChar; // Special "EOF" case\n\n                var minChar = cur.minChar;\n                var limChar = cur.limChar + (inclusive ? 1 : 0)\n                if (pos >= minChar && pos < limChar) {\n\n                    // TODO: Since AST is sometimes not correct wrt to position, only add "cur" if it\'s better\n                    //       than top of the stack.\n                    var previous = ctx.path.ast();\n                    if (previous == null || (cur.minChar >= previous.minChar && cur.limChar <= previous.limChar)) {\n                        ctx.path.push(cur);\n                    }\n                    else {\n                        //logger.log("TODO: Ignoring node because minChar, limChar not better than previous node in stack");\n                    }\n                }\n\n                // The AST walker skips comments, but we might be in one, so check the pre/post comments for this node manually\n                if (pos < limChar) {\n                    lookInComments(cur.preComments);\n                }\n                if (pos >= minChar) {\n                    lookInComments(cur.postComments);\n                }\n\n                if (!hasFlag(options, GetAstPathOptions.DontPruneSearchBasedOnPosition)) {\n                    // Don\'t go further down the tree if pos is outside of [minChar, limChar]\n                    walker.options.goChildren = (minChar <= pos && pos <= limChar);\n                }\n            }\n            return cur;\n        }\n\n        var ctx = new AstPathContext();\n        TypeScript.getAstWalkerFactory().walk(script, pre, null, null, ctx);\n        return ctx.path;\n    }\n\n    //\n    // Find a source text offset that is safe for lexing tokens at the given position.\n    // This is used when "position" might be inside a comment or string, etc.\n    //\n    export function getTokenizationOffset(script: TypeScript.Script, position: number): number {\n        var bestOffset = 0;\n        var pre = (cur: TypeScript.AST, parent: TypeScript.AST, walker: TypeScript.IAstWalker): TypeScript.AST => {\n            if (TypeScript.isValidAstNode(cur)) {\n                // Did we find a closer offset?\n                if (cur.minChar <= position) {\n                    bestOffset = max(bestOffset, cur.minChar);\n                }\n\n                // Stop the walk if this node is not related to ',
v27692=v27693+'"minChar"\n                if (cur.minChar > position || cur.limChar < bestOffset) {\n                    walker.options.goChildren = false;\n                }\n            }\n\n            return cur;\n        }\n\n        TypeScript.getAstWalkerFactory().walk(script, pre);\n        return bestOffset;\n    }\n\n    ///\n    /// Simple function to Walk an AST using a simple callback function.\n    ///\n    export function walkAST(ast: TypeScript.AST, callback: (path: AstPath, walker: TypeScript.IAstWalker) => void ): void {\n        var pre = function (cur: TypeScript.AST, parent: TypeScript.AST, walker: TypeScript.IAstWalker) {\n            var path: TypeScript.AstPath = walker.state;\n            path.push(cur);\n            callback(path, walker);\n            return cur;\n        }\n        var post = function (cur: TypeScript.AST, parent: TypeScript.AST, walker: TypeScript.IAstWalker) {\n            var path: TypeScript.AstPath = walker.state;\n            path.pop();\n            return cur;\n        }\n\n        var path = new AstPath();\n        TypeScript.getAstWalkerFactory().walk(ast, pre, post, null, path);\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class ASTSpan {\n        public minChar: number = -1;  // -1 = "undefined" or "compiler generated"\n        public limChar: number = -1;  // -1 = "undefined" or "compiler generated"   \n    }\n\n    export class AST extends ASTSpan {\n        public type: Type = null;\n        public flags = ASTFlags.Writeable;\n\n        // REVIEW: for diagnostic purposes\n        public passCreated: number = CompilerDiagnostics.analysisPass;\n\n        public preComments: Comment[] = null;\n        public postComments: Comment[] = null;\n        private docComments: Comment[] = null;\n\n        public isParenthesized = false;\n\n        constructor (public nodeType: NodeType) {\n            super();\n        }\n\n        public isExpression() { return false; }\n\n        public isStatementOrExpression() { return false; }\n\n        public isCompoundStatement() { return false; }\n\n        public isLeaf() { return this.isStatementOrExpression() && (!this.isCompoundStatement()); }\n        \n        public isDeclaration() { return false; }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            switch (this.nodeType) {\n                case NodeType.Error:\n                case NodeType.EmptyExpr:\n                    this.type = typeFlow.anyType;\n                    break;\n                case NodeType.This:\n                    return typeFlow.typeCheckThis(this);\n                case NodeType.Null:\n                    this.type = typeFlow.nullType;\n                    break;\n                case NodeType.False:\n                case NodeType.True:\n                    this.type = typeFlow.booleanType;\n                    break;\n                case NodeType.Super:\n                    return typeFlow.typeCheckSuper(this);\n                case NodeType.EndCode:\n                case NodeType.Empty:\n                case NodeType.Void:\n                    this.type = typeFlow.voidType;\n                    break;\n                default:\n                    throw new Error("please implement in derived class");\n            }\n            return this;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            switch (this.nodeType) {\n                case NodeType.This:\n                    emitter.recordSourceMappingStart(this);\n                    if (emitter.thisFnc && (hasFlag(emitter.thisFnc.fncFlags, FncFlags.IsFatArrowFunction))) {\n                        emitter.writeToOutput("_this");\n                    }\n                    else {\n                        emitter.writeToOutput("this");\n                    }\n                    emitter.recordSourceMappingEnd(this);\n                    break;\n                case NodeType.Null:\n                    emitter.recordSourceMappingStart(this);\n                    emitter.writeToOutput("null");\n                    emitter.recordSourceMappingEnd(this);\n                    break;\n                case NodeType.False:\n                    emitter.recordSourceMappingStart(this);\n                    emitter.writeToOutput("false");\n                    emitter.recordSourceMappingEnd(this);\n                    break;\n                case NodeType.True',
v27691=v27692+':\n                    emitter.recordSourceMappingStart(this);\n                    emitter.writeToOutput("true");\n                    emitter.recordSourceMappingEnd(this);\n                    break;\n                case NodeType.Super:\n                    emitter.recordSourceMappingStart(this);\n                    emitter.emitSuperReference();\n                    emitter.recordSourceMappingEnd(this);\n                    break;\n                case NodeType.EndCode:\n                case NodeType.Error:\n                case NodeType.EmptyExpr:\n                    break;\n                case NodeType.Empty:\n                    emitter.recordSourceMappingStart(this);\n                    emitter.recordSourceMappingEnd(this);\n                    break;\n                case NodeType.Void:\n                    emitter.recordSourceMappingStart(this);\n                    emitter.writeToOutput("void ");\n                    emitter.recordSourceMappingEnd(this);\n                    break;\n                default:\n                    throw new Error("please implement in derived class");\n            }\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public print(context: PrintContext) {\n            context.startLine();\n            var lineCol = { line: -1, col: -1 };\n            var limLineCol = { line: -1, col: -1 };\n            if (context.parser !== null) {\n                context.parser.getSourceLineCol(lineCol, this.minChar);\n                context.parser.getSourceLineCol(limLineCol, this.limChar);\n                context.write("(" + lineCol.line + "," + lineCol.col + ")--" +\n                              "(" + limLineCol.line + "," + limLineCol.col + "): ");\n            }\n            var lab = this.printLabel();\n            if (hasFlag(this.flags, ASTFlags.Error)) {\n                lab += " (Error)";\n            }\n            context.writeLine(lab);\n        }\n\n        public printLabel() {\n            if (nodeTypeTable[this.nodeType] !== undefined) {\n                return nodeTypeTable[this.nodeType];\n            }\n            else {\n                return (<any>NodeType)._map[this.nodeType];\n            }\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            // by default, AST adds itself to current basic block and does not check its children\n            context.walker.options.goChildren = false;\n            context.addContent(this);\n        }\n\n        public netFreeUses(container: Symbol, freeUses: StringHashTable) {\n        }\n\n        public treeViewLabel() {\n            return (<any>NodeType)._map[this.nodeType];\n        }\n\n        public static getResolvedIdentifierName(name: string): string {\n            if (!name) return "";\n\n            var resolved = "";\n            var start = 0;\n            var i = 0;\n            while(i <= name.length - 6) {\n                // Look for escape sequence \\uxxxx\n                if (name.charAt(i) == \'\\\\\' && name.charAt(i+1) == \'u\') {\n                    var charCode = parseInt(name.substr(i + 2, 4), 16);\n                    resolved += name.substr(start, i - start);\n                    resolved += String.fromCharCode(charCode);\n                    i += 6;\n                    start = i;\n                    continue;\n                } \n                i++;\n            }\n            // Append remaining string\n            resolved += name.substring(start);\n            return resolved;\n        }\n\n        public getDocComments() : Comment[] {\n            if (!this.isDeclaration() || !this.preComments || this.preComments.length == 0) {\n                return [];\n            }\n\n            if (!this.docComments) {\n                var preCommentsLength = this.preComments.length;\n                var docComments: Comment[] = [];\n                for (var i = preCommentsLength - 1; i >= 0; i--) {\n                    if (this.preComments[i].isDocComment()) {\n                        var prevDocComment = docComments.length > 0 ? docComments[docComments.length - 1] : null;\n                        if (prevDocComment == null || // If the help comments were not yet set then this is the comment\n                             (this.preComments[i].limLine == prevDocComment.minLine ||\n                              this.preComments[i].limLine + 1 == prevDocComment.minLine)) { // On same line or next line\n                            docComments.push(this.preComments[i]);\n                            continue;\n                        }\n                    }\n                    break;\n                }\n\n                this.docComments = docComments.reverse();\n            }\n\n            return this.docComments;\n        }\n    }\n\n    export class IncompleteAST extends AST {\n        constructor (min: number, lim: number) {\n            super(NodeType.Error);\n\n            this.minChar = min;\n            this.limChar = lim;\n        }\n    }\n\n    export class ASTList extends AST {\n        public enclosingScope: SymbolScope = null;\n        publ',
v27690=v27691+"ic members: AST[] = new AST[];\n\n        constructor () {\n            super(NodeType.List);\n        }\n\n        public addToControlFlow(context: ControlFlowContext) {\n            var len = this.members.length;\n            for (var i = 0; i < len; i++) {\n                if (context.noContinuation) {\n                    context.addUnreachable(this.members[i]);\n                    break;\n                }\n                else {\n                    this.members[i] = context.walk(this.members[i], this);\n                }\n            }\n            context.walker.options.goChildren = false;\n        }\n\n        public append(ast: AST) {\n            this.members[this.members.length] = ast;\n            return this;\n        }\n\n        public appendAll(ast: AST) {\n            if (ast.nodeType == NodeType.List) {\n                var list = <ASTList>ast;\n                for (var i = 0, len = list.members.length; i < len; i++) {\n                    this.append(list.members[i]);\n                }\n            }\n            else {\n                this.append(ast);\n            }\n            return this;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.recordSourceMappingStart(this);\n            emitter.emitJavascriptList(this, null, TokenID.Semicolon, startLine, false, false);\n            emitter.recordSourceMappingEnd(this);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            var len = this.members.length;\n            typeFlow.nestingLevel++;\n            for (var i = 0; i < len; i++) {\n                if (this.members[i]) {\n                    this.members[i] = this.members[i].typeCheck(typeFlow);\n                }\n            }\n            typeFlow.nestingLevel--;\n            return this;\n        }\n    }\n\n    export class Identifier extends AST {\n        public sym: Symbol = null;\n        public cloId = -1;\n        public text: string;\n\n        // 'actualText' is the text that the user has entered for the identifier. the text might \n        // include any Unicode escape sequences (e.g.: \\u0041 for 'A'). 'text', however, contains \n        // the resolved value of any escape sequences in the actual text; so in the previous \n        // example, actualText = '\\u0041', text = 'A'.\n        //\n        // For purposes of finding a symbol, use text, as this will allow you to match all \n        // variations of the variable text. For full-fidelity translation of the user input, such\n        // as emitting, use the actualText field.\n        // \n        // Note: \n        //    To change text, and to avoid running into a situation where 'actualText' does not \n        //    match 'text', always use setText.\n        constructor (public actualText: string, public hasEscapeSequence?: bool) {\n            super(NodeType.Name);\n            this.setText(actualText, hasEscapeSequence);\n        }\n\n        public setText(actualText: string, hasEscapeSequence?: bool) {\n            this.actualText = actualText;\n            if (hasEscapeSequence) {\n                this.text = AST.getResolvedIdentifierName(actualText);\n            }\n            else {\n                this.text = actualText;\n            }\n        }\n\n        public isMissing() { return false; }\n        public isLeaf() { return true; }\n\n        public treeViewLabel() {\n            return \"id: \" + this.actualText;\n        }\n\n        public printLabel() {\n            if (this.actualText) {\n                return \"id: \" + this.actualText;\n            }\n            else {\n                return \"name node\";\n            }\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckName(this);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitJavascriptName(this, true);\n        }\n\n        public static fromToken(token: Token): Identifier {\n            return new Identifier(token.getText(), (<IdentifierToken>token).hasEscapeSequence);\n        }\n    }\n\n    export class MissingIdentifier extends Identifier {\n        constructor () {\n            super(\"__missing\");\n        }\n\n        public isMissing() {\n            return true;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            // Emit nothing for a missing ID\n        }\n    }\n\n    export class Label extends AST {\n        constructor (public id: Identifier) {\n            super(NodeType.Label);\n        }\n\n        public printLabel() { return this.id.actualText + \":\"; }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.type = typeFlow.voidType;\n            return this;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.recordSourceMappingStart(this.id);\n            emitter.writeToOutput(this.id.actualText);\n            emitter.recordSourceMappingEnd(this.id);",
v27689=v27690+'\n            emitter.writeLineToOutput(":");\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export class Expression extends AST {\n        constructor (nodeType: NodeType) {\n            super(nodeType);\n        }\n\n        public isExpression() { return true; }\n\n        public isStatementOrExpression() { return true; }\n    }\n\n    export class UnaryExpression extends Expression {\n        public targetType: Type = null; // Target type for an object literal (null if no target type)\n        public castTerm: AST = null;\n\n        constructor (nodeType: NodeType, public operand: AST) {\n            super(nodeType);\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            super.addToControlFlow(context);\n            // TODO: add successor as catch block/finally block if present\n            if (this.nodeType == NodeType.Throw) {\n                context.returnStmt();\n            }\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            switch (this.nodeType) {\n                case NodeType.Not:\n                    return typeFlow.typeCheckBitNot(this);\n\n                case NodeType.LogNot:\n                    return typeFlow.typeCheckLogNot(this);\n\n                case NodeType.Pos:\n                case NodeType.Neg:\n                    return typeFlow.typeCheckUnaryNumberOperator(this);\n\n                case NodeType.IncPost:\n                case NodeType.IncPre:\n                case NodeType.DecPost:\n                case NodeType.DecPre:\n                    return typeFlow.typeCheckIncOrDec(this);\n\n                case NodeType.ArrayLit:\n                    typeFlow.typeCheckArrayLit(this);\n                    return this;\n\n                case NodeType.ObjectLit:\n                    typeFlow.typeCheckObjectLit(this);\n                    return this;\n\n                case NodeType.Throw:\n                    this.operand = typeFlow.typeCheck(this.operand);\n                    this.type = typeFlow.voidType;\n                    return this;\n\n                case NodeType.Typeof:\n                    this.operand = typeFlow.typeCheck(this.operand);\n                    this.type = typeFlow.stringType;\n                    return this;\n\n                case NodeType.Delete:\n                    this.operand = typeFlow.typeCheck(this.operand);\n                    this.type = typeFlow.booleanType;\n                    break;\n\n                case NodeType.TypeAssertion:\n                    this.castTerm = typeFlow.typeCheck(this.castTerm);\n                    var applyTargetType = !this.operand.isParenthesized;\n\n                    var targetType = applyTargetType ? this.castTerm.type : null;\n\n                    typeFlow.checker.typeCheckWithContextualType(targetType, typeFlow.checker.inProvisionalTypecheckMode(), true, this.operand);\n                    typeFlow.castWithCoercion(this.operand, this.castTerm.type, false, true);\n                    this.type = this.castTerm.type;\n                    return this;\n\n                case NodeType.Void:\n                    // REVIEW - Although this is good to do for completeness\'s sake,\n                    // this shouldn\'t be strictly necessary from the void operator\'s\n                    // point of view\n                    this.operand = typeFlow.typeCheck(this.operand);\n                    this.type = typeFlow.checker.undefinedType;\n                    break;\n\n                default:\n                    throw new Error("please implement in derived class");\n            }\n            return this;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            switch (this.nodeType) {\n                case NodeType.IncPost:\n                    emitter.emitJavascript(this.operand, TokenID.PlusPlus, false);\n                    emitter.writeToOutput("++");\n                    break;\n                case NodeType.LogNot:\n                    emitter.writeToOutput("!");\n                    emitter.emitJavascript(this.operand, TokenID.Exclamation, false);\n                    break;\n                case NodeType.DecPost:\n                    emitter.emitJavascript(this.operand, TokenID.MinusMinus, false);\n                    emitter.writeToOutput("--");\n                    break;\n                case NodeType.ObjectLit:\n                    emitter.emitObjectLiteral(<ASTList>this.operand);\n                    break;\n                case NodeType.ArrayLit:\n                    emitter.emitArrayLiteral(<ASTList>this.operand);\n                    break;\n                case NodeType.Not:\n                    emitter.writeToOutput("~");\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    break;\n                case NodeType.Neg:\n                    emitter.writeToOutput("-"',
v27688=v27689+');\n                    if (this.operand.nodeType == NodeType.Neg) {\n                        this.operand.isParenthesized = true;\n                    }\n                    emitter.emitJavascript(this.operand, TokenID.Minus, false);\n                    break;\n                case NodeType.Pos:\n                    emitter.writeToOutput("+");\n                    if (this.operand.nodeType == NodeType.Pos) {\n                        this.operand.isParenthesized = true;\n                    }\n                    emitter.emitJavascript(this.operand, TokenID.Plus, false);\n                    break;\n                case NodeType.IncPre:\n                    emitter.writeToOutput("++");\n                    emitter.emitJavascript(this.operand, TokenID.PlusPlus, false);\n                    break;\n                case NodeType.DecPre:\n                    emitter.writeToOutput("--");\n                    emitter.emitJavascript(this.operand, TokenID.MinusMinus, false);\n                    break;\n                case NodeType.Throw:\n                    emitter.writeToOutput("throw ");\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    emitter.writeToOutput(";");\n                    break;\n                case NodeType.Typeof:\n                    emitter.writeToOutput("typeof ");\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    break;\n                case NodeType.Delete:\n                    emitter.writeToOutput("delete ");\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    break;\n                case NodeType.Void:\n                    emitter.writeToOutput("void ");\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    break;\n                case NodeType.TypeAssertion:\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    break;\n                default:\n                    throw new Error("please implement in derived class");\n            }\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export class CallExpression extends Expression {\n        constructor (nodeType: NodeType,\n                     public target: AST,\n                     public arguments: ASTList) {\n            super(nodeType);\n            this.minChar = this.target.minChar;\n        }\n\n        public signature: Signature = null;\n\n        public typeCheck(typeFlow: TypeFlow) {\n            if (this.nodeType == NodeType.New) {\n                return typeFlow.typeCheckNew(this);\n            }\n            else {\n                return typeFlow.typeCheckCall(this);\n            }\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n\n            if (this.nodeType == NodeType.New) {\n                emitter.emitNew(this.target, this.arguments);\n            }\n            else {\n                emitter.emitCall(this, this.target, this.arguments);\n            }\n\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export class BinaryExpression extends Expression {\n        constructor (nodeType: NodeType, public operand1: AST, public operand2: AST) {\n            super(nodeType);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            switch (this.nodeType) {\n                case NodeType.Dot:\n                    return typeFlow.typeCheckDotOperator(this);\n                case NodeType.Asg:\n                    return typeFlow.typeCheckAsgOperator(this);\n                case NodeType.Add:\n                case NodeType.Sub:\n                case NodeType.Mul:\n                case NodeType.Div:\n                case NodeType.Mod:\n                case NodeType.Or:\n                case NodeType.And:\n                    return typeFlow.typeCheckArithmeticOperator(this, false);\n                case NodeType.Xor:\n                    return typeFlow.typeCheckBitwiseOperator(this, false);\n                case NodeType.Ne:\n                case NodeType.Eq:\n                    var text: string;\n                    if (typeFlow.checker.styleSettings.eqeqeq) {\n                        text = nodeTypeTable[this.nodeType];\n                        typeFlow.checker.errorReporter.styleError(this, "use of " + text);\n                    }\n                    else if (typeFlow.checker.styleSettings.eqnull) {\n                        text = nodeTypeTable[this.nodeType];\n                        if ((this.operand2 !== null) && (this.operand2.nodeType == NodeType.Null)) {\n                            typeFlow.checker.errorReporter.styleError(this, "use of " + text + " to compare with null");\n                        }\n                    }\n         ',
v27687=v27688+'       case NodeType.Eqv:\n                case NodeType.NEqv:\n                case NodeType.Lt:\n                case NodeType.Le:\n                case NodeType.Ge:\n                case NodeType.Gt:\n                    return typeFlow.typeCheckBooleanOperator(this);\n                case NodeType.Index:\n                    return typeFlow.typeCheckIndex(this);\n                case NodeType.Member:\n                    this.type = typeFlow.voidType;\n                    return this;\n                case NodeType.LogOr:\n                    return typeFlow.typeCheckLogOr(this);\n                case NodeType.LogAnd:\n                    return typeFlow.typeCheckLogAnd(this);\n                case NodeType.AsgAdd:\n                case NodeType.AsgSub:\n                case NodeType.AsgMul:\n                case NodeType.AsgDiv:\n                case NodeType.AsgMod:\n                case NodeType.AsgOr:\n                case NodeType.AsgAnd:\n                    return typeFlow.typeCheckArithmeticOperator(this, true);\n                case NodeType.AsgXor:\n                    return typeFlow.typeCheckBitwiseOperator(this, true);\n                case NodeType.Lsh:\n                case NodeType.Rsh:\n                case NodeType.Rs2:\n                    return typeFlow.typeCheckShift(this, false);\n                case NodeType.AsgLsh:\n                case NodeType.AsgRsh:\n                case NodeType.AsgRs2:\n                    return typeFlow.typeCheckShift(this, true);\n                case NodeType.Comma:\n                    return typeFlow.typeCheckCommaOperator(this);\n                case NodeType.InstOf:\n                    return typeFlow.typeCheckInstOf(this);\n                case NodeType.In:\n                    return typeFlow.typeCheckInOperator(this);\n                case NodeType.From:\n                    typeFlow.checker.errorReporter.simpleError(this, "Illegal use of \'from\' keyword in binary expression");\n                    break;\n                default:\n                    throw new Error("please implement in derived class");\n            }\n            return this;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            var binTokenId = nodeTypeToTokTable[this.nodeType];\n\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (binTokenId != undefined) {\n\n                emitter.emitJavascript(this.operand1, binTokenId, false);\n\n                if (tokenTable[binTokenId].text == "instanceof") {\n                    emitter.writeToOutput(" instanceof ");\n                }\n                else if (tokenTable[binTokenId].text == "in") {\n                    emitter.writeToOutput(" in ");\n                }\n                else {\n                    emitter.writeToOutputTrimmable(" " + tokenTable[binTokenId].text + " ");\n                }\n\n                emitter.emitJavascript(this.operand2, binTokenId, false);\n            }\n            else {\n                switch (this.nodeType) {\n                    case NodeType.Dot:\n                        if (!emitter.tryEmitConstant(this)) {\n                            emitter.emitJavascript(this.operand1, TokenID.Dot, false);\n                            emitter.writeToOutput(".");\n                            emitter.emitJavascriptName(<Identifier>this.operand2, false);\n                        }\n                        break;\n                    case NodeType.Index:\n                        emitter.emitIndex(this.operand1, this.operand2);\n                        break;\n\n                    case NodeType.Member:\n                        if (this.operand2.nodeType == NodeType.FuncDecl && (<FuncDecl>this.operand2).isAccessor()) {\n                            var funcDecl = <FuncDecl>this.operand2;\n                            if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {\n                                emitter.writeToOutput("get ");\n                            }\n                            else {\n                                emitter.writeToOutput("set ");\n                            }\n                            emitter.emitJavascript(this.operand1, TokenID.Colon, false);\n                        }\n                        else {\n                            emitter.emitJavascript(this.operand1, TokenID.Colon, false);\n                            emitter.writeToOutputTrimmable(": ");\n                        }\n                        emitter.emitJavascript(this.operand2, TokenID.Comma, false);\n                        break;\n                    case NodeType.Comma:\n                        emitter.emitJavascript(this.operand1, TokenID.Comma, false);\n                        if (emitter.emitState.inObjectLiteral) {\n                            emitter.writeLineToOutput(", ");\n                        }\n                        else {\n                            emitter.writeToOutput(",");\n                        }\n                        emitter.emitJavascript(this.op',
v27686=v27687+'erand2, TokenID.Comma, false);\n                        break;\n                    case NodeType.Is:\n                        throw new Error("should be de-sugared during type check");\n                    default:\n                        throw new Error("please implement in derived class");\n                }\n            }\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export class ConditionalExpression extends Expression {\n        constructor (public operand1: AST,\n                     public operand2: AST,\n                     public operand3: AST) {\n            super(NodeType.ConditionalExpression);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckQMark(this);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.emitJavascript(this.operand1, TokenID.Question, false);\n            emitter.writeToOutput(" ? ");\n            emitter.emitJavascript(this.operand2, TokenID.Question, false);\n            emitter.writeToOutput(" : ");\n            emitter.emitJavascript(this.operand3, TokenID.Question, false);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export class NumberLiteral extends Expression {\n        constructor (public value: number, public hasEmptyFraction?: bool) {\n            super(NodeType.NumberLit);\n        }\n\n        public isNegativeZero = false;\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.type = typeFlow.doubleType;\n            return this;\n        }\n\n        public treeViewLabel() {\n            return "num: " + this.printLabel();\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (this.isNegativeZero) {\n                emitter.writeToOutput("-");\n            }\n\n            emitter.writeToOutput(this.value.toString());\n\n            if (this.hasEmptyFraction)\n                emitter.writeToOutput(".0");\n\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public printLabel() {\n            if (Math.floor(this.value) != this.value) {\n                return this.value.toFixed(2).toString();\n            }\n            else if (this.hasEmptyFraction) {\n                return this.value.toString() + ".0";\n            }\n            else {\n                return this.value.toString();\n            }\n        }\n    }\n\n    export class RegexLiteral extends Expression {\n        constructor (public regex) {\n            super(NodeType.Regex);\n        }\n        \n        public typeCheck(typeFlow: TypeFlow) {\n            this.type = typeFlow.regexType;\n            return this;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput(this.regex.toString());\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export class StringLiteral extends Expression {\n        constructor (public text: string) {\n            super(NodeType.QString);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.emitStringLiteral(this.text);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.type = typeFlow.stringType;\n            return this;\n        }\n\n        public treeViewLabel() {\n            return "st: " + this.text;\n        }\n\n        public printLabel() {\n            return this.text;\n        }\n    }\n\n    export class ModuleElement extends AST {\n        constructor (nodeType: NodeType) {\n            super(nodeType);\n        }\n    }\n\n    export class ImportDeclaration extends ModuleElement {\n        public isStatementOrExpression() { return true; }\n        public varFlags = VarFlags.None;\n        public isDynamicImport = false;\n        public isDeclaration() { return true; }\n\n        constructor (public id: Identifier, public alias: AST) {\n            super(NodeType.ImportDeclaration);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            var mod = <ModuleType>this.alias.type;\n            // REVIEW: Only modules may be aliased for now, though there\'s no real\n            // restriction on what the typ',
v27685=v27686+'e symbol may be\n            if (!this.isDynamicImport || (this.id.sym && !(<TypeSymbol>this.id.sym).onlyReferencedAsTypeRef)) {\n                var prevModAliasId = emitter.modAliasId;\n                var prevFirstModAlias = emitter.firstModAlias;\n\n                emitter.recordSourceMappingStart(this);\n                emitter.emitParensAndCommentsInPlace(this, true);\n                emitter.writeToOutput("var " + this.id.actualText + " = ");\n                emitter.modAliasId = this.id.actualText;\n                emitter.firstModAlias = this.firstAliasedModToString();\n                emitter.emitJavascript(this.alias, TokenID.Tilde, false);\n                // the dynamic import case will insert the semi-colon automatically\n                if (!this.isDynamicImport) {\n                    emitter.writeToOutput(";");\n                }\n                emitter.emitParensAndCommentsInPlace(this, false);\n                emitter.recordSourceMappingEnd(this);\n\n                emitter.modAliasId = prevModAliasId;\n                emitter.firstModAlias = prevFirstModAlias;\n            }\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckImportDecl(this);\n        }\n\n        public getAliasName(aliasAST?: AST = this.alias) : string {\n            if (aliasAST.nodeType == NodeType.Name) {\n                return (<Identifier>aliasAST).actualText;\n            } else {\n                var dotExpr = <BinaryExpression>aliasAST;\n                return this.getAliasName(dotExpr.operand1) + "." + this.getAliasName(dotExpr.operand2);\n            }\n        }\n\n        public firstAliasedModToString() {\n            if (this.alias.nodeType == NodeType.Name) {\n                return (<Identifier>this.alias).actualText;\n            }\n            else {\n                var dotExpr = <BinaryExpression>this.alias;\n                var firstMod = <Identifier>dotExpr.operand1;\n                return firstMod.actualText;\n            }\n        }\n    }\n\n    export class BoundDecl extends AST {\n        public init: AST = null;\n        public typeExpr: AST = null;\n        public varFlags = VarFlags.None;\n        public sym: Symbol = null;\n        public isDeclaration() { return true; }\n\n        constructor (public id: Identifier, nodeType: NodeType, public nestingLevel: number) {\n            super(nodeType);\n        }\n\n        public isStatementOrExpression() { return true; }\n\n        public isPrivate() { return hasFlag(this.varFlags, VarFlags.Private); }\n        public isPublic() { return hasFlag(this.varFlags, VarFlags.Public); }\n        public isProperty() { return hasFlag(this.varFlags, VarFlags.Property); }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckBoundDecl(this);\n        }\n\n        public printLabel() {\n            return this.treeViewLabel();\n        }\n    }\n\n    export class VarDecl extends BoundDecl {\n        constructor (id: Identifier, nest: number) {\n            super(id, NodeType.VarDecl, nest);\n        }\n\n        public isAmbient() { return hasFlag(this.varFlags, VarFlags.Ambient); }\n        public isExported() { return hasFlag(this.varFlags, VarFlags.Exported); }\n        public isStatic() { return hasFlag(this.varFlags, VarFlags.Static); }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitJavascriptVarDecl(this, tokenId);\n        }\n\n        public treeViewLabel() {\n            return "var " + this.id.actualText;\n        }\n    }\n\n    export class ArgDecl extends BoundDecl {\n        constructor (id: Identifier) {\n            super(id, NodeType.ArgDecl, 0);\n        }\n\n        public isOptional = false;\n\n        public isOptionalArg() { return this.isOptional || this.init; }\n\n        public treeViewLabel() {\n            return "arg: " + this.id.actualText;\n        }\n\n        public parameterPropertySym: FieldSymbol = null;\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput(this.id.actualText);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    var internalId = 0;\n\n    export class FuncDecl extends AST {\n        public hint: string = null;\n        public fncFlags = FncFlags.None;\n        public returnTypeAnnotation: AST = null;\n        public symbols: IHashTable;\n        public variableArgList = false;\n        public signature: Signature;\n        public envids: Identifier[];\n        public jumpRefs: Identifier[] = null;\n        public internalNameCache: string = null;\n        public tmp1Declared = false;\n        public enclosingFnc: FuncDecl = null;\n        public freeVariables: Symbol[] = [];\n        public unitIndex = -1;\n        public classDecl: NamedDeclaration = null;\n        public boundToProperty: VarDecl = null;\n        public isOverload = fa',
v27684=v27685+'lse;\n        public innerStaticFuncs: FuncDecl[] = [];\n        public isTargetTypedAsMethod = false;\n        public isInlineCallLiteral = false;\n        public accessorSymbol: Symbol = null;\n        public leftCurlyCount = 0;\n        public rightCurlyCount = 0;\n        public returnStatementsWithExpressions: ReturnStatement[] = [];\n        public scopeType: Type = null; // Type of the FuncDecl, before target typing\n        public endingToken: ASTSpan = null;\n        public isDeclaration() { return true; }\n\n        constructor (public name: Identifier, public bod: ASTList, public isConstructor: bool,\n                     public arguments: ASTList, public vars: ASTList, public scopes: ASTList, public statics: ASTList,\n                     nodeType: number) {\n\n            super(nodeType);\n        }\n\n        public internalName(): string {\n            if (this.internalNameCache == null) {\n                var extName = this.getNameText();\n                if (extName) {\n                    this.internalNameCache = "_internal_" + extName;\n                }\n                else {\n                    this.internalNameCache = "_internal_" + internalId++;\n                }\n            }\n            return this.internalNameCache;\n        }\n\n        public hasSelfReference() { return hasFlag(this.fncFlags, FncFlags.HasSelfReference); }\n        public setHasSelfReference() { this.fncFlags |= FncFlags.HasSelfReference; }\n\n        public hasSuperReferenceInFatArrowFunction() { return hasFlag(this.fncFlags, FncFlags.HasSuperReferenceInFatArrowFunction); }\n        public setHasSuperReferenceInFatArrowFunction() { this.fncFlags |= FncFlags.HasSuperReferenceInFatArrowFunction; }\n\n        public addCloRef(id: Identifier, sym: Symbol): number {\n            if (this.envids == null) {\n                this.envids = new Identifier[];\n            }\n            this.envids[this.envids.length] = id;\n            var outerFnc = this.enclosingFnc;\n            if (sym) {\n                while (outerFnc && (outerFnc.type.symbol != sym.container)) {\n                    outerFnc.addJumpRef(sym);\n                    outerFnc = outerFnc.enclosingFnc;\n                }\n            }\n            return this.envids.length - 1;\n        }\n\n        public addJumpRef(sym: Symbol): void {\n            if (this.jumpRefs == null) {\n                this.jumpRefs = new Identifier[];\n            }\n            var id = new Identifier(sym.name);\n            this.jumpRefs[this.jumpRefs.length] = id;\n            id.sym = sym;\n            id.cloId = this.addCloRef(id, null);\n        }\n\n        public buildControlFlow(): ControlFlowContext {\n            var entry = new BasicBlock();\n            var exit = new BasicBlock();\n\n            var context = new ControlFlowContext(entry, exit);\n\n            var controlFlowPrefix = (ast: AST, parent: AST, walker: IAstWalker) => {\n                ast.addToControlFlow(walker.state);\n                return ast;\n            }\n\n            var walker = getAstWalkerFactory().getWalker(controlFlowPrefix, null, null, context);\n            context.walker = walker;\n            walker.walk(this.bod, this);\n\n            return context;\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckFunction(this);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitJavascriptFunction(this);\n        }\n\n        public getNameText() {\n            if (this.name) {\n                return this.name.actualText;\n            }\n            else {\n                return this.hint;\n            }\n        }\n\n        public isMethod() {\n            return (this.fncFlags & FncFlags.Method) != FncFlags.None;\n        }\n\n        public isCallMember() { return hasFlag(this.fncFlags, FncFlags.CallMember); }\n        public isConstructMember() { return hasFlag(this.fncFlags, FncFlags.ConstructMember); }\n        public isIndexerMember() { return hasFlag(this.fncFlags, FncFlags.IndexerMember); }\n        public isSpecialFn() { return this.isCallMember() || this.isIndexerMember() || this.isConstructMember(); }\n        public isAnonymousFn() { return this.name === null; }\n        public isAccessor() { return hasFlag(this.fncFlags, FncFlags.GetAccessor) || hasFlag(this.fncFlags, FncFlags.SetAccessor); }\n        public isGetAccessor() { return hasFlag(this.fncFlags, FncFlags.GetAccessor); }\n        public isSetAccessor() { return hasFlag(this.fncFlags, FncFlags.SetAccessor); }\n        public isAmbient() { return hasFlag(this.fncFlags, FncFlags.Ambient); }\n        public isExported() { return hasFlag(this.fncFlags, FncFlags.Exported); }\n        public isPrivate() { return hasFlag(this.fncFlags, FncFlags.Private); }\n        public isPublic() { return hasFlag(this.fncFlags, FncFlags.Public); }\n        public isStatic() { return hasFlag(this.fncFlags, FncFlags.Static); }\n\n        public treeViewLabel() {\n            if (this.name == null) {\n                return "funcExpr";\n      ',
v27683=v27684+'      }\n            else {\n                return "func: " + this.name.actualText\n            }\n        }\n\n        public ClearFlags(): void {\n            this.fncFlags = FncFlags.None;\n        }\n\n        public isSignature() { return (this.fncFlags & FncFlags.Signature) != FncFlags.None; }\n    }\n\n    export class LocationInfo {\n        constructor (public filename: string, public lineMap: number[], public unitIndex) { }\n    }\n\n    export var unknownLocationInfo = new LocationInfo("unknown", null, -1);\n\n    export class Script extends FuncDecl {\n        public locationInfo: LocationInfo = null;\n        public referencedFiles: IFileReference[] = [];\n        public requiresGlobal = false;\n        public requiresExtendsBlock = false;\n        public isResident = false;\n        public isDeclareFile = false;\n        public hasBeenTypeChecked = false;\n        public topLevelMod: ModuleDeclaration = null;\n        public leftCurlyCount = 0;\n        public rightCurlyCount = 0;\n        public vars: ASTList;\n        public scopes: ASTList;\n        // Remember if the script contains Unicode chars, that is needed when generating code for this script object to decide the output file correct encoding.\n        public containsUnicodeChar = false;\n        public containsUnicodeCharInComment = false;\n        public cachedEmitRequired: bool;\n\n        private setCachedEmitRequired(value: bool) {\n            this.cachedEmitRequired = value;\n            return this.cachedEmitRequired;\n        }\n\n        constructor (vars: ASTList, scopes: ASTList) {\n            super(new Identifier("script"), null, false, null, vars, scopes, null, NodeType.Script);\n            this.vars = vars;\n            this.scopes = scopes;\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckScript(this);\n        }\n\n        public treeViewLabel() {\n            return "Script";\n        }\n\n        public emitRequired(emitOptions: EmitOptions) {\n            if (this.cachedEmitRequired != undefined) {\n                return this.cachedEmitRequired;\n            }\n\n            if (!this.isDeclareFile && !this.isResident && this.bod) {\n                if (this.bod.members.length == 0) {\n                    // allow empty files that are not declare files \n                    return this.setCachedEmitRequired(true);\n                }\n\n                for (var i = 0, len = this.bod.members.length; i < len; i++) {\n                    var stmt = this.bod.members[i];\n                    if (stmt.nodeType == NodeType.ModuleDeclaration) {\n                        if (!hasFlag((<ModuleDeclaration>stmt).modFlags, ModuleFlags.ShouldEmitModuleDecl | ModuleFlags.Ambient)) {\n                            return this.setCachedEmitRequired(true);\n                        }\n                    }\n                    else if (stmt.nodeType == NodeType.ClassDeclaration) {\n                        if (!hasFlag((<ClassDeclaration>stmt).varFlags, VarFlags.Ambient)) {\n                            return this.setCachedEmitRequired(true);\n                        }\n                    }\n                    else if (stmt.nodeType == NodeType.VarDecl) {\n                        if (!hasFlag((<VarDecl>stmt).varFlags, VarFlags.Ambient)) {\n                            return this.setCachedEmitRequired(true);\n                        }\n                    }\n                    else if (stmt.nodeType == NodeType.FuncDecl) {\n                        if (!(<FuncDecl>stmt).isSignature()) {\n                            return this.setCachedEmitRequired(true);\n                        }\n                    }\n                    else if (stmt.nodeType != NodeType.InterfaceDeclaration && stmt.nodeType != NodeType.Empty) {\n                        return this.setCachedEmitRequired(true);\n                    }\n                }\n\n                if ( emitOptions.emitComments &&\n                    ((this.bod.preComments && this.bod.preComments.length > 0) || (this.bod.postComments && this.bod.postComments.length > 0))) {\n                    return this.setCachedEmitRequired(true);\n                }\n            }\n            return this.setCachedEmitRequired(false);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            if (this.emitRequired(emitter.emitOptions)) {\n                emitter.emitParensAndCommentsInPlace(this.bod, true);\n                emitter.emitJavascriptList(this.bod, null, TokenID.Semicolon, true, false, false, true, this.requiresExtendsBlock);\n                emitter.emitParensAndCommentsInPlace(this.bod, false);\n            }\n        }\n\n        private externallyVisibleImportedSymbols: Symbol[] = [];\n\n        public AddExternallyVisibleImportedSymbol(symbol: Symbol, checker: TypeChecker) {\n            if (this.isExternallyVisibleSymbol(symbol)) {\n                return;\n            }\n\n            // Before adding check if the external symbol is also marked for visibility\n            if (!symbol.getType().symbol.isExter',
v27682=v27683+'nallyVisible(checker)) {\n                // Report error\n                var quotes = "";\n                var moduleName = symbol.getType().symbol.prettyName;\n                if (!isQuoted(moduleName)) {\n                    quotes = "\'";\n                }\n                checker.errorReporter.simpleError(symbol.declAST, "Externally visible import statement uses non exported module " + quotes + moduleName + quotes);\n            }\n            this.externallyVisibleImportedSymbols.push(symbol);\n        }\n\n        public isExternallyVisibleSymbol(symbol: Symbol) {\n            for (var i = 0 ; i < this.externallyVisibleImportedSymbols.length; i++) {\n                if (this.externallyVisibleImportedSymbols[i] == symbol) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    export class NamedDeclaration extends ModuleElement {\n        public leftCurlyCount = 0;\n        public rightCurlyCount = 0;\n        public isDeclaration() { return true; }\n\n        constructor (nodeType: NodeType,\n                     public name: Identifier,\n                     public members: ASTList) {\n            super(nodeType);\n        }\n    }\n\n    export class ModuleDeclaration extends NamedDeclaration {\n        public modFlags = ModuleFlags.ShouldEmitModuleDecl;\n        public mod: ModuleType;\n        public prettyName: string;\n        public amdDependencies: string[] = [];\n        public vars: ASTList;\n        public scopes: ASTList;\n        // Remember if the module contains Unicode chars, that is needed for dynamic module as we will generate a file for each.\n        public containsUnicodeChar = false;\n        public containsUnicodeCharInComment = false;\n\n        constructor (name: Identifier, members: ASTList, vars: ASTList, scopes: ASTList, public endingToken: ASTSpan) {\n            super(NodeType.ModuleDeclaration, name, members);\n\n            this.vars = vars;\n            this.scopes = scopes;\n            this.prettyName = this.name.actualText;\n        }\n\n        public isExported() { return hasFlag(this.modFlags, ModuleFlags.Exported); }\n        public isAmbient() { return hasFlag(this.modFlags, ModuleFlags.Ambient); }\n        public isEnum() { return hasFlag(this.modFlags, ModuleFlags.IsEnum); }\n\n        public recordNonInterface() {\n            this.modFlags &= ~ModuleFlags.ShouldEmitModuleDecl;\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckModule(this);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            if (!hasFlag(this.modFlags, ModuleFlags.ShouldEmitModuleDecl)) {\n                emitter.emitParensAndCommentsInPlace(this, true);\n                emitter.emitJavascriptModule(this);\n                emitter.emitParensAndCommentsInPlace(this, false);\n            }\n        }\n    }\n\n    export class TypeDeclaration extends NamedDeclaration {\n        public varFlags = VarFlags.None;\n\n        constructor (nodeType: NodeType,\n                     name: Identifier,\n                     public extendsList: ASTList,\n                     public implementsList: ASTList,\n                     members: ASTList) {\n            super(nodeType, name, members);\n        }\n\n        public isExported() { \n            return hasFlag(this.varFlags, VarFlags.Exported);\n        }\n\n        public isAmbient() {\n            return hasFlag(this.varFlags, VarFlags.Ambient);\n        }\n    }\n\n    export class ClassDeclaration extends TypeDeclaration {\n        public knownMemberNames: any = {};\n        public constructorDecl: FuncDecl = null;\n        public constructorNestingLevel = 0;\n        public endingToken: ASTSpan = null;\n\n        constructor (name: Identifier,\n                     members: ASTList,\n                     extendsList: ASTList,\n                     implementsList: ASTList) {\n            super(NodeType.ClassDeclaration, name, extendsList, implementsList, members);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckClass(this);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitJavascriptClass(this);\n        }\n    }\n\n    export class InterfaceDeclaration extends TypeDeclaration {\n        constructor (name: Identifier,\n                     members: ASTList,\n                     extendsList: ASTList,\n                     implementsList: ASTList) {\n            super(NodeType.InterfaceDeclaration, name, extendsList, implementsList, members);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckInterface(this);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n        }\n    }\n\n    export class Statement extends ModuleElement {\n        constructor (nodeType: NodeType) {\n            super(nodeType);\n            this.flags |= ASTFlags.IsStatement;\n        }\n\n        public isLoop() { return false; }\n\n        public i',
v27681=v27682+'sStatementOrExpression() { return true; }\n\n        public isCompoundStatement() { return this.isLoop(); }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.type = typeFlow.voidType;\n            return this;\n        }\n    }\n\n    export class LabeledStatement extends Statement {\n        constructor (public labels: ASTList, public stmt: AST) {\n            super(NodeType.LabeledStatement);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (this.labels) {\n                var labelsLen = this.labels.members.length;\n                for (var i = 0; i < labelsLen; i++) {\n                    this.labels.members[i].emit(emitter, tokenId, startLine);\n                }\n            }\n            this.stmt.emit(emitter, tokenId, true);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            typeFlow.typeCheck(this.labels);\n            this.stmt = this.stmt.typeCheck(typeFlow);\n            return this;\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            var beforeBB = context.current;\n            var bb = new BasicBlock();\n            context.current = bb;\n            beforeBB.addSuccessor(bb);\n        }\n    }\n\n    export class Block extends Statement {\n        constructor (public statements: ASTList,\n                     public isStatementBlock: bool) {\n            super(NodeType.Block);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (this.isStatementBlock) {\n                emitter.writeLineToOutput(" {");\n                emitter.indenter.increaseIndent();\n            } else {\n                emitter.setInVarBlock(this.statements.members.length);\n            }\n            var temp = emitter.setInObjectLiteral(false);\n            if (this.statements) {\n                emitter.emitJavascriptList(this.statements, null, TokenID.Semicolon, true, false, false);\n            }\n            if (this.isStatementBlock) {\n                emitter.indenter.decreaseIndent();\n                emitter.emitIndent();\n                emitter.writeToOutput("}");\n            }\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public addToControlFlow(context: ControlFlowContext) {\n            var afterIfNeeded = new BasicBlock();\n            context.pushStatement(this, context.current, afterIfNeeded);\n            if (this.statements) {\n                context.walk(this.statements, this);\n            }\n            context.walker.options.goChildren = false;\n            context.popStatement();\n            if (afterIfNeeded.predecessors.length > 0) {\n                context.current.addSuccessor(afterIfNeeded);\n                context.current = afterIfNeeded;\n            }\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            if (!typeFlow.checker.styleSettings.emptyBlocks) {\n                if ((this.statements === null) || (this.statements.members.length == 0)) {\n                    typeFlow.checker.errorReporter.styleError(this, "empty block");\n                }\n            }\n\n            typeFlow.typeCheck(this.statements);\n            return this;\n        }\n    }\n\n    export class Jump extends Statement {\n        public target: string = null;\n        public hasExplicitTarget() { return (this.target); }\n        public resolvedTarget: Statement = null;\n\n        constructor (nodeType: NodeType) {\n            super(nodeType);\n        }\n\n        public setResolvedTarget(parser: Parser, stmt: Statement): bool {\n            if (stmt.isLoop()) {\n                this.resolvedTarget = stmt;\n                return true;\n            }\n            if (this.nodeType === NodeType.Continue) {\n                parser.reportParseError("continue statement applies only to loops");\n                return false;\n            }\n            else {\n                if ((stmt.nodeType == NodeType.Switch) || this.hasExplicitTarget()) {\n                    this.resolvedTarget = stmt;\n                    return true;\n                }\n                else {\n                    parser.reportParseError("break statement with no label can apply only to a loop or switch statement");\n                    return false;\n                }\n            }\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            super.addToControlFlow(context);\n            context.unconditionalBranch(this.resolvedTarget, (this.nodeType == NodeType.Continue));\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, s',
v27680=v27681+'tartLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (this.nodeType == NodeType.Break) {\n                emitter.writeToOutput("break");\n            }\n            else {\n                emitter.writeToOutput("continue");\n            }\n            if (this.hasExplicitTarget()) {\n                emitter.writeToOutput(" " + this.target);\n            }\n            emitter.recordSourceMappingEnd(this);\n            emitter.writeToOutput(";");\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export class WhileStatement extends Statement {\n        public body: AST = null;\n\n        constructor (public cond: AST) {\n            super(NodeType.While);\n        }\n\n        public isLoop() { return true; }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.writeToOutput("while(");\n            emitter.emitJavascript(this.cond, TokenID.While, false);\n            emitter.writeToOutput(")");\n            emitter.emitJavascriptStatements(this.body, false);\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckWhile(this);\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            var loopHeader = context.current;\n            var loopStart = new BasicBlock();\n            var afterLoop = new BasicBlock();\n\n            loopHeader.addSuccessor(loopStart);\n            context.current = loopStart;\n            context.addContent(this.cond);\n            var condBlock = context.current;\n            var targetInfo: ITargetInfo = null;\n            if (this.body) {\n                context.current = new BasicBlock();\n                condBlock.addSuccessor(context.current);\n                context.pushStatement(this, loopStart, afterLoop);\n                context.walk(this.body, this);\n                targetInfo = context.popStatement();\n            }\n            if (!(context.noContinuation)) {\n                var loopEnd = context.current;\n                loopEnd.addSuccessor(loopStart);\n            }\n            context.current = afterLoop;\n            condBlock.addSuccessor(afterLoop);\n            // TODO: check for while (true) and then only continue if afterLoop has predecessors\n            context.noContinuation = false;\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class DoWhileStatement extends Statement {\n        public body: AST = null;\n        public whileAST: AST = null;\n        public cond: AST = null;\n        public isLoop() { return true; }\n\n        constructor () {\n            super(NodeType.DoWhile);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.writeToOutput("do");\n            emitter.emitJavascriptStatements(this.body, true);\n            emitter.recordSourceMappingStart(this.whileAST);\n            emitter.writeToOutput("while");\n            emitter.recordSourceMappingEnd(this.whileAST);\n            emitter.writeToOutput(\'(\');\n            emitter.emitJavascript(this.cond, TokenID.CloseParen, false);\n            emitter.writeToOutput(")");\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.writeToOutput(";");\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckDoWhile(this);\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            var loopHeader = context.current;\n            var loopStart = new BasicBlock();\n            var afterLoop = new BasicBlock();\n            loopHeader.addSuccessor(loopStart);\n            context.current = loopStart;\n            var targetInfo: ITargetInfo = null;\n            if (this.body) {\n                context.pushStatement(this, loopStart, afterLoop);\n                context.walk(this.body, this);\n                targetInfo = context.popStatement();\n            }\n            if (!(context.noContinuation)) {\n                var loopEnd = context.current;\n                loopEnd.addSuccessor(loopStart);\n                context.addContent(this.cond);\n                // TODO: check for while (true) \n                context.current = afterLoop;\n                loopEnd.addSuccessor(afterLoop);\n            }\n            else {\n                context.addUnreachable(t',
v27679=v27680+'his.cond);\n            }\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class IfStatement extends Statement {\n        public thenBod: AST;\n        public elseBod: AST = null;\n        public statement: ASTSpan = new ASTSpan();\n\n        constructor (public cond: AST) {\n            super(NodeType.If);\n        }\n\n        public isCompoundStatement() { return true; }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.recordSourceMappingStart(this.statement);\n            emitter.writeToOutput("if(");\n            emitter.emitJavascript(this.cond, TokenID.If, false);\n            emitter.writeToOutput(")");\n            emitter.recordSourceMappingEnd(this.statement);\n            emitter.emitJavascriptStatements(this.thenBod, true);\n            if (this.elseBod) {\n                if (this.elseBod.nodeType === NodeType.If) {\n                    emitter.writeToOutput(" else ");\n                    this.elseBod.emit(emitter, tokenId, /*startLine:*/ false);\n                }\n                else {\n                    emitter.writeToOutput(" else");\n                    emitter.emitJavascriptStatements(this.elseBod, true);\n                }\n            }\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckIf(this);\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            this.cond.addToControlFlow(context);\n            var afterIf = new BasicBlock();\n            var beforeIf = context.current;\n            context.pushStatement(this, beforeIf, afterIf);\n            var hasContinuation = false;\n            context.current = new BasicBlock();\n            beforeIf.addSuccessor(context.current);\n            context.walk(this.thenBod, this);\n            if (!context.noContinuation) {\n                hasContinuation = true;\n                context.current.addSuccessor(afterIf);\n            }\n            if (this.elseBod) {\n                // current block will be thenBod\n                context.current = new BasicBlock();\n                context.noContinuation = false;\n                beforeIf.addSuccessor(context.current);\n                context.walk(this.elseBod, this);\n                if (!context.noContinuation) {\n                    hasContinuation = true;\n                    context.current.addSuccessor(afterIf);\n                }\n                else {\n                    // thenBod created continuation for if statement\n                    if (hasContinuation) {\n                        context.noContinuation = false;\n                    }\n                }\n            }\n            else {\n                beforeIf.addSuccessor(afterIf);\n                context.noContinuation = false;\n                hasContinuation = true;\n            }\n            var targetInfo = context.popStatement();\n            if (afterIf.predecessors.length > 0) {\n                context.noContinuation = false;\n                hasContinuation = true;\n            }\n            if (hasContinuation) {\n                context.current = afterIf;\n            }\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class ReturnStatement extends Statement {\n        public returnExpression: AST = null;\n\n        constructor () {\n            super(NodeType.Return);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            if (this.returnExpression) {\n                emitter.writeToOutput("return ");\n                emitter.emitJavascript(this.returnExpression, TokenID.Semicolon, false);\n\n                if (this.returnExpression.nodeType === NodeType.FuncDecl) {\n                    emitter.writeToOutput(";");\n                }\n            }\n            else {\n                emitter.writeToOutput("return;");\n            }\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            super.addToControlFlow(context);\n            context.returnStmt();\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckReturn(this);\n        }\n    }\n\n    export class EndCode extends AST {\n        constructor () {\n            super(NodeType.EndCode);\n        }\n    }\n\n    export class ForInStatement extends Statement {\n        constructor ',
v27678=v27679+'(public lval: AST, public obj: AST) {\n            super(NodeType.ForIn);\n            if (this.lval && (this.lval.nodeType == NodeType.VarDecl)) {\n                (<BoundDecl>this.lval).varFlags |= VarFlags.AutoInit;\n            }\n        }\n        public statement: ASTSpan = new ASTSpan();\n        public body: AST;\n\n        public isLoop() { return true; }\n\n        public isFiltered() {\n            if (this.body) {\n                var singleItem: AST = null;\n                if (this.body.nodeType == NodeType.List) {\n                    var stmts = <ASTList>this.body;\n                    if (stmts.members.length == 1) {\n                        singleItem = stmts.members[0];\n                    }\n                }\n                else {\n                    singleItem = this.body;\n                }\n                // match template for filtering \'own\' properties from obj\n                if (singleItem !== null) {\n                    if (singleItem.nodeType == NodeType.Block) {\n                        var block = <Block>singleItem;\n                        if ((block.statements !== null) && (block.statements.members.length == 1)) {\n                            singleItem = block.statements.members[0];\n                        }\n                    }\n                    if (singleItem.nodeType == NodeType.If) {\n                        var cond = (<IfStatement>singleItem).cond;\n                        if (cond.nodeType == NodeType.Call) {\n                            var target = (<CallExpression>cond).target;\n                            if (target.nodeType == NodeType.Dot) {\n                                var binex = <BinaryExpression>target;\n                                if ((binex.operand1.nodeType == NodeType.Name) &&\n                                    (this.obj.nodeType == NodeType.Name) &&\n                                    ((<Identifier>binex.operand1).actualText == (<Identifier>this.obj).actualText)) {\n                                    var prop = <Identifier>binex.operand2;\n                                    if (prop.actualText == "hasOwnProperty") {\n                                        var args = (<CallExpression>cond).arguments;\n                                        if ((args !== null) && (args.members.length == 1)) {\n                                            var arg = args.members[0];\n                                            if ((arg.nodeType == NodeType.Name) &&\n                                                 (this.lval.nodeType == NodeType.Name)) {\n                                                if (((<Identifier>this.lval).actualText) == (<Identifier>arg).actualText) {\n                                                    return true;\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.recordSourceMappingStart(this.statement);\n            emitter.writeToOutput("for(");\n            emitter.emitJavascript(this.lval, TokenID.For, false);\n            emitter.writeToOutput(" in ");\n            emitter.emitJavascript(this.obj, TokenID.For, false);\n            emitter.writeToOutput(")");\n            emitter.recordSourceMappingEnd(this.statement);\n            emitter.emitJavascriptStatements(this.body, true);\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            if (typeFlow.checker.styleSettings.forin) {\n                if (!this.isFiltered()) {\n                    typeFlow.checker.errorReporter.styleError(this, "no hasOwnProperty filter");\n                }\n            }\n            return typeFlow.typeCheckForIn(this);\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            if (this.lval) {\n                context.addContent(this.lval);\n            }\n            if (this.obj) {\n                context.addContent(this.obj);\n            }\n\n            var loopHeader = context.current;\n            var loopStart = new BasicBlock();\n            var afterLoop = new BasicBlock();\n\n            loopHeader.addSuccessor(loopStart);\n            context.current = loopStart;\n            if (this.body) {\n                context.pushStatement(this, loopStart, afterLoop);\n                context.walk(this.body, this);\n                context.popStatement();\n            }\n            if (!(context.noContinuation)) {\n                var loopE',
v27677=v27678+'nd = context.current;\n                loopEnd.addSuccessor(loopStart);\n            }\n            context.current = afterLoop;\n            context.noContinuation = false;\n            loopHeader.addSuccessor(afterLoop);\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class ForStatement extends Statement {\n        public cond: AST;\n        public body: AST;\n        public incr: AST;\n\n        constructor (public init: AST) {\n            super(NodeType.For);\n        }\n\n        public isLoop() { return true; }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.writeToOutput("for(");\n            if (this.init) {\n                if (this.init.nodeType != NodeType.List) {\n                    emitter.emitJavascript(this.init, TokenID.For, false);\n                }\n                else {\n                    emitter.setInVarBlock((<ASTList>this.init).members.length); \n                    emitter.emitJavascriptList(this.init, null, TokenID.For, false, false, false);\n                }\n            }\n            emitter.writeToOutput("; ");\n            emitter.emitJavascript(this.cond, TokenID.For, false);\n            emitter.writeToOutput("; ");\n            emitter.emitJavascript(this.incr, TokenID.For, false);\n            emitter.writeToOutput(")");\n            emitter.emitJavascriptStatements(this.body, true);\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckFor(this);\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            if (this.init) {\n                context.addContent(this.init);\n            }\n            var loopHeader = context.current;\n            var loopStart = new BasicBlock();\n            var afterLoop = new BasicBlock();\n\n            loopHeader.addSuccessor(loopStart);\n            context.current = loopStart;\n            var condBlock: BasicBlock = null;\n            var continueTarget = loopStart;\n            var incrBB: BasicBlock = null;\n            if (this.incr) {\n                incrBB = new BasicBlock();\n                continueTarget = incrBB;\n            }\n            if (this.cond) {\n                condBlock = context.current;\n                context.addContent(this.cond);\n                context.current = new BasicBlock();\n                condBlock.addSuccessor(context.current);\n            }\n            var targetInfo: ITargetInfo = null;\n            if (this.body) {\n                context.pushStatement(this, continueTarget, afterLoop);\n                context.walk(this.body, this);\n                targetInfo = context.popStatement();\n            }\n            if (this.incr) {\n                if (context.noContinuation) {\n                    if (incrBB.predecessors.length == 0) {\n                        context.addUnreachable(this.incr);\n                    }\n                }\n                else {\n                    context.current.addSuccessor(incrBB);\n                    context.current = incrBB;\n                    context.addContent(this.incr);\n                }\n            }\n            var loopEnd = context.current;\n            if (!(context.noContinuation)) {\n                loopEnd.addSuccessor(loopStart);\n\n            }\n            if (condBlock) {\n                condBlock.addSuccessor(afterLoop);\n                context.noContinuation = false;\n            }\n            if (afterLoop.predecessors.length > 0) {\n                context.noContinuation = false;\n                context.current = afterLoop;\n            }\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class WithStatement extends Statement {\n        public body: AST;\n\n        public isCompoundStatement() { return true; }\n\n        public withSym: WithSymbol = null;\n\n        constructor (public expr: AST) {\n            super(NodeType.With);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput("with (");\n            if (this.expr) {\n                emitter.emitJavascript(this.expr, TokenID.With, false);\n            }\n\n            emitter.writeToOutput(")");\n            emitter.emitJavascriptStatements(this.body, true);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckWith(this);\n        }\n    }\n\n    export class SwitchStatement extends Statement {\n        public caseList:',
v27676=v27677+' ASTList;\n        public defaultCase: CaseStatement = null;\n        public statement: ASTSpan = new ASTSpan();\n\n        constructor (public val: AST) {\n            super(NodeType.Switch);\n        }\n\n        public isCompoundStatement() { return true; }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.recordSourceMappingStart(this.statement);\n            emitter.writeToOutput("switch(");\n            emitter.emitJavascript(this.val, TokenID.Identifier, false);\n            emitter.writeToOutput(")"); \n            emitter.recordSourceMappingEnd(this.statement);\n            emitter.writeLineToOutput(" {");\n            emitter.indenter.increaseIndent();\n            var casesLen = this.caseList.members.length;\n            for (var i = 0; i < casesLen; i++) {\n                var caseExpr = this.caseList.members[i];\n                emitter.emitJavascript(caseExpr, TokenID.Case, true);\n            }\n            emitter.indenter.decreaseIndent();\n            emitter.emitIndent();\n            emitter.writeToOutput("}");\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            var len = this.caseList.members.length;\n            this.val = typeFlow.typeCheck(this.val);\n            for (var i = 0; i < len; i++) {\n                this.caseList.members[i] = typeFlow.typeCheck(this.caseList.members[i]);\n            }\n            this.defaultCase = <CaseStatement>typeFlow.typeCheck(this.defaultCase);\n            this.type = typeFlow.voidType;\n            return this;\n        }\n\n        // if there are break statements that match this switch, then just link cond block with block after switch\n        public addToControlFlow(context: ControlFlowContext) {\n            var condBlock = context.current;\n            context.addContent(this.val);\n            var execBlock = new BasicBlock();\n            var afterSwitch = new BasicBlock();\n\n            condBlock.addSuccessor(execBlock);\n            context.pushSwitch(execBlock);\n            context.current = execBlock;\n            context.pushStatement(this, execBlock, afterSwitch);\n            context.walk(this.caseList, this);\n            context.popSwitch();\n            var targetInfo = context.popStatement();\n            var hasCondContinuation = (this.defaultCase == null);\n            if (this.defaultCase == null) {\n                condBlock.addSuccessor(afterSwitch);\n            }\n            if (afterSwitch.predecessors.length > 0) {\n                context.noContinuation = false;\n                context.current = afterSwitch;\n            }\n            else {\n                context.noContinuation = true;\n            }\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class CaseStatement extends Statement {\n        public expr: AST = null;\n        public body: ASTList;\n\n        constructor () {\n            super(NodeType.Case);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (this.expr) {\n                emitter.writeToOutput("case ");\n                emitter.emitJavascript(this.expr, TokenID.Identifier, false);\n            }\n            else {\n                emitter.writeToOutput("default");\n            }\n            emitter.writeToOutput(":");\n            if (this.body.members.length == 1 && this.body.members[0].nodeType == NodeType.Block) {\n                // The case statement was written with curly braces, so emit it with the appropriate formatting\n                emitter.emitJavascriptStatements(this.body, false);\n            }\n            else {\n                // No curly braces. Format in the expected way\n                emitter.writeLineToOutput("");\n                emitter.indenter.increaseIndent();\n                emitter.emitBareJavascriptStatements(this.body);\n                emitter.indenter.decreaseIndent();\n            }\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.expr = typeFlow.typeCheck(this.expr);\n            typeFlow.typeCheck(this.body);\n            this.type = typeFlow.voidType;\n            return this;\n        }\n\n        // TODO: more reasoning about unreachable cases (such as duplicate literals as case expressions)\n        // for now, assume all cases are reachable, regardless of whether some cases fall through\n        public addToControlFlow(context: ControlFlowContext) {\n            var execBlock = new BasicBlock();\n            v',
v27675=v27676+'ar sw = context.currentSwitch[context.currentSwitch.length - 1];\n            // TODO: fall-through from previous (+ to end of switch)\n            if (this.expr) {\n                var exprBlock = new BasicBlock();\n                context.current = exprBlock;\n                sw.addSuccessor(exprBlock);\n                context.addContent(this.expr);\n                exprBlock.addSuccessor(execBlock);\n            }\n            else {\n                sw.addSuccessor(execBlock);\n            }\n            context.current = execBlock;\n            if (this.body) {\n                context.walk(this.body, this);\n            }\n            context.noContinuation = false;\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class TypeReference extends AST {\n        constructor (public term: AST, public arrayCount: number) {\n            super(NodeType.TypeRef);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            throw new Error("should not emit a type ref");\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            var prevInTCTR = typeFlow.inTypeRefTypeCheck;\n            typeFlow.inTypeRefTypeCheck = true;\n            var typeLink = getTypeLink(this, typeFlow.checker, true);\n            typeFlow.checker.resolveTypeLink(typeFlow.scope, typeLink, false);\n\n            if (this.term) {\n                typeFlow.typeCheck(this.term);\n            }\n\n            typeFlow.checkForVoidConstructor(typeLink.type, this);\n\n            this.type = typeLink.type;\n\n            // in error recovery cases, there may not be a term\n            if (this.term) {\n                this.term.type = this.type;\n            }\n\n            typeFlow.inTypeRefTypeCheck = prevInTCTR;\n            return this;\n        }\n    }\n\n    export class TryFinally extends Statement {\n        constructor (public tryNode: AST, public finallyNode: Finally) {\n            super(NodeType.TryFinally);\n        }\n\n        public isCompoundStatement() { return true; }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.recordSourceMappingStart(this);\n            emitter.emitJavascript(this.tryNode, TokenID.Try, false);\n            emitter.emitJavascript(this.finallyNode, TokenID.Finally, false);\n            emitter.recordSourceMappingEnd(this);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.tryNode = typeFlow.typeCheck(this.tryNode);\n            this.finallyNode = <Finally>typeFlow.typeCheck(this.finallyNode);\n            this.type = typeFlow.voidType;\n            return this;\n        }\n\n        public addToControlFlow(context: ControlFlowContext) {\n            var afterFinally = new BasicBlock();\n            context.walk(this.tryNode, this);\n            var finBlock = new BasicBlock();\n            if (context.current) {\n                context.current.addSuccessor(finBlock);\n            }\n            context.current = finBlock;\n            context.pushStatement(this, null, afterFinally);\n            context.walk(this.finallyNode, this);\n            if (!context.noContinuation && context.current) {\n                context.current.addSuccessor(afterFinally);\n            }\n            if (afterFinally.predecessors.length > 0) {\n                context.current = afterFinally;\n            }\n            else {\n                context.noContinuation = true;\n            }\n            context.popStatement();\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class TryCatch extends Statement {\n        constructor (public tryNode: Try, public catchNode: Catch) {\n            super(NodeType.TryCatch);\n        }\n\n        public isCompoundStatement() { return true; }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.emitJavascript(this.tryNode, TokenID.Try, false);\n            emitter.emitJavascript(this.catchNode, TokenID.Catch, false);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public addToControlFlow(context: ControlFlowContext) {\n            var beforeTry = context.current;\n            var tryBlock = new BasicBlock();\n            beforeTry.addSuccessor(tryBlock);\n            context.current = tryBlock;\n            var afterTryCatch = new BasicBlock();\n            context.pushStatement(this, null, afterTryCatch);\n            context.walk(this.tryNode, this);\n            if (!context.noContinuation) {\n                if (context.current) {\n                    context.current.addSuccessor(afterTryCatch);\n                }\n            }\n            context.current = new BasicBlock();\n            beforeTry.addSuccessor(context.current);\n            context.walk(this.catchNode, this);\n            context.popStatement();\n            if (!context.noContinuation)',
v27674=v27675+' {\n                if (context.current) {\n                    context.current.addSuccessor(afterTryCatch);\n                }\n            }\n            context.current = afterTryCatch;\n            context.walker.options.goChildren = false;\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.tryNode = <Try>typeFlow.typeCheck(this.tryNode);\n            this.catchNode = <Catch>typeFlow.typeCheck(this.catchNode);\n            this.type = typeFlow.voidType;\n            return this;\n        }\n    }\n\n    export class Try extends Statement {\n        constructor (public body: AST) {\n            super(NodeType.Try);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput("try ");\n            emitter.emitJavascript(this.body, TokenID.Try, false);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.body = typeFlow.typeCheck(this.body);\n            return this;\n        }\n\n        public addToControlFlow(context: ControlFlowContext) {\n            if (this.body) {\n                context.walk(this.body, this);\n            }\n            context.walker.options.goChildren = false;\n            context.noContinuation = false;\n        }\n    }\n\n    export class Catch extends Statement {\n        constructor (public param: VarDecl, public body: AST) {\n            super(NodeType.Catch);\n            if (this.param) {\n                this.param.varFlags |= VarFlags.AutoInit;\n            }\n        }\n        public statement: ASTSpan = new ASTSpan();\n        public containedScope: SymbolScope = null;\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput(" ");\n            emitter.recordSourceMappingStart(this.statement);\n            emitter.writeToOutput("catch (");\n            emitter.emitJavascript(this.param, TokenID.OpenParen, false);\n            emitter.writeToOutput(")");\n            emitter.recordSourceMappingEnd(this.statement);\n            emitter.emitJavascript(this.body, TokenID.Catch, false);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public addToControlFlow(context: ControlFlowContext) {\n            if (this.param) {\n                context.addContent(this.param);\n                var bodBlock = new BasicBlock();\n                context.current.addSuccessor(bodBlock);\n                context.current = bodBlock;\n            }\n            if (this.body) {\n                context.walk(this.body, this);\n            }\n            context.noContinuation = false;\n            context.walker.options.goChildren = false;\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            var prevScope = typeFlow.scope;\n            typeFlow.scope = this.containedScope;\n            this.param = <VarDecl>typeFlow.typeCheck(this.param);\n            var exceptVar = new ValueLocation();\n            var varSym = new VariableSymbol((<VarDecl>this.param).id.text,\n                                          this.param.minChar,\n                                          typeFlow.checker.locationInfo.unitIndex,\n                                          exceptVar);\n            exceptVar.symbol = varSym;\n            exceptVar.typeLink = new TypeLink();\n            // var type for now (add syntax for type annotation)\n            exceptVar.typeLink.type = typeFlow.anyType;\n            var thisFnc = typeFlow.thisFnc;\n            if (thisFnc && thisFnc.type) {\n                exceptVar.symbol.container = thisFnc.type.symbol;\n            }\n            else {\n                exceptVar.symbol.container = null;\n            }\n            this.param.sym = exceptVar.symbol;\n            typeFlow.scope.enter(exceptVar.symbol.container, this.param, exceptVar.symbol,\n                                 typeFlow.checker.errorReporter, false, false, false);\n            this.body = typeFlow.typeCheck(this.body);\n\n            // if we\'re in provisional typecheck mode, clean up the symbol entry\n            // REVIEW: This is obviously bad form, since we\'re counting on the internal\n            // layout of the symbol table, but this is also the only place where we insert\n            // symbols during typecheck\n            if (typeFlow.checker.inProvisionalTypecheckMode()) {\n                var table = typeFlow.scope.getTable();\n                (<any>table).secondaryTable.table[exceptVar.symbol.name] = undefined;\n            }\n            this.type = typeFlow.voidType;\n            typeFlow.scope = prevScope;\n            return this;\n        }\n    }\n\n    export class Finally extends Statement ',
v27673=v27674+'{\n        constructor (public body: AST) {\n            super(NodeType.Finally);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput("finally");\n            emitter.emitJavascript(this.body, TokenID.Finally, false);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public addToControlFlow(context: ControlFlowContext) {\n            if (this.body) {\n                context.walk(this.body, this);\n            }\n            context.walker.options.goChildren = false;\n            context.noContinuation = false;\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.body = typeFlow.typeCheck(this.body);\n            return this;\n        }\n    }\n\n    export class Comment extends AST {\n\n        public text: string[] = null;\n        public minLine: number;\n        public limLine: number;\n        private docCommentText: string = null;\n\n        constructor (public content: string, public isBlockComment: bool, public endsLine) {\n            super(NodeType.Comment);\n        }\n\n        public getText(): string[] {\n            if (this.text == null) {\n                if (this.isBlockComment) {\n                    this.text = this.content.split("\\n");\n                    for (var i = 0; i < this.text.length; i++) {\n                        this.text[i] = this.text[i].replace(/^\\s+|\\s+$/g, \'\');\n                    }\n                }\n                else {\n                    this.text = [(this.content.replace(/^\\s+|\\s+$/g, \'\'))];\n                }\n            }\n\n            return this.text;\n        }\n\n        public isDocComment() {\n            if (this.isBlockComment) {\n                return this.content.charAt(2) == "*";\n            }\n\n            return false;\n        }\n\n        public getDocCommentText() {\n            if (this.docCommentText == null) {\n                this.docCommentText = Comment.cleanJSDocComment(this.content);\n            }\n\n            return this.docCommentText;\n        }\n\n        static consumeLeadingSpace(line: string, startIndex: number, maxSpacesToRemove?: number) {\n            var endIndex = line.length;\n            if (maxSpacesToRemove != undefined) {\n                endIndex = min(startIndex + maxSpacesToRemove, endIndex);\n            }\n\n            for (; startIndex < endIndex; startIndex++) {\n                var charCode = line.charCodeAt(startIndex);\n                if (charCode != LexCodeSpace && charCode != LexCodeTAB) {\n                    return startIndex;\n                }\n            }\n            \n            if (endIndex != line.length) {\n                return endIndex;\n            }\n\n            return -1;\n        }\n\n        static isSpaceChar(line: string, index: number) {\n            var length = line.length;\n            if (index < length) {\n                var charCode = line.charCodeAt(index);\n                // If the character is space\n                return charCode == LexCodeSpace || charCode == LexCodeTAB;\n            }\n\n            // If the index is end of the line it is space\n            return index == length;\n        }\n\n        static cleanDocCommentLine(line: string, jsDocStyleComment: bool, jsDocLineSpaceToRemove?: number) {\n            var nonSpaceIndex = Comment.consumeLeadingSpace(line, 0);\n            if (nonSpaceIndex != -1) {\n                var jsDocSpacesRemoved = nonSpaceIndex;\n                if (jsDocStyleComment && line.charAt(nonSpaceIndex) == \'*\') { // remove leading * in case of jsDocComment\n                    var startIndex = nonSpaceIndex + 1;\n                    nonSpaceIndex = Comment.consumeLeadingSpace(line, startIndex, jsDocLineSpaceToRemove);\n\n                    if (nonSpaceIndex != -1) {\n                        jsDocSpacesRemoved = nonSpaceIndex - startIndex;\n                    } else {\n                        return null;\n                    }\n                }\n\n                return {\n                    minChar: nonSpaceIndex,\n                    limChar: line.charAt(line.length - 1) == "\\r" ? line.length - 1 : line.length,\n                    jsDocSpacesRemoved: jsDocSpacesRemoved\n                };\n            }\n\n            return null;\n        }\n\n        static cleanJSDocComment(content: string, spacesToRemove?: number) {\n            var docCommentLines: string[] = [];\n            content = content.replace("/**", ""); // remove /**\n            if (content.length >= 2 && content.charAt(content.length - 1) == "/" && content.charAt(content.length - 2) == "*") {\n                content = content.substring(0, content.length - 2); // remove last */\n            }\n            var lines = content.split("\\n");\n            var inParamTag = false;\n            for (var l = 0; l < lines.length; l++) {\n                var line = lines[l];\n                var clean',
v27672=v27673+'LinePos = Comment.cleanDocCommentLine(line, true, spacesToRemove);\n                if (!cleanLinePos) {\n                    // Whole line empty, read next line\n                    continue;\n                }\n\n                var docCommentText = "";\n                var prevPos = cleanLinePos.minChar;\n                for (var i = line.indexOf("@", cleanLinePos.minChar); 0 <= i && i < cleanLinePos.limChar; i = line.indexOf("@", i + 1)) {\n                    // We have encoutered @. \n                    // If we were omitting param comment, we dont have to do anything\n                    // other wise the content of the text till @ tag goes as doc comment\n                    var wasInParamtag = inParamTag;\n\n                    // Parse contents next to @\n                    if (line.indexOf("param", i + 1) == i + 1 && Comment.isSpaceChar(line, i + 6)) {\n                        // It is param tag. \n\n                        // If we were not in param tag earlier, push the contents from prev pos of the tag this tag start as docComment\n                        if (!wasInParamtag) {\n                            docCommentText += line.substring(prevPos, i);\n                        }\n\n                        // New start of contents \n                        prevPos = i;\n                        inParamTag = true;\n                    } else if (wasInParamtag) {\n                        // Non param tag start\n                        prevPos = i;\n                        inParamTag = false;\n                    }\n                }\n\n                if (!inParamTag) {\n                    docCommentText += line.substring(prevPos, cleanLinePos.limChar);\n                }\n\n                // Add line to comment text if it is not only white space line\n                var newCleanPos = Comment.cleanDocCommentLine(docCommentText, false);\n                if (newCleanPos) {\n                    if (spacesToRemove == undefined) {\n                        spacesToRemove = cleanLinePos.jsDocSpacesRemoved;\n                    }\n                    docCommentLines.push(docCommentText);\n                }\n            }\n            \n            return docCommentLines.join("\\n");\n        }\n\n        static getDocCommentText(comments: Comment[]) {\n            var docCommentText: string[] = [];\n            for (var c = 0 ; c < comments.length; c++) {\n                var commentText = comments[c].getDocCommentText();\n                if (commentText != "") {\n                    docCommentText.push(commentText);\n                }\n            }\n            return docCommentText.join("\\n");\n        }\n\n        static getParameterDocCommentText(param: string, fncDocComments: Comment[]) {\n            if (fncDocComments.length == 0 || !fncDocComments[0].isBlockComment) {\n                // there were no fnc doc comments and the comment is not block comment then it cannot have \n                // @param comment that can be parsed\n                return "";\n            }\n            \n            for (var i = 0; i < fncDocComments.length; i++) {\n                var commentContents = fncDocComments[i].content;\n                for (var j = commentContents.indexOf("@param", 0); 0 <= j; j = commentContents.indexOf("@param", j)) {\n                    j += 6;\n                    if (!Comment.isSpaceChar(commentContents, j)) {\n                        // This is not param tag but a tag line @paramxxxxx\n                        continue;\n                    }\n\n                    // This is param tag. Check if it is what we are looking for\n                    j = Comment.consumeLeadingSpace(commentContents, j);\n                    if (j == -1) {\n                        break;\n                    }\n                    \n                    // Ignore the type expression\n                    if (commentContents.charCodeAt(j) == LexCodeLC) {\n                        j++;\n                        // Consume the type\n                        var charCode = 0;\n                        for (var curlies = 1; j < commentContents.length; j++) {\n                            charCode = commentContents.charCodeAt(j);\n                            // { character means we need to find another } to match the found one\n                            if (charCode == LexCodeLC) {\n                                curlies++;\n                                continue;\n                            }\n\n                            // } char\n                            if (charCode == LexCodeRC) {\n                                curlies--;\n                                if (curlies == 0) {\n                                    // We do not have any more } to match the type expression is ignored completely\n                                    break;\n                                } else {\n                                    // there are more { to be matched with }\n                                    continue;\n                                }\n                            }\n\n                            // Found start',
v27671=v27672+' of another tag\n                            if (charCode == LexCodeAtSign) {\n                                break;\n                            }\n                        }\n\n                        // End of the comment\n                        if (j == commentContents.length) {\n                            break;\n                        }\n\n                        // End of the tag, go onto looking for next tag\n                        if (charCode == LexCodeAtSign) {\n                            continue;\n                        }\n\n                        j = Comment.consumeLeadingSpace(commentContents, j + 1);\n                        if (j == -1) {\n                            break;\n                        }\n                    }\n\n                    // Parameter name\n                    if (param != commentContents.substr(j, param.length) || !Comment.isSpaceChar(commentContents, j + param.length)) {\n                        // this is not the parameter we are looking for\n                        continue;\n                    }\n\n                    // Found the parameter we were looking for\n                    j = Comment.consumeLeadingSpace(commentContents, j + param.length);\n                    if (j == -1) {\n                        return "";\n                    }\n                    \n                    var endOfParam = commentContents.indexOf("@", j);\n                    var paramHelpString = commentContents.substring(j, endOfParam < 0 ? commentContents.length : endOfParam);\n\n                    // Find alignement spaces to remove\n                    var paramSpacesToRemove: number = undefined;\n                    var paramLineIndex = commentContents.substring(0, j).lastIndexOf("\\n") + 1;\n                    if (paramLineIndex != 0) {\n                        if (paramLineIndex < j && commentContents.charAt(paramLineIndex + 1) == "\\r") {\n                            paramLineIndex++;\n                        }\n                    }\n                    var startSpaceRemovalIndex = Comment.consumeLeadingSpace(commentContents, paramLineIndex);\n                    if (startSpaceRemovalIndex != j && commentContents.charAt(startSpaceRemovalIndex) == "*") {\n                        paramSpacesToRemove = j - startSpaceRemovalIndex - 1;\n                    }\n\n                    // Clean jsDocComment and return\n                    return Comment.cleanJSDocComment(paramHelpString, paramSpacesToRemove);\n                }\n            }\n\n            return "";\n        }\n\n        static getDocCommentTextOfSignatures(signatures: Signature[]) {\n            var comments: string[] = [];\n            for (var i = 0; i < signatures.length; i++) {\n                var signatureDocComment = TypeScript.Comment.getDocCommentText(signatures[i].declAST.getDocComments());\n                if (signatureDocComment != "") {\n                    comments.push(signatureDocComment);\n                }\n            }\n\n            return comments.join("\\n");\n        }\n    }\n\n    export class DebuggerStatement extends Statement {\n        constructor () {\n            super(NodeType.Debugger);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeLineToOutput("debugger;");\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript.AstWalkerWithDetailCallback {\n    export interface AstWalkerDetailCallback {\n        EmptyCallback? (pre, ast: AST): bool;\n        EmptyExprCallback? (pre, ast: AST): bool;\n        TrueCallback? (pre, ast: AST): bool;\n        FalseCallback? (pre, ast: AST): bool;\n        ThisCallback? (pre, ast: AST): bool;\n        SuperCallback? (pre, ast: AST): bool;\n        QStringCallback? (pre, ast: AST): bool;\n        RegexCallback? (pre, ast: AST): bool;\n        NullCallback? (pre, ast: AST): bool;\n        ArrayLitCallback? (pre, ast: AST): bool;\n        ObjectLitCallback? (pre, ast: AST): bool;\n        VoidCallback? (pre, ast: AST): bool;\n        CommaCallback? (pre, ast: AST): bool;\n        PosCallback? (pre, ast: AST): bool;\n        NegCallback? (pre, ast: AST): bool;\n        DeleteCallback? (pre, ast: AST): bool;\n        AwaitCal',
v27670=v27671+"lback? (pre, ast: AST): bool;\n        InCallback? (pre, ast: AST): bool;\n        DotCallback? (pre, ast: AST): bool;\n        FromCallback? (pre, ast: AST): bool;\n        IsCallback? (pre, ast: AST): bool;\n        InstOfCallback? (pre, ast: AST): bool;\n        TypeofCallback? (pre, ast: AST): bool;\n        NumberLitCallback? (pre, ast: AST): bool;\n        NameCallback? (pre, identifierAst: Identifier): bool;\n        TypeRefCallback? (pre, ast: AST): bool;\n        IndexCallback? (pre, ast: AST): bool;\n        CallCallback? (pre, ast: AST): bool;\n        NewCallback? (pre, ast: AST): bool;\n        AsgCallback? (pre, ast: AST): bool;\n        AsgAddCallback? (pre, ast: AST): bool;\n        AsgSubCallback? (pre, ast: AST): bool;\n        AsgDivCallback? (pre, ast: AST): bool;\n        AsgMulCallback? (pre, ast: AST): bool;\n        AsgModCallback? (pre, ast: AST): bool;\n        AsgAndCallback? (pre, ast: AST): bool;\n        AsgXorCallback? (pre, ast: AST): bool;\n        AsgOrCallback? (pre, ast: AST): bool;\n        AsgLshCallback? (pre, ast: AST): bool;\n        AsgRshCallback? (pre, ast: AST): bool;\n        AsgRs2Callback? (pre, ast: AST): bool;\n        QMarkCallback? (pre, ast: AST): bool;\n        LogOrCallback? (pre, ast: AST): bool;\n        LogAndCallback? (pre, ast: AST): bool;\n        OrCallback? (pre, ast: AST): bool;\n        XorCallback? (pre, ast: AST): bool;\n        AndCallback? (pre, ast: AST): bool;\n        EqCallback? (pre, ast: AST): bool;\n        NeCallback? (pre, ast: AST): bool;\n        EqvCallback? (pre, ast: AST): bool;\n        NEqvCallback? (pre, ast: AST): bool;\n        LtCallback? (pre, ast: AST): bool;\n        LeCallback? (pre, ast: AST): bool;\n        GtCallback? (pre, ast: AST): bool;\n        GeCallback? (pre, ast: AST): bool;\n        AddCallback? (pre, ast: AST): bool;\n        SubCallback? (pre, ast: AST): bool;\n        MulCallback? (pre, ast: AST): bool;\n        DivCallback? (pre, ast: AST): bool;\n        ModCallback? (pre, ast: AST): bool;\n        LshCallback? (pre, ast: AST): bool;\n        RshCallback? (pre, ast: AST): bool;\n        Rs2Callback? (pre, ast: AST): bool;\n        NotCallback? (pre, ast: AST): bool;\n        LogNotCallback? (pre, ast: AST): bool;\n        IncPreCallback? (pre, ast: AST): bool;\n        DecPreCallback? (pre, ast: AST): bool;\n        IncPostCallback? (pre, ast: AST): bool;\n        DecPostCallback? (pre, ast: AST): bool;\n        TypeAssertionCallback? (pre, ast: AST): bool;\n        FuncDeclCallback? (pre, funcDecl: FuncDecl): bool;\n        MemberCallback? (pre, ast: AST): bool;\n        VarDeclCallback? (pre, varDecl: VarDecl): bool;\n        ArgDeclCallback? (pre, ast: AST): bool;\n        ReturnCallback? (pre, ast: AST): bool;\n        BreakCallback? (pre, ast: AST): bool;\n        ContinueCallback? (pre, ast: AST): bool;\n        ThrowCallback? (pre, ast: AST): bool;\n        ForCallback? (pre, ast: AST): bool;\n        ForInCallback? (pre, ast: AST): bool;\n        IfCallback? (pre, ast: AST): bool;\n        WhileCallback? (pre, ast: AST): bool;\n        DoWhileCallback? (pre, ast: AST): bool;\n        BlockCallback? (pre, block: Block): bool;\n        CaseCallback? (pre, ast: AST): bool;\n        SwitchCallback? (pre, ast: AST): bool;\n        TryCallback? (pre, ast: AST): bool;\n        TryCatchCallback? (pre, ast: AST): bool;\n        TryFinallyCallback? (pre, ast: AST): bool;\n        FinallyCallback? (pre, ast: AST): bool;\n        CatchCallback? (pre, ast: AST): bool;\n        ListCallback? (pre, astList: ASTList): bool;\n        ScriptCallback? (pre, script: Script): bool;\n        ClassDeclarationCallback? (pre, ast: AST): bool;\n        InterfaceDeclarationCallback? (pre, interfaceDecl: InterfaceDeclaration): bool;\n        ModuleDeclarationCallback? (pre, moduleDecl: ModuleDeclaration): bool;\n        ImportDeclarationCallback? (pre, ast: AST): bool;\n        WithCallback? (pre, ast: AST): bool;\n        LabelCallback? (pre, labelAST: AST): bool;\n        LabeledStatementCallback? (pre, ast: AST): bool;\n        EBStartCallback? (pre, ast: AST): bool;\n        GotoEBCallback? (pre, ast: AST): bool;\n        EndCodeCallback? (pre, ast: AST): bool;\n        ErrorCallback? (pre, ast: AST): bool;\n        CommentCallback? (pre, ast: AST): bool;\n        DebuggerCallback? (pre, ast: AST): bool;\n        DefaultCallback? (pre, ast: AST): bool;\n    }\n\n    export function walk(script: Script, callback: AstWalkerDetailCallback): void {\n        var pre = (cur: AST, parent: AST) => {\n            walker.options.goChildren = AstWalkerCallback(true, cur, callback);\n            return cur;\n        }\n\n        var post = (cur: AST, parent: AST) => {\n            AstWalkerCallback(false, cur, callback);\n            return cur;\n        }\n\n        var walker = TypeScript.getAstWalkerFactory().getWalker(pre, post);\n        walker.walk(script, null);\n    }\n\n    function AstWalkerCallback(pre: bool, ast: AST, callback: AstWalkerDetailCallback): bool {\n        // See if the Callback needs to be handled using spe",
v27669=v27670+'cific one or default one\n        var nodeType = ast.nodeType;\n        var callbackString = (<any>NodeType)._map[nodeType] + "Callback";\n        if (callback[callbackString]) {\n            return callback[callbackString](pre, ast);\n        }\n\n        if (callback.DefaultCallback) {\n            return callback.DefaultCallback(pre, ast);\n        }\n\n        return true;\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export interface IAstWalker {\n        walk(ast: AST, parent: AST): AST;\n        options: AstWalkOptions;\n        state: any; // user state object\n    }\n\n    export class AstWalkOptions {\n        public goChildren = true;\n        public goNextSibling = true;\n        public reverseSiblings = false; // visit siblings in reverse execution order\n\n        public stopWalk(stop:bool = true) {\n            this.goChildren = !stop;\n            this.goNextSibling = !stop;\n        }\n    }\n\n    export interface IAstWalkCallback {\n        (ast: AST, parent: AST, walker: IAstWalker): AST;\n    }\n\n    export interface IAstWalkChildren {\n        (preAst: AST, parent: AST, walker: IAstWalker): void;\n    }\n\n    class AstWalker implements IAstWalker {\n        constructor (\n            private childrenWalkers: IAstWalkChildren[],\n            private pre: IAstWalkCallback,\n            private post: IAstWalkCallback,\n            public options: AstWalkOptions,\n            public state: any) {\n        }\n\n        public walk(ast: AST, parent: AST): AST {\n            var preAst = this.pre(ast, parent, this);\n            if (preAst === undefined) {\n                preAst = ast;\n            }\n            if (this.options.goChildren) {\n                var svGoSib = this.options.goNextSibling;\n                this.options.goNextSibling = true;\n                // Call the "walkChildren" function corresponding to "nodeType".\n                this.childrenWalkers[ast.nodeType](ast, parent, this);\n                this.options.goNextSibling = svGoSib;\n            }\n            else {\n                // no go only applies to children of node issuing it\n                this.options.goChildren = true;\n            }\n            if (this.post) {\n                var postAst = this.post(preAst, parent, this);\n                if (postAst === undefined) {\n                    postAst = preAst;\n                }\n                return postAst;\n            }\n            else {\n                return preAst;\n            }\n        }\n    }\n\n    export class AstWalkerFactory {\n        private childrenWalkers: IAstWalkChildren[] = [];\n\n        constructor () {\n            this.initChildrenWalkers();\n        }\n\n        public walk(ast: AST, pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any): AST {\n            return this.getWalker(pre, post, options, state).walk(ast, null)\n        }\n\n        public getWalker(pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any): IAstWalker {\n            return this.getSlowWalker(pre, post, options, state);\n        }\n\n        private getSlowWalker(pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any): IAstWalker {\n            if (!options) {\n                options = new AstWalkOptions();\n            }\n\n            return new AstWalker(this.childrenWalkers, pre, post, options, state);\n        }\n\n        private initChildrenWalkers(): void {\n            this.childrenWalkers[NodeType.None] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Empty] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.EmptyExpr] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.True] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.False] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.This] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Super] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.QString] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Regex] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Null] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.ArrayLit] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.ObjectLit] = ChildrenWalkers.walkUnaryExpressionChild',
v27668=v27669+"ren;\n            this.childrenWalkers[NodeType.Void] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.Comma] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Pos] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.Neg] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.Delete] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.Await] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.In] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Dot] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.From] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Is] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.InstOf] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Typeof] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.NumberLit] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Name] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.TypeRef] = ChildrenWalkers.walkTypeReferenceChildren;\n            this.childrenWalkers[NodeType.Index] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Call] = ChildrenWalkers.walkCallExpressionChildren;\n            this.childrenWalkers[NodeType.New] = ChildrenWalkers.walkCallExpressionChildren;\n            this.childrenWalkers[NodeType.Asg] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgAdd] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgSub] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgDiv] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgMul] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgMod] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgAnd] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgXor] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgOr] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgLsh] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgRsh] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgRs2] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.ConditionalExpression] = ChildrenWalkers.walkTrinaryExpressionChildren;\n            this.childrenWalkers[NodeType.LogOr] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.LogAnd] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Or] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Xor] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.And] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Eq] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Ne] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Eqv] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.NEqv] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Lt] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Le] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Gt] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Ge] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Add] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Sub] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Mul] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Div] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Mod] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Lsh] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Rsh] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Rs2] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalker",
v27667=v27668+'s[NodeType.Not] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.LogNot] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.IncPre] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.DecPre] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.IncPost] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.DecPost] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.TypeAssertion] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.FuncDecl] = ChildrenWalkers.walkFuncDeclChildren;\n            this.childrenWalkers[NodeType.Member] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.VarDecl] = ChildrenWalkers.walkBoundDeclChildren;\n            this.childrenWalkers[NodeType.ArgDecl] = ChildrenWalkers.walkBoundDeclChildren;\n            this.childrenWalkers[NodeType.Return] = ChildrenWalkers.walkReturnStatementChildren;\n            this.childrenWalkers[NodeType.Break] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Continue] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Throw] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.For] = ChildrenWalkers.walkForStatementChildren;\n            this.childrenWalkers[NodeType.ForIn] = ChildrenWalkers.walkForInStatementChildren;\n            this.childrenWalkers[NodeType.If] = ChildrenWalkers.walkIfStatementChildren;\n            this.childrenWalkers[NodeType.While] = ChildrenWalkers.walkWhileStatementChildren;\n            this.childrenWalkers[NodeType.DoWhile] = ChildrenWalkers.walkDoWhileStatementChildren;\n            this.childrenWalkers[NodeType.Block] = ChildrenWalkers.walkBlockChildren;\n            this.childrenWalkers[NodeType.Case] = ChildrenWalkers.walkCaseStatementChildren;\n            this.childrenWalkers[NodeType.Switch] = ChildrenWalkers.walkSwitchStatementChildren;\n            this.childrenWalkers[NodeType.Try] = ChildrenWalkers.walkTryChildren;\n            this.childrenWalkers[NodeType.TryCatch] = ChildrenWalkers.walkTryCatchChildren;\n            this.childrenWalkers[NodeType.TryFinally] = ChildrenWalkers.walkTryFinallyChildren;\n            this.childrenWalkers[NodeType.Finally] = ChildrenWalkers.walkFinallyChildren;\n            this.childrenWalkers[NodeType.Catch] = ChildrenWalkers.walkCatchChildren;\n            this.childrenWalkers[NodeType.List] = ChildrenWalkers.walkListChildren;\n            this.childrenWalkers[NodeType.Script] = ChildrenWalkers.walkScriptChildren;\n            this.childrenWalkers[NodeType.ClassDeclaration] = ChildrenWalkers.walkClassDeclChildren;\n            this.childrenWalkers[NodeType.InterfaceDeclaration] = ChildrenWalkers.walkTypeDeclChildren;\n            this.childrenWalkers[NodeType.ModuleDeclaration] = ChildrenWalkers.walkModuleDeclChildren;\n            this.childrenWalkers[NodeType.ImportDeclaration] = ChildrenWalkers.walkImportDeclChildren;\n            this.childrenWalkers[NodeType.With] = ChildrenWalkers.walkWithStatementChildren;\n            this.childrenWalkers[NodeType.Label] = ChildrenWalkers.walkLabelChildren;\n            this.childrenWalkers[NodeType.LabeledStatement] = ChildrenWalkers.walkLabeledStatementChildren;\n            this.childrenWalkers[NodeType.EBStart] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.GotoEB] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.EndCode] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Error] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Comment] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Debugger] = ChildrenWalkers.walkNone;\n\n            // Verify the code is up to date with the enum\n            for (var e in (<any>NodeType)._map) {\n                if ((<any>this.childrenWalkers)[e] === undefined) {\n                    throw new Error("initWalkers function is not up to date with enum content!");\n                }\n            }\n        }\n    }\n\n    var globalAstWalkerFactory: AstWalkerFactory;\n\n    export function getAstWalkerFactory(): AstWalkerFactory {\n        if (!globalAstWalkerFactory) {\n            globalAstWalkerFactory = new AstWalkerFactory();\n        }\n        return globalAstWalkerFactory;\n    }\n\n    module ChildrenWalkers {\n        export function walkNone(preAst: ASTList, parent: AST, walker: IAstWalker): void {\n            // Nothing to do\n        }\n\n        export function walkListChildren(preAst: ASTList, parent: AST, walker: IAstWalker): void {\n            var len = preAst.members.length;\n            if (walker.options.reverseSiblings) {\n                for (var i = len - 1; i >= 0; i--) {\n                    if (walker.options.goNextSibling) {\n                        preAst.m',
v27666=v27667+"embers[i] = walker.walk(preAst.members[i], preAst);\n                    }\n                }\n            }\n            else {\n                for (var i = 0; i < len; i++) {\n                    if (walker.options.goNextSibling) {\n                        preAst.members[i] = walker.walk(preAst.members[i], preAst);\n                    }\n                }\n            }\n        }\n\n        export function walkUnaryExpressionChildren(preAst: UnaryExpression, parent: AST, walker: IAstWalker): void {\n            if (preAst.castTerm) {\n                preAst.castTerm = walker.walk(preAst.castTerm, preAst);\n            }\n            if (preAst.operand) {\n                preAst.operand = walker.walk(preAst.operand, preAst);\n            }\n        }\n\n        export function walkBinaryExpressionChildren(preAst: BinaryExpression, parent: AST, walker: IAstWalker): void {\n            if (walker.options.reverseSiblings) {\n                if (preAst.operand2) {\n                    preAst.operand2 = walker.walk(preAst.operand2, preAst);\n                }\n                if ((preAst.operand1) && (walker.options.goNextSibling)) {\n                    preAst.operand1 = walker.walk(preAst.operand1, preAst);\n                }\n            } else {\n                if (preAst.operand1) {\n                    preAst.operand1 = walker.walk(preAst.operand1, preAst);\n                }\n                if ((preAst.operand2) && (walker.options.goNextSibling)) {\n                    preAst.operand2 = walker.walk(preAst.operand2, preAst);\n                }\n            }\n        }\n\n        export function walkTypeReferenceChildren(preAst: TypeReference, parent: AST, walker: IAstWalker): void {\n            if (preAst.term) {\n                preAst.term = walker.walk(preAst.term, preAst);\n            }\n        }\n\n        export function walkCallExpressionChildren(preAst: CallExpression, parent: AST, walker: IAstWalker): void {\n            if (!walker.options.reverseSiblings) {\n                preAst.target = walker.walk(preAst.target, preAst);\n            }\n            if (preAst.arguments && (walker.options.goNextSibling)) {\n                preAst.arguments = <ASTList> walker.walk(preAst.arguments, preAst);\n            }\n            if ((walker.options.reverseSiblings) && (walker.options.goNextSibling)) {\n                preAst.target = walker.walk(preAst.target, preAst);\n            }\n        }\n\n        export function walkTrinaryExpressionChildren(preAst: ConditionalExpression, parent: AST, walker: IAstWalker): void {\n            if (preAst.operand1) {\n                preAst.operand1 = walker.walk(preAst.operand1, preAst);\n            }\n            if (preAst.operand2 && (walker.options.goNextSibling)) {\n                preAst.operand2 = walker.walk(preAst.operand2, preAst);\n            }\n            if (preAst.operand3 && (walker.options.goNextSibling)) {\n                preAst.operand3 = walker.walk(preAst.operand3, preAst);\n            }\n        }\n\n        export function walkFuncDeclChildren(preAst: FuncDecl, parent: AST, walker: IAstWalker): void {\n            if (preAst.name) {\n                preAst.name = <Identifier>walker.walk(preAst.name, preAst);\n            }\n            if (preAst.arguments && (preAst.arguments.members.length > 0) && (walker.options.goNextSibling)) {\n                preAst.arguments = <ASTList>walker.walk(preAst.arguments, preAst);\n            }\n            if (preAst.returnTypeAnnotation && (walker.options.goNextSibling)) {\n                preAst.returnTypeAnnotation = walker.walk(preAst.returnTypeAnnotation, preAst);\n            }\n            if (preAst.bod && (preAst.bod.members.length > 0) && (walker.options.goNextSibling)) {\n                preAst.bod = <ASTList>walker.walk(preAst.bod, preAst);\n            }\n        }\n\n        export function walkBoundDeclChildren(preAst: BoundDecl, parent: AST, walker: IAstWalker): void {\n            if (preAst.id) {\n                preAst.id = <Identifier>walker.walk(preAst.id, preAst);\n            }\n            if (preAst.init) {\n                preAst.init = walker.walk(preAst.init, preAst);\n            }\n            if ((preAst.typeExpr) && (walker.options.goNextSibling)) {\n                preAst.typeExpr = walker.walk(preAst.typeExpr, preAst);\n            }\n        }\n\n        export function walkReturnStatementChildren(preAst: ReturnStatement, parent: AST, walker: IAstWalker): void {\n            if (preAst.returnExpression) {\n                preAst.returnExpression = walker.walk(preAst.returnExpression, preAst);\n            }\n        }\n\n        export function walkForStatementChildren(preAst: ForStatement, parent: AST, walker: IAstWalker): void {\n            if (preAst.init) {\n                preAst.init = walker.walk(preAst.init, preAst);\n            }\n\n            if (preAst.cond && walker.options.goNextSibling) {\n                preAst.cond = walker.walk(preAst.cond, preAst);\n            }\n\n            if (preAst.incr && walker.options.goNextSibling) {\n                pr",
v27665=v27666+"eAst.incr = walker.walk(preAst.incr, preAst);\n            }\n\n            if (preAst.body && walker.options.goNextSibling) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkForInStatementChildren(preAst: ForInStatement, parent: AST, walker: IAstWalker): void {\n            preAst.lval = walker.walk(preAst.lval, preAst);\n            if (walker.options.goNextSibling) {\n                preAst.obj = walker.walk(preAst.obj, preAst);\n            }\n            if (preAst.body && (walker.options.goNextSibling)) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkIfStatementChildren(preAst: IfStatement, parent: AST, walker: IAstWalker): void {\n            preAst.cond = walker.walk(preAst.cond, preAst);\n            if (preAst.thenBod && (walker.options.goNextSibling)) {\n                preAst.thenBod = walker.walk(preAst.thenBod, preAst);\n            }\n            if (preAst.elseBod && (walker.options.goNextSibling)) {\n                preAst.elseBod = walker.walk(preAst.elseBod, preAst);\n            }\n        }\n\n        export function walkWhileStatementChildren(preAst: WhileStatement, parent: AST, walker: IAstWalker): void {\n            preAst.cond = walker.walk(preAst.cond, preAst);\n            if (preAst.body && (walker.options.goNextSibling)) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkDoWhileStatementChildren(preAst: DoWhileStatement, parent: AST, walker: IAstWalker): void {\n            preAst.cond = walker.walk(preAst.cond, preAst);\n            if (preAst.body && (walker.options.goNextSibling)) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkBlockChildren(preAst: Block, parent: AST, walker: IAstWalker): void {\n            if (preAst.statements) {\n                preAst.statements = <ASTList>walker.walk(preAst.statements, preAst);\n            }\n        }\n\n        export function walkCaseStatementChildren(preAst: CaseStatement, parent: AST, walker: IAstWalker): void {\n            if (preAst.expr) {\n                preAst.expr = walker.walk(preAst.expr, preAst);\n            }\n\n            if (preAst.body && walker.options.goNextSibling) {\n                preAst.body = <ASTList>walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkSwitchStatementChildren(preAst: SwitchStatement, parent: AST, walker: IAstWalker): void {\n            if (preAst.val) {\n                preAst.val = walker.walk(preAst.val, preAst);\n            }\n\n            if ((preAst.caseList) && walker.options.goNextSibling) {\n                preAst.caseList = <ASTList>walker.walk(preAst.caseList, preAst);\n            }\n        }\n\n        export function walkTryChildren(preAst: Try, parent: AST, walker: IAstWalker): void {\n            if (preAst.body) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkTryCatchChildren(preAst: TryCatch, parent: AST, walker: IAstWalker): void {\n            if (preAst.tryNode) {\n                preAst.tryNode = <Try>walker.walk(preAst.tryNode, preAst);\n            }\n\n            if ((preAst.catchNode) && walker.options.goNextSibling) {\n                preAst.catchNode = <Catch>walker.walk(preAst.catchNode, preAst);\n            }\n        }\n\n        export function walkTryFinallyChildren(preAst: TryFinally, parent: AST, walker: IAstWalker): void {\n            if (preAst.tryNode) {\n                preAst.tryNode = walker.walk(preAst.tryNode, preAst);\n            }\n\n            if (preAst.finallyNode && walker.options.goNextSibling) {\n                preAst.finallyNode = <Finally>walker.walk(preAst.finallyNode, preAst);\n            }\n        }\n\n        export function walkFinallyChildren(preAst: Finally, parent: AST, walker: IAstWalker): void {\n            if (preAst.body) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkCatchChildren(preAst: Catch, parent: AST, walker: IAstWalker): void {\n            if (preAst.param) {\n                preAst.param = <VarDecl>walker.walk(preAst.param, preAst);\n            }\n\n            if ((preAst.body) && walker.options.goNextSibling) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkRecordChildren(preAst: NamedDeclaration, parent: AST, walker: IAstWalker): void {\n            preAst.name = <Identifier>walker.walk(preAst.name, preAst);\n            if (walker.options.goNextSibling && preAst.members) {\n                preAst.members = <ASTList>walker.walk(preAst.members, preAst);\n            }\n\n        }\n\n        export function walkNamedTypeChildren(preAst: TypeDeclaration, parent: AST, walker: IAstWalker): void {\n            walkRecordChildren(preAst, parent, walker);\n        }\n",
v27664=v27665+'\n        export function walkClassDeclChildren(preAst: ClassDeclaration, parent: AST, walker: IAstWalker): void {\n            walkNamedTypeChildren(preAst, parent, walker);\n\n            if (walker.options.goNextSibling && preAst.extendsList) {\n                preAst.extendsList = <ASTList>walker.walk(preAst.extendsList, preAst);\n            }\n\n            if (walker.options.goNextSibling && preAst.implementsList) {\n                preAst.implementsList = <ASTList>walker.walk(preAst.implementsList, preAst);\n            }\n        }\n\n        export function walkScriptChildren(preAst: Script, parent: AST, walker: IAstWalker): void {\n            if (preAst.bod) {\n                preAst.bod = <ASTList>walker.walk(preAst.bod, preAst);\n            }\n        }\n\n        export function walkTypeDeclChildren(preAst: InterfaceDeclaration, parent: AST, walker: IAstWalker): void {\n            walkNamedTypeChildren(preAst, parent, walker);\n\n            // walked arguments as part of members\n            if (walker.options.goNextSibling && preAst.extendsList) {\n                preAst.extendsList = <ASTList>walker.walk(preAst.extendsList, preAst);\n            }\n\n            if (walker.options.goNextSibling && preAst.implementsList) {\n                preAst.implementsList = <ASTList>walker.walk(preAst.implementsList, preAst);\n            }\n        }\n\n        export function walkModuleDeclChildren(preAst: ModuleDeclaration, parent: AST, walker: IAstWalker): void {\n            walkRecordChildren(preAst, parent, walker);\n        }\n\n        export function walkImportDeclChildren(preAst: ImportDeclaration, parent: AST, walker: IAstWalker): void {\n            if (preAst.id) {\n                preAst.id = <Identifier>walker.walk(preAst.id, preAst);\n            }\n            if (preAst.alias) {\n                preAst.alias = walker.walk(preAst.alias, preAst);\n            }\n        }\n\n        export function walkWithStatementChildren(preAst: WithStatement, parent: AST, walker: IAstWalker): void {\n            if (preAst.expr) {\n                preAst.expr = walker.walk(preAst.expr, preAst);\n            }\n\n            if (preAst.body && walker.options.goNextSibling) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkLabelChildren(preAst: Label, parent: AST, walker: IAstWalker): void {\n            //TODO: Walk "id"?\n        }\n\n        export function walkLabeledStatementChildren(preAst: LabeledStatement, parent: AST, walker: IAstWalker): void {\n            preAst.labels = <ASTList>walker.walk(preAst.labels, preAst);\n            if (walker.options.goNextSibling) {\n                preAst.stmt = walker.walk(preAst.stmt, preAst);\n            }\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nmodule TypeScript {\n    class Base64Format {\n        static encodedValues = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\';\n        static encode(inValue: number) {\n            if (inValue < 64) {\n                return encodedValues.charAt(inValue);\n            }\n            throw TypeError(inValue + ": not a 64 based value");\n        }\n\n        static decodeChar(inChar: string) {\n            if (inChar.length === 1) {\n                return encodedValues.indexOf(inChar);\n            } else {\n                throw TypeError(\'"\' + inChar + \'" must have length 1\');\n            }\n        }\n    }\n\n    export class Base64VLQFormat {\n        static encode(inValue: number) {\n            // Add a new least significant bit that has the sign of the value.\n            // if negative number the least significant bit that gets added to the number has value 1\n            // else least significant bit value that gets added is 0\n            // eg. -1 changes to binary : 01 [1] => 3\n            //     +1 changes to binary : 01 [0] => 2\n            if (inValue < 0) {\n                inValue = ((-inValue) << 1) + 1;\n            }\n            else {\n                inValue = inValue << 1;\n            }\n\n            // Encode 5 bits at a time starting from least significant bits\n            var encodedStr = "";\n            do {\n                var currentDigit = inValue & 31; // 11111\n                inValue = inValue >> 5;\n                if (inValue > 0) {\n                    // There are still more digits to decode, set the msb (6th bit)\n                    currentDigit = currentDigit | 32; \n               ',
v27663=v27664+' }\n                encodedStr = encodedStr + Base64Format.encode(currentDigit);\n            } while (inValue > 0);\n\n            return encodedStr;\n        }\n\n        static decode(inString: string) {\n            var result = 0;\n            var negative = false;\n\n            var shift = 0;\n            for (var i = 0; i < inString.length; i++) {\n                var byte = Base64Format.decodeChar(inString[i]);\n                if (i === 0) {\n                    // Sign bit appears in the LSBit of the first value\n                    if ((byte & 1) === 1) {\n                        negative = true;\n                    }\n                    result = (byte >> 1) & 15; // 1111x\n                } else {\n                    result = result | ((byte & 31) << shift); // 11111\n                }\n\n                shift += (i == 0) ? 4 : 5;\n\n                if ((byte & 32) === 32) {\n                    // Continue\n                } else {\n                    return { value: negative ? -(result) : result, rest: inString.substr(i + 1) };\n                }\n            }\n\n            throw new Error(\'Base64 value "\' + inString + \'" finished with a continuation bit\');\n        }\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class Binder {\n        constructor(public checker: TypeChecker) { }\n        \n        public resolveBaseTypeLinks(typeLinks: TypeLink[], scope: SymbolScope) {\n            var extendsList: Type[] = null;\n            if (typeLinks) {\n                extendsList = new Type[];\n                for (var i = 0, len = typeLinks.length; i < len; i++) {\n                    extendsList[i] = this.checker.resolveBaseTypeLink(typeLinks[i], scope);\n                }\n            }\n            return extendsList;\n        }\n\n        public resolveBases(scope: SymbolScope, type: Type) {\n            type.extendsList = this.resolveBaseTypeLinks(type.extendsTypeLinks, scope);\n\n            var i = 0, len = type.extendsList.length;\n            var derivedIsClass = type.isClassInstance();\n            for (; i < len; i++) {\n                var baseIsClass = type.extendsList[i].isClassInstance();\n                if (type.extendsList[i] != this.checker.anyType) {\n                    var baseRef = type.extendsTypeLinks[i].ast;\n                    if (derivedIsClass) {\n                        if (!baseIsClass) {\n                            this.checker.errorReporter.simpleError(baseRef,\n                                                                     "A class may only extend other classes, " + type.extendsList[i].symbol.fullName() + " is not a class.");\n                        }\n                    }\n                    else {\n                        if (baseIsClass) {\n                            this.checker.errorReporter.simpleError(baseRef,\n                                                                     "An interface may only extend other interfaces, " + type.extendsList[i].symbol.fullName() + " is a class.");\n                        }\n                    }\n                }\n            }\n\n            type.implementsList = this.resolveBaseTypeLinks(type.implementsTypeLinks, scope);\n\n            if (type.implementsList) {\n                for (i = 0, len = type.implementsList.length; i < len; i++) {\n                    var iface = type.implementsList[i];\n                    var baseRef = type.implementsTypeLinks[i].ast;\n                    if (iface.isClassInstance()) {\n                        if (derivedIsClass) {\n                            this.checker.errorReporter.simpleError(baseRef,\n                                                                     "A class may only implement an interface; " + iface.symbol.fullName() + " is a class.");\n                        }\n                    }\n                }\n            }\n        }\n\n        public resolveSignatureGroup(signatureGroup: SignatureGroup, scope: SymbolScope, instanceType: Type) {\n            var supplyVar = !(signatureGroup.hasImplementation);\n            for (var i = 0, len = signatureGroup.signatures.length; i < len; i++) {\n                var signature = signatureGroup.signatures[i];\n                if (instanceType) {\n                    signature.returnType.type = instanceType;\n                }\n                else {\n                    this.checker.resolveTypeLink(scope, signature.returnType, supplyVar);\n               ',
v27662=v27663+' }\n                var paramLen = signature.parameters.length;\n                for (var j = 0; j < paramLen; j++) {\n                    this.bindSymbol(scope, signature.parameters[j]);\n                }\n                if (signature.hasVariableArgList) {\n                    // check that last parameter has an array type\n                    var lastParam = <ParameterSymbol>signature.parameters[paramLen - 1];\n                    lastParam.argsOffset = paramLen - 1;\n                    if (!lastParam.getType().isArray()) {\n                        this.checker.errorReporter.simpleErrorFromSym(lastParam,\n                                                                 "... parameter must have array type");\n                        lastParam.parameter.typeLink.type = this.checker.makeArrayType(lastParam.parameter.typeLink.type);\n                    }\n                }\n            }\n        }\n\n        public bindType(scope: SymbolScope, type: Type, instanceType: Type): void {\n            if (instanceType) {\n                this.bindType(scope, instanceType, null);\n            }\n            if (type.hasMembers()) {\n                var members = type.members;\n                var ambientMembers = type.ambientMembers;\n                var typeMembers = type.getAllEnclosedTypes(); // REVIEW: Should only be getting exported types?\n                var ambientTypeMembers = type.getAllAmbientEnclosedTypes(); // REVIEW: Should only be getting exported types?\n                var memberScope = new SymbolTableScope(members, ambientMembers, typeMembers, ambientTypeMembers, type.symbol);\n                var agg = new SymbolAggregateScope(type.symbol);\n                var prevCurrentModDecl = this.checker.currentModDecl;\n                var prevBindStatus = this.checker.inBind;\n                agg.addParentScope(memberScope);\n                agg.addParentScope(scope);\n                if (type.isModuleType()) {\n                    this.checker.currentModDecl = <ModuleDeclaration>type.symbol.declAST;\n                    this.checker.inBind = true;\n                }\n                if (members) {\n                    this.bind(agg, type.members.allMembers); // REVIEW: Should only be getting exported types?\n                }\n                if (typeMembers) {\n                    this.bind(agg, typeMembers.allMembers);\n                }\n                if (ambientMembers) {\n                    this.bind(agg, ambientMembers.allMembers);\n                }\n                if (ambientTypeMembers) {\n                    this.bind(agg, ambientTypeMembers.allMembers);\n                }\n                this.checker.currentModDecl = prevCurrentModDecl;\n                this.checker.inBind = prevBindStatus;\n            }\n            if (type.extendsTypeLinks) {\n                this.resolveBases(scope, type);\n            }\n            if (type.construct) {\n                this.resolveSignatureGroup(type.construct, scope, instanceType);\n            }\n            if (type.call) {\n                this.resolveSignatureGroup(type.call, scope, null);\n            }\n            if (type.index) {\n                this.resolveSignatureGroup(type.index, scope, null);\n            }\n            if (type.elementType) {\n                this.bindType(scope, type.elementType, null);\n            }\n        }\n\n        public bindSymbol(scope: SymbolScope, symbol: Symbol) {\n            if (!symbol.bound) {\n                var prevLocationInfo = this.checker.locationInfo;\n                if ((this.checker.units) && (symbol.unitIndex >= 0) && (symbol.unitIndex < this.checker.units.length)) {\n                    this.checker.locationInfo = this.checker.units[symbol.unitIndex];\n                }\n                switch (symbol.kind()) {\n                    case SymbolKind.Type:\n\n                        if (symbol.flags & SymbolFlags.Bound) {\n                            break;\n                        }\n\n                        var typeSymbol = <TypeSymbol>symbol;\n                        typeSymbol.flags |= SymbolFlags.Bound;\n\n                        // Since type collection happens out of order, a dynamic module referenced by an import statement\n                        // may not yet be in scope when the import symbol is created.  In that case, we need to search\n                        // out the module symbol now\n                        // Note that we\'ll also want to do this in resolveTypeMembers, in case the symbol is set outside the\n                        // context of a given module  (E.g., an outer import statement)\n                        if (typeSymbol.aliasLink && !typeSymbol.type && typeSymbol.aliasLink.alias.nodeType == NodeType.Name) {\n                            var modPath = (<Identifier>typeSymbol.aliasLink.alias).text;\n                            var modSym = this.checker.findSymbolForDynamicModule(modPath, this.checker.locationInfo.filename, (id) => scope.find(id, false, true));\n                            if (modSym) {\n                                typeSymb',
v27661=v27662+'ol.type = modSym.getType();\n                            }\n                        }\n\n                        if (typeSymbol.type && typeSymbol.type != this.checker.gloModType) {\n                            this.bindType(scope, typeSymbol.type, typeSymbol.instanceType);\n\n                            // bind expansions on the parent type symbol\n                            if (typeSymbol.type.isModuleType()) {\n                                for (var i = 0; i < typeSymbol.expansions.length; i++) {\n                                    this.bindType(scope, typeSymbol.expansions[i], typeSymbol.instanceType);\n                                }\n                            }\n                        }\n                        break;\n                    case SymbolKind.Field:\n                        this.checker.resolveTypeLink(scope, (<FieldSymbol>symbol).field.typeLink,\n                                                false);\n                        break;\n                    case SymbolKind.Parameter:\n                        this.checker.resolveTypeLink(scope,\n                                                (<ParameterSymbol>symbol).parameter.typeLink,\n                                                true);\n                        break;\n                }\n                this.checker.locationInfo = prevLocationInfo;\n            }\n            symbol.bound = true;\n        }\n\n        public bind(scope: SymbolScope, table: IHashTable) {\n            table.map(\n                (key, sym, binder) => {\n                    binder.bindSymbol(scope, sym);\n                },\n                this);\n        }\n    }\n\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class DeclFileWriter {\n        public onNewLine = true;\n        constructor(private declFile: ITextWriter) {\n        }\n\n        public Write(s: string) {\n            this.declFile.Write(s);\n            this.onNewLine = false;\n        }\n\n        public WriteLine(s: string) {\n            this.declFile.WriteLine(s);\n            this.onNewLine = true;\n        }\n\n        public Close() {\n            this.declFile.Close();\n        }\n    }\n\n    export class DeclarationEmitter implements AstWalkerWithDetailCallback.AstWalkerDetailCallback {\n        private declFile: DeclFileWriter = null;\n        private indenter = new Indenter();\n        private declarationContainerStack: AST[] = [];\n        private isDottedModuleName: bool[] = [];\n        private dottedModuleEmit: string;\n        private ignoreCallbackAst: AST = null;\n        private singleDeclFile: DeclFileWriter = null;\n        private varListCount: number = 0;\n\n        private getAstDeclarationContainer() {\n            return this.declarationContainerStack[this.declarationContainerStack.length - 1];\n        }\n\n        private emitDottedModuleName() {\n            return (this.isDottedModuleName.length == 0) ? false : this.isDottedModuleName[this.isDottedModuleName.length - 1];\n        }\n\n        constructor (public checker: TypeChecker, public emitOptions: EmitOptions, public errorReporter: ErrorReporter) {\n        }\n\n        public setDeclarationFile(file: ITextWriter) {\n            this.declFile = new DeclFileWriter(file);\n        }\n\n        public Close() {\n            try {\n                // Closing files could result in exceptions, report them if they occur\n                this.declFile.Close();\n            } catch (ex) {\n                this.errorReporter.emitterError(null, ex.message);\n            }\n        }\n\n        public emitDeclarations(script: TypeScript.Script): void {\n            AstWalkerWithDetailCallback.walk(script, this);\n        }\n\n        private getIndentString(declIndent? = false) {\n            if (this.emitOptions.minWhitespace) {\n                return "";\n            }\n            else {\n                return this.indenter.getIndent();\n            }\n        }\n\n        private emitIndent() {\n            this.declFile.Write(this.getIndentString());\n        }\n\n        private canEmitSignature(declFlags: DeclFlags, canEmitGlobalAmbientDecl?: bool = true, useDeclarationContainerTop?: bool = true) {\n            var container: AST;\n            if (useDeclarationContainerTop) {\n                container = this.getAstDeclarationContainer();\n            } else {\n                container = this.declarationContainerStack[this.declarationContainerStack.length - 2];\n            }\n',
v27660=v27661+'\n            if (container.nodeType == NodeType.ModuleDeclaration && !hasFlag(declFlags, DeclFlags.Exported)) {\n                return false;\n            }\n\n            if (!canEmitGlobalAmbientDecl && container.nodeType == NodeType.Script && hasFlag(declFlags, DeclFlags.Ambient)) {\n                return false;\n            }\n\n            return true;\n        }\n\n        private canEmitPrePostAstSignature(declFlags: DeclFlags, astWithPrePostCallback: AST, preCallback: bool) {\n            if (this.ignoreCallbackAst) {\n                CompilerDiagnostics.assert(this.ignoreCallbackAst != astWithPrePostCallback, "Ignore Callback AST mismatch");\n                this.ignoreCallbackAst = null;\n                return false;\n            } else if (preCallback &&\n                !this.canEmitSignature(declFlags, true, preCallback)) {\n                this.ignoreCallbackAst = astWithPrePostCallback;\n                return false;\n            }\n\n            return true;\n        }\n\n        private getDeclFlagsString(declFlags: DeclFlags, typeString: string) {\n            var result = this.getIndentString();\n\n            // Accessor strings\n            var accessorString = "";\n            if (hasFlag(declFlags, DeclFlags.GetAccessor)) {\n                accessorString = "get ";\n            }\n            else if (hasFlag(declFlags, DeclFlags.SetAccessor)) {\n                accessorString = "set ";\n            }\n\n            // Emit export only for global export statements. The container for this would be dynamic module which is whole file\n            var container = this.getAstDeclarationContainer();\n            if (container.nodeType == NodeType.ModuleDeclaration &&\n                hasFlag((<ModuleDeclaration>container).modFlags, ModuleFlags.IsWholeFile) &&\n                hasFlag(declFlags, DeclFlags.Exported)) {\n                result += "export ";\n            }\n\n            // Static/public/private/global declare\n            if (hasFlag(declFlags, DeclFlags.LocalStatic) || hasFlag(declFlags, DeclFlags.Static)) {\n                result += "static " + accessorString;\n            }\n            else {\n                if (hasFlag(declFlags, DeclFlags.Private)) {\n                    result += "private " + accessorString;\n                }\n                else if (hasFlag(declFlags, DeclFlags.Public)) {\n                    result += "public " + accessorString;\n                }\n                else {\n                    if (accessorString == "") {\n                        result += typeString + " ";\n                    } else {\n                        result += accessorString;\n                    }\n                }\n            }\n\n            return result;\n        }\n\n        private emitDeclFlags(declFlags: DeclFlags, typeString: string) {\n            this.declFile.Write(this.getDeclFlagsString(declFlags, typeString));\n        }\n\n        private canEmitTypeAnnotationSignature(declFlag: DeclFlags = DeclFlags.None) {\n            // Private declaration, shouldnt emit type any time.\n            return !hasFlag(declFlag, DeclFlags.Private);\n        }\n\n        private pushDeclarationContainer(ast: AST) {\n            this.declarationContainerStack.push(ast);\n        }\n\n        private popDeclarationContainer(ast: AST) {\n            CompilerDiagnostics.assert(ast != this.getAstDeclarationContainer(), \'Declaration container mismatch\');\n            this.declarationContainerStack.pop();\n        }\n\n        private emitTypeNamesMember(memberName: MemberName, emitIndent? : bool = false) {\n            if (memberName.prefix == "{ ") {\n                if (emitIndent) {\n                    this.emitIndent();\n                }\n                this.declFile.WriteLine("{");\n                this.indenter.increaseIndent();\n                emitIndent = true;\n            } else if (memberName.prefix != "") {\n                if (emitIndent) {\n                    this.emitIndent();\n                }\n                this.declFile.Write(memberName.prefix);\n                emitIndent = false;\n            }\n\n            if (memberName.isString()) {\n                if (emitIndent) {\n                    this.emitIndent();\n                }\n                this.declFile.Write((<MemberNameString>memberName).text);\n            } else {\n                var ar = <MemberNameArray>memberName;\n                for (var index = 0; index < ar.entries.length; index++) {\n                    this.emitTypeNamesMember(ar.entries[index], emitIndent);\n                    if (ar.delim == "; ") {\n                        this.declFile.WriteLine(";");\n                    }\n                }\n            }\n\n            if (memberName.suffix == "}") {\n                this.indenter.decreaseIndent();\n                this.emitIndent();\n                this.declFile.Write(memberName.suffix);\n            } else {\n                this.declFile.Write(memberName.suffix);\n            }\n        }\n\n        private emitTypeSignature(type: Type) {\n            var containingScope: SymbolScope = null',
v27659=v27660+';\n            var declarationContainerAst = this.getAstDeclarationContainer();\n            switch (declarationContainerAst.nodeType) {\n                case NodeType.ModuleDeclaration:\n                case NodeType.InterfaceDeclaration:\n                case NodeType.FuncDecl:\n                    if (declarationContainerAst.type) {\n                        containingScope = declarationContainerAst.type.containedScope;\n                    }\n                    break;\n\n                case NodeType.Script:\n                    var script = <Script>declarationContainerAst;\n                    if (script.bod) {\n                        containingScope = script.bod.enclosingScope;\n                    }\n                    break;\n\n                case NodeType.ClassDeclaration:\n                    if (declarationContainerAst.type) {\n                        containingScope = declarationContainerAst.type.instanceType.containedScope;\n                    }\n                    break;\n\n                default:\n                    CompilerDiagnostics.debugPrint("Unknown containing scope");\n            }\n\n            var typeNameMembers = type.getScopedTypeNameEx(containingScope);\n            this.emitTypeNamesMember(typeNameMembers);\n        }\n\n        private emitComment(comment: Comment) {\n            var text = comment.getText();\n            if (this.declFile.onNewLine) {\n                this.emitIndent();\n            } else if (!comment.isBlockComment) {\n                this.declFile.WriteLine("");\n                this.emitIndent();\n            }\n            \n            this.declFile.Write(text[0]);\n\n            for (var i = 1; i < text.length; i++) {\n                this.declFile.WriteLine("");\n                this.emitIndent();\n                this.declFile.Write(text[i]);\n            }\n\n            if (comment.endsLine || !comment.isBlockComment) {\n                this.declFile.WriteLine("");\n            } else {\n                this.declFile.Write(" ");\n            }\n        }\n\n        private emitDeclarationComments(ast: AST, endLine?: bool);\n        private emitDeclarationComments(symbol: Symbol, endLine?: bool);\n        private emitDeclarationComments(astOrSymbol, endLine = true) {\n            if (!this.emitOptions.emitComments) {\n                return;\n            }\n\n            var declComments = <Comment[]>astOrSymbol.getDocComments();\n            if (declComments.length > 0) {\n                for (var i = 0; i < declComments.length; i++) {\n                    this.emitComment(declComments[i]);\n                }\n\n                if (endLine) {\n                    if (!this.declFile.onNewLine) {\n                        this.declFile.WriteLine("");\n                    }\n                } else {\n                    if (this.declFile.onNewLine) {\n                        this.emitIndent();\n                    }\n                }\n            }\n        }\n\n        public VarDeclCallback(pre: bool, varDecl: VarDecl): bool {\n            if (pre && this.canEmitSignature(ToDeclFlags(varDecl.varFlags), false)) {\n                var interfaceMember = (this.getAstDeclarationContainer().nodeType == NodeType.InterfaceDeclaration);\n                this.emitDeclarationComments(varDecl);\n                if (!interfaceMember) {\n                    // If it is var list of form var a, b, c = emit it only if count > 0 - which will be when emitting first var\n                    // If it is var list of form  var a = varList count will be 0\n                    if (this.varListCount >= 0) {\n                        this.emitDeclFlags(ToDeclFlags(varDecl.varFlags), "var");\n                        this.varListCount = -this.varListCount;\n                    }\n                    this.declFile.Write(varDecl.id.text);\n                } else {\n                    this.emitIndent();\n                    this.declFile.Write(varDecl.id.text);\n                    if (hasFlag(varDecl.id.flags, ASTFlags.OptionalName)) {\n                        this.declFile.Write("?");\n                    }\n                }\n\n                var type: Type = null;\n                if (varDecl.typeExpr && varDecl.typeExpr.type) {\n                    type = varDecl.typeExpr.type;\n                }\n                else if (varDecl.sym) {\n                    type = (<FieldSymbol>varDecl.sym).getType();\n                    // Dont emit inferred any\n                    if (type == this.checker.anyType) {\n                        type = null;\n                    }\n                }\n\n                if (type && this.canEmitTypeAnnotationSignature(ToDeclFlags(varDecl.varFlags))) {\n                    this.declFile.Write(": ");\n                    this.emitTypeSignature(type);\n                }\n               \n                // emitted one var decl\n                if (this.varListCount > 0) { this.varListCount--; } else if (this.varListCount < 0) { this.varListCount++; }\n\n                // Write ; or ,\n                if (this.varListCount < 0) {\n                    this.declF',
v27658=v27659+'ile.Write(", ");\n                } else {\n                    this.declFile.WriteLine(";");\n                }\n            }\n            return false;\n        }\n\n        public BlockCallback(pre: bool, block: Block): bool {\n            if (!block.isStatementBlock) {\n                if (pre) {\n                    this.varListCount = block.statements.members.length;\n                } else {\n                    this.varListCount = 0;\n                }\n                return true;\n            }\n            return false;\n        }\n\n        private emitArgDecl(argDecl: ArgDecl, funcDecl: FuncDecl) {\n            this.emitDeclarationComments(argDecl, false);\n            this.declFile.Write(argDecl.id.text);\n            if (argDecl.isOptionalArg()) {\n                this.declFile.Write("?");\n            }\n            if ((argDecl.typeExpr || argDecl.type != this.checker.anyType) &&\n                this.canEmitTypeAnnotationSignature(ToDeclFlags(funcDecl.fncFlags))) {\n                this.declFile.Write(": ");\n                this.emitTypeSignature(argDecl.type);\n            }\n        }\n\n        public FuncDeclCallback(pre: bool, funcDecl: FuncDecl): bool {\n            if (!pre) {\n                return false;\n            }\n\n            if (funcDecl.isAccessor()) {\n                return this.emitPropertyAccessorSignature(funcDecl);\n            }\n\n            var isInterfaceMember = (this.getAstDeclarationContainer().nodeType == NodeType.InterfaceDeclaration);\n            if (funcDecl.bod) {\n                if (funcDecl.isConstructor) {\n                    if (funcDecl.type.construct && funcDecl.type.construct.signatures.length > 1) {\n                        return false;\n                    }\n                } else {\n                    if (funcDecl.type.call && funcDecl.type.call.signatures.length > 1) {\n                        // This means its implementation of overload signature. do not emit\n                        return false;\n                    }\n                }\n            } else if (!isInterfaceMember && hasFlag(funcDecl.fncFlags, FncFlags.Private) && funcDecl.type.call && funcDecl.type.call.signatures.length > 1) {\n                // Print only first overload of private function\n                var signatures = funcDecl.type.call.signatures;\n                var firstSignature = signatures[0].declAST;\n                if (firstSignature.bod) {\n                    // Its a implementation, use next one\n                    firstSignature = signatures[1].declAST;\n                }\n\n                if (firstSignature != funcDecl) {\n                    return false;\n                }\n            }\n\n            if (!this.canEmitSignature(ToDeclFlags(funcDecl.fncFlags), false)) {\n                return false;\n            }\n\n            this.emitDeclarationComments(funcDecl);\n            if (funcDecl.isConstructor) {\n                this.emitIndent();\n                this.declFile.Write("constructor");\n            }\n            else {\n                var id = funcDecl.getNameText();\n                if (!isInterfaceMember) {\n                    this.emitDeclFlags(ToDeclFlags(funcDecl.fncFlags), "function");\n                    this.declFile.Write(id);\n                } else {\n                    this.emitIndent();\n                    if (funcDecl.isConstructMember()) {\n                        this.declFile.Write("new");\n                    } else if (!funcDecl.isCallMember() && !funcDecl.isIndexerMember()) {\n                        this.declFile.Write(id);\n                        if (hasFlag(funcDecl.name.flags, ASTFlags.OptionalName)) {\n                            this.declFile.Write("? ");\n                        }\n                    }\n                }\n            }\n\n            if (!funcDecl.isIndexerMember()) {\n                this.declFile.Write("(");\n            } else {\n                this.declFile.Write("[");\n            }\n\n            this.indenter.increaseIndent();\n\n            if (funcDecl.arguments) {\n                var argsLen = funcDecl.arguments.members.length;\n                if (funcDecl.variableArgList) {\n                    argsLen--;\n                }\n                for (var i = 0; i < argsLen; i++) {\n                    var argDecl = <ArgDecl>funcDecl.arguments.members[i];\n                    this.emitArgDecl(argDecl, funcDecl);\n                    if (i < (argsLen - 1)) {\n                        this.declFile.Write(", ");\n                    }\n                }\n            }\n\n            if (funcDecl.variableArgList) {\n                var lastArg = <ArgDecl>funcDecl.arguments.members[funcDecl.arguments.members.length - 1];\n                if (funcDecl.arguments.members.length > 1) {\n                    this.declFile.Write(", ...");\n                }\n                else {\n                    this.declFile.Write("...");\n                }\n                this.emitArgDecl(lastArg, funcDecl);\n            }\n\n            this.indenter.decreaseIndent();\n\n            if (!funcDecl.isIndexerMember(',
v27657=v27658+')) {\n                this.declFile.Write(")");\n            } else {\n                this.declFile.Write("]");\n            }\n\n            if (!funcDecl.isConstructor &&\n                (funcDecl.returnTypeAnnotation || funcDecl.signature.returnType.type != this.checker.anyType) &&\n                this.canEmitTypeAnnotationSignature(ToDeclFlags(funcDecl.fncFlags))) {\n                this.declFile.Write(": ");\n                this.emitTypeSignature(funcDecl.signature.returnType.type);\n            }\n\n            this.declFile.WriteLine(";");\n\n            return false;\n        }\n\n        private emitBaseList(bases: ASTList, qual: string) {\n            if (bases && (bases.members.length > 0)) {\n                this.declFile.Write(" " + qual + " ");\n                var basesLen = bases.members.length;\n                for (var i = 0; i < basesLen; i++) {\n                    var baseExpr = bases.members[i];\n                    var baseSymbol = baseExpr.type.symbol;\n                    var baseType = baseExpr.type;\n                    if (i > 0) {\n                        this.declFile.Write(", ");\n                    }\n                    this.emitTypeSignature(baseType);\n                }\n            }\n        }\n\n        private emitPropertyAccessorSignature(funcDecl: FuncDecl) {\n            var accessorSymbol = <FieldSymbol>funcDecl.accessorSymbol;\n            if (accessorSymbol.getter && accessorSymbol.getter.declAST != funcDecl) {\n                // Setter is being used to emit the type info. \n                return false;\n            }\n\n            this.emitDeclarationComments(accessorSymbol);\n            this.emitDeclFlags(ToDeclFlags(accessorSymbol.flags), "var");\n            this.declFile.Write(funcDecl.name.text);\n            var propertyType = accessorSymbol.getType();\n            if (this.canEmitTypeAnnotationSignature(ToDeclFlags(accessorSymbol.flags))) {\n                this.declFile.Write(" : ");\n                this.emitTypeSignature(propertyType);\n            }\n            this.declFile.WriteLine(";");\n\n            return false;\n        }\n\n        private emitClassMembersFromConstructorDefinition(funcDecl: FuncDecl) {\n            if (funcDecl.arguments) {\n                var argsLen = funcDecl.arguments.members.length; if (funcDecl.variableArgList) { argsLen--; }\n\n                for (var i = 0; i < argsLen; i++) {\n                    var argDecl = <ArgDecl>funcDecl.arguments.members[i];\n                    if (hasFlag(argDecl.varFlags, VarFlags.Property)) {\n                        this.emitDeclarationComments(argDecl);\n                        this.emitDeclFlags(ToDeclFlags(argDecl.varFlags), "var");\n                        this.declFile.Write(argDecl.id.text);\n\n                        if (argDecl.typeExpr && this.canEmitTypeAnnotationSignature(ToDeclFlags(argDecl.varFlags))) {\n                            this.declFile.Write(": ");\n                            this.emitTypeSignature(argDecl.type);\n                        }\n                        this.declFile.WriteLine(";");\n                    }\n                }\n            }\n        }\n\n        public ClassDeclarationCallback(pre: bool, classDecl: ClassDeclaration): bool {\n            if (!this.canEmitPrePostAstSignature(ToDeclFlags(classDecl.varFlags), classDecl, pre)) {\n                return false;\n            }\n\n            if (pre) {\n                var className = classDecl.name.text;\n                this.emitDeclarationComments(classDecl);\n                this.emitDeclFlags(ToDeclFlags(classDecl.varFlags), "class");\n                this.declFile.Write(className);\n                this.emitBaseList(classDecl.extendsList, "extends");\n                this.emitBaseList(classDecl.implementsList, "implements");\n                this.declFile.WriteLine(" {");\n\n                this.pushDeclarationContainer(classDecl);\n                this.indenter.increaseIndent();\n                if (classDecl.constructorDecl) {\n                    this.emitClassMembersFromConstructorDefinition(classDecl.constructorDecl);\n                }\n            } else {\n                this.indenter.decreaseIndent();\n                this.popDeclarationContainer(classDecl);\n\n                this.emitIndent();\n                this.declFile.WriteLine("}");\n            }\n\n            return true;\n        }\n\n        public InterfaceDeclarationCallback(pre: bool, interfaceDecl: InterfaceDeclaration): bool {\n            if (!this.canEmitPrePostAstSignature(ToDeclFlags(interfaceDecl.varFlags), interfaceDecl, pre)) {\n                return false;\n            }\n\n            if (pre) {\n                var interfaceName = interfaceDecl.name.text;\n                this.emitDeclarationComments(interfaceDecl);\n                this.emitDeclFlags(ToDeclFlags(interfaceDecl.varFlags), "interface");\n                this.declFile.Write(interfaceName);\n                this.emitBaseList(interfaceDecl.extendsList, "extends");\n                this.declFile.WriteLine(" {");\n\n                this.indenter',
v27656=v27657+'.increaseIndent();\n                this.pushDeclarationContainer(interfaceDecl);\n            } else {\n                this.indenter.decreaseIndent();\n                this.popDeclarationContainer(interfaceDecl);\n\n                this.emitIndent();\n                this.declFile.WriteLine("}");\n            }\n\n            return true;\n        }\n\n        public ImportDeclarationCallback(pre: bool, importDecl: ImportDeclaration): bool {\n            if (pre) {\n                if ((<Script>this.declarationContainerStack[0]).isExternallyVisibleSymbol(importDecl.id.sym)) {\n                    this.emitDeclarationComments(importDecl);\n                    this.emitIndent();\n                    this.declFile.Write("import ");\n\n                    this.declFile.Write(importDecl.id.text + " = ");\n                    if (importDecl.isDynamicImport) {\n                        this.declFile.WriteLine("module (" + importDecl.getAliasName() + ");");\n                    } else {\n                        this.declFile.WriteLine(importDecl.getAliasName() + ";");\n                    }\n                }\n            }\n\n            return false;\n        }\n\n        private emitEnumSignature(moduleDecl: ModuleDeclaration) {\n            if (!this.canEmitSignature(ToDeclFlags(moduleDecl.modFlags))) {\n                return false;\n            }\n\n            this.emitDeclarationComments(moduleDecl);\n            this.emitDeclFlags(ToDeclFlags(moduleDecl.modFlags), "enum");\n            this.declFile.WriteLine(moduleDecl.name.text + " {");\n\n            this.indenter.increaseIndent();\n            var membersLen = moduleDecl.members.members.length;\n            for (var j = 1; j < membersLen; j++) {\n                var memberDecl: AST = moduleDecl.members.members[j];\n                if (memberDecl.nodeType == NodeType.VarDecl) {\n                    this.emitDeclarationComments(memberDecl);\n                    this.emitIndent();\n                    this.declFile.WriteLine((<VarDecl>memberDecl).id.text + ",");\n                } else {\n                    CompilerDiagnostics.assert(memberDecl.nodeType != NodeType.Asg, "We want to catch this");\n                }\n            }\n            this.indenter.decreaseIndent();\n\n            this.emitIndent();\n            this.declFile.WriteLine("}");\n\n            return false;\n        }\n\n        public ModuleDeclarationCallback(pre: bool, moduleDecl: ModuleDeclaration): bool {\n            if (hasFlag(moduleDecl.modFlags, ModuleFlags.IsWholeFile)) {\n                // This is dynamic modules and we are going to outputing single file, \n                // we need to change the declFile because dynamic modules are always emitted to their corresponding .d.ts\n                if (hasFlag(moduleDecl.modFlags, ModuleFlags.IsDynamic)) {\n                    if (pre) {\n                        if (!this.emitOptions.outputMany) {\n                            this.singleDeclFile = this.declFile;\n                            CompilerDiagnostics.assert(this.indenter.indentAmt == 0, "Indent has to be 0 when outputing new file");\n                            // Create new file\n                            var declareFileName = this.emitOptions.mapOutputFileName(stripQuotes(moduleDecl.name.sym.name), TypeScriptCompiler.mapToDTSFileName);\n                            var useUTF8InOutputfile = moduleDecl.containsUnicodeChar || (this.emitOptions.emitComments && moduleDecl.containsUnicodeCharInComment);\n                            try {\n                                // Creating files can cause exceptions, report them.   \n                                this.declFile = new DeclFileWriter(this.emitOptions.ioHost.createFile(declareFileName, useUTF8InOutputfile));\n                            } catch (ex) {\n                                this.errorReporter.emitterError(null, ex.message);\n                            }\n                        }\n                        this.pushDeclarationContainer(moduleDecl);\n                    } else {\n                        if (!this.emitOptions.outputMany) {\n                            CompilerDiagnostics.assert(this.singleDeclFile != this.declFile, "singleDeclFile cannot be null as we are going to revert back to it");\n                            CompilerDiagnostics.assert(this.indenter.indentAmt == 0, "Indent has to be 0 when outputing new file");\n                            try {\n                                // Closing files could result in exceptions, report them if they occur\n                                this.declFile.Close();\n                            } catch (ex) {\n                                this.errorReporter.emitterError(null, ex.message);\n                            }\n                            this.declFile = this.singleDeclFile;\n                        }\n                        this.popDeclarationContainer(moduleDecl);\n                    }\n                }\n\n                return true;\n            }\n\n            if (moduleDecl.isEnum()) {\n                if (pre) {\n           ',
v27655=v27656+'         this.emitEnumSignature(moduleDecl);\n                }\n                return false;\n            }\n\n            if (!this.canEmitPrePostAstSignature(ToDeclFlags(moduleDecl.modFlags), moduleDecl, pre)) {\n                return false;\n            }\n\n            if (pre) {\n                if (this.emitDottedModuleName()) {\n                    this.dottedModuleEmit += ".";\n                } else {\n                    this.dottedModuleEmit = this.getDeclFlagsString(ToDeclFlags(moduleDecl.modFlags), "module");\n                }\n                this.dottedModuleEmit += moduleDecl.name.text;\n\n                var isCurrentModuleDotted = (moduleDecl.members.members.length == 1 &&\n                    moduleDecl.members.members[0].nodeType == NodeType.ModuleDeclaration &&\n                    !(<ModuleDeclaration>moduleDecl.members.members[0]).isEnum() &&\n                    hasFlag((<ModuleDeclaration>moduleDecl.members.members[0]).modFlags, ModuleFlags.Exported));\n\n                // Module is dotted only if it does not have doc comments for it\n                var moduleDeclComments = moduleDecl.getDocComments();\n                isCurrentModuleDotted = isCurrentModuleDotted && (moduleDeclComments == null || moduleDeclComments.length == 0);\n\n                this.isDottedModuleName.push(isCurrentModuleDotted);\n                this.pushDeclarationContainer(moduleDecl);\n\n                if (!isCurrentModuleDotted) {\n                    this.emitDeclarationComments(moduleDecl);\n                    this.declFile.Write(this.dottedModuleEmit);\n                    this.declFile.WriteLine(" {");\n                    this.indenter.increaseIndent();\n                }\n            } else {\n                if (!this.emitDottedModuleName()) {\n                    this.indenter.decreaseIndent();\n                    this.emitIndent();\n                    this.declFile.WriteLine("}");\n                }\n                this.popDeclarationContainer(moduleDecl);\n                this.isDottedModuleName.pop();\n            }\n\n            return true;\n        }\n\n        public ScriptCallback(pre: bool, script: Script): bool {\n            if (pre) {\n                if (this.emitOptions.outputMany) {\n                    for (var i = 0; i < script.referencedFiles.length; i++) {\n                        var referencePath = script.referencedFiles[i].path;\n                        var declareFileName: string;\n                        if (isRooted(referencePath)) {\n                            declareFileName = this.emitOptions.mapOutputFileName(referencePath, TypeScriptCompiler.mapToDTSFileName)\n                        } else {\n                            declareFileName = getDeclareFilePath(script.referencedFiles[i].path);\n                        }\n                        this.declFile.WriteLine(\'/// <reference path="\' + declareFileName + \'" />\');\n                    }\n                }\n                this.pushDeclarationContainer(script);\n            }\n            else {\n                this.popDeclarationContainer(script);\n            }\n            return true;\n        }\n\n        public DefaultCallback(pre: bool, ast: AST): bool {\n            return !hasFlag(ast.flags, ASTFlags.IsStatement);\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export module CompilerDiagnostics {\n        export var debug = false;\n        export interface IDiagnosticWriter {\n            Alert(output: string): void;\n        }\n\n        export var diagnosticWriter: IDiagnosticWriter = null;\n\n        export var analysisPass: number = 0;\n\n        export function Alert(output: string) {\n            if (diagnosticWriter) {\n                diagnosticWriter.Alert(output);\n            }\n        }\n\n        export function debugPrint(s: string) {\n            if (debug) {\n                Alert(s);\n            }\n        }\n\n        export function assert(condition: bool, s: string) {\n            if (debug) {\n                if (!condition) {\n                    Alert(s);\n                }\n            }\n        }\n\n    }\n\n    export interface ILogger {\n        information(): bool;\n        debug(): bool;\n        warning(): bool;\n        error(): bool;\n        fatal(): bool;\n        log(s: string): void;\n    }\n\n    export class NullLogger implements ILogger {\n        public information(): bool { return false; }\n        public debug(): bool { r',
v27654=v27655+'eturn false; }\n        public warning(): bool { return false; }\n        public error(): bool { return false; }\n        public fatal(): bool { return false; }\n        public log(s: string): void {\n        }\n    }\n\n    export class LoggerAdapter implements ILogger {\n        private _information: bool;\n        private _debug: bool;\n        private _warning: bool;\n        private _error: bool;\n        private _fatal: bool;\n\n        constructor (public logger: ILogger) { \n            this._information = this.logger.information();\n            this._debug = this.logger.debug();\n            this._warning = this.logger.warning();\n            this._error = this.logger.error();\n            this._fatal = this.logger.fatal();\n        }\n\n\n        public information(): bool { return this._information; }\n        public debug(): bool { return this._debug; }\n        public warning(): bool { return this._warning; }\n        public error(): bool { return this._error; }\n        public fatal(): bool { return this._fatal; }\n        public log(s: string): void {\n            this.logger.log(s);\n        }\n    }\n\n    export class BufferedLogger implements ILogger {\n        public logContents = [];\n\n        public information(): bool { return false; }\n        public debug(): bool { return false; }\n        public warning(): bool { return false; }\n        public error(): bool { return false; }\n        public fatal(): bool { return false; }\n        public log(s: string): void {\n            this.logContents.push(s);\n        }\n    }\n\n    export function timeFunction(logger: ILogger, funcDescription: string, func: () =>any): any {\n        var start = +new Date();\n        var result = func();\n        var end = +new Date();\n        logger.log(funcDescription + " completed in " + (end - start) + " msec");\n        return result;\n    }\n\n    export function stringToLiteral(value: string, length: number): string {\n        var result = "";\n\n        var addChar = (index: number) => {\n            var ch = value.charCodeAt(index);\n            switch (ch) {\n                case 0x09: // tab\n                    result += "\\\\t";\n                    break;\n                case 0x0a: // line feed\n                    result += "\\\\n";\n                    break;\n                case 0x0b: // vertical tab\n                    result += "\\\\v";\n                    break;\n                case 0x0c: // form feed\n                    result += "\\\\f";\n                    break;\n                case 0x0d: // carriage return\n                    result += "\\\\r";\n                    break;\n                case 0x22:  // double quote\n                    result += "\\\\\\"";\n                    break;\n                case 0x27: // single quote\n                    result += "\\\\\\\'";\n                    break;\n                case 0x5c: // Backslash\n                    result += "\\\\";\n                    break;\n                default:\n                    result += value.charAt(index);\n            }\n        }\n\n        var tooLong = (value.length > length);\n        if (tooLong) {\n            var mid = length >> 1;\n            for (var i = 0; i < mid; i++) addChar(i);\n            result += "(...)";\n            for (var i = value.length - mid; i < value.length; i++) addChar(i);\n        }\n        else {\n            length = value.length;\n            for (var i = 0; i < length; i++) addChar(i);\n        }\n        return result;\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export enum EmitContainer {\n        Prog,\n        Module,\n        DynamicModule,\n        Class,\n        Constructor,\n        Function,\n        Args,\n        Interface,\n    }\n\n    export class EmitState {\n        public column: number;\n        public line: number;\n        public pretty: bool;\n        public inObjectLiteral: bool;\n        public container: EmitContainer;\n\n        constructor () {\n            this.column = 0;\n            this.line = 0;\n            this.pretty = false;\n            this.inObjectLiteral = false;\n            this.container = EmitContainer.Prog;\n        }\n    }\n\n    export class EmitOptions {\n        public minWhitespace: bool;\n        public propagateConstants: bool;\n        public emitComments: bool;\n        public outputOption: string;\n        public ioHost: EmitterIOHost = null;\n        public outputMany: bool = true;\n        public commonDirectoryPath',
v27653=v27654+' = "";\n\n        constructor(settings: CompilationSettings) {\n            this.minWhitespace = settings.minWhitespace;\n            this.propagateConstants = settings.propagateConstants;\n            this.emitComments = settings.emitComments;\n            this.outputOption = settings.outputOption;\n        }\n\n        public mapOutputFileName(fileName: string, extensionChanger: (fname: string, wholeFileNameReplaced: bool) => string) {\n            if (this.outputMany) {\n                var updatedFileName = fileName;\n                if (this.outputOption != "") {\n                    // Replace the common directory path with the option specified\n                    updatedFileName = fileName.replace(this.commonDirectoryPath, "");\n                    updatedFileName = this.outputOption + updatedFileName;\n                }\n                return extensionChanger(updatedFileName, false);\n            } else {\n                return extensionChanger(this.outputOption, true);\n            }\n        }\n    }\n\n    export class Indenter {\n        static indentStep : number = 4;\n        static indentStepString : string = "    ";\n        static indentStrings: string[] = [];\n        public indentAmt: number = 0;\n\n        public increaseIndent() {\n            this.indentAmt += Indenter.indentStep;\n        }\n\n        public decreaseIndent() {\n            this.indentAmt -= Indenter.indentStep;\n        }\n\n        public getIndent() {\n            var indentString = Indenter.indentStrings[this.indentAmt];\n            if (indentString === undefined) {\n                indentString = "";\n                for (var i = 0; i < this.indentAmt; i = i + Indenter.indentStep) {\n                    indentString += Indenter.indentStepString;\n                }\n                Indenter.indentStrings[this.indentAmt] = indentString;\n            }\n            return indentString;\n        }\n    }\n\n    export class Emitter {\n        public prologueEmitted = false;\n        public thisClassNode: TypeDeclaration = null;\n        public thisFnc: FuncDecl = null;\n        public moduleDeclList: ModuleDeclaration[] = [];\n        public moduleName = "";\n        public emitState = new EmitState();\n        public indenter = new Indenter();\n        public ambientModule = false;\n        public modAliasId: string = null;\n        public firstModAlias: string = null;\n        public allSourceMappers: SourceMapper[] = [];\n        public sourceMapper: SourceMapper = null;\n        public captureThisStmtString = "var _this = this;";\n        private varListCountStack: number[] = [0]; \n\n        constructor(public checker: TypeChecker, public emittingFileName: string, public outfile: ITextWriter, public emitOptions: EmitOptions, public errorReporter: ErrorReporter) {\n        }\n\n        public setSourceMappings(mapper: SourceMapper) {\n            this.allSourceMappers.push(mapper);\n            this.sourceMapper = mapper;\n        }\n\n        public writeToOutput(s: string) {\n            this.outfile.Write(s);\n            // TODO: check s for newline\n            this.emitState.column += s.length;\n        }\n\n        public writeToOutputTrimmable(s: string) {\n            if (this.emitOptions.minWhitespace) {\n                s = s.replace(/[\\s]*/g, \'\');\n            }\n            this.writeToOutput(s);\n        }\n\n        public writeLineToOutput(s: string) {\n            if (this.emitOptions.minWhitespace) {\n                this.writeToOutput(s);\n                var c = s.charCodeAt(s.length - 1);\n                if (!((c == LexCodeSpace) || (c == LexCodeSMC) || (c == LexCodeLBR))) {\n                    this.writeToOutput(\' \');\n                }\n            }\n            else {\n                this.outfile.WriteLine(s);\n                this.emitState.column = 0\n                this.emitState.line++;\n            }\n        }\n\n        public writeCaptureThisStatement(ast: AST) {\n            this.emitIndent();\n            this.recordSourceMappingStart(ast);\n            this.writeToOutput(this.captureThisStmtString);\n            this.recordSourceMappingEnd(ast);\n            this.writeLineToOutput("");\n        }\n\n        public setInVarBlock(count: number) {\n            this.varListCountStack[this.varListCountStack.length - 1] = count;\n        }\n\n        public setInObjectLiteral(val: bool): bool {\n            var temp = this.emitState.inObjectLiteral;\n            this.emitState.inObjectLiteral = val;\n            return temp;\n        }\n\n        public setContainer(c: number): number {\n            var temp = this.emitState.container;\n            this.emitState.container = c;\n            return temp;\n        }\n\n        private getIndentString() {\n            if (this.emitOptions.minWhitespace) {\n                return "";\n            }\n            else {\n                return this.indenter.getIndent();\n            }\n        }\n\n        public emitIndent() {\n            this.writeToOutput(this.getIndentString());\n        }\n\n        public emitCommentInPlace(comment: Comment) {\n            var tex',
v27652=v27653+'t = comment.getText();\n            var hadNewLine = false;\n\n            if (comment.isBlockComment) {\n                if (this.emitState.column == 0) {\n                    this.emitIndent();\n                }\n                this.recordSourceMappingStart(comment);\n                this.writeToOutput(text[0]);\n\n                if (text.length > 1 || comment.endsLine) {\n                    for (var i = 1; i < text.length; i++) {\n                        this.writeLineToOutput("");\n                        this.emitIndent();\n                        this.writeToOutput(text[i]);\n                    }\n                    this.recordSourceMappingEnd(comment);\n                    this.writeLineToOutput("");\n                    hadNewLine = true;\n                } else {\n                    this.recordSourceMappingEnd(comment);\n                }\n            }\n            else {\n                if (this.emitState.column == 0) {\n                    this.emitIndent();\n                }\n                this.recordSourceMappingStart(comment);\n                this.writeToOutput(text[0]);\n                this.recordSourceMappingEnd(comment);\n                this.writeLineToOutput("");\n                hadNewLine = true;\n            }\n\n            if (hadNewLine) {\n                this.emitIndent();\n            }\n            else {\n                this.writeToOutput(" ");\n            }\n        }\n\n        public emitParensAndCommentsInPlace(ast: AST, pre: bool) {\n            var comments = pre ? ast.preComments : ast.postComments;\n\n            // comments should be printed before the LParen, but after the RParen\n            if (ast.isParenthesized && !pre) {\n                this.writeToOutput(")");\n            }\n            if (this.emitOptions.emitComments && comments && comments.length != 0) {\n                for (var i = 0; i < comments.length; i++) {\n                    this.emitCommentInPlace(comments[i]);\n                }\n            }\n            if (ast.isParenthesized && pre) {\n                this.writeToOutput("(");\n            }\n        }\n\n        // TODO: emit accessor pattern\n        public emitObjectLiteral(content: ASTList) {\n            this.writeLineToOutput("{");\n            this.indenter.increaseIndent();\n            var inObjectLiteral = this.setInObjectLiteral(true);\n            this.emitJavascriptList(content, ",", TokenID.Comma, true, false, false);\n            this.setInObjectLiteral(inObjectLiteral);\n            this.indenter.decreaseIndent();\n            this.emitIndent();\n            this.writeToOutput("}");\n        }\n\n        public emitArrayLiteral(content: ASTList) {\n            this.writeToOutput("[");\n            if (content) {\n                this.writeLineToOutput("");\n                this.indenter.increaseIndent();\n                this.emitJavascriptList(content, ", ", TokenID.Comma, true, false, false);\n                this.indenter.decreaseIndent();\n                this.emitIndent();\n            }\n            this.writeToOutput("]");\n        }\n\n        public emitNew(target: AST, args: ASTList) {\n            this.writeToOutput("new ");\n            if (target.nodeType == NodeType.TypeRef) {\n                var typeRef = <TypeReference>target;\n                if (typeRef.arrayCount) {\n                    this.writeToOutput("Array()");\n                }\n                else {\n                    this.emitJavascript(typeRef.term, TokenID.Tilde, false);\n                    this.writeToOutput("()");\n                }\n            }\n            else {\n                this.emitJavascript(target, TokenID.Tilde, false);\n                this.recordSourceMappingStart(args);\n                this.writeToOutput("(");\n                this.emitJavascriptList(args, ", ", TokenID.Comma, false, false, false);\n                this.writeToOutput(")");\n                this.recordSourceMappingEnd(args);\n            }\n        }\n\n        public tryEmitConstant(dotExpr: BinaryExpression) {\n            if (!this.emitOptions.propagateConstants) {\n                return false;\n            }\n            var propertyName = <Identifier>dotExpr.operand2;\n            if (propertyName && propertyName.sym && propertyName.sym.isVariable()) {\n                if (hasFlag(propertyName.sym.flags, SymbolFlags.Constant)) {\n                    if (propertyName.sym.declAST) {\n                        var boundDecl = <BoundDecl>propertyName.sym.declAST;\n                        if (boundDecl.init && (boundDecl.init.nodeType == NodeType.NumberLit)) {\n                            var numLit = <NumberLiteral>boundDecl.init;\n                            this.writeToOutput(numLit.value.toString());\n                            var comment = " /* ";\n                            comment += propertyName.actualText;\n                            comment += " */ ";\n                            this.writeToOutput(comment);\n                            return true;\n                        }\n                    }\n                }\n            }\n            ret',
v27651=v27652+'urn false;\n        }\n\n        public emitCall(callNode: CallExpression, target: AST, args: ASTList) {\n            if (!this.emitSuperCall(callNode)) {\n                if (!hasFlag(callNode.flags, ASTFlags.ClassBaseConstructorCall)) {\n                    if (target.nodeType == NodeType.FuncDecl && !target.isParenthesized) {\n                        this.writeToOutput("(");\n                    }\n                    if (callNode.target.nodeType == NodeType.Super && this.emitState.container == EmitContainer.Constructor) {\n                        this.writeToOutput("_super.call");\n                    }\n                    else {\n                        this.emitJavascript(target, TokenID.OpenParen, false);\n                    }\n                    if (target.nodeType == NodeType.FuncDecl && !target.isParenthesized) {\n                        this.writeToOutput(")");\n                    }\n                    this.recordSourceMappingStart(args);\n                    this.writeToOutput("(");\n                    if (callNode.target.nodeType == NodeType.Super && this.emitState.container == EmitContainer.Constructor) {\n                        this.writeToOutput("this");\n                        if (args && args.members.length) {\n                            this.writeToOutput(", ");\n                        }\n                    }\n                    this.emitJavascriptList(args, ", ", TokenID.Comma, false, false, false);\n                    this.writeToOutput(")");\n                    this.recordSourceMappingEnd(args);\n                }\n                else {\n                    this.indenter.decreaseIndent();\n                    this.indenter.decreaseIndent();\n                    var constructorCall = new ASTList();\n                    constructorCall.members[0] = callNode;\n                    this.emitConstructorCalls(constructorCall, this.thisClassNode);\n                    this.indenter.increaseIndent();\n                    this.indenter.increaseIndent();\n                }\n            }\n        }\n\n        public emitConstructorCalls(bases: ASTList, classDecl: TypeDeclaration) {\n            if (bases == null) {\n                return;\n            }\n            var basesLen = bases.members.length;\n            this.recordSourceMappingStart(classDecl);\n            for (var i = 0; i < basesLen; i++) {\n                var baseExpr = bases.members[i];\n                var baseSymbol: Symbol = null;\n                if (baseExpr.nodeType == NodeType.Call) {\n                    baseSymbol = (<CallExpression>baseExpr).target.type.symbol;\n                }\n                else {\n                    baseSymbol = baseExpr.type.symbol;\n                }\n                var baseName = baseSymbol.name;\n                if (baseSymbol.declModule != classDecl.type.symbol.declModule) {\n                    baseName = baseSymbol.fullName();\n                }\n                if (baseExpr.nodeType == NodeType.Call) {\n                    this.emitIndent();\n                    this.writeToOutput("_super.call(this");\n                    var args = (<CallExpression>baseExpr).arguments;\n                    if (args && (args.members.length > 0)) {\n                        this.writeToOutput(", ");\n                        this.emitJavascriptList(args, ", ", TokenID.Comma, false, false, false);\n                    }\n                    this.writeToOutput(")");\n                }\n                else {\n                    if (baseExpr.type && (baseExpr.type.isClassInstance())) {\n                        // parameterless constructor call;\n                        this.emitIndent();\n                        this.writeToOutput(classDecl.name.actualText + "._super.constructor");\n                        //emitJavascript(baseExpr,TokenID.LParen,false);\n                        this.writeToOutput(".call(this)");\n                    }\n                }\n            }\n            this.recordSourceMappingEnd(classDecl);\n        }\n\n        public emitInnerFunction(funcDecl: FuncDecl, printName: bool, isMember: bool,\n            bases: ASTList, hasSelfRef: bool, classDecl: TypeDeclaration) {\n            /// REVIEW: The code below causes functions to get pushed to a newline in cases where they shouldn\'t\n            /// such as: \n            ///     Foo.prototype.bar = \n            ///         function() {\n            ///         };\n            /// Once we start emitting comments, we should pull this code out to place on the outer context where the function\n            /// is used.\n            //if (funcDecl.preComments!=null && funcDecl.preComments.length>0) {\n            //    this.writeLineToOutput("");\n            //    this.increaseIndent();\n            //    emitIndent();\n            //}\n\n            var isClassConstructor = funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod);\n            var hasNonObjectBaseType = isClassConstructor && hasFlag(this.thisClassNode.type.instanceType.typeFlags, TypeFlags.HasBaseType) && !hasFlag(this.thisClassNode.',
v27650=v27651+'type.instanceType.typeFlags, TypeFlags.HasBaseTypeOfObject);\n            var classPropertiesMustComeAfterSuperCall = hasNonObjectBaseType && hasFlag((<ClassDeclaration>this.thisClassNode).varFlags, VarFlags.ClassSuperMustBeFirstCallInConstructor);\n\n            // We have no way of knowing if the current function is used as an expression or a statement, so as to enusre that the emitted\n            // JavaScript is always valid, add an extra parentheses for unparenthesized function expressions\n            var shouldParenthesize = hasFlag(funcDecl.fncFlags, FncFlags.IsFunctionExpression) && !funcDecl.isParenthesized && !funcDecl.isAccessor() && (hasFlag(funcDecl.flags, ASTFlags.ExplicitSemicolon) || hasFlag(funcDecl.flags, ASTFlags.AutomaticSemicolon));\n\n            this.emitParensAndCommentsInPlace(funcDecl, true);\n            if (shouldParenthesize) {\n                this.writeToOutput("(");\n            }\n            this.recordSourceMappingStart(funcDecl);\n            if (!(funcDecl.isAccessor() && (<FieldSymbol>funcDecl.accessorSymbol).isObjectLitField)) {\n                this.writeToOutput("function ");\n            }\n            if (printName) {\n                var id = funcDecl.getNameText();\n                if (id && !funcDecl.isAccessor()) {\n                    if (funcDecl.name) {\n                        this.recordSourceMappingStart(funcDecl.name);\n                    }\n                    this.writeToOutput(id);\n                    if (funcDecl.name) {\n                        this.recordSourceMappingEnd(funcDecl.name);\n                    }\n                }\n            }\n\n            this.writeToOutput("(");\n            var argsLen = 0;\n            var i = 0;\n            var arg: ArgDecl;\n            var defaultArgs: ArgDecl[] = [];\n            if (funcDecl.arguments) {\n                var tempContainer = this.setContainer(EmitContainer.Args);\n                argsLen = funcDecl.arguments.members.length;\n                var printLen = argsLen;\n                if (funcDecl.variableArgList) {\n                    printLen--;\n                }\n                for (i = 0; i < printLen; i++) {\n                    arg = <ArgDecl>funcDecl.arguments.members[i];\n                    if (arg.init) {\n                        defaultArgs.push(arg);\n                    }\n                    this.emitJavascript(arg, TokenID.OpenParen, false);\n                    if (i < (printLen - 1)) {\n                        this.writeToOutput(", ");\n                    }\n                }\n                this.setContainer(tempContainer);\n            }\n            this.writeLineToOutput(") {");\n\n            if (funcDecl.isConstructor) {\n                this.recordSourceMappingNameStart("constructor");\n            } else if (funcDecl.isGetAccessor()) {\n                this.recordSourceMappingNameStart("get_" + funcDecl.getNameText());\n            } else if (funcDecl.isSetAccessor()) {\n                this.recordSourceMappingNameStart("set_" + funcDecl.getNameText());\n            } else {\n                this.recordSourceMappingNameStart(funcDecl.getNameText());\n            }\n            this.indenter.increaseIndent();\n\n            // set default args first\n            for (i = 0; i < defaultArgs.length; i++) {\n                var arg = defaultArgs[i];\n                this.emitIndent();\n                this.recordSourceMappingStart(arg);\n                this.writeToOutput("if (typeof " + arg.id.actualText + " === \\"undefined\\") { ");//\n                this.recordSourceMappingStart(arg.id);\n                this.writeToOutput(arg.id.actualText);\n                this.recordSourceMappingEnd(arg.id);\n                this.writeToOutput(" = ");\n                this.emitJavascript(arg.init, TokenID.OpenParen, false);\n                this.writeLineToOutput("; }")\n                this.recordSourceMappingEnd(arg);\n            }\n\n            if (funcDecl.isConstructor && ((<ClassDeclaration>funcDecl.classDecl).varFlags & VarFlags.MustCaptureThis)) {\n                this.writeCaptureThisStatement(funcDecl);\n            }\n\n            if (funcDecl.isConstructor && !classPropertiesMustComeAfterSuperCall) {\n                if (funcDecl.arguments) {\n                    argsLen = funcDecl.arguments.members.length;\n                    for (i = 0; i < argsLen; i++) {\n                        arg = <ArgDecl>funcDecl.arguments.members[i];\n                        if ((arg.varFlags & VarFlags.Property) != VarFlags.None) {\n                            this.emitIndent();\n                            this.recordSourceMappingStart(arg);\n                            this.recordSourceMappingStart(arg.id);\n                            this.writeToOutput("this." + arg.id.actualText);\n                            this.recordSourceMappingEnd(arg.id);\n                            this.writeToOutput(" = ");\n                            this.recordSourceMappingStart(arg.id);\n                            this.writeToOutput(arg.id.actualText);\n                            this.re',
v27649=v27650+'cordSourceMappingEnd(arg.id);\n                            this.writeLineToOutput(";");\n                            this.recordSourceMappingEnd(arg);\n                        }\n                    }\n                }\n\n                // For classes, the constructor needs to be explicitly called\n                if (!hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {\n                    this.emitConstructorCalls(bases, classDecl);\n                }\n            }\n            if (hasSelfRef) {\n                this.writeCaptureThisStatement(funcDecl);\n            }\n            if (funcDecl.variableArgList) {\n                argsLen = funcDecl.arguments.members.length;\n                var lastArg = <ArgDecl>funcDecl.arguments.members[argsLen - 1];\n                this.emitIndent();\n                this.recordSourceMappingStart(lastArg);\n                this.writeToOutput("var ");\n                this.recordSourceMappingStart(lastArg.id);\n                this.writeToOutput(lastArg.id.actualText);\n                this.recordSourceMappingEnd(lastArg.id);\n                this.writeLineToOutput(" = [];");\n                this.recordSourceMappingEnd(lastArg);\n                this.emitIndent();\n                this.writeToOutput("for (")\n                this.recordSourceMappingStart(lastArg);\n                this.writeToOutput("var _i = 0;");\n                this.recordSourceMappingEnd(lastArg);\n                this.writeToOutput(" ");\n                this.recordSourceMappingStart(lastArg);\n                this.writeToOutput("_i < (arguments.length - " + (argsLen - 1) + ")");\n                this.recordSourceMappingEnd(lastArg);\n                this.writeToOutput("; ");\n                this.recordSourceMappingStart(lastArg);\n                this.writeToOutput("_i++");\n                this.recordSourceMappingEnd(lastArg);\n                this.writeLineToOutput(") {");\n                this.indenter.increaseIndent();\n                this.emitIndent();\n\n                this.recordSourceMappingStart(lastArg);\n                this.writeToOutput(lastArg.id.actualText + "[_i] = arguments[_i + " + (argsLen - 1) + "];");\n                this.recordSourceMappingEnd(lastArg);\n                this.writeLineToOutput("");\n                this.indenter.decreaseIndent();\n                this.emitIndent();\n                this.writeLineToOutput("}");\n            }\n\n            // if it\'s a class, emit the uninitializedMembers, first emit the non-proto class body members\n            if (funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod) && !classPropertiesMustComeAfterSuperCall) {\n\n                var nProps = (<ASTList>this.thisClassNode.members).members.length;\n\n                for (var i = 0; i < nProps; i++) {\n                    if ((<ASTList>this.thisClassNode.members).members[i].nodeType == NodeType.VarDecl) {\n                        var varDecl = <VarDecl>(<ASTList>this.thisClassNode.members).members[i];\n                        if (!hasFlag(varDecl.varFlags, VarFlags.Static) && varDecl.init) {\n                            this.emitIndent();\n                            this.emitJavascriptVarDecl(varDecl, TokenID.Tilde);\n                            this.writeLineToOutput("");\n                        }\n                    }\n                }\n                //this.writeLineToOutput("");\n            }\n\n            this.emitBareJavascriptStatements(funcDecl.bod, classPropertiesMustComeAfterSuperCall);\n\n            this.indenter.decreaseIndent();\n            this.emitIndent();\n            this.recordSourceMappingStart(funcDecl.endingToken);\n            this.writeToOutput("}");\n\n            this.recordSourceMappingNameEnd();\n            this.recordSourceMappingEnd(funcDecl.endingToken);\n            this.recordSourceMappingEnd(funcDecl);\n\n            if (shouldParenthesize) {\n                this.writeToOutput(")");\n            }\n\n            // The extra call is to make sure the caller\'s funcDecl end is recorded, since caller wont be able to record it\n            this.recordSourceMappingEnd(funcDecl);\n\n            this.emitParensAndCommentsInPlace(funcDecl, false);\n\n            if (!isMember &&\n                //funcDecl.name != null &&\n                !hasFlag(funcDecl.fncFlags, FncFlags.IsFunctionExpression) &&\n                (hasFlag(funcDecl.fncFlags, FncFlags.Definition) || funcDecl.isConstructor)) {\n                this.writeLineToOutput("");\n            } else if (hasFlag(funcDecl.fncFlags, FncFlags.IsFunctionExpression)) {\n                if (hasFlag(funcDecl.flags, ASTFlags.ExplicitSemicolon) || hasFlag(funcDecl.flags, ASTFlags.AutomaticSemicolon)) {\n                    // If either of these two flags are set, then the function expression is a statement. Terminate it.\n                    this.writeLineToOutput(";");\n                }\n            }\n            /// TODO: See the other part of this at the beginning of function\n            //if (funcDecl.preComments!=null && funcDecl.preComments.length>0) {\n  ',
v27648=v27649+'          //    this.decreaseIndent();\n            //}           \n        }\n\n        public emitJavascriptModule(moduleDecl: ModuleDeclaration) {\n            var modName = moduleDecl.name.actualText;\n            if (isTSFile(modName)) {\n                moduleDecl.name.setText(modName.substring(0, modName.length - 3));\n            }\n            else if (isSTRFile(modName)) {\n                moduleDecl.name.setText(modName.substring(0, modName.length - 4));\n            }\n\n            if (!hasFlag(moduleDecl.modFlags, ModuleFlags.Ambient)) {\n                var isDynamicMod = hasFlag(moduleDecl.modFlags, ModuleFlags.IsDynamic);\n                var prevOutFile = this.outfile;\n                var prevOutFileName = this.emittingFileName;\n                var prevAllSourceMappers = this.allSourceMappers;\n                var prevSourceMapper = this.sourceMapper;\n                var prevColumn = this.emitState.column;\n                var prevLine = this.emitState.line;\n                var temp = this.setContainer(EmitContainer.Module);\n                var svModuleName = this.moduleName;\n                var isExported = hasFlag(moduleDecl.modFlags, ModuleFlags.Exported);\n                this.moduleDeclList[this.moduleDeclList.length] = moduleDecl;\n                var isWholeFile = hasFlag(moduleDecl.modFlags, ModuleFlags.IsWholeFile);\n                this.moduleName = moduleDecl.name.actualText;\n\n                // prologue\n                if (isDynamicMod) {\n                    // create the new outfile for this module\n                    var tsModFileName = stripQuotes(moduleDecl.name.actualText);\n                    var modFilePath = trimModName(tsModFileName) + ".js";\n                    modFilePath = this.emitOptions.mapOutputFileName(modFilePath, TypeScriptCompiler.mapToJSFileName);\n\n                    if (this.emitOptions.ioHost) {\n                        // Ensure that the slashes are normalized so that the comparison is fair\n                        // REVIEW: Note that modFilePath is normalized to forward slashes in Parser.parse, so the \n                        // first call to switchToForwardSlashes is technically a no-op, but it will prevent us from\n                        // regressing if the parser changes\n                        if (switchToForwardSlashes(modFilePath) != switchToForwardSlashes(this.emittingFileName)) {\n                            this.emittingFileName = modFilePath;\n                            var useUTF8InOutputfile = moduleDecl.containsUnicodeChar || (this.emitOptions.emitComments && moduleDecl.containsUnicodeCharInComment);\n                            this.outfile = this.createFile(this.emittingFileName, useUTF8InOutputfile);\n                            if (prevSourceMapper != null) {\n                                this.allSourceMappers = [];\n                                var sourceMappingFile = this.createFile(this.emittingFileName + SourceMapper.MapFileExtension, false);\n                                this.setSourceMappings(new TypeScript.SourceMapper(tsModFileName, this.emittingFileName, this.outfile, sourceMappingFile, this.errorReporter));\n                                this.emitState.column = 0;\n                                this.emitState.line = 0;\n                            }\n                        } else {\n                            CompilerDiagnostics.assert(this.emitOptions.outputMany, "Cannot have dynamic modules compiling into single file");\n                        }\n                    }\n\n                    this.setContainer(EmitContainer.DynamicModule); // discard the previous \'Module\' container\n\n                    this.recordSourceMappingStart(moduleDecl);\n                    if (moduleGenTarget == ModuleGenTarget.Asynchronous) { // AMD\n                        var dependencyList = "[\\"require\\", \\"exports\\"";\n                        var importList = "require, exports";\n                        var importStatement: ImportDeclaration = null;\n\n                        // all dependencies are quoted\n                        for (var i = 0; i < (<ModuleType>moduleDecl.mod).importedModules.length; i++) {\n                            importStatement = (<ModuleType>moduleDecl.mod).importedModules[i]\n\n                            // if the imported module is only used in a type position, do not add it as a requirement\n                            if (importStatement.id.sym &&\n                                !(<TypeSymbol>importStatement.id.sym).onlyReferencedAsTypeRef) {\n                                if (i <= (<ModuleType>moduleDecl.mod).importedModules.length - 1) {\n                                    dependencyList += ", ";\n                                    importList += ", ";\n                                }\n\n                                importList += "__" + importStatement.id.actualText + "__";\n                                dependencyList += importStatement.firstAliasedModToString();\n                            }\n                        }\n\n                 ',
v27647=v27648+'       // emit any potential amd dependencies\n                        for (var i = 0; i < moduleDecl.amdDependencies.length; i++) {\n                            dependencyList += ", \\"" + moduleDecl.amdDependencies[i] + "\\"";\n                        }\n\n                        dependencyList += "]";\n\n                        this.writeLineToOutput("define(" + dependencyList + "," + " function(" + importList + ") {");\n                    }\n                    else { // Node\n\n                    }\n                }\n                else {\n\n                    if (!isExported) {\n                        this.recordSourceMappingStart(moduleDecl);\n                        this.writeToOutput("var ");\n                        this.recordSourceMappingStart(moduleDecl.name);\n                        this.writeToOutput(this.moduleName);\n                        this.recordSourceMappingEnd(moduleDecl.name);\n                        this.writeLineToOutput(";");\n                        this.recordSourceMappingEnd(moduleDecl);\n                        this.emitIndent();\n                    }\n\n                    this.writeToOutput("(");\n                    this.recordSourceMappingStart(moduleDecl);\n                    this.writeToOutput("function (");\n                    this.recordSourceMappingStart(moduleDecl.name);\n                    this.writeToOutput(this.moduleName);\n                    this.recordSourceMappingEnd(moduleDecl.name);\n                    this.writeLineToOutput(") {");\n                }\n\n                if (!isWholeFile) {\n                    this.recordSourceMappingNameStart(this.moduleName);\n                }\n\n                // body - don\'t indent for Node\n                if (!isDynamicMod || moduleGenTarget == ModuleGenTarget.Asynchronous) {\n                    this.indenter.increaseIndent();\n                }\n\n                if (moduleDecl.modFlags & ModuleFlags.MustCaptureThis) {\n                    this.writeCaptureThisStatement(moduleDecl);\n                }\n\n                this.emitJavascriptList(moduleDecl.members, null, TokenID.Semicolon, true, false, false);\n                if (!isDynamicMod || moduleGenTarget == ModuleGenTarget.Asynchronous) {\n                    this.indenter.decreaseIndent();\n                }\n                this.emitIndent();\n\n                // epilogue\n                if (isDynamicMod) {\n                    if (moduleGenTarget == ModuleGenTarget.Asynchronous) { // AMD\n                        this.writeLineToOutput("})");\n                    }\n                    else { // Node\n                    }\n                    if (!isWholeFile) {\n                        this.recordSourceMappingNameEnd();\n                    }\n                    this.recordSourceMappingEnd(moduleDecl);\n\n                    // close the module outfile, and restore the old one\n                    if (this.outfile != prevOutFile) {\n                        this.Close();\n                        if (prevSourceMapper != null) {\n                            this.allSourceMappers = prevAllSourceMappers;\n                            this.sourceMapper = prevSourceMapper;\n                            this.emitState.column = prevColumn;\n                            this.emitState.line = prevLine;\n                        }\n                        this.outfile = prevOutFile;\n                        this.emittingFileName = prevOutFileName;\n                    }\n                }\n                else {\n                    var containingMod: ModuleDeclaration = null;\n                    if (moduleDecl.type && moduleDecl.type.symbol.container && moduleDecl.type.symbol.container.declAST) {\n                        containingMod = <ModuleDeclaration>moduleDecl.type.symbol.container.declAST;\n                    }\n                    var parentIsDynamic = containingMod && hasFlag(containingMod.modFlags, ModuleFlags.IsDynamic);\n\n                    this.recordSourceMappingStart(moduleDecl.endingToken);\n                    if (temp == EmitContainer.Prog && isExported) {\n                        this.writeToOutput("}");\n                        if (!isWholeFile) {\n                            this.recordSourceMappingNameEnd();\n                        }\n                        this.recordSourceMappingEnd(moduleDecl.endingToken);\n                        this.writeToOutput(")(this." + this.moduleName + " || (this." + this.moduleName + " = {}));");\n                    }\n                    else if (isExported || temp == EmitContainer.Prog) {\n                        var dotMod = svModuleName != "" ? (parentIsDynamic ? "exports" : svModuleName) + "." : svModuleName;\n                        this.writeToOutput("}");\n                        if (!isWholeFile) {\n                            this.recordSourceMappingNameEnd();\n                        }\n                        this.recordSourceMappingEnd(moduleDecl.endingToken);\n                        this.writeToOutput(")(" + dotMod + this.moduleName + " || (" + dotMod + this.moduleName + " = {})',
v27646=v27647+');");\n                    }\n                    else if (!isExported && temp != EmitContainer.Prog) {\n                        this.writeToOutput("}");\n                        if (!isWholeFile) {\n                            this.recordSourceMappingNameEnd();\n                        }\n                        this.recordSourceMappingEnd(moduleDecl.endingToken);\n                        this.writeToOutput(")(" + this.moduleName + " || (" + this.moduleName + " = {}));");\n                    }\n                    else {\n                        this.writeToOutput("}");\n                        if (!isWholeFile) {\n                            this.recordSourceMappingNameEnd();\n                        }\n                        this.recordSourceMappingEnd(moduleDecl.endingToken);\n                        this.writeToOutput(")();");\n                    }\n                    this.recordSourceMappingEnd(moduleDecl);\n                    this.writeLineToOutput("");\n                    if (temp != EmitContainer.Prog && isExported) {\n                        this.emitIndent();\n                        this.recordSourceMappingStart(moduleDecl);\n                        if (parentIsDynamic) {\n                            this.writeLineToOutput("var " + this.moduleName + " = exports." + this.moduleName + ";");\n                        } else {\n                            this.writeLineToOutput("var " + this.moduleName + " = " + svModuleName + "." + this.moduleName + ";");\n                        }\n                        this.recordSourceMappingEnd(moduleDecl);\n                    }\n                }\n\n                this.setContainer(temp);\n                this.moduleName = svModuleName;\n                this.moduleDeclList.length--;\n            }\n        }\n\n        public emitIndex(operand1: AST, operand2: AST) {\n            var temp = this.setInObjectLiteral(false);\n            this.emitJavascript(operand1, TokenID.Tilde, false);\n            this.writeToOutput("[");\n            this.emitJavascriptList(operand2, ", ", TokenID.Comma, false, false, false);\n            this.writeToOutput("]");\n            this.setInObjectLiteral(temp);\n        }\n\n        public emitStringLiteral(text: string) {\n            // should preserve escape etc.\n            // TODO: simplify object literal simple name\n            this.writeToOutput(text);\n        }\n\n        public emitJavascriptFunction(funcDecl: FuncDecl) {\n            if (hasFlag(funcDecl.fncFlags, FncFlags.Signature) || funcDecl.isOverload) {\n                return;\n            }\n            var temp: number;\n            var tempFnc = this.thisFnc;\n            this.thisFnc = funcDecl;\n\n            if (funcDecl.isConstructor) {\n                temp = this.setContainer(EmitContainer.Constructor);\n            }\n            else {\n                temp = this.setContainer(EmitContainer.Function);\n            }\n\n            var bases: ASTList = null;\n            var hasSelfRef = false;\n            var funcName = funcDecl.getNameText();\n\n            if ((this.emitState.inObjectLiteral || !funcDecl.isAccessor()) &&\n                ((temp != EmitContainer.Constructor) ||\n                ((funcDecl.fncFlags & FncFlags.Method) == FncFlags.None))) {\n                var tempLit = this.setInObjectLiteral(false);\n                if (this.thisClassNode) {\n                    bases = this.thisClassNode.extendsList;\n                }\n                hasSelfRef = Emitter.shouldCaptureThis(funcDecl);\n                this.recordSourceMappingStart(funcDecl);\n                if (hasFlag(funcDecl.fncFlags, FncFlags.Exported | FncFlags.ClassPropertyMethodExported) && funcDecl.type.symbol.container == this.checker.gloMod && !funcDecl.isConstructor) {\n                    this.writeToOutput("this." + funcName + " = ");\n                    this.emitInnerFunction(funcDecl, false, false, bases, hasSelfRef, this.thisClassNode);\n                }\n                else {\n                    this.emitInnerFunction(funcDecl, (funcDecl.name && !funcDecl.name.isMissing()), false, bases, hasSelfRef, this.thisClassNode);\n                }\n                this.setInObjectLiteral(tempLit);\n            }\n            this.setContainer(temp);\n            this.thisFnc = tempFnc;\n\n            if (hasFlag(funcDecl.fncFlags, FncFlags.Definition)) {\n                if (hasFlag(funcDecl.fncFlags, FncFlags.Static)) {\n                    if (this.thisClassNode) {\n                        if (funcDecl.isAccessor()) {\n                            this.emitPropertyAccessor(funcDecl, this.thisClassNode.name.actualText, false);\n                        }\n                        else {\n                            this.emitIndent();\n                            this.recordSourceMappingStart(funcDecl);\n                            this.writeLineToOutput(this.thisClassNode.name.actualText + "." + funcName +\n                                          " = " + funcName + ";");\n                            this.recordSourceMappingEnd(funcDecl);\n                     ',
v27645=v27646+'   }\n                    }\n                }\n                else if ((this.emitState.container == EmitContainer.Module || this.emitState.container == EmitContainer.DynamicModule) && hasFlag(funcDecl.fncFlags, FncFlags.Exported | FncFlags.ClassPropertyMethodExported)) {\n                    this.emitIndent();\n                    var modName = this.emitState.container == EmitContainer.Module ? this.moduleName : "exports";\n                    this.recordSourceMappingStart(funcDecl);\n                    this.writeLineToOutput(modName + "." + funcName +\n                                      " = " + funcName + ";");\n                    this.recordSourceMappingEnd(funcDecl);\n                }\n            }\n        }\n\n        public emitAmbientVarDecl(varDecl: VarDecl) {\n            if (varDecl.init) {\n                this.emitParensAndCommentsInPlace(varDecl, true);\n                this.recordSourceMappingStart(varDecl);\n                this.recordSourceMappingStart(varDecl.id);\n                this.writeToOutput(varDecl.id.actualText);\n                this.recordSourceMappingEnd(varDecl.id);\n                this.writeToOutput(" = ");\n                this.emitJavascript(varDecl.init, TokenID.Comma, false);\n                this.recordSourceMappingEnd(varDecl);\n                this.writeToOutput(";");\n                this.emitParensAndCommentsInPlace(varDecl, false);\n            }\n        }\n\n        private varListCount(): number {\n            return this.varListCountStack[this.varListCountStack.length - 1];\n        }\n\n        // Emits "var " if it is allowed\n        private emitVarDeclVar() {\n            // If it is var list of form var a, b, c = emit it only if count > 0 - which will be when emitting first var\n            // If it is var list of form  var a = varList count will be 0\n            if (this.varListCount() >= 0) {\n                this.writeToOutput("var ");\n                this.setInVarBlock(-this.varListCount());\n            }\n            return true;\n        }\n\n        private onEmitVar() {\n            if (this.varListCount() > 0) {\n                this.setInVarBlock(this.varListCount() - 1);\n            }\n            else if (this.varListCount() < 0) {\n                this.setInVarBlock(this.varListCount() + 1);\n            }\n        }\n\n        public emitJavascriptVarDecl(varDecl: VarDecl, tokenId: TokenID) {\n            if ((varDecl.varFlags & VarFlags.Ambient) == VarFlags.Ambient) {\n                this.emitAmbientVarDecl(varDecl);\n                this.onEmitVar();\n            }\n            else {\n                var sym = varDecl.sym;\n                var hasInitializer = (varDecl.init != null);\n                this.emitParensAndCommentsInPlace(varDecl, true);\n                this.recordSourceMappingStart(varDecl);\n                if (sym && sym.isMember() && sym.container &&\n                    (sym.container.kind() == SymbolKind.Type)) {\n                    var type = (<TypeSymbol>sym.container).type;\n                    if (type.isClass() && (!hasFlag(sym.flags, SymbolFlags.ModuleMember))) {\n                        // class\n                        if (this.emitState.container != EmitContainer.Args) {\n                            if (hasFlag(sym.flags, SymbolFlags.Static)) {\n                                this.writeToOutput(sym.container.name + ".");\n                            }\n                            else {\n                                this.writeToOutput("this.");\n                            }\n                        }\n                    }\n                    else if (type.hasImplementation()) {\n                        // module\n                        if (!hasFlag(sym.flags, SymbolFlags.Exported) && (sym.container == this.checker.gloMod || !hasFlag(sym.flags, SymbolFlags.Property))) {\n                            this.emitVarDeclVar();\n                        }\n                        else if (hasFlag(varDecl.varFlags, VarFlags.LocalStatic)) {\n                            this.writeToOutput(".");\n                        }\n                        else {\n                            if (this.emitState.container == EmitContainer.DynamicModule) {\n                                this.writeToOutput("exports.");\n                            }\n                            else {\n                                this.writeToOutput(this.moduleName + ".");\n                            }\n                        }\n                    }\n                    else {\n                        // function, constructor, method etc.\n                        if (tokenId != TokenID.OpenParen) {\n                            if (hasFlag(sym.flags, SymbolFlags.Exported) && sym.container == this.checker.gloMod) {\n                                this.writeToOutput("this.");\n                            }\n                            else {\n                                this.emitVarDeclVar();\n                            }\n                        }\n                    }\n                }\n                else {\n            ',
v27644=v27645+'        if (tokenId != TokenID.OpenParen) {\n                        this.emitVarDeclVar();\n                    }\n                }\n                this.recordSourceMappingStart(varDecl.id);\n                this.writeToOutput(varDecl.id.actualText);\n                this.recordSourceMappingEnd(varDecl.id);\n                if (hasInitializer) {\n                    this.writeToOutputTrimmable(" = ");\n\n                    // Ensure we have a fresh var list count when recursing into the variable \n                    // initializer.  We don\'t want our current list of variables to affect how we\n                    // emit nested variable lists.\n                    this.varListCountStack.push(0);\n                    this.emitJavascript(varDecl.init, TokenID.Comma, false);\n                    this.varListCountStack.pop();\n                }\n                this.onEmitVar();\n                if ((tokenId != TokenID.OpenParen)) {\n                    if (this.varListCount() < 0) {\n                        this.writeToOutput(", ");\n                    } else if (tokenId != TokenID.For) {\n                        this.writeToOutputTrimmable(";");\n                    }\n                }\n                this.recordSourceMappingEnd(varDecl);\n                this.emitParensAndCommentsInPlace(varDecl, false);\n            }\n        }\n\n        public declEnclosed(moduleDecl: ModuleDeclaration): bool {\n            if (moduleDecl == null) {\n                return true;\n            }\n            for (var i = 0, len = this.moduleDeclList.length; i < len; i++) {\n                if (this.moduleDeclList[i] == moduleDecl) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        public emitJavascriptName(name: Identifier, addThis: bool) {\n            var sym = name.sym;\n            this.emitParensAndCommentsInPlace(name, true);\n            this.recordSourceMappingStart(name);\n            if (!name.isMissing()) {\n                if (addThis && (this.emitState.container != EmitContainer.Args) && sym) {\n                    // TODO: flag global module with marker other than string name\n                    if (sym.container && (sym.container.name != globalId)) {\n                        if (hasFlag(sym.flags, SymbolFlags.Static) && (hasFlag(sym.flags, SymbolFlags.Property))) {\n                            if (sym.declModule && hasFlag(sym.declModule.modFlags, ModuleFlags.IsDynamic)) {\n                                this.writeToOutput("exports.");\n                            }\n                            else {\n                                this.writeToOutput(sym.container.name + ".");\n                            }\n                        }\n                        else if (sym.kind() == SymbolKind.Field) {\n                            var fieldSym = <FieldSymbol>sym;\n                            if (hasFlag(fieldSym.flags, SymbolFlags.ModuleMember)) {\n                                if ((sym.container != this.checker.gloMod) && ((hasFlag(sym.flags, SymbolFlags.Property)) || hasFlag(sym.flags, SymbolFlags.Exported))) {\n                                    if (hasFlag(sym.declModule.modFlags, ModuleFlags.IsDynamic)) {\n                                        this.writeToOutput("exports.");\n                                    }\n                                    else {\n                                        this.writeToOutput(sym.container.name + ".");\n                                    }\n                                }\n                            }\n                            else {\n                                if (sym.isInstanceProperty()) {\n                                    this.emitThis();\n                                    this.writeToOutput(".");\n                                }\n                            }\n                        }\n                        else if (sym.kind() == SymbolKind.Type) {\n                            if (sym.isInstanceProperty()) {\n                                var typeSym = <TypeSymbol>sym;\n                                var type = typeSym.type;\n                                if (type.call && !hasFlag(sym.flags, SymbolFlags.ModuleMember)) {\n                                    this.emitThis();\n                                    this.writeToOutput(".");\n                                }\n                            }\n                            else if ((sym.unitIndex != this.checker.locationInfo.unitIndex) || (!this.declEnclosed(sym.declModule))) {\n                                this.writeToOutput(sym.container.name + ".")\n                            }\n                        }\n                    }\n                    else if (sym.container == this.checker.gloMod &&\n                                hasFlag(sym.flags, SymbolFlags.Exported) &&\n                                !hasFlag(sym.flags, SymbolFlags.Ambient) &&\n                                // check that it\'s a not a member of an ambient module...\n                                !((sym.isType()',
v27643=v27644+' || sym.isMember()) &&\n                                    sym.declModule &&\n                                    hasFlag(sym.declModule.modFlags, ModuleFlags.Ambient)) &&\n                                this.emitState.container == EmitContainer.Prog &&\n                                sym.declAST.nodeType != NodeType.FuncDecl) {\n                        this.writeToOutput("this.");\n                    }\n                }\n\n                // If it\'s a dynamic module, we need to print the "require" invocation\n                if (sym &&\n                    sym.declAST &&\n                    sym.declAST.nodeType == NodeType.ModuleDeclaration &&\n                    (hasFlag((<ModuleDeclaration>sym.declAST).modFlags, ModuleFlags.IsDynamic))) {\n                    var moduleDecl: ModuleDeclaration = <ModuleDeclaration>sym.declAST;\n\n                    if (moduleGenTarget == ModuleGenTarget.Asynchronous) {\n                        this.writeLineToOutput("__" + this.modAliasId + "__;");\n                    }\n                    else {\n                        var modPath = name.actualText;//(<ModuleDecl>moduleDecl.mod.symbol.declAST).name.actualText;\n                        var isAmbient = moduleDecl.mod.symbol.declAST && hasFlag((<ModuleDeclaration>moduleDecl.mod.symbol.declAST).modFlags, ModuleFlags.Ambient);\n                        modPath = isAmbient ? modPath : this.firstModAlias ? this.firstModAlias : quoteBaseName(modPath);\n                        modPath = isAmbient ? modPath : (!isRelative(stripQuotes(modPath)) ? quoteStr("./" + stripQuotes(modPath)) : modPath);\n                        this.writeToOutput("require(" + modPath + ")");\n                    }\n                }\n                else {\n                    this.writeToOutput(name.actualText);\n                }\n            }\n            this.recordSourceMappingEnd(name);\n            this.emitParensAndCommentsInPlace(name, false);\n        }\n\n        public emitJavascriptStatements(stmts: AST, emitEmptyBod: bool) {\n            if (stmts) {\n                if (stmts.nodeType != NodeType.Block) {\n                    var hasContents = (stmts && (stmts.nodeType != NodeType.List || ((<ASTList>stmts).members.length > 0)));\n                    if (emitEmptyBod || hasContents) {\n                        var hasOnlyBlockStatement = ((stmts.nodeType == NodeType.Block) ||\n                            ((stmts.nodeType == NodeType.List) && ((<ASTList>stmts).members.length == 1) && ((<ASTList>stmts).members[0].nodeType == NodeType.Block)));\n\n                        this.recordSourceMappingStart(stmts);\n                        if (!hasOnlyBlockStatement) {\n                            this.writeLineToOutput(" {");\n                            this.indenter.increaseIndent();\n                        }\n                        this.emitJavascriptList(stmts, null, TokenID.Semicolon, true, false, false);\n                        if (!hasOnlyBlockStatement) {\n                            this.writeLineToOutput("");\n                            this.indenter.decreaseIndent();\n                            this.emitIndent();\n                            this.writeToOutput("}");\n                        }\n                        this.recordSourceMappingEnd(stmts);\n                    }\n                }\n                else {\n                    this.emitJavascript(stmts, TokenID.Semicolon, true);\n                }\n            }\n            else if (emitEmptyBod) {\n                this.writeToOutput("{ }");\n            }\n        }\n\n        public emitBareJavascriptStatements(stmts: AST, emitClassPropertiesAfterSuperCall: bool = false) {\n            // just the statements without enclosing curly braces\n            if (stmts.nodeType != NodeType.Block) {\n                if (stmts.nodeType == NodeType.List) {\n                    var stmtList = <ASTList>stmts;\n                    if ((stmtList.members.length == 2) &&\n                        (stmtList.members[0].nodeType == NodeType.Block) &&\n                        (stmtList.members[1].nodeType == NodeType.EndCode)) {\n                        this.emitJavascript(stmtList.members[0], TokenID.Semicolon, true);\n                        this.writeLineToOutput("");\n                    }\n                    else {\n                        this.emitJavascriptList(stmts, null, TokenID.Semicolon, true, false, emitClassPropertiesAfterSuperCall);\n                    }\n                }\n                else {\n                    this.emitJavascript(stmts, TokenID.Semicolon, true);\n                }\n            }\n            else {\n                this.emitJavascript(stmts, TokenID.Semicolon, true);\n            }\n        }\n\n        public recordSourceMappingNameStart(name: string) {\n            if (this.sourceMapper) {\n                var finalName = name;\n                if (!name) {\n                    finalName = "";\n                } else if (this.sourceMapper.currentNameIndex.length > 0) {\n                    finalName = this.sourceMapper.names[this.source',
v27642=v27643+"Mapper.currentNameIndex.length - 1] + \".\" + name;\n                }\n\n                // We are currently not looking for duplicate but that is possible.\n                this.sourceMapper.names.push(finalName);\n                this.sourceMapper.currentNameIndex.push(this.sourceMapper.names.length - 1);\n            }\n        }\n\n        public recordSourceMappingNameEnd() {\n            if (this.sourceMapper) {\n                this.sourceMapper.currentNameIndex.pop();\n            }\n        }\n\n        public recordSourceMappingStart(ast: ASTSpan) {\n            if (this.sourceMapper && isValidAstNode(ast)) {\n                var lineCol = { line: -1, col: -1 };\n                var sourceMapping = new SourceMapping();\n                sourceMapping.start.emittedColumn = this.emitState.column;\n                sourceMapping.start.emittedLine = this.emitState.line;\n                // REVIEW: check time consumed by this binary search (about two per leaf statement)\n                getSourceLineColFromMap(lineCol, ast.minChar, this.checker.locationInfo.lineMap);\n                sourceMapping.start.sourceColumn = lineCol.col;\n                sourceMapping.start.sourceLine = lineCol.line;\n                getSourceLineColFromMap(lineCol, ast.limChar, this.checker.locationInfo.lineMap);\n                sourceMapping.end.sourceColumn = lineCol.col;\n                sourceMapping.end.sourceLine = lineCol.line;\n                if (this.sourceMapper.currentNameIndex.length > 0) {\n                    sourceMapping.nameIndex = this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length - 1];\n                }\n                // Set parent and child relationship\n                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];\n                siblings.push(sourceMapping);\n                this.sourceMapper.currentMappings.push(sourceMapping.childMappings);\n            }\n        }\n\n        public recordSourceMappingEnd(ast: ASTSpan) {\n            if (this.sourceMapper && isValidAstNode(ast)) {\n                // Pop source mapping childs\n                this.sourceMapper.currentMappings.pop();\n\n                // Get the last source mapping from sibling list = which is the one we are recording end for\n                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];\n                var sourceMapping = siblings[siblings.length - 1];\n\n                sourceMapping.end.emittedColumn = this.emitState.column;\n                sourceMapping.end.emittedLine = this.emitState.line;\n            }\n        }\n\n        public Close() {\n            if (this.sourceMapper != null) {\n                SourceMapper.EmitSourceMapping(this.allSourceMappers);\n            }\n            try {\n                // Closing files could result in exceptions, report them if they occur\n                this.outfile.Close();\n            } catch (ex) {\n                this.errorReporter.emitterError(null, ex.message);\n            }\n        }\n\n        public emitJavascriptList(ast: AST, delimiter: string, tokenId: TokenID, startLine: bool, onlyStatics: bool, emitClassPropertiesAfterSuperCall: bool = false, emitPrologue? = false, requiresExtendsBlock?: bool) {\n            if (ast == null) {\n                return;\n            }\n            else if (ast.nodeType != NodeType.List) {\n                this.emitPrologue(emitPrologue);\n                this.emitJavascript(ast, tokenId, startLine);\n            }\n            else {\n                var list = <ASTList>ast;\n                if (list.members.length == 0) {\n                    return;\n                }\n\n                this.emitParensAndCommentsInPlace(ast, true);\n                var len = list.members.length;\n                for (var i = 0; i < len; i++) {\n                    if (emitPrologue) {\n                        // If the list has Strict mode flags, emit prologue after first statement\n                        // otherwise emit before first statement\n                        if (i == 1 || !hasFlag(list.flags, ASTFlags.StrictMode)) {\n                            this.emitPrologue(requiresExtendsBlock);\n                            emitPrologue = false;\n                        }\n                    }\n\n                    // In some circumstances, class property initializers must be emitted immediately after the 'super' constructor\n                    // call which, in these cases, must be the first statement in the constructor body\n                    if (i == 1 && emitClassPropertiesAfterSuperCall) {\n\n                        // emit any parameter properties first\n                        var constructorDecl = (<ClassDeclaration>this.thisClassNode).constructorDecl;\n\n                        if (constructorDecl && constructorDecl.arguments) {\n                            var argsLen = constructorDecl.arguments.members.length;\n                            for (var iArg = 0; iArg < argsLen; iArg++) {\n                     ",
v27641=v27642+'           var arg = <BoundDecl>constructorDecl.arguments.members[iArg];\n                                if ((arg.varFlags & VarFlags.Property) != VarFlags.None) {\n                                    this.emitIndent();\n                                    this.recordSourceMappingStart(arg);\n                                    this.recordSourceMappingStart(arg.id);\n                                    this.writeToOutput("this." + arg.id.actualText);\n                                    this.recordSourceMappingEnd(arg.id);\n                                    this.writeToOutput(" = ");\n                                    this.recordSourceMappingStart(arg.id);\n                                    this.writeToOutput(arg.id.actualText);\n                                    this.recordSourceMappingEnd(arg.id);\n                                    this.writeLineToOutput(";");\n                                    this.recordSourceMappingEnd(arg);\n                                }\n                            }\n                        }\n\n                        var nProps = (<ASTList>this.thisClassNode.members).members.length;\n\n                        for (var iMember = 0; iMember < nProps; iMember++) {\n                            if ((<ASTList>this.thisClassNode.members).members[iMember].nodeType == NodeType.VarDecl) {\n                                var varDecl = <VarDecl>(<ASTList>this.thisClassNode.members).members[iMember];\n                                if (!hasFlag(varDecl.varFlags, VarFlags.Static) && varDecl.init) {\n                                    this.emitIndent();\n                                    this.emitJavascriptVarDecl(varDecl, TokenID.Tilde);\n                                    this.writeLineToOutput("");\n                                }\n                            }\n                        }\n                    }\n\n                    var emitNode = list.members[i];\n\n                    var isStaticDecl =\n                                (emitNode.nodeType == NodeType.FuncDecl && hasFlag((<FuncDecl>emitNode).fncFlags, FncFlags.Static)) ||\n                                (emitNode.nodeType == NodeType.VarDecl && hasFlag((<VarDecl>emitNode).varFlags, VarFlags.Static))\n\n                    if (onlyStatics ? !isStaticDecl : isStaticDecl) {\n                        continue;\n                    }\n                    this.emitJavascript(emitNode, tokenId, startLine);\n\n                    if (delimiter && (i < (len - 1))) {\n                        if (startLine) {\n                            this.writeLineToOutput(delimiter);\n                        }\n                        else {\n                            this.writeToOutput(delimiter);\n                        }\n                    }\n                    else if (startLine &&\n                             (emitNode.nodeType != NodeType.ModuleDeclaration) &&\n                             (emitNode.nodeType != NodeType.InterfaceDeclaration) &&\n                             (!((emitNode.nodeType == NodeType.VarDecl) &&\n                                ((((<VarDecl>emitNode).varFlags) & VarFlags.Ambient) == VarFlags.Ambient) &&\n                                (((<VarDecl>emitNode).init) == null)) && this.varListCount() >= 0) &&\n                             (emitNode.nodeType != NodeType.Block || (<Block>emitNode).isStatementBlock) &&\n                             (emitNode.nodeType != NodeType.EndCode) &&\n                             (emitNode.nodeType != NodeType.FuncDecl)) {\n                        this.writeLineToOutput("");\n                    }\n                }\n                this.emitParensAndCommentsInPlace(ast, false);\n            }\n        }\n\n        // tokenId is the id the preceding token\n        public emitJavascript(ast: AST, tokenId: TokenID, startLine: bool) {\n            if (ast == null) {\n                return;\n            }\n\n            // REVIEW: simplify rules for indenting\n            if (startLine && (this.indenter.indentAmt > 0) && (ast.nodeType != NodeType.List) &&\n                (ast.nodeType != NodeType.Block)) {\n                if ((ast.nodeType != NodeType.InterfaceDeclaration) &&\n                    (!((ast.nodeType == NodeType.VarDecl) &&\n                       ((((<VarDecl>ast).varFlags) & VarFlags.Ambient) == VarFlags.Ambient) &&\n                       (((<VarDecl>ast).init) == null)) && this.varListCount() >= 0) &&\n                    (ast.nodeType != NodeType.EndCode) &&\n                    ((ast.nodeType != NodeType.FuncDecl) ||\n                     (this.emitState.container != EmitContainer.Constructor))) {\n                    this.emitIndent();\n                }\n            }\n\n            ast.emit(this, tokenId, startLine);\n\n            if ((tokenId == TokenID.Semicolon) && (ast.nodeType < NodeType.GeneralNode)) {\n                this.writeToOutput(";");\n            }\n        }\n\n        public emitPropertyAccessor(funcDecl: FuncDecl, className: string, isProto: bool) {\n            if (!(<FieldSymbol>funcDecl.accessorSymbol).h',
v27640=v27641+'asBeenEmitted) {\n                var accessorSymbol = <FieldSymbol>funcDecl.accessorSymbol;\n                this.emitIndent();\n                this.recordSourceMappingStart(funcDecl);\n                this.writeLineToOutput("Object.defineProperty(" + className + (isProto ? ".prototype, \\"" : ", \\"") + funcDecl.name.actualText + "\\"" + ", {");\n                this.indenter.increaseIndent();\n\n                if (accessorSymbol.getter) {\n                    var getter: FuncDecl = <FuncDecl>accessorSymbol.getter.declAST;\n\n                    this.emitIndent();\n                    this.recordSourceMappingStart(getter);\n                    this.writeToOutput("get: ");\n                    this.emitInnerFunction(getter, false, isProto, null, Emitter.shouldCaptureThis(getter), null);\n                    this.writeLineToOutput(",");\n                }\n\n                if (accessorSymbol.setter) {\n                    var setter: FuncDecl = <FuncDecl>accessorSymbol.setter.declAST;\n\n                    this.emitIndent();\n                    this.recordSourceMappingStart(setter);\n                    this.writeToOutput("set: ");\n                    this.emitInnerFunction(setter, false, isProto, null, Emitter.shouldCaptureThis(setter), null);\n                    this.writeLineToOutput(",");\n                }\n\n                this.emitIndent();\n                this.writeLineToOutput("enumerable: true,");\n                this.emitIndent();\n                this.writeLineToOutput("configurable: true");\n                this.indenter.decreaseIndent();\n                this.emitIndent();\n                this.writeLineToOutput("});");\n                this.recordSourceMappingEnd(funcDecl);\n\n                accessorSymbol.hasBeenEmitted = true;\n            }\n        }\n\n        public emitPrototypeMember(member: AST, className: string) {\n            if (member.nodeType == NodeType.FuncDecl) {\n                var funcDecl = <FuncDecl>member;\n                if (funcDecl.isAccessor()) {\n                    this.emitPropertyAccessor(funcDecl, className, true);\n                }\n                else {\n                    this.emitIndent();\n                    this.recordSourceMappingStart(funcDecl);\n                    this.writeToOutput(className + ".prototype." + funcDecl.getNameText() + " = ");\n                    this.emitInnerFunction(funcDecl, false, true, null, Emitter.shouldCaptureThis(funcDecl), null);\n                    this.writeLineToOutput(";");\n                }\n            }\n            else if (member.nodeType == NodeType.VarDecl) {\n                var varDecl = <VarDecl>member;\n\n                if (varDecl.init) {\n                    this.emitIndent();\n                    this.recordSourceMappingStart(varDecl);\n                    this.recordSourceMappingStart(varDecl.id);\n                    this.writeToOutput(className + ".prototype." + varDecl.id.actualText);\n                    this.recordSourceMappingEnd(varDecl.id);\n                    this.writeToOutput(" = ");\n                    this.emitJavascript(varDecl.init, TokenID.Equals, false);\n                    this.recordSourceMappingEnd(varDecl);\n                    this.writeLineToOutput(";");\n                }\n            }\n        }\n\n        public emitAddBaseMethods(className: string, base: Type, classDecl: TypeDeclaration): void {\n            if (base.members) {\n                var baseSymbol = base.symbol;\n                var baseName = baseSymbol.name;\n                if (baseSymbol.declModule != classDecl.type.symbol.declModule) {\n                    baseName = baseSymbol.fullName();\n                }\n                base.members.allMembers.map(function(key, s, c) {\n                    var sym = <Symbol>s;\n                    if ((sym.kind() == SymbolKind.Type) && (<TypeSymbol>sym).type.call) {\n                        this.recordSourceMappingStart(sym.declAST);\n                        this.writeLineToOutput(className + ".prototype." + sym.name + " = " +\n                                          baseName + ".prototype." + sym.name + ";");\n                        this.recordSourceMappingEnd(sym.declAST);\n                    }\n                }, null);\n            }\n            if (base.extendsList) {\n                for (var i = 0, len = base.extendsList.length; i < len; i++) {\n                    this.emitAddBaseMethods(className, base.extendsList[i], classDecl);\n                }\n            }\n        }\n\n        public emitJavascriptClass(classDecl: ClassDeclaration) {\n            if (!hasFlag(classDecl.varFlags, VarFlags.Ambient)) {\n                var svClassNode = this.thisClassNode;\n                var i = 0;\n                this.thisClassNode = classDecl;\n                var className = classDecl.name.actualText;\n                this.emitParensAndCommentsInPlace(classDecl, true);\n                var temp = this.setContainer(EmitContainer.Class);\n\n                this.recordSourceMappingStart(classDecl);\n                if (hasFlag(classDecl.varFlags, VarF',
v27639=v27640+'lags.Exported) && classDecl.type.symbol.container == this.checker.gloMod) {\n                    this.writeToOutput("this." + className);\n                }\n                else {\n                    this.writeToOutput("var " + className);\n                }\n\n                //if (hasFlag(classDecl.varFlags, VarFlags.Exported) && (temp == EmitContainer.Module || temp == EmitContainer.DynamicModule)) {\n                //    var modName = temp == EmitContainer.Module ? this.moduleName : "exports";\n                //    this.writeToOutput(" = " + modName + "." + className);\n                //}\n\n                var hasBaseClass = classDecl.extendsList && classDecl.extendsList.members.length;\n                var baseNameDecl: AST = null;\n                var baseName: AST = null;\n\n                if (hasBaseClass) {\n                    this.writeLineToOutput(" = (function (_super) {");\n                } else {\n                    this.writeLineToOutput(" = (function () {");\n                }\n\n                this.recordSourceMappingNameStart(className);\n                this.indenter.increaseIndent();\n\n                if (hasBaseClass) {\n                    baseNameDecl = classDecl.extendsList.members[0];\n                    baseName = baseNameDecl.nodeType == NodeType.Call ? (<CallExpression>baseNameDecl).target : baseNameDecl;\n                    this.emitIndent();\n                    this.writeLineToOutput("__extends(" + className + ", _super);");\n                }\n\n                this.emitIndent();\n\n                var constrDecl = classDecl.constructorDecl;\n\n                // output constructor\n                if (constrDecl) {\n                    // declared constructor\n                    this.emitJavascript(classDecl.constructorDecl, TokenID.OpenParen, false);\n\n                }\n                else {\n                    var wroteProps = 0;\n\n                    this.recordSourceMappingStart(classDecl);\n                    // default constructor\n                    this.indenter.increaseIndent();\n                    this.writeToOutput("function " + classDecl.name.actualText + "() {");\n                    this.recordSourceMappingNameStart("constructor");\n                    if (hasBaseClass) {\n                        this.writeLineToOutput("");\n                        this.emitIndent();\n                        this.writeLineToOutput("_super.apply(this, arguments);");\n                        wroteProps++;\n                    }\n\n                    if (classDecl.varFlags & VarFlags.MustCaptureThis) {\n                        this.writeCaptureThisStatement(classDecl);\n                    }\n\n                    var members = (<ASTList>this.thisClassNode.members).members\n\n                    // output initialized properties\n                    for (var i = 0; i < members.length; i++) {\n                        if (members[i].nodeType == NodeType.VarDecl) {\n                            var varDecl = <VarDecl>members[i];\n                            if (!hasFlag(varDecl.varFlags, VarFlags.Static) && varDecl.init) {\n                                this.writeLineToOutput("");\n                                this.emitIndent();\n                                this.emitJavascriptVarDecl(varDecl, TokenID.Tilde);\n                                wroteProps++;\n                            }\n                        }\n                    }\n                    if (wroteProps) {\n                        this.writeLineToOutput("");\n                        this.indenter.decreaseIndent();\n                        this.emitIndent();\n                        this.writeLineToOutput("}");\n                    }\n                    else {\n                        this.writeLineToOutput(" }");\n                        this.indenter.decreaseIndent();\n                    }\n                    this.recordSourceMappingNameEnd();\n                    this.recordSourceMappingEnd(classDecl);\n                }\n\n                var membersLen = classDecl.members.members.length;\n                for (var j = 0; j < membersLen; j++) {\n\n                    var memberDecl: AST = classDecl.members.members[j];\n\n                    if (memberDecl.nodeType == NodeType.FuncDecl) {\n                        var fn = <FuncDecl>memberDecl;\n\n                        if (hasFlag(fn.fncFlags, FncFlags.Method) && !fn.isSignature()) {\n                            if (!hasFlag(fn.fncFlags, FncFlags.Static)) {\n                                this.emitPrototypeMember(fn, className);\n                            }\n                            else { // static functions\n                                if (fn.isAccessor()) {\n                                    this.emitPropertyAccessor(fn, this.thisClassNode.name.actualText, false);\n                                }\n                                else {\n                                    this.emitIndent();\n                                    this.recordSourceMappingStart(fn)\n                                    this.writeToOutput(classD',
v27638=v27639+'ecl.name.actualText + "." + fn.name.actualText + " = ");\n                                    this.emitInnerFunction(fn, (fn.name && !fn.name.isMissing()), true,\n                                            null, Emitter.shouldCaptureThis(fn), null);\n                                    this.writeLineToOutput(";");\n                                }\n                            }\n                        }\n                    }\n                    else if (memberDecl.nodeType == NodeType.VarDecl) {\n                        var varDecl = <VarDecl>memberDecl;\n                        if (hasFlag(varDecl.varFlags, VarFlags.Static)) {\n\n                            if (varDecl.init) {\n                                // EMITREVIEW\n                                this.emitIndent();\n                                this.recordSourceMappingStart(varDecl);\n                                this.writeToOutput(classDecl.name.actualText + "." + varDecl.id.actualText + " = ");\n                                this.emitJavascript(varDecl.init, TokenID.Equals, false);\n                                // EMITREVIEW\n\n                                this.writeLineToOutput(";");\n                                this.recordSourceMappingEnd(varDecl);\n                            }\n                        }\n                    }\n                    else {\n                        throw Error("We want to catch this");\n                    }\n                }\n\n                this.emitIndent();\n                this.recordSourceMappingStart(classDecl.endingToken);\n                this.writeLineToOutput("return " + className + ";");\n                this.recordSourceMappingEnd(classDecl.endingToken);\n                this.indenter.decreaseIndent();\n                this.emitIndent();\n                this.recordSourceMappingStart(classDecl.endingToken);\n                this.writeToOutput("}");\n                this.recordSourceMappingNameEnd();\n                this.recordSourceMappingEnd(classDecl.endingToken);\n                this.recordSourceMappingStart(classDecl);\n                this.writeToOutput(")(");\n                if (hasBaseClass)\n                    this.emitJavascript(baseName, TokenID.Tilde, false);\n                this.writeToOutput(");");\n                this.recordSourceMappingEnd(classDecl);\n\n                if ((temp == EmitContainer.Module || temp == EmitContainer.DynamicModule) && hasFlag(classDecl.varFlags, VarFlags.Exported)) {\n                    this.writeLineToOutput("");\n                    this.emitIndent();\n                    var modName = temp == EmitContainer.Module ? this.moduleName : "exports";\n                    this.recordSourceMappingStart(classDecl);\n                    this.writeToOutput(modName + "." + className + " = " + className + ";");\n                    this.recordSourceMappingEnd(classDecl);\n                }\n\n                this.emitIndent();\n                this.recordSourceMappingEnd(classDecl);\n                this.emitParensAndCommentsInPlace(classDecl, false);\n                this.setContainer(temp);\n                this.thisClassNode = svClassNode;\n            }\n        }\n\n        public emitPrologue(reqInherits: bool) {\n            if (!this.prologueEmitted) {\n                if (reqInherits) {\n                    this.prologueEmitted = true;\n                    this.writeLineToOutput("var __extends = this.__extends || function (d, b) {");\n                    this.writeLineToOutput("    function __() { this.constructor = d; }");\n                    this.writeLineToOutput("    __.prototype = b.prototype;");\n                    this.writeLineToOutput("    d.prototype = new __();");\n                    this.writeLineToOutput("};");\n                }\n                if (this.checker.mustCaptureGlobalThis) {\n                    this.prologueEmitted = true;\n                    this.writeLineToOutput(this.captureThisStmtString);\n                }\n            }\n        }\n\n        public emitSuperReference() {\n            this.writeToOutput("_super.prototype");\n        }\n\n        public emitSuperCall(callEx: CallExpression): bool {\n            if (callEx.target.nodeType == NodeType.Dot) {\n                var dotNode = <BinaryExpression>callEx.target;\n                if (dotNode.operand1.nodeType == NodeType.Super) {\n                    this.emitJavascript(dotNode, TokenID.OpenParen, false);\n                    this.writeToOutput(".call(");\n                    this.emitThis();\n                    if (callEx.arguments && callEx.arguments.members.length > 0) {\n                        this.writeToOutput(", ");\n                        this.emitJavascriptList(callEx.arguments, ", ", TokenID.Comma, false, false, false);\n                    }\n                    this.writeToOutput(")");\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        public emitThis() {\n            if (this.thisFnc && !this.thisFnc.isMethod() && (!this.thisFnc.isConstructor)) {\n          ',
v27637=v27638+'      this.writeToOutput("_this");\n            }\n            else {\n                this.writeToOutput("this");\n            }\n        }\n\n        private static shouldCaptureThis(func: FuncDecl): bool {\n            // Super calls use \'this\' reference. If super call is in a lambda, \'this\' value needs to be captured in the parent.\n            return func.hasSelfReference() || func.hasSuperReferenceInFatArrowFunction();\n        }\n\n        private createFile(fileName: string, useUTF8: bool): ITextWriter {\n            try {\n                return this.emitOptions.ioHost.createFile(fileName, useUTF8);\n            } catch (ex) {\n                this.errorReporter.emitterError(null, ex.message);\n            }\n        }\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export interface ILineCol {\n        line: number;\n        col: number;\n    }\n\n    export class ErrorReporter {\n        public parser: Parser = null;\n        public checker: TypeChecker = null;\n        public lineCol = { line: 0, col: 0 };\n        public emitAsComments = true;\n        public hasErrors = false;\n        public pushToErrorSink = false;\n        public errorSink: string[] = [];\n\n        constructor (public outfile: ITextWriter) { }\n\n        public getCapturedErrors() { return this.errorSink; }\n        public freeCapturedErrors() { this.errorSink = []; }\n        public captureError(emsg: string) { this.errorSink[this.errorSink.length] = emsg; }\n\n        public setErrOut(outerr) {\n            this.outfile = outerr;\n            this.emitAsComments = false;\n        }\n\n        public emitPrefix() {\n            if (this.emitAsComments) {\n                this.outfile.Write("// ");\n            }\n            this.outfile.Write(this.checker.locationInfo.filename + "(" + this.lineCol.line + "," + this.lineCol.col + "): ");\n        }\n\n        public writePrefix(ast: AST): void {\n            if (ast) {\n                this.setError(ast);\n            }\n            else {\n                this.lineCol.line = 0;\n                this.lineCol.col = 0;\n            }\n            this.emitPrefix();\n        }\n\n        public writePrefixFromSym(symbol: Symbol): void {\n            if (symbol && this.checker.locationInfo.lineMap) {\n                getSourceLineColFromMap(this.lineCol, symbol.location,\n                                        this.checker.locationInfo.lineMap);\n            }\n            else {\n                this.lineCol.line = -1;\n                this.lineCol.col = -1;\n            }\n            this.emitPrefix();\n        }\n\n        public setError(ast: AST) {\n            if (ast) {\n                ast.flags |= ASTFlags.Error;\n                if (this.checker.locationInfo.lineMap) {\n                    getSourceLineColFromMap(this.lineCol, ast.minChar, this.checker.locationInfo.lineMap);\n                }\n            }\n        }\n\n        public reportError(ast: AST, message: string) {\n            if (this.pushToErrorSink) {\n                this.captureError(message);\n                return;\n            }\n\n            this.hasErrors = true;\n            if (ast && this.parser.errorRecovery && this.parser.errorCallback) {\n                var len = (ast.limChar - ast.minChar);\n                this.parser.errorCallback(ast.minChar, len, message, this.checker.locationInfo.unitIndex);\n            }\n            else {\n                this.writePrefix(ast);\n                this.outfile.WriteLine(message); // Right after the semi-colon\n            }\n        }\n\n        public reportErrorFromSym(symbol: Symbol, message: string) {\n            if (this.pushToErrorSink) {\n                this.captureError(message);\n                return;\n            }\n\n            this.hasErrors = true;\n            if (this.parser.errorRecovery && this.parser.errorCallback) {\n                this.parser.errorCallback(symbol.location, symbol.length, message, this.checker.locationInfo.unitIndex);\n            }\n            else {\n                this.writePrefixFromSym(symbol);\n                this.outfile.WriteLine(message);\n            }\n        }\n\n        public emitterError(ast: AST, message: string) {\n            this.reportError(ast, message);\n            // Emitter errors are not recoverable, stop immediately\n            throw Error("EmitError");\n        }\n\n        public duplicateIdentifier(ast: AST, name: string) {\n            this.reportError(',
v27636=v27637+'ast, "Duplicate identifier \'" + name + "\'");\n        }\n\n        public showRef(ast: AST, text: string, symbol: Symbol) {\n            var defLineCol = { line: -1, col: -1 };\n            // TODO: multiple def locations\n            this.parser.getSourceLineCol(defLineCol, symbol.location);\n            this.reportError(ast, "symbol " + text + " defined at (" + defLineCol.line + "," +\n                              defLineCol.col + ")");\n        }\n\n        public unresolvedSymbol(ast: AST, name: string) {\n            this.reportError(ast, "The name \'" + name + "\' does not exist in the current scope");\n        }\n\n        public symbolDoesNotReferToAValue(ast: AST, name: string): void {\n            this.reportError(ast, "The name \'" + name + "\' does not refer to a value");\n        }\n\n        public styleError(ast: AST, msg: string): void {\n            var bkThrow = this.pushToErrorSink;\n            this.pushToErrorSink = false;\n            this.reportError(ast, "STYLE: " + msg);\n            this.pushToErrorSink = bkThrow;\n        }\n\n        public simpleError(ast: AST, msg: string): void {\n            this.reportError(ast, msg);\n        }\n\n        public simpleErrorFromSym(sym: Symbol, msg: string): void {\n            this.reportErrorFromSym(sym, msg);\n        }\n\n        public invalidSuperReference(ast: AST) {\n            this.simpleError(ast, "Keyword \'super\' can only be used inside a class instance method");\n        }\n\n        public valueCannotBeModified(ast: AST) {\n            this.simpleError(ast, "The left-hand side of an assignment expression must be a variable, property or indexer");\n        }\n\n        public invalidCall(ast: CallExpression, nodeType: number, scope: SymbolScope): void {\n            var targetType = ast.target.type;\n            var typeName = targetType.getScopedTypeName(scope);\n            if (targetType.construct && (nodeType == NodeType.Call)) {\n                this.reportError(ast, "Value of type \'" + typeName + "\' is not callable.  Did you mean to include \'new\'?");\n            } else {\n                var catString = (nodeType == NodeType.Call) ? "callable" : "newable";\n\n                this.reportError(ast, "Value of type \'" + typeName + "\' is not " + catString);\n            }\n        }\n\n        public indexLHS(ast: BinaryExpression, scope: SymbolScope): void {\n            var targetType = ast.operand1.type.getScopedTypeName(scope);\n            var indexType = ast.operand2.type.getScopedTypeName(scope);\n            this.simpleError(ast, "Value of type \'" + targetType + "\' is not indexable by type \'" + indexType + "\'");\n        }\n\n        public incompatibleTypes(ast: AST, t1: Type, t2: Type, op: string, scope: SymbolScope, comparisonInfo?:TypeComparisonInfo) {\n            if (!t1) {\n                t1 = this.checker.anyType;\n            }\n            if (!t2) {\n                t2 = this.checker.anyType;\n            }\n\n            var reason = comparisonInfo ? comparisonInfo.message : "";\n            if (op) {\n                this.reportError(ast, "Operator \'" + op + "\' cannot be applied to types \'" + t1.getScopedTypeName(scope) +\n                                  "\' and \'" + t2.getScopedTypeName(scope) + "\'" + (reason ? ": " + reason : ""));\n            }\n            else {\n                this.reportError(ast, "Cannot convert \'" + t1.getScopedTypeName(scope) +\n                                  "\' to \'" + t2.getScopedTypeName(scope) + "\'" + (reason ? ": " + reason : ""));\n            }\n        }\n\n        public expectedClassOrInterface(ast: AST): void {\n            this.simpleError(ast, "Expected var, class, interface, or module");\n        }\n\n        public unaryOperatorTypeError(ast: AST, op: string, type: Type) {\n            this.reportError(ast, "Operator \'" + op + "\' cannot be applied to type \'" + type.getTypeName() + "\'");\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export function hasFlag(val: number, flag: number) {\n        return (val & flag) != 0;\n    }\n\n    export enum ErrorRecoverySet {\n        None = 0,\n        Comma = 1, // Comma\n        SColon = 1 << 1, // SColon\n        Asg = 1 << 2, // Asg\n        BinOp = 1 << 3, // Lsh, Rsh, Rs2, Le, Ge, INSTANCEOF, EQ, NE, Eqv, NEqv, LogAnd, LogOr, AsgMul, AsgDiv\n        // AsgMod, AsgAdd, AsgSub, AsgLsh, AsgRsh, AsgRs2, AsgAnd, AsgXor, AsgOr, QMark, Mult, Div, \n        // Pct, GT, LT, ',
v27635=v27636+"And, Xor, Or\n        RBrack = 1 << 4, // RBrack\n        RCurly = 1 << 5, // RCurly\n        RParen = 1 << 6, // RParen\n        Dot = 1 << 7, // Dot\n        Colon = 1 << 8, // Colon\n        PrimType = 1 << 9, // number, string, bool\n        AddOp = 1 << 10, // Add, Sub\n        LCurly = 1 << 11, // LCurly\n        PreOp = 1 << 12, // Tilde, Bang, Inc, Dec\n        RegExp = 1 << 13, // RegExp\n        LParen = 1 << 14, // LParen\n        LBrack = 1 << 15, // LBrack\n        Scope = 1 << 16, // Scope\n        In = 1 << 17, // IN\n        SCase = 1 << 18, // CASE, DEFAULT\n        Else = 1 << 19, // ELSE\n        Catch = 1 << 20, // CATCH, FINALLY\n        Var = 1 << 21, // \n        Stmt = 1 << 22, // BREAK, RETURN, THROW, DEBUGGER, FOR, SWITCH, DO, IF, TRY, WITH\n        While = 1 << 23, // WHILE\n        ID = 1 << 24, // ID\n        Prefix = 1 << 25, // VOID, DELETE, TYPEOF, AWAIT\n        Literal = 1 << 26, // IntCon, FltCon, StrCon\n        RLit = 1 << 27, // THIS, TRUE, FALSE, NULL\n        Func = 1 << 28, // FUNCTION\n        EOF = 1 << 29, // EOF\n\n        // REVIEW: Name this something clearer.\n        TypeScriptS = 1 << 30, // PROPERTY, PRIVATE, STATIC, INTERFACE, CLASS, MODULE, EXPORT, IMPORT\n        ExprStart = SColon | AddOp | LCurly | PreOp | RegExp | LParen | LBrack | ID | Prefix | RLit | Func | Literal,\n        StmtStart = ExprStart | SColon | Var | Stmt | While | TypeScriptS,\n        Postfix = Dot | LParen | LBrack,\n    }\n\n    export enum AllowedElements {\n        None = 0,\n        ModuleDeclarations = 1 << 2,\n        ClassDeclarations = 1 << 3,\n        InterfaceDeclarations = 1 << 4,\n        AmbientDeclarations = 1 << 10,\n        Properties = 1 << 11,\n\n        Global = ModuleDeclarations | ClassDeclarations | InterfaceDeclarations | AmbientDeclarations,\n        QuickParse = Global | Properties,\n    }\n\n    export enum Modifiers {\n        None = 0,\n        Private = 1,\n        Public = 1 << 1,\n        Readonly = 1 << 2,\n        Ambient = 1 << 3,\n        Exported = 1 << 4,\n        Getter = 1 << 5,\n        Setter = 1 << 6,\n        Static = 1 << 7,\n    }\n\n    export enum ASTFlags {\n        None = 0,\n        ExplicitSemicolon = 1, // statment terminated by an explicit semicolon\n        AutomaticSemicolon = 1 << 1, // statment terminated by an automatic semicolon\n        Writeable = 1 << 2,  // node is lhs that can be modified\n        Error = 1 << 3, // node has an error\n        DotLHSPartial = 1 << 4, // node is the lhs of an incomplete dot expr at cursor\n        DotLHS = 1 << 5, // node is the lhs of a dot expr\n        IsStatement = 1 << 6, // node is a statement\n        StrictMode = 1 << 7, // node is in the strict mode environment\n        PossibleOptionalParameter = 1 << 8,\n        ClassBaseConstructorCall = 1 << 9,\n        OptionalName = 1 << 10,\n        // REVIEW: This flag is to mark lambda nodes to note that the LParen of an expression has already been matched in the lambda header.\n        //         The flag is used to communicate this piece of information to the calling parseTerm, which intern will remove it.\n        //         Once we have a better way to associate information with nodes, this flag should not be used.\n        SkipNextRParen = 1 << 11, \n    }\n\n    export enum DeclFlags {\n        None = 0,\n        Exported = 1,\n        Private = 1 << 1,\n        Public = 1 << 2,\n        Ambient = 1 << 3,\n        Static = 1 << 4,\n        LocalStatic = 1 << 5,\n        GetAccessor = 1 << 6,\n        SetAccessor = 1 << 7,\n    }\n\n    export enum ModuleFlags {\n        None = 0,\n        Exported = 1,\n        Private = 1 << 1,\n        Public = 1 << 2,\n        Ambient = 1 << 3,\n        Static = 1 << 4,\n        LocalStatic = 1 << 5,\n        GetAccessor = 1 << 6,\n        SetAccessor = 1 << 7,\n        IsEnum = 1 << 8,\n        ShouldEmitModuleDecl = 1 << 9,\n        IsWholeFile = 1 << 10,\n        IsDynamic = 1 << 11,\n        MustCaptureThis = 1 << 12,\n    }\n\n    export enum SymbolFlags {\n        None = 0,\n        Exported = 1,\n        Private = 1 << 1,\n        Public = 1 << 2,\n        Ambient = 1 << 3,\n        Static = 1 << 4,\n        LocalStatic = 1 << 5,\n        GetAccessor = 1 << 6,\n        SetAccessor = 1 << 7,\n        Property = 1 << 8,\n        Readonly = 1 << 9,\n        ModuleMember = 1 << 10,\n        InterfaceMember = 1 << 11,\n        ClassMember = 1 << 12,\n        BuiltIn = 1 << 13,\n        TypeSetDuringScopeAssignment = 1 << 14,\n        Constant = 1 << 15,\n        Optional = 1 << 16,\n        RecursivelyReferenced = 1 << 17,\n        Bound = 1 << 18,\n        CompilerGenerated = 1 << 19,\n    }\n\n    export enum VarFlags {\n        None = 0,\n        Exported = 1,\n        Private = 1 << 1,\n        Public = 1 << 2,\n        Ambient = 1 << 3,\n        Static = 1 << 4,\n        LocalStatic = 1 << 5,\n        GetAccessor = 1 << 6,\n        SetAccessor = 1 << 7,\n        AutoInit = 1 << 8,\n        Property = 1 << 9,\n        Readonly = 1 << 10,\n        Class = 1 << 11,\n        ClassProperty = 1 << 12,\n        ClassBodyProperty = 1 << 13,",
v27634=v27635+'\n        ClassConstructorProperty = 1 << 14,\n        ClassSuperMustBeFirstCallInConstructor = 1 << 15,\n        Constant = 1 << 16,\n        MustCaptureThis = 1 << 17,\n    }\n\n    export enum FncFlags {\n        None = 0,\n        Exported = 1,\n        Private = 1 << 1,\n        Public = 1 << 2,\n        Ambient = 1 << 3,\n        Static = 1 << 4,\n        LocalStatic = 1 << 5,\n        GetAccessor = 1 << 6,\n        SetAccessor = 1 << 7,\n        Definition = 1 << 8,\n        Signature = 1 << 9,\n        Method = 1 << 10,\n        HasReturnExpression = 1 << 11,\n        CallMember = 1 << 12,\n        ConstructMember = 1 << 13,\n        HasSelfReference = 1 << 14,\n        IsFatArrowFunction = 1 << 15,\n        IndexerMember = 1 << 16,\n        IsFunctionExpression = 1 << 17,\n        ClassMethod = 1 << 18,\n        ClassPropertyMethodExported = 1 << 19,\n        HasSuperReferenceInFatArrowFunction = 1 << 20,\n        IsPropertyBound = 1 << 21,\n    }\n\n    export enum SignatureFlags {\n        None = 0,\n        IsIndexer = 1,\n        IsStringIndexer = 1 << 1,\n        IsNumberIndexer = 1 << 2,\n    }\n\n    export function ToDeclFlags(fncFlags: FncFlags) : DeclFlags;\n    export function ToDeclFlags(varFlags: VarFlags) : DeclFlags;\n    export function ToDeclFlags(symFlags: SymbolFlags): DeclFlags;\n    export function ToDeclFlags(moduleFlags: ModuleFlags): DeclFlags;\n    export function ToDeclFlags(fncOrVarOrSymbolOrModuleFlags: any) {\n        return <DeclFlags>fncOrVarOrSymbolOrModuleFlags;\n    }\n\n    export enum TypeFlags {\n        None = 0,\n        HasImplementation = 1,\n        HasSelfReference = 1 << 1,\n        MergeResult = 1 << 2,\n        IsEnum = 1 << 3,\n        BuildingName = 1 << 4,\n        HasBaseType = 1 << 5,\n        HasBaseTypeOfObject = 1 << 6,\n        IsClass = 1 << 7,\n    }\n\n    export enum TypeRelationshipFlags {\n        SuccessfulComparison = 0,\n        SourceIsNullTargetIsVoidOrUndefined = 1,\n        RequiredPropertyIsMissing = 1 << 1,\n        IncompatibleSignatures = 1 << 2,\n        SourceSignatureHasTooManyParameters = 3,\n        IncompatibleReturnTypes = 1 << 4,\n        IncompatiblePropertyTypes = 1 << 5,\n        IncompatibleParameterTypes = 1 << 6,\n    }\n\n    export enum CodeGenTarget {\n        ES3 = 0,\n        ES5 = 1,\n    }\n\n    export enum ModuleGenTarget {\n        Synchronous = 0,\n        Asynchronous = 1,\n        Local = 1 << 1,\n    }\n\n    // Compiler defaults to generating ES5-compliant code for\n    //  - getters and setters\n    export var codeGenTarget: CodeGenTarget = CodeGenTarget.ES3;\n\n    export var moduleGenTarget: ModuleGenTarget = ModuleGenTarget.Synchronous;\n\n    export var optimizeModuleCodeGen = true;\n\n    export function flagsToString(e, flags: number): string {\n        var builder = "";\n        for (var i = 1; i < (1 << 31) ; i = i << 1) {\n            if ((flags & i) != 0) {\n                for (var k in e) {\n                    if (e[k] == i) {\n                        if (builder.length > 0) {\n                            builder += "|";\n                        }\n                        builder += k;\n                        break;\n                    }\n                }\n            }\n        }\n        return builder;\n    }\n\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export class BlockIntrinsics {\n        public prototype = undefined;\n        public toString = undefined;\n        public toLocaleString = undefined;\n        public valueOf = undefined;\n        public hasOwnProperty = undefined;\n        public propertyIsEnumerable = undefined;\n        public isPrototypeOf = undefined;\n\n        constructor () {\n            // initialize the \'constructor\' field\n            this["constructor"] = undefined;\n        }\n    }\n\n    export interface IHashTable {\n        getAllKeys(): string[];\n        add(key: string, data): bool;\n        addOrUpdate(key: string, data): bool;\n        map(fn: (k: string, v, c) => void , context): void;\n        every(fn: (k: string, v, c) => bool, context): bool;\n        some(fn: (k: string, v, c) => bool, context): bool;\n        count(): number;\n        lookup(key: string): any;\n    }\n\n    export class StringHashTable implements IHashTable {\n        public itemCount = 0;\n        public table = <any>(<any> new BlockIntrinsics());\n\n        public getAllKeys(): string[]{\n            var result: string[] = [];\n            for (var k in this.table) {\n ',
v27633=v27634+"               if (this.table[k] != undefined) {\n                    result[result.length] = k;\n                }\n            }\n            return result;\n        }\n\n        public add(key: string, data): bool {\n            if (this.table[key] != undefined) {\n                return false;\n            }\n            this.table[key] = data;\n            this.itemCount++;\n            return true;\n        }\n\n        public addOrUpdate(key: string, data): bool {\n            if (this.table[key] != undefined) {\n                this.table[key] = data;\n                return false;\n            }\n            this.table[key] = data;\n            this.itemCount++;\n            return true;\n        }\n\n        public map(fn: (k: string, v, c) => void , context) {\n            for (var k in this.table) {\n                var data = this.table[k];\n                if (data != undefined) {\n                    fn(k, this.table[k], context);\n                }\n            }\n        }\n\n        public every(fn: (k: string, v, c) => bool, context) {\n            for (var k in this.table) {\n                var data = this.table[k];\n                if (data != undefined) {\n                    if (!fn(k, this.table[k], context)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n\n        public some(fn: (k: string, v, c) => bool, context) {\n            for (var k in this.table) {\n                var data = this.table[k];\n                if (data != undefined) {\n                    if (fn(k, this.table[k], context)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        public count(): number { return this.itemCount; }\n\n        public lookup(key: string) {\n            var data = this.table[key];\n            if (data != undefined) {\n                return data;\n            }\n            else {\n                return (null);\n            }\n        }\n    }\n\n    // The resident table is expected to reference the same table object, whereas the \n    // transientTable may reference different objects over time\n    // REVIEW:  WARNING:  For performance reasons, neither the primary nor secondary table may be null\n    export class DualStringHashTable implements IHashTable {\n\n        public insertPrimary = true;\n\n        constructor (public primaryTable: IHashTable,\n                                        public secondaryTable: IHashTable) { }\n\n        public getAllKeys(): string[]{\n            return this.primaryTable.getAllKeys().concat(this.secondaryTable.getAllKeys());\n        }\n\n        public add(key: string, data): bool {\n            if (this.insertPrimary) {\n                return this.primaryTable.add(key, data);\n            }\n            else {\n                return this.secondaryTable.add(key, data);\n            }\n        }\n\n        public addOrUpdate(key: string, data): bool {\n            if (this.insertPrimary) {\n                return this.primaryTable.addOrUpdate(key, data);\n            }\n            else {\n                return this.secondaryTable.addOrUpdate(key, data);\n            }\n        }\n\n        public map(fn: (k: string, v, c) => void , context) {\n            this.primaryTable.map(fn, context);\n            this.secondaryTable.map(fn, context);\n        }\n\n        public every(fn: (k: string, v, c) => bool, context) {\n            return this.primaryTable.every(fn, context) && this.secondaryTable.every(fn, context);\n        }\n\n        public some(fn: (k: string, v, c) => bool, context) {\n            return this.primaryTable.some(fn, context) || this.secondaryTable.some(fn, context);\n        }\n\n        public count() {\n            return this.primaryTable.count() + this.secondaryTable.count();\n        }\n\n        public lookup(key: string) {\n            var data = this.primaryTable.lookup(key);\n            if (data != undefined) {\n                return data;\n            }\n            else {\n                return this.secondaryTable.lookup(key);\n            }\n        }\n    }\n\n    export function numberHashFn(key: number): number {\n        var c2 = 0x27d4eb2d; // a prime or an odd constant\n        key = (key ^ 61) ^ (key >>> 16);\n        key = key + (key << 3);\n        key = key ^ (key >>> 4);\n        key = key * c2;\n        key = key ^ (key >>> 15);\n        return key;\n    }\n\n    export function combineHashes(key1: number, key2: number) {\n        return key2 ^ ((key1 >> 5) + key1);\n    }\n\n    export class HashEntry {\n        public next: HashEntry;\n\n        constructor (public key, public data) { }\n    }\n\n    export class HashTable {\n        public itemCount: number = 0;\n        public table = new HashEntry[];\n\n        constructor (public size: number, public hashFn: (key) =>number,\n                    public equalsFn: (key1, key2) =>bool) {\n            for (var i: number = 0; i < this.size; i++) {\n                this.table[i] = null;\n            }\n        }\n\n        publi",
v27632=v27633+'c add(key, data): bool {\n            var current: HashEntry;\n            var entry: HashEntry = new HashEntry(key, data);\n            var val: number = this.hashFn(key);\n            val = val % this.size;\n\n            for (current = this.table[val]; current != null ; current = current.next) {\n                if (this.equalsFn(key, current.key)) {\n                    return false;\n                }\n            }\n            entry.next = this.table[val];\n            this.table[val] = entry;\n            this.itemCount++;\n            return true;\n        }\n\n        public remove(key) {\n            var current: HashEntry;\n            var val: number = this.hashFn(key);\n            val = val % this.size;\n            var result = null;\n            var prevEntry: HashEntry = null;\n\n            for (current = this.table[val]; current != null ; current = current.next) {\n                if (this.equalsFn(key, current.key)) {\n                    result = current.data;\n                    this.itemCount--;\n                    if (prevEntry) {\n                        prevEntry.next = current.next;\n                    }\n                    else {\n                        this.table[val] = current.next;\n                    }\n                    break;\n                }\n                prevEntry = current;\n            }\n            return result;\n        }\n\n        public count(): number { return this.itemCount; }\n\n        public lookup(key) {\n            var current: HashEntry;\n            var val: number = this.hashFn(key);\n            val = val % this.size;\n            for (current = this.table[val]; current != null ; current = current.next) {\n                if (this.equalsFn(key, current.key)) {\n                    return (current.data);\n                }\n            }\n            return (null);\n        }\n    }\n\n    // Simple Hash table with list of keys and values matching each other at the given index\n    export class SimpleHashTable {\n        private keys = [];\n        private values = [];\n\n        public lookup(key, findValue?: bool) {\n            var searchArray = this.keys;\n            if (findValue) {\n                searchArray = this.values;\n            }\n\n            for (var i = 0; i < searchArray.length; i++) {\n                if (searchArray[i] == key) {\n                    return {\n                        key: this.keys[i],\n                        data: this.values[i],\n                    };\n                }\n            }\n            return null;\n        }\n\n        public add(key, data): bool {\n            var lookupData = this.lookup(key);\n            if (lookupData) {\n                return false;\n            }\n\n            this.keys[this.keys.length] = key;\n            this.values[this.values.length] = data;\n\n            return true;\n        }\n    }\n\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export class IncrementalParser {\n        \n        private astLogger: AstLogger;\n\n        constructor (private logger: TypeScript.ILogger) {\n            this.astLogger = new AstLogger(this.logger);\n        }\n\n        //\n        // Return "null" if "editRange" cannot be safely determined to be inside a single scope.\n        //\n        public getEnclosingScopeContextIfSingleScopeEdit(previousScript: Script, scriptId: string, newSourceText: ISourceText, editRange: ScriptEditRange): EnclosingScopeContext {\n            this.logger.log("checkEditsInsideSingleScope(\\"" + scriptId + "\\")");\n\n            if (editRange === null) {\n                throw new Error("editRange should be valid");\n            }\n\n            if (editRange.isUnknown()) {\n                this.logger.log("  Bailing out because edit range is unknown");\n                return null;\n            }\n\n            var scope1 = TypeScript.findEnclosingScopeAt(this.logger, previousScript, newSourceText, editRange.minChar, false/*isMemberCompletion*/);\n            var scope2 = TypeScript.findEnclosingScopeAt(this.logger, previousScript, newSourceText, editRange.limChar, false/*isMemberCompletion*/);\n            if (scope1 == null || scope2 == null) {\n                this.logger.log("  Bailing out because containing scopes cannot be determined");\n                return null;\n            }\n\n            // We only support changes within a single containing scope\n            if (scope1.scopeStartAST !== scope2.scopeStartAST) {\n      ',
v27631=v27632+'          this.logger.log("  Bailing out because edit overlaps 2 disctint scopes");\n                return null;\n            }\n\n            var newScopeLength = scope1.scopeStartAST.limChar - scope1.scopeStartAST.minChar + editRange.delta;\n            if (newScopeLength <= 0) {\n                this.logger.log("  Bailing out because scope has been entirely removed from new source text");\n                return null;\n            }\n\n            return scope1;\n        }\n\n        public attemptIncrementalUpdateUnit(previousScript: Script, scriptId: string, newSourceText: ISourceText, editRange: ScriptEditRange): UpdateUnitResult {\n            this.logger.log("attemptIncrementalUpdateUnit(\\"" + scriptId + "\\")");\n\n            if (editRange === null) {\n                throw new Error("editRange should be valid");\n            }\n\n            var scope1 = this.getEnclosingScopeContextIfSingleScopeEdit(previousScript, scriptId, newSourceText, editRange);\n            if (scope1 === null) {\n                return null;\n            }\n\n            var newScopeLength = scope1.scopeStartAST.limChar - scope1.scopeStartAST.minChar + editRange.delta;\n\n            // Heuristic: if the range to reparse is too big, bail out. \n            // This is because a full parse will be faster than an incremental parse followed by all the necessary fix-ups \n            if (newScopeLength >= newSourceText.getLength() / 2) {\n                this.logger.log("  Bailing out because range of scope to reparse (" + newScopeLength + " characters) is greater than half the size of the source text");\n                return null;\n            }\n\n            // Capture parsing errors so that they are part of "updateResult"\n            var parseErrors: TypeScript.ErrorEntry[] = [];\n            var errorCapture = function(minChar: number, charLen: number, message: string, unitIndex: number): void {\n                parseErrors.push(new TypeScript.ErrorEntry(unitIndex, minChar, minChar + charLen, message));\n            };\n\n            var quickParseResult = TypeScript.quickParse(this.logger, scope1.scopeStartAST, newSourceText, scope1.scopeStartAST.minChar, scope1.scopeStartAST.minChar + newScopeLength, errorCapture);\n            if (quickParseResult.endLexState != TypeScript.LexState.Start) {\n                this.logger.log("  Bailing out because scope contains unterminated comment");\n                return null;\n            }\n\n            var scriptFragment = quickParseResult.Script;\n            if (scriptFragment.vars.members.length !== 0) {\n                this.logger.log("  Bailing out because new source text defines variables");\n                return null;\n            }\n\n            //if (scriptFragment.scopes.members.length !== 1) {\n            //    logger.log("  Bailing out because new source text defines more than one scope (or none)");\n            //    return null;\n            //}\n\n            // This detects adding close curlies, since they have the side effect of having the parser \n            // parse more members in the scope range.\n            if (scriptFragment.bod.members.length !== 1) {\n                this.logger.log("  Bailing out because new source text defines more than one scope (or none)");\n                return null;\n            }\n\n            var oldScope = scope1.scopeStartAST;\n            var newScope = scriptFragment.bod.members[0];\n\n            if (oldScope.nodeType != newScope.nodeType) {\n                this.logger.log("  Bailing out because new source text does not define the same scope type as the existing scope");\n                return null;\n            }\n\n            if (!(<any>oldScope).leftCurlyCount || !(<any>oldScope).rightCurlyCount) {\n                this.logger.log("  Bailing out because sopce doesn\'t have left/right curly count");\n                return null;\n            }\n\n            if ((<any>oldScope).leftCurlyCount !== (<any>newScope).leftCurlyCount) {\n                this.logger.log("  Bailing out because new source text contains more (or fewer) left curly braces");\n                return null;\n            }\n\n            if ((<any>oldScope).rightCurlyCount !== (<any>newScope).rightCurlyCount) {\n                this.logger.log("  Bailing out because new source text contains more (or fewer) right curly braces");\n                return null;\n            }\n\n            if (newScope.minChar !== 0) {\n                this.logger.log("  Bailing out because new function declaration does not start at position 0");\n                return null;\n            }\n\n            if (newScope.limChar !== newScopeLength) {\n                this.logger.log("  Bailing out because new function declaration does not end at the new end position");\n                return null;\n            }\n\n            return TypeScript.UpdateUnitResult.singleScopeEdits(previousScript, scriptFragment, oldScope, newScope, editRange, parseErrors);\n        }\n\n        public mergeTrees(updateResult: UpdateUnitResult): void {\n            TypeScript.timeF',
v27630=v27631+'unction(this.logger, "mergeTrees()", () => {\n                var editRange = new ScriptEditRange(updateResult.scope1.minChar, updateResult.scope1.limChar, updateResult.editRange.delta);\n                // Update positions in current ast\n                this.applyDeltaPosition(updateResult.script1, editRange.limChar, editRange.delta);\n                // Update positions in new (partial) ast\n                this.applyDeltaPosition(updateResult.script2, 0, editRange.minChar);\n                // Merge linemaps\n                this.mergeLocationInfo(updateResult.script1, updateResult.script2, editRange);\n                //  Replace old AST for scope with new one\n                this.replaceAST(updateResult.script1, updateResult.scope1, updateResult.scope2);\n            });\n        }\n\n        private replaceAST(script: TypeScript.AST, oldAst: TypeScript.AST, newAst: TypeScript.AST) {\n            var pre = (cur: TypeScript.AST, parent: TypeScript.AST, walker: TypeScript.IAstWalker) => {\n                if (cur === oldAst) {\n                    // Transfer comments ownership to new AST. We need this because when "quick parsing" the\n                    // new AST, we don\'t take into account the text before and after the "minChar/limChar" pair\n                    // of the scope, which don\'t include pre/post-comments.\n                    newAst.preComments = cur.preComments;\n                    newAst.postComments = cur.postComments;\n\n                    this.logger.log("replaced old AST node with new one in script AST");\n                    walker.options.stopWalk();\n                    return newAst;\n                }\n\n                // Avoid visiting sub-trees outside of the edit range\n                if (TypeScript.isValidAstNode(cur)) {\n                    if (cur.limChar < oldAst.minChar || cur.minChar > oldAst.limChar) {\n                        walker.options.goChildren = false;\n                    }\n                }\n                return cur;\n            }\n\n            TypeScript.getAstWalkerFactory().walk(script, pre);\n        }\n\n        private mergeLocationInfo(script: TypeScript.Script, partial: TypeScript.Script, editRange: ScriptEditRange) {\n            // Don\'t merger these fields, as the original script has the right values\n            //script.locationInfo.unitIndex = partial.locationInfo.unitIndex;\n            //script.locationInfo.filename = partial.locationInfo.filename;\n\n            var lineMap1 = script.locationInfo.lineMap;\n            var lineMap2 = partial.locationInfo.lineMap;\n\n            if (this.logger.information()) {\n                this.logger.log("lineMap1 (before):");\n                this.astLogger.logLinemap(lineMap1);\n                this.logger.log("lineMap2 (quick parse):");\n                this.astLogger.logLinemap(lineMap2);\n                this.logger.log("EditRange=" + editRange);\n            }\n\n            // Skip entries < minChar\n            var i1 = 2; // lineMap[0] is always undefined, lineMap[1] is always 0.\n            var i2 = 2; // lineMap[0] is always undefined, lineMap[1] is always 0.\n            var len1 = lineMap1.length;\n            var len2 = lineMap2.length;\n            while (i1 < len1) {\n                if (lineMap1[i1] <= editRange.minChar) {\n                    // Nothing to do for this entry, since it\'s before the range of the change\n                    i1++;\n                } else if (lineMap1[i1] >= editRange.limChar) {\n                    // Apply delta to this entry, since it\'s outside the range of the change\n                    lineMap1[i1] += editRange.delta;\n                    i1++;\n                }\n                else {\n                    if (i2 < len2) {\n                        // Add a new entry to lineMap1 corresponding to lineMap2 in new range\n                        lineMap1.splice(i1, 0, lineMap2[i2] + editRange.minChar);\n                        i1++;\n                        len1++;\n                        i2++;\n                    }\n                    else { /* i2 >= len 2 */\n                        // Remove this entry, since there is no corresponding entry in the new map\n                        lineMap1.splice(i1, 1);\n                        len1--;\n                    }\n                }\n            }\n            // Merge the remaining entries in lineMap2 while maintaing the constraint that a lineMap is sorted\n            if (i2 < len2) {\n                // i1 >= len1 && i2 < len2 \n                if (lineMap1[len1 - 1] >= (lineMap2[i2] + editRange.minChar)) {\n                    // lineMap2 needs to be merged within lineMap1\n                    i1 = 2;\n                    while (i1 < len1 && i2 < len2) {\n                        if (lineMap1[i1] < (lineMap2[i2] + editRange.minChar)) {\n                            i1++;\n                        }\n                        else {\n                            lineMap1.splice(i1, 0, lineMap2[i2] + editRange.minChar);\n                            i1++;\n                            len1++;\n  ',
v27629=v27630+'                          i2++;\n                        }\n                    }\n                }\n\n                // Append all the remaining entries in lineMap2 to the end of lineMap1\n                for (; i2 < len2; i2++) {\n                    lineMap1.push(lineMap2[i2] + editRange.minChar);\n                }\n            }\n\n            if (this.logger.information()) {\n                this.logger.log("lineMap1 (after merge):");\n                this.astLogger.logLinemap(lineMap1);\n            }\n        }\n\n        private applyDeltaPosition(ast: TypeScript.AST, start: number, delta: number) {\n            var applyDelta = (ast: TypeScript.AST) => {\n                if (ast.minChar !== -1 && ast.minChar >= start) {\n                    ast.minChar += delta;\n                }\n                if (ast.limChar !== -1 && ast.limChar >= start) {\n                    ast.limChar += delta;\n                }\n            }\n\n            var applyDeltaToComments = (comments: TypeScript.Comment[]) => {\n                if (comments && comments.length > 0) {\n                    for (var i = 0; i < comments.length; i++) {\n                        applyDelta(comments[i]);\n                    }\n                }\n            }\n\n            var pre = function(cur: TypeScript.AST, parent: TypeScript.AST, walker: TypeScript.IAstWalker) {\n                // *Before* applying delta to this, check if we need to go to children\n                if (cur.limChar !== -1 && cur.limChar < start) {\n                    walker.options.goChildren = false; // Done with applying Delta for this sub-tree\n                }\n\n                // Apply delta to this node\n                applyDelta(cur);\n                applyDeltaToComments(cur.preComments);\n                applyDeltaToComments(cur.postComments);\n\n                return cur;\n            }\n\n            TypeScript.getAstWalkerFactory().walk(ast, pre);\n        }\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\ninterface IResolvedFile {\n    content: string;\n    path: string;\n}\n\ninterface IFileWatcher {\n    close(): void;\n}\n\ninterface IIO {\n    readFile(path: string): string;\n    writeFile(path: string, contents: string): void;\n    createFile(path: string, useUTF8?: bool): ITextWriter;\n    deleteFile(path: string): void;\n    dir(path: string, re?: RegExp, options?: { recursive?: bool; }): string[];\n    fileExists(path: string): bool;\n    directoryExists(path: string): bool;\n    createDirectory(path: string): void;\n    resolvePath(path: string): string;\n    dirName(path: string): string;\n    findFile(rootPath: string, partialFilePath: string): IResolvedFile;\n    print(str: string): void;\n    printLine(str: string): void;\n    arguments: string[];\n    stderr: ITextWriter;\n    stdout: ITextWriter;\n    watchFile(filename: string, callback: (string) => void ): IFileWatcher;\n    run(source: string, filename: string): void;\n    getExecutingFilePath(): string;\n    quit(exitCode?: number);\n}\n\nmodule IOUtils {\n    // Creates the directory including its parent if not already present\n    function createDirectoryStructure(ioHost: IIO, dirName: string) {\n        if (ioHost.directoryExists(dirName)) {\n            return;\n        }\n\n        var parentDirectory = ioHost.dirName(dirName);\n        if (parentDirectory != "") {\n            createDirectoryStructure(ioHost, parentDirectory);\n        }\n        ioHost.createDirectory(dirName);\n    }\n\n    // Creates a file including its directory structure if not already present\n    export function createFileAndFolderStructure(ioHost: IIO, fileName: string, useUTF8?: bool) {\n        var path = ioHost.resolvePath(fileName);\n        var dirName = ioHost.dirName(path);\n        createDirectoryStructure(ioHost, dirName);\n        return ioHost.createFile(path, useUTF8);\n    }\n\n    export function throwIOError(message: string, error: Error) {\n        var errorMessage = message;\n        if (error && error.message) {\n            errorMessage += (" " + error.message);\n        }\n        throw new Error(errorMessage);\n    }\n}\n\n// Declare dependencies needed for all supported hosts\ndeclare class Enumerator {\n    public atEnd(): bool;\n    public moveNext();\n    public item(): any;\n    constructor (o: any);\n}\ndeclare function setTimeout(callback: () =>void , ms?: number);\ndeclare var require: any;\ndeclare module process {\n    export var argv: string[];\n    export var platform: string;\n    export function on(event: st',
v27628=v27629+'ring, handler: (any) => void ): void;\n    export module stdout {\n        export function write(str: string);\n    }\n    export module stderr {\n        export function write(str: string);\n    }\n    export module mainModule {\n        export var filename: string;\n    }\n    export function exit(exitCode?: number);\n}\n\nvar IO = (function() {\n\n    // Create an IO object for use inside WindowsScriptHost hosts\n    // Depends on WSCript and FileSystemObject\n    function getWindowsScriptHostIO(): IIO {\n        var fso = new ActiveXObject("Scripting.FileSystemObject");\n        var streamObjectPool = [];\n\n        function getStreamObject(): any { \n            if (streamObjectPool.length > 0) {\n                return streamObjectPool.pop();\n            }  else {\n                return new ActiveXObject("ADODB.Stream");\n            }\n        }\n\n        function releaseStreamObject(obj: any) { \n            streamObjectPool.push(obj);\n        }\n\n        var args = [];\n        for (var i = 0; i < WScript.Arguments.length; i++) {\n            args[i] = WScript.Arguments.Item(i);\n        }\n\n        return {\n            readFile: function(path) {\n                try {\n                    var streamObj = getStreamObject();\n                    streamObj.Open();\n                    streamObj.Type = 2; // Text data\n                    streamObj.Charset = \'x-ansi\'; // Assume we are reading ansi text\n                    streamObj.LoadFromFile(path);\n                    var bomChar = streamObj.ReadText(2); // Read the BOM char\n                    streamObj.Position = 0; // Position has to be at 0 before changing the encoding\n                    if ((bomChar.charCodeAt(0) == 0xFE && bomChar.charCodeAt(1) == 0xFF)\n                        || (bomChar.charCodeAt(0) == 0xFF && bomChar.charCodeAt(1) == 0xFE)) {\n                        streamObj.Charset = \'unicode\';\n                    } else if (bomChar.charCodeAt(0) == 0xEF && bomChar.charCodeAt(1) == 0xBB) {\n                        streamObj.Charset = \'utf-8\'; \n                    }\n\n                    // Read the whole file\n                    var str = streamObj.ReadText(-1 /* read from the current position to EOS */);\n                    streamObj.Close();\n                    releaseStreamObject(streamObj);\n                    return <string>str;\n                }\n                catch (err) {\n                    IOUtils.throwIOError("Error reading file \\"" + path + "\\".", err);\n                }\n            },\n\n            writeFile: function(path, contents) {\n                var file = this.createFile(path);\n                file.Write(contents);\n                file.Close();\n            },\n\n            fileExists: function(path: string): bool {\n                return fso.FileExists(path);\n            },\n\n            resolvePath: function(path: string): string {\n                return fso.GetAbsolutePathName(path);\n            },\n\n            dirName: function(path: string): string {\n                return fso.GetParentFolderName(path);\n            },\n\n            findFile: function(rootPath: string, partialFilePath: string): IResolvedFile {\n                var path = fso.GetAbsolutePathName(rootPath) + "/" + partialFilePath;\n\n                while (true) {\n                    if (fso.FileExists(path)) {\n                        try {\n                            var content = this.readFile(path);\n                            return { content: content, path: path };\n                        }\n                        catch (err) {\n                            //Tools.CompilerDiagnostics.debugPrint("Could not find " + path + ", trying parent");\n                        }\n                    }\n                    else {\n                        rootPath = fso.GetParentFolderName(fso.GetAbsolutePathName(rootPath));\n\n                        if (rootPath == "") {\n                            return null;\n                        }\n                        else {\n                            path = fso.BuildPath(rootPath, partialFilePath);\n                        }\n                    }\n                }\n            },\n\n            deleteFile: function(path: string): void {\n                try {\n                    if (fso.FileExists(path)) {\n                        fso.DeleteFile(path, true); // true: delete read-only files\n                    }\n                } catch (e) {\n                    IOUtils.throwIOError("Couldn\'t delete file \'" + path + "\'.", e);\n                }\n            },\n\n            createFile: function (path, useUTF8?) {\n                try {\n                    var streamObj = getStreamObject();\n                    streamObj.Charset = useUTF8 ? \'utf-8\' : \'x-ansi\';\n                    streamObj.Open();\n                    return {\n                        Write: function (str) { streamObj.WriteText(str, 0); },\n                        WriteLine: function (str) { streamObj.WriteText(str, 1); },\n                        Close: function() {\n                            try {\n            ',
v27627=v27628+'                    streamObj.SaveToFile(path, 2);\n                            } catch (saveError) {\n                                IOUtils.throwIOError("Couldn\'t write to file \'" + path + "\'.", saveError);\n                            }\n                            finally {\n                                if (streamObj.State != 0 /*adStateClosed*/) {\n                                    streamObj.Close();\n                                }\n                                releaseStreamObject(streamObj);\n                            }\n                        }\n                    };\n                } catch (creationError) {\n                    IOUtils.throwIOError("Couldn\'t write to file \'" + path + "\'.", creationError);\n                }\n            },\n\n            directoryExists: function(path) {\n                return <bool>fso.FolderExists(path);\n            },\n\n            createDirectory: function(path) {\n                try {\n                    if (!this.directoryExists(path)) {\n                        fso.CreateFolder(path);\n                    }\n                } catch (e) {\n                    IOUtils.throwIOError("Couldn\'t create directory \'" + path + "\'.", e);\n                }\n            },\n\n            dir: function(path, spec?, options?) {\n                options = options || <{ recursive?: bool; }>{};\n                function filesInFolder(folder, root): string[]{\n                    var paths = [];\n                    var fc: Enumerator;\n\n                    if (options.recursive) {\n                        fc = new Enumerator(folder.subfolders);\n\n                        for (; !fc.atEnd() ; fc.moveNext()) {\n                            paths = paths.concat(filesInFolder(fc.item(), root + "/" + fc.item().Name));\n                        }\n                    }\n\n                    fc = new Enumerator(folder.files);\n\n                    for (; !fc.atEnd() ; fc.moveNext()) {\n                        if (!spec || fc.item().Name.match(spec)) {\n                            paths.push(root + "/" + fc.item().Name);\n                        }\n                    }\n\n                    return paths;\n                }\n\n                var folder = fso.GetFolder(path);\n                var paths = [];\n\n                return filesInFolder(folder, path);\n            },\n\n            print: function(str) {\n                WScript.StdOut.Write(str);\n            },\n\n            printLine: function(str) {\n                WScript.Echo(str);\n            },\n\n            arguments: <string[]>args,\n            stderr: WScript.StdErr,\n            stdout: WScript.StdOut,\n            watchFile: null,\n            run: function(source, filename) {\n                try {\n                    eval(source);\n                } catch (e) {\n                    IOUtils.throwIOError("Error while executing file \'" + filename + "\'.", e);\n                }\n            },\n            getExecutingFilePath: function () {\n                return WScript.ScriptFullName;\n            },\n            quit: function (exitCode? : number = 0) {\n                try {\n                    WScript.Quit(exitCode);\n                } catch (e) {\n                }\n            }\n        }\n\n    };\n\n    // Create an IO object for use inside Node.js hosts\n    // Depends on \'fs\' and \'path\' modules\n    function getNodeIO(): IIO {\n\n        var _fs = require(\'fs\');\n        var _path = require(\'path\');\n        var _module = require(\'module\');\n\n        return {\n            readFile: function(file) {\n                try {\n                    var buffer = _fs.readFileSync(file);\n                    switch (buffer[0]) {\n                        case 0xFE:\n                            if (buffer[1] == 0xFF) {\n                                // utf16-be. Reading the buffer as big endian is not supported, so convert it to \n                                // Little Endian first\n                                var i = 0;\n                                while ((i + 1) < buffer.length) {\n                                    var temp = buffer[i]\n                                    buffer[i] = buffer[i + 1];\n                                    buffer[i + 1] = temp;\n                                    i += 2;\n                                }\n                                return buffer.toString("ucs2", 2);\n                            }\n                            break;\n                        case 0xFF:\n                            if (buffer[1] == 0xFE) {\n                                // utf16-le \n                                return buffer.toString("ucs2", 2);\n                            }\n                            break;\n                        case 0xEF:\n                            if (buffer[1] == 0xBB) {\n                                // utf-8\n                                return buffer.toString("utf8", 3);\n                            }\n                    }\n                    // Default behaviour\n                    return buffer.toString();\n                } catch ',
v27626=v27627+'(e) {\n                    IOUtils.throwIOError("Error reading file \\"" + file + "\\".", e);\n                }\n            },\n            writeFile: <(path: string, contents: string) => void >_fs.writeFileSync,\n            deleteFile: function(path) {\n                try {\n                    _fs.unlinkSync(path);\n                } catch (e) {\n                    IOUtils.throwIOError("Couldn\'t delete file \'" + path + "\'.", e);\n                }\n            },\n            fileExists: function(path): bool {\n                return _fs.existsSync(path);\n            },\n            createFile: function(path, useUTF8?) {\n                function mkdirRecursiveSync(path) {\n                    var stats = _fs.statSync(path);\n                    if (stats.isFile()) {\n                        IOUtils.throwIOError("\\"" + path + "\\" exists but isn\'t a directory.", null);\n                    } else if (stats.isDirectory()) {\n                        return;\n                    } else {\n                        mkdirRecursiveSync(_path.dirname(path));\n                        _fs.mkdirSync(path, 0775);\n                    }\n                }\n\n                mkdirRecursiveSync(_path.dirname(path));\n\n                try {\n                    var fd = _fs.openSync(path, \'w\');\n                } catch (e) {\n                    IOUtils.throwIOError("Couldn\'t write to file \'" + path + "\'.", e);\n                }\n                return {\n                    Write: function(str) { _fs.writeSync(fd, str); },\n                    WriteLine: function(str) { _fs.writeSync(fd, str + \'\\r\\n\'); },\n                    Close: function() { _fs.closeSync(fd); fd = null; }\n                };\n            },\n            dir: function dir(path, spec?, options?) {\n                options = options || <{ recursive?: bool; }>{};\n\n                function filesInFolder(folder: string): string[]{\n                    var paths = [];\n\n                    var files = _fs.readdirSync(folder);\n                    for (var i = 0; i < files.length; i++) {\n                        var stat = _fs.statSync(folder + "/" + files[i]);\n                        if (options.recursive && stat.isDirectory()) {\n                            paths = paths.concat(filesInFolder(folder + "/" + files[i]));\n                        } else if (stat.isFile() && (!spec || files[i].match(spec))) {\n                            paths.push(folder + "/" + files[i]);\n                        }\n                    }\n\n                    return paths;\n                }\n\n                return filesInFolder(path);\n            },\n            createDirectory: function(path: string): void {\n                try {\n                    if (!this.directoryExists(path)) {\n                        _fs.mkdirSync(path);\n                    }\n                } catch (e) {\n                    IOUtils.throwIOError("Couldn\'t create directory \'" + path + "\'.", e);\n                }\n            },\n\n            directoryExists: function(path: string): bool {\n                return _fs.existsSync(path) && _fs.lstatSync(path).isDirectory();\n            },\n            resolvePath: function(path: string): string {\n                return _path.resolve(path);\n            },\n            dirName: function(path: string): string {\n                return _path.dirname(path);\n            },\n            findFile: function(rootPath: string, partialFilePath): IResolvedFile {\n                var path = rootPath + "/" + partialFilePath;\n\n                while (true) {\n                    if (_fs.existsSync(path)) {\n                        try {\n                            var content = this.readFile(path);\n                            return { content: content, path: path };\n                        } catch (err) {\n                            //Tools.CompilerDiagnostics.debugPrint(("Could not find " + path) + ", trying parent");\n                        }\n                    }\n                    else {\n                        var parentPath = _path.resolve(rootPath, "..");\n\n                        // Node will just continue to repeat the root path, rather than return null\n                        if (rootPath === parentPath) {\n                            return null;\n                        }\n                        else {\n                            rootPath = parentPath;\n                            path = _path.resolve(rootPath, partialFilePath);\n                        }\n                    }\n                }\n            },\n            print: function(str) { process.stdout.write(str) },\n            printLine: function(str) { process.stdout.write(str + \'\\n\') },\n            arguments: process.argv.slice(2),\n            stderr: {\n                Write: function(str) { process.stderr.write(str); },\n                WriteLine: function(str) { process.stderr.write(str + \'\\n\'); },\n                Close: function() { }\n            },\n            stdout: {\n                Write: function(str) { process.stdout.write(str); },\n                Write',
v27625=v27626+'Line: function(str) { process.stdout.write(str + \'\\n\'); },\n                Close: function() { }\n            },\n            watchFile: function(filename: string, callback: (string) => void ): IFileWatcher {\n                var firstRun = true;\n                var processingChange = false;\n\n                var fileChanged: any = function(curr, prev) {\n                    if (!firstRun) {\n                        if (curr.mtime < prev.mtime) {\n                            return;\n                        }\n\n                        _fs.unwatchFile(filename, fileChanged);\n                        if (!processingChange) {\n                            processingChange = true;\n                            callback(filename);\n                            setTimeout(function() { processingChange = false; }, 100);\n                        }\n                    }\n                    firstRun = false;\n                    _fs.watchFile(filename, { persistent: true, interval: 500 }, fileChanged);\n                };\n\n                fileChanged();\n                return {\n                    filename: filename,\n                    close: function() {\n                        _fs.unwatchFile(filename, fileChanged);\n                    }\n                };\n            },\n            run: function(source, filename) {\n                require.main.filename = filename;\n                require.main.paths = _module._nodeModulePaths(_path.dirname(_fs.realpathSync(filename)));\n                require.main._compile(source, filename);\n            }, \n            getExecutingFilePath: function () {\n                return process.mainModule.filename;\n            },\n            quit: process.exit\n        }\n    };\n\n    if (typeof ActiveXObject === "function")\n        return getWindowsScriptHostIO();\n    else if (typeof require === "function")\n        return getNodeIO();\n    else\n        return null; // Unsupported host\n})();\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    // Note: Any addition to the NodeType should also be supported with addition to AstWalkerDetailCallback\n    export enum NodeType {\n        None,\n        Empty,\n        EmptyExpr,\n        True,\n        False,\n        This,\n        Super,\n        QString,\n        Regex,\n        Null,\n        ArrayLit,\n        ObjectLit,\n        Void,\n        Comma,\n        Pos,\n        Neg,\n        Delete,\n        Await,\n        In,\n        Dot,\n        From,\n        Is,\n        InstOf,\n        Typeof,\n        NumberLit,\n        Name,\n        TypeRef,\n        Index,\n        Call,\n        New,\n        Asg,\n        AsgAdd,\n        AsgSub,\n        AsgDiv,\n        AsgMul,\n        AsgMod,\n        AsgAnd,\n        AsgXor,\n        AsgOr,\n        AsgLsh,\n        AsgRsh,\n        AsgRs2,\n        ConditionalExpression,\n        LogOr,\n        LogAnd,\n        Or,\n        Xor,\n        And,\n        Eq,\n        Ne,\n        Eqv,\n        NEqv,\n        Lt,\n        Le,\n        Gt,\n        Ge,\n        Add,\n        Sub,\n        Mul,\n        Div,\n        Mod,\n        Lsh,\n        Rsh,\n        Rs2,\n        Not,\n        LogNot,\n        IncPre,\n        DecPre,\n        IncPost,\n        DecPost,\n        TypeAssertion,\n        FuncDecl,\n        Member,\n        VarDecl,\n        ArgDecl,\n        Return,\n        Break,\n        Continue,\n        Throw,\n        For,\n        ForIn,\n        If,\n        While,\n        DoWhile,\n        Block,\n        Case,\n        Switch,\n        Try,\n        TryCatch,\n        TryFinally,\n        Finally,\n        Catch,\n        List,\n        Script,\n        ClassDeclaration,\n        InterfaceDeclaration,\n        ModuleDeclaration,\n        ImportDeclaration,\n        With,\n        Label,\n        LabeledStatement,\n        EBStart,\n        GotoEB,\n        EndCode,\n        Error,\n        Comment,\n        Debugger,\n        GeneralNode = FuncDecl,\n        LastAsg = AsgRs2,\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.',
v27624=v27625+'\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path="io.ts" />\n\ninterface IOptions {\n    name?: string;\n    flag?: bool;\n    short?: string;\n    usage?: string;\n    set?: (s: string) => void;\n    type?: string;\n    experimental?: bool;\n}\n\nclass OptionsParser {\n    private DEFAULT_SHORT_FLAG = "-";\n    private DEFAULT_LONG_FLAG = "--";\n\n    // Find the option record for the given string. Returns null if not found.\n    private findOption(arg: string) {\n\n        for (var i = 0; i < this.options.length; i++) {\n\n            if (arg === this.options[i].short || arg === this.options[i].name) {\n                return this.options[i];\n            }\n        }\n\n        return null;\n    }\n\n    public unnamed: string[] = [];\n\n    public options: IOptions[] = [];\n\n    constructor (public host: IIO) {\n    }\n\n    public printUsage() {\n        this.host.printLine("Syntax:   tsc [options] [file ..]");\n        this.host.printLine("");\n        this.host.printLine("Examples: tsc hello.ts");\n        this.host.printLine("          tsc --out foo.js foo.ts");\n        this.host.printLine("          tsc @args.txt");\n        this.host.printLine("");\n        this.host.printLine("Options:");\n\n        var output = [];\n        var maxLength = 0;\n\n        this.options = this.options.sort(function(a, b) {\n            var aName = a.name.toLowerCase();\n            var bName = b.name.toLowerCase();\n\n            if (aName > bName) {\n                return 1;\n            } else if (aName < bName) {\n                return -1;\n            } else {\n                return 0;\n            }\n        });\n\n        // Build up output array\n        for (var i = 0; i < this.options.length; i++) {\n            var option = this.options[i];\n\n            if (option.experimental) {\n                continue;\n            }\n\n            if (!option.usage) {\n                break;\n            }\n\n            var usageString = "  ";\n            var type = option.type ? " " + option.type.toUpperCase() : "";\n\n            if (option.short) {\n                usageString += this.DEFAULT_SHORT_FLAG + option.short + type + ", ";\n            }\n\n            usageString += this.DEFAULT_LONG_FLAG + option.name + type;\n\n            output.push([usageString, option.usage]);\n\n            if (usageString.length > maxLength) {\n                maxLength = usageString.length;\n            }\n        }\n\n        output.push(["  @<file>", "Insert command line options and files from a file."]);\n\n        // Print padded output\n        for (var i = 0; i < output.length; i++) {\n            this.host.printLine(output[i][0] + (new Array(maxLength - output[i][0].length + 3)).join(" ") + output[i][1]);\n        }\n    }\n\n    public option(name: string, config: IOptions, short?: string) {\n        if (!config) {\n            config = <any>short;\n            short = null;\n        }\n\n        config.name = name;\n        config.short = short;\n        config.flag = false;\n\n        this.options.push(config);\n    }\n\n    public flag(name: string, config: IOptions, short?: string) {\n        if (!config) {\n            config = <any>short;\n            short = null;\n        }\n\n        config.name = name;\n        config.short = short;\n        config.flag = true\n\n        this.options.push(config);\n    }\n\n    // Parse an arguments string\n    public parseString(argString: string) {\n        var position = 0;\n        var tokens = argString.match(/\\s+|"|[^\\s"]+/g);\n\n        function peek() {\n            return tokens[position];\n        }\n\n        function consume() {\n            return tokens[position++];\n        }\n\n        function consumeQuotedString() {\n            var value = \'\';\n            consume(); // skip opening quote.\n\n            var token = peek();\n\n            while (token && token !== \'"\') {\n                consume();\n\n                value += token;\n\n                token = peek();\n            }\n\n            consume(); // skip ending quote;\n\n            return value;\n        }\n\n        var args: string[] = [];\n        var currentArg = \'\';\n\n        while (position < tokens.length) {\n            var token = peek();\n\n            if (token === \'"\') {\n                currentArg += consumeQuotedString();\n            } else if (token.match(/\\s/)) {\n                if (currentArg.length > 0) {\n                    args.push(currentArg);\n                    currentArg = \'\';\n                }\n\n                consume();\n            } else {\n                consume();\n                currentArg += token;\n            }\n        }\n\n        if (currentArg.length > 0) {\n            args.push(currentArg);\n        }\n\n        this.parse(args);\n    }\n\n    // Parse arguments as they come from the platform: split into arguments.\n    public parse(args: string[]) {\n        var position = 0;\n\n        function consume() {\n            return args[position++];\n        }\n\n        while (position < args.length) {\n            var current = consume();\n           ',
v27623=v27624+' var match = current.match(/^(--?|@)(.*)/);\n            var value = null;\n\n            if (match) {\n                if (match[1] === \'@\') {\n                    this.parseString(this.host.readFile(match[2]));\n                } else {\n                    var arg = match[2];\n                    var option = this.findOption(arg);\n\n                    if (option === null) {\n                        this.host.printLine("Unknown option \'" + arg +"\'");\n                        this.host.printLine("Use the \'--help\' flag to see options");\n                    } else {\n                        if (!option.flag)\n                            value = consume();\n\n                        option.set(value);\n                    }\n                }\n            } else {\n                this.unnamed.push(current);\n            }\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export enum TypeContext {\n        NoTypes = 0,\n        ArraySuffix = 1,\n        Primitive = 2,\n        Named = 4,\n        AllSimpleTypes = Primitive | Named,\n        AllTypes = Primitive | Named | ArraySuffix,\n    }\n\n    export enum ParseState {\n        None,\n        StartScript,\n        StartStatementList,\n        StartStatement,\n        StartFncDecl,\n        FncDeclName,\n        FncDeclArgs,\n        FncDeclReturnType,\n        ForInit,\n        ForInitAfterVar,\n        ForCondStart,\n        EndStmtList,\n        EndScript,\n    }\n\n    export interface IStatementInfo {\n        stmt: Statement;\n        labels: ASTList;\n    }\n\n    export interface ILambdaArgumentContext {\n        preProcessedLambdaArgs: AST;\n    }\n\n    export class QuickParseResult {\n        constructor (public Script: Script, public endLexState: LexState) { }\n    }\n\n    export class Parser {\n        private varLists: ASTList[] = [];\n        private scopeLists: ASTList[] = [];\n        private staticsLists: ASTList[] = [];\n\n        private scanner: IScanner = new Scanner();\n        private currentToken: Token = null;\n\n        private needTerminator = false;\n\n        // TODO: consolidate these\n        private inFunction = false;\n        private inInterfaceDecl = false;\n        public currentClassDecl: NamedDeclaration = null;\n\n        private inFncDecl = false;  // this is only for FuncDecls - not constructors, like inFnc\n        private anonId = new Identifier("_anonymous");\n        public style_requireSemi = false;\n        public style_funcInLoop = true;\n        private incremental = false;\n        public errorRecovery = false;\n        public outfile: ITextWriter = undefined;\n        public errorCallback: (minChar: number, charLen: number, message: string, unit: number) =>void = null;\n        private state: ParseState = ParseState.StartStatementList;\n        private ambientModule = false;\n        private ambientClass = false;\n        private topLevel = true;\n        private allowImportDeclaration = true;\n        private currentUnitIndex = (-1);\n        private prevIDTok: Token = null;\n        private statementInfoStack: IStatementInfo[] = new IStatementInfo[];\n        private hasTopLevelImportOrExport = false; // for imports, only true if it\'s a dynamic module\n        private strictMode = false;\n        private nestingLevel = 0;\n        private prevExpr: AST = null;\n        private currentClassDefinition: ClassDeclaration = null;\n        private parsingClassConstructorDefinition = false;\n        private parsingDeclareFile = false;\n        private amdDependencies: string[] = [];\n        public inferPropertiesFromThisAssignment = false;\n        public requiresExtendsBlock = false;\n\n        private resetStmtStack() {\n            this.statementInfoStack = new IStatementInfo[];\n        }\n\n        private inLoop() {\n            for (var j = this.statementInfoStack.length - 1; j >= 0; j--) {\n                if (this.statementInfoStack[j].stmt.isLoop()) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private pushStmt(stmt: Statement, labels: ASTList) {\n            // allocate here to avoid always storing this information in statements\n            var info = { stmt: stmt, labels: labels };\n            this.statementInfoStack.push(info);\n        }\n\n        private popStmt(): IStatementInfo {\n            return this.statementInfoStack.pop();\n        }\n\n        private resolveJumpTarget(jump: Jump): void {',
v27622=v27623+'\n            var resolvedTarget = AST.getResolvedIdentifierName(jump.target);\n            var len = this.statementInfoStack.length;\n            for (var i = len - 1; i >= 0; i--) {\n                var info = this.statementInfoStack[i];\n                if (jump.target) {\n                    if (info.labels && (info.labels.members.length > 0)) {\n                        for (var j = 0, labLen = info.labels.members.length; j < labLen; j++) {\n                            var label = <Label>info.labels.members[j];\n                            if (label.id.text == resolvedTarget) {\n                                jump.setResolvedTarget(this, info.stmt);\n                                return;\n                            }\n                        }\n                    }\n                }\n                else {\n                    if (info.stmt.isLoop()) {\n                        jump.setResolvedTarget(this, info.stmt);\n                        return;\n                    }\n                    else if ((info.stmt.nodeType == NodeType.Switch) && (jump.nodeType == NodeType.Break)) {\n                        jump.setResolvedTarget(this, info.stmt);\n                        return;\n                    }\n                }\n            }\n            // no luck\n            if (jump.target) {\n                this.reportParseError("could not find enclosing statement with label " + jump.target);\n            }\n            else {\n                if (jump.nodeType == NodeType.Break) {\n                    this.reportParseError("break statement requires enclosing loop or switch");\n                }\n                else {\n                    this.reportParseError("continue statement requires enclosing loop");\n                }\n            }\n        }\n\n        public setErrorRecovery(outfile: ITextWriter) {\n            this.outfile = outfile;\n            this.errorRecovery = true;\n        }\n\n        public getSourceLineCol(lineCol: ILineCol, minChar: number): void {\n            getSourceLineColFromMap(lineCol, minChar, this.scanner.lineMap);\n        }\n\n        private createRef(text: string, hasEscapeSequence: bool, minChar: number): Identifier {\n            var id = new Identifier(text, hasEscapeSequence);\n            id.minChar = minChar;\n            return id;\n        }\n\n        private reportParseStyleError(message: string) {\n            this.reportParseError("STYLE: " + message);\n        }\n\n        public reportParseError(message: string, startPos = this.scanner.startPos, pos = this.scanner.pos) {\n            var len = Math.max(1, pos - startPos);\n            if (this.errorCallback) {\n                this.errorCallback(startPos, len, message, this.currentUnitIndex);\n            }\n            else if (this.errorRecovery) {\n                var lineCol = { line: -1, col: -1 };\n                this.getSourceLineCol(lineCol, startPos);\n                if (this.outfile) {\n                    this.outfile.WriteLine("// " + this.fname + " (" + lineCol.line + "," + lineCol.col + "): " + message);\n                }\n            }\n            else {\n                throw new SyntaxError(this.fname + " (" + this.scanner.line + "," + this.scanner.col + "): " + message);\n            }\n        }\n\n        private checkNextToken(tokenId: TokenID, errorRecoverySet: ErrorRecoverySet, errorText: string = null): void {\n            this.currentToken = this.scanner.scan();\n            this.checkCurrentToken(tokenId, errorRecoverySet, errorText);\n        }\n\n        private skip(errorRecoverySet: ErrorRecoverySet) {\n            errorRecoverySet |= ErrorRecoverySet.EOF;\n            var ersTok = ErrorRecoverySet.None;\n            var tokenInfo = lookupToken(this.currentToken.tokenId);\n            if (tokenInfo != undefined) {\n                ersTok = tokenInfo.ers;\n            }\n            var pendingRightCurlies = 0;\n            while (((ersTok & errorRecoverySet) == ErrorRecoverySet.None) ||\n                   (this.currentToken.tokenId == TokenID.CloseBrace) && (pendingRightCurlies > 0)) {\n                if (this.currentToken.tokenId == TokenID.OpenBrace) {\n                    pendingRightCurlies++;\n                }\n                else if (this.currentToken.tokenId == TokenID.CloseBrace) {\n                    pendingRightCurlies--;\n                }\n                this.currentToken = this.scanner.scan();\n                ersTok = ErrorRecoverySet.None;\n                tokenInfo = lookupToken(this.currentToken.tokenId);\n                if (tokenInfo != undefined) {\n                    ersTok = tokenInfo.ers;\n                }\n                // TODO: regex rescan \n            }\n        }\n\n        private checkCurrentToken(tokenId: TokenID, errorRecoverySet: ErrorRecoverySet, errorText: string = null): void {\n            if (this.currentToken.tokenId != tokenId) {\n                errorText = errorText == null ? ("Expected \'" + tokenTable[tokenId].text + "\'") : errorText;\n                this.reportParseError(errorText);\n                if (this.errorRecove',
v27621=v27622+'ry) {\n                    this.skip(errorRecoverySet);\n                }\n            }\n            else {\n                this.currentToken = this.scanner.scan();\n            }\n        }\n\n        private pushDeclLists() {\n            this.staticsLists.push(new ASTList());\n            this.varLists.push(new ASTList());\n            this.scopeLists.push(new ASTList());\n        }\n\n        private popDeclLists() {\n            this.staticsLists.pop();\n            this.varLists.pop();\n            this.scopeLists.pop();\n        }\n\n        private topVarList() {\n            return this.varLists[this.varLists.length - 1];\n        }\n\n        private topScopeList() {\n            return this.scopeLists[this.scopeLists.length - 1];\n        }\n\n        private topStaticsList() {\n            return this.staticsLists[this.staticsLists.length - 1];\n        }\n\n        private parseComment(comment: CommentToken) {\n            if (comment) {\n                var c: Comment = new Comment(comment.value, comment.isBlock, comment.endsLine);\n                c.minChar = comment.startPos;\n                c.limChar = comment.startPos + comment.value.length;\n                var lineCol = { line: -1, col: -1 };\n                this.getSourceLineCol(lineCol, c.minChar);\n                c.minLine = lineCol.line;\n                this.getSourceLineCol(lineCol, c.limChar);\n                c.limLine = lineCol.line;\n\n                if (!comment.isBlock && comment.value.length > 3 && comment.value.substring(0, 3) == "///") {\n                    var dependencyPath = getAdditionalDependencyPath(comment.value);\n\n                    if (dependencyPath) {\n                        this.amdDependencies.push(dependencyPath);\n                    }\n\n                    if (getImplicitImport(comment.value)) {\n                        this.hasTopLevelImportOrExport = true;\n                    }\n                }\n\n                return c;\n            }\n            else {\n                return null;\n            }\n        }\n\n        private parseCommentsInner(comments: CommentToken[]) {\n            if (comments) {\n                var commentASTs: Comment[] = new Comment[];\n                for (var i = 0; i < comments.length; i++) {\n                    commentASTs.push(this.parseComment(comments[i]));\n                }\n                return commentASTs;\n            } else {\n                return null;\n            }\n        }\n\n        private parseComments() {\n            var comments = this.scanner.getComments();\n            return this.parseCommentsInner(comments);\n        }\n\n        private parseCommentsForLine(line: number) {\n            var comments = this.scanner.getCommentsForLine(line);\n\n            return this.parseCommentsInner(comments);\n        }\n\n        private combineComments(comment1: Comment[], comment2: Comment[]) {\n            if (comment1 == null) {\n                return comment2;\n            }\n            else if (comment2 == null) {\n                return comment1;\n            }\n            else {\n                return comment1.concat(comment2);\n            }\n        }\n\n        private parseEnumDecl(errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers): ModuleDeclaration {\n            var leftCurlyCount = this.scanner.leftCurlyCount;\n            var rightCurlyCount = this.scanner.rightCurlyCount;\n\n            var name: Identifier = null;\n            if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                name = Identifier.fromToken(this.currentToken);\n                name.minChar = this.scanner.startPos;\n                name.limChar = this.scanner.pos;\n                this.currentToken = this.scanner.scan();\n            }\n            else {\n                this.reportParseError("Enum declaration requires identifier");\n                if (this.errorRecovery) {\n                    name = new MissingIdentifier();\n                    name.minChar = this.scanner.startPos;\n                    name.limChar = this.scanner.startPos;\n                    name.flags |= ASTFlags.Error;\n                }\n            }\n\n            var membersMinChar = this.scanner.startPos;\n            this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet | ErrorRecoverySet.ID);\n            this.pushDeclLists();\n            var members = new ASTList();\n            members.minChar = membersMinChar;\n            var mapDecl = new VarDecl(new Identifier("_map"), 0);\n            mapDecl.varFlags |= VarFlags.Exported;\n            mapDecl.varFlags |= VarFlags.Private;\n\n            // REVIEW: Is this still necessary?\n            mapDecl.varFlags |= (VarFlags.Property | VarFlags.Public);\n            mapDecl.init = new UnaryExpression(NodeType.ArrayLit, null);\n            members.append(mapDecl);\n            var lastValue: NumberLiteral = null;\n            for (; ;) {\n                var minChar = this.scanner.startPos;\n                var limChar;\n                var memberName: Identifier = null;\n',
v27620=v27621+'                var memberValue: AST = null;\n                var preComments = null;\n                var postComments = null;\n\n                if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToIDName(this.currentToken)) {\n                    memberName = Identifier.fromToken(this.currentToken);\n                    memberName.minChar = this.scanner.startPos;\n                    memberName.limChar = this.scanner.pos;\n                }\n                else if (this.currentToken.tokenId == TokenID.CloseBrace) {\n                    break;\n                }\n                else {\n                    this.reportParseError("Expected identifer of enum member");\n                    if (this.errorRecovery) {\n                        memberName = new MissingIdentifier();\n                        memberName.minChar = this.scanner.startPos;\n                        memberName.limChar = this.scanner.startPos;\n                        memberName.flags |= ASTFlags.Error;\n                    }\n                }\n\n                limChar = this.scanner.pos;\n                preComments = this.parseComments();\n                this.currentToken = this.scanner.scan();\n                postComments = this.parseComments();\n\n                if (this.currentToken.tokenId == TokenID.Equals) {\n                    this.currentToken = this.scanner.scan();\n                    memberValue = this.parseExpr(errorRecoverySet, OperatorPrecedence.Comma, true,\n                                          TypeContext.NoTypes);\n                    lastValue = <NumberLiteral>memberValue;\n                    limChar = memberValue.limChar;\n                }\n                else {\n                    if (lastValue == null) {\n                        memberValue = new NumberLiteral(0);\n                        lastValue = <NumberLiteral>memberValue;\n                    }\n                    else {\n                        memberValue = new NumberLiteral(lastValue.value + 1);\n                        lastValue = <NumberLiteral>memberValue;\n                    }\n                    var map: BinaryExpression =\n                        new BinaryExpression(NodeType.Asg,\n                                             new BinaryExpression(NodeType.Index,\n                                                                  new Identifier("_map"),\n                                                                  memberValue),\n                                             new StringLiteral(\'"\' + memberName.actualText + \'"\'));\n                    members.append(map);\n                }\n                var member = new VarDecl(memberName, this.nestingLevel);\n                member.minChar = minChar;\n                member.limChar = limChar;\n                member.init = memberValue;\n                // Note: Leave minChar, limChar as "-1" on typeExpr as this is a parsing artifact.\n                member.typeExpr = new TypeReference(this.createRef(name.actualText, name.hasEscapeSequence, -1), 0);\n                member.varFlags |= (VarFlags.Readonly | VarFlags.Property);\n                if (memberValue.nodeType == NodeType.NumberLit) {\n                    member.varFlags |= VarFlags.Constant;\n                }\n                member.preComments = preComments;\n                members.append(member);\n                member.postComments = postComments;\n                // all enum members are exported\n                member.varFlags |= VarFlags.Exported;\n\n                if (this.currentToken.tokenId == TokenID.Comma) {\n                    this.currentToken = this.scanner.scan();\n                    member.postComments = this.combineComments(member.postComments, this.parseCommentsForLine(this.scanner.prevLine));\n                    if ((this.currentToken.tokenId == TokenID.Identifier) || (convertTokToIDName(this.currentToken))) {\n                        continue;\n                    }\n                }\n                break;\n            }\n            var endingToken = new ASTSpan();\n            endingToken.minChar = this.scanner.startPos;\n            endingToken.limChar = this.scanner.pos;\n\n            this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n            members.limChar = this.scanner.lastTokenLimChar();\n            var modDecl = new ModuleDeclaration(name, members, this.topVarList(), this.topScopeList(), endingToken);\n            modDecl.modFlags |= ModuleFlags.IsEnum;\n            this.popDeclLists();\n\n            modDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n            modDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n            return modDecl;\n        }\n\n        private parseDottedName(enclosedList: AST[]): void {\n            this.currentToken = this.scanner.scan();\n            if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                var id = Identifier.fromToken(this.currentToken);\n                id.preComments = this.parseCom',
v27619=v27620+"ments();\n                enclosedList[enclosedList.length] = id;\n                id.minChar = this.scanner.startPos;\n                id.limChar = this.scanner.pos;\n                this.currentToken = this.scanner.scan();\n                if (this.currentToken.tokenId == TokenID.Dot) {\n                    this.parseDottedName(enclosedList);\n                }\n            }\n            else {\n                this.reportParseError(\"need identifier after '.'\");\n            }\n        }\n\n        // REVIEW: This is much more lenient than the spec - we're basically just checking to see if the\n        // path is rooted or contains an extension, not if it could potentially be a bogus file path\n        private isValidImportPath(importPath: string) {\n            importPath = stripQuotes(importPath);\n\n            if (!importPath ||\n                importPath.indexOf(':') != -1 || \n                importPath.indexOf('\\\\') != -1 ||\n                //(importPath.indexOf('.') != -1 && importPath.charAt(0) != '.') ||\n                importPath.charAt(0) == '/') {\n                return false;\n            }\n            return true;\n        }\n\n        private parseImportDeclaration(errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers): ImportDeclaration {\n\n            var name: Identifier = null;\n            var alias: AST = null;\n            var importDecl: ImportDeclaration = null;\n            var minChar = this.scanner.startPos;\n            var isDynamicImport = false;\n\n            this.currentToken = this.scanner.scan();\n\n            if (this.currentToken.tokenId == TokenID.Identifier || convertTokToID(this.currentToken, this.strictMode)) {\n                name = Identifier.fromToken(this.currentToken);\n            }\n            else {\n                this.reportParseError(\"Expected identifer after 'import'\");\n                name = new MissingIdentifier();\n            }\n\n            name.minChar = this.scanner.startPos;\n            name.limChar = this.scanner.pos;\n\n            this.currentToken = this.scanner.scan();\n\n            this.checkCurrentToken(TokenID.Equals, errorRecoverySet | ErrorRecoverySet.ID);\n\n            var aliasPreComments = this.parseComments();\n\n            var limChar;\n            if (this.currentToken.tokenId == TokenID.Identifier || convertTokToID(this.currentToken, this.strictMode)) {\n\n                if (this.currentToken.tokenId == TokenID.Module) {\n                    limChar = this.scanner.pos;\n                    this.currentToken = this.scanner.scan();\n                    if (this.currentToken.tokenId == TokenID.OpenParen) {\n                        this.currentToken = this.scanner.scan();\n\n                        if (this.currentToken.tokenId == TokenID.StringLiteral || this.currentToken.tokenId == TokenID.Identifier || convertTokToID(this.currentToken, this.strictMode)) {\n\n                            if (this.currentToken.tokenId == TokenID.StringLiteral) {\n\n                                if (this.topLevel) {\n                                    this.hasTopLevelImportOrExport = true;\n                                } else if (!this.allowImportDeclaration) {\n                                    this.reportParseError(\"Import declaration of external module is permitted only in global or top level dynamic modules\");\n                                }\n\n                                var aliasText = this.currentToken.getText();\n                                alias = Identifier.fromToken(this.currentToken);\n                                alias.minChar = this.scanner.startPos;\n                                alias.limChar = this.scanner.pos;\n\n                                if (!this.isValidImportPath((<Identifier>alias).text)) {\n                                    this.reportParseError(\"Invalid import path\");\n                                }\n\n                                isDynamicImport = true;\n                                this.currentToken = this.scanner.scan();\n                                    \n                                alias.preComments = aliasPreComments;\n                            }\n                            else {\n                                alias = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon,\n                                            OperatorPrecedence.Assignment, true,\n                                            TypeContext.NoTypes);\n                                    \n                                alias.preComments = aliasPreComments;\n                            }\n                        }\n\n                        limChar = this.scanner.pos;\n                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.ID);\n\n                        if (alias) {\n                            alias.postComments = this.parseComments();\n                        }\n                    }\n                }\n                else {\n                    alias = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon,\n                 ",
v27618=v27619+'                           OperatorPrecedence.Assignment, true,\n                                            TypeContext.NoTypes);\n                    limChar = this.scanner.pos; // Include semicolon if needed\n                }\n            }\n            else {\n                this.reportParseError("Expected module name");\n                alias = new MissingIdentifier();\n                alias.minChar = this.scanner.startPos;\n                if (this.currentToken.tokenId == TokenID.Semicolon) {\n                    alias.limChar = this.scanner.startPos;\n                } else {\n                    alias.limChar = this.scanner.pos;\n                    this.currentToken = this.scanner.scan();\n                }\n                alias.flags |= ASTFlags.Error;\n                limChar = alias.limChar;\n            }\n\n            importDecl = new ImportDeclaration(name, alias);\n            importDecl.isDynamicImport = isDynamicImport;\n\n            importDecl.minChar = minChar;\n            importDecl.limChar = limChar;\n\n            return importDecl;\n        }\n\n        private parseModuleDecl(errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers, preComments: Comment[]): ModuleDeclaration {\n            var leftCurlyCount = this.scanner.leftCurlyCount;\n            var rightCurlyCount = this.scanner.rightCurlyCount;\n\n            var svAmbient = this.ambientModule;\n            var svTopLevel = this.topLevel;\n            this.topLevel = false;\n            if (this.parsingDeclareFile || svAmbient || hasFlag(modifiers, Modifiers.Ambient)) {\n                this.ambientModule = true;\n            }\n\n            this.currentToken = this.scanner.scan();\n            var name: AST = null;\n            var enclosedList: AST[] = null;\n            this.pushDeclLists();\n            var minChar = this.scanner.startPos;\n            var isDynamicMod = false;\n\n            if ((this.currentToken.tokenId == TokenID.Identifier) || (this.currentToken.tokenId == TokenID.StringLiteral) || (!isPrimitiveTypeToken(this.currentToken) && convertTokToID(this.currentToken, this.strictMode))) {\n                var nameText = this.currentToken.getText();\n\n                if (this.currentToken.tokenId == TokenID.StringLiteral) {\n                    isDynamicMod = true;\n                    if (!this.ambientModule) {\n                        this.reportParseError("Only ambient dynamic modules may have string literal names");\n                    }\n\n                    if (!svTopLevel) {\n                        this.reportParseError("Dynamic modules may not be nested within other modules");\n                    }\n                }\n\n                name = Identifier.fromToken(this.currentToken);\n                name.minChar = this.scanner.startPos;\n                name.limChar = this.scanner.pos;\n\n                this.currentToken = this.scanner.scan();\n            }\n            else if (this.currentToken.tokenId == TokenID.OpenBrace) {\n                this.reportParseError("Module name missing");\n                name = new Identifier("");\n                // "fake" position of where the ID would be\n                name.minChar = minChar;\n                name.limChar = minChar;\n            }\n\n            if (this.currentToken.tokenId == TokenID.Dot) {\n                enclosedList = new AST[];\n                this.parseDottedName(enclosedList);\n            }\n\n            if (name == null) {\n                name = new MissingIdentifier();\n            }\n\n            var moduleBody = new ASTList();\n            var bodyMinChar = this.scanner.startPos;\n            this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet | ErrorRecoverySet.ID);\n\n            if (svTopLevel && isDynamicMod) {\n                this.allowImportDeclaration = true;\n            } else {\n                this.allowImportDeclaration = false;\n            }\n            this.parseStatementList(\n                errorRecoverySet | ErrorRecoverySet.RCurly, moduleBody,\n                /*sourceElements:*/ true, /*noLeadingCase:*/ true, AllowedElements.Global, modifiers);\n            moduleBody.minChar = bodyMinChar;\n            moduleBody.limChar = this.scanner.pos;\n\n            var endingToken = new ASTSpan();\n            endingToken.minChar = this.scanner.startPos;\n            endingToken.limChar = this.scanner.pos;\n            this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n\n            var limChar = this.scanner.lastTokenLimChar();\n            var moduleDecl: ModuleDeclaration;\n\n            this.allowImportDeclaration = svTopLevel;\n\n            if (enclosedList && (enclosedList.length > 0)) {\n                var len = enclosedList.length;\n                var innerName = <Identifier>enclosedList[len - 1];\n                var innerDecl = new ModuleDeclaration(innerName, moduleBody, this.topVarList(),\n                                                this.topScopeList(), endingToken);\n                innerDecl.preComments = preComments;\n\n                if (this.parsingDeclareFile || hasFl',
v27617=v27618+'ag(modifiers, Modifiers.Ambient)) {\n                    innerDecl.modFlags |= ModuleFlags.Ambient;\n                }\n\n                innerDecl.modFlags |= ModuleFlags.Exported;\n\n                // REVIEW: will also possibly need to re-parent comments as well\n                innerDecl.minChar = minChar;\n                innerDecl.limChar = limChar;\n\n                this.popDeclLists();\n                var outerModBod: ASTList;\n                for (var i = len - 2; i >= 0; i--) {\n                    outerModBod = new ASTList();\n                    outerModBod.append(innerDecl);\n                    innerName = <Identifier>enclosedList[i];\n                    innerDecl = new ModuleDeclaration(innerName, outerModBod, new ASTList(),\n                                                new ASTList(), endingToken);\n                    outerModBod.minChar = innerDecl.minChar = minChar;\n                    outerModBod.limChar = innerDecl.limChar = limChar;\n\n                    if (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)) {\n                        innerDecl.modFlags |= ModuleFlags.Ambient;\n                    }\n\n                    innerDecl.modFlags |= ModuleFlags.Exported;\n                }\n                outerModBod = new ASTList();\n                outerModBod.append(innerDecl);\n                outerModBod.minChar = minChar;\n                outerModBod.limChar = limChar;\n                moduleDecl = new ModuleDeclaration(<Identifier>name, outerModBod, new ASTList(),\n                                            new ASTList(), endingToken);\n            }\n            else {\n                moduleDecl = new ModuleDeclaration(<Identifier>name, moduleBody, this.topVarList(), this.topScopeList(), endingToken);\n                moduleDecl.preComments = preComments;\n                this.popDeclLists();\n            }\n\n            if (this.parsingDeclareFile || svAmbient || hasFlag(modifiers, Modifiers.Ambient)) {\n                moduleDecl.modFlags |= ModuleFlags.Ambient;\n            }\n            if (svAmbient || hasFlag(modifiers, Modifiers.Exported)) {\n                moduleDecl.modFlags |= ModuleFlags.Exported;\n            }\n            if (isDynamicMod) {\n                moduleDecl.modFlags |= ModuleFlags.IsDynamic;\n            }\n\n            this.ambientModule = svAmbient;\n\n            this.topLevel = svTopLevel;\n            moduleDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n            moduleDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n            moduleDecl.limChar = moduleBody.limChar;\n            return moduleDecl;\n        }\n\n        private parseTypeReferenceTail(errorRecoverySet: ErrorRecoverySet, minChar: number, term: AST): TypeReference {\n            var result = new TypeReference(term, 0);\n            result.minChar = minChar;\n            while (this.currentToken.tokenId == TokenID.OpenBracket) {\n                this.currentToken = this.scanner.scan();\n                result.arrayCount++;\n                this.checkCurrentToken(TokenID.CloseBracket, errorRecoverySet | ErrorRecoverySet.LBrack);\n            }\n            result.limChar = this.scanner.lastTokenLimChar();\n            return result;\n        }\n\n        // REVIEW: Consider renaming to parseTypeName.\n        private parseNamedType(errorRecoverySet: ErrorRecoverySet, minChar: number, term: AST, tail: bool): AST {\n            this.currentToken = this.scanner.scan();\n            if (this.currentToken.tokenId == TokenID.Dot) {\n                var curpos = this.scanner.pos;\n                this.currentToken = this.scanner.scan();\n                // Don\'t allow reserved words if immediately after a new line and error recovery is enabled\n                if ((this.currentToken.tokenId == TokenID.Identifier) || ((!this.errorRecovery || !this.scanner.lastTokenHadNewline()) && convertTokToID(this.currentToken, this.strictMode))) {\n                    var op2 = Identifier.fromToken(this.currentToken);\n                    op2.minChar = this.scanner.startPos;\n                    op2.limChar = this.scanner.pos;\n                    var dotNode = new BinaryExpression(NodeType.Dot, term, op2);\n                    dotNode.minChar = term.minChar;\n                    dotNode.limChar = op2.limChar;\n                    return this.parseNamedType(errorRecoverySet, minChar,\n                                            dotNode, tail);\n                }\n                else {\n                    this.reportParseError("need identifier after \'.\'");\n                    if (this.errorRecovery) {\n                        term.flags |= ASTFlags.DotLHS;\n                        // We set "limChar" to be slightly innacurate for completion list behavior\n                        // (last AST node from "quickParse" will match DotLHS and be at end of file position)\n                        // This is to match the behavior of TokenId.Dot processing in parsePostfixOperators.\n                        term.limChar = this.scanner.las',
v27616=v27617+'tTokenLimChar();\n                        return term;\n                    }\n                    else {\n                        var eop2 = new MissingIdentifier();\n                        eop2.minChar = this.scanner.pos;\n                        eop2.limChar = this.scanner.pos;\n                        var edotNode = new BinaryExpression(NodeType.Dot, term, eop2);\n                        edotNode.flags |= ASTFlags.Error;\n                        edotNode.minChar = term.minChar;\n                        edotNode.limChar = eop2.limChar;\n                        return this.parseNamedType(errorRecoverySet, minChar,\n                                                edotNode, tail);\n                    }\n                }\n            }\n            else {\n                if (tail) {\n                    return this.parseTypeReferenceTail(errorRecoverySet, minChar, term);\n                }\n                else {\n                    return term;\n                }\n            }\n        }\n\n        // REVIEW: Reconsider renaming this to parseType to match the grammar.\n        private parseTypeReference(errorRecoverySet: ErrorRecoverySet, allowVoid: bool): AST {\n            var minChar = this.scanner.startPos;\n            var isConstructorMember = false;\n\n            switch (this.currentToken.tokenId) {\n                case TokenID.Void:\n                    if (!allowVoid) {\n                        this.reportParseError("void not a valid type in this context");\n                    }\n                // Intentional fall-through\n                case TokenID.Any:\n                case TokenID.Number:\n                case TokenID.Bool:\n                case TokenID.String: {\n                    var text = tokenTable[this.currentToken.tokenId].text;\n                    var predefinedIdentifier = new Identifier(text);\n                    predefinedIdentifier.minChar = minChar;\n                    predefinedIdentifier.limChar = this.scanner.pos;\n                    this.currentToken = this.scanner.scan();\n                    return this.parseTypeReferenceTail(errorRecoverySet, minChar, predefinedIdentifier);\n                }\n\n                case TokenID.Identifier:\n                    var ident = this.createRef(this.currentToken.getText(), (<IdentifierToken>this.currentToken).hasEscapeSequence, minChar);\n                    ident.limChar = this.scanner.pos;\n                    return this.parseNamedType(errorRecoverySet, minChar, ident, true);\n\n                case TokenID.OpenBrace:\n                    return this.parseObjectType(minChar, errorRecoverySet);\n\n                case TokenID.New:\n                    this.currentToken = this.scanner.scan();\n                    // can\'t use chkCurrentTok, since we don\'t want to advance the token\n                    if (this.currentToken.tokenId != TokenID.OpenParen) {\n                        this.reportParseError("Expected \'(\'");\n                    }\n                    else {\n                        isConstructorMember = true;\n                        // fall through...\n                    }\n\n                case TokenID.OpenParen: {\n                    // ( formals ) => type\n                    var formals = new ASTList();\n                    var variableArgList =\n                        this.parseFormalParameterList(errorRecoverySet | ErrorRecoverySet.RParen,\n                                            formals, false, true, false, false, false, false, null, true);\n                    this.checkCurrentToken(TokenID.EqualsGreaterThan, errorRecoverySet);\n                    var returnType = this.parseTypeReference(errorRecoverySet, true);\n                    var funcDecl = new FuncDecl(null, null, false, formals, null, null, null,\n                                                NodeType.FuncDecl);\n                    funcDecl.returnTypeAnnotation = returnType;\n                    funcDecl.variableArgList = variableArgList;\n                    funcDecl.fncFlags |= FncFlags.Signature;\n\n                    if (isConstructorMember) {\n                        funcDecl.fncFlags |= FncFlags.ConstructMember;\n                        funcDecl.hint = "_construct";\n                        funcDecl.classDecl = null;\n                    }\n                    funcDecl.minChar = minChar;\n                    return this.parseTypeReferenceTail(errorRecoverySet, minChar, funcDecl);\n                }\n\n                default:\n                    this.reportParseError("Expected type name");\n                    var etr = new TypeReference(null, 0);\n                    etr.flags |= ASTFlags.Error;\n                    etr.minChar = this.scanner.pos;\n                    etr.limChar = this.scanner.pos;\n                    return etr;\n            }\n        }\n\n        private parseObjectType(minChar: number, errorRecoverySet: ErrorRecoverySet): TypeReference {\n            this.currentToken = this.scanner.scan();\n\n            var members = new ASTList();\n            members.minChar = minChar;\n\n            var prevInInter',
v27615=v27616+'faceDecl = this.inInterfaceDecl;\n            this.inInterfaceDecl = true;\n            this.parseTypeMemberList(errorRecoverySet | ErrorRecoverySet.RCurly, members);\n            this.inInterfaceDecl = prevInInterfaceDecl;\n\n            this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n\n            // REVIEW: We\'re parsing an ObjectType, but we give a NodeType of Interface here.\n            var interfaceDecl = new InterfaceDeclaration(\n                this.anonId, members, /*extends:*/ null, /*implementsL*/ null);\n\n            interfaceDecl.minChar = minChar;\n            interfaceDecl.limChar = members.limChar;    // "}"\n\n            return this.parseTypeReferenceTail(errorRecoverySet, minChar, interfaceDecl);\n        }\n\n        private parseFunctionBlock(errorRecoverySet: ErrorRecoverySet,\n                                   allowedElements: AllowedElements,\n                                   parentModifiers: Modifiers,\n                                   bod: ASTList,\n                                   bodMinChar: number): void {\n            this.state = ParseState.StartStatementList;\n            this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet | ErrorRecoverySet.StmtStart);\n            var savedInFunction = this.inFunction;\n            this.inFunction = true;\n            this.parseStatementList(\n                errorRecoverySet | ErrorRecoverySet.RCurly | ErrorRecoverySet.StmtStart,\n                bod, /*sourceElements:*/ true, /*noLeadingCase:*/ false, allowedElements, parentModifiers);\n            bod.minChar = bodMinChar;\n            bod.limChar = this.scanner.pos;\n            this.inFunction = savedInFunction;\n            var ec = new EndCode();\n            ec.minChar = bod.limChar;\n            ec.limChar = ec.minChar;\n            bod.append(ec);\n        }\n\n        private parseFunctionStatements(errorRecoverySet: ErrorRecoverySet,\n                                        name: Identifier,\n                                        isConstructor: bool,\n                                        isMethod: bool,\n                                        args: ASTList,\n                                        allowedElements: AllowedElements,\n                                        minChar: number,\n                                        requiresSignature: bool,\n                                        parentModifiers: Modifiers) {\n\n            this.pushDeclLists();\n            // start new statement stack\n            var svStmtStack = this.statementInfoStack;\n            this.resetStmtStack();\n\n            var bod: ASTList = null;\n            var wasShorthand = false;\n            var isAnonLambda = false;\n            var limChar: number;\n\n            if (requiresSignature) {\n                // If we require a signature, but they provided a block, then give an error, but\n                // still consume the block.\n                limChar = this.scanner.pos;\n                if (this.currentToken.tokenId === TokenID.OpenBrace) {\n                    this.reportParseError("Function declarations are not permitted within interfaces, ambient modules or classes")\n                    bod = new ASTList();\n                    var bodMinChar = this.scanner.startPos;\n\n                    this.parseFunctionBlock(errorRecoverySet, allowedElements, parentModifiers, bod, bodMinChar);\n                    this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n\n                    // If there\'s also a semicolon, then just skip over it.  We don\'t want to report an \n                    // additional error here.\n                    if (this.currentToken.tokenId === TokenID.Semicolon) {\n                        this.currentToken = this.scanner.scan();\n                    }\n                }\n                else {\n                    this.checkCurrentToken(TokenID.Semicolon, errorRecoverySet, "Expected \';\'");\n                }\n            }\n            else {\n                bod = new ASTList();\n                var bodMinChar = this.scanner.startPos;\n                if (this.currentToken.tokenId == TokenID.EqualsGreaterThan) {\n                    if (isMethod) {\n                        this.reportParseError("\'=>\' may not be used for class methods");\n                    }\n                    wasShorthand = true;\n                    this.currentToken = this.scanner.scan();\n                }\n\n                if (wasShorthand && this.currentToken.tokenId != TokenID.OpenBrace) {\n                    var retExpr = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon,\n                                            OperatorPrecedence.Assignment, true,\n                                            TypeContext.NoTypes);\n                    var retStmt = new ReturnStatement();\n                    retStmt.returnExpression = retExpr;\n                    retStmt.minChar = retExpr.minChar;\n                    retStmt.limChar = retExpr.limChar;\n                    bod.minChar = bodMinChar;\n                    bod.append(retStmt);\n ',
v27614=v27615+'               }\n                else {\n                    isAnonLambda = wasShorthand;\n                    this.parseFunctionBlock(errorRecoverySet, allowedElements, parentModifiers, bod, bodMinChar);\n                }\n\n                limChar = this.scanner.pos;\n            }\n\n            var funcDecl = new FuncDecl(name, bod, isConstructor, args, this.topVarList(),\n                                        this.topScopeList(), this.topStaticsList(), NodeType.FuncDecl);\n            this.popDeclLists();\n            var scopeList = this.topScopeList();\n            scopeList.append(funcDecl);\n            var staticFuncDecl = false;\n\n            if (!requiresSignature) {\n                if (!wasShorthand || isAnonLambda) {\n                    funcDecl.endingToken = new ASTSpan();\n                    funcDecl.endingToken.minChar = this.scanner.startPos;\n                    funcDecl.endingToken.limChar = this.scanner.pos;\n                    this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n\n                    if (isAnonLambda) {\n                        funcDecl.fncFlags |= FncFlags.IsFatArrowFunction;\n                    }\n                }\n                else {\n                    funcDecl.fncFlags |= FncFlags.IsFatArrowFunction;\n                    funcDecl.endingToken = new ASTSpan();\n\n                    funcDecl.endingToken.minChar = bod.members[0].minChar;\n                    funcDecl.endingToken.limChar = bod.members[0].limChar;\n                }\n            }\n            funcDecl.minChar = minChar;\n            funcDecl.limChar = limChar;\n\n            if (!requiresSignature) {\n                funcDecl.fncFlags |= FncFlags.Definition;\n            }\n\n            this.statementInfoStack = svStmtStack;\n            return funcDecl;\n        }\n\n        private transformAnonymousArgsIntoFormals(formals: ASTList, argList: AST) : bool {\n\n            var translateBinExOperand = (operand: AST) : bool => {\n                if (operand.nodeType == NodeType.Comma) {\n                    return this.transformAnonymousArgsIntoFormals(formals, operand);\n                }\n                else if (operand.nodeType == NodeType.Name || operand.nodeType == NodeType.Asg) {\n                    var opArg = operand.nodeType == NodeType.Asg ? (<BinaryExpression>operand).operand1 : operand;\n\n                    var arg = new ArgDecl(<Identifier>opArg);\n                    arg.preComments = opArg.preComments;\n                    arg.postComments = opArg.postComments;\n                    arg.minChar = operand.minChar;\n                    arg.limChar = operand.limChar;\n\n                    if (hasFlag(opArg.flags, ASTFlags.PossibleOptionalParameter)) {\n                        arg.isOptional = true;\n                    }\n\n                    if (operand.nodeType == NodeType.Asg) {\n                        arg.init = (<BinaryExpression>operand).operand2;\n                    }\n\n                    formals.append(arg);\n\n                    return arg.isOptional || arg.init;\n                }\n                else {\n                    this.reportParseError("Invalid lambda argument");\n                }\n                return false;\n            }\n\n            if (argList) {\n                if (argList.nodeType == NodeType.Comma) {\n                    var commaList = <BinaryExpression> argList;\n                    if (commaList.operand1.isParenthesized) { \n                        this.reportParseError("Invalid lambda argument", commaList.operand1.minChar, commaList.operand1.limChar);\n                    }\n                    if (commaList.operand2.isParenthesized) { \n                        this.reportParseError("Invalid lambda argument", commaList.operand2.minChar, commaList.operand2.limChar);\n                    }\n                    var isOptional = translateBinExOperand(commaList.operand1);\n                    isOptional = translateBinExOperand(commaList.operand2) || isOptional;\n                    return isOptional;\n                }\n                else {\n                    return translateBinExOperand(argList);\n                }\n            }\n        }\n\n        private parseFormalParameterList(errorRecoverySet: ErrorRecoverySet,\n                                            formals: ASTList,\n                                            isClassConstr: bool,\n                                            isSig: bool,\n                                            isIndexer: bool,\n                                            isGetter: bool,\n                                            isSetter: bool,\n                                            isLambda: bool,\n                                            preProcessedLambdaArgs: AST,\n                                            expectClosingRParen: bool): bool \n        {\n\n            formals.minChar = this.scanner.startPos; // \'(\' or \'[\'\n            if (isIndexer) {\n                this.currentToken = this.scanner.scan();\n            }\n            else if (!isLambda) {\n                this.ch',
v27613=v27614+'eckCurrentToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.RParen);\n            }\n            var sawEllipsis = false;\n            var firstArg = true;\n            var hasOptional = false;\n            var haveFirstArgID = false;\n\n            // if preProcessedLambdaArgs is "true", we either have a typeless argument list, or we have\n            // a single identifier node and the current token is the \':\' before a typereference\n            if (isLambda && preProcessedLambdaArgs && preProcessedLambdaArgs.nodeType != NodeType.EmptyExpr) {\n                hasOptional = this.transformAnonymousArgsIntoFormals(formals, preProcessedLambdaArgs);\n                haveFirstArgID = true;\n            }\n\n            while (true) {\n                var munchedArg = false;\n                var argFlags = VarFlags.None;\n                var argMinChar = this.scanner.startPos;\n\n                if (this.inferPropertiesFromThisAssignment && this.currentToken.tokenId == TokenID.This) {\n                    if (!isClassConstr) {\n                        this.reportParseError("Instance property declarations using \'this\' may only be used in class constructors");\n                    }\n                    this.currentToken = this.scanner.scan(); // consume the \'.\'\n\n                    argFlags |= (VarFlags.Public | VarFlags.Property);\n                    if (this.currentClassDefinition) {\n                        this.currentClassDefinition.varFlags |= VarFlags.ClassSuperMustBeFirstCallInConstructor;\n                    }\n                }\n                if (this.currentToken.tokenId == TokenID.Public) {\n                    argFlags |= (VarFlags.Public | VarFlags.Property);\n\n                    if (this.currentClassDefinition) {\n                        this.currentClassDefinition.varFlags |= VarFlags.ClassSuperMustBeFirstCallInConstructor;\n                    }\n                }\n                else if (this.currentToken.tokenId == TokenID.Private) {\n                    argFlags |= (VarFlags.Private | VarFlags.Property);\n\n                    if (this.currentClassDefinition) {\n                        this.currentClassDefinition.varFlags |= VarFlags.ClassSuperMustBeFirstCallInConstructor;\n                    }\n                }\n                else if (this.currentToken.tokenId == TokenID.Static && isClassConstr) {\n                    this.reportParseError("Static properties can not be declared as parameter properties");\n                    this.currentToken = this.scanner.scan();\n                }\n\n                if (argFlags != VarFlags.None) {\n                    if (!isClassConstr) {\n                        this.reportParseError("only constructor parameters can be properties");\n                    }\n                    this.currentToken = this.scanner.scan();\n\n                    if (isModifier(this.currentToken)) { \n                        this.reportParseError("Multiple modifiers may not be applied to parameters");\n                        this.currentToken = this.scanner.scan();\n                    }\n\n                    if (this.inferPropertiesFromThisAssignment && this.currentToken.tokenId == TokenID.This) {\n                        if (!isClassConstr) {\n                            this.reportParseError("Instance property declarations using \'this\' may only be used in class constructors");\n                        }\n                        this.currentToken = this.scanner.scan(); // consume the \'.\'\n                        this.currentToken = this.scanner.scan();\n                    }\n                }\n                else if (this.currentToken.tokenId == TokenID.DotDotDot) {\n                    sawEllipsis = true;\n                    this.currentToken = this.scanner.scan();\n\n                    if (!(this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                        this.reportParseError("\'...\' parameters require both a parameter name and an array type annotation to be specified");\n                        sawEllipsis = false; // Do not treat this parameter as vararg\n                    }\n                }\n\n                var argId: Identifier = null;\n\n                if (!haveFirstArgID && (this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                    argId = Identifier.fromToken(this.currentToken);\n                    argId.minChar = this.scanner.startPos;\n                    argId.limChar = this.scanner.pos;\n                }\n\n                if (haveFirstArgID || argId) {\n                    munchedArg = true;\n                    var type: AST = null;\n                    var arg: ArgDecl = null;\n\n                    if (haveFirstArgID && formals.members.length) {\n                        arg = <ArgDecl>formals.members[formals.members.length - 1];\n\n                        if (arg.isOptional) {\n                            hasOptional = true;\n                        }\n                    }\n         ',
v27612=v27613+'           else {\n                        arg = new ArgDecl(argId);\n\n                        if (isGetter) {\n                            this.reportParseError("Property getters may not take any arguments");\n                        }\n\n                        if (isSetter && !firstArg) {\n                            this.reportParseError("Property setters may only take one argument");\n                        }\n\n                        arg.minChar = argMinChar;\n                        arg.preComments = this.parseComments();\n                        this.currentToken = this.scanner.scan();\n                    }\n\n                    if (this.currentToken.tokenId == TokenID.Question) {\n                        arg.isOptional = true;\n                        hasOptional = true;\n                        this.currentToken = this.scanner.scan();\n                    }\n\n                    if (this.currentToken.tokenId == TokenID.Colon) {\n                        this.currentToken = this.scanner.scan();\n                        type = this.parseTypeReference(errorRecoverySet, false);\n                    }\n\n                    // check for default parameter\n                    // REVIEW: In the case of a typed reference, assume that parseTypeReference or one\n                    // of its children in the call graph advanced tok\n                    if (this.currentToken.tokenId == TokenID.Equals) {\n                        if (isSig) {\n                            this.reportParseError("Arguments in signatures may not have default values");\n                        }\n\n                        hasOptional = true;\n                        this.currentToken = this.scanner.scan();\n                        arg.init = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                            OperatorPrecedence.Comma, false,\n                                            TypeContext.NoTypes);\n\n                    }\n\n                    if (hasOptional && !arg.isOptionalArg() && !sawEllipsis) {\n                        this.reportParseError("Optional parameters may only be followed by other optional parameters");\n                    }\n\n                    if (sawEllipsis && arg.isOptionalArg()) {\n                        this.reportParseError("Varargs may not be optional or have default parameters");\n                    }\n\n                    if (sawEllipsis && !type) {\n                        // Ellipsis is missing a type definition\n                        this.reportParseError("\'...\' parameters require both a parameter name and an array type annotation to be specified");\n                    }\n\n                    // REVIEW: Ok for lambdas?\n                    arg.postComments = this.parseComments();\n                    arg.typeExpr = type;\n                    arg.limChar = this.scanner.lastTokenLimChar();\n                    arg.varFlags |= argFlags;\n                    if (!haveFirstArgID) {\n                        formals.append(arg);\n                    }\n                    else {\n                        haveFirstArgID = false;\n                    }\n                }\n                firstArg = false;\n                if (this.currentToken.tokenId == TokenID.Comma) {\n                    if ((munchedArg) && (!sawEllipsis)) {\n                        this.currentToken = this.scanner.scan();\n                        continue;\n                    }\n                    else {\n                        this.reportParseError("Unexpected \',\' in argument list");\n                        if (this.errorRecovery) {\n                            this.currentToken = this.scanner.scan();\n                            continue;\n                        }\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n\n            if (isIndexer) {\n                this.checkCurrentToken(TokenID.CloseBracket, errorRecoverySet | ErrorRecoverySet.LCurly | ErrorRecoverySet.SColon);\n            }\n            else if (expectClosingRParen) {\n                this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.LCurly | ErrorRecoverySet.SColon);\n            }\n            formals.limChar = this.scanner.lastTokenLimChar(); // \')\' or \']\'\n            return sawEllipsis;\n        }\n\n        private parseFncDecl(errorRecoverySet: ErrorRecoverySet,\n                             isDecl: bool,\n                             requiresSignature: bool,\n                             isMethod: bool,\n                             methodName: Identifier,\n                             indexer: bool,\n                             isStatic: bool,\n                             markedAsAmbient: bool,\n                             modifiers: Modifiers,\n                             lambdaArgContext: ILambdaArgumentContext,\n                             expectClosingRParen: bool): AST {\n\n            var leftCurlyCount = this.scanner.leftCurlyCount;\n            var rightCurlyCount = this.scanner.rightCurlyC',
v27611=v27612+'ount;\n\n            var prevInConstr = this.parsingClassConstructorDefinition;\n            this.parsingClassConstructorDefinition = false;\n\n            var name: Identifier = null;\n            var fnMin = this.scanner.startPos;\n            var minChar = this.scanner.pos;\n            var prevNestingLevel = this.nestingLevel;\n            var preComments = this.parseComments();\n            var isLambda = !!lambdaArgContext;\n            this.nestingLevel = 0;\n            if ((!this.style_funcInLoop) && this.inLoop()) {\n                this.reportParseStyleError("function declaration in loop");\n            }\n            if (!isMethod && !isStatic && !indexer && !lambdaArgContext) {\n                // past function keyword\n                this.currentToken = this.scanner.scan();\n                this.state = ParseState.StartFncDecl;\n                if ((this.currentToken.tokenId != TokenID.Identifier) && (!convertTokToID(this.currentToken, this.strictMode))) {\n                    if (isDecl) {\n                        this.reportParseError("Function declaration must include identifier");\n\n                        this.nestingLevel = prevNestingLevel;\n                        return new IncompleteAST(fnMin, this.scanner.pos);\n                    }\n                }\n                else {\n                    name = Identifier.fromToken(this.currentToken);\n                    name.minChar = this.scanner.startPos;\n                    name.limChar = this.scanner.pos;\n                    this.currentToken = this.scanner.scan();\n                }\n            }\n            else {\n                if (methodName) {\n                    name = methodName;\n                }\n            }\n\n            this.state = ParseState.FncDeclName;\n            var args: ASTList = new ASTList();\n            var variableArgList = false;\n            var isOverload = false;\n            var isGetter = hasFlag(modifiers, Modifiers.Getter);\n            var isSetter = hasFlag(modifiers, Modifiers.Setter);\n            if ((this.currentToken.tokenId == TokenID.OpenParen) || (indexer && (this.currentToken.tokenId == TokenID.OpenBracket)) || (lambdaArgContext && (lambdaArgContext.preProcessedLambdaArgs || this.currentToken.tokenId == TokenID.DotDotDot))) {\n                // arg list\n                variableArgList = this.parseFormalParameterList(errorRecoverySet, args, false, requiresSignature, indexer, isGetter, isSetter, isLambda, lambdaArgContext ? lambdaArgContext.preProcessedLambdaArgs : null, expectClosingRParen);\n            }\n            this.state = ParseState.FncDeclArgs;\n            var returnType: AST = null;\n            if (this.currentToken.tokenId == TokenID.Colon) {\n                this.currentToken = this.scanner.scan();\n                if (hasFlag(modifiers, Modifiers.Setter)) {\n                    this.reportParseError("Property setters may not declare a return type");\n                }\n                returnType = this.parseTypeReference(errorRecoverySet, true);\n            }\n\n            if (indexer && args.members.length == 0) {\n                this.reportParseError("Index signatures require a parameter type to be specified");\n            }\n            this.state = ParseState.FncDeclReturnType;\n\n            if (isLambda && this.currentToken.tokenId != TokenID.EqualsGreaterThan) {\n                this.reportParseError("Expected \'=>\'");\n            }\n\n            // REVIEW:\n            // Currently, it\'s imperative that ambient functions *not* be marked as overloads.  At some point, we may\n            // want to unify the two concepts internally\n            if (isDecl && !(this.parsingDeclareFile || markedAsAmbient) && (!isMethod || !(this.ambientModule || this.ambientClass || this.inInterfaceDecl)) && this.currentToken.tokenId == TokenID.Semicolon) {\n                isOverload = true;\n                isDecl = false;\n                requiresSignature = true;\n            }\n            var svInFncDecl = this.inFncDecl;\n            this.inFncDecl = true;\n            var funcDecl: FuncDecl =\n                this.parseFunctionStatements(\n                errorRecoverySet | ErrorRecoverySet.RCurly,\n                name, /*isConstructor:*/ false, isMethod, args, AllowedElements.None,\n                minChar, requiresSignature, Modifiers.None);\n\n            this.inFncDecl = svInFncDecl;\n            funcDecl.variableArgList = variableArgList;\n            funcDecl.isOverload = isOverload;\n\n            if (!requiresSignature) { // REVIEW: What\'s the point of this?  Why not just use \'Signature\' instead of \'Definition\'?\n                funcDecl.fncFlags |= FncFlags.Definition;\n            }\n\n            if (isStatic) {\n                funcDecl.fncFlags |= FncFlags.Static;\n            }\n\n            if (requiresSignature) {\n                funcDecl.fncFlags |= FncFlags.Signature;\n            }\n            if (indexer) {\n                funcDecl.fncFlags |= FncFlags.IndexerMember;\n            }\n            funcDecl.returnTypeAnnotation = returnType;',
v27610=v27611+'\n            if (isMethod) {\n                funcDecl.fncFlags |= FncFlags.Method;\n                // all class property methods are currently exported\n                funcDecl.fncFlags |= FncFlags.ClassPropertyMethodExported;\n            }\n            funcDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n            funcDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n\n            this.nestingLevel = prevNestingLevel;\n            this.parsingClassConstructorDefinition = prevInConstr;\n            funcDecl.preComments = preComments;\n            return funcDecl;\n        }\n\n        private convertToTypeReference(ast: AST): TypeReference {\n            var result: TypeReference;\n            switch (ast.nodeType) {\n                case NodeType.TypeRef:\n                    return <TypeReference>ast;\n                case NodeType.Name:\n                    result = new TypeReference(ast, 0);\n                    result.minChar = ast.minChar;\n                    result.limChar = ast.limChar;\n                    return result;\n                case NodeType.Index: {\n                    var expr = <BinaryExpression>ast;\n                    result = this.convertToTypeReference(expr.operand1);\n                    if (result) {\n                        result.arrayCount++;\n                        result.minChar = expr.minChar;\n                        result.limChar = expr.limChar;\n                        return result;\n                    }\n                    else {\n                        var etr = <TypeReference>new AST(NodeType.Error);\n                        return etr;\n                    }\n                }\n            }\n            return null;\n        }\n\n        private parseArgList(errorRecoverySet: ErrorRecoverySet): ASTList {\n            var args: ASTList = new ASTList();\n            args.minChar = this.scanner.startPos;\n\n            // skip left paren\n            this.currentToken = this.scanner.scan();\n\n            if (this.currentToken.tokenId !== TokenID.CloseParen) {\n                while (true) {\n                    if (args.members.length > 0xffff) {\n                        this.reportParseError("max number of args exceeded");\n                        break;\n                    }\n\n                    var arg = this.parseExpr(\n                        ErrorRecoverySet.Comma | errorRecoverySet,\n                        OperatorPrecedence.Comma, \n                        /*allowIn:*/ true,\n                        TypeContext.NoTypes);\n\n                    args.append(arg);\n                    if (this.currentToken.tokenId != TokenID.Comma) {\n                        break;\n                    }\n\n                    this.currentToken = this.scanner.scan();\n                }\n            }\n\n            args.limChar = this.scanner.pos;\n            return args;\n        }\n\n        private parseBaseList(extendsList: ASTList,\n                              implementsList: ASTList,\n                              errorRecoverySet: ErrorRecoverySet,\n                              isClass: bool): void {\n            var keyword = true;\n            var currentList = extendsList;\n            for (; ;) {\n                if (keyword) {\n                    if (this.currentToken.tokenId === TokenID.Implements) {\n                        currentList = implementsList;\n                    }\n                    else if (this.currentToken.tokenId == TokenID.Extends && !this.requiresExtendsBlock) {\n                        this.requiresExtendsBlock = isClass;\n                    }\n                    this.currentToken = this.scanner.scan();\n                    keyword = false;\n                }\n                var baseName: Identifier = null;\n                if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                    var minChar = this.scanner.startPos;\n                    baseName = Identifier.fromToken(this.currentToken);\n                    baseName.minChar = minChar;\n                    baseName.limChar = this.scanner.pos;\n                    baseName = <Identifier>this.parseNamedType(errorRecoverySet | ErrorRecoverySet.LCurly,\n                                            minChar, baseName, false);\n                }\n                else {\n                    this.reportParseError("Expected base name");\n                    if (this.errorRecovery) {\n                        baseName = new MissingIdentifier();\n                        baseName.minChar = this.scanner.pos;\n                        baseName.limChar = this.scanner.pos;\n                        baseName.flags |= ASTFlags.Error;\n                    }\n                }\n                if (this.currentToken.tokenId == TokenID.OpenParen) {\n                    if (isClass) {\n                        this.reportParseError("Base classes may only be initialized via a \'super\' call within the constructor body");\n                    }\n                    else {\n                        th',
v27609=v27610+'is.reportParseError("Interfaces may not be extended with a call expression");\n                    }\n                }\n                else {\n                    currentList.append(baseName);\n                }\n\n                if (isClass && currentList == extendsList && extendsList.members.length > 1) {\n                    this.reportParseError("A class may only extend one other class");\n                }\n\n                if (this.currentToken.tokenId == TokenID.Comma) {\n                    this.currentToken = this.scanner.scan();\n                    continue;\n                }\n\n                else if ((this.currentToken.tokenId == TokenID.Extends) ||\n                         (this.currentToken.tokenId == TokenID.Implements)) {\n\n                    if (this.currentToken.tokenId == TokenID.Extends && !this.requiresExtendsBlock) {\n                        this.requiresExtendsBlock = isClass;\n                    }\n\n                    currentList = extendsList;\n                    keyword = true;\n                    continue;\n                }\n\n                break;\n            }\n        }\n\n        private parseClassDecl(errorRecoverySet: ErrorRecoverySet, minChar: number, modifiers: Modifiers): ClassDeclaration {\n            var leftCurlyCount = this.scanner.leftCurlyCount;\n            var rightCurlyCount = this.scanner.rightCurlyCount;\n\n            if ((modifiers & Modifiers.Readonly) != Modifiers.None) {\n                this.reportParseError("const modifier is implicit for class");\n            }\n\n            // mark the class as ambient, as necessary\n            if (this.parsingDeclareFile || this.ambientModule) {\n                modifiers |= Modifiers.Ambient;\n                modifiers |= Modifiers.Exported;\n            }\n            var classIsMarkedAsAmbient = this.parsingDeclareFile || (modifiers & Modifiers.Ambient) != Modifiers.None;\n            var svAmbientClass = this.ambientClass;\n            this.ambientClass = classIsMarkedAsAmbient;\n\n            // grab the class\'s name\n            this.currentToken = this.scanner.scan();\n            var name: Identifier = null;\n            if ((this.currentToken.tokenId == TokenID.Identifier) || (!isPrimitiveTypeToken(this.currentToken) && convertTokToID(this.currentToken, this.strictMode)) ) {\n                name = Identifier.fromToken(this.currentToken);\n                name.minChar = this.scanner.startPos;\n                name.limChar = this.scanner.pos;\n                this.currentToken = this.scanner.scan();\n            }\n            else {\n                this.reportParseError("class missing name");\n                if (this.errorRecovery) {\n                    name = new MissingIdentifier();\n                    name.minChar = this.scanner.pos;\n                    name.limChar = this.scanner.pos;\n                    name.flags |= ASTFlags.Error;\n                }\n            }\n\n            var extendsList: ASTList = null;\n            var implementsList: ASTList = null;\n            var requiresSignature = false;\n\n            if ((this.currentToken.tokenId == TokenID.Extends) ||\n                (this.currentToken.tokenId == TokenID.Implements)) {\n                extendsList = new ASTList();\n                implementsList = new ASTList();\n                this.parseBaseList(extendsList, implementsList, errorRecoverySet, /*isClass:*/ true);\n            }\n\n            // REVIEW: Note that we don\'t set this as the current class decl\n            var classDecl = new ClassDeclaration(name, new ASTList(), extendsList, implementsList);\n\n            this.currentClassDefinition = classDecl;\n\n            // parse the classes members\n            this.parseClassElements(classDecl, errorRecoverySet, modifiers);\n\n            if (this.ambientModule || this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Exported)) {\n                classDecl.varFlags |= VarFlags.Exported;\n            }\n\n            if (this.ambientModule || hasFlag(modifiers, Modifiers.Ambient)) {\n                classDecl.varFlags |= VarFlags.Ambient;\n            }\n\n            classDecl.varFlags |= VarFlags.Class;\n\n            this.ambientClass = svAmbientClass;\n            classDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n            classDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n            return classDecl;\n        }\n\n        private parseClassElements(classDecl: ClassDeclaration, errorRecoverySet: ErrorRecoverySet, parentModifiers: Modifiers) {\n            var modifiers = parentModifiers;\n            var resetModifiers = false;\n\n            var membersMinChar = this.scanner.startPos;\n            this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet);\n\n            this.nestingLevel++;\n\n            var currentMemberMinChar = this.scanner.startPos;\n            var wasGetOrSetId = false;\n\n            while (!(this.currentToken.tokenId == TokenID.CloseBrace || this.currentToken.tokenId == TokenID.EndOfFile)) {\n                var scanNext = true;',
v27608=v27609+'\n                var publicOrPrivateFlags = Modifiers.Public | Modifiers.Private;\n\n                // modifiers\n                if (this.currentToken.tokenId == TokenID.Get) {\n                    if (modifiers & Modifiers.Getter) {\n                        this.reportParseError("Duplicate \'get\' declaration in class body");\n                    }\n                    if (modifiers & Modifiers.Setter) {\n                        this.reportParseError("Getter already marked as a setter");\n                    }\n                    modifiers |= Modifiers.Getter;\n                }\n                else if (this.currentToken.tokenId == TokenID.Set) {\n                    if (modifiers & Modifiers.Setter) {\n                        this.reportParseError("Duplicate \'set\' declaration in class body");\n                    }\n                    if (modifiers & Modifiers.Getter) {\n                        this.reportParseError("Setter already marked as a getter");\n                    }\n                    modifiers |= Modifiers.Setter;\n\n                }\n                else if (this.currentToken.tokenId == TokenID.Private) {\n                    if (modifiers & publicOrPrivateFlags) {\n                        this.reportParseError("Multiple modifiers may not be applied to class members");\n                    }\n                    modifiers |= Modifiers.Private;\n                }\n                else if (this.currentToken.tokenId == TokenID.Public) {\n                    if (modifiers & publicOrPrivateFlags) {\n                        this.reportParseError("Multiple modifiers may not be applied to class members");\n                    }\n                    modifiers |= Modifiers.Public;\n                }\n                else if (this.currentToken.tokenId == TokenID.Static) {\n                    if (modifiers & Modifiers.Static) { // only check for double instances of static\n                        this.reportParseError("Multiple modifiers may not be applied to class members");\n                    }\n                    modifiers |= Modifiers.Static;\n                }  // constructors\n                else if (this.currentToken.tokenId == TokenID.Constructor) {\n\n                    if (modifiers != parentModifiers) {\n                        this.reportParseError("Constructors may not have modifiers");\n                    }\n\n                    this.parseClassConstructorDeclaration(currentMemberMinChar, errorRecoverySet, modifiers);\n                    scanNext = false; // parsing functions advances the token for us\n                    resetModifiers = true;\n                }  // member declarations\n                else if (wasGetOrSetId || this.currentToken.tokenId == TokenID.Identifier || convertTokToIDName(this.currentToken)) {\n\n                    var idText = wasGetOrSetId ? ((modifiers & Modifiers.Getter) ? "get" : "set") : this.currentToken.getText();\n                    var id = wasGetOrSetId ? new Identifier(idText) : Identifier.fromToken(this.currentToken);\n                    id.minChar = this.scanner.startPos;\n                    id.limChar = this.scanner.pos;\n\n                    // unset the get/set bit, if we\'re using it for an id\n                    if (wasGetOrSetId) {\n                        modifiers = modifiers ^ ((modifiers & Modifiers.Getter) ? Modifiers.Getter : Modifiers.Setter);\n                        wasGetOrSetId = false;\n                    }\n                    else {\n                        this.currentToken = this.scanner.scan();\n                    }\n\n                    if (this.currentToken.tokenId == TokenID.OpenParen) {\n                        this.parseClassMemberFunctionDeclaration(id, currentMemberMinChar, errorRecoverySet, modifiers);\n                        scanNext = false; // parsing functions advances the token for us\n                    }\n                    else {\n                        if (modifiers & Modifiers.Getter || modifiers & Modifiers.Setter) {\n                            this.reportParseError("Property accessors must be functions");\n                        }\n\n                        var varDecl = this.parseClassMemberVariableDeclaration(id, currentMemberMinChar, false, errorRecoverySet, modifiers);\n\n                        if (varDecl.init && varDecl.init.nodeType == NodeType.FuncDecl) {\n                            if (this.currentToken.tokenId == TokenID.CloseBrace) {\n                                scanNext = false;\n                            }\n                        }\n                        else if (varDecl.init && varDecl.init.nodeType == NodeType.ObjectLit && this.currentToken.tokenId != TokenID.Semicolon) {\n                            scanNext = false;\n                            varDecl.init.flags |= ASTFlags.AutomaticSemicolon;\n                        }\n                        else if (this.currentToken.tokenId != TokenID.Semicolon) {\n                            this.reportParseError("Expected \';\'");\n                            scanNext = false;\n                        }',
v27607=v27608+"\n                    }\n\n                    resetModifiers = true;\n                } // catch errant uses of 'super'\n                else if (this.currentToken.tokenId == TokenID.Super) {\n                    this.reportParseError(\"Base class initializers must be the first statement in a class definition\");\n                }\n                else if (!wasGetOrSetId && ((modifiers & Modifiers.Getter) || (modifiers & Modifiers.Setter)) &&\n                         ((this.currentToken.tokenId == TokenID.OpenParen) || (this.currentToken.tokenId == TokenID.Equals) ||\n                          (this.currentToken.tokenId == TokenID.Colon) || (this.currentToken.tokenId == TokenID.Semicolon))) {\n                             // catch a 'get' or 'set' used as an identifier\n                    wasGetOrSetId = true;\n                    scanNext = false;\n\n                }  // mark anything else as an error\n                else if (this.currentToken.tokenId != TokenID.Semicolon) { // jettison semicolons\n                    this.reportParseError(\"Unexpected '\" + this.currentToken.getText() + \"' in class definition\");\n                    resetModifiers = true;\n                }\n\n                if (scanNext) {\n                    this.currentToken = this.scanner.scan();\n                }\n\n                if (resetModifiers) {\n                    modifiers = parentModifiers;\n                    currentMemberMinChar = this.scanner.startPos;\n                    resetModifiers = false;\n                }\n            }\n\n            var membersLimChar = this.scanner.pos;\n            if (this.currentToken.tokenId == TokenID.CloseBrace) {\n                classDecl.endingToken = new ASTSpan();\n                classDecl.endingToken.minChar = this.scanner.startPos;\n                classDecl.endingToken.limChar = this.scanner.pos;\n\n                // for a class with an empty body, consume any 'dangling' inner comments\n                if (!this.currentClassDefinition.members.members.length) {\n                    this.currentClassDefinition.preComments = this.parseComments();\n                }\n\n                this.currentToken = this.scanner.scan();\n            }\n\n            this.nestingLevel--;\n\n            this.currentClassDefinition.members.minChar = membersMinChar;\n            this.currentClassDefinition.members.limChar = membersLimChar;\n            this.currentClassDefinition.limChar = membersLimChar;\n            this.currentClassDefinition = null;\n        }\n\n        private parseClassConstructorDeclaration(minChar: number, errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers) {\n            this.parsingClassConstructorDefinition = true;\n\n            var isAmbient = this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient);\n\n            var args: ASTList = new ASTList();\n            var variableArgList = false;\n            var preComments = this.parseComments();\n\n            this.currentToken = this.scanner.scan(); // scan past the 'constructor' token\n\n            if (this.currentToken.tokenId == TokenID.OpenParen) {\n                variableArgList = this.parseFormalParameterList(errorRecoverySet, args, true, isAmbient, false, false, false, false, null, true);\n                if (args.members.length > 0) {\n                    var lastArg = args.members[args.members.length - 1];\n                }\n            }\n\n            var requiresSignature = isAmbient || this.currentToken.tokenId == TokenID.Semicolon;\n\n\n            if (requiresSignature) {\n                for (var i = 0; i < args.members.length; i++) {\n                    var arg = <ArgDecl> args.members[i];\n                    if (hasFlag(arg.varFlags, VarFlags.Property)) {\n                        this.reportParseError(\"Overload or ambient signatures may not specify parameter properties\", arg.minChar, arg.limChar);\n                    }\n                }\n            }\n\n            if (!requiresSignature) {\n                this.currentClassDefinition.constructorNestingLevel = this.nestingLevel + 1;\n            }\n\n            var constructorFuncDecl = this.parseFunctionStatements(\n                errorRecoverySet | ErrorRecoverySet.RCurly, this.currentClassDefinition.name, \n                /*isConstructor:*/ true, /*isMethod:*/ false, args, AllowedElements.Properties, \n                minChar, requiresSignature, modifiers);\n\n            constructorFuncDecl.preComments = preComments;\n\n            if (requiresSignature && !isAmbient) {\n                constructorFuncDecl.isOverload = true;\n            }\n\n            constructorFuncDecl.variableArgList = variableArgList;\n            this.currentClassDecl = null;\n            constructorFuncDecl.returnTypeAnnotation = this.convertToTypeReference(this.currentClassDefinition.name);\n            constructorFuncDecl.classDecl = this.currentClassDefinition;\n\n            if (isAmbient) {\n                constructorFuncDecl.fncFlags |= FncFlags.Ambient;\n            }\n\n            if (requiresSignature) {\n                constructorF",
v27606=v27607+'uncDecl.fncFlags |= FncFlags.Signature;\n            }\n\n            if (this.ambientModule || hasFlag(modifiers, Modifiers.Exported)) {\n                constructorFuncDecl.fncFlags |= FncFlags.Exported;\n            }\n\n\n            if (this.currentClassDefinition.constructorDecl) {\n                if (!isAmbient && !this.currentClassDefinition.constructorDecl.isSignature() && !constructorFuncDecl.isSignature()) {\n                    this.reportParseError("Duplicate constructor definition");\n                }\n            }\n\n            if (isAmbient || !constructorFuncDecl.isSignature()) {\n                this.currentClassDefinition.constructorDecl = constructorFuncDecl;\n            }\n\n            // REVIEW: Should we have a separate flag for class constructors?  (Constructors are not methods)\n            constructorFuncDecl.fncFlags |= FncFlags.ClassMethod;\n\n            this.currentClassDefinition.members.members[this.currentClassDefinition.members.members.length] = constructorFuncDecl;\n\n            this.parsingClassConstructorDefinition = false;\n\n            return constructorFuncDecl;\n        }\n\n        private parseClassMemberVariableDeclaration(text: Identifier, minChar: number, isDeclaredInConstructor: bool, errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers) {\n\n            var varDecl = new VarDecl(text, this.nestingLevel);\n            varDecl.minChar = minChar;\n            var isStatic = false;\n            varDecl.preComments = this.parseComments();\n\n            if (this.currentToken.tokenId == TokenID.Colon) {\n                this.currentToken = this.scanner.scan();\n                varDecl.typeExpr =\n                    this.parseTypeReference(errorRecoverySet | ErrorRecoverySet.Asg | ErrorRecoverySet.Comma, false);\n                if (varDecl.typeExpr && varDecl.typeExpr.nodeType == NodeType.TypeRef) {\n                    var typeExpr = (<TypeReference>varDecl.typeExpr);\n                    if (typeExpr.term && typeExpr.term.nodeType == NodeType.FuncDecl) {\n                        typeExpr.term.preComments = varDecl.preComments;\n                    }\n                }\n            }\n\n            if (this.currentToken.tokenId == TokenID.Equals) {\n                if (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)) {\n                    this.reportParseError("context does not permit variable initializer");\n                    if (this.errorRecovery) {\n                        this.skip(errorRecoverySet);\n                        varDecl.flags |= ASTFlags.Error;\n                        varDecl.limChar = this.scanner.lastTokenLimChar();\n                        return varDecl;\n                    }\n                }\n\n                // TODO: note assignment for language service\n                this.currentToken = this.scanner.scan();\n\n                varDecl.init = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                        OperatorPrecedence.Comma, true, TypeContext.NoTypes);\n\n                varDecl.limChar = varDecl.init.limChar;\n\n                // member initializers on instance properties require that super be invoked as the first call within the constructor\n                if (!(modifiers & Modifiers.Static)) {\n                    this.currentClassDefinition.varFlags |= VarFlags.ClassSuperMustBeFirstCallInConstructor;\n                }\n            }\n            else {\n                varDecl.limChar = this.scanner.pos;\n            }\n\n            if (modifiers & Modifiers.Static) {\n                varDecl.varFlags |= VarFlags.Static;\n                isStatic = true;\n            }\n\n            if ((modifiers & Modifiers.Private) != Modifiers.None) {\n                varDecl.varFlags |= VarFlags.Private;\n            }\n            else {\n                varDecl.varFlags |= VarFlags.Public;\n            }\n\n            varDecl.varFlags |= VarFlags.Property;\n\n            if (isDeclaredInConstructor) {\n                varDecl.varFlags |= VarFlags.ClassConstructorProperty;\n            }\n\n            if (!isDeclaredInConstructor && !isStatic) {\n                varDecl.varFlags |= VarFlags.ClassBodyProperty;\n            }\n\n            this.currentClassDefinition.knownMemberNames[text.actualText] = true;\n\n            if (!isDeclaredInConstructor) {\n                this.currentClassDefinition.members.members[this.currentClassDefinition.members.members.length] = varDecl;\n            }\n\n            varDecl.postComments = this.parseComments();\n            return varDecl;\n        }\n\n        private parseClassMemberFunctionDeclaration(methodName: Identifier, minChar: number, errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers) {\n            var wasAccessorID = this.prevIDTok != null;\n            var isAccessor = hasFlag(modifiers, Modifiers.Getter) || hasFlag(modifiers, Modifiers.Setter);\n            var isStatic = hasFlag(modifiers, Modifiers.Static);\n\n            var isAmbient = this.ambientModule || hasFlag(modifiers, Modifiers.Ambient);\n\n            er',
v27605=v27606+'rorRecoverySet |= ErrorRecoverySet.RParen;\n\n            if (isAccessor && (modifiers & Modifiers.Ambient)) {\n                this.reportParseError("Property accessors may not be declared in ambient classes");\n            }\n\n            // REVIEW: Why bother passing in isAmbient for both requiresSignature and isAmbient?  Shouldn\'t just saying its ambient suffice?\n            var ast: AST = this.parseFncDecl(errorRecoverySet, true, isAmbient, true, methodName, false, isStatic, isAmbient, modifiers, null, true);\n            if (ast.nodeType == NodeType.Error) {\n                return ast;\n            }\n\n            var funcDecl = <FuncDecl>ast;\n\n            funcDecl.minChar = minChar;\n            if (funcDecl.bod !== null)\n                funcDecl.limChar = funcDecl.bod.limChar;\n\n            if (modifiers & Modifiers.Private) {\n                funcDecl.fncFlags |= FncFlags.Private;\n            }\n            else {\n                funcDecl.fncFlags |= FncFlags.Public;\n            }\n\n            if (isStatic) {\n                funcDecl.fncFlags |= FncFlags.Static;\n            }\n\n            if (isAccessor) {\n                // REVIEW: verify return-type annotations and arguments\n                if (hasFlag(modifiers, Modifiers.Getter)) {\n                    funcDecl.fncFlags |= FncFlags.GetAccessor;\n                    funcDecl.hint = "get" + funcDecl.name.actualText;\n                }\n                else {\n                    funcDecl.fncFlags |= FncFlags.SetAccessor;\n                    funcDecl.hint = "set" + funcDecl.name.actualText;\n                }\n                funcDecl.fncFlags |= FncFlags.IsFunctionExpression;\n                if (codeGenTarget < CodeGenTarget.ES5) {\n                    this.reportParseError("Property accessors are only available when targeting ES5 or greater", funcDecl.minChar, funcDecl.limChar);\n                }\n            }\n\n            funcDecl.fncFlags |= FncFlags.ClassMethod;\n\n            this.currentClassDefinition.knownMemberNames[methodName.actualText] = true;\n\n            this.currentClassDefinition.members.members[this.currentClassDefinition.members.members.length] = funcDecl;\n\n            return funcDecl;\n        }\n\n        private parseTypeMember(errorRecoverySet: ErrorRecoverySet): AST {\n            var minChar = this.scanner.startPos;\n\n            var propertyDecl = this.parsePropertyDeclaration(\n                errorRecoverySet, Modifiers.Public, /*requireSignature:*/ true, /*isStatic:*/ false);\n\n            if (propertyDecl) {\n                propertyDecl.minChar = minChar;\n\n                if (propertyDecl.nodeType == NodeType.VarDecl) {\n                     this.checkCurrentToken(TokenID.Semicolon, errorRecoverySet);\n                }\n            }\n\n            return propertyDecl;\n        }\n\n        private parseTypeMemberList(errorRecoverySet: ErrorRecoverySet, members: ASTList) {\n            errorRecoverySet |= ErrorRecoverySet.TypeScriptS;\n            while (true) {\n                switch (this.currentToken.tokenId) {\n                    case TokenID.CloseBrace:\n                    case TokenID.EndOfFile:\n                        members.limChar = this.scanner.pos;\n                        return;\n                }\n\n                // REVIEW: This code looks suspect.  If parseTypeMember returns null, then \n                // won\'t we just infinite loop?\n                var element = this.parseTypeMember(errorRecoverySet);\n                if (element) {\n                    members.append(element);\n                }\n            }\n        }\n\n        private parseInterfaceDecl(errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers): InterfaceDeclaration {\n            var leftCurlyCount = this.scanner.leftCurlyCount;\n            var rightCurlyCount = this.scanner.rightCurlyCount;\n\n            this.currentToken = this.scanner.scan();\n            var minChar = this.scanner.pos;\n            var name: Identifier = null;\n            if ((this.currentToken.tokenId == TokenID.Identifier) || (!isPrimitiveTypeToken(this.currentToken) && convertTokToID(this.currentToken, this.strictMode))) {\n                name = Identifier.fromToken(this.currentToken);\n                name.minChar = this.scanner.startPos;\n                name.limChar = this.scanner.pos;\n                this.currentToken = this.scanner.scan();\n            }\n            else {\n                this.reportParseError("interface missing name");\n                if (this.errorRecovery) {\n                    name = new MissingIdentifier();\n                    name.minChar = this.scanner.pos;\n                    name.limChar = this.scanner.pos;\n                    name.flags |= ASTFlags.Error;\n                }\n            }\n\n            var extendsList: ASTList = null;\n            var implementsList: ASTList = null;\n            if (this.currentToken.tokenId === TokenID.Extends || this.currentToken.tokenId === TokenID.Implements) {\n                if (this.currentToken.tokenId === TokenID.Implements) {\n            ',
v27604=v27605+'        this.reportParseError("Expected \'extends\'");\n                }\n\n                extendsList = new ASTList();\n                implementsList = new ASTList();\n                extendsList.minChar = this.scanner.startPos;\n                this.parseBaseList(extendsList, implementsList, errorRecoverySet, /*isClass:*/ false);\n            }\n\n            var membersMinChar = this.scanner.startPos;\n            this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet | ErrorRecoverySet.TypeScriptS);\n            var members = new ASTList();\n            members.minChar = membersMinChar;\n            var prevInInterfaceDecl = this.inInterfaceDecl;\n            this.inInterfaceDecl = true;\n            this.parseTypeMemberList(errorRecoverySet | ErrorRecoverySet.RCurly, members);\n            this.inInterfaceDecl = prevInInterfaceDecl;\n            this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n\n            // REVIEW: According to the grammar, an interface declaration should actually just\n            // have an \'ObjectType\' and not a list of members.  We may want to consider making that\n            // change.  Note: it would mean breaking aparat TypeDecl into InterfaceDeclaration and \n            // ClassDeclaration.\n            var interfaceDecl = new InterfaceDeclaration(name, members, extendsList, null);\n            if (hasFlag(modifiers, Modifiers.Private)) {\n                interfaceDecl.varFlags |= VarFlags.Private;\n            }\n            if (hasFlag(modifiers, Modifiers.Public)) {\n                interfaceDecl.varFlags |= VarFlags.Public;\n            }\n            if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Exported)) {\n                interfaceDecl.varFlags |= VarFlags.Exported;\n            }\n\n            interfaceDecl.limChar = members.limChar;\n            interfaceDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n            interfaceDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n            return interfaceDecl;\n        }\n\n        private makeVarDecl(id: Identifier, nest: number): VarDecl {\n            var varDecl = new VarDecl(id, nest);\n            var currentVarList = this.topVarList();\n            if (currentVarList) {\n                currentVarList.append(varDecl);\n            }\n            return varDecl;\n        }\n\n        private parsePropertyDeclaration(\n            errorRecoverySet: ErrorRecoverySet,\n            modifiers: Modifiers,\n            requireSignature: bool,\n            isStatic: bool): AST {\n\n            var text: Identifier = null;\n            var minChar = this.scanner.startPos;\n            var nameLimChar = minChar;\n            var isNew = false;\n            var isIndexer = false;\n            var wasAccessorID = this.prevIDTok != null;\n            var isAccessor = hasFlag(modifiers, Modifiers.Getter) || hasFlag(modifiers, Modifiers.Setter);\n\n            if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Ambient)) {\n                requireSignature = true;\n            }\n\n            if (this.currentToken.tokenId == TokenID.OpenParen && !wasAccessorID) {\n                if (!requireSignature && !isStatic) {\n                    this.reportParseError("Expected identifier in property declaration");\n                    if (this.errorRecovery) {\n                        this.skip(errorRecoverySet);\n                        //REVIEW: Use something else than "Identifier"?\n                        text = new MissingIdentifier();\n                    }\n                }\n            }\n            else if (this.currentToken.tokenId == TokenID.New) {\n                if (requireSignature) {\n                    this.currentToken = this.scanner.scan();\n                    if (this.currentToken.tokenId == TokenID.OpenParen) {\n                        isNew = true;\n                    }\n                }\n\n                if (!isNew) {\n                    // is identifier\n                    if (!requireSignature) {\n                        this.currentToken = this.scanner.scan();\n                    }\n                    text = new Identifier("new");\n                    text.minChar = this.scanner.pos - 3;\n                    text.limChar = this.scanner.pos;\n                    nameLimChar = this.scanner.pos;\n                }\n            }\n            else if ((this.currentToken.tokenId == TokenID.OpenBracket) && requireSignature) {\n                // indexer signature\n                isIndexer = true;\n                //REVIEW: Should we use a special "compiler reserved" identifier node?\n                text = new Identifier("__item");\n            }\n            else if ((this.currentToken.tokenId != TokenID.Identifier) && (!convertTokToIDName(this.currentToken)) && !wasAccessorID) {\n                this.reportParseError("Expected identifier in property declaration");\n                if (this.errorRecovery) {\n                    var eminChar = this.scanner.startPos;\n             ',
v27603=v27604+'       var curpos = this.scanner.pos;\n                    this.skip(errorRecoverySet & (~ErrorRecoverySet.Comma));\n                    if (this.scanner.pos == curpos) {\n                        // ensure progress\n                        this.currentToken = this.scanner.scan();\n                    }\n\n                    var epd = new VarDecl(new MissingIdentifier(), this.nestingLevel);\n                    epd.flags |= ASTFlags.Error;\n                    epd.minChar = eminChar;\n                    epd.limChar = this.scanner.lastTokenLimChar();\n                    return epd;\n                }\n            }\n            else {\n                if (wasAccessorID) {\n                    text = Identifier.fromToken(this.prevIDTok);\n                    text.minChar = this.scanner.lastTokenLimChar() - 3;\n                    text.limChar = this.scanner.lastTokenLimChar();\n                    nameLimChar = text.limChar;\n\n                    if (codeGenTarget < CodeGenTarget.ES5) {\n                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                    }\n\n                    // this block guards against \'get\' and \'set\' tokens that\n                    // were coerced into identifiers\n                    if (this.currentToken.getText() == text.actualText && this.currentToken != this.prevIDTok) {\n                        this.currentToken = this.scanner.scan();\n                    } // Otherwise, don\'t update the token - we\'re already at \'(\'\n\n                    // reset the previous ID Token\n                    this.prevIDTok = null;\n                }\n                else {\n                    text = Identifier.fromToken(this.currentToken);\n                    text.minChar = this.scanner.startPos;\n                    text.limChar = this.scanner.pos;\n                    nameLimChar = this.scanner.pos;\n                    this.currentToken = this.scanner.scan();\n                }\n            }\n\n            if (this.currentToken.tokenId == TokenID.Question) {\n                if (this.inInterfaceDecl && text) {\n                    text.flags |= ASTFlags.OptionalName;\n                }\n                else {\n                    this.reportParseError("Optional properties may only be declared on interface or object types");\n                }\n                this.currentToken = this.scanner.scan();\n            }\n\n            if ((this.currentToken.tokenId == TokenID.OpenParen) ||\n                (isIndexer && (this.currentToken.tokenId == TokenID.OpenBracket))) {\n                var ers = errorRecoverySet | ErrorRecoverySet.RParen;\n                if (isIndexer) {\n                    ers = errorRecoverySet | ErrorRecoverySet.RBrack;\n                }\n                var ast = this.parseFncDecl(ers, true, requireSignature,\n                                       !this.inFncDecl, text, isIndexer, isStatic, (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)), modifiers, null, true);\n                var funcDecl: FuncDecl;\n                if (ast.nodeType == NodeType.Error) {\n                    return ast;\n                }\n                else {\n                    funcDecl = <FuncDecl>ast;\n                }\n                if (funcDecl.name) {\n                    funcDecl.name.minChar = minChar;\n                    funcDecl.name.limChar = nameLimChar;\n                }\n                if ((modifiers & Modifiers.Public) != Modifiers.None) {\n                    funcDecl.fncFlags |= FncFlags.Public;\n                }\n                if ((modifiers & Modifiers.Private) != Modifiers.None) {\n                    funcDecl.fncFlags |= FncFlags.Private;\n                }\n                if (isStatic) {\n                    funcDecl.fncFlags |= FncFlags.Static;\n                }\n                if (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)) {\n                    funcDecl.fncFlags |= FncFlags.Ambient;\n                }\n                if (isAccessor) {\n                    // REVIEW: verify return-type annotations and arguments\n                    if (hasFlag(modifiers, Modifiers.Getter)) {\n                        funcDecl.fncFlags |= FncFlags.GetAccessor;\n                        funcDecl.hint = "get" + funcDecl.name.actualText;\n                    }\n                    else {\n                        funcDecl.fncFlags |= FncFlags.SetAccessor;\n                        funcDecl.hint = "set" + funcDecl.name.actualText;\n                    }\n                    funcDecl.fncFlags |= FncFlags.IsFunctionExpression;\n\n                    if (modifiers & Modifiers.Ambient) {\n                        this.reportParseError("Property accessors may not be declared in ambient types");\n                    }\n                }\n\n                if (text == null) {\n                    if (isNew) {\n                        funcDecl.fncFlags |= FncFlags.ConstructMember;\n                        funcDecl.hint = "_construct";\n                        funcDecl.classDecl = thi',
v27602=v27603+'s.currentClassDecl;\n                    }\n                    else {\n                        funcDecl.hint = "_call";\n                        funcDecl.fncFlags |= FncFlags.CallMember;\n                    }\n                }\n                return funcDecl;\n            }\n            else {\n                var varDecl = new VarDecl(text, this.nestingLevel);\n                varDecl.preComments = this.parseComments();\n                varDecl.minChar = minChar;\n                if (this.currentToken.tokenId == TokenID.Colon) {\n                    this.currentToken = this.scanner.scan();\n                    varDecl.typeExpr =\n                        this.parseTypeReference(errorRecoverySet | ErrorRecoverySet.Asg |\n                                           ErrorRecoverySet.Comma, false);\n                    if (varDecl.typeExpr && varDecl.typeExpr.nodeType == NodeType.TypeRef) {\n                        var typeExpr = (<TypeReference>varDecl.typeExpr);\n                        if (typeExpr.term && typeExpr.term.nodeType == NodeType.FuncDecl) {\n                            typeExpr.term.preComments = varDecl.preComments;\n                        }\n                    }\n                }\n                if (this.currentToken.tokenId == TokenID.Equals) {\n                    if (requireSignature) {\n                        this.reportParseError("context does not permit variable initializer");\n                        if (this.errorRecovery) {\n                            this.skip(errorRecoverySet);\n                            varDecl.flags |= ASTFlags.Error;\n                            varDecl.limChar = this.scanner.lastTokenLimChar();\n                            return varDecl;\n                        }\n                    }\n                    // TODO: note assignment for language service\n                    this.currentToken = this.scanner.scan();\n                    varDecl.init = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                           OperatorPrecedence.Comma, true, TypeContext.NoTypes);\n                    varDecl.limChar = varDecl.init.limChar;\n                    if (varDecl.init.nodeType == NodeType.FuncDecl) {\n                        var funcDecl = <FuncDecl>varDecl.init;\n                        funcDecl.hint = varDecl.id.text;\n                        funcDecl.boundToProperty = varDecl;\n                    }\n                    else if (isAccessor) {\n                        this.reportParseError("Accessors may only be functions");\n                    }\n                }\n                else {\n                    varDecl.limChar = this.scanner.pos;\n                }\n                if ((modifiers & Modifiers.Readonly) != Modifiers.None) {\n                    varDecl.varFlags |= VarFlags.Readonly;\n                }\n                if (isStatic) {\n                    varDecl.varFlags |= VarFlags.Static;\n                }\n                if ((modifiers & Modifiers.Public) != Modifiers.None) {\n                    varDecl.varFlags |= VarFlags.Public;\n                }\n                if ((modifiers & Modifiers.Private) != Modifiers.None) {\n                    varDecl.varFlags |= VarFlags.Private;\n                }\n                varDecl.varFlags |= VarFlags.Property;\n                return varDecl;\n            }\n        }\n\n        private parseVariableDeclaration(\n            errorRecoverySet: ErrorRecoverySet,\n            modifiers: Modifiers,\n            allowIn: bool,\n            isStatic: bool): AST {\n\n            var isConst = hasFlag(modifiers, Modifiers.Readonly);\n            var minChar = this.scanner.startPos;\n            var varDecl: VarDecl = null;\n            var declList: ASTList = null;\n            var multivar = false;\n\n            this.currentToken = this.scanner.scan();\n            var varDeclPreComments = this.parseComments();\n\n            while (true) {\n                if ((this.currentToken.tokenId != TokenID.Identifier) && (!convertTokToID(this.currentToken, this.strictMode))) {\n                    this.reportParseError("Expected identifier in variable declaration");\n\n                    if (this.errorRecovery) {\n                        varDecl = new VarDecl(new MissingIdentifier(), this.nestingLevel);\n                        varDecl.minChar = minChar;\n                        this.skip(errorRecoverySet);\n                        varDecl.flags |= ASTFlags.Error;\n                        varDecl.limChar = this.scanner.lastTokenLimChar();\n                        return varDecl;\n                    }\n                }\n\n                var varDeclName = Identifier.fromToken(this.currentToken)\n                if (this.strictMode && (varDeclName.text == "eval")) {\n                    this.reportParseError("\'eval\' may not name a variable in strict mode");\n                }\n\n                varDecl = this.makeVarDecl(varDeclName, this.nestingLevel);\n                varDecl.id.minChar = this.scanner.startPos;\n                varDecl.id.limChar = this.scanner.pos;\n  ',
v27601=v27602+'              varDecl.preComments = varDeclPreComments;\n\n                if (isStatic) {\n                    varDecl.varFlags |= VarFlags.Static;\n                }\n                if (hasFlag(modifiers, Modifiers.Readonly)) {\n                    varDecl.varFlags |= VarFlags.Readonly;\n                }\n                if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Ambient)) {\n                    varDecl.varFlags |= VarFlags.Ambient;\n                }\n                if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Exported)) {\n                    varDecl.varFlags |= VarFlags.Exported;\n                }\n                varDecl.minChar = minChar;\n                if (declList) {\n                    declList.append(varDecl);\n                }\n\n                // move past ID; with error recovery need a test \n                this.currentToken = this.scanner.scan();\n                if (this.currentToken.tokenId == TokenID.Colon) {\n                    this.currentToken = this.scanner.scan();\n                    var prevInFncDecl = this.inFncDecl;\n                    this.inFncDecl = false;\n                    varDecl.typeExpr = this.parseTypeReference(\n                        errorRecoverySet | ErrorRecoverySet.Asg | ErrorRecoverySet.Comma, /*allowVoid:*/ false);\n                    this.inFncDecl = prevInFncDecl;\n                }\n\n                if (this.currentToken.tokenId == TokenID.Equals) {\n                    if (hasFlag(varDecl.varFlags, VarFlags.Ambient)) {\n                        this.reportParseError("Ambient variable can not have an initializer");\n                    }\n                    // TODO: note assignment for language service\n                    this.currentToken = this.scanner.scan();\n                    varDecl.init = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                           OperatorPrecedence.Comma, allowIn,\n                                           TypeContext.NoTypes);\n                    varDecl.limChar = varDecl.init.limChar;\n                    if (varDecl.init.nodeType == NodeType.FuncDecl) {\n                        // TODO: use \'as\' operator when can bootstrap\n                        var funcDecl = <FuncDecl>varDecl.init;\n                        funcDecl.hint = varDecl.id.actualText;\n                    }\n                }\n                else {\n                    if (isConst) {\n                        this.reportParseError("const declaration requires initializer");\n                    }\n                    varDecl.limChar = this.scanner.pos;\n                }\n                varDecl.postComments = this.parseCommentsForLine(this.scanner.line);\n\n                if (this.currentToken.tokenId != TokenID.Comma) {\n                    if (declList) {\n                        declList.limChar = varDecl.limChar;\n                        return declList;\n                    }\n                    else {\n                        return varDecl;\n                    }\n                }\n\n                if (!multivar) {\n                    declList = new ASTList();\n                    declList.minChar = varDecl.minChar;\n                    declList.append(varDecl);\n                    multivar = true;\n                }\n\n                this.currentToken = this.scanner.scan();\n                minChar = this.scanner.startPos;\n            }\n        }\n\n        private parseMemberList(errorRecoverySet: ErrorRecoverySet): ASTList {\n            var elements = new ASTList();\n            if (this.currentToken.tokenId == TokenID.CloseBrace) {\n                return elements;\n            }\n\n            var idHint: string = null;\n            var memberName: AST = null;\n            var memberExpr: AST = null;\n            var member: BinaryExpression = null;\n            var minChar = this.scanner.startPos;\n            var isSet = false;\n            var skippedTokenForGetSetId = false;\n            var getSetTok: Token = null;\n            var getSetStartPos = 0;\n            var getSetPos = 0;\n\n            for (; ;) {\n                var accessorPattern = false;\n                if (this.currentToken.tokenId == TokenID.Get || this.currentToken.tokenId == TokenID.Set) {\n                    isSet = this.currentToken.tokenId == TokenID.Set;\n                    getSetTok = this.currentToken;\n                    getSetStartPos = this.scanner.startPos;\n                    getSetPos = this.scanner.pos;\n\n                    this.currentToken = this.scanner.scan();\n\n                    if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToIDName(this.currentToken)) {\n                        idHint = isSet ? "set" : "get";\n                        idHint = idHint + this.currentToken.getText();\n                        memberName = Identifier.fromToken(this.currentToken);\n                        memberName.minChar = this.scanner.startPos;\n                        accessorPattern = true;\n                   ',
v27600=v27601+'     if (codeGenTarget < CodeGenTarget.ES5) {\n                            this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                        }\n                    }\n                    else if (this.currentToken.tokenId != TokenID.Colon) {\n                        this.reportParseError("Expected identifier, string or number as accessor name");\n                    }\n                    else {\n                        skippedTokenForGetSetId = true;\n                        memberName = Identifier.fromToken(getSetTok);\n                        memberName.minChar = getSetStartPos;\n                        memberName.limChar = getSetPos;\n                    }\n                }\n                else if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToIDName(this.currentToken)) {\n                    idHint = this.currentToken.getText();\n                    memberName = Identifier.fromToken(this.currentToken);\n                    memberName.minChar = this.scanner.startPos;\n                    memberName.limChar = this.scanner.pos;\n                }\n                else if (this.currentToken.tokenId == TokenID.StringLiteral) {\n                    idHint = this.currentToken.getText();\n                    memberName = new StringLiteral(idHint);\n                    memberName.minChar = this.scanner.startPos;\n                    memberName.limChar = this.scanner.pos;\n                }\n                    // TODO: allow reserved words\n                else if (this.currentToken.tokenId == TokenID.NumberLiteral) {\n                    var ntok = <NumberLiteralToken>this.currentToken;\n                    idHint = ntok.value.toString();\n                    memberName = new StringLiteral(idHint);\n                    memberName.minChar = this.scanner.startPos;\n                    memberName.limChar = this.scanner.pos;\n                }\n                else {\n                    this.reportParseError("Expected identifier, string or number as member name");\n                    if (this.errorRecovery) {\n                        memberName = new MissingIdentifier();\n                        memberName.minChar = this.scanner.startPos;\n                        memberName.flags |= ASTFlags.Error;\n                        this.skip(errorRecoverySet | ErrorRecoverySet.Comma);\n                        memberName.limChar = this.scanner.lastTokenLimChar();\n                    }\n                }\n\n                if (!skippedTokenForGetSetId) {\n                    this.currentToken = this.scanner.scan();\n                }\n                else {\n                    skippedTokenForGetSetId = false;\n                }\n\n                if (this.currentToken.tokenId == TokenID.Question) {\n                    memberName.flags |= ASTFlags.OptionalName;\n                    this.currentToken = this.scanner.scan();\n                }\n\n                if (accessorPattern) {\n                    var args = new ASTList();\n                    this.parseFormalParameterList(errorRecoverySet | ErrorRecoverySet.RParen,\n                                      args, false, true, false, !isSet, isSet, false, null, true);\n\n                    var funcDecl: FuncDecl =\n                        this.parseFunctionStatements(errorRecoverySet | ErrorRecoverySet.RCurly,\n                                                <Identifier>memberName, false, true, args,\n                                                AllowedElements.None,\n                                                this.scanner.startPos, false, Modifiers.None);\n\n                    if (isSet && funcDecl.returnTypeAnnotation) {\n                        this.reportParseError("Property setters may not declare a return type");\n                    }\n\n                    funcDecl.fncFlags |= isSet ? FncFlags.SetAccessor : FncFlags.GetAccessor;\n                    funcDecl.fncFlags |= FncFlags.IsFunctionExpression;\n                    funcDecl.hint = idHint;\n                    memberExpr = funcDecl;\n                    member = new BinaryExpression(NodeType.Member, memberName, memberExpr);\n                    member.minChar = memberName.minChar;\n                    if (memberExpr.nodeType == NodeType.FuncDecl) {\n                        var funcDecl = <FuncDecl>memberExpr;\n                        funcDecl.hint = idHint;\n                    }\n                }\n                else if (this.currentToken.tokenId == TokenID.Colon) {\n                    this.currentToken = this.scanner.scan();\n                    memberExpr = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                         OperatorPrecedence.Comma, true, TypeContext.NoTypes);\n                    // If the memberExpr is a type reference, we can be certain that it was an\n                    // array type declaraion that lacked a "new".  We can realistically only\n                    // expect call and name ASTs to be the result of this call to parseExpr.\n                   ',
v27599=v27600+" // If it's a constructor without a \"new\", we'll flag it as an invalid\n                    // call site later on.\n                    if (memberExpr.nodeType == NodeType.TypeRef) {\n                        this.reportParseError(\"Expected 'new' on array declaration in member definition\")\n                    }\n                    member = new BinaryExpression(NodeType.Member, memberName, memberExpr);\n                    member.minChar = memberName.minChar;\n                    if (memberExpr.nodeType == NodeType.FuncDecl) {\n                        var funcDecl = <FuncDecl>memberExpr;\n                        funcDecl.hint = idHint;\n                    }\n                }\n                else {\n                    this.reportParseError(\"Expected ':' in member definition\");\n                    if (this.errorRecovery) {\n                        this.skip(errorRecoverySet);\n                        elements.flags |= ASTFlags.Error;\n                        elements.minChar = minChar;\n                        elements.limChar = this.scanner.lastTokenLimChar();\n                        return elements;\n                    }\n                }\n                idHint = null;\n                elements.append(member);\n                member.limChar = this.scanner.lastTokenLimChar();\n                if (this.currentToken.tokenId != TokenID.Comma) {\n                    break;\n                }\n                else {\n                    // munch comma\n                    this.currentToken = this.scanner.scan();\n                }\n\n                // trailing comma allowed\n                if (this.currentToken.tokenId == TokenID.CloseBrace) {\n                    break;\n                }\n            }\n\n            if (member) {\n                elements.limChar = member.limChar;\n            }\n            elements.minChar = minChar;\n            return elements;\n        }\n\n        private parseArrayList(errorRecoverySet: ErrorRecoverySet): ASTList {\n            var elements: ASTList = null;\n            if (this.currentToken.tokenId == TokenID.CloseBracket) {\n                return elements;\n            }\n            else {\n                elements = new ASTList();\n                elements.minChar = this.scanner.startPos;\n            }\n\n            var arg: AST;\n\n            for (; ;) {\n                if ((this.currentToken.tokenId == TokenID.Comma) ||\n                    (this.currentToken.tokenId == TokenID.CloseBracket)) {\n                    arg = new AST(NodeType.EmptyExpr);\n                }\n                else {\n                    arg = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                  OperatorPrecedence.Comma, true, TypeContext.NoTypes);\n                }\n                elements.append(arg);\n                if (this.currentToken.tokenId != TokenID.Comma) {\n                    break;\n                }\n                this.currentToken = this.scanner.scan();\n            }\n            elements.limChar = this.scanner.lastTokenLimChar();\n            return elements;\n        }\n\n        private parseArrayLiteral(errorRecoverySet: ErrorRecoverySet): UnaryExpression {\n            var arrayLiteral: UnaryExpression = null;\n            arrayLiteral = new UnaryExpression(NodeType.ArrayLit,\n                                             this.parseArrayList(errorRecoverySet));\n            return arrayLiteral;\n        }\n\n        private parseTerm(errorRecoverySet: ErrorRecoverySet, allowCall: bool, typeContext: TypeContext, inCast: bool): AST {\n            var ast: AST = null;\n            var sawId = false;\n            var inNew = false;\n            var minChar = this.scanner.startPos;\n            var limChar = this.scanner.pos;\n            var parseAsLambda = false;\n            var expectlambdaRParen = false;\n\n            // keywords first\n            switch (this.currentToken.tokenId) {\n                case TokenID.Number:\n                case TokenID.Bool:\n                case TokenID.Any:\n                case TokenID.String:\n                    var tid = new Identifier(tokenTable[this.currentToken.tokenId].text);\n                    if (hasFlag(typeContext, TypeContext.Primitive)) {\n                        ast = new TypeReference(tid, 0);\n                        sawId = true;\n                    }\n                    else {\n                        ast = tid;\n                        sawId = true;\n                    }\n                    ast.minChar = minChar;\n                    this.currentToken = this.scanner.scan();\n                    limChar = this.scanner.lastTokenLimChar();\n                    break;\n                case TokenID.This:\n                    ast = new AST(NodeType.This);\n                    ast.minChar = minChar;\n                    this.currentToken = this.scanner.scan();\n                    limChar = this.scanner.lastTokenLimChar();\n                    break;\n                case TokenID.Super:\n                    ast = new AST(NodeType.Super);\n                    ast.minChar =",
v27598=v27599+" minChar;\n                    this.currentToken = this.scanner.scan();\n                    limChar = this.scanner.lastTokenLimChar();\n                    break;\n                case TokenID.True:\n                    ast = new AST(NodeType.True);\n                    this.currentToken = this.scanner.scan();\n                    ast.minChar = minChar;\n                    break;\n                case TokenID.False:\n                    ast = new AST(NodeType.False);\n                    this.currentToken = this.scanner.scan();\n                    ast.minChar = minChar;\n                    break;\n                case TokenID.Null:\n                    ast = new AST(NodeType.Null);\n                    this.currentToken = this.scanner.scan();\n                    ast.minChar = minChar;\n                    break;\n                case TokenID.New:\n                    minChar = this.scanner.pos;\n                    this.currentToken = this.scanner.scan();\n                    var target = this.parseTerm(errorRecoverySet, false, TypeContext.AllSimpleTypes, inCast);\n\n                    if (target.nodeType == NodeType.Error || (target.nodeType == NodeType.Index && (<BinaryExpression>target).operand1.nodeType == NodeType.TypeRef)) {\n                        this.reportParseError(\"Cannot invoke 'new' on this expression\");\n                    } else {\n                        ast = new CallExpression(NodeType.New, target, null);\n                        ast.minChar = minChar;\n                        limChar = this.scanner.lastTokenLimChar();\n                        inNew = true;\n                    }\n                    break;\n                case TokenID.Function:\n                    minChar = this.scanner.pos;\n                    ast = this.parseFncDecl(errorRecoverySet, false, false, false, null, false, false, false, Modifiers.None, null, true);\n                    (<FuncDecl>ast).fncFlags |= FncFlags.IsFunctionExpression;\n                    ast.minChar = minChar;\n                    limChar = this.scanner.lastTokenLimChar();\n                    ast.limChar = limChar;\n                    break;\n            }\n\n            if (ast == null) {\n                if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n\n                    var idText = this.currentToken.getText();\n                    ast = this.createRef(idText, (<IdentifierToken>this.currentToken).hasEscapeSequence, minChar);\n                    sawId = true;\n \n                    ast.minChar = minChar;\n                    this.currentToken = this.scanner.scan();\n\n                    if (this.currentToken.tokenId == TokenID.Question) {\n                        ast.flags |= ASTFlags.PossibleOptionalParameter;\n                    }\n\n                    limChar = this.scanner.lastTokenLimChar();\n                }\n            }\n\n            if (inCast) {\n                this.checkCurrentToken(TokenID.GreaterThan, errorRecoverySet);\n            }\n\n            if (ast == null) {\n                switch (this.currentToken.tokenId) {\n                    case TokenID.OpenParen:\n                        minChar = this.scanner.pos;\n                        var prevTokId = this.scanner.previousToken().tokenId;\n                        this.currentToken = this.scanner.scan();\n\n                        var couldBeLambda = prevTokId == TokenID.OpenParen || // foo(()=>{});\n                                            prevTokId == TokenID.Comma || // foo(x,()=>{});\n                                            prevTokId == TokenID.EqualsEquals || // var foo = ()=>{};\n                                            prevTokId == TokenID.Colon;    // var x = { foo: ()=> {} };\n\n\n                        if (couldBeLambda && this.currentToken.tokenId == TokenID.CloseParen) {\n                            parseAsLambda = true;\n                            expectlambdaRParen = false;\n                            this.currentToken = this.scanner.scan();\n                        }\n                        else if (couldBeLambda && this.currentToken.tokenId == TokenID.DotDotDot) {\n                            parseAsLambda = true;\n                            expectlambdaRParen = true;\n                        }\n                        else {\n                            ast = this.parseExpr(errorRecoverySet | ErrorRecoverySet.RParen,\n                                          OperatorPrecedence.None, true, TypeContext.NoTypes, couldBeLambda);\n                            limChar = this.scanner.lastTokenLimChar();\n                            parseAsLambda = couldBeLambda && (ast.nodeType == NodeType.Name || ast.nodeType == NodeType.Comma) &&\n                                            (this.currentToken.tokenId == TokenID.Colon || this.currentToken.tokenId == TokenID.Question);\n                            expectlambdaRParen = true;\n                        }\n\n                        // Check for the RParen if it's not an anonymous '=>' function\n                       ",
v27597=v27598+" if ((ast && !parseAsLambda)) {\n                            if (hasFlag(ast.flags, ASTFlags.SkipNextRParen)) {\n                                // REVIEW: parseExpr resulted in a lambda node, the LParen scanned earlier, is the beginning of that node, and not of a parenthesized expression;\n                                //         do not look for a matching RParen for this node, but make sure to remove the flag, so that any enclosing parenthesis are matched correctly.\n                                ast.flags = ast.flags & (~(ASTFlags.SkipNextRParen)); \n                                break;\n                            }\n                            this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet);\n                            ast.isParenthesized = true;\n                        }\n\n                        break;\n                    case TokenID.NumberLiteral: {\n                        var numTok = <NumberLiteralToken>this.currentToken;\n                        this.currentToken = this.scanner.scan();\n                        ast = new NumberLiteral(numTok.value, numTok.hasEmptyFraction);\n                        ast.minChar = minChar;\n                        limChar = this.scanner.lastTokenLimChar();\n                        break;\n                    }\n                    case TokenID.StringLiteral:\n                        ast = new StringLiteral(this.currentToken.getText());\n                        this.currentToken = this.scanner.scan();\n                        ast.minChar = minChar;\n                        limChar = this.scanner.lastTokenLimChar();\n                        break;\n                    case TokenID.RegularExpressionLiteral: {\n                        var rtok = <RegularExpressionLiteralToken>this.currentToken;\n                        ast = new RegexLiteral(rtok.regex);\n                        this.currentToken = this.scanner.scan();\n                        ast.minChar = minChar;\n                        limChar = this.scanner.lastTokenLimChar();\n                        break;\n                    }\n                    case TokenID.OpenBracket:\n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        ast = this.parseArrayLiteral(ErrorRecoverySet.RBrack | errorRecoverySet);\n                        ast.minChar = minChar;\n                        limChar = this.scanner.pos; // ']'\n                        this.checkCurrentToken(TokenID.CloseBracket, errorRecoverySet);\n                        break;\n                    // TODO: rescan regex for TokenID.Div and AsgDiv\n                        case TokenID.OpenBrace:\n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        var members = this.parseMemberList(ErrorRecoverySet.RCurly | errorRecoverySet)\n                        this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n                        ast = new UnaryExpression(NodeType.ObjectLit, members);\n                        ast.minChar = minChar;\n                        limChar = this.scanner.lastTokenLimChar();\n                        members.minChar = minChar;\n                        members.limChar = limChar;\n                        break;\n\n                    case TokenID.LessThan:\n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        var term: AST = this.parseTypeReference(ErrorRecoverySet.BinOp, false);\n                        this.checkCurrentToken(TokenID.GreaterThan, errorRecoverySet);\n                        ast = new UnaryExpression(NodeType.TypeAssertion, this.parseExpr(errorRecoverySet, OperatorPrecedence.Unary, false, TypeContext.NoTypes));\n                        (<UnaryExpression>ast).castTerm = term;\n                        break;\n\n                    default:\n                        if (this.prevExpr && hasFlag(this.prevExpr.flags, ASTFlags.PossibleOptionalParameter)) {\n                            parseAsLambda = true;\n                            ast = this.prevExpr;\n                        }\n                        else {\n                            this.reportParseError(\"Check format of expression term\");\n                            if (this.errorRecovery) {\n                                var ident = new MissingIdentifier();\n                                ident.minChar = minChar;\n                                ident.flags |= ASTFlags.Error;\n                                this.skip(errorRecoverySet | ErrorRecoverySet.Postfix);\n                                if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                                    ident.setText(this.currentToken.getText(), (<IdentifierToken>this.currentToken).hasEscapeSequence);\n                                    this.currentToken = this.scanner.scan();\n                       ",
v27596=v27597+'             limChar = this.scanner.lastTokenLimChar();\n                                }\n                                else {\n                                    limChar = this.scanner.lastTokenLimChar();\n                                    //tok=scanner.scan();\n                                }\n\n                                // REVIEW: set sawId\n                                ast = ident;\n                            }\n                        }\n                }\n            }\n\n            if (parseAsLambda) {\n                // If the next token is an fat arrow or a colon, we either have a parameter list, or can rightly assume\n                // that we have a typed formal, so we proceed with the lambda parse\n                if (\n                    this.currentToken.tokenId == TokenID.Colon ||\n                    this.currentToken.tokenId == TokenID.Comma ||\n                    this.currentToken.tokenId == TokenID.CloseParen ||\n                    this.currentToken.tokenId == TokenID.DotDotDot) {\n\n                        // We won\'t scan in the \':\' case, since keeping the \':\' simplifies argument handling in parseFormalParameterList\n                        // Note that we don\'t set the minchar in this case\n                    ast = this.parseLambdaExpr(errorRecoverySet, ast, true /* skipNextRParen */, expectlambdaRParen);\n                    ast.minChar = minChar;\n                    limChar = this.scanner.lastTokenLimChar();\n                    ast.limChar = limChar;\n                }\n                else if (ast) {\n                    ast.isParenthesized = true;\n                }\n            }\n\n            if (sawId && (typeContext != TypeContext.NoTypes)) {\n                typeContext |= TypeContext.ArraySuffix;\n            }\n\n            var postFix = this.parsePostfixOperators(errorRecoverySet, ast, allowCall, inNew, typeContext, minChar, limChar);\n\n            // Defensive error check...\n            if (postFix) {\n                if (sawId && (postFix.nodeType == NodeType.Index)) {\n                    var binExpr = <BinaryExpression>postFix;\n                    if (binExpr.operand2 == null) {\n                        postFix = this.convertToTypeReference(postFix);\n                    }\n                }\n\n                ///////////////////////////////////////////////////////////\n                //TODO: Eventually, we want to remove "minChar" and "limChar" assignments here,\n                //      as they are sometimes not specific enough for each expression kind.\n                postFix.minChar = minChar;\n                // Only update "limChar" if it is not better than "lastTokenLimChar()"\n                postFix.limChar = max(postFix.limChar, this.scanner.lastTokenLimChar());\n                //\n                ///////////////////////////////////////////////////////////\n                return postFix;\n            }\n            else {\n                return new AST(NodeType.Error);\n            }\n\n        }\n\n        private parseLambdaExpr(errorRecoverySet: ErrorRecoverySet, lambdaArgs: AST, skipNextRParen: bool, expectClosingRParen: bool): AST {\n            // REVIEW: Parse the remainder of a lambda expression. The opening paren has been read already, if it existed. \n            //         skipNextRParen sets a flag on the resulting lambda node to tell the calling parseTerm that the LParen it scanned has been matched as part of parsing the formal parameter list\n            //         expectClosingRParen indicates that a closing RParen is expected, in the cases with optional parameter or more than one parameter.\n            var ast = this.parseFncDecl(errorRecoverySet, false, false, false, null, false, false, false, Modifiers.None, { preProcessedLambdaArgs: lambdaArgs }, expectClosingRParen);\n            (<FuncDecl>ast).fncFlags |= FncFlags.IsFunctionExpression;\n            (<FuncDecl>ast).fncFlags |= FncFlags.IsFatArrowFunction;\n            if (!skipNextRParen) {\n                ast.flags |= ASTFlags.SkipNextRParen;\n            }\n            ast.limChar = this.scanner.lastTokenLimChar();;\n            return ast;\n        }\n\n        private parseExpr(errorRecoverySet: ErrorRecoverySet, minPrecedence: number, allowIn: bool,\n            typeContext: TypeContext, possiblyInLambda: bool = false): AST {\n            var ast: AST = null;\n            var tokenInfo = lookupToken(this.currentToken.tokenId);\n            var canAssign: bool = true;\n            var idHint: string = null;\n            var minChar = this.scanner.startPos;\n            var preComments = this.parseComments();\n            var exprIsAnonLambda = false;\n\n            if ((tokenInfo != undefined) && (tokenInfo.unopNodeType != NodeType.None)) {\n                canAssign = false;\n                this.currentToken = this.scanner.scan();\n                var tempExpr = this.parseExpr(ErrorRecoverySet.BinOp | errorRecoverySet,\n                                       tokenInfo.unopPrecedence, allowIn,\n                                       TypeCo',
v27595=v27596+'ntext.NoTypes);\n\n                // fold unary +- into constants\n                if ((tokenInfo.unopNodeType == NodeType.Pos) &&\n                    (tempExpr.nodeType == NodeType.NumberLit)) {\n                    ast = tempExpr;\n                }\n                else if ((tokenInfo.unopNodeType == NodeType.Neg) &&\n                         (tempExpr.nodeType == NodeType.NumberLit)) {\n                    var numLit = <NumberLiteral>tempExpr;\n                    numLit.value = (-numLit.value);\n                    if (numLit.value == 0) {\n                        numLit.isNegativeZero = true;\n                    }\n                    ast = tempExpr;\n                }\n                else {\n                    ast = new UnaryExpression(tokenInfo.unopNodeType, tempExpr);\n                    ast.limChar = tempExpr.limChar;\n                }\n                ast.minChar = minChar;\n            }\n            else {\n                ast = this.parseTerm(ErrorRecoverySet.BinOp | ErrorRecoverySet.AddOp |\n                              errorRecoverySet, true, typeContext, false);\n                var id: Identifier;\n                var temp: AST;\n                if (ast.nodeType == NodeType.Name) {\n                    id = <Identifier>ast;\n                    idHint = id.actualText;\n                }\n                else if (ast.nodeType == NodeType.Dot) {\n\n                    // If this is within a class declaration, and the circumstances are right, we need to\n                    // transform the dotted expression into a member declaration\n                    var subsumedExpr = false;\n\n                    if (this.inferPropertiesFromThisAssignment && \n                        (this.currentToken.tokenId == TokenID.Colon || this.currentToken.tokenId == TokenID.Equals) &&\n                         this.parsingClassConstructorDefinition &&\n                         this.nestingLevel == this.currentClassDefinition.constructorNestingLevel && // this nesting level means we\'re at the top-level in the constructor\n                         (<BinaryExpression>ast).operand1.nodeType == NodeType.This) {\n\n                        if ((<BinaryExpression>ast).operand2.nodeType == NodeType.Name) {\n                            var op2ID: Identifier = (<Identifier>(<BinaryExpression>ast).operand2);\n\n                            if (!this.currentClassDefinition.knownMemberNames[op2ID.actualText]) {\n                                ast = this.parseClassMemberVariableDeclaration(op2ID, ast.minChar, true, errorRecoverySet, Modifiers.Public);\n                                subsumedExpr = true;\n                            }\n                        }\n                    }\n\n                    if (!subsumedExpr) {\n                        temp = ast;\n                        while (temp.nodeType == NodeType.Dot) {\n                            var binExpr = <BinaryExpression>temp;\n                            temp = binExpr.operand2;\n                        }\n                        if (temp.nodeType == NodeType.Name) {\n                             id = <Identifier>temp;\n                            idHint = id.actualText;\n                        }\n                    }\n                }\n                if ((!this.scanner.lastTokenHadNewline()) &&\n                    ((this.currentToken.tokenId == TokenID.PlusPlus) || (this.currentToken.tokenId == TokenID.MinusMinus))) {\n                    canAssign = false;\n                    var operand = ast;\n                    ast = new UnaryExpression((this.currentToken.tokenId == TokenID.PlusPlus) ? NodeType.IncPost : NodeType.DecPost, operand);\n                    ast.limChar = this.scanner.pos;\n                    ast.minChar = operand.minChar;\n                    this.currentToken = this.scanner.scan();\n                }\n            }\n            for (; ;) {\n                tokenInfo = lookupToken(this.currentToken.tokenId);\n                if ((tokenInfo == undefined) || (tokenInfo.binopNodeType == NodeType.None)) {\n                    break;\n                }\n                if ((!allowIn) && (tokenInfo.binopNodeType == NodeType.In)) {\n                    break;\n                }\n                if (tokenInfo.binopPrecedence == OperatorPrecedence.Assignment) {\n                    if (tokenInfo.binopPrecedence < minPrecedence) {\n                        break;\n                    }\n                    if (!canAssign) {\n                        this.reportParseError("illegal assignment");\n                    }\n                }\n                else if (tokenInfo.binopPrecedence <= minPrecedence) {\n                    break;\n                }\n\n                if (possiblyInLambda && this.currentToken.tokenId == TokenID.Comma && this.scanner.getLookAheadToken().tokenId == TokenID.DotDotDot) {\n                    // The ellipsis can only exist in the formal list of a lambda expression, so do not attempt to parse the comma token as the comma binary operator\n                    // instead parse it as a lambda\n               ',
v27594=v27595+'     exprIsAnonLambda = true;\n                    canAssign = false;\n                    ast = this.parseLambdaExpr(errorRecoverySet, ast, false, true);\n                    break;\n                }\n\n                // Precedence is high enough. Consume the operator token.\n                this.currentToken = this.scanner.scan();\n                canAssign = false;\n                if (tokenInfo.binopNodeType == NodeType.ConditionalExpression) {\n                    if (possiblyInLambda && \n                        ( this.currentToken.tokenId == TokenID.Equals || this.currentToken.tokenId == TokenID.Colon || this.currentToken.tokenId == TokenID.CloseParen || this.currentToken.tokenId == TokenID.Comma)) {\n                        // The QMark is not a ternary expression, it is a marker for optional parameter in a lambda expression.\n                        exprIsAnonLambda = true;\n                        canAssign = true;\n                    }\n                    else {\n                        this.prevExpr = ast;\n                        var whenTrue = this.parseExpr(\n                            errorRecoverySet | ErrorRecoverySet.Colon, OperatorPrecedence.Assignment, allowIn, TypeContext.NoTypes);\n\n                        // Do not hold onto the prevExpr handle\n                        this.prevExpr = null;\n                        this.checkCurrentToken(TokenID.Colon, errorRecoverySet | ErrorRecoverySet.ExprStart);\n\n                        var whenFalse = this.parseExpr(\n                            errorRecoverySet | ErrorRecoverySet.BinOp, OperatorPrecedence.Assignment, allowIn, TypeContext.NoTypes)\n                        ast = new ConditionalExpression(ast, whenTrue, whenFalse);\n                    }\n                }\n                else {\n                    var tc = TypeContext.NoTypes;\n                    var binExpr2: BinaryExpression;\n\n                    binExpr2 = new BinaryExpression(tokenInfo.binopNodeType, ast,\n                                                    this.parseExpr(errorRecoverySet |\n                                                            ErrorRecoverySet.BinOp,\n                                                            tokenInfo.binopPrecedence,\n                                                            allowIn, TypeContext.NoTypes, possiblyInLambda));\n                    if (binExpr2.operand2.nodeType == NodeType.FuncDecl) {\n                        var funcDecl = <FuncDecl>binExpr2.operand2;\n                        funcDecl.hint = idHint;\n                    }\n\n                    binExpr2.minChar = ast.minChar;\n                    binExpr2.limChar = this.scanner.lastTokenLimChar();\n                    idHint = null;\n                    ast = binExpr2;\n                }\n            }\n            if (canAssign) {\n                ast.flags |= ASTFlags.Writeable;\n            }\n            if (!exprIsAnonLambda) {\n                ///////////////////////////////////////////////////////////\n                //TODO: Eventually, we want to remove "minChar" and "limChar" assignments here,\n                //      as they are sometimes not specific enough for each statement kind.\n                ast.minChar = minChar;\n                // Only update "limChar" if it is not better than "lastTokenLimChar()"\n                ast.limChar = max(ast.limChar, this.scanner.lastTokenLimChar());\n                //\n                ///////////////////////////////////////////////////////////\n                ast.preComments = preComments;\n                ast.postComments = this.parseCommentsForLine(this.scanner.line);\n            }\n            return ast;\n        }\n\n        private parsePostfixOperators(errorRecoverySet: ErrorRecoverySet, ast: AST, allowCall: bool, inNew: bool,\n            typeContext: TypeContext, lhsMinChar: number, lhsLimChar: number): AST {\n            var count = 0;\n\n            if (!ast) {\n                ast = new AST(NodeType.EmptyExpr);\n                ast.isParenthesized = true;\n            }\n\n            ast.minChar = lhsMinChar;\n            ast.limChar = lhsLimChar;\n\n            for (; ;) {\n                switch (this.currentToken.tokenId) {\n                    case TokenID.OpenParen:\n                        if (inNew) {\n                            var callExpr = <CallExpression>ast;\n                            callExpr.arguments = this.parseArgList(errorRecoverySet);\n                            inNew = false;\n                        }\n                        else {\n                            if (!allowCall) {\n                                return ast;\n                            }\n                            ast = new CallExpression(NodeType.Call, ast,\n                                                   this.parseArgList(errorRecoverySet));\n                            ast.minChar = lhsMinChar;\n                        }\n                        ast.limChar = this.scanner.pos; // \')\'\n                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet);\n              ',
v27593=v27594+"          break;\n                    case TokenID.OpenBracket:\n                        this.currentToken = this.scanner.scan();\n                        if (this.currentToken.tokenId == TokenID.CloseBracket) {\n                            if (hasFlag(typeContext, TypeContext.ArraySuffix)) {\n                                this.currentToken = this.scanner.scan();\n                                if (ast.nodeType == NodeType.TypeRef) {\n                                    var typeRef = <TypeReference>ast;\n                                    typeRef.arrayCount++;\n                                }\n                                else {\n                                    ast = new BinaryExpression(NodeType.Index, ast, null);\n                                }\n                                ast.limChar = this.scanner.pos;\n                                break; // note early exit from case\n                            }\n                        }\n\n                        ast = new BinaryExpression(NodeType.Index, ast,\n                                                 this.parseExpr(errorRecoverySet | ErrorRecoverySet.RBrack,\n                                                           OperatorPrecedence.None, true,\n                                                           TypeContext.NoTypes));\n                        ast.minChar = lhsMinChar;\n                        ast.limChar = this.scanner.pos; // ']'\n                        this.checkCurrentToken(TokenID.CloseBracket, errorRecoverySet);\n                        break;\n                    case TokenID.Dot: {\n                        var name: Identifier = null;\n                        var curpos = this.scanner.pos;\n                        this.currentToken = this.scanner.scan();\n                        // Don't allow reserved words if immediately after a new line and error recovery is enabled\n                        if ((this.currentToken.tokenId == TokenID.Identifier) || ((!this.errorRecovery || !this.scanner.lastTokenHadNewline()) && convertTokToIDName(this.currentToken))) {\n                            ast.flags |= ASTFlags.DotLHS;\n                            name = this.createRef(this.currentToken.getText(), (<IdentifierToken>this.currentToken).hasEscapeSequence, this.scanner.startPos);\n                            name.limChar = this.scanner.pos;\n                            this.currentToken = this.scanner.scan();\n                        }\n                        else {\n                            this.reportParseError(\"Expected identifier following dot\");\n                            if (this.errorRecovery) {\n                                this.skip(errorRecoverySet);\n                                ast.flags |= (ASTFlags.Error | ASTFlags.DotLHS);\n                                return ast;\n                            }\n                            else {\n                                name = new MissingIdentifier();\n                            }\n                        }\n                        ast = new BinaryExpression(NodeType.Dot, ast, name);\n                        ast.minChar = lhsMinChar;\n                        ast.limChar = this.scanner.lastTokenLimChar();\n                        break;\n                    }\n                    case TokenID.EqualsGreaterThan:\n                        ast = this.parseFncDecl(errorRecoverySet, false, false, false, null, false, false, false, Modifiers.None, { preProcessedLambdaArgs: ast }, false);\n                        (<FuncDecl>ast).fncFlags |= FncFlags.IsFunctionExpression;\n                        ast.minChar = lhsMinChar;\n                        ast.limChar = this.scanner.lastTokenLimChar();\n                        break;\n                    default:\n                        return ast;\n\n                }\n            }\n        }\n\n        private parseTry(tryNode: Try, errorRecoverySet: ErrorRecoverySet, parentModifiers: Modifiers): Try {\n            var minChar = this.scanner.startPos;\n            var preComments = this.parseComments();\n            this.currentToken = this.scanner.scan();\n            if (this.currentToken.tokenId != TokenID.OpenBrace) {\n                this.reportParseError(\"Expected '{'\");\n                if (this.errorRecovery) {\n                    var etryNode = tryNode;\n                    etryNode.minChar = minChar;\n                    etryNode.limChar = this.scanner.lastTokenLimChar();\n                    etryNode.flags |= ASTFlags.Error;\n                    return etryNode;\n                }\n            }\n            tryNode.body = this.parseStatement(errorRecoverySet, AllowedElements.None, parentModifiers);\n            tryNode.minChar = minChar;\n            tryNode.limChar = tryNode.body.limChar;\n            tryNode.preComments = preComments;\n            tryNode.postComments = this.parseComments();\n            return tryNode;\n        }\n\n        private parseCatch(errorRecoverySet: ErrorRecoverySet, parentModifiers: Modifiers): Catch {\n            var catchMinChar = this.scanner.startPos;\n       ",
v27592=v27593+'     var preComments = this.parseComments();\n            this.currentToken = this.scanner.scan();\n            this.checkCurrentToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart);\n            if ((this.currentToken.tokenId != TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                this.reportParseError("Expected identifier in catch header");\n                if (this.errorRecovery) {\n                    this.skip(errorRecoverySet);\n\n                    var ecatch = new Catch(new VarDecl(new MissingIdentifier(), this.nestingLevel),\n                                            new Statement(NodeType.Empty));\n                    ecatch.statement.minChar = catchMinChar;\n                    ecatch.statement.limChar = this.scanner.pos;\n                    ecatch.minChar = this.scanner.startPos;\n                    ecatch.limChar = this.scanner.pos;\n                    ecatch.flags |= ASTFlags.Error;\n                    return ecatch;\n                }\n            }\n            var param = new VarDecl(Identifier.fromToken(this.currentToken), this.nestingLevel);\n            param.id.minChar = this.scanner.startPos;\n            param.id.limChar = this.scanner.pos;\n            param.minChar = param.id.minChar;\n            param.limChar = param.id.limChar;\n            this.currentToken = this.scanner.scan();\n            var statementPos = this.scanner.pos;\n            this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.StmtStart);\n            if (this.currentToken.tokenId != TokenID.OpenBrace) {\n                this.reportParseError("Expected \'{\' to start catch body");\n                if (this.errorRecovery) {\n                    this.skip(errorRecoverySet);\n\n                    var ecatch = new Catch(new VarDecl(new MissingIdentifier(), this.nestingLevel),\n                                            new Statement(NodeType.Empty));\n                    ecatch.statement.minChar = catchMinChar;\n                    ecatch.statement.limChar = statementPos;\n                    ecatch.minChar = this.scanner.startPos;\n                    ecatch.limChar = this.scanner.pos;\n                    ecatch.flags |= ASTFlags.Error;\n                    return ecatch;\n                }\n            }\n\n            var catchStmt = this.parseStatement(errorRecoverySet, AllowedElements.None, parentModifiers);\n            var catchNode = new Catch(param, catchStmt);\n            catchNode.statement.minChar = catchMinChar;\n            catchNode.statement.limChar = statementPos;\n            catchNode.minChar = catchMinChar;\n            catchNode.limChar = catchStmt.limChar;\n            catchNode.preComments = preComments;\n            catchNode.postComments = this.parseComments();\n            return catchNode;\n        }\n\n        private parseFinally(errorRecoverySet: ErrorRecoverySet, parentModifiers: Modifiers): Finally {\n            var finMinChar = this.scanner.startPos;\n            var preComments = this.parseComments();\n            this.currentToken = this.scanner.scan();\n            if (this.currentToken.tokenId != TokenID.OpenBrace) {\n                this.reportParseError("Expected \'{\' to start body of finally statement");\n                if (this.errorRecovery) {\n                    this.skip(errorRecoverySet);\n                    var efin = new Finally(new Statement(NodeType.Empty));\n                    efin.flags |= ASTFlags.Error;\n                    efin.minChar = this.scanner.startPos;\n                    efin.limChar = this.scanner.pos;\n                    return efin;\n                }\n            }\n\n            var finBody = this.parseStatement(errorRecoverySet, AllowedElements.None, parentModifiers)\n            var fin = new Finally(finBody);\n            fin.minChar = finMinChar;\n            fin.limChar = fin.body.limChar;\n            fin.preComments = preComments;\n            fin.postComments = this.parseComments();\n            return fin;\n        }\n\n        private parseTryCatchFinally(errorRecoverySet: ErrorRecoverySet, parentModifiers: Modifiers, labelList: ASTList): AST {\n            var tryPart: AST = new Try(null);\n            var tryMinChar = this.scanner.startPos;\n            this.pushStmt(<Statement>tryPart, labelList);\n            this.parseTry(<Try>tryPart, errorRecoverySet | ErrorRecoverySet.Catch, parentModifiers);\n            this.popStmt();\n            var tc: TryCatch = null;\n            var tf: TryFinally = null;\n\n            if (this.currentToken.tokenId == TokenID.Catch) {\n                var catchPart = this.parseCatch(errorRecoverySet | ErrorRecoverySet.Catch, parentModifiers);\n                tc = new TryCatch(<Try>tryPart, catchPart);\n                tc.minChar = tryPart.minChar;\n                tc.limChar = catchPart.limChar;\n            }\n\n            if (this.currentToken.tokenId != TokenID.Finally) {\n                if (tc == null) {\n                    this.reportParseError("try with neither catch nor finally");\n        ',
v27591=v27592+'            if (this.errorRecovery) {\n                        var etf = new TryFinally(tryPart, new Finally(new AST(NodeType.Empty)));\n                        etf.flags |= ASTFlags.Error;\n                        etf.minChar = this.scanner.startPos;\n                        etf.limChar = this.scanner.pos;\n                        return etf;\n                    }\n                    return new TryFinally(tryPart, new Finally(new AST(NodeType.Empty)));\n                }\n                else {\n                    return tc;\n                }\n            }\n            else {\n                if (tc) {\n                    tryPart = tc;\n                }\n                var finallyPart = this.parseFinally(errorRecoverySet, parentModifiers)\n                tf = new TryFinally(tryPart, finallyPart);\n                tf.minChar = tryMinChar;\n                tf.limChar = finallyPart.limChar;\n                return tf;\n            }\n        }\n\n        private parseStatement(errorRecoverySet: ErrorRecoverySet, allowedElements: AllowedElements, parentModifiers: Modifiers): AST {\n            var ast: AST = null;\n            var labelList: ASTList = null;\n            var astList: ASTList = null;\n            var temp: AST;\n            var modifiers = Modifiers.None;\n            var minChar = this.scanner.startPos;\n            var forInOk = false;\n            var needTerminator = false;\n            var fnOrVar: AST = null;\n            var preComments = this.parseComments();\n            this.state = ParseState.StartStatement;\n\n            function isAmbient() {\n                return hasFlag(modifiers, Modifiers.Ambient) || hasFlag(parentModifiers, Modifiers.Ambient);\n            }\n\n            function mayNotBeExported() {\n                if (hasFlag(modifiers, Modifiers.Exported)) {\n                    this.reportError("Statement may not be exported");\n                }\n            }\n\n            for (; ;) {\n                switch (this.currentToken.tokenId) {\n                    case TokenID.EndOfFile:\n                        ast = new AST(NodeType.Error);\n                        ast.minChar = minChar;\n                        ast.limChar = this.scanner.pos;\n                        break;\n                    case TokenID.Function:\n                        if (this.parsingDeclareFile || isAmbient() || this.ambientModule) {\n                            this.currentToken = this.scanner.scan();\n                            fnOrVar = this.parsePropertyDeclaration(errorRecoverySet | ErrorRecoverySet.SColon,\n                                                      modifiers, true, false);\n                            if (fnOrVar.nodeType == NodeType.VarDecl) {\n                                this.reportParseError("function keyword can only introduce function declaration");\n                            }\n                            else if ((fnOrVar.nodeType == NodeType.FuncDecl) && ((<FuncDecl>fnOrVar).fncFlags, FncFlags.IsFatArrowFunction)) {\n                                needTerminator = true;\n                            }\n                            ast = fnOrVar;\n                            if (this.parsingDeclareFile || this.ambientModule && ast.nodeType == NodeType.FuncDecl) {\n                                (<FuncDecl>ast).fncFlags |= FncFlags.Exported;\n                            }\n                        }\n                        else {\n                            ast = this.parseFncDecl(errorRecoverySet, true, false, false, null, false, false, isAmbient(), modifiers, null, true);\n                            if (hasFlag((<FuncDecl>ast).fncFlags, FncFlags.IsFatArrowFunction)) {\n                                needTerminator = true;\n                            }\n                            if (this.ambientModule) {\n                                this.reportParseError("function declaration not permitted within ambient module");\n                            }\n                            if (hasFlag(modifiers, Modifiers.Exported)) {\n                                (<FuncDecl>ast).fncFlags |= FncFlags.Exported;\n                            }\n                        }\n                        break;\n                    case TokenID.Module:\n                        if ((allowedElements & AllowedElements.ModuleDeclarations) == AllowedElements.None) {\n                            this.reportParseError("module not allowed in this context");\n                            this.currentToken = this.scanner.scan();\n                            ast = new AST(NodeType.Error);\n                            ast.minChar = minChar;\n                            ast.limChar = this.scanner.lastTokenLimChar();\n                        }\n                        else {\n                            ast = this.parseModuleDecl(errorRecoverySet, modifiers, preComments);\n                            preComments = null;\n                        }\n                        break;\n                    case TokenID.Import:\n                        if ((allowedElements & AllowedElement',
v27590=v27591+'s.ModuleDeclarations) == AllowedElements.None) {\n                            this.reportParseError("module not allowed in this context");\n                            this.currentToken = this.scanner.scan();\n                            ast = new AST(NodeType.Error);\n                            ast.minChar = minChar;\n                            ast.limChar = this.scanner.lastTokenLimChar();\n                        }\n                        else {\n                            if (hasFlag(modifiers, Modifiers.Exported)) {\n                                this.reportParseError("export keyword not permitted on import declaration");\n                            }\n                            ast = this.parseImportDeclaration(errorRecoverySet, modifiers);\n                            needTerminator = true;\n                        }\n                        break;\n                    case TokenID.Export:\n                        if ((allowedElements & AllowedElements.ModuleDeclarations) == AllowedElements.None) {\n                            this.reportParseError("\'export\' statements are only allowed at the global and module levels");\n                            this.currentToken = this.scanner.scan();\n                            ast = new AST(NodeType.Error);\n                            ast.minChar = minChar;\n                            ast.limChar = this.scanner.lastTokenLimChar();\n                        }\n                        if (this.topLevel) {\n                            this.hasTopLevelImportOrExport = true;\n                        }\n                        modifiers |= Modifiers.Exported;\n                        this.currentToken = this.scanner.scan();\n                        break;\n                    case TokenID.Private:\n                        modifiers |= Modifiers.Private;\n\n                        this.currentToken = this.scanner.scan();\n\n                        if (this.parsingClassConstructorDefinition) {\n\n                            if (!this.inferPropertiesFromThisAssignment) {\n                                this.reportParseError("Property declarations are not permitted within constructor bodies");\n                            }\n\n                            minChar = this.scanner.pos;\n                            if (this.inferPropertiesFromThisAssignment && (this.currentToken.tokenId != TokenID.This || (this.currentToken = this.scanner.scan()).tokenId != TokenID.Dot)) {\n                                this.reportParseError("Expected \'this.\' for property declaration");\n                                this.currentToken = this.scanner.scan();\n                                ast = new AST(NodeType.Error);\n                                ast.minChar = minChar;\n                                ast.limChar = this.scanner.lastTokenLimChar();\n                            }\n                            else {\n                                this.currentToken = this.scanner.scan();\n\n                                var id = Identifier.fromToken(this.currentToken);\n                                id.minChar = this.scanner.startPos;\n                                id.limChar = this.scanner.pos;\n\n                                this.currentToken = this.scanner.scan();\n                                ast = this.parseClassMemberVariableDeclaration(id, minChar, this.parsingClassConstructorDefinition, errorRecoverySet, modifiers);\n                            }\n                        }\n                        else {\n                            if (this.currentToken.tokenId != TokenID.Interface) {\n                                if (this.currentToken.tokenId == TokenID.Get) {\n                                    this.prevIDTok = this.currentToken;\n                                    this.currentToken = this.scanner.scan();\n                                    if (codeGenTarget < CodeGenTarget.ES5) {\n                                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                                    }\n                                    if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                                        modifiers |= Modifiers.Getter;\n                                        this.prevIDTok = null;\n                                    }\n                                }\n                                else if (this.currentToken.tokenId == TokenID.Set) {\n                                    this.prevIDTok = this.currentToken;\n                                    this.currentToken = this.scanner.scan();\n                                    if (codeGenTarget < CodeGenTarget.ES5) {\n                                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                                    }\n                                    if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMod',
v27589=v27590+'e)) {\n                                        modifiers |= Modifiers.Setter;\n                                        this.prevIDTok = null;\n                                    }\n                                }\n                                fnOrVar = this.parsePropertyDeclaration(errorRecoverySet | ErrorRecoverySet.SColon,\n                                                          modifiers, isAmbient(), false);\n                                if ((fnOrVar.nodeType == NodeType.VarDecl) ||\n                                    ((fnOrVar.nodeType == NodeType.FuncDecl) && (hasFlag((<FuncDecl>fnOrVar).fncFlags, FncFlags.IsFatArrowFunction)))) {\n                                    needTerminator = true;\n                                }\n                                ast = fnOrVar;\n                            }\n                        }\n                        break;\n                    case TokenID.Public:\n                        if (this.parsingClassConstructorDefinition) {\n\n                            if (!this.inferPropertiesFromThisAssignment) {\n                                this.reportParseError("Property declarations are not permitted within constructor bodies");\n                            }\n\n                            this.currentToken = this.scanner.scan(); \n                            minChar = this.scanner.pos;\n                            modifiers |= Modifiers.Public;\n                            if (this.inferPropertiesFromThisAssignment && (this.currentToken.tokenId != TokenID.This || (this.currentToken = this.scanner.scan()).tokenId != TokenID.Dot)) {\n                                this.reportParseError("Expected \'this.\' for property declaration");\n                                this.currentToken = this.scanner.scan();\n                                ast = new AST(NodeType.Error);\n                                ast.minChar = minChar;\n                                ast.limChar = this.scanner.lastTokenLimChar();\n                            }\n                            else {\n                                this.currentToken = this.scanner.scan();\n\n                                var id = Identifier.fromToken(this.currentToken);\n                                id.minChar = this.scanner.startPos;\n                                id.limChar = this.scanner.pos;\n\n                                this.currentToken = this.scanner.scan();\n                                ast = this.parseClassMemberVariableDeclaration(id, minChar, this.parsingClassConstructorDefinition, errorRecoverySet, modifiers);\n                            }\n                        }\n                        else {\n                            if ((allowedElements & AllowedElements.Properties) == AllowedElements.None) {\n                                this.reportParseError("\'property\' statements are only allowed within classes");\n                                this.currentToken = this.scanner.scan();\n                                ast = new AST(NodeType.Error);\n                                ast.minChar = minChar;\n                                ast.limChar = this.scanner.lastTokenLimChar();\n                            }\n                            else {\n                                modifiers |= Modifiers.Public;\n                                this.currentToken = this.scanner.scan();\n                                if (this.currentToken.tokenId == TokenID.Get) {\n                                    this.prevIDTok = this.currentToken;\n                                    this.currentToken = this.scanner.scan();\n                                    if (codeGenTarget < CodeGenTarget.ES5) {\n                                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                                    }\n                                    if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                                        modifiers |= Modifiers.Getter;\n                                        this.prevIDTok = null;\n                                    }\n                                }\n                                else if (this.currentToken.tokenId == TokenID.Set) {\n                                    this.prevIDTok = this.currentToken;\n                                    this.currentToken = this.scanner.scan();\n                                    if (codeGenTarget < CodeGenTarget.ES5) {\n                                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                                    }\n                                    if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                                        modifiers |= Modifiers.Setter;\n                                        this.prevIDTok = null;\n                                    }\n                                }\n       ',
v27588=v27589+'                         fnOrVar = this.parsePropertyDeclaration(errorRecoverySet | ErrorRecoverySet.SColon,\n                                                            modifiers, isAmbient(), false);\n                                if ((fnOrVar.nodeType == NodeType.VarDecl) ||\n                                    ((fnOrVar.nodeType == NodeType.FuncDecl) && hasFlag((<FuncDecl>fnOrVar).fncFlags, FncFlags.IsFatArrowFunction))) {\n                                    needTerminator = true;\n                                }\n                                ast = fnOrVar;\n                            }\n                        }\n                        break;\n                    case TokenID.Declare:\n                        if (!(allowedElements & AllowedElements.AmbientDeclarations)) {\n                            this.reportParseError("Ambient declarations are only allowed at the top-level or module scopes")\n                        }\n                        if (!this.parsingDeclareFile && hasFlag(parentModifiers, Modifiers.Ambient)) {\n                            this.reportParseError("Duplicate ambient declaration in this context. (Is the enclosing module or class already ambient?)")\n                        }\n                        modifiers |= Modifiers.Ambient;\n                        this.currentToken = this.scanner.scan();\n                        break;\n                    case TokenID.Class:\n                        if ((allowedElements & AllowedElements.ClassDeclarations) == AllowedElements.None) {\n                            this.reportParseError("class not allowed in this context");\n                            this.currentToken = this.scanner.scan();\n                            ast = new AST(NodeType.Error);\n                            ast.minChar = minChar;\n                            ast.limChar = this.scanner.lastTokenLimChar();\n                        }\n                        else {\n                            ast = this.parseClassDecl(errorRecoverySet, minChar, modifiers);\n                        }\n                        break;\n                    case TokenID.Interface:\n                        if ((allowedElements & AllowedElements.InterfaceDeclarations) == AllowedElements.None) {\n                            this.reportParseError("interface not allowed in this context");\n                            this.currentToken = this.scanner.scan();\n                            ast = new AST(NodeType.Error);\n                            ast.minChar = minChar;\n                            ast.limChar = this.scanner.lastTokenLimChar();\n                        }\n                        else {\n                            ast = this.parseInterfaceDecl(errorRecoverySet, modifiers);\n                        }\n                        break;\n                    case TokenID.Var:\n                        var declAst: AST = this.parseVariableDeclaration(errorRecoverySet | ErrorRecoverySet.StmtStart, modifiers,\n                                                     true, false);\n                        if (declAst.nodeType == NodeType.VarDecl) {\n                            ast = declAst;\n                        }\n                        else {\n                            ast = new Block(<ASTList>declAst, false);\n                        }\n                        needTerminator = true;\n                        break;\n                    case TokenID.Static:\n\n                        if (this.currentClassDecl == null) {\n                            this.reportParseError("Statics may only be class members");\n                        }\n\n                        mayNotBeExported();\n                        modifiers |= Modifiers.Public;\n                        this.currentToken = this.scanner.scan();\n                        if (this.currentToken.tokenId == TokenID.Get) {\n                            this.prevIDTok = this.currentToken;\n                            this.currentToken = this.scanner.scan();\n                            if (codeGenTarget < CodeGenTarget.ES5) {\n                                this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                            }\n                            if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                                modifiers |= Modifiers.Getter;\n                                this.prevIDTok = null;\n                            }\n                        }\n                        else if (this.currentToken.tokenId == TokenID.Set) {\n                            this.currentToken = this.scanner.scan();\n                            if (codeGenTarget < CodeGenTarget.ES5) {\n                                this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                            }\n                            if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n             ',
v27587=v27588+'                   modifiers |= Modifiers.Setter;\n                            }\n                        }\n                        if (isAmbient()) {\n                            modifiers |= Modifiers.Ambient;\n                        }\n                        fnOrVar = this.parsePropertyDeclaration(errorRecoverySet | ErrorRecoverySet.SColon,\n                                                  modifiers, this.parsingDeclareFile || (modifiers & Modifiers.Ambient) != Modifiers.None, true);\n\n                        var staticsList = this.topStaticsList();\n                        if (staticsList && fnOrVar.nodeType == NodeType.VarDecl) {\n                            staticsList.append(fnOrVar);\n                        }\n\n                        if (fnOrVar.nodeType == NodeType.VarDecl || ((fnOrVar.nodeType == NodeType.FuncDecl) && hasFlag((<FuncDecl>fnOrVar).fncFlags, FncFlags.IsFatArrowFunction))) {\n                            needTerminator = true;\n                        }\n\n                        ast = fnOrVar;\n                        break;\n                    case TokenID.For:\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("syntax error: for statement does not take modifiers");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.checkNextToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart | ErrorRecoverySet.Var);\n                        this.state = ParseState.ForInit;\n                        forInOk = true;\n                        switch (this.currentToken.tokenId) {\n                            case TokenID.Var:\n                                temp = this.parseVariableDeclaration(errorRecoverySet | ErrorRecoverySet.SColon |\n                                                  ErrorRecoverySet.In, Modifiers.None, false, false);\n                                break;\n                            case TokenID.Semicolon:\n                                temp = null;\n                                this.state = ParseState.ForCondStart;\n                                break;\n                            default:\n                                temp = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon |\n                                               ErrorRecoverySet.In, OperatorPrecedence.None, false,\n                                               TypeContext.NoTypes);\n                                break;\n                        }\n                        this.state = ParseState.ForInitAfterVar;\n                        if (this.currentToken.tokenId == TokenID.In) {\n                            if ((temp == null) || (!forInOk)) {\n                                this.reportParseError("malformed for statement");\n                                if (this.errorRecovery) {\n                                    this.skip(errorRecoverySet | ErrorRecoverySet.StmtStart);\n                                    ast = new AST(NodeType.Empty);\n                                    ast.flags |= ASTFlags.Error;\n                                }\n                            }\n                            else {\n                                this.currentToken = this.scanner.scan();\n                                var forInStmt = new ForInStatement(temp,\n                                                                 this.parseExpr(ErrorRecoverySet.RParen |\n                                                                           errorRecoverySet,\n                                                                           OperatorPrecedence.Comma,\n                                                                           false,\n                                                                           TypeContext.NoTypes));\n\n                                forInStmt.limChar = this.scanner.pos;\n                                forInStmt.statement.minChar = minChar;\n                                forInStmt.statement.limChar = this.scanner.pos;\n                                this.checkCurrentToken(TokenID.CloseParen, ErrorRecoverySet.StmtStart | errorRecoverySet);\n                                this.pushStmt(forInStmt, labelList);\n                                forInStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\n                                this.popStmt();\n                                forInStmt.minChar = minChar;\n                                ast = forInStmt;\n                            }\n                        }\n                        else {\n                            var forStmt: ForStatement = new ForStatement(temp);\n                            forStmt.minChar = minChar;\n                            this.checkCurrentToken(TokenID.Semicolon, errorRecoverySet);\n                            if (this.currentToken.tokenId == TokenID.Semicolon) {\n                                forStmt.cond = null;\n                 ',
v27586=v27587+"           }\n                            else {\n                                forStmt.cond = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon |\n                                                       ErrorRecoverySet.RParen,\n                                                       OperatorPrecedence.None, true,\n                                                       TypeContext.NoTypes);\n                                if (this.currentToken.tokenId != TokenID.Semicolon) {\n                                    this.skip(errorRecoverySet | ErrorRecoverySet.StmtStart);\n                                    ast = forStmt;\n                                    ast.flags |= ASTFlags.Error;\n                                }\n                            }\n                            this.currentToken = this.scanner.scan();\n                            if (this.currentToken.tokenId == TokenID.CloseParen) {\n                                forStmt.incr = null;\n                            }\n                            else {\n                                forStmt.incr = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon |\n                                                       ErrorRecoverySet.RParen,\n                                                       OperatorPrecedence.None, true,\n                                                       TypeContext.NoTypes);\n                            }\n                            this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.LCurly);\n                            this.pushStmt(forStmt, labelList);\n                            forStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\n                            this.popStmt();\n                            forStmt.limChar = forStmt.body.limChar;\n                            ast = forStmt;\n                        }\n                        break;\n                    case TokenID.With: {\n                        if (codeGenTarget < CodeGenTarget.ES5) {\n                            this.reportParseError(\"'with' statements are only available in ES5 codegen mode or better\");\n                        }\n\n                        if (this.strictMode) {\n                            this.reportParseError(\"'with' statements are not available in strict mode\");\n                        }\n\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError(\"'with' statement does not take modifiers\");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.checkNextToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart | ErrorRecoverySet.Var);\n\n                        var expr = this.parseExpr(errorRecoverySet | ErrorRecoverySet.Colon,\n                                                            OperatorPrecedence.None, true,\n                                                            TypeContext.NoTypes);\n                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.LCurly);\n\n                        var withStmt = new WithStatement(expr);\n                        withStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\n                        withStmt.minChar = minChar;\n                        withStmt.limChar = withStmt.body.limChar;\n                        ast = withStmt;\n                    }\n                        break;\n                    case TokenID.Switch: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError(\"'switch' statement does not take modifiers\");\n                        }\n                        this.checkNextToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart);\n\n                        var switchStmt = new SwitchStatement(this.parseExpr(errorRecoverySet |\n                                                                     ErrorRecoverySet.RParen,\n                                                                     OperatorPrecedence.None,\n                                                                     true,\n                                                                     TypeContext.NoTypes));\n                        switchStmt.statement.minChar = minChar;\n                        switchStmt.statement.limChar = this.scanner.pos;\n                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.LCurly);\n                        var caseListMinChar = this.scanner.startPos;\n                         this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet | ErrorRecoverySet.SCase);\n                        switchStmt.defaultCase = null;\n                        switchStmt.caseList = new ASTList();\n                        var caseStmt: CaseStatement = null;\n                        this.push",
v27585=v27586+'Stmt(switchStmt, labelList);\n                        for (; ;) {\n                            if ((this.currentToken.tokenId == TokenID.Case) ||\n                                (this.currentToken.tokenId == TokenID.Default)) {\n                                var isDefault = (this.currentToken.tokenId == TokenID.Default);\n                                caseStmt = new CaseStatement();\n                                caseStmt.minChar = this.scanner.startPos;\n                                this.currentToken = this.scanner.scan();\n                                if (isDefault) {\n                                    switchStmt.defaultCase = caseStmt;\n                                }\n                                else {\n                                    caseStmt.expr = this.parseExpr(errorRecoverySet | ErrorRecoverySet.Colon,\n                                                            OperatorPrecedence.None, true,\n                                                            TypeContext.NoTypes);\n                                }\n                                this.checkCurrentToken(TokenID.Colon, errorRecoverySet | ErrorRecoverySet.StmtStart);\n                                caseStmt.body = new ASTList();\n                                this.parseStatementList(errorRecoverySet | ErrorRecoverySet.RCurly,\n                                              caseStmt.body, false, true, allowedElements, modifiers);\n                                caseStmt.limChar = caseStmt.body.limChar;\n                                switchStmt.caseList.append(caseStmt);\n                            }\n                            else {\n                                break;\n                            }\n                        }\n                        // end of switch statement\n                        switchStmt.caseList.minChar = caseListMinChar;\n                        switchStmt.caseList.limChar = this.scanner.pos;\n                        switchStmt.limChar = switchStmt.caseList.limChar;\n                        this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n                        this.popStmt();\n                        ast = switchStmt;\n                        break;\n                    }\n                    case TokenID.While: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("\'while\' statement does not take modifiers");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.checkNextToken(TokenID.OpenParen, ErrorRecoverySet.ExprStart |\n                                  errorRecoverySet);\n                        var whileStmt = new WhileStatement(this.parseExpr(errorRecoverySet |\n                                                                   ErrorRecoverySet.RParen,\n                                                                   OperatorPrecedence.None,\n                                                                   true, TypeContext.NoTypes));\n                        whileStmt.minChar = minChar;\n                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet |\n                                  ErrorRecoverySet.StmtStart);\n                        this.pushStmt(whileStmt, labelList);\n                        whileStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\n                        whileStmt.limChar = whileStmt.body.limChar;\n                        this.popStmt();\n                        ast = whileStmt;\n                        break;\n                    }\n                    case TokenID.Do: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("\'do\' statement does not take modifiers");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        var doStmt = new DoWhileStatement();\n                        doStmt.minChar = minChar;\n                        this.pushStmt(doStmt, labelList);\n                        doStmt.body = this.parseStatement(errorRecoverySet | ErrorRecoverySet.While,\n                                                   allowedElements, parentModifiers);\n                        this.popStmt();\n                        doStmt.whileAST = new Identifier("while");\n                        doStmt.whileAST.minChar = this.scanner.startPos;\n                        this.checkCurrentToken(TokenID.While, errorRecoverySet | ErrorRecoverySet.LParen);\n                        doStmt.whileAST.limChar = doStmt.whileAST.minChar + 5;\n                        this.checkCurrentToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart);\n                        doStmt.cond = this.parseExpr(errorRecoverySet | ErrorRecoverySet.RParen,\n                                           ',
v27584=v27585+'   OperatorPrecedence.None, true, TypeContext.NoTypes);\n                        doStmt.limChar = this.scanner.pos;\n                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet);\n                        ast = doStmt;\n                        // compatibility; more strict would be to require the \';\'\n                        if (this.currentToken.tokenId == TokenID.Semicolon) {\n                            this.currentToken = this.scanner.scan();\n                        }\n                        break;\n                    }\n                    case TokenID.If: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("if statement does not take modifiers");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.checkNextToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart);\n                        var ifStmt = new IfStatement(this.parseExpr(errorRecoverySet |\n                                                             ErrorRecoverySet.LParen,\n                                                             OperatorPrecedence.None, true,\n                                                             TypeContext.NoTypes));\n                        ifStmt.minChar = minChar;\n                        ifStmt.statement.minChar = minChar;\n                        ifStmt.statement.limChar = this.scanner.pos;\n                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.StmtStart);\n                        this.pushStmt(ifStmt, labelList);\n                        ifStmt.thenBod = this.parseStatement(ErrorRecoverySet.Else | errorRecoverySet,\n                                                      allowedElements, parentModifiers);\n                        ifStmt.limChar = ifStmt.thenBod.limChar;\n                        if (this.currentToken.tokenId == TokenID.Else) {\n                            this.currentToken = this.scanner.scan();\n                            ifStmt.elseBod = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\n                            ifStmt.limChar = ifStmt.elseBod.limChar;\n                        }\n                        this.popStmt();\n                        ast = ifStmt;\n                        break;\n                    }\n                    case TokenID.Try: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("try statement does not take modifiers");\n                        }\n                        minChar = this.scanner.startPos;\n                        ast = this.parseTryCatchFinally(errorRecoverySet, parentModifiers, labelList);\n                        break;\n                    }\n                    case TokenID.OpenBrace: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("block does not take modifiers");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        var block = new Block(new ASTList(), true);\n                        this.pushStmt(block, labelList);\n                        this.parseStatementList(\n                            errorRecoverySet | ErrorRecoverySet.RCurly, block.statements,\n                            /*sourceElements:*/ false, /*noLeadingCase:*/ false, AllowedElements.None, modifiers);\n                        this.popStmt();\n                        block.statements.minChar = minChar;\n                        block.statements.limChar = this.scanner.pos;\n                        block.minChar = block.statements.minChar;\n                        block.limChar = block.statements.limChar;\n                        this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n                        ast = block;\n                        break;\n                    }\n                    case TokenID.Semicolon:\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("modifier can not appear here");\n                        }\n                        ast = new AST(NodeType.Empty);\n                        this.currentToken = this.scanner.scan();\n                        break;\n                    case TokenID.Break:\n                    case TokenID.Continue: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("modifiers can not appear before jump statement");\n                        }\n                        var jump =\n                            new Jump((this.currentToken.tokenId == TokenID.Break) ? NodeType.Break : NodeType.Cont',
v27583=v27584+'inue);\n                        this.currentToken = this.scanner.scan();\n                        if ((this.currentToken.tokenId == TokenID.Identifier) && (!this.scanner.lastTokenHadNewline())) {\n                            // Labeled break or continue.\n                            jump.target = this.currentToken.getText();\n                            this.currentToken = this.scanner.scan();\n                        }\n                        this.resolveJumpTarget(jump);\n                        ast = jump;\n                        needTerminator = true;\n                        break;\n                    }\n                    case TokenID.Return: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("modifiers can not appear before return statement");\n                        }\n                        if (!this.inFunction) {\n                            this.reportParseError("return statement outside of function body");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        var retStmt = new ReturnStatement();\n                        retStmt.minChar = minChar;\n                        if ((this.currentToken.tokenId != TokenID.Semicolon) &&\n                            (this.currentToken.tokenId != TokenID.CloseBrace) &&\n                            (!(this.scanner.lastTokenHadNewline()))) {\n                            retStmt.returnExpression = this.parseExpr(errorRecoverySet |\n                                                               ErrorRecoverySet.SColon,\n                                                               OperatorPrecedence.None,\n                                                               true, TypeContext.NoTypes);\n                        }\n                        needTerminator = true;\n                        retStmt.limChar = this.scanner.lastTokenLimChar();\n                        ast = retStmt;\n                        break;\n                    }\n                    case TokenID.Throw:\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("modifiers can not appear before a throw statement");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        if ((this.currentToken.tokenId != TokenID.Semicolon) &&\n                            (this.currentToken.tokenId != TokenID.CloseBrace) &&\n                            (!(this.scanner.lastTokenHadNewline()))) {\n                            temp = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon,\n                                           OperatorPrecedence.None, true, TypeContext.NoTypes);\n                        }\n                        else {\n                            this.reportParseError("throw with no target");\n                            temp = null;\n                        }\n                        ast = new UnaryExpression(NodeType.Throw, temp);\n                        ast.limChar = this.scanner.lastTokenLimChar();\n                        needTerminator = true;\n                        break;\n                    case TokenID.Enum:\n                        // TODO: check module allowed here\n                        //minChar=scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        ast = this.parseEnumDecl(errorRecoverySet, modifiers);\n                        ast.minChar = minChar;\n                        ast.limChar = this.scanner.lastTokenLimChar();\n                        if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Ambient)) {\n                            (<ModuleDeclaration>ast).modFlags |= ModuleFlags.Ambient;\n                        }\n                        if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Exported)) {\n                            (<ModuleDeclaration>ast).modFlags |= ModuleFlags.Exported;\n                        }\n                        break;\n                    case TokenID.Debugger:\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("modifiers can not appear before debugger statement");\n                        }\n                        \n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        var debuggerStmt = new DebuggerStatement();\n                        debuggerStmt.minChar = minChar;\n                        needTerminator = true;\n                        debuggerStmt.limChar = this.scanner.lastTokenLimChar();\n                        ast = debuggerStmt;\n                       ',
v27582=v27583+' break;\n                    default:\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("modifiers can not appear before an expression statement or label");\n                        }\n                        minChar = this.scanner.startPos;\n                        var svPos = this.scanner.pos;\n                        temp = this.parseExpr(ErrorRecoverySet.Colon | ErrorRecoverySet.StmtStart |\n                                       errorRecoverySet, OperatorPrecedence.None, true,\n                                       TypeContext.NoTypes);\n                        if (this.scanner.pos == svPos) {\n                            // no progress\n                            this.currentToken = this.scanner.scan();\n                            ast = temp;\n                        }\n                        else if ((this.currentToken.tokenId == TokenID.Colon) && (!this.scanner.lastTokenHadNewline()) &&\n                                        temp && (temp.nodeType == NodeType.Name)) {\n                                            // It\'s a label\n                            if (labelList == null) {\n                                labelList = new ASTList();\n                            }\n                            labelList.append(new Label(<Identifier>temp));\n                            this.currentToken = this.scanner.scan();\n                        }\n                        else {\n                            // expression statement\n                            ast = temp;\n                            needTerminator = true;\n                        }\n                }\n                if (ast) {\n                    break;\n                }\n            }\n            if (needTerminator) {\n                switch (this.currentToken.tokenId) {\n                    case TokenID.Semicolon:\n                        this.currentToken = this.scanner.scan();\n                        ast.flags |= ASTFlags.ExplicitSemicolon;\n                        break;\n                    case TokenID.EndOfFile:\n                        // Extend any incomplete statements to include EOF token. This makes sure that this node is in the path \n                        // when completion or parameter help is requested.\n                        ast.limChar = this.scanner.pos;\n                        // IntentionaCloseBracethrough\n                    case TokenID.CloseBrace:\n                        ast.flags |= ASTFlags.AutomaticSemicolon;\n                        if (this.style_requireSemi) {\n                            this.reportParseStyleError("no automatic semicolon");\n                        }\n                        break;\n                    default:\n                        if (!this.scanner.lastTokenHadNewline()) {\n                            this.reportParseError("Expected \';\'");\n                        }\n                        else {\n                            ast.flags |= ASTFlags.AutomaticSemicolon;\n                            if (this.style_requireSemi) {\n                                this.reportParseStyleError("no automatic semicolon");\n                            }\n                        }\n                        break;\n                }\n            }\n            if (labelList) {\n                ast = new LabeledStatement(labelList, ast);\n            }\n\n            ///////////////////////////////////////////////////////////\n            //TODO: Eventually, we want to remove "minChar" and "limChar" assignments here,\n            //      as they are sometimes not specific enough for each statement kind.\n            ast.minChar = minChar;\n            // Only update "limChar" if it is not better than "lastTokenLimChar()"\n            ast.limChar = max(ast.limChar, this.scanner.lastTokenLimChar());\n            //\n            ///////////////////////////////////////////////////////////\n\n            if (preComments) {\n                ast.preComments = preComments;\n            }\n            if (this.ambientModule && (!this.okAmbientModuleMember(ast))) {\n                this.reportParseError("statement not permitted within ambient module");\n            }\n            ast.flags |= ASTFlags.IsStatement;\n            return ast;\n        }\n\n        private okAmbientModuleMember(ast: AST) {\n            var nt = ast.nodeType;\n            return (nt == NodeType.ClassDeclaration) || (nt == NodeType.ImportDeclaration) || (nt == NodeType.InterfaceDeclaration) || (nt == NodeType.ModuleDeclaration) ||\n                (nt == NodeType.Empty) || (nt == NodeType.VarDecl) || \n                ((nt == NodeType.Block) && !(<Block>ast).isStatementBlock) ||\n                ((nt == NodeType.FuncDecl) && ((<FuncDecl>ast).isMethod()));\n        }\n\n        private parseStatementList(errorRecoverySet: ErrorRecoverySet,\n                                   statements: ASTList,\n                                   sourceElms: bool,\n                                   noLeadingCase: bool,\n                                   allowedElements: A',
v27581=v27582+'llowedElements,\n                                   parentModifiers: Modifiers): void {\n            var directivePrologue = sourceElms;\n            statements.minChar = this.scanner.startPos;\n            var limChar = this.scanner.pos;\n            var innerStmts = (allowedElements & AllowedElements.ModuleDeclarations) == AllowedElements.None;\n            var classNope = (allowedElements & AllowedElements.ClassDeclarations) == AllowedElements.None;\n\n            errorRecoverySet |= ErrorRecoverySet.TypeScriptS | ErrorRecoverySet.RCurly;\n\n            this.state = ParseState.StartStatementList;\n            var oldStrictMode = this.strictMode;\n            this.nestingLevel++;\n            for (; ;) {\n                if ((this.currentToken.tokenId == TokenID.CloseBrace) ||\n                    (noLeadingCase && ((this.currentToken.tokenId == TokenID.Case) || (this.currentToken.tokenId == TokenID.Default))) ||\n                    (innerStmts && (this.currentToken.tokenId == TokenID.Export)) ||\n                    (classNope && (this.currentToken.tokenId == TokenID.Class)) ||\n                    (this.currentToken.tokenId == TokenID.EndOfFile)) {\n                    this.state = ParseState.EndStmtList;\n                    statements.limChar = limChar;\n                    if (statements.members.length == 0) {\n                        statements.preComments = this.parseComments();\n                    }\n                    else {\n                        statements.postComments = this.parseComments();\n                    }\n                    this.strictMode = oldStrictMode;\n                    this.nestingLevel--;\n                    return;\n                }\n\n                var stmt = this.parseStatement(errorRecoverySet &\n                                        (~(ErrorRecoverySet.Else | ErrorRecoverySet.RParen |\n                                           ErrorRecoverySet.Catch | ErrorRecoverySet.Colon)),\n                                        allowedElements, parentModifiers);\n\n\n                if (stmt) {\n                    stmt.postComments = this.combineComments(stmt.postComments, this.parseCommentsForLine(this.scanner.prevLine));\n                    statements.append(stmt);\n                    limChar = stmt.limChar;\n                    if (directivePrologue) {\n                        if (stmt.nodeType == NodeType.QString) {\n                            var qstring = <StringLiteral>stmt;\n                            if (qstring.text == "\\"use strict\\"") {\n                                statements.flags |= ASTFlags.StrictMode;\n                                this.strictMode = true;\n                            }\n                            else {\n                                directivePrologue = false;\n                            }\n                        }\n                        else {\n                            directivePrologue = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        private fname = "";\n\n        public quickParse(sourceText: ISourceText, filename: string, unitIndex: number): QuickParseResult {\n            //TODO: REVIEW: We set this to avoid adding a "module" decl in the resulting script (see parse() method)\n            var svGenTarget = TypeScript.moduleGenTarget;\n            try {\n                TypeScript.moduleGenTarget = TypeScript.ModuleGenTarget.Local;\n                var script = this.parse(sourceText, filename, unitIndex, AllowedElements.QuickParse);\n                return new QuickParseResult(script, this.scanner.lexState);\n            }\n            finally {\n                TypeScript.moduleGenTarget = svGenTarget;\n            }\n        }\n\n        public parse(sourceText: ISourceText, filename: string, unitIndex: number, allowedElements = AllowedElements.Global): Script {\n            // Reset all parser state here.  This allows us to be resilient to reentrancy if an \n            // exception is thrown.\n            this.fname = filename;\n            this.currentUnitIndex = unitIndex;\n\n            this.currentToken = null;\n            this.needTerminator = false;\n            this.inFunction = false;\n            this.inInterfaceDecl = false;\n            this.inFncDecl = false;\n            this.state = ParseState.StartStatementList;\n            this.ambientModule = false;\n            this.ambientClass = false;\n            this.topLevel = true;\n            this.allowImportDeclaration = true;\n            this.prevIDTok = null;\n            this.statementInfoStack = new IStatementInfo[];\n            this.hasTopLevelImportOrExport = false;\n            this.strictMode = false;\n            this.nestingLevel = 0;\n            this.prevExpr = null;\n            this.currentClassDefinition = null;\n            this.parsingClassConstructorDefinition = false;\n            this.parsingDeclareFile = false;\n            this.amdDependencies = [];\n            this.inferPropertiesFromThisAssignment = false;\n            this.requiresExtendsBlock = false;\n\n',
v27580=v27581+'            this.scanner.resetComments();\n            this.scanner.setErrorHandler((message) =>this.reportParseError(message));\n            this.scanner.setSourceText(sourceText, LexMode.File);\n\n            var leftCurlyCount = this.scanner.leftCurlyCount;\n            var rightCurlyCount = this.scanner.rightCurlyCount;\n\n            var minChar = this.scanner.pos;\n            this.currentToken = this.scanner.scan();\n            this.pushDeclLists();\n            var bod = new ASTList();\n            bod.minChar = minChar;\n\n            this.state = ParseState.StartScript;\n            this.parsingDeclareFile = isDSTRFile(filename) || isDTSFile(filename);\n\n            while (true) {\n                this.parseStatementList(\n                    ErrorRecoverySet.EOF | ErrorRecoverySet.Func,\n                    bod, /*sourceElements:*/ true, /*noLeadingCase:*/ false,\n                    allowedElements, Modifiers.None);\n\n                if (this.currentToken.tokenId === TokenID.EndOfFile) {\n                    break;\n                }\n\n                // Still have remaining tokens in the file.  Report error for this unexpected token,\n                // skip it, and continue trying to parse statements until we\'re done. \n                var badToken = tokenTable[this.currentToken.tokenId];\n                this.reportParseError("Unexpected statement block terminator \'" + badToken.text + "\'");\n\n                this.currentToken = this.scanner.scan();\n            }\n\n            this.state = ParseState.EndScript;\n\n            bod.limChar = this.scanner.pos;\n\n            var topLevelMod: ModuleDeclaration = null;\n            if (moduleGenTarget != ModuleGenTarget.Local && this.hasTopLevelImportOrExport) {\n                var correctedFileName = switchToForwardSlashes(filename);\n                var id: Identifier = new Identifier(correctedFileName);\n                topLevelMod = new ModuleDeclaration(id, bod, this.topVarList(), this.topScopeList(), null);\n\n                topLevelMod.modFlags |= ModuleFlags.IsDynamic;\n                topLevelMod.modFlags |= ModuleFlags.IsWholeFile;\n                topLevelMod.modFlags |= ModuleFlags.Exported;\n\n                if (this.parsingDeclareFile) {\n                    topLevelMod.modFlags |= ModuleFlags.Ambient;\n                }\n\n                topLevelMod.minChar = minChar;\n                topLevelMod.limChar = this.scanner.pos;\n                topLevelMod.prettyName = getPrettyName(correctedFileName);\n                topLevelMod.containsUnicodeChar = this.scanner.seenUnicodeChar;\n                topLevelMod.containsUnicodeCharInComment = this.scanner.seenUnicodeCharInComment;\n\n                topLevelMod.amdDependencies = this.amdDependencies;\n\n                bod = new ASTList();\n                bod.minChar = topLevelMod.minChar;\n                bod.limChar = topLevelMod.limChar;\n                bod.append(topLevelMod);\n            }\n\n            var script = new Script(this.topVarList(), this.topScopeList());\n            script.bod = bod;\n            this.popDeclLists();\n            script.minChar = minChar;\n            script.limChar = this.scanner.pos;\n            script.locationInfo = new LocationInfo(filename, this.scanner.lineMap, unitIndex);\n            script.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n            script.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n            script.isDeclareFile = this.parsingDeclareFile;\n            script.topLevelMod = topLevelMod;\n            script.containsUnicodeChar = this.scanner.seenUnicodeChar;\n            script.containsUnicodeCharInComment = this.scanner.seenUnicodeCharInComment;\n            script.requiresExtendsBlock = this.requiresExtendsBlock;\n            return script;\n        }\n    }\n\n    export function quickParse(logger: TypeScript.ILogger, scopeStartAST: AST, sourceText: ISourceText, minChar: number, limChar: number,\n        errorCapture: (minChar: number, charLen: number, message: string, unitIndex: number) => void ): QuickParseResult {\n\n        var fragment = sourceText.getText(minChar, limChar);\n        logger.log("Quick parse range (" + minChar + "," + limChar + "): \\"" + TypeScript.stringToLiteral(fragment, 100) + "\\"");\n\n        var quickParser = new Parser();\n        quickParser.setErrorRecovery(null);\n        quickParser.errorCallback = errorCapture;\n\n        // REVIEW: use enclosing scope to determine this\n        // REVIEW: Why even use class here?\n        var quickClassDecl = new ClassDeclaration(null, null, null, null);\n        quickParser.currentClassDecl = quickClassDecl;\n\n        var result = quickParser.quickParse(new StringSourceText(fragment), "", 0);\n        return result;\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/license',
v27579=v27580+'s/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    // We need to catch both left and right quotes\n    // (depending on your editor\'s font, this may not be clear...)    \n    export function stripQuotes(str: string) {\n        return str.replace("\\"", "").replace("\'", "").replace("\'", "").replace("\\"", "")\n    }\n\n    export function isQuoted(str: string) {\n        return str.indexOf("\\"") != -1 || str.indexOf("\'") != -1 || str.indexOf("\'") != -1 || str.indexOf("\\"") != -1;\n    }\n\n    export function quoteStr(str: string) {\n        return "\\"" + str + "\\"";\n    }\n\n    export function swapQuotes(str: string) {\n\n        if (str.indexOf("\\"") != -1) {\n            str = str.replace("\\"", "\'");\n            str = str.replace("\\"", "\'");\n        }\n        else {\n            str = str.replace("\'", "\\"");\n            str = str.replace("\'", "\\"");\n        }\n\n        return str;\n    }\n\n    export function switchToForwardSlashes(path: string) {\n        return path.replace(/\\\\/g, "/");\n    }\n\n    export function trimModName(modName: string) {\n        // in case\'s it\'s a declare file...\n        if (modName.length > 6 && modName.substring(modName.length - 6, modName.length) == ".d.str") {\n            return modName.substring(0, modName.length - 6);\n        }\n        if (modName.length > 4 && modName.substring(modName.length - 4, modName.length) == ".str") {\n            return modName.substring(0, modName.length - 4);\n        }\n        if (modName.length > 5 && modName.substring(modName.length - 5, modName.length) == ".d.ts") {\n            return modName.substring(0, modName.length - 5);\n        }\n        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) == ".ts") {\n            return modName.substring(0, modName.length - 3);\n        }\n        // in case\'s it\'s a .js file\n        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) == ".js") {\n            return modName.substring(0, modName.length - 3);\n        }\n\n        return modName;\n    }\n\n    export function getDeclareFilePath(fname: string) {\n        return isSTRFile(fname) ? changePathToDSTR(fname) : isTSFile(fname) ? changePathToDTS(fname) : changePathToDTS(fname);\n    }\n\n    function isFileOfExtension(fname: string, ext: string) {\n        var invariantFname = fname.toLocaleUpperCase();\n        var invariantExt = ext.toLocaleUpperCase();\n        var extLength = invariantExt.length;\n        return invariantFname.length > extLength && invariantFname.substring(invariantFname.length - extLength, invariantFname.length) == invariantExt;\n    }\n\n    export function isJSFile(fname: string) {\n        return isFileOfExtension(fname, ".js");\n    }\n\n    export function isSTRFile(fname: string) {\n        return isFileOfExtension(fname, ".str");\n    }\n\n    export function isTSFile(fname: string) {\n        return isFileOfExtension(fname, ".ts");\n    }\n\n    export function isDSTRFile(fname: string) {\n        return isFileOfExtension(fname, ".d.str");\n    }\n\n    export function isDTSFile(fname: string) {\n        return isFileOfExtension(fname, ".d.ts");\n    }\n\n    export function getPrettyName(modPath: string, quote?=true, treatAsFileName?=false) { \n        var modName = treatAsFileName ? switchToForwardSlashes(modPath) : trimModName(stripQuotes(modPath));\n        var components = this.getPathComponents(modName);\n        return components.length ? (quote ? quoteStr(components[components.length - 1]) : components[components.length - 1]) : modPath;\n    }\n\n    export function getPathComponents(path: string) {\n        return path.split("/");\n    }\n\n    export function getRelativePathToFixedPath(fixedModFilePath: string, absoluteModPath: string) {\n        absoluteModPath = switchToForwardSlashes(absoluteModPath);\n\n        var modComponents = this.getPathComponents(absoluteModPath);\n        var fixedModComponents = this.getPathComponents(fixedModFilePath);\n\n        // Find the component that differs\n        var joinStartIndex = 0;\n        for (; joinStartIndex < modComponents.length && joinStartIndex < fixedModComponents.length ; joinStartIndex++) {\n            if (fixedModComponents[joinStartIndex] != modComponents[joinStartIndex]) {\n                break;\n            }\n        }\n\n        // Get the relative path\n        if (joinStartIndex != 0) {\n            var relativePath = "";\n            var relativePathComponents = modComponents.slice(joinStartIndex, modComponents.length);\n            for (; joinStartIndex < fixedModComponents.length; joinStartIndex++) {\n                if (fixedModComponents[joinStartIndex] != "") {\n                    relativePath = relativePath + "../";\n      ',
v27578=v27579+'          }\n            }\n\n            return relativePath + relativePathComponents.join("/");\n        }\n\n        return absoluteModPath;\n    }\n\n    export function quoteBaseName(modPath: string) {\n        var modName = trimModName(stripQuotes(modPath));\n        var path = getRootFilePath(modName);\n        if (path == "") {\n            return modPath;\n        }\n        else {\n            var components = modName.split(path);\n            var fileIndex = components.length > 1 ? 1 : 0;\n            return quoteStr(components[fileIndex]);\n        }\n    }\n\n    export function changePathToSTR(modPath: string) {\n        return trimModName(stripQuotes(modPath)) + ".str";\n    }\n\n    export function changePathToDSTR(modPath: string) {\n        return trimModName(stripQuotes(modPath)) + ".d.str";\n    }\n\n    export function changePathToTS(modPath: string) {\n        return trimModName(stripQuotes(modPath)) + ".ts";\n    }\n\n    export function changePathToDTS(modPath: string) {\n        return trimModName(stripQuotes(modPath)) + ".d.ts";\n    }\n\n    export function isRelative(path: string) {\n        return path.charAt(0) == ".";\n    }\n    export function isRooted(path: string) {\n        return path.charAt(0) == "\\\\" || path.charAt(0) == "/" || (path.indexOf(":\\\\") != -1) || (path.indexOf(":/") != -1);\n    }\n\n    export function getRootFilePath(outFname: string) {\n        if (outFname == "") {\n            return outFname;\n        }\n        else {\n            var isPath = outFname.indexOf("/") != -1;\n            return isPath ? filePath(outFname) : "";\n        }\n    }\n\n    export function filePathComponents(fullPath: string) {\n        fullPath = switchToForwardSlashes(fullPath);\n        var components = getPathComponents(fullPath);\n        return components.slice(0, components.length - 1);\n    }\n\n    export function filePath(fullPath: string) {\n        var path = filePathComponents(fullPath);\n        return path.join("/") + "/";\n    }\n\n    export function normalizeURL(url: string): string {\n        var hostDomainAndPortRegex = /^(https?:\\/\\/[\\-\\w\\.]+(:\\d+)?\\/)(.*)$/i;\n        var matches = hostDomainAndPortRegex.exec(url);\n        if (matches) {\n            var hostDomainAndPort = matches[1];\n            var actualPath = matches[3];\n            return hostDomainAndPort + normalizePath(actualPath);\n        }\n        return normalizePath(url);\n    }\n\n    export var pathNormalizeRegExp = /\\//g;\n\n    export function normalizePath(path: string): string {\n        path = switchToForwardSlashes(path);\n        var startedWithSep = path.charAt(0) === "/";\n        var parts = this.getPathComponents(path);\n        for (var i = 0; i < parts.length; i++) {\n            if (parts[i] === "." || parts[i] === "") {\n                parts.splice(i, 1);\n                i--;\n            }\n            if (i > 0 && parts[i] === ".." && parts[i - 1] !== "..") {\n                parts.splice(i - 1, 2);\n                i -= 2;\n            }\n        }\n        return (startedWithSep ? "/" : "") + parts.join("/");\n    }\n\n    export function normalizeImportPath(path: string): string {\n        return normalizePath(path);\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    /// Compiler settings\n\n    export class StyleSettings {\n        // bitwise operations not permitted\n        public bitwise = false;  \n        // disallow non-block statements as bodies of compound statements\n        public blockInCompoundStmt = false;\n        // disallow == and !=\n        public eqeqeq = false;\n        // require body of for in loop to start with a filter\n        public forin = false;\n        // empty blocks permitted\n        public emptyBlocks = true;\n        // require result of new expression to be used (no new just for side-effects)\n        public newMustBeUsed = false;\n        // require semicolons to terminate statements\n        public requireSemi = false;\n        // no top-level assignment in conditionals if (a=b) { ...\n        public assignmentInCond = false;\n        // no == null or != null\n        public eqnull = false;\n        // permit eval\n        public evalOK = true;\n        // permit var use if decl in inner scope as in if (c) { var v=10; } v=11;\n        public innerScopeDeclEscape = true;\n        // permit functions in loops\n        public funcInLoop = true;\n        // permit re-declaration of local variable \n        public reDecl',
v27577=v27578+'areLocal = true;\n        // permit obj[\'x\'] in addition to obj.x\n        public literalSubscript = true;\n        // flag implicit \'any\'\n        public implicitAny = false;\n\n        public setOption(opt: string, val: bool): bool {\n            var optExists = this[opt];\n            if (optExists !== undefined) {\n                this[opt] = val;\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n        \n        public parseOptions(str: string) {\n            var opts=str.split(";");\n            for (var i = 0, len = opts.length; i < len; i++) {\n                var opt = opts[i];\n                var val = true;\n                var colonIndex=opt.lastIndexOf(":");\n                if (colonIndex >= 0) {\n                    var valStr = opt.substring(colonIndex+1);\n                    opt = opt.substring(0, colonIndex);\n                    if (valStr == "off") {\n                        val = false;\n                    }\n                }\n                if (!this.setOption(opt, val)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    \n    export class CompilationSettings {\n        public styleSettings = new StyleSettings();\n        public propagateConstants = false;\n        public minWhitespace = false;\n        public parseOnly = false;\n        public errorRecovery = false;\n        public emitComments = false;\n        public watch = false;\n        public exec = false;\n        public resolve = true;\n        public controlFlow = false;\n        public printControlFlow = false;\n        public controlFlowUseDef = false;\n        public errorOnWith = true;\n        public preprocess = true;\n        public canCallDefinitionSignature = false;\n\n        public inferPropertiesFromThisAssignment = false;\n        public useDefaultLib = true;\n\n        public codeGenTarget = CodeGenTarget.ES3;\n        public moduleGenTarget = ModuleGenTarget.Synchronous;\n        // --out option passed. \n        // Default is the "" which leads to multiple files generated next to the.ts files\n        public outputOption: string = "";\n        public mapSourceFiles = false;\n        public generateDeclarationFiles = false;\n\n        public useCaseSensitiveFileResolution = false;\n\n        public setStyleOptions(str: string) {\n            this.styleSettings.parseOptions(str);\n        }\n    }\n\n    ///\n    /// Preprocessing\n    ///\n    export interface IPreProcessedFileInfo {\n        settings: CompilationSettings;\n        referencedFiles: IFileReference[];\n        importedFiles: IFileReference[];\n        isLibFile: bool;\n    }\n\n    function getFileReferenceFromReferencePath(comment: string): IFileReference {\n        var referencesRegEx = /^(\\/\\/\\/\\s*<reference\\s+path=)(\'|")(.+?)\\2\\s*(static=(\'|")(.+?)\\2\\s*)*\\/>/gim;\n        var match = referencesRegEx.exec(comment);\n\n        if (match) {\n            var path: string = normalizePath(match[3]);\n            var adjustedPath = normalizePath(path);\n    \n            var isResident = match.length >= 7 && match[6] == "true";\n            if (isResident) {\n                CompilerDiagnostics.debugPrint(path + " is resident");\n            }\n            return { minChar: 0, limChar: 0, path: switchToForwardSlashes(adjustedPath), isResident: isResident };\n        }\n        else {\n            return null;\n        }\n    }\n\n    // used in the parser, but kept here in case we want to reintegrate it with preprocessing\n    export function getAdditionalDependencyPath(comment: string): string {\n        var amdDependencyRegEx = /^(\\/\\/\\/\\s*<amd-dependency\\s+path=)(\'|")(.+?)\\2\\s*(static=(\'|")(.+?)\\2\\s*)*\\/>/gim;\n        var match = amdDependencyRegEx.exec(comment);\n\n        if (match) {\n            var path: string = match[3];\n            return path;\n        }\n        else {\n            return null;\n        }\n    }\n\n    export function getImplicitImport(comment: string): bool {\n        var implicitImportRegEx = /^(\\/\\/\\/\\s*<implicit-import\\s*)*\\/>/gim;\n        var match = implicitImportRegEx.exec(comment);\n\n        if (match) {\n            return true;\n        }\n        \n        return false;\n    }\n\n    export function getStyleSettings(comment: string, styleSettings: StyleSettings) {\n        var styleRegEx = /^(\\/\\/\\/\\s*<style\\s+)(([a-zA-Z])+=(\'|").+(\'|"))\\s*\\/>/gim;\n\n        var settings = styleRegEx.exec(comment);\n\n        if (settings) {\n            var settingsRegEx = /^([a-zA-Z]+=[\'"]on[\'|"])/gim;\n            settings = settingsRegEx.exec(settings[2]);\n                \n            if (settings) {\n                for (var i = 0; i < settings.length; i++) {\n                    var setting = (<string>settings[i]).split("=");\n                    var on = "\\"on\\"";\n\n                    switch (setting[0]) {\n                        case "blockInCompoundStmt": styleSettings.blockInCompoundStmt = setting[1] == on; break;\n                        case "eqeqeq": styleSettings.eqeqeq = setting[1] == on; break;',
v27576=v27577+'\n                        case "forin": styleSettings.forin = setting[1] == on; break;\n                        case "emptyBlocks": styleSettings.emptyBlocks = setting[1] == on; break;\n                        case "newMustBeUsed": styleSettings.newMustBeUsed = setting[1] == on; break;\n                        case "requireSemi": styleSettings.requireSemi = setting[1] == on; break;\n                        case "assignmentInCond": styleSettings.assignmentInCond = setting[1] == on; break;\n                        case "eqnull": styleSettings.eqnull = setting[1] == on; break;\n                        case "evalOK": styleSettings.evalOK = setting[1] == on; break;\n                        case "innerScopeDeclEscape": styleSettings.innerScopeDeclEscape = setting[1] == on; break;\n                        case "funcInLoop": styleSettings.funcInLoop = setting[1] == on; break;\n                        case "reDeclareLocal": styleSettings.reDeclareLocal = setting[1] == on; break;\n                        case "literalSubscript": styleSettings.literalSubscript = setting[1] == on; break;\n                        case "implicitAny": styleSettings.implicitAny = setting[1] == on; break;                               \n                    }\n                }\n            }\n        }\n    }\n\n    export function getReferencedFiles(sourceText: ISourceText): IFileReference[] {\n        var preProcessInfo = preProcessFile(sourceText, null, false);\n        return preProcessInfo.referencedFiles;\n    }\n\n    export function preProcessFile(sourceText: ISourceText, options=new CompilationSettings(), readImportFiles? = true): IPreProcessedFileInfo {\n        var scanner = new Scanner();\n        scanner.resetComments();\n        scanner.setSourceText(sourceText, LexMode.File);\n\n        var tok: Token = scanner.scan();\n        var comments: CommentToken[] = [];\n        var comment: CommentToken = null;\n        var leftCurlies: Token[] = [];\n\n        var settings: CompilationSettings = options;\n        var referencedFiles: IFileReference[] = [];\n        var importedFiles: IFileReference[] = [];\n        var isLibFile: bool = false;\n\n        // only search out dynamic mods\n        // if you find a dynamic mod, ignore every other mod inside, until you balance rcurlies\n\n        while (tok.tokenId != TokenID.EndOfFile) {\n\n            if (readImportFiles && tok.tokenId == TokenID.Import) {\n\n                tok = scanner.scan();\n\n                if (tok.tokenId == TokenID.Identifier || convertTokToID(tok, false)) {\n                    tok = scanner.scan();\n\n                    if (tok.tokenId == TokenID.Equals) {\n                        tok = scanner.scan();\n\n                        if (tok.tokenId == TokenID.Module) {\n                            tok = scanner.scan();\n                            if (tok.tokenId == TokenID.OpenParen) {\n                                tok = scanner.scan();\n\n                                // import foo = module("foo")\n                                if (tok.tokenId == TokenID.StringLiteral) {\n                                    var ref = { minChar: scanner.startPos, limChar: scanner.pos, path: stripQuotes(switchToForwardSlashes(tok.getText())), isResident: false };\n                                    importedFiles.push(ref);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (tok.tokenId == TokenID.OpenBrace) {\n                leftCurlies.push(tok);\n            }\n\n            if (tok.tokenId == TokenID.CloseBrace) {\n                leftCurlies.pop();\n            }\n\n            tok = scanner.scan();\n        }\n\n        // deal with comment references, amd dependencies and style settings\n        // REVIEW: We could potentially do this inline with the above, if we\n        // set Scanner::scanComments to \'true\'\n        comments = scanner.getComments();\n\n        for (var iComment = 0; iComment < comments.length; iComment++) {\n            comment = comments[iComment];\n            \n            if (!comment.isBlock) {\n                var referencedCode = getFileReferenceFromReferencePath(comment.getText());\n                if (referencedCode) {\n                    referencedCode.minChar = comment.startPos;\n                    referencedCode.limChar = referencedCode.minChar + comment.value.length;\n                    referencedFiles.push(referencedCode);\n                }\n\n                if (settings) {\n                    getStyleSettings(comment.getText(), settings.styleSettings);\n\n                    // is it a lib file?\n                    var isNoLibRegex = /^(\\/\\/\\/\\s*<reference\\s+no-default-lib=)(\'|")(.+?)\\2\\s*\\/>/gim;\n                    var isNoLibMatch: any = isNoLibRegex.exec(comment.getText());\n                    if (isNoLibMatch) {\n                        isLibFile = (isNoLibMatch[3] == "true");\n                    }\n                }\n            }\n        }\n\n        return { settings: settings, referencedFiles: refere',
v27575=v27576+'ncedFiles, importedFiles: importedFiles, isLibFile: isLibFile };\n    }\n\n} // Tools//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    // TODO: refactor indent logic for use in emit\n    export class PrintContext {\n        public builder = "";\n        public indent1 = "  ";\n        public indentStrings: string[] = [];\n        public indentAmt = 0;\n\n        constructor (public outfile: ITextWriter, public parser: Parser) {\n        }\n\n        public increaseIndent() {\n            this.indentAmt++;\n        }\n\n        public decreaseIndent() {\n            this.indentAmt--;\n        }\n\n        public startLine() {\n            if (this.builder.length > 0) {\n                CompilerDiagnostics.Alert(this.builder);\n            }\n            var indentString = this.indentStrings[this.indentAmt];\n            if (indentString === undefined) {\n                indentString = "";\n                for (var i = 0; i < this.indentAmt; i++) {\n                    indentString += this.indent1;\n                }\n                this.indentStrings[this.indentAmt] = indentString;\n            }\n            this.builder += indentString;\n        }\n\n        public write(s) {\n            this.builder += s;\n        }\n\n        public writeLine(s) {\n            this.builder += s;\n            this.outfile.WriteLine(this.builder);\n            this.builder = "";\n        }\n\n    }\n\n    export function prePrintAST(ast: AST, parent: AST, walker: IAstWalker) {\n        var pc: PrintContext = <PrintContext>walker.state;\n\n        ast.print(pc);\n        pc.increaseIndent();\n        return ast;\n    }\n\n\n    export function postPrintAST(ast: AST, parent: AST, walker: IAstWalker) {\n        var pc: PrintContext = <PrintContext>walker.state;\n        pc.decreaseIndent();\n        return ast;\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export interface IResolvedFile {\n        content: string;\n        path: string;\n    }\n\n    /// This class acts as a convenience class to store path and content information in places\n    /// where we need an ISourceText object\n    export class SourceUnit implements ISourceText, IResolvedFile {\n        public referencedFiles: IFileReference[] = null;\n        constructor(public path: string, public content: string) {\n        }\n\n        public getText(start: number, end: number): string { return this.content.substring(start, end); }\n        public getLength(): number { return this.content.length; }\n    }\n\n    export interface IFileReference {\n        minChar: number;\n        limChar: number;\n        path: string;\n        isResident: bool;\n    }\n\n    /// Limited API for file system manipulation\n    export interface IFileSystemObject {\n        resolvePath(path: string): string;\n        readFile(path: string): string;\n        findFile(rootPath: string, partialFilePath: string): IResolvedFile;\n        dirName(path: string): string;\n    }\n\n    export class CompilationEnvironment {\n        constructor (public compilationSettings: CompilationSettings, public ioHost: IFileSystemObject) { }\n        public residentCode: SourceUnit[] = [];\n        public code: SourceUnit[] = [];\n    }\n\n    export interface IResolutionDispatcher {\n        postResolutionError(errorFile: string, errorMessage: string, errorObject: any): void;\n        postResolution(path: string, source: ISourceText): void;\n    }\n\n    export interface ICodeResolver {\n        resolveCode(referencePath: string, rootPath: string, performSearch:bool, state: IResolutionDispatcher): void;\n    }\n\n    export interface IResolverHost {\n        resolveCompilationEnvironment(preEnvironment: CompilationEnvironment, resolver: ICodeResolver, traceDependencies: bool): CompilationEnvironment;\n    }\n\n    export class CodeResolver implements T',
v27574=v27575+'ypeScript.ICodeResolver {\n        public visited: any = { };\n\n        constructor (public environment: CompilationEnvironment) { }\n\n        public resolveCode(referencePath: string, parentPath: string, performSearch: bool, resolutionDispatcher: TypeScript.IResolutionDispatcher): void {\n            \n            var resolvedFile: IResolvedFile = { content: null, path: referencePath };\n            \n            var ioHost = this.environment.ioHost;\n            \n            // If the path is relative, normalize it, based on the root\n            var isRelativePath = TypeScript.isRelative(referencePath);\n            var isRootedPath = isRelativePath ? false : isRooted(referencePath);\n            var normalizedPath: string = \n                isRelativePath ? ioHost.resolvePath(parentPath + "/" + referencePath) : \n                // we only follow the second clause if the path is a non-rooted triple-slash reference path\n                (isRootedPath || !parentPath || performSearch ? referencePath : parentPath + "/" + referencePath);\n\n            // We use +=.ts to make sure we don\'t accidentally pick up ".js" files or the like\n            if (!isSTRFile(normalizedPath) && !isTSFile(normalizedPath)) {\n                normalizedPath += ".ts";  //changePathToSTR(normalizedPath);\n            }\n\n            normalizedPath = switchToForwardSlashes(stripQuotes(normalizedPath));\n            var absoluteModuleID = this.environment.compilationSettings.useCaseSensitiveFileResolution ? normalizedPath : normalizedPath.toLocaleUpperCase();\n            // read the file contents - if it doesn\'t exist, trigger a resolution error\n            if (!this.visited[absoluteModuleID]) {\n\n                // if the path is relative, or came from a reference tag, we don\'t perform a search\n                if (isRelativePath || isRootedPath || !performSearch) {\n                    try {\n                        CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);\n                            \n                        // Look for the .ts file first - if not present, use the .ts, the .d.str and the .d.ts\n                        try {\n                            resolvedFile.content = ioHost.readFile(normalizedPath);\n                        }\n                        catch (err) {\n                            try {\n                                if (isSTRFile(normalizedPath)) {\n                                    normalizedPath = changePathToTS(normalizedPath);\n                                }\n                                else if (isTSFile(normalizedPath)) {\n                                    normalizedPath = changePathToSTR(normalizedPath);\n                                }\n                                CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);\n                                resolvedFile.content = ioHost.readFile(normalizedPath);\n                            }\n                            catch (err) {\n                                normalizedPath = changePathToDSTR(normalizedPath);\n                                CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);\n\n                                try {\n                                    resolvedFile.content = ioHost.readFile(normalizedPath);\n                                }\n                                catch (err) {\n                                    normalizedPath = changePathToDTS(normalizedPath);\n                                    CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);\n                                    resolvedFile.content = ioHost.readFile(normalizedPath);\n                                }\n                            }\n                        }\n                        CompilerDiagnostics.debugPrint("   Found code at " + normalizedPath);\n\n                        resolvedFile.path = normalizedPath;\n                        this.visited[absoluteModuleID] = true;\n                    }\n                    catch (err) {\n                        CompilerDiagnostics.debugPrint("   Did not find code for " + referencePath);\n                    }\n                }\n                else {\n\n                    // if the path is non-relative, we should attempt to search on the relative path\n                    resolvedFile = ioHost.findFile(parentPath, normalizedPath);\n\n                    if (!resolvedFile) {\n                        if (isSTRFile(normalizedPath)) {\n                            normalizedPath = changePathToTS(normalizedPath);\n                        }\n                        else if (isTSFile(normalizedPath)) {\n                            normalizedPath = changePathToSTR(normalizedPath);\n                        }\n                        resolvedFile = ioHost.findFile(parentPath, normalizedPath);\n                    }\n\n                    if (!resolvedFile) {\n                        normalizedPath = changePathToDTS(normalizedPath);\n                        resolvedFile = ioHo',
v27573=v27574+"st.findFile(parentPath, normalizedPath);\n                        if (!resolvedFile) {\n                            normalizedPath = changePathToDSTR(normalizedPath);\n                            resolvedFile = ioHost.findFile(parentPath, normalizedPath);\n                        }\n                    }\n\n                    if (resolvedFile) {\n                        resolvedFile.path = switchToForwardSlashes(TypeScript.stripQuotes(resolvedFile.path));\n                        CompilerDiagnostics.debugPrint(referencePath + \" resolved to: \" + resolvedFile.path);\n                        resolvedFile.content = resolvedFile.content;\n                        this.visited[absoluteModuleID] = true;\n                    }\n                    else {\n                        CompilerDiagnostics.debugPrint(\"Could not find \" + referencePath);\n                    }\n                }\n\n                if (resolvedFile && resolvedFile.content != null) {\n                    // preprocess the file, to gather dependencies\n                    var rootDir = ioHost.dirName(resolvedFile.path);\n                    var sourceUnit = new SourceUnit(resolvedFile.path, resolvedFile.content);\n                    var preProcessedFileInfo = preProcessFile(sourceUnit, this.environment.compilationSettings);\n                    sourceUnit.referencedFiles = preProcessedFileInfo.referencedFiles;\n\n                    // resolve explicit references\n                    for (var i = 0; i < preProcessedFileInfo.referencedFiles.length; i++) {\n                        var referencedFile = preProcessedFileInfo.referencedFiles[i];\n                        var normalizedPath = isRooted(referencedFile.path) ? referencedFile.path : rootDir + \"/\" + referencedFile.path;\n                        normalizedPath = ioHost.resolvePath(normalizedPath);\n                        if (referencePath == normalizedPath) {\n                            resolutionDispatcher.postResolutionError(normalizedPath, \"File contains reference to itself\", null);\n                            continue;\n                        }\n                        this.resolveCode(referencedFile.path, rootDir, false, resolutionDispatcher);\n                    }\n                    \n                    // resolve imports\n                    for (var i = 0; i < preProcessedFileInfo.importedFiles.length; i++) {\n                        this.resolveCode(preProcessedFileInfo.importedFiles[i].path, rootDir, true, resolutionDispatcher);\n                    }\n\n                    // add the file to the appropriate code list\n                    resolutionDispatcher.postResolution(sourceUnit.path, sourceUnit);\n                }\n            }\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path='typescript.ts' />\n\nmodule TypeScript {\n\n    export var LexEOF = (-1);\n\n    export var LexCodeNWL = 0x0A;\n    export var LexCodeRET = 0x0D;\n    export var LexCodeLS =  0x2028;\n    export var LexCodePS =  0x2029;\n    export var LexCodeTAB = 0x09;\n    export var LexCodeVTAB = 0x0B;\n    export var LexCode_e = 'e'.charCodeAt(0);\n    export var LexCode_E = 'E'.charCodeAt(0);\n    export var LexCode_x = 'x'.charCodeAt(0);\n    export var LexCode_X = 'X'.charCodeAt(0);\n    export var LexCode_a = 'a'.charCodeAt(0);\n    export var LexCode_A = 'A'.charCodeAt(0);\n    export var LexCode_f = 'f'.charCodeAt(0);\n    export var LexCode_F = 'F'.charCodeAt(0);\n\n    export var LexCode_g = 'g'.charCodeAt(0);\n    export var LexCode_m = 'm'.charCodeAt(0);\n    export var LexCode_i = 'i'.charCodeAt(0);\n\n    export var LexCode_u = 'u'.charCodeAt(0);\n\n    export var LexCode_0 = '0'.charCodeAt(0);\n    export var LexCode_9 = '9'.charCodeAt(0);\n    export var LexCode_8 = '8'.charCodeAt(0);\n    export var LexCode_7 = '7'.charCodeAt(0);\n\n    export var LexCodeBSL = '\\\\'.charCodeAt(0);\n    export var LexCodeSHP = '#'.charCodeAt(0);\n    export var LexCodeBNG = '!'.charCodeAt(0);\n    export var LexCodeQUO = '\"'.charCodeAt(0);\n    export var LexCodeAPO = '\\''.charCodeAt(0);\n    export var LexCodePCT = '%'.charCodeAt(0);\n    export var LexCodeAMP = '&'.charCodeAt(0);\n    export var LexCodeLPR = '('.charCodeAt(0);\n    export var LexCodeRPR = ')'.charCodeAt(0);\n    export var LexCodePLS = '+'.charCodeAt(0);\n    export var LexCodeMIN = '-'.charCodeAt(0);\n    export var LexCodeMUL = '*'.charCodeAt(0);\n    export var LexCodeSLH = '/'.charCodeAt(0);\n    export var LexCodeXOR = '^'.",
v27572=v27573+"charCodeAt(0);\n    export var LexCodeCMA = ','.charCodeAt(0);\n    export var LexCodeDOT = '.'.charCodeAt(0);\n    export var LexCodeLT = '<'.charCodeAt(0);\n    export var LexCodeEQ = '='.charCodeAt(0);\n    export var LexCodeGT = '>'.charCodeAt(0);\n    export var LexCodeQUE = '?'.charCodeAt(0);\n    export var LexCodeLBR = '['.charCodeAt(0);\n    export var LexCodeRBR = ']'.charCodeAt(0);\n    export var LexCodeUSC = '_'.charCodeAt(0);\n    export var LexCodeLC = '{'.charCodeAt(0);\n    export var LexCodeRC = '}'.charCodeAt(0);\n    export var LexCodeBAR = '|'.charCodeAt(0);\n    export var LexCodeTIL = '~'.charCodeAt(0);\n    export var LexCodeCOL = ':'.charCodeAt(0);\n    export var LexCodeSMC = ';'.charCodeAt(0);\n    export var LexCodeUnderscore = '_'.charCodeAt(0);\n    export var LexCodeDollar = '$'.charCodeAt(0);\n    export var LexCodeSpace = 32;\n    export var LexCodeAtSign = '@'.charCodeAt(0);\n    export var LexCodeASCIIChars = 128;\n\n    export var LexKeywordTable = undefined;\n    // TODO: use new Token[128];\n    var autoToken: Token[] = new Array(LexCodeASCIIChars);\n    var lexIdStartTable: bool[] = new Array(LexCodeASCIIChars);\n\n    // Unicode range maps\n    // REVIEW: These range maps have been extracted from the Unicode specifications, they might be missing values, and/or include \n    //         incorrect ranges. but for the most they seem to be correct. A more accurate and thorough review is needed.\n\n    /*\n        As per ECMAScript Language Specification 3th Edition, Section 7.6: Identifiers\n        IdentifierStart :: Can contain Unicode 3.0.0  categories Uppercase letter (Lu), Lowercase letter (Ll), Titlecase letter (Lt), Modifier letter (Lm), Other letter (Lo), or Letter number (Nl).\n        IdentifierPart :: Can contain IdentifierStart + Unicode 3.0.0  categories Non-spacing mark (Mn), Combining spacing mark (Mc), Decimal number (Nd), or Connector punctuation (Pc).\n                    \n        Codepoint ranges for ES3 Identifiers are extracted from the Unicode 3.0.0 specification at:\n        http://www.unicode.org/Public/3.0-Update/UnicodeData-3.0.0.txt\n    */\n    var unicodeES3IdStart = [\n\t\t170, 170,181, 181,186, 186,192, 214,216, 246,248, 543,546, 563,592, 685,688, 696,699, 705,720, 721,736, 740,750, 750,890, 890,902, 902,904, 906,908, 908,910, 929,931, 974,976, 983,986, 1011,1024, 1153,1164, 1220,1223, 1224,1227, 1228,1232, 1269,1272, 1273,1329, 1366,1369, 1369,1377, 1415,1488, 1514,\n\t\t1520, 1522,1569, 1594,1600, 1610,1649, 1747,1749, 1749,1765, 1766,1786, 1788,1808, 1808,1810, 1836,1920, 1957,2309, 2361,2365, 2365,2384, 2384,2392, 2401,2437, 2444,2447, 2448,2451, 2472,2474, 2480,2482, 2482,2486, 2489,2524, 2525,2527, 2529,2544, 2545,2565, 2570,2575, 2576,2579, 2600,2602, 2608,2610, 2611,\n\t\t2613, 2614,2616, 2617,2649, 2652,2654, 2654,2674, 2676,2693, 2699,2701, 2701,2703, 2705,2707, 2728,2730, 2736,2738, 2739,2741, 2745,2749, 2749,2768, 2768,2784, 2784,2821, 2828,2831, 2832,2835, 2856,2858, 2864,2866, 2867,2870, 2873,2877, 2877,2908, 2909,2911, 2913,2949, 2954,2958, 2960,2962, 2965,2969, 2970,\n\t\t2972, 2972,2974, 2975,2979, 2980,2984, 2986,2990, 2997,2999, 3001,3077, 3084,3086, 3088,3090, 3112,3114, 3123,3125, 3129,3168, 3169,3205, 3212,3214, 3216,3218, 3240,3242, 3251,3253, 3257,3294, 3294,3296, 3297,3333, 3340,3342, 3344,3346, 3368,3370, 3385,3424, 3425,3461, 3478,3482, 3505,3507, 3515,3517, 3517,\n\t\t3520, 3526,3585, 3632,3634, 3635,3648, 3654,3713, 3714,3716, 3716,3719, 3720,3722, 3722,3725, 3725,3732, 3735,3737, 3743,3745, 3747,3749, 3749,3751, 3751,3754, 3755,3757, 3760,3762, 3763,3773, 3773,3776, 3780,3782, 3782,3804, 3805,3840, 3840,3904, 3911,3913, 3946,3976, 3979,4096, 4129,4131, 4135,4137, 4138,\n\t\t4176, 4181,4256, 4293,4304, 4342,4352, 4441,4447, 4514,4520, 4601,4608, 4614,4616, 4678,4680, 4680,4682, 4685,4688, 4694,4696, 4696,4698, 4701,4704, 4742,4744, 4744,4746, 4749,4752, 4782,4784, 4784,4786, 4789,4792, 4798,4800, 4800,4802, 4805,4808, 4814,4816, 4822,4824, 4846,4848, 4878,4880, 4880,4882, 4885,\n\t\t4888, 4894,4896, 4934,4936, 4954,5024, 5108,5121, 5740,5743, 5750,5761, 5786,5792, 5866,6016, 6067,6176, 6263,6272, 6312,7680, 7835,7840, 7929,7936, 7957,7960, 7965,7968, 8005,8008, 8013,8016, 8023,8025, 8025,8027, 8027,8029, 8029,8031, 8061,8064, 8116,8118, 8124,8126, 8126,8130, 8132,8134, 8140,8144, 8147,\n\t\t8150, 8155,8160, 8172,8178, 8180,8182, 8188,8319, 8319,8450, 8450,8455, 8455,8458, 8467,8469, 8469,8473, 8477,8484, 8484,8486, 8486,8488, 8488,8490, 8493,8495, 8497,8499, 8505,8544, 8579,12293, 12295,12321, 12329,12337, 12341,12344, 12346,12353, 12436,12445, 12446,12449, 12538,12540, 12542,12549, 12588,\n\t\t12593, 12686,12704, 12727,13312, 13312,19893, 19893,19968, 19968,40869, 40869,40960, 42124,44032, 44032,55203, 55203,63744, 64045,64256, 64262,64275, 64279,64285, 64285,64287, 64296,64298, 64310,64312, 64316,64318, 64318,64320, 64321,64323, 64324,64326, 64433,64467, 64829,64848, 64911,64914, 64967,\n\t\t65008, 65019,65136, 65138,65140, 65140,65142, 65276,65313, 65338,65345, 65370,65382, 654",
v27571=v27572+"70,65474, 65479,65482, 65487,65490, 65495,65498, 65500\n\t];\n\n\tvar unicodeES3IdCont = [\n\t\t768, 846,864, 866,1155, 1158,1425, 1441,1443, 1465,1467, 1469,1471, 1471,1473, 1474,1476, 1476,1611, 1621,1632, 1641,1648, 1648,1750, 1756,1759, 1764,1767, 1768,1770, 1773,1776, 1785,1809, 1809,1840, 1866,1958, 1968,2305, 2307,2364, 2364,2366, 2381,2385, 2388,2402, 2403,2406, 2415,2433, 2435,2492, 2492,\n\t\t2494, 2500,2503, 2504,2507, 2509,2519, 2519,2530, 2531,2534, 2543,2562, 2562,2620, 2620,2622, 2626,2631, 2632,2635, 2637,2662, 2673,2689, 2691,2748, 2748,2750, 2757,2759, 2761,2763, 2765,2790, 2799,2817, 2819,2876, 2876,2878, 2883,2887, 2888,2891, 2893,2902, 2903,2918, 2927,2946, 2947,3006, 3010,3014, 3016,\n\t\t3018, 3021,3031, 3031,3047, 3055,3073, 3075,3134, 3140,3142, 3144,3146, 3149,3157, 3158,3174, 3183,3202, 3203,3262, 3268,3270, 3272,3274, 3277,3285, 3286,3302, 3311,3330, 3331,3390, 3395,3398, 3400,3402, 3405,3415, 3415,3430, 3439,3458, 3459,3530, 3530,3535, 3540,3542, 3542,3544, 3551,3570, 3571,3633, 3633,\n\t\t3636, 3642,3655, 3662,3664, 3673,3761, 3761,3764, 3769,3771, 3772,3784, 3789,3792, 3801,3864, 3865,3872, 3881,3893, 3893,3895, 3895,3897, 3897,3902, 3903,3953, 3972,3974, 3975,3984, 3991,3993, 4028,4038, 4038,4140, 4146,4150, 4153,4160, 4169,4182, 4185,4969, 4977,6068, 6099,6112, 6121,6160, 6169,6313, 6313,\n\t\t8255, 8256,8400, 8412,8417, 8417,12330, 12335,12441, 12442,12539, 12539,64286, 64286,65056, 65059,65075, 65076,65101, 65103,65296, 65305,65343, 65343,65381, 65381\n\t];\n\n\n    /*\n        As per ECMAScript Language Specification 5th Edition, Section 7.6: Identifier Names and Identifiers\n        IdentifierStart :: Can contain Unicode 6.2  categories Uppercase letter (Lu), Lowercase letter (Ll), Titlecase letter (Lt), Modifier letter (Lm), Other letter (Lo), or Letter number (Nl).\n        IdentifierPart :: Can contain IdentifierStart + Unicode 6.2  categories Non-spacing mark (Mn), Combining spacing mark (Mc), Decimal number (Nd), Connector punctuation (Pc), <ZWNJ>, or <ZWJ>.\n                    \n        Codepoint ranges for ES5 Identifiers are extracted from the Unicode 6.2 specification at:\n        http://www.unicode.org/Public/6.2.0/ucd/UnicodeData.txt\n    */\n\tvar unicodeES5IdStart = [\n\t\t170, 170,181, 181,186, 186,192, 214,216, 246,248, 705,710, 721,736, 740,748, 748,750, 750,880, 884,886, 887,890, 893,902, 902,904, 906,908, 908,910, 929,931, 1013,1015, 1153,1162, 1319,1329, 1366,1369, 1369,1377, 1415,1488, 1514,1520, 1522,1568, 1610,1646, 1647,1649, 1747,1749, 1749,1765, 1766,1774, 1775,\n\t\t1786, 1788,1791, 1791,1808, 1808,1810, 1839,1869, 1957,1969, 1969,1994, 2026,2036, 2037,2042, 2042,2048, 2069,2074, 2074,2084, 2084,2088, 2088,2112, 2136,2208, 2208,2210, 2220,2308, 2361,2365, 2365,2384, 2384,2392, 2401,2417, 2423,2425, 2431,2437, 2444,2447, 2448,2451, 2472,2474, 2480,2482, 2482,2486, 2489,\n\t\t2493, 2493,2510, 2510,2524, 2525,2527, 2529,2544, 2545,2565, 2570,2575, 2576,2579, 2600,2602, 2608,2610, 2611,2613, 2614,2616, 2617,2649, 2652,2654, 2654,2674, 2676,2693, 2701,2703, 2705,2707, 2728,2730, 2736,2738, 2739,2741, 2745,2749, 2749,2768, 2768,2784, 2785,2821, 2828,2831, 2832,2835, 2856,2858, 2864,\n\t\t2866, 2867,2869, 2873,2877, 2877,2908, 2909,2911, 2913,2929, 2929,2947, 2947,2949, 2954,2958, 2960,2962, 2965,2969, 2970,2972, 2972,2974, 2975,2979, 2980,2984, 2986,2990, 3001,3024, 3024,3077, 3084,3086, 3088,3090, 3112,3114, 3123,3125, 3129,3133, 3133,3160, 3161,3168, 3169,3205, 3212,3214, 3216,3218, 3240,\n\t\t3242, 3251,3253, 3257,3261, 3261,3294, 3294,3296, 3297,3313, 3314,3333, 3340,3342, 3344,3346, 3386,3389, 3389,3406, 3406,3424, 3425,3450, 3455,3461, 3478,3482, 3505,3507, 3515,3517, 3517,3520, 3526,3585, 3632,3634, 3635,3648, 3654,3713, 3714,3716, 3716,3719, 3720,3722, 3722,3725, 3725,3732, 3735,3737, 3743,\n\t\t3745, 3747,3749, 3749,3751, 3751,3754, 3755,3757, 3760,3762, 3763,3773, 3773,3776, 3780,3782, 3782,3804, 3807,3840, 3840,3904, 3911,3913, 3948,3976, 3980,4096, 4138,4159, 4159,4176, 4181,4186, 4189,4193, 4193,4197, 4198,4206, 4208,4213, 4225,4238, 4238,4256, 4293,4295, 4295,4301, 4301,4304, 4346,4348, 4680,\n\t\t4682, 4685,4688, 4694,4696, 4696,4698, 4701,4704, 4744,4746, 4749,4752, 4784,4786, 4789,4792, 4798,4800, 4800,4802, 4805,4808, 4822,4824, 4880,4882, 4885,4888, 4954,4992, 5007,5024, 5108,5121, 5740,5743, 5759,5761, 5786,5792, 5866,5870, 5872,5888, 5900,5902, 5905,5920, 5937,5952, 5969,5984, 5996,5998, 6000,\n\t\t6016, 6067,6103, 6103,6108, 6108,6176, 6263,6272, 6312,6314, 6314,6320, 6389,6400, 6428,6480, 6509,6512, 6516,6528, 6571,6593, 6599,6656, 6678,6688, 6740,6823, 6823,6917, 6963,6981, 6987,7043, 7072,7086, 7087,7098, 7141,7168, 7203,7245, 7247,7258, 7293,7401, 7404,7406, 7409,7413, 7414,7424, 7615,7680, 7957,\n\t\t7960, 7965,7968, 8005,8008, 8013,8016, 8023,8025, 8025,8027, 8027,8029, 8029,8031, 8061,8064, 8116,8118, 8124,8126, 8126,8130, 8132,8134, 8140,8144, 8147,8150, 8155,8160, 8172,8178, 8180,8182, 8188,8305, 8305,8319, 8319,8336, 8348,8450, 8450,8455, 8455,8458, 8467,8469, 8469,8473, 8477,84",
v27570=v27571+"84, 8484,8486, 8486,\n\t\t8488, 8488,8490, 8493,8495, 8505,8508, 8511,8517, 8521,8526, 8526,8544, 8584,11264, 11310,11312, 11358,11360, 11492,11499, 11502,11506, 11507,11520, 11557,11559, 11559,11565, 11565,11568, 11623,11631, 11631,11648, 11670,11680, 11686,11688, 11694,11696, 11702,11704, 11710,11712, 11718,11720, 11726,\n\t\t11728, 11734,11736, 11742,11823, 11823,12293, 12295,12321, 12329,12337, 12341,12344, 12348,12353, 12438,12445, 12447,12449, 12538,12540, 12543,12549, 12589,12593, 12686,12704, 12730,12784, 12799,13312, 13312,19893, 19893,19968, 19968,40908, 40908,40960, 42124,42192, 42237,42240, 42508,42512, 42527,\n\t\t42538, 42539,42560, 42606,42623, 42647,42656, 42735,42775, 42783,42786, 42888,42891, 42894,42896, 42899,42912, 42922,43000, 43009,43011, 43013,43015, 43018,43020, 43042,43072, 43123,43138, 43187,43250, 43255,43259, 43259,43274, 43301,43312, 43334,43360, 43388,43396, 43442,43471, 43471,43520, 43560,\n\t\t43584, 43586,43588, 43595,43616, 43638,43642, 43642,43648, 43695,43697, 43697,43701, 43702,43705, 43709,43712, 43712,43714, 43714,43739, 43741,43744, 43754,43762, 43764,43777, 43782,43785, 43790,43793, 43798,43808, 43814,43816, 43822,43968, 44002,44032, 44032,55203, 55203,55216, 55238,55243, 55291,\n\t\t63744, 64109,64112, 64217,64256, 64262,64275, 64279,64285, 64285,64287, 64296,64298, 64310,64312, 64316,64318, 64318,64320, 64321,64323, 64324,64326, 64433,64467, 64829,64848, 64911,64914, 64967,65008, 65019,65136, 65140,65142, 65276,65313, 65338,65345, 65370,65382, 65470,65474, 65479,65482, 65487,\n\t\t65490, 65495,65498, 65500\n\t];\n\n\tvar unicodeES5IdCont = [\n\t\t768, 879,1155, 1159,1425, 1469,1471, 1471,1473, 1474,1476, 1477,1479, 1479,1552, 1562,1611, 1641,1648, 1648,1750, 1756,1759, 1764,1767, 1768,1770, 1773,1776, 1785,1809, 1809,1840, 1866,1958, 1968,1984, 1993,2027, 2035,2070, 2073,2075, 2083,2085, 2087,2089, 2093,2137, 2139,2276, 2302,2304, 2307,2362, 2364,\n\t\t2366, 2383,2385, 2391,2402, 2403,2406, 2415,2433, 2435,2492, 2492,2494, 2500,2503, 2504,2507, 2509,2519, 2519,2530, 2531,2534, 2543,2561, 2563,2620, 2620,2622, 2626,2631, 2632,2635, 2637,2641, 2641,2662, 2673,2677, 2677,2689, 2691,2748, 2748,2750, 2757,2759, 2761,2763, 2765,2786, 2787,2790, 2799,2817, 2819,\n\t\t2876, 2876,2878, 2884,2887, 2888,2891, 2893,2902, 2903,2914, 2915,2918, 2927,2946, 2946,3006, 3010,3014, 3016,3018, 3021,3031, 3031,3046, 3055,3073, 3075,3134, 3140,3142, 3144,3146, 3149,3157, 3158,3170, 3171,3174, 3183,3202, 3203,3260, 3260,3262, 3268,3270, 3272,3274, 3277,3285, 3286,3298, 3299,3302, 3311,\n\t\t3330, 3331,3390, 3396,3398, 3400,3402, 3405,3415, 3415,3426, 3427,3430, 3439,3458, 3459,3530, 3530,3535, 3540,3542, 3542,3544, 3551,3570, 3571,3633, 3633,3636, 3642,3655, 3662,3664, 3673,3761, 3761,3764, 3769,3771, 3772,3784, 3789,3792, 3801,3864, 3865,3872, 3881,3893, 3893,3895, 3895,3897, 3897,3902, 3903,\n\t\t3953, 3972,3974, 3975,3981, 3991,3993, 4028,4038, 4038,4139, 4158,4160, 4169,4182, 4185,4190, 4192,4194, 4196,4199, 4205,4209, 4212,4226, 4237,4239, 4253,4957, 4959,5906, 5908,5938, 5940,5970, 5971,6002, 6003,6068, 6099,6109, 6109,6112, 6121,6155, 6157,6160, 6169,6313, 6313,6432, 6443,6448, 6459,6470, 6479,\n\t\t6576, 6592,6600, 6601,6608, 6617,6679, 6683,6741, 6750,6752, 6780,6783, 6793,6800, 6809,6912, 6916,6964, 6980,6992, 7001,7019, 7027,7040, 7042,7073, 7085,7088, 7097,7142, 7155,7204, 7223,7232, 7241,7248, 7257,7376, 7378,7380, 7400,7405, 7405,7410, 7412,7616, 7654,7676, 7679,8204, 8205,8255, 8256,8276, 8276,\n\t\t8400, 8412,8417, 8417,8421, 8432,11503, 11505,11647, 11647,11744, 11775,12330, 12335,12441, 12442,42528, 42537,42607, 42607,42612, 42621,42655, 42655,42736, 42737,43010, 43010,43014, 43014,43019, 43019,43043, 43047,43136, 43137,43188, 43204,43216, 43225,43232, 43249,43264, 43273,43302, 43309,43335, 43347,\n\t\t43392, 43395,43443, 43456,43472, 43481,43561, 43574,43587, 43587,43596, 43597,43600, 43609,43643, 43643,43696, 43696,43698, 43700,43703, 43704,43710, 43711,43713, 43713,43755, 43759,43765, 43766,44003, 44010,44012, 44013,44016, 44025,64286, 64286,65024, 65039,65056, 65062,65075, 65076,65101, 65103,\n\t\t65296, 65305,65343, 65343\n\t];\n\n    export function LexLookUpUnicodeMap(code: number, map: number[]) : bool {\n        // Perform binary search in one of the unicode range maps\n        var lo: number = 0;\n        var hi: number = map.length;\n        var mid: number;\n\n        while (lo + 1 < hi)\n        {\n            mid = lo + (hi - lo) / 2;\n            // mid has to be even to catch a range's beginning\n            mid -= mid % 2;\n            if (map[mid] <= code && code <= map[mid + 1])\n                return true;\n            if (code < map[mid])\n                hi = mid;\n            else\n                lo = mid + 2;\n        }\n        return false;\n    }\n\n    export function LexIsUnicodeDigit(code: number): bool {\n        if (codeGenTarget == CodeGenTarget.ES3) {\n            return LexLookUpUnicodeMap(code, unicodeES3IdCont);\n        } else {\n            return LexLookUpUnicodeMap(code, unicodeES5IdCont);\n        }\n    ",
v27569=v27570+"}\n\n    export function LexIsUnicodeIdStart(code: number): bool {\n        if (codeGenTarget == CodeGenTarget.ES3) {\n            return LexLookUpUnicodeMap(code, unicodeES3IdStart);\n        } else {\n            return LexLookUpUnicodeMap(code, unicodeES5IdStart);\n        }\n    }\n    export function LexInitialize() {\n        initializeStaticTokens();\n        autoToken[LexCodeLPR] = staticTokens[TokenID.OpenParen];\n        autoToken[LexCodeRPR] = staticTokens[TokenID.CloseParen];\n        autoToken[LexCodeCMA] = staticTokens[TokenID.Comma];\n        autoToken[LexCodeSMC] = staticTokens[TokenID.Semicolon];\n        autoToken[LexCodeLBR] = staticTokens[TokenID.OpenBracket];\n        autoToken[LexCodeRBR] = staticTokens[TokenID.CloseBracket];\n        autoToken[LexCodeTIL] = staticTokens[TokenID.Tilde];\n        autoToken[LexCodeQUE] = staticTokens[TokenID.Question];\n        autoToken[LexCodeLC] = staticTokens[TokenID.OpenBrace];\n        autoToken[LexCodeRC] = staticTokens[TokenID.CloseBrace];\n        autoToken[LexCodeCOL] = staticTokens[TokenID.Colon];\n        LexKeywordTable = new StringHashTable();\n        for (var i in (<any>TokenID)._map) {\n            if ((<number><any>i) <= TokenID.LimKeyword) {\n                LexKeywordTable.add((<any>TokenID)._map[i].toLowerCase(), i);\n            }\n        }\n        for (var j = 0; j < LexCodeASCIIChars; j++) {\n            if (LexIsIdentifierStartChar(j)) {\n                lexIdStartTable[j] = true;\n            }\n            else {\n                lexIdStartTable[j] = false;\n            }\n        }\n    }\n\n    export function LexAdjustIndent(code, indentAmt) {\n        if ((code == LexCodeLBR) || (code == LexCodeLC) || (code == LexCodeLPR)) {\n            return indentAmt + 1;\n        }\n        else if ((code == LexCodeRBR) || (code == LexCodeRC) || (code == LexCodeRPR)) {\n            return indentAmt - 1;\n        }\n        else return indentAmt;\n    }\n\n    export function LexIsIdentifierStartChar(code): bool {\n        return (((code >= 97) && (code <= 122)) ||\n                ((code >= 65) && (code <= 90)) ||\n                (code == LexCodeDollar) ||\n                (code == LexCodeUnderscore));\n    }\n\n    export function LexIsDigit(code): bool {\n        return ((code >= 48) && (code <= 57));\n    }\n\n    export function LexIsIdentifierChar(code:number) {\n        return lexIdStartTable[code] || LexIsDigit(code);\n    }\n\n    export function LexMatchingOpen(code) {\n        if (code == LexCodeRBR)\n            return LexCodeLBR;\n        else if (code == LexCodeRC)\n            return LexCodeLC;\n        else if (code == LexCodeRPR)\n            return LexCodeLPR;\n        else return 0;\n    }\n\n    export enum NumberScanState {\n        Start,\n        InFraction,\n        InEmptyFraction,\n        InExponent\n    }\n\n    export enum LexState {\n        Start,\n        InMultilineComment,\n        InMultilineSingleQuoteString,\n        InMultilineDoubleQuoteString,\n    }\n\n    export enum LexMode {\n        Line,\n        File,\n    }\n\n    export enum CommentStyle {\n        Line,\n        Block\n    }\n\n    // Represent a piece of source code which can be read in multiple segments\n    export interface ISourceText {\n        getText(start: number, end: number): string;\n        getLength(): number;\n    }\n\n    // Implementation on top of a contiguous string\n    export class StringSourceText implements ISourceText {\n        constructor (public text: string) {\n        }\n\n        public getText(start: number, end: number): string {\n            return this.text.substring(start, end);\n        }\n\n        public getLength(): number {\n            return this.text.length;\n        }\n    }\n\n    export class SourceTextSegment implements ISourceTextSegment {\n        constructor (public segmentStart: number,\n                    public segmentEnd: number,\n                    public segment: string) {\n        }\n\n        charCodeAt(index: number): number {\n            return this.segment.charCodeAt(index - this.segmentStart);\n        }\n\n        substring(start: number, end: number): string {\n            return this.segment.substring(start - this.segmentStart, end - this.segmentStart);\n        }\n    }\n\n    export class AggerateSourceTextSegment implements ISourceTextSegment {\n\n        constructor (public seg1: SourceTextSegment, public seg2: SourceTextSegment) { }\n\n        public charCodeAt(index: number): number {\n            if (this.seg1.segmentStart <= index && index < this.seg1.segmentEnd)\n                return this.seg1.segment.charCodeAt(index - this.seg1.segmentStart);\n\n            return this.seg2.segment.charCodeAt(index - this.seg2.segmentStart);\n        }\n\n        public substring(start: number, end: number): string {\n            if (this.seg1.segmentStart <= start && end <= this.seg1.segmentEnd)\n                return this.seg1.segment.substring(start - this.seg1.segmentStart, end - this.seg1.segmentStart);\n\n            return this.seg2.segment.substring(start - this.seg2.segmentStart) + this.seg1.segment.substri",
v27568=v27569+'ng(0, end - this.seg1.segmentStart);\n        }\n    }\n\n    export interface ISourceTextSegment {\n        charCodeAt(index: number): number;\n        substring(start: number, end: number): string;\n    }\n\n    export class ScannerTextStream {\n        static emptySegment = new SourceTextSegment(0, 0, "");\n        public agg: AggerateSourceTextSegment;\n        public len: number;\n\n        constructor (public sourceText: ISourceText) {\n            this.agg = new AggerateSourceTextSegment(ScannerTextStream.emptySegment, ScannerTextStream.emptySegment);\n            this.len = this.sourceText.getLength();\n        }\n\n        public max(a: number, b: number): number {\n            return a >= b ? a : b;\n        }\n\n        public min(a: number, b: number): number {\n            return a <= b ? a : b;\n        }\n\n        public fetchSegment(start: number, end: number): ISourceTextSegment {\n            // Common case\n            if (this.agg.seg1.segmentStart <= start && end <= this.agg.seg1.segmentEnd)\n                return this.agg.seg1;\n\n            // Common overlap case\n            if (this.agg.seg2.segmentStart <= start && end <= this.agg.seg1.segmentEnd)\n                return this.agg;\n\n            // if overlapping outside of fetched segment(s), fetch a new segment\n            var prev = this.agg.seg1;\n\n            var s = prev.segmentEnd;\n            var e = max(s + 512, end); // ensure we move forward at least 512 characters or "end"\n            e = min(e, this.len);    // but don\'t go past the end of the source text\n\n            var src = this.sourceText.getText(s, e);\n            var newSeg = new SourceTextSegment(s, e, src);\n            this.agg.seg2 = prev;\n            this.agg.seg1 = newSeg;\n            return this.agg;\n        }\n\n        public charCodeAt(index: number): number {\n            return this.fetchSegment(index, index + 1).charCodeAt(index);\n        }\n\n        public substring(start: number, end: number) {\n            return this.fetchSegment(start, end).substring(start, end);\n        }\n    }\n\n    export interface IScanner {\n        startPos: number;\n        pos: number;\n        scan(): Token;\n        previousToken(): Token;\n        prevLine: number;\n        line: number;\n        col: number;\n        leftCurlyCount: number;\n        rightCurlyCount: number;\n        lastTokenLimChar(): number;\n        lastTokenHadNewline(): bool;\n        lexState: number;\n        getComments(): CommentToken[];\n        getCommentsForLine(line: number): CommentToken[];\n        resetComments(): void;\n        lineMap: number[];\n        setSourceText(newSrc: ISourceText, textMode: number): void;\n        setErrorHandler(reportError: (message: string) => void): void;\n        seenUnicodeChar: bool;\n        seenUnicodeCharInComment: bool;\n        getLookAheadToken(): Token;\n    }\n\n    export class SavedTokens implements IScanner {\n        public prevToken: Token = null;\n        public curSavedToken: SavedToken = null;\n        public prevSavedToken: SavedToken = null;\n        public currentTokenIndex: number;\n        public currentTokens: SavedToken[];\n        public tokensByLine: SavedToken[][];\n        public lexStateByLine: LexState[];\n        private prevToken: SavedToken = null;\n        public previousToken(): Token { return this.prevToken; }\n        public currentToken = 0;\n        public tokens = new SavedToken[];\n        public startPos: number;\n        public pos: number;\n        public seenUnicodeChar: bool = false;\n        seenUnicodeCharInComment: bool = false;\n\n        public close() {\n            this.currentToken = 0;\n        }\n\n        public addToken(tok: Token, scanner: IScanner) {\n            this.tokens[this.currentToken++] = new SavedToken(tok, scanner.startPos, scanner.pos);\n        }\n\n        public scan(): Token {\n            // TODO: curly count\n            this.startLine = this.line;\n            this.startPos = this.col;\n            if (this.currentTokenIndex == this.currentTokens.length) {\n                if (this.line < this.lineMap.length) {\n                    this.line++;\n                    this.col = 0;\n                    this.currentTokenIndex = 0;\n                    this.currentTokens = this.tokensByLine[this.line];\n                }\n                else {\n                    return staticTokens[TokenID.EndOfFile];\n                }\n            }\n            if (this.currentTokenIndex < this.currentTokens.length) {\n                this.prevToken = this.curSavedToken.tok;\n                this.prevSavedToken = this.curSavedToken;\n                this.curSavedToken = this.currentTokens[this.currentTokenIndex++];\n                var curToken = this.curSavedToken.tok;\n                this.pos = this.curSavedToken.limChar;\n                this.col += (this.curSavedToken.limChar - this.curSavedToken.minChar);\n                this.startPos = this.curSavedToken.minChar;\n                this.prevLine = this.line;\n                return curToken;\n            }\n            else {\n                retur',
v27567=v27568+'n staticTokens[TokenID.EndOfFile];\n            }\n        }\n        public startLine: number;\n        public prevLine = 1;\n        public line = 1;\n        public col = 0;\n        public leftCurlyCount: number;\n        public rightCurlyCount: number;\n\n        public syncToTok(offset: number): number {\n            this.line = getLineNumberFromPosition(this.lineMap, offset);\n            this.currentTokenIndex = 0;\n            var tmpCol = offset - this.lineMap[this.line];\n            while ((this.lexStateByLine[this.line] == LexState.InMultilineComment) && (this.line > 0)) {\n                this.line--;\n                tmpCol = 0;\n            }\n            var lenMin1 = this.lineMap.length - 1;\n            this.currentTokens = this.tokensByLine[this.line];\n            while ((this.currentTokens.length == 0) && (this.line < lenMin1)) {\n                this.line++;\n                this.currentTokens = this.tokensByLine[this.line];\n                tmpCol = 0;\n            }\n            if (this.line <= lenMin1) {\n                while ((this.currentTokenIndex < this.currentTokens.length) &&\n                       (tmpCol > this.currentTokens[this.currentTokenIndex].limChar)) {\n                    this.currentTokenIndex++;\n                }\n                if (this.currentTokenIndex < this.currentTokens.length) {\n                    this.col = this.currentTokens[this.currentTokenIndex].minChar;\n                    return this.col + this.lineMap[this.line];\n                }\n            }\n            return -1;\n        }\n\n        public lastTokenLimChar(): number {\n            if (this.prevSavedToken !== null) {\n                return this.prevSavedToken.limChar;\n            }\n            else {\n                return 0;\n            }\n        }\n\n        public lastTokenHadNewline(): bool {\n            return this.prevLine != this.startLine;\n        }\n\n        public lexState = LexState.Start;\n\n        public commentStack: CommentToken[] = new CommentToken[];\n\n        public pushComment(comment: CommentToken) {\n            this.commentStack.push(comment);\n        }\n\n        public getComments() {\n            var stack = this.commentStack;\n            this.commentStack = [];\n            return stack;\n        }\n\n        public getCommentsForLine(line: number) {\n            var comments: CommentToken[] = null;\n            while ((this.commentStack.length > 0) && (this.commentStack[0].line == line)) {\n                if (comments == null) {\n                    comments = [this.commentStack.shift()];\n                }\n                else {\n                    comments = comments.concat([this.commentStack.shift()]);\n                }\n\n            }\n            return comments;\n        }\n\n        public resetComments() {\n            this.commentStack = [];\n        }\n\n        public lineMap: number[] = [];\n        public setSourceText(newSrc: ISourceText, textMode: number) {\n        }\n        public setErrorHandler(reportError: (message: string) => void ) { \n        }\n        public getLookAheadToken(): Token {\n            throw new Error("Invalid operation.");\n        }\n    }\n\n    export class Scanner implements IScanner {\n        // REVIEW: When adding new variables make sure to handle storing them in getLookAheadToken. \n        //         The method works by storing the state before scanning and restoring it later on, missing a member variable \n        //         could result in an inconsistent state.\n        public prevLine = 1;\n        public line = 1;\n        public col = 0;\n        public pos = 0;\n        public startPos = 0;\n        public startCol: number;\n        public startLine: number;\n        public src: string;\n        public len = 0;\n        public lineMap: number[] = [];\n        \n        public ch = LexEOF;\n        public lexState = LexState.Start;\n        public mode = LexMode.File;\n        public scanComments: bool = true;\n        public interveningWhitespace = false; // Was there a whitespace token between the last token and the current one?\n        private interveningWhitespacePos = 0; //  If yes, this contains the start position of the whitespace\n        public leftCurlyCount = 0;\n        public rightCurlyCount = 0;\n        public commentStack: CommentToken[] = new CommentToken[];\n        public saveScan: SavedTokens = null;\n        public seenUnicodeChar: bool = false;\n        seenUnicodeCharInComment: bool = false;\n\n        private reportError: (message: string) =>void;\n\n        constructor () {\n            this.startCol = this.col;\n            this.startLine = this.line;            \n            this.lineMap[1] = 0;\n            \n            if (!LexKeywordTable) {\n                LexInitialize();\n            }            \n        }\n\n        private prevTok = staticTokens[TokenID.EndOfFile];\n        public previousToken() { return this.prevTok; }\n\n        public setSourceText(newSrc: ISourceText, textMode: number) {\n            this.mode = textMode;\n            this.scanComments = (this.mode === LexMo',
v27566=v27567+"de.Line);\n            this.pos = 0;\n            this.interveningWhitespacePos = 0;\n            this.startPos = 0;\n            this.line = 1;\n            this.col = 0;\n            this.startCol = this.col;\n            this.startLine = this.line;\n            this.len = 0;\n            this.src = newSrc.getText(0, newSrc.getLength());\n            this.len = this.src.length;\n            this.lineMap = [];\n            this.lineMap[1] = 0;\n            this.commentStack = [];\n            this.leftCurlyCount = 0;\n            this.rightCurlyCount = 0;\n            this.seenUnicodeChar = false;\n            this.seenUnicodeCharInComment = false;\n        }\n\n        public setErrorHandler(reportError: (message: string) => void ) { \n            this.reportError = reportError;\n        }\n\n        public setSaveScan(savedTokens: SavedTokens) {\n            this.saveScan = savedTokens;\n        }\n\n        public setText(newSrc: string, textMode: number) {\n            this.setSourceText(new StringSourceText(newSrc), textMode);\n        }\n\n        public setScanComments(value: bool) {\n            this.scanComments = value;\n        }\n\n        public getLexState(): number {\n            return this.lexState;\n        }\n\n        public tokenStart() {\n            this.startPos = this.pos;\n            this.startLine = this.line;\n            this.startCol = this.col;\n            this.interveningWhitespace = false;\n        }\n\n        public peekChar(): number {\n            if (this.pos < this.len) {\n                return this.src.charCodeAt(this.pos);\n            }\n            else {\n                return LexEOF;\n            }\n        }\n\n        public peekCharAt(index: number): number {\n            if (index < this.len) {\n                return this.src.charCodeAt(index);\n            }\n            else {\n                return LexEOF;\n            }\n        }\n\n        public IsHexDigit(c: number) {\n            return ((c >= LexCode_0) && (c <= LexCode_9)) || ((c >= LexCode_A) && (c <= LexCode_F)) ||\n                ((c >= LexCode_a) && (c <= LexCode_f));\n        }\n\n        public IsOctalDigit(c: number) {\n            return ((c >= LexCode_0) && (c <= LexCode_7)) ||\n                ((c >= LexCode_a) && (c <= LexCode_f));\n        }\n\n        public scanHexDigits(): Token {\n            var atLeastOneDigit = false;\n            for (; ;) {\n                if (this.IsHexDigit(this.ch)) {\n                    this.nextChar();\n                    atLeastOneDigit = true;\n                }\n                else {\n                    if (atLeastOneDigit) {\n                        return new NumberLiteralToken(parseInt(this.src.substring(this.startPos, this.pos)));\n                    }\n                    else {\n                        return null;\n                    }\n                }\n            }\n\n        }\n\n        public scanOctalDigits(): Token {\n            var atLeastOneDigit = false;\n            for (; ;) {\n                if (this.IsOctalDigit(this.ch)) {\n                    this.nextChar();\n                    atLeastOneDigit = true;\n                }\n                else {\n                    if (atLeastOneDigit) {\n                        return new NumberLiteralToken(parseInt(this.src.substring(this.startPos, this.pos)));\n                    }\n                    else {\n                        return null;\n                    }\n                }\n            }\n\n        }\n\n        public scanDecimalNumber(state: number): Token {\n            var atLeastOneDigit = false;\n            var svPos = this.pos;\n            var svCol = this.col;\n            for (; ;) {\n                if (LexIsDigit(this.ch)) {\n                    atLeastOneDigit = true;\n                    if (this.ch != LexCode_0 && state == NumberScanState.InEmptyFraction) {\n                        state = NumberScanState.InFraction;\n                    }\n                    this.nextChar();\n                }\n                else if (this.ch == LexCodeDOT) {\n                    if (state == NumberScanState.Start) {\n                        // DecimalDigit* .\n                        this.nextChar();\n                        state = NumberScanState.InEmptyFraction;\n                    }\n                    else {\n                        // dot not part of number\n                        if (atLeastOneDigit) {\n                            // DecimalDigit* . DecimalDigit+\n                            return new NumberLiteralToken(parseFloat(this.src.substring(this.startPos, this.pos)), state == NumberScanState.InEmptyFraction);\n                        }\n                        else {\n                            this.pos = svPos;\n                            this.col = svCol;\n                            return null;\n                        }\n                    }\n                } else if ((this.ch == LexCode_e) || (this.ch == LexCode_E)) {\n                    if (state == NumberScanState.Start) {\n                        if (atLeastOneDigit) {\n                            // DecimalDigit+ (.",
v27565=v27566+" DecimalDigit*) [eE] [+-]DecimalDigit+\n                            atLeastOneDigit = false;\n                            this.nextChar();\n                            state = NumberScanState.InExponent;\n                        }\n                        else {\n                            this.pos = svPos;\n                            this.col = svCol;\n                            return null;\n                        }\n                    }\n                    else if (state == NumberScanState.InFraction || state == NumberScanState.InEmptyFraction) {\n                        // DecimalDigit+ . DecimalDigit* [eE]\n                        this.nextChar();\n                        state = NumberScanState.InExponent;\n                        atLeastOneDigit = false;\n                    }\n                    else {\n                        // DecimalDigit+ . DecimalDigit* [eE] DecimalDigit+\n                        if (atLeastOneDigit) {\n                            return new NumberLiteralToken(parseFloat(this.src.substring(this.startPos, this.pos)));\n                        }\n                        else {\n                            this.pos = svPos;\n                            this.col = svCol;\n                            return null;\n                        }\n                    }\n                }\n                else if ((this.ch == LexCodePLS) || (this.ch == LexCodeMIN)) {\n                    if (state == NumberScanState.InExponent) {\n                        if (!atLeastOneDigit) {\n                            this.nextChar();\n                        }\n                        else {\n                            this.pos = svPos;\n                            this.col = svCol;\n                            return null;\n                        }\n                    }\n                    else if (state == NumberScanState.InEmptyFraction || state == NumberScanState.InFraction) {\n                        // This case will not generate bad javascript if we miss the fractional part, but we just want to be consistent with the dot case\n                        return new NumberLiteralToken(parseFloat(this.src.substring(this.startPos, this.pos)), state == NumberScanState.InEmptyFraction);\n                    }\n                    else {\n                        if (!atLeastOneDigit) {\n                            this.pos = svPos;\n                            this.col = svCol;\n                            return null;\n                        }\n                        else {\n                            return new NumberLiteralToken(parseFloat(this.src.substring(this.startPos, this.pos)));\n                        }\n                    }\n                }\n                else {\n                    if (!atLeastOneDigit) {\n                        this.pos = svPos;\n                        this.col = svCol;\n                        return null;\n                    }\n                    else {\n                        return new NumberLiteralToken(parseFloat(this.src.substring(this.startPos, this.pos)), state == NumberScanState.InEmptyFraction);\n                    }\n                }\n            }\n        }\n\n        // 0 [xX] hexDigits\n        // 0 octalDigits\n        // 0 [89] decimalDigits\n        // decimalDigits? fraction? exponent?\n\n        public scanNumber(): Token {\n            if (this.peekChar() == LexCode_0) {\n                switch (this.peekCharAt(this.pos + 1)) {\n                    case LexCode_x:\n                    case LexCode_X:\n                        // Hex\n                        this.advanceChar(2);\n                        return this.scanHexDigits();\n                    case LexCode_8:\n                    case LexCode_9:\n                    case LexCodeDOT:\n                        return this.scanDecimalNumber(NumberScanState.Start);\n                    default:\n                        // Octal\n                        return this.scanOctalDigits();\n                }\n            }\n            else {\n                return this.scanDecimalNumber(NumberScanState.Start);\n            }\n        }\n\n        public scanFraction(): Token {\n            return this.scanDecimalNumber(NumberScanState.InFraction);\n        }\n\n        public newLine() {\n            this.col = 0;\n            if (this.mode == LexMode.File) {\n                this.line++;\n                this.lineMap[this.line] = this.pos + 1;\n            }\n        }\n\n        public finishMultilineComment(): bool {\n            var ch2: number;\n            this.lexState = LexState.InMultilineComment;\n            while (this.pos < this.len) {\n                if (this.ch == LexCodeMUL) {\n                    ch2 = this.peekCharAt(this.pos + 1);\n                    if (ch2 == LexCodeSLH) {\n                        this.advanceChar(2);\n                        if (this.mode == LexMode.File) {\n                            this.tokenStart();\n                        }\n                        this.lexState = LexState.Start;\n                        return true;\n                    }\n        ",
v27564=v27565+"        }\n                else if (this.ch == LexCodeNWL) {\n                    this.newLine();\n                    if (this.mode == LexMode.Line) {\n                        this.nextChar();\n                        return false;\n                    }\n                } \n                else if (this.ch >= LexCodeASCIIChars) { \n                    this.seenUnicodeCharInComment = true;\n                }\n                this.nextChar();\n            }\n            return false;\n        }\n\n        public pushComment(comment: CommentToken) {\n            this.commentStack.push(comment);\n        }\n\n        public getComments() {\n            var stack = this.commentStack;\n            this.commentStack = [];\n            return stack;\n        }\n\n        public getCommentsForLine(line: number) {\n            var comments: CommentToken[] = null;\n            while ((this.commentStack.length > 0) && (this.commentStack[0].line == line)) {\n                if (comments == null) {\n                    comments = [this.commentStack.shift()];\n                }\n                else {\n                    comments = comments.concat([this.commentStack.shift()]);\n                }\n\n            }\n            return comments;\n        }\n\n        public resetComments() {\n            this.commentStack = [];\n        }\n\n        public endsLine(c: number) {\n            return (c == LexCodeNWL) || (c == LexCodeRET) || (c == LexCodeLS) || (c == LexCodePS);\n        }\n\n        public finishSinglelineComment() {\n            while (this.pos < this.len) {\n                if (this.endsLine(this.ch))\n                    break;\n                if (this.ch >= LexCodeASCIIChars) { \n                    this.seenUnicodeCharInComment = true;\n                }\n                this.nextChar();\n            }\n\n            if (this.mode == LexMode.File) {\n                this.tokenStart();\n            }\n        }\n\n        public tokenText(): string {\n            return this.src.substring(this.startPos, this.pos);\n        }\n\n        public findClosingSLH() {\n            var index = this.pos;\n            var ch2 = this.src.charCodeAt(index);\n            var prevCh = 0;\n            var liveEsc = false;\n            while (!this.endsLine(ch2) && (index < this.len)) {\n                if ((ch2 == LexCodeSLH) && (!liveEsc)) {\n                    return index;\n                }\n                prevCh = ch2;\n                index++;\n                if (liveEsc) {\n                    liveEsc = false;\n                }\n                else {\n                    liveEsc = (prevCh == LexCodeBSL);\n                }\n\n                ch2 = this.src.charCodeAt(index);\n            }\n            return -1;\n        }\n\n        public speculateRegex(): Token {\n            if (noRegexTable[this.prevTok.tokenId] != undefined) {\n                return null;\n            }\n            var svPos = this.pos;\n            var svCol = this.col;\n            // first char is '/' and has been skipped\n            var index = this.findClosingSLH();\n            if (index > 0) {\n                // found closing /\n                var pattern = this.src.substring(svPos, index);\n                var flags = \"\";\n                this.pos = index + 1;\n                this.ch = this.peekChar();\n                var flagsStart = this.pos;\n                // TODO: check for duplicate flags\n                while ((this.ch == LexCode_i) || (this.ch == LexCode_g) || (this.ch == LexCode_m)) {\n                    this.nextChar();\n                }\n                if ((this.pos - flagsStart) > 3) {\n                    return null;\n                }\n                else {\n                    flags = this.src.substring(flagsStart, this.pos);\n                }\n                var regex = undefined;\n                try {\n                    regex = new RegExp(pattern, flags);\n                }\n                catch (regexException) {\n                }\n                if (regex) {\n                    // no line boundary in regex string\n                    this.col = svCol + (this.pos - this.startPos);\n                    return new RegularExpressionLiteralToken(regex);\n                }\n            }\n            this.pos = svPos;\n            this.col = svCol;\n            return null;\n        }\n\n        public lastTokenHadNewline() {\n            return this.prevLine != this.startLine;\n        }\n\n        public lastTokenLimChar() {\n            return this.interveningWhitespace ? this.interveningWhitespacePos : this.startPos;\n        }\n\n        // use only when known not to skip line terminators\n        public advanceChar(amt: number) {\n            this.pos += amt;\n            this.col += amt;\n            this.ch = this.peekChar();\n        }\n\n        public nextChar() {\n            this.pos++;\n            this.col++;\n            this.ch = this.peekChar();\n        }\n\n        public getLookAheadToken(): Token {\n            // REVIEW: This method is only used for parsing varargs in lambda expressions. If this functionality is neede",
v27563=v27564+'d for more common cases, \n            //         it needs to be designed. \n            //         Look-ahead token needs to be integrated in the scanner design to allow for an efficient lookup.\n\n            // Store the scanner state\n            var prevLine = this.prevLine;\n            var line = this.line;\n            var col = this.col;\n            var pos = this.pos;\n            var startPos = this.startPos;\n            var startCol = this.startCol;\n            var startLine = this.startLine;\n            var ch = this.ch;\n            var prevTok = this.prevTok;\n            var lexState = this.lexState;\n            var interveningWhitespace = this.interveningWhitespace;\n            var interveningWhitespacePos = this.interveningWhitespacePos;\n            var leftCurlyCount = this.leftCurlyCount;\n            var rightCurlyCount = this.rightCurlyCount;\n            var seenUnicodeChar = this.seenUnicodeChar;\n            var seenUnicodeCharInComment = this.seenUnicodeCharInComment;\n            var commentStackLength = this.commentStack.length;\n\n            var lookAheadToken = this.scan();\n\n            // Restore state\n            this.prevLine = prevLine;\n            this.line = line;\n            this.col = col;\n            this.pos = pos;\n            this.startPos = startPos;\n            this.startCol = startCol;\n            this.startLine = startLine;\n            this.ch = ch;\n            this.prevTok = prevTok;\n            this.lexState = lexState;\n            this.interveningWhitespace = interveningWhitespace;\n            this.interveningWhitespacePos = interveningWhitespacePos;\n            this.leftCurlyCount = leftCurlyCount;\n            this.rightCurlyCount = rightCurlyCount;\n            this.seenUnicodeChar = seenUnicodeChar;\n            this.seenUnicodeCharInComment = seenUnicodeCharInComment;\n            this.commentStack.length = commentStackLength;\n\n            return lookAheadToken;\n        }\n\n        public scanInLine(): Token {\n            if ((this.lexState == LexState.InMultilineComment) && (this.scanComments)) {\n                this.ch = this.peekChar();\n                var commentLine = this.line;\n                this.finishMultilineComment();\n                if (this.startPos < this.pos) {\n                    var commentText = this.src.substring(this.startPos, this.pos);\n                    this.tokenStart();\n                    return new CommentToken(TokenID.Comment, commentText,/*isBlock*/true, this.startPos, commentLine,/*endsLine*/true);\n                }\n                else {\n                    return staticTokens[TokenID.EndOfFile];\n                }\n            } \n            else if (this.lexState == LexState.InMultilineSingleQuoteString && this.pos < this.len) { \n                this.ch = LexCodeAPO;\n                this.lexState = LexState.Start;\n                return this.scanStringConstant();\n            }\n            else if (this.lexState == LexState.InMultilineDoubleQuoteString && this.pos < this.len) { \n                this.ch = LexCodeQUO;\n                this.lexState = LexState.Start;\n                return this.scanStringConstant();\n            }\n            this.prevLine = this.line;\n            var prevTok = this.innerScan();\n\n            // Ingore white spaces\n            if (prevTok.tokenId != TokenID.Whitespace) {\n                this.prevTok = prevTok;\n            }\n            return prevTok;\n        }\n\n        public scan(): Token {\n            this.prevLine = this.line;\n            this.prevTok = this.innerScan();\n            if (this.saveScan) {\n                this.saveScan.addToken(this.prevTok, this);\n            }\n            return this.prevTok;\n        }\n\n        private isValidUnicodeIdentifierChar(): bool {\n            var valid = LexIsUnicodeIdStart(this.ch) || LexIsUnicodeDigit(this.ch);\n            this.seenUnicodeChar = this.seenUnicodeChar || valid;\n            return valid;\n        }\n\n        private scanStringConstant(): Token {\n            var endCode = this.ch;\n            \n            // Skip the first quote\n            this.nextChar();\n            \n            // Accumulate with escape characters\n            scanStringConstantLoop:\n            for (;;) {\n                switch (this.ch) {\n                    case LexEOF:\n                        // Unexpected end of file\n                        this.reportScannerError("Unterminated string constant");\n                        break scanStringConstantLoop;\n\n                    case LexCodeLS:\n                    case LexCodePS:\n                        this.seenUnicodeChar = true;\n                    // Intentional fall through\n                    case LexCodeRET:\n                    case LexCodeNWL:\n                        this.reportScannerError("Unterminated string constant");\n                        break scanStringConstantLoop;\n\n                    case LexCodeAPO:\n                    case LexCodeQUO:\n                        if (this.ch == endCode) {\n                            // Foun',
v27562=v27563+'d string terminator. Skip past end code.\n                            this.nextChar();\n                            break scanStringConstantLoop;\n                        }\n                        break;\n\n                    case LexCodeBSL:\n                        // Consume the current slash\n                        this.nextChar();\n\n                        switch (this.ch) {\n                            case LexCodeAPO:\n                            case LexCodeQUO:\n                            case LexCodeBSL:\n                                // Valid escape sequences\n                                this.nextChar();\n                                continue scanStringConstantLoop;\n\n                            case LexCodeLS:\n                            case LexCodePS:\n                                this.seenUnicodeChar = true;\n                            // Intentional fall through\n                            case LexCodeRET:\n                            case LexCodeNWL:\n                                // Skip /r in a /r/n sequence\n                                if (this.ch == LexCodeRET && this.peekCharAt(this.pos + 1) == LexCodeNWL) {\n                                    this.nextChar();\n                                }\n\n                                // Consume the new line char\n                                this.nextChar();\n\n                                // Record new line\n                                this.newLine();\n\n                                if (this.mode == LexMode.Line) {\n                                    this.lexState = endCode == LexCodeAPO ? LexState.InMultilineSingleQuoteString : LexState.InMultilineDoubleQuoteString;\n                                    break scanStringConstantLoop;\n                                }\n                                break;\n\n                            case LexCode_x:\n                            case LexCode_u:\n                                var expectedHexDigits = this.ch == LexCode_x ? 2 : 4;\n                                this.nextChar();\n                                for (var i = 0; i < expectedHexDigits; i++) {\n                                    if (this.IsHexDigit(this.ch)) {\n                                        this.nextChar();\n                                    }\n                                    else {\n                                        this.reportScannerError("Invalid Unicode escape sequence");\n                                        break;\n                                    }\n                                }\n                                continue scanStringConstantLoop;\n                        }\n                        break;\n                }\n\n                // Record seeing a Unicode char\n                if (this.ch >= LexCodeASCIIChars) {\n                    this.seenUnicodeChar = true;\n                }\n\n                this.nextChar();\n            }\n\n            return new StringLiteralToken(this.src.substring(this.startPos, this.pos));\n        }\n\n        private scanIdentifier(): Token {\n            var hasEscape = false;\n            var isFirstChar = (this.ch == LexCodeBSL);\n            var hasUnicode: any = false;\n\n            for (; ;) {\n                while (lexIdStartTable[this.ch] || LexIsDigit(this.ch) || \n                      (this.ch >= LexCodeASCIIChars && this.isValidUnicodeIdentifierChar())) {\n                    this.nextChar();\n                }\n                if (this.ch == LexCodeBSL) {\n                    this.nextChar();\n                    if (this.ch == LexCode_u) {\n                        // 4 hex digits\n                        this.nextChar();\n                        for (var h = 0; h < 4 ; h++) {\n                            if (this.IsHexDigit(this.ch)) {\n                                this.nextChar();\n                            }\n                            else {\n                                this.reportScannerError("Invalid Unicode escape sequence");\n                                return staticTokens[TokenID.Error];\n                            }\n                        }\n                        var hexChar = parseInt(this.src.substring(this.pos - 4, this.pos), 16);\n\n                        // Verify is valid ID char \n                        if (lexIdStartTable[hexChar] || (!isFirstChar && LexIsDigit(hexChar)) ||\n                            (hexChar >= LexCodeASCIIChars && (LexIsUnicodeIdStart(hexChar) || (!isFirstChar && LexIsUnicodeDigit(hexChar))))) {\n                        }\n                        else { \n                            this.reportScannerError("Invalid identifier character");\n                            return staticTokens[TokenID.Error];\n                        }\n\n                        hasEscape = true;\n                        isFirstChar = false;\n                        continue;\n                    }\n\n                    this.reportScannerError("Invalid Unicode escape sequence");\n                    return staticTokens[TokenID.Error];\n                }\n        ',
v27561=v27562+'        break;\n            }\n\n            var id: number;\n            var text = this.src.substring(this.startPos, this.pos);\n            if (!hasEscape && (id = LexKeywordTable.lookup(text)) != null) {\n                return staticTokens[id];\n            }\n            else {\n                return new IdentifierToken(text, hasEscape);\n            }\n        }\n\n        public innerScan(): Token {\n            var rtok;\n            this.tokenStart();\n            this.ch = this.peekChar();\n\n            start: while (this.pos < this.len) {\n                 if (lexIdStartTable[this.ch] || this.ch == LexCodeBSL || (this.ch >= LexCodeASCIIChars && LexIsUnicodeIdStart(this.ch))) {\n                    // identifier or keyword\n                    return this.scanIdentifier();\n                }\n                else if (this.ch == LexCodeSpace) {\n                    if (!this.interveningWhitespace) {\n                        this.interveningWhitespacePos = this.pos;\n                    }\n                    do {\n                        this.nextChar();\n                    } while (this.ch == LexCodeSpace);\n                    if (this.mode == LexMode.Line) {\n                        var whitespaceText = this.src.substring(this.startPos, this.pos);\n                        return new WhitespaceToken(TokenID.Whitespace, whitespaceText);\n                    }\n                    else {\n                        this.tokenStart();\n                        this.interveningWhitespace = true;\n                    }\n                }\n                else if (this.ch == LexCodeSLH) {\n                    this.nextChar();\n                    var commentText;\n                    if (this.ch == LexCodeSLH) {\n                        if (!this.interveningWhitespace) {\n                            this.interveningWhitespacePos = this.pos - 1;\n                        }\n                        var commentStartPos = this.pos - 1;\n                        var commentStartLine = this.line;\n                        this.finishSinglelineComment();\n                        var commentText = this.src.substring(commentStartPos, this.pos);\n                        var commentToken = new CommentToken(TokenID.Comment, commentText,/*isBlock*/false, commentStartPos, commentStartLine,/*endsLine*/false);\n                        if (this.scanComments) {\n                            // respect scanner contract: when returning a token, startPos is the start position of the token\n                            this.startPos = commentStartPos;\n                            return commentToken;\n                        }\n                        else {\n                            this.pushComment(commentToken);\n                        }\n\n                        this.interveningWhitespace = true;\n                    }\n                    else if (this.ch == LexCodeMUL) {\n                        if (!this.interveningWhitespace) {\n                            this.interveningWhitespacePos = this.pos - 1;\n                        }\n                        var commentStartPos = this.pos - 1;\n                        var commentStartLine = this.line;\n                        this.nextChar();  // Skip the "*"\n                        this.finishMultilineComment();\n                        var commentText = this.src.substring(commentStartPos, this.pos);\n                        var endsLine = this.endsLine(this.peekChar());\n                        var commentToken = new CommentToken(TokenID.Comment, commentText,/*isBlock*/true, commentStartPos, commentStartLine, endsLine);\n                        if (this.scanComments) {\n                            // respect scanner contract: when returning a token, startPos is the start position of the token\n                            this.startPos = commentStartPos;\n                            return commentToken;\n                        }\n                        else {\n                            this.pushComment(commentToken);\n                        }\n                        this.interveningWhitespace = true;\n                    }\n                    else {\n                        var regexTok = this.speculateRegex();\n                        if (regexTok) {\n                            return regexTok;\n                        }\n                        else {\n                            if (this.peekCharAt(this.pos) == LexCodeEQ) {\n                                this.nextChar();\n                                return staticTokens[TokenID.SlashEquals];\n                            }\n                            else {\n                                return staticTokens[TokenID.Slash];\n                            }\n                        }\n                    }\n                }\n                else if (this.ch == LexCodeSMC) {\n                    this.nextChar();\n                    return staticTokens[TokenID.Semicolon];\n                }\n                else if ((this.ch == LexCodeAPO) || (this.ch == LexCodeQUO)) {\n                    return this.scanSt',
v27560=v27561+"ringConstant();\n                }\n                else if (autoToken[this.ch]) {\n                    var atok = autoToken[this.ch];\n                    if (atok.tokenId == TokenID.OpenBrace) {\n                        this.leftCurlyCount++;\n                    }\n                    else if (atok.tokenId == TokenID.CloseBrace) {\n                        this.rightCurlyCount++;\n                    }\n                    this.nextChar();\n                    return atok;\n                }\n                else if ((this.ch >= LexCode_0) && (this.ch <= LexCode_9)) {\n                    rtok = this.scanNumber();\n                    if (rtok) {\n                        return rtok;\n                    }\n                    else {\n                        this.nextChar();\n                        return staticTokens[TokenID.Error];\n                    }\n                }\n                else switch (this.ch) {\n                    // TAB\n                    case LexCodeTAB:\n                    case LexCodeVTAB:\n                        if (!this.interveningWhitespace) {\n                            this.interveningWhitespacePos = this.pos;\n                        }\n                        if (this.mode == LexMode.Line) {\n                            do {\n                                this.nextChar();\n                            } while ((this.ch == LexCodeSpace) || (this.ch == 9));\n                            var wsText = this.src.substring(this.startPos, this.pos);\n                            return new WhitespaceToken(TokenID.Whitespace, wsText);\n                        }\n                        else {\n                            this.interveningWhitespace = true;\n                        }\n                     // Newlines and BOM\n                    case 0xFF: // UTF16 SEQUENCE\n                    case 0xFE:\n                    case 0xEF:    // UTF8 SEQUENCE\n                    case 0xBB:\n                    case 0xBF:\n                    case LexCodeLS:\n                    case LexCodePS:\n                    case LexCodeNWL:\n                    case LexCodeRET:\n                        if (this.ch == LexCodeNWL) {\n                            this.newLine();\n                            if (this.mode == LexMode.Line) {\n                                return staticTokens[TokenID.EndOfFile];\n                            }\n                        }\n                        if (!this.interveningWhitespace) {\n                            this.interveningWhitespacePos = this.pos;\n                        }\n                        this.nextChar();\n                        this.tokenStart();\n                        this.interveningWhitespace = true;\n                        break;\n                    case LexCodeDOT: {\n                        if (this.peekCharAt(this.pos + 1) == LexCodeDOT) {\n                            if (this.peekCharAt(this.pos + 2) == LexCodeDOT) {\n                                this.advanceChar(3);\n                                return staticTokens[TokenID.DotDotDot];\n                            }\n                            else {\n                                this.nextChar();\n                                return staticTokens[TokenID.Dot];\n                            }\n                        }\n                        else {\n                            this.nextChar();\n                            rtok = this.scanFraction();\n                            if (rtok) {\n                                return rtok;\n                            }\n                            else {\n                                return staticTokens[TokenID.Dot];\n                            }\n                        }\n                        // break;\n                    }\n                    case LexCodeEQ:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            if (this.peekCharAt(this.pos + 2) == LexCodeEQ) {\n                                this.advanceChar(3);\n                                return staticTokens[TokenID.EqualsEqualsEquals];\n                            }\n                            else {\n                                this.advanceChar(2);\n                                return staticTokens[TokenID.EqualsEquals];\n                            }\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodeGT) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.EqualsGreaterThan];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Equals];\n                        }\n                    // break;\n                    case LexCodeBNG:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            if (this.peekCharAt(this.pos + 2) == LexCodeEQ) {\n                                this.advanceChar(3);\n                                return staticTo",
v27559=v27560+"kens[TokenID.ExclamationEqualsEquals];\n                            }\n                            else {\n                                this.advanceChar(2);\n                                return staticTokens[TokenID.ExclamationEquals];\n                            }\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Exclamation];\n                        }\n                    // break;\n                    case LexCodePLS:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.PlusEquals];\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodePLS) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.PlusPlus];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Plus];\n                        }\n                    // break;\n                    case LexCodeMIN:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.MinusEquals];\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodeMIN) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.MinusMinus];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Minus];\n                        }\n                    // break;\n                    case LexCodeMUL:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.AsteriskEquals];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Asterisk];\n                        }\n                    // break;\n                    case LexCodePCT:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.PercentEquals];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Percent];\n                        }\n                    // break;\n                    case LexCodeLT:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeLT) {\n                            if (this.peekCharAt(this.pos + 2) == LexCodeEQ) {\n                                this.advanceChar(3);\n                                return staticTokens[TokenID.LessThanLessThanEquals];\n                            }\n                            else {\n                                this.advanceChar(2);\n                                return staticTokens[TokenID.LessThanLessThan];\n                            }\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.LessThanEquals];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.LessThan];\n                        }\n                    //  break;\n                    case LexCodeGT:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeGT) {\n                            if (this.peekCharAt(this.pos + 2) == LexCodeEQ) {\n                                this.advanceChar(3);\n                                return staticTokens[TokenID.GreaterThanGreaterThanEquals];\n                            }\n                            else if (this.peekCharAt(this.pos + 2) == LexCodeGT) {\n                                if (this.peekCharAt(this.pos + 3) == LexCodeEQ) {\n                                    this.advanceChar(4);\n                                    return staticTokens[TokenID.GreaterThanGreaterThanGreaterThanEquals];\n                                }\n                                else {\n                                    this.advanceChar(3);\n                                    return staticTokens[TokenID.GreaterThanGreaterThanGreaterThan];\n                                }\n                            }\n                            else {\n                                this.advanceChar(2);\n                                return staticTokens[TokenID.GreaterThanGreaterThan];\n                            }\n                        }\n                        ",
v27558=v27559+'else if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.GreaterThanEquals];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.GreaterThan];\n                        }\n                    // break;\n                    case LexCodeXOR:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.CaretEquals];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Caret];\n                        }\n                    //  break;\n                    case LexCodeBAR:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.BarEquals];\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodeBAR) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.BarBar];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Bar];\n                        }\n                    //  break;\n                    case LexCodeAMP:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.AmpersandEquals];\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodeAMP) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.AmpersandAmpersand];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.And];\n                        }\n                    //  break;\n                    default:\n                        // Report error\n                        this.reportScannerError("Invalid character");\n                        this.nextChar();\n\n                        continue start;\n                }\n            }\n            return staticTokens[TokenID.EndOfFile];\n        }\n\n        private reportScannerError(message: string) { \n            if (this.reportError) { \n                this.reportError(message);\n            }\n        }\n    }\n\n    // Reseverved words only apply to Identifiers, not IdentifierNames\n    export function convertTokToIDName(tok: Token): bool {\n        return convertTokToIDBase(tok, true, false);\n    }\n\n    export function convertTokToID(tok: Token, strictMode: bool): bool {\n        return convertTokToIDBase(tok, false, strictMode);\n    }\n\n    function convertTokToIDBase(tok: Token, identifierName: bool, strictMode: bool): bool {\n        if (tok.tokenId <= TokenID.LimKeyword) {\n            var tokInfo = lookupToken(tok.tokenId);\n            if (tokInfo != undefined) {\n                var resFlags = Reservation.Javascript | Reservation.JavascriptFuture;\n                if (strictMode) {\n                    resFlags |= Reservation.JavascriptFutureStrict;\n                }\n                if (identifierName || !hasFlag(tokInfo.reservation, resFlags)) {\n                    return true;\n                }\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n\n    // Return the (1-based) line number from a character offset using the provided linemap.\n    export function getLineNumberFromPosition(lineMap: number[], position: number): number {\n        if (position === -1)\n            return 0;\n\n        // Binary search\n        var min = 0;\n        var max = lineMap.length - 1;\n        while (min < max) {\n            var med = (min + max) >> 1;\n            if (position < lineMap[med]) {\n                max = med - 1;\n            }\n            else if (position < lineMap[med + 1]) {\n                min = max = med; // found it\n            }\n            else {\n                min = med + 1;\n            }\n        }\n\n        return min;\n    }\n\n    /// Return the [line, column] data for a given offset and a lineMap.\n    /// Note that the returned line is 1-based, while the column is 0-based.\n    export function getSourceLineColFromMap(lineCol: ILineCol, minChar: number, lineMap: number[]): void {\n        var line = getLineNumberFromPosition(lineMap, minChar);\n\n        if (line > 0) {\n            lineCol.line = line;\n            lineCol.col = (minChar - lineMap[line]);\n        }\n    }\n\n    // Return the [line, column] (both 1 based) corresponding to a given position in a given script.\n    export funct',
v27557=v27558+'ion getLineColumnFromPosition(script: TypeScript.Script, position: number): ILineCol {\n        var result = { line: -1, col: -1 };\n        getSourceLineColFromMap(result, position, script.locationInfo.lineMap);\n        if (result.col >= 0) {\n            result.col++;   // Make it 1-based\n        }\n        return result;\n    }\n\n    //\n    // Return the position (offset) corresponding to a given [line, column] (both 1-based) in a given script.\n    //\n    export function getPositionFromLineColumn(script: TypeScript.Script, line: number, column: number): number {\n        return script.locationInfo.lineMap[line] + (column - 1);\n    }\n    \n    // Return true if the token is a primitive type\n    export function isPrimitiveTypeToken(token: Token) {\n        switch (token.tokenId) {\n            case TokenID.Any:\n            case TokenID.Bool:\n            case TokenID.Number:\n            case TokenID.String:\n                return true;\n        }\n        return false;\n    }\n\n    // Return true if the token is a primitive type\n    export function isModifier(token: Token) {\n        switch (token.tokenId) {\n            case TokenID.Public:\n            case TokenID.Private:\n            case TokenID.Static:\n                return true;\n        }\n        return false;\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export class AssignScopeContext {\n        constructor (public scopeChain: ScopeChain,\n                     public typeFlow: TypeFlow,\n                     public modDeclChain: ModuleDeclaration[]) {\n        }\n    }\n\n    export function pushAssignScope(scope: SymbolScope,\n        context: AssignScopeContext,\n        type: Type,\n        classType: Type,\n        fnc: FuncDecl) {\n\n        var chain = new ScopeChain(null, context.scopeChain, scope);\n        chain.thisType = type;\n        chain.classType = classType;\n        chain.fnc = fnc;\n        context.scopeChain = chain;\n    }\n\n    export function popAssignScope(context: AssignScopeContext) {\n        context.scopeChain = context.scopeChain.previous;\n    }\n\n    export function instanceCompare(a: Symbol, b: Symbol) {\n        if (((a == null) || (!a.isInstanceProperty()))) {\n            return b;\n        }\n        else {\n            return a;\n        }\n    }\n\n    export function instanceFilterStop(s: Symbol) {\n        return s.isInstanceProperty();\n    }\n\n    export class ScopeSearchFilter {\n\n        constructor (public select: (a: Symbol, b: Symbol) =>Symbol,\n                            public stop: (s: Symbol) =>bool) { }\n\n        public result: Symbol = null;\n\n        public reset() {\n            this.result = null;\n        }\n\n        public update(b: Symbol): bool {\n            this.result = this.select(this.result, b);\n            if (this.result) {\n                return this.stop(this.result);\n            }\n            else {\n                return false;\n            }\n        }\n    }\n\n    export var instanceFilter = new ScopeSearchFilter(instanceCompare, instanceFilterStop);\n\n    export function preAssignModuleScopes(ast: AST, context: AssignScopeContext) {\n        var moduleDecl = <ModuleDeclaration>ast;\n        var memberScope: SymbolTableScope = null;\n        var aggScope: SymbolAggregateScope = null;\n\n        if (moduleDecl.name && moduleDecl.mod) {\n            moduleDecl.name.sym = moduleDecl.mod.symbol;\n        }\n\n        var mod = moduleDecl.mod;\n\n        // We\'re likely here because of error recovery\n        if (!mod) {\n            return;\n        }\n\n        memberScope = new SymbolTableScope(mod.members, mod.ambientMembers, mod.enclosedTypes, mod.ambientEnclosedTypes, mod.symbol);\n        mod.memberScope = memberScope;\n        context.modDeclChain.push(moduleDecl);\n        context.typeFlow.checker.currentModDecl = moduleDecl;\n        aggScope = new SymbolAggregateScope(mod.symbol);\n        aggScope.addParentScope(memberScope);\n        aggScope.addParentScope(context.scopeChain.scope);\n        pushAssignScope(aggScope, context, null, null, null);\n        mod.containedScope = aggScope;\n        if (mod.symbol) {\n            context.typeFlow.addLocalsFromScope(mod.containedScope, mod.symbol, moduleDecl.vars, mod.members.privateMembers, true);\n        }\n    }\n\n    export function preAssignClassScopes(ast: AST, context: AssignScopeContext) {\n        var classDecl = <InterfaceDeclaration>ast;\n        var memberScope: Symb',
v27556=v27557+"olTableScope = null;\n        var aggScope: SymbolAggregateScope = null;\n\n        if (classDecl.name && classDecl.type) {\n            classDecl.name.sym = classDecl.type.symbol;\n        }\n\n        var classType = ast.type;\n\n        if (classType) {\n            var classSym = classType.symbol;\n            memberScope = <SymbolTableScope>context.typeFlow.checker.scopeOf(classType);\n\n            aggScope = new SymbolAggregateScope(classType.symbol);\n            aggScope.addParentScope(memberScope);\n            aggScope.addParentScope(context.scopeChain.scope);\n\n            classType.containedScope = aggScope;\n            classType.memberScope = memberScope;\n\n            var instanceType = classType.instanceType;\n            memberScope = <SymbolTableScope>context.typeFlow.checker.scopeOf(instanceType);\n            instanceType.memberScope = memberScope;\n\n            aggScope = new SymbolAggregateScope(instanceType.symbol);\n            aggScope.addParentScope(context.scopeChain.scope);\n\n            pushAssignScope(aggScope, context, instanceType, classType, null);\n            instanceType.containedScope = aggScope;\n        }\n        else {\n            ast.type = context.typeFlow.anyType;\n        }\n    }\n\n    export function preAssignInterfaceScopes(ast: AST, context: AssignScopeContext) {\n        var interfaceDecl = <InterfaceDeclaration>ast;\n        var memberScope: SymbolTableScope = null;\n        var aggScope: SymbolAggregateScope = null;\n\n        if (interfaceDecl.name && interfaceDecl.type) {\n            interfaceDecl.name.sym = interfaceDecl.type.symbol;\n        }\n\n        var interfaceType = ast.type;\n        memberScope = <SymbolTableScope>context.typeFlow.checker.scopeOf(interfaceType);\n        interfaceType.memberScope = memberScope;\n        aggScope = new SymbolAggregateScope(interfaceType.symbol);\n        aggScope.addParentScope(memberScope);\n        aggScope.addParentScope(context.scopeChain.scope);\n        pushAssignScope(aggScope, context, null, null, null);\n        interfaceType.containedScope = aggScope;\n    }\n\n    export function preAssignWithScopes(ast: AST, context: AssignScopeContext) {\n        var withStmt = <WithStatement>ast;\n        var withType = withStmt.type;\n\n        var members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n        var ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n\n        var withType = new Type();\n        var withSymbol = new WithSymbol(withStmt.minChar, context.typeFlow.checker.locationInfo.unitIndex, withType);\n        withType.members = members;\n        withType.ambientMembers = ambientMembers;\n        withType.symbol = withSymbol;\n        withType.setHasImplementation();\n        withStmt.type = withType;\n\n        var withScope = new TypeScript.SymbolScopeBuilder(withType.members, withType.ambientMembers, null, null, context.scopeChain.scope, withType.symbol);\n\n        pushAssignScope(withScope, context, null, null, null);\n        withType.containedScope = withScope;\n    }\n\n    export function preAssignFuncDeclScopes(ast: AST, context: AssignScopeContext) {\n        var funcDecl = <FuncDecl>ast;\n\n        var container: Symbol = null;\n        var localContainer: Symbol = null;\n        if (funcDecl.type) {\n            localContainer = ast.type.symbol;\n        }\n\n        var isStatic = hasFlag(funcDecl.fncFlags, FncFlags.Static);\n        var isInnerStatic = isStatic && context.scopeChain.fnc != null;\n        // for inner static functions, use the parent's member scope, so local vars cannot be captured\n        var parentScope = isInnerStatic ? context.scopeChain.fnc.type.memberScope : context.scopeChain.scope;\n\n        // if this is not a method, but enclosed by class, use constructor as\n        // the enclosing scope\n        // REVIEW: Some twisted logic here - this needs to be cleaned up once old classes are removed\n        //  - if it's a new class, always use the contained scope, since we initialize the constructor scope below\n        if (context.scopeChain.thisType &&\n            (!funcDecl.isConstructor || hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod))) {\n            var instType = context.scopeChain.thisType;\n\n            if (!(instType.typeFlags & TypeFlags.IsClass) && !hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {\n                if (!funcDecl.isMethod() || isStatic) {\n                    parentScope = instType.constructorScope;\n                }\n                else {\n                    // use constructor scope if a method as well\n                    parentScope = instType.containedScope;\n                }\n            }\n            else {\n                if (context.scopeChain.previous.scope.container &&\n                    context.scopeChain.previous.scope.container.declAST &&\n                    context.scopeChain.previous.scope.container.declAST.nodeType == NodeType.FuncDecl &&\n                    (<FuncDecl>context.scopeChain.previous.sco",
v27555=v27556+"pe.container.declAST).isConstructor) {\n\n                        // if the parent is the class constructor, use the constructor scope\n                    parentScope = instType.constructorScope;\n                }\n                else if (isStatic && context.scopeChain.classType) {\n                    parentScope = context.scopeChain.classType.containedScope;\n                }\n                else {\n                    // else, use the contained scope\n                    parentScope = instType.containedScope;\n                }\n            }\n            container = instType.symbol;\n        }\n        else if (funcDecl.isConstructor && context.scopeChain.thisType) {\n            // sets the container to the class type's symbol (which is shared by the instance type)\n            container = context.scopeChain.thisType.symbol;\n        }\n\n        if (funcDecl.type == null || hasFlag(funcDecl.type.symbol.flags, SymbolFlags.TypeSetDuringScopeAssignment)) {\n            if (context.scopeChain.fnc && context.scopeChain.fnc.type) {\n                container = context.scopeChain.fnc.type.symbol;\n            }\n\n            var funcScope = null;\n            var outerFnc: FuncDecl = context.scopeChain.fnc;\n            var nameText = funcDecl.name ? funcDecl.name.actualText : null;\n            var fgSym: TypeSymbol = null;\n\n            if (isStatic) {\n                // In the case of function-nested statics, no member list will have bee initialized for the function, so we need\n                // to copy it over.  We don't set this by default because having a non-null member list will throw off assignment\n                // compatibility tests\n                if (outerFnc.type.members == null && container.getType().memberScope) {\n                    outerFnc.type.members = (<SymbolScopeBuilder>(<TypeSymbol>container).type.memberScope).valueMembers;\n                }\n                funcScope = context.scopeChain.fnc.type.memberScope;\n                outerFnc.innerStaticFuncs[outerFnc.innerStaticFuncs.length] = funcDecl;\n            }\n            else {\n                funcScope = context.scopeChain.scope;\n            }\n\n            // REVIEW: We don't search for another sym for accessors to prevent us from\n            // accidentally coalescing function signatures with the same name (E.g., a function\n            // 'f' the outer scope and a setter 'f' in an object literal within that scope)\n            if (nameText && nameText != \"__missing\" && !funcDecl.isAccessor()) {\n                if (isStatic) {\n                    fgSym = funcScope.findLocal(nameText, false, false);\n                }\n                else {\n                    // REVIEW: This logic should be symmetric with preCollectClassTypes\n                    fgSym = funcScope.findLocal(nameText, false, false);\n                }\n            }\n\n            context.typeFlow.checker.createFunctionSignature(funcDecl, container,\n                                                            funcScope, fgSym, fgSym == null);\n\n            // it's a getter or setter for a class property                     \n            if (!funcDecl.accessorSymbol && \n                (funcDecl.fncFlags & FncFlags.ClassMethod) &&\n                container && \n                ((!fgSym || fgSym.declAST.nodeType != NodeType.FuncDecl) && funcDecl.isAccessor()) || \n                    (fgSym && fgSym.isAccessor())) \n            {\n                funcDecl.accessorSymbol = context.typeFlow.checker.createAccessorSymbol(funcDecl, fgSym, container.getType(), (funcDecl.isMethod() && isStatic), true, funcScope, container);\n            }\n\n            funcDecl.type.symbol.flags |= SymbolFlags.TypeSetDuringScopeAssignment;\n        }\n\n        // Set the symbol for functions and their overloads\n        if (funcDecl.name && funcDecl.type) {\n            funcDecl.name.sym = funcDecl.type.symbol;\n        }\n\n        // Keep track of the original scope type, because target typing might override\n        // the \"type\" member. We need the original \"Scope type\" for completion list, etc.\n        funcDecl.scopeType = funcDecl.type;\n\n        // Overloads have no scope, so bail here\n        if (funcDecl.isOverload) {\n            return;\n        }\n\n        var funcTable = new StringHashTable();\n        var funcMembers = new ScopedMembers(new DualStringHashTable(funcTable, new StringHashTable()));\n        var ambientFuncTable = new StringHashTable();\n        var ambientFuncMembers = new ScopedMembers(new DualStringHashTable(ambientFuncTable, new StringHashTable()));\n        var funcStaticTable = new StringHashTable();\n        var funcStaticMembers = new ScopedMembers(new DualStringHashTable(funcStaticTable, new StringHashTable()));\n        var ambientFuncStaticTable = new StringHashTable();\n        var ambientFuncStaticMembers = new ScopedMembers(new DualStringHashTable(ambientFuncStaticTable, new StringHashTable()));\n\n        // REVIEW: Is it a problem that this is being set twice for properties and constructors?\n        funcDe",
v27554=v27555+"cl.unitIndex = context.typeFlow.checker.locationInfo.unitIndex;\n\n        var locals = new SymbolScopeBuilder(funcMembers, ambientFuncMembers, null, null, parentScope, localContainer);\n        var statics = new SymbolScopeBuilder(funcStaticMembers, ambientFuncStaticMembers, null, null, parentScope, null);\n\n        if (funcDecl.isConstructor && context.scopeChain.thisType) {\n            context.scopeChain.thisType.constructorScope = locals;\n        }\n\n        // basically, there are two problems\n        // - Above, for new classes, we were overwriting the constructor scope with the containing scope.  This caused constructor params to be\n        // in scope everywhere\n        // - Below, we're setting the contained scope table to the same table we were overwriting the constructor scope with, which we need to\n        // fish lambda params, etc, out (see funcTable below)\n        //\n        // A good first approach to solving this would be to change addLocalsFromScope to take a scope instead of a table, and add to the\n        // constructor scope as appropriate\n\n        funcDecl.symbols = funcTable;\n\n        if (!funcDecl.isSpecialFn()) {\n            var group = funcDecl.type;\n            var signature = funcDecl.signature;\n\n            if (!funcDecl.isConstructor) {\n                group.containedScope = locals;\n                locals.container = group.symbol;\n\n                group.memberScope = statics;\n                statics.container = group.symbol;\n            }\n            funcDecl.enclosingFnc = context.scopeChain.fnc;\n            group.enclosingType = isStatic ? context.scopeChain.classType : context.scopeChain.thisType;\n            // for mapping when type checking\n            var fgSym = <TypeSymbol>ast.type.symbol;\n            if (((funcDecl.fncFlags & FncFlags.Signature) == FncFlags.None) && funcDecl.vars) {\n                context.typeFlow.addLocalsFromScope(locals, fgSym, funcDecl.vars,\n                                                    funcTable, false);\n                context.typeFlow.addLocalsFromScope(statics, fgSym, funcDecl.statics,\n                                                    funcStaticTable, false);\n            }\n            if (signature.parameters) {\n                var len = signature.parameters.length;\n                for (var i = 0; i < len; i++) {\n                    var paramSym: ParameterSymbol = signature.parameters[i];\n                    context.typeFlow.checker.resolveTypeLink(locals,\n                                                                paramSym.parameter.typeLink, true);\n                }\n            }\n            context.typeFlow.checker.resolveTypeLink(locals, signature.returnType,\n                                                        funcDecl.isSignature());\n        }\n\n        if (!funcDecl.isConstructor || hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {\n            var thisType = (funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) ? context.scopeChain.thisType : null;\n            pushAssignScope(locals, context, thisType, null, funcDecl);\n        }\n\n        if (funcDecl.name && hasFlag(funcDecl.fncFlags, FncFlags.IsFunctionExpression)) {\n            // If the function is an expression, the name will not be visible in the enclosing scope.\n            // Add the function symbol under its name to the local scope to allow for recursive calls.\n            if (funcDecl.name.sym) {\n                funcTable.add(funcDecl.name.actualText, funcDecl.name.sym);\n            }\n        }\n    }\n\n    export function preAssignCatchScopes(ast: AST, context: AssignScopeContext) {\n        var catchBlock = <Catch>ast;\n        if (catchBlock.param) {\n            var catchTable = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable())); // REVIEW: Should we be allocating a public table instead of a private one?\n            var catchLocals = new SymbolScopeBuilder(catchTable, null, null, null, context.scopeChain.scope,\n                                                   context.scopeChain.scope.container);\n            catchBlock.containedScope = catchLocals;\n            pushAssignScope(catchLocals, context, context.scopeChain.thisType, context.scopeChain.classType, context.scopeChain.fnc);\n        }\n    }\n\n    export function preAssignScopes(ast: AST, parent: AST, walker: IAstWalker) {\n        var context:AssignScopeContext = walker.state;\n        var go = true;\n\n        if (ast) {\n            if (ast.nodeType == NodeType.List) {\n                var list = <ASTList>ast;\n                list.enclosingScope = context.scopeChain.scope;\n            }\n            else if (ast.nodeType == NodeType.ModuleDeclaration) {\n                preAssignModuleScopes(ast, context);\n            }\n            else if (ast.nodeType == NodeType.ClassDeclaration) {\n                preAssignClassScopes(ast, context);\n            }\n            else if (ast.nodeType == NodeType.InterfaceDeclaration) {\n                preAssignInterfaceScopes(",
v27553=v27554+'ast, context);\n            }\n            else if (ast.nodeType == NodeType.With) {\n                preAssignWithScopes(ast, context);\n            }\n            else if (ast.nodeType == NodeType.FuncDecl) {\n                preAssignFuncDeclScopes(ast, context);\n            }\n            else if (ast.nodeType == NodeType.Catch) {\n                preAssignCatchScopes(ast, context);\n            }\n            else if (ast.nodeType == NodeType.TypeRef) {\n                go = false;\n            }\n        }\n        walker.options.goChildren = go;\n        return ast;\n    }\n\n    export function postAssignScopes(ast: AST, parent: AST, walker: IAstWalker) {\n        var context:AssignScopeContext = walker.state;\n        var go = true;\n        if (ast) {\n            if (ast.nodeType == NodeType.ModuleDeclaration) {\n                var prevModDecl = <ModuleDeclaration>ast;\n\n                popAssignScope(context);\n\n                context.modDeclChain.pop();\n                if (context.modDeclChain.length >= 1) {\n                    context.typeFlow.checker.currentModDecl = context.modDeclChain[context.modDeclChain.length - 1];\n                }\n            }\n            else if (ast.nodeType == NodeType.ClassDeclaration) {\n                popAssignScope(context);\n            }\n            else if (ast.nodeType == NodeType.InterfaceDeclaration) {\n                popAssignScope(context);\n            }\n            else if (ast.nodeType == NodeType.With) {\n                popAssignScope(context);\n            }\n            else if (ast.nodeType == NodeType.FuncDecl) {\n                var funcDecl = <FuncDecl>ast;\n                if ((!funcDecl.isConstructor || hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) && !funcDecl.isOverload) {\n                    popAssignScope(context);\n                }\n            }\n            else if (ast.nodeType == NodeType.Catch) {\n                var catchBlock = <Catch>ast;\n                if (catchBlock.param) {\n                    popAssignScope(context);\n                }\n            }\n            else {\n                go = false;\n            }\n        }\n        walker.options.goChildren = go;\n        return ast;\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class TypeCollectionContext {\n        public script: Script = null;\n\n        constructor (public scopeChain: ScopeChain, public checker: TypeChecker) {\n        }\n    }\n\n    export class MemberScopeContext {\n        public type: Type = null;\n        public ast: AST = null;\n        public scope: SymbolScope;\n        public options = new AstWalkOptions();\n\n        constructor (public flow: TypeFlow, public pos: number, public matchFlag: ASTFlags) {\n        }\n    }\n\n    export class EnclosingScopeContext {\n\n        public scopeGetter: () => SymbolScope = null;\n        public objectLiteralScopeGetter: () => SymbolScope = null;\n        public scopeStartAST: AST = null;\n        public skipNextFuncDeclForClass = false;\n        public deepestModuleDecl: ModuleDeclaration = null;\n        public enclosingClassDecl: TypeDeclaration = null;\n        public enclosingObjectLit: UnaryExpression = null;\n        public publicsOnly = true;\n        public useFullAst = false;\n        private scriptFragment: Script;\n\n        constructor (public logger: ILogger,\n                    public script: Script,\n                    public text: ISourceText,\n                    public pos: number,\n                    public isMemberCompletion: bool) {\n        }\n\n        public getScope(): SymbolScope {\n            return this.scopeGetter();\n        }\n\n        public getObjectLiteralScope(): SymbolScope {\n            return this.objectLiteralScopeGetter();\n        }\n\n        public getScopeAST() {\n            return this.scopeStartAST;\n        }\n\n        public getScopePosition() {\n            return this.scopeStartAST.minChar;\n        }\n\n        public getScriptFragmentStartAST(): AST {\n            return this.scopeStartAST;\n        }\n\n        public getScriptFragmentPosition(): number {\n            return this.getScriptFragmentStartAST().minChar;\n        }\n\n        public getScriptFragment(): Script {\n            if (this.scriptFragment == null) {\n                var ast = this.getScriptFragmentStartAST();\n                var minChar = ast.minChar;\n                var limChar = (this.isMemberCompletion ? this.pos : this.po',
v27552=v27553+"s + 1);\n                this.scriptFragment = TypeScript.quickParse(this.logger, ast, this.text, minChar, limChar, null/*errorCapture*/).Script;\n            }\n            return this.scriptFragment;\n        }\n    }\n\n    export function preFindMemberScope(ast: AST, parent: AST, walker: IAstWalker) {\n        var memScope: MemberScopeContext = walker.state;\n        if (hasFlag(ast.flags, memScope.matchFlag) && ((memScope.pos < 0) || (memScope.pos == ast.limChar))) {\n            memScope.ast = ast;\n            if ((ast.type == null) && (memScope.pos >= 0)) {\n                memScope.flow.inScopeTypeCheck(ast, memScope.scope);\n            }\n            memScope.type = ast.type;\n            memScope.options.stopWalk();\n        }\n        return ast;\n    }\n\n    export function pushTypeCollectionScope(container: Symbol,\n        valueMembers: ScopedMembers,\n        ambientValueMembers: ScopedMembers,\n        enclosedTypes: ScopedMembers,\n        ambientEnclosedTypes: ScopedMembers,\n        context: TypeCollectionContext,\n        thisType: Type,\n        classType: Type,\n        moduleDecl: ModuleDeclaration) {\n        var builder = new SymbolScopeBuilder(valueMembers, ambientValueMembers, enclosedTypes, ambientEnclosedTypes, null, container);\n        var chain: ScopeChain = new ScopeChain(container, context.scopeChain, builder);\n        chain.thisType = thisType;\n        chain.classType = classType;\n        chain.moduleDecl = moduleDecl;\n        context.scopeChain = chain;\n    }\n\n    export function popTypeCollectionScope(context: TypeCollectionContext) {\n        context.scopeChain = context.scopeChain.previous;\n    }\n\n    export function preFindEnclosingScope(ast: AST, parent: AST, walker: IAstWalker) {\n        var context: EnclosingScopeContext = walker.state;\n        var minChar = ast.minChar;\n        var limChar = ast.limChar;\n\n        // Account for the fact completion list may be called at the end of a file which\n        // is has not been fully re-parsed yet.\n        if (ast.nodeType == NodeType.Script && context.pos > limChar)\n            limChar = context.pos;\n\n        if ((minChar <= context.pos) &&\n            (limChar >= context.pos)) {\n            switch (ast.nodeType) {\n                case NodeType.Script:\n                    var script = <Script>ast;\n                    context.scopeGetter = function () {\n                        return script.bod === null ? null : script.bod.enclosingScope;\n                    };\n                    context.scopeStartAST = script;\n                    break;\n\n                case NodeType.ClassDeclaration:\n                    context.scopeGetter = function () {\n                        return (ast.type === null || ast.type.instanceType.containedScope === null) ? null : ast.type.instanceType.containedScope;\n                    };\n                    context.scopeStartAST = ast;\n                    context.enclosingClassDecl = <TypeDeclaration>ast;\n                    break;\n\n                case NodeType.ObjectLit:\n                    var objectLit = <UnaryExpression>ast;\n                    // Only consider target-typed object literals\n                    if (objectLit.targetType) {\n                        context.scopeGetter = function () {\n                            return objectLit.targetType.containedScope;\n                        };\n                        context.objectLiteralScopeGetter = function () {\n                            return objectLit.targetType.memberScope;\n                        }\n                        context.enclosingObjectLit = objectLit;\n                    }\n                    break;\n\n                case NodeType.ModuleDeclaration:\n                    context.deepestModuleDecl = <ModuleDeclaration>ast;\n                    context.scopeGetter = function () {\n                        return ast.type === null ? null : ast.type.containedScope;\n                    };\n                    context.scopeStartAST = ast;\n                    break;\n\n                case NodeType.InterfaceDeclaration:\n                    context.scopeGetter = function () {\n                        return (ast.type === null) ? null : ast.type.containedScope;\n                    };\n                    context.scopeStartAST = ast;\n                    break;\n\n                case NodeType.FuncDecl: {\n                    var funcDecl = <FuncDecl>ast;\n                    if (context.skipNextFuncDeclForClass) {\n                        context.skipNextFuncDeclForClass = false;\n                    }\n                    else {\n                        context.scopeGetter = function () {\n                            // The scope of a class constructor is hidden somewhere we don't expect :-S\n                            if (funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {\n                                if (ast.type && ast.type.enclosingType) {\n                                    return ast.type.enclosingType.constructorScope;\n                              ",
v27551=v27552+'  }\n                            }\n\n                            if (funcDecl.scopeType) {\n                                return funcDecl.scopeType.containedScope;\n                            }\n\n                            if (funcDecl.type) {\n                                return funcDecl.type.containedScope;\n                            }\n                            return null;\n                        };\n                        context.scopeStartAST = ast;\n                    }\n                }\n                    break;\n            }\n            walker.options.goChildren = true;\n        }\n        else {\n            walker.options.goChildren = false;\n        }\n        return ast;\n    }\n\n    //\n    // Find the enclosing scope context from a position inside a script AST.\n    // The "scopeStartAST" of the returned scope is always valid.\n    // Return "null" if the enclosing scope can\'t be found.\n    //\n    export function findEnclosingScopeAt(logger: ILogger, script: Script, text: ISourceText, pos: number, isMemberCompletion: bool): EnclosingScopeContext {\n        var context = new EnclosingScopeContext(logger, script, text, pos, isMemberCompletion);\n\n        TypeScript.getAstWalkerFactory().walk(script, preFindEnclosingScope, null, null, context);\n\n        if (context.scopeStartAST === null)\n            return null;\n        return context;\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class Signature {\n        public hasVariableArgList = false;\n        public returnType: TypeLink;\n        public parameters: ParameterSymbol[] = null;\n        public declAST: FuncDecl = null;\n        public typeCheckStatus = TypeCheckStatus.NotStarted;\n        public nonOptionalParameterCount = 0;\n\n        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Signature {\n            var result = new Signature();\n            if (this.hasVariableArgList) {\n                result.hasVariableArgList = true;\n            }\n            result.returnType = new TypeLink();\n            if (this.returnType.type) {\n                result.returnType.type =\n                    this.returnType.type.specializeType(pattern, replacement, checker, false);\n            }\n            else {\n                result.returnType.type = checker.anyType;\n            }\n\n            if (this.parameters) {\n                result.parameters = [];\n                for (var i = 0, len = this.parameters.length; i < len; i++) {\n                    var oldSym:ParameterSymbol = this.parameters[i];\n                    var paramDef = new ValueLocation();\n                    var paramSym = new ParameterSymbol(oldSym.name, oldSym.location,\n                                                     checker.locationInfo.unitIndex,\n                                                     paramDef);\n\n                    paramSym.declAST = this.declAST;\n                    paramDef.symbol = paramSym;\n                    paramDef.typeLink = new TypeLink();\n                    result.parameters[i] = paramSym;\n                    var oldType = oldSym.getType();\n                    if (oldType) {\n                        paramDef.typeLink.type = oldType.specializeType(pattern, replacement, checker, false);\n                        paramSym.declAST.type = paramDef.typeLink.type;\n                    }\n                    else {\n                        paramDef.typeLink.type = checker.anyType;\n                    }\n                }\n            }\n            result.nonOptionalParameterCount = this.nonOptionalParameterCount;\n            result.declAST = this.declAST;\n\n            return result;\n        }\n\n        public toString() {\n            return this.toStringHelper(false, false, null);\n        }\n\n        public toStringHelper(shortform: bool, brackets: bool, scope: SymbolScope) {\n            return this.toStringHelperEx(shortform, brackets, scope).toString();\n        }\n\n        public toStringHelperEx(shortform: bool, brackets: bool, scope: SymbolScope, prefix? : string = "") : MemberName {\n            var builder = new MemberNameArray();\n            if (brackets) {\n                builder.prefix =  prefix + "[";\n            }\n            else {\n                builder.prefix = prefix + "(";\n            }\n\n            var paramLen = this.parameters.length;\n            var len = this.hasVariableArgList ? paramLen - 1 : par',
v27550=v27551+'amLen;\n            for (var i = 0; i < len; i++) {\n                builder.add(MemberName.create(this.parameters[i].name + (this.parameters[i].isOptional() ? "?" : "") + ": "));\n                builder.add(this.parameters[i].getType().getScopedTypeNameEx(scope));\n                if (i < paramLen - 1) {\n                    builder.add(MemberName.create(", "));\n                }\n            }\n\n            if (this.hasVariableArgList) {\n                builder.add(MemberName.create("..." + this.parameters[i].name + ": "));\n                builder.add(this.parameters[i].getType().getScopedTypeNameEx(scope));\n            }\n\n            if (shortform) {\n                if (brackets) {\n                    builder.add(MemberName.create("] => "));\n                }\n                else {\n                    builder.add(MemberName.create(") => "));\n                }\n            }\n            else {\n                if (brackets) {\n                    builder.add(MemberName.create("]: "));\n                }\n                else {\n                    builder.add(MemberName.create("): "));\n                }\n            }\n\n            if (this.returnType.type) {\n                 builder.add(this.returnType.type.getScopedTypeNameEx(scope));\n            }\n            else {\n                builder.add(MemberName.create("any"));\n            }\n            return builder;\n        }\n    }\n\n    export class SignatureGroup {\n        public signatures: Signature[] = [];\n        public hasImplementation = true;\n        public definitionSignature: Signature = null;\n        public hasBeenTypechecked = false;\n        public flags: SignatureFlags = SignatureFlags.None;\n        public addSignature(signature: Signature) {\n            if (this.signatures == null) {\n                this.signatures = new Signature[];\n            }\n            this.signatures[this.signatures.length] = signature;\n            \n            // REVIEW: duplicates should be found within createFunctionSignature,\n            // so we won\'t check for them here\n            if (signature.declAST &&\n                !signature.declAST.isOverload &&\n                !signature.declAST.isSignature() && \n                !hasFlag(signature.declAST.fncFlags, FncFlags.Ambient) &&\n                hasFlag(signature.declAST.fncFlags, FncFlags.Definition)) {\n                this.definitionSignature = signature;\n            }\n        }\n\n        public toString() { return this.signatures.toString(); }\n        public toStrings(prefix: string, shortform: bool, scope: SymbolScope) {\n            var result : MemberName[] = [];  \n            var len = this.signatures.length;\n            if (len > 1) {\n                shortform = false;\n            }\n            for (var i = 0; i < len; i++) {\n                // the definition signature shouldn\'t be printed if there are overloads\n                if (len > 1 && this.signatures[i] == this.definitionSignature) {\n                    continue;\n                }\n                if (this.flags & SignatureFlags.IsIndexer) {\n                    result.push(this.signatures[i].toStringHelperEx(shortform, true, scope));\n                }\n                else {\n                    result.push(this.signatures[i].toStringHelperEx(shortform, false, scope, prefix));\n                }\n            }\n            \n            return result;\n        }\n\n        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): SignatureGroup {\n            var result = new SignatureGroup();\n            if (this.signatures) {\n                for (var i = 0, len = this.signatures.length; i < len; i++) {\n                    result.addSignature(this.signatures[i].specializeType(pattern, replacement, checker));\n                }\n            }\n            return result;\n        }\n\n        // verifies that signatures are\n        //  - unique within a given group\n        //  - compatible with the declaration signature\n        public verifySignatures(checker: TypeChecker) {\n\n            var len = 0;\n            \n            // TODO: verify no signature pair with identical parameters\n            if (this.signatures && ((len = this.signatures.length) > 0)) {\n                \n                for (var i = 0; i < len; i++) {\n                    \n                    for (var j = i + 1; j < len; j++) {\n                        // next check for equivalence between overloads - no two can be exactly the same                     \n                        if (this.signatures[i].declAST && this.signatures[j].declAST &&\n                            (!hasFlag(this.signatures[i].declAST.fncFlags, FncFlags.Definition) && !hasFlag(this.signatures[j].declAST.fncFlags, FncFlags.Definition)) &&\n                            checker.signaturesAreIdentical(this.signatures[i], this.signatures[j])) {\n                            checker.errorReporter.simpleError(this.signatures[i].declAST, (this.signatures[i].declAST && this.signatures[i].declAST.name) ? "Signature for \'" + this.signatures',
v27549=v27550+'[i].declAST.name.actualText + "\' is duplicated" :"Signature is duplicated");\n                        }\n                    }\n                    \n                    // finally, ensure that the definition is assignable to each signature\n                    if (this.definitionSignature) {\n                        if (!checker.signatureIsAssignableToTarget(this.definitionSignature, this.signatures[i])) {\n                            checker.errorReporter.simpleError(this.signatures[i].declAST, "Overload signature is not compatible with function definition");\n                        }\n                    }\n                }\n            }\n        }\n\n        public typeCheck(checker: TypeChecker, ast: AST, hasConstruct:bool) {\n            \n            if (this.hasBeenTypechecked) {\n                return;\n            }\n            \n            // set here to prevent us from recursively invoking typeCheck again\n            this.hasBeenTypechecked = true;\n            \n            var len = 0;\n            \n            if (this.signatures && ((len = this.signatures.length) > 0)) {\n                \n                // first, typecheck each signature\n                for (var i = 0; i < len; i++) {\n\n                    if (!hasConstruct && !this.definitionSignature && this.signatures[i].declAST && this.signatures[i].declAST.isOverload && !hasFlag(this.signatures[i].declAST.fncFlags, FncFlags.Ambient)) {\n                        checker.errorReporter.simpleError(this.signatures[i].declAST, "Overload declaration lacks definition");\n                    }\n\n                    // If we\'re typechecking a constructor via one of its overloads, ensure that the outer class is typechecked, since we need to validate its inheritance properties\n                    // to properly check that \'super\' is being used correctly\n                    if (this.signatures[i].declAST && this.signatures[i].declAST.isConstructor && this.signatures[i].declAST.classDecl && this.signatures[i].declAST.classDecl.type.symbol.typeCheckStatus == TypeCheckStatus.NotStarted) {\n                        checker.typeFlow.typeCheck(this.signatures[i].declAST.classDecl);\n                    }\n\n                    checker.typeFlow.typeCheck(this.signatures[i].declAST);\n                }\n\n                this.verifySignatures(checker);\n            }\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n///<reference path=\'..\\harness\\external\\json2.ts\' />\n\nmodule TypeScript {\n    export class SourceMapPosition {\n        public sourceLine: number;\n        public sourceColumn: number;\n        public emittedLine: number;\n        public emittedColumn: number;\n    }\n\n    export class SourceMapping {\n        public start = new SourceMapPosition();\n        public end = new SourceMapPosition();\n        public nameIndex: number = -1;\n        public childMappings: SourceMapping[] = [];\n    }\n\n    export class SourceMapper {\n        static MapFileExtension = ".map";\n        \n        public sourceMappings: SourceMapping[] = [];\n        public currentMappings: SourceMapping[][] = [];\n\n        public names: string[] = [];\n        public currentNameIndex: number[] = [];\n\n        public jsFileName: string;\n        public tsFileName: string;\n\n        constructor(tsFileName: string, jsFileName: string, public jsFile: ITextWriter, public sourceMapOut: ITextWriter, public errorReporter: ErrorReporter) {\n            this.currentMappings.push(this.sourceMappings);\n\n            jsFileName = switchToForwardSlashes(jsFileName);\n            this.jsFileName = TypeScript.getPrettyName(jsFileName, false, true);\n\n            var removalIndex = jsFileName.lastIndexOf(this.jsFileName);\n            var fixedPath = jsFileName.substring(0, removalIndex);\n\n            this.tsFileName = TypeScript.getRelativePathToFixedPath(fixedPath, tsFileName);\n        }\n        \n        // Generate source mapping\n        static EmitSourceMapping(allSourceMappers: SourceMapper[]) {\n            // At this point we know that there is at least one source mapper present.\n            // If there are multiple source mappers, all will correspond to same map file but different sources\n\n            // Output map file name into the js file\n            var sourceMapper = allSourceMappers[0];\n            sourceMapper.jsFile.WriteLine("//@ sourceMappingURL=" + sourceMapper.jsFileName + SourceMapper.MapFileExtension);\n\n  ',
v27548=v27549+'          // Now output map file\n            var sourceMapOut = sourceMapper.sourceMapOut;\n            var mappingsString = "";\n            var tsFiles: string[] = [];\n\n            var prevEmittedColumn = 0;\n            var prevEmittedLine = 0;\n            var prevSourceColumn = 0;\n            var prevSourceLine = 0;\n            var prevSourceIndex = 0;\n            var prevNameIndex = 0;\n            var namesList: string[] = [];\n            var namesCount = 0;\n            var emitComma = false;\n\n            var recordedPosition: SourceMapPosition = null;\n            for (var sourceMapperIndex = 0; sourceMapperIndex < allSourceMappers.length; sourceMapperIndex++) {\n                sourceMapper = allSourceMappers[sourceMapperIndex];\n\n                // If there are any mappings generated\n                var currentSourceIndex = tsFiles.length;\n                tsFiles.push(sourceMapper.tsFileName);\n\n                // Join namelist\n                if (sourceMapper.names.length > 0) {\n                    namesList.push.apply(namesList, sourceMapper.names);\n                }\n\n                var recordSourceMapping = (mappedPosition: SourceMapPosition, nameIndex: number) => {\n                    if (recordedPosition != null &&\n                        recordedPosition.emittedColumn == mappedPosition.emittedColumn &&\n                        recordedPosition.emittedLine == mappedPosition.emittedLine) {\n                        // This position is already recorded\n                        return;\n                    }\n\n                    // Record this position\n                    if (prevEmittedLine !== mappedPosition.emittedLine) {\n                        while (prevEmittedLine < mappedPosition.emittedLine) {\n                            prevEmittedColumn = 0;\n                            mappingsString = mappingsString + ";";\n                            prevEmittedLine++;\n                        }\n                        emitComma = false;\n                    }\n                    else if (emitComma) {\n                        mappingsString = mappingsString + ",";\n                    }\n\n                    // 1. Relative Column\n                    mappingsString = mappingsString + Base64VLQFormat.encode(mappedPosition.emittedColumn - prevEmittedColumn);\n                    prevEmittedColumn = mappedPosition.emittedColumn;\n\n                    // 2. Relative sourceIndex \n                    mappingsString = mappingsString + Base64VLQFormat.encode(currentSourceIndex - prevSourceIndex);\n                    prevSourceIndex = currentSourceIndex;\n\n                    // 3. Relative sourceLine 0 based\n                    mappingsString = mappingsString + Base64VLQFormat.encode(mappedPosition.sourceLine - 1 - prevSourceLine);\n                    prevSourceLine = mappedPosition.sourceLine - 1;\n\n                    // 4. Relative sourceColumn 0 based \n                    mappingsString = mappingsString + Base64VLQFormat.encode(mappedPosition.sourceColumn - prevSourceColumn);\n                    prevSourceColumn = mappedPosition.sourceColumn;\n\n                    // 5. Relative namePosition 0 based\n                    if (nameIndex >= 0) {\n                        mappingsString = mappingsString + Base64VLQFormat.encode(namesCount + nameIndex - prevNameIndex);\n                        prevNameIndex = namesCount + nameIndex;\n                    }\n\n                    emitComma = true;\n                    recordedPosition = mappedPosition;\n                }\n\n                // Record starting spans\n                var recordSourceMappingSiblings = (sourceMappings: SourceMapping[]) => {\n                    for (var i = 0; i < sourceMappings.length; i++) {\n                        var sourceMapping = sourceMappings[i];\n                        recordSourceMapping(sourceMapping.start, sourceMapping.nameIndex);\n                        recordSourceMappingSiblings(sourceMapping.childMappings);\n                        recordSourceMapping(sourceMapping.end, sourceMapping.nameIndex);\n                    }\n                }\n\n                recordSourceMappingSiblings(sourceMapper.sourceMappings, -1);\n                namesCount = namesCount + sourceMapper.names.length;\n            }\n\n            // Write the actual map file\n            if (mappingsString != "") {\n                sourceMapOut.Write(JSON2.stringify({\n                    version: 3,\n                    file: sourceMapper.jsFileName,\n                    sources: tsFiles,\n                    names: namesList,\n                    mappings: mappingsString\n                }));\n            }\n\n            // Done, close the file\n            try {\n                // Closing files could result in exceptions, report them if they occur\n                sourceMapOut.Close();\n            } catch (ex) {\n                sourceMapper.errorReporter.emitterError(null, ex.message);\n            }\n        }\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under',
v27547=v27548+' the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    // private members are private to the scope\n    // public members are public to the scope\n    export class ScopedMembers {\n\n        public allMembers: IHashTable;\n        public publicMembers: IHashTable;\n        public privateMembers: IHashTable;\n\n        constructor (public dualMembers: DualStringHashTable) { \n            this.allMembers = this.dualMembers;\n            this.publicMembers = this.dualMembers.primaryTable;\n            this.privateMembers = this.dualMembers.secondaryTable;\n        }\n\n        // add a public member\n        public addPublicMember(key: string, data) { return this.dualMembers.primaryTable.add(key, data); }\n\n        // add a private member \n        public addPrivateMember(key: string, data) { return this.dualMembers.secondaryTable.add(key, data); }\n    }\n\n    export enum SymbolKind {\n        None,\n        Type,\n        Field,\n        Parameter,\n        Variable,\n    }\n\n    export class SymbolScope {\n        constructor (public container: Symbol) { }\n        public printLabel() { return "base"; }\n        public getAllSymbolNames(members: bool): string[]{\n            return ["please", "implement", "in", "derived", "classes"];\n        }\n        public getAllTypeSymbolNames(members: bool): string[]{\n            return ["please", "implement", "in", "derived", "classes"];\n        }\n        public getAllValueSymbolNames(members: bool): string[]{\n            return ["please", "implement", "in", "derived", "classes"];\n        }\n        // advanced search using a filter\n        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool): Symbol { return null; }\n        // find in this immediate scope\n        public findLocal(name: string, publicOnly: bool, typespace: bool): Symbol { return null; }\n        // find in value namespace \n        public find(name: string, publicOnly: bool, typespace: bool): Symbol { return null; }\n        // find symbol that supplies an implementation\n        public findImplementation(name: string, publicOnly: bool, typespace: bool): Symbol { return null; }\n        // restrict the search to ambient values\n        public findAmbient(name: string, publicOnly: bool, typespace: bool): Symbol { return null; }\n        public print(outfile: ITextWriter) {\n            if (this.container) {\n                outfile.WriteLine(this.printLabel() + " scope with container: " + this.container.name + "...");\n            }\n            else {\n                outfile.WriteLine(this.printLabel() + " scope...");\n            }\n        }\n\n        public enter(container: Symbol, ast: AST, symbol: Symbol, errorReporter: ErrorReporter, publicOnly: bool,\n            typespace: bool, ambient: bool): void {\n            throw new Error("please implement in derived class");\n        }\n\n        public getTable(): IHashTable {\n            throw new Error("please implement in derived class");\n        }\n    }\n\n    function symbolCanBeUsed(sym: Symbol, publicOnly) {\n        return publicOnly ? !(hasFlag(sym.flags, SymbolFlags.Private) ||\n                            (sym.declAST && sym.declAST.nodeType == NodeType.FuncDecl && hasFlag((<FuncDecl>sym.declAST).fncFlags, FncFlags.Private)))\n                          : true;\n    }\n\n    export class SymbolAggregateScope extends SymbolScope {\n        public printLabel() { return "agg"; }\n        public valueCache: IHashTable = null;\n        public valueImplCache: IHashTable = null;\n        public valueAmbientCache: IHashTable = null;\n        public typeCache: IHashTable = null;\n        public typeImplCache: IHashTable = null;\n        public typeAmbientCache: IHashTable = null;\n        public parents: SymbolScope[] = null;\n        public container: Symbol;\n\n        constructor (container: Symbol) {\n            super(container);\n            this.container = container;\n        }\n\n        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool) {\n            if (this.parents) {\n                for (var i = 0; i < this.parents.length; i++) {\n                    var sym = this.parents[i].search(filter, name, publicOnly, typespace);\n                    if (sym) {\n                        if (filter.update(sym)) {\n                            return sym;\n                        }\n                    }\n                }\n            }\n            return filter.result;\n        }\n\n        public getAllSymbolNames(members',
v27546=v27547+": bool): string[]{\n            var result: string[] = [];\n            if (this.parents) {\n                for (var i = 0; i < this.parents.length; i++) {\n                    var parentResult = this.parents[i].getAllSymbolNames(members);\n                    if (parentResult) {\n                        result = result.concat(parentResult);\n                    }\n                }\n            }\n            return result;\n        }\n\n        public getAllTypeSymbolNames(members: bool): string[]{\n            var result: string[] = [];\n            if (this.parents) {\n                for (var i = 0; i < this.parents.length; i++) {\n                    var parentResult = this.parents[i].getAllTypeSymbolNames(members);\n                    if (parentResult) {\n                        result = result.concat(parentResult);\n                    }\n                }\n            }\n            return result;\n        }\n\n        public getAllValueSymbolNames(members: bool): string[]{\n            var result: string[] = [];\n            if (this.parents) {\n                for (var i = 0; i < this.parents.length; i++) {\n                    var parentResult = this.parents[i].getAllValueSymbolNames(members);\n                    if (parentResult) {\n                        result = result.concat(parentResult);\n                    }\n                }\n            }\n            return result;\n        }\n\n        public print(outfile: ITextWriter) {\n            super.print(outfile);\n            if (this.parents) {\n                for (var i = 0; i < this.parents.length; i++) {\n                    this.parents[i].print(outfile);\n                }\n            }\n        }\n\n        public findImplementation(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var i = 0;\n            var implCache = this.valueImplCache;\n\n            if (typespace) {\n                implCache = this.typeImplCache;\n            }\n            if (implCache &&\n                ((sym = implCache.lookup(name)) != null) &&\n                (publicOnly ? !(hasFlag(sym.flags, SymbolFlags.Private) ||\n                                        (sym.declAST && sym.declAST.nodeType == NodeType.FuncDecl && hasFlag((<FuncDecl>sym.declAST).fncFlags, FncFlags.Private)))\n                                        : true)) {\n                return sym;\n            }\n            if (this.parents) {\n                for (i = 0; i < this.parents.length; i++) {\n                    sym = this.parents[i].findImplementation(name, publicOnly, typespace);\n                    if (sym) {\n                        break;\n                    }\n                }\n            }\n            if (implCache) {\n                if (typespace) {\n                    this.typeImplCache = new StringHashTable();\n                    implCache = this.typeImplCache;\n                }\n                else {\n                    this.valueImplCache = new StringHashTable();\n                    implCache = this.valueImplCache;\n                }\n            }\n            implCache.add(name, sym);\n            return sym;\n        }\n\n        public find(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var i = 0;\n            var cache = this.valueCache;\n\n            if (typespace) {\n                cache = this.typeCache;\n            }\n            if (cache &&\n                ((sym = cache.lookup(name)) != null) &&\n                (publicOnly ? !(hasFlag(sym.flags, SymbolFlags.Private) ||\n                                        (sym.declAST && sym.declAST.nodeType == NodeType.FuncDecl && hasFlag((<FuncDecl>sym.declAST).fncFlags, FncFlags.Private)))\n                                        : true)) {\n                return sym;\n            }\n            if (this.parents) {\n                for (i = 0; i < this.parents.length; i++) {\n                    sym = this.parents[i].find(name, publicOnly, typespace);\n                    if (sym) {\n                        break;\n                    }\n                }\n            }\n            if (cache == null) {\n                if (typespace) {\n                    this.typeCache = new StringHashTable();\n                    cache = this.typeCache;\n                }\n                else {\n                    this.valueCache = new StringHashTable();\n                    cache = this.valueCache;\n                }\n            }\n            cache.add(name, sym);\n            return sym;\n        }\n\n        public findAmbient(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var i = 0;\n            var cache = this.valueAmbientCache;\n            if (typespace) {\n                cache = this.typeAmbientCache;\n            }\n            if (cache && ((sym = cache.lookup(name)) != null)) {\n                return sym;\n            }\n            if (this.parents) {\n                for (i = 0; i < this.parents.length; i++) {\n                    sym =",
v27545=v27546+' this.parents[i].findAmbient(name, publicOnly, typespace);\n                    if (sym) {\n                        break;\n                    }\n                }\n            }\n            if (cache == null) {\n                if (typespace) {\n                    this.typeAmbientCache = new StringHashTable();\n                    cache = this.typeAmbientCache;\n                }\n                else {\n                    this.valueAmbientCache = new StringHashTable();\n                    cache = this.valueAmbientCache;\n                }\n            }\n            cache.add(name, sym);\n            return sym;\n        }\n\n        public addParentScope(parent: SymbolScope): void {\n            if (this.parents == null) {\n                this.parents = new SymbolScope[];\n            }\n            this.parents[this.parents.length] = parent;\n        }\n    }\n\n    export class SymbolTableScope extends SymbolScope {\n        public container: Symbol;\n\n        constructor(public valueMembers: ScopedMembers,\n                            public ambientValueMembers: ScopedMembers,\n                            public enclosedTypes: ScopedMembers,\n                            public ambientEnclosedTypes: ScopedMembers,\n                            container: Symbol)\n        {\n            super(container);\n            this.container = container;\n        }\n\n        public printLabel() { return "table"; }\n\n        public getAllSymbolNames(members: bool): string[]{\n            var result = this.getAllTypeSymbolNames(members);\n\n            return result.concat(this.getAllValueSymbolNames(members));\n        }\n\n        public getAllTypeSymbolNames(members: bool): string[]{\n            var result = [];\n            if (this.ambientEnclosedTypes) {\n                result = result.concat(this.ambientEnclosedTypes.allMembers.getAllKeys());\n            }\n            if (this.enclosedTypes) {\n                result = result.concat(this.enclosedTypes.allMembers.getAllKeys());\n            }\n            return result;\n        }\n\n        public getAllValueSymbolNames(members: bool): string[]{\n            var result = [];\n            if (this.ambientValueMembers) {\n                result = result.concat(this.ambientValueMembers.allMembers.getAllKeys());\n            }\n            if (this.valueMembers) {\n                result = result.concat(this.valueMembers.allMembers.getAllKeys());\n            }\n            return result;\n        }\n\n        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool) {\n            var sym = this.find(name, publicOnly, typespace);\n            filter.update(sym);\n            return filter.result;\n        }\n\n        public find(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var table: IHashTable = null;\n            var ambientTable: IHashTable = null;\n\n            if (typespace) {\n                table = (this.enclosedTypes == null) ? null :\n                            publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            else {\n                table = (this.valueMembers == null) ? null :\n                                publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;\n                ambientTable = (this.ambientValueMembers == null) ? null :\n                                    publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            }\n            if (ambientTable) {\n                var s = ambientTable.lookup(name);\n                if (s) { return s; }\n            }\n            if (table) {\n                var s = table.lookup(name);\n                if (s) { return s; }\n            }\n\n            return null;\n        }\n\n        public findAmbient(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var ambientTable = (this.ambientValueMembers == null) ? null :\n                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            if (typespace) {\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            if (ambientTable) {\n                var s = ambientTable.lookup(name);\n                if (s) { return s; }\n            }\n\n            return null;\n        }\n\n        public print(outfile: ITextWriter) {\n            super.print(outfile);\n            if (this.ambientValueMembers) {\n                this.ambientValueMembers.allMembers.map(function (key, sym, context) {\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n            if (this.valueMembers) {\n   ',
v27544=v27545+'             this.valueMembers.allMembers.map(function (key, sym, context) {\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n            if (this.ambientEnclosedTypes) {\n                this.ambientEnclosedTypes.allMembers.map(function (key, sym, context) {\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n            if (this.enclosedTypes) {\n                this.enclosedTypes.allMembers.map(function (key, sym, context) {\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n        }\n\n        public findImplementation(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym = this.find(name, publicOnly, typespace);\n            if (sym) {\n                if (sym.kind() == SymbolKind.Type) {\n                    var typeSym = <TypeSymbol>sym;\n                    if (!typeSym.type.hasImplementation()) {\n                        sym = null;\n                    }\n                }\n                else if (sym.container) {\n                    if (sym.container.kind() == SymbolKind.Type) {\n                        var ctypeSym = <TypeSymbol>sym.container;\n                        if (!ctypeSym.type.hasImplementation()) {\n                            sym = null;\n                        }\n                    }\n                }\n            }\n            return sym;\n        }\n\n        public getTable() {\n            return this.valueMembers.publicMembers;\n        }\n    }\n\n    export class SymbolScopeBuilder extends SymbolScope {\n        public container: Symbol;\n        \n        constructor (public valueMembers: ScopedMembers,\n                    public ambientValueMembers: ScopedMembers,\n                    public enclosedTypes: ScopedMembers,\n                    public ambientEnclosedTypes: ScopedMembers,\n                    public parent: SymbolScope,\n                    container: Symbol)\n        {\n            super(container);\n            this.container = container;\n        }\n\n        public printLabel() { return "builder"; }\n        public getAllSymbolNames(members: bool): string[]{\n            var result: string[] = this.getAllTypeSymbolNames(members);\n            return result.concat(this.getAllValueSymbolNames(members));\n        }\n\n        public getAllTypeSymbolNames(members: bool): string[]{\n            var result: string[] = [];\n            if (this.ambientEnclosedTypes) {\n                result = result.concat(this.ambientEnclosedTypes.allMembers.getAllKeys());\n            }\n            if (this.enclosedTypes) {\n                result = result.concat(this.enclosedTypes.allMembers.getAllKeys());\n            }\n            if (!members && this.parent) {\n                var parentResult = this.parent.getAllTypeSymbolNames(members);\n                if (parentResult) {\n                    result = result.concat(parentResult);\n                }\n            }\n            return result;\n        }\n\n        public getAllValueSymbolNames(members: bool): string[]{\n            var result: string[] = [];\n            if (this.ambientValueMembers) {\n                result = result.concat(this.ambientValueMembers.allMembers.getAllKeys());\n            }\n            if (this.valueMembers) {\n                result = result.concat(this.valueMembers.allMembers.getAllKeys());\n            }\n            if (!members && this.parent) {\n                var parentResult = this.parent.getAllValueSymbolNames(members);\n                if (parentResult) {\n                    result = result.concat(parentResult);\n                }\n            }\n            return result;\n        }\n\n        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool) {\n            var sym: Symbol = null;\n            var table = (this.valueMembers == null) ? null :\n                            publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;\n            var ambientTable = (this.ambientValueMembers == null) ? null :\n                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            if (typespace) {\n                table = (this.enclosedTypes == null) ? null :\n                            publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            if (ambientTable) {\n                if ((sym = ambientTable.lookup(name)) != null) {\n                    if (filter.update(sym)) {\n                        return sym;\n                    }\n                }\n            }\n            if (table) {\n                if ((sym = table.lookup(name)) != null) {\n                    if (filter.update(sym)) {\n                        return sym;\n                    }\n        ',
v27543=v27544+'        }\n            }\n            if (this.parent) {\n                sym = this.parent.search(filter, name, publicOnly, typespace);\n                if (sym) {\n                    if (filter.update(sym)) {\n                        return sym;\n                    }\n                }\n            }\n            return filter.result;\n        }\n\n        public print(outfile: ITextWriter) {\n            super.print(outfile);\n            if (this.ambientValueMembers) {\n                this.ambientValueMembers.allMembers.map(function (key, s, context) {\n                    var sym = <Symbol>s;\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n            if (this.valueMembers) {\n                this.valueMembers.allMembers.map(function (key, s, context) {\n                    var sym = <Symbol>s;\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n            if (this.ambientEnclosedTypes) {\n                this.ambientEnclosedTypes.allMembers.map(function (key, s, context) {\n                    var sym = <Symbol>s;\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n            if (this.enclosedTypes) {\n                this.enclosedTypes.allMembers.map(function (key, s, context) {\n                    var sym = <Symbol>s;\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n            if (this.parent) {\n                this.parent.print(outfile);\n            }\n        }\n\n        public find(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var table = (this.valueMembers == null) ? null :\n                            publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;\n            var ambientTable = (this.ambientValueMembers == null) ? null :\n                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            if (typespace) {\n                table = (this.enclosedTypes == null) ? null :\n                            publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            if (ambientTable && ((sym = ambientTable.lookup(name)) != null)) {\n                return sym;\n            }\n            if (table && ((sym = table.lookup(name)) != null)) {\n                return sym;\n            }\n            if (this.parent) {\n                return this.parent.find(name, publicOnly, typespace);\n            }\n            return null;\n        }\n\n        public findAmbient(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var ambientTable = (this.ambientValueMembers == null) ? null :\n                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            if (typespace) {\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            if (ambientTable && ((sym = ambientTable.lookup(name)) != null)) {\n                return sym;\n            }\n            if (this.parent) {\n                return this.parent.findAmbient(name, publicOnly, typespace);\n            }\n            return null;\n        }\n\n        public findLocal(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var table = (this.valueMembers == null) ? null :\n                            publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;\n            var ambientTable = (this.ambientValueMembers == null) ? null :\n                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            if (typespace) {\n                table = (this.enclosedTypes == null) ? null :\n                            publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            if (table) {\n                if ((sym = table.lookup(name)) != null) {\n                    if (sym) { return sym; }\n                }\n            }\n            if (ambientTable) {\n                if ((sym = ambientTable.lookup(name)) != null) {\n                    if (sym) { return sym; }\n                }\n            }\n            return null;\n        }\n\n        public enter(container: Symbol, ast: AST, symbol: Symbol, ',
v27542=v27543+'errorReporter: ErrorReporter, insertAsPublic: bool, typespace: bool, ambient: bool): void {\n            var table = null;\n\n            if (ambient) {\n                if (typespace) {\n                    table = (this.ambientEnclosedTypes == null) ? null :\n                                    insertAsPublic ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.privateMembers;\n                }\n                else {\n                    table = (this.ambientValueMembers == null) ? null :\n                                insertAsPublic ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.privateMembers;\n                }\n            }\n            else {\n                if (typespace) {\n                    table = (this.enclosedTypes == null) ? null :\n                                insertAsPublic ? this.enclosedTypes.publicMembers : this.enclosedTypes.privateMembers;\n                }\n                else {\n                    table = (this.valueMembers == null) ? null :\n                                insertAsPublic ? this.valueMembers.publicMembers : this.valueMembers.privateMembers;\n                }\n            }\n\n            if (table) {\n                if (!table.add(symbol.name, symbol)) {\n                    errorReporter.duplicateIdentifier(ast, symbol.name);\n                }\n            }\n            else {\n                CompilerDiagnostics.Alert("YYYYY");  // REVIEW: Surely we can do better than this...\n            }\n            symbol.container = container;\n        }\n\n        public getTable() { return this.valueMembers.allMembers; }\n    }\n\n    export class FilteredSymbolScope extends SymbolScope {\n        constructor (public scope: SymbolScope, container: Symbol, public filter: ScopeSearchFilter) {\n            super(container);\n        }\n        public print(outfile: ITextWriter) {\n            this.scope.print(outfile);\n        }\n\n        public find(name: string, publicOnly: bool, typespace: bool) {\n            this.filter.reset();\n            return this.scope.search(this.filter, name, publicOnly, typespace);\n        }\n        public findLocal(name: string, publicOnly: bool, typespace: bool) { return this.scope.findLocal(name, publicOnly, typespace); }\n    }\n\n    export class FilteredSymbolScopeBuilder extends SymbolScopeBuilder {\n        constructor (valueMembers: ScopedMembers, parent: SymbolScope, container: Symbol, public filter: (sym: Symbol) =>bool) {\n            super(valueMembers, null, null, null, parent, container);\n        }\n        public findLocal(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym = super.findLocal(name, publicOnly, typespace);\n            if (sym) {\n                if (!this.filter(sym)) {\n                    return null;\n                }\n            }\n            return sym;\n        }\n\n        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool):Symbol {\n            throw new Error("please implement");\n        }\n\n        public find(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym = super.findLocal(name, publicOnly, typespace);\n            if (sym) {\n                if (!this.filter(sym)) {\n                    return null;\n                }\n            }\n            return super.find(name, publicOnly, typespace);\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export enum TypeCheckStatus {\n        NotStarted,\n        Started,\n        Finished,\n    }\n\n    // For lexically-scoped constructs\n    export function aLexicallyEnclosesB(a: Symbol, b: Symbol) {\n        if (a.declAST && b && b.declAST && a.declAST.nodeType == NodeType.FuncDecl) {\n            return a.declAST.minChar <= b.declAST.minChar && a.declAST.limChar >= b.declAST.limChar;\n        }\n        else {\n            return false;\n        }\n    }\n\n    export function aEnclosesB(a: Symbol, b: Symbol) {\n        while (a.container) {\n            if (a == b || aLexicallyEnclosesB(a.container, b)) {\n                return true;\n            }\n            a = a.container;\n        }\n        return false;\n    }\n\n    export interface PhasedTypecheckObject {\n        typeCheckStatus: TypeCheckStatus;\n    }\n\n    export class Symbol {\n        public bound = false;\n        public container: Symbol;\n        public instanceScope(): SymbolScope { return null;',
v27541=v27542+' }\n        public isVariable() { return false; }\n        public isMember() { return false; }\n        public isInferenceSymbol() { return false; }\n        public isWith() { return false; }\n        public writeable() { return false; }\n        public isType(): bool { return false; }\n        public getType(): Type { return null; }\n        public flags: SymbolFlags = SymbolFlags.None;\n        public refs: Identifier[];\n        public isAccessor() { return false; }\n        public isObjectLitField = false;\n\n        public declAST: AST = null;\n        public declModule: ModuleDeclaration = null;  // if child of module, this is the module that declared it\n\n        public passSymbolCreated: number = CompilerDiagnostics.analysisPass;\n\n        constructor(public name: string, public location: number, public length: number,\n                 public unitIndex: number) { }\n\n        public isInstanceProperty() {\n            return hasFlag(this.flags, SymbolFlags.Property) && (!hasFlag(this.flags, SymbolFlags.ModuleMember));\n        }\n\n        public getTypeName(scope: SymbolScope): string {\n            return this.getTypeNameEx(scope).toString();\n        }\n        \n        public getTypeNameEx(scope: SymbolScope): MemberName {\n            return MemberName.create(this.toString());\n        }\n\n        public getOptionalNameString() {\n            return hasFlag(this.flags, SymbolFlags.Optional) ? "?" : "";\n        }\n\n        public pathToRoot() {\n            var path = new Symbol[];\n            var node = this;\n            while (node && (node.name != globalId)) {\n                path[path.length] = node;\n                node = node.container;\n            }\n            return path;\n        }\n\n        public findCommonAncestorPath(b: Symbol) {\n            if (this.container == null) {\n                return new Symbol[];\n            }\n            var aPath = this.container.pathToRoot();\n            var bPath: Symbol[];\n            if (b) {\n                bPath = b.pathToRoot();\n            }\n            else {\n                bPath = new Symbol[];\n            }\n            var commonNodeIndex = -1;\n            for (var i = 0, aLen = aPath.length; i < aLen; i++) {\n                var aNode = aPath[i];\n                for (var j = 0, bLen = bPath.length; j < bLen; j++) {\n                    var bNode = bPath[j];\n                    if (aNode == bNode) {\n                        commonNodeIndex = i;\n                        break;\n                    }\n                }\n                if (commonNodeIndex >= 0) {\n                    break;\n                }\n            }\n            if (commonNodeIndex >= 0) {\n                return aPath.slice(0, commonNodeIndex);\n            }\n            else {\n                return aPath;\n            }\n        }\n\n        // Gets the pretty Name for the symbol withing the scope\n        public getPrettyName(scopeSymbol: Symbol) {\n            return this.name;\n        }\n\n        public scopeRelativeName(scope: SymbolScope): string {\n            if (scope == null) {\n                return this.getPrettyName(null) + this.getOptionalNameString();\n            }\n            var lca = this.findCommonAncestorPath(scope.container);\n            var builder = "";\n            for (var i = 0, len = lca.length; i < len; i++) {\n                var prettyName = lca[i].getPrettyName(i == len - 1 ? scope.container : lca[i + 1]);\n                builder = prettyName + "." + builder;\n            }\n            builder += this.getPrettyName(len == 0 ? scope.container : lca[0]) + this.getOptionalNameString();\n            return builder;\n        }\n\n        public fullName(): string {\n            var builder = this.name;\n            var ancestor = this.container;\n            while (ancestor && (ancestor.name != globalId)) {\n                builder = ancestor.name + "." + builder;\n                ancestor = ancestor.container;\n            }\n            return builder;\n        }\n\n        public isExternallyVisible(checker: TypeChecker) {\n            // Global module is not hidden\n            if (this == checker.gloMod) {\n                return true;\n            }\n\n            // private symbol\n            if (hasFlag(this.flags, SymbolFlags.Private)) {\n                return false;\n            }\n\n            // If the current container is not exported\n            // If its in global - it is visible, otherwise it isn\'t\n            if (!hasFlag(this.flags, SymbolFlags.Exported)) {\n                return this.container == checker.gloMod;\n            }\n\n            // It is visible if its container is visible too\n            return this.container.isExternallyVisible(checker);\n        }\n\n        public visible(scope: SymbolScope, checker: TypeChecker) {\n            if (checker == null || this.container == checker.gloMod) {\n                return true;\n            }\n\n            if (hasFlag(this.flags, SymbolFlags.ModuleMember)) {\n\n                if (hasFlag(this.flags, SymbolFlags.Exported)) {\n                    if (!hasFlag',
v27540=v27541+'(this.flags, SymbolFlags.Private)) {\n                        return true;\n                    }\n                    else {\n                        return aEnclosesB(this, scope.container);\n                    }\n                }\n                else {\n                    // REVIEW:\n                    // Note that in the scope-assignment and binding phases,\n                    // currentModDecl will point to the "master" module decl,\n                    // and not necessarily the one that the symbol in question\n                    // was declared in.\n                    // That\'s ok - there\'s no harm done in attributing the symbol\n                    // to the master mod decl in either of those phases, so long\n                    // as we reference the actual module fragment of declaration\n                    // during typecheck.  Doing this also prevents us from printing\n                    // multiple error messages if the symbol is not visible.\n                    return checker && (checker.currentModDecl == this.declModule) ||\n                                                (checker.currentModDecl &&\n                                                    checker.currentModDecl.mod &&\n                                                    checker.currentModDecl.mod.symbol &&\n                                                    this.declModule &&\n                                                    this.declModule.mod &&\n                                                    this.declModule.mod.symbol &&\n                                                    aEnclosesB(checker.currentModDecl.mod.symbol, this.declModule.mod.symbol));\n                }\n            }\n            else {\n                // field or method\n                var isFunction = this.declAST && this.declAST.nodeType == NodeType.FuncDecl;\n                var isMethod = isFunction && (<FuncDecl>this.declAST).isMethod();\n                var isStaticFunction = isFunction && hasFlag((<FuncDecl>this.declAST).fncFlags, FncFlags.Static)\n                var isPrivateMethod = isMethod && hasFlag((<FuncDecl>this.declAST).fncFlags, FncFlags.Private);\n                var isAlias = this.isType() && (<TypeSymbol>this).aliasLink;\n\n                if (this.isMember() || isMethod || isStaticFunction || isAlias) {\n                    if (hasFlag(this.flags, SymbolFlags.Private) || isPrivateMethod) {\n                        if (scope.container == null && this.container != scope.container) {\n                            return false; // it\'s an inner member being accessed by the global scope\n                        }\n                        else {\n                            return this.container == null ? true : aEnclosesB(scope.container, this.container);\n                        }\n                    }\n                    else {\n                        return true;\n                    }\n                }\n                else if (this.container) {\n                    return aEnclosesB(this, scope.container);\n                }\n                else {\n                    return true;\n                }\n            }\n        }\n\n        public addRef(identifier: Identifier) {\n            if (!this.refs) {\n                this.refs = [];\n            }\n            this.refs[this.refs.length] = identifier;\n        }\n\n        public toString() {\n            if (this.name) {\n                return this.name;\n            }\n            else {\n                return "_anonymous";\n            }\n        }\n\n        public print(outfile) {\n            outfile.Write(this.toString());\n        }\n\n        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Symbol {\n            throw new Error("please implement in derived class");\n        }\n\n        public setType(type: Type) {\n            throw new Error("please implement in derived class");\n        }\n\n        public kind(): SymbolKind {\n            throw new Error("please implement in derived class");\n        }\n\n        public getInterfaceDeclFromSymbol(checker: TypeChecker) {\n            if (this.declAST != null) {\n                if (this.declAST.nodeType == NodeType.InterfaceDeclaration) {\n                    return <InterfaceDeclaration>this.declAST;\n                } else if (this.container != null && this.container != checker.gloMod && this.container.declAST.nodeType == NodeType.InterfaceDeclaration) {\n                    return <InterfaceDeclaration>this.container.declAST;\n                }\n            }\n\n            return null;\n        }\n\n        public getVarDeclFromSymbol() {\n            if (this.declAST != null && this.declAST.nodeType == NodeType.VarDecl) {\n                return <VarDecl>this.declAST;\n            }\n\n            return null;\n        }\n\n        public getDocComments() : Comment[] {\n            if (this.declAST != null) {\n                return this.declAST.getDocComments();\n            }\n\n            return [];\n        }\n\n        public isStatic() {\n            return hasFlag(this.fla',
v27539=v27540+'gs, SymbolFlags.Static);\n        }\n    }\n\n    export class ValueLocation {\n        public symbol: Symbol;\n        public typeLink: TypeLink;\n    }\n\n    export class InferenceSymbol extends Symbol {\n        constructor (name: string, location: number, length: number, unitIndex: number) {\n            super(name, location, length, unitIndex);\n        }\n\n        public typeCheckStatus = TypeCheckStatus.NotStarted;\n        public isInferenceSymbol() { return true; }\n        public transferVarFlags(varFlags: VarFlags) {\n            if (hasFlag(varFlags, VarFlags.Ambient)) {\n                this.flags |= SymbolFlags.Ambient;\n            }\n            if (hasFlag(varFlags, VarFlags.Constant)) {\n                this.flags |= SymbolFlags.Constant;\n            }\n            if (hasFlag(varFlags, VarFlags.Static)) {\n                this.flags |= SymbolFlags.Static;\n            }\n            if (hasFlag(varFlags, VarFlags.Property)) {\n                this.flags |= SymbolFlags.Property;\n            }\n            if (hasFlag(varFlags, VarFlags.Private)) {\n                this.flags |= SymbolFlags.Private;\n            }\n            if (hasFlag(varFlags, VarFlags.Public)) {\n                this.flags |= SymbolFlags.Public;\n            }\n            if (hasFlag(varFlags, VarFlags.Readonly)) {\n                this.flags |= SymbolFlags.Readonly;\n            }\n            if (hasFlag(varFlags, VarFlags.Exported)) {\n                this.flags |= SymbolFlags.Exported;\n            }\n        }\n    }\n\n    export class TypeSymbol extends InferenceSymbol {\n        public additionalLocations: number[];\n        public expansions: Type[] = []; // For types that may be "split", keep track of the subsequent definitions\n        public expansionsDeclAST: AST[] = [];\n        public isDynamic = false;\n\n        constructor (locName: string, location: number, length: number, unitIndex: number, public type: Type) {\n            super(locName, location, length, unitIndex);\n            this.prettyName = this.name;\n        }\n\n        public addLocation(loc: number) {\n            if (this.additionalLocations == null) {\n                this.additionalLocations = [];\n            }\n            this.additionalLocations[this.additionalLocations.length] = loc;\n        }\n        public isMethod = false;\n        public aliasLink:ImportDeclaration = null;\n        public kind() { return SymbolKind.Type; }\n        public isType(): bool { return true; }\n        public getType() { return this.type; }\n        public prettyName: string;\n        public onlyReferencedAsTypeRef = optimizeModuleCodeGen;\n\n        public getTypeNameEx(scope: SymbolScope) {\n            return this.type.getMemberTypeNameEx(this.name ? this.name + this.getOptionalNameString() : "", false, false, scope);\n        }\n\n        public instanceScope(): SymbolScope {\n            // Don\'t use the constructor scope for a class body or methods - use the contained scope\n            if (!(this.type.typeFlags & TypeFlags.IsClass) && this.type.isClass()) {\n                return this.type.instanceType.constructorScope;\n            }\n            else {\n                return this.type.containedScope;\n            }\n        }\n        // corresponding instance type if this is a class\n        public instanceType: Type;\n\n        public toString() {\n            var result = this.type.getTypeName();\n            if (this.name) {\n                result = this.name + ":" + result;\n            }\n            return result;\n        }\n\n        public isClass() { return this.instanceType != null; }\n        public isFunction() { return this.declAST != null && this.declAST.nodeType == NodeType.FuncDecl; }\n\n        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Symbol {\n            if (this.type == pattern) {\n                return replacement.symbol;\n            }\n            else {\n                var replType = this.type.specializeType(pattern, replacement, checker, false);\n                if (replType != this.type) {\n                    var result = new TypeSymbol(this.name, -1, 0, -1, replType);\n                    return result;\n                }\n                else {\n                    return this;\n                }\n            }\n        }\n\n        // Gets the pretty name of the symbol with respect to symbol of the scope (scopeSymbol)\n        // searchTillRoot specifies if the name need to searched in the root path of the scope\n        public getPrettyName(scopeSymbol: Symbol) {\n            if (!!scopeSymbol && isQuoted(this.prettyName) && this.type.isModuleType()) {\n                // Its a dynamic module - and need to be specialized with the scope\n                // Check in exported module members in each scope\n                var symbolPath = scopeSymbol.pathToRoot();\n                var prettyName = this.getPrettyNameOfDynamicModule(symbolPath);\n                if (prettyName != null) {\n                    return prettyName.name;\n                }\n            }\n\n            retur',
v27538=v27539+'n this.prettyName;\n        }\n\n        public getPrettyNameOfDynamicModule(scopeSymbolPath: Symbol[]) {\n            var scopeSymbolPathLength = scopeSymbolPath.length;\n            var externalSymbol: { name: string; symbol: Symbol; } = null;\n            if (scopeSymbolPath.length > 0 &&\n                scopeSymbolPath[scopeSymbolPathLength - 1].getType().isModuleType() &&\n                (<TypeSymbol>scopeSymbolPath[scopeSymbolPathLength - 1]).isDynamic) {\n\n                // Check if submodule is dynamic\n                if (scopeSymbolPathLength > 1 &&\n                    scopeSymbolPath[scopeSymbolPathLength - 2].getType().isModuleType() &&\n                    (<TypeSymbol>scopeSymbolPath[scopeSymbolPathLength - 2]).isDynamic) {\n                    var moduleType = <ModuleType>scopeSymbolPath[scopeSymbolPathLength - 2].getType();\n                    externalSymbol = moduleType.findDynamicModuleName(this.type);\n\n                }\n\n                if (externalSymbol == null) {\n                    // Check in this module\n                    var moduleType = <ModuleType>scopeSymbolPath[scopeSymbolPathLength - 1].getType();\n                    externalSymbol = moduleType.findDynamicModuleName(this.type);\n                }\n            }\n\n            return externalSymbol;\n        }\n\n        public getDocComments(): Comment[]{\n            var comments : Comment[] = [];\n            if (this.declAST != null) {\n                comments = comments.concat(this.declAST.getDocComments());\n            }\n\n            for (var i = 0; i < this.expansionsDeclAST.length; i++) {\n                comments = comments.concat(this.expansionsDeclAST[i].getDocComments());\n            }\n\n            return comments;\n        }\n    }\n\n    export class WithSymbol extends TypeSymbol {\n        constructor (location: number, unitIndex: number, withType: Type) {\n            super("with", location, 4, unitIndex, withType);\n        }\n        public isWith() { return true; }\n    }\n\n    export class FieldSymbol extends InferenceSymbol {\n        public name: string;\n        public location: number;\n\n        constructor (name: string, location: number, unitIndex: number, public canWrite: bool,\n                      public field: ValueLocation) {\n\n            super(name, location, name.length, unitIndex);\n            this.name = name;\n            this.location = location;\n        }\n        public kind() { return SymbolKind.Field; }\n        public writeable() { return this.isAccessor() ? this.setter != null : this.canWrite; }\n        public getType() { return this.field.typeLink.type; }\n        public getTypeNameEx(scope: SymbolScope) {\n            return MemberName.create(this.field.typeLink.type.getScopedTypeNameEx(scope), this.name + this.getOptionalNameString() + ": ", "");\n        }\n\n        public isMember() { return true; }\n        public setType(type: Type) {\n            this.field.typeLink.type = type;\n        }\n\n        public getter: TypeSymbol = null;\n        public setter: TypeSymbol = null;\n        public hasBeenEmitted = false; // since getters and setters are emitted together, need to track if one has been emitted\n\n        public isAccessor() { return this.getter != null || this.setter != null; }\n\n        public isVariable() { return true; }\n        public toString() { return this.getTypeNameEx(null).toString(); }\n        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Symbol {\n            var rType = this.field.typeLink.type.specializeType(pattern, replacement, checker, false);\n            if (rType != this.field.typeLink.type) {\n                var fieldDef = new ValueLocation();\n                var result = new FieldSymbol(this.name, 0, checker.locationInfo.unitIndex,\n                                           this.canWrite, fieldDef);\n                result.flags = this.flags;\n                fieldDef.symbol = result;\n                fieldDef.typeLink = new TypeLink();\n                result.setType(rType);\n                result.typeCheckStatus = TypeCheckStatus.Finished;\n                return result;\n            }\n            else {\n                return this;\n            }\n        }\n\n        public getDocComments(): Comment[] {\n            if (this.getter != null || this.setter != null) {\n                var comments : Comment[] = [];\n                if (this.getter != null) {\n                    comments = comments.concat(this.getter.getDocComments());\n                }\n                if (this.setter != null) {\n                    comments = comments.concat(this.setter.getDocComments());\n                }\n                return comments;\n            }\n            else if (this.declAST != null) {\n                return this.declAST.getDocComments();\n            }\n\n            return [];\n        }\n\n    }\n\n    export class ParameterSymbol extends InferenceSymbol {\n        public name: string;\n        public location: number;\n        private paramDocComment: string = null;\n        public funcDecl',
v27537=v27538+': AST = null;\n        \n        constructor (name: string, location: number, unitIndex: number,\n                          public parameter: ValueLocation) {\n            super(name, location, name.length, unitIndex);\n\n            this.name = name;\n            this.location = location;\n        }\n        public kind() { return SymbolKind.Parameter; }\n        public writeable() { return true; }\n        public getType() { return this.parameter.typeLink.type; }\n        public setType(type: Type) {\n            this.parameter.typeLink.type = type;\n        }\n        public isVariable() { return true; }\n        public argsOffset = (-1);\n        public isOptional() {\n            if (this.parameter && this.parameter.symbol && this.parameter.symbol.declAST) {\n                return (<ArgDecl>this.parameter.symbol.declAST).isOptional;\n            }\n            else {\n                return false;\n            }\n        }\n\n        public getTypeNameEx(scope: SymbolScope) {\n            return MemberName.create(this.getType().getScopedTypeNameEx(scope), this.name + (this.isOptional() ? "?" : "") + ": ", "");\n        }\n\n        public toString() { return this.getTypeNameEx(null).toString(); }\n\n        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Symbol {\n            var rType = this.parameter.typeLink.type.specializeType(pattern, replacement, checker, false);\n            if (this.parameter.typeLink.type != rType) {\n                var paramDef = new ValueLocation();\n                var result = new ParameterSymbol(this.name, 0, checker.locationInfo.unitIndex,\n                                               paramDef);\n                paramDef.symbol = result;\n                result.setType(rType);\n                return result;\n            }\n            else {\n                return this;\n            }\n        }\n\n        public getParameterDocComments() {\n            if (!this.paramDocComment) {\n                var parameterComments: string[] = [];\n                if (this.funcDecl) {\n                    var fncDocComments = this.funcDecl.getDocComments();\n                    var paramComment = Comment.getParameterDocCommentText(this.name, fncDocComments);\n                    if (paramComment != "") {\n                        parameterComments.push(paramComment);\n                    }\n                }\n                var docComments = TypeScript.Comment.getDocCommentText(this.getDocComments());\n                if (docComments != "") {\n                    parameterComments.push(docComments);\n                }\n                \n                this.paramDocComment = parameterComments.join("\\n");\n            }\n\n            return this.paramDocComment;\n        }\n    }\n\n    export class VariableSymbol extends InferenceSymbol {\n\n        constructor (name: string, location: number, unitIndex: number, public variable: ValueLocation) {\n            super(name, location, name.length, unitIndex);\n        }\n        public kind() { return SymbolKind.Variable; }\n        public writeable() { return true; }\n        public getType() { return this.variable.typeLink.type; }\n        public getTypeNameEx(scope: SymbolScope) {\n            return MemberName.create(this.getType().getScopedTypeNameEx(scope), this.name + ": ", "");\n        }\n\n        public setType(type: Type) {\n            this.variable.typeLink.type = type;\n        }\n        public isVariable() { return true; }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export enum TokenID {\n        // Keywords\n        Any,\n        Bool,\n        Break,\n        Case,\n        Catch,\n        Class,\n        Const,\n        Continue,\n        Debugger,\n        Default,\n        Delete,\n        Do,\n        Else,\n        Enum,\n        Export,\n        Extends,\n        Declare,\n        False,\n        Finally,\n        For,\n        Function,\n        Constructor,\n        Get,\n        If,\n        Implements,\n        Import,\n        In,\n        InstanceOf,\n        Interface,\n        Let,\n        Module,\n        New,\n        Number,\n        Null,\n        Package,\n        Private,\n        Protected,\n        Public,\n        Return,\n        Set,\n        Static,\n        String,\n        Super,\n        Switch,\n        This,\n        Throw,\n        True,\n        Try,\n        TypeOf,\n        Var,\n        Void,\n        With,\n        While,\n        Yield,\n      ',
v27536=v27537+'  // Punctuation\n        Semicolon,\n        OpenParen,\n        CloseParen,\n        OpenBracket,\n        CloseBracket,\n        OpenBrace,\n        CloseBrace,\n        Comma,\n        Equals,\n        PlusEquals,\n        MinusEquals,\n        AsteriskEquals,\n        SlashEquals,\n        PercentEquals,\n        AmpersandEquals,\n        CaretEquals,\n        BarEquals,\n        LessThanLessThanEquals,\n        GreaterThanGreaterThanEquals,\n        GreaterThanGreaterThanGreaterThanEquals,\n        Question,\n        Colon,\n        BarBar,\n        AmpersandAmpersand,\n        Bar,\n        Caret,\n        And,\n        EqualsEquals,\n        ExclamationEquals,\n        EqualsEqualsEquals,\n        ExclamationEqualsEquals,\n        LessThan,\n        LessThanEquals,\n        GreaterThan,\n        GreaterThanEquals,\n        LessThanLessThan,\n        GreaterThanGreaterThan,\n        GreaterThanGreaterThanGreaterThan,\n        Plus,\n        Minus,\n        Asterisk,\n        Slash,\n        Percent,\n        Tilde,\n        Exclamation,\n        PlusPlus,\n        MinusMinus,\n        Dot,\n        DotDotDot,\n        Error,\n        EndOfFile,\n        EqualsGreaterThan,\n        Identifier,\n        StringLiteral,\n        RegularExpressionLiteral,\n        NumberLiteral,\n        Whitespace,\n        Comment,\n        Lim,\n        LimFixed = EqualsGreaterThan,\n        LimKeyword = Yield,\n    }\n\n    export var tokenTable = new TokenInfo[];\n    export var nodeTypeTable = new string[];\n    export var nodeTypeToTokTable = new number[];\n    export var noRegexTable = new bool[];\n\n    noRegexTable[TokenID.Identifier] = true;\n    noRegexTable[TokenID.StringLiteral] = true;\n    noRegexTable[TokenID.NumberLiteral] = true;\n    noRegexTable[TokenID.RegularExpressionLiteral] = true;\n    noRegexTable[TokenID.This] = true;\n    noRegexTable[TokenID.PlusPlus] = true;\n    noRegexTable[TokenID.MinusMinus] = true;\n    noRegexTable[TokenID.CloseParen] = true;\n    noRegexTable[TokenID.CloseBracket] = true;\n    noRegexTable[TokenID.CloseBrace] = true;\n    noRegexTable[TokenID.True] = true;\n    noRegexTable[TokenID.False] = true;\n\n    export enum OperatorPrecedence {\n        None,\n        Comma,\n        Assignment,\n        Conditional,\n        LogicalOr,\n        LogicalAnd,\n        BitwiseOr,\n        BitwiseExclusiveOr,\n        BitwiseAnd,\n        Equality,\n        Relational,\n        Shift,\n        Additive,\n        Multiplicative,\n        Unary,\n        Lim\n    }\n\n    export enum Reservation {\n        None = 0,\n        Javascript = 1,\n        JavascriptFuture = 2,\n        TypeScript = 4,\n        JavascriptFutureStrict = 8,\n        TypeScriptAndJS = Javascript | TypeScript,\n        TypeScriptAndJSFuture = JavascriptFuture | TypeScript,\n        TypeScriptAndJSFutureStrict = JavascriptFutureStrict | TypeScript,\n    }\n\n    export class TokenInfo {\n        constructor (public tokenId: TokenID, public reservation: Reservation,\n                    public binopPrecedence: number, public binopNodeType: number,\n                    public unopPrecedence: number, public unopNodeType: number,\n                    public text: string, public ers: ErrorRecoverySet) { }\n    }\n\n    function setTokenInfo(tokenId: TokenID, reservation: number, binopPrecedence: number,\n        binopNodeType: number, unopPrecedence: number, unopNodeType: number,\n        text: string, ers: ErrorRecoverySet) {\n        if (tokenId !== undefined) {\n            tokenTable[tokenId] = new TokenInfo(tokenId, reservation, binopPrecedence,\n                                              binopNodeType, unopPrecedence, unopNodeType, text, ers);\n            if (binopNodeType != NodeType.None) {\n                nodeTypeTable[binopNodeType] = text;\n                nodeTypeToTokTable[binopNodeType] = tokenId;\n            }\n            if (unopNodeType != NodeType.None) {\n                nodeTypeTable[unopNodeType] = text;\n            }\n        }\n    }\n\n    setTokenInfo(TokenID.Any, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "any", ErrorRecoverySet.PrimType);\n    setTokenInfo(TokenID.Bool, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "bool", ErrorRecoverySet.PrimType);\n    setTokenInfo(TokenID.Break, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "break", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.Case, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "case", ErrorRecoverySet.SCase);\n    setTokenInfo(TokenID.Catch, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "catch", ErrorRecoverySet.Catch);\n    setTokenInfo(TokenID.Class, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "class", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.Const, Reservation.TypeScri',
v27535=v27536+'ptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "const", ErrorRecoverySet.Var);\n    setTokenInfo(TokenID.Continue, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "continue", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.Debugger, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.Debugger, "debugger", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.Default, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "default", ErrorRecoverySet.SCase);\n    setTokenInfo(TokenID.Delete, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.Delete, "delete", ErrorRecoverySet.Prefix);\n    setTokenInfo(TokenID.Do, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "do", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.Else, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "else", ErrorRecoverySet.Else);\n    setTokenInfo(TokenID.Enum, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "enum", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.Export, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "export", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.Extends, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "extends", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.Declare, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "declare", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.False, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "false", ErrorRecoverySet.RLit);\n    setTokenInfo(TokenID.Finally, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "finally", ErrorRecoverySet.Catch);\n    setTokenInfo(TokenID.For, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "for", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.Function, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "function", ErrorRecoverySet.Func);\n    setTokenInfo(TokenID.Constructor, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "constructor", ErrorRecoverySet.Func);\n    setTokenInfo(TokenID.Get, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "get", ErrorRecoverySet.Func);\n    setTokenInfo(TokenID.Set, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "set", ErrorRecoverySet.Func);\n    setTokenInfo(TokenID.If, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "if", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.Implements, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "implements", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.Import, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "import", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.In, Reservation.TypeScriptAndJS, OperatorPrecedence.Relational, NodeType.In, OperatorPrecedence.None, NodeType.None, "in", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.InstanceOf, Reservation.TypeScriptAndJS, OperatorPrecedence.Relational, NodeType.InstOf, OperatorPrecedence.None, NodeType.None, "instanceof", ErrorRecoverySet.BinOp);\n    setTokenInfo(TokenID.Interface, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "interface", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.Let, Reservation.JavascriptFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "let", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.Module, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "module", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.New, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "new", ErrorRecoverySet.PreOp);\n    setTokenInfo(TokenID.Number, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "number", ErrorRecoverySet.PrimType);\n    setTokenInfo(TokenID.Nu',
v27534=v27535+'ll, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "null", ErrorRecoverySet.RLit);\n    setTokenInfo(TokenID.Package, Reservation.JavascriptFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "package", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.Private, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "private", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.Protected, Reservation.JavascriptFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "protected", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.Public, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "public", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.Return, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "return", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.Static, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "static", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.String, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "string", ErrorRecoverySet.PrimType);\n    setTokenInfo(TokenID.Super, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "super", ErrorRecoverySet.RLit);\n    setTokenInfo(TokenID.Switch, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "switch", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.This, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "this", ErrorRecoverySet.RLit);\n    setTokenInfo(TokenID.Throw, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "throw", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.True, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "true", ErrorRecoverySet.RLit);\n    setTokenInfo(TokenID.Try, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "try", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.TypeOf, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.Typeof, "typeof", ErrorRecoverySet.Prefix);\n    setTokenInfo(TokenID.Var, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "var", ErrorRecoverySet.Var);\n    setTokenInfo(TokenID.Void, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.Void, "void", ErrorRecoverySet.Prefix);\n    setTokenInfo(TokenID.With, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.With, "with", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.While, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "while", ErrorRecoverySet.While);\n    setTokenInfo(TokenID.Yield, Reservation.JavascriptFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "yield", ErrorRecoverySet.None);\n\n    setTokenInfo(TokenID.Identifier, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "identifier", ErrorRecoverySet.ID);\n    setTokenInfo(TokenID.NumberLiteral, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "numberLiteral", ErrorRecoverySet.Literal);\n    setTokenInfo(TokenID.RegularExpressionLiteral, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "regex", ErrorRecoverySet.RegExp);\n    setTokenInfo(TokenID.StringLiteral, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "qstring", ErrorRecoverySet.Literal);\n\n    // Non-operator non-identifier tokens\n    setTokenInfo(TokenID.Semicolon, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, ";", ErrorRecoverySet.SColon); // ;\n    setTokenInfo(TokenID.CloseParen, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, ")", ErrorRecoverySet.RParen); // )\n    setTokenInfo(TokenID.CloseBracket, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "]", ErrorRecoverySet.RBrack); // ]\n    setTokenInfo(TokenID.OpenBrace, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "{", ErrorRecoverySet.LCurly); // {\n    setToken',
v27533=v27534+'Info(TokenID.CloseBrace, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "}", ErrorRecoverySet.RCurly); // }\n    setTokenInfo(TokenID.DotDotDot, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "...", ErrorRecoverySet.None); // ...\n\n    // Operator non-identifier tokens\n    setTokenInfo(TokenID.Comma, Reservation.None, OperatorPrecedence.Comma, NodeType.Comma, OperatorPrecedence.None, NodeType.None, ",", ErrorRecoverySet.Comma); // ,\n    setTokenInfo(TokenID.Equals, Reservation.None, OperatorPrecedence.Assignment, NodeType.Asg, OperatorPrecedence.None, NodeType.None, "=", ErrorRecoverySet.Asg); // =\n    setTokenInfo(TokenID.PlusEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgAdd, OperatorPrecedence.None, NodeType.None, "+=", ErrorRecoverySet.BinOp); // +=\n    setTokenInfo(TokenID.MinusEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgSub, OperatorPrecedence.None, NodeType.None, "-=", ErrorRecoverySet.BinOp); // -=\n    setTokenInfo(TokenID.AsteriskEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgMul, OperatorPrecedence.None, NodeType.None, "*=", ErrorRecoverySet.BinOp); // *=\n\n    setTokenInfo(TokenID.SlashEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgDiv, OperatorPrecedence.None, NodeType.None, "/=", ErrorRecoverySet.BinOp); // /=\n    setTokenInfo(TokenID.PercentEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgMod, OperatorPrecedence.None, NodeType.None, "%=", ErrorRecoverySet.BinOp); // %=\n    setTokenInfo(TokenID.AmpersandEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgAnd, OperatorPrecedence.None, NodeType.None, "&=", ErrorRecoverySet.BinOp); // &=\n    setTokenInfo(TokenID.CaretEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgXor, OperatorPrecedence.None, NodeType.None, "^=", ErrorRecoverySet.BinOp); // ^=\n    setTokenInfo(TokenID.BarEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgOr, OperatorPrecedence.None, NodeType.None, "|=", ErrorRecoverySet.BinOp); // |=\n    setTokenInfo(TokenID.LessThanLessThanEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgLsh, OperatorPrecedence.None, NodeType.None, "<<=", ErrorRecoverySet.BinOp); // <<=\n    setTokenInfo(TokenID.GreaterThanGreaterThanEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgRsh, OperatorPrecedence.None, NodeType.None, ">>=", ErrorRecoverySet.BinOp); // >>=\n    setTokenInfo(TokenID.GreaterThanGreaterThanGreaterThanEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgRs2, OperatorPrecedence.None, NodeType.None, ">>>=", ErrorRecoverySet.BinOp); // >>>=\n    setTokenInfo(TokenID.Question, Reservation.None, OperatorPrecedence.Conditional, NodeType.ConditionalExpression, OperatorPrecedence.None, NodeType.None, "?", ErrorRecoverySet.BinOp); // ?\n    setTokenInfo(TokenID.Colon, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, ":", ErrorRecoverySet.Colon); // :\n    setTokenInfo(TokenID.BarBar, Reservation.None, OperatorPrecedence.LogicalOr, NodeType.LogOr, OperatorPrecedence.None, NodeType.None, "||", ErrorRecoverySet.BinOp); // ||\n    setTokenInfo(TokenID.AmpersandAmpersand, Reservation.None, OperatorPrecedence.LogicalAnd, NodeType.LogAnd, OperatorPrecedence.None, NodeType.None, "&&", ErrorRecoverySet.BinOp); // &&\n    setTokenInfo(TokenID.Bar, Reservation.None, OperatorPrecedence.BitwiseOr, NodeType.Or, OperatorPrecedence.None, NodeType.None, "|", ErrorRecoverySet.BinOp); // |\n    setTokenInfo(TokenID.Caret, Reservation.None, OperatorPrecedence.BitwiseExclusiveOr, NodeType.Xor, OperatorPrecedence.None, NodeType.None, "^", ErrorRecoverySet.BinOp); // ^\n    setTokenInfo(TokenID.And, Reservation.None, OperatorPrecedence.BitwiseAnd, NodeType.And, OperatorPrecedence.None, NodeType.None, "&", ErrorRecoverySet.BinOp); // &\n    setTokenInfo(TokenID.EqualsEquals, Reservation.None, OperatorPrecedence.Equality, NodeType.Eq, OperatorPrecedence.None, NodeType.None, "==", ErrorRecoverySet.BinOp); // ==\n    setTokenInfo(TokenID.ExclamationEquals, Reservation.None, OperatorPrecedence.Equality, NodeType.Ne, OperatorPrecedence.None, NodeType.None, "!=", ErrorRecoverySet.BinOp); // !=\n    setTokenInfo(TokenID.EqualsEqualsEquals, Reservation.None, OperatorPrecedence.Equality, NodeType.Eqv, OperatorPrecedence.None, NodeType.None, "===", ErrorRecoverySet.BinOp); // ===\n    setTokenInfo(TokenID.ExclamationEqualsEquals, Reservation.None, OperatorPrecedence.Equality, NodeType.NEqv, OperatorPrecedence.None, NodeType.None, "!==", ErrorRecoverySet.BinOp); // !==\n    setTokenInfo(TokenID.LessThan, Reservation.None, OperatorPrecedence.Relational, NodeType.Lt, OperatorPrecedence.None, NodeType.None, "<", ErrorRecoverySet.BinOp); // <\n    setTokenInfo(TokenID.LessThanEquals, Reservation.None, OperatorPrecedence.Relational, NodeTyp',
v27532=v27533+'e.Le, OperatorPrecedence.None, NodeType.None, "<=", ErrorRecoverySet.BinOp); // <=\n    setTokenInfo(TokenID.GreaterThan, Reservation.None, OperatorPrecedence.Relational, NodeType.Gt, OperatorPrecedence.None, NodeType.None, ">", ErrorRecoverySet.BinOp); // >\n    setTokenInfo(TokenID.GreaterThanEquals, Reservation.None, OperatorPrecedence.Relational, NodeType.Ge, OperatorPrecedence.None, NodeType.None, ">=", ErrorRecoverySet.BinOp); // >=\n    setTokenInfo(TokenID.LessThanLessThan, Reservation.None, OperatorPrecedence.Shift, NodeType.Lsh, OperatorPrecedence.None, NodeType.None, "<<", ErrorRecoverySet.BinOp); // <<\n    setTokenInfo(TokenID.GreaterThanGreaterThan, Reservation.None, OperatorPrecedence.Shift, NodeType.Rsh, OperatorPrecedence.None, NodeType.None, ">>", ErrorRecoverySet.BinOp); // >>\n    setTokenInfo(TokenID.GreaterThanGreaterThanGreaterThan, Reservation.None, OperatorPrecedence.Shift, NodeType.Rs2, OperatorPrecedence.None, NodeType.None, ">>>", ErrorRecoverySet.BinOp); // >>>\n    setTokenInfo(TokenID.Plus, Reservation.None, OperatorPrecedence.Additive, NodeType.Add, OperatorPrecedence.Unary, NodeType.Pos, "+", ErrorRecoverySet.AddOp); // +\n    setTokenInfo(TokenID.Minus, Reservation.None, OperatorPrecedence.Additive, NodeType.Sub, OperatorPrecedence.Unary, NodeType.Neg, "-", ErrorRecoverySet.AddOp); // -\n    setTokenInfo(TokenID.Asterisk, Reservation.None, OperatorPrecedence.Multiplicative, NodeType.Mul, OperatorPrecedence.None, NodeType.None, "*", ErrorRecoverySet.BinOp); // *\n    setTokenInfo(TokenID.Slash, Reservation.None, OperatorPrecedence.Multiplicative, NodeType.Div, OperatorPrecedence.None, NodeType.None, "/", ErrorRecoverySet.BinOp); // /\n    setTokenInfo(TokenID.Percent, Reservation.None, OperatorPrecedence.Multiplicative, NodeType.Mod, OperatorPrecedence.None, NodeType.None, "%", ErrorRecoverySet.BinOp); // %\n    setTokenInfo(TokenID.Tilde, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.Not, "~", ErrorRecoverySet.PreOp); // ~\n    setTokenInfo(TokenID.Exclamation, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.LogNot, "!", ErrorRecoverySet.PreOp); // !\n    setTokenInfo(TokenID.PlusPlus, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.IncPre, "++", ErrorRecoverySet.PreOp); // ++\n    setTokenInfo(TokenID.MinusMinus, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.DecPre, "--", ErrorRecoverySet.PreOp); // --\n    setTokenInfo(TokenID.OpenParen, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "(", ErrorRecoverySet.LParen); // (\n    setTokenInfo(TokenID.OpenBracket, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "[", ErrorRecoverySet.LBrack); // [\n    setTokenInfo(TokenID.Dot, Reservation.None, OperatorPrecedence.Unary, NodeType.None, OperatorPrecedence.None, NodeType.None, ".", ErrorRecoverySet.Dot); // .\n    setTokenInfo(TokenID.EndOfFile, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "<EOF>", ErrorRecoverySet.EOF); // EOF\n    setTokenInfo(TokenID.EqualsGreaterThan, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "=>", ErrorRecoverySet.None); // =>\n\n    export function lookupToken(tokenId: TokenID): TokenInfo {\n        return tokenTable[tokenId];\n    }\n\n    export enum TokenClass {\n        Punctuation,\n        Keyword,\n        Operator,\n        Comment,\n        Whitespace,\n        Identifier,\n        NumberLiteral,\n        StringLiteral,\n        RegExpLiteral,\n    }\n\n    export class SavedToken {\n        constructor (public tok: Token, public minChar: number, public limChar: number) { }\n    }\n\n    export class Token {\n        constructor (public tokenId: TokenID) {\n        }\n\n        public toString() {\n            return "token: " + this.tokenId + " " + this.getText() + " (" + (<any>TokenID)._map[this.tokenId] + ")";\n        }\n\n        public print(line: number, outfile) {\n            outfile.WriteLine(this.toString() + ",on line" + line);\n        }\n\n        public getText(): string {\n            return tokenTable[this.tokenId].text;\n        }\n\n        public classification(): TokenClass {\n            if (this.tokenId <= TokenID.LimKeyword) {\n                return TokenClass.Keyword;\n            }\n            else {\n                var tokenInfo = lookupToken(this.tokenId);\n                if (tokenInfo != undefined) {\n                    if ((tokenInfo.unopNodeType != NodeType.None) ||\n                        (tokenInfo.binopNodeType != NodeType.None)) {\n                        return TokenClass.Operator;\n                    }\n                }\n            }\n\n            return TokenClass.Punctuation;\n        }\n    }\n\n    export class NumberLiteralToken extends Token {\n        constructor (public value: number,',
v27531=v27532+' public hasEmptyFraction?: bool) {\n            super(TokenID.NumberLiteral);\n        }\n\n        public getText(): string {\n            return this.hasEmptyFraction ? this.value.toString() + ".0" : this.value.toString();\n        }\n\n        public classification(): TokenClass {\n            return TokenClass.NumberLiteral;\n        }\n    }\n\n    export class StringLiteralToken extends Token {\n        constructor (public value: string) {\n            super(TokenID.StringLiteral);\n        }\n\n        public getText(): string {\n            return this.value;\n        }\n\n        public classification(): TokenClass {\n            return TokenClass.StringLiteral;\n        }\n    }\n\n    export class IdentifierToken extends Token {\n        constructor (public value: string, public hasEscapeSequence : bool) {\n            super(TokenID.Identifier);\n        }\n        public getText(): string {\n            return this.value;\n        }\n        public classification(): TokenClass {\n            return TokenClass.Identifier;\n        }\n    }\n\n    export class WhitespaceToken extends Token {\n        constructor (tokenId: TokenID, public value: string) {\n            super(tokenId);\n        }\n\n        public getText(): string {\n            return this.value;\n        }\n\n        public classification(): TokenClass {\n            return TokenClass.Whitespace;\n        }\n    }\n\n    export class CommentToken extends Token {\n        constructor (tokenID: TokenID, public value: string, public isBlock: bool, public startPos: number, public line: number, public endsLine: bool) {\n            super(tokenID);\n        }\n\n        public getText(): string {\n            return this.value;\n        }\n\n        public classification(): TokenClass {\n            return TokenClass.Comment;\n        }\n    }\n\n    export class RegularExpressionLiteralToken extends Token {\n        constructor(public regex) {\n            super(TokenID.RegularExpressionLiteral);\n        }\n\n        public getText(): string {\n            return this.regex.toString();\n        }\n\n        public classification(): TokenClass {\n            return TokenClass.RegExpLiteral;\n        }\n    }\n\n    // TODO: new with length TokenID.LimFixed\n    export var staticTokens = new Token[];\n    export function initializeStaticTokens() {\n        for (var i = 0; i <= TokenID.LimFixed; i++) {\n            staticTokens[i] = new Token(i);\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\'/>\n///<reference path=\'io.ts\'/>\n///<reference path=\'optionsParser.ts\'/>\n\nclass CommandLineHost implements TypeScript.IResolverHost {\n\n    public pathMap: any = {};\n    public resolvedPaths: any = {};\n\n    constructor(public compilationSettings: TypeScript.CompilationSettings) { \n    }\n\n    public getPathIdentifier(path: string) { \n        return this.compilationSettings.useCaseSensitiveFileResolution ? path : path.toLocaleUpperCase();\n    }\n\n    public isResolved(path: string) {\n        return this.resolvedPaths[this.getPathIdentifier(this.pathMap[path])] != undefined;\n    }\n\n    public resolveCompilationEnvironment(preEnv: TypeScript.CompilationEnvironment,\n        resolver: TypeScript.ICodeResolver,\n        traceDependencies: bool): TypeScript.CompilationEnvironment {\n        var resolvedEnv = new TypeScript.CompilationEnvironment(preEnv.compilationSettings, preEnv.ioHost);\n\n        var nCode = preEnv.code.length;\n        var path = "";\n\n        var postResolutionError = \n            (errorFile: string, errorMessage: string) => {\n                TypeScript.CompilerDiagnostics.debugPrint("Could not resolve file \'" + errorFile + "\'" + (errorMessage == "" ? "" : ": " + errorMessage));\n            }\n\n        var resolutionDispatcher: TypeScript.IResolutionDispatcher = {\n            postResolutionError: postResolutionError,\n            postResolution: (path: string, code: TypeScript.ISourceText) => {\n                var pathId = this.getPathIdentifier(path);\n                if (!this.resolvedPaths[pathId]) {\n                    resolvedEnv.code.push(<TypeScript.SourceUnit>code);\n                    this.resolvedPaths[pathId] = true;\n                }\n            }\n        };\n\n        for (var i = 0; i < nCode; i++) {\n            path = TypeScript.switchToForwardSlashes(preEnv.ioHost.resolvePath(preEnv.code[i].path));\n            this.pathMap[preEnv.code[i].path] = path;\n            resolver.resolveCode(path, "", false, r',
v27530=v27531+'esolutionDispatcher);\n        }\n\n        return resolvedEnv;\n    }\n}\nclass BatchCompiler {\n    public compilationSettings: TypeScript.CompilationSettings;\n    public compilationEnvironment: TypeScript.CompilationEnvironment;\n    public resolvedEnvironment: TypeScript.CompilationEnvironment = null;\n    public hasResolveErrors: bool = false;\n    public compilerVersion = "0.8.2.0";\n    public printedVersion = false;\n\n    constructor (public ioHost: IIO) { \n        this.compilationSettings = new TypeScript.CompilationSettings();\n        this.compilationEnvironment = new TypeScript.CompilationEnvironment(this.compilationSettings, this.ioHost);\n    }\n\n    public resolve() {\n        var resolver = new TypeScript.CodeResolver(this.compilationEnvironment);\n        var commandLineHost = new CommandLineHost(this.compilationSettings);\n        var ret = commandLineHost.resolveCompilationEnvironment(this.compilationEnvironment, resolver, true);\n\n        // Reset resolve error status\n        this.hasResolveErrors = false;\n\n        for (var i = 0; i < this.compilationEnvironment.code.length; i++) {\n            if (!commandLineHost.isResolved(this.compilationEnvironment.code[i].path)) {\n                this.hasResolveErrors = true;\n                var path = this.compilationEnvironment.code[i].path;\n                if (!TypeScript.isSTRFile(path) && !TypeScript.isDSTRFile(path) && !TypeScript.isTSFile(path) && !TypeScript.isDTSFile(path)) {\n                    this.ioHost.stderr.WriteLine("Unknown extension for file: \\""+path+"\\". Only .ts and .d.ts extensions are allowed.");\n                }\n                else {\n                    this.ioHost.stderr.WriteLine("Error reading file \\"" + path + "\\": File not found");\n                }\n            }\n        }\n\n        return ret;\n    }\n    \n    /// Do the actual compilation reading from input files and\n    /// writing to output file(s).\n    public compile(): bool {\n        var compiler: TypeScript.TypeScriptCompiler;\n\n        compiler = new TypeScript.TypeScriptCompiler(this.ioHost.stderr, new TypeScript.NullLogger(), this.compilationSettings);\n        compiler.setErrorOutput(this.ioHost.stderr);\n        compiler.setErrorCallback(\n            (minChar, charLen, message, unitIndex) => {\n                compiler.errorReporter.hasErrors = true;\n                var fname = this.resolvedEnvironment.code[unitIndex].path;\n                var lineCol = { line: -1, col: -1 };\n                compiler.parser.getSourceLineCol(lineCol, minChar);\n                // line is 1-base, col, however, is 0-base. add 1 to the col before printing the message\n                var msg = fname + " (" + lineCol.line + "," + (lineCol.col + 1) + "): " + message;\n                if (this.compilationSettings.errorRecovery) {\n                    this.ioHost.stderr.WriteLine(msg);\n                } else {\n                    throw new SyntaxError(msg);\n                }\n            });\n\n        if (this.compilationSettings.emitComments) {\n            compiler.emitCommentsToOutput();\n        }\n\n        var consumeUnit = (code: TypeScript.SourceUnit, addAsResident: bool) => {\n            try {\n                // if file resolving is disabled, the file\'s content will not yet be loaded\n\n                if (!this.compilationSettings.resolve) {\n                    code.content = this.ioHost.readFile(code.path);\n                    // If declaration files are going to be emitted, \n                    // preprocess the file contents and add in referenced files as well\n                    if (this.compilationSettings.generateDeclarationFiles) {\n                        TypeScript.CompilerDiagnostics.assert(code.referencedFiles == null, "With no resolve option, referenced files need to null");\n                        code.referencedFiles = TypeScript.getReferencedFiles(code);\n                    }\n                }\n\n                if (code.content != null) {\n                    if (this.compilationSettings.parseOnly) {\n                        compiler.parseUnit(code.content, code.path);\n                    }\n                    else {\n                        if (this.compilationSettings.errorRecovery) {\n                            compiler.parser.setErrorRecovery(this.ioHost.stderr);\n                        }\n                        compiler.addUnit(code.content, code.path, addAsResident, code.referencedFiles);\n                    }\n                }\n            }\n            catch (err) {\n                compiler.errorReporter.hasErrors = true;\n                // This includes syntax errors thrown from error callback if not in recovery mode\n                this.ioHost.stderr.WriteLine(err.message);\n            }\n\n        }\n\n        for (var iCode = 0 ; iCode < this.resolvedEnvironment.code.length; iCode++) {\n            if (!this.compilationSettings.parseOnly || (iCode > 0)) {\n                consumeUnit(this.resolvedEnvironment.code[iCode], false);\n            }\n        }\n\n        var emitterIOHost = {\n          ',
v27529=v27530+"  createFile: (fileName: string, useUTF8?: bool) => IOUtils.createFileAndFolderStructure(this.ioHost, fileName, useUTF8),\n            directoryExists: this.ioHost.directoryExists,\n            fileExists: this.ioHost.fileExists,\n            resolvePath: this.ioHost.resolvePath\n        };\n\n        try {\n            if (!this.compilationSettings.parseOnly) {\n                compiler.typeCheck();\n                compiler.emit(emitterIOHost);\n                compiler.emitDeclarations();\n            }\n            else {\n                compiler.emitAST(emitterIOHost);\n            }\n        } catch (err) {\n            compiler.errorReporter.hasErrors = true;\n            // Catch emitter exceptions\n            if (err.message != \"EmitError\") {\n                throw err;\n            }\n        }\n\n        return compiler.errorReporter.hasErrors;\n    }\n\n    // Execute the provided inputs\n    public run() {\n        for (var i = 0; i < this.compilationEnvironment.code.length; i++) {\n            var unit = this.compilationEnvironment.code[i];\n            \n            var outputFileName: string = unit.path;\n            if (TypeScript.isTSFile(outputFileName)) {\n                outputFileName = outputFileName.replace(/\\.ts$/, \".js\");\n            } else if (TypeScript.isSTRFile(outputFileName)) {\n                outputFileName = outputFileName.replace(/\\.str$/, \".js\");\n            }\n            if (this.ioHost.fileExists(outputFileName)) {\n                var unitRes = this.ioHost.readFile(outputFileName)\n                this.ioHost.run(unitRes, outputFileName);\n            }\n        }\n    }\n\n    /// Begin batch compilation\n    public batchCompile() {\n        TypeScript.CompilerDiagnostics.diagnosticWriter = { Alert: (s: string) => { this.ioHost.printLine(s); } }\n\n        var code: TypeScript.SourceUnit;\n\n        var opts = new OptionsParser(this.ioHost);\n\n        opts.option('out', {\n            usage: 'Concatenate and emit output to single file | Redirect output structure to the directory',\n            type: 'file|directory',\n            set: (str) => {\n                this.compilationSettings.outputOption = str;\n            }\n        });\n\n        opts.option('style', {\n            usage: 'Select style checking options (examples --style requireSemi:off or --style \"eqeqeq;bitwise:off\")',\n            experimental: true,\n            set: (str) => {\n                this.compilationSettings.setStyleOptions(str);\n            }\n        });\n\n        opts.flag('sourcemap', {\n            usage: 'Generates corresponding .map file',\n            set: () => {\n                this.compilationSettings.mapSourceFiles = true;\n            }\n        });\n\n        opts.flag('declaration', {\n            usage: 'Generates corresponding .d.ts file',\n            set: () => {\n                this.compilationSettings.generateDeclarationFiles = true;\n            }\n        });\n\n        if (this.ioHost.watchFile) {\n            opts.flag('watch', {\n                usage: 'Watch output files',\n                set: () => {\n                    this.compilationSettings.watch = true;\n                }\n            }, 'w');\n        }\n\n        opts.flag('exec', {\n            usage: 'Execute the script after compilation',\n            set: () => {\n                this.compilationSettings.exec = true;\n            }\n        }, 'e');\n\n        opts.flag('parse', {\n            usage: 'Parse only',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.parseOnly = true;\n            }\n        });\n\n        opts.flag('minw', {\n            usage: 'Minimize whitespace',\n            experimental: true,\n            set: () => { this.compilationSettings.minWhitespace = true; }\n        }, 'mw');\n\n        opts.flag('const', {\n            usage: 'Propagate constants to emitted code',\n            experimental: true,\n            set: () => { this.compilationSettings.propagateConstants = true; }\n        });\n\n        opts.flag('errorrecovery', {\n            usage: 'Enable error recovery',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.errorRecovery = true;\n            }\n        }, 'er');\n\n        opts.flag('comments', {\n            usage: 'Emit comments to output',\n            set: () => {\n                this.compilationSettings.emitComments = true;\n            }\n        }, 'c');\n\n        opts.flag('cflow', {\n            usage: 'Control flow',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.controlFlow = true;\n            }\n        });\n\n        opts.flag('cflowp', {\n            usage: 'Print control flow',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.controlFlow = true;\n                this.compilationSettings.printControlFlow = true;\n            }\n        });\n\n        opts.flag('cflowu', {\n            usage: 'Print Use Def control flow',\n            experimental: true,\n            set: () ",
v27528=v27529+"=> {\n                this.compilationSettings.controlFlow = true;\n                this.compilationSettings.controlFlowUseDef = true;\n            }\n        });\n\n        opts.flag('noerroronwith', {\n            usage: 'Allow with statements',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.errorOnWith = false;\n            }\n        });\n\n        opts.flag('noresolve', {\n            usage: 'Skip resolution and preprocessing',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.resolve = false;\n                this.compilationSettings.preprocess = false;\n            }\n        });\n\n        opts.flag('debug', {\n            usage: 'Print debug output',\n            experimental: true,\n            set: () => {\n                TypeScript.CompilerDiagnostics.debug = true;\n            }\n        });\n\n        opts.flag('canCallDefinitionSignature', {\n            usage: 'Allows you to call the definition signature of an overload group',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.canCallDefinitionSignature = true;\n            }\n        });\n\n        opts.flag('nooptimizemodules', {\n            usage: 'Do not optimize module codegen',\n            experimental: true,\n            set: () => {\n                TypeScript.optimizeModuleCodeGen = false;\n            }\n        });\n\n        opts.flag('nolib', {\n            usage: 'Do not include a default lib.d.ts with global declarations',\n            set: () => {\n                this.compilationSettings.useDefaultLib = false;\n            }\n        });\n\n\n        opts.flag('inferProperties', {\n            usage: 'Infer class properties from top-level assignments to \\'this\\'',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.inferPropertiesFromThisAssignment = true;\n            }\n        });\n\n        opts.option('target', {\n            usage: 'Specify ECMAScript target version: \"ES3\" (default), or \"ES5\"',\n            type: 'VER',\n            set: (type) => {\n                type = type.toLowerCase();\n\n                if (type === 'es3') {\n                    this.compilationSettings.codeGenTarget = TypeScript.CodeGenTarget.ES3;\n                } else if (type === 'es5') {\n                    this.compilationSettings.codeGenTarget = TypeScript.CodeGenTarget.ES5;\n                }\n                else {\n                    this.ioHost.printLine(\"ECMAScript target version '\" + type + \"' not supported.  Using default 'ES3' code generation\");\n                }\n            }\n        });\n\n        opts.option('module', {\n            usage: 'Specify module code generation: \"commonjs\" (default) or \"amd\"',\n            type: 'kind',\n            set: (type) => {\n                type = type.toLowerCase();\n\n                if (type === 'commonjs' || type === 'node') {\n                    TypeScript.moduleGenTarget = TypeScript.ModuleGenTarget.Synchronous;\n                } else if (type === 'amd') {\n                    TypeScript.moduleGenTarget = TypeScript.ModuleGenTarget.Asynchronous;\n                } else {\n                    this.ioHost.printLine(\"Module code generation '\" + type + \"' not supported.  Using default 'commonjs' code generation\");\n                }\n            }\n        });\n\n        var printedUsage = false;\n\n        opts.flag('help', {\n            usage: 'Print this message',\n            set: () => {\n                this.printVersion();\n                opts.printUsage();\n                printedUsage = true;\n            }\n        }, 'h');\n\n        opts.flag('useCaseSensitiveFileResolution', {\n            usage: 'Force file resolution to be case sensitive',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.useCaseSensitiveFileResolution = true;\n            }\n        });\n\n        opts.flag('version', {\n            usage: 'Print the compiler\\'s version: ' + this.compilerVersion,\n            set: () => {\n                this.printVersion();\n            }\n        }, 'v');\n\n        opts.parse(this.ioHost.arguments);\n        \n        if (this.compilationSettings.useDefaultLib) {\n            var compilerFilePath = this.ioHost.getExecutingFilePath()\n            var binDirPath = this.ioHost.dirName(compilerFilePath);\n            var libStrPath = this.ioHost.resolvePath(binDirPath + \"/lib.d.ts\");\n            code = new TypeScript.SourceUnit(libStrPath, null);\n            this.compilationEnvironment.code.push(code);\n        }\n\n        for (var i = 0; i < opts.unnamed.length; i++) {\n            code = new TypeScript.SourceUnit(opts.unnamed[i], null);\n            this.compilationEnvironment.code.push(code);\n        }\n\n        // If no source files provided to compiler - print usage information\n        if (this.compilationEnvironment.code.length == (this.compilationSettings.useDefaultLib ? 1 : 0)) {\n            if (!printedUsage && !this.printedVersion",
v27527=v27528+') {\n                this.printVersion();\n                opts.printUsage();\n                this.ioHost.quit(1);\n            }\n            return;\n        }\n\n        var sourceFiles: TypeScript.SourceUnit[] = [];\n        if (this.compilationSettings.watch) {\n            // Capture the state before calling resolve\n            sourceFiles = this.compilationEnvironment.code.slice(0);\n        }\n\n        // Resolve file dependencies, if requested\n        this.resolvedEnvironment = this.compilationSettings.resolve ? this.resolve() : this.compilationEnvironment;\n\n        var hasCompileErrors = this.compile();\n\n        var hasErrors = hasCompileErrors || this.hasResolveErrors;\n        if (!hasErrors) {\n            if (this.compilationSettings.exec) {\n                this.run();\n            }\n        }\n\n        if (this.compilationSettings.watch) {\n            // Watch will cause the program to stick around as long as the files exist\n            this.watchFiles(sourceFiles);\n        }\n        else {  \n            // Exit with the appropriate error code\n            this.ioHost.quit(hasErrors ? 1 : 0);\n        }\n    }\n\n    public printVersion() {\n        if (!this.printedVersion) {\n            this.ioHost.printLine("Version " + this.compilerVersion);\n            this.printedVersion = true;\n        }\n    }\n\n    public watchFiles(soruceFiles: TypeScript.SourceUnit[]) {\n        if (!this.ioHost.watchFile) {\n            this.ioHost.printLine("Error: Current host does not support -w[atch] option");\n            return;\n        }\n\n        var resolvedFiles: string[] = []\n        var watchers: { [x: string]: IFileWatcher; } = {};\n\n        var addWatcher = (filename: string) => {\n            if (!watchers[filename]) {\n                var watcher = this.ioHost.watchFile(filename, onWatchedFileChange);\n                watchers[filename] = watcher;\n            }\n            else {\n                throw new Error("Cannot watch file, it is already watched.");\n            }\n        };\n\n        var removeWatcher = (filename: string) => {\n            if (watchers[filename]) {\n                watchers[filename].close();\n                delete watchers[filename];\n            }\n            else {\n                throw new Error("Cannot stop watching file, it is not being watched.");\n            }\n        };\n\n        var onWatchedFileChange = () => {\n            // Reset the state\n            this.compilationEnvironment.code = soruceFiles;\n\n            // Resolve file dependencies, if requested\n            this.resolvedEnvironment = this.compilationSettings.resolve ? this.resolve() : this.compilationEnvironment;\n\n            // Check if any new files were added to the environment as a result of the file change\n            var oldFiles = resolvedFiles;\n            var newFiles: string[] = [];\n            this.resolvedEnvironment.code.forEach((sf) => newFiles.push(sf.path));\n            newFiles = newFiles.sort();\n\n            var i = 0, j = 0;\n            while (i < oldFiles.length && j < newFiles.length) {\n\n                var compareResult = oldFiles[i].localeCompare(newFiles[j]);\n                if (compareResult == 0) {\n                    // No change here\n                    i++;\n                    j++;\n                }\n                else if (compareResult < 0) {\n                    // Entry in old list does not exist in the new one, it was removed\n                    removeWatcher(oldFiles[i]);\n                    i++;\n                }\n                else {\n                    // Entry in new list does exist in the new one, it was added\n                    addWatcher(newFiles[j]);\n                    j++;\n                }\n            }\n\n            // All remaining unmatched items in the old list have been removed\n            for (var k = i; k < oldFiles.length; k++) {\n                removeWatcher(oldFiles[k]);\n            }\n\n            // All remaing unmatched items in the new list have been added\n            for (var k = j; k < newFiles.length; k++) {\n                addWatcher(newFiles[k]);\n            }\n\n            // Update the state\n            resolvedFiles = newFiles;;\n\n            // Print header\n            this.ioHost.printLine("");\n            this.ioHost.printLine("Recompiling (" + new Date() + "): ");\n            resolvedFiles.forEach((f) => this.ioHost.printLine("    " + f));\n\n            // Trigger a new compilation\n            var hasCompileErrors = this.compile();\n\n            var hasErrors = hasCompileErrors || this.hasResolveErrors;\n            if (!hasErrors) {\n                if (this.compilationSettings.exec) {\n                    this.run();\n                }\n            }\n        };\n\n        // Switch to using stdout for all error messages\n        this.ioHost.stderr = this.ioHost.stdout;\n\n        // Initialize the initial list of resolved files, and add watches to them\n        this.resolvedEnvironment.code.forEach((sf) => {\n            resolvedFiles.push(sf.path);\n            addWatcher(sf.path);\n ',
v27526=v27527+'       });\n        resolvedFiles.sort();\n    }\n}\n\n// Start the batch compilation using the current hosts IO\nvar batch = new BatchCompiler(IO);\nbatch.batchCompile();\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class ArrayCache {\n        public arrayType: Type;\n        public arrayBase: Type = null;\n\n        public specialize(arrInstType: Type, checker: TypeChecker): Type {\n            if (this.arrayBase == null) {\n                this.arrayBase = arrInstType.specializeType(checker.wildElm.type, this.arrayType.elementType,\n                                                   checker, true);\n            }\n            return this.arrayBase;\n        }\n    }\n\n    export class TypeComparisonInfo {\n        public onlyCaptureFirstError = false;\n        public flags: TypeRelationshipFlags = TypeRelationshipFlags.SuccessfulComparison;\n        public message = "";\n\n        public addMessageToFront(message) {\n            if (!this.onlyCaptureFirstError) {\n                this.message = this.message ? message + ":\\n\\t" + this.message : message;\n            }\n            else {\n                this.setMessage(message);\n            }\n        }\n\n        public setMessage(message) {\n            this.message = message;\n        }\n    }\n\n    export interface SignatureData {\n        parameters: ParameterSymbol[];\n        nonOptionalParameterCount: number;\n    }\n\n    export interface ApplicableSignature {\n        signature: Signature;\n        hadProvisionalErrors: bool;\n    }\n\n    export enum TypeCheckCollectionMode {\n        Resident,\n        Transient\n    }\n\n    export class PersistentGlobalTypeState {\n        public importedGlobalsTable = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n        public importedGlobalsTypeTable = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n\n        public importedGlobals: SymbolScopeBuilder;\n\n        // transient state\n        public globals: IHashTable = null;\n        public globalTypes: IHashTable = null;\n        public ambientGlobals: IHashTable = null;\n        public ambientGlobalTypes: IHashTable = null;\n\n        // resident state\n        public residentGlobalValues = new StringHashTable();\n        public residentGlobalTypes = new StringHashTable();\n        public residentGlobalAmbientValues = new StringHashTable();\n        public residentGlobalAmbientTypes = new StringHashTable();\n\n        // dual resident/transient state\n\n        // REVIEW: We shouldn\'t need to allocate private hash tables for these, since there\'s no private global scope\n        // REVIEW: In general, we should audit each instance of DualStringHashTable to ensure that both the primary\n        // and secondary tables are necessary.  If it\'s not necessary, we should sub in a constant sentinel value.\n        public dualGlobalValues: DualStringHashTable;\n        public dualGlobalTypes: DualStringHashTable;\n        public dualAmbientGlobalValues: DualStringHashTable;\n        public dualAmbientGlobalTypes: DualStringHashTable;\n\n        public globalScope: SymbolScope;\n\n        public voidType: Type;\n        public booleanType: Type;\n        public doubleType: Type;\n\n        public stringType: Type;\n        public anyType: Type;\n        public nullType: Type;\n        public undefinedType: Type;\n\n        // Use this flag to turn resident checking on and off\n        public residentTypeCheck: bool = true;\n\n        public mod: ModuleType = null;\n        public gloMod: TypeSymbol = null;\n\n        public wildElm: TypeSymbol = null;\n\n        constructor (public errorReporter: ErrorReporter) {\n            this.importedGlobals = new SymbolScopeBuilder(null, this.importedGlobalsTable, null, this.importedGlobalsTypeTable, null, null);\n\n            this.dualGlobalValues = new DualStringHashTable(this.residentGlobalValues, new StringHashTable());\n            this.dualGlobalTypes = new DualStringHashTable(this.residentGlobalTypes, new StringHashTable());\n            this.dualAmbientGlobalValues = new DualStringHashTable(this.residentGlobalAmbientValues, new StringHashTable());\n            this.dualAmbientGlobalTypes = new DualStringHashTable(this.residentGlobalAmbientTypes, new StringHashTable());\n\n            var dualGlobalScopedMembers = new ScopedMembers(new DualStringHashTable(this.dualGlobalValues, new StringHashTable',
v27525=v27526+'()));\n            var dualGlobalScopedAmbientMembers = new ScopedMembers(new DualStringHashTable(this.dualAmbientGlobalValues, new StringHashTable()));\n            var dualGlobalScopedEnclosedTypes = new ScopedMembers(new DualStringHashTable(this.dualGlobalTypes, new StringHashTable()));\n            var dualGlobalScopedAmbientEnclosedTypes = new ScopedMembers(new DualStringHashTable(this.dualAmbientGlobalTypes, new StringHashTable()));\n\n            this.globalScope = new SymbolScopeBuilder(dualGlobalScopedMembers, dualGlobalScopedAmbientMembers, dualGlobalScopedEnclosedTypes, dualGlobalScopedAmbientEnclosedTypes, this.importedGlobals, null);\n\n            this.voidType = this.enterPrimitive(Primitive.Void, "void");\n            this.booleanType = this.enterPrimitive(Primitive.Boolean, "bool");\n            this.doubleType = this.enterPrimitive(Primitive.Double, "number");\n            this.importedGlobals.ambientEnclosedTypes.addPublicMember("number", this.doubleType.symbol);\n\n            this.stringType = this.enterPrimitive(Primitive.String, "string");\n            this.anyType = this.enterPrimitive(Primitive.Any, "any");\n            this.nullType = this.enterPrimitive(Primitive.Null, "null");\n            this.undefinedType = this.enterPrimitive(Primitive.Undefined, "undefined");\n\n            // shared global state is resident\n            this.setCollectionMode(TypeCheckCollectionMode.Resident);\n\n            this.wildElm = new TypeSymbol("_element", -1, 0, -1, new Type());\n            this.importedGlobalsTypeTable.addPublicMember(this.wildElm.name, this.wildElm);\n\n            this.mod = new ModuleType(dualGlobalScopedEnclosedTypes, dualGlobalScopedAmbientEnclosedTypes);\n            this.mod.members = dualGlobalScopedMembers;\n            this.mod.ambientMembers = dualGlobalScopedAmbientMembers;\n            this.mod.containedScope = this.globalScope;\n\n            this.gloMod = new TypeSymbol(globalId, -1, 0, -1, this.mod);\n            this.mod.members.addPublicMember(this.gloMod.name, this.gloMod);\n\n            this.defineGlobalValue("undefined", this.undefinedType);\n        }\n\n\n        public enterPrimitive(flags: number, name: string) {\n            var primitive = new Type();\n            primitive.primitiveTypeClass = flags;\n            var symbol = new TypeSymbol(name, -1, name.length, -1, primitive);\n            symbol.typeCheckStatus = TypeCheckStatus.Finished;\n            primitive.symbol = symbol;\n            this.importedGlobals.enter(null, null, symbol, this.errorReporter, true, true, true);\n            return primitive;\n        }\n\n        public setCollectionMode(mode: TypeCheckCollectionMode) {\n            this.residentTypeCheck =\n                this.dualGlobalValues.insertPrimary =\n                    this.dualGlobalTypes.insertPrimary =\n                        this.dualAmbientGlobalValues.insertPrimary =\n                            this.dualAmbientGlobalTypes.insertPrimary = mode == TypeCheckCollectionMode.Resident;\n        }\n\n        public refreshPersistentState() {\n            this.globals = new StringHashTable();\n            this.globalTypes = new StringHashTable();\n            this.ambientGlobals = new StringHashTable();\n            this.ambientGlobalTypes = new StringHashTable();\n\n            // add global types to the global scope\n            this.globalTypes.add(this.voidType.symbol.name, this.voidType.symbol);\n            this.globalTypes.add(this.booleanType.symbol.name, this.booleanType.symbol);\n            this.globalTypes.add(this.doubleType.symbol.name, this.doubleType.symbol);\n            this.globalTypes.add("number", this.doubleType.symbol);\n            this.globalTypes.add(this.stringType.symbol.name, this.stringType.symbol);\n            this.globalTypes.add(this.anyType.symbol.name, this.anyType.symbol);\n            this.globalTypes.add(this.nullType.symbol.name, this.nullType.symbol);\n            this.globalTypes.add(this.undefinedType.symbol.name, this.undefinedType.symbol);\n\n            this.dualGlobalValues.secondaryTable = this.globals;\n            this.dualGlobalTypes.secondaryTable = this.globalTypes;\n            this.dualAmbientGlobalValues.secondaryTable = this.ambientGlobals;\n            this.dualAmbientGlobalTypes.secondaryTable = this.ambientGlobalTypes;\n        }\n\n        public defineGlobalValue(name: string, type: Type) {\n            var valueLocation = new ValueLocation();\n            valueLocation.typeLink = new TypeLink();\n            var sym = new VariableSymbol(name, 0, -1, valueLocation);\n            sym.setType(type);\n            sym.typeCheckStatus = TypeCheckStatus.Finished;\n            sym.container = this.gloMod;\n            this.importedGlobalsTable.addPublicMember(name, sym);\n        }\n    }\n\n    export class ContextualTypeContext {\n        public targetSig: Signature = null;\n        public targetThis: Type = null;\n        public targetAccessorType: Type = null;\n\n        constructor (public contextualType: Type,\n            public provisional: bool, pu',
v27524=v27525+'blic contextID: number) { }\n    }\n\n    export class ContextualTypingContextStack {\n        private contextStack: ContextualTypeContext[] = [];\n        static contextID = TypeCheckStatus.Finished + 1;\n        public pushContextualType(type: Type, provisional: bool) { this.contextStack.push(new ContextualTypeContext(type, provisional, ContextualTypingContextStack.contextID++)); this.checker.errorReporter.pushToErrorSink = provisional; }\n        public hadProvisionalErrors = false; // somewhere in the chain a provisional typecheck error was thrown\n        public popContextualType() {\n            var tc = this.contextStack.pop();\n            this.checker.errorReporter.pushToErrorSink = this.isProvisional();\n            this.hadProvisionalErrors = this.hadProvisionalErrors || (tc.provisional && (this.checker.errorReporter.getCapturedErrors().length));\n            this.checker.errorReporter.freeCapturedErrors();\n            return tc;\n        }\n        public getContextualType(): ContextualTypeContext { return (!this.contextStack.length ? null : this.contextStack[this.contextStack.length - 1]); }\n        public getContextID() { return (!this.contextStack.length ? TypeCheckStatus.Finished : this.contextStack[this.contextStack.length - 1].contextID); }\n        public isProvisional() { return (!this.contextStack.length ? false : this.contextStack[this.contextStack.length - 1].provisional); }\n\n        constructor (public checker: TypeChecker) { }\n    }\n\n    export class TypeChecker {\n        public errorReporter: ErrorReporter = null;\n        public globalScope: SymbolScope;\n\n        public checkControlFlow = false;\n        public printControlFlowGraph = false;\n        public checkControlFlowUseDef = false;\n        public styleSettings: StyleSettings = null;\n\n        public units: LocationInfo[] = null;\n\n        public voidType: Type;\n        public booleanType: Type;\n        public numberType: Type;\n        public stringType: Type;\n        public anyType: Type;\n        public nullType: Type;\n        public undefinedType: Type;\n\n        public anon = "_anonymous";\n\n        public globals: DualStringHashTable;\n        public globalTypes: DualStringHashTable;\n        public ambientGlobals: DualStringHashTable;\n        public ambientGlobalTypes: DualStringHashTable;\n        public gloModType: ModuleType;\n        public gloMod: TypeSymbol;\n        public wildElm: TypeSymbol;\n\n        public locationInfo: LocationInfo = null;\n        public typeFlow: TypeFlow = null;\n\n        public currentCompareA: Symbol = null;\n        public currentCompareB: Symbol = null;\n\n        public currentModDecl: ModuleDeclaration = null;\n\n        public inBind = false;\n        public inWith = false;\n        public errorsOnWith = true;\n\n        public typingContextStack: ContextualTypingContextStack;\n        public currentContextualTypeContext: ContextualTypeContext = null;\n\n        public resolvingBases = false;\n\n        public canCallDefinitionSignature = false;\n\n        public assignableCache: any[] = <any>{};\n        public subtypeCache: any[] = <any>{};\n        public identicalCache: any[] = <any>{};\n\n        public provisionalStartedTypecheckObjects: PhasedTypecheckObject[] = [];\n\n        public mustCaptureGlobalThis = false;\n\n        constructor (public persistentState: PersistentGlobalTypeState) {\n            this.voidType = this.persistentState.voidType;\n            this.booleanType = this.persistentState.booleanType;\n            this.numberType = this.persistentState.doubleType;\n            this.stringType = this.persistentState.stringType;\n            this.anyType = this.persistentState.anyType;\n            this.nullType = this.persistentState.nullType;\n            this.undefinedType = this.persistentState.undefinedType;\n\n            this.globals = this.persistentState.dualGlobalValues;\n            this.globalTypes = this.persistentState.dualGlobalTypes;\n            this.ambientGlobals = this.persistentState.dualAmbientGlobalValues;\n            this.ambientGlobalTypes = this.persistentState.dualAmbientGlobalTypes;\n            this.gloModType = this.persistentState.mod;\n            this.gloMod = this.persistentState.gloMod;\n            this.wildElm = this.persistentState.wildElm;\n\n            this.globalScope = this.persistentState.globalScope;\n\n            this.typingContextStack = new ContextualTypingContextStack(this);\n        }\n\n        public setStyleOptions(style: StyleSettings) {\n            this.styleSettings = style;\n        }\n\n        // Contextual typing\n        public setContextualType(type: Type, provisional: bool) {\n            this.typingContextStack.pushContextualType(type, provisional);\n            this.currentContextualTypeContext = this.typingContextStack.getContextualType();\n        }\n\n        public unsetContextualType() {\n            var lastTC = this.typingContextStack.popContextualType();\n            this.currentContextualTypeContext = this.typingContextStack.getContextualType();\n            return lastTC;\n   ',
v27523=v27524+'     }\n\n        public hadProvisionalErrors() {\n            return this.typingContextStack.hadProvisionalErrors;\n        }\n        public resetProvisionalErrors() {\n            if (!this.typingContextStack.getContextualType()) {\n                this.typingContextStack.hadProvisionalErrors = false;\n            }\n        }\n\n        public typeCheckWithContextualType(contextType: Type, provisional: bool, condition: bool, ast: AST) {\n            if (condition) {\n                this.setContextualType(contextType, this.typingContextStack.isProvisional() || provisional);\n            }\n            this.typeFlow.typeCheck(ast);\n            if (condition) {\n                this.unsetContextualType();\n            }\n        }\n\n        public resetTargetType() {\n            this.currentContextualTypeContext = this.typingContextStack.getContextualType();\n        }\n\n        // Unset the current contextual type without disturbing the stack, effectively "killing" the contextual typing process\n        public killCurrentContextualType() { this.currentContextualTypeContext = null; this.errorReporter.pushToErrorSink = false; }\n        public hasTargetType() { return this.currentContextualTypeContext && this.currentContextualTypeContext.contextualType; }\n        public getTargetTypeContext() { return this.currentContextualTypeContext; }\n\n        public inProvisionalTypecheckMode() {\n            return this.typingContextStack.isProvisional();\n        }\n\n        public getTypeCheckFinishedStatus() {\n            if (this.inProvisionalTypecheckMode()) {\n                return this.typingContextStack.getContextID();\n            }\n            return TypeCheckStatus.Finished;\n        }\n\n        public typeStatusIsFinished(status: TypeCheckStatus) {\n\n            return status == TypeCheckStatus.Finished ||\n                   (this.inProvisionalTypecheckMode() && status == this.typingContextStack.getContextID());\n        }\n\n        public addStartedPTO(pto: PhasedTypecheckObject) {\n            if (this.inProvisionalTypecheckMode()) {\n                this.provisionalStartedTypecheckObjects[this.provisionalStartedTypecheckObjects.length] = pto;\n            }\n        }\n\n        public cleanStartedPTO() {\n            for (var i = 0; i < this.provisionalStartedTypecheckObjects.length; i++) {\n                if (this.provisionalStartedTypecheckObjects[i].typeCheckStatus >= this.typingContextStack.getContextID()) {\n                    this.provisionalStartedTypecheckObjects[i].typeCheckStatus = TypeCheckStatus.NotStarted;\n                }\n            }\n            this.provisionalStartedTypecheckObjects = [];\n        }\n\n        // type collection      \n        public collectTypes(ast: AST): void {\n            if (ast.nodeType == NodeType.Script) {\n                var script = <Script>ast;\n                this.locationInfo = script.locationInfo;\n            }\n            var globalChain = new ScopeChain(this.gloMod, null, this.globalScope);\n            var context = new TypeCollectionContext(globalChain, this);\n            getAstWalkerFactory().walk(ast, preCollectTypes, postCollectTypes, null, context);\n        }\n\n        public makeArrayType(type: Type): Type {\n            if (type.arrayCache == null) {\n                type.arrayCache = new ArrayCache();\n                type.arrayCache.arrayType = new Type();\n                type.arrayCache.arrayType.elementType = type;\n                type.arrayCache.arrayType.symbol = type.symbol;\n            }\n            return type.arrayCache.arrayType;\n        }\n\n        public getParameterList(funcDecl: FuncDecl, container: Symbol): SignatureData {\n            var args = funcDecl.arguments;\n            var parameterTable = null;\n            var parameterBuilder = null;\n            var len = args.members.length;\n            var nonOptionalParams = 0;\n            var result: ParameterSymbol[] = [];\n\n            if (len > 0) {\n                parameterTable = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                parameterBuilder = new SymbolScopeBuilder(parameterTable, null, null, null, null, container);\n\n                for (var i = 0; i < len; i++) {\n                    var parameter = <ArgDecl>args.members[i];\n                    var paramDef = new ValueLocation();\n                    var parameterSymbol = new ParameterSymbol(parameter.id.text, parameter.minChar,\n                                                            this.locationInfo.unitIndex, paramDef);\n                    parameterSymbol.declAST = parameter;\n                    parameterSymbol.funcDecl = funcDecl;\n                    parameter.id.sym = parameterSymbol;\n                    parameter.sym = parameterSymbol;\n                    paramDef.symbol = parameterSymbol;\n                    paramDef.typeLink = getTypeLink(parameter.typeExpr, this, false);\n                    parameterBuilder.enter(null, parameter, parameterSymbol, this.errorReporter, true, false, false); // REVIEW: Shoul',
v27522=v27523+"d this be entered into the private scope?\n                    result[result.length] = parameterSymbol;\n                    if (!parameter.isOptionalArg()) {\n                        nonOptionalParams++;\n                    }\n                }\n            }\n            return { parameters: result, nonOptionalParameterCount: nonOptionalParams };\n        }\n\n        // Create a signature for a function definition\n        //  (E.g., has a function body - function declarations, property declarations, lambdas)\n        public createFunctionSignature(funcDecl: FuncDecl, container: Symbol, scope: SymbolScope, overloadGroupSym: Symbol, addToScope: bool): Signature {\n\n            var isExported = hasFlag(funcDecl.fncFlags, FncFlags.Exported | FncFlags.ClassPropertyMethodExported) || container == this.gloMod;\n            var isStatic = hasFlag(funcDecl.fncFlags, FncFlags.Static);\n            var isPrivate = hasFlag(funcDecl.fncFlags, FncFlags.Private);\n            var isDefinition = hasFlag(funcDecl.fncFlags, FncFlags.Definition);\n            var isAmbient = hasFlag(funcDecl.fncFlags, FncFlags.Ambient);\n            var isConstructor = funcDecl.isConstructMember() || funcDecl.isConstructor;\n            var isGlobal = container == this.gloMod;\n\n            var signature: Signature = new Signature();\n            var isLambda = funcDecl.fncFlags & FncFlags.IsFunctionExpression;\n\n            // If a return type has been declared for the signature, set the type link.\n            // Otherwise:\n            //  if it's a signature, its type will be 'any'\n            //  if it's a definition, the return type will be inferred  \n            if (funcDecl.returnTypeAnnotation || isDefinition) {\n                signature.returnType = getTypeLink(funcDecl.returnTypeAnnotation, this, false);\n            }\n            else {\n                signature.returnType = new TypeLink();\n                signature.returnType.type = this.anyType;\n            }\n\n            signature.hasVariableArgList = funcDecl.variableArgList;\n\n            var sigData = this.getParameterList(funcDecl, container);\n\n            signature.parameters = sigData.parameters;\n            signature.nonOptionalParameterCount = sigData.nonOptionalParameterCount;\n\n            funcDecl.signature = signature;\n            signature.declAST = funcDecl;\n\n            var useOverloadGroupSym =\n                overloadGroupSym &&\n                overloadGroupSym.getType() &&\n                !overloadGroupSym.isAccessor() &&\n                (funcDecl.isSignature() || (isAmbient == hasFlag(overloadGroupSym.flags, SymbolFlags.Ambient)));\n\n            if (useOverloadGroupSym && isPrivate != hasFlag(overloadGroupSym.flags, SymbolFlags.Private)) {\n                this.errorReporter.simpleError(funcDecl, \"Public/Private visibility of overloads does not agree\");\n            }\n\n            var groupType = useOverloadGroupSym ? overloadGroupSym.getType() : new Type();\n\n            if (isConstructor) {\n                if (groupType.construct == null) {\n                    groupType.construct = new SignatureGroup();\n                }\n                groupType.construct.addSignature(signature);\n                groupType.construct.hasImplementation = !(funcDecl.isSignature());\n                if (groupType.construct.hasImplementation) {\n                    groupType.setHasImplementation();\n                }\n            }\n            else if (funcDecl.isIndexerMember()) {\n                if (groupType.index == null) {\n                    groupType.index = new SignatureGroup();\n                    groupType.index.flags |= SignatureFlags.IsIndexer;\n                }\n\n                groupType.index.addSignature(signature);\n                groupType.index.hasImplementation = !(funcDecl.isSignature());\n                if (groupType.index.hasImplementation) {\n                    groupType.setHasImplementation();\n                }\n            }\n            else {\n                if (groupType.call == null) {\n                    groupType.call = new SignatureGroup();\n                }\n                groupType.call.addSignature(signature);\n\n                groupType.call.hasImplementation = !(funcDecl.isSignature());\n                if (groupType.call.hasImplementation) {\n                    groupType.setHasImplementation();\n                }\n            }\n\n            var instanceType = groupType.instanceType;\n\n            // Ensure that the function's symbol is properly configured\n            // (If there were overloads, we'll already have a symbol, otherwise we need to create one)\n            var funcName: string = null;\n\n            // Set the function's name:\n            //  In the case of anonymous or functions resulting from error\n            //  correction in the parser (isMissing() == true), we do not\n            //  want to set a function name, since they shouldn't be inserted\n            //  into the enclosing scope\n\n            // usedHint prevents functions bound to object literal fields from",
v27521=v27522+" being added to the\n            // enclosing scope\n            var usedHint = false;\n            if (funcDecl.name && !funcDecl.name.isMissing()) {\n                funcName = funcDecl.name.text;\n            }\n            else if (funcDecl.hint) {\n                funcName = funcDecl.hint;\n                usedHint = true;\n            }\n\n            if (groupType.symbol == null) {\n                groupType.symbol =\n                    new TypeSymbol(funcName ? funcName : this.anon,\n                                    funcDecl.minChar, funcDecl.limChar - funcDecl.minChar,\n                                    this.locationInfo.unitIndex,\n                                    groupType);\n                if (!useOverloadGroupSym) {\n                    groupType.symbol.declAST = funcDecl;\n                }\n            }\n\n            // REVIEW: Are we missing any other flags?\n            if (isStatic) {\n                groupType.symbol.flags |= SymbolFlags.Static;\n            }\n\n            if (isAmbient) {\n                groupType.symbol.flags |= SymbolFlags.Ambient;\n            }\n\n            if (isPrivate) {\n                groupType.symbol.flags |= SymbolFlags.Private;\n            }\n\n            groupType.symbol.isMethod = funcDecl.isMethod();\n            if (groupType.symbol.isMethod) {\n                groupType.symbol.flags |= SymbolFlags.Property;\n            }\n\n            funcDecl.type = groupType;\n\n            // Add the function symbol to the appropriate scope\n            // if the funcDecl is a constructor, it will be added to the enclosing scope as a class\n            if (!isConstructor) {\n                // Add the function's symbol to its enclosing scope\n                if (funcName && !isLambda && !funcDecl.isAccessor() && !usedHint) {\n\n                    // REVIEW: We're not setting the isDecl flags for fuctions bound to object literal properties\n                    // so removing the isDefiniton clause would break object literals\n                    if (addToScope) {  // REVIEW: If we combine this with createFunctionDeclarationSignature, we'll need to broaden this for both decls and defs                      \n                        // if it's a static method, enter directly into the container's scope\n                        if (funcDecl.isMethod() && isStatic) {\n\n                            // REVIEW: What about private statics?\n                            if (!(<TypeSymbol>container).type.members.publicMembers.add(funcName, groupType.symbol)) {\n                                this.errorReporter.duplicateIdentifier(funcDecl, funcName);\n                            }\n\n                            groupType.symbol.container = container;\n                        } // REVIEW: Another check for overloads...\n                        else if (overloadGroupSym == null || (overloadGroupSym.declAST && !(<FuncDecl>overloadGroupSym.declAST).isOverload && (container.isType()))) {\n                            scope.enter(container, funcDecl, groupType.symbol, this.errorReporter, !isPrivate && (isExported || isStatic || isGlobal), false, isAmbient);\n                        }\n                    }\n                    else if (!funcDecl.isSpecialFn()) {\n                        groupType.symbol.container = container; // REVIEW: Set container for overloads or anonymous?\n                    }\n                }\n                else if (!funcDecl.isSpecialFn()) {\n                    groupType.symbol.container = container; // REVIEW: Set container for lambdas and accessors?\n                }\n            }\n\n            // If, say, a call signature overload was declared before the class type was, we want to reuse\n            // the type that's already been instantiated for the class type, rather than allocate a new one\n            if (useOverloadGroupSym) {\n                var overloadGroupType = overloadGroupSym ? overloadGroupSym.getType() : null;\n                var classType = groupType;\n\n                if (classType != overloadGroupType) {\n                    if (classType.construct == null) {\n                        if (overloadGroupType && overloadGroupType.construct) {\n                            classType.construct = overloadGroupType.construct;\n                        }\n                        else {\n                            classType.construct = new SignatureGroup();\n                        }\n                    }\n                    else if (overloadGroupType) {\n                        if (overloadGroupType.construct) {\n                            classType.construct.signatures.concat(overloadGroupType.construct.signatures);\n                        }\n                    }\n\n                    // sync call and index signatures as well, but don't allocate should they not\n                    // already exist\n                    if (overloadGroupType) {\n                        if (classType.call == null) {\n                            classType.call = overloadGroupType.call;\n                        }\n                ",
v27520=v27521+'        else if (overloadGroupType.call) {\n                            classType.call.signatures.concat(overloadGroupType.call.signatures);\n                        }\n\n                        // if the function is not static, we need to add any call overloads onto the\n                        // instance type\'s call signature list\n                        if (!isStatic) {\n\n                            if (classType.instanceType == null) {\n                                classType.instanceType = overloadGroupType.instanceType;\n                            }\n\n                            var instanceType = classType.instanceType;\n\n                            if (instanceType) {\n                                if (instanceType.call == null) {\n                                    instanceType.call = overloadGroupType.call;\n                                }\n                                else if (overloadGroupType.call) {\n                                    instanceType.call.signatures.concat(overloadGroupType.call.signatures);\n                                }\n                            }\n                        }\n\n                        if (classType.index == null) {\n                            classType.index = overloadGroupType.index;\n                        }\n                        else if (overloadGroupType.index) {\n                            classType.index.signatures.concat(overloadGroupType.index.signatures);\n                        }\n                    }\n                }\n            }\n\n            return signature;\n        }\n\n        // Creates a new symbol for an accessor property\n        // Note that funcDecl.type.symbol and fgSym may not be the same (E.g., in the case of type collection)\n        public createAccessorSymbol(funcDecl: FuncDecl, fgSym: Symbol, enclosingClass: Type, addToMembers: bool, isClassProperty: bool, scope: SymbolScope, container: Symbol) {\n            var accessorSym: FieldSymbol = null\n            var sig = funcDecl.signature;\n            var nameText = funcDecl.name.text;\n            var isStatic = hasFlag(funcDecl.fncFlags, FncFlags.Static);\n            var isPrivate = hasFlag(funcDecl.fncFlags, FncFlags.Private);\n\n            if (fgSym == null) {\n                var field = new ValueLocation();\n                accessorSym = new FieldSymbol(nameText, funcDecl.minChar, this.locationInfo.unitIndex, false, field);\n                field.symbol = accessorSym;\n                accessorSym.declAST = funcDecl; // REVIEW: need to reset for getters and setters\n\n                if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {\n                    if (accessorSym.getter) {\n                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property getter");\n                    }\n                    accessorSym.getter = <TypeSymbol>sig.declAST.type.symbol;\n                }\n                else {\n                    if (accessorSym.setter) {\n                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property setter");\n                    }\n                    accessorSym.setter = <TypeSymbol>sig.declAST.type.symbol;\n                }\n\n                field.typeLink = getTypeLink(null, this, false);\n\n                // if it\'s static, enter it into the class\'s member list directly\n                if (addToMembers) {\n                    if (enclosingClass) {\n                        if (!enclosingClass.members.publicMembers.add(nameText, accessorSym)) {\n                            this.errorReporter.duplicateIdentifier(funcDecl, accessorSym.name);\n                        }\n                        accessorSym.container = enclosingClass.symbol;\n                    }\n                    else {\n                        this.errorReporter.simpleError(funcDecl, "Accessor property may not be added in this context");\n                    }\n                }\n                else {\n                    scope.enter(container, funcDecl, accessorSym, this.errorReporter, !isPrivate || isStatic, false, false);\n                }\n\n                // We set the flags here, instead of below, because the accessor symbol does not yet have a type\n                if (isClassProperty) {\n                    accessorSym.flags |= SymbolFlags.Property;\n                }\n                if (isStatic) {\n                    accessorSym.flags |= SymbolFlags.Static;\n                }\n\n                if (isPrivate) {\n                    accessorSym.flags |= SymbolFlags.Private;\n                }\n                else {\n                    accessorSym.flags |= SymbolFlags.Public;\n                }\n            }\n            else {\n                accessorSym = <FieldSymbol>(<any>fgSym);\n\n                if (isPrivate != hasFlag(accessorSym.flags, SymbolFlags.Private)) {\n                    this.errorReporter.simpleError(funcDecl, "Getter and setter accessors do not agree in visibility");\n                }\n\n                if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {\n       ',
v27519=v27520+'             if (accessorSym.getter) {\n                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property getter");\n                    }\n                    accessorSym.getter = <TypeSymbol>funcDecl.type.symbol;\n                }\n                else {\n                    if (accessorSym.setter) {\n                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property setter");\n                    }\n                    accessorSym.setter = <TypeSymbol>funcDecl.type.symbol;\n                }\n            }\n\n            return accessorSym;\n        }\n\n        public addBases(resultScope: SymbolAggregateScope, type: Type, baseContext: { base: string; baseId: number; }): void {\n            resultScope.addParentScope(new SymbolTableScope(type.members, type.ambientMembers, type.getAllEnclosedTypes(), type.getAllAmbientEnclosedTypes(), type.symbol));\n            var i = 0;\n            var parent: Type;\n            if (type.extendsList) {\n                for (var len = type.extendsList.length; i < len; i++) {\n                    parent = type.extendsList[i];\n                    if (baseContext.baseId == parent.typeID) {\n                        this.errorReporter.reportErrorFromSym(parent.symbol, "Type \'" + baseContext.base + "\' is recursively referenced as a base class of itself");\n                        parent.symbol.flags |= SymbolFlags.RecursivelyReferenced;\n                        break;\n                    }\n                    this.addBases(resultScope, parent, baseContext);\n                }\n            }\n        }\n\n        public scopeOf(type: Type): SymbolScope {\n            var resultScope = new SymbolAggregateScope(type.symbol);\n            var baseContext = { base: type.symbol && type.symbol.name ? type.symbol.name : "{}", baseId: type.typeID };\n            this.addBases(resultScope, type, baseContext);\n            return resultScope;\n        }\n\n        public lookupMemberTypeSymbol(containingType: Type, name: string): Symbol {\n            var symbol: Symbol = null;\n            if (containingType.containedScope) {\n                symbol = containingType.containedScope.find(name, false, true);\n            }\n            else if (containingType.members) {\n                symbol = containingType.members.allMembers.lookup(name);\n\n                if (symbol == null && containingType.ambientMembers) {\n                    symbol = containingType.ambientMembers.allMembers.lookup(name);\n                }\n            }\n            if (symbol == null) {\n                var typeMembers = containingType.getAllEnclosedTypes();\n                var ambientTypeMembers = containingType.getAllAmbientEnclosedTypes();\n                if (typeMembers) {\n                    symbol = typeMembers.allMembers.lookup(name);\n\n                    if (symbol == null && ambientTypeMembers) {\n                        symbol = ambientTypeMembers.allMembers.lookup(name);\n                    }\n\n                }\n            }\n            if (symbol && symbol.isType()) {\n                return symbol;\n            }\n            else {\n                return null;\n            }\n        }\n\n        public findSymbolForDynamicModule(idText: string, currentFileName: string, search: (id: string) =>Symbol): Symbol {\n            var originalIdText = idText;\n            var symbol = search(idText);\n           \n            if (symbol == null) {\n                // perhaps it\'s a dynamic module?\n                if (!symbol) {\n                    idText = swapQuotes(originalIdText);\n                    symbol = search(idText);\n                }\n\n                // Check the literal path first\n                if (!symbol) {\n                    idText = stripQuotes(originalIdText) + ".ts";\n                    symbol = search(idText);\n                }\n\n                if (!symbol) {\n                    idText = stripQuotes(originalIdText) + ".str";\n                    symbol = search(idText);\n                }\n\n                // Check check for .d.str\n                if (!symbol) {\n                    idText = stripQuotes(originalIdText) + ".d.ts";\n                    symbol = search(idText);\n                }\n\n                if (!symbol) {\n                    idText = stripQuotes(originalIdText) + ".d.str";\n                    symbol = search(idText);\n                }\n\n                // If the literal path doesn\'t work, begin the search\n                if (!symbol && !isRelative(originalIdText)) {\n                    // check the full path first, as this is the most likely scenario\n                    idText = originalIdText;\n\n                    var strippedIdText = stripQuotes(idText);\n\n                    // REVIEW: Technically, we shouldn\'t have to normalize here - we should normalize in addUnit.\n                    // Still, normalizing here alows any language services to be free of assumptions\n                    var path = getRootFilePath(switchToForwardSlashes(currentFileName));\n\n                    ',
v27518=v27519+'while (symbol == null && path != "") {\n                        idText = normalizePath(path + strippedIdText + ".ts");\n                        symbol = search(idText);\n\n                        // check for .str\n                        if (symbol == null) {\n                            idText = changePathToSTR(idText);\n                            symbol = search(idText);\n                        }\n\n                        // check for .d.ts\n                        if (symbol == null) {\n                            idText = changePathToDTS(idText);\n                            symbol = search(idText);\n                        }\n\n                        // check for .d.str\n                        if (symbol == null) {\n                            idText = changePathToDSTR(idText);\n                            symbol = search(idText);\n                        }\n\n                        if (symbol == null) {\n\t\t\t\t\t\t\tif(path === \'/\') {\n\t\t\t\t\t\t\t\tpath = \'\';\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpath = normalizePath(path + "..");\n\t\t\t\t\t\t\t\tpath = path && path != \'/\' ? path + \'/\' : path;\n\t\t\t\t\t\t\t}\n                        }\n                    }\n                }\n            }\n\n            return symbol;\n        }\n\n        public resolveTypeMember(scope: SymbolScope, dotNode: BinaryExpression): Type {\n            var lhs = dotNode.operand1;\n            var rhs = dotNode.operand2;\n            var resultType = this.anyType;\n            var lhsType = this.anyType;\n\n            if (lhs && rhs && (rhs.nodeType == NodeType.Name)) {\n                if (lhs.nodeType == NodeType.Dot) {\n                    lhsType = this.resolveTypeMember(scope, <BinaryExpression>lhs);\n                }\n                else if (lhs.nodeType == NodeType.Name) {\n                    var identifier = <Identifier>lhs;\n                    var symbol = scope.find(identifier.text, false, true);\n                    if (symbol == null) {\n                        this.errorReporter.unresolvedSymbol(identifier, identifier.actualText);\n                    }\n                    else if (symbol.isType()) {\n\n                        var typeSymbol = <TypeSymbol> symbol;\n\n                        if (typeSymbol.aliasLink && !typeSymbol.type && typeSymbol.aliasLink.alias.nodeType == NodeType.Name) {\n                            var modPath = (<Identifier>typeSymbol.aliasLink.alias).text;\n                            var modSym = this.findSymbolForDynamicModule(modPath, this.locationInfo.filename, (id) => scope.find(id, false, true));\n                            if (modSym) {\n                                typeSymbol.type = modSym.getType();\n                            }\n                        }\n\n                        if (optimizeModuleCodeGen && symbol) {\n                            var symType = symbol.getType();\n                            // Once the type has been referenced outside of a type ref position, there\'s\n                            // no going back                        \n                            if (symType && typeSymbol.aliasLink && typeSymbol.onlyReferencedAsTypeRef) {\n\n                                var modDecl = <ModuleDeclaration>symType.symbol.declAST;\n                                if (modDecl && hasFlag(modDecl.modFlags, ModuleFlags.IsDynamic)) {\n                                    typeSymbol.onlyReferencedAsTypeRef = !this.resolvingBases;\n                                }\n                            }\n                        }\n                        if (!symbol.visible(scope, this)) {\n                            this.errorReporter.simpleError(lhs, "The symbol \'" + identifier.actualText + "\' is not visible at this point");\n                        }\n                        lhsType = symbol.getType();\n\n                        identifier.sym = symbol;\n                    }\n                    else {\n                        this.errorReporter.simpleError(lhs, "Expected type");\n                    }\n\n                }\n\n                // if the LHS type is a module alias, we won\'t be able to resolve it until\n                // typecheck type.  If this is called during binding, lhsType will be null\n                if (!lhsType) {\n                    lhsType = this.anyType;\n                }\n\n                if (lhsType != this.anyType) {\n                    var rhsIdentifier = <Identifier>rhs;\n                    var resultSymbol = this.lookupMemberTypeSymbol(lhsType, rhsIdentifier.text);\n                    if (resultSymbol == null) {\n                        resultType = this.anyType;\n                        this.errorReporter.simpleError(dotNode, "Expected type");\n                    }\n                    else {\n                        resultType = resultSymbol.getType();\n                        if (!resultSymbol.visible(scope, this)) {\n                            this.errorReporter.simpleError(lhs, "The symbol \'" + (<Identifier>rhs).actualText + "\' is not visible at this point");\n                        }\n                    }\n                    rhsIdentifier.sym =',
v27517=v27518+' resultType.symbol;\n                }\n            }\n            if (resultType.isClass()) {\n                resultType = resultType.instanceType;\n            }\n            return resultType;\n        }\n\n        public resolveFuncDecl(funcDecl: FuncDecl, scope: SymbolScope,\n            fgSym: TypeSymbol): Symbol {\n            var functionGroupSymbol = this.createFunctionSignature(funcDecl, scope.container, scope, fgSym, false).declAST.type.symbol;\n            var signatures: Signature[];\n            if (funcDecl.isConstructMember()) {\n                signatures = functionGroupSymbol.type.construct.signatures;\n            }\n            else if (funcDecl.isIndexerMember()) {\n                signatures = functionGroupSymbol.type.getInstanceType().index.signatures;\n            }\n            else {\n                signatures = functionGroupSymbol.type.call.signatures;\n            }\n\n            var signature = signatures[signatures.length - 1];\n            var len = signature.parameters.length;\n            for (var i = 0; i < len; i++) {\n                var paramSym: ParameterSymbol = signature.parameters[i];\n                this.resolveTypeLink(scope, paramSym.parameter.typeLink, true);\n            }\n\n            // If a vararg list is present, check that the type is an array type\n            if (len && funcDecl.variableArgList) {\n                if (!signature.parameters[len - 1].parameter.typeLink.type.elementType) {\n                    this.errorReporter.simpleErrorFromSym(signature.parameters[len - 1].parameter.symbol, "... parameter must have array type");\n                    signature.parameters[len - 1].parameter.typeLink.type = this.makeArrayType(signature.parameters[len - 1].parameter.typeLink.type);\n                }\n            }\n            this.resolveTypeLink(scope, signature.returnType,\n                            funcDecl.isSignature());\n            return functionGroupSymbol;\n        }\n\n        public resolveVarDecl(varDecl: VarDecl, scope: SymbolScope): Symbol {\n            var field = new ValueLocation();\n            var fieldSymbol =\n                new FieldSymbol(varDecl.id.text, varDecl.minChar, this.locationInfo.unitIndex,\n                                (varDecl.varFlags & VarFlags.Readonly) == VarFlags.None,\n                                field);\n            fieldSymbol.transferVarFlags(varDecl.varFlags);\n            field.symbol = fieldSymbol;\n            fieldSymbol.declAST = varDecl;\n            field.typeLink = getTypeLink(varDecl.typeExpr, this, varDecl.init == null);\n            this.resolveTypeLink(scope, field.typeLink, true);\n            varDecl.sym = fieldSymbol;\n            varDecl.type = field.typeLink.type;\n            return fieldSymbol;\n        }\n\n        public resolveTypeLink(scope: SymbolScope, typeLink: TypeLink, supplyVar: bool): void {\n            var arrayCount = 0;\n            if (typeLink.type == null) {\n                var ast: AST = typeLink.ast;\n                if (ast) {\n                    while (typeLink.type == null) {\n                        switch (ast.nodeType) {\n                            case NodeType.Name:\n                                var identifier = <Identifier>ast;\n                                var symbol = scope.find(identifier.text, false, true);\n                                if (symbol == null) {\n                                    typeLink.type = this.anyType;\n                                    this.errorReporter.unresolvedSymbol(identifier, identifier.actualText);\n                                }\n                                else if (symbol.isType()) {\n                                    if (!symbol.visible(scope, this)) {\n                                        this.errorReporter.simpleError(ast, "The symbol \'" + identifier.actualText + "\' is not visible at this point");\n                                    }\n                                    identifier.sym = symbol;\n                                    typeLink.type = symbol.getType();\n                                    if (typeLink.type) {\n                                        if (typeLink.type.isClass()) {\n                                            typeLink.type = typeLink.type.instanceType;\n                                        }\n                                    }\n                                    else {\n                                        typeLink.type = this.anyType;\n                                    }\n                                }\n                                else {\n                                    typeLink.type = this.anyType;\n                                    this.errorReporter.simpleError(ast, "Expected type");\n                                }\n                                break;\n                            case NodeType.Dot:\n                                typeLink.type = this.resolveTypeMember(scope, <BinaryExpression>ast);\n                                break;\n                            case NodeType.TypeRef:\n                       ',
v27516=v27517+'         var typeRef = <TypeReference>ast;\n                                arrayCount = typeRef.arrayCount;\n                                ast = typeRef.term;\n                                if (ast == null) {\n                                    typeLink.type = this.anyType;\n                                }\n                                break;\n                            case NodeType.InterfaceDeclaration:\n                                var interfaceDecl = <InterfaceDeclaration>ast;\n                                var interfaceType = new Type();\n                                var interfaceSymbol = new TypeSymbol((<Identifier>interfaceDecl.name).text,\n                                                                   ast.minChar,\n                                                                   ast.limChar - ast.minChar,\n                                                                   this.locationInfo.unitIndex,\n                                                                   interfaceType);\n                                interfaceType.symbol = interfaceSymbol;\n                                interfaceType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n\n                                interfaceType.containedScope =\n                                    new SymbolTableScope(interfaceType.members, null, null, null,\n                                                         interfaceSymbol);\n\n                                interfaceType.containedScope.container = interfaceSymbol;\n                                interfaceType.memberScope = interfaceType.containedScope;\n\n                                var memberList = <ASTList>interfaceDecl.members;\n                                var props: AST[] = memberList.members;\n                                var propsLen = props.length;\n\n                                for (var j = 0; j < propsLen; j++) {\n                                    var propDecl = props[j];\n                                    var propSym: Symbol = null;\n                                    var addMember = true;\n                                    var id: Identifier = null;\n                                    if (propDecl.nodeType == NodeType.FuncDecl) {\n                                        var funcDecl = <FuncDecl>propDecl;\n                                        id = funcDecl.name;\n                                        propSym = interfaceType.members.allMembers.lookup(funcDecl.getNameText());\n                                        addMember = (propSym == null);\n                                        if (funcDecl.isSpecialFn()) {\n                                            addMember = false;\n                                            propSym = this.resolveFuncDecl(funcDecl, scope, interfaceSymbol);\n                                        }\n                                        else {\n                                            propSym = this.resolveFuncDecl(funcDecl, scope, <TypeSymbol>propSym);\n                                        }\n                                        funcDecl.type = (<TypeSymbol>propSym).type;\n                                    }\n                                    else {\n                                        id = (<VarDecl>propDecl).id;\n                                        propSym = this.resolveVarDecl(<VarDecl>propDecl, scope);\n\n                                        // Don\'t add the member if it was missing a name.  This \n                                        // generally just leads to cascading errors that make things\n                                        // more confusing for the user.\n                                        addMember = !id.isMissing();\n                                    }\n\n                                    if (addMember) {\n                                        if (id && hasFlag(id.flags, ASTFlags.OptionalName)) {\n                                            propSym.flags |= SymbolFlags.Optional;\n                                        }\n                                        if (!interfaceType.members.allMembers.add(propSym.name, propSym)) {\n                                            this.errorReporter.duplicateIdentifier(ast, propSym.name);\n                                        }\n                                    }\n                                }\n\n                                ast.type = interfaceType;\n                                typeLink.type = interfaceType;\n\n                                break;\n                            case NodeType.FuncDecl:\n                                var tsym = <TypeSymbol>this.resolveFuncDecl(<FuncDecl>ast, scope, null);\n                                typeLink.type = tsym.type;\n                                break;\n                            default:\n                                typeLink.type = this.anyType;\n                                this.errorReporter.simpleError(ast, "Expected type");\n                ',
v27515=v27516+'                break;\n                        }\n                    }\n                }\n                for (var count = arrayCount; count > 0; count--) {\n                    typeLink.type = this.makeArrayType(typeLink.type);\n                }\n                if (supplyVar && (typeLink.type == null)) {\n                    typeLink.type = this.anyType;\n                }\n                if (typeLink.ast) {\n                    typeLink.ast.type = typeLink.type;\n                }\n            }\n            // else wait for type inference\n        }\n\n        public resolveBaseTypeLink(typeLink: TypeLink, scope: SymbolScope) {\n            this.resolvingBases = true;\n            this.resolveTypeLink(scope, typeLink, true);\n            this.resolvingBases = false;\n            var extendsType: Type = null;\n            if (typeLink.type.isClass()) {\n                extendsType = typeLink.type.instanceType;\n            }\n            else {\n                extendsType = typeLink.type;\n            }\n\n            return extendsType;\n        }\n\n        public findMostApplicableSignature(signatures: ApplicableSignature[], args: ASTList): { sig: Signature; ambiguous: bool; } {\n\n            if (signatures.length == 1) {\n                return { sig: signatures[0].signature, ambiguous: false };\n            }\n\n            var best: ApplicableSignature = signatures[0];\n            var Q: ApplicableSignature = null;\n            var AType: Type = null;\n            var PType: Type = null;\n            var QType: Type = null;\n            var ambiguous = false;\n\n            for (var qSig = 1; qSig < signatures.length; qSig++) {\n                Q = signatures[qSig];\n                var i = 0;\n                // find the better conversion\n                for (i = 0; args && i < args.members.length; i++) {\n                    AType = args.members[i].type;\n                    PType = i < best.signature.parameters.length ? best.signature.parameters[i].getType() : best.signature.parameters[best.signature.parameters.length - 1].getType().elementType;\n                    QType = i < Q.signature.parameters.length ? Q.signature.parameters[i].getType() : Q.signature.parameters[Q.signature.parameters.length - 1].getType().elementType;\n\n                    if (this.typesAreIdentical(PType, QType)) {\n                        continue;\n                    }\n                    else if (this.typesAreIdentical(AType, PType)) {\n                        break;\n                    }\n                    else if (this.typesAreIdentical(AType, QType)) {\n                        best = Q;\n                        break;\n                    }\n                    else if (this.sourceIsSubtypeOfTarget(PType, QType)) {\n                        break;\n                    }\n                    else if (this.sourceIsSubtypeOfTarget(QType, PType)) {\n                        best = Q;\n                        break;\n                    }\n                    else if (Q.hadProvisionalErrors) {\n                        break;\n                    }\n                    else if (best.hadProvisionalErrors) {\n                        best = Q;\n                        break;\n                    }\n                }\n\n                if (!args || i == args.members.length) {\n                    var collection: ITypeCollection = {\n                        getLength: () => { return 2; },\n                        setTypeAtIndex: (index: number, type: Type) => { }, // no contextual typing here, so no need to do anything\n                        getTypeAtIndex: (index: number) => { return index ? Q.signature.returnType.type : best.signature.returnType.type; } // we only want the "second" type - the "first" is skipped\n                    }\n                    var bct = this.findBestCommonType(best.signature.returnType.type, null, collection, true);\n                    ambiguous = !bct;\n                }\n                else {\n                    ambiguous = false;\n                }\n            }\n\n            return { sig: best.signature, ambiguous: ambiguous };\n        }\n\n        public getApplicableSignatures(signatures: Signature[], args: ASTList, comparisonInfo: TypeComparisonInfo): ApplicableSignature[] {\n\n            var applicableSigs: ApplicableSignature[] = [];\n            var memberType: Type = null;\n            var miss = false;\n            var cxt: ContextualTypeContext = null;\n            var hadProvisionalErrors = false;\n\n            for (var i = 0; i < signatures.length; i++) {\n                miss = false;\n\n                for (var j = 0; j < args.members.length; j++) {\n\n                    if (j >= signatures[i].parameters.length) {\n                        continue;\n                    }\n                    memberType = signatures[i].parameters[j].getType();\n\n                    // account for varargs\n                    if (signatures[i].declAST.variableArgList && (j >= signatures[i].nonOptionalParameterCount - 1) && memberType.isArray()) {\n                        memberType = mem',
v27514=v27515+'berType.elementType;\n                    }\n\n                    if (memberType == this.anyType) {\n                        continue;\n                    }\n                    else if (args.members[j].nodeType == NodeType.FuncDecl) {\n                        if (this.typeFlow.functionInterfaceType && memberType == this.typeFlow.functionInterfaceType) {\n                            continue;\n                        }\n                        if (!this.canContextuallyTypeFunction(memberType, <FuncDecl>args.members[j], true)) {\n                            // if it\'s just annotations that are blocking us, typecheck the function and add it to the list\n                            if (this.canContextuallyTypeFunction(memberType, <FuncDecl>args.members[j], false)) {\n                                this.typeFlow.typeCheck(args.members[j]);\n                                if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {\n                                    break;\n                                }\n                            }\n                            else {\n                                break;\n                            }\n                        }\n                        else { // if it can be contextually typed, try it out...\n\n                            this.typeCheckWithContextualType(memberType, true, true, args.members[j]);\n                            this.cleanStartedPTO();\n                            hadProvisionalErrors = this.hadProvisionalErrors();\n\n                            if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {\n                                if (comparisonInfo) {\n                                    comparisonInfo.setMessage("Could not apply type \'" + memberType.getTypeName() + "\' to argument " + (j + 1) + ", which is of type \'" + args.members[j].type.getTypeName() + "\'");\n                                }\n                                miss = true;\n                            }\n\n                            // clean the type\n                            //if (hadProvisionalErrors) {\n                            //    cxt = this.currentContextualTypeContext;\n                            //    this.typeCheckWithContextualType(null, true, true, args.members[j]);\n                            //    if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType)) {\n                            //        miss = true;\n                            //    }\n                            //    this.cleanStartedPTO();\n                            //}\n\n                            this.resetProvisionalErrors();\n                            if (miss) {\n                                break;\n                            }\n                        }\n                    }\n                    else if (args.members[j].nodeType == NodeType.ObjectLit) {\n                        // now actually attempt to typecheck as the contextual type\n                        if (this.typeFlow.objectInterfaceType && memberType == this.typeFlow.objectInterfaceType) {\n                            continue;\n                        }\n\n                        this.typeCheckWithContextualType(memberType, true, true, args.members[j]);\n                        this.cleanStartedPTO();\n                        hadProvisionalErrors = this.hadProvisionalErrors(); \n\n                        if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {\n                            if (comparisonInfo) {\n                                comparisonInfo.setMessage("Could not apply type \'" + memberType.getTypeName() + "\' to argument " + (j + 1) + ", which is of type \'" + args.members[j].type.getTypeName() + "\'");\n                            }\n                            miss = true;\n                        }\n\n                        // clean the type\n                        //if (hadProvisionalErrors) {\n                        //    this.typeCheckWithContextualType(null, true, true, args.members[j]);\n\n                        //    // is the "cleaned" type even assignable?\n                        //    if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType)) {\n                        //        miss = true;\n                        //    }\n\n                        //    this.cleanStartedPTO();\n                        //}\n\n                        this.resetProvisionalErrors();\n                        if (miss) {\n                            break;\n                        }\n                    }\n                    else if (args.members[j].nodeType == NodeType.ArrayLit) {\n                        // attempt to contextually type the array literal\n                        if (this.typeFlow.arrayInterfaceType && memberType == this.typeFlow.arrayInterfaceType) {\n                            continue;\n                        }\n\n                        this.typeCheckWithContextualType(memberType, true, true, args.members[j]);\n                        thi',
v27513=v27514+'s.cleanStartedPTO();\n                        hadProvisionalErrors = this.hadProvisionalErrors(); \n\n                        if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {\n                            if (comparisonInfo) {\n                                comparisonInfo.setMessage("Could not apply type \'" + memberType.getTypeName() + "\' to argument " + (j + 1) + ", which is of type \'" + args.members[j].type.getTypeName() + "\'");\n                            }\n                            break;\n                        }\n\n                        // clean the type\n                        //if (hadProvisionalErrors) {\n                        //    this.typeCheckWithContextualType(null, true, true, args.members[j]);\n                        //    if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType)) {\n                        //        miss = true;\n                        //    }\n\n                        //    this.cleanStartedPTO();\n                        //}\n\n                        this.resetProvisionalErrors();\n                        if (miss) {\n                            break;\n                        }\n                    }\n                }\n\n                if (j == args.members.length) {\n                    applicableSigs[applicableSigs.length] = { signature: signatures[i], hadProvisionalErrors: hadProvisionalErrors };\n                }\n                hadProvisionalErrors = false;\n            }\n\n            return applicableSigs;\n        }\n\n        public canContextuallyTypeFunction(candidateType: Type, funcDecl: FuncDecl, beStringent: bool): bool {\n\n            // in these cases, we do not attempt to apply a contextual type\n            //  RE: isInlineCallLiteral - if the call target is a function literal, we don\'t want to apply the target type\n            //  to its body - instead, it should be applied to its return type\n            if (funcDecl.isParenthesized ||\n                funcDecl.isMethod() ||\n                beStringent && funcDecl.returnTypeAnnotation ||\n                funcDecl.isInlineCallLiteral) {\n                return false;\n            }\n\n            beStringent = beStringent || (this.typeFlow.functionInterfaceType == candidateType);\n\n            // At this point, if we\'re not being stringent, there\'s no need to check for multiple call sigs\n            // or count parameters - we just want to unblock typecheck\n            if (!beStringent) {\n                return true;\n            }\n\n            // If we\'re coming from an in-scope typecheck, lambdas may not have had function signatures created for them\n            // REVIEW: Should we search out the overload group here?\n            if (!funcDecl.signature) {\n                this.createFunctionSignature(funcDecl, this.typeFlow.scope.container, this.typeFlow.scope, null, null);\n                this.typeFlow.typeCheck(funcDecl);\n            }\n\n            var signature = funcDecl.signature;\n            var paramLen = signature.parameters.length;\n\n            // Check that the argument declarations have no type annotations\n            for (var i = 0; i < paramLen; i++) {\n                var param = signature.parameters[i];\n                var symbol = <ParameterSymbol>param;\n                var argDecl = <ArgDecl>symbol.declAST;\n\n                // REVIEW: a valid typeExpr is a requirement for varargs,\n                // so we may want to revise our invariant\n                if (beStringent && argDecl.typeExpr) {\n                    return false;\n                }\n            }\n\n            if (candidateType.construct && candidateType.call) {\n                return false;\n            }\n\n            var candidateSigs = candidateType.construct ? candidateType.construct : candidateType.call;\n\n            if (!candidateSigs || candidateSigs.signatures.length > 1) {\n                return false;\n            }\n\n            // if we\'re here, the contextual type can be applied to the function\n            return true;\n        }\n\n        public canContextuallyTypeObjectLiteral(targetType: Type, objectLit: UnaryExpression): bool {\n\n            if (targetType == this.typeFlow.objectInterfaceType) {\n                return true;\n            }\n\n            var memberDecls = <ASTList>objectLit.operand;\n\n            if (!(memberDecls && targetType.memberScope)) {\n                return false;\n            }\n\n            var id: AST = null;\n            var targetMember: Symbol = null;\n            var text = "";\n            var foundSyms = {};\n\n            // Check that each property in the object literal is present in the target\n            // type\n            for (var i = 0; i < memberDecls.members.length; i++) {\n                id = (<BinaryExpression>memberDecls.members[i]).operand1;\n\n                if (id.nodeType == NodeType.Name) {\n                    text = (<Identifier>id).text;\n                }\n                else if (id.nodeType == NodeType.QString) {\n                    // TODO: set te',
v27512=v27513+"xt to unescaped string\n                    var idText = (<StringLiteral>id).text;\n                    text = idText.substring(1, idText.length - 1);\n                }\n                else {\n                    return false;\n                }\n\n                targetMember = targetType.memberScope.find(text, true, false);\n\n                if (!targetMember) {\n                    return false;\n                }\n\n                foundSyms[text] = true;\n            }\n\n            // Check that all members in the target type are present in the object literal\n            var targetMembers = targetType.memberScope.getAllValueSymbolNames(true);\n\n            for (var i = 0; i < targetMembers.length; i++) {\n                var memberName = targetMembers[i];\n                var memberSym = targetType.memberScope.find(memberName, true, false);\n\n                if (!foundSyms[targetMembers[i]] &&\n                    !hasFlag(memberSym.flags, SymbolFlags.Optional)) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        public widenType(t: Type) {\n            if (t == this.undefinedType || t == this.nullType) { // REVIEW: not isNullOrUndefinedType for perf reasons\n                return this.anyType;\n            }\n\n            return t;\n        }\n\n        public isNullOrUndefinedType(t: Type) {\n            return t == this.undefinedType || t == this.nullType;\n        }\n\n        public findBestCommonType(initialType: Type, targetType: Type, collection: ITypeCollection, acceptVoid:bool, comparisonInfo?: TypeComparisonInfo) {\n            var i = 0;\n            var len = collection.getLength();\n            var nlastChecked = 0;\n            var bestCommonType = initialType;\n\n            if (targetType) {\n                bestCommonType = bestCommonType ? bestCommonType.mergeOrdered(targetType, this, acceptVoid) : targetType;\n            }\n\n            // it's important that we set the convergence type here, and not in the loop,\n            // since the first element considered may be the contextual type\n            var convergenceType: Type = bestCommonType;\n\n            while (nlastChecked < len) {\n\n                for (i = 0; i < len; i++) {\n\n                    // no use in comparing a type against itself\n                    if (i == nlastChecked) {\n                        continue;\n                    }\n\n                    if (convergenceType && (bestCommonType = convergenceType.mergeOrdered(collection.getTypeAtIndex(i), this, acceptVoid, comparisonInfo))) {\n                        convergenceType = bestCommonType;\n                    }\n\n                    if (bestCommonType == this.anyType || bestCommonType == null) {\n                        break;\n                    }\n                    else if (targetType) { // set the element type to the target type\n                        collection.setTypeAtIndex(i, targetType);\n                    }\n                }\n\n                // use the type if we've agreed upon it\n                if (convergenceType && bestCommonType) {\n                    break;\n                }\n\n                nlastChecked++;\n                if (nlastChecked < len) {\n                    convergenceType = collection.getTypeAtIndex(nlastChecked);\n                }\n            }\n\n            return acceptVoid ? bestCommonType : (bestCommonType == this.voidType ? null : bestCommonType);\n        }\n\n        // Type Identity\n\n        public typesAreIdentical(t1: Type, t2: Type) {\n\n            // This clause will cover both primitive types (since the type objects are shared),\n            // as well as shared brands\n            if (t1 == t2) {\n                return true;\n            }\n\n            if (!t1 || !t2) {\n                return false;\n            }\n\n            if (t1.isClass() || t1.isClassInstance()) {\n                return false;\n            }\n\n            var comboId = (t2.typeID << 16) | t1.typeID;\n\n            if (this.identicalCache[comboId]) {\n                return true;\n            }\n\n            // If one is an enum, and they're not the same type, they're not identical\n            if ((t1.typeFlags & TypeFlags.IsEnum) || (t2.typeFlags & TypeFlags.IsEnum)) {\n                return false;\n            }\n\n            if (t1.isArray() || t2.isArray()) {\n                if (!(t1.isArray() && t2.isArray())) {\n                    return false;\n                }\n                this.identicalCache[comboId] = false;\n                var ret = this.typesAreIdentical(t1.elementType, t2.elementType);\n                if (ret) {\n                    this.subtypeCache[comboId] = true;\n                }\n                else {\n                    this.subtypeCache[comboId] = undefined;\n                }\n\n                return ret;\n            }\n\n            if (t1.primitiveTypeClass != t2.primitiveTypeClass) {\n                return false;\n            }\n\n            this.identicalCache[comboId] = false;\n\n            // properties are identical in na",
v27511=v27512+"me, optionality, and type\n            // REVIEW: TypeChanges - The compiler does not currently check against the members of parent types!\n            // REVIEW: TypeChanges - What about ambientMembers?\n            if (t1.memberScope && t2.memberScope) {\n                var t1MemberKeys = t1.memberScope.getAllValueSymbolNames(true).sort();\n                var t2MemberKeys = t2.memberScope.getAllValueSymbolNames(true).sort();\n\n                if (t1MemberKeys.length != t2MemberKeys.length) {\n                    this.identicalCache[comboId] = undefined;\n                    return false;\n                }\n\n                var t1MemberSymbol: Symbol = null;\n                var t2MemberSymbol: Symbol = null;\n\n                var t1MemberType: Type = null;\n                var t2MemberType: Type = null;\n\n                for (var iMember = 0; iMember < t1MemberKeys.length; iMember++) {\n                    if (t1MemberKeys[iMember] != t2MemberKeys[iMember]) {\n                        this.identicalCache[comboId] = undefined;\n                        return false;\n                    }\n\n                    t1MemberSymbol = <Symbol>t1.memberScope.find(t1MemberKeys[iMember], false, false);\n                    t2MemberSymbol = <Symbol>t2.memberScope.find(t2MemberKeys[iMember], false, false);\n\n                    if ((t1MemberSymbol.flags & SymbolFlags.Optional) != (t2MemberSymbol.flags & SymbolFlags.Optional)) {\n                        this.identicalCache[comboId] = undefined;\n                        return false;\n                    }\n\n                    t1MemberType = t1MemberSymbol.getType();\n                    t2MemberType = t2MemberSymbol.getType();\n\n                    // catch the mutually recursive or cached cases\n                    if (t1MemberType && t2MemberType && (this.identicalCache[(t2MemberType.typeID << 16) | t1MemberType.typeID] != undefined)) {\n                        continue;\n                    }\n\n                    if (!this.typesAreIdentical(t1MemberType, t2MemberType)) {\n                        this.identicalCache[comboId] = undefined;\n                        return false;\n                    }\n                }\n            }\n            else if (t1.memberScope || t2.memberScope) {\n                this.identicalCache[comboId] = undefined;\n                return false;\n            }\n\n            if (!this.signatureGroupsAreIdentical(t1.call, t2.call)) {\n                this.identicalCache[comboId] = undefined;\n                return false;\n            }\n\n            if (!this.signatureGroupsAreIdentical(t1.construct, t2.construct)) {\n                this.identicalCache[comboId] = undefined;\n                return false;\n            }\n\n            if (!this.signatureGroupsAreIdentical(t1.index, t2.index)) {\n                this.identicalCache[comboId] = undefined;\n                return false;\n            }\n\n            this.identicalCache[comboId] = true;\n            return true;\n        }\n\n        public signatureGroupsAreIdentical(sg1: SignatureGroup, sg2: SignatureGroup) {\n\n            // covers the null case\n            if (sg1 == sg2) {\n                return true;\n            }\n\n            // covers the mixed-null case\n            if (!sg1 || !sg2) {\n                return false;\n            }\n\n            if (sg1.signatures.length != sg2.signatures.length) {\n                return false;\n            }\n\n            var sig1: Signature = null;\n            var sig2: Signature = null;\n            var sigsMatch = false;\n\n            // The signatures in the signature group may not be ordered...\n            // REVIEW: Should definition signatures be required to be identical as well?\n            for (var iSig1 = 0; iSig1 < sg1.signatures.length; iSig1++) {\n                sig1 = sg1.signatures[iSig1];\n\n                for (var iSig2 = 0; iSig2 < sg2.signatures.length; iSig2++) {\n                    sig2 = sg2.signatures[iSig2];\n\n                    if (this.signaturesAreIdentical(sig1, sig2)) {\n                        sigsMatch = true;\n                        break;\n                    }\n                }\n\n                if (sigsMatch) {\n                    sigsMatch = false;\n                    continue;\n                }\n\n                // no match found for a specific signature\n                return false;\n            }\n\n            return true;\n        }\n\n        public signaturesAreIdentical(s1: Signature, s2: Signature) {\n\n            if (s1.hasVariableArgList != s2.hasVariableArgList) {\n                return false;\n            }\n\n            if (s1.nonOptionalParameterCount != s2.nonOptionalParameterCount) {\n                return false;\n            }\n\n            if (s1.parameters.length != s2.parameters.length) {\n                return false;\n            }\n\n            if (!this.typesAreIdentical(s1.returnType.type, s2.returnType.type)) {\n                return false;\n            }\n\n            for (var iParam = 0; iParam < s1.parameters.length; iParam++) {\n                if (!thi",
v27510=v27511+"s.typesAreIdentical(s1.parameters[iParam].parameter.typeLink.type, s2.parameters[iParam].parameter.typeLink.type)) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        // Subtyping and Assignment compatibility\n\n        public sourceIsSubtypeOfTarget(source: Type, target: Type, comparisonInfo?: TypeComparisonInfo) { return this.sourceIsRelatableToTarget(source, target, false, this.subtypeCache, comparisonInfo); }\n        public signatureGroupIsSubtypeOfTarget(sg1: SignatureGroup, sg2: SignatureGroup, comparisonInfo?: TypeComparisonInfo) { return this.signatureGroupIsRelatableToTarget(sg1, sg2, false, this.subtypeCache, comparisonInfo); }\n        public signatureIsSubtypeOfTarget(s1: Signature, s2: Signature, comparisonInfo?: TypeComparisonInfo) { return this.signatureIsRelatableToTarget(s1, s2, false, this.subtypeCache, comparisonInfo); }\n\n        public sourceIsAssignableToTarget(source: Type, target: Type, comparisonInfo?: TypeComparisonInfo) { return this.sourceIsRelatableToTarget(source, target, true, this.assignableCache, comparisonInfo); }\n        public signatureGroupIsAssignableToTarget(sg1: SignatureGroup, sg2: SignatureGroup, comparisonInfo?: TypeComparisonInfo) { return this.signatureGroupIsRelatableToTarget(sg1, sg2, true, this.assignableCache, comparisonInfo); }\n        public signatureIsAssignableToTarget(s1: Signature, s2: Signature, comparisonInfo?: TypeComparisonInfo) { return this.signatureIsRelatableToTarget(s1, s2, true, this.assignableCache, comparisonInfo); }\n\n        public sourceIsRelatableToTarget(source: Type, target: Type, assignableTo: bool, comparisonCache: any, comparisonInfo: TypeComparisonInfo) {\n\n            // REVIEW: Does this check even matter?\n            //if (this.typesAreIdentical(source, target)) {\n            //    return true;\n            //}\n            if (source == target) {\n                return true;\n            }\n\n            // An error has already been reported in this case\n            if (!(source && target)) {\n                return true;\n            }\n\n            var comboId = (source.typeID << 16) | target.typeID;\n\n            // In the case of a 'false', we want to short-circuit a recursive typecheck\n            if (comparisonCache[comboId] != undefined) {\n                return true;\n            }\n\n            // this is one difference between subtyping and assignment compatibility\n            if (assignableTo) {\n                if (source == this.anyType || target == this.anyType) {\n                    return true;\n                }\n            }\n            else {\n                // This is one difference between assignment compatibility and subtyping\n                if (target == this.anyType) {\n                    return true;\n                }\n            }\n\n            if (source == this.undefinedType) {\n                return true;\n            }\n\n            if ((source == this.nullType) && (target != this.undefinedType && target != this.voidType)) {\n                return true;\n            }\n\n            // REVIEW: enum types aren't explicitly covered in the spec\n            if (target == this.numberType && (source.typeFlags & TypeFlags.IsEnum)) {\n                return true;\n            }\n            if (source == this.numberType && (target.typeFlags & TypeFlags.IsEnum)) {\n                return true;\n            }\n            if ((source.typeFlags & TypeFlags.IsEnum) || (target.typeFlags & TypeFlags.IsEnum)) {\n                return false;\n            }\n\n            if (source.isArray() || target.isArray()) {\n                if (!(source.isArray() && target.isArray())) {\n                    return false;\n                }\n                comparisonCache[comboId] = false;\n                var ret = this.sourceIsRelatableToTarget(source.elementType, target.elementType, assignableTo, comparisonCache, comparisonInfo);\n                if (ret) {\n                    comparisonCache[comboId] = true;\n                }\n                else {\n                    comparisonCache[comboId] = undefined;\n                }\n\n                return ret;\n            }\n\n            // this check ensures that we only operate on object types from this point forward,\n            // since the checks involving primitives occurred above\n            if (source.primitiveTypeClass != target.primitiveTypeClass) {\n\n                if (target.primitiveTypeClass == Primitive.None) {\n                    if (source == this.numberType && this.typeFlow.numberInterfaceType) {\n                        source = this.typeFlow.numberInterfaceType;\n                    }\n                    else if (source == this.stringType && this.typeFlow.stringInterfaceType) {\n                        source = this.typeFlow.stringInterfaceType;\n                    }\n                    else if (source == this.booleanType && this.typeFlow.booleanInterfaceType) {\n                        source = this.typeFlow.booleanInterfaceType;\n           ",
v27509=v27510+'         }\n                    else {\n                        return false;\n                    }\n                }\n                else {\n                    return false;\n                }\n            }\n\n            comparisonCache[comboId] = false;\n\n            if (source.hasBase(target)) {\n                comparisonCache[comboId] = true;\n                return true;\n            }\n\n            if (this.typeFlow.objectInterfaceType && target == this.typeFlow.objectInterfaceType) {\n                return true;\n            }\n\n            if (this.typeFlow.functionInterfaceType && (source.call || source.construct) && target == this.typeFlow.functionInterfaceType) {\n                return true;\n            }\n\n            // REVIEW: We should perhaps do this, though it wouldn\'t be quite right without generics support\n            //if (this.typeFlow.arrayInterfaceType && (source.index) && target == this.typeFlow.arrayInterfaceType) {\n            //    return true;\n            //}\n\n            // At this point, if the target is a class, but not the source or a parent of the source, bail\n            if (target.isClass() || target.isClassInstance()) {\n                comparisonCache[comboId] = undefined;\n                return false;\n            }\n\n            if (target.memberScope && source.memberScope) {\n                var mPropKeys = target.memberScope.getAllValueSymbolNames(true);\n                var mProp: Symbol = null;\n                var nProp: Symbol = null;\n                var mPropType: Type = null;\n                var nPropType: Type = null;\n                var inferenceSymbol: InferenceSymbol = null;\n\n                for (var iMProp = 0; iMProp < mPropKeys.length; iMProp++) {\n                    mProp = target.memberScope.find(mPropKeys[iMProp], false, false);\n                    nProp = source.memberScope.find(mPropKeys[iMProp], false, false);\n\n                    // methods do not have the "arguments" field\n                    if (mProp.name == "arguments" &&\n                        this.typeFlow.iargumentsInterfaceType &&\n                        (this.typeFlow.iargumentsInterfaceType.symbol.flags & SymbolFlags.CompilerGenerated) &&\n                        mProp.kind() == SymbolKind.Variable &&\n                        (<VariableSymbol>mProp).variable.typeLink.type == this.typeFlow.iargumentsInterfaceType) {\n                        continue;\n                    }\n\n                    if (mProp.isInferenceSymbol()) {\n                        inferenceSymbol = <InferenceSymbol>mProp;\n                        if (inferenceSymbol.typeCheckStatus == TypeCheckStatus.NotStarted) {\n                            // REVIEW: TypeChanges: Does this ever really happen?  Maybe for out-of-order typecheck?\n                            this.typeFlow.typeCheck(mProp.declAST);\n                        }\n                    }\n                    mPropType = mProp.getType();\n\n                    if (!nProp) {\n                        // If it\'s not present on the type in question, look for the property on \'Object\'\n                        if (this.typeFlow.objectInterfaceType) {\n                            nProp = this.typeFlow.objectInterfaceType.memberScope.find(mPropKeys[iMProp], false, false);\n                        }\n\n                        if (!nProp) {\n                            // Now, the property was not found on Object, but the type in question is a function, look\n                            // for it on function\n                            if (this.typeFlow.functionInterfaceType && (mPropType.call || mPropType.construct)) {\n                                nProp = this.typeFlow.functionInterfaceType.memberScope.find(mPropKeys[iMProp], false, false);\n                            }\n\n                            // finally, check to see if the property is optional\n                            if (!nProp) {\n                                if (!(mProp.flags & SymbolFlags.Optional)) {\n                                    comparisonCache[comboId] = undefined;\n                                    if (comparisonInfo) { // only surface the first error\n                                        comparisonInfo.flags |= TypeRelationshipFlags.RequiredPropertyIsMissing;\n                                        comparisonInfo.addMessageToFront("Type \'" + source.getTypeName() + "\' is missing property \'" + mPropKeys[iMProp] + "\' from type \'" + target.getTypeName() + "\'");\n                                    }\n                                    return false;\n                                }\n                                else {\n                                    continue;\n                                }\n                            }\n                        }\n                    }\n\n                    if (nProp.isInferenceSymbol()) {\n                        inferenceSymbol = <InferenceSymbol>nProp;\n                        if (inferenceSymbol.typeCheckStatus == TypeCheckStatus.NotStarted) {\n                            this.typeFlow.type',
v27508=v27509+'Check(nProp.declAST);\n                        }\n                    }\n\n\n                    nPropType = nProp.getType();\n\n                    // catch the mutually recursive or cached cases\n                    if (mPropType && nPropType && (comparisonCache[(nPropType.typeID << 16) | mPropType.typeID] != undefined)) {\n                        continue;\n                    }\n\n                    if (!this.sourceIsRelatableToTarget(nPropType, mPropType, assignableTo, comparisonCache, comparisonInfo)) {\n                        comparisonCache[comboId] = undefined;\n                        if (comparisonInfo) { // only surface the first error\n                            comparisonInfo.flags |= TypeRelationshipFlags.IncompatiblePropertyTypes;\n                            comparisonInfo.addMessageToFront("Types of property \'" + mProp.name + "\' of types \'" + source.getTypeName() + "\' and \'" + target.getTypeName() + "\' are incompatible");\n                        }\n                        return false;\n                    }\n                }\n            }\n\n            // check signature groups\n            if (source.call || target.call) {\n                if (!this.signatureGroupIsRelatableToTarget(source.call, target.call, assignableTo, comparisonCache, comparisonInfo)) {\n                    if (comparisonInfo) {\n                        if (source.call && target.call) {\n                            comparisonInfo.addMessageToFront("Call signatures of types \'" + source.getTypeName() + "\' and \'" + target.getTypeName() + "\' are incompatible");\n                        }\n                        else {\n                            var hasSig = target.call ? target.getTypeName() : source.getTypeName();\n                            var lacksSig = !target.call ? target.getTypeName() : source.getTypeName();\n                            comparisonInfo.setMessage("Type \'" + hasSig + "\' requires a call signature, but Type \'" + lacksSig + "\' lacks one");\n                        }\n                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleSignatures;\n                    }\n                    comparisonCache[comboId] = undefined;\n                    return false;\n                }\n            }\n\n            if (source.construct || target.construct) {\n                if (!this.signatureGroupIsRelatableToTarget(source.construct, target.construct, assignableTo, comparisonCache, comparisonInfo)) {\n                    if (comparisonInfo) {\n                        if (source.construct && target.construct) {\n                            comparisonInfo.addMessageToFront("Construct signatures of types \'" + source.getTypeName() + "\' and \'" + target.getTypeName() + "\' are incompatible");\n                        }\n                        else {\n                            var hasSig = target.construct ? target.getTypeName() : source.getTypeName();\n                            var lacksSig = !target.construct ? target.getTypeName() : source.getTypeName();\n                            comparisonInfo.setMessage("Type \'" + hasSig + "\' requires a construct signature, but Type \'" + lacksSig + "\' lacks one");\n                        }\n                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleSignatures;\n                    }\n                    comparisonCache[comboId] = undefined;\n                    return false;\n                }\n            }\n\n            if (target.index) {\n                var targetIndex = !target.index && this.typeFlow.objectInterfaceType ? this.typeFlow.objectInterfaceType.index : target.index;\n                var sourceIndex = !source.index && this.typeFlow.objectInterfaceType ? this.typeFlow.objectInterfaceType.index : source.index;\n\n                if (!this.signatureGroupIsRelatableToTarget(sourceIndex, targetIndex, assignableTo, comparisonCache, comparisonInfo)) {\n                    if (comparisonInfo) {\n                        comparisonInfo.addMessageToFront("Index signatures of types \'" + source.getTypeName() + "\' and \'" + target.getTypeName() + "\' are incompatible");\n                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleSignatures;\n                    }\n                    comparisonCache[comboId] = undefined;\n                    return false;\n                }\n            }\n\n            comparisonCache[comboId] = true;\n            return true;\n        }\n\n        // REVIEW: TypeChanges: Return an error context object so the user can get better diagnostic info\n        public signatureGroupIsRelatableToTarget(sourceSG: SignatureGroup, targetSG: SignatureGroup, assignableTo: bool, comparisonCache: any, comparisonInfo?: TypeComparisonInfo) {\n            if (sourceSG == targetSG) {\n                return true;\n            }\n\n            if (!(sourceSG && targetSG)) {\n                return false;\n            }\n\n            var mSig: Signature = null;\n            var nSig: Signature = null;\n            var foundMatch = false;\n\n            for (var iMSig = 0; ',
v27507=v27508+'iMSig < targetSG.signatures.length; iMSig++) {\n                mSig = targetSG.signatures[iMSig];\n\n                for (var iNSig = 0; iNSig < sourceSG.signatures.length; iNSig++) {\n                    nSig = sourceSG.signatures[iNSig];\n                    if (this.signatureIsRelatableToTarget(nSig, mSig, assignableTo, comparisonCache, comparisonInfo)) {\n                        foundMatch = true;\n                        break;\n                    }\n                }\n\n                if (foundMatch) {\n                    foundMatch = false;\n                    continue;\n                }\n                return false;\n            }\n\n            return true;\n        }\n\n        public signatureIsRelatableToTarget(sourceSig: Signature, targetSig: Signature, assignableTo: bool, comparisonCache: any, comparisonInfo?: TypeComparisonInfo) {\n\n            if (!sourceSig.parameters || !targetSig.parameters) {\n                return false;\n            }\n\n            var targetVarArgCount = targetSig.hasVariableArgList ? targetSig.nonOptionalParameterCount - 1 : targetSig.nonOptionalParameterCount;\n            var sourceVarArgCount = sourceSig.hasVariableArgList ? sourceSig.nonOptionalParameterCount - 1 : sourceSig.nonOptionalParameterCount;\n\n            if (sourceVarArgCount > targetVarArgCount && !targetSig.hasVariableArgList) {\n                if (comparisonInfo) {\n                    comparisonInfo.flags |= TypeRelationshipFlags.SourceSignatureHasTooManyParameters;\n                    comparisonInfo.addMessageToFront("Call signature expects " + targetVarArgCount + " or fewer parameters");\n                }\n                return false;\n            }\n\n            var sourceReturnType = sourceSig.returnType.type;\n            var targetReturnType = targetSig.returnType.type;\n\n            if (targetReturnType != this.voidType) {\n                if (!this.sourceIsRelatableToTarget(sourceReturnType, targetReturnType, assignableTo, comparisonCache, comparisonInfo)) {\n                    if (comparisonInfo) {\n                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleReturnTypes;\n                        // No need to print this one here - it\'s printed as part of the signature error in sourceIsRelatableToTarget\n                        //comparisonInfo.addMessageToFront("Incompatible return types: \'" + sourceReturnType.getTypeName() + "\' and \'" + targetReturnType.getTypeName() + "\'");\n                    }\n                    return false;\n                }\n            }\n\n            var len = (sourceVarArgCount < targetVarArgCount && sourceSig.hasVariableArgList) ? targetVarArgCount : sourceVarArgCount;\n            var sourceParamType: Type = null;\n            var targetParamType: Type = null;\n            var sourceParamName = "";\n            var targetParamName = "";\n\n            for (var iSource = 0, iTarget = 0; iSource < len; iSource++, iTarget++) {\n\n                if (!sourceSig.hasVariableArgList || iSource < sourceVarArgCount) {\n                    sourceParamType = (<ParameterSymbol>sourceSig.parameters[iSource]).parameter.typeLink.type;\n                    sourceParamName = (<ParameterSymbol>sourceSig.parameters[iSource]).parameter.symbol.name;\n                }\n                else if (iSource == sourceVarArgCount) {\n                    sourceParamType = (<ParameterSymbol>sourceSig.parameters[iSource]).parameter.typeLink.type;\n                    if (sourceParamType.elementType) {\n                        sourceParamType = sourceParamType.elementType;\n                    }\n                    sourceParamName = (<ParameterSymbol>sourceSig.parameters[iSource]).parameter.symbol.name;\n                }\n\n                if (iTarget < targetSig.parameters.length && iTarget < targetVarArgCount) {\n                    targetParamType = (<ParameterSymbol>targetSig.parameters[iTarget]).parameter.typeLink.type;\n                    targetParamName = (<ParameterSymbol>targetSig.parameters[iTarget]).parameter.symbol.name;\n                }\n                else if (targetSig.hasVariableArgList && iTarget == targetVarArgCount) {\n                    targetParamType = (<ParameterSymbol>targetSig.parameters[iTarget]).parameter.typeLink.type;\n                    if (targetParamType.elementType) {\n                        targetParamType = targetParamType.elementType;\n                    }\n                    targetParamName = (<ParameterSymbol>targetSig.parameters[iTarget]).parameter.symbol.name;\n                }\n\n                if (!(this.sourceIsRelatableToTarget(sourceParamType, targetParamType, assignableTo, comparisonCache, comparisonInfo) ||\n                        this.sourceIsRelatableToTarget(targetParamType, sourceParamType, assignableTo, comparisonCache, comparisonInfo))) {\n\n                    if (comparisonInfo) {\n                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleParameterTypes;\n                    }\n                    return false;\n                }\n            }\n   ',
v27506=v27507+'         return true;\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class Continuation {\n        public exceptionBlock = -1;\n        constructor (public normalBlock: number) { }\n    }\n\n    function getBaseTypeLinks(bases: ASTList, baseTypeLinks: TypeLink[]) {\n        if (bases) {\n            var len = bases.members.length;\n            if (baseTypeLinks == null) {\n                baseTypeLinks = new TypeLink[];\n            }\n            for (var i = 0; i < len; i++) {\n                var baseExpr = bases.members[i];\n                var name = baseExpr;\n                var typeLink = new TypeLink();\n                typeLink.ast = name;\n                baseTypeLinks[baseTypeLinks.length] = typeLink;\n            }\n        }\n        return baseTypeLinks;\n    }\n\n    function getBases(type: Type, typeDecl: TypeDeclaration) {\n        type.extendsTypeLinks = getBaseTypeLinks(typeDecl.extendsList, type.extendsTypeLinks);\n        type.implementsTypeLinks = getBaseTypeLinks(typeDecl.implementsList, type.implementsTypeLinks);\n    }\n\n    function addPrototypeField(classType: Type, ast: AST, context: TypeCollectionContext) {\n        var field = new ValueLocation();\n        field.typeLink = new TypeLink();\n        field.typeLink.ast = ast;\n        field.typeLink.type = classType.instanceType;\n\n        var fieldSymbol =\n            new FieldSymbol("prototype", ast.minChar,\n                            context.checker.locationInfo.unitIndex, true, field);\n        fieldSymbol.flags |= (SymbolFlags.Property | SymbolFlags.BuiltIn);\n        field.symbol = fieldSymbol;\n        fieldSymbol.declAST = ast;\n        classType.members.addPublicMember("prototype", fieldSymbol);\n    }\n\n    export function createNewConstructGroupForType(type: Type) {\n        var signature = new Signature();\n        signature.returnType = new TypeLink();\n        signature.returnType.type = type.instanceType;\n        signature.parameters = [];\n\n        type.construct = new SignatureGroup();\n        type.construct.addSignature(signature);     \n    }\n\n    export function cloneParentConstructGroupForChildType(child: Type, parent: Type) {\n        child.construct = new SignatureGroup();\n        var sig: Signature = null;\n\n        if (!parent.construct) {\n            createNewConstructGroupForType(parent);\n        }\n\n        for (var i = 0; i < parent.construct.signatures.length; i++) { \n            sig = new Signature();\n            sig.parameters = parent.construct.signatures[i].parameters;\n            sig.nonOptionalParameterCount = parent.construct.signatures[i].nonOptionalParameterCount;\n            sig.typeCheckStatus = parent.construct.signatures[i].typeCheckStatus;\n            sig.declAST = parent.construct.signatures[i].declAST;\n            sig.returnType = new TypeLink();\n            sig.returnType.type = child.instanceType;\n            child.construct.addSignature(sig);\n        }\n\n    }\n\n    export var globalId = "__GLO";\n\n    export interface IAliasScopeContext {\n        topLevelScope: ScopeChain;\n        members: IHashTable;\n        tcContext: TypeCollectionContext;\n    }\n\n    function findTypeSymbolInScopeChain(name: string, scopeChain: ScopeChain): Symbol {\n        var symbol = scopeChain.scope.find(name, false, true);\n\n        if (symbol == null && scopeChain.previous) {\n            symbol = findTypeSymbolInScopeChain(name, scopeChain.previous);\n        }\n\n        return symbol;\n    }\n\n    function findSymbolFromAlias(alias: AST, context: IAliasScopeContext): Symbol {\n        var symbol: Symbol = null;\n        switch (alias.nodeType) {\n            case NodeType.Name:\n                var name = (<Identifier>alias).text;\n                var isDynamic = isQuoted(name);\n\n                var findSym = (id: string) => {\n                    if (context.members) {\n                        return context.members.lookup(name);\n                    }\n                    else {\n                        return findTypeSymbolInScopeChain(name, context.topLevelScope);\n                    }\n                }\n\n                if (isDynamic) {\n                    symbol = context.tcContext.checker.findSymbolForDynamicModule(name, context.tcContext.script.locationInfo.filename, findSym);\n                }\n                else {\n                    symbol = findSym(name);\n                }\n\n                break;\n\n     ',
v27505=v27506+"       case NodeType.Dot:\n                var dottedExpr = <BinaryExpression>alias;\n                var op1Sym = findSymbolFromAlias(dottedExpr.operand1, context);\n\n                if (op1Sym && op1Sym.getType()) {\n                    symbol = findSymbolFromAlias(dottedExpr.operand2, context);\n                }\n\n                break;\n\n            default:\n                break;\n        }\n\n        if (symbol) {\n            var symType = symbol.getType();\n            if (symType) {\n                var members = symType.members;\n                if (members) {\n                    context.members = members.publicMembers;\n                }\n            }\n        }\n\n        return symbol;\n    }\n\n    export function preCollectImportTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n        var typeSymbol: TypeSymbol = null;\n        var modType: ModuleType = null;\n        var importDecl = <ImportDeclaration>ast;\n\n        // REVIEW: technically, this call isn't strictly necessary, since we'll find the type during the call to resolveTypeMembers\n        var aliasedModSymbol = findSymbolFromAlias(importDecl.alias, { topLevelScope: scopeChain, members: null, tcContext: context });\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\n\n        if (aliasedModSymbol) {\n            var aliasedModType = aliasedModSymbol.getType();\n\n            if (aliasedModType) {\n                modType = <ModuleType>aliasedModType;\n            }\n        }\n\n        typeSymbol = new TypeSymbol(importDecl.id.text, importDecl.id.minChar, importDecl.limChar - importDecl.minChar,\n                                    context.checker.locationInfo.unitIndex, modType);\n\n        typeSymbol.aliasLink = importDecl;\n\n        if (context.scopeChain.moduleDecl) {\n            typeSymbol.flags |= SymbolFlags.ModuleMember;\n            typeSymbol.declModule = context.scopeChain.moduleDecl;\n        }\n\n        typeSymbol.declAST = importDecl;\n        importDecl.id.sym = typeSymbol;\n        scopeChain.scope.enter(scopeChain.container, ast, typeSymbol,\n                                context.checker.errorReporter, isGlobal, true, false);\n        scopeChain.scope.enter(scopeChain.container, ast, typeSymbol,\n                                context.checker.errorReporter, isGlobal, false, false);\n        return true;\n    }\n\n    export function preCollectModuleTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n\n        var moduleDecl: ModuleDeclaration = <ModuleDeclaration>ast;\n\n        var isAmbient = hasFlag(moduleDecl.modFlags, ModuleFlags.Ambient);\n        var isEnum = hasFlag(moduleDecl.modFlags, ModuleFlags.IsEnum);\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\n        var isExported = hasFlag(moduleDecl.modFlags, ModuleFlags.Exported);\n        var modName = (<Identifier>moduleDecl.name).text;\n\n        var isDynamic = isQuoted(modName);\n\n        var symbol = scopeChain.scope.findLocal(modName, false, false);\n        var typeSymbol: TypeSymbol = null;\n        var modType: ModuleType = null;\n        if ((symbol == null) || (symbol.kind() != SymbolKind.Type)) {\n\n            if (modType == null) {\n                var enclosedTypes = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                var ambientEnclosedTypes = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                modType = new ModuleType(enclosedTypes, ambientEnclosedTypes);\n                if (isEnum) {\n                    modType.typeFlags |= TypeFlags.IsEnum;\n                }\n                modType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                modType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                modType.setHasImplementation();\n            }\n\n            typeSymbol = new TypeSymbol(modName, moduleDecl.name.minChar, modName.length,\n                                        context.checker.locationInfo.unitIndex, modType);\n            typeSymbol.isDynamic = isQuoted(moduleDecl.prettyName);\n\n            if (context.scopeChain.moduleDecl) {\n                typeSymbol.declModule = context.scopeChain.moduleDecl;\n            }\n            typeSymbol.declAST = moduleDecl;\n            typeSymbol.prettyName = moduleDecl.prettyName;\n            scopeChain.scope.enter(scopeChain.container, ast, typeSymbol,\n                                    context.checker.errorReporter, isExported || isGlobal, true, isAmbient);\n            scopeChain.scope.enter(scopeChain.container, ast, typeSymbol,\n                                    context.checker.errorReporter, isExported || isGlobal, false, isAmbient);\n            modType.symbol = typeSymbol;\n        }\n        else {\n            if (symbol && symbol.declAST && symbol.",
v27504=v27505+"declAST.nodeType != NodeType.ModuleDeclaration) {\n                context.checker.errorReporter.simpleError(moduleDecl, \"Conflicting symbol name for module '\" + modName + \"'\");\n            }\n            typeSymbol = <TypeSymbol>symbol;\n\n            // initialize new private scope for the type\n            var publicEnclosedTypes = typeSymbol.type.getAllEnclosedTypes().publicMembers;\n            var publicEnclosedTypesTable = (publicEnclosedTypes == null) ? new StringHashTable() : publicEnclosedTypes;\n            var enclosedTypes = new ScopedMembers(new DualStringHashTable(publicEnclosedTypesTable, new StringHashTable()));\n\n            var publicEnclosedAmbientTypes = typeSymbol.type.getAllAmbientEnclosedTypes().publicMembers;\n            var publicAmbientEnclosedTypesTable = (publicEnclosedAmbientTypes == null) ? new StringHashTable() : publicEnclosedAmbientTypes;\n            var ambientEnclosedTypes = new ScopedMembers(new DualStringHashTable(publicAmbientEnclosedTypesTable, new StringHashTable()));\n\n            var publicMembers = typeSymbol.type.members.publicMembers;\n            var publicMembersTable = (publicMembers == null) ? new StringHashTable() : publicMembers;\n            var members = new ScopedMembers(new DualStringHashTable(publicMembersTable, new StringHashTable()));\n\n            var publicAmbientMembers = typeSymbol.type.ambientMembers.publicMembers;\n            var publicAmbientMembersTable = (publicAmbientMembers == null) ? new StringHashTable() : publicAmbientMembers;\n            var ambientMembers = new ScopedMembers(new DualStringHashTable(publicAmbientMembersTable, new StringHashTable()));\n\n            modType = new ModuleType(enclosedTypes, ambientEnclosedTypes);\n            if (isEnum) {\n                modType.typeFlags |= TypeFlags.IsEnum;\n            }\n            modType.members = members;\n            modType.ambientMembers = ambientMembers;\n            modType.setHasImplementation();\n            modType.symbol = typeSymbol;\n\n            typeSymbol.addLocation(moduleDecl.minChar);\n            typeSymbol.expansions.push(modType);\n            typeSymbol.expansionsDeclAST.push(moduleDecl);\n\n        }\n        if (context.scopeChain.moduleDecl) {\n            context.scopeChain.moduleDecl.recordNonInterface();\n        }\n        // REVIEW: If multiple disparate module decls for the same module don't agree\n        // in export privileges, how should we handle it?\n        if (isExported) {\n            typeSymbol.flags |= SymbolFlags.Exported;\n        }\n        if ((context.scopeChain.moduleDecl) ||\n            (context.scopeChain.container == context.checker.gloMod)) {\n            typeSymbol.flags |= SymbolFlags.ModuleMember;\n        }\n\n        moduleDecl.mod = modType;\n        pushTypeCollectionScope(typeSymbol, modType.members,\n                                modType.ambientMembers,\n                                modType.enclosedTypes,\n                                modType.ambientEnclosedTypes,\n                                context, null, null, moduleDecl);\n\n        return true;\n    }\n\n    export function preCollectClassTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n        var classDecl = <ClassDeclaration>ast;\n\n        var classType: Type;\n        var instanceType: Type;\n        var typeSymbol: TypeSymbol = null;\n        var className = (<Identifier>classDecl.name).text;\n        var alreadyInScope = false;\n        var isAmbient = hasFlag(classDecl.varFlags, VarFlags.Ambient);\n        var isExported = hasFlag(classDecl.varFlags, VarFlags.Exported);\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\n        var containerMod = <TypeSymbol>scopeChain.container;\n        var foundValSymbol = false;\n\n        typeSymbol = <TypeSymbol>scopeChain.scope.findLocal(className, false, true);\n        \n        // check the value space, since an override may have been declared with the type's name\n        // REVIEW-CLASSES\n        if (!typeSymbol) {\n            var valTypeSymbol = scopeChain.scope.findLocal(className, false, false);\n            \n            if (valTypeSymbol &&\n                valTypeSymbol.isType() &&\n                valTypeSymbol.declAST &&\n                valTypeSymbol.declAST.nodeType == NodeType.FuncDecl &&\n                (<FuncDecl>valTypeSymbol.declAST).isSignature()) {\n                \n                typeSymbol = <TypeSymbol>valTypeSymbol;\n                foundValSymbol = true;\n                \n                if (isExported) {\n                    typeSymbol.flags |= SymbolFlags.Exported;\n                }\n            \n                if (isAmbient) {\n                    typeSymbol.flags |= SymbolFlags.Ambient;\n                }                \n                \n                // the class was never entered into type space, so add it\n                context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol,\n                                            context.checke",
v27503=v27504+"r.errorReporter, isExported || isGlobal, true, isAmbient);                \n            }\n        }\n        \n        if (typeSymbol && !foundValSymbol && (typeSymbol.declAST != classDecl)) {\n            typeSymbol = null;\n        }\n\n        if (typeSymbol == null) {\n            var valueSymbol = scopeChain.scope.findLocal(className, false, false);\n            classType = new Type();\n            classType.setHasImplementation();\n            instanceType = new Type();\n            instanceType.setHasImplementation();\n            classType.instanceType = instanceType;\n            classType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            classType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            addPrototypeField(classType, classDecl, context);\n            instanceType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            instanceType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            typeSymbol = new TypeSymbol(className, classDecl.name.minChar, className.length,\n                                        context.checker.locationInfo.unitIndex, classType);\n            typeSymbol.declAST = classDecl;\n            typeSymbol.instanceType = instanceType;\n            classType.symbol = typeSymbol;\n            instanceType.symbol = typeSymbol;\n\n            if (context.scopeChain.moduleDecl) {\n                context.scopeChain.moduleDecl.recordNonInterface();\n                typeSymbol.declModule = context.scopeChain.moduleDecl;\n                typeSymbol.flags |= SymbolFlags.ModuleMember;\n            }\n\n            if (isExported) {\n                typeSymbol.flags |= SymbolFlags.Exported;\n            }\n            \n            if (isAmbient) {\n                typeSymbol.flags |= SymbolFlags.Ambient;\n            }\n\n            ast.type = classType;\n\n            // class in both name spaces (type for instance type; constructor representative in value space)\n            context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol,\n                                            context.checker.errorReporter, isExported || isGlobal, true, isAmbient);\n\n            if (valueSymbol == null) {\n                context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol,\n                                            context.checker.errorReporter, isExported || isGlobal, false, isAmbient);\n            }\n        }\n        else {                            \n            classType = typeSymbol.type;\n            \n            // If the instance type is null, a call overload was likely declared before the class constructor\n            if (classType.instanceType == null) {\n                classType.instanceType = new Type();\n                classType.instanceType.setHasImplementation();\n                classType.instanceType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                classType.instanceType.symbol = classType.symbol;\n                classType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                classType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            }\n            \n            instanceType = classType.instanceType;\n            ast.type = classType;\n        }\n        \n        // if the class has no declared constructor, either create a default signature or adapt \n        // it's base class's signature group\n        if (!classDecl.constructorDecl) {\n\n            if (typeSymbol && typeSymbol.declAST && typeSymbol.declAST.type && typeSymbol.declAST.type.call && !(<FuncDecl>typeSymbol.declAST).isOverload) {\n                context.checker.errorReporter.duplicateIdentifier(typeSymbol.declAST, typeSymbol.name);\n            }\n\n            createNewConstructGroupForType(classDecl.type);\n        }\n\n        classType.typeFlags |= TypeFlags.IsClass;\n        instanceType.typeFlags |= TypeFlags.IsClass;\n\n        getBases(instanceType, classDecl);\n        pushTypeCollectionScope(typeSymbol, instanceType.members, instanceType.ambientMembers, null, null,\n                                context, instanceType, classType, null);\n        return true;\n    }\n\n    export function preCollectInterfaceTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n        var interfaceDecl = <InterfaceDeclaration>ast;\n        var interfaceSymbol: TypeSymbol = null;\n        var interfaceType: Type = null;\n        var isExported = hasFlag(interfaceDecl.varFlags, VarFlags.Exported);\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\n        var alreadyInScope = true;\n\n        alreadyInScope = false;\n        var ",
v27502=v27503+'interfaceName = (<Identifier>interfaceDecl.name).text;\n        interfaceSymbol = <TypeSymbol>scopeChain.scope.findLocal(interfaceName, false, true);\n        if (interfaceSymbol == null) {\n            interfaceType = new Type();\n            interfaceSymbol = new TypeSymbol(interfaceName,\n                                        interfaceDecl.name.minChar,\n                                        interfaceName.length,\n                                        context.checker.locationInfo.unitIndex,\n                                        interfaceType);\n            interfaceType.symbol = interfaceSymbol;\n            // REVIEW: Shouldn\'t allocate another table for interface privates\n            interfaceType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            interfaceType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            interfaceSymbol.declAST = interfaceDecl;\n            interfaceSymbol.declModule = context.scopeChain.moduleDecl;\n        }\n        else {\n            alreadyInScope = true;\n            interfaceType = interfaceSymbol.type;\n        }\n\n        if (!interfaceType) {\n            interfaceType = context.checker.anyType;\n        }\n\n        ast.type = interfaceType;\n        getBases(interfaceType, interfaceDecl);\n\n        if (isExported) {\n            interfaceSymbol.flags |= SymbolFlags.Exported;\n        }\n\n        if (context.scopeChain.moduleDecl) {\n            interfaceSymbol.flags |= SymbolFlags.ModuleMember;\n        }\n\n        if (!alreadyInScope) {\n            context.scopeChain.scope.enter(context.scopeChain.container, ast,\n                                            interfaceSymbol, context.checker.errorReporter, isGlobal || isExported, true, false); // REVIEW: Technically, interfaces should be ambient\n        }\n        pushTypeCollectionScope(interfaceSymbol, interfaceType.members, interfaceType.ambientMembers, null, null,\n                                context, interfaceType, null, null);\n        return true;\n    }\n\n    export function preCollectArgDeclTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n        var argDecl = <ArgDecl>ast;\n        if (hasFlag(argDecl.varFlags, VarFlags.Public | VarFlags.Private)) {\n            var field = new ValueLocation();\n            var isPrivate = hasFlag(argDecl.varFlags, VarFlags.Private);\n            var fieldSymbol =\n                new FieldSymbol(argDecl.id.text, argDecl.id.minChar,\n                                context.checker.locationInfo.unitIndex,\n                                !hasFlag(argDecl.varFlags, VarFlags.Readonly),\n                                field);\n            fieldSymbol.transferVarFlags(argDecl.varFlags);\n            field.symbol = fieldSymbol;\n            fieldSymbol.declAST = ast;\n            argDecl.parameterPropertySym = fieldSymbol;\n\n            context.scopeChain.scope.enter(context.scopeChain.container, ast,\n                                            fieldSymbol, context.checker.errorReporter, !isPrivate, false, false);\n\n            field.typeLink = getTypeLink(argDecl.typeExpr, context.checker, argDecl.init == null);\n            argDecl.sym = fieldSymbol;\n        }\n        return false;\n    }\n\n    export function preCollectVarDeclTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n        var varDecl = <VarDecl>ast;\n        var isAmbient = hasFlag(varDecl.varFlags, VarFlags.Ambient);\n        var isExported = hasFlag(varDecl.varFlags, VarFlags.Exported);\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\n        var isProperty = hasFlag(varDecl.varFlags, VarFlags.Property);\n        var isStatic = hasFlag(varDecl.varFlags, VarFlags.Static);\n        var isPrivate = hasFlag(varDecl.varFlags, VarFlags.Private);\n        var isOptional = hasFlag(varDecl.id.flags, ASTFlags.OptionalName);\n\n        if (context.scopeChain.moduleDecl) {\n            context.scopeChain.moduleDecl.recordNonInterface();\n        }\n        if (isProperty ||\n            isExported ||\n            (context.scopeChain.container == context.checker.gloMod) ||\n            context.scopeChain.moduleDecl) {\n            if (isAmbient) {\n                var existingSym =\n                    <FieldSymbol>scopeChain.scope.findLocal(varDecl.id.text, false, false);\n                if (existingSym) {\n                    varDecl.sym = existingSym;\n                    return false;\n                }\n            }\n\n            // Defensive error detection...\n            if (varDecl.id == null) {\n                context.checker.errorReporter.simpleError(varDecl, "Expected variable identifier at this location");\n                return false;\n            }\n\n            var field = new ValueLocation();\n            var fieldSymbol =\n                new FieldSymbol(varDecl.id.text, varDecl.id.minChar,\n         ',
v27501=v27502+'                       context.checker.locationInfo.unitIndex,\n                                (varDecl.varFlags & VarFlags.Readonly) == VarFlags.None,\n                                field);\n            fieldSymbol.transferVarFlags(varDecl.varFlags);\n            if (isOptional) {\n                fieldSymbol.flags |= SymbolFlags.Optional;\n            }\n            field.symbol = fieldSymbol;\n            fieldSymbol.declAST = ast;\n            if ((context.scopeChain.moduleDecl) ||\n                (context.scopeChain.container == context.checker.gloMod)) {\n                fieldSymbol.flags |= SymbolFlags.ModuleMember;\n                fieldSymbol.declModule = context.scopeChain.moduleDecl;\n            }\n\n            // if it\'s static, enter it into the class\'s member list directly\n            if (hasFlag(varDecl.varFlags, VarFlags.Property) && isStatic && context.scopeChain.classType) {\n                if (!context.scopeChain.classType.members.publicMembers.add(varDecl.id.text, fieldSymbol)) {\n                    context.checker.errorReporter.duplicateIdentifier(ast, fieldSymbol.name);\n                }\n                fieldSymbol.container = context.scopeChain.classType.symbol;\n            }\n            else {\n                context.scopeChain.scope.enter(context.scopeChain.container,\n                                                ast,\n                                                fieldSymbol,\n                                                context.checker.errorReporter,\n                                                !isPrivate && (isProperty || isExported || isGlobal || isStatic),\n                                                false,\n                                                isAmbient);\n            }\n\n            if (hasFlag(varDecl.varFlags, VarFlags.Exported)) {\n                fieldSymbol.flags |= SymbolFlags.Exported;\n            }\n\n            field.typeLink = getTypeLink(varDecl.typeExpr, context.checker,\n                                        varDecl.init == null);\n            varDecl.sym = fieldSymbol;\n        }\n        return false;\n    }\n\n    export function preCollectFuncDeclTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n\n        // REVIEW: This will have to change when we move to "export"\n        if (context.scopeChain.moduleDecl) {\n            context.scopeChain.moduleDecl.recordNonInterface();\n        }\n\n        var funcDecl = <FuncDecl>ast;\n        var fgSym: TypeSymbol = null;\n        var nameText = funcDecl.getNameText();\n        var isExported = hasFlag(funcDecl.fncFlags, FncFlags.Exported | FncFlags.ClassPropertyMethodExported);\n        var isStatic = hasFlag(funcDecl.fncFlags, FncFlags.Static);\n        var isPrivate = hasFlag(funcDecl.fncFlags, FncFlags.Private);\n        var isConstructor = funcDecl.isConstructMember() || funcDecl.isConstructor;\n        var containerSym:TypeSymbol = <TypeSymbol> (((funcDecl.isMethod() && isStatic) || funcDecl.isAccessor()) && context.scopeChain.classType ? context.scopeChain.classType.symbol : context.scopeChain.container);\n        var containerScope: SymbolScope = context.scopeChain.scope;\n        var isGlobal = containerSym == context.checker.gloMod;\n        var isOptional = funcDecl.name && hasFlag(funcDecl.name.flags, ASTFlags.OptionalName);\n        var go = false;\n        var foundSymbol = false; \n\n        // If this is a class constructor, the "container" is actually the class declaration\n        if (isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {\n            containerSym = <TypeSymbol>containerSym.container;\n            containerScope = scopeChain.previous.scope;\n        }\n\n        funcDecl.unitIndex = context.checker.locationInfo.unitIndex;\n        \n        // If the parent is the constructor, and this isn\'t an instance method, skip it.\n        // That way, we\'ll set the type during scope assignment, and can be sure that the\n        // function will be placed in the constructor-local scope\n        if (!funcDecl.isConstructor &&\n            containerSym &&\n            containerSym.declAST &&\n            containerSym.declAST.nodeType == NodeType.FuncDecl &&\n            (<FuncDecl>containerSym.declAST).isConstructor &&\n            !funcDecl.isMethod()) {\n            return go;\n        }        \n\n        // Interfaces and overloads\n        if (hasFlag(funcDecl.fncFlags, FncFlags.Signature)) {\n            var instType = context.scopeChain.thisType;                       \n\n            // If the function is static, search in the class type\'s\n            if (nameText && nameText != "__missing") {\n                if (isStatic) {\n                    fgSym = containerSym.type.members.allMembers.lookup(nameText);\n                }\n                else {\n                    // REVIEW: This logic should be symmetric with preCollectClassTypes\n                    fgSym = <TypeSymbol>containerScope.findLocal(nameText, false, false);\n                    \n                 ',
v27500=v27501+"   // If we could not find the function symbol in the value context, look\n                    // in the type context.\n                    // This would be the case, for example, if a class constructor override\n                    // were declared before a call override for a given class\n                    if (fgSym == null) {\n                        fgSym = <TypeSymbol>containerScope.findLocal(nameText, false, true);\n                    }\n                }\n                \n                if (fgSym) {\n                    foundSymbol = true;\n                    \n                    // We'll combine ambient and non-ambient funcdecls during typecheck (for contextual typing).,\n                    // So, if they don't agree, don't use the symbol we've found                    \n                    if (!funcDecl.isSignature() && (hasFlag(funcDecl.fncFlags, FncFlags.Ambient) != hasFlag(fgSym.flags, SymbolFlags.Ambient))) {\n                       fgSym = null;\n                    }\n                }                \n            }\n            \n            // a function with this symbol has not yet been declared in this scope\n            // REVIEW: In the code below, we need to ensure that only function overloads are considered\n            //  (E.g., if a vardecl has the same id as a function or class, we may use the vardecl symbol\n            //  as the overload.)  Defensively, however, the vardecl won't have a type yet, so it should\n            //  suffice to just check for a null type when considering the overload symbol in\n            //  createFunctionSignature\n            if (fgSym == null) {\n                if (!(funcDecl.isSpecialFn())) {                    \n                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, null, !foundSymbol).declAST.type.symbol;\n                }\n                else {\n                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, containerSym, false).declAST.type.symbol;                                                                         \n                }\n                \n                // set the symbol's declAST, which will point back to the first declaration (symbol or otherwise)\n                // related to this symbol\n                if (fgSym.declAST == null || !funcDecl.isSpecialFn()) {\n                    fgSym.declAST = ast;\n                }\n            }\n            else { // there exists a symbol with this name\n                \n                if ((fgSym.kind() == SymbolKind.Type)) {\n\n                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, fgSym, false).declAST.type.symbol;\n                }\n                else {\n                    context.checker.errorReporter.simpleError(funcDecl, \"Function or method '\" + funcDecl.name.actualText + \"' already declared as a property\");\n                }\n            }\n         \n            if (funcDecl.isSpecialFn() && !isStatic) {\n                funcDecl.type = instType ? instType : fgSym.type; \n            }\n            else {\n                funcDecl.type = fgSym.type;\n            }            \n        }\n        else {\n            // declarations\n            \n            if (nameText) {\n                if (isStatic) {\n                    fgSym = containerSym.type.members.allMembers.lookup(nameText);\n                }\n                else {\n                    // in the constructor case, we want to check the parent scope for overloads\n                    if (funcDecl.isConstructor && context.scopeChain.previous) {\n                        fgSym = <TypeSymbol>context.scopeChain.previous.scope.findLocal(nameText, false, false);\n                    }\n                    \n                    if (fgSym == null) {\n                        fgSym = <TypeSymbol>containerScope.findLocal(nameText, false, false);\n                    }\n                }\n                if (fgSym) {\n                    foundSymbol = true;\n                    \n                    if (!isConstructor && fgSym.declAST.nodeType == NodeType.FuncDecl && !(<FuncDecl>fgSym.declAST).isAccessor() && !(<FuncDecl>fgSym.declAST).isSignature()) {\n                        fgSym = null;\n                        foundSymbol = false;\n                    }\n                }                \n            }\n\n            // REVIEW: Move this check into the typecheck phase?  It's only being run over properties...\n            if (fgSym &&\n                !fgSym.isAccessor() &&\n                fgSym.type &&\n                fgSym.type.construct &&\n                fgSym.type.construct.signatures != [] &&\n                (fgSym.type.construct.signatures[0].declAST == null ||\n                    !hasFlag(fgSym.type.construct.signatures[0].declAST.fncFlags, FncFlags.Ambient)) &&\n                !funcDecl.isConstructor) {\n                context.checker.errorReporter.simpleError(funcDecl, \"Functions may not have class overloads\");\n            }\n\n   ",
v27499=v27500+'         if (fgSym && !(fgSym.kind() == SymbolKind.Type) && funcDecl.isMethod() && !funcDecl.isAccessor() && !funcDecl.isConstructor) {\n                context.checker.errorReporter.simpleError(funcDecl, "Function or method \'" + funcDecl.name.actualText + "\' already declared as a property");\n                fgSym.type = context.checker.anyType;\n            }\n            var sig = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, fgSym, !foundSymbol);\n\n            // it\'s a getter or setter function                                   \n            if (((!fgSym || fgSym.declAST.nodeType != NodeType.FuncDecl) && funcDecl.isAccessor()) || (fgSym && fgSym.isAccessor())) {\n                funcDecl.accessorSymbol = context.checker.createAccessorSymbol(funcDecl, fgSym, containerSym.type, (funcDecl.isMethod() && isStatic), true, containerScope, containerSym);\n            }\n\n            funcDecl.type.symbol.declAST = ast;\n            if (funcDecl.isConstructor) { // REVIEW: Remove when classes completely replace oldclass\n                go = true;\n            };\n        }\n        if (isExported) {\n            if (funcDecl.type.call) {\n                funcDecl.type.symbol.flags |= SymbolFlags.Exported;\n            }\n            \n            // Accessors are set to \'exported\' above\n            if (fgSym && !fgSym.isAccessor() && fgSym.kind() == SymbolKind.Type && fgSym.type.call) {\n                fgSym.flags |= SymbolFlags.Exported;\n            }\n        }\n        if (context.scopeChain.moduleDecl && !funcDecl.isSpecialFn()) {\n            funcDecl.type.symbol.flags |= SymbolFlags.ModuleMember;\n            funcDecl.type.symbol.declModule = context.scopeChain.moduleDecl;\n        }\n\n        if (fgSym && isOptional) {\n            fgSym.flags |= SymbolFlags.Optional;\n        }\n\n        return go;\n    }\n\n    export function preCollectTypes(ast: AST, parent: AST, walker: IAstWalker) {\n        var context: TypeCollectionContext = walker.state;\n        var go = false;\n        var scopeChain = context.scopeChain;\n\n        if (ast.nodeType == NodeType.Script) {\n            var script: Script = <Script>ast;\n            context.script = script;\n            go = true;\n        }\n        else if (ast.nodeType == NodeType.List) {\n            go = true;\n        }\n        else if (ast.nodeType == NodeType.ImportDeclaration) {\n            go = preCollectImportTypes(ast, parent, context);\n        }\n        else if (ast.nodeType == NodeType.With) {\n            go = false;\n        }\n        else if (ast.nodeType == NodeType.ModuleDeclaration) {\n            go = preCollectModuleTypes(ast, parent, context);\n        }\n        else if (ast.nodeType == NodeType.ClassDeclaration) {\n            go = preCollectClassTypes(ast, parent, context);\n        }\n        else if (ast.nodeType == NodeType.Block) {\n            go = true;\n        }\n        else if (ast.nodeType == NodeType.InterfaceDeclaration) {\n            go = preCollectInterfaceTypes(ast, parent, context);\n        }\n        // This will be a constructor arg because this pass only traverses\n        // constructor arg lists\n        else if (ast.nodeType == NodeType.ArgDecl) {\n            go = preCollectArgDeclTypes(ast, parent, context);\n        }\n        else if (ast.nodeType == NodeType.VarDecl) {\n            go = preCollectVarDeclTypes(ast, parent, context);\n        }\n        else if (ast.nodeType == NodeType.FuncDecl) {\n            go = preCollectFuncDeclTypes(ast, parent, context);\n        }\n        else {\n            if (ast.isStatementOrExpression() && context.scopeChain.moduleDecl) {\n                context.scopeChain.moduleDecl.recordNonInterface();\n            }\n        }\n        walker.options.goChildren = go;\n        return ast;\n    }\n\n    export function postCollectTypes(ast: AST, parent: AST, walker: IAstWalker) {\n        var context: TypeCollectionContext = walker.state;\n\n        if (ast.nodeType == NodeType.ModuleDeclaration) {\n            popTypeCollectionScope(context);\n        }\n        else if (ast.nodeType == NodeType.ClassDeclaration) {\n            popTypeCollectionScope(context);\n        }\n        else if (ast.nodeType == NodeType.InterfaceDeclaration) {\n            popTypeCollectionScope(context);\n        }\n        return ast;\n    }\n\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class ScopeChain {\n        ',
v27498=v27499+"public thisType: Type;\n        public classType: Type;\n        public fnc: FuncDecl;\n        public moduleDecl: ModuleDeclaration;\n\n        constructor (public container: Symbol, public previous: ScopeChain,\n                     public scope: SymbolScope) { }\n    }\n\n    export class BBUseDefInfo {\n        public defsBySymbol = new bool[];\n        public gen: BitVector;\n        public kill: BitVector;\n        public top: BitVector;\n        // use lists by symbol \n        public useIndexBySymbol = new number[][];\n\n        constructor (public bb: BasicBlock) { }\n\n        public updateTop() {\n            var temp = new BitVector(this.top.bitCount);\n            for (var i = 0, succLen = this.bb.successors.length; i < succLen; i++) {\n                var succ = this.bb.successors[i];\n                if (succ.useDef) {\n                    temp.union(succ.useDef.top);\n                }\n            }\n            temp.difference(this.kill);\n            temp.union(this.gen);\n            var changed = temp.notEq(this.top);\n            this.top = temp;\n            return changed;\n        }\n\n\n        public initialize(useDefContext: UseDefContext) {\n            var defSym = (sym: Symbol, context: UseDefContext) => {\n                if (context.isLocalSym(sym)) {\n                    var index = context.getSymbolIndex(sym);\n                    // clear pending uses\n                    this.useIndexBySymbol[index] = new number[];\n                    this.defsBySymbol[index] = true;\n                }\n            }\n\n            var useSym = (sym: Symbol, context: UseDefContext, ast: AST) => {\n                if (context.isLocalSym(sym)) {\n                    var symIndex = context.getSymbolIndex(sym);\n                    if (this.useIndexBySymbol[symIndex] == undefined) {\n                        this.useIndexBySymbol[symIndex] = new number[];\n                    }\n                    var symUses = this.useIndexBySymbol[symIndex];\n                    var astIndex = context.getUseIndex(ast);\n                    context.addUse(symIndex, astIndex);\n                    symUses.push(astIndex);\n                }\n            }\n\n            function initUseDefPre(cur: AST, parent: AST, walker: IAstWalker) {\n                var context: UseDefContext = walker.state;\n                if (cur == null) {\n                    cur = null;\n                }\n                if (cur.nodeType == NodeType.VarDecl) {\n                    var varDecl = <BoundDecl>cur;\n                    if (varDecl.init || hasFlag(varDecl.varFlags, VarFlags.AutoInit)) {\n                        defSym(varDecl.sym, context);\n                    }\n                }\n                else if (cur.nodeType == NodeType.Name) {\n                    // use\n                    if (parent) {\n                        if (parent.nodeType == NodeType.Asg) {\n                            var asg = <BinaryExpression>parent;\n                            if (asg.operand1 == cur) {\n                                return cur;\n                            }\n                        }\n                        else if (parent.nodeType == NodeType.VarDecl) {\n                            var parentDecl = <BoundDecl>parent;\n                            if (parentDecl.id == cur) {\n                                return cur;\n                            }\n                        }\n                    }\n                    var id = <Identifier>cur;\n                    useSym(id.sym, context, cur);\n                }\n                else if ((cur.nodeType >= NodeType.Asg) && (cur.nodeType <= NodeType.LastAsg)) {\n                    // def\n                    var asg = <BinaryExpression>cur;\n                    if (asg.operand1 && (asg.operand1.nodeType == NodeType.Name)) {\n                        var id = <Identifier>asg.operand1;\n                        defSym(id.sym, context);\n                    }\n                }\n                else if (cur.nodeType == NodeType.FuncDecl) {\n                    walker.options.goChildren = false;\n                }\n\n                return cur;\n            }\n\n            var options = new AstWalkOptions();\n            // traverse ASTs in reverse order of execution (to match uses with preceding defs)\n            options.reverseSiblings = true;\n\n            getAstWalkerFactory().walk(this.bb.content, initUseDefPre, null, options, useDefContext);\n        }\n\n        public initializeGen(useDefContext: UseDefContext) {\n            var symbolLen = this.useIndexBySymbol.length;\n            var bitCount = useDefContext.uses.length;\n            this.gen = new BitVector(bitCount);\n            for (var s = 0; s < symbolLen; s++) {\n                var symUses = this.useIndexBySymbol[s];\n                if ((symUses != undefined) && (symUses.length > 0)) {\n                    for (var u = 0, uLen = symUses.length; u < uLen; u++) {\n                        this.gen.set(symUses[u], true);\n                    }\n                }\n            }\n            this.top = this.gen;\n        }\n\n     ",
v27497=v27498+"   public initializeKill(useDefContext: UseDefContext) {\n            this.kill = new BitVector(this.gen.bitCount);\n            for (var s = 0, symbolLen = this.defsBySymbol.length; s < symbolLen; s++) {\n                if (this.defsBySymbol[s]) {\n                    var globalSymUses = useDefContext.useIndexBySymbol[s];\n                    if (globalSymUses) {\n                        for (var u = 0, useLen = globalSymUses.length; u < useLen; u++) {\n                            this.kill.set(globalSymUses[u], true);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    export class UseDefContext {\n        // global use lists by symbol\n        public useIndexBySymbol = new number[][];\n        // global list of uses (flat)\n        public uses = new AST[];\n        public symbols = new VariableSymbol[];\n        public symbolMap = new StringHashTable();\n        public symbolCount = 0;\n        public func: Symbol;\n\n        constructor () {\n        }\n\n        public getSymbolIndex(sym: Symbol) {\n            var name = sym.name;\n            var index = <number>(this.symbolMap.lookup(name));\n            if (index == null) {\n                index = this.symbolCount++;\n                this.symbols[index] = <VariableSymbol>sym;\n                this.symbolMap.add(name, index);\n            }\n            return index;\n        }\n\n        public addUse(symIndex: number, astIndex: number) {\n            var useBySym = this.useIndexBySymbol[symIndex];\n            if (useBySym == undefined) {\n                useBySym = new number[];\n                this.useIndexBySymbol[symIndex] = useBySym;\n            }\n            useBySym[useBySym.length] = astIndex;\n        }\n\n        public getUseIndex(ast: AST) {\n            this.uses[this.uses.length] = ast;\n            return this.uses.length - 1;\n        }\n\n        public isLocalSym(sym: Symbol) { return (sym && (sym.container == this.func) && (sym.kind() == SymbolKind.Variable)); }\n\n        public killSymbol(sym: VariableSymbol, bbUses: BitVector) {\n            var index: number = this.symbolMap.lookup(sym.name);\n            var usesOfSym = this.useIndexBySymbol[index];\n            for (var k = 0, len = usesOfSym.length; k < len; k++) {\n                bbUses.set(usesOfSym[k], true);\n            }\n        }\n    }\n\n    export class BitVector {\n        static packBits = 30;\n        public firstBits = 0;\n        public restOfBits: number[] = null;\n\n        constructor (public bitCount: number) {\n            if (this.bitCount > BitVector.packBits) {\n                this.restOfBits = new number[];\n                var len = Math.floor(this.bitCount / BitVector.packBits);\n                for (var i = 0; i < len; i++) {\n                    this.restOfBits[i] = 0;\n                }\n            }\n        }\n\n        public set(bitIndex: number, value: bool) {\n            if (bitIndex < BitVector.packBits) {\n                if (value) {\n                    this.firstBits |= (1 << bitIndex);\n                }\n                else {\n                    this.firstBits &= (~(1 << bitIndex));\n                }\n            }\n            else {\n                var offset = Math.floor(bitIndex / BitVector.packBits) - 1;\n                var localIndex = bitIndex % BitVector.packBits;\n                if (value) {\n                    this.restOfBits[offset] |= (1 << localIndex);\n                }\n                else {\n                    this.restOfBits[offset] &= (~(1 << localIndex));\n                }\n            }\n        }\n\n        public map(fn: (index: number) =>any) {\n            var k: number;\n            for (k = 0; k < BitVector.packBits; k++) {\n                if (k == this.bitCount) {\n                    return;\n                }\n                if (((1 << k) & this.firstBits) != 0) {\n                    fn(k);\n                }\n            }\n            if (this.restOfBits) {\n                var len: number;\n                var cumu = BitVector.packBits;\n                for (k = 0, len = this.restOfBits.length; k < len; k++) {\n                    var myBits = this.restOfBits[k];\n                    for (var j = 0; j < BitVector.packBits; j++) {\n                        if (((1 << j) & myBits) != 0) {\n                            fn(cumu);\n                        }\n                        cumu++;\n                        if (cumu == this.bitCount) {\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n\n        // assume conforming sizes\n        public union(b: BitVector) {\n            this.firstBits |= b.firstBits;\n            if (this.restOfBits) {\n                for (var k = 0, len = this.restOfBits.length; k < len; k++) {\n                    var myBits = this.restOfBits[k];\n                    var bBits = b.restOfBits[k];\n                    this.restOfBits[k] = myBits | bBits;\n                }\n            }\n        }\n\n        // assume conforming sizes\n        public interse",
v27496=v27497+'ction(b: BitVector) {\n            this.firstBits &= b.firstBits;\n            if (this.restOfBits) {\n                for (var k = 0, len = this.restOfBits.length; k < len; k++) {\n                    var myBits = this.restOfBits[k];\n                    var bBits = b.restOfBits[k];\n                    this.restOfBits[k] = myBits & bBits;\n                }\n            }\n        }\n\n        // assume conforming sizes\n        public notEq(b: BitVector) {\n            if (this.firstBits != b.firstBits) {\n                return true;\n            }\n            if (this.restOfBits) {\n                for (var k = 0, len = this.restOfBits.length; k < len; k++) {\n                    var myBits = this.restOfBits[k];\n                    var bBits = b.restOfBits[k];\n                    if (myBits != bBits) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        public difference(b: BitVector) {\n            var oldFirstBits = this.firstBits;\n            this.firstBits &= (~b.firstBits);\n            if (this.restOfBits) {\n                for (var k = 0, len = this.restOfBits.length; k < len; k++) {\n                    var myBits = this.restOfBits[k];\n                    var bBits = b.restOfBits[k];\n                    this.restOfBits[k] &= (~bBits);\n                }\n            }\n        }\n    }\n\n    export class BasicBlock {\n        // blocks that branch to the block after this one\n        public predecessors = new BasicBlock[];\n        public index = -1;\n        public markValue = 0;\n        public marked(markBase: number) { return this.markValue > markBase; }\n        public mark() {\n            this.markValue++;\n        }\n        public successors = new BasicBlock[];\n        public useDef: BBUseDefInfo = null;\n        public content = new ASTList();\n        public addSuccessor(successor: BasicBlock): void {\n            this.successors[this.successors.length] = successor;\n            successor.predecessors[successor.predecessors.length] = this;\n        }\n    }\n\n    export interface ITargetInfo {\n        stmt: AST;\n        continueBB: BasicBlock;\n        breakBB: BasicBlock;\n    }\n\n    export class ControlFlowContext {\n        public entry = null;\n        // first unreachable ast for each unreachable code segment\n        public unreachable: AST[] = null;\n        public noContinuation = false;\n        // statements enclosing the current statement\n        public statementStack = new ITargetInfo[];\n        public currentSwitch = new BasicBlock[];\n        public walker: IAstWalker;\n\n        constructor (public current: BasicBlock,\n                     public exit: BasicBlock) {\n            this.entry = this.current;\n        }\n\n        public walk(ast: AST, parent: AST) {\n            return this.walker.walk(ast, parent);\n        }\n\n        public pushSwitch(bb: BasicBlock) {\n            this.currentSwitch.push(bb);\n        }\n\n        public popSwitch() {\n            return this.currentSwitch.pop();\n        }\n\n        public reportUnreachable(er: ErrorReporter) {\n            if (this.unreachable && (this.unreachable.length > 0)) {\n                var len = this.unreachable.length;\n                for (var i = 0; i < len; i++) {\n                    var unreachableAST = this.unreachable[i];\n                    if (unreachableAST.nodeType != NodeType.EndCode) {\n                        er.simpleError(unreachableAST, "unreachable code");\n                    }\n                }\n            }\n        }\n\n        private printAST(ast: AST, outfile: ITextWriter) {\n            var printContext = new PrintContext(outfile, null);\n\n            printContext.increaseIndent();\n            //ast.walk(prePrintAST, postPrintAST, null, printContext);\n            getAstWalkerFactory().walk(ast, prePrintAST, postPrintAST, null, printContext);\n\n            printContext.decreaseIndent();\n        }\n\n        private printBlockContent(bb: BasicBlock, outfile: ITextWriter) {\n            var content = bb.content;\n            for (var i = 0, len = content.members.length; i < len; i++) {\n                var ast = content.members[i];\n                this.printAST(ast, outfile);\n            }\n        }\n\n        public markBase = 0;\n\n        public bfs(nodeFunc: (bb: BasicBlock) =>void , edgeFunc: (node1: BasicBlock, node2: BasicBlock) =>void ,\n            preEdges: () =>void , postEdges: () =>void ) {\n            var markValue = this.markBase++;\n            var q = new BasicBlock[];\n            q[q.length] = this.entry;\n\n            while (q.length > 0) {\n                var bb = q.pop();\n                if (!(bb.marked(markValue))) {\n                    bb.mark();\n                    if (nodeFunc) {\n                        nodeFunc(bb);\n                    }\n                    var succLen = bb.successors.length;\n                    if (succLen > 0) {\n                        if (preEdges) {\n                            preEdges();\n                        }\n                        for',
v27495=v27496+' (var j = succLen - 1; j >= 0; j--) {\n                            var successor = bb.successors[j];\n                            if (!(successor.marked(this.markBase))) {\n                                if (edgeFunc) {\n                                    edgeFunc(bb, successor);\n                                }\n                                q[q.length] = successor;\n                            }\n                        }\n                        if (postEdges) {\n                            postEdges();\n                        }\n                    }\n                }\n            }\n        }\n\n        public linearBBs = new BasicBlock[];\n\n        public useDef(er: ErrorReporter, funcSym: Symbol) {\n            var useDefContext = new UseDefContext();\n            useDefContext.func = funcSym;\n            var useDefInit = (bb: BasicBlock) => {\n                bb.useDef = new BBUseDefInfo(bb);\n                bb.useDef.initialize(useDefContext);\n                this.linearBBs[this.linearBBs.length] = bb;\n            }\n            this.bfs(useDefInit, null, null, null);\n            var i: number, bbLen: number;\n            for (i = 0, bbLen = this.linearBBs.length; i < bbLen; i++) {\n                this.linearBBs[i].useDef.initializeGen(useDefContext);\n                this.linearBBs[i].useDef.initializeKill(useDefContext);\n            }\n            var changed = true;\n\n            while (changed) {\n                changed = false;\n                for (i = 0; i < bbLen; i++) {\n                    changed = this.linearBBs[i].useDef.updateTop() || changed;\n                }\n            }\n\n            var top = this.entry.useDef.top;\n            top.map((index) => {\n                var ast = <Identifier>useDefContext.uses[<number>index];\n                er.simpleError(ast, "use of variable \'" + ast.actualText + "\' that is not definitely assigned");\n            });\n        }\n\n        public print(outfile: ITextWriter) {\n            var index = 0;\n            var node = (bb: BasicBlock) => {\n                if (bb.index < 0) {\n                    bb.index = index++;\n                }\n                if (bb == this.exit) {\n                    outfile.WriteLine("Exit block with index " + bb.index);\n                }\n                else {\n                    outfile.WriteLine("Basic block with index " + bb.index);\n                    this.printBlockContent(bb, outfile);\n                }\n            }\n\n            function preEdges() {\n                outfile.Write("  Branches to ");\n            }\n\n            function postEdges() {\n                outfile.WriteLine("");\n            }\n\n            function edge(node1: BasicBlock, node2: BasicBlock) {\n                if (node2.index < 0) {\n                    node2.index = index++;\n                }\n                outfile.Write(node2.index + " ");\n            }\n\n            this.bfs(node, edge, preEdges, postEdges);\n            if (this.unreachable != null) {\n                for (var i = 0, len = this.unreachable.length; i < len; i++) {\n                    outfile.WriteLine("Unreachable basic block ...");\n                    this.printAST(this.unreachable[i], outfile);\n                }\n            }\n        }\n\n        public pushStatement(stmt: Statement, continueBB: BasicBlock, breakBB: BasicBlock) {\n            this.statementStack.push({ stmt: stmt, continueBB: continueBB, breakBB: breakBB });\n        }\n\n        public popStatement() { return this.statementStack.pop(); }\n\n        public returnStmt() {\n            // TODO: make successor finally block if return stmt inside of try/finally \n            this.current.addSuccessor(this.exit);\n            this.setUnreachable();\n        }\n\n        public setUnreachable() {\n            this.current = null;\n            this.noContinuation = true;\n        }\n\n        public addUnreachable(ast: AST) {\n            if (this.unreachable === null) {\n                this.unreachable = new AST[];\n            }\n            this.unreachable[this.unreachable.length] = ast;\n        }\n\n        public unconditionalBranch(target: AST, isContinue: bool) {\n            var targetBB = null;\n            for (var i = 0, len = this.statementStack.length; i < len; i++) {\n                var targetInfo = this.statementStack[i];\n                if (targetInfo.stmt == target) {\n                    if (isContinue) {\n                        targetBB = targetInfo.continueBB;\n                    }\n                    else {\n                        targetBB = targetInfo.breakBB;\n                    }\n                    break;\n                }\n            }\n            if (targetBB) {\n                this.current.addSuccessor(targetBB);\n            }\n            this.setUnreachable();\n        }\n\n        public addContent(ast: AST): void {\n            if (this.current) {\n                this.current.content.append(ast);\n            }\n        }\n    }\n\n    export interface IResolutionData {\n        actuals: Type[];\n        exactCandidates: Signature[];\n        c',
v27494=v27495+'onversionCandidates: Signature[];\n        id: number;\n    }\n\n    export class ResolutionDataCache {\n        public cacheSize = 16;\n        public rdCache: IResolutionData[] = [];\n        public nextUp: number = 0;\n\n        constructor () {\n            for (var i = 0; i < this.cacheSize; i++) {\n                this.rdCache[i] = {\n                    actuals: new Type[],\n                    exactCandidates: new Signature[],\n                    conversionCandidates: new Signature[],\n                    id: i\n                };\n            }\n        }\n\n        public getResolutionData(): IResolutionData {\n            var rd: IResolutionData = null;\n\n            if (this.nextUp < this.cacheSize) {\n                rd = this.rdCache[this.nextUp];\n            }\n\n            if (rd == null) {\n                this.cacheSize++;\n                rd = {\n                    actuals: new Type[],\n                    exactCandidates: new Signature[],\n                    conversionCandidates: new Signature[],\n                    id: this.cacheSize\n                };\n                this.rdCache[this.cacheSize] = rd;\n            }\n\n            // cache operates as a stack - RD is always served up in-order\n            this.nextUp++;\n\n            return rd;\n        }\n\n        public returnResolutionData(rd: IResolutionData) {\n            // Pop to save on array allocations, which are a bottleneck\n            // REVIEW: On some VMs, Array.pop doesn\'t always pop the last value in the array\n            rd.actuals.length = 0;\n            rd.exactCandidates.length = 0;\n            rd.conversionCandidates.length = 0;\n\n            this.nextUp = rd.id;\n        }\n    }\n\n    export class TypeFlow {\n        public scope: SymbolScope;\n        public globalScope: SymbolScope;\n\n        public thisType: Type;\n        public thisFnc: FuncDecl = null;\n        public thisClassNode: TypeDeclaration = null;\n        public enclosingFncIsMethod = false;\n\n        // REVIEW: Prune in favor of typechecker fields\n        public doubleType: Type;\n        public booleanType: Type;\n        public stringType: Type;\n        public anyType: Type;\n        public regexType: Type;\n        public nullType: Type;\n        public voidType: Type;\n        public arrayAnyType: Type;\n\n        public arrayInterfaceType: Type = null;\n        public stringInterfaceType: Type = null;\n        public objectInterfaceType: Type = null;\n        public functionInterfaceType: Type = null;\n        public numberInterfaceType: Type = null;\n        public booleanInterfaceType: Type = null;\n        public iargumentsInterfaceType: Type = null;\n\n        public currentScript: Script = null;\n\n        public inImportTypeCheck = false;\n        public inTypeRefTypeCheck = false;\n        public inArrayElementTypeCheck = false;\n        public resolutionDataCache = new ResolutionDataCache();\n        public nestingLevel = 0;\n        public inSuperCall = false;\n\n        constructor (public logger: ILogger, public initScope: SymbolScope, public parser: Parser,\n                   public checker: TypeChecker) {\n            this.checker.typeFlow = this;\n            this.scope = this.initScope;\n            this.globalScope = this.initScope;\n            this.doubleType = this.checker.numberType;\n            this.booleanType = this.checker.booleanType;\n            this.stringType = this.checker.stringType;\n            this.anyType = this.checker.anyType;\n            this.regexType = this.anyType;\n            this.nullType = this.checker.nullType;\n            this.voidType = this.checker.voidType;\n            this.arrayAnyType = this.checker.makeArrayType(this.anyType);\n        }\n\n        public initLibs() {\n            var arraySym = this.globalScope.find("Array", false, true);\n            if (arraySym && (arraySym.kind() == SymbolKind.Type)) {\n                this.arrayInterfaceType = (<TypeSymbol>arraySym).type;\n            }\n            var stringSym = this.globalScope.find("String", false, true);\n            if (stringSym && (stringSym.kind() == SymbolKind.Type)) {\n                this.stringInterfaceType = (<TypeSymbol>stringSym).type;\n            }\n            var objectSym = this.globalScope.find("Object", false, true);\n            if (objectSym && (objectSym.kind() == SymbolKind.Type)) {\n                this.objectInterfaceType = (<TypeSymbol>objectSym).type;\n            }\n            var fnSym = this.globalScope.find("Function", false, true);\n            if (fnSym && (fnSym.kind() == SymbolKind.Type)) {\n                this.functionInterfaceType = (<TypeSymbol>fnSym).type;\n            }\n            var numberSym = this.globalScope.find("Number", false, true);\n            if (numberSym && (numberSym.kind() == SymbolKind.Type)) {\n                this.numberInterfaceType = (<TypeSymbol>numberSym).type;\n            }\n            var booleanSym = this.globalScope.find("Boolean", false, true);\n            if (booleanSym && (booleanSym.kind() == SymbolKind.Type)) {\n                this.booleanInterfaceT',
v27493=v27494+'ype = (<TypeSymbol>booleanSym).type;\n            }\n            var regexSym = this.globalScope.find("RegExp", false, true);\n            if (regexSym && (regexSym.kind() == SymbolKind.Type)) {\n                this.regexType = (<TypeSymbol>regexSym).type;\n            }\n        }\n\n        public cast(ast: AST, type: Type): AST {\n            return this.castWithCoercion(ast, type, true, false);\n        }\n\n        public castWithCoercion(ast: AST, type: Type, applyCoercion: bool, typeAssertion: bool): AST {\n            var comparisonInfo = new TypeComparisonInfo();\n            if (this.checker.sourceIsAssignableToTarget(ast.type, type, comparisonInfo) || (typeAssertion && this.checker.sourceIsAssignableToTarget(type, ast.type, comparisonInfo))) {\n                if (applyCoercion) {\n                    if (type == null) {\n                        ast.type = this.anyType;\n                    }\n                    else if (type.isClass()) {\n                        ast.type = type.instanceType;\n                    }\n                    else {\n                        ast.type = type;\n                    }\n                }\n                return ast;\n            }\n            else {\n                this.checker.errorReporter.incompatibleTypes(ast, ast.type, type, null, this.scope, comparisonInfo);\n                return ast;\n            }\n        }\n\n        public inScopeTypeCheck(ast: AST, enclosingScope: SymbolScope): AST {\n            var prevScope = this.scope;\n            this.scope = enclosingScope;\n            var svThisFnc = this.thisFnc;\n            var svThisType = this.thisType;\n            var svThisClassNode = this.thisClassNode;\n            var svCurrentModDecl = this.checker.currentModDecl;\n            var prevMethodStatus = this.enclosingFncIsMethod;\n            var container = this.scope.container;\n            var fnc: FuncDecl = null;\n            while (container) {\n                if (container.kind() == SymbolKind.Type) {\n                    var typeSym = <TypeSymbol>container;\n                    var type = typeSym.type;\n                    if (type.call) {\n                        if (fnc == null) {\n                            // use innermost function\n                            this.enclosingFncIsMethod = typeSym.isMethod;\n                            fnc = <FuncDecl>container.declAST;\n                        }\n                    }\n                    if (type.isClass()) {\n                        this.thisType = type.instanceType;\n                        if (typeSym.declAST &&\n                            (typeSym.declAST.nodeType == NodeType.ClassDeclaration)) {\n                            this.thisClassNode = <TypeDeclaration>typeSym.declAST;\n                        }\n                        // use innermost class\n                        break;\n                    }\n                    if (type.isModuleType()) {\n                        this.checker.currentModDecl = <ModuleDeclaration>typeSym.declAST;\n                        // use innermost module\n                        break;\n                    }\n                }\n                container = container.container;\n            }\n            this.thisFnc = fnc;\n\n            var updated = this.typeCheck(ast);\n\n            this.thisFnc = svThisFnc;\n            this.thisType = svThisType;\n            this.thisClassNode = svThisClassNode;\n            this.checker.currentModDecl = svCurrentModDecl;\n            this.enclosingFncIsMethod = prevMethodStatus;\n            this.scope = prevScope;\n            return updated;\n        }\n\n        public typeCheck(ast: AST): AST {\n            if (ast) {\n                return ast.typeCheck(this);\n            }\n            else {\n                return null;\n            }\n        }\n\n        public inScopeTypeCheckDecl(ast: AST) {\n            if (ast.nodeType == NodeType.VarDecl || ast.nodeType == NodeType.ArgDecl) {\n                this.inScopeTypeCheckBoundDecl(<BoundDecl>ast);\n            }\n            else if (ast.nodeType == NodeType.FuncDecl) {\n\n                var funcDecl = <FuncDecl>ast;\n\n                if (funcDecl.isAccessor()) {\n                    this.typeCheckFunction(funcDecl);\n                }\n            }\n        }\n\n        public inScopeTypeCheckBoundDecl(varDecl: BoundDecl) {\n            var sym = varDecl.sym;\n            var svThisFnc = this.thisFnc;\n            var svThisType = this.thisType;\n            var prevMethodStatus = this.enclosingFncIsMethod;\n            var prevLocationInfo = this.checker.locationInfo;\n            if (sym && sym.container) {\n                var instanceScope = hasFlag(varDecl.varFlags, VarFlags.ClassConstructorProperty) ? sym.container.getType().constructorScope : sym.container.instanceScope();\n                if (hasFlag(varDecl.varFlags, VarFlags.Property) && sym.container.declAST.nodeType == NodeType.FuncDecl) {\n                    this.thisFnc = <FuncDecl>sym.container.declAST;\n                }\n                if (instanceScope) {\n                    var',
v27492=v27493+" prevScope = this.scope;\n                    this.scope = instanceScope;\n                    var container = sym.container;\n                    var svCurrentModDecl = this.checker.currentModDecl;\n                    if (this.checker.units &&\n                        (sym.unitIndex >= 0) &&\n                        (sym.unitIndex < this.checker.units.length)) {\n                        this.checker.locationInfo = this.checker.units[sym.unitIndex];\n                    }\n                    else {\n                        this.checker.locationInfo = unknownLocationInfo;\n                    }\n                    // REVIEW: container linkage for function expressions\n                    while (container) {\n                        if (container.kind() == SymbolKind.Type) {\n                            var typeSym = <TypeSymbol>container;\n                            var type = typeSym.type;\n                            if (type.call) {\n                                this.enclosingFncIsMethod = typeSym.isMethod;\n                            }\n                            if (type.isClass()) {\n                                this.thisType = type.instanceType;\n                            }\n                            if (type.isModuleType()) {\n                                this.checker.currentModDecl = <ModuleDeclaration>container.declAST;\n                                break;\n                            }\n                        }\n                        container = container.container;\n                    }\n\n                    this.typeCheckBoundDecl(varDecl);\n                    this.checker.currentModDecl = svCurrentModDecl;\n                    this.scope = prevScope;\n                }\n            }\n            this.thisFnc = svThisFnc;\n            this.thisType = svThisType;\n            this.checker.locationInfo = prevLocationInfo;\n            this.enclosingFncIsMethod = prevMethodStatus;\n        }\n\n        public resolveBoundDecl(varDecl: BoundDecl) {\n            if (varDecl.typeExpr) {\n                if (varDecl.typeExpr.type == null ||\n                    (varDecl.typeExpr.type && varDecl.typeExpr.type == this.anyType && this.scope) ||\n                    varDecl.typeExpr.type.symbol == null ||\n                    !this.checker.typeStatusIsFinished(varDecl.typeExpr.type.symbol.typeCheckStatus)) {\n                    this.typeCheck(varDecl.typeExpr);\n                }\n                varDecl.type = varDecl.typeExpr.type;\n                if (varDecl.sym) {\n                    varDecl.sym.setType(varDecl.type);\n                }\n            }\n            else if (varDecl.init == null) {\n                if (this.checker.styleSettings.implicitAny) {\n                    this.checker.errorReporter.styleError(varDecl, \"type implicitly set to 'any'\");\n                }\n                varDecl.type = this.anyType;\n                if (varDecl.sym) {\n                    if (varDecl.sym.isType()) {\n                        var tsym = <TypeSymbol>varDecl.sym;\n                        if (tsym.isMethod) {\n                            this.checker.errorReporter.simpleError(varDecl, \"Cannot bind method group to variable.  (Did you mean to use 'declare function' instead of 'declare var'?)\");\n                            return;\n                        }\n                        else {\n                            this.checker.errorReporter.simpleError(varDecl, \"Cannot bind type to variable\");\n                            return;\n                        }\n                    }\n                    varDecl.sym.setType(varDecl.type);\n                }\n            }\n        }\n\n        public typeCheckBoundDecl(varDecl: BoundDecl): VarDecl {\n            // symbol has already been added to the scope\n            var infSym = <InferenceSymbol>varDecl.sym;\n            if (infSym == null) {\n                if (varDecl.init) {\n                    varDecl.init = this.typeCheck(varDecl.init);\n                    varDecl.type = this.checker.widenType(varDecl.init.type);\n                }\n                else {\n                    if (this.checker.styleSettings.implicitAny) {\n                        this.checker.errorReporter.styleError(varDecl, \"type implicitly set to 'any'\");\n                    }\n                    varDecl.type = this.anyType;\n                }\n            }\n            else {\n                if (infSym.typeCheckStatus == TypeCheckStatus.Started) {\n                    if (this.checker.styleSettings.implicitAny) {\n                        this.checker.errorReporter.styleError(varDecl, \"type implicitly set to 'any'\");\n                    }\n                    varDecl.type = this.anyType;\n                    infSym.setType(this.anyType);\n                }\n                else if (infSym.typeCheckStatus == TypeCheckStatus.NotStarted) {\n                    infSym.typeCheckStatus = TypeCheckStatus.Started;\n                    this.checker.addStartedPTO(infSym);\n                    var resolved = false;\n                    if (varDecl.type",
v27491=v27492+" == null) {\n                        // propagate declared type\n                        if (varDecl.typeExpr) {\n                            this.resolveBoundDecl(varDecl);\n                            resolved = true;\n                            varDecl.type = varDecl.typeExpr.type;\n                            infSym.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();\n                        }\n                    }\n\n                    if (varDecl.init) {\n                        // if the bound decl is a function-local static, we need to set the\n                        // encapsulating scope to the function's member scope\n                        var isLocalStatic = hasFlag(varDecl.varFlags, VarFlags.LocalStatic);\n                        var prevScope = this.scope;\n                        var applyTargetType = !varDecl.init.isParenthesized;\n                        if (isLocalStatic) {\n                            this.scope = varDecl.sym.container.getType().memberScope;\n                        }\n\n                        // Mark Lambda expressions with IsPropertyBound flag\n                        if (hasFlag(varDecl.varFlags, VarFlags.Property) && this.thisClassNode) {\n                            getAstWalkerFactory().walk(varDecl.init, (ast: AST, parent: AST, walker: IAstWalker) => {\n                                if (ast && ast.nodeType == NodeType.FuncDecl) {\n                                    if (hasFlag((<FuncDecl>ast).fncFlags, FncFlags.IsFatArrowFunction)) {\n                                        // Found a Lambda, mark it\n                                        (<FuncDecl>ast).fncFlags |= FncFlags.IsPropertyBound;\n                                    }\n                                    // Only mark the top level functions\n                                    walker.options.goChildren = false;\n                                }\n                                return ast;\n                            });\n                        }\n\n                        this.checker.typeCheckWithContextualType(varDecl.type, this.checker.inProvisionalTypecheckMode(), applyTargetType, varDecl.init);\n\n                        this.scope = prevScope;\n                        if (varDecl.type) {\n                            // If the cast is to a target type, in the case of a funcdecl,\n                            // we may overwrite the init's type with one generated from a signature.\n                            // In that case, we need to preserve the contained scope of the actual decl\n                            var preserveScope = false;\n                            var preservedContainedScope = null;\n\n                            if (varDecl.init.type) {\n                                preservedContainedScope = varDecl.init.type.containedScope;\n                                preserveScope = true;\n                                if (varDecl.init.type == this.voidType) {\n                                    this.checker.errorReporter.simpleError(varDecl, \"Cannot assign type 'void' to variable '\" + varDecl.id.actualText + \"'\");\n                                }\n                            }\n\n                            varDecl.init = this.castWithCoercion(varDecl.init, varDecl.type, applyTargetType && !this.checker.inProvisionalTypecheckMode(), false);\n\n                            if (preserveScope && varDecl.init.type.containedScope == null) {\n                                varDecl.init.type.containedScope = preservedContainedScope;\n                            }\n                        }\n                        else {\n                            varDecl.type = this.checker.widenType(varDecl.init.type);\n                            if (varDecl.type == this.voidType) {\n                                this.checker.errorReporter.simpleError(varDecl, \"Cannot assign type 'void' to variable '\" + varDecl.id.actualText + \"'\");\n                                varDecl.type = this.anyType;\n                            }\n                        }\n                        infSym.setType(varDecl.type);\n                    }\n                    else {\n                        if (!resolved) {\n                            this.resolveBoundDecl(varDecl);\n                        }\n                    }\n                    infSym.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();\n                }\n                else if (this.checker.typeStatusIsFinished(infSym.typeCheckStatus) &&\n                         (infSym.declAST != varDecl)) {\n                    if (varDecl.init) {\n                        varDecl.init = this.typeCheck(varDecl.init);\n                        varDecl.type = infSym.getType();\n                        varDecl.init = this.cast(varDecl.init, varDecl.type);\n                    }\n                }\n            }\n            if (varDecl.id && varDecl.sym) {\n                varDecl.id.sym = varDecl.sym;\n            }\n\n            // Check if variable satisfies type privacy\n            if (varDecl.sym && varDecl.sym.con",
v27490=v27491+'tainer) {\n                this.checkTypePrivacy(varDecl.sym.getType(), varDecl.sym, (typeName: string, isModuleName: bool) => this.varPrivacyErrorReporter(varDecl, typeName, isModuleName));\n            }\n            return <VarDecl>varDecl;\n        }\n\n        private varPrivacyErrorReporter(varDecl: BoundDecl, typeName: string, isModuleName: bool) {\n            var typestring = "";\n            if (isModuleName) {\n                var quotestring = "";\n                if (!isQuoted(typeName)) {\n                    quotestring = "\'";\n                }\n                typestring = " is using inaccessible module " + quotestring + typeName + quotestring;\n            } else {\n                typestring = " has or is using private type \'" + typeName + "\'";\n            }\n\n            if (hasFlag(varDecl.varFlags, VarFlags.Public)) {\n                if (varDecl.sym.container.declAST.nodeType == NodeType.InterfaceDeclaration) {\n                    this.checker.errorReporter.simpleError(varDecl, "property \'" + varDecl.sym.name + "\' of exported interface" + typestring);\n                } else {\n                    this.checker.errorReporter.simpleError(varDecl, "public member \'" + varDecl.sym.name + "\' of exported class" + typestring);\n                }\n            } else {\n                this.checker.errorReporter.simpleError(varDecl, "exported variable \'" + varDecl.sym.name + "\'" + typestring);\n            }\n        }\n\n        public typeCheckSuper(ast: AST): AST {\n            if (this.thisType && (this.enclosingFncIsMethod && !this.thisFnc.isStatic()) && this.thisType.baseClass()) {\n                ast.type = this.thisType.baseClass();\n            }\n            else {\n                // redirect \'super\' used within lambdas\n                if (!this.enclosingFncIsMethod &&\n                    this.thisType && this.thisType.baseClass() &&\n                    this.thisFnc && hasFlag(this.thisFnc.fncFlags, FncFlags.IsFatArrowFunction)) {\n                    // Find the closest non lambda function\n                    var enclosingFnc = this.thisFnc.enclosingFnc;\n                    while (hasFlag(enclosingFnc.fncFlags, FncFlags.IsFatArrowFunction)) {\n                        enclosingFnc = enclosingFnc.enclosingFnc;\n                    }\n\n                    // If the lambda is enclosed is a valid member, use the base type\n                    if (enclosingFnc && (enclosingFnc.isMethod() || enclosingFnc.isConstructor) && !enclosingFnc.isStatic()) {\n                        ast.type = this.thisType.baseClass();\n                        enclosingFnc.setHasSuperReferenceInFatArrowFunction();\n                        return ast;\n                    }\n                }\n\n                ast.type = this.anyType;\n                this.checker.errorReporter.invalidSuperReference(ast);\n            }\n            return ast;\n        }\n\n        public typeCheckThis(ast: AST): AST {\n           ast.type = this.anyType;\n            var illegalThisRef = false;\n            if (this.thisFnc == null) {\n                // \'this\' in class bodies should bind to \'any\'\n                if (this.thisType) {\n                    if (this.thisClassNode && this.thisClassNode.nodeType == NodeType.ClassDeclaration) {\n                        illegalThisRef = true;\n                    }\n                    else {\n                        ast.type = this.thisType;\n                    }\n                }\n                else if (this.checker.currentModDecl) {\n                    this.checker.errorReporter.simpleError(ast, "\'this\' may not be referenced within module bodies");\n                }\n            }\n            else {\n                if (this.thisClassNode && (hasFlag(this.thisFnc.fncFlags, FncFlags.IsPropertyBound) || (this.inSuperCall && hasFlag((<ClassDeclaration>this.thisClassNode).varFlags, VarFlags.ClassSuperMustBeFirstCallInConstructor)))) {\n                    illegalThisRef = true;\n                }\n                if (this.thisFnc.isMethod() || this.thisFnc.isConstructor || this.thisFnc.isTargetTypedAsMethod) {\n                    if (this.thisType && !(this.thisFnc.fncFlags & FncFlags.Static)) {\n                        ast.type = this.thisType;\n                    }\n                }\n            }\n\n            // redirect \'this\' used within lambdas\n            if (!this.enclosingFncIsMethod &&\n                this.thisFnc &&\n                hasFlag(this.thisFnc.fncFlags, FncFlags.IsFatArrowFunction)) {\n\n                    // if the enclosing function was bound to a property,\n                    // checkInitSelf would not have been able to mark the \n                    // function for a self init\n                if (this.thisFnc.boundToProperty) {\n                    var container = this.thisFnc.boundToProperty.sym.container;\n                    if (container.declAST.nodeType == NodeType.FuncDecl) {\n                        (<FuncDecl>container.declAST).setHasSelfReference();\n                    }\n                }\n                else {\n         ',
v27489=v27490+'           var encFnc = this.thisFnc.enclosingFnc;\n                    var firstEncFnc = encFnc;\n\n                    while (encFnc) {\n                        if (this.thisClassNode && hasFlag(encFnc.fncFlags, FncFlags.IsPropertyBound)) {\n                            illegalThisRef = true;\n                        }\n\n                        if (!hasFlag(encFnc.fncFlags, FncFlags.IsFatArrowFunction) || encFnc.hasSelfReference()) {\n                            encFnc.setHasSelfReference();\n                            break;\n                        }\n\n                        encFnc = encFnc.enclosingFnc;\n                    }\n\n                    if (!encFnc && firstEncFnc) {\n                        encFnc = firstEncFnc;\n                        encFnc.setHasSelfReference();\n                    }\n                    else if (!encFnc) { // the lambda is bound at the top-level...\n                        if (this.thisClassNode) {\n                            (<ClassDeclaration>this.thisClassNode).varFlags |= VarFlags.MustCaptureThis;\n                        }\n                        else if (this.checker.currentModDecl) {\n                            this.checker.currentModDecl.modFlags |= ModuleFlags.MustCaptureThis;\n                        }\n                        else {\n                            this.checker.mustCaptureGlobalThis = true;\n                        }\n                    }\n\n                    if (encFnc && (encFnc.isMethod() || encFnc.isConstructor) && this.thisType && !hasFlag(encFnc.fncFlags, FncFlags.Static)) {\n                        ast.type = this.thisType;\n                    }\n                }\n            }\n\n            if (illegalThisRef) {\n                this.checker.errorReporter.simpleError(ast, "Keyword \'this\' cannot be referenced in initializers in a class body, or in super constructor calls");\n            }\n            return ast;\n        }\n\n        public setTypeFromSymbol(ast: AST, symbol: Symbol): void {\n            if (symbol.isVariable()) {\n                if (symbol.isInferenceSymbol()) {\n                    var infSym = <InferenceSymbol>symbol;\n                    if (infSym.declAST &&\n                        !this.checker.typeStatusIsFinished(infSym.typeCheckStatus)) {\n                        this.inScopeTypeCheckDecl(infSym.declAST);\n                    }\n                    if (!this.checker.styleSettings.innerScopeDeclEscape) {\n                        if (infSym.declAST && (infSym.declAST.nodeType == NodeType.VarDecl)) {\n                            if (this.nestingLevel < (<VarDecl>infSym.declAST).nestingLevel) {\n                                this.checker.errorReporter.styleError(ast, "Illegal reference to a variable defined in more nested scope");\n                            }\n                        }\n                    }\n                }\n                ast.type = symbol.getType();\n                if (!symbol.writeable()) {\n                    ast.flags = ast.flags & (~(ASTFlags.Writeable));\n                }\n            }\n            else if (symbol.isType()) {\n                ast.type = symbol.getType();\n                ast.flags = ast.flags & (~(ASTFlags.Writeable));\n            }\n            else {\n                ast.type = this.anyType;\n                this.checker.errorReporter.symbolDoesNotReferToAValue(ast, symbol.name);\n            }\n        }\n\n        public typeCheckName(ast: AST): AST {\n            var identifier = <Identifier>ast;\n\n            if (this.checker.inWith) {\n                identifier.type = this.anyType;\n            }\n            else {\n                var typespace = this.inTypeRefTypeCheck;\n                var idText = identifier.text;\n                var originalIdText = idText;\n                var isDynamicModuleName = isQuoted(identifier.text);\n\n                var symbol = this.scope.find(idText, false, typespace);\n\n                if (symbol == null && isDynamicModuleName) {\n                    symbol = this.checker.findSymbolForDynamicModule(idText, this.currentScript.locationInfo.filename, (id) => this.scope.find(id, false, typespace));\n                }\n\n                if (!symbol) {\n                    if (!identifier.isMissing()) {\n                        this.checker.errorReporter.unresolvedSymbol(identifier, identifier.text);\n                    }\n                    identifier.type = this.anyType;\n                }\n                else {\n                    if (optimizeModuleCodeGen && symbol && symbol.isType()) {\n                        var symType = symbol.getType();\n                        // Once the type has been referenced outside of a type ref position, there\'s\n                        // no going back                        \n                        if (symType && (<TypeSymbol>symbol).aliasLink && (<TypeSymbol>symbol).onlyReferencedAsTypeRef) {\n\n                            var modDecl = <ModuleDeclaration>symType.symbol.declAST;\n                            if (modDecl && hasFlag(modDecl.modFlags, ModuleFlags.IsDynamic',
v27488=v27489+")) {\n                                (<TypeSymbol>symbol).onlyReferencedAsTypeRef = this.inTypeRefTypeCheck;\n                            }\n                        }\n                    }\n\n                    if (symbol.declAST &&\n                        symbol.declAST.nodeType == NodeType.FuncDecl &&\n                        !(<FuncDecl>symbol.declAST).returnTypeAnnotation &&\n                        (<FuncDecl>symbol.declAST).signature.typeCheckStatus == TypeCheckStatus.Started) {\n                        (<FuncDecl>symbol.declAST).type.symbol.flags |= SymbolFlags.RecursivelyReferenced;\n                        (<FuncDecl>symbol.declAST).signature.returnType.type = this.anyType;\n                    }\n\n                    this.setTypeFromSymbol(ast, symbol);\n                    identifier.sym = symbol;\n                    if (this.thisFnc) {\n                        if (this.thisFnc.type && symbol.container != this.thisFnc.type.symbol) {\n                            this.thisFnc.freeVariables[this.thisFnc.freeVariables.length] = symbol;\n                        }\n                    }\n                }\n            }\n            return ast;\n        }\n\n        public typeCheckScript(script: Script): Script {\n            this.checker.locationInfo = script.locationInfo;\n            this.scope = this.checker.globalScope;\n\n            // if it's a top-level module, the globals have already been added to the implicit\n            // module decl\n            if (!script.topLevelMod) {\n                this.addLocalsFromScope(this.scope, this.checker.gloMod,\n                                   script.vars, this.checker.globals, true);\n            }\n\n            this.currentScript = script;\n            script.bod = <ASTList>this.typeCheck(script.bod);\n            this.currentScript = null;\n            return script;\n        }\n\n        public typeCheckBitNot(ast: AST): AST {\n            var unex = <UnaryExpression>ast;\n            unex.operand = this.typeCheck(unex.operand);\n            unex.type = this.doubleType;\n            return unex;\n        }\n\n        public typeCheckUnaryNumberOperator(ast: AST): AST {\n            var unex = <UnaryExpression>ast;\n            unex.operand = this.typeCheck(unex.operand);\n            unex.type = this.doubleType;\n            return ast;\n        }\n\n        public typeCheckLogNot(ast: AST): AST {\n            var unex = <UnaryExpression>ast;\n            unex.operand = this.typeCheck(unex.operand);\n            unex.type = this.booleanType;\n            return unex;\n        }\n\n        public astIsWriteable(ast: AST): bool {\n            return hasFlag(ast.flags, ASTFlags.Writeable);\n        }\n\n        public typeCheckIncOrDec(ast: AST): AST {\n            var unex = <UnaryExpression>ast;\n            var lval = unex.operand;\n            if (!this.astIsWriteable(unex)) {\n                this.checker.errorReporter.valueCannotBeModified(unex);\n                unex.type = this.doubleType;\n            }\n            else {\n                unex = <UnaryExpression> this.typeCheckUnaryNumberOperator(ast);\n                if (unex.operand.type != this.checker.numberType && unex.operand.type != this.checker.anyType && !(unex.operand.type.typeFlags & TypeFlags.IsEnum)) {\n                    this.checker.errorReporter.simpleError(ast, \"'++' and '--' may only be applied to operands of type 'number' or 'any'\");\n                }\n            }\n            return unex;\n        }\n\n        public typeCheckBitwiseOperator(ast: AST, assignment: bool): AST {\n            var binex = <BinaryExpression>ast;\n            var resultType: Type = null;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            var leftType = binex.operand1.type;\n            var rightType = binex.operand2.type;\n\n            if (assignment && (!this.astIsWriteable(binex))) {\n                this.checker.errorReporter.valueCannotBeModified(binex);\n            }\n\n            if (this.checker.styleSettings.bitwise) {\n                this.checker.errorReporter.styleError(ast, \"use of \" + nodeTypeTable[binex.nodeType]);\n            }\n\n            if (this.checker.sourceIsSubtypeOfTarget(leftType, this.doubleType) && (this.checker.sourceIsSubtypeOfTarget(rightType, this.doubleType))) {\n                resultType = this.doubleType;\n            }\n            else if ((leftType == this.booleanType) &&\n                     (rightType == this.booleanType)) {\n                resultType = this.booleanType;\n            }\n            else if (leftType == this.anyType) {\n                if ((rightType == this.anyType) ||\n                    (rightType == this.doubleType) ||\n                    (rightType == this.booleanType)) {\n                    resultType = this.anyType;\n                }\n            }\n            else if (rightType == this.anyType) {\n                if ((leftType == this.anyType) ||\n                    (leftType == this.doubleType) ||\n                    (leftType == th",
v27487=v27488+'is.booleanType)) {\n                    resultType = this.anyType;\n                }\n            }\n            if (resultType == null) {\n                resultType = this.anyType;\n                this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType,\n                                                        binex.printLabel(), this.scope);\n            }\n            binex.type = resultType;\n            return binex;\n        }\n\n        public typeCheckArithmeticOperator(ast: AST, assignment: bool): AST {\n            var binex = <BinaryExpression>ast;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            var leftType = binex.operand1.type;\n            var rightType = binex.operand2.type;\n\n            if (assignment && (!this.astIsWriteable(binex.operand1))) {\n                this.checker.errorReporter.valueCannotBeModified(binex);\n            }\n\n            if (this.checker.styleSettings.bitwise &&\n                ((binex.nodeType == NodeType.And) ||\n                (binex.nodeType == NodeType.Or) ||\n                (binex.nodeType == NodeType.AsgAnd) ||\n                (binex.nodeType == NodeType.AsgOr))) {\n                this.checker.errorReporter.styleError(ast, "use of " + nodeTypeTable[binex.nodeType]);\n            }\n\n            if (leftType == null || rightType == null) {\n                this.checker.errorReporter.simpleError(binex, "Could not typecheck arithmetic operation.  Possible recursive typecheck error?");\n                binex.type = this.anyType;\n                return binex;\n            }\n            var nodeType = binex.nodeType;\n\n            if (this.checker.isNullOrUndefinedType(leftType)) {\n                leftType = rightType;\n            }\n            if (this.checker.isNullOrUndefinedType(rightType)) {\n                rightType = leftType;\n            }\n            leftType = this.checker.widenType(leftType);\n            rightType = this.checker.widenType(rightType);\n\n            if (nodeType == NodeType.Add || nodeType == NodeType.AsgAdd) {\n\n                if (leftType == this.checker.stringType || rightType == this.checker.stringType) {\n                    binex.type = this.checker.stringType;\n                }\n                else if (leftType == this.checker.numberType && rightType == this.checker.numberType) {\n                    binex.type = this.checker.numberType;\n                }\n                else if (this.checker.sourceIsSubtypeOfTarget(leftType, this.checker.numberType) && this.checker.sourceIsSubtypeOfTarget(rightType, this.checker.numberType)) {\n                    binex.type = this.checker.numberType;\n                }\n                else if (leftType == this.checker.anyType || rightType == this.checker.anyType) {\n                    binex.type = this.checker.anyType;\n                }\n                else {\n                    binex.type = this.anyType;\n                    this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType,\n                                                            binex.printLabel(), this.scope);\n                }\n            }\n            else {\n                if (leftType == this.checker.numberType && rightType == this.checker.numberType) {\n                    binex.type = this.checker.numberType;\n                }\n                else if (this.checker.sourceIsSubtypeOfTarget(leftType, this.checker.numberType) && this.checker.sourceIsSubtypeOfTarget(rightType, this.checker.numberType)) {\n                    binex.type = this.checker.numberType;\n                }\n                else if (leftType == this.checker.anyType || rightType == this.checker.anyType) {\n                    binex.type = this.checker.numberType;\n                }\n                else {\n                    binex.type = this.anyType;\n                    this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType,\n                                                            binex.printLabel(), this.scope);\n                }\n            }\n\n            return binex;\n        }\n\n        public typeCheckDotOperator(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            var leftIsFnc = false;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            var leftType = binex.operand1.type;\n            var leftScope: SymbolScope = null;\n            // REVIEW: replace with get member scope\n            if (leftType) {\n                if (leftType == this.anyType) {\n                    binex.type = this.anyType;\n                    return binex;\n                }\n                else if (leftType == this.stringType) {\n                    if (this.stringInterfaceType) {\n                        leftScope = this.stringInterfaceType.memberScope;\n                    }\n                    else {\n                        binex.type = this.anyType;\n                        return binex;\n                    }\n                }\n              ',
v27486=v27487+"  else if (leftType == this.doubleType) {\n                    if (this.numberInterfaceType) {\n                        leftScope = this.numberInterfaceType.memberScope;\n                    }\n                    else {\n                        binex.type = this.anyType;\n                        return binex;\n                    }\n                }\n                else if (leftType == this.booleanType) {\n                    if (this.booleanInterfaceType) {\n                        leftScope = this.booleanInterfaceType.memberScope;\n                    }\n                    else {\n                        binex.type = this.anyType;\n                        return binex;\n                    }\n                }\n                else if ((leftType.call || leftType.construct) && leftType.members == null) {\n                    if (this.functionInterfaceType) {\n                        leftScope = this.functionInterfaceType.memberScope;\n                    }\n                    else {\n                        binex.type = this.anyType;\n                        return binex;\n                    }\n                }\n                else if (leftType.elementType) {\n                    if (this.arrayInterfaceType) {\n                        var arrInstType = leftType.elementType.getArrayBase(this.arrayInterfaceType, this.checker);\n                        leftScope = arrInstType.memberScope;\n                    }\n                    else {\n                        binex.type = this.anyType;\n                        return binex;\n                    }\n                }\n                else {\n                    leftScope = leftType.memberScope;\n                }\n            }\n            if (leftScope == null) {\n                this.checker.errorReporter.expectedClassOrInterface(binex);\n                binex.type = this.anyType;\n            }\n            else {\n                var propertyName = <Identifier>binex.operand2;\n                var lhsIsEnclosingType = (this.thisClassNode && binex.operand1.type == this.thisClassNode.type.instanceType) || this.inTypeRefTypeCheck;\n                var symbol = leftScope.find(propertyName.text, !lhsIsEnclosingType, this.inTypeRefTypeCheck); // only search the public members, unless the rhs is a 'this' pointer\n\n                // If the symbol wasn't found, delegate to the appropriate 'virtual' parent type\n                if (!symbol) {\n                    if (this.objectInterfaceType && leftType) {\n                        // check 'Object' for the symbol\n                        if (leftType.isReferenceType()) {\n                            symbol = this.objectInterfaceType.memberScope.find(propertyName.text, false, this.inTypeRefTypeCheck);\n                        }\n                        if (!symbol) {\n                            // check 'Function', if appropriate\n                            if (this.functionInterfaceType && (leftType.call || leftType.construct)) {\n                                symbol = this.functionInterfaceType.memberScope.find(propertyName.text, false, this.inTypeRefTypeCheck);\n                            }\n                        }\n                    }\n                }\n\n                if (!symbol || (!symbol.visible(leftScope, this.checker))) {\n                    binex.type = this.anyType;\n\n                    if (symbol == null) {\n                        this.checker.errorReporter.simpleError(propertyName, \"The property '\" + propertyName.actualText + \"' does not exist on value of type '\" + leftType.getScopedTypeName(this.scope) + \"'\");\n                    }\n                    else if (!this.inTypeRefTypeCheck) {  // if it's a dotted type reference, we'll catch the visibility error during binding\n                        this.checker.errorReporter.simpleError(binex, \"The property '\" + propertyName.actualText + \" on type '\" + leftType.getScopedTypeName(this.scope) + \"' is not visible\");\n                    }\n                }\n                else {\n                    if (symbol.isVariable()) {\n                        if (symbol.isInferenceSymbol()) {\n                            var infSym = <InferenceSymbol>symbol;\n                            if (infSym.declAST && !this.checker.typeStatusIsFinished(infSym.typeCheckStatus)) {\n                                this.inScopeTypeCheckDecl(infSym.declAST);\n                            }\n                        }\n                    }\n                    propertyName.sym = symbol;\n                    binex.type = symbol.getType();\n                }\n            }\n            if (binex.type == null) {\n                binex.type = this.anyType;\n            }\n\n            return binex;\n        }\n\n        public typeCheckBooleanOperator(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            var leftType = binex.operand1.type;\n            var rightType = binex.operand2.type;\n            if ((!",
v27485=v27486+'(this.checker.sourceIsAssignableToTarget(leftType, rightType))) &&\n                (!(this.checker.sourceIsAssignableToTarget(rightType, leftType)))) {\n                this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType, binex.printLabel(), this.scope);\n            }\n            binex.type = this.booleanType;\n            return binex;\n        }\n\n        public typeCheckAsgOperator(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            var applyTargetType = !binex.operand2.isParenthesized;\n            binex.operand1 = this.typeCheck(binex.operand1);\n\n            this.checker.typeCheckWithContextualType(binex.operand1.type, this.checker.inProvisionalTypecheckMode(), applyTargetType, binex.operand2);\n\n            var leftType = binex.operand1.type;\n            var rightType = binex.operand2.type;\n\n            if (!(this.astIsWriteable(binex.operand1))) {\n                this.checker.errorReporter.valueCannotBeModified(binex);\n            }\n            if (binex.operand1.nodeType == NodeType.Call) {\n                var callEx = <CallExpression>binex.operand1;\n            }\n            var preserveScope = false;\n            var preservedContainedScope = null;\n            if (binex.operand2.type) {\n                preservedContainedScope = binex.operand2.type.containedScope;\n                preserveScope = true;\n            }\n            // Do not re-write the AST in provisional typecheck mode\n            binex.operand2 = this.castWithCoercion(binex.operand2, leftType, applyTargetType && !this.checker.inProvisionalTypecheckMode(), false);\n            if (preserveScope && binex.operand2.type.containedScope == null) {\n                binex.operand2.type.containedScope = preservedContainedScope;\n            }\n            binex.type = rightType;\n            return binex;\n        }\n\n        public typeCheckIndex(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            binex.operand1 = this.typeCheck(binex.operand1); // ObjExpr\n            binex.operand2 = this.typeCheck(binex.operand2); // IndexExpr\n\n            if (!this.checker.styleSettings.literalSubscript) {\n                if (binex.operand2.nodeType == NodeType.QString) {\n                    this.checker.errorReporter.styleError(ast, "use literal subscript (\'.\') notation instead)");\n                }\n            }\n\n            var objExprType = binex.operand1.type;\n            var indexExprType = binex.operand2.type;\n\n            if (objExprType.elementType) { // arrays\n                if (indexExprType == this.checker.anyType || indexExprType == this.checker.numberType || hasFlag(indexExprType.typeFlags, TypeFlags.IsEnum)) {\n                    binex.type = objExprType.elementType;\n                }\n                else if (indexExprType == this.checker.stringType) {\n                    binex.type = this.checker.anyType;\n                }\n                else {\n                    this.checker.errorReporter.simpleError(binex, "Illegal property access");\n                    binex.type = this.checker.anyType;\n                }\n            }\n            else if (objExprType.index) { // types with index sigs\n\n                if (indexExprType == this.checker.anyType ||\n                    !((objExprType.index.flags & SignatureFlags.IsStringIndexer) || (objExprType.index.flags & SignatureFlags.IsNumberIndexer)) || // REVIEW: unvalidated type expression\n                    ((objExprType.index.flags & SignatureFlags.IsStringIndexer) && indexExprType == this.checker.stringType) ||\n                    ((objExprType.index.flags & SignatureFlags.IsNumberIndexer) && (indexExprType == this.checker.numberType || hasFlag(indexExprType.typeFlags, TypeFlags.IsEnum)))) {\n                    var sig = this.resolveOverload(ast, objExprType.index);\n                    if (sig) {\n                        binex.type = sig.returnType.type;//objExprType.index.signatures[0].returnType.type;\n                    }\n                    else {\n                        binex.type = this.checker.anyType;\n                    }\n                }\n                else if (indexExprType == this.checker.stringType) {\n                    binex.type = this.checker.anyType;\n                }\n                else {\n                    this.checker.errorReporter.simpleError(binex, "Illegal property access");\n                    binex.type = this.checker.anyType;\n                }\n            }\n            else if ((objExprType == this.checker.anyType ||\n                     objExprType == this.checker.stringType ||\n                     objExprType == this.checker.numberType ||\n                     objExprType == this.checker.booleanType ||\n                     objExprType.isReferenceType()) &&\n                     (indexExprType == this.checker.anyType ||\n                      indexExprType == this.checker.stringType ||\n                      (indexExprType == this.checker.numberType || hasFlag(indexExprType.typeFlags, TypeFlags.IsEnum)))) { // RE',
v27484=v27485+'VIEW: Do we want to allow indexes of type \'number\'?\n                binex.type = this.checker.anyType;\n            }\n            else {\n                this.checker.errorReporter.simpleError(binex, "Illegal property access");\n                binex.type = this.checker.anyType;\n            }\n\n            return binex;\n        }\n\n        public typeCheckInOperator(binex: BinaryExpression): BinaryExpression {\n            binex.operand1 = this.cast(this.typeCheck(binex.operand1), this.stringType);\n            binex.operand2 = this.typeCheck(binex.operand2);\n\n            if (!((binex.operand1.type == this.checker.anyType || binex.operand1.type == this.checker.stringType) &&\n                    (binex.operand2.type == this.anyType || this.checker.sourceIsSubtypeOfTarget(binex.operand2.type, this.objectInterfaceType)))) {\n                this.checker.errorReporter.simpleError(binex, "The in operator requires the left operand to be of type Any or the String primitive type, and the right operand to be of type Any or an object type");\n            }\n\n            binex.type = this.booleanType;\n            return binex;\n        }\n\n        public typeCheckShift(binex: BinaryExpression, assignment: bool): BinaryExpression {\n            binex.operand1 = this.cast(this.typeCheck(binex.operand1), this.doubleType);\n            binex.operand2 = this.cast(this.typeCheck(binex.operand2), this.doubleType);\n            if (assignment && (!(this.astIsWriteable(binex.operand1)))) {\n                this.checker.errorReporter.valueCannotBeModified(binex);\n            }\n            binex.type = this.doubleType;\n            return binex;\n        }\n\n        public typeCheckQMark(trinex: ConditionalExpression): ConditionalExpression {\n            trinex.operand1 = this.typeCheck(trinex.operand1);\n            trinex.operand2 = this.typeCheck(trinex.operand2);\n            trinex.operand3 = this.typeCheck(trinex.operand3);\n            var leftType = trinex.operand2.type;\n            var rightType = trinex.operand3.type;\n\n            if (leftType == rightType) {\n                trinex.type = leftType;\n            }\n            else {\n                if (this.checker.sourceIsSubtypeOfTarget(leftType, rightType)) {\n                    trinex.type = rightType;\n                }\n                else if (this.checker.sourceIsSubtypeOfTarget(rightType, leftType)) {\n                    trinex.type = leftType;\n                }\n                else {\n                    trinex.type = this.anyType;\n                    this.checker.errorReporter.incompatibleTypes(trinex, leftType, rightType, trinex.printLabel(), this.scope);\n                }\n            }\n\n            return trinex;\n        }\n\n        public addFormals(container: Symbol, signature: Signature,\n            table: IHashTable) {\n            var len = signature.parameters.length;\n            for (var i = 0; i < len; i++) {\n                var symbol = <ParameterSymbol>signature.parameters[i];\n                symbol.container = container;\n                table.add(symbol.name, symbol);\n            }\n        }\n\n        // REVIEW: We use isModContainer instead of container.getType().isModuleType because container.type may be null at this\n        // juncture\n        public addLocalsFromScope(scope: SymbolScope, container: Symbol, vars: ASTList, table: IHashTable, isModContainer: bool) {\n            var len = vars.members.length;\n            var hasArgsDef = false;\n            for (var i = 0; i < len; i++) {\n                var local = <VarDecl>vars.members[i];\n                if (((local.sym == null) || (local.sym.kind() != SymbolKind.Field))) {\n                    var result: Symbol = null;\n                    if ((result = table.lookup(local.id.text)) == null) {\n                        var localVar: ValueLocation = new ValueLocation();\n                        localVar.typeLink = new TypeLink();\n                        var varSym = null;\n\n                        if (hasFlag(local.varFlags, VarFlags.Static)) {\n                            local.varFlags |= VarFlags.LocalStatic;\n                            varSym = new FieldSymbol(local.id.text, local.minChar,\n                                                      this.checker.locationInfo.unitIndex,\n                                                      true, localVar);\n                        }\n                        else {\n                            varSym = new VariableSymbol(local.id.text, local.minChar,\n                                                      this.checker.locationInfo.unitIndex,\n                                                      localVar);\n                        }\n                        varSym.transferVarFlags(local.varFlags);\n                        localVar.symbol = varSym;\n                        varSym.declAST = local;\n                        localVar.typeLink.ast = local.typeExpr;\n                        this.checker.resolveTypeLink(scope, localVar.typeLink, false);\n                        if ((local.type == null) &&',
v27483=v27484+' (local.init == null)) {\n                            local.type = this.anyType;\n                        }\n                        localVar.typeLink.type = local.type;\n                        localVar.symbol.container = container;\n                        local.sym = localVar.symbol;\n                        table.add(local.id.text, varSym);\n                        if (local.id.text == "arguments") {\n                            hasArgsDef = true;\n                        }\n                    }\n                    else {\n                        local.type = result.getType();\n                        local.sym = result;\n                    }\n                }\n            }\n            if (!isModContainer) {\n                if (!hasArgsDef) {\n                    var argLoc = new ValueLocation();\n                    argLoc.typeLink = new TypeLink();\n                    var theArgSym = new VariableSymbol("arguments", vars.minChar,\n                                                     this.checker.locationInfo.unitIndex,\n                                                     argLoc);\n\n                    // if the user is using a custom lib.d.ts where IArguments has not been defined\n                    // (or they\'re compiling with the --nolib option), use \'any\' as the argument type\n                    if (!this.iargumentsInterfaceType) {\n                        var argumentsSym = scope.find("IArguments", false, true);\n\n                        if (argumentsSym) {\n                            argumentsSym.flags |= SymbolFlags.CompilerGenerated;\n                            this.iargumentsInterfaceType = argumentsSym.getType();\n                        }\n                        else {\n                            this.iargumentsInterfaceType = this.anyType;\n                        }\n                    }\n                    argLoc.typeLink.type = this.iargumentsInterfaceType;\n                    table.add("arguments", theArgSym);\n                }\n            }\n        }\n\n        // REVIEW: isClass param may now be redundant\n        public addConstructorLocalArgs(container: Symbol, args: ASTList, table: IHashTable, isClass: bool): void {\n            if (args) {\n                var len = args.members.length;\n                for (var i = 0; i < len; i++) {\n                    var local = <ArgDecl>args.members[i];\n                    if ((local.sym == null) ||\n                        (isClass || (local.sym.kind() != SymbolKind.Field))) {\n                        var result: Symbol = null;\n                        if ((result = table.lookup(local.id.text)) == null) {\n                            this.resolveBoundDecl(local);\n                            var localVar: ValueLocation = new ValueLocation();\n                            localVar.typeLink = new TypeLink();\n                            var varSym = new ParameterSymbol(local.id.text, local.minChar,\n                                                                   this.checker.locationInfo.unitIndex,\n                                                                   localVar);\n                            varSym.declAST = local;\n                            localVar.symbol = varSym;\n                            localVar.typeLink.type = local.type;\n                            localVar.symbol.container = container;\n                            local.sym = localVar.symbol;\n                            table.add(local.id.text, varSym);\n                        }\n                        else {\n                            local.type = result.getType();\n                            local.sym = result;\n                        }\n                    }\n                }\n            }\n        }\n\n        public checkInitSelf(funcDecl: FuncDecl): bool {\n            if (!funcDecl.isMethod()) {\n                var freeVars = funcDecl.freeVariables;\n                for (var k = 0, len = freeVars.length; k < len; k++) {\n                    var sym = freeVars[k];\n                    if (sym.isInstanceProperty()) {\n                        return true;\n                    }\n                }\n            }\n            var fns = funcDecl.scopes;\n            var fnsLen = fns.members.length;\n\n            for (var j = 0; j < fnsLen; j++) {\n                var fn = <FuncDecl>fns.members[j];\n                if (this.checkInitSelf(fn)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        public checkPromoteFreeVars(funcDecl: FuncDecl, constructorSym: Symbol): void {\n            var freeVars = funcDecl.freeVariables;\n            for (var k = 0, len = freeVars.length; k < len; k++) {\n                var sym = freeVars[k];\n                if ((!sym.isInstanceProperty()) && (sym.container == constructorSym)) {\n                    instanceFilter.reset();\n                    if (this.scope.search(instanceFilter, sym.name, false, false)) {\n                        this.checker.errorReporter.simpleError(funcDecl, "Constructor-local variable shadows class property',
v27482=v27483+' \'" + sym.name + "\'. To access the class property, use \'self." + sym.name + "\'");\n                    }\n\n                    this.checker.errorReporter.simpleError(funcDecl, "Constructor-local variables may not be accessed from instance method bodies. Consider changing local variable \'" + sym.name + "\' to a class property")\n                }\n            }\n        }\n\n        public allReturnsAreVoid(funcDecl: FuncDecl) {\n            // in the case of a function or method with no declared return type, walk the body to \n            // pre-emptively determine if the function has a return type of void\n            //\n            // REVIEW: Eventually, we\'ll want to perform exit graph analysis to determine\n            // if the function ever "escapes" without a return expression\n            // This would require moving some of this logic into the function\'s typecheck-proper,\n            // which would slow things down a fair bit, but would open up more analysis opportunities\n            var allReturnsAreVoid = true;\n\n            if (funcDecl.signature.returnType.type == null) {\n                var preFindReturnExpressionTypes = function (ast: AST, parent: AST, walker: IAstWalker) {\n                    var go = true;\n                    switch (ast.nodeType) {\n                        case NodeType.FuncDecl:\n                            // don\'t recurse into a function decl - we don\'t want to confuse a nested\n                            // return type with the top-level function\'s return type\n                            go = false;\n                            break;\n                        case NodeType.Return:\n                            var returnStmt: ReturnStatement = <ReturnStatement>ast;\n\n                            if (returnStmt.returnExpression) {\n                                allReturnsAreVoid = false;\n                                go = false;\n                            }\n\n                        default:\n                            break;\n                    }\n                    walker.options.goChildren = go;\n                    walker.options.goNextSibling = go;\n                    return ast;\n                }\n\n                getAstWalkerFactory().walk(funcDecl.bod, preFindReturnExpressionTypes);\n            }\n\n            return allReturnsAreVoid;\n        }\n\n        public classConstructorHasSuperCall(funcDecl: FuncDecl) {\n            var foundSuper = false;\n\n            var preFindSuperCall = function (ast: AST, parent: AST, walker: IAstWalker) {\n\n                var go = true;\n\n                switch (ast.nodeType) {\n                    case NodeType.FuncDecl:\n                        go = false;\n                        break;\n                    case NodeType.Call:\n                        var call = <CallExpression>ast;\n\n                        if (call.target.nodeType == NodeType.Super) {\n                            go = false;\n                            foundSuper = true;\n                            break;\n                        }\n                        break;\n                    default:\n                        break;\n                }\n                walker.options.goChildren = go;\n                return ast;\n            }\n\n            getAstWalkerFactory().walk(funcDecl.bod, preFindSuperCall);\n\n            return foundSuper;\n        }\n\n        private baseListPrivacyErrorReporter(bases: ASTList, i: number, declSymbol: Symbol, extendsList: bool, typeName: string, isModuleName: bool) {\n            var baseSymbol = bases.members[i].type.symbol;\n            var declTypeString = (declSymbol.declAST.nodeType == NodeType.InterfaceDeclaration) ? "interface" : "class";\n            var baseListTypeString = extendsList ? "extends" : "implements";\n            var baseTypeString = (baseSymbol.declAST.nodeType == NodeType.InterfaceDeclaration) ? "interface" : "class";\n            var typestring = "";\n            if (isModuleName) {\n                var quotestring = "";\n                if (!isQuoted(typeName)) {\n                    quotestring = "\'";\n                }\n                typestring = " is using inaccessible module ";\n                baseTypeString = " " + baseTypeString + " from private module " + quotestring + typeName + quotestring;\n            } else {\n                baseTypeString = " private " + baseTypeString + " \'" + typeName + "\'";\n            }\n            this.checker.errorReporter.simpleError(bases.members[i], "exported " + declTypeString + " \'" + declSymbol.name + "\' " + baseListTypeString + baseTypeString);\n        }\n\n        // Check if declSymbol can satisfy baselist privacy\n        private typeCheckBaseListPrivacy(bases: ASTList, declSymbol: Symbol, extendsList: bool) {\n            if (bases) {\n                var basesLen = bases.members.length;\n                for (var i = 0; i < basesLen; i++) {\n                    if (!bases.members[i].type || bases.members[i].type == this.checker.anyType) {\n                        // This type is coming from external module so it ha',
v27481=v27482+"s to be exported, or we're recovering from an\n                        // error condition\n                        continue;\n                    }\n\n                    this.checkSymbolPrivacy(bases.members[i].type.symbol, declSymbol, (typeName: string, isModuleName: bool) => this.baseListPrivacyErrorReporter(bases, i, declSymbol, extendsList, typeName, isModuleName));\n                }\n            }\n        }\n\n        // Checks if the privacy is satisfied by typeSymbol that is used in the declaration inside container\n        private checkSymbolPrivacy(typeSymbol: TypeSymbol, declSymbol: Symbol, errorCallback: (typeName: string, isModuleName: bool) => void ) {\n            var externalModuleSymbol: TypeSymbol = null;\n            var declSymbolPath: Symbol[] = null;\n\n            // Type is visible type, so this can be used by anyone.\n            if (typeSymbol.isExternallyVisible(this.checker)) {\n                // Symbol could be from external module, go ahead and find the external module\n                var typeSymbolPath = typeSymbol.pathToRoot();\n                declSymbolPath = declSymbol.pathToRoot();\n                var typeSymbolLength = typeSymbolPath.length;\n                var declSymbolPathLength = declSymbolPath.length;\n\n                if (typeSymbolLength > 0) {\n                    if (typeSymbolPath[typeSymbolLength - 1].getType().isModuleType() &&\n                        (<TypeSymbol>typeSymbolPath[typeSymbolLength - 1]).isDynamic &&\n                        typeSymbolPath[typeSymbolLength - 1] != declSymbolPath[declSymbolPathLength - 1]) {\n                        // Symbol from external module that was imported using one of the import statement\n                        externalModuleSymbol = <TypeSymbol>typeSymbolPath[typeSymbolLength - 1];\n                    } else if (typeSymbolLength > 1) {\n                        // Is symbol from declared quoted module\n                        if (typeSymbolPath[typeSymbolLength - 2].getType().isModuleType() &&\n                            (<TypeSymbol>typeSymbolPath[typeSymbolLength - 2]).isDynamic &&\n                            (declSymbolPathLength == 1 || typeSymbolPath[typeSymbolLength - 2] != declSymbolPath[declSymbolPathLength - 2])) {\n                            // From quoted module name\n                            externalModuleSymbol = <TypeSymbol>typeSymbolPath[typeSymbolLength - 2];\n                        }\n                    }\n                }\n\n                if (externalModuleSymbol == null) {\n                    return;\n                }\n            }\n\n            // Interface symbol doesn't reflect correct Exported state so use AST instead\n            var interfaceDecl: InterfaceDeclaration = declSymbol.getInterfaceDeclFromSymbol(this.checker);\n            if (interfaceDecl && !hasFlag(interfaceDecl.varFlags, VarFlags.Exported)) {\n                return;\n            }\n\n            var checkVisibilitySymbol = declSymbol;\n            // Var decl symbol doesnt reflect correct exported state so use AST instead\n            var varDecl = declSymbol.getVarDeclFromSymbol();\n            if (varDecl) {\n                if (hasFlag(varDecl.varFlags, VarFlags.Private)) {\n                    return;\n                } else if (hasFlag(varDecl.varFlags, VarFlags.Public)) {\n                    // Its a member from class so check visibility of its container\n                    checkVisibilitySymbol = declSymbol.container;\n                }\n            }\n\n            // If the container is visible from global scrope it is error\n            if (checkVisibilitySymbol.isExternallyVisible(this.checker)) {\n                var privateSymbolName = typeSymbol.name;\n\n                // If imported typeSymbol mark it as visible externally and verify that the symbol it imports is visible externally\n                if (externalModuleSymbol != null) {\n                    var prettyName = externalModuleSymbol.getPrettyNameOfDynamicModule(declSymbolPath);\n                    if (prettyName != null) {\n                        this.currentScript.AddExternallyVisibleImportedSymbol(prettyName.symbol, this.checker);\n                        return;\n                    } else {\n                        privateSymbolName = externalModuleSymbol.prettyName;\n                    }\n                }\n\n                // Visible declaration using non visible type.\n                errorCallback(privateSymbolName, typeSymbol.name != privateSymbolName);\n            }\n        }\n\n        // Checks if the privacy is satisfied by type that is used in the declaration inside container\n        private checkTypePrivacy(type: Type, declSymbol: Symbol, errorCallback: (typeName: string, isModuleName : bool) =>void ) {\n            // Primitive types\n            if (!(type && type.primitiveTypeClass == Primitive.None)) {\n                return;\n            }\n\n\n            // If type is array, check element type\n            if (type.isArray()) {\n                return this.checkTypePrivacy(type.elementTyp",
v27480=v27481+'e, declSymbol, errorCallback);\n            }\n\n            // Going to be printing symbol name, verify if symbol can be emitted\n            if (type.symbol && type.symbol.name && type.symbol.name != "_anonymous" &&\n                        (((type.call == null) && (type.construct == null) && (type.index == null)) ||\n                        (type.members && (!type.isClass())))) {\n                return this.checkSymbolPrivacy(<TypeSymbol>type.symbol, declSymbol, errorCallback);\n            }\n\n            if (type.members) {\n                // Verify symbols for members\n                type.members.allMembers.map((key, s, unused) => {\n                    var sym = <Symbol>s;\n                    if (!hasFlag(sym.flags, SymbolFlags.BuiltIn)) {\n                        this.checkTypePrivacy(sym.getType(), declSymbol, errorCallback);\n                    }\n                }, null);\n            }\n\n            this.checkSignatureGroupPrivacy(type.call, declSymbol, errorCallback);\n            this.checkSignatureGroupPrivacy(type.construct, declSymbol, errorCallback);\n            this.checkSignatureGroupPrivacy(type.index, declSymbol, errorCallback);\n        }\n\n        // Checks if the privacy is satisfied by typeSymbol that is used in the declaration inside container\n        private checkSignatureGroupPrivacy(sgroup: SignatureGroup, declSymbol: Symbol, errorCallback: (typeName: string, isModuleName : bool) =>void ) {\n            if (sgroup) {\n                var len = sgroup.signatures.length;\n                for (var i = 0; i < sgroup.signatures.length; i++) {\n                    var signature = sgroup.signatures[i];\n                    if (len > 1 && signature == sgroup.definitionSignature) {\n                        // In case of overloads don\'t look up for overload defintion types.\n                        continue;\n                    }\n\n                    if (signature.returnType) {\n                        this.checkTypePrivacy(signature.returnType.type, declSymbol, errorCallback);\n                    }\n\n                    var paramLen = signature.parameters.length;\n                    for (var j = 0; j < paramLen; j++) {\n                        var param = signature.parameters[j];\n                        this.checkTypePrivacy(param.getType(), declSymbol, errorCallback);\n                    }\n                }\n            }\n        }\n\n        private functionArgumentPrivacyErrorReporter(funcDecl: FuncDecl, p: number, paramSymbol: Symbol, typeName: string, isModuleName: bool) {\n            var isGetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor);\n            var isSetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.SetAccessor);\n            var isPublicFunc = hasFlag(funcDecl.fncFlags, FncFlags.Public);\n            var isContainerInterface = funcDecl.type.symbol.getInterfaceDeclFromSymbol(this.checker) != null;\n            var typestring = "";\n            if (isModuleName) {\n                var quotestring = "";\n                if (!isQuoted(typeName)) {\n                    quotestring = "\'";\n                }\n                typestring = " is using inaccessible module " + quotestring + typeName + quotestring;\n            } else {\n                typestring = " has or is using private type \'" + typeName + "\'";\n            }\n\n            if (!isContainerInterface) {\n                if (funcDecl.isConstructor) {\n                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported class\'s constructor parameter \'" + paramSymbol.name + "\'" + typestring);\n                } else if (isSetter) {\n                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], (isPublicFunc ? "public" : "exported") + " setter parameter \'" + paramSymbol.name + "\'" + typestring);\n                } else if (!isGetter) {\n                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], (isPublicFunc ? "public" : "exported") + " function parameter \'" + paramSymbol.name + "\'" + typestring);\n                }\n            } else {\n                if (funcDecl.isConstructMember()) {\n                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported interface\'s constructor parameter \'" + paramSymbol.name + "\'" + typestring);\n                } else if (funcDecl.isCallMember()) {\n                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported interface\'s call parameter \'" + paramSymbol.name + "\'" + typestring);\n                } else if (!funcDecl.isIndexerMember()) {\n                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported interface\'s function parameter \'" + paramSymbol.name + "\'" + typestring);\n                }\n            }\n        }\n\n        private returnTypePrivacyError(astError: AST, funcDecl: FuncDecl, typeName: string, isModuleName: bool) {\n            var isGetter = funcDecl.isAccessor() && hasFlag(funcD',
v27479=v27480+'ecl.fncFlags, FncFlags.GetAccessor);\n            var isSetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.SetAccessor);\n            var isPublicFunc = hasFlag(funcDecl.fncFlags, FncFlags.Public);\n            var isContainerInterface = funcDecl.type.symbol.getInterfaceDeclFromSymbol(this.checker) != null;\n            var typestring = "";\n            if (isModuleName) {\n                var quotestring = "";\n                if (!isQuoted(typeName)) {\n                    quotestring = "\'";\n                }\n                typestring = " is using inaccessible module " + quotestring + typeName + quotestring;\n            } else {\n                typestring = " has or is using private type \'" + typeName + "\'";\n            }\n            if (!isContainerInterface) {\n                if (isGetter) {\n                    this.checker.errorReporter.simpleError(astError, (isPublicFunc ? "public" : "exported") + " getter return type" + typestring);\n                } else if (!isSetter) {\n                    this.checker.errorReporter.simpleError(astError, (isPublicFunc ? "public" : "exported") + " function return type" + typestring);\n                }\n            } else {\n                if (funcDecl.isConstructMember()) {\n                    this.checker.errorReporter.simpleError(astError, "exported interface\'s constructor return type" + typestring);\n                } else if (funcDecl.isCallMember()) {\n                    this.checker.errorReporter.simpleError(astError, "exported interface\'s call return type" + typestring);\n                } else if (funcDecl.isIndexerMember()) {\n                    this.checker.errorReporter.simpleError(astError, "exported interface\'s indexer return type" + typestring);\n                } else {\n                    this.checker.errorReporter.simpleError(astError, "exported interface\'s function return type" + typestring);\n                }\n            }\n        }\n\n        private functionReturnTypePrivacyErrorReporter(funcDecl: FuncDecl, signature: Signature, typeName: string, isModuleName: bool) {\n            var reportOnFuncDecl = false;\n\n            // Error coming from return annotation\n            if (funcDecl.returnTypeAnnotation != null &&\n                funcDecl.returnTypeAnnotation.type == signature.returnType.type) {\n                this.returnTypePrivacyError(funcDecl.returnTypeAnnotation, funcDecl, typeName, isModuleName);\n            }\n\n            // Check if return statement\'s type matches the one that we concluded\n            for (var i = 0; i < funcDecl.returnStatementsWithExpressions.length; i++) {\n                if (funcDecl.returnStatementsWithExpressions[i].type == signature.returnType.type) {\n                    this.returnTypePrivacyError(funcDecl.returnStatementsWithExpressions[i], funcDecl, typeName, isModuleName);\n                } else {\n                    reportOnFuncDecl = true;\n                }\n            }\n\n            if (reportOnFuncDecl) {\n                // Show on function decl\n                this.returnTypePrivacyError(funcDecl, funcDecl, typeName, isModuleName);\n            }\n        }\n\n        public typeCheckFunction(funcDecl: FuncDecl): FuncDecl {\n            this.nestingLevel = 0;\n            var fnType = funcDecl.type;\n\n            var fgSym = fnType.symbol;\n            var signature = funcDecl.signature;\n\n            if (this.checker.typeStatusIsFinished(signature.typeCheckStatus)) {\n                return funcDecl;\n            }\n            else if (signature.typeCheckStatus == TypeCheckStatus.Started) {\n                if (!funcDecl.returnTypeAnnotation &&\n                    funcDecl.bod &&\n                       !funcDecl.isSignature() &&\n                       !(funcDecl.isConstructor) &&\n                       this.allReturnsAreVoid(funcDecl)) {\n\n                    signature.returnType.type = this.voidType;\n                    return funcDecl;\n                }\n                else {\n                    if (funcDecl.returnTypeAnnotation == null) {\n                        if (this.checker.styleSettings.implicitAny) {\n                            this.checker.errorReporter.styleError(funcDecl, "type implicitly set to \'any\'");\n                        }\n                        signature.returnType.type = this.anyType;\n                        fgSym.flags |= SymbolFlags.RecursivelyReferenced;\n                    }\n                    return funcDecl;\n                }\n            }\n\n            signature.typeCheckStatus = TypeCheckStatus.Started;\n            this.checker.addStartedPTO(signature);\n            var prevScope = this.scope;\n            var prevFnc = this.thisFnc;\n            var prevMethodStatus = this.enclosingFncIsMethod;\n            var prevClassNode = this.thisClassNode;\n            this.enclosingFncIsMethod = funcDecl.isMethod() || funcDecl.isConstructor;\n            this.thisFnc = funcDecl;\n            var container = funcDecl.type.symbol;\n            var prevThisType = this.thisType;\n            var pr',
v27478=v27479+"evLocationInfo = this.checker.locationInfo;\n            var funcTable: IHashTable = null;\n            var acceptedContextualType = false;\n            var targetParams: ParameterSymbol[] = null;\n            var targetReturnType: Type = null;\n            var isGetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor);\n            var isSetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.SetAccessor);\n            var accessorType: Type = (isGetter || isSetter) && funcDecl.accessorSymbol ? funcDecl.accessorSymbol.getType() : null;\n            var prevModDecl = this.checker.currentModDecl;\n\n            if (funcDecl.isConstructor && !funcDecl.isOverload) {\n                if (fnType.instanceType == null) {\n                    this.checker.errorReporter.simpleError(funcDecl, \"Malformed function body (is this a class named the same as an existing interface?)\");\n                    return funcDecl;\n                }\n\n                this.scope = fnType.instanceType.constructorScope;\n                var ssb = <SymbolScopeBuilder>this.scope;\n                funcTable = ssb.valueMembers.allMembers;\n            }\n            else if ((funcDecl.isSpecialFn() && !(funcDecl.fncFlags & FncFlags.Signature)) || funcDecl.isOverload) {\n                funcTable = funcDecl.symbols;\n                // if the function is static, we just want to use the \n                // current scope\n                if (!hasFlag(funcDecl.fncFlags, FncFlags.Static) && fnType.containedScope) {\n                    this.scope = fnType.containedScope;\n                }\n            }\n            else {\n                if (funcDecl.bod) {\n                    this.scope = fnType.containedScope;\n                }\n                var ssb = <SymbolScopeBuilder>this.scope;\n\n                // If it is null, it's an ambient declaration with no body, so it doesn't strictly matter\n                // if funcTable is not set\n                if (ssb && ssb.valueMembers) {\n                    funcTable = ssb.valueMembers.allMembers;\n                }\n            }\n\n            // If it's a class constructor, we need to check for the presence (or absense) of calls\n            // to the 'super' constructor\n            //\n            // A super constructor call must exist if:\n            //  - the class has a base class\n            //\n            // A super constructor call must be the first statement in the function body if:\n            //  - the constructor has parameter properties or\n            //  - the class body has initialized property decls\n            //\n            // A super constructor call may not exist if:\n            //  - The class has no base type, or inherits directly from 'Object'\n            if (funcDecl.isConstructor && funcDecl.bod && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {\n\n                var hasBaseType = hasFlag(funcDecl.classDecl.type.instanceType.typeFlags, TypeFlags.HasBaseType);\n                var noSuperCallAllowed = !hasBaseType || hasFlag(funcDecl.classDecl.type.instanceType.typeFlags, TypeFlags.HasBaseTypeOfObject);\n                var superCallMustBeFirst = hasFlag((<ClassDeclaration>funcDecl.classDecl).varFlags, VarFlags.ClassSuperMustBeFirstCallInConstructor);\n\n                if (noSuperCallAllowed && this.classConstructorHasSuperCall(funcDecl)) {\n                    this.checker.errorReporter.simpleError(funcDecl, \"Calls to 'super' constructor are not allowed in classes that either inherit directly from 'Object' or have no base class\");\n                }\n                else if (hasBaseType) {\n                    if (superCallMustBeFirst) {\n                        if (!funcDecl.bod ||\n                            !funcDecl.bod.members.length ||\n                            !((funcDecl.bod.members[0].nodeType == NodeType.Call && (<CallExpression>funcDecl.bod.members[0]).target.nodeType == NodeType.Super) ||\n                            (hasFlag(funcDecl.bod.flags, ASTFlags.StrictMode) && funcDecl.bod.members.length > 1 &&\n                             funcDecl.bod.members[1].nodeType == NodeType.Call && (<CallExpression>funcDecl.bod.members[1]).target.nodeType == NodeType.Super))) {\n                            this.checker.errorReporter.simpleError(funcDecl, \"If a derived class contains initialized properties or constructor parameter properties, the first statement in the constructor body must be a call to the super constructor\");\n                        }\n                    }\n                    else if (!this.classConstructorHasSuperCall(funcDecl)) {\n                        this.checker.errorReporter.simpleError(funcDecl, \"Constructors for derived classes must contain a call to the class's 'super' constructor\");\n                    }\n                }\n            }\n\n            // If we've typechecked this method \"out of order\" (not by walking the class, but through a method call somewhere else),\n            // we need to reset the current class node in question, so that vis",
v27477=v27478+"ibility checks on class members don't fail\n            if (funcDecl.isMethod() && funcDecl.type.enclosingType) {\n\n                var enclosingClassNode: TypeDeclaration = null;\n\n                if (funcDecl.type.enclosingType.symbol.declAST.nodeType == NodeType.FuncDecl) {\n                    enclosingClassNode = <TypeDeclaration>(<FuncDecl>funcDecl.type.enclosingType.symbol.declAST).classDecl;\n                }\n                else if (funcDecl.type.enclosingType.symbol.declAST.nodeType == NodeType.ClassDeclaration) {\n                    enclosingClassNode = <TypeDeclaration>funcDecl.type.enclosingType.symbol.declAST;\n                }\n\n                if (enclosingClassNode) {\n                    this.thisClassNode = enclosingClassNode;\n                }\n            }\n\n            // if this function is contained in a module, we may be in the midst of a recursive typecheck operation\n            // should that be the case, we need to properly set the current module (for visibility tests)\n            if (fnType.enclosingType) {;\n                var enclosingSym = fnType.symbol.container;\n\n                // if the enclosing type is a class, grab the parent module\n                if (enclosingSym && enclosingSym.isType() && enclosingSym.getType().isClass()) {\n                    enclosingSym = enclosingSym.container;\n                }\n\n                if (enclosingSym && enclosingSym.declAST && enclosingSym.declAST.nodeType == NodeType.ModuleDeclaration) {\n                    this.checker.currentModDecl = <ModuleDeclaration>enclosingSym.declAST;\n                }\n            }\n\n            if (funcDecl.unitIndex > 0) {\n                if (this.checker.units &&\n                    (funcDecl.unitIndex < this.checker.units.length)) {\n                    this.checker.locationInfo = this.checker.units[funcDecl.unitIndex];\n                }\n                else {\n                    this.checker.locationInfo = unknownLocationInfo;\n                }\n            }\n\n            if (fnType.enclosingType) {\n                this.thisType = fnType.enclosingType;\n            }\n            else {\n                this.thisType = prevThisType;\n            }\n\n            var paramLen = signature.parameters.length;\n\n            if (!funcDecl.isConstructor && funcDecl.bod && !funcDecl.isSignature()) {\n                var tmpParamScope = this.scope;\n                var ssb = <SymbolScopeBuilder>this.scope;\n\n                // Attempt to contextually type the function declaration             \n                if (!funcDecl.isMethod() && funcDecl.returnTypeAnnotation == null) {\n\n                    // the funcDecl may be a candidate for contextual typing                 \n                    // REVIEW: prevScope will only be null in the case of an upstream error\n                    if (prevScope && funcDecl.name && !funcDecl.name.isMissing()) {\n                        // Go ahead and check for an ambient symbol\n                        var considerSym: Symbol = prevScope.findAmbient(funcDecl.name.text, false, false);\n\n                        if (considerSym && considerSym.declAST && considerSym.declAST.type) {\n                            // REVIEW: Ambients beget signatures, and signatures don't need to be typechecked\n                            //typeCheck(considerSym.declAST);\n                            this.checker.setContextualType(considerSym.declAST.type, false);\n                        }\n                    }\n\n                    if (this.checker.hasTargetType()) {\n                        var candidateTypeContext = this.checker.getTargetTypeContext();\n                        var candidateType = candidateTypeContext.contextualType;\n\n                        if (this.checker.canContextuallyTypeFunction(candidateType, funcDecl, true)) {\n\n                            // Safe to do this, since the indices and fields are guaranteed to be\n                            // non-null and valid by the above call to canContextuallyTypeFunction\n                            var candidateSigs = candidateType.construct ? candidateType.construct : candidateType.call;\n                            candidateTypeContext.targetSig = candidateSigs.signatures[0];\n                            var candidateParams = candidateTypeContext.targetSig.parameters;\n\n                            // the target type has been accepted\n                            targetParams = candidateParams;\n                            targetReturnType = candidateTypeContext.targetSig.returnType.type;\n\n                            // Set \"this\" if applicable\n                            if (candidateTypeContext.targetSig.declAST) {\n                                if (candidateTypeContext.targetSig.declAST.isConstructor) {\n                                    //candidateTypeContext.targetThis=candidateType.instanceType;\n                                    //this.thisType = candidateType.instanceType;\n                                    funcDecl.isTargetTypedAsMethod = true;\n               ",
v27476=v27477+"                 }\n                                else if (candidateTypeContext.targetSig.declAST.isMethod()) {\n                                    //candidateTypeContext.targetThis=candidateTypeContext.targetSig.declAST.type.enclosingType;\n                                    //this.thisType = candidateTypeContext.targetSig.declAST.type.enclosingType;\n                                    funcDecl.isTargetTypedAsMethod = true;\n                                }\n                            }\n                            fgSym.type = candidateTypeContext.contextualType;\n                            acceptedContextualType = true;\n                        }\n                        else if (candidateType && funcDecl.isAccessor()) {\n                            accessorType = candidateType;\n                            candidateTypeContext.targetAccessorType = accessorType;\n                        }\n                        else {\n                            this.checker.killCurrentContextualType();\n                        }\n                    }\n                }\n\n                // typecheck parameters\n                // Add parameter symbols to current scope for typechecking (in case default params reference each other)\n                // Order matters here - default parameters can reference previously defined parameters\n                var paramTable = ssb.valueMembers;\n                this.scope = new SymbolScopeBuilder(paramTable, null, null, null, prevScope, container);\n\n                for (var p = 0; p < paramLen; p++) {\n                    var symbol = signature.parameters[p];\n                    var ast = <ArgDecl>symbol.declAST\n\n                    if (this.checker.hasTargetType() && (targetParams && (this.checker.getTargetTypeContext().targetSig.hasVariableArgList || p < targetParams.length))) {\n                        var candidateTypeContext = this.checker.getTargetTypeContext();\n                        var hasVarArgList = candidateTypeContext.targetSig.hasVariableArgList;\n                        ast.type = hasVarArgList && p >= targetParams.length - 1 ? targetParams[targetParams.length - 1].getType().elementType : targetParams[p].getType();\n                        ast.sym.setType(ast.type);\n                        (<InferenceSymbol>ast.sym).typeCheckStatus = this.checker.getTypeCheckFinishedStatus();\n                    }\n                    else {\n                        this.typeCheck(ast);\n                    }\n\n                    // infer the setter type, if necessary\n                    if (isSetter && accessorType) {\n                        ast = <ArgDecl>this.cast(ast, accessorType);\n                    }\n\n                    symbol.container = container;\n                    // Verify the parameter for the privacy\n                    this.checkTypePrivacy(symbol.getType(), container, (typeName: string, isModuleName: bool) => this.functionArgumentPrivacyErrorReporter(funcDecl, p, symbol, typeName, isModuleName));\n                    paramTable.publicMembers.add(symbol.name, symbol);\n                }\n                this.scope = tmpParamScope;\n            }\n            else {\n                this.typeCheck(funcDecl.arguments)\n\n                // Because some terms were not yet type-checkable during binding, ensure that\n                // param symbols are updated with the proper argument types\n                for (var p = 0; p < paramLen; p++) {\n                    signature.parameters[p].parameter.typeLink.type = funcDecl.arguments.members[p].type;\n                    // Verify the parameter for the privacy\n                    this.checkTypePrivacy(signature.parameters[p].getType(), container, (typeName: string, isModuleName: bool) => this.functionArgumentPrivacyErrorReporter(funcDecl, p, signature.parameters[p], typeName, isModuleName));\n                    if ((<ArgDecl>funcDecl.arguments.members[p]).parameterPropertySym) {\n                        (<ArgDecl>funcDecl.arguments.members[p]).parameterPropertySym.setType(funcDecl.arguments.members[p].type);\n                    }\n                }\n\n                if ((funcDecl.fncFlags & FncFlags.IndexerMember)) {\n                    if (!paramLen || paramLen > 1) {\n                        this.checker.errorReporter.simpleError(funcDecl, \"Index signatures may take one and only one parameter\");\n                    }\n                    else if (funcDecl.arguments.members[0].type == this.checker.numberType) {\n                        fnType.index.flags |= SignatureFlags.IsNumberIndexer;\n                    }\n                    else if (funcDecl.arguments.members[0].type == this.checker.stringType) {\n                        fnType.index.flags |= SignatureFlags.IsStringIndexer;\n                    }\n                    else {\n                        this.checker.errorReporter.simpleError(funcDecl.arguments.members[0], \"Index signatures may only take 'string' or 'number' as their parameter\");\n                    }\n\n                }\n            }\n\n       ",
v27475=v27476+"     // typecheck body\n            if (funcDecl.bod && (!funcDecl.isSignature())) {\n                if (!(funcDecl.isConstructor)) {\n                    this.addFormals(container, signature, funcTable);\n                }\n                else {\n                    this.addConstructorLocalArgs(funcDecl.type.symbol, funcDecl.arguments, funcTable, hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod));\n\n                    if (this.thisClassNode && this.thisClassNode.extendsList) {\n                        var tmpScope = this.scope;\n                        var funcMembers = new ScopedMembers(<DualStringHashTable>funcTable);\n                        this.scope = new FilteredSymbolScopeBuilder(funcMembers, prevScope, funcDecl.type.symbol,\n                                                             function (sym) {\n                                                                 return sym.kind() == SymbolKind.Parameter;\n                                                             });\n                        this.typeCheckBaseCalls(this.thisClassNode.extendsList);\n                        this.scope = tmpScope;\n                    }\n                }\n\n                // Because this function may have been typechecked in a different visiblity context as its caller (e.g., this\n                // function is being typechecked as a result of a call, before the declaration could be typechecked), we need\n                // to set the enclosing module\n                var prevMod = this.checker.currentModDecl;\n                if (funcDecl.type &&\n                    funcDecl.type.symbol &&\n                    !funcDecl.isMethod() &&\n                    funcDecl.type.symbol.declModule) {\n                    this.checker.currentModDecl = funcDecl.type.symbol.declModule;\n                }\n\n\n                // unset the contextual type before typechecking the function body\n                if (acceptedContextualType) {\n                    this.checker.setContextualType(null, this.checker.inProvisionalTypecheckMode());\n                }\n\n                this.typeCheck(funcDecl.bod);\n\n                if (acceptedContextualType) {\n                    this.checker.unsetContextualType();\n                }\n\n                this.checker.currentModDecl = prevMod;\n\n                if (this.checker.checkControlFlow) {\n                    var cfg = funcDecl.buildControlFlow();\n                    if (this.checker.printControlFlowGraph) {\n                        cfg.print(this.checker.errorReporter.outfile);\n                    }\n                    cfg.reportUnreachable(this.checker.errorReporter);\n                    if (this.checker.checkControlFlowUseDef) {\n                        cfg.useDef(this.checker.errorReporter, funcDecl.type.symbol);\n                    }\n                }\n\n                if (funcDecl.isConstructor) {\n                    var fns: ASTList = funcDecl.scopes;\n                    var fnsLen = fns.members.length;\n                    var freeVars: Symbol[];\n                    var sym: Symbol;\n                    var j = 0;\n                    for (; j < fnsLen; j++) {\n                        var fn = <FuncDecl>fns.members[j];\n                        if (!fn.isSignature()) {\n                            if (hasFlag(fn.fncFlags, FncFlags.Method) && (!hasFlag(fn.fncFlags, FncFlags.Static))) {\n                                this.checkPromoteFreeVars(fn, funcDecl.type.symbol);\n                            }\n                        }\n                    }\n                }\n            }\n\n            this.scope = prevScope;\n            this.thisFnc = prevFnc;\n            this.thisClassNode = prevClassNode;\n            this.enclosingFncIsMethod = prevMethodStatus;\n            this.thisType = prevThisType;\n            this.checker.locationInfo = prevLocationInfo;\n            this.checker.currentModDecl = prevModDecl;\n\n            signature.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();\n\n            // set the return type\n            if (funcDecl.returnTypeAnnotation) {\n                this.checkForVoidConstructor(funcDecl.returnTypeAnnotation.type, funcDecl.returnTypeAnnotation);\n\n                if (signature.returnType.type == null) {\n                    this.checker.resolveTypeLink(this.scope, signature.returnType, false);\n                }\n            }\n            else if (targetReturnType) {\n                signature.returnType.type = targetReturnType;\n            }\n\n            // If no return type annotation has been applied to the function declaration\n            // unify the return types from the given return statements\n\n            if (!(fgSym.flags & SymbolFlags.RecursivelyReferenced) && funcDecl.returnStatementsWithExpressions.length > 0) {\n                var collection: ITypeCollection = {\n                    getLength: () => { return funcDecl.returnStatementsWithExpressions.length; },\n                    setTypeAtIndex: (index: number, type: Type) => { funcDecl.returnStatementsWithExpressions[index].t",
v27474=v27475+'ype = type; },\n                    getTypeAtIndex: (index: number) => { return funcDecl.returnStatementsWithExpressions[index].type; }\n                }\n\n                var bestCommonReturnType = funcDecl.returnStatementsWithExpressions[0].type;\n                bestCommonReturnType = this.checker.findBestCommonType(bestCommonReturnType, null, collection, true);\n\n                if (bestCommonReturnType) {\n                    signature.returnType.type = this.checker.widenType(bestCommonReturnType);\n                }\n                else {\n                    for (var i = 0; i < funcDecl.returnStatementsWithExpressions.length; i++) {\n                        this.checker.errorReporter.simpleError(funcDecl.returnStatementsWithExpressions[i], "Incompatible return type");\n                    }\n                    signature.returnType.type = this.anyType;\n                }\n            }\n\n            var onlyHasThrow = false;\n\n            if (signature.returnType.type == null) {\n                if (hasFlag(funcDecl.fncFlags, FncFlags.HasReturnExpression)) {\n                    if (this.checker.styleSettings.implicitAny) {\n                        this.checker.errorReporter.styleError(funcDecl, "type implicitly set to \'any\'");\n                    }\n                    signature.returnType.type = this.anyType;\n                }\n                else {\n                    signature.returnType.type = this.voidType;\n                }\n            }\n            else if (signature.returnType.type == this.nullType || signature.returnType.type == this.checker.undefinedType) {\n                signature.returnType.type = this.anyType;\n            }\n            else if ((signature.returnType.type != this.voidType && signature.returnType.type != this.checker.undefinedType && signature.returnType.type != this.anyType)) {\n                // the signature declared a non-void type, but there\'s no return statement\n                if (!funcDecl.isSignature() &&\n                    !funcDecl.isConstructor &&\n                    !hasFlag(funcDecl.fncFlags, FncFlags.HasReturnExpression) &&\n                    !hasFlag(funcDecl.fncFlags, FncFlags.IsFatArrowFunction)) {\n                        // relax the restriction if the method only contains a single "throw" statement\n                    onlyHasThrow = (funcDecl.bod.members.length > 0) && (funcDecl.bod.members[0].nodeType == NodeType.Throw)\n\n                    if (!onlyHasThrow) {\n                        this.checker.errorReporter.simpleError(funcDecl.returnTypeAnnotation || funcDecl,\n                             "Function declared a non-void return type, but has no return expression");\n                    }\n                }\n\n                // Type check for return type Privacy\n                this.checkTypePrivacy(signature.returnType.type, container, (typeName: string, isModuleName: bool) => this.functionReturnTypePrivacyErrorReporter(funcDecl, signature, typeName, isModuleName));\n            }\n\n            // if the function declaration is a getter or a setter, set the type of the associated getter/setter symbol\n            if (funcDecl.accessorSymbol) {\n                var accessorType = funcDecl.accessorSymbol.getType();\n                if (!onlyHasThrow && hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor) && !hasFlag(funcDecl.fncFlags, FncFlags.HasReturnExpression)) {\n                    this.checker.errorReporter.simpleError(funcDecl, "Getters must return a value");\n                }\n                if (accessorType) {\n                    if ((hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor) && accessorType != signature.returnType.type) ||\n                        (funcDecl.arguments.members.length > 0 && accessorType != funcDecl.arguments.members[0].type)) {\n                        this.checker.errorReporter.simpleError(funcDecl, "Getter and setter types do not agree");\n                    }\n                }\n                else {\n                    if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {\n                        funcDecl.accessorSymbol.setType(signature.returnType.type);\n                    }\n                    else {\n                        if (funcDecl.arguments.members.length != 1) {\n                            this.checker.errorReporter.simpleError(funcDecl, "Setters may have one and only one argument");\n                        }\n                        else {\n                            funcDecl.accessorSymbol.setType(funcDecl.arguments.members[0].type);\n                        }\n                    }\n                }\n            }\n\n            this.typeCheckOverloadSignatures(fnType, funcDecl);\n            return funcDecl;\n        }\n\n        public typeCheckBases(type: Type) {\n            var seenInterface = false;\n            var bases = type.extendsList;\n            var baseLinks = type.extendsTypeLinks;\n            if (bases) {\n                var len = bases.length;\n\n                if (len > 0) {\n                    type.typeFlags |= TypeFlags.Has',
v27473=v27474+'BaseType;\n                }\n\n                for (var i = 0; i < len; i++) {\n                    if (bases[i] == this.checker.anyType) {\n                        // This may be the type from imported module and hence the type was not really resolved to the correct one.\n                        // Try resolving it again\n                        baseLinks[i].type = null;\n                        // There are no contextual errors when trying to verify the base class\n                        var oldErrors = this.checker.errorReporter.getCapturedErrors();\n                        CompilerDiagnostics.assert(oldErrors.length == 0, "There shouldnt be any contextual errors when typechecking base type names");\n                        this.checker.errorReporter.pushToErrorSink = true;\n                        bases[i] = this.checker.resolveBaseTypeLink(baseLinks[i], type.containedScope);\n                        this.checker.errorReporter.pushToErrorSink = false;\n                        this.checker.errorReporter.freeCapturedErrors();\n                    }\n\n                    var base = bases[i];\n                    var baseRef = baseLinks[i].ast;\n\n                    // make sure it\'s the global \'Object\' and not some alias\n                    var baseTypeOfObject = base.symbol && base.symbol.name == "Object" && base.symbol.container == this.checker.gloMod;\n\n                    if (baseTypeOfObject) {\n                        type.typeFlags |= TypeFlags.HasBaseTypeOfObject;\n                    }\n\n                    if (base.isClassInstance()) {\n                        if (!(type.isClassInstance())) {\n                            this.checker.errorReporter.simpleError(baseRef, "Interface base type must be interface");\n                        }\n                        else {\n                            if (seenInterface) {\n                                this.checker.errorReporter.simpleError(baseRef, "Class may not follow interface as base type");\n                            }\n                        }\n                    }\n                    else if (base.isModuleType()) {\n                        this.checker.errorReporter.simpleError(baseRef, "Types may not be derived from module types");\n                    }\n                    else if (base.members) {\n                        if (!seenInterface) {\n                            seenInterface = true;\n                        }\n                    }\n                    else {\n                        if (!(type.isClassInstance())) {\n                            this.checker.errorReporter.simpleError(baseRef,\n                                                                     "Interface base type must be interface");\n                        }\n                        else {\n                            this.checker.errorReporter.simpleError(baseRef,\n                                                                     "Base type must be interface or class");\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n\n        public checkMembersImplementInterfaces(implementingType: Type) {\n            var instanceType = implementingType.getInstanceType();\n            if (instanceType.implementsList) {\n                var len = instanceType.implementsList.length;\n\n                for (var i = 0; i < len; i++) {\n                    var interfaceType = instanceType.implementsList[i];\n                    var comparisonInfo = new TypeComparisonInfo();\n                    if (!this.checker.sourceIsSubtypeOfTarget(instanceType, interfaceType, comparisonInfo)) {\n                        var emsg = "Class \'" + instanceType.getTypeName() +\n                              "\' declares interface \'" + interfaceType.getTypeName() +\n                              "\' but does not implement it";\n                        if (!comparisonInfo.message) {\n                            this.checker.errorReporter.simpleErrorFromSym(instanceType.symbol, emsg);\n                        }\n                        else {\n                            this.checker.errorReporter.simpleErrorFromSym(instanceType.symbol, emsg + ": " + comparisonInfo.message);\n                        }\n                    }\n                }\n            }\n        }\n\n        public typeCheckBaseCalls(bases: ASTList) {\n            if (bases == null) {\n                return;\n            }\n            var basesLen = bases.members.length;\n            for (var i = 0; i < basesLen; i++) {\n                var baseExpr = bases.members[i];\n                var baseSymbol: Symbol = null;\n                if (baseExpr.nodeType == NodeType.Call) {\n                    this.typeCheckNew(baseExpr);\n                }\n            }\n        }\n\n        public assertUniqueNamesInBaseTypes(names: IHashTable, type: Type, classDecl: InterfaceDeclaration, checkUnique: bool): void {\n            if (type) {\n                if (type.members) {\n                    type.members.publicMembers.map((key, s, c) => {\n  ',
v27472=v27473+'                      var sym = <Symbol>s;\n                        var dup = names.lookup(sym.name);\n                        if (dup) {\n                            if (checkUnique) {\n                                this.checker.errorReporter.simpleError(classDecl,\n                                                                  "duplicate member name in bases for " + classDecl.name.actualText + ": " + type.symbol.name + " and " + dup.container.name + " both contain member with name " + sym.name);\n                            }\n                        }\n                        else {\n                            names.add(sym.name, sym);\n                        }\n                    }, null);\n                }\n                if (type.extendsList) {\n                    var len = type.extendsList.length;\n                    for (var i = 0; i < len; i++) {\n                        if (!(type.extendsList[i].symbol.flags & SymbolFlags.RecursivelyReferenced)) {\n                            this.assertUniqueNamesInBaseTypes(names, type.extendsList[i], classDecl, checkUnique);\n                        }\n                    }\n                }\n            }\n        }\n\n        public checkBaseTypeMemberInheritance(derivedType: Type, derivedTypeDecl: AST): void {\n            var instanceType = derivedType.getInstanceType();\n            if (instanceType.extendsList == null) {\n                return;\n            }\n\n            var len = instanceType.extendsList.length;\n            if (len > 0) {\n                var names = new StringHashTable();\n                if (instanceType.isClassInstance()) {\n                    for (var i = 0; i < len; i++) {\n                        this.assertUniqueNamesInBaseTypes(names, instanceType.extendsList[i], <InterfaceDeclaration>derivedTypeDecl, i > 0);\n                    }\n                }\n\n                if (instanceType.members) {\n                    instanceType.members.publicMembers.map((key, s, c) => {\n                        var sym = <Symbol>s;\n                        for (var j = 0; j < len; j++) {\n                            var base = instanceType.extendsList[j];\n                            if (base.memberScope == null) {\n                                this.checker.errorReporter.simpleError(derivedTypeDecl, "Base type \'" + base.symbol.name + "\' lacks an implementation.")\n                            }\n                            else {\n                                var bSym = base.memberScope.find(sym.name, false, false);\n                                if (bSym) {\n                                    var aType = sym.getType();\n                                    var bType = bSym.getType();\n                                    if (!(this.checker.sourceIsSubtypeOfTarget(aType, bType))) {\n                                        this.checker.errorReporter.simpleErrorFromSym(sym,\n                                                                          "Type of overridden member \'" + sym.name + "\' is not subtype of original member defined by type \'" + bSym.container.name + "\'");\n                                    }\n                                    else if ((sym.kind() == SymbolKind.Type) &&\n                                             (bSym.kind() == SymbolKind.Field)) {\n                                        this.checker.errorReporter.simpleErrorFromSym(sym,\n                                                                          "Cannot override field \'" + sym.name + "\' with method");\n                                    }\n                                }\n                            }\n                        }\n                    }, null);\n                }\n            }\n        }\n\n        public typeCheckClass(classDecl: ClassDeclaration): ClassDeclaration {\n            var typeSymbol = <TypeSymbol>classDecl.type.symbol;\n\n            if (typeSymbol.typeCheckStatus == TypeCheckStatus.Finished) {\n                return classDecl;\n            }\n            else if (typeSymbol.typeCheckStatus == TypeCheckStatus.Started) {\n                // REVIEW: report this recursion\n                //checker.errorReporter.recursionRequiresTypeAnnotation(classDecl);\n                return classDecl;\n            }\n            else {\n                typeSymbol.typeCheckStatus = TypeCheckStatus.Started;\n                this.checker.addStartedPTO(typeSymbol);\n            }\n\n            var prevScope = this.scope;\n            var svClassNode = this.thisClassNode;\n            this.thisClassNode = classDecl;\n            var classType = classDecl.type;\n            this.typeCheckBases(classType.instanceType);\n\n            this.typeCheckBaseListPrivacy(classDecl.extendsList, typeSymbol, true);\n            this.typeCheckBaseListPrivacy(classDecl.implementsList, typeSymbol, false);\n\n            var prevThisType = this.thisType;\n            this.thisType = classType.instanceType;\n            this.scope = classType.instanceType.containedScope;\n\n            // Add the constructor locals, if necessary\n  ',
v27471=v27472+'          if (classDecl.constructorDecl) {\n                this.scope = classType.instanceType.constructorScope;\n                var ssb = <SymbolScopeBuilder>this.scope;\n                var funcTable = ssb.valueMembers.allMembers;\n\n                this.addConstructorLocalArgs(classDecl.constructorDecl.type.symbol, classDecl.constructorDecl.arguments, funcTable, true);\n            }\n\n            this.typeCheck(classDecl.members);\n            typeSymbol.typeCheckStatus = TypeCheckStatus.Finished;\n            this.checkBaseTypeMemberInheritance(classType, classDecl);\n            this.checkMembersImplementInterfaces(classType);\n\n            this.typeCheckOverloadSignatures(classType, classDecl);\n            this.typeCheckOverloadSignatures(classType.instanceType, classDecl);\n\n            // if the class has no declared constructor, adapt its base class\'s signature group, if necessary\n            if (!classDecl.constructorDecl) {\n                if (classDecl.extendsList &&\n                    classDecl.extendsList.members.length &&\n                    classDecl.extendsList.members[0].type &&\n                    classDecl.extendsList.members[0].type.symbol.type.isClass()) {\n                    cloneParentConstructGroupForChildType(classDecl.type, classDecl.extendsList.members[0].type.symbol.type);\n                }\n            }\n\n            this.thisType = prevThisType;\n            this.thisClassNode = svClassNode;\n            this.scope = prevScope;\n            return classDecl;\n        }\n\n        public typeCheckOverloadSignatures(type: Type, ast: AST) {\n            if (type.call) {\n                type.call.typeCheck(this.checker, ast, type.construct != null);\n            }\n            if (type.construct) {\n                type.construct.typeCheck(this.checker, ast, false);\n            }\n            if (type.index) {\n                type.index.typeCheck(this.checker, ast, false);\n            }\n        }\n\n        public typeCheckInterface(interfaceDecl: InterfaceDeclaration): InterfaceDeclaration {\n            // overloads will be typechecked inline by the members\n            //this.typeCheckOverloadSignatures(interfaceDecl.type, interfaceDecl);\n            this.typeCheckBases(interfaceDecl.type);\n            this.typeCheckBaseListPrivacy(interfaceDecl.extendsList, interfaceDecl.type.symbol, true);\n            this.typeCheck(interfaceDecl.members);\n            this.checkBaseTypeMemberInheritance(interfaceDecl.type, interfaceDecl);\n\n            // propagate base type signatures\n            if (interfaceDecl.extendsList) {\n                for (var i = 0; i < interfaceDecl.extendsList.members.length; i++) {\n                    if (interfaceDecl.extendsList.members[i].type.call) {\n                        if (interfaceDecl.type.call) {\n                            interfaceDecl.type.call.signatures = interfaceDecl.type.call.signatures.concat(interfaceDecl.extendsList.members[i].type.call.signatures);\n                        }\n                        else {\n                            interfaceDecl.type.call = interfaceDecl.extendsList.members[i].type.call;\n                        }\n                    }\n                    if (interfaceDecl.extendsList.members[i].type.construct) {\n                        if (interfaceDecl.type.construct) {\n                            interfaceDecl.type.construct.signatures = interfaceDecl.type.construct.signatures.concat(interfaceDecl.extendsList.members[i].type.construct.signatures);\n                        }\n                        else {\n                            interfaceDecl.type.construct = interfaceDecl.extendsList.members[i].type.construct;\n                        }\n                    }\n                    if (interfaceDecl.extendsList.members[i].type.index) {\n                        if (interfaceDecl.type.index) {\n                            interfaceDecl.type.index.signatures = interfaceDecl.type.index.signatures.concat(interfaceDecl.extendsList.members[i].type.index.signatures);\n                        }\n                        else {\n                            interfaceDecl.type.index = interfaceDecl.extendsList.members[i].type.index;\n                        }\n                    }\n                }\n            }\n\n            return interfaceDecl;\n        }\n\n        public typeCheckImportDecl(importDecl: ImportDeclaration) {\n            var mod: ModuleType = <ModuleType>importDecl.alias.type;\n            var sym: TypeSymbol = null;\n            var prevInImportTC = this.inImportTypeCheck;\n            this.inImportTypeCheck = true;\n\n            this.typeCheck(importDecl.alias);\n            mod = <ModuleType>importDecl.alias.type;\n\n            if (mod == null) {\n                this.checker.errorReporter.simpleError(importDecl.alias, "Could not resolve module alias \'" + importDecl.id.actualText + "\'");\n                mod = <ModuleType>this.checker.anyType;\n                (<TypeSymbol>importDecl.id.sym).type = mod;\n            }\n\n            importDecl.id.type = mod;',
v27470=v27471+'\n            sym = mod.symbol;\n\n            if (!mod.isModuleType()) {\n                this.checker.errorReporter.simpleError(importDecl.alias, "A module cannot be aliased to a non-module type");\n            }\n            else {\n                sym.type = mod;\n                \n                // Add the imported module to the AMD dependency list\n                if (this.checker.typeFlow.currentScript && \n                    this.checker.typeFlow.currentScript.topLevelMod && \n                    this.checker.typeFlow.currentScript.topLevelMod.mod) \n                {\n                    this.checker.typeFlow.currentScript.topLevelMod.mod.importedModules.push(importDecl);\n                }\n\n                (<TypeSymbol>importDecl.id.sym).type = mod;\n\n                if (mod.symbol && mod.symbol.declAST) {\n                    (<ModuleDeclaration>mod.symbol.declAST).modFlags &= ~ModuleFlags.ShouldEmitModuleDecl;\n                }\n\n                //importDecl.id.sym = sym;\n                // REVIEW: Uncomment when you can toggle module codegen targets from the language service\n                //else if (typeFlow.checker.currentModDecl == null && \n                //            hasFlag((<ModuleDecl>sym.declAST).modFlags,ModuleFlags.IsDynamic) &&\n                //            moduleGenTarget == ModuleGenTarget.Asynchronous) \n                //{\n                //    typeFlow.checker.errorReporter.simpleError(alias, "In AMD codegen mode, dynamic modules may not be referenced from global scope.  (Wrap the file in a module declaration.)");\n                //}\n            }\n            this.inImportTypeCheck = prevInImportTC;\n            return importDecl;\n        }\n\n        public typeCheckModule(moduleDecl: ModuleDeclaration): ModuleDeclaration {\n\n            // In some really nasty cases of error recovery, we may not have a type\n            if (!moduleDecl.mod) {\n                return moduleDecl;\n            }\n\n            if (this.currentScript) {\n                this.currentScript.requiresGlobal = true;\n            }\n            var mod = moduleDecl.mod;\n            var sym: TypeSymbol = null;\n\n            var prevScope = this.scope;\n            var prevThisType = this.thisType;\n            var prevCurrentModDecl = this.checker.currentModDecl;\n            this.checker.currentModDecl = moduleDecl;\n\n            this.thisType = null;\n            this.scope = mod.containedScope;\n            this.typeCheck(moduleDecl.members);\n            sym = mod.symbol;\n\n            this.checker.currentModDecl = prevCurrentModDecl;\n            this.thisType = prevThisType;\n            this.scope = prevScope;\n\n            moduleDecl.type = mod;\n\n            if (sym) {\n                sym.typeCheckStatus = TypeCheckStatus.Finished;\n            }\n            return moduleDecl;\n        }\n\n        public typeCheckFor(forStmt: ForStatement): ForStatement {\n            forStmt.init = this.typeCheck(forStmt.init);\n            this.nestingLevel++;\n            forStmt.cond = this.typeCheck(forStmt.cond);\n            this.typeCheckCondExpr(forStmt.cond);\n            forStmt.incr = this.typeCheck(forStmt.incr);\n            this.nestingLevel--;\n            forStmt.body = this.typeCheck(forStmt.body);\n            this.typeCheckCompoundStmtBlock(forStmt.body, "for statement");\n            forStmt.type = this.voidType;\n            return forStmt;\n        }\n\n        public typeCheckWith(withStmt: WithStatement): WithStatement {\n            if (this.checker.errorsOnWith) {\n                this.checker.errorReporter.simpleError(withStmt.expr, "All symbols within a \'with\' block will be typed as \'any\'");\n            }\n            withStmt.expr = this.typeCheck(withStmt.expr);\n            this.checker.inWith = true;\n            withStmt.body = this.typeCheck(withStmt.body);\n            this.typeCheckCompoundStmtBlock(withStmt.body, "with statement");\n            this.checker.inWith = false;\n            return withStmt;\n        }\n\n        public typeCheckForIn(forInStmt: ForInStatement): ForInStatement {\n            forInStmt.obj = this.typeCheck(forInStmt.obj);\n            forInStmt.lval = this.cast(this.typeCheck(forInStmt.lval), this.checker.stringType);\n            if (forInStmt.lval.nodeType == NodeType.VarDecl) {\n\n                var varDecl = <VarDecl>forInStmt.lval;\n                if (varDecl.typeExpr) {\n                    this.checker.errorReporter.simpleError(varDecl, "Variable declarations for for/in expressions may not contain a type annotation");\n                }\n\n                if (varDecl.sym) {\n                    varDecl.sym.setType(this.checker.stringType);\n                }\n            }\n            forInStmt.body = this.typeCheck(forInStmt.body);\n            this.typeCheckCompoundStmtBlock(forInStmt.body, "for in statement");\n            return forInStmt;\n        }\n\n        public typeCheckWhile(whileStmt: WhileStatement): WhileStatement {\n            whileStmt.cond = this.typeCheck(whileStmt.cond);\n            this.typeCheckCondE',
v27469=v27470+'xpr(whileStmt.cond);\n            whileStmt.body = this.typeCheck(whileStmt.body);\n            this.typeCheckCompoundStmtBlock(whileStmt.body, "while statement");\n            whileStmt.type = this.voidType;\n            return whileStmt;\n        }\n\n        public typeCheckDoWhile(doWhileStmt: DoWhileStatement): DoWhileStatement {\n            doWhileStmt.cond = this.typeCheck(doWhileStmt.cond);\n            this.typeCheckCondExpr(doWhileStmt.cond);\n            doWhileStmt.body = this.typeCheck(doWhileStmt.body);\n            this.typeCheckCompoundStmtBlock(doWhileStmt.body, "do while statement");\n            doWhileStmt.type = this.voidType;\n            return doWhileStmt;\n        }\n\n        public typeCheckCondExpr(cond: AST) {\n            if (this.checker.styleSettings.assignmentInCond) {\n                if ((cond !== null) &&\n                    (cond.nodeType >= NodeType.Asg) &&\n                    (cond.nodeType <= NodeType.LastAsg)) {\n                    this.checker.errorReporter.simpleError(cond, "top-level assignment statement in conditional expression");\n                }\n            }\n        }\n\n        public typeCheckCompoundStmtBlock(stmts: AST, stmtType: string) {\n            if (this.checker.styleSettings.blockInCompoundStmt && stmts) {\n                if (stmts.nodeType != NodeType.Block) {\n                    this.checker.errorReporter.styleError(stmts, stmtType + " requires a block");\n                }\n            }\n        }\n        public typeCheckIf(ifStmt: IfStatement): IfStatement {\n            ifStmt.cond = this.typeCheck(ifStmt.cond);\n            this.typeCheckCondExpr(ifStmt.cond);\n            ifStmt.thenBod = this.typeCheck(ifStmt.thenBod);\n            ifStmt.elseBod = this.typeCheck(ifStmt.elseBod);\n            this.typeCheckCompoundStmtBlock(ifStmt.thenBod, "if statement");\n            this.typeCheckCompoundStmtBlock(ifStmt.elseBod, "if statement");\n            ifStmt.type = this.voidType;\n            return ifStmt;\n        }\n\n        public typeFromAccessorFuncDecl(funcDecl: FuncDecl) {\n            if (!funcDecl.isAccessor()) {\n                return null;\n            }\n\n            if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {\n                return funcDecl.type.call.signatures[0].returnType.type;\n            }\n            else {\n                return funcDecl.type.call.signatures[0].parameters[0].getType();\n            }\n        }\n\n        public typeCheckObjectLit(objectLit: UnaryExpression): void {\n\n            var resultType = new Type();\n            resultType.symbol = new TypeSymbol(this.checker.anon, objectLit.minChar,\n                                             objectLit.limChar - objectLit.minChar,\n                                             this.checker.locationInfo.unitIndex,\n                                             resultType);\n\n            resultType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            resultType.memberScope = new SymbolTableScope(resultType.members, null, null, null, null);\n\n            var aggScope = new SymbolAggregateScope(resultType.symbol);\n            aggScope.addParentScope(resultType.memberScope);\n            aggScope.addParentScope(this.scope);\n            resultType.containedScope = aggScope;\n            var memberDecls = <ASTList>objectLit.operand;\n            var prevThisType = this.thisType;\n            var acceptTargetType = false;\n            var targetType: Type = null;\n\n            if (this.checker.hasTargetType()) {\n                targetType = this.checker.getTargetTypeContext().contextualType;\n\n                if (targetType && targetType.symbol && !this.checker.typeStatusIsFinished(targetType.symbol.typeCheckStatus)) {\n                    if (targetType.symbol.declAST) {\n                        this.typeCheck(targetType.symbol.declAST);\n                    }\n                }\n                acceptTargetType = true;\n            }\n\n            if (memberDecls) {\n                for (var i = 0, len = memberDecls.members.length; i < len; i++) {\n\n                    var binex = <BinaryExpression>memberDecls.members[i];\n\n                    var id = binex.operand1;\n                    var text: string;\n                    var targetMember: Symbol = null;\n                    var fieldSymbol: FieldSymbol = null;\n\n                    if (id.nodeType == NodeType.Name) {\n                        text = (<Identifier>id).text;\n                    }\n                    else if (id.nodeType == NodeType.QString) {\n                        // TODO: set text to unescaped string\n                        var idText = (<StringLiteral>id).text;\n                        text = idText.substring(1, idText.length - 1);\n                    }\n                    else {\n                        this.checker.errorReporter.simpleError(objectLit,\n                                                          "malformed object literal");\n                        resultType = this.anyType;\n       ',
v27468=v27469+"                 break;\n                    }\n\n                    if (acceptTargetType && targetType.memberScope) {\n                        targetMember = targetType.memberScope.find(text, false, false);\n                    }\n\n                    // before typechecking an accessor function member, we need to initialize its accessor symbol\n                    if (binex.operand2.nodeType == NodeType.FuncDecl && (<FuncDecl>binex.operand2).isAccessor()) {\n\n                        var funcDecl = <FuncDecl>binex.operand2;\n                        var accessorSym: FieldSymbol = resultType.members.publicMembers.lookup(text);\n\n                        accessorSym = this.checker.createAccessorSymbol(funcDecl, accessorSym, resultType, true, false, resultType.memberScope, null);\n                        funcDecl.accessorSymbol = accessorSym;\n                        fieldSymbol = accessorSym;\n                        if (id.nodeType == NodeType.Name) {\n                            (<Identifier>id).sym = accessorSym;\n                        }\n                    }\n\n                    this.checker.typeCheckWithContextualType(acceptTargetType && targetMember ? targetMember.getType() : null, false, acceptTargetType, binex.operand2);\n\n                    if (acceptTargetType && targetMember) {\n                        // Note that we accept 'any' in place of a valid subtype                     \n                        if ((binex.operand2.type == this.anyType || this.checker.sourceIsAssignableToTarget(binex.operand2.type, targetMember.getType())) ||\n                            (binex.operand2.nodeType == NodeType.FuncDecl &&\n                            (<FuncDecl>binex.operand2).isAccessor() &&\n                                this.typeFromAccessorFuncDecl(<FuncDecl>binex.operand2) == targetMember.getType())) {\n                                    // set the field type to the proper contextual type\n                                    // this is especially important in the 'any' case, so that\n                                    // fields typed to 'any' aren't accepted for contextual typing,\n                                    // but never properly set to the target type\n                            binex.operand1.type = targetMember.getType();\n                        }\n                    }\n                    else {\n                        // here we sub in 'any' for 'undefined' to account for field initialization to\n                        // 'undefined'  \n                        binex.operand2.type = binex.operand2.type == this.checker.undefinedType ? this.anyType : binex.operand2.type;\n                    }\n\n                    // the field symbol hasn't been set by a getter or setter\n                    if (fieldSymbol == null) {\n                        var memberType = binex.operand2.type;\n                        var field = new ValueLocation();\n                        fieldSymbol =\n                            new FieldSymbol(text, id.minChar,\n                                            this.checker.locationInfo.unitIndex,\n                                            true, field);\n                        fieldSymbol.flags |= SymbolFlags.Property;\n                        field.symbol = fieldSymbol;\n                        fieldSymbol.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();\n                        field.typeLink = new TypeLink();\n                        field.typeLink.type = memberType;\n                        resultType.members.publicMembers.add(text, fieldSymbol);\n                    }\n                    fieldSymbol.isObjectLitField = true;\n                }\n            }\n\n            this.thisType = prevThisType;\n            objectLit.type = resultType;\n            if (targetType) {\n                objectLit.targetType = targetType;\n            }\n        }\n\n        public typeCheckArrayLit(arrayLit: UnaryExpression): void {\n            var elements = <ASTList>arrayLit.operand;\n            var elementType = this.anyType;\n            var targetElementType: Type = null;\n            var comparisonInfo = new TypeComparisonInfo();\n            comparisonInfo.onlyCaptureFirstError = true;\n\n            // if the target type is an array type, extract the element type\n            if (this.checker.hasTargetType()) {\n                var targetType = this.checker.getTargetTypeContext().contextualType;\n                if (targetType.elementType) {\n                    targetElementType = targetType.elementType;\n                }\n            }\n\n            if (elements) {\n\n                var prevInArrayElemTypeCheck = this.inArrayElementTypeCheck;\n\n                this.inArrayElementTypeCheck = true;\n                this.checker.typeCheckWithContextualType(targetElementType, this.checker.inProvisionalTypecheckMode(), targetElementType != null, elements);\n                this.inArrayElementTypeCheck = prevInArrayElemTypeCheck;\n\n                elementType = elements.members[0].type;\n\n                var collection: ITypeCo",
v27467=v27468+'llection = {\n                    getLength: () => { return elements.members.length; },\n                    setTypeAtIndex: (index: number, type: Type) => { elements.members[index].type = type; },\n                    getTypeAtIndex: (index: number) => { return elements.members[index].type; }\n                }\n\n                elementType = this.checker.findBestCommonType(elementType, targetElementType, collection, false, comparisonInfo);\n\n                // if the array type is the undefined type, we should widen it to any\n                // if it\'s of the null type, only widen it if it\'s not in a nested array element, so as not to \n                // short-circuit any checks for the best common type\n                if (elementType == this.checker.undefinedType || (!prevInArrayElemTypeCheck && elementType == this.nullType)) {\n                    elementType = this.anyType;\n                }\n            }\n            if (!elementType) {\n                var emsg = "Incompatible types in array literal expression";\n                if (!comparisonInfo.message) {\n                    this.checker.errorReporter.simpleError(arrayLit, emsg);\n                }\n                else {\n                    this.checker.errorReporter.simpleError(arrayLit, emsg + ": " + comparisonInfo.message);\n                }\n                elementType = this.anyType;\n            }\n            else if (targetElementType) {\n                // for the case of zero-length \'any\' arrays, we still want to set the contextual type, if\n                // need be\n                if (this.checker.sourceIsAssignableToTarget(elementType, targetElementType)) {\n                    elementType = targetElementType;\n                }\n            }\n\n            arrayLit.type = this.checker.makeArrayType(elementType);\n\n        }\n\n        public checkForVoidConstructor(type: Type, ast: AST) {\n            if (type &&\n                type.construct &&\n                type.construct.signatures.length > 0) {\n\n                for (var i = 0; i < type.construct.signatures.length; i++) {\n                    if (type.construct.signatures[i].returnType.type == this.checker.voidType) {\n                        this.checker.errorReporter.simpleError(ast, "Constructors may not have a return type of \'void\'");\n                        break;\n                    }\n                }\n            }\n        }\n\n        // REVIEW: the code below could set the signature type of the function to the current return\n        // type, which would have a benefit of reducing the risk of a recursive typecheck scenario, but is\n        // is technically wrong - mergeOrdered will only work properly if the best common supertype\n        // comes before any sibling types.  This would mean that if a function, "color()", returned\n        // three types (in order) - "Red", "Blue", and "IColor", an "Incompatible return type" error \n        // would be triggered.  However, if "color()" returned (in order) "Red", "IColor" and "Blue"\n        // no error would be triggered, and the return type of the function would be "IColor"\n        public typeCheckReturn(returnStmt: ReturnStatement): ReturnStatement {\n\n            if (this.thisFnc) {\n                var targetType: Type = null;\n\n                // determine the target type\n                if (this.checker.hasTargetType()) {\n                    var tcContext = this.checker.getTargetTypeContext();\n                    var accessorType = tcContext.targetAccessorType;\n\n                    if (accessorType) {\n                        targetType = accessorType;\n                    }\n                    else {\n                        var targetSig = this.checker.getTargetTypeContext().targetSig;\n                        if (targetSig && targetSig.returnType.type != this.voidType) {\n                            targetType = targetSig.returnType.type;\n                        }\n                    }\n                }\n\n                if (returnStmt.returnExpression) {\n                    this.thisFnc.fncFlags |= FncFlags.HasReturnExpression;\n\n                    if (targetType == null && this.thisFnc.returnTypeAnnotation && this.thisFnc.returnTypeAnnotation.type && this.thisFnc.returnTypeAnnotation.type != this.voidType) {\n                        targetType = this.thisFnc.returnTypeAnnotation.type;\n                    }\n\n                    this.checker.typeCheckWithContextualType(targetType, this.checker.inProvisionalTypecheckMode(), targetType != null, returnStmt.returnExpression);\n\n                    var expectedReturnType: Type =\n                        (this.thisFnc.returnTypeAnnotation && this.thisFnc.returnTypeAnnotation.type) ?\n                            this.thisFnc.returnTypeAnnotation.type :\n                            targetType;\n                    if (expectedReturnType) {\n                        if (expectedReturnType == this.voidType && returnStmt.returnExpression.type != this.voidType) {\n                            this.checker.errorReporter.simp',
v27466=v27467+'leError(returnStmt,\n                                                              "Return with value expression in void function");\n\n                            // even though we\'ve raised an error, use the more specific type\n                            returnStmt.type = returnStmt.returnExpression.type;\n                        }\n                        else {\n                            returnStmt.returnExpression = this.cast(returnStmt.returnExpression, expectedReturnType);\n                            returnStmt.type = expectedReturnType;\n                        }\n                    }\n                    else {\n                        if (targetType) {\n                            if (returnStmt.returnExpression.type != this.voidType) {\n                                returnStmt.returnExpression = this.cast(returnStmt.returnExpression, targetType);\n                            }\n                            else {\n                                returnStmt.returnExpression.type = targetType;\n                            }\n                        }\n                        returnStmt.type = returnStmt.returnExpression.type;\n                    }\n                    this.thisFnc.returnStatementsWithExpressions[this.thisFnc.returnStatementsWithExpressions.length] = returnStmt;\n                }\n                else {\n                    returnStmt.type = targetType == null ? this.checker.voidType : targetType; //((this.thisFnc.returnTypeAnnotation && this.thisFnc.returnTypeAnnotation.type) ? this.thisFnc.returnTypeAnnotation.type : this.checker.voidType) : targetType;\n                }\n            }\n\n            return returnStmt;\n        }\n\n        public typeCheckInstOf(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n\n            if (!((binex.operand1.type == this.checker.anyType || this.checker.sourceIsSubtypeOfTarget(binex.operand1.type, this.objectInterfaceType)) &&\n                    (binex.operand2.type == this.anyType || this.checker.sourceIsSubtypeOfTarget(binex.operand2.type, this.functionInterfaceType)))) {\n                this.checker.errorReporter.simpleError(ast, "The instanceof operator requires the left operand to be of type Any or an object type, and the right operand to be of type Any or a subtype of the Function interface type");\n            }\n            binex.type = this.booleanType;\n            return binex;\n        }\n\n        public typeCheckCommaOperator(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            binex.type = binex.operand2.type;\n            return binex;\n        }\n\n        public typeCheckLogOr(binex: BinaryExpression): BinaryExpression {\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            var leftType = binex.operand1.type;\n            var rightType = binex.operand2.type;\n\n            if (leftType == this.checker.anyType || rightType == this.checker.anyType) {\n                binex.type = this.checker.anyType;\n            }\n            else if (leftType == this.checker.booleanType) {\n                if (rightType == this.checker.booleanType) {\n                    binex.type = this.checker.booleanType;\n                }\n                else {\n                    binex.type = this.checker.anyType;\n                }\n            }\n            else if (leftType == this.checker.numberType) {\n                if (rightType == this.checker.numberType) {\n                    binex.type = this.checker.numberType;\n                }\n                else {\n                    binex.type = this.checker.anyType;\n                }\n            }\n            else if (leftType == this.checker.stringType) {\n                if (rightType == this.checker.stringType) {\n                    binex.type = this.checker.stringType;\n                }\n                else {\n                    binex.type = this.checker.anyType;\n                }\n            }\n            else {\n                if (this.checker.sourceIsSubtypeOfTarget(leftType, rightType)) {\n                    binex.type = rightType;\n                }\n                else if (this.checker.sourceIsSubtypeOfTarget(rightType, leftType)) {\n                    binex.type = leftType;\n                }\n                else {\n                    binex.type = this.checker.anyType;\n                }\n            }\n            return binex;\n        }\n\n        public typeCheckLogAnd(binex: BinaryExpression): BinaryExpression {\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            binex.type = binex.operand2.type;\n            return binex;\n        }\n\n        public tryAddCandidates(signature: Signature, actuals: Type[]',
v27465=v27466+", exactCandidates: Signature[], conversionCandidates: Signature[], comparisonInfo: TypeComparisonInfo): void {\n            var lowerBound = signature.nonOptionalParameterCount; // required parameters\n            var upperBound = signature.parameters.length; // required and optional parameters\n            var formalLen = lowerBound;\n            var acceptable = false;\n\n            if ((actuals.length >= lowerBound) && (signature.hasVariableArgList || actuals.length <= upperBound)) {\n                formalLen = (signature.hasVariableArgList ? signature.parameters.length : actuals.length);\n                acceptable = true;\n            }\n\n            var repeatType: Type = null;\n\n            if (acceptable || signature.hasVariableArgList) {\n                // assumed structure here is checked when signature is formed\n                if (signature.hasVariableArgList) {\n                    formalLen -= 1;\n                    repeatType = (<ParameterSymbol>signature.parameters[formalLen]).parameter.typeLink.type;\n                    repeatType = repeatType.elementType;\n                    acceptable = actuals.length >= formalLen;\n                }\n                var len = actuals.length;\n\n                var exact = acceptable;\n                var convert = acceptable;\n                for (var i = 0; i < len; i++) {\n                    var typeA: Type;\n                    if (i < formalLen) {\n                        typeA =\n                            (<ParameterSymbol>signature.parameters[i]).parameter.typeLink.type;\n                    }\n                    else {\n                        typeA = repeatType;\n                    }\n\n                    var typeB = actuals[i];\n                    if (!typeA || !typeB || !(this.checker.typesAreIdentical(typeA, typeB))) {\n                        exact = false;\n                    }\n                    // is the argument assignable to the parameter?\n                    if (!this.checker.sourceIsAssignableToTarget(typeB, typeA, comparisonInfo)) {\n                        convert = false;\n                    }\n                    if (!(exact || convert)) {\n                        break;\n                    }\n                }\n                if (exact) {\n                    exactCandidates[exactCandidates.length] = signature;\n                }\n                else if (convert && (exactCandidates.length == 0)) {\n                    conversionCandidates[conversionCandidates.length] = signature;\n                }\n\n            }\n        }\n\n        public resolveOverload(application: AST, group: SignatureGroup): Signature {\n            var rd = this.resolutionDataCache.getResolutionData();\n            var actuals = rd.actuals;\n            var exactCandidates = rd.exactCandidates;\n            var conversionCandidates = rd.conversionCandidates;\n            var candidate: Signature = null;\n            var hasOverloads = group.signatures.length > 1;\n            var comparisonInfo = new TypeComparisonInfo();\n            var args: ASTList = null;\n            var target: AST = null;\n\n            if (application.nodeType == NodeType.Call || application.nodeType == NodeType.New) {\n                var callEx = <CallExpression>application;\n                args = callEx.arguments;\n                target = callEx.target;\n                if (callEx.arguments) {\n                    var len = callEx.arguments.members.length;\n                    for (var i = 0; i < len; i++) {\n                        actuals[i] = callEx.arguments.members[i].type;\n                    }\n                }\n            }\n            else if (application.nodeType == NodeType.Index) {\n                var binExp = <BinaryExpression>application;\n                target = binExp.operand1;\n                args = new ASTList();\n                args.members[0] = binExp.operand2;\n                actuals[0] = binExp.operand2.type;\n            }\n\n            for (var j = 0, groupLen = group.signatures.length; j < groupLen; j++) {\n                var signature = group.signatures[j];\n                if (hasOverloads && signature == group.definitionSignature && !this.checker.canCallDefinitionSignature) {\n                    continue;\n                }\n                if (!signature.returnType.type && signature.declAST &&\n                    (signature.typeCheckStatus != TypeCheckStatus.Finished)) {\n                    this.typeCheckFunction(signature.declAST);\n                }\n                this.tryAddCandidates(signature, actuals, exactCandidates, conversionCandidates, comparisonInfo);\n            }\n            if (exactCandidates.length == 0) {\n\n                var applicableCandidates = this.checker.getApplicableSignatures(conversionCandidates, args, comparisonInfo);\n                if (applicableCandidates.length > 0) {\n                    var candidateInfo = this.checker.findMostApplicableSignature(applicableCandidates, args);\n                    if (candidateInfo.ambiguous) {\n                        this.checker.errorR",
v27464=v27465+'eporter.simpleError(target, "Ambiguous call expression - could not choose overload");\n                    }\n                    candidate = candidateInfo.sig;\n                }\n                else {\n                    var emsg = "Supplied parameters do not match any signature of call target";\n                    if (comparisonInfo.message) {\n                        this.checker.errorReporter.simpleError(target, emsg + ":\\n\\t" + comparisonInfo.message);\n                    }\n                    else {\n                        this.checker.errorReporter.simpleError(target, emsg);\n                    }\n                }\n            }\n            else {\n                if (exactCandidates.length > 1) {\n                    var applicableSigs: ApplicableSignature[] = [];\n                    for (var i = 0; i < exactCandidates.length; i++) {\n                        applicableSigs[i] = { signature: exactCandidates[i], hadProvisionalErrors: false };\n                    }\n                    var candidateInfo = this.checker.findMostApplicableSignature(applicableSigs, args);\n                    if (candidateInfo.ambiguous) {\n                        this.checker.errorReporter.simpleError(target, "Ambiguous call expression - could not choose overload");\n                    }\n                    candidate = candidateInfo.sig;\n                }\n                else {\n                    candidate = exactCandidates[0];\n                }\n            }\n\n            this.resolutionDataCache.returnResolutionData(rd);\n            return candidate;\n        }\n\n        public typeCheckNew(ast: AST): AST {\n            var callEx = <CallExpression>ast;\n\n            callEx.target = this.typeCheck(callEx.target);\n            var target = callEx.target;\n            if (target.type.construct || target.type.call) {\n                this.preTypeCheckCallArgs(callEx.arguments);\n            }\n            else {\n                callEx.arguments = <ASTList>this.typeCheck(callEx.arguments);\n            }\n\n            if (target.type == this.anyType) {\n                callEx.type = this.anyType;\n                callEx.arguments = <ASTList>this.typeCheck(callEx.arguments);\n            }\n            else {\n                if (target.type.construct) {\n                    var signature = this.resolveOverload(callEx, target.type.construct);\n                    if (signature == null) {\n                        callEx.type = this.anyType;\n                    }\n                    else if (signature.returnType.type == this.voidType) {\n                        callEx.type = this.anyType;\n                        callEx.signature = signature;\n                    }\n                    else {\n                        callEx.type = signature.returnType.type;\n                        callEx.signature = signature;\n                    }\n                }\n                else if (target.type.call) {\n                    var signature = this.resolveOverload(callEx, target.type.call);\n                    if (signature == null) {\n                        callEx.type = this.anyType;\n                    }\n                    else if ((signature.returnType.type == this.voidType) || (signature.returnType.type == this.anyType)) {\n                        callEx.type = this.anyType;\n                        callEx.signature = signature;\n                    }\n                    else {\n                        this.checker.errorReporter.simpleError(callEx.target,\n                           "new expression only valid on constructors");\n                    }\n                }\n                else if (target.type.elementType) {\n                    callEx.type = target.type;\n                }\n                else {\n                    this.checker.errorReporter.invalidCall(callEx, callEx.nodeType, this.scope);\n                    callEx.type = this.anyType;\n                }\n            }\n\n            this.postTypeCheckCallArgs(callEx);\n\n            return callEx;\n        }\n\n        // Typecheck all args that cannot be affected by contextual typing of overloads\n        public preTypeCheckCallArgs(args: ASTList) {\n\n            if (!args) {\n                return;\n            }\n\n            for (var i = 0; i < args.members.length; i++) {\n                switch (args.members[i].nodeType) {\n                    case NodeType.FuncDecl:\n                    case NodeType.ObjectLit:\n                    case NodeType.ArrayLit:\n                        continue;\n                    default:\n                        this.typeCheck(args.members[i]);\n                        break;\n                }\n            }\n        }\n\n        public postTypeCheckCallArgs(callEx: CallExpression) {\n\n            var acceptedTargetType = false;\n            var i = 0;\n\n            if (callEx.target &&\n                callEx.target.type &&\n                callEx.signature &&\n                callEx.arguments) {\n                var sig = callEx.signature;\n\n                if (sig && callEx.arguments.members.length >= si',
v27463=v27464+'g.nonOptionalParameterCount) {\n                    acceptedTargetType = true;\n                    var targetType: Type = null;\n                    var nonVarArgFormalParamLength = sig.hasVariableArgList ? sig.parameters.length - 1 : sig.parameters.length;\n                    var nonVarArgActualParamLength = callEx.arguments.members.length < nonVarArgFormalParamLength ? callEx.arguments.members.length : nonVarArgFormalParamLength\n\n                    for (i = 0; i < nonVarArgActualParamLength; i++) {\n                        targetType = sig.parameters[i].getType();\n                        switch (callEx.arguments.members[i].nodeType) {\n                            case NodeType.FuncDecl:\n                            case NodeType.ObjectLit:\n                            case NodeType.ArrayLit:\n                                this.checker.typeCheckWithContextualType(targetType, this.checker.inProvisionalTypecheckMode(), !sig.parameters[i].declAST.isParenthesized, callEx.arguments.members[i]);\n                                break;\n                        }\n                    }\n\n                    if (sig.hasVariableArgList) {\n                        var varArgParamIndex = sig.nonOptionalParameterCount - 1;\n                        targetType = sig.parameters[varArgParamIndex].getType();\n                        if (targetType) {\n                            targetType = targetType.elementType;\n                        }\n                        var isParenthesized = !sig.parameters[varArgParamIndex].declAST.isParenthesized;\n                        for (i = nonVarArgActualParamLength; i < callEx.arguments.members.length; i++) {\n                            switch (callEx.arguments.members[i].nodeType) {\n                                case NodeType.FuncDecl:\n                                case NodeType.ObjectLit:\n                                case NodeType.ArrayLit:\n                                    this.checker.typeCheckWithContextualType(targetType, this.checker.inProvisionalTypecheckMode(), isParenthesized, callEx.arguments.members[i]);\n                                    break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (!acceptedTargetType && callEx.arguments) {\n                this.checker.killCurrentContextualType();\n\n                for (i = 0; i < callEx.arguments.members.length; i++) {\n                    switch (callEx.arguments.members[i].nodeType) {\n                        case NodeType.FuncDecl:\n                        case NodeType.ObjectLit:\n                        case NodeType.ArrayLit:\n                            this.typeCheck(callEx.arguments.members[i]);\n                            break;\n                        default:\n                            continue;\n                    }\n                }\n            }\n        }\n\n        public typeCheckCall(ast: AST): AST {\n            var callEx = <CallExpression>ast;\n            if (this.checker.styleSettings.newMustBeUsed && (ast.nodeType == NodeType.New)) {\n                if (hasFlag(ast.flags, ASTFlags.IsStatement)) {\n                    this.checker.errorReporter.styleError(ast, "use of new expression as a statement");\n                }\n            }\n            else if ((!this.checker.styleSettings.evalOK) && (ast.nodeType == NodeType.Call)) {\n                if ((callEx.target.nodeType == NodeType.Name) && ((<Identifier>callEx.target).text == "eval")) {\n                    this.checker.errorReporter.styleError(callEx, "eval not permitted");\n                }\n            }\n\n            if (callEx.target.nodeType == NodeType.FuncDecl) {\n                (<FuncDecl>callEx.target).isInlineCallLiteral = true;\n            }\n\n            var prevInSuperCall = this.inSuperCall;\n\n            if (callEx.target.nodeType == NodeType.Super) {\n                this.inSuperCall = true;\n            }\n\n            callEx.target = this.typeCheck(callEx.target);\n            this.preTypeCheckCallArgs(callEx.arguments);\n\n            var target = callEx.target;\n\n            if ((target.type == null) || (target.type == this.anyType) || (this.functionInterfaceType && target.type == this.functionInterfaceType)) {\n                callEx.type = this.anyType;\n            }\n            else {\n                var fnType = target.type;\n                if (fnType.call) {\n                    var signature = this.resolveOverload(callEx, fnType.call);\n                    if (signature == null) {\n                        callEx.type = this.anyType;\n                    }\n                    else {\n                        callEx.type = signature.returnType.type;\n                        callEx.signature = signature;\n                    }\n                }\n                else {\n                    // track calls to class base class\n                    if (callEx.target.nodeType == NodeType.Super &&\n                        this.thisFnc &&\n                        this.thisFnc.isConstructor &&\n        ',
v27462=v27463+'                hasFlag(this.thisFnc.fncFlags, FncFlags.ClassMethod)) {\n\n                            // Need to use the class type for the construct signature, not the instance type\n                        var signature = fnType.symbol.type.construct ? this.resolveOverload(callEx, fnType.symbol.type.construct) : null;\n\n                        if (signature == null) {\n                            callEx.type = this.anyType;\n                        }\n                        else {\n                            callEx.flags |= ASTFlags.ClassBaseConstructorCall;\n                            callEx.type = signature.returnType.type;\n                            callEx.signature = signature;\n                        }\n                    }\n                    else {\n                        callEx.type = this.anyType;\n                        this.checker.errorReporter.invalidCall(callEx, callEx.nodeType, this.scope);\n                    }\n                }\n            }\n            this.postTypeCheckCallArgs(callEx);\n\n            this.inSuperCall = prevInSuperCall;\n\n            return callEx;\n        }\n\n        public assignScopes(ast: AST) {\n            var script = <Script>ast;\n            this.checker.locationInfo = script.locationInfo;\n            var globalChain = new ScopeChain(this.checker.gloMod, null, this.globalScope);\n            var context = new AssignScopeContext(globalChain, this, [this.checker.currentModDecl]);\n            getAstWalkerFactory().walk(ast, preAssignScopes, postAssignScopes, null, context);\n        }\n\n        public findMemberScope(enclosingScopeContext: EnclosingScopeContext, matchFlag: ASTFlags) {\n            var enclosingScope = enclosingScopeContext.getScope();\n            var pos = enclosingScopeContext.pos - enclosingScopeContext.getScriptFragmentPosition();\n            var scriptFragment = enclosingScopeContext.getScriptFragment();\n\n            var memContext = new MemberScopeContext(this, pos, matchFlag);\n            memContext.scope = enclosingScope;\n            if (scriptFragment.nodeType == NodeType.Name) {\n                return scriptFragment.type.getMemberScope(this);\n            }\n            else {\n                getAstWalkerFactory().walk(scriptFragment, preFindMemberScope, null, null, memContext);\n                if (memContext.ast && enclosingScopeContext.enclosingClassDecl && memContext.ast.type == enclosingScopeContext.enclosingClassDecl.type.instanceType) {\n                    enclosingScopeContext.publicsOnly = false;\n                }\n                if (memContext.type) {\n                    return memContext.type.getMemberScope(this);\n                }\n                else {\n                    return null;\n                }\n            }\n        }\n\n        public findMemberScopeAt(enclosingScopeContext: EnclosingScopeContext) {\n            return this.findMemberScope(enclosingScopeContext, ASTFlags.DotLHS);\n        }\n\n        public findMemberScopeAtFullAst(enclosingScopeContext: EnclosingScopeContext) {\n            var matchFlag = ASTFlags.DotLHS;\n            var pos = enclosingScopeContext.pos;\n            var astResult: AST = null;\n\n            var preFindMemberScopeFullAst = function (ast: AST, parent: AST, walker: IAstWalker) {\n                if (isValidAstNode(ast)) {\n                    // Note: pos == ast.limChar       in case of incomplete code (e.g. "foo.")\n                    // Note: (pos - 1) == ast.limChar in case of complete code (e.g. "foo.bar")\n                    if (hasFlag(ast.flags, matchFlag) && (pos == ast.limChar || (pos - 1) == ast.limChar)) {\n                        astResult = ast;\n                        walker.options.stopWalk();\n                    }\n\n                    // Stop traversal if range does not contain position\n                    walker.options.goChildren = (ast.minChar <= pos) && (pos <= ast.limChar);\n                }\n                return ast;\n            }\n\n            var preFindMemberScopeFullAstFuzy = function (ast: AST, parent: AST, walker: IAstWalker) {\n                if (isValidAstNode(ast)) {\n                    if (hasFlag(ast.flags, matchFlag) && ((ast.minChar < pos) && (pos <= ast.limChar))) {\n                        astResult = ast;\n                    }\n\n                    // Stop traversal if range does not contain position\n                    walker.options.goChildren = (ast.minChar <= pos) && (pos <= ast.limChar);\n                }\n                return ast;\n            }\n\n            getAstWalkerFactory().walk(enclosingScopeContext.script, preFindMemberScopeFullAst);\n\n            if (astResult == null) {\n                // Perform a more "fusy" match. This is because the limChar of AST nodes is sometimes\n                // not what we expect, for example:\n                //   foo./*comment*/;\n                // In this case, limChar points to ";" instead of "." (because of the trailing comment).\n                getAstWalkerFactory().walk(enclosingScopeContext.script, preFindMemberScopeFullAstFuzy)',
v27461=v27462+";\n            }\n\n            if (astResult &&\n                enclosingScopeContext.enclosingClassDecl &&\n                astResult.type == enclosingScopeContext.enclosingClassDecl.type.instanceType) {\n                enclosingScopeContext.publicsOnly = false;\n            }\n\n            if (astResult && astResult.type) {\n                return astResult.type.getMemberScope(this);\n            }\n            else {\n                return null;\n            }\n        }\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path='diagnostics.ts' />\n///<reference path='flags.ts' />\n///<reference path='nodeTypes.ts' />\n///<reference path='hashTable.ts' />\n///<reference path='ast.ts' />\n///<reference path='astWalker.ts' />\n///<reference path='astWalkerCallback.ts' />\n///<reference path='astPath.ts' />\n///<reference path='astLogger.ts' />\n///<reference path='binder.ts' />\n///<reference path='base64.ts' />\n///<reference path='sourceMapping.ts' />\n///<reference path='emitter.ts' />\n///<reference path='errorReporter.ts' />\n///<reference path='parser.ts' />\n///<reference path='printContext.ts' />\n///<reference path='scanner.ts' />\n///<reference path='scopeAssignment.ts' />\n///<reference path='scopeWalk.ts' />\n///<reference path='signatures.ts' />\n///<reference path='symbols.ts' />\n///<reference path='symbolScope.ts' />\n///<reference path='tokens.ts' />\n///<reference path='typeChecker.ts' />\n///<reference path='typeCollection.ts' />\n///<reference path='typeFlow.ts' />\n///<reference path='types.ts' />\n///<reference path='pathUtils.ts' />\n///<reference path='referenceResolution.ts' />\n///<reference path='precompile.ts' />\n///<reference path='incrementalParser.ts' />\n///<reference path='declarationEmitter.ts' />\n\nmodule TypeScript {\n\n    export enum UpdateUnitKind {\n        Unknown,\n        NoEdits,\n        EditsInsideSingleScope,\n    }\n\n    export class ScriptEditRange {\n        constructor (public minChar: number,\n                     public limChar: number,\n                     public delta: number) { }\n\n        static unknown(): ScriptEditRange {\n            return new ScriptEditRange(-1, -1, -1);\n        }\n\n        public isUnknown() {\n            return this.minChar === -1 && this.limChar === -1 && this.delta === -1;\n        }\n\n        public containsPosition(pos: number) {\n            return (this.minChar <= pos && pos < this.limChar)\n                || (this.minChar <= pos && pos < this.limChar + this.delta);\n        }\n\n        public toString(): string {\n            return \"editRange(minChar=\" + this.minChar + \", limChar=\" + this.limChar + \", delta=\" + this.delta + \")\";\n        }\n    }\n\n    export class UpdateUnitResult {\n\n        constructor (public kind: UpdateUnitKind, public unitIndex: number, public script1: Script, public script2: Script) { }\n\n        public scope1: AST = null;\n        public scope2: AST = null;\n        public editRange: ScriptEditRange = null;\n        public parseErrors: ErrorEntry[] = [];\n\n        static noEdits(unitIndex: number) {\n            return new UpdateUnitResult(UpdateUnitKind.NoEdits, unitIndex, null, null);\n        }\n\n        static unknownEdits(script1: Script, script2: Script, parseErrors: ErrorEntry[]) {\n            var result = new UpdateUnitResult(UpdateUnitKind.Unknown, script1.locationInfo.unitIndex, script1, script2);\n            result.parseErrors = parseErrors;\n            return result;\n        }\n\n        static singleScopeEdits(script1: Script, script2: Script, scope1: AST, scope2: AST, editRange: ScriptEditRange, parseErrors: ErrorEntry[]) {\n            var result = new UpdateUnitResult(UpdateUnitKind.EditsInsideSingleScope, script1.locationInfo.unitIndex, script1, script2);\n            result.scope1 = scope1;\n            result.scope2 = scope2;\n            result.editRange = editRange;\n            result.parseErrors = parseErrors;\n            return result;\n        }\n    }\n\n    export class ErrorEntry {\n        constructor (public unitIndex: number,\n                    public minChar: number,\n                    public limChar: number,\n                    public message: string) { }\n    }\n\n    export var defaultSettings = new CompilationSettings();\n\n    export interface EmitterIOHost {\n        // function that can even create a folder structure if needed\n        createFile(path: string, useUTF8?: bool): ITextWriter;\n\n        // function to check if file exists on the disk\n        fileExi",
v27460=v27461+'sts(path: string): bool;\n\n        // Function to check if the directory exists on the disk\n        directoryExists(path: string): bool;\n\n        // Resolves the path\n        resolvePath(path: string): string;\n    }\n\n    export class TypeScriptCompiler {\n        public parser = new Parser();\n        public typeChecker: TypeChecker;\n        public typeFlow: TypeFlow = null;\n        public scripts = new ASTList();\n        public units: LocationInfo[] = new LocationInfo[];\n        public errorReporter: ErrorReporter;\n\n        public persistentTypeState: PersistentGlobalTypeState;\n\n\n        public emitSettings: EmitOptions;\n\n        constructor (public errorOutput: ITextWriter, public logger: ILogger = new NullLogger(), public settings: CompilationSettings = defaultSettings) {\n            this.errorReporter = new ErrorReporter(this.errorOutput);\n            this.persistentTypeState = new PersistentGlobalTypeState(this.errorReporter);\n            this.errorReporter.parser = this.parser;\n            this.initTypeChecker(this.errorOutput);\n\n            this.parser.style_requireSemi = this.settings.styleSettings.requireSemi;\n            this.parser.style_funcInLoop = this.settings.styleSettings.funcInLoop;\n            this.parser.inferPropertiesFromThisAssignment = this.settings.inferPropertiesFromThisAssignment;\n            this.emitSettings = new EmitOptions(this.settings);\n            codeGenTarget = settings.codeGenTarget;\n        }\n\n        public timeFunction(funcDescription: string, func: () => any): any {\n            return TypeScript.timeFunction(this.logger, funcDescription, func);\n        }\n\n        public initTypeChecker(errorOutput: ITextWriter) {\n            // The initial "refresh" initializes the persistent type state\n            this.persistentTypeState.refreshPersistentState();\n            this.typeChecker = new TypeChecker(this.persistentTypeState);\n            this.typeChecker.errorReporter = this.errorReporter;\n\n            // REVIEW: These properties should be moved out of the typeCheck object\n            // ideally, CF should be a separate pass, independent of control flow\n            this.typeChecker.checkControlFlow = this.settings.controlFlow;\n            this.typeChecker.checkControlFlowUseDef = this.settings.controlFlowUseDef;\n            this.typeChecker.printControlFlowGraph = this.settings.printControlFlow;\n\n            this.typeChecker.errorsOnWith = this.settings.errorOnWith;\n            this.typeChecker.styleSettings = this.settings.styleSettings;\n            this.typeChecker.canCallDefinitionSignature = this.settings.canCallDefinitionSignature;\n\n            this.errorReporter.checker = this.typeChecker;\n            this.setErrorOutput(this.errorOutput);\n        }\n\n        public setErrorOutput(outerr) {\n            this.errorOutput = outerr;\n            this.errorReporter.setErrOut(outerr);\n            this.parser.outfile = outerr;\n        }\n\n        public emitCommentsToOutput() {\n            this.emitSettings = new EmitOptions(this.settings);\n        }\n\n        public setErrorCallback(fn: (minChar: number, charLen: number, message: string,\n            unitIndex: number) =>void ) {\n            this.parser.errorCallback = fn;\n        }\n\n        public updateUnit(prog: string, filename: string, setRecovery: bool) {\n            return this.updateSourceUnit(new StringSourceText(prog), filename, setRecovery);\n        }\n\n        public updateSourceUnit(sourceText: ISourceText, filename: string, setRecovery: bool): bool {\n            return this.timeFunction("updateSourceUnit(" + filename + ")", () => {\n                var updateResult = this.partialUpdateUnit(sourceText, filename, setRecovery);\n                return this.applyUpdateResult(updateResult);\n            });\n        }\n\n        // Apply changes to compiler state.\n        // Return "false" if the change is empty and nothing was updated.\n        public applyUpdateResult(updateResult: UpdateUnitResult): bool {\n            switch (updateResult.kind) {\n                case UpdateUnitKind.NoEdits:\n                    return false;\n\n                case UpdateUnitKind.Unknown:\n                    this.scripts.members[updateResult.unitIndex] = updateResult.script2;\n                    this.units[updateResult.unitIndex] = updateResult.script2.locationInfo;\n                    for (var i = 0, len = updateResult.parseErrors.length; i < len; i++) {\n                        var e = updateResult.parseErrors[i];\n                        if (this.parser.errorCallback) {\n                            this.parser.errorCallback(e.minChar, e.limChar - e.minChar, e.message, e.unitIndex);\n                        }\n                    }\n                    return true;\n\n                case UpdateUnitKind.EditsInsideSingleScope:\n                    new IncrementalParser(this.logger).mergeTrees(updateResult);\n                    return true;\n            }\n        }\n\n        public partialUpdateUnit(sourceText: ISourceText, filename: string, setRecovery:',
v27459=v27460+' bool): UpdateUnitResult {\n            return this.timeFunction("partialUpdateUnit(" + filename + ")", () => {\n                for (var i = 0, len = this.units.length; i < len; i++) {\n                    if (this.units[i].filename == filename) {\n                        if ((<Script>this.scripts.members[i]).isResident) {\n                            return UpdateUnitResult.noEdits(i);\n                        }\n\n                        if (setRecovery) {\n                            this.parser.setErrorRecovery(null);\n                        }\n\n                        var updateResult: UpdateUnitResult;\n\n                        // Capture parsing errors so that they are part of "updateResult"\n                        var parseErrors: ErrorEntry[] = [];\n                        var errorCapture = (minChar: number, charLen: number, message: string, unitIndex: number): void => {\n                            parseErrors.push(new ErrorEntry(unitIndex, minChar, minChar + charLen, message));\n                        };\n                        var svErrorCallback = this.parser.errorCallback;\n                        if (svErrorCallback)\n                            this.parser.errorCallback = errorCapture;\n\n                        var oldScript = <Script>this.scripts.members[i];\n                        var newScript = this.parser.parse(sourceText, filename, i);\n\n                        if (svErrorCallback)\n                            this.parser.errorCallback = svErrorCallback;\n\n                        updateResult = UpdateUnitResult.unknownEdits(oldScript, newScript, parseErrors);\n\n                        return updateResult;\n                    }\n                }\n                throw new Error("Unknown file \\"" + filename + "\\"");\n            });\n        }\n\n        public addUnit(prog: string, filename: string, keepResident? = false, referencedFiles?: IFileReference[] = []): Script {\n            return this.addSourceUnit(new StringSourceText(prog), filename, keepResident, referencedFiles);\n        }\n\n        public addSourceUnit(sourceText: ISourceText, filename: string, keepResident:bool, referencedFiles?: IFileReference[] = []): Script {\n            return this.timeFunction("addSourceUnit(" + filename + ", " + keepResident + ")", () => {\n                var script: Script = this.parser.parse(sourceText, filename, this.units.length, AllowedElements.Global);\n                script.referencedFiles = referencedFiles;\n                script.isResident = keepResident;\n                this.persistentTypeState.setCollectionMode(keepResident ? TypeCheckCollectionMode.Resident : TypeCheckCollectionMode.Transient);\n                var index = this.units.length;\n                this.units[index] = script.locationInfo;\n                this.typeChecker.collectTypes(script);\n                this.scripts.append(script);\n                return script\n            });\n        }\n\n        public parseUnit(prog: string, filename: string) {\n            return this.parseSourceUnit(new StringSourceText(prog), filename);\n        }\n\n        public parseSourceUnit(sourceText: ISourceText, filename: string) {\n            this.parser.setErrorRecovery(this.errorOutput);\n            var script: Script = this.parser.parse(sourceText, filename, 0);\n\n            var index = this.units.length;\n            this.units[index] = script.locationInfo;\n            this.typeChecker.collectTypes(script);\n            this.scripts.append(script);\n        }\n\n        public typeCheck() {\n            return this.timeFunction("typeCheck()", () => {\n                var binder = new Binder(this.typeChecker);\n                this.typeChecker.units = this.units;\n                binder.bind(this.typeChecker.globalScope, this.typeChecker.globals);\n                binder.bind(this.typeChecker.globalScope, this.typeChecker.ambientGlobals);\n                binder.bind(this.typeChecker.globalScope, this.typeChecker.globalTypes);\n                binder.bind(this.typeChecker.globalScope, this.typeChecker.ambientGlobalTypes);\n                this.typeFlow = new TypeFlow(this.logger, this.typeChecker.globalScope, this.parser, this.typeChecker);\n                var i = 0;\n                var script: Script = null;\n                var len = this.scripts.members.length;\n\n\n                this.persistentTypeState.setCollectionMode(TypeCheckCollectionMode.Resident);\n                // first, typecheck resident "lib" scripts, if necessary\n                for (i = 0; i < len; i++) {\n                    script = <Script>this.scripts.members[i];\n                    if (!script.isResident || script.hasBeenTypeChecked) { continue; }\n\n                    this.typeFlow.assignScopes(script);\n                    this.typeFlow.initLibs();\n                }\n                for (i = 0; i < len; i++) {\n                    script = <Script>this.scripts.members[i];\n                    if (!script.isResident || script.hasBeenTypeChecked) { continue; }\n\n                    this.typeFlow.typeCheck(script);',
v27458=v27459+'\n                    script.hasBeenTypeChecked = true;\n                }\n\n                // next typecheck scripts that may change\n                this.persistentTypeState.setCollectionMode(TypeCheckCollectionMode.Transient);\n                len = this.scripts.members.length;\n                for (i = 0; i < len; i++) {\n                    script = <Script>this.scripts.members[i];\n                    if (script.isResident) { continue; }\n                    this.typeFlow.assignScopes(script);\n                    this.typeFlow.initLibs();\n                }\n                for (i = 0; i < len; i++) {\n                    script = <Script>this.scripts.members[i];\n                    if (script.isResident) { continue; }\n                    this.typeFlow.typeCheck(script);\n                }\n\n                return null;\n            });\n        }\n\n        public cleanASTTypesForReTypeCheck(ast: AST) {\n            function cleanASTType(ast: AST, parent: AST): AST {\n                ast.type = null;\n                if (ast.nodeType == NodeType.VarDecl) {\n                    var vardecl = <VarDecl>ast;\n                    vardecl.sym = null;\n                }\n                else if (ast.nodeType == NodeType.ArgDecl) {\n                    var argdecl = <ArgDecl>ast;\n                    argdecl.sym = null;\n                }\n                else if (ast.nodeType == NodeType.Name) {\n                    var name = <Identifier>ast;\n                    name.sym = null;\n                }\n                else if (ast.nodeType == NodeType.FuncDecl) {\n                    var funcdecl = <FuncDecl>ast;\n                    funcdecl.signature = null;\n                    funcdecl.freeVariables = new Symbol[]\n                    funcdecl.symbols = null;\n                    funcdecl.accessorSymbol = null;\n                    funcdecl.scopeType = null;\n                }\n                else if (ast.nodeType == NodeType.ModuleDeclaration) {\n                    var modDecl = <ModuleDeclaration>ast;\n                    modDecl.mod = null;\n                }\n                else if (ast.nodeType == NodeType.With) {\n                    (<WithStatement>ast).withSym = null;\n                }\n                else if (ast.nodeType == NodeType.Catch) {\n                    (<Catch>ast).containedScope = null;\n                }\n                return ast;\n            }\n            TypeScript.getAstWalkerFactory().walk(ast, cleanASTType);\n        }\n\n        public cleanTypesForReTypeCheck() {\n            return this.timeFunction("cleanTypesForReTypeCheck()", () => {\n                for (var i = 0, len = this.scripts.members.length; i < len; i++) {\n                    var script = this.scripts.members[i];\n                    if ((<Script>script).isResident) {\n                        continue;\n                    }\n                    this.cleanASTTypesForReTypeCheck(script);\n                    this.typeChecker.collectTypes(script);\n                }\n\n                return null;\n            });\n        }\n\n        // Return "true" if the incremental typecheck was successful\n        // Return "false" if incremental typecheck failed, requiring a full typecheck\n        public attemptIncrementalTypeCheck(updateResult: TypeScript.UpdateUnitResult): bool {\n            return this.timeFunction("attemptIncrementalTypeCheck()", () => {\n                // updateResult.kind == editsInsideFunction\n                // updateResult.scope1 == old function\n                // updateResult.scope2 == new function\n                //REVIEW: What about typecheck errors? How do we replace the old ones with the new ones?\n                return false;\n            });\n        }\n\n        public reTypeCheck() {\n            return this.timeFunction("reTypeCheck()", () => {\n                CompilerDiagnostics.analysisPass++;\n                this.initTypeChecker(this.errorOutput);\n                this.persistentTypeState.setCollectionMode(TypeCheckCollectionMode.Transient);\n                this.cleanTypesForReTypeCheck();\n                return this.typeCheck();\n            });\n        }\n\n        private isDynamicModuleCompilation() {\n            for (var i = 0, len = this.scripts.members.length; i < len; i++) {\n                var script = <Script>this.scripts.members[i];\n                if (!script.isDeclareFile && script.topLevelMod != null) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private updateCommonDirectoryPath() {\n            var commonComponents: string[] = [];\n            var commonComponentsLength = -1;\n            for (var i = 0, len = this.scripts.members.length; i < len; i++) {\n                var script = <Script>this.scripts.members[i];\n                if (script.emitRequired(this.emitSettings)) {\n                    var fileName = script.locationInfo.filename;\n                    var fileComponents = filePathComponents(fileName);\n                    if (commonComponentsLength == -1) {\n            ',
v27457=v27458+'            // First time at finding common path\n                        // So common path = directory of file\n                        commonComponents = fileComponents;\n                        commonComponentsLength = commonComponents.length;\n                    } else {\n                        var updatedPath = false;\n                        for (var j = 0; j < commonComponentsLength && j < fileComponents.length; j++) {\n                            if (commonComponents[j] != fileComponents[j]) {\n                                // The new components = 0 ... j -1\n                                commonComponentsLength = j;\n                                updatedPath = true;\n\n                                if (j == 0) {\n                                    // Its error to not have common path\n                                    this.errorReporter.emitterError(null, "Cannot find the common subdirectory path for the input files");\n                                    return;\n                                }\n\n                                break;\n                            }\n                        }\n\n                        // If the fileComponent path completely matched and less than already found update the length\n                        if (!updatedPath && fileComponents.length < commonComponentsLength) {\n                            commonComponentsLength = fileComponents.length;\n                        }\n                    }\n                }\n            }\n\n            this.emitSettings.commonDirectoryPath = commonComponents.slice(0, commonComponentsLength).join("/") + "/";\n            if (this.emitSettings.outputOption.charAt(this.emitSettings.outputOption.length - 1) != "/") {\n                this.emitSettings.outputOption += "/";\n            }\n        }\n\n        public parseEmitOption(ioHost: EmitterIOHost) {\n            this.emitSettings.ioHost = ioHost;\n            if (this.emitSettings.outputOption == "") {\n                this.emitSettings.outputMany = true;\n                this.emitSettings.commonDirectoryPath = "";\n                return;\n            }\n\n            this.emitSettings.outputOption = switchToForwardSlashes(this.emitSettings.ioHost.resolvePath(this.emitSettings.outputOption));\n\n            // Determine if output options is directory or file\n            if (this.emitSettings.ioHost.directoryExists(this.emitSettings.outputOption)) {\n                // Existing directory\n                this.emitSettings.outputMany = true;\n            } else if (this.emitSettings.ioHost.fileExists(this.emitSettings.outputOption)) {\n                // Existing file\n                this.emitSettings.outputMany = false;\n            }\n            else {\n                // New File/directory\n                this.emitSettings.outputMany = !isJSFile(this.emitSettings.outputOption);\n            }\n\n            // Verify if options are correct\n            if (this.isDynamicModuleCompilation() && !this.emitSettings.outputMany) {\n                this.errorReporter.emitterError(null, "Cannot compile dynamic modules when emitting into single file");\n            }\n\n            // Parse the directory structure\n            if (this.emitSettings.outputMany) {\n                this.updateCommonDirectoryPath();\n            }\n        }\n\n        public useUTF8ForFile(script: Script) {\n            if (this.emitSettings.outputMany) {\n                return this.outputScriptToUTF8(script);\n            } else {\n                return this.outputScriptsToUTF8(<Script[]>(this.scripts.members));\n            }\n        }\n\n        static mapToDTSFileName(fileName: string, wholeFileNameReplaced: bool) {\n            return getDeclareFilePath(fileName);\n        }\n\n        private canEmitDeclarations(script?: Script) {\n            if (!this.settings.generateDeclarationFiles) {\n                return false;\n            }\n\n            // If its already a declare file or is resident or does not contain body \n            if (!!script && (script.isDeclareFile || script.isResident || script.bod == null)) {\n                return false;\n            }\n\n            return true;\n        }\n\n        public emitDeclarationsUnit(script: Script, reuseEmitter?: bool, declarationEmitter?: DeclarationEmitter) {\n            if (!this.canEmitDeclarations(script)) {\n                return null;\n            }\n\n            if (!declarationEmitter) {\n                var declareFileName = this.emitSettings.mapOutputFileName(script.locationInfo.filename, TypeScriptCompiler.mapToDTSFileName);\n                var declareFile = this.createFile(declareFileName, this.useUTF8ForFile(script));\n                declarationEmitter = new DeclarationEmitter(this.typeChecker, this.emitSettings, this.errorReporter);\n                declarationEmitter.setDeclarationFile(declareFile);\n            }\n\n            declarationEmitter.emitDeclarations(script);\n\n            if (!reuseEmitter) {\n                declarationEmitter.Close();\n                return null;\n            } else {',
v27456=v27457+'\n                return declarationEmitter;\n            }\n        }\n\n        public emitDeclarations() {\n            if (!this.canEmitDeclarations()) {\n                return;\n            }\n\n            if (this.errorReporter.hasErrors) {\n                // There were errors reported, do not generate declaration file\n                return;\n            }\n\n            if (this.scripts.members.length == 0) {\n                return;\n            }\n\n            var declarationEmitter: DeclarationEmitter = null;\n            for (var i = 0, len = this.scripts.members.length; i < len; i++) {\n                var script = <Script>this.scripts.members[i];\n                if (this.emitSettings.outputMany || declarationEmitter == null) {\n                    // Create or reuse file\n                    declarationEmitter = this.emitDeclarationsUnit(script, !this.emitSettings.outputMany);\n                } else {\n                    // Emit in existing emitter\n                    this.emitDeclarationsUnit(script, true, declarationEmitter);\n                }\n            }\n\n            if (declarationEmitter) {\n                declarationEmitter.Close();\n            }\n        }\n\n        static mapToFileNameExtension(extension: string, fileName: string, wholeFileNameReplaced: bool) {\n            if (wholeFileNameReplaced) {\n                // The complete output is redirected in this file so do not change extension\n                return fileName;\n            } else {\n                // Change the extension of the file\n                var splitFname = fileName.split(".");\n                splitFname.pop();\n                return splitFname.join(".") + extension;\n            }\n        }\n\n        static mapToJSFileName(fileName: string, wholeFileNameReplaced: bool) {\n            return TypeScriptCompiler.mapToFileNameExtension(".js", fileName, wholeFileNameReplaced);\n        }\n\n        public emitUnit(script: Script, reuseEmitter?: bool, emitter?: Emitter) {\n            if (!script.emitRequired(this.emitSettings)) {\n                return null;\n            }\n\n            var fname = script.locationInfo.filename;\n            if (!emitter) {\n                var outFname = this.emitSettings.mapOutputFileName(fname, TypeScriptCompiler.mapToJSFileName);\n                var outFile = this.createFile(outFname, this.useUTF8ForFile(script));\n                emitter = new Emitter(this.typeChecker, outFname, outFile, this.emitSettings, this.errorReporter);\n                if (this.settings.mapSourceFiles) {\n                    emitter.setSourceMappings(new TypeScript.SourceMapper(fname, outFname, outFile, this.createFile(outFname + SourceMapper.MapFileExtension, false), this.errorReporter));\n                }\n            } else if (this.settings.mapSourceFiles) {\n                emitter.setSourceMappings(new TypeScript.SourceMapper(fname, emitter.emittingFileName, emitter.outfile, emitter.sourceMapper.sourceMapOut, this.errorReporter));\n            }\n\n            this.typeChecker.locationInfo = script.locationInfo;\n            emitter.emitJavascript(script, TokenID.Comma, false);\n            if (!reuseEmitter) {\n                emitter.Close();\n                return null;\n            } else {\n                return emitter;\n            }\n        }\n\n        public emit(ioHost: EmitterIOHost) {\n            this.parseEmitOption(ioHost);\n\n            var emitter: Emitter = null;\n            for (var i = 0, len = this.scripts.members.length; i < len; i++) {\n                var script = <Script>this.scripts.members[i];\n                if (this.emitSettings.outputMany || emitter == null) {\n                    emitter = this.emitUnit(script, !this.emitSettings.outputMany);\n                } else {\n                    this.emitUnit(script, true, emitter);\n                }\n            }\n\n            if (emitter) {\n                emitter.Close();\n            }\n        }\n\n        public emitToOutfile(outputFile: ITextWriter) {\n            if (this.settings.mapSourceFiles) {\n                throw Error("Cannot generate source map");\n            }\n\n            if (this.settings.generateDeclarationFiles) {\n                throw Error("Cannot generate declaration files");\n            }\n\n            if (this.settings.outputOption != "") {\n                throw Error("Cannot parse output option");\n            }\n\n            var emitter: Emitter = emitter = new Emitter(this.typeChecker, "stdout", outputFile, this.emitSettings, this.errorReporter);;\n            for (var i = 0, len = this.scripts.members.length; i < len; i++) {\n                var script = <Script>this.scripts.members[i];\n                this.typeChecker.locationInfo = script.locationInfo;\n                emitter.emitJavascript(script, TokenID.Comma, false);\n            }\n        }\n\n        public emitAST(ioHost: EmitterIOHost) {\n            this.parseEmitOption(ioHost);\n\n            var outFile: ITextWriter = null;\n            var context: PrintContext = null;\n\n            for (var i = 0, ',
v27455=v27456+'len = this.scripts.members.length; i < len; i++) {\n                var script = <Script>this.scripts.members[i];\n                if (this.emitSettings.outputMany || context == null) {\n                    var fname = this.units[i].filename;\n                    var mapToTxtFileName = (fileName: string, wholeFileNameReplaced: bool) => {\n                        return TypeScriptCompiler.mapToFileNameExtension(".txt", fileName, wholeFileNameReplaced);\n                    };\n                    var outFname = this.emitSettings.mapOutputFileName(fname, mapToTxtFileName);\n                    outFile = this.createFile(outFname, this.useUTF8ForFile(script));\n                    context = new PrintContext(outFile, this.parser);\n                }\n                getAstWalkerFactory().walk(script, prePrintAST, postPrintAST, null, context);\n                if (this.emitSettings.outputMany) {\n                    try {\n                        outFile.Close();\n                    } catch (e) {\n                        this.errorReporter.emitterError(null, e.message);\n                    }\n                }\n            }\n\n            if (!this.emitSettings.outputMany) {\n                try {\n                    outFile.Close();\n                } catch (e) {\n                    this.errorReporter.emitterError(null, e.message);\n                }\n            }\n        }\n\n        private outputScriptToUTF8(script: Script): bool {\n            return script.containsUnicodeChar || (this.emitSettings.emitComments && script.containsUnicodeCharInComment);\n        }\n\n        private outputScriptsToUTF8(scripts: Script[]): bool {\n            for (var i = 0, len = scripts.length; i < len; i++) {\n                var script = scripts[i];\n                if (this.outputScriptToUTF8(script)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private createFile(fileName: string, useUTF8: bool): ITextWriter {\n            try {\n                // Creating files can cause exceptions, report them.   \n                return this.emitSettings.ioHost.createFile(fileName, useUTF8);\n            } catch (ex) {\n                this.errorReporter.emitterError(null, ex.message);\n            }\n        }\n    }\n\n    export class ScopeEntry {\n        constructor (\n            public name: string,\n            public type: string,\n            public sym: Symbol) {\n        }\n    }\n\n    export class ScopeTraversal {\n        constructor (private compiler: TypeScriptCompiler) {\n        }\n\n        public getScope(enclosingScopeContext: EnclosingScopeContext): SymbolScope {\n            if (enclosingScopeContext.enclosingObjectLit && enclosingScopeContext.isMemberCompletion) {\n                return enclosingScopeContext.getObjectLiteralScope();\n            }\n            else if (enclosingScopeContext.isMemberCompletion) {\n                if (enclosingScopeContext.useFullAst) {\n                    return this.compiler.typeFlow.findMemberScopeAtFullAst(enclosingScopeContext)\n                }\n                else {\n                    return this.compiler.typeFlow.findMemberScopeAt(enclosingScopeContext)\n                }\n            }\n            else {\n                return enclosingScopeContext.getScope();\n            }\n        }\n\n        public getScopeEntries(enclosingScopeContext: EnclosingScopeContext): ScopeEntry[] {\n            var scope = this.getScope(enclosingScopeContext);\n            if (scope == null) {\n                return [];\n            }\n\n            var inScopeNames: IHashTable = new StringHashTable();\n            var allSymbolNames: string[] = scope.getAllSymbolNames(enclosingScopeContext.isMemberCompletion);\n\n            // there may be duplicates between the type and value tables, so batch the symbols\n            // getTypeNamesForNames will prefer the entry in the value table\n            for (var i = 0; i < allSymbolNames.length; i++) {\n                var name = allSymbolNames[i];\n\n                // Skip global/internal symbols that won\'t compile in user code\n                if (name == globalId || name == "_Core" || name == "_element") {\n                    continue;\n                }\n\n                inScopeNames.add(name, "");\n            }\n\n            var svModuleDecl = this.compiler.typeChecker.currentModDecl;\n            this.compiler.typeChecker.currentModDecl = enclosingScopeContext.deepestModuleDecl;\n\n            var result = this.getTypeNamesForNames(enclosingScopeContext, inScopeNames.getAllKeys(), scope);\n\n            this.compiler.typeChecker.currentModDecl = svModuleDecl;\n            return result;\n        }\n\n        private getTypeNamesForNames(enclosingScopeContext: EnclosingScopeContext, allNames: string[], scope: SymbolScope): ScopeEntry[] {\n            var result: ScopeEntry[] = [];\n\n            var enclosingScope = enclosingScopeContext.getScope();\n            for (var i = 0; i < allNames.length; i++) {\n                var name = allNames[i];\n                //',
v27454=v27455+' Search for the id in the value space first\n                // if we don\'t find it, search in the type space.\n                // We don\'t want to search twice, because the first\n                // search may insert the name in the symbol value table\n                // if the scope is aggregate\n                var publicsOnly = enclosingScopeContext.publicsOnly && enclosingScopeContext.isMemberCompletion;\n                var symbol = scope.find(name, publicsOnly, false/*typespace*/);  // REVIEW: Should search public members only?\n                if (symbol == null) {\n                    symbol = scope.find(name, publicsOnly, true/*typespace*/);\n                }\n\n                var displayThisMember = symbol && symbol.flags & SymbolFlags.Private ? symbol.container == scope.container : true;\n\n                if (symbol) {\n                    // Do not add dynamic module names to the list, since they\'re not legal as identifiers\n                    if (displayThisMember && !isQuoted(symbol.name) && !isRelative(symbol.name)) {\n                        var typeName = symbol.getType().getScopedTypeName(enclosingScope);\n                        result.push(new ScopeEntry(name, typeName, symbol));\n                    }\n                }\n                else {\n                    // Special case for "true" and "false"\n                    // REVIEW: This may no longer be necessary?\n                    if (name == "true" || name == "false") {\n                        result.push(new ScopeEntry(name, "bool", this.compiler.typeChecker.booleanType.symbol));\n                    }\n                }\n            }\n\n            return result;\n        }\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export enum Primitive {\n        None = 0,\n        Void = 1,\n        Double = 2,\n        String = 4,\n        Boolean = 8,\n        Any = 16,\n        Null = 32,\n        Undefined = 64,\n    }\n\n    export class MemberName {\n        public prefix: string = "";\n        public suffix: string = "";\n\n        public isString() { return false; }\n        public isArray() { return false; }\n\n        public toString(): string {\n            return MemberName.memberNameToString(this);\n        }\n\n        static memberNameToString(memberName: MemberName): string {\n            var result = memberName.prefix;\n\n            if (memberName.isString()) {\n                result += (<MemberNameString>memberName).text;\n            }\n            else {\n                var ar = <MemberNameArray>memberName;\n                for (var index = 0; index < ar.entries.length; index++) {\n                    result += memberNameToString(ar.entries[index]);\n                    result += ar.delim;\n                }\n            }\n\n            result += memberName.suffix;\n            return result;\n        }\n\n        static create(text: string): MemberName;\n        static create(entry: MemberName, prefix: string, suffix: string): MemberName;\n        static create(arg1: any, arg2?: any, arg3?: any): MemberName {\n            if (typeof arg1 == "string") {\n                return new MemberNameString(arg1);\n            }\n            else {\n                var result = new MemberNameArray();\n                if (arg2)\n                    result.prefix = arg2;\n                if (arg3)\n                    result.suffix = arg3;\n                result.entries.push(arg1);\n                return result;\n            }\n        }\n    }\n\n    export class MemberNameString extends MemberName {\n        constructor (public text: string) {\n            super()\n        }\n\n        public isString() { return true; }\n    }\n\n    export class MemberNameArray extends MemberName {\n        public delim: string = "";\n        public entries: MemberName[] = [];\n\n        public isArray() { return true; }\n\n        public add(entry: MemberName) {\n            this.entries.push(entry);\n        }\n\n        public addAll(entries: MemberName[]) {\n            for (var i = 0 ; i < entries.length; i++) {\n                this.entries.push(entries[i]);\n            }\n        }\n    }\n\n    var currentTypeID = -1;\n\n    export class Type {\n        public typeID = currentTypeID++;\n\n        public members: ScopedMembers;\n        public ambientMembers: ScopedMembers;\n\n        public construct: SignatureGroup = null;\n        public call: SignatureGroup = null;\n        public index: SignatureGroup =',
v27453=v27454+' null;\n\n        // REVIEW: for either of the below, why do we have lists of types and lists of type links?\n        // interface can only extend\n        public extendsList: Type[];\n        public extendsTypeLinks: TypeLink[];\n\n        // class can also implement\n        public implementsList: Type[];\n        public implementsTypeLinks: TypeLink[];\n\n        public passTypeCreated: number = CompilerDiagnostics.analysisPass;\n\n        public baseClass(): Type {\n            if (this.extendsList && (this.extendsList.length > 0)) {\n                return this.extendsList[0];\n            }\n            else {\n                return null;\n            }\n        }\n\n        public elementType: Type;\n\n        public getArrayBase(arrInstType: Type, checker: TypeChecker): Type {\n            return this.arrayCache.specialize(arrInstType, checker);\n        }\n\n        public primitiveTypeClass: number = Primitive.None;\n\n        // REVIEW: Prune constructorScope\n        public constructorScope: SymbolScope;\n        public containedScope: SymbolScope;\n        public memberScope: SymbolScope;\n\n        public arrayCache: ArrayCache;\n\n        public typeFlags = TypeFlags.None;\n\n        public symbol: TypeSymbol;\n\n        public enclosingType: Type;\n        public instanceType: Type;\n\n        // REVIEW: Prune\n        public isClass() { return this.instanceType != null; }\n        public isArray() { return this.elementType != null; }\n        public isClassInstance() {\n            return this.symbol && !this.elementType && (<TypeSymbol>this.symbol).type.isClass();\n        }\n\n        public getInstanceType() {\n            if (this.isClass()) {\n                return this.instanceType;\n            }\n            else {\n                return this;\n            }\n        }\n\n        public hasImplementation() { return hasFlag(this.typeFlags, TypeFlags.HasImplementation); }\n        public setHasImplementation() { this.typeFlags |= TypeFlags.HasImplementation; }\n\n        public isDouble() { return hasFlag(this.primitiveTypeClass, Primitive.Double); }\n        public isString() { return hasFlag(this.primitiveTypeClass, Primitive.String); }\n        public isBoolean() { return hasFlag(this.primitiveTypeClass, Primitive.Boolean); }\n        public isNull() { return hasFlag(this.primitiveTypeClass, Primitive.Null); }\n\n        // REVIEW: No need for this to be a method\n        public getTypeName(): string {\n            return this.getMemberTypeName("", true, false, null);\n        }\n\n        public getScopedTypeName(scope: SymbolScope) {\n            return this.getMemberTypeName("", true, false, scope);\n        }\n\n        public getScopedTypeNameEx(scope: SymbolScope) {\n            return this.getMemberTypeNameEx("", true, false, scope);\n        }\n\n        // REVIEW: No need for this to be a method\n        public callCount() {\n            var total = 0;\n            if (this.call) {\n                total += this.call.signatures.length;\n            }\n            if (this.construct) {\n                total += this.construct.signatures.length;\n            }\n            if (this.index) {\n                total += this.index.signatures.length;\n            }\n            return total;\n        }\n\n        // REVIEW: No need for this to be a method\n        public getMemberTypeName(prefix: string, topLevel: bool, isElementType: bool, scope: SymbolScope): string {\n            var memberName = this.getMemberTypeNameEx(prefix, topLevel, isElementType, scope);\n            return memberName.toString();\n        }\n\n        // REVIEW: No need for this to be a method\n        public getMemberTypeNameEx(prefix: string, topLevel: bool, isElementType: bool, scope: SymbolScope): MemberName {\n            if (this.elementType) {\n                return MemberName.create(this.elementType.getMemberTypeNameEx(prefix, false, true, scope), "", "[]");\n            }\n            else if (this.symbol && this.symbol.name && this.symbol.name != "_anonymous" &&\n                     (((this.call == null) && (this.construct == null) && (this.index == null)) ||\n                      (hasFlag(this.typeFlags, TypeFlags.BuildingName)) ||\n                      (this.members && (!this.isClass())))) {\n                var tn = this.symbol.scopeRelativeName(scope);\n                return MemberName.create(tn == "null" ? "any" : tn); // REVIEW: GROSS!!!\n            }\n            else {\n                if (this.members || this.call || this.construct) {\n                    if (hasFlag(this.typeFlags, TypeFlags.BuildingName)) {\n                        return MemberName.create("this");\n                    }\n                    this.typeFlags |= TypeFlags.BuildingName;\n                    var builder = "";\n                    var allMemberNames = new MemberNameArray();\n                    var curlies = isElementType || this.index != null;\n                    var memCount = 0;\n                    var delim = "; ";\n                    if (this.members) {\n                        this.members.allMembers.map((key, ',
v27452=v27453+'s, unused) => {\n                            var sym = <Symbol>s;\n                            if (!hasFlag(sym.flags, SymbolFlags.BuiltIn)) {\n                                // Remove the delimiter character from the generated type name, since\n                                // our "allMemberNames" array takes care of storing delimiters\n                                var typeNameMember = sym.getTypeNameEx(scope);\n                                if (typeNameMember.isArray() && (<MemberNameArray>typeNameMember).delim == delim) {\n                                    allMemberNames.addAll((<MemberNameArray>typeNameMember).entries);\n                                } else {\n                                    allMemberNames.add(typeNameMember);\n                                }\n                                memCount++;\n                                curlies = true;\n                            }\n                        }, null);\n                    }\n\n                    var signatureCount = this.callCount();\n                    var j: number;\n                    var len = 0;\n                    var shortform = !curlies && signatureCount == 1 && topLevel;\n                    if (this.call) {\n                        allMemberNames.addAll(this.call.toStrings(prefix, shortform, scope));\n                    }\n\n                    if (this.construct) {\n                        allMemberNames.addAll(this.construct.toStrings("new", shortform, scope));\n                    }\n\n                    if (this.index) {\n                        allMemberNames.addAll(this.index.toStrings("", shortform, scope));\n                    }\n\n                    if ((curlies) || ((signatureCount > 1) && topLevel)) {\n                        allMemberNames.prefix = "{ ";\n                        allMemberNames.suffix = "}";\n                        allMemberNames.delim = delim;\n                    } else if (allMemberNames.entries.length > 1) {\n                        allMemberNames.delim = delim;\n                    }\n\n                    this.typeFlags &= (~TypeFlags.BuildingName);\n                    if ((signatureCount == 0) && (memCount == 0)) {\n                        return MemberName.create("{}");\n                    }\n                    else {\n                        return allMemberNames;\n                    }\n                }\n                else {\n                    return MemberName.create("{}");\n                }\n            }\n        }\n\n        public checkDecl(checker: TypeChecker) {\n            if (this.isClassInstance() || this.isClass()) {\n                if (this.symbol.declAST) {\n                    checker.typeFlow.inScopeTypeCheckDecl(this.symbol.declAST);\n                }\n            }\n        }\n\n        public getMemberScope(flow: TypeFlow) {\n            if (this == flow.anyType) {\n                return null;\n            }\n            else if (this.isDouble()) {\n                if (flow.numberInterfaceType) {\n                    return flow.numberInterfaceType.memberScope;\n                }\n                else {\n                    return null;\n                }\n            }\n            else if (this.isBoolean()) {\n                if (flow.booleanInterfaceType) {\n                    return flow.booleanInterfaceType.memberScope;\n                }\n                else {\n                    return null;\n                }\n            }\n            else if (this == flow.stringType) {\n                if (flow.stringInterfaceType) {\n                    return flow.stringInterfaceType.memberScope;\n                }\n                else {\n                    return null;\n                }\n            }\n            else if (this.elementType) {\n                if (flow.arrayInterfaceType) {\n                    var arrInstType = this.elementType.getArrayBase(flow.arrayInterfaceType, flow.checker);\n                    return arrInstType.memberScope;\n                }\n                else {\n                    return null;\n                }\n            }\n            else {\n                return this.memberScope;\n            }\n        }\n\n        public isReferenceType() {\n            return this.members || this.extendsList ||\n                this.construct || this.call || this.index ||\n                this.elementType;\n        }\n\n        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker, membersOnly: bool): Type {\n            if (pattern == this) {\n                return replacement;\n            }\n            var result = this;\n            if (membersOnly) {\n                // assume interface type without bases\n                if (this.isReferenceType()) {\n                    result = new Type();\n                    if (this.members) {\n                        result.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n\n                        this.members.publicMembers.map((key, s, unused) => {\n                            var sym = <Symbol>s;\n         ',
v27451=v27452+"                   var bSym = sym.specializeType(pattern, replacement, checker);\n                            result.members.addPublicMember(bSym.name, bSym);\n                        }, null);\n\n                        this.members.privateMembers.map((key, s, unused) => {\n                            var sym = <Symbol>s;\n                            var bSym = sym.specializeType(pattern, replacement, checker);\n                            result.members.addPrivateMember(bSym.name, bSym);\n                        }, null);\n                    }\n                    if (this.ambientMembers) {\n                        result.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                        this.ambientMembers.publicMembers.map((key, s, unused) => {\n                            var sym = <Symbol>s;\n                            var bSym = sym.specializeType(pattern, replacement, checker);\n                            result.ambientMembers.addPublicMember(bSym.name, bSym);\n                        }, null);\n\n                        this.ambientMembers.privateMembers.map((key, s, unused) => {\n                            var sym = <Symbol>s;\n                            var bSym = sym.specializeType(pattern, replacement, checker);\n                            result.ambientMembers.addPrivateMember(bSym.name, bSym);\n                        }, null);\n                    }\n                    result.containedScope = checker.scopeOf(result);\n                    result.memberScope = result.containedScope;\n                }\n            }\n            else {\n                if (this.elementType) {\n                    if (this.elementType == pattern) {\n                        result = checker.makeArrayType(replacement);\n                    }\n                    else {\n                        if (this.elementType.elementType == pattern) {\n                            result = checker.makeArrayType(checker.makeArrayType(replacement));\n                        }\n                    }\n                }\n                else if (this.call) {\n                    result = new Type();\n                    result.call = this.call.specializeType(pattern, replacement, checker);\n                }\n            }\n            return result;\n        }\n\n        public hasBase(baseType: Type): bool {\n            if (baseType == this) {\n                return true;\n            }\n            else {\n                if (this.extendsList) {\n                    for (var i = 0, len = this.extendsList.length; i < len; i++) {\n                        if (this.extendsList[i].hasBase(baseType)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n\n        public mergeOrdered(b: Type, checker: TypeChecker, acceptVoid: bool, comparisonInfo?: TypeComparisonInfo): Type {\n            if ((this == checker.anyType) || (b == checker.anyType)) {\n                return checker.anyType;\n            }\n            else if (this == b) {\n                return this;\n            }\n            else if ((b == checker.nullType) && this != checker.nullType) {\n                return this;\n            }\n            else if ((this == checker.nullType) && (b != checker.nullType)) {\n                return b;\n            }\n            else if (acceptVoid && (b == checker.voidType) && this != checker.voidType) {\n                return this;\n            }\n            else if (acceptVoid && (this == checker.voidType) && (b != checker.voidType)) {\n                return b;\n            }\n            else if ((b == checker.undefinedType) && this != checker.undefinedType) {\n                return this;\n            }\n            else if ((this == checker.undefinedType) && (b != checker.undefinedType)) {\n                return b;\n            }\n            else if (this.elementType && b.elementType) {\n                if (this.elementType == b.elementType) {\n                    return this;\n                }\n                else {\n                    var mergedET = this.elementType.mergeOrdered(b.elementType, checker, acceptVoid, comparisonInfo);\n                    if (mergedET == null) {\n                        return checker.makeArrayType(checker.anyType);\n                    }\n                    else {\n                        return checker.makeArrayType(mergedET);\n                    }\n                }\n            }\n            else if (checker.sourceIsSubtypeOfTarget(this, b, comparisonInfo)) {\n                return b;\n            }\n            else if (checker.sourceIsSubtypeOfTarget(b, this, comparisonInfo)) {\n                return this;\n            }\n            else {\n                return null;\n            }\n        }\n\n        public isModuleType() { return false; }\n        public hasMembers() { return this.members != null; }\n        public getAllEnclosedTypes(): ScopedMembers { return null; }\n        public getAllAmbientEnc",
v27450=v27451+'losedTypes(): ScopedMembers { return null; }\n        public getPublicEnclosedTypes(): ScopedMembers { return null; }\n        public getpublicAmbientEnclosedTypes(): ScopedMembers { return null; }\n\n        public getDocComments(): Comment[]{\n            if (this.elementType || !this.symbol) {\n                return [];\n            }\n\n            if (this.isClassInstance() || this.isClass()) {\n                if (this.symbol.declAST.nodeType == NodeType.FuncDecl) {\n                    // Its a constructor - use the class declaration instead\n                    return (<FuncDecl>this.symbol.declAST).classDecl.getDocComments();\n                } else {\n                    // Its a class without constructor\n                    return this.symbol.getDocComments();\n                }\n            }\n\n            if (this.symbol.name && this.symbol.name != "_anonymous" &&\n                (((this.call == null) && (this.construct == null) && (this.index == null))\n                  || this.members)) {\n                return this.symbol.getDocComments();\n            }\n\n            return [];\n        }\n    }\n\n    export interface ITypeCollection {\n        // returns null when types are exhausted\n        getLength(): number;\n        setTypeAtIndex(index: number, type: Type): void;\n        getTypeAtIndex(index: number): Type;\n    }\n\n    export class ModuleType extends Type {\n\n        constructor (public enclosedTypes: ScopedMembers, public ambientEnclosedTypes: ScopedMembers) {\n            super();\n        }\n\n        public isModuleType() { return true; }\n        public hasMembers() { return this.members != null || this.enclosedTypes != null; }\n        public getAllEnclosedTypes() { return this.enclosedTypes; }\n        public getAllAmbientEnclosedTypes() { return this.ambientEnclosedTypes; }\n        public getPublicEnclosedTypes(): ScopedMembers { return null; }\n        public getpublicAmbientEnclosedTypes(): ScopedMembers { return null; }\n        public importedModules: ImportDeclaration[] = [];\n\n        // Finds the dynamic module name of moduleType in the members\n        // ignoreSymbols define list of symbols already visited - to avoid recursion\n        static findDynamicModuleNameInHashTable(moduleType: Type, members: IHashTable) {\n            var moduleName: { name: string; symbol: Symbol; } = null;\n            members.map((key, s, c) => {\n                if (moduleName == null && !isQuoted(key)) {\n                    var symbol = <Symbol>s;\n                    var type = symbol.getType();\n                    if (type == moduleType) {\n                        // If this is the module type we were looking for\n                        moduleName = { name: key, symbol: symbol };\n                    }\n                }\n            }, null);\n\n            return moduleName;\n        }\n\n        // Finds the Dynamic module name of the moduleType in this moduleType\n        // onlyPublic tells if we are looking for module name in public members only\n        public findDynamicModuleName(moduleType: Type): { name: string; symbol: Symbol; } {\n            var moduleName: { name: string; symbol: Symbol; } = null;\n            // Not cached, so seach and add to the cache\n            moduleName = ModuleType.findDynamicModuleNameInHashTable(moduleType, this.members.allMembers);\n            if (moduleName == null) {\n                moduleName = ModuleType.findDynamicModuleNameInHashTable(moduleType, this.ambientMembers.allMembers);\n            }\n            return moduleName;\n        }\n    }\n\n    export class TypeLink {\n        public type: Type = null;\n        public ast: AST = null;\n    }\n\n    export function getTypeLink(ast: AST, checker: TypeChecker, autoVar: bool): TypeLink {\n        var result = new TypeLink();\n\n        result.ast = ast;\n\n        if ((ast == null) && (autoVar)) {\n            result.type = checker.anyType;\n        }\n        else {\n            result.type = null;\n        }\n\n        return result;\n    }\n\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule Tools {\n    export interface IWalkContext {\n        goChildren: bool;\n        goNextSibling: bool;\n        // visit siblings in reverse execution order\n        reverseSiblings: bool;\n    }\n\n    export class BaseWalkContext implements IWalkContext {\n        public goChildren = true;\n        public goNextSibling = true;\n        public reverseSiblings = false;\n    }\n}',
compiler_input=v27450,TypeScript,v18791=TypeScript;v18791||(v18791=TypeScript={});v48();var v18792=TypeScript;v18792||(v18792=TypeScript={});v49();var v18793=TypeScript;v18793||(v18793=TypeScript={});v78();var v12343=this.__extends;v12343||(v12343=v79);var __extends=v12343,v18795=TypeScript;v18795||(v18795=TypeScript={});v322();var v18796=TypeScript;v18796||(v18796=TypeScript={});v333();var v18797=TypeScript;v18797||(v18797=TypeScript={});v335();var v18798=TypeScript;v18798||(v18798=TypeScript={});
v399();var v18799=TypeScript;v18799||(v18799=TypeScript={});v407();var v18800=TypeScript;v18800||(v18800=TypeScript={});v417();var v18801=TypeScript;v18801||(v18801=TypeScript={});v420();var JSON2={};v427();var v18802=TypeScript;v18802||(v18802=TypeScript={});v433();var v18803=TypeScript;v18803||(v18803=TypeScript={});v492();var v18804=TypeScript;v18804||(v18804=TypeScript={});v519();var v18805=TypeScript;v18805||(v18805=TypeScript={});v592();var v18806=TypeScript;v18806||(v18806=TypeScript={});v599();
var v18807=TypeScript;v18807||(v18807=TypeScript={});v675();var v18808=TypeScript;v18808||(v18808=TypeScript={});v680();var v18809=TypeScript;v18809||(v18809=TypeScript={});v698();var v18810=TypeScript;v18810||(v18810=TypeScript={});v711();var v18811=TypeScript;v18811||(v18811=TypeScript={});v794();var v18812=TypeScript;v18812||(v18812=TypeScript={});v862();var v18813=TypeScript;v18813||(v18813=TypeScript={});v892();var v18814=TypeScript;v18814||(v18814=TypeScript={});v964();var v18815=TypeScript;
v18815||(v18815=TypeScript={});v967();var v18816=TypeScript;v18816||(v18816=TypeScript={});v1113();var v18817=TypeScript;v18817||(v18817=TypeScript={});v1172();var v18818=TypeScript;v18818||(v18818=TypeScript={});v1173();var v18819=TypeScript;v18819||(v18819=TypeScript={});v1180();var v18820=TypeScript;v18820||(v18820=TypeScript={});v1186();var v18821=TypeScript;v18821||(v18821=TypeScript={});v1195();var v18822=TypeScript;v18822||(v18822=TypeScript={});v1233();var v18823=TypeScript;
v18823||(v18823=TypeScript={});v1288();var v18824=TypeScript;v18824||(v18824=TypeScript={});v1311();var IOUtils,v18825=IOUtils;v18825||(v18825=IOUtils={});v1312();var IO=v1357(),OptionsParser=v1365(),CommandLineHost=v1370(),BatchCompiler=v1409(),completed=0,benchmarks=BenchmarkSuite.CountBenchmarks(),success=!0,latencyBenchmarks=["Splay","Mandreel"],v12375,skipBenchmarks=v12375="undefined"===typeof skipBenchmarks?[]:skipBenchmarks;
