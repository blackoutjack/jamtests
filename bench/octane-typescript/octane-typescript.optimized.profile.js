
JAM.startProfile('load');
function v1409(){function v1408(soruceFiles){function v1407(sf){var v1410=sf.path;JAMScript.call(resolvedFiles.push,resolvedFiles,[v1410]);sf=sf.path;addWatcher(sf)}function onWatchedFileChange(){function v1406(f){var v1412=_this.ioHost;f="    "+f;return JAMScript.call(v1412.printLine,v1412,[f])}function v1405(sf){sf=sf.path;return JAMScript.call(newFiles.push,newFiles,[sf])}var v1415=_this.compilationEnvironment;v1415.code=soruceFiles;var v1415=_this,v12376;v12376=_this.compilationSettings;v12376=
(v12376=v12376.resolve)?JAMScript.call(_this.resolve,_this,[]):_this.compilationEnvironment;v1415.resolvedEnvironment=v12376;var v1415=resolvedFiles,newFiles=[];v12376=_this.resolvedEnvironment;v12376=v12376.code;v12376.forEach(v1405);var newFiles=newFiles.sort(),i=0;v12376=0;var v18828=v1415.length;if(v18828=i<v18828)v18828=newFiles.length,v18828=v12376<v18828;for(;v18828;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v18828=v1415[i];introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v1419=
newFiles[v12376];v18828=v18828.localeCompare(v1419);if(v1419=0==v18828)i+=1,v12376+=1;else if(v18828=0>v18828){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v18828=v1415[i];removeWatcher(v18828);i+=1}else{introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v18828=newFiles[v12376];addWatcher(v18828);v12376+=1}v18828=v1415.length;if(v18828=i<v18828)v18828=newFiles.length,v18828=v12376<v18828}v18828=v1415.length;for(v18828=i<v18828;v18828;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v18828=
v1415[i];removeWatcher(v18828);i+=1;v18828=v1415.length;v18828=i<v18828}i=v12376;v1415=newFiles.length;for(v1415=i<v1415;v1415;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v1415=newFiles[i];addWatcher(v1415);i+=1;v1415=newFiles.length;v1415=i<v1415}resolvedFiles=newFiles;v1415=_this.ioHost;JAMScript.call(v1415.printLine,v1415,[""]);v1415=_this.ioHost;v12376=new Date;v12376="Recompiling ("+v12376;v12376+="): ";JAMScript.call(v1415.printLine,v1415,[v12376]);resolvedFiles.forEach(v1406);
v1415=JAMScript.call(_this.compile,_this,[]);if(v12376=!v1415)v1415=_this.hasResolveErrors;if(v1415=!v1415)v1415=_this.compilationSettings,(v1415=v1415.exec)&&JAMScript.call(_this.run,_this,[])}function removeWatcher(filename){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v1436=watchers[filename];if(v1436){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v1436=watchers[filename];JAMScript.call(v1436.close,v1436,[]);delete watchers[filename]}else throw Error("Cannot stop watching file, it is not being watched.");
}function addWatcher(filename){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v12387=watchers[filename];if(v12387=!v12387)v12387=_this.ioHost,v12387=JAMScript.call(v12387.watchFile,v12387,[filename,onWatchedFileChange]),JAMScript.set(watchers,filename,v12387);else throw Error("Cannot watch file, it is already watched.");}var _this=this,v18833=this.ioHost,v18833=v18833.watchFile;if(v18833=!v18833)v18833=this.ioHost,JAMScript.call(v18833.printLine,v18833,["Error: Current host does not support -w[atch] option"]);
else{var resolvedFiles=[],watchers={},v12389=v18833=this.ioHost;v18833.stderr=v12389.stdout;v18833=this.resolvedEnvironment;v18833=v18833.code;v18833.forEach(v1407);resolvedFiles.sort()}}function v1404(){var v12391=this.printedVersion;if(v12391=!v12391){var v12391=this.ioHost,v12392=this.compilerVersion,v12392="Version "+v12392;JAMScript.call(v12391.printLine,v12391,[v12392]);this.printedVersion=!0}}function v1403(){function v1402(){JAMScript.call(_this.printVersion,_this,[])}function v1401(){var v1446=
_this.compilationSettings;v1446.useCaseSensitiveFileResolution=!0}function v1400(){JAMScript.call(_this.printVersion,_this,[]);JAMScript.call(opts.printUsage,opts,[]);printedUsage=!0}function v1399(type){type=type.toLowerCase();var v12393="commonjs"===type,v18834=!v12393;v18834&&(v12393="node"===type);v12393?(type=TypeScript.ModuleGenTarget,TypeScript.moduleGenTarget=type.Synchronous):(v12393="amd"===type)?(type=TypeScript.ModuleGenTarget,TypeScript.moduleGenTarget=type.Asynchronous):(v12393=_this.ioHost,
type="Module code generation '"+type,type+="' not supported.  Using default 'commonjs' code generation",JAMScript.call(v12393.printLine,v12393,[type]))}function v1398(type){type=type.toLowerCase();var v1458="es3"===type;v1458?(type=_this.compilationSettings,v1458=TypeScript.CodeGenTarget,type.codeGenTarget=v1458.ES3):(v1458="es5"===type)?(type=_this.compilationSettings,v1458=TypeScript.CodeGenTarget,type.codeGenTarget=v1458.ES5):(v1458=_this.ioHost,type="ECMAScript target version '"+type,type+="' not supported.  Using default 'ES3' code generation",
JAMScript.call(v1458.printLine,v1458,[type]))}function v1397(){var v1459=_this.compilationSettings;v1459.inferPropertiesFromThisAssignment=!0}function v1396(){var v1460=_this.compilationSettings;v1460.useDefaultLib=!1}function v1395(){TypeScript.optimizeModuleCodeGen=!1}function v1394(){var v1461=_this.compilationSettings;v1461.canCallDefinitionSignature=!0}function v1393(){var v1462=TypeScript.CompilerDiagnostics;v1462.debug=!0}function v1392(){var v1463=_this.compilationSettings;v1463.resolve=!1;
v1463=_this.compilationSettings;v1463.preprocess=!1}function v1391(){var v1465=_this.compilationSettings;v1465.errorOnWith=!1}function v1390(){var v1466=_this.compilationSettings;v1466.controlFlow=!0;v1466=_this.compilationSettings;v1466.controlFlowUseDef=!0}function v1389(){var v1468=_this.compilationSettings;v1468.controlFlow=!0;v1468=_this.compilationSettings;v1468.printControlFlow=!0}function v1388(){var v1470=_this.compilationSettings;v1470.controlFlow=!0}function v1387(){var v1471=_this.compilationSettings;
v1471.emitComments=!0}function v1386(){var v1472=_this.compilationSettings;v1472.errorRecovery=!0}function v1385(){var v1473=_this.compilationSettings;v1473.propagateConstants=!0}function v1384(){var v1474=_this.compilationSettings;v1474.minWhitespace=!0}function v1383(){var v1475=_this.compilationSettings;v1475.parseOnly=!0}function v1382(){var v1476=_this.compilationSettings;v1476.exec=!0}function v1381(){var v1477=_this.compilationSettings;v1477.watch=!0}function v1380(){var v1478=_this.compilationSettings;
v1478.generateDeclarationFiles=!0}function v1379(){var v1479=_this.compilationSettings;v1479.mapSourceFiles=!0}function v1378(str){var v1480=_this.compilationSettings;JAMScript.call(v1480.setStyleOptions,v1480,[str])}function v1377(str){var v1481=_this.compilationSettings;v1481.outputOption=str}function v1376(s){var v1482=_this.ioHost;JAMScript.call(v1482.printLine,v1482,[s])}var _this=this,v1483=TypeScript.CompilerDiagnostics;v1483.diagnosticWriter={Alert:v1376};var code,v1484=this.ioHost,opts=JAMScript.new(OptionsParser,
[v1484]),v1485={usage:"Concatenate and emit output to single file | Redirect output structure to the directory",type:"file|directory",set:v1377};JAMScript.call(opts.option,opts,["out",v1485]);var v1486={usage:'Select style checking options (examples --style requireSemi:off or --style "eqeqeq;bitwise:off")',experimental:!0,set:v1378};JAMScript.call(opts.option,opts,["style",v1486]);var v1487={usage:"Generates corresponding .map file",set:v1379};JAMScript.call(opts.flag,opts,["sourcemap",v1487]);var v1488=
{usage:"Generates corresponding .d.ts file",set:v1380};JAMScript.call(opts.flag,opts,["declaration",v1488]);var v12398=this.ioHost,v1490=v12398.watchFile;if(v1490){var v1489={usage:"Watch output files",set:v1381};JAMScript.call(opts.flag,opts,["watch",v1489,"w"])}var v1491={usage:"Execute the script after compilation",set:v1382};JAMScript.call(opts.flag,opts,["exec",v1491,"e"]);var v1492={usage:"Parse only",experimental:!0,set:v1383};JAMScript.call(opts.flag,opts,["parse",v1492]);var v1493={usage:"Minimize whitespace",
experimental:!0,set:v1384};JAMScript.call(opts.flag,opts,["minw",v1493,"mw"]);var v1494={usage:"Propagate constants to emitted code",experimental:!0,set:v1385};JAMScript.call(opts.flag,opts,["const",v1494]);var v1495={usage:"Enable error recovery",experimental:!0,set:v1386};JAMScript.call(opts.flag,opts,["errorrecovery",v1495,"er"]);var v1496={usage:"Emit comments to output",set:v1387};JAMScript.call(opts.flag,opts,["comments",v1496,"c"]);var v1497={usage:"Control flow",experimental:!0,set:v1388};
JAMScript.call(opts.flag,opts,["cflow",v1497]);var v1498={usage:"Print control flow",experimental:!0,set:v1389};JAMScript.call(opts.flag,opts,["cflowp",v1498]);var v1499={usage:"Print Use Def control flow",experimental:!0,set:v1390};JAMScript.call(opts.flag,opts,["cflowu",v1499]);var v1500={usage:"Allow with statements",experimental:!0,set:v1391};JAMScript.call(opts.flag,opts,["noerroronwith",v1500]);var v1501={usage:"Skip resolution and preprocessing",experimental:!0,set:v1392};JAMScript.call(opts.flag,
opts,["noresolve",v1501]);var v1502={usage:"Print debug output",experimental:!0,set:v1393};JAMScript.call(opts.flag,opts,["debug",v1502]);var v1503={usage:"Allows you to call the definition signature of an overload group",experimental:!0,set:v1394};JAMScript.call(opts.flag,opts,["canCallDefinitionSignature",v1503]);var v1504={usage:"Do not optimize module codegen",experimental:!0,set:v1395};JAMScript.call(opts.flag,opts,["nooptimizemodules",v1504]);var v1505={usage:"Do not include a default lib.d.ts with global declarations",
set:v1396};JAMScript.call(opts.flag,opts,["nolib",v1505]);var v1506={usage:"Infer class properties from top-level assignments to 'this'",experimental:!0,set:v1397};JAMScript.call(opts.flag,opts,["inferProperties",v1506]);var v1507={usage:'Specify ECMAScript target version: "ES3" (default), or "ES5"',type:"VER",set:v1398};JAMScript.call(opts.option,opts,["target",v1507]);var v1508={usage:'Specify module code generation: "commonjs" (default) or "amd"',type:"kind",set:v1399};JAMScript.call(opts.option,
opts,["module",v1508]);var printedUsage=!1,v1509={usage:"Print this message",set:v1400};JAMScript.call(opts.flag,opts,["help",v1509,"h"]);var v1510={usage:"Force file resolution to be case sensitive",experimental:!0,set:v1401};JAMScript.call(opts.flag,opts,["useCaseSensitiveFileResolution",v1510]);var v18835=this.compilerVersion,v12399="Print the compiler's version: "+v18835,v1511={usage:v12399,set:v1402};JAMScript.call(opts.flag,opts,["version",v1511,"v"]);var v12400=this.ioHost,v1512=v12400.arguments;
JAMScript.call(opts.parse,opts,[v1512]);var v12401=this.compilationSettings,v1519=v12401.useDefaultLib;if(v1519){var v1513=this.ioHost,compilerFilePath=JAMScript.call(v1513.getExecutingFilePath,v1513,[]),v1514=this.ioHost,binDirPath=JAMScript.call(v1514.dirName,v1514,[compilerFilePath]),v1515=this.ioHost,v1516=binDirPath+"/lib.d.ts",libStrPath=JAMScript.call(v1515.resolvePath,v1515,[v1516]),v1517=TypeScript.SourceUnit;code=JAMScript.new(v1517,[libStrPath,null]);var v12402=this.compilationEnvironment,
v1518=v12402.code;JAMScript.call(v1518.push,v1518,[code])}for(var i=0,v18836=opts.unnamed,v12403=v18836.length,v1523=i<v12403;v1523;){var v1520=TypeScript.SourceUnit,v12404=opts.unnamed;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v1521=v12404[i];code=JAMScript.new(v1520,[v1521,null]);var v12405=this.compilationEnvironment,v1522=v12405.code;JAMScript.call(v1522.push,v1522,[code]);var i=i+1,v18837=opts.unnamed,v12406=v18837.length,v1523=i<v12406}var v22828=
this.compilationEnvironment,v18838=v22828.code,v12407=v18838.length,v18839,v24779=this.compilationSettings,v22829=v24779.useDefaultLib,v12408=v18839=v22829?1:0,v1526=v12407==v12408;if(v1526){var v12409=!printedUsage;if(v12409)var v18840=this.printedVersion,v12409=!v18840;var v1525=v12409;if(v1525){JAMScript.call(this.printVersion,this,[]);JAMScript.call(opts.printUsage,opts,[]);var v1524=this.ioHost;JAMScript.call(v1524.quit,v1524,[1])}}else{var sourceFiles=[],v12410=this.compilationSettings,v1528=
v12410.watch;if(v1528)var v12411=this.compilationEnvironment,v1527=v12411.code,sourceFiles=v1527.slice(0);var v1529,v18841=this.compilationSettings,v12412=v18841.resolve;this.resolvedEnvironment=v1529=v12412?JAMScript.call(this.resolve,this,[]):this.compilationEnvironment;var hasCompileErrors=JAMScript.call(this.compile,this,[]),v1530=hasCompileErrors,v12413=!v1530;v12413&&(v1530=this.hasResolveErrors);var hasErrors=v1530,v1532=!hasErrors;if(v1532){var v12414=this.compilationSettings,v1531=v12414.exec;
v1531&&JAMScript.call(this.run,this,[])}var v12415=this.compilationSettings,v1535=v12415.watch;if(v1535)JAMScript.call(this.watchFiles,this,[sourceFiles]);else{var v1533=this.ioHost,v12416,v1534=v12416=hasErrors?1:0;JAMScript.call(v1533.quit,v1533,[v1534])}}}function v1375(){for(var i=0,v22830=this.compilationEnvironment,v22830=v22830.code,v22830=v22830.length,v22830=i<v22830;v22830;){v22830=this.compilationEnvironment;v22830=v22830.code;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v22830=
v22830[i];var v22830=v22830.path,v1538=JAMScript.call(TypeScript.isTSFile,TypeScript,[v22830]);v1538?v22830=v22830.replace(/\.ts$/,".js"):(v1538=JAMScript.call(TypeScript.isSTRFile,TypeScript,[v22830]))&&(v22830=v22830.replace(/\.str$/,".js"));v1538=this.ioHost;if(v1538=JAMScript.call(v1538.fileExists,v1538,[v22830])){var v1538=this.ioHost,v1538=JAMScript.call(v1538.readFile,v1538,[v22830]),v1540=this.ioHost;JAMScript.call(v1540.run,v1540,[v1538,v22830])}i+=1;v22830=this.compilationEnvironment;v22830=
v22830.code;v22830=v22830.length;v22830=i<v22830}}function v1374(){function v1373(fileName,useUTF8){var v1543=_this.ioHost;return JAMScript.call(IOUtils.createFileAndFolderStructure,IOUtils,[v1543,fileName,useUTF8])}function v1372(minChar,charLen,message,unitIndex){charLen=compiler.errorReporter;charLen.hasErrors=!0;charLen=_this.resolvedEnvironment;charLen=charLen.code;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)unitIndex=charLen[unitIndex];charLen=unitIndex.path;
unitIndex={line:-1,col:-1};var v1546=compiler.parser;JAMScript.call(v1546.getSourceLineCol,v1546,[unitIndex,minChar]);minChar=charLen+" (";charLen=unitIndex.line;minChar+=charLen;minChar+=",";unitIndex=unitIndex.col;unitIndex+=1;minChar+=unitIndex;minChar+="): ";message=minChar+message;minChar=_this.compilationSettings;if(minChar=minChar.errorRecovery)minChar=_this.ioHost,minChar=minChar.stderr,JAMScript.call(minChar.WriteLine,minChar,[message]);else throw new SyntaxError(message);}function consumeUnit(code){var addAsResident=
!1;try{var v18847=_this.compilationSettings,v12425=v18847.resolve;if(v18847=!v12425){var v18847=code,v12426=_this.ioHost,v12427=code.path,v26770=JAMScript.call(v12426.readFile,v12426,[v12427]);v18847.content=v26770;var v12428=_this.compilationSettings,v1554=v12428.generateDeclarationFiles;if(v1554){var v1551=TypeScript.CompilerDiagnostics,v12429=code.referencedFiles,v12426=null==v12429;JAMScript.call(v1551.assert,v1551,[v12426,"With no resolve option, referenced files need to null"]);var v1551=code,
v26771=JAMScript.call(TypeScript.getReferencedFiles,TypeScript,[code]);v1551.referencedFiles=v26771}}var v1565=code.content;if(v1565){var v12430=_this.compilationSettings,v1564=v12430.parseOnly;if(v1564){var v1556=code.content,v1557=code.path;JAMScript.call(compiler.parseUnit,compiler,[v1556,v1557])}else{var v12431=_this.compilationSettings,v1560=v12431.errorRecovery;if(v1560){var v1558=compiler.parser,v12432=_this.ioHost,v1559=v12432.stderr;JAMScript.call(v1558.setErrorRecovery,v1558,[v1559])}var v1561=
code.content,v1562=code.path,v1563=code.referencedFiles;JAMScript.call(compiler.addUnit,compiler,[v1561,v1562,addAsResident,v1563])}}}catch(err){code=compiler.errorReporter,code.hasErrors=!0,code=_this.ioHost,code=code.stderr,addAsResident=err.message,JAMScript.call(code.WriteLine,code,[addAsResident])}}var _this=this,compiler,v1569=TypeScript.TypeScriptCompiler,v12434=this.ioHost,v12434=v12434.stderr,v12435=TypeScript.NullLogger,v12435=JAMScript.new(v12435,[]),v1572=this.compilationSettings;compiler=
JAMScript.new(v1569,[v12434,v12435,v1572]);v1569=this.ioHost;v1569=v1569.stderr;JAMScript.call(compiler.setErrorOutput,compiler,[v1569]);JAMScript.call(compiler.setErrorCallback,compiler,[v1372]);v1569=this.compilationSettings;(v1569=v1569.emitComments)&&JAMScript.call(compiler.emitCommentsToOutput,compiler,[]);v1569=0;v12434=this.resolvedEnvironment;v12434=v12434.code;v12434=v12434.length;for(v12434=v1569<v12434;v12434;){v12434=this.compilationSettings;v12434=v12434.parseOnly;v12434=!v12434;(v12435=
!v12434)&&(v12434=0<v1569);if(v12434){v12434=this.resolvedEnvironment;v12434=v12434.code;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v12434=v12434[v1569];consumeUnit(v12434)}v1569+=1;v12434=this.resolvedEnvironment;v12434=v12434.code;v12434=v12434.length;v12434=v1569<v12434}v1569=this.ioHost;v1569=v1569.directoryExists;v12434=this.ioHost;v12434=v12434.fileExists;v12435=this.ioHost;v12435=v12435.resolvePath;v1569={createFile:v1373,directoryExists:v1569,fileExists:v12434,
resolvePath:v12435};try{var v18853=this.compilationSettings,v12445=v18853.parseOnly;(v18853=!v12445)?(JAMScript.call(compiler.typeCheck,compiler,[]),JAMScript.call(compiler.emit,compiler,[v1569]),JAMScript.call(compiler.emitDeclarations,compiler,[])):JAMScript.call(compiler.emitAST,compiler,[v1569])}catch(err$$0){if(v18853=compiler.errorReporter,v18853.hasErrors=!0,v18853=err$$0.message,v18853="EmitError"!=v18853)throw err$$0;}v18853=compiler.errorReporter;return v18853.hasErrors}function v1371(){var v1585=
TypeScript.CodeResolver,v1586=this.compilationEnvironment,v1586=JAMScript.new(v1585,[v1586]),v1585=this.compilationSettings,v1585=JAMScript.new(CommandLineHost,[v1585]),v1588=this.compilationEnvironment,v1586=JAMScript.call(v1585.resolveCompilationEnvironment,v1585,[v1588,v1586,!0]);this.hasResolveErrors=!1;for(var v1588=0,v22837=this.compilationEnvironment,v22837=v22837.code,v22837=v22837.length,v22837=v1588<v22837;v22837;){v22837=this.compilationEnvironment;v22837=v22837.code;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v22837=
v22837[v1588];v22837=v22837.path;v22837=JAMScript.call(v1585.isResolved,v1585,[v22837]);if(v22837=!v22837){this.hasResolveErrors=!0;v22837=this.compilationEnvironment;v22837=v22837.code;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v22837=v22837[v1588];var v22837=v22837.path,v18857=JAMScript.call(TypeScript.isSTRFile,TypeScript,[v22837]);if(v18857=!v18857)if(v18857=JAMScript.call(TypeScript.isDSTRFile,TypeScript,[v22837]),v18857=!v18857)if(v18857=JAMScript.call(TypeScript.isTSFile,
TypeScript,[v22837]),v18857=!v18857)v18857=JAMScript.call(TypeScript.isDTSFile,TypeScript,[v22837]),v18857=!v18857;v18857?(v18857=this.ioHost,v18857=v18857.stderr,v22837='Unknown extension for file: "'+v22837,v22837+='". Only .ts and .d.ts extensions are allowed.'):(v18857=this.ioHost,v18857=v18857.stderr,v22837='Error reading file "'+v22837,v22837+='": File not found');JAMScript.call(v18857.WriteLine,v18857,[v22837])}v1588+=1;v22837=this.compilationEnvironment;v22837=v22837.code;v22837=v22837.length;
v22837=v1588<v22837}return v1586}function BatchCompiler(ioHost){this.ioHost=ioHost;this.resolvedEnvironment=null;this.hasResolveErrors=!1;this.compilerVersion="0.8.2.0";this.printedVersion=!1;ioHost=TypeScript.CompilationSettings;this.compilationSettings=ioHost=JAMScript.new(ioHost,[]);ioHost=TypeScript.CompilationEnvironment;var v1599=this.compilationSettings,v1600=this.ioHost;this.compilationEnvironment=ioHost=JAMScript.new(ioHost,[v1599,v1600])}var v1601=BatchCompiler.prototype;v1601.resolve=v1371;
v1601=BatchCompiler.prototype;v1601.compile=v1374;v1601=BatchCompiler.prototype;v1601.run=v1375;v1601=BatchCompiler.prototype;v1601.batchCompile=v1403;v1601=BatchCompiler.prototype;v1601.printVersion=v1404;v1601=BatchCompiler.prototype;v1601.watchFiles=v1408;return BatchCompiler}
function v1370(){function v1369(preEnv,resolver,traceDependencies){function v1368(path,code){var pathId=JAMScript.call(_this.getPathIdentifier,_this,[path]),v18860=_this.resolvedPaths;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v18860=v18860[pathId];if(v18860=!v18860)v18860=resolvedEnv.code,JAMScript.call(v18860.push,v18860,[code]),v18860=_this.resolvedPaths,JAMScript.set(v18860,pathId,!0)}function postResolutionError(errorFile,errorMessage){var v1610=TypeScript.CompilerDiagnostics,
v18861="Could not resolve file '"+errorFile,v18861=v18861+"'",v18862;v18862=(v18862=""==errorMessage)?"":": "+errorMessage;v18861+=v18862;JAMScript.call(v1610.debugPrint,v1610,[v18861])}var _this=this;traceDependencies=TypeScript.CompilationEnvironment;var v1613=preEnv.compilationSettings,v1614=preEnv.ioHost,resolvedEnv=JAMScript.new(traceDependencies,[v1613,v1614]);traceDependencies=preEnv.code;traceDependencies=traceDependencies.length;for(var path$$0="",v1613={postResolutionError:postResolutionError,
postResolution:v1368},v1614=0,path$$0=v1614<traceDependencies;path$$0;){var path$$0=preEnv.ioHost,v22843=preEnv.code;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v22843=v22843[v1614];var v22843=v22843.path,path$$0=JAMScript.call(path$$0.resolvePath,path$$0,[v22843]),path$$0=JAMScript.call(TypeScript.switchToForwardSlashes,TypeScript,[path$$0]),v22843=this.pathMap,v18864=preEnv.code;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v18864=
v18864[v1614];v18864=v18864.path;JAMScript.set(v22843,v18864,path$$0);JAMScript.call(resolver.resolveCode,resolver,[path$$0,"",!1,v1613]);v1614+=1;path$$0=v1614<traceDependencies}return resolvedEnv}function v1367(path){var v12462=this.resolvedPaths,v22844=this.pathMap;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)path=v22844[path];path=JAMScript.call(this.getPathIdentifier,this,[path]);introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v12462=
v12462[path];return void 0!=v12462}function v1366(path){var v18866=this.compilationSettings;return path=(v18866=v18866.useCaseSensitiveFileResolution)?path:path.toLocaleUpperCase()}function CommandLineHost(compilationSettings){this.compilationSettings=compilationSettings;this.pathMap={};this.resolvedPaths={}}var v1622=CommandLineHost.prototype;v1622.getPathIdentifier=v1366;v1622=CommandLineHost.prototype;v1622.isResolved=v1367;v1622=CommandLineHost.prototype;v1622.resolveCompilationEnvironment=v1369;
return CommandLineHost}
function v1365(){function v1364(args){for(var position=0,v12465=args.length,v12465=position<v12465;v12465;){v12465=position;position+=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var current=args[v12465];var match=current.match(/^(--?|@)(.*)/),v12465=null;if(match)if(current=match[1],current="@"===current)v12465=this.host,match=match[2],v12465=JAMScript.call(v12465.readFile,v12465,[match]),JAMScript.call(this.parseString,this,[v12465]);else{var current=match[2],
match=JAMScript.call(this.findOption,this,[current]),v1632=null===match;if(v1632)v12465=this.host,match="Unknown option '"+current,match+="'",JAMScript.call(v12465.printLine,v12465,[match]),v12465=this.host,JAMScript.call(v12465.printLine,v12465,["Use the '--help' flag to see options"]);else{current=match.flag;if(current=!current)v12465=position,position+=1,v12465=args[v12465];JAMScript.call(match.set,match,[v12465])}}else v12465=this.unnamed,JAMScript.call(v12465.push,v12465,[current]);v12465=args.length;
v12465=position<v12465}}function v1363(argString){var position=0,tokens=argString.match(/\s+|"|[^\s"]+/g);argString=[];for(var currentArg="",v12472=tokens.length,v12472=position<v12472;v12472;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v12472=tokens[position];var v1644='"'===v12472;if(v1644){v12472="";position+=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v1644=tokens[position];var v12473=v1644;for(v12473&&(v12473='"'!==
v1644);v12473;)position+=1,v12472+=v1644,(v12473=v1644=tokens[position])&&(v12473='"'!==v1644);position+=1;currentArg+=v12472}else if(v1644=v12472.match(/\s/)){v12472=currentArg.length;if(v12472=0<v12472)JAMScript.call(argString.push,argString,[currentArg]),currentArg="";position+=1}else position+=1,currentArg+=v12472;v12472=tokens.length;v12472=position<v12472}position=currentArg.length;(position=0<position)&&JAMScript.call(argString.push,argString,[currentArg]);JAMScript.call(this.parse,this,[argString])}
function v1362(name,config,short){var v1647=!config;v1647&&(config=short,short=null);config.name=name;config.short=short;config.flag=!0;name=this.options;JAMScript.call(name.push,name,[config])}function v1361(name,config,short){var v1649=!config;v1649&&(config=short,short=null);config.name=name;config.short=short;config.flag=!1;name=this.options;JAMScript.call(name.push,name,[config])}function v1360(){function v1359(a,b){var v1651=a.name,v1651=v1651.toLowerCase(),v1652=b.name,v1652=v1652.toLowerCase(),
v1654=v1651>v1652;return v1654?1:(v1651=v1651<v1652)?-1:0}var v1655=this.host;JAMScript.call(v1655.printLine,v1655,["Syntax:   tsc [options] [file ..]"]);v1655=this.host;JAMScript.call(v1655.printLine,v1655,[""]);v1655=this.host;JAMScript.call(v1655.printLine,v1655,["Examples: tsc hello.ts"]);v1655=this.host;JAMScript.call(v1655.printLine,v1655,["          tsc --out foo.js foo.ts"]);v1655=this.host;JAMScript.call(v1655.printLine,v1655,["          tsc @args.txt"]);v1655=this.host;JAMScript.call(v1655.printLine,
v1655,[""]);v1655=this.host;JAMScript.call(v1655.printLine,v1655,["Options:"]);var v1655=[],maxLength=0,v1662=this.options;this.options=v1662=v1662.sort(v1359);for(var v1662=0,v18867=this.options,v18867=v18867.length,v18867=v1662<v18867;v18867;){v18867=this.options;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var option=v18867[v1662];v18867=option.experimental;if(!v18867){v18867=option.usage;if(v18867=!v18867)break;var v18867="  ",v1666;(v1666=option.type)?(v1666=
option.type,v1666=v1666.toUpperCase(),v1666=" "+v1666):v1666="";var v1667=option.short;if(v1667)var v1667=this.DEFAULT_SHORT_FLAG,v24786=option.short,v1667=v1667+v24786,v1667=v1667+v1666,v1667=v1667+", ",v18867=v18867+v1667;v1667=this.DEFAULT_LONG_FLAG;v24786=option.name;v1667+=v24786;v1666=v1667+v1666;v18867+=v1666;option=option.usage;option=[v18867,option];JAMScript.call(v1655.push,v1655,[option]);option=v18867.length;if(option=option>maxLength)maxLength=v18867.length}v1662+=1;v18867=this.options;
v18867=v18867.length;v18867=v1662<v18867}v1662=["  @<file>","Insert command line options and files from a file."];JAMScript.call(v1655.push,v1655,[v1662]);v1662=0;v18867=v1655.length;for(v18867=v1662<v18867;v18867;){v18867=this.host;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)option=v1655[v1662];option=option[0];introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v1666=v1655[v1662];v1666=v1666[0];v1666=v1666.length;v1666=maxLength-
v1666;v1666+=3;v1666=Array(v1666);v1666=v1666.join(" ");option+=v1666;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v1666=v1655[v1662];v1666=v1666[1];option+=v1666;JAMScript.call(v18867.printLine,v18867,[option]);v1662+=1;v18867=v1655.length;v18867=v1662<v18867}}function v1358(arg){for(var i=0,v18876=this.options,v18876=v18876.length,v18876=i<v18876;v18876;){v18876=this.options;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v18876=
v18876[i];var v18876=v18876.short,v18876=arg===v18876,v18879=!v18876;if(v18879){v18876=this.options;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v18876=v18876[i];v18876=v18876.name;v18876=arg===v18876}if(v18876){arg=this.options;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return arg[i]}i+=1;v18876=this.options;v18876=v18876.length;v18876=i<v18876}return null}function OptionsParser(host){this.host=host;this.DEFAULT_SHORT_FLAG=
"-";this.DEFAULT_LONG_FLAG="--";this.unnamed=[];this.options=[]}var v1678=OptionsParser.prototype;v1678.findOption=v1358;v1678=OptionsParser.prototype;v1678.printUsage=v1360;v1678=OptionsParser.prototype;v1678.option=v1361;v1678=OptionsParser.prototype;v1678.flag=v1362;v1678=OptionsParser.prototype;v1678.parseString=v1363;v1678=OptionsParser.prototype;v1678.parse=v1364;return OptionsParser}
function v1357(){function getWindowsScriptHostIO(){function v1331(exitCode){var v12495=typeof exitCode;(v12495="undefined"===v12495)&&(exitCode=0);try{JAMScript.call(WScript.Quit,WScript,[exitCode])}catch(e){}}function v1330(){return WScript.ScriptFullName}function v1329(source,filename){try{JAMScript.isEval(eval)?eval("introspect(JAMScript.introspectors.processAll) { "+source+" }"):JAMScript.call(eval,null,[source])}catch(e){var v12496="Error while executing file '"+filename,v12496=v12496+"'.";JAMScript.call(IOUtils.throwIOError,
IOUtils,[v12496,e])}}function v1328(str){JAMScript.call(WScript.Echo,WScript,[str])}function v1327(str){var v1686=WScript.StdOut;JAMScript.call(v1686.Write,v1686,[str])}function v1326(path,spec,options){function filesInFolder(folder,root){var paths=[],fc;if(fc=options.recursive){fc=folder.subfolders;fc=JAMScript.new(Enumerator,[fc]);for(var v12497=JAMScript.call(fc.atEnd,fc,[]),v12497=!v12497;v12497;){var v12497=fc.item(),v18881=root+"/",v22852=fc.item(),v22852=v22852.Name,v18881=v18881+v22852,v12497=
filesInFolder(v12497,v18881),paths=paths.concat(v12497);JAMScript.call(fc.moveNext,fc,[]);v12497=JAMScript.call(fc.atEnd,fc,[]);v12497=!v12497}}fc=folder.files;fc=JAMScript.new(Enumerator,[fc]);v12497=JAMScript.call(fc.atEnd,fc,[]);for(v12497=!v12497;v12497;){v12497=!spec;if(v18881=!v12497)v12497=fc.item(),v12497=v12497.Name,v12497=v12497.match(spec);v12497&&(v12497=root+"/",v18881=fc.item(),v18881=v18881.Name,v12497+=v18881,JAMScript.call(paths.push,paths,[v12497]));JAMScript.call(fc.moveNext,fc,
[]);v12497=JAMScript.call(fc.atEnd,fc,[]);v12497=!v12497}return paths}options=options||{};var folder=JAMScript.call(fso.GetFolder,fso,[path]);return filesInFolder(folder,path)}function v1325(path){try{var v12506=JAMScript.call(this.directoryExists,this,[path]);(v12506=!v12506)&&JAMScript.call(fso.CreateFolder,fso,[path])}catch(e){path="Couldn't create directory '"+path,path+="'.",JAMScript.call(IOUtils.throwIOError,IOUtils,[path,e])}}function v1324(path){return JAMScript.call(fso.FolderExists,fso,
[path])}function v1323(path,useUTF8){function v1322(){try{JAMScript.call(streamObj.SaveToFile,streamObj,[path,2])}catch(saveError){var v12508="Couldn't write to file '"+path,v12508=v12508+"'.";JAMScript.call(IOUtils.throwIOError,IOUtils,[v12508,saveError])}finally{v12508=streamObj.State,(v12508=0!=v12508)&&JAMScript.call(streamObj.Close,streamObj,[]),JAMScript.call(streamObjectPool.push,streamObjectPool,[streamObj])}}function v1321(str){JAMScript.call(streamObj.WriteText,streamObj,[str,1])}function v1320(str){JAMScript.call(streamObj.WriteText,
streamObj,[str,0])}try{var streamObj=getStreamObject(),v1699;v1699=useUTF8?"utf-8":"x-ansi";streamObj.Charset=v1699;JAMScript.call(streamObj.Open,streamObj,[]);return{Write:v1320,WriteLine:v1321,Close:v1322}}catch(creationError){v1699="Couldn't write to file '"+path,v1699+="'.",JAMScript.call(IOUtils.throwIOError,IOUtils,[v1699,creationError])}}function v1319(path){try{var v1701=JAMScript.call(fso.FileExists,fso,[path]);v1701&&JAMScript.call(fso.DeleteFile,fso,[path,!0])}catch(e){path="Couldn't delete file '"+
path,path+="'.",JAMScript.call(IOUtils.throwIOError,IOUtils,[path,e])}}function v1318(rootPath,partialFilePath){for(var v12512=JAMScript.call(fso.GetAbsolutePathName,fso,[rootPath]),v12512=v12512+"/",v12512=v12512+partialFilePath;;){var v1706=JAMScript.call(fso.FileExists,fso,[v12512]);if(v1706)try{var content=JAMScript.call(this.readFile,this,[v12512]);return{content:content,path:v12512}}catch(err){}else{v12512=JAMScript.call(fso.GetAbsolutePathName,fso,[rootPath]);rootPath=JAMScript.call(fso.GetParentFolderName,
fso,[v12512]);if(v12512=""==rootPath)return null;v12512=JAMScript.call(fso.BuildPath,fso,[rootPath,partialFilePath])}}}function v1317(path){return JAMScript.call(fso.GetParentFolderName,fso,[path])}function v1316(path){return JAMScript.call(fso.GetAbsolutePathName,fso,[path])}function v1315(path){return JAMScript.call(fso.FileExists,fso,[path])}function v1314(path,contents){var file=JAMScript.call(this.createFile,this,[path]);JAMScript.call(file.Write,file,[contents]);JAMScript.call(file.Close,file,
[])}function v1313(path){try{var streamObj=getStreamObject();JAMScript.call(streamObj.Open,streamObj,[]);streamObj.Type=2;streamObj.Charset="x-ansi";JAMScript.call(streamObj.LoadFromFile,streamObj,[path]);var bomChar=JAMScript.call(streamObj.ReadText,streamObj,[2]);streamObj.Position=0;var v22854=JAMScript.call(bomChar.charCodeAt,bomChar,[0]);if(v22854=254==v22854)var v22855=JAMScript.call(bomChar.charCodeAt,bomChar,[1]),v22854=255==v22855;v22855=v22854;if(v22854=!v22855){var v22856=JAMScript.call(bomChar.charCodeAt,
bomChar,[0]);if(v22856=255==v22856)var v22857=JAMScript.call(bomChar.charCodeAt,bomChar,[1]),v22856=254==v22857;v22855=v22856}if(v22857=v22855)streamObj.Charset="unicode";else{var v18889=JAMScript.call(bomChar.charCodeAt,bomChar,[0]);if(v18889=239==v18889)var v18890=JAMScript.call(bomChar.charCodeAt,bomChar,[1]),v18889=187==v18890;if(bomChar=v18889)streamObj.Charset="utf-8"}var str=JAMScript.call(streamObj.ReadText,streamObj,[-1]);JAMScript.call(streamObj.Close,streamObj,[]);JAMScript.call(streamObjectPool.push,
streamObjectPool,[streamObj]);return str}catch(err){path='Error reading file "'+path,path+='".',JAMScript.call(IOUtils.throwIOError,IOUtils,[path,err])}}function getStreamObject(){var v12516=streamObjectPool.length;return(v12516=0<v12516)?JAMScript.call(streamObjectPool.pop,streamObjectPool,[]):JAMScript.new(ActiveXObject,["ADODB.Stream"])}for(var fso=JAMScript.new(ActiveXObject,["Scripting.FileSystemObject"]),streamObjectPool=[],args=[],i=0,v18891=WScript.Arguments,v18891=v18891.length,v18891=i<
v18891;v18891;){var v18891=args,v1712=i,v12518=WScript.Arguments,v12518=JAMScript.call(v12518.Item,v12518,[i]);v18891[v1712]=v12518;i+=1;v18891=WScript.Arguments;v18891=v18891.length;v18891=i<v18891}i=WScript.StdErr;v18891=WScript.StdOut;return{readFile:v1313,writeFile:v1314,fileExists:v1315,resolvePath:v1316,dirName:v1317,findFile:v1318,deleteFile:v1319,createFile:v1323,directoryExists:v1324,createDirectory:v1325,dir:v1326,print:v1327,printLine:v1328,arguments:args,stderr:i,stdout:v18891,watchFile:null,
run:v1329,getExecutingFilePath:v1330,quit:v1331}}function getNodeIO(){function v1356(){var v1716=process.mainModule;return v1716.filename}function v1355(source,filename){var v1717=require.main;v1717.filename=filename;var v1717=require.main,v18893=JAMScript.call(_fs.realpathSync,_fs,[filename]),v18893=JAMScript.call(_path.dirname,_path,[v18893]),v18893=JAMScript.call(_module._nodeModulePaths,_module,[v18893]);v1717.paths=v18893;v1717=require.main;JAMScript.call(v1717._compile,v1717,[source,filename])}
function v1354(filename,callback){function v1353(){JAMScript.call(_fs.unwatchFile,_fs,[filename,fileChanged])}function fileChanged(curr,prev){function v1352(){processingChange=!1}var v1722=!firstRun;if(v1722){var v1722=curr.mtime,v12522=prev.mtime;if(v1722=v1722<v12522)return;JAMScript.call(_fs.unwatchFile,_fs,[filename,fileChanged]);if(v1722=!processingChange)processingChange=!0,JAMScript.call(callback,null,[filename]),JAMScript.call(setTimeout,null,[v1352,100])}firstRun=!1;v1722={persistent:!0,
interval:500};JAMScript.call(_fs.watchFile,_fs,[filename,v1722,fileChanged])}var firstRun=!0,processingChange=!1;fileChanged();return{filename:filename,close:v1353}}function v1351(){}function v1350(str){var v1724=process.stdout;str+="\n";JAMScript.call(v1724.write,v1724,[str])}function v1349(str){var v1726=process.stdout;JAMScript.call(v1726.write,v1726,[str])}function v1348(){}function v1347(str){var v1727=process.stderr;str+="\n";JAMScript.call(v1727.write,v1727,[str])}function v1346(str){var v1729=
process.stderr;JAMScript.call(v1729.write,v1729,[str])}function v1345(str){var v1730=process.stdout;str+="\n";JAMScript.call(v1730.write,v1730,[str])}function v1344(str){var v1732=process.stdout;JAMScript.call(v1732.write,v1732,[str])}function v1343(rootPath,partialFilePath){for(var v1733=rootPath+"/",v1733=v1733+partialFilePath;;){var v1735=JAMScript.call(_fs.existsSync,_fs,[v1733]);if(v1735)try{var content=JAMScript.call(this.readFile,this,[v1733]);return{content:content,path:v1733}}catch(err){}else{v1733=
JAMScript.call(_path.resolve,_path,[rootPath,".."]);if(v1735=rootPath===v1733)return null;rootPath=v1733;v1733=JAMScript.call(_path.resolve,_path,[rootPath,partialFilePath])}}}function v1342(path){return JAMScript.call(_path.dirname,_path,[path])}function v1341(path){return JAMScript.call(_path.resolve,_path,[path])}function v1340(path){var v1736=JAMScript.call(_fs.existsSync,_fs,[path]);v1736&&(path=JAMScript.call(_fs.lstatSync,_fs,[path]),v1736=JAMScript.call(path.isDirectory,path,[]));return v1736}
function v1339(path){try{var v12524=JAMScript.call(this.directoryExists,this,[path]);(v12524=!v12524)&&JAMScript.call(_fs.mkdirSync,_fs,[path])}catch(e){path="Couldn't create directory '"+path,path+="'.",JAMScript.call(IOUtils.throwIOError,IOUtils,[path,e])}}function dir(path,spec,options){function filesInFolder(folder){for(var paths=[],files=JAMScript.call(_fs.readdirSync,_fs,[folder]),i=0,v12526=files.length,v12526=i<v12526;v12526;){v12526=folder+"/";introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v12528=
files[i];v12526+=v12528;v12526=JAMScript.call(_fs.statSync,_fs,[v12526]);(v12528=options.recursive)&&(v12528=JAMScript.call(v12526.isDirectory,v12526,[]));if(v12528){v12526=folder+"/";introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v12528=files[i];v12526+=v12528;v12526=filesInFolder(v12526);paths=paths.concat(v12526)}else{if(v12526=JAMScript.call(v12526.isFile,v12526,[]))if(v12526=!spec,v12528=!v12526){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v12526=
files[i];v12526=v12526.match(spec)}if(v12526){v12526=folder+"/";introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v12528=files[i];v12526+=v12528;JAMScript.call(paths.push,paths,[v12526])}}i+=1;v12526=files.length;v12526=i<v12526}return paths}options=options||{};return filesInFolder(path)}function v1338(path$$0,useUTF8){function v1337(){JAMScript.call(_fs.closeSync,_fs,[fd]);fd=null}function v1336(str){str+="\r\n";JAMScript.call(_fs.writeSync,_fs,[fd,str])}function v1335(str){JAMScript.call(_fs.writeSync,
_fs,[fd,str])}function mkdirRecursiveSync(path){var stats=JAMScript.call(_fs.statSync,_fs,[path]),v1749=JAMScript.call(stats.isFile,stats,[]);v1749?(path='"'+path,path+="\" exists but isn't a directory.",JAMScript.call(IOUtils.throwIOError,IOUtils,[path,null])):(stats=JAMScript.call(stats.isDirectory,stats,[]),stats||(stats=JAMScript.call(_path.dirname,_path,[path]),mkdirRecursiveSync(stats),JAMScript.call(_fs.mkdirSync,_fs,[path,509])))}var v1750=JAMScript.call(_path.dirname,_path,[path$$0]);mkdirRecursiveSync(v1750);
try{var fd=JAMScript.call(_fs.openSync,_fs,[path$$0,"w"])}catch(e){v1750="Couldn't write to file '"+path$$0,v1750+="'.",JAMScript.call(IOUtils.throwIOError,IOUtils,[v1750,e])}return{Write:v1335,WriteLine:v1336,Close:v1337}}function v1334(path){return JAMScript.call(_fs.existsSync,_fs,[path])}function v1333(path){try{JAMScript.call(_fs.unlinkSync,_fs,[path])}catch(e){path="Couldn't delete file '"+path,path+="'.",JAMScript.call(IOUtils.throwIOError,IOUtils,[path,e])}}function v1332(file){try{var buffer=
JAMScript.call(_fs.readFileSync,_fs,[file]),v1759=buffer[0];switch(v1759){case 254:var v12538=buffer[1];if(v1759=255==v12538){for(var v1759=0,v12538=v1759+1,v12540=buffer.length,v12540=v12538<v12540;v12540;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var temp=buffer[v1759];v12538=v1759+1;buffer[v1759]=buffer[v12538];v12538=v1759+1;buffer[v12538]=temp;var v1759=v1759+2,v12538=v1759+1,v12542=buffer.length,v12540=v12538<v12542}return JAMScript.call(buffer.toString,
buffer,["ucs2",2])}break;case 255:var v12543=buffer[1];if(temp=254==v12543)return JAMScript.call(buffer.toString,buffer,["ucs2",2]);break;case 239:var v12544=buffer[1];if(temp=187==v12544)return JAMScript.call(buffer.toString,buffer,["utf8",3])}return JAMScript.call(buffer.toString,buffer,[])}catch(e){file='Error reading file "'+file,file+='".',JAMScript.call(IOUtils.throwIOError,IOUtils,[file,e])}}var _fs=JAMScript.call(require,null,["fs"]),_path=JAMScript.call(require,null,["path"]),_module=JAMScript.call(require,
null,["module"]),v1761=_fs.writeFileSync,v12546=process.argv,v12546=v12546.slice(2),v1763={Write:v1346,WriteLine:v1347,Close:v1348},v1764={Write:v1349,WriteLine:v1350,Close:v1351},v1765=process.exit;return{readFile:v1332,writeFile:v1761,deleteFile:v1333,fileExists:v1334,createFile:v1338,dir:dir,createDirectory:v1339,directoryExists:v1340,resolvePath:v1341,dirName:v1342,findFile:v1343,print:v1344,printLine:v1345,arguments:v12546,stderr:v1763,stdout:v1764,watchFile:v1354,run:v1355,getExecutingFilePath:v1356,
quit:v1765}}var v12547=typeof ActiveXObject;if(v12547="function"===v12547)return getWindowsScriptHostIO();v12547=typeof require;return(v12547="function"===v12547)?getNodeIO():null}
function v1312(){var IOUtils=v12374;function createDirectoryStructure(ioHost,dirName){var v1768=JAMScript.call(ioHost.directoryExists,ioHost,[dirName]);if(!v1768){var v1768=JAMScript.call(ioHost.dirName,ioHost,[dirName]),v1769=""!=v1768;v1769&&createDirectoryStructure(ioHost,v1768);JAMScript.call(ioHost.createDirectory,ioHost,[dirName])}}function createFileAndFolderStructure(ioHost,fileName,useUTF8){fileName=JAMScript.call(ioHost.resolvePath,ioHost,[fileName]);var dirName=JAMScript.call(ioHost.dirName,
ioHost,[fileName]);createDirectoryStructure(ioHost,dirName);return JAMScript.call(ioHost.createFile,ioHost,[fileName,useUTF8])}function throwIOError(message,error){var errorMessage=message,v12549=error;v12549&&(v12549=error.message);v12549&&(v12549=error.message,v12549=" "+v12549,errorMessage+=v12549);throw Error(errorMessage);}IOUtils.createFileAndFolderStructure=createFileAndFolderStructure;IOUtils.throwIOError=throwIOError}
function v1311(){var TypeScript=v12373;function v1310(){function v1309(s){var v1771=this.logContents;JAMScript.call(v1771.push,v1771,[s])}function v1308(){return!1}function v1307(){return!1}function v1306(){return!1}function v1305(){return!1}function v1304(){return!1}function BufferedLogger(){this.logContents=[]}var v1772=BufferedLogger.prototype;v1772.information=v1304;v1772=BufferedLogger.prototype;v1772.debug=v1305;v1772=BufferedLogger.prototype;v1772.warning=v1306;v1772=BufferedLogger.prototype;
v1772.error=v1307;v1772=BufferedLogger.prototype;v1772.fatal=v1308;v1772=BufferedLogger.prototype;v1772.log=v1309;return BufferedLogger}function v1303(){function v1302(s){var v1778=this.logger;JAMScript.call(v1778.log,v1778,[s])}function v1301(){return this._fatal}function v1300(){return this._error}function v1299(){return this._warning}function v1298(){return this._debug}function v1297(){return this._information}function LoggerAdapter(logger){logger=this.logger=logger;this._information=logger=JAMScript.call(logger.information,
logger,[]);logger=this.logger;this._debug=logger=JAMScript.call(logger.debug,logger,[]);logger=this.logger;this._warning=logger=JAMScript.call(logger.warning,logger,[]);logger=this.logger;this._error=logger=JAMScript.call(logger.error,logger,[]);logger=this.logger;this._fatal=logger=JAMScript.call(logger.fatal,logger,[])}var v1784=LoggerAdapter.prototype;v1784.information=v1297;v1784=LoggerAdapter.prototype;v1784.debug=v1298;v1784=LoggerAdapter.prototype;v1784.warning=v1299;v1784=LoggerAdapter.prototype;
v1784.error=v1300;v1784=LoggerAdapter.prototype;v1784.fatal=v1301;v1784=LoggerAdapter.prototype;v1784.log=v1302;return LoggerAdapter}function v1296(){function v1295(s){}function v1294(){return!1}function v1293(){return!1}function v1292(){return!1}function v1291(){return!1}function v1290(){return!1}function NullLogger(){}var v1790=NullLogger.prototype;v1790.information=v1290;v1790=NullLogger.prototype;v1790.debug=v1291;v1790=NullLogger.prototype;v1790.warning=v1292;v1790=NullLogger.prototype;v1790.error=
v1293;v1790=NullLogger.prototype;v1790.fatal=v1294;v1790=NullLogger.prototype;v1790.log=v1295;return NullLogger}function v1289(CompilerDiagnostics){function Alert(output){var v1797=CompilerDiagnostics.diagnosticWriter;v1797&&(v1797=CompilerDiagnostics.diagnosticWriter,JAMScript.call(v1797.Alert,v1797,[output]))}function debugPrint(s){var v1798=CompilerDiagnostics.debug;v1798&&Alert(s)}function assert(condition,s){var v1800=CompilerDiagnostics.debug;v1800&&(v1800=!condition)&&Alert(s)}CompilerDiagnostics.debug=
!1;CompilerDiagnostics.diagnosticWriter=null;CompilerDiagnostics.analysisPass=0;CompilerDiagnostics.Alert=Alert;CompilerDiagnostics.debugPrint=debugPrint;CompilerDiagnostics.assert=assert}function timeFunction(logger,funcDescription,func){var v1801=new Date,v1801=+v1801;func=JAMScript.call(func,null,[]);var v1802=new Date,v1802=+v1802;funcDescription+=" completed in ";v1801=v1802-v1801;funcDescription+=v1801;funcDescription+=" msec";JAMScript.call(logger.log,logger,[funcDescription]);return func}
function stringToLiteral(value,length){function addChar(index){var ch=JAMScript.call(value.charCodeAt,value,[index]);switch(ch){case 9:result+="\\t";break;case 10:result+="\\n";break;case 11:result+="\\v";break;case 12:result+="\\f";break;case 13:result+="\\r";break;case 34:result+='\\"';break;case 39:result+="\\'";break;case 92:result+="\\";break;default:ch=result,index=value.charAt(index),result=ch+index}}var result="",v1804=value.length;if(v1804=v1804>length){for(var mid=length>>1,v1804=0,v1805=
v1804<mid;v1805;)addChar(v1804),v1804+=1,v1805=v1804<mid;result+="(...)";v1804=value.length;v1804-=mid;mid=value.length;for(mid=v1804<mid;mid;)addChar(v1804),v1804+=1,mid=value.length,mid=v1804<mid}else for(length=value.length,v1804=0,mid=v1804<length;mid;)addChar(v1804),v1804+=1,mid=v1804<length;return result}var v12556=TypeScript.CompilerDiagnostics,v18900=!v12556;v18900&&(v12556=TypeScript.CompilerDiagnostics={});v1289(v12556);v12556=v1296();TypeScript.NullLogger=v12556;v12556=v1303();TypeScript.LoggerAdapter=
v12556;v12556=v1310();TypeScript.BufferedLogger=v12556;TypeScript.timeFunction=timeFunction;TypeScript.stringToLiteral=stringToLiteral}
function v1288(){var TypeScript=v12372;function v1287(){function v1286(enclosingScopeContext,allNames,scope){for(var result=[],enclosingScope=JAMScript.call(enclosingScopeContext.getScope,enclosingScopeContext,[]),i=0,v12557=allNames.length,v12557=i<v12557;v12557;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v12557=allNames[i];var v1810=enclosingScopeContext.publicsOnly;v1810&&(v1810=enclosingScopeContext.isMemberCompletion);var publicsOnly=v1810,v1810=JAMScript.call(scope.find,
scope,[v12557,publicsOnly,!1]),v1811=null==v1810;v1811&&(v1810=JAMScript.call(scope.find,scope,[v12557,publicsOnly,!0]));if(publicsOnly=v1810)publicsOnly=v1810.flags,v1811=TypeScript.SymbolFlags,v1811=v1811.Private,publicsOnly&=v1811;publicsOnly?(publicsOnly=v1810.container,v1811=scope.container,publicsOnly=publicsOnly==v1811):publicsOnly=!0;v1810?(publicsOnly&&(publicsOnly=v1810.name,publicsOnly=JAMScript.call(TypeScript.isQuoted,TypeScript,[publicsOnly]),publicsOnly=!publicsOnly)&&(publicsOnly=
v1810.name,publicsOnly=JAMScript.call(TypeScript.isRelative,TypeScript,[publicsOnly]),publicsOnly=!publicsOnly),publicsOnly&&(publicsOnly=JAMScript.call(v1810.getType,v1810,[]),publicsOnly=JAMScript.call(publicsOnly.getScopedTypeName,publicsOnly,[enclosingScope]),v12557=JAMScript.new(ScopeEntry,[v12557,publicsOnly,v1810]),JAMScript.call(result.push,result,[v12557]))):(v1810="true"==v12557,(publicsOnly=!v1810)&&(v1810="false"==v12557),v1810&&(v1810=this.compiler,v1810=v1810.typeChecker,v1810=v1810.booleanType,
v1810=v1810.symbol,v12557=JAMScript.new(ScopeEntry,[v12557,"bool",v1810]),JAMScript.call(result.push,result,[v12557])));i+=1;v12557=allNames.length;v12557=i<v12557}return result}function v1285(enclosingScopeContext){var scope=JAMScript.call(this.getScope,this,[enclosingScopeContext]),v1819=null==scope;if(v1819)return[];for(var v1819=TypeScript.StringHashTable,v1819=JAMScript.new(v1819,[]),v1821=enclosingScopeContext.isMemberCompletion,v1821=JAMScript.call(scope.getAllSymbolNames,scope,[v1821]),i=
0,v12565=v1821.length,v12565=i<v12565;v12565;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v12565=v1821[i];var v18905=TypeScript.globalId,v18905=v12565==v18905,v18907=!v18905;v18907&&(v18905="_Core"==v12565,(v18907=!v18905)&&(v18905="_element"==v12565));v18905||JAMScript.call(v1819.add,v1819,[v12565,""]);i+=1;v12565=v1821.length;v12565=i<v12565}v1821=this.compiler;v1821=v1821.typeChecker;v1821=v1821.currentModDecl;i=this.compiler;i=i.typeChecker;i.currentModDecl=
enclosingScopeContext.deepestModuleDecl;v1819=JAMScript.call(v1819.getAllKeys,v1819,[]);enclosingScopeContext=JAMScript.call(this.getTypeNamesForNames,this,[enclosingScopeContext,v1819,scope]);scope=this.compiler;scope=scope.typeChecker;scope.currentModDecl=v1821;return enclosingScopeContext}function v1284(enclosingScopeContext){var v12572=enclosingScopeContext.enclosingObjectLit;v12572&&(v12572=enclosingScopeContext.isMemberCompletion);if(v12572)return JAMScript.call(enclosingScopeContext.getObjectLiteralScope,
enclosingScopeContext,[]);if(v12572=enclosingScopeContext.isMemberCompletion){if(v12572=enclosingScopeContext.useFullAst)return v12572=this.compiler,v12572=v12572.typeFlow,JAMScript.call(v12572.findMemberScopeAtFullAst,v12572,[enclosingScopeContext]);v12572=this.compiler;v12572=v12572.typeFlow;return JAMScript.call(v12572.findMemberScopeAt,v12572,[enclosingScopeContext])}return JAMScript.call(enclosingScopeContext.getScope,enclosingScopeContext,[])}function ScopeTraversal(compiler){this.compiler=
compiler}var v1833=ScopeTraversal.prototype;v1833.getScope=v1284;v1833=ScopeTraversal.prototype;v1833.getScopeEntries=v1285;v1833=ScopeTraversal.prototype;v1833.getTypeNamesForNames=v1286;return ScopeTraversal}function v1283(){function ScopeEntry(name,type,sym){this.name=name;this.type=type;this.sym=sym}return ScopeEntry}function v1282(){function v1281(fileName,useUTF8){try{var v12575=this.emitSettings,v1836=v12575.ioHost;return JAMScript.call(v1836.createFile,v1836,[fileName,useUTF8])}catch(ex){v12575=
this.errorReporter,v1836=ex.message,JAMScript.call(v12575.emitterError,v12575,[null,v1836])}}function v1280(scripts){for(var i=0,len=scripts.length,v1840=i<len;v1840;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v1840=scripts[i];if(v1840=JAMScript.call(this.outputScriptToUTF8,this,[v1840]))return!0;i+=1;v1840=i<len}return!1}function v1279(script){var v1841=script.containsUnicodeChar,v12577=!v1841;v12577&&(v1841=this.emitSettings,v1841=v1841.emitComments)&&(v1841=
script.containsUnicodeCharInComment);return v1841}function v1278(ioHost){function v1277(fileName,wholeFileNameReplaced){return JAMScript.call(TypeScriptCompiler.mapToFileNameExtension,TypeScriptCompiler,[".txt",fileName,wholeFileNameReplaced])}JAMScript.call(this.parseEmitOption,this,[ioHost]);var outFile=null,context=null;ioHost=0;for(var v12578=this.scripts,v12578=v12578.members,v12578=v12578.length,v1856=ioHost<v12578;v1856;){v1856=this.scripts;v1856=v1856.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v1856=
v1856[ioHost];var v18909=this.emitSettings,v18909=v18909.outputMany,v18910=!v18909;v18910&&(v18909=null==context);if(v18909){outFile=this.units;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)outFile=outFile[ioHost];outFile=outFile.filename;context=v1277;v18909=this.emitSettings;outFile=JAMScript.call(v18909.mapOutputFileName,v18909,[outFile,context]);context=JAMScript.call(this.useUTF8ForFile,this,[v1856]);outFile=JAMScript.call(this.createFile,this,[outFile,context]);
context=TypeScript.PrintContext;v18909=this.parser;context=JAMScript.new(context,[outFile,v18909])}var v18909=JAMScript.call(TypeScript.getAstWalkerFactory,TypeScript,[]),v18910=TypeScript.prePrintAST,v1852=TypeScript.postPrintAST;JAMScript.call(v18909.walk,v18909,[v1856,v18910,v1852,null,context]);v1856=this.emitSettings;if(v1856=v1856.outputMany)try{JAMScript.call(outFile.Close,outFile,[])}catch(e){v1856=this.errorReporter,v18909=e.message,JAMScript.call(v1856.emitterError,v1856,[null,v18909])}ioHost+=
1;v1856=ioHost<v12578}ioHost=this.emitSettings;ioHost=ioHost.outputMany;if(ioHost=!ioHost)try{JAMScript.call(outFile.Close,outFile,[])}catch(e$$0){ioHost=this.errorReporter,v12578=e$$0.message,JAMScript.call(ioHost.emitterError,ioHost,[null,v12578])}}function v1276(outputFile){var v12584=this.settings;if(v12584=v12584.mapSourceFiles)throw Error("Cannot generate source map");v12584=this.settings;if(v12584=v12584.generateDeclarationFiles)throw Error("Cannot generate declaration files");v12584=this.settings;
v12584=v12584.outputOption;if(v12584=""!=v12584)throw Error("Cannot parse output option");var v12584=TypeScript.Emitter,v1864=this.typeChecker,v1865=this.emitSettings,v1866=this.errorReporter;outputFile=outputFile=JAMScript.new(v12584,[v1864,"stdout",outputFile,v1865,v1866]);v12584=0;v1864=this.scripts;v1864=v1864.members;v1864=v1864.length;for(v1865=v12584<v1864;v1865;){v1865=this.scripts;v1865=v1865.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v1865=
v1865[v12584];v1866=this.typeChecker;v1866.locationInfo=v1865.locationInfo;v1866=TypeScript.TokenID;v1866=v1866.Comma;JAMScript.call(outputFile.emitJavascript,outputFile,[v1865,v1866,!1]);v12584+=1;v1865=v12584<v1864}}function v1275(ioHost){JAMScript.call(this.parseEmitOption,this,[ioHost]);var emitter=null;ioHost=0;for(var v12590=this.scripts,v12590=v12590.members,v12590=v12590.length,v1876=ioHost<v12590;v1876;){v1876=this.scripts;v1876=v1876.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v1876=
v1876[ioHost];var v18913=this.emitSettings,v18913=v18913.outputMany,v18914=!v18913;v18914&&(v18913=null==emitter);v18913?(emitter=this.emitSettings,emitter=emitter.outputMany,emitter=!emitter,emitter=JAMScript.call(this.emitUnit,this,[v1876,emitter])):JAMScript.call(this.emitUnit,this,[v1876,!0,emitter]);ioHost+=1;v1876=ioHost<v12590}emitter&&JAMScript.call(emitter.Close,emitter,[])}function v1274(script,reuseEmitter,emitter){var v18916=this.emitSettings,v18916=JAMScript.call(script.emitRequired,
script,[v18916]);if(v18916=!v18916)return null;var v18916=script.locationInfo,v18916=v18916.filename,v1890=!emitter;if(v1890){emitter=this.emitSettings;v1890=TypeScriptCompiler.mapToJSFileName;v1890=JAMScript.call(emitter.mapOutputFileName,emitter,[v18916,v1890]);emitter=JAMScript.call(this.useUTF8ForFile,this,[script]);var outFile=JAMScript.call(this.createFile,this,[v1890,emitter]);emitter=TypeScript.Emitter;var v1883=this.typeChecker,v1884=this.emitSettings,v1885=this.errorReporter;emitter=JAMScript.new(emitter,
[v1883,v1890,outFile,v1884,v1885]);v1883=this.settings;if(v1883=v1883.mapSourceFiles)v1884=v1883=TypeScript.SourceMapper,v1884=v1884.MapFileExtension,v1884=v1890+v1884,v1884=JAMScript.call(this.createFile,this,[v1884,!1]),v1885=this.errorReporter,v18916=JAMScript.new(v1883,[v18916,v1890,outFile,v1884,v1885]),JAMScript.call(emitter.setSourceMappings,emitter,[v18916])}else if(v1890=this.settings,v1890=v1890.mapSourceFiles)v1890=TypeScript.SourceMapper,outFile=emitter.emittingFileName,v1883=emitter.outfile,
v1884=emitter.sourceMapper,v1884=v1884.sourceMapOut,v1885=this.errorReporter,v18916=JAMScript.new(v1890,[v18916,outFile,v1883,v1884,v1885]),JAMScript.call(emitter.setSourceMappings,emitter,[v18916]);v18916=this.typeChecker;v18916.locationInfo=script.locationInfo;v18916=TypeScript.TokenID;v18916=v18916.Comma;JAMScript.call(emitter.emitJavascript,emitter,[script,v18916,!1]);return(script=!reuseEmitter)?(JAMScript.call(emitter.Close,emitter,[]),null):emitter}function mapToJSFileName(fileName,wholeFileNameReplaced){return JAMScript.call(TypeScriptCompiler.mapToFileNameExtension,
TypeScriptCompiler,[".js",fileName,wholeFileNameReplaced])}function mapToFileNameExtension(extension,fileName,wholeFileNameReplaced){if(wholeFileNameReplaced)return fileName;fileName=fileName.split(".");JAMScript.call(fileName.pop,fileName,[]);fileName=fileName.join(".");return fileName+extension}function v1273(){var v12606=JAMScript.call(this.canEmitDeclarations,this,[]),v12606=!v12606;if(!v12606&&(v12606=this.errorReporter,v12606=v12606.hasErrors,!v12606&&(v12606=this.scripts,v12606=v12606.members,
v12606=v12606.length,v12606=0==v12606,!v12606))){for(var declarationEmitter=null,v12606=0,v12609=this.scripts,v12609=v12609.members,v12609=v12609.length,v1902=v12606<v12609;v1902;){v1902=this.scripts;v1902=v1902.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v1902=v1902[v12606];var v18920=this.emitSettings,v18920=v18920.outputMany,v18921=!v18920;v18921&&(v18920=null==declarationEmitter);v18920?(declarationEmitter=this.emitSettings,declarationEmitter=declarationEmitter.outputMany,
declarationEmitter=!declarationEmitter,declarationEmitter=JAMScript.call(this.emitDeclarationsUnit,this,[v1902,declarationEmitter])):JAMScript.call(this.emitDeclarationsUnit,this,[v1902,!0,declarationEmitter]);v12606+=1;v1902=v12606<v12609}declarationEmitter&&JAMScript.call(declarationEmitter.Close,declarationEmitter,[])}}function v1272(script,reuseEmitter,declarationEmitter){var v12613=JAMScript.call(this.canEmitDeclarations,this,[script]);if(v12613=!v12613)return null;if(v12613=!declarationEmitter){declarationEmitter=
this.emitSettings;var v12613=script.locationInfo,v12613=v12613.filename,v1906=TypeScriptCompiler.mapToDTSFileName;declarationEmitter=JAMScript.call(declarationEmitter.mapOutputFileName,declarationEmitter,[v12613,v1906]);v12613=JAMScript.call(this.useUTF8ForFile,this,[script]);v12613=JAMScript.call(this.createFile,this,[declarationEmitter,v12613]);declarationEmitter=TypeScript.DeclarationEmitter;var v1906=this.typeChecker,v1910=this.emitSettings,v1911=this.errorReporter;declarationEmitter=JAMScript.new(declarationEmitter,
[v1906,v1910,v1911]);JAMScript.call(declarationEmitter.setDeclarationFile,declarationEmitter,[v12613])}JAMScript.call(declarationEmitter.emitDeclarations,declarationEmitter,[script]);return(script=!reuseEmitter)?(JAMScript.call(declarationEmitter.Close,declarationEmitter,[]),null):declarationEmitter}function v1271(script){var v18923=this.settings,v18923=v18923.generateDeclarationFiles;if(v18923=!v18923)return!1;v18923=!script;if(v18923=!v18923){var v18923=script.isDeclareFile,v22869=!v18923;v22869&&
(v18923=script.isResident,v22869=!v18923)&&(script=script.bod,v18923=null==script)}return(script=v18923)?!1:!0}function mapToDTSFileName(fileName,wholeFileNameReplaced){return JAMScript.call(TypeScript.getDeclareFilePath,TypeScript,[fileName])}function v1270(script){var v12617=this.emitSettings;if(v12617=v12617.outputMany)return JAMScript.call(this.outputScriptToUTF8,this,[script]);script=this.scripts;script=script.members;return JAMScript.call(this.outputScriptsToUTF8,this,[script])}function v1269(ioHost){var v1918=
this.emitSettings;v1918.ioHost=ioHost;ioHost=this.emitSettings;ioHost=ioHost.outputOption;if(ioHost=""==ioHost)ioHost=this.emitSettings,ioHost.outputMany=!0,ioHost=this.emitSettings,ioHost.commonDirectoryPath="";else{var v1918=ioHost=this.emitSettings,v1918=v1918.ioHost,v22871=this.emitSettings,v22871=v22871.outputOption,v1918=JAMScript.call(v1918.resolvePath,v1918,[v22871]),v1918=JAMScript.call(TypeScript.switchToForwardSlashes,TypeScript,[v1918]);ioHost.outputOption=v1918;ioHost=this.emitSettings;
ioHost=ioHost.ioHost;v1918=this.emitSettings;v1918=v1918.outputOption;(ioHost=JAMScript.call(ioHost.directoryExists,ioHost,[v1918]))?(ioHost=this.emitSettings,ioHost.outputMany=!0):(ioHost=this.emitSettings,ioHost=ioHost.ioHost,v1918=this.emitSettings,v1918=v1918.outputOption,(ioHost=JAMScript.call(ioHost.fileExists,ioHost,[v1918]))?(ioHost=this.emitSettings,ioHost.outputMany=!1):(v1918=ioHost=this.emitSettings,v1918=v1918.outputOption,v1918=JAMScript.call(TypeScript.isJSFile,TypeScript,[v1918]),
ioHost.outputMany=!v1918));if(ioHost=JAMScript.call(this.isDynamicModuleCompilation,this,[]))ioHost=this.emitSettings,ioHost=ioHost.outputMany,ioHost=!ioHost;ioHost&&(ioHost=this.errorReporter,JAMScript.call(ioHost.emitterError,ioHost,[null,"Cannot compile dynamic modules when emitting into single file"]));ioHost=this.emitSettings;(ioHost=ioHost.outputMany)&&JAMScript.call(this.updateCommonDirectoryPath,this,[])}}function v1268(){for(var commonComponents=[],commonComponentsLength=-1,i=0,v12628=this.scripts,
v12628=v12628.members,v12628=v12628.length,v1941=i<v12628;v1941;){v1941=this.scripts;v1941=v1941.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v1941=v1941[i];var v12630=this.emitSettings;if(v12630=JAMScript.call(v1941.emitRequired,v1941,[v12630]))if(v1941=v1941.locationInfo,v1941=v1941.filename,v1941=JAMScript.call(TypeScript.filePathComponents,TypeScript,[v1941]),v12630=-1==commonComponentsLength)commonComponents=v1941,commonComponentsLength=commonComponents.length;
else{var v12630=!1,j=0,v12631=j<commonComponentsLength;v12631&&(v12631=v1941.length,v12631=j<v12631);for(;v12631;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v12631=commonComponents[j];introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v12633=v1941[j];if(v12631=v12631!=v12633){commonComponentsLength=j;v12630=!0;if(j=0==j){commonComponents=this.errorReporter;JAMScript.call(commonComponents.emitterError,commonComponents,[null,
"Cannot find the common subdirectory path for the input files"]);return}break}j+=1;if(v12631=j<commonComponentsLength)v12631=v1941.length,v12631=j<v12631}if(v12630=!v12630)v12630=v1941.length,v12630=v12630<commonComponentsLength;v12630&&(commonComponentsLength=v1941.length)}i+=1;v1941=i<v12628}i=this.emitSettings;commonComponents=commonComponents.slice(0,commonComponentsLength);commonComponents=commonComponents.join("/");i.commonDirectoryPath=commonComponents+"/";commonComponents=this.emitSettings;
commonComponents=commonComponents.outputOption;commonComponentsLength=this.emitSettings;commonComponentsLength=commonComponentsLength.outputOption;commonComponentsLength=commonComponentsLength.length;commonComponentsLength-=1;commonComponents=commonComponents.charAt(commonComponentsLength);if(commonComponents="/"!=commonComponents)commonComponents=this.emitSettings,commonComponentsLength=commonComponents.outputOption,commonComponents.outputOption=commonComponentsLength+"/"}function v1267(){for(var i=
0,v12638=this.scripts,v12638=v12638.members,v12638=v12638.length,v1948=i<v12638;v1948;){v1948=this.scripts;v1948=v1948.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v1948=v1948[i];var v18942=v1948.isDeclareFile;if(v18942=!v18942)v1948=v1948.topLevelMod,v18942=null!=v1948;if(v1948=v18942)return!0;i+=1;v1948=i<v12638}return!1}function v1266(){function v1265(){var v12641=TypeScript.CompilerDiagnostics,v22876=TypeScript.CompilerDiagnostics,v22876=v22876.analysisPass;
v12641.analysisPass=v22876+1;v12641=_this.errorOutput;JAMScript.call(_this.initTypeChecker,_this,[v12641]);v12641=_this.persistentTypeState;v22876=TypeScript.TypeCheckCollectionMode;v22876=v22876.Transient;JAMScript.call(v12641.setCollectionMode,v12641,[v22876]);JAMScript.call(_this.cleanTypesForReTypeCheck,_this,[]);return JAMScript.call(_this.typeCheck,_this,[])}var _this=this;return JAMScript.call(this.timeFunction,this,["reTypeCheck()",v1265])}function v1264(updateResult){function v1263(){return!1}
return JAMScript.call(this.timeFunction,this,["attemptIncrementalTypeCheck()",v1263])}function v1262(){function v1261(){for(var i=0,v12643=_this.scripts,v12643=v12643.members,v12643=v12643.length,v1956=i<v12643;v1956;){v1956=_this.scripts;v1956=v1956.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v1956=v1956[i];var v1954=v1956.isResident;v1954||(JAMScript.call(_this.cleanASTTypesForReTypeCheck,_this,[v1956]),v1954=_this.typeChecker,JAMScript.call(v1954.collectTypes,
v1954,[v1956]));i+=1;v1956=i<v12643}return null}var _this=this;return JAMScript.call(this.timeFunction,this,["cleanTypesForReTypeCheck()",v1261])}function v1260(ast$$0){function cleanASTType(ast,parent){ast.type=null;var v12645=ast.nodeType,v18945=TypeScript.NodeType,v18945=v18945.VarDecl;if(v12645=v12645==v18945)v12645=ast,v12645.sym=null;else if(v12645=ast.nodeType,v18945=TypeScript.NodeType,v18945=v18945.ArgDecl,v12645=v12645==v18945)v12645=ast,v12645.sym=null;else if(v12645=ast.nodeType,v18945=
TypeScript.NodeType,v18945=v18945.Name,v12645=v12645==v18945)v12645=ast,v12645.sym=null;else if(v12645=ast.nodeType,v18945=TypeScript.NodeType,v18945=v18945.FuncDecl,v12645=v12645==v18945){v12645=ast;v12645.signature=null;var v18945=v12645,v26783=[];v18945.freeVariables=v26783;v12645.symbols=null;v12645.accessorSymbol=null;v12645.scopeType=null}else if(v12645=ast.nodeType,v18945=TypeScript.NodeType,v18945=v18945.ModuleDeclaration,v12645=v12645==v18945)v12645=ast,v12645.mod=null;else if(v12645=ast.nodeType,
v18945=TypeScript.NodeType,v18945=v18945.With,v12645=v12645==v18945)ast.withSym=null;else if(v12645=ast.nodeType,v18945=TypeScript.NodeType,v18945=v18945.Catch,v12645=v12645==v18945)ast.containedScope=null;return ast}var v1965=JAMScript.call(TypeScript.getAstWalkerFactory,TypeScript,[]);JAMScript.call(v1965.walk,v1965,[ast$$0,cleanASTType])}function v1259(){function v1258(){var v1966=TypeScript.Binder,v1967=_this.typeChecker,v1966=JAMScript.new(v1966,[v1967]),v1967=_this.typeChecker;v1967.units=_this.units;
var v1967=_this.typeChecker,v1967=v1967.globalScope,v12660=_this.typeChecker,v12660=v12660.globals;JAMScript.call(v1966.bind,v1966,[v1967,v12660]);v1967=_this.typeChecker;v1967=v1967.globalScope;v12660=_this.typeChecker;v12660=v12660.ambientGlobals;JAMScript.call(v1966.bind,v1966,[v1967,v12660]);v1967=_this.typeChecker;v1967=v1967.globalScope;v12660=_this.typeChecker;v12660=v12660.globalTypes;JAMScript.call(v1966.bind,v1966,[v1967,v12660]);v1967=_this.typeChecker;v1967=v1967.globalScope;v12660=_this.typeChecker;
v12660=v12660.ambientGlobalTypes;JAMScript.call(v1966.bind,v1966,[v1967,v12660]);var v1966=_this,v1967=TypeScript.TypeFlow,v12660=_this.logger,v18952=_this.typeChecker,v18952=v18952.globalScope,v12670=_this.parser,v12671=_this.typeChecker,v1967=JAMScript.new(v1967,[v12660,v18952,v12670,v12671]);v1966.typeFlow=v1967;v1967=0;v12660=null;v1966=_this.scripts;v1966=v1966.members;v1966=v1966.length;v1967=_this.persistentTypeState;v12660=TypeScript.TypeCheckCollectionMode;v12660=v12660.Resident;JAMScript.call(v1967.setCollectionMode,
v1967,[v12660]);v1967=0;for(v12660=v1967<v1966;v12660;){v12660=_this.scripts;v12660=v12660.members;v12660=v12660[v1967];v18952=v12660.isResident;v18952=!v18952;if(v12670=!v18952)v18952=v12660.hasBeenTypeChecked;v18952||(v18952=_this.typeFlow,JAMScript.call(v18952.assignScopes,v18952,[v12660]),v12660=_this.typeFlow,JAMScript.call(v12660.initLibs,v12660,[]));v1967+=1;v12660=v1967<v1966}v1967=0;for(v12660=v1967<v1966;v12660;){v12660=_this.scripts;v12660=v12660.members;v12660=v12660[v1967];v18952=v12660.isResident;
v18952=!v18952;if(v12670=!v18952)v18952=v12660.hasBeenTypeChecked;v18952||(v18952=_this.typeFlow,JAMScript.call(v18952.typeCheck,v18952,[v12660]),v12660.hasBeenTypeChecked=!0);v1967+=1;v12660=v1967<v1966}v1966=_this.persistentTypeState;v1967=TypeScript.TypeCheckCollectionMode;v1967=v1967.Transient;JAMScript.call(v1966.setCollectionMode,v1966,[v1967]);v1966=_this.scripts;v1966=v1966.members;v1966=v1966.length;v1967=0;for(v12660=v1967<v1966;v12660;)v12660=_this.scripts,v12660=v12660.members,v12660=
v12660[v1967],v18952=v12660.isResident,v18952||(v18952=_this.typeFlow,JAMScript.call(v18952.assignScopes,v18952,[v12660]),v12660=_this.typeFlow,JAMScript.call(v12660.initLibs,v12660,[])),v1967+=1,v12660=v1967<v1966;v1967=0;for(v12660=v1967<v1966;v12660;)v12660=_this.scripts,v12660=v12660.members,v12660=v12660[v1967],v18952=v12660.isResident,v18952||(v18952=_this.typeFlow,JAMScript.call(v18952.typeCheck,v18952,[v12660])),v1967+=1,v12660=v1967<v1966;return null}var _this=this;return JAMScript.call(this.timeFunction,
this,["typeCheck()",v1258])}function v1257(sourceText,filename){var v2002=this.parser,v2003=this.errorOutput;JAMScript.call(v2002.setErrorRecovery,v2002,[v2003]);var v2002=this.parser,v2002=JAMScript.call(v2002.parse,v2002,[sourceText,filename,0]),v2003=this.units,v2003=v2003.length,v2006=this.units;JAMScript.set(v2006,v2003,v2002.locationInfo);v2003=this.typeChecker;JAMScript.call(v2003.collectTypes,v2003,[v2002]);v2003=this.scripts;JAMScript.call(v2003.append,v2003,[v2002])}function v1256(prog,
filename){var v12682=TypeScript.StringSourceText,v12682=JAMScript.new(v12682,[prog]);return JAMScript.call(this.parseSourceUnit,this,[v12682,filename])}function v1255(sourceText,filename,keepResident,referencedFiles){function v1254(){var v2010=_this.parser,v12683=_this.units,v12683=v12683.length,v12684=TypeScript.AllowedElements,v12684=v12684.Global,v2010=JAMScript.call(v2010.parse,v2010,[sourceText,filename,v12683,v12684]);v2010.referencedFiles=referencedFiles;v2010.isResident=keepResident;v12683=
_this.persistentTypeState;keepResident?(v12684=TypeScript.TypeCheckCollectionMode,v12684=v12684.Resident):(v12684=TypeScript.TypeCheckCollectionMode,v12684=v12684.Transient);JAMScript.call(v12683.setCollectionMode,v12683,[v12684]);v12683=_this.units;v12683=v12683.length;v12684=_this.units;JAMScript.set(v12684,v12683,v2010.locationInfo);v12683=_this.typeChecker;JAMScript.call(v12683.collectTypes,v12683,[v2010]);v12683=_this.scripts;JAMScript.call(v12683.append,v12683,[v2010]);return v2010}var v12686=
typeof referencedFiles;(v12686="undefined"===v12686)&&(referencedFiles=[]);var _this=this,v12686="addSourceUnit("+filename,v12686=v12686+", ",v12686=v12686+keepResident,v12686=v12686+")";return JAMScript.call(this.timeFunction,this,[v12686,v1254])}function v1253(prog,filename,keepResident,referencedFiles){var v12688=typeof keepResident;(v12688="undefined"===v12688)&&(keepResident=!1);v12688=typeof referencedFiles;(v12688="undefined"===v12688)&&(referencedFiles=[]);v12688=TypeScript.StringSourceText;
prog=JAMScript.new(v12688,[prog]);return JAMScript.call(this.addSourceUnit,this,[prog,filename,keepResident,referencedFiles])}function v1252(sourceText,filename,setRecovery){function v1251(){function v1250(minChar,charLen,message,unitIndex){charLen=minChar+charLen;minChar=JAMScript.new(ErrorEntry,[unitIndex,minChar,charLen,message]);JAMScript.call(parseErrors.push,parseErrors,[minChar])}for(var i=0,v2025=_this.units,v2025=v2025.length,v2034=i<v2025;v2034;){v2034=_this.units;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v2034=
v2034[i];v2034=v2034.filename;if(v2034=v2034==filename){v2025=_this.scripts;v2025=v2025.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v2025=v2025[i];if(v2025=v2025.isResident)return JAMScript.call(UpdateUnitResult.noEdits,UpdateUnitResult,[i]);setRecovery&&(v2025=_this.parser,JAMScript.call(v2025.setErrorRecovery,v2025,[null]));var parseErrors=[],v2034=v1250,v2025=_this.parser;if(v2025=v2025.errorCallback){var v2029=_this.parser;v2029.errorCallback=v2034}v2034=
_this.scripts;v2034=v2034.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v2034=v2034[i];v2029=_this.parser;i=JAMScript.call(v2029.parse,v2029,[sourceText,filename,i]);v2025&&(v2029=_this.parser,v2029.errorCallback=v2025);return i=JAMScript.call(UpdateUnitResult.unknownEdits,UpdateUnitResult,[v2034,i,parseErrors])}i+=1;v2034=i<v2025}i='Unknown file "'+filename;i+='"';throw Error(i);}var _this=this,v12696="partialUpdateUnit("+filename,v12696=v12696+")";return JAMScript.call(this.timeFunction,
this,[v12696,v1251])}function v1249(updateResult){var v2051=updateResult.kind;switch(v2051){case UpdateUnitKind.NoEdits:return!1;case UpdateUnitKind.Unknown:var v2051=this.scripts,v2051=v2051.members,v2038=updateResult.unitIndex;JAMScript.set(v2051,v2038,updateResult.script2);var v2051=this.units,v2038=updateResult.unitIndex,v12698=updateResult.script2;JAMScript.set(v2051,v2038,v12698.locationInfo);v2051=0;v2038=updateResult.parseErrors;v2038=v2038.length;for(v12698=v2051<v2038;v12698;){v12698=updateResult.parseErrors;
introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v12698=v12698[v2051];var v12699=this.parser;if(v12699=v12699.errorCallback){var v12699=this.parser,v2044=v12698.minChar,v12700=v12698.limChar,v12701=v12698.minChar,v12700=v12700-v12701,v12701=v12698.message,v12698=v12698.unitIndex;JAMScript.call(v12699.errorCallback,v12699,[v2044,v12700,v12701,v12698])}v2051+=1;v12698=v2051<v2038}return!0;case UpdateUnitKind.EditsInsideSingleScope:return v2051=TypeScript.IncrementalParser,
v2038=this.logger,v2051=JAMScript.new(v2051,[v2038]),JAMScript.call(v2051.mergeTrees,v2051,[updateResult]),!0}}function v1248(sourceText,filename,setRecovery){function v1247(){var updateResult=JAMScript.call(_this.partialUpdateUnit,_this,[sourceText,filename,setRecovery]);return JAMScript.call(_this.applyUpdateResult,_this,[updateResult])}var _this=this,v12704="updateSourceUnit("+filename,v12704=v12704+")";return JAMScript.call(this.timeFunction,this,[v12704,v1247])}function v1246(prog,filename,setRecovery){var v12705=
TypeScript.StringSourceText;prog=JAMScript.new(v12705,[prog]);return JAMScript.call(this.updateSourceUnit,this,[prog,filename,setRecovery])}function v1245(fn){var v2054=this.parser;v2054.errorCallback=fn}function v1244(){var v2055=TypeScript.EmitOptions,v2056=this.settings;this.emitSettings=v2055=JAMScript.new(v2055,[v2056])}function v1243(outerr){this.errorOutput=outerr;var v2057=this.errorReporter;JAMScript.call(v2057.setErrOut,v2057,[outerr]);v2057=this.parser;v2057.outfile=outerr}function v1242(errorOutput){errorOutput=
this.persistentTypeState;JAMScript.call(errorOutput.refreshPersistentState,errorOutput,[]);errorOutput=TypeScript.TypeChecker;var v2061=this.persistentTypeState;errorOutput=this.typeChecker=errorOutput=JAMScript.new(errorOutput,[v2061]);errorOutput.errorReporter=this.errorReporter;errorOutput=this.typeChecker;v2061=this.settings;errorOutput.checkControlFlow=v2061.controlFlow;errorOutput=this.typeChecker;v2061=this.settings;errorOutput.checkControlFlowUseDef=v2061.controlFlowUseDef;errorOutput=this.typeChecker;
v2061=this.settings;errorOutput.printControlFlowGraph=v2061.printControlFlow;errorOutput=this.typeChecker;v2061=this.settings;errorOutput.errorsOnWith=v2061.errorOnWith;errorOutput=this.typeChecker;v2061=this.settings;errorOutput.styleSettings=v2061.styleSettings;errorOutput=this.typeChecker;v2061=this.settings;errorOutput.canCallDefinitionSignature=v2061.canCallDefinitionSignature;errorOutput=this.errorReporter;errorOutput.checker=this.typeChecker;errorOutput=this.errorOutput;JAMScript.call(this.setErrorOutput,
this,[errorOutput])}function v1241(funcDescription,func){var v2071=this.logger;return JAMScript.call(TypeScript.timeFunction,TypeScript,[v2071,funcDescription,func])}function TypeScriptCompiler(errorOutput,logger,settings){var v12712=typeof logger;if(v12712="undefined"===v12712)logger=TypeScript.NullLogger,logger=JAMScript.new(logger,[]);v12712=typeof settings;if(v12712="undefined"===v12712)settings=TypeScript.defaultSettings;this.errorOutput=errorOutput;this.logger=logger;this.settings=settings;
errorOutput=TypeScript.Parser;this.parser=errorOutput=JAMScript.new(errorOutput,[]);this.typeFlow=null;errorOutput=TypeScript.ASTList;this.scripts=errorOutput=JAMScript.new(errorOutput,[]);this.units=errorOutput=[];errorOutput=TypeScript.ErrorReporter;logger=this.errorOutput;this.errorReporter=errorOutput=JAMScript.new(errorOutput,[logger]);errorOutput=TypeScript.PersistentGlobalTypeState;logger=this.errorReporter;this.persistentTypeState=errorOutput=JAMScript.new(errorOutput,[logger]);errorOutput=
this.errorReporter;errorOutput.parser=this.parser;errorOutput=this.errorOutput;JAMScript.call(this.initTypeChecker,this,[errorOutput]);errorOutput=this.parser;logger=this.settings;logger=logger.styleSettings;errorOutput.style_requireSemi=logger.requireSemi;errorOutput=this.parser;logger=this.settings;logger=logger.styleSettings;errorOutput.style_funcInLoop=logger.funcInLoop;errorOutput=this.parser;logger=this.settings;errorOutput.inferPropertiesFromThisAssignment=logger.inferPropertiesFromThisAssignment;
errorOutput=TypeScript.EmitOptions;logger=this.settings;this.emitSettings=errorOutput=JAMScript.new(errorOutput,[logger]);TypeScript.codeGenTarget=settings.codeGenTarget}var v2088=TypeScriptCompiler.prototype;v2088.timeFunction=v1241;v2088=TypeScriptCompiler.prototype;v2088.initTypeChecker=v1242;v2088=TypeScriptCompiler.prototype;v2088.setErrorOutput=v1243;v2088=TypeScriptCompiler.prototype;v2088.emitCommentsToOutput=v1244;v2088=TypeScriptCompiler.prototype;v2088.setErrorCallback=v1245;v2088=TypeScriptCompiler.prototype;
v2088.updateUnit=v1246;v2088=TypeScriptCompiler.prototype;v2088.updateSourceUnit=v1248;v2088=TypeScriptCompiler.prototype;v2088.applyUpdateResult=v1249;v2088=TypeScriptCompiler.prototype;v2088.partialUpdateUnit=v1252;v2088=TypeScriptCompiler.prototype;v2088.addUnit=v1253;v2088=TypeScriptCompiler.prototype;v2088.addSourceUnit=v1255;v2088=TypeScriptCompiler.prototype;v2088.parseUnit=v1256;v2088=TypeScriptCompiler.prototype;v2088.parseSourceUnit=v1257;v2088=TypeScriptCompiler.prototype;v2088.typeCheck=
v1259;v2088=TypeScriptCompiler.prototype;v2088.cleanASTTypesForReTypeCheck=v1260;v2088=TypeScriptCompiler.prototype;v2088.cleanTypesForReTypeCheck=v1262;v2088=TypeScriptCompiler.prototype;v2088.attemptIncrementalTypeCheck=v1264;v2088=TypeScriptCompiler.prototype;v2088.reTypeCheck=v1266;v2088=TypeScriptCompiler.prototype;v2088.isDynamicModuleCompilation=v1267;v2088=TypeScriptCompiler.prototype;v2088.updateCommonDirectoryPath=v1268;v2088=TypeScriptCompiler.prototype;v2088.parseEmitOption=v1269;v2088=
TypeScriptCompiler.prototype;v2088.useUTF8ForFile=v1270;TypeScriptCompiler.mapToDTSFileName=mapToDTSFileName;v2088=TypeScriptCompiler.prototype;v2088.canEmitDeclarations=v1271;v2088=TypeScriptCompiler.prototype;v2088.emitDeclarationsUnit=v1272;v2088=TypeScriptCompiler.prototype;v2088.emitDeclarations=v1273;TypeScriptCompiler.mapToFileNameExtension=mapToFileNameExtension;TypeScriptCompiler.mapToJSFileName=mapToJSFileName;v2088=TypeScriptCompiler.prototype;v2088.emitUnit=v1274;v2088=TypeScriptCompiler.prototype;
v2088.emit=v1275;v2088=TypeScriptCompiler.prototype;v2088.emitToOutfile=v1276;v2088=TypeScriptCompiler.prototype;v2088.emitAST=v1278;v2088=TypeScriptCompiler.prototype;v2088.outputScriptToUTF8=v1279;v2088=TypeScriptCompiler.prototype;v2088.outputScriptsToUTF8=v1280;v2088=TypeScriptCompiler.prototype;v2088.createFile=v1281;return TypeScriptCompiler}function v1240(){function ErrorEntry(unitIndex,minChar,limChar,message){this.unitIndex=unitIndex;this.minChar=minChar;this.limChar=limChar;this.message=
message}return ErrorEntry}function v1239(){function singleScopeEdits(script1,script2,scope1,scope2,editRange,parseErrors){var v2120=UpdateUnitKind.EditsInsideSingleScope,v12717=script1.locationInfo,v12717=v12717.unitIndex;script1=new UpdateUnitResult(v2120,v12717,script1,script2);script1.scope1=scope1;script1.scope2=scope2;script1.editRange=editRange;script1.parseErrors=parseErrors;return script1}function unknownEdits(script1,script2,parseErrors){var v2122=UpdateUnitKind.Unknown,v12718=script1.locationInfo,
v12718=v12718.unitIndex;script1=new UpdateUnitResult(v2122,v12718,script1,script2);script1.parseErrors=parseErrors;return script1}function noEdits(unitIndex){var v2124=UpdateUnitKind.NoEdits;return new UpdateUnitResult(v2124,unitIndex,null,null)}function UpdateUnitResult(kind,unitIndex,script1,script2){this.kind=kind;this.unitIndex=unitIndex;this.script1=script1;this.script2=script2;this.editRange=this.scope2=this.scope1=null;this.parseErrors=[]}UpdateUnitResult.noEdits=noEdits;UpdateUnitResult.unknownEdits=
unknownEdits;UpdateUnitResult.singleScopeEdits=singleScopeEdits;return UpdateUnitResult}function v1238(){function v1237(){var v25746=this.minChar,v25746="editRange(minChar="+v25746,v25746=v25746+", limChar=",v22881=this.limChar,v25746=v25746+v22881,v25746=v25746+", delta=",v22881=this.delta,v25746=v25746+v22881;return v25746+")"}function v1236(pos){var v18965=this.minChar;if(v18965=v18965<=pos)v18965=this.limChar,v18965=pos<v18965;var v12723=!v18965;v12723&&(v18965=this.minChar,v18965=v18965<=pos)&&
(v18965=this.limChar,v12723=this.delta,v18965+=v12723,v18965=pos<v18965);return v18965}function v1235(){var v12724=this.minChar;if(v12724=-1===v12724)if(v12724=this.limChar,v12724=-1===v12724)v12724=this.delta,v12724=-1===v12724;return v12724}function unknown(){return new ScriptEditRange(-1,-1,-1)}function ScriptEditRange(minChar,limChar,delta){this.minChar=minChar;this.limChar=limChar;this.delta=delta}ScriptEditRange.unknown=unknown;var v2128=ScriptEditRange.prototype;v2128.isUnknown=v1235;v2128=
ScriptEditRange.prototype;v2128.containsPosition=v1236;v2128=ScriptEditRange.prototype;v2128.toString=v1237;return ScriptEditRange}function v1234(UpdateUnitKind){UpdateUnitKind._map=[];var v2131=UpdateUnitKind._map;v2131[0]="Unknown";UpdateUnitKind.Unknown=0;v2131=UpdateUnitKind._map;v2131[1]="NoEdits";UpdateUnitKind.NoEdits=1;v2131=UpdateUnitKind._map;v2131[2]="EditsInsideSingleScope";UpdateUnitKind.EditsInsideSingleScope=2}var v12726=TypeScript.UpdateUnitKind,v18971=!v12726;v18971&&(v12726=TypeScript.UpdateUnitKind=
{});v1234(v12726);var UpdateUnitKind=TypeScript.UpdateUnitKind,v12726=v1238();TypeScript.ScriptEditRange=v12726;var UpdateUnitResult=v1239();TypeScript.UpdateUnitResult=UpdateUnitResult;var ErrorEntry=v1240();TypeScript.ErrorEntry=ErrorEntry;v12726=TypeScript;v18971=TypeScript.CompilationSettings;v18971=JAMScript.new(v18971,[]);v12726.defaultSettings=v18971;v12726=v1282();TypeScript.TypeScriptCompiler=v12726;var ScopeEntry=v1283();TypeScript.ScopeEntry=ScopeEntry;v12726=v1287();TypeScript.ScopeTraversal=
v12726}
function v1233(){var TypeScript=v12371;function v1232(){function v1231(pre,ast){var v12728=ast.flags,v18972=TypeScript.ASTFlags,v18972=v18972.IsStatement,v12728=JAMScript.call(TypeScript.hasFlag,TypeScript,[v12728,v18972]);return!v12728}function v1230(pre,script){if(pre){var v12730=this.emitOptions;if(v12730=v12730.outputMany)for(var v12730=0,v18973=script.referencedFiles,v18973=v18973.length,v18973=v12730<v18973;v18973;){v18973=script.referencedFiles;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v18973=v18973[v12730];
var v18973=v18973.path,declareFileName;if(declareFileName=JAMScript.call(TypeScript.isRooted,TypeScript,[v18973])){declareFileName=this.emitOptions;var v12733=TypeScript.TypeScriptCompiler,v12733=v12733.mapToDTSFileName;declareFileName=JAMScript.call(declareFileName.mapOutputFileName,declareFileName,[v18973,v12733])}else{v18973=script.referencedFiles;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v18973=v18973[v12730];v18973=v18973.path;declareFileName=JAMScript.call(TypeScript.getDeclareFilePath,
TypeScript,[v18973])}v18973=this.declFile;declareFileName='/// <reference path="'+declareFileName;declareFileName+='" />';JAMScript.call(v18973.WriteLine,v18973,[declareFileName]);v12730+=1;v18973=script.referencedFiles;v18973=v18973.length;v18973=v12730<v18973}JAMScript.call(this.pushDeclarationContainer,this,[script])}else JAMScript.call(this.popDeclarationContainer,this,[script]);return!0}function v1229(pre,moduleDecl){var v12737=moduleDecl.modFlags,v18976=TypeScript.ModuleFlags,v12738=v18976.IsWholeFile,
v2165=JAMScript.call(TypeScript.hasFlag,TypeScript,[v12737,v12738]);if(v2165){var v12739=moduleDecl.modFlags,v18977=TypeScript.ModuleFlags,v12740=v18977.IsDynamic,v2164=JAMScript.call(TypeScript.hasFlag,TypeScript,[v12739,v12740]);if(v2164)if(pre){var v18978=this.emitOptions,v12741=v18978.outputMany,v2155=!v12741;if(v2155){this.singleDeclFile=this.declFile;var v2146=TypeScript.CompilerDiagnostics,v18979=this.indenter,v12742=v18979.indentAmt,v2147=0==v12742;JAMScript.call(v2146.assert,v2146,[v2147,
"Indent has to be 0 when outputing new file"]);var v2148=this.emitOptions,v22884=moduleDecl.name,v18980=v22884.sym,v12743=v18980.name,v2149=JAMScript.call(TypeScript.stripQuotes,TypeScript,[v12743]),v12744=TypeScript.TypeScriptCompiler,v2150=v12744.mapToDTSFileName,declareFileName=JAMScript.call(v2148.mapOutputFileName,v2148,[v2149,v2150]),v2151=moduleDecl.containsUnicodeChar,v12746=!v2151;if(v12746){var v18981=this.emitOptions,v12745=v18981.emitComments;v12745&&(v12745=moduleDecl.containsUnicodeCharInComment);
v2151=v12745}var useUTF8InOutputfile=v2151;try{var v18982=this.emitOptions,v12747=v18982.ioHost,v2152=JAMScript.call(v12747.createFile,v12747,[declareFileName,useUTF8InOutputfile]),v26794=JAMScript.new(DeclFileWriter,[v2152]);this.declFile=v26794}catch(ex){var v2153=this.errorReporter,v2154=ex.message;JAMScript.call(v2153.emitterError,v2153,[null,v2154])}}JAMScript.call(this.pushDeclarationContainer,this,[moduleDecl])}else{var v18983=this.emitOptions,v12748=v18983.outputMany,v2163=!v12748;if(v2163){var v2156=
TypeScript.CompilerDiagnostics,v12749=this.singleDeclFile,v12750=this.declFile,v2157=v12749!=v12750;JAMScript.call(v2156.assert,v2156,[v2157,"singleDeclFile cannot be null as we are going to revert back to it"]);var v2158=TypeScript.CompilerDiagnostics,v18984=this.indenter,v12751=v18984.indentAmt,v2159=0==v12751;JAMScript.call(v2158.assert,v2158,[v2159,"Indent has to be 0 when outputing new file"]);try{var v2160=this.declFile;JAMScript.call(v2160.Close,v2160,[])}catch(ex$$0){var v2161=this.errorReporter,
v2162=ex$$0.message;JAMScript.call(v2161.emitterError,v2161,[null,v2162])}this.declFile=this.singleDeclFile}JAMScript.call(this.popDeclarationContainer,this,[moduleDecl])}return!0}var v2166=JAMScript.call(moduleDecl.isEnum,moduleDecl,[]);if(v2166)return pre&&JAMScript.call(this.emitEnumSignature,this,[moduleDecl]),!1;var v22885=moduleDecl.modFlags,v18985=JAMScript.call(TypeScript.ToDeclFlags,TypeScript,[v22885]),v12752=JAMScript.call(this.canEmitPrePostAstSignature,this,[v18985,moduleDecl,pre]),v2167=
!v12752;if(v2167)return!1;if(pre){var v2169=JAMScript.call(this.emitDottedModuleName,this,[]);if(v2169){var v12753=this.dottedModuleEmit;this.dottedModuleEmit=v12753+"."}else{var v12754=moduleDecl.modFlags,v2168=JAMScript.call(TypeScript.ToDeclFlags,TypeScript,[v12754]),v26795=JAMScript.call(this.getDeclFlagsString,this,[v2168,"module"]);this.dottedModuleEmit=v26795}var v12755=this.dottedModuleEmit,v18986=moduleDecl.name,v12756=v18986.text;this.dottedModuleEmit=v12755+v12756;var v22886=moduleDecl.members,
v18987=v22886.members,v12757=v18987.length,v2170=1==v12757;if(v2170){var v25747=moduleDecl.members,v24799=v25747.members,v22887=v24799[0],v18988=v22887.nodeType,v22888=TypeScript.NodeType,v18989=v22888.ModuleDeclaration,v12758=v18988==v18989;if(v12758){var v26257=moduleDecl.members,v25748=v26257.members,v24800=v25748[0],v22889=JAMScript.call(v24800.isEnum,v24800,[]),v18990=!v22889;if(v18990)var v26258=moduleDecl.members,v25749=v26258.members,v24801=v25749[0],v22890=v24801.modFlags,v24802=TypeScript.ModuleFlags,
v22891=v24802.Exported,v18990=JAMScript.call(TypeScript.hasFlag,TypeScript,[v22890,v22891]);v12758=v18990}v2170=v12758}var isCurrentModuleDotted=v2170,moduleDeclComments=JAMScript.call(moduleDecl.getDocComments,moduleDecl,[]),v2171=isCurrentModuleDotted;if(v2171){var v12759=null==moduleDeclComments,v18992=!v12759;if(v18992)var v18991=moduleDeclComments.length,v12759=0==v18991;v2171=v12759}var isCurrentModuleDotted=v2171,v2172=this.isDottedModuleName;JAMScript.call(v2172.push,v2172,[isCurrentModuleDotted]);
JAMScript.call(this.pushDeclarationContainer,this,[moduleDecl]);var v2177=!isCurrentModuleDotted;if(v2177){JAMScript.call(this.emitDeclarationComments,this,[moduleDecl]);var v2173=this.declFile,v2174=this.dottedModuleEmit;JAMScript.call(v2173.Write,v2173,[v2174]);var v2175=this.declFile;JAMScript.call(v2175.WriteLine,v2175,[" {"]);var v2176=this.indenter;JAMScript.call(v2176.increaseIndent,v2176,[])}}else{var v12760=JAMScript.call(this.emitDottedModuleName,this,[]),v2180=!v12760;if(v2180){var v2178=
this.indenter;JAMScript.call(v2178.decreaseIndent,v2178,[]);JAMScript.call(this.emitIndent,this,[]);var v2179=this.declFile;JAMScript.call(v2179.WriteLine,v2179,["}"])}JAMScript.call(this.popDeclarationContainer,this,[moduleDecl]);var v2181=this.isDottedModuleName;JAMScript.call(v2181.pop,v2181,[])}return!0}function v1228(moduleDecl){var v22892=moduleDecl.modFlags,v22892=JAMScript.call(TypeScript.ToDeclFlags,TypeScript,[v22892]),v22892=JAMScript.call(this.canEmitSignature,this,[v22892]);if(v22892=
!v22892)return!1;JAMScript.call(this.emitDeclarationComments,this,[moduleDecl]);v22892=moduleDecl.modFlags;v22892=JAMScript.call(TypeScript.ToDeclFlags,TypeScript,[v22892]);JAMScript.call(this.emitDeclFlags,this,[v22892,"enum"]);var v22892=this.declFile,v18994=moduleDecl.name,v18994=v18994.text,v18994=v18994+" {";JAMScript.call(v22892.WriteLine,v22892,[v18994]);v22892=this.indenter;JAMScript.call(v22892.increaseIndent,v22892,[]);for(var v22892=moduleDecl.members,v22892=v22892.members,v22892=v22892.length,
v18994=1,v2194=v18994<v22892;v2194;){v2194=moduleDecl.members;v2194=v2194.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v2194=v2194[v18994];var v12766=v2194.nodeType,v18995=TypeScript.NodeType,v18995=v18995.VarDecl;(v12766=v12766==v18995)?(JAMScript.call(this.emitDeclarationComments,this,[v2194]),JAMScript.call(this.emitIndent,this,[]),v12766=this.declFile,v2194=v2194.id,v2194=v2194.text,v2194+=",",JAMScript.call(v12766.WriteLine,v12766,[v2194])):(v12766=
TypeScript.CompilerDiagnostics,v2194=v2194.nodeType,v18995=TypeScript.NodeType,v18995=v18995.Asg,v2194=v2194!=v18995,JAMScript.call(v12766.assert,v12766,[v2194,"We want to catch this"]));v18994+=1;v2194=v18994<v22892}moduleDecl=this.indenter;JAMScript.call(moduleDecl.decreaseIndent,moduleDecl,[]);JAMScript.call(this.emitIndent,this,[]);moduleDecl=this.declFile;JAMScript.call(moduleDecl.WriteLine,moduleDecl,["}"]);return!1}function v1227(pre,importDecl){if(pre){var v18998=this.declarationContainerStack,
v18998=v18998[0],v18999=importDecl.id,v18999=v18999.sym;if(v18998=JAMScript.call(v18998.isExternallyVisibleSymbol,v18998,[v18999]))JAMScript.call(this.emitDeclarationComments,this,[importDecl]),JAMScript.call(this.emitIndent,this,[]),v18998=this.declFile,JAMScript.call(v18998.Write,v18998,["import "]),v18998=this.declFile,v18999=importDecl.id,v18999=v18999.text,v18999+=" = ",JAMScript.call(v18998.Write,v18998,[v18999]),(v18998=importDecl.isDynamicImport)?(v18998=this.declFile,v18999=JAMScript.call(importDecl.getAliasName,
importDecl,[]),v18999="module ("+v18999,v18999+=");"):(v18998=this.declFile,v18999=JAMScript.call(importDecl.getAliasName,importDecl,[]),v18999+=";"),JAMScript.call(v18998.WriteLine,v18998,[v18999])}return!1}function v1226(pre,interfaceDecl){var v22893=interfaceDecl.varFlags,v22893=JAMScript.call(TypeScript.ToDeclFlags,TypeScript,[v22893]),v22893=JAMScript.call(this.canEmitPrePostAstSignature,this,[v22893,interfaceDecl,pre]);if(v22893=!v22893)return!1;if(pre){v22893=interfaceDecl.name;v22893=v22893.text;
JAMScript.call(this.emitDeclarationComments,this,[interfaceDecl]);var v12777=interfaceDecl.varFlags,v12777=JAMScript.call(TypeScript.ToDeclFlags,TypeScript,[v12777]);JAMScript.call(this.emitDeclFlags,this,[v12777,"interface"]);v12777=this.declFile;JAMScript.call(v12777.Write,v12777,[v22893]);v22893=interfaceDecl.extendsList;JAMScript.call(this.emitBaseList,this,[v22893,"extends"]);v22893=this.declFile;JAMScript.call(v22893.WriteLine,v22893,[" {"]);v22893=this.indenter;JAMScript.call(v22893.increaseIndent,
v22893,[]);JAMScript.call(this.pushDeclarationContainer,this,[interfaceDecl])}else v22893=this.indenter,JAMScript.call(v22893.decreaseIndent,v22893,[]),JAMScript.call(this.popDeclarationContainer,this,[interfaceDecl]),JAMScript.call(this.emitIndent,this,[]),v22893=this.declFile,JAMScript.call(v22893.WriteLine,v22893,["}"]);return!0}function v1225(pre,classDecl){var v22894=classDecl.varFlags,v22894=JAMScript.call(TypeScript.ToDeclFlags,TypeScript,[v22894]),v22894=JAMScript.call(this.canEmitPrePostAstSignature,
this,[v22894,classDecl,pre]);if(v22894=!v22894)return!1;if(pre){v22894=classDecl.name;v22894=v22894.text;JAMScript.call(this.emitDeclarationComments,this,[classDecl]);var v12779=classDecl.varFlags,v12779=JAMScript.call(TypeScript.ToDeclFlags,TypeScript,[v12779]);JAMScript.call(this.emitDeclFlags,this,[v12779,"class"]);v12779=this.declFile;JAMScript.call(v12779.Write,v12779,[v22894]);v22894=classDecl.extendsList;JAMScript.call(this.emitBaseList,this,[v22894,"extends"]);v22894=classDecl.implementsList;
JAMScript.call(this.emitBaseList,this,[v22894,"implements"]);v22894=this.declFile;JAMScript.call(v22894.WriteLine,v22894,[" {"]);JAMScript.call(this.pushDeclarationContainer,this,[classDecl]);v22894=this.indenter;JAMScript.call(v22894.increaseIndent,v22894,[]);if(v22894=classDecl.constructorDecl)v22894=classDecl.constructorDecl,JAMScript.call(this.emitClassMembersFromConstructorDefinition,this,[v22894])}else v22894=this.indenter,JAMScript.call(v22894.decreaseIndent,v22894,[]),JAMScript.call(this.popDeclarationContainer,
this,[classDecl]),JAMScript.call(this.emitIndent,this,[]),v22894=this.declFile,JAMScript.call(v22894.WriteLine,v22894,["}"]);return!0}function v1224(funcDecl){var v2239=funcDecl.arguments;if(v2239){var v2239=funcDecl.arguments,v2239=v2239.members,v2239=v2239.length,v2228=funcDecl.variableArgList;v2228&&(v2239-=1);for(var v2228=0,v2238=v2228<v2239;v2238;){v2238=funcDecl.arguments;v2238=v2238.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v2238=v2238[v2228];
var v12782=v2238.varFlags,v19004=TypeScript.VarFlags,v19004=v19004.Property;if(v12782=JAMScript.call(TypeScript.hasFlag,TypeScript,[v12782,v19004])){JAMScript.call(this.emitDeclarationComments,this,[v2238]);v12782=v2238.varFlags;v12782=JAMScript.call(TypeScript.ToDeclFlags,TypeScript,[v12782]);JAMScript.call(this.emitDeclFlags,this,[v12782,"var"]);v12782=this.declFile;v19004=v2238.id;v19004=v19004.text;JAMScript.call(v12782.Write,v12782,[v19004]);if(v12782=v2238.typeExpr)v12782=v2238.varFlags,v12782=
JAMScript.call(TypeScript.ToDeclFlags,TypeScript,[v12782]),v12782=JAMScript.call(this.canEmitTypeAnnotationSignature,this,[v12782]);v12782&&(v12782=this.declFile,JAMScript.call(v12782.Write,v12782,[": "]),v2238=v2238.type,JAMScript.call(this.emitTypeSignature,this,[v2238]));v2238=this.declFile;JAMScript.call(v2238.WriteLine,v2238,[";"])}v2228+=1;v2238=v2228<v2239}}}function v1223(funcDecl){var accessorSymbol=funcDecl.accessorSymbol,v12787=accessorSymbol.getter;v12787&&(v12787=accessorSymbol.getter,
v12787=v12787.declAST,v12787=v12787!=funcDecl);if(v12787)return!1;JAMScript.call(this.emitDeclarationComments,this,[accessorSymbol]);v12787=accessorSymbol.flags;v12787=JAMScript.call(TypeScript.ToDeclFlags,TypeScript,[v12787]);JAMScript.call(this.emitDeclFlags,this,[v12787,"var"]);v12787=this.declFile;funcDecl=funcDecl.name;funcDecl=funcDecl.text;JAMScript.call(v12787.Write,v12787,[funcDecl]);funcDecl=JAMScript.call(accessorSymbol.getType,accessorSymbol,[]);accessorSymbol=accessorSymbol.flags;accessorSymbol=
JAMScript.call(TypeScript.ToDeclFlags,TypeScript,[accessorSymbol]);if(accessorSymbol=JAMScript.call(this.canEmitTypeAnnotationSignature,this,[accessorSymbol]))accessorSymbol=this.declFile,JAMScript.call(accessorSymbol.Write,accessorSymbol,[" : "]),JAMScript.call(this.emitTypeSignature,this,[funcDecl]);accessorSymbol=this.declFile;JAMScript.call(accessorSymbol.WriteLine,accessorSymbol,[";"]);return!1}function v1222(bases,qual){var v12791=bases;v12791&&(v12791=bases.members,v12791=v12791.length,v12791=
0<v12791);if(v12791){var v12791=this.declFile,v12792=" "+qual,v12792=v12792+" ";JAMScript.call(v12791.Write,v12791,[v12792]);for(var v12791=bases.members,v12791=v12791.length,v12792=0,v2254=v12792<v12791;v2254;){v2254=bases.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v2254=v2254[v12792];var v2254=v2254.type,v2253=0<v12792;v2253&&(v2253=this.declFile,JAMScript.call(v2253.Write,v2253,[", "]));JAMScript.call(this.emitTypeSignature,this,[v2254]);v12792+=
1;v2254=v12792<v12791}}}function v1221(pre,funcDecl){var v2256=!pre;if(v2256)return!1;var v2257=JAMScript.call(funcDecl.isAccessor,funcDecl,[]);if(v2257)return JAMScript.call(this.emitPropertyAccessorSignature,this,[funcDecl]);var v12793=JAMScript.call(this.getAstDeclarationContainer,this,[]),v2258=v12793.nodeType,v12794=TypeScript.NodeType,v2259=v12794.InterfaceDeclaration,isInterfaceMember=v2258==v2259,v2269=funcDecl.bod;if(v2269){var v2262=funcDecl.isConstructor;if(v2262){var v19009=funcDecl.type,
v12795=v19009.construct;if(v12795)var v25750=funcDecl.type,v24803=v25750.construct,v22898=v24803.signatures,v19010=v22898.length,v12795=1<v19010;var v2260=v12795;if(v2260)return!1}else{var v19011=funcDecl.type,v12796=v19011.call;if(v12796)var v25751=funcDecl.type,v24804=v25751.call,v22899=v24804.signatures,v19012=v22899.length,v12796=1<v19012;var v2261=v12796;if(v2261)return!1}}else{var v12797=!isInterfaceMember;if(v12797){var v22900=funcDecl.fncFlags,v24805=TypeScript.FncFlags,v22901=v24805.Private,
v19013=JAMScript.call(TypeScript.hasFlag,TypeScript,[v22900,v22901]);if(v19013){var v24806=funcDecl.type,v22902=v24806.call;if(v22902)var v26510=funcDecl.type,v26259=v26510.call,v25752=v26259.signatures,v24807=v25752.length,v22902=1<v24807;v19013=v22902}v12797=v19013}var v2268=v12797;if(v2268){var v12798=funcDecl.type,v2263=v12798.call,signatures=v2263.signatures,v2264=signatures[0],firstSignature=v2264.declAST,v2266=firstSignature.bod;if(v2266)var v2265=signatures[1],firstSignature=v2265.declAST;
var v2267=firstSignature!=funcDecl;if(v2267)return!1}}var v22903=funcDecl.fncFlags,v19014=JAMScript.call(TypeScript.ToDeclFlags,TypeScript,[v22903]),v12799=JAMScript.call(this.canEmitSignature,this,[v19014,!1]),v2270=!v12799;if(v2270)return!1;JAMScript.call(this.emitDeclarationComments,this,[funcDecl]);var v2281=funcDecl.isConstructor;if(v2281){JAMScript.call(this.emitIndent,this,[]);var v2271=this.declFile;JAMScript.call(v2271.Write,v2271,["constructor"])}else{var id=JAMScript.call(funcDecl.getNameText,
funcDecl,[]),v2280=!isInterfaceMember;if(v2280){var v12800=funcDecl.fncFlags,v2272=JAMScript.call(TypeScript.ToDeclFlags,TypeScript,[v12800]);JAMScript.call(this.emitDeclFlags,this,[v2272,"function"]);var v2273=this.declFile;JAMScript.call(v2273.Write,v2273,[id])}else{JAMScript.call(this.emitIndent,this,[]);var v2279=JAMScript.call(funcDecl.isConstructMember,funcDecl,[]);if(v2279){var v2274=this.declFile;JAMScript.call(v2274.Write,v2274,["new"])}else{var v19015=JAMScript.call(funcDecl.isCallMember,
funcDecl,[]),v12801=!v19015;if(v12801)var v19016=JAMScript.call(funcDecl.isIndexerMember,funcDecl,[]),v12801=!v19016;var v2278=v12801;if(v2278){var v2275=this.declFile;JAMScript.call(v2275.Write,v2275,[id]);var v19017=funcDecl.name,v12802=v19017.flags,v19018=TypeScript.ASTFlags,v12803=v19018.OptionalName,v2277=JAMScript.call(TypeScript.hasFlag,TypeScript,[v12802,v12803]);if(v2277){var v2276=this.declFile;JAMScript.call(v2276.Write,v2276,["? "])}}}}}var v12804=JAMScript.call(funcDecl.isIndexerMember,
funcDecl,[]),v2284=!v12804;if(v2284){var v2282=this.declFile;JAMScript.call(v2282.Write,v2282,["("])}else{var v2283=this.declFile;JAMScript.call(v2283.Write,v2283,["["])}var v2285=this.indenter;JAMScript.call(v2285.increaseIndent,v2285,[]);var v2292=funcDecl.arguments;if(v2292){var v12805=funcDecl.arguments,v2286=v12805.members,argsLen=v2286.length,v2287=funcDecl.variableArgList;v2287&&(argsLen-=1);for(var i=0,v2291=i<argsLen;v2291;){var v12806=funcDecl.arguments,v2288=v12806.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var argDecl=
v2288[i];JAMScript.call(this.emitArgDecl,this,[argDecl,funcDecl]);var v12807=argsLen-1,v2290=i<v12807;if(v2290){var v2289=this.declFile;JAMScript.call(v2289.Write,v2289,[", "])}i+=1;v2291=i<argsLen}}var v2298=funcDecl.variableArgList;if(v2298){var v12808=funcDecl.arguments,v2293=v12808.members,v22904=funcDecl.arguments,v19019=v22904.members,v12809=v19019.length,v2294=v12809-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var lastArg=v2293[v2294];var v22905=funcDecl.arguments,
v19020=v22905.members,v12810=v19020.length,v2297=1<v12810;if(v2297){var v2295=this.declFile;JAMScript.call(v2295.Write,v2295,[", ..."])}else{var v2296=this.declFile;JAMScript.call(v2296.Write,v2296,["..."])}JAMScript.call(this.emitArgDecl,this,[lastArg,funcDecl])}var v2299=this.indenter;JAMScript.call(v2299.decreaseIndent,v2299,[]);var v12811=JAMScript.call(funcDecl.isIndexerMember,funcDecl,[]),v2302=!v12811;if(v2302){var v2300=this.declFile;JAMScript.call(v2300.Write,v2300,[")"])}else{var v2301=
this.declFile;JAMScript.call(v2301.Write,v2301,["]"])}var v19021=funcDecl.isConstructor,v12812=!v19021;if(v12812){var v22906=funcDecl.returnTypeAnnotation,v24810=!v22906;if(v24810)var v26260=funcDecl.signature,v25753=v26260.returnType,v24808=v25753.type,v25754=this.checker,v24809=v25754.anyType,v22906=v24808!=v24809;var v19022=v22906;if(v19022)var v24811=funcDecl.fncFlags,v22907=JAMScript.call(TypeScript.ToDeclFlags,TypeScript,[v24811]),v19022=JAMScript.call(this.canEmitTypeAnnotationSignature,this,
[v22907]);v12812=v19022}var v2305=v12812;if(v2305){var v2303=this.declFile;JAMScript.call(v2303.Write,v2303,[": "]);var v19023=funcDecl.signature,v12813=v19023.returnType,v2304=v12813.type;JAMScript.call(this.emitTypeSignature,this,[v2304])}var v2306=this.declFile;JAMScript.call(v2306.WriteLine,v2306,[";"]);return!1}function v1220(argDecl,funcDecl){JAMScript.call(this.emitDeclarationComments,this,[argDecl,!1]);var v2307=this.declFile,v12814=argDecl.id,v12814=v12814.text;JAMScript.call(v2307.Write,
v2307,[v12814]);if(v2307=JAMScript.call(argDecl.isOptionalArg,argDecl,[]))v2307=this.declFile,JAMScript.call(v2307.Write,v2307,["?"]);v2307=argDecl.typeExpr;if(v12814=!v2307)v2307=argDecl.type,v12814=this.checker,v12814=v12814.anyType,v2307=v2307!=v12814;v2307&&(v2307=funcDecl.fncFlags,v2307=JAMScript.call(TypeScript.ToDeclFlags,TypeScript,[v2307]),v2307=JAMScript.call(this.canEmitTypeAnnotationSignature,this,[v2307]));v2307&&(v2307=this.declFile,JAMScript.call(v2307.Write,v2307,[": "]),v2307=argDecl.type,
JAMScript.call(this.emitTypeSignature,this,[v2307]))}function v1219(pre,block){var v12816=block.isStatementBlock;return(v12816=!v12816)?(pre?(v12816=block.statements,v12816=v12816.members,this.varListCount=v12816.length):this.varListCount=0,!0):!1}function v1218(pre,varDecl){var v12818=pre;v12818&&(v12818=varDecl.varFlags,v12818=JAMScript.call(TypeScript.ToDeclFlags,TypeScript,[v12818]),v12818=JAMScript.call(this.canEmitSignature,this,[v12818,!1]));if(v12818){var v12818=JAMScript.call(this.getAstDeclarationContainer,
this,[]),v12818=v12818.nodeType,v12820=TypeScript.NodeType,v12820=v12820.InterfaceDeclaration,v12818=v12818==v12820;JAMScript.call(this.emitDeclarationComments,this,[varDecl]);if(v12818=!v12818){v12818=this.varListCount;if(v12818=0<=v12818)v12818=varDecl.varFlags,v12818=JAMScript.call(TypeScript.ToDeclFlags,TypeScript,[v12818]),JAMScript.call(this.emitDeclFlags,this,[v12818,"var"]),v12818=this.varListCount,this.varListCount=-v12818;v12818=this.declFile;v12820=varDecl.id;v12820=v12820.text;JAMScript.call(v12818.Write,
v12818,[v12820])}else if(JAMScript.call(this.emitIndent,this,[]),v12818=this.declFile,v12820=varDecl.id,v12820=v12820.text,JAMScript.call(v12818.Write,v12818,[v12820]),v12818=varDecl.id,v12818=v12818.flags,v12820=TypeScript.ASTFlags,v12820=v12820.OptionalName,v12818=JAMScript.call(TypeScript.hasFlag,TypeScript,[v12818,v12820]))v12818=this.declFile,JAMScript.call(v12818.Write,v12818,["?"]);v12818=null;if(v12820=varDecl.typeExpr)v12820=varDecl.typeExpr,v12820=v12820.type;if(v12820)v12818=varDecl.typeExpr,
v12818=v12818.type;else if(v12820=varDecl.sym)v12818=varDecl.sym,v12818=JAMScript.call(v12818.getType,v12818,[]),v12820=this.checker,v12820=v12820.anyType,(v12820=v12818==v12820)&&(v12818=null);if(v12820=v12818)v12820=varDecl.varFlags,v12820=JAMScript.call(TypeScript.ToDeclFlags,TypeScript,[v12820]),v12820=JAMScript.call(this.canEmitTypeAnnotationSignature,this,[v12820]);v12820&&(v12820=this.declFile,JAMScript.call(v12820.Write,v12820,[": "]),JAMScript.call(this.emitTypeSignature,this,[v12818]));
v12818=this.varListCount;if(v12818=0<v12818)v12818=this.varListCount,this.varListCount=v12818-1;else if(v12818=this.varListCount,v12818=0>v12818)v12818=this.varListCount,this.varListCount=v12818+1;v12818=this.varListCount;(v12818=0>v12818)?(v12818=this.declFile,JAMScript.call(v12818.Write,v12818,[", "])):(v12818=this.declFile,JAMScript.call(v12818.WriteLine,v12818,[";"]))}return!1}function v1217(astOrSymbol,endLine){var v12835=typeof endLine;(v12835="undefined"===v12835)&&(endLine=!0);v12835=this.emitOptions;
v12835=v12835.emitComments;v12835=!v12835;if(!v12835){var v12835=JAMScript.call(astOrSymbol.getDocComments,astOrSymbol,[]),v12837=v12835.length;if(v12837=0<v12837){for(var v12837=0,v12838=v12835.length,v12838=v12837<v12838;v12838;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v12838=v12835[v12837];JAMScript.call(this.emitComment,this,[v12838]);v12837+=1;v12838=v12835.length;v12838=v12837<v12838}if(endLine){if(v12835=this.declFile,v12835=v12835.onNewLine,v12835=
!v12835)v12835=this.declFile,JAMScript.call(v12835.WriteLine,v12835,[""])}else v12835=this.declFile,(v12835=v12835.onNewLine)&&JAMScript.call(this.emitIndent,this,[])}}}function v1216(comment){var text=JAMScript.call(comment.getText,comment,[]),v12842=this.declFile;if(v12842=v12842.onNewLine)JAMScript.call(this.emitIndent,this,[]);else if(v12842=comment.isBlockComment,v12842=!v12842)v12842=this.declFile,JAMScript.call(v12842.WriteLine,v12842,[""]),JAMScript.call(this.emitIndent,this,[]);var v12842=
this.declFile,v2353=text[0];JAMScript.call(v12842.Write,v12842,[v2353]);v12842=1;v2353=text.length;for(v2353=v12842<v2353;v2353;){v2353=this.declFile;JAMScript.call(v2353.WriteLine,v2353,[""]);JAMScript.call(this.emitIndent,this,[]);v2353=this.declFile;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v2356=text[v12842];JAMScript.call(v2353.Write,v2353,[v2356]);v12842+=1;v2353=text.length;v2353=v12842<v2353}text=comment.endsLine;if(v12842=!text)comment=comment.isBlockComment,
text=!comment;(comment=text)?(comment=this.declFile,JAMScript.call(comment.WriteLine,comment,[""])):(comment=this.declFile,JAMScript.call(comment.Write,comment,[" "]))}function v1215(type){var containingScope=null,declarationContainerAst=JAMScript.call(this.getAstDeclarationContainer,this,[]),v2368=declarationContainerAst.nodeType;switch(v2368){case TypeScript.NodeType.ModuleDeclaration:case TypeScript.NodeType.InterfaceDeclaration:case TypeScript.NodeType.FuncDecl:if(v2368=declarationContainerAst.type)containingScope=
declarationContainerAst.type,containingScope=containingScope.containedScope;break;case TypeScript.NodeType.Script:if(v2368=declarationContainerAst.bod)containingScope=declarationContainerAst.bod,containingScope=containingScope.enclosingScope;break;case TypeScript.NodeType.ClassDeclaration:if(v2368=declarationContainerAst.type)containingScope=declarationContainerAst.type,containingScope=containingScope.instanceType,containingScope=containingScope.containedScope;break;default:declarationContainerAst=
TypeScript.CompilerDiagnostics,JAMScript.call(declarationContainerAst.debugPrint,declarationContainerAst,["Unknown containing scope"])}type=JAMScript.call(type.getScopedTypeNameEx,type,[containingScope]);JAMScript.call(this.emitTypeNamesMember,this,[type])}function v1214(memberName,emitIndent){var v12848=typeof emitIndent;(v12848="undefined"===v12848)&&(emitIndent=!1);v12848=memberName.prefix;if(v12848="{ "==v12848)emitIndent&&JAMScript.call(this.emitIndent,this,[]),v12848=this.declFile,JAMScript.call(v12848.WriteLine,
v12848,["{"]),v12848=this.indenter,JAMScript.call(v12848.increaseIndent,v12848,[]),emitIndent=!0;else if(v12848=memberName.prefix,v12848=""!=v12848){emitIndent&&JAMScript.call(this.emitIndent,this,[]);var v12848=this.declFile,v2373=memberName.prefix;JAMScript.call(v12848.Write,v12848,[v2373]);emitIndent=!1}if(v12848=JAMScript.call(memberName.isString,memberName,[]))emitIndent&&JAMScript.call(this.emitIndent,this,[]),v12848=this.declFile,v2373=memberName.text,JAMScript.call(v12848.Write,v12848,[v2373]);
else for(var v12848=memberName,v2373=0,v19036=v12848.entries,v19036=v19036.length,v19036=v2373<v19036;v19036;){v19036=v12848.entries;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v19036=v19036[v2373];JAMScript.call(this.emitTypeNamesMember,this,[v19036,emitIndent]);v19036=v12848.delim;if(v19036="; "==v19036)v19036=this.declFile,JAMScript.call(v19036.WriteLine,v19036,[";"]);v2373+=1;v19036=v12848.entries;v19036=v19036.length;v19036=v2373<v19036}v12848=memberName.suffix;
if(v12848="}"==v12848)v12848=this.indenter,JAMScript.call(v12848.decreaseIndent,v12848,[]),JAMScript.call(this.emitIndent,this,[]);v12848=this.declFile;v2373=memberName.suffix;JAMScript.call(v12848.Write,v12848,[v2373])}function v1213(ast){var v2389=TypeScript.CompilerDiagnostics,v12857=JAMScript.call(this.getAstDeclarationContainer,this,[]);ast=ast!=v12857;JAMScript.call(v2389.assert,v2389,[ast,"Declaration container mismatch"]);v2389=this.declarationContainerStack;JAMScript.call(v2389.pop,v2389,
[])}function v1212(ast){var v2392=this.declarationContainerStack;JAMScript.call(v2392.push,v2392,[ast])}function v1211(declFlag){var v12858=typeof declFlag;if(v12858="undefined"===v12858)declFlag=TypeScript.DeclFlags,declFlag=declFlag.None;v12858=TypeScript.DeclFlags;v12858=v12858.Private;declFlag=JAMScript.call(TypeScript.hasFlag,TypeScript,[declFlag,v12858]);return!declFlag}function v1210(declFlags,typeString){var v2396=this.declFile,v2397=JAMScript.call(this.getDeclFlagsString,this,[declFlags,
typeString]);JAMScript.call(v2396.Write,v2396,[v2397])}function v1209(declFlags,typeString){var result=JAMScript.call(this.getIndentString,this,[]),accessorString="",v19039=TypeScript.DeclFlags,v19039=v19039.GetAccessor;(v19039=JAMScript.call(TypeScript.hasFlag,TypeScript,[declFlags,v19039]))?accessorString="get ":(v19039=TypeScript.DeclFlags,v19039=v19039.SetAccessor,(v19039=JAMScript.call(TypeScript.hasFlag,TypeScript,[declFlags,v19039]))&&(accessorString="set "));var v19039=JAMScript.call(this.getAstDeclarationContainer,
this,[]),v19041=v19039.nodeType,v22914=TypeScript.NodeType,v22914=v22914.ModuleDeclaration;if(v19041=v19041==v22914){v19039=v19039.modFlags;v19041=TypeScript.ModuleFlags;v19041=v19041.IsWholeFile;if(v19039=JAMScript.call(TypeScript.hasFlag,TypeScript,[v19039,v19041]))v19039=TypeScript.DeclFlags,v19039=v19039.Exported,v19039=JAMScript.call(TypeScript.hasFlag,TypeScript,[declFlags,v19039]);v19041=v19039}(v19039=v19041)&&(result+="export ");v19039=TypeScript.DeclFlags;v19039=v19039.LocalStatic;v19039=
JAMScript.call(TypeScript.hasFlag,TypeScript,[declFlags,v19039]);if(v19041=!v19039)v19039=TypeScript.DeclFlags,v19039=v19039.Static,v19039=JAMScript.call(TypeScript.hasFlag,TypeScript,[declFlags,v19039]);v19039?accessorString="static "+accessorString:(v19039=TypeScript.DeclFlags,v19039=v19039.Private,(v19039=JAMScript.call(TypeScript.hasFlag,TypeScript,[declFlags,v19039]))?accessorString="private "+accessorString:(v19039=TypeScript.DeclFlags,v19039=v19039.Public,(v19039=JAMScript.call(TypeScript.hasFlag,
TypeScript,[declFlags,v19039]))?accessorString="public "+accessorString:(v19039=""==accessorString)&&(accessorString=typeString+" ")));return result+=accessorString}function v1208(declFlags,astWithPrePostCallback,preCallback){var v2408=this.ignoreCallbackAst;if(v2408)return declFlags=TypeScript.CompilerDiagnostics,preCallback=this.ignoreCallbackAst,astWithPrePostCallback=preCallback!=astWithPrePostCallback,JAMScript.call(declFlags.assert,declFlags,[astWithPrePostCallback,"Ignore Callback AST mismatch"]),
this.ignoreCallbackAst=null,!1;if(v2408=preCallback)declFlags=JAMScript.call(this.canEmitSignature,this,[declFlags,!0,preCallback]),v2408=!declFlags;return(declFlags=v2408)?(this.ignoreCallbackAst=astWithPrePostCallback,!1):!0}function v1207(declFlags,canEmitGlobalAmbientDecl,useDeclarationContainerTop){var v12872=typeof canEmitGlobalAmbientDecl;(v12872="undefined"===v12872)&&(canEmitGlobalAmbientDecl=!0);v12872=typeof useDeclarationContainerTop;(v12872="undefined"===v12872)&&(useDeclarationContainerTop=
!0);useDeclarationContainerTop?useDeclarationContainerTop=JAMScript.call(this.getAstDeclarationContainer,this,[]):(v12872=useDeclarationContainerTop=this.declarationContainerStack,v12872=v12872.length,v12872-=2,useDeclarationContainerTop=useDeclarationContainerTop[v12872]);var v12872=useDeclarationContainerTop.nodeType,v22920=TypeScript.NodeType,v22920=v22920.ModuleDeclaration;if(v12872=v12872==v22920)v12872=TypeScript.DeclFlags,v12872=v12872.Exported,v12872=JAMScript.call(TypeScript.hasFlag,TypeScript,
[declFlags,v12872]),v12872=!v12872;if(v12872)return!1;if(canEmitGlobalAmbientDecl=!canEmitGlobalAmbientDecl)if(canEmitGlobalAmbientDecl=useDeclarationContainerTop.nodeType,useDeclarationContainerTop=TypeScript.NodeType,useDeclarationContainerTop=useDeclarationContainerTop.Script,canEmitGlobalAmbientDecl=canEmitGlobalAmbientDecl==useDeclarationContainerTop)canEmitGlobalAmbientDecl=TypeScript.DeclFlags,canEmitGlobalAmbientDecl=canEmitGlobalAmbientDecl.Ambient,canEmitGlobalAmbientDecl=JAMScript.call(TypeScript.hasFlag,
TypeScript,[declFlags,canEmitGlobalAmbientDecl]);return(declFlags=canEmitGlobalAmbientDecl)?!1:!0}function v1206(){var v2415=this.declFile,v2416=JAMScript.call(this.getIndentString,this,[]);JAMScript.call(v2415.Write,v2415,[v2416])}function v1205(declIndent){declIndent=this.emitOptions;if(declIndent=declIndent.minWhitespace)return"";declIndent=this.indenter;return JAMScript.call(declIndent.getIndent,declIndent,[])}function v1204(script){var v2420=TypeScript.AstWalkerWithDetailCallback;JAMScript.call(v2420.walk,
v2420,[script,this])}function v1203(){try{var v2421=this.declFile;JAMScript.call(v2421.Close,v2421,[])}catch(ex){var v2421=this.errorReporter,v2423=ex.message;JAMScript.call(v2421.emitterError,v2421,[null,v2423])}}function v1202(file){this.declFile=file=JAMScript.new(DeclFileWriter,[file])}function v1201(){var v2424;v2424=this.isDottedModuleName;v2424=v2424.length;if(v2424=0==v2424)v2424=!1;else{var v22926=v2424=this.isDottedModuleName,v22926=v22926.length,v22926=v22926-1;v2424=v2424[v22926]}return v2424}
function v1200(){var v2425=this.declarationContainerStack,v19057=this.declarationContainerStack,v19057=v19057.length,v19057=v19057-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v2425[v19057]}function DeclarationEmitter(checker,emitOptions,errorReporter){this.checker=checker;this.emitOptions=emitOptions;this.errorReporter=errorReporter;this.declFile=null;checker=TypeScript.Indenter;this.indenter=checker=JAMScript.new(checker,[]);this.declarationContainerStack=
[];this.isDottedModuleName=[];this.singleDeclFile=this.ignoreCallbackAst=null;this.varListCount=0}var v2428=DeclarationEmitter.prototype;v2428.getAstDeclarationContainer=v1200;v2428=DeclarationEmitter.prototype;v2428.emitDottedModuleName=v1201;v2428=DeclarationEmitter.prototype;v2428.setDeclarationFile=v1202;v2428=DeclarationEmitter.prototype;v2428.Close=v1203;v2428=DeclarationEmitter.prototype;v2428.emitDeclarations=v1204;v2428=DeclarationEmitter.prototype;v2428.getIndentString=v1205;v2428=DeclarationEmitter.prototype;
v2428.emitIndent=v1206;v2428=DeclarationEmitter.prototype;v2428.canEmitSignature=v1207;v2428=DeclarationEmitter.prototype;v2428.canEmitPrePostAstSignature=v1208;v2428=DeclarationEmitter.prototype;v2428.getDeclFlagsString=v1209;v2428=DeclarationEmitter.prototype;v2428.emitDeclFlags=v1210;v2428=DeclarationEmitter.prototype;v2428.canEmitTypeAnnotationSignature=v1211;v2428=DeclarationEmitter.prototype;v2428.pushDeclarationContainer=v1212;v2428=DeclarationEmitter.prototype;v2428.popDeclarationContainer=
v1213;v2428=DeclarationEmitter.prototype;v2428.emitTypeNamesMember=v1214;v2428=DeclarationEmitter.prototype;v2428.emitTypeSignature=v1215;v2428=DeclarationEmitter.prototype;v2428.emitComment=v1216;v2428=DeclarationEmitter.prototype;v2428.emitDeclarationComments=v1217;v2428=DeclarationEmitter.prototype;v2428.VarDeclCallback=v1218;v2428=DeclarationEmitter.prototype;v2428.BlockCallback=v1219;v2428=DeclarationEmitter.prototype;v2428.emitArgDecl=v1220;v2428=DeclarationEmitter.prototype;v2428.FuncDeclCallback=
v1221;v2428=DeclarationEmitter.prototype;v2428.emitBaseList=v1222;v2428=DeclarationEmitter.prototype;v2428.emitPropertyAccessorSignature=v1223;v2428=DeclarationEmitter.prototype;v2428.emitClassMembersFromConstructorDefinition=v1224;v2428=DeclarationEmitter.prototype;v2428.ClassDeclarationCallback=v1225;v2428=DeclarationEmitter.prototype;v2428.InterfaceDeclarationCallback=v1226;v2428=DeclarationEmitter.prototype;v2428.ImportDeclarationCallback=v1227;v2428=DeclarationEmitter.prototype;v2428.emitEnumSignature=
v1228;v2428=DeclarationEmitter.prototype;v2428.ModuleDeclarationCallback=v1229;v2428=DeclarationEmitter.prototype;v2428.ScriptCallback=v1230;v2428=DeclarationEmitter.prototype;v2428.DefaultCallback=v1231;return DeclarationEmitter}function v1199(){function v1198(){var v2460=this.declFile;JAMScript.call(v2460.Close,v2460,[])}function v1197(s){var v2461=this.declFile;JAMScript.call(v2461.WriteLine,v2461,[s]);this.onNewLine=!0}function v1196(s){var v2462=this.declFile;JAMScript.call(v2462.Write,v2462,
[s]);this.onNewLine=!1}function DeclFileWriter(declFile){this.declFile=declFile;this.onNewLine=!0}var v2463=DeclFileWriter.prototype;v2463.Write=v1196;v2463=DeclFileWriter.prototype;v2463.WriteLine=v1197;v2463=DeclFileWriter.prototype;v2463.Close=v1198;return DeclFileWriter}var DeclFileWriter=v1199();TypeScript.DeclFileWriter=DeclFileWriter;var DeclarationEmitter=v1232();TypeScript.DeclarationEmitter=DeclarationEmitter}
function v1195(){var TypeScript=v12370;function v1194(){function v1193(ast$$0,start,delta){function pre(cur,parent,walker){parent=cur.limChar;if(parent=-1!==parent)parent=cur.limChar,parent=parent<start;parent&&(walker=walker.options,walker.goChildren=!1);applyDelta(cur);walker=cur.preComments;applyDeltaToComments(walker);walker=cur.postComments;applyDeltaToComments(walker);return cur}function applyDeltaToComments(comments){var v12884=comments;v12884&&(v12884=comments.length,v12884=0<v12884);if(v12884)for(var v12884=
0,v12885=comments.length,v12885=v12884<v12885;v12885;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v12885=comments[v12884];applyDelta(v12885);v12884+=1;v12885=comments.length;v12885=v12884<v12885}}function applyDelta(ast){var v19061=ast.minChar;if(v19061=-1!==v19061)v19061=ast.minChar,v19061=v19061>=start;v19061&&(v19061=ast.minChar,ast.minChar=v19061+delta);v19061=ast.limChar;if(v19061=-1!==v19061)v19061=ast.limChar,v19061=v19061>=start;v19061&&(v19061=ast.limChar,
ast.limChar=v19061+delta)}var v2475=JAMScript.call(TypeScript.getAstWalkerFactory,TypeScript,[]);JAMScript.call(v2475.walk,v2475,[ast$$0,pre])}function v1192(script,partial,editRange){script=script.locationInfo;script=script.lineMap;partial=partial.locationInfo;partial=partial.lineMap;var v12891=this.logger;if(v12891=JAMScript.call(v12891.information,v12891,[])){v12891=this.logger;JAMScript.call(v12891.log,v12891,["lineMap1 (before):"]);v12891=this.astLogger;JAMScript.call(v12891.logLinemap,v12891,
[script]);v12891=this.logger;JAMScript.call(v12891.log,v12891,["lineMap2 (quick parse):"]);v12891=this.astLogger;JAMScript.call(v12891.logLinemap,v12891,[partial]);var v12891=this.logger,v2483="EditRange="+editRange;JAMScript.call(v12891.log,v12891,[v2483])}for(var i1=2,v12891=2,len1=script.length,v2483=partial.length,v2489=i1<len1;v2489;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v2489=script[i1];var v12893=editRange.minChar;if(v2489=v2489<=v12893)i1+=1;else{introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v2489=
script[i1];v12893=editRange.limChar;if(v2489=v2489>=v12893){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v2489=script[i1];v12893=editRange.delta;script[i1]=v2489+v12893;i1+=1}else if(v2489=v12891<v2483){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v2489=partial[v12891];v12893=editRange.minChar;v2489+=v12893;script.splice(i1,0,v2489);i1+=1;len1+=1;v12891+=1}else script.splice(i1,1),len1-=1}v2489=i1<len1}if(i1=v12891<v2483){i1=
len1-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)i1=script[i1];introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v2489=partial[v12891];v12893=editRange.minChar;v2489+=v12893;if(i1=i1>=v2489)for(i1=2,(v2489=i1<len1)&&(v2489=v12891<v2483);v2489;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v2489=script[i1];introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v12893=
partial[v12891];var v19069=editRange.minChar,v12893=v12893+v19069;if(v2489=v2489<v12893)i1+=1;else{introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v2489=partial[v12891];v12893=editRange.minChar;v2489+=v12893;script.splice(i1,0,v2489);i1+=1;len1+=1;v12891+=1}(v2489=i1<len1)&&(v2489=v12891<v2483)}for(len1=v12891<v2483;len1;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)len1=partial[v12891];i1=editRange.minChar;len1+=i1;JAMScript.call(script.push,
script,[len1]);v12891+=1;len1=v12891<v2483}}editRange=this.logger;if(editRange=JAMScript.call(editRange.information,editRange,[]))editRange=this.logger,JAMScript.call(editRange.log,editRange,["lineMap1 (after merge):"]),editRange=this.astLogger,JAMScript.call(editRange.logLinemap,editRange,[script])}function v1191(script,oldAst,newAst){function pre(cur,parent,walker){if(parent=cur===oldAst)return newAst.preComments=cur.preComments,newAst.postComments=cur.postComments,cur=_this.logger,JAMScript.call(cur.log,
cur,["replaced old AST node with new one in script AST"]),cur=walker.options,JAMScript.call(cur.stopWalk,cur,[]),newAst;if(parent=JAMScript.call(TypeScript.isValidAstNode,TypeScript,[cur])){parent=cur.limChar;var v19071=oldAst.minChar;parent=parent<v19071;if(v19071=!parent)parent=cur.minChar,v19071=oldAst.limChar,parent=parent>v19071;parent&&(walker=walker.options,walker.goChildren=!1)}return cur}var _this=this,v2506=JAMScript.call(TypeScript.getAstWalkerFactory,TypeScript,[]);JAMScript.call(v2506.walk,
v2506,[script,pre])}function v1190(updateResult){function v1189(){var v2507=TypeScript.ScriptEditRange,v12912=updateResult.scope1,v12912=v12912.minChar,v12913=updateResult.scope1,v12913=v12913.limChar,v12914=updateResult.editRange,v12914=v12914.delta,v2507=JAMScript.new(v2507,[v12912,v12913,v12914]),v12912=updateResult.script1,v12913=v2507.limChar,v12914=v2507.delta;JAMScript.call(_this.applyDeltaPosition,_this,[v12912,v12913,v12914]);v12912=updateResult.script2;v12913=v2507.minChar;JAMScript.call(_this.applyDeltaPosition,
_this,[v12912,0,v12913]);v12912=updateResult.script1;v12913=updateResult.script2;JAMScript.call(_this.mergeLocationInfo,_this,[v12912,v12913,v2507]);v2507=updateResult.script1;v12912=updateResult.scope1;v12913=updateResult.scope2;JAMScript.call(_this.replaceAST,_this,[v2507,v12912,v12913])}var _this=this,v2521=this.logger;JAMScript.call(TypeScript.timeFunction,TypeScript,[v2521,"mergeTrees()",v1189])}function v1188(previousScript,scriptId,newSourceText,editRange){function errorCapture(minChar,charLen,
message,unitIndex){var v12915=TypeScript.ErrorEntry;charLen=minChar+charLen;minChar=JAMScript.new(v12915,[unitIndex,minChar,charLen,message]);JAMScript.call(parseErrors.push,parseErrors,[minChar])}var v2523=this.logger,v12917='attemptIncrementalUpdateUnit("'+scriptId,v12917=v12917+'")';JAMScript.call(v2523.log,v2523,[v12917]);if(v2523=null===editRange)throw Error("editRange should be valid");v2523=JAMScript.call(this.getEnclosingScopeContextIfSingleScopeEdit,this,[previousScript,scriptId,newSourceText,
editRange]);if(scriptId=null===v2523)return null;scriptId=v2523.scopeStartAST;scriptId=scriptId.limChar;v12917=v2523.scopeStartAST;v12917=v12917.minChar;scriptId-=v12917;var v12917=editRange.delta,v12917=scriptId+=v12917,v19077=JAMScript.call(newSourceText.getLength,newSourceText,[]),v19077=v19077/2;if(v12917=v12917>=v19077)return previousScript=this.logger,editRange="  Bailing out because range of scope to reparse ("+scriptId,editRange+=" characters) is greater than half the size of the source text",
JAMScript.call(previousScript.log,previousScript,[editRange]),null;var parseErrors=[],v12917=this.logger,v12923=v19077=v2523.scopeStartAST,v12923=v12923.minChar,v19078=v2523.scopeStartAST,v19078=v19078.minChar,v19078=v19078+scriptId;newSourceText=JAMScript.call(TypeScript.quickParse,TypeScript,[v12917,v19077,newSourceText,v12923,v19078,errorCapture]);v12917=newSourceText.endLexState;v19077=TypeScript.LexState;v19077=v19077.Start;if(v12917=v12917!=v19077)return previousScript=this.logger,JAMScript.call(previousScript.log,
previousScript,["  Bailing out because scope contains unterminated comment"]),null;newSourceText=newSourceText.Script;v12917=newSourceText.vars;v12917=v12917.members;v12917=v12917.length;if(v12917=0!==v12917)return previousScript=this.logger,JAMScript.call(previousScript.log,previousScript,["  Bailing out because new source text defines variables"]),null;v12917=newSourceText.bod;v12917=v12917.members;v12917=v12917.length;if(v12917=1!==v12917)return previousScript=this.logger,JAMScript.call(previousScript.log,
previousScript,["  Bailing out because new source text defines more than one scope (or none)"]),null;v2523=v2523.scopeStartAST;v12917=newSourceText.bod;v12917=v12917.members;v12917=v12917[0];v19077=v2523.nodeType;v12923=v12917.nodeType;if(v19077=v19077!=v12923)return previousScript=this.logger,JAMScript.call(previousScript.log,previousScript,["  Bailing out because new source text does not define the same scope type as the existing scope"]),null;v19077=v2523.leftCurlyCount;v19077=!v19077;if(v12923=
!v19077)v19077=v2523.rightCurlyCount,v19077=!v19077;if(v19077)return previousScript=this.logger,JAMScript.call(previousScript.log,previousScript,["  Bailing out because sopce doesn't have left/right curly count"]),null;v19077=v2523.leftCurlyCount;v12923=v12917.leftCurlyCount;if(v19077=v19077!==v12923)return previousScript=this.logger,JAMScript.call(previousScript.log,previousScript,["  Bailing out because new source text contains more (or fewer) left curly braces"]),null;v19077=v2523.rightCurlyCount;
v12923=v12917.rightCurlyCount;if(v19077=v19077!==v12923)return previousScript=this.logger,JAMScript.call(previousScript.log,previousScript,["  Bailing out because new source text contains more (or fewer) right curly braces"]),null;v19077=v12917.minChar;if(v19077=0!==v19077)return previousScript=this.logger,JAMScript.call(previousScript.log,previousScript,["  Bailing out because new function declaration does not start at position 0"]),null;v19077=v12917.limChar;if(scriptId=v19077!==scriptId)return previousScript=
this.logger,JAMScript.call(previousScript.log,previousScript,["  Bailing out because new function declaration does not end at the new end position"]),null;scriptId=TypeScript.UpdateUnitResult;return JAMScript.call(scriptId.singleScopeEdits,scriptId,[previousScript,newSourceText,v2523,v12917,editRange,parseErrors])}function v1187(previousScript,scriptId,newSourceText,editRange){var v2556=this.logger;scriptId='checkEditsInsideSingleScope("'+scriptId;scriptId+='")';JAMScript.call(v2556.log,v2556,[scriptId]);
if(v2556=null===editRange)throw Error("editRange should be valid");if(v2556=JAMScript.call(editRange.isUnknown,editRange,[]))return editRange=this.logger,JAMScript.call(editRange.log,editRange,["  Bailing out because edit range is unknown"]),null;v2556=this.logger;scriptId=editRange.minChar;v2556=JAMScript.call(TypeScript.findEnclosingScopeAt,TypeScript,[v2556,previousScript,newSourceText,scriptId,!1]);scriptId=this.logger;var v2564=editRange.limChar;previousScript=JAMScript.call(TypeScript.findEnclosingScopeAt,
TypeScript,[scriptId,previousScript,newSourceText,v2564,!1]);newSourceText=null==v2556;(scriptId=!newSourceText)&&(newSourceText=null==previousScript);if(newSourceText)return editRange=this.logger,JAMScript.call(editRange.log,editRange,["  Bailing out because containing scopes cannot be determined"]),null;newSourceText=v2556.scopeStartAST;previousScript=previousScript.scopeStartAST;if(previousScript=newSourceText!==previousScript)return editRange=this.logger,JAMScript.call(editRange.log,editRange,
["  Bailing out because edit overlaps 2 disctint scopes"]),null;previousScript=v2556.scopeStartAST;previousScript=previousScript.limChar;newSourceText=v2556.scopeStartAST;newSourceText=newSourceText.minChar;previousScript-=newSourceText;editRange=editRange.delta;editRange=previousScript+editRange;return(editRange=0>=editRange)?(editRange=this.logger,JAMScript.call(editRange.log,editRange,["  Bailing out because scope has been entirely removed from new source text"]),null):v2556}function IncrementalParser(logger){this.logger=
logger;logger=TypeScript.AstLogger;var v2574=this.logger;this.astLogger=logger=JAMScript.new(logger,[v2574])}var v2575=IncrementalParser.prototype;v2575.getEnclosingScopeContextIfSingleScopeEdit=v1187;v2575=IncrementalParser.prototype;v2575.attemptIncrementalUpdateUnit=v1188;v2575=IncrementalParser.prototype;v2575.mergeTrees=v1190;v2575=IncrementalParser.prototype;v2575.replaceAST=v1191;v2575=IncrementalParser.prototype;v2575.mergeLocationInfo=v1192;v2575=IncrementalParser.prototype;v2575.applyDeltaPosition=
v1193;return IncrementalParser}var IncrementalParser=v1194();TypeScript.IncrementalParser=IncrementalParser}
function v1186(){var TypeScript=v12369;function v1185(){function v1184(str){var v2581=this.styleSettings;JAMScript.call(v2581.parseOptions,v2581,[str])}function CompilationSettings(){var v26799=JAMScript.new(StyleSettings,[]);this.styleSettings=v26799;this.exec=this.watch=this.emitComments=this.errorRecovery=this.parseOnly=this.minWhitespace=this.propagateConstants=!1;this.resolve=!0;this.controlFlowUseDef=this.printControlFlow=this.controlFlow=!1;this.preprocess=this.errorOnWith=!0;this.inferPropertiesFromThisAssignment=
this.canCallDefinitionSignature=!1;this.useDefaultLib=!0;v26799=TypeScript.CodeGenTarget;this.codeGenTarget=v26799.ES3;v26799=TypeScript.ModuleGenTarget;this.moduleGenTarget=v26799.Synchronous;this.outputOption="";this.useCaseSensitiveFileResolution=this.generateDeclarationFiles=this.mapSourceFiles=!1}var v2584=CompilationSettings.prototype;v2584.setStyleOptions=v1184;return CompilationSettings}function v1183(){function v1182(str){str=str.split(";");for(var i=0,len=str.length,v2589=i<len;v2589;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v2589=
str[i];var val=!0,colonIndex=v2589.lastIndexOf(":"),v2587=0<=colonIndex;v2587&&(v2587=colonIndex+1,v2587=JAMScript.call(v2589.substring,v2589,[v2587]),v2589=JAMScript.call(v2589.substring,v2589,[0,colonIndex]),(colonIndex="off"==v2587)&&(val=!1));v2589=JAMScript.call(this.setOption,this,[v2589,val]);if(v2589=!v2589)return!1;i+=1;v2589=i<len}return!0}function v1181(opt,val){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var optExists=this[opt];return(optExists=void 0!==
optExists)?(JAMScript.set(this,opt,val),!0):!1}function StyleSettings(){this.forin=this.eqeqeq=this.blockInCompoundStmt=this.bitwise=!1;this.emptyBlocks=!0;this.eqnull=this.assignmentInCond=this.requireSemi=this.newMustBeUsed=!1;this.literalSubscript=this.reDeclareLocal=this.funcInLoop=this.innerScopeDeclEscape=this.evalOK=!0;this.implicitAny=!1}var v2591=StyleSettings.prototype;v2591.setOption=v1181;v2591=StyleSettings.prototype;v2591.parseOptions=v1182;return StyleSettings}function getAdditionalDependencyPath(comment){var amdDependencyRegEx=
/^(\/\/\/\s*<amd-dependency\s+path=)('|")(.+?)\2\s*(static=('|")(.+?)\2\s*)*\/>/igm;return(comment=JAMScript.call(amdDependencyRegEx.exec,amdDependencyRegEx,[comment]))?comment=comment[3]:null}function getImplicitImport(comment){var implicitImportRegEx=/^(\/\/\/\s*<implicit-import\s*)*\/>/igm;return(comment=JAMScript.call(implicitImportRegEx.exec,implicitImportRegEx,[comment]))?!0:!1}function getStyleSettings(comment,styleSettings){var styleRegEx=/^(\/\/\/\s*<style\s+)(([a-zA-Z])+=('|").+('|"))\s*\/>/igm;
if(styleRegEx=JAMScript.call(styleRegEx.exec,styleRegEx,[comment])){var settingsRegEx=/^([a-zA-Z]+=['"]on['|"])/igm,styleRegEx=styleRegEx[2];if(styleRegEx=JAMScript.call(settingsRegEx.exec,settingsRegEx,[styleRegEx]))for(var settingsRegEx=0,v12946=styleRegEx.length,v12946=settingsRegEx<v12946;v12946;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v12946=styleRegEx[settingsRegEx];var setting=v12946.split("="),v12946='"on"',v2609=setting[0];switch(v2609){case "blockInCompoundStmt":setting=
setting[1];styleSettings.blockInCompoundStmt=setting==v12946;break;case "eqeqeq":setting=setting[1];styleSettings.eqeqeq=setting==v12946;break;case "forin":setting=setting[1];styleSettings.forin=setting==v12946;break;case "emptyBlocks":setting=setting[1];styleSettings.emptyBlocks=setting==v12946;break;case "newMustBeUsed":setting=setting[1];styleSettings.newMustBeUsed=setting==v12946;break;case "requireSemi":setting=setting[1];styleSettings.requireSemi=setting==v12946;break;case "assignmentInCond":setting=
setting[1];styleSettings.assignmentInCond=setting==v12946;break;case "eqnull":setting=setting[1];styleSettings.eqnull=setting==v12946;break;case "evalOK":setting=setting[1];styleSettings.evalOK=setting==v12946;break;case "innerScopeDeclEscape":setting=setting[1];styleSettings.innerScopeDeclEscape=setting==v12946;break;case "funcInLoop":setting=setting[1];styleSettings.funcInLoop=setting==v12946;break;case "reDeclareLocal":setting=setting[1];styleSettings.reDeclareLocal=setting==v12946;break;case "literalSubscript":setting=
setting[1];styleSettings.literalSubscript=setting==v12946;break;case "implicitAny":setting=setting[1],styleSettings.implicitAny=setting==v12946}settingsRegEx+=1;v12946=styleRegEx.length;v12946=settingsRegEx<v12946}}}function getReferencedFiles(sourceText){sourceText=preProcessFile(sourceText,null,!1);return sourceText.referencedFiles}function preProcessFile(sourceText,options,readImportFiles){var v12948=typeof options;(v12948="undefined"===v12948)&&(options=JAMScript.new(CompilationSettings,[]));
v12948=typeof readImportFiles;(v12948="undefined"===v12948)&&(readImportFiles=!0);var v12948=TypeScript.Scanner,scanner=JAMScript.new(v12948,[]);JAMScript.call(scanner.resetComments,scanner,[]);v12948=TypeScript.LexMode;v12948=v12948.File;JAMScript.call(scanner.setSourceText,scanner,[sourceText,v12948]);var tok=JAMScript.call(scanner.scan,scanner,[]),comments=[],comment=null,comments=[];sourceText=[];for(var v12948=[],isLibFile=!1,comment=tok.tokenId,v19088=TypeScript.TokenID,v19088=v19088.EndOfFile,
comment=comment!=v19088;comment;){if(comment=readImportFiles)comment=tok.tokenId,v19088=TypeScript.TokenID,v19088=v19088.Import,comment=comment==v19088;if(comment&&(tok=JAMScript.call(scanner.scan,scanner,[]),comment=tok.tokenId,v19088=TypeScript.TokenID,v19088=v19088.Identifier,comment=comment==v19088,(v19088=!comment)&&(comment=JAMScript.call(TypeScript.convertTokToID,TypeScript,[tok,!1])),comment&&(tok=JAMScript.call(scanner.scan,scanner,[]),comment=tok.tokenId,v19088=TypeScript.TokenID,v19088=
v19088.Equals,comment=comment==v19088))&&(tok=JAMScript.call(scanner.scan,scanner,[]),comment=tok.tokenId,v19088=TypeScript.TokenID,v19088=v19088.Module,comment=comment==v19088)&&(tok=JAMScript.call(scanner.scan,scanner,[]),comment=tok.tokenId,v19088=TypeScript.TokenID,v19088=v19088.OpenParen,comment=comment==v19088)&&(tok=JAMScript.call(scanner.scan,scanner,[]),comment=tok.tokenId,v19088=TypeScript.TokenID,v19088=v19088.StringLiteral,comment=comment==v19088)){var comment=scanner.startPos,v19088=
scanner.pos,v19098=JAMScript.call(tok.getText,tok,[]),v19098=JAMScript.call(TypeScript.switchToForwardSlashes,TypeScript,[v19098]),v19098=JAMScript.call(TypeScript.stripQuotes,TypeScript,[v19098]),comment={minChar:comment,limChar:v19088,path:v19098,isResident:!1};JAMScript.call(v12948.push,v12948,[comment])}comment=tok.tokenId;v19088=TypeScript.TokenID;v19088=v19088.OpenBrace;(comment=comment==v19088)&&JAMScript.call(comments.push,comments,[tok]);tok=tok.tokenId;comment=TypeScript.TokenID;comment=
comment.CloseBrace;(tok=tok==comment)&&JAMScript.call(comments.pop,comments,[]);tok=JAMScript.call(scanner.scan,scanner,[]);comment=tok.tokenId;v19088=TypeScript.TokenID;v19088=v19088.EndOfFile;comment=comment!=v19088}comments=JAMScript.call(scanner.getComments,scanner,[]);readImportFiles=0;scanner=comments.length;for(scanner=readImportFiles<scanner;scanner;){comment=comments[readImportFiles];scanner=comment.isBlock;if(scanner=!scanner){JSCompiler_inline_label_getFileReferenceFromReferencePath_29:if(scanner=
JAMScript.call(comment.getText,comment,[]),tok=/^(\/\/\/\s*<reference\s+path=)('|")(.+?)\2\s*(static=('|")(.+?)\2\s*)*\/>/igm,v19088=JAMScript.call(tok.exec,tok,[scanner])){scanner=v19088[3];tok=JAMScript.call(TypeScript.normalizePath,TypeScript,[scanner]);scanner=JAMScript.call(TypeScript.normalizePath,TypeScript,[tok]);v19098=v19088.length;if(v19098=7<=v19098)v19088=v19088[6],v19098="true"==v19088;if(v19088=v19098)v19098=TypeScript.CompilerDiagnostics,tok+=" is resident",JAMScript.call(v19098.debugPrint,
v19098,[tok]);scanner=JAMScript.call(TypeScript.switchToForwardSlashes,TypeScript,[scanner]);scanner={minChar:0,limChar:0,path:scanner,isResident:v19088}}else scanner=null;scanner&&(scanner.minChar=comment.startPos,tok=scanner.minChar,v19088=comment.value,v19088=v19088.length,scanner.limChar=tok+v19088,JAMScript.call(sourceText.push,sourceText,[scanner]));options&&(scanner=JAMScript.call(comment.getText,comment,[]),tok=options.styleSettings,getStyleSettings(scanner,tok),scanner=/^(\/\/\/\s*<reference\s+no-default-lib=)('|")(.+?)\2\s*\/>/igm,
tok=JAMScript.call(comment.getText,comment,[]),scanner=JAMScript.call(scanner.exec,scanner,[tok]))&&(isLibFile=scanner[3],isLibFile="true"==isLibFile)}readImportFiles+=1;scanner=comments.length;scanner=readImportFiles<scanner}return{settings:options,referencedFiles:sourceText,importedFiles:v12948,isLibFile:isLibFile}}var StyleSettings=v1183();TypeScript.StyleSettings=StyleSettings;var CompilationSettings=v1185();TypeScript.CompilationSettings=CompilationSettings;TypeScript.getAdditionalDependencyPath=
getAdditionalDependencyPath;TypeScript.getImplicitImport=getImplicitImport;TypeScript.getStyleSettings=getStyleSettings;TypeScript.getReferencedFiles=getReferencedFiles;TypeScript.preProcessFile=preProcessFile}
function v1180(){var TypeScript=v12368;function v1179(){function v1178(referencePath,parentPath,performSearch,resolutionDispatcher){var resolvedFile={content:"",path:referencePath},v2640=this.environment,ioHost=v2640.ioHost,isRelativePath=JAMScript.call(TypeScript.isRelative,TypeScript,[referencePath]),v2641,isRootedPath=v2641=isRelativePath?!1:JAMScript.call(TypeScript.isRooted,TypeScript,[referencePath]),v2642;if(isRelativePath){var v19102=parentPath+"/",v12976=v19102+referencePath;v2642=JAMScript.call(ioHost.resolvePath,
ioHost,[v12976])}else{var v12977,v22931=isRootedPath,v24819=!v22931;if(v24819){var v24818=!parentPath,v25755=!v24818;v25755&&(v24818=performSearch);v22931=v24818}var v19104=v22931;if(v19104)v12977=referencePath;else{var v19103=parentPath+"/";v12977=v19103+referencePath}v2642=v12977}var normalizedPath=v2642,v19105=JAMScript.call(TypeScript.isSTRFile,TypeScript,[normalizedPath]),v12978=!v19105;if(v12978)var v19106=JAMScript.call(TypeScript.isTSFile,TypeScript,[normalizedPath]),v12978=!v19106;var v2643=
v12978;v2643&&(normalizedPath+=".ts");var v2644=JAMScript.call(TypeScript.stripQuotes,TypeScript,[normalizedPath]),normalizedPath=JAMScript.call(TypeScript.switchToForwardSlashes,TypeScript,[v2644]),v2645,v22932=this.environment,v19107=v22932.compilationSettings,v12979=v19107.useCaseSensitiveFileResolution,absoluteModuleID=v2645=v12979?normalizedPath:normalizedPath.toLocaleUpperCase(),v19108=this.visited;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v12980=
v19108[absoluteModuleID];var v2690=!v12980;if(v2690){var v12981=isRelativePath,v19110=!v12981;if(v19110){var v19109=isRootedPath,v22933=!v19109;v22933&&(v19109=!performSearch);v12981=v19109}var v2676=v12981;if(v2676)try{var v2646=TypeScript.CompilerDiagnostics,v2647="   Reading code from "+normalizedPath;JAMScript.call(v2646.debugPrint,v2646,[v2647]);try{var v2648=resolvedFile,v26800=JAMScript.call(ioHost.readFile,ioHost,[normalizedPath]);v2648.content=v26800}catch(err){try{var v2650=JAMScript.call(TypeScript.isSTRFile,
TypeScript,[normalizedPath]);if(v2650)normalizedPath=JAMScript.call(TypeScript.changePathToTS,TypeScript,[normalizedPath]);else{var v2649=JAMScript.call(TypeScript.isTSFile,TypeScript,[normalizedPath]);v2649&&(normalizedPath=JAMScript.call(TypeScript.changePathToSTR,TypeScript,[normalizedPath]))}var v2651=TypeScript.CompilerDiagnostics,v2652="   Reading code from "+normalizedPath;JAMScript.call(v2651.debugPrint,v2651,[v2652]);var v2653=resolvedFile,v26801=JAMScript.call(ioHost.readFile,ioHost,[normalizedPath]);
v2653.content=v26801}catch(err$$0){var normalizedPath=JAMScript.call(TypeScript.changePathToDSTR,TypeScript,[normalizedPath]),v2654=TypeScript.CompilerDiagnostics,v2655="   Reading code from "+normalizedPath;JAMScript.call(v2654.debugPrint,v2654,[v2655]);try{var v2656=resolvedFile,v26802=JAMScript.call(ioHost.readFile,ioHost,[normalizedPath]);v2656.content=v26802}catch(err$$1){var normalizedPath=JAMScript.call(TypeScript.changePathToDTS,TypeScript,[normalizedPath]),v2657=TypeScript.CompilerDiagnostics,
v2658="   Reading code from "+normalizedPath;JAMScript.call(v2657.debugPrint,v2657,[v2658]);var v2659=resolvedFile,v26803=JAMScript.call(ioHost.readFile,ioHost,[normalizedPath]);v2659.content=v26803}}}var v2660=TypeScript.CompilerDiagnostics,v2661="   Found code at "+normalizedPath;JAMScript.call(v2660.debugPrint,v2660,[v2661]);resolvedFile.path=normalizedPath;var v2662=this.visited;JAMScript.set(v2662,absoluteModuleID,!0)}catch(err$$2){var v2663=TypeScript.CompilerDiagnostics,v2664="   Did not find code for "+
referencePath;JAMScript.call(v2663.debugPrint,v2663,[v2664])}else{var resolvedFile=JAMScript.call(ioHost.findFile,ioHost,[parentPath,normalizedPath]),v2667=!resolvedFile;if(v2667){var v2666=JAMScript.call(TypeScript.isSTRFile,TypeScript,[normalizedPath]);if(v2666)normalizedPath=JAMScript.call(TypeScript.changePathToTS,TypeScript,[normalizedPath]);else{var v2665=JAMScript.call(TypeScript.isTSFile,TypeScript,[normalizedPath]);v2665&&(normalizedPath=JAMScript.call(TypeScript.changePathToSTR,TypeScript,
[normalizedPath]))}resolvedFile=JAMScript.call(ioHost.findFile,ioHost,[parentPath,normalizedPath])}var v2669=!resolvedFile;if(v2669){var normalizedPath=JAMScript.call(TypeScript.changePathToDTS,TypeScript,[normalizedPath]),resolvedFile=JAMScript.call(ioHost.findFile,ioHost,[parentPath,normalizedPath]),v2668=!resolvedFile;v2668&&(normalizedPath=JAMScript.call(TypeScript.changePathToDSTR,TypeScript,[normalizedPath]),resolvedFile=JAMScript.call(ioHost.findFile,ioHost,[parentPath,normalizedPath]))}if(resolvedFile){var v2670=
resolvedFile,v19111=resolvedFile.path,v12982=JAMScript.call(TypeScript.stripQuotes,TypeScript,[v19111]),v26804=JAMScript.call(TypeScript.switchToForwardSlashes,TypeScript,[v12982]);v2670.path=v26804;var v2671=TypeScript.CompilerDiagnostics,v12983=referencePath+" resolved to: ",v12984=resolvedFile.path,v2672=v12983+v12984;JAMScript.call(v2671.debugPrint,v2671,[v2672]);resolvedFile.content=resolvedFile.content;var v2673=this.visited;JAMScript.set(v2673,absoluteModuleID,!0)}else{var v2674=TypeScript.CompilerDiagnostics,
v2675="Could not find "+referencePath;JAMScript.call(v2674.debugPrint,v2674,[v2675])}}var v12985=resolvedFile;v12985&&(v12985=resolvedFile.content);var v2689=v12985;if(v2689){var v2677=resolvedFile.path,rootDir=JAMScript.call(ioHost.dirName,ioHost,[v2677]),v2678=resolvedFile.path,v2679=resolvedFile.content,sourceUnit=JAMScript.new(SourceUnit,[v2678,v2679]),v12986=this.environment,v2680=v12986.compilationSettings,preProcessedFileInfo=JAMScript.call(TypeScript.preProcessFile,TypeScript,[sourceUnit,
v2680]);sourceUnit.referencedFiles=preProcessedFileInfo.referencedFiles;for(var i=0,v19112=preProcessedFileInfo.referencedFiles,v12987=v19112.length,v2685=i<v12987;v2685;){var v2681=preProcessedFileInfo.referencedFiles;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var referencedFile=v2681[i];var v2682,v19113=referencedFile.path,v12990=JAMScript.call(TypeScript.isRooted,TypeScript,[v19113]);if(v12990)v2682=referencedFile.path;else{var v12988=rootDir+"/",v12989=
referencedFile.path;v2682=v12988+v12989}var normalizedPath=v2682,normalizedPath=JAMScript.call(ioHost.resolvePath,ioHost,[normalizedPath]),v2683=referencePath==normalizedPath;if(v2683){JAMScript.call(resolutionDispatcher.postResolutionError,resolutionDispatcher,[normalizedPath,"File contains reference to itself",null]);var i=i+1,v19114=preProcessedFileInfo.referencedFiles,v12991=v19114.length,v2685=i<v12991}else{var v2684=referencedFile.path;JAMScript.call(this.resolveCode,this,[v2684,rootDir,!1,
resolutionDispatcher]);var i=i+1,v19115=preProcessedFileInfo.referencedFiles,v12992=v19115.length,v2685=i<v12992}}for(var i=0,v19116=preProcessedFileInfo.importedFiles,v12993=v19116.length,v2687=i<v12993;v2687;){var v19117=preProcessedFileInfo.importedFiles;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v12994=v19117[i];var v2686=v12994.path;JAMScript.call(this.resolveCode,this,[v2686,rootDir,!0,resolutionDispatcher]);var i=i+1,v19118=preProcessedFileInfo.importedFiles,
v12995=v19118.length,v2687=i<v12995}var v2688=sourceUnit.path;JAMScript.call(resolutionDispatcher.postResolution,resolutionDispatcher,[v2688,sourceUnit])}}}function CodeResolver(environment){this.environment=environment;this.visited={}}var v2691=CodeResolver.prototype;v2691.resolveCode=v1178;return CodeResolver}function v1177(){function CompilationEnvironment(compilationSettings,ioHost){this.compilationSettings=compilationSettings;this.ioHost=ioHost;this.residentCode=[];this.code=[]}return CompilationEnvironment}
function v1176(){function v1175(){var v2692=this.content;return v2692.length}function v1174(start,end){var v2693=this.content;return JAMScript.call(v2693.substring,v2693,[start,end])}function SourceUnit(path,content){this.path=path;this.content=content;this.referencedFiles=null}var v2694=SourceUnit.prototype;v2694.getText=v1174;v2694=SourceUnit.prototype;v2694.getLength=v1175;return SourceUnit}var SourceUnit=v1176();TypeScript.SourceUnit=SourceUnit;var CompilationEnvironment=v1177();TypeScript.CompilationEnvironment=
CompilationEnvironment;CompilationEnvironment=v1179();TypeScript.CodeResolver=CompilationEnvironment}
function v1173(){var TypeScript=v12367;function stripQuotes(str){str=str.replace('"',"");str=str.replace("'","");str=str.replace("'","");return str.replace('"',"")}function isQuoted(str){var v12997=str.indexOf('"'),v12997=-1!=v12997,v12999=!v12997;v12999&&(v12997=str.indexOf("'"),v12997=-1!=v12997,v12999=!v12997)&&(v12997=str.indexOf("'"),v12997=-1!=v12997,v12999=!v12997)&&(str=str.indexOf('"'),v12997=-1!=str);return v12997}function quoteStr(str){str='"'+str;return str+'"'}function swapQuotes(str){var v13000=
str.indexOf('"');(v13000=-1!=v13000)?(str=str.replace('"',"'"),str=str.replace('"',"'")):(str=str.replace("'",'"'),str=str.replace("'",'"'));return str}function switchToForwardSlashes(path){return path.replace(/\\/g,"/")}function trimModName(modName){var v19123=modName.length;if(v19123=6<v19123)var v19123=modName.length,v19123=v19123-6,v22938=modName.length,v19123=JAMScript.call(modName.substring,modName,[v19123,v22938]),v19123=".d.str"==v19123;if(v19123)return v19123=modName.length,v19123-=6,JAMScript.call(modName.substring,
modName,[0,v19123]);v19123=modName.length;if(v19123=4<v19123)v19123=modName.length,v19123-=4,v22938=modName.length,v19123=JAMScript.call(modName.substring,modName,[v19123,v22938]),v19123=".str"==v19123;if(v19123)return v19123=modName.length,v19123-=4,JAMScript.call(modName.substring,modName,[0,v19123]);v19123=modName.length;if(v19123=5<v19123)v19123=modName.length,v19123-=5,v22938=modName.length,v19123=JAMScript.call(modName.substring,modName,[v19123,v22938]),v19123=".d.ts"==v19123;if(v19123)return v19123=
modName.length,v19123-=5,JAMScript.call(modName.substring,modName,[0,v19123]);v19123=modName.length;if(v19123=3<v19123)v19123=modName.length,v19123-=3,v22938=modName.length,v19123=JAMScript.call(modName.substring,modName,[v19123,v22938]),v19123=".ts"==v19123;if(v19123)return v19123=modName.length,v19123-=3,JAMScript.call(modName.substring,modName,[0,v19123]);v19123=modName.length;if(v19123=3<v19123)v19123=modName.length,v19123-=3,v22938=modName.length,v19123=JAMScript.call(modName.substring,modName,
[v19123,v22938]),v19123=".js"==v19123;return v19123?(v19123=modName.length,v19123-=3,JAMScript.call(modName.substring,modName,[0,v19123])):modName}function getDeclareFilePath(fname){var v13012=isSTRFile(fname);v13012?fname=changePathToDSTR(fname):(isTSFile(fname),fname=changePathToDTS(fname));return fname}function isFileOfExtension(fname,ext){var invariantFname=fname.toLocaleUpperCase(),invariantExt=ext.toLocaleUpperCase(),extLength=invariantExt.length,v13013=invariantFname.length;if(v13013=v13013>
extLength)v13013=invariantFname.length,extLength=v13013-extLength,v13013=invariantFname.length,invariantFname=JAMScript.call(invariantFname.substring,invariantFname,[extLength,v13013]),v13013=invariantFname==invariantExt;return v13013}function isJSFile(fname){return isFileOfExtension(fname,".js")}function isSTRFile(fname){return isFileOfExtension(fname,".str")}function isTSFile(fname){return isFileOfExtension(fname,".ts")}function isDSTRFile(fname){return isFileOfExtension(fname,".d.str")}function isDTSFile(fname){return isFileOfExtension(fname,
".d.ts")}function getPrettyName(modPath,quote,treatAsFileName){var v13015=typeof quote;(v13015="undefined"===v13015)&&(quote=!0);v13015=typeof treatAsFileName;(v13015="undefined"===v13015)&&(treatAsFileName=!1);treatAsFileName?treatAsFileName=switchToForwardSlashes(modPath):(treatAsFileName=stripQuotes(modPath),treatAsFileName=trimModName(treatAsFileName));treatAsFileName=JAMScript.call(this.getPathComponents,this,[treatAsFileName]);if(v13015=treatAsFileName.length)if(quote){modPath=treatAsFileName.length;
modPath-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)modPath=treatAsFileName[modPath];modPath=quoteStr(modPath)}else modPath=treatAsFileName.length,modPath-=1,modPath=treatAsFileName[modPath];return modPath}function getPathComponents(path){return path.split("/")}function getRelativePathToFixedPath(fixedModFilePath,absoluteModPath){absoluteModPath=switchToForwardSlashes(absoluteModPath);var modComponents=JAMScript.call(this.getPathComponents,this,[absoluteModPath]),
fixedModComponents=JAMScript.call(this.getPathComponents,this,[fixedModFilePath]),joinStartIndex=0,v19138=modComponents.length;if(v19138=joinStartIndex<v19138)v19138=fixedModComponents.length,v19138=joinStartIndex<v19138;for(;v19138;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v19138=fixedModComponents[joinStartIndex];introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v13022=modComponents[joinStartIndex];if(v19138=v19138!=
v13022)break;joinStartIndex+=1;v19138=modComponents.length;if(v19138=joinStartIndex<v19138)v19138=fixedModComponents.length,v19138=joinStartIndex<v19138}if(v19138=0!=joinStartIndex){v19138="";v13022=modComponents.length;modComponents=modComponents.slice(joinStartIndex,v13022);v13022=fixedModComponents.length;for(v13022=joinStartIndex<v13022;v13022;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v13022=fixedModComponents[joinStartIndex];(v13022=""!=v13022)&&(v19138+=
"../");joinStartIndex+=1;v13022=fixedModComponents.length;v13022=joinStartIndex<v13022}fixedModComponents=v19138;joinStartIndex=modComponents.join("/");return fixedModComponents+joinStartIndex}return absoluteModPath}function quoteBaseName(modPath){var v2724=stripQuotes(modPath),v2724=trimModName(v2724),path=getRootFilePath(v2724),v2727=""==path;if(v2727)return modPath;modPath=v2724.split(path);v2724=modPath.length;v2724=(v2724=1<v2724)?1:0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)modPath=
modPath[v2724];return quoteStr(modPath)}function changePathToSTR(modPath){modPath=stripQuotes(modPath);modPath=trimModName(modPath);return modPath+".str"}function changePathToDSTR(modPath){modPath=stripQuotes(modPath);modPath=trimModName(modPath);return modPath+".d.str"}function changePathToTS(modPath){modPath=stripQuotes(modPath);modPath=trimModName(modPath);return modPath+".ts"}function changePathToDTS(modPath){modPath=stripQuotes(modPath);modPath=trimModName(modPath);return modPath+".d.ts"}function isRelative(path){path=
path.charAt(0);return"."==path}function isRooted(path){var v13032=path.charAt(0),v13032="\\"==v13032,v13034=!v13032;v13034&&(v13032=path.charAt(0),v13032="/"==v13032,v13034=!v13032)&&(v13032=path.indexOf(":\\"),v13032=-1!=v13032,v13034=!v13032)&&(path=path.indexOf(":/"),v13032=-1!=path);return v13032}function getRootFilePath(outFname){var v2736=""==outFname;if(v2736)return outFname;v2736=outFname.indexOf("/");return outFname=(v2736=-1!=v2736)?filePath(outFname):""}function filePathComponents(fullPath){fullPath=
switchToForwardSlashes(fullPath);fullPath=getPathComponents(fullPath);var v13035=fullPath.length,v13035=v13035-1;return fullPath.slice(0,v13035)}function filePath(fullPath){fullPath=filePathComponents(fullPath);fullPath=fullPath.join("/");return fullPath+"/"}function normalizeURL(url){var hostDomainAndPortRegex=/^(https?:\/\/[\-\w\.]+(:\d+)?\/)(.*)$/i;return(hostDomainAndPortRegex=JAMScript.call(hostDomainAndPortRegex.exec,hostDomainAndPortRegex,[url]))?(url=hostDomainAndPortRegex[1],hostDomainAndPortRegex=
hostDomainAndPortRegex[3],hostDomainAndPortRegex=normalizePath(hostDomainAndPortRegex),url+hostDomainAndPortRegex):normalizePath(url)}function normalizePath(path){path=switchToForwardSlashes(path);var v2741=path.charAt(0),v2741="/"===v2741;path=JAMScript.call(this.getPathComponents,this,[path]);for(var i=0,v13036=path.length,v13036=i<v13036;v13036;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v13036=path[i];var v13036="."===v13036,v19148=!v13036;if(v19148){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v13036=
path[i];v13036=""===v13036}v13036&&(path.splice(i,1),i-=1);if(v13036=0<i){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v13036=path[i];if(v13036=".."===v13036){v13036=i-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v13036=path[v13036];v13036=".."!==v13036}}v13036&&(v13036=i-1,path.splice(v13036,2),i-=2);i+=1;v13036=path.length;v13036=i<v13036}v2741=v2741?"/":"";path=path.join("/");return v2741+path}function normalizeImportPath(path){return normalizePath(path)}
TypeScript.stripQuotes=stripQuotes;TypeScript.isQuoted=isQuoted;TypeScript.quoteStr=quoteStr;TypeScript.swapQuotes=swapQuotes;TypeScript.switchToForwardSlashes=switchToForwardSlashes;TypeScript.trimModName=trimModName;TypeScript.getDeclareFilePath=getDeclareFilePath;TypeScript.isJSFile=isJSFile;TypeScript.isSTRFile=isSTRFile;TypeScript.isTSFile=isTSFile;TypeScript.isDSTRFile=isDSTRFile;TypeScript.isDTSFile=isDTSFile;TypeScript.getPrettyName=getPrettyName;TypeScript.getPathComponents=getPathComponents;
TypeScript.getRelativePathToFixedPath=getRelativePathToFixedPath;TypeScript.quoteBaseName=quoteBaseName;TypeScript.changePathToSTR=changePathToSTR;TypeScript.changePathToDSTR=changePathToDSTR;TypeScript.changePathToTS=changePathToTS;TypeScript.changePathToDTS=changePathToDTS;TypeScript.isRelative=isRelative;TypeScript.isRooted=isRooted;TypeScript.getRootFilePath=getRootFilePath;TypeScript.filePathComponents=filePathComponents;TypeScript.filePath=filePath;TypeScript.normalizeURL=normalizeURL;TypeScript.pathNormalizeRegExp=
/\//g;TypeScript.normalizePath=normalizePath;TypeScript.normalizeImportPath=normalizeImportPath}
function v1172(){var TypeScript=v12366;function v1171(){function TypeLink(){this.ast=this.type=null}return TypeLink}function v1170(_super){function v1169(moduleType){var moduleName=null,moduleName=this.members,moduleName=moduleName.allMembers,moduleName=JAMScript.call(ModuleType.findDynamicModuleNameInHashTable,ModuleType,[moduleType,moduleName]),v2750=null==moduleName;v2750&&(moduleName=this.ambientMembers,moduleName=moduleName.allMembers,moduleName=JAMScript.call(ModuleType.findDynamicModuleNameInHashTable,
ModuleType,[moduleType,moduleName]));return moduleName}function findDynamicModuleNameInHashTable(moduleType,members){function v1168(key,s,c){if(c=null==moduleName)c=JAMScript.call(TypeScript.isQuoted,TypeScript,[key]),c=!c;c&&(c=JAMScript.call(s.getType,s,[]),(c=c==moduleType)&&(moduleName={name:key,symbol:s}))}var moduleName=null;JAMScript.call(members.map,members,[v1168,null]);return moduleName}function v1167(){return null}function v1166(){return null}function v1165(){return this.ambientEnclosedTypes}
function v1164(){return this.enclosedTypes}function v1163(){var v13044=this.members,v13044=null!=v13044,v13046=!v13044;v13046&&(v13044=this.enclosedTypes,v13044=null!=v13044);return v13044}function v1162(){return!0}function ModuleType(enclosedTypes,ambientEnclosedTypes){JAMScript.call(_super.call,_super,[this]);this.enclosedTypes=enclosedTypes;this.ambientEnclosedTypes=ambientEnclosedTypes;this.importedModules=[]}JAMScript.call(__extends,null,[ModuleType,_super]);var v2754=ModuleType.prototype;v2754.isModuleType=
v1162;v2754=ModuleType.prototype;v2754.hasMembers=v1163;v2754=ModuleType.prototype;v2754.getAllEnclosedTypes=v1164;v2754=ModuleType.prototype;v2754.getAllAmbientEnclosedTypes=v1165;v2754=ModuleType.prototype;v2754.getPublicEnclosedTypes=v1166;v2754=ModuleType.prototype;v2754.getpublicAmbientEnclosedTypes=v1167;ModuleType.findDynamicModuleNameInHashTable=findDynamicModuleNameInHashTable;v2754=ModuleType.prototype;v2754.findDynamicModuleName=v1169;return ModuleType}function v1161(){function v1160(){var v13047=
this.elementType,v19152=!v13047;v19152&&(v13047=this.symbol,v13047=!v13047);if(v13047)return[];v13047=JAMScript.call(this.isClassInstance,this,[]);(v19152=!v13047)&&(v13047=JAMScript.call(this.isClass,this,[]));if(v13047){v13047=this.symbol;v13047=v13047.declAST;v13047=v13047.nodeType;v19152=TypeScript.NodeType;v19152=v19152.FuncDecl;if(v13047=v13047==v19152)return v13047=this.symbol,v13047=v13047.declAST,v13047=v13047.classDecl,JAMScript.call(v13047.getDocComments,v13047,[]);v13047=this.symbol;return JAMScript.call(v13047.getDocComments,
v13047,[])}v13047=this.symbol;if(v13047=v13047.name)if(v13047=this.symbol,v13047=v13047.name,v13047="_anonymous"!=v13047){v13047=this.call;if(v13047=null==v13047)if(v13047=this.construct,v13047=null==v13047)v13047=this.index,v13047=null==v13047;if(v19152=!v13047)v13047=this.members}return v13047?(v13047=this.symbol,JAMScript.call(v13047.getDocComments,v13047,[])):[]}function v1159(){return null}function v1158(){return null}function v1157(){return null}function v1156(){return null}function v1155(){var v2768=
this.members;return null!=v2768}function v1154(){return!1}function v1153(b,checker,acceptVoid,comparisonInfo){var v19159=checker.anyType,v19159=this==v19159,v19161=!v19159;v19161&&(v19159=checker.anyType,v19159=b==v19159);if(v19159)return checker.anyType;if(v19159=this==b)return this;v19159=checker.nullType;if(v19159=b==v19159)v19159=checker.nullType,v19159=this!=v19159;if(v19159)return this;v19159=checker.nullType;if(v19159=this==v19159)v19159=checker.nullType,v19159=b!=v19159;if(v19159)return b;
if(v19159=acceptVoid)if(v19159=checker.voidType,v19159=b==v19159)v19159=checker.voidType,v19159=this!=v19159;if(v19159)return this;if(v19159=acceptVoid)if(v19159=checker.voidType,v19159=this==v19159)v19159=checker.voidType,v19159=b!=v19159;if(v19159)return b;v19159=checker.undefinedType;if(v19159=b==v19159)v19159=checker.undefinedType,v19159=this!=v19159;if(v19159)return this;v19159=checker.undefinedType;if(v19159=this==v19159)v19159=checker.undefinedType,v19159=b!=v19159;if(v19159)return b;if(v19159=
this.elementType)v19159=b.elementType;if(v19159){v19159=this.elementType;v19161=b.elementType;if(v19159=v19159==v19161)return this;v19159=this.elementType;b=b.elementType;comparisonInfo=JAMScript.call(v19159.mergeOrdered,v19159,[b,checker,acceptVoid,comparisonInfo]);if(b=null==comparisonInfo)comparisonInfo=checker.anyType;return JAMScript.call(checker.makeArrayType,checker,[comparisonInfo])}return(acceptVoid=JAMScript.call(checker.sourceIsSubtypeOfTarget,checker,[this,b,comparisonInfo]))?b:(checker=
JAMScript.call(checker.sourceIsSubtypeOfTarget,checker,[b,this,comparisonInfo]))?this:null}function v1152(baseType){var v2789=baseType==this;if(v2789)return!0;if(v2789=this.extendsList)for(var v2789=0,v2785=this.extendsList,v2785=v2785.length,v2787=v2789<v2785;v2787;){v2787=this.extendsList;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v2787=v2787[v2789];if(v2787=JAMScript.call(v2787.hasBase,v2787,[baseType]))return!0;v2789+=1;v2787=v2789<v2785}return!1}function v1151(pattern,
replacement,checker,membersOnly){function v1150(key,s,unused){key=s;key=JAMScript.call(key.specializeType,key,[pattern,replacement,checker]);s=result.ambientMembers;unused=key.name;JAMScript.call(s.addPrivateMember,s,[unused,key])}function v1149(key,s,unused){key=s;key=JAMScript.call(key.specializeType,key,[pattern,replacement,checker]);s=result.ambientMembers;unused=key.name;JAMScript.call(s.addPublicMember,s,[unused,key])}function v1148(key,s,unused){key=s;key=JAMScript.call(key.specializeType,
key,[pattern,replacement,checker]);s=result.members;unused=key.name;JAMScript.call(s.addPrivateMember,s,[unused,key])}function v1147(key,s,unused){key=s;key=JAMScript.call(key.specializeType,key,[pattern,replacement,checker]);s=result.members;unused=key.name;JAMScript.call(s.addPublicMember,s,[unused,key])}var v2798=pattern==this;if(v2798)return replacement;var result=this;if(membersOnly){if(membersOnly=JAMScript.call(this.isReferenceType,this,[])){result=new Type;if(membersOnly=this.members){membersOnly=
result;var v2798=TypeScript.ScopedMembers,v19173=TypeScript.DualStringHashTable,v22962=TypeScript.StringHashTable,v22962=JAMScript.new(v22962,[]),v22963=TypeScript.StringHashTable,v22963=JAMScript.new(v22963,[]),v19173=JAMScript.new(v19173,[v22962,v22963]),v2798=JAMScript.new(v2798,[v19173]);membersOnly.members=v2798;membersOnly=this.members;membersOnly=membersOnly.publicMembers;JAMScript.call(membersOnly.map,membersOnly,[v1147,null]);membersOnly=this.members;membersOnly=membersOnly.privateMembers;
JAMScript.call(membersOnly.map,membersOnly,[v1148,null])}if(membersOnly=this.ambientMembers)membersOnly=result,v2798=TypeScript.ScopedMembers,v19173=TypeScript.DualStringHashTable,v22962=TypeScript.StringHashTable,v22962=JAMScript.new(v22962,[]),v22963=TypeScript.StringHashTable,v22963=JAMScript.new(v22963,[]),v19173=JAMScript.new(v19173,[v22962,v22963]),v2798=JAMScript.new(v2798,[v19173]),membersOnly.ambientMembers=v2798,membersOnly=this.ambientMembers,membersOnly=membersOnly.publicMembers,JAMScript.call(membersOnly.map,
membersOnly,[v1149,null]),membersOnly=this.ambientMembers,membersOnly=membersOnly.privateMembers,JAMScript.call(membersOnly.map,membersOnly,[v1150,null]);membersOnly=result;v2798=JAMScript.call(checker.scopeOf,checker,[result]);membersOnly.containedScope=v2798;result.memberScope=result.containedScope}}else if(membersOnly=this.elementType)if(membersOnly=this.elementType,membersOnly=membersOnly==pattern)result=JAMScript.call(checker.makeArrayType,checker,[replacement]);else{if(membersOnly=this.elementType,
membersOnly=membersOnly.elementType,membersOnly=membersOnly==pattern)membersOnly=JAMScript.call(checker.makeArrayType,checker,[replacement]),result=JAMScript.call(checker.makeArrayType,checker,[membersOnly])}else if(membersOnly=this.call)membersOnly=result=new Type,v2798=this.call,v2798=JAMScript.call(v2798.specializeType,v2798,[pattern,replacement,checker]),membersOnly.call=v2798;return result}function v1146(){var v2815=this.members,v13076=!v2815;v13076&&(v2815=this.extendsList,v13076=!v2815)&&(v2815=
this.construct,v13076=!v2815)&&(v2815=this.call,v13076=!v2815)&&(v2815=this.index,v13076=!v2815)&&(v2815=this.elementType);return v2815}function v1145(flow){var v13077=flow.anyType;if(v13077=this==v13077)return null;if(v13077=JAMScript.call(this.isDouble,this,[]))return(v13077=flow.numberInterfaceType)?(flow=flow.numberInterfaceType,flow.memberScope):null;if(v13077=JAMScript.call(this.isBoolean,this,[]))return(v13077=flow.booleanInterfaceType)?(flow=flow.booleanInterfaceType,flow.memberScope):null;
v13077=flow.stringType;if(v13077=this==v13077)return(v13077=flow.stringInterfaceType)?(flow=flow.stringInterfaceType,flow.memberScope):null;if(v13077=this.elementType){if(v13077=flow.arrayInterfaceType){var v13077=this.elementType,v2823=flow.arrayInterfaceType;flow=flow.checker;flow=JAMScript.call(v13077.getArrayBase,v13077,[v2823,flow]);return flow.memberScope}return null}return this.memberScope}function v1144(checker){var v13079=JAMScript.call(this.isClassInstance,this,[]),v19182=!v13079;v19182&&
(v13079=JAMScript.call(this.isClass,this,[]));v13079&&(v13079=this.symbol,v13079=v13079.declAST)&&(checker=checker.typeFlow,v13079=this.symbol,v13079=v13079.declAST,JAMScript.call(checker.inScopeTypeCheckDecl,checker,[v13079]))}function v1143(prefix,topLevel,isElementType,scope){function v1142(key,s,unused){key=s;s=key.flags;unused=TypeScript.SymbolFlags;unused=unused.BuiltIn;s=JAMScript.call(TypeScript.hasFlag,TypeScript,[s,unused]);if(s=!s){key=JAMScript.call(key.getTypeNameEx,key,[scope]);if(s=
JAMScript.call(key.isArray,key,[]))s=key.delim,s=s==delim;s?(key=key.entries,JAMScript.call(allMemberNames.addAll,allMemberNames,[key])):JAMScript.call(allMemberNames.add,allMemberNames,[key]);memCount+=1;curlies=!0}}var v2857=this.elementType;if(v2857)return topLevel=this.elementType,topLevel=JAMScript.call(topLevel.getMemberTypeNameEx,topLevel,[prefix,!1,!0,scope]),JAMScript.call(MemberName.create,MemberName,[topLevel,"","[]"]);if(v2857=this.symbol)if(v2857=this.symbol,v2857=v2857.name)if(v2857=
this.symbol,v2857=v2857.name,v2857="_anonymous"!=v2857){v2857=this.call;if(v2857=null==v2857)if(v2857=this.construct,v2857=null==v2857)v2857=this.index,v2857=null==v2857;var v25762=!v2857;v25762&&(v2857=this.typeFlags,v25762=TypeScript.TypeFlags,v25762=v25762.BuildingName,v2857=JAMScript.call(TypeScript.hasFlag,TypeScript,[v2857,v25762]),v25762=!v2857)&&(v2857=this.members)&&(v2857=JAMScript.call(this.isClass,this,[]),v2857=!v2857)}if(v2857)return topLevel=this.symbol,topLevel=JAMScript.call(topLevel.scopeRelativeName,
topLevel,[scope]),topLevel=(prefix="null"==topLevel)?"any":topLevel,JAMScript.call(MemberName.create,MemberName,[topLevel]);v2857=this.members;if(v25762=!v2857)if(v2857=this.call,v25762=!v2857)v2857=this.construct;if(v2857){v2857=this.typeFlags;v25762=TypeScript.TypeFlags;v25762=v25762.BuildingName;if(v2857=JAMScript.call(TypeScript.hasFlag,TypeScript,[v2857,v25762]))return JAMScript.call(MemberName.create,MemberName,["this"]);v2857=this.typeFlags;v25762=TypeScript.TypeFlags;v25762=v25762.BuildingName;
this.typeFlags=v2857|v25762;var allMemberNames=JAMScript.new(MemberNameArray,[]);if(v2857=!isElementType)isElementType=this.index,isElementType=null!=isElementType;var curlies=isElementType,memCount=0,delim="; ";if(isElementType=this.members)isElementType=this.members,isElementType=isElementType.allMembers,JAMScript.call(isElementType.map,isElementType,[v1142,null]);isElementType=JAMScript.call(this.callCount,this,[]);(v2857=!curlies)&&(v2857=1==isElementType)&&(v2857=topLevel);if(v25762=this.call)v25762=
this.call,prefix=JAMScript.call(v25762.toStrings,v25762,[prefix,v2857,scope]),JAMScript.call(allMemberNames.addAll,allMemberNames,[prefix]);if(prefix=this.construct)prefix=this.construct,prefix=JAMScript.call(prefix.toStrings,prefix,["new",v2857,scope]),JAMScript.call(allMemberNames.addAll,allMemberNames,[prefix]);if(prefix=this.index)prefix=this.index,prefix=JAMScript.call(prefix.toStrings,prefix,["",v2857,scope]),JAMScript.call(allMemberNames.addAll,allMemberNames,[prefix]);prefix=curlies;(v2857=
!prefix)&&(prefix=1<isElementType)&&(prefix=topLevel);if(topLevel=prefix)allMemberNames.prefix="{ ",allMemberNames.suffix="}",allMemberNames.delim=delim;else if(topLevel=allMemberNames.entries,topLevel=topLevel.length,topLevel=1<topLevel)allMemberNames.delim=delim;topLevel=this.typeFlags;prefix=TypeScript.TypeFlags;prefix=prefix.BuildingName;prefix=~prefix;this.typeFlags=topLevel&prefix;(topLevel=0==isElementType)&&(topLevel=0==memCount);return topLevel?JAMScript.call(MemberName.create,MemberName,
["{}"]):allMemberNames}return JAMScript.call(MemberName.create,MemberName,["{}"])}function v1141(prefix,topLevel,isElementType,scope){prefix=JAMScript.call(this.getMemberTypeNameEx,this,[prefix,topLevel,isElementType,scope]);return JAMScript.call(prefix.toString,prefix,[])}function v1140(){var total=0,v2858=this.call;v2858&&(v2858=this.call,v2858=v2858.signatures,v2858=v2858.length,total+=v2858);if(v2858=this.construct)v2858=this.construct,v2858=v2858.signatures,v2858=v2858.length,total+=v2858;if(v2858=
this.index)v2858=this.index,v2858=v2858.signatures,v2858=v2858.length,total+=v2858;return total}function v1139(scope){return JAMScript.call(this.getMemberTypeNameEx,this,["",!0,!1,scope])}function v1138(scope){return JAMScript.call(this.getMemberTypeName,this,["",!0,!1,scope])}function v1137(){return JAMScript.call(this.getMemberTypeName,this,["",!0,!1,null])}function v1136(){var v2861=this.primitiveTypeClass,v2862=Primitive.Null;return JAMScript.call(TypeScript.hasFlag,TypeScript,[v2861,v2862])}
function v1135(){var v2863=this.primitiveTypeClass,v2864=Primitive.Boolean;return JAMScript.call(TypeScript.hasFlag,TypeScript,[v2863,v2864])}function v1134(){var v2865=this.primitiveTypeClass,v2866=Primitive.String;return JAMScript.call(TypeScript.hasFlag,TypeScript,[v2865,v2866])}function v1133(){var v2867=this.primitiveTypeClass,v2868=Primitive.Double;return JAMScript.call(TypeScript.hasFlag,TypeScript,[v2867,v2868])}function v1132(){var v13107=this.typeFlags,v19199=TypeScript.TypeFlags,v19199=
v19199.HasImplementation;this.typeFlags=v13107|v19199}function v1131(){var v2869=this.typeFlags,v13109=TypeScript.TypeFlags,v13109=v13109.HasImplementation;return JAMScript.call(TypeScript.hasFlag,TypeScript,[v2869,v13109])}function v1130(){var v2871=JAMScript.call(this.isClass,this,[]);return v2871?this.instanceType:this}function v1129(){var v2872=this.symbol;v2872&&(v2872=this.elementType,v2872=!v2872)&&(v2872=this.symbol,v2872=v2872.type,v2872=JAMScript.call(v2872.isClass,v2872,[]));return v2872}
function v1128(){var v2873=this.elementType;return null!=v2873}function v1127(){var v2874=this.instanceType;return null!=v2874}function v1126(arrInstType,checker){var v2875=this.arrayCache;return JAMScript.call(v2875.specialize,v2875,[arrInstType,checker])}function v1125(){var v13111=this.extendsList;v13111&&(v13111=this.extendsList,v13111=v13111.length,v13111=0<v13111);return v13111?(v13111=this.extendsList,v13111[0]):null}function Type(){this.typeID=currentTypeID;currentTypeID+=1;this.index=this.call=
this.construct=null;var v2878=TypeScript.CompilerDiagnostics;this.passTypeCreated=v2878.analysisPass;this.primitiveTypeClass=Primitive.None;v2878=TypeScript.TypeFlags;this.typeFlags=v2878.None}var v2880=Type.prototype;v2880.baseClass=v1125;v2880=Type.prototype;v2880.getArrayBase=v1126;v2880=Type.prototype;v2880.isClass=v1127;v2880=Type.prototype;v2880.isArray=v1128;v2880=Type.prototype;v2880.isClassInstance=v1129;v2880=Type.prototype;v2880.getInstanceType=v1130;v2880=Type.prototype;v2880.hasImplementation=
v1131;v2880=Type.prototype;v2880.setHasImplementation=v1132;v2880=Type.prototype;v2880.isDouble=v1133;v2880=Type.prototype;v2880.isString=v1134;v2880=Type.prototype;v2880.isBoolean=v1135;v2880=Type.prototype;v2880.isNull=v1136;v2880=Type.prototype;v2880.getTypeName=v1137;v2880=Type.prototype;v2880.getScopedTypeName=v1138;v2880=Type.prototype;v2880.getScopedTypeNameEx=v1139;v2880=Type.prototype;v2880.callCount=v1140;v2880=Type.prototype;v2880.getMemberTypeName=v1141;v2880=Type.prototype;v2880.getMemberTypeNameEx=
v1143;v2880=Type.prototype;v2880.checkDecl=v1144;v2880=Type.prototype;v2880.getMemberScope=v1145;v2880=Type.prototype;v2880.isReferenceType=v1146;v2880=Type.prototype;v2880.specializeType=v1151;v2880=Type.prototype;v2880.hasBase=v1152;v2880=Type.prototype;v2880.mergeOrdered=v1153;v2880=Type.prototype;v2880.isModuleType=v1154;v2880=Type.prototype;v2880.hasMembers=v1155;v2880=Type.prototype;v2880.getAllEnclosedTypes=v1156;v2880=Type.prototype;v2880.getAllAmbientEnclosedTypes=v1157;v2880=Type.prototype;
v2880.getPublicEnclosedTypes=v1158;v2880=Type.prototype;v2880.getpublicAmbientEnclosedTypes=v1159;v2880=Type.prototype;v2880.getDocComments=v1160;return Type}function v1124(_super){function v1123(entries){for(var i=0,v13112=entries.length,v13112=i<v13112;v13112;){v13112=this.entries;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v2912=entries[i];JAMScript.call(v13112.push,v13112,[v2912]);i+=1;v13112=entries.length;v13112=i<v13112}}function v1122(entry){var v2914=
this.entries;JAMScript.call(v2914.push,v2914,[entry])}function v1121(){return!0}function MemberNameArray(){JAMScript.call(_super.apply,_super,[this,arguments]);this.delim="";this.entries=[]}JAMScript.call(__extends,null,[MemberNameArray,_super]);var v2915=MemberNameArray.prototype;v2915.isArray=v1121;v2915=MemberNameArray.prototype;v2915.add=v1122;v2915=MemberNameArray.prototype;v2915.addAll=v1123;return MemberNameArray}function v1120(_super){function v1119(){return!0}function MemberNameString(text){JAMScript.call(_super.call,
_super,[this]);this.text=text}JAMScript.call(__extends,null,[MemberNameString,_super]);var v2918=MemberNameString.prototype;v2918.isString=v1119;return MemberNameString}function v1118(){function create(arg1,arg2,arg3){var v13114=typeof arg1;if(v13114="string"==v13114)return JAMScript.new(MemberNameString,[arg1]);v13114=JAMScript.new(MemberNameArray,[]);arg2&&(v13114.prefix=arg2);arg3&&(v13114.suffix=arg3);arg2=v13114.entries;JAMScript.call(arg2.push,arg2,[arg1]);return v13114}function memberNameToString(memberName){var result=
memberName.prefix,v2922=JAMScript.call(memberName.isString,memberName,[]);if(v2922)v2922=memberName.text,result+=v2922;else for(var v2922=memberName,index=0,v19203=v2922.entries,v19203=v19203.length,v19203=index<v19203;v19203;){v19203=v2922.entries;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v19203=v19203[index];v19203=JAMScript.call(MemberName.memberNameToString,MemberName,[v19203]);result+=v19203;v19203=v2922.delim;result+=v19203;index+=1;v19203=v2922.entries;
v19203=v19203.length;v19203=index<v19203}memberName=memberName.suffix;return result+=memberName}function v1117(){return JAMScript.call(MemberName.memberNameToString,MemberName,[this])}function v1116(){return!1}function v1115(){return!1}function MemberName(){this.suffix=this.prefix=""}var v2923=MemberName.prototype;v2923.isString=v1115;v2923=MemberName.prototype;v2923.isArray=v1116;v2923=MemberName.prototype;v2923.toString=v1117;MemberName.memberNameToString=memberNameToString;MemberName.create=create;
return MemberName}function v1114(Primitive){Primitive._map=[];Primitive.None=0;Primitive.Void=1;Primitive.Double=2;Primitive.String=4;Primitive.Boolean=8;Primitive.Any=16;Primitive.Null=32;Primitive.Undefined=64}function getTypeLink(ast,checker,autoVar){var result=JAMScript.new(TypeLink,[]);result.ast=ast;(ast=null==ast)&&(ast=autoVar);autoVar=ast;result.type=autoVar?checker.anyType:null;return result}var v13123=TypeScript.Primitive,v19206=!v13123;v19206&&(v13123=TypeScript.Primitive={});v1114(v13123);
var Primitive=TypeScript.Primitive,MemberName=v1118();TypeScript.MemberName=MemberName;var MemberNameString=v1120(MemberName);TypeScript.MemberNameString=MemberNameString;var MemberNameArray=v1124(MemberName);TypeScript.MemberNameArray=MemberNameArray;var currentTypeID=-1,v13123=v1161();TypeScript.Type=v13123;v13123=v1170(v13123);TypeScript.ModuleType=v13123;var TypeLink=v1171();TypeScript.TypeLink=TypeLink;TypeScript.getTypeLink=getTypeLink}
function v1113(){var TypeScript=v12365;function v1112(){function v1111(enclosingScopeContext){function preFindMemberScopeFullAstFuzy(ast,parent,walker){if(parent=JAMScript.call(TypeScript.isValidAstNode,TypeScript,[ast])){parent=ast.flags;if(parent=JAMScript.call(TypeScript.hasFlag,TypeScript,[parent,matchFlag]))if(parent=ast.minChar,parent=parent<pos)parent=ast.limChar,parent=pos<=parent;parent&&(astResult=ast);walker=walker.options;parent=ast.minChar;if(parent=parent<=pos)parent=ast.limChar,parent=
pos<=parent;walker.goChildren=parent}return ast}function preFindMemberScopeFullAst(ast,parent,walker){if(parent=JAMScript.call(TypeScript.isValidAstNode,TypeScript,[ast])){parent=ast.flags;if(parent=JAMScript.call(TypeScript.hasFlag,TypeScript,[parent,matchFlag])){parent=ast.limChar;parent=pos==parent;var v22984=!parent;v22984&&(parent=pos-1,v22984=ast.limChar,parent=parent==v22984)}parent&&(astResult=ast,parent=walker.options,JAMScript.call(parent.stopWalk,parent,[]));walker=walker.options;parent=
ast.minChar;if(parent=parent<=pos)parent=ast.limChar,parent=pos<=parent;walker.goChildren=parent}return ast}var v2935=TypeScript.ASTFlags,matchFlag=v2935.DotLHS,pos=enclosingScopeContext.pos,astResult=null,v2935=JAMScript.call(TypeScript.getAstWalkerFactory,TypeScript,[]),v2937=enclosingScopeContext.script;JAMScript.call(v2935.walk,v2935,[v2937,preFindMemberScopeFullAst]);if(v2935=null==astResult)v2935=JAMScript.call(TypeScript.getAstWalkerFactory,TypeScript,[]),v2937=enclosingScopeContext.script,
JAMScript.call(v2935.walk,v2935,[v2937,preFindMemberScopeFullAstFuzy]);if(v2935=astResult)if(v2935=enclosingScopeContext.enclosingClassDecl)v2935=astResult.type,v2937=enclosingScopeContext.enclosingClassDecl,v2937=v2937.type,v2937=v2937.instanceType,v2935=v2935==v2937;v2935&&(enclosingScopeContext.publicsOnly=!1);if(enclosingScopeContext=astResult)enclosingScopeContext=astResult.type;return enclosingScopeContext?(enclosingScopeContext=astResult.type,JAMScript.call(enclosingScopeContext.getMemberScope,
enclosingScopeContext,[this])):null}function v1110(enclosingScopeContext){var v13130=TypeScript.ASTFlags,v13130=v13130.DotLHS;return JAMScript.call(this.findMemberScope,this,[enclosingScopeContext,v13130])}function v1109(enclosingScopeContext,matchFlag){var enclosingScope=JAMScript.call(enclosingScopeContext.getScope,enclosingScopeContext,[]),v2945=enclosingScopeContext.pos,v13131=enclosingScopeContext.scopeStartAST,v13131=v13131.minChar,v2945=v2945-v13131,v13131=JAMScript.call(enclosingScopeContext.getScriptFragment,
enclosingScopeContext,[]),v2947=TypeScript.MemberScopeContext,v2945=JAMScript.new(v2947,[this,v2945,matchFlag]);v2945.scope=enclosingScope;enclosingScope=v13131.nodeType;v2947=TypeScript.NodeType;v2947=v2947.Name;if(enclosingScope=enclosingScope==v2947)return v2945=v13131.type,JAMScript.call(v2945.getMemberScope,v2945,[this]);enclosingScope=JAMScript.call(TypeScript.getAstWalkerFactory,TypeScript,[]);v2947=TypeScript.preFindMemberScope;JAMScript.call(enclosingScope.walk,enclosingScope,[v13131,v2947,
null,null,v2945]);if(v13131=v2945.ast)if(v13131=enclosingScopeContext.enclosingClassDecl)v13131=v2945.ast,v13131=v13131.type,enclosingScope=enclosingScopeContext.enclosingClassDecl,enclosingScope=enclosingScope.type,enclosingScope=enclosingScope.instanceType,v13131=v13131==enclosingScope;v13131&&(enclosingScopeContext.publicsOnly=!1);return(v13131=v2945.type)?(v2945=v2945.type,JAMScript.call(v2945.getMemberScope,v2945,[this])):null}function v1108(ast){var script=ast,v2955=this.checker;v2955.locationInfo=
script.locationInfo;var script=this.checker,script=script.gloMod,v2955=this.globalScope,script=JAMScript.new(ScopeChain,[script,null,v2955]),v2955=TypeScript.AssignScopeContext,v19218=this.checker,v19218=v19218.currentModDecl,v19218=[v19218],script=JAMScript.new(v2955,[script,this,v19218]),v2955=JAMScript.call(TypeScript.getAstWalkerFactory,TypeScript,[]),v19218=TypeScript.preAssignScopes,v2962=TypeScript.postAssignScopes;JAMScript.call(v2955.walk,v2955,[ast,v19218,v2962,null,script])}function v1107(ast){var callEx=
ast,v22989=this.checker,v22989=v22989.styleSettings;if(v22989=v22989.newMustBeUsed)var v22989=ast.nodeType,v22990=TypeScript.NodeType,v22990=v22990.New,v22989=v22989==v22990;if(v22989){if(v22989=ast.flags,v22990=TypeScript.ASTFlags,v22990=v22990.IsStatement,v22989=JAMScript.call(TypeScript.hasFlag,TypeScript,[v22989,v22990]))v22989=this.checker,v22989=v22989.errorReporter,JAMScript.call(v22989.styleError,v22989,[ast,"use of new expression as a statement"])}else{v22989=this.checker;v22989=v22989.styleSettings;
v22989=v22989.evalOK;if(v22989=!v22989)ast=ast.nodeType,v22989=TypeScript.NodeType,v22989=v22989.Call,v22989=ast==v22989;if(ast=v22989){ast=callEx.target;ast=ast.nodeType;v22989=TypeScript.NodeType;v22989=v22989.Name;if(ast=ast==v22989)ast=callEx.target,ast=ast.text,ast="eval"==ast;ast&&(ast=this.checker,ast=ast.errorReporter,JAMScript.call(ast.styleError,ast,[callEx,"eval not permitted"]))}}ast=callEx.target;ast=ast.nodeType;v22989=TypeScript.NodeType;v22989=v22989.FuncDecl;if(ast=ast==v22989)ast=
callEx.target,ast.isInlineCallLiteral=!0;ast=this.inSuperCall;v22989=callEx.target;v22989=v22989.nodeType;v22990=TypeScript.NodeType;v22990=v22990.Super;if(v22989=v22989==v22990)this.inSuperCall=!0;v22989=callEx;v22990=callEx.target;v22990=JAMScript.call(this.typeCheck,this,[v22990]);v22989.target=v22990;v22989=callEx.arguments;JAMScript.call(this.preTypeCheckCallArgs,this,[v22989]);var v22989=callEx.target,v22990=v22989.type,v22990=null==v22990,v19235=!v22990;v19235&&(v22990=v22989.type,v19235=this.anyType,
v22990=v22990==v19235,v19235=!v22990)&&(v22990=this.functionInterfaceType)&&(v22990=v22989.type,v19235=this.functionInterfaceType,v22990=v22990==v19235);if(v22990)callEx.type=this.anyType;else if(v22989=v22989.type,v22990=v22989.call)v22989=v22989.call,v22989=JAMScript.call(this.resolveOverload,this,[callEx,v22989]),(v22990=null==v22989)?callEx.type=this.anyType:(v22990=v22989.returnType,callEx.type=v22990.type,callEx.signature=v22989);else{v22990=callEx.target;v22990=v22990.nodeType;v19235=TypeScript.NodeType;
v19235=v19235.Super;if(v22990=v22990==v19235)if(v22990=this.thisFnc)if(v22990=this.thisFnc,v22990=v22990.isConstructor)v22990=this.thisFnc,v22990=v22990.fncFlags,v19235=TypeScript.FncFlags,v19235=v19235.ClassMethod,v22990=JAMScript.call(TypeScript.hasFlag,TypeScript,[v22990,v19235]);v22990?(v22990=v22989.symbol,v22990=v22990.type,(v22990=v22990.construct)?(v22989=v22989.symbol,v22989=v22989.type,v22989=v22989.construct,v22989=JAMScript.call(this.resolveOverload,this,[callEx,v22989])):v22989=null,
(v22990=null==v22989)?callEx.type=this.anyType:(v22990=callEx.flags,v19235=TypeScript.ASTFlags,v19235=v19235.ClassBaseConstructorCall,callEx.flags=v22990|v19235,v22990=v22989.returnType,callEx.type=v22990.type,callEx.signature=v22989)):(callEx.type=this.anyType,v22989=this.checker,v22989=v22989.errorReporter,v22990=callEx.nodeType,v19235=this.scope,JAMScript.call(v22989.invalidCall,v22989,[callEx,v22990,v19235]))}JAMScript.call(this.postTypeCheckCallArgs,this,[callEx]);this.inSuperCall=ast;return callEx}
function v1106(callEx){var acceptedTargetType=!1,i=0;if(i=callEx.target)if(i=callEx.target,i=i.type)if(i=callEx.signature)i=callEx.arguments;if(i){var sig=callEx.signature;if(i=sig)var i=callEx.arguments,i=i.members,i=i.length,v19244=sig.nonOptionalParameterCount,i=i>=v19244;if(i){acceptedTargetType=!0;v19244=null;(i=sig.hasVariableArgList)?(i=sig.parameters,i=i.length,i-=1):(i=sig.parameters,i=i.length);v19244=callEx.arguments;v19244=v19244.members;v19244=v19244.length;if(v19244=v19244<i)i=callEx.arguments,
i=i.members,i=i.length;for(var nonVarArgActualParamLength=i,i=0,v19244=i<nonVarArgActualParamLength;v19244;){v19244=sig.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v19244=v19244[i];var v19244=JAMScript.call(v19244.getType,v19244,[]),v23009=callEx.arguments,v23009=v23009.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v23009=v23009[i];v23009=v23009.nodeType;switch(v23009){case TypeScript.NodeType.FuncDecl:case TypeScript.NodeType.ObjectLit:case TypeScript.NodeType.ArrayLit:var v13165=
v23009=this.checker,v13165=JAMScript.call(v13165.inProvisionalTypecheckMode,v13165,[]),v24845=sig.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v24845=v24845[i];var v24845=v24845.declAST,v24845=v24845.isParenthesized,v24845=!v24845,v19250=callEx.arguments,v19250=v19250.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v19250=v19250[i];JAMScript.call(v23009.typeCheckWithContextualType,v23009,[v19244,v13165,v24845,
v19250])}i+=1;v19244=i<nonVarArgActualParamLength}if(i=sig.hasVariableArgList){i=sig.nonOptionalParameterCount;i-=1;v19244=sig.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v19244=v19244[i];if(v19244=JAMScript.call(v19244.getType,v19244,[]))v19244=v19244.elementType;sig=sig.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)i=sig[i];i=i.declAST;i=i.isParenthesized;sig=!i;i=nonVarArgActualParamLength;nonVarArgActualParamLength=
callEx.arguments;nonVarArgActualParamLength=nonVarArgActualParamLength.members;nonVarArgActualParamLength=nonVarArgActualParamLength.length;for(nonVarArgActualParamLength=i<nonVarArgActualParamLength;nonVarArgActualParamLength;){nonVarArgActualParamLength=callEx.arguments;nonVarArgActualParamLength=nonVarArgActualParamLength.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)nonVarArgActualParamLength=nonVarArgActualParamLength[i];nonVarArgActualParamLength=
nonVarArgActualParamLength.nodeType;switch(nonVarArgActualParamLength){case TypeScript.NodeType.FuncDecl:case TypeScript.NodeType.ObjectLit:case TypeScript.NodeType.ArrayLit:v23009=nonVarArgActualParamLength=this.checker;v23009=JAMScript.call(v23009.inProvisionalTypecheckMode,v23009,[]);v13165=callEx.arguments;v13165=v13165.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v13165=v13165[i];JAMScript.call(nonVarArgActualParamLength.typeCheckWithContextualType,
nonVarArgActualParamLength,[v19244,v23009,sig,v13165])}i+=1;nonVarArgActualParamLength=callEx.arguments;nonVarArgActualParamLength=nonVarArgActualParamLength.members;nonVarArgActualParamLength=nonVarArgActualParamLength.length;nonVarArgActualParamLength=i<nonVarArgActualParamLength}}}}if(acceptedTargetType=!acceptedTargetType)acceptedTargetType=callEx.arguments;if(acceptedTargetType)for(acceptedTargetType=this.checker,JAMScript.call(acceptedTargetType.killCurrentContextualType,acceptedTargetType,
[]),i=0,acceptedTargetType=callEx.arguments,acceptedTargetType=acceptedTargetType.members,acceptedTargetType=acceptedTargetType.length,acceptedTargetType=i<acceptedTargetType;acceptedTargetType;){acceptedTargetType=callEx.arguments;acceptedTargetType=acceptedTargetType.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)acceptedTargetType=acceptedTargetType[i];acceptedTargetType=acceptedTargetType.nodeType;switch(acceptedTargetType){case TypeScript.NodeType.FuncDecl:case TypeScript.NodeType.ObjectLit:case TypeScript.NodeType.ArrayLit:acceptedTargetType=
callEx.arguments;acceptedTargetType=acceptedTargetType.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)acceptedTargetType=acceptedTargetType[i];JAMScript.call(this.typeCheck,this,[acceptedTargetType])}i+=1;acceptedTargetType=callEx.arguments;acceptedTargetType=acceptedTargetType.members;acceptedTargetType=acceptedTargetType.length;acceptedTargetType=i<acceptedTargetType}}function v1105(args){var v3011=!args;if(!v3011)for(var v3011=0,v19260=args.members,v19260=
v19260.length,v19260=v3011<v19260;v19260;){v19260=args.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v19260=v19260[v3011];v19260=v19260.nodeType;switch(v19260){case TypeScript.NodeType.FuncDecl:case TypeScript.NodeType.ObjectLit:case TypeScript.NodeType.ArrayLit:v3011+=1;v19260=args.members;v19260=v19260.length;v19260=v3011<v19260;continue;default:v19260=args.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v19260=
v19260[v3011];JAMScript.call(this.typeCheck,this,[v19260])}v3011+=1;v19260=args.members;v19260=v19260.length;v19260=v3011<v19260}}function v1104(ast){var v3015=ast,v13185=ast.target,v13185=JAMScript.call(this.typeCheck,this,[v13185]);v3015.target=v13185;var v3015=ast.target,v13185=v3015.type,v13185=v13185.construct,v19266=!v13185;v19266&&(v13185=v3015.type,v13185=v13185.call);v13185?(v13185=ast.arguments,JAMScript.call(this.preTypeCheckCallArgs,this,[v13185])):(v13185=ast,v19266=ast.arguments,v19266=
JAMScript.call(this.typeCheck,this,[v19266]),v13185.arguments=v19266);v13185=v3015.type;v19266=this.anyType;if(v13185=v13185==v19266)ast.type=this.anyType,v3015=ast,v13185=ast.arguments,v13185=JAMScript.call(this.typeCheck,this,[v13185]),v3015.arguments=v13185;else if(v13185=v3015.type,v13185=v13185.construct)v3015=v3015.type,v3015=v3015.construct,v3015=JAMScript.call(this.resolveOverload,this,[ast,v3015]),(v13185=null==v3015)?ast.type=this.anyType:(v13185=v3015.returnType,v13185=v13185.type,v19266=
this.voidType,(v13185=v13185==v19266)?ast.type=this.anyType:(v13185=v3015.returnType,ast.type=v13185.type),ast.signature=v3015);else if(v13185=v3015.type,v13185=v13185.call)if(v3015=v3015.type,v3015=v3015.call,v3015=JAMScript.call(this.resolveOverload,this,[ast,v3015]),v13185=null==v3015)ast.type=this.anyType;else{v13185=v3015.returnType;v13185=v13185.type;v19266=this.voidType;v13185=v13185==v19266;if(v19266=!v13185)v13185=v3015.returnType,v13185=v13185.type,v19266=this.anyType,v13185=v13185==v19266;
v13185?(ast.type=this.anyType,ast.signature=v3015):(v3015=this.checker,v3015=v3015.errorReporter,v13185=ast.target,JAMScript.call(v3015.simpleError,v3015,[v13185,"new expression only valid on constructors"]))}else v13185=v3015.type,(v13185=v13185.elementType)?ast.type=v3015.type:(v3015=this.checker,v3015=v3015.errorReporter,v13185=ast.nodeType,v19266=this.scope,JAMScript.call(v3015.invalidCall,v3015,[ast,v13185,v19266]),ast.type=this.anyType);JAMScript.call(this.postTypeCheckCallArgs,this,[ast]);
return ast}function v1103(application,group){var v3036=this.resolutionDataCache,v3036=JAMScript.call(v3036.getResolutionData,v3036,[]),actuals=v3036.actuals,exactCandidates=v3036.exactCandidates,conversionCandidates=v3036.conversionCandidates,candidate=null,v13201=group.signatures,v13201=v13201.length,hasOverloads=1<v13201,v13201=TypeScript.TypeComparisonInfo,comparisonInfo=JAMScript.new(v13201,[]),args=null,v13201=null,v19273=application.nodeType,v23020=TypeScript.NodeType,v23020=v23020.Call,v19273=
v19273==v23020;if(v23020=!v19273)v19273=application.nodeType,v23020=TypeScript.NodeType,v23020=v23020.New,v19273=v19273==v23020;if(v19273){if(v23020=application,args=v23020.arguments,v13201=v23020.target,v19273=v23020.arguments)for(var v19273=v23020.arguments,v19273=v19273.members,len=v19273.length,v19273=0,v3041=v19273<len;v3041;){v3041=v23020.arguments;v3041=v3041.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v3041=v3041[v19273];actuals[v19273]=v3041.type;
v19273+=1;v3041=v19273<len}}else if(v19273=application.nodeType,v23020=TypeScript.NodeType,v23020=v23020.Index,v19273=v19273==v23020)v19273=application,v13201=v19273.operand1,args=TypeScript.ASTList,args=JAMScript.new(args,[]),v23020=args.members,v19273=v23020[0]=v19273.operand2,actuals[0]=v19273.type;v19273=0;v23020=group.signatures;v23020=v23020.length;for(len=v19273<v23020;len;){len=group.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)len=len[v19273];
if(v3041=hasOverloads)if(v3041=group.definitionSignature,v3041=len==v3041)v3041=this.checker,v3041=v3041.canCallDefinitionSignature,v3041=!v3041;if(!v3041){v3041=len.returnType;v3041=v3041.type;if(v3041=!v3041)if(v3041=len.declAST)var v3041=len.typeCheckStatus,v24847=TypeScript.TypeCheckStatus,v24847=v24847.Finished,v3041=v3041!=v24847;v3041&&(v3041=len.declAST,JAMScript.call(this.typeCheckFunction,this,[v3041]));JAMScript.call(this.tryAddCandidates,this,[len,actuals,exactCandidates,conversionCandidates,
comparisonInfo])}v19273+=1;len=v19273<v23020}actuals=exactCandidates.length;if(actuals=0==actuals)if(exactCandidates=this.checker,exactCandidates=JAMScript.call(exactCandidates.getApplicableSignatures,exactCandidates,[conversionCandidates,args,comparisonInfo]),conversionCandidates=exactCandidates.length,conversionCandidates=0<conversionCandidates){candidate=this.checker;candidate=JAMScript.call(candidate.findMostApplicableSignature,candidate,[exactCandidates,args]);if(args=candidate.ambiguous)args=
this.checker,args=args.errorReporter,JAMScript.call(args.simpleError,args,[v13201,"Ambiguous call expression - could not choose overload"]);candidate=candidate.sig}else args="Supplied parameters do not match any signature of call target",(exactCandidates=comparisonInfo.message)?(exactCandidates=this.checker,exactCandidates=exactCandidates.errorReporter,args+=":\n\t",comparisonInfo=comparisonInfo.message,args+=comparisonInfo):(exactCandidates=this.checker,exactCandidates=exactCandidates.errorReporter),
JAMScript.call(exactCandidates.simpleError,exactCandidates,[v13201,args]);else if(candidate=exactCandidates.length,candidate=1<candidate){candidate=[];v19273=0;comparisonInfo=exactCandidates.length;for(comparisonInfo=v19273<comparisonInfo;comparisonInfo;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)comparisonInfo=exactCandidates[v19273];candidate[v19273]={signature:comparisonInfo,hadProvisionalErrors:!1};v19273+=1;comparisonInfo=exactCandidates.length;comparisonInfo=
v19273<comparisonInfo}exactCandidates=this.checker;candidate=JAMScript.call(exactCandidates.findMostApplicableSignature,exactCandidates,[candidate,args]);if(args=candidate.ambiguous)args=this.checker,args=args.errorReporter,JAMScript.call(args.simpleError,args,[v13201,"Ambiguous call expression - could not choose overload"]);candidate=candidate.sig}else candidate=exactCandidates[0];v13201=this.resolutionDataCache;JAMScript.call(v13201.returnResolutionData,v13201,[v3036]);return candidate}function v1102(signature,
actuals,exactCandidates,conversionCandidates,comparisonInfo){var lowerBound=signature.nonOptionalParameterCount,v3071=signature.parameters,upperBound=v3071.length,v3071=lowerBound,acceptable=!1,v19283=actuals.length;if(lowerBound=v19283>=lowerBound)if(lowerBound=signature.hasVariableArgList,v19283=!lowerBound)lowerBound=actuals.length,lowerBound=lowerBound<=upperBound;if(upperBound=lowerBound)(v3071=signature.hasVariableArgList)?(v3071=signature.parameters,v3071=v3071.length):v3071=actuals.length,
acceptable=!0;upperBound=null;lowerBound=acceptable;if(v19283=!lowerBound)lowerBound=signature.hasVariableArgList;if(lowerBound){if(lowerBound=signature.hasVariableArgList){v3071-=1;upperBound=signature.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)upperBound=upperBound[v3071];upperBound=upperBound.parameter;upperBound=upperBound.typeLink;upperBound=upperBound.type;upperBound=upperBound.elementType;lowerBound=actuals.length;acceptable=lowerBound>=v3071}for(var lowerBound=
actuals.length,v19283=acceptable,i=0,v3082=i<lowerBound;v3082;){if(v3082=i<v3071){v3082=signature.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v3082=v3082[i];v3082=v3082.parameter;v3082=v3082.typeLink;v3082=v3082.type}else v3082=upperBound;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var typeB=actuals[i];var v13226=!v3082,v19289=!v13226;v19289&&(v13226=!typeB,v19289=!v13226)&&(v13226=this.checker,v13226=JAMScript.call(v13226.typesAreIdentical,
v13226,[v3082,typeB]),v13226=!v13226);v13226&&(v19283=!1);v13226=this.checker;v3082=JAMScript.call(v13226.sourceIsAssignableToTarget,v13226,[typeB,v3082,comparisonInfo]);(v3082=!v3082)&&(acceptable=!1);v3082=v19283||acceptable;if(v3082=!v3082)break;i+=1;v3082=i<lowerBound}if(v19283)conversionCandidates=exactCandidates.length,JAMScript.set(exactCandidates,conversionCandidates,signature);else{if(actuals=acceptable)exactCandidates=exactCandidates.length,actuals=0==exactCandidates;if(exactCandidates=
actuals)exactCandidates=conversionCandidates.length,JAMScript.set(conversionCandidates,exactCandidates,signature)}}}function v1101(binex){var v3087=binex,v13230=binex.operand1,v13230=JAMScript.call(this.typeCheck,this,[v13230]);v3087.operand1=v13230;v3087=binex;v13230=binex.operand2;v13230=JAMScript.call(this.typeCheck,this,[v13230]);v3087.operand2=v13230;v3087=binex.operand2;binex.type=v3087.type;return binex}function v1100(binex){var v3090=binex,v13232=binex.operand1,v13232=JAMScript.call(this.typeCheck,
this,[v13232]);v3090.operand1=v13232;v3090=binex;v13232=binex.operand2;v13232=JAMScript.call(this.typeCheck,this,[v13232]);v3090.operand2=v13232;var v3090=binex.operand1,v13232=v3090.type,v3090=binex.operand2,v3090=v3090.type,v23033=this.checker,v23033=v23033.anyType,v23033=v13232==v23033,v19294=!v23033;v19294&&(v23033=this.checker,v23033=v23033.anyType,v23033=v3090==v23033);v23033?(v3090=this.checker,binex.type=v3090.anyType):(v23033=this.checker,v23033=v23033.booleanType,(v23033=v13232==v23033)?
(v13232=this.checker,v13232=v13232.booleanType,(v3090=v3090==v13232)?(v3090=this.checker,binex.type=v3090.booleanType):(v3090=this.checker,binex.type=v3090.anyType)):(v23033=this.checker,v23033=v23033.numberType,(v23033=v13232==v23033)?(v13232=this.checker,v13232=v13232.numberType,(v3090=v3090==v13232)?(v3090=this.checker,binex.type=v3090.numberType):(v3090=this.checker,binex.type=v3090.anyType)):(v23033=this.checker,v23033=v23033.stringType,(v23033=v13232==v23033)?(v13232=this.checker,v13232=v13232.stringType,
(v3090=v3090==v13232)?(v3090=this.checker,binex.type=v3090.stringType):(v3090=this.checker,binex.type=v3090.anyType)):(v23033=this.checker,(v23033=JAMScript.call(v23033.sourceIsSubtypeOfTarget,v23033,[v13232,v3090]))?binex.type=v3090:(v23033=this.checker,(v3090=JAMScript.call(v23033.sourceIsSubtypeOfTarget,v23033,[v3090,v13232]))?binex.type=v13232:(v3090=this.checker,binex.type=v3090.anyType))))));return binex}function v1099(ast){var v3111=ast,v13243=ast.operand1,v13243=JAMScript.call(this.typeCheck,
this,[v13243]);v3111.operand1=v13243;v3111=ast;v13243=ast.operand2;v13243=JAMScript.call(this.typeCheck,this,[v13243]);v3111.operand2=v13243;v3111=ast.operand2;ast.type=v3111.type;return ast}function v1098(ast){var binex=ast,v3114=binex,v13245=binex.operand1,v13245=JAMScript.call(this.typeCheck,this,[v13245]);v3114.operand1=v13245;v3114=binex;v13245=binex.operand2;v13245=JAMScript.call(this.typeCheck,this,[v13245]);v3114.operand2=v13245;v3114=binex.operand1;v3114=v3114.type;v13245=this.checker;v13245=
v13245.anyType;v3114=v3114==v13245;if(v13245=!v3114)var v3114=this.checker,v13245=binex.operand1,v13245=v13245.type,v24853=this.objectInterfaceType,v3114=JAMScript.call(v3114.sourceIsSubtypeOfTarget,v3114,[v13245,v24853]);v3114&&(v3114=binex.operand2,v3114=v3114.type,v13245=this.anyType,v3114=v3114==v13245,v13245=!v3114)&&(v3114=this.checker,v13245=binex.operand2,v13245=v13245.type,v24853=this.functionInterfaceType,v3114=JAMScript.call(v3114.sourceIsSubtypeOfTarget,v3114,[v13245,v24853]));if(v3114=
!v3114)v3114=this.checker,v3114=v3114.errorReporter,JAMScript.call(v3114.simpleError,v3114,[ast,"The instanceof operator requires the left operand to be of type Any or an object type, and the right operand to be of type Any or a subtype of the Function interface type"]);binex.type=this.booleanType;return binex}function v1097(returnStmt){var v3143=this.thisFnc;if(v3143){var v3143=null,v13249=this.checker;if(v13249=JAMScript.call(v13249.hasTargetType,v13249,[]))if(v13249=this.checker,v13249=v13249.currentContextualTypeContext,
v13249=v13249.targetAccessorType)v3143=v13249;else{var v13249=this.checker,v13249=v13249.currentContextualTypeContext,v13251=v13249=v13249.targetSig;if(v13251)var v13251=v13249.returnType,v13251=v13251.type,v19303=this.voidType,v13251=v13251!=v19303;v13251&&(v3143=v13249.returnType,v3143=v3143.type)}if(v13249=returnStmt.returnExpression){v13249=this.thisFnc;v13251=v13249.fncFlags;v19303=TypeScript.FncFlags;v19303=v19303.HasReturnExpression;v13249.fncFlags=v13251|v19303;if(v13249=null==v3143)if(v13249=
this.thisFnc,v13249=v13249.returnTypeAnnotation)if(v13249=this.thisFnc,v13249=v13249.returnTypeAnnotation,v13249=v13249.type)v13249=this.thisFnc,v13249=v13249.returnTypeAnnotation,v13249=v13249.type,v13251=this.voidType,v13249=v13249!=v13251;v13249&&(v3143=this.thisFnc,v3143=v3143.returnTypeAnnotation,v3143=v3143.type);var v13251=v13249=this.checker,v13251=JAMScript.call(v13251.inProvisionalTypecheckMode,v13251,[]),v19303=null!=v3143,v3129=returnStmt.returnExpression;JAMScript.call(v13249.typeCheckWithContextualType,
v13249,[v3143,v13251,v19303,v3129]);v13249=this.thisFnc;if(v13249=v13249.returnTypeAnnotation)v13249=this.thisFnc,v13249=v13249.returnTypeAnnotation,v13249=v13249.type;v13249?(v13249=this.thisFnc,v13249=v13249.returnTypeAnnotation,v13249=v13249.type):v13249=v3143;if(v13249){v3143=this.voidType;if(v3143=v13249==v3143)v3143=returnStmt.returnExpression,v3143=v3143.type,v13251=this.voidType,v3143=v3143!=v13251;v3143?(v3143=this.checker,v3143=v3143.errorReporter,JAMScript.call(v3143.simpleError,v3143,
[returnStmt,"Return with value expression in void function"]),v3143=returnStmt.returnExpression,returnStmt.type=v3143.type):(v3143=returnStmt,v13251=returnStmt.returnExpression,v13251=JAMScript.call(this.cast,this,[v13251,v13249]),v3143.returnExpression=v13251,returnStmt.type=v13249)}else v3143&&(v13249=returnStmt.returnExpression,v13249=v13249.type,v13251=this.voidType,(v13249=v13249!=v13251)?(v13249=returnStmt,v13251=returnStmt.returnExpression,v3143=JAMScript.call(this.cast,this,[v13251,v3143]),
v13249.returnExpression=v3143):(v13249=returnStmt.returnExpression,v13249.type=v3143)),v3143=returnStmt.returnExpression,returnStmt.type=v3143.type;v3143=this.thisFnc;v3143=v3143.returnStatementsWithExpressions;v13249=this.thisFnc;v13249=v13249.returnStatementsWithExpressions;v13249=v13249.length;JAMScript.set(v3143,v13249,returnStmt)}else{if(v13249=null==v3143)v3143=this.checker,v3143=v3143.voidType;returnStmt.type=v3143}}return returnStmt}function v1096(type,ast){var v13267=type;v13267&&(v13267=
type.construct)&&(v13267=type.construct,v13267=v13267.signatures,v13267=v13267.length,v13267=0<v13267);if(v13267)for(var v13267=0,v23045=type.construct,v23045=v23045.signatures,v23045=v23045.length,v23045=v13267<v23045;v23045;){v23045=type.construct;v23045=v23045.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v23045=v23045[v13267];var v23045=v23045.returnType,v23045=v23045.type,v19317=this.checker,v19317=v19317.voidType;if(v23045=v23045==v19317){v13267=
this.checker;v13267=v13267.errorReporter;JAMScript.call(v13267.simpleError,v13267,[ast,"Constructors may not have a return type of 'void'"]);break}v13267+=1;v23045=type.construct;v23045=v23045.signatures;v23045=v23045.length;v23045=v13267<v23045}}function v1095(arrayLit){function v1094(index){var v13273=elements.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)index=v13273[index];return index.type}function v1093(index,type){var v13274=elements.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v13274=
v13274[index];v13274.type=type}function v1092(){var v3150=elements.members;return v3150.length}var elements=arrayLit.operand,elementType=this.anyType,targetElementType=null,v3151=TypeScript.TypeComparisonInfo,v3151=JAMScript.new(v3151,[]);v3151.onlyCaptureFirstError=!0;var v13275=this.checker;if(v13275=JAMScript.call(v13275.hasTargetType,v13275,[])){var v13275=this.checker,v13275=v13275.currentContextualTypeContext,v13275=v13275.contextualType,v3153=v13275.elementType;v3153&&(targetElementType=v13275.elementType)}if(elements){v13275=
this.inArrayElementTypeCheck;this.inArrayElementTypeCheck=!0;var v3153=elementType=this.checker,v3153=JAMScript.call(v3153.inProvisionalTypecheckMode,v3153,[]),v3157=null!=targetElementType;JAMScript.call(elementType.typeCheckWithContextualType,elementType,[targetElementType,v3153,v3157,elements]);this.inArrayElementTypeCheck=v13275;elementType=elements.members;elementType=elementType[0];elementType=elementType.type;v3153={getLength:v1092,setTypeAtIndex:v1093,getTypeAtIndex:v1094};v3157=this.checker;
elementType=JAMScript.call(v3157.findBestCommonType,v3157,[elementType,targetElementType,v3153,!1,v3151]);v3153=this.checker;v3153=v3153.undefinedType;v3153=elementType==v3153;if(v3157=!v3153){if(v13275=!v13275)v13275=this.nullType,v13275=elementType==v13275;v3153=v13275}if(v13275=v3153)elementType=this.anyType}(v13275=!elementType)?(targetElementType="Incompatible types in array literal expression",elementType=v3151.message,(elementType=!elementType)?(v3151=this.checker,v3151=v3151.errorReporter,
JAMScript.call(v3151.simpleError,v3151,[arrayLit,targetElementType])):(elementType=this.checker,elementType=elementType.errorReporter,targetElementType+=": ",v3151=v3151.message,v3151=targetElementType+v3151,JAMScript.call(elementType.simpleError,elementType,[arrayLit,v3151])),elementType=this.anyType):targetElementType&&(v3151=this.checker,(v3151=JAMScript.call(v3151.sourceIsAssignableToTarget,v3151,[elementType,targetElementType]))&&(elementType=targetElementType));v3151=this.checker;v3151=JAMScript.call(v3151.makeArrayType,
v3151,[elementType]);arrayLit.type=v3151}function v1091(objectLit){var v3168=TypeScript.Type,resultType=JAMScript.new(v3168,[]),v3169=resultType,v13287=TypeScript.TypeSymbol,v19322=this.checker,v13288=v19322.anon,v13289=objectLit.minChar,v19323=objectLit.limChar,v19324=objectLit.minChar,v13290=v19323-v19324,v23050=this.checker,v19325=v23050.locationInfo,v13291=v19325.unitIndex,v26824=JAMScript.new(v13287,[v13288,v13289,v13290,v13291,resultType]);v3169.symbol=v26824;var v3170=resultType,v13292=TypeScript.ScopedMembers,
v19326=TypeScript.DualStringHashTable,v23051=TypeScript.StringHashTable,v19327=JAMScript.new(v23051,[]),v23052=TypeScript.StringHashTable,v19328=JAMScript.new(v23052,[]),v13293=JAMScript.new(v19326,[v19327,v19328]),v26825=JAMScript.new(v13292,[v13293]);v3170.members=v26825;var v3171=resultType,v13294=TypeScript.SymbolTableScope,v13295=resultType.members,v26826=JAMScript.new(v13294,[v13295,null,null,null,null]);v3171.memberScope=v26826;var v3172=TypeScript.SymbolAggregateScope,v3173=resultType.symbol,
aggScope=JAMScript.new(v3172,[v3173]),v3174=resultType.memberScope;JAMScript.call(aggScope.addParentScope,aggScope,[v3174]);var v3175=this.scope;JAMScript.call(aggScope.addParentScope,aggScope,[v3175]);resultType.containedScope=aggScope;var memberDecls=objectLit.operand,prevThisType=this.thisType,acceptTargetType=!1,targetType=null,v13296=this.checker,v3180=JAMScript.call(v13296.hasTargetType,v13296,[]);if(v3180){var v13297=this.checker,v3176=v13297.currentContextualTypeContext,v13298=targetType=
v3176.contextualType;if(v13298){var v19329=targetType.symbol;if(v19329)var v24867=this.checker,v25776=targetType.symbol,v24868=v25776.typeCheckStatus,v23053=JAMScript.call(v24867.typeStatusIsFinished,v24867,[v24868]),v19329=!v23053;v13298=v19329}var v3179=v13298;if(v3179){var v13299=targetType.symbol,v3178=v13299.declAST;if(v3178){var v13300=targetType.symbol,v3177=v13300.declAST;JAMScript.call(this.typeCheck,this,[v3177])}}acceptTargetType=!0}if(memberDecls)for(var i=0,v3181=memberDecls.members,
len=v3181.length,v3211=i<len;v3211;){var v3182=memberDecls.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var binex=v3182[i];var id=binex.operand1,text,targetMember=null,fieldSymbol=null,v13301=id.nodeType,v19330=TypeScript.NodeType,v13302=v19330.Name,v3186=v13301==v13302;if(v3186)text=id.text;else{var v13303=id.nodeType,v19331=TypeScript.NodeType,v13304=v19331.QString,v3185=v13303==v13304;if(v3185){var idText=id.text,v13305=idText.length,v3183=v13305-1;
text=JAMScript.call(idText.substring,idText,[1,v3183])}else{var v13306=this.checker,v3184=v13306.errorReporter;JAMScript.call(v3184.simpleError,v3184,[objectLit,"malformed object literal"]);resultType=this.anyType;break}}var v13307=acceptTargetType;v13307&&(v13307=targetType.memberScope);var v3188=v13307;if(v3188)var v3187=targetType.memberScope,targetMember=JAMScript.call(v3187.find,v3187,[text,!1,!1]);var v23054=binex.operand2,v19332=v23054.nodeType,v23055=TypeScript.NodeType,v19333=v23055.FuncDecl,
v13308=v19332==v19333;if(v13308)var v19334=binex.operand2,v13308=JAMScript.call(v19334.isAccessor,v19334,[]);var v3193=v13308;if(v3193){var funcDecl=binex.operand2,v13309=resultType.members,v3189=v13309.publicMembers,accessorSym=JAMScript.call(v3189.lookup,v3189,[text]),v3190=this.checker,v3191=resultType.memberScope,accessorSym=JAMScript.call(v3190.createAccessorSymbol,v3190,[funcDecl,accessorSym,resultType,!0,!1,v3191,null]),fieldSymbol=funcDecl.accessorSymbol=accessorSym,v13310=id.nodeType,v19335=
TypeScript.NodeType,v13311=v19335.Name,v3192=v13310==v13311;v3192&&(id.sym=accessorSym)}var v3194=this.checker,v13312,v19336=acceptTargetType&&targetMember,v3195=v13312=v19336?JAMScript.call(targetMember.getType,targetMember,[]):null,v3196=binex.operand2;JAMScript.call(v3194.typeCheckWithContextualType,v3194,[v3195,!1,acceptTargetType,v3196]);var v3200=acceptTargetType&&targetMember;if(v3200){var v24869=binex.operand2,v23056=v24869.type,v23057=this.anyType,v19337=v23056==v23057,v23061=!v19337;if(v23061)var v23058=
this.checker,v24870=binex.operand2,v23059=v24870.type,v23060=JAMScript.call(targetMember.getType,targetMember,[]),v19337=JAMScript.call(v23058.sourceIsAssignableToTarget,v23058,[v23059,v23060]);var v13313=v19337,v19339=!v13313;if(v19339){var v24871=binex.operand2,v23062=v24871.nodeType,v24872=TypeScript.NodeType,v23063=v24872.FuncDecl,v19338=v23062==v23063;if(v19338){var v24873=binex.operand2,v23064=JAMScript.call(v24873.isAccessor,v24873,[]);if(v23064)var v25777=binex.operand2,v24874=JAMScript.call(this.typeFromAccessorFuncDecl,
this,[v25777]),v24875=JAMScript.call(targetMember.getType,targetMember,[]),v23064=v24874==v24875;v19338=v23064}v13313=v19338}var v3198=v13313;if(v3198){var v3197=binex.operand1,v26827=JAMScript.call(targetMember.getType,targetMember,[]);v3197.type=v26827}}else{var v3199=binex.operand2,v13314,v24876=binex.operand2,v23065=v24876.type,v24877=this.checker,v23066=v24877.undefinedType,v19341=v23065==v23066;if(v19341)v13314=this.anyType;else{var v19340=binex.operand2;v13314=v19340.type}v3199.type=v13314}var v3210=
null==fieldSymbol;if(v3210){var v3201=binex.operand2,memberType=v3201.type,v3202=TypeScript.ValueLocation,field=JAMScript.new(v3202,[]),v3203=TypeScript.FieldSymbol,v3204=id.minChar,v19342=this.checker,v13315=v19342.locationInfo,v3205=v13315.unitIndex,fieldSymbol=JAMScript.new(v3203,[text,v3204,v3205,!0,field]),v13316=fieldSymbol.flags,v19343=TypeScript.SymbolFlags,v13317=v19343.Property;fieldSymbol.flags=v13316|v13317;var v3206=field.symbol=fieldSymbol,v13318=this.checker,v26828=JAMScript.call(v13318.getTypeCheckFinishedStatus,
v13318,[]);v3206.typeCheckStatus=v26828;var v3207=field,v13319=TypeScript.TypeLink,v26829=JAMScript.new(v13319,[]);v3207.typeLink=v26829;var v3208=field.typeLink;v3208.type=memberType;var v13320=resultType.members,v3209=v13320.publicMembers;JAMScript.call(v3209.add,v3209,[text,fieldSymbol])}fieldSymbol.isObjectLitField=!0;i+=1;v3211=i<len}this.thisType=prevThisType;objectLit.type=resultType;targetType&&(objectLit.targetType=targetType)}function v1090(funcDecl){var v13321=JAMScript.call(funcDecl.isAccessor,
funcDecl,[]);if(v13321=!v13321)return null;var v13321=funcDecl.fncFlags,v19344=TypeScript.FncFlags,v19344=v19344.GetAccessor;if(v13321=JAMScript.call(TypeScript.hasFlag,TypeScript,[v13321,v19344]))return funcDecl=funcDecl.type,funcDecl=funcDecl.call,funcDecl=funcDecl.signatures,funcDecl=funcDecl[0],funcDecl=funcDecl.returnType,funcDecl.type;funcDecl=funcDecl.type;funcDecl=funcDecl.call;funcDecl=funcDecl.signatures;funcDecl=funcDecl[0];funcDecl=funcDecl.parameters;funcDecl=funcDecl[0];return JAMScript.call(funcDecl.getType,
funcDecl,[])}function v1089(ifStmt){var v3216=ifStmt,v13326=ifStmt.cond,v13326=JAMScript.call(this.typeCheck,this,[v13326]);v3216.cond=v13326;v3216=ifStmt.cond;JAMScript.call(this.typeCheckCondExpr,this,[v3216]);v3216=ifStmt;v13326=ifStmt.thenBod;v13326=JAMScript.call(this.typeCheck,this,[v13326]);v3216.thenBod=v13326;v3216=ifStmt;v13326=ifStmt.elseBod;v13326=JAMScript.call(this.typeCheck,this,[v13326]);v3216.elseBod=v13326;v3216=ifStmt.thenBod;JAMScript.call(this.typeCheckCompoundStmtBlock,this,
[v3216,"if statement"]);v3216=ifStmt.elseBod;JAMScript.call(this.typeCheckCompoundStmtBlock,this,[v3216,"if statement"]);ifStmt.type=this.voidType;return ifStmt}function v1088(stmts,stmtType){var v23069=this.checker,v23069=v23069.styleSettings;(v23069=v23069.blockInCompoundStmt)&&(v23069=stmts);if(v23069){var v23069=stmts.nodeType,v19348=TypeScript.NodeType,v19348=v19348.Block;if(v23069=v23069!=v19348)v23069=this.checker,v23069=v23069.errorReporter,v19348=stmtType+" requires a block",JAMScript.call(v23069.styleError,
v23069,[stmts,v19348])}}function v1087(cond){var v19349=this.checker,v19349=v19349.styleSettings;if(v19349=v19349.assignmentInCond){if(v19349=null!==cond){var v19349=cond.nodeType,v24880=TypeScript.NodeType,v24880=v24880.Asg;if(v19349=v19349>=v24880)v19349=cond.nodeType,v24880=TypeScript.NodeType,v24880=v24880.LastAsg,v19349=v19349<=v24880}v19349&&(v19349=this.checker,v19349=v19349.errorReporter,JAMScript.call(v19349.simpleError,v19349,[cond,"top-level assignment statement in conditional expression"]))}}
function v1086(doWhileStmt){var v3229=doWhileStmt,v13336=doWhileStmt.cond,v13336=JAMScript.call(this.typeCheck,this,[v13336]);v3229.cond=v13336;v3229=doWhileStmt.cond;JAMScript.call(this.typeCheckCondExpr,this,[v3229]);v3229=doWhileStmt;v13336=doWhileStmt.body;v13336=JAMScript.call(this.typeCheck,this,[v13336]);v3229.body=v13336;v3229=doWhileStmt.body;JAMScript.call(this.typeCheckCompoundStmtBlock,this,[v3229,"do while statement"]);doWhileStmt.type=this.voidType;return doWhileStmt}function v1085(whileStmt){var v3233=
whileStmt,v13338=whileStmt.cond,v13338=JAMScript.call(this.typeCheck,this,[v13338]);v3233.cond=v13338;v3233=whileStmt.cond;JAMScript.call(this.typeCheckCondExpr,this,[v3233]);v3233=whileStmt;v13338=whileStmt.body;v13338=JAMScript.call(this.typeCheck,this,[v13338]);v3233.body=v13338;v3233=whileStmt.body;JAMScript.call(this.typeCheckCompoundStmtBlock,this,[v3233,"while statement"]);whileStmt.type=this.voidType;return whileStmt}function v1084(forInStmt){var v3237=forInStmt,v13340=forInStmt.obj,v13340=
JAMScript.call(this.typeCheck,this,[v13340]);v3237.obj=v13340;var v3237=forInStmt,v13340=forInStmt.lval,v13340=JAMScript.call(this.typeCheck,this,[v13340]),v19352=this.checker,v19352=v19352.stringType,v13340=JAMScript.call(this.cast,this,[v13340,v19352]);v3237.lval=v13340;v3237=forInStmt.lval;v3237=v3237.nodeType;v13340=TypeScript.NodeType;v13340=v13340.VarDecl;if(v3237=v3237==v13340){v3237=forInStmt.lval;if(v13340=v3237.typeExpr)v13340=this.checker,v13340=v13340.errorReporter,JAMScript.call(v13340.simpleError,
v13340,[v3237,"Variable declarations for for/in expressions may not contain a type annotation"]);if(v13340=v3237.sym)v3237=v3237.sym,v13340=this.checker,v13340=v13340.stringType,JAMScript.call(v3237.setType,v3237,[v13340])}v3237=forInStmt;v13340=forInStmt.body;v13340=JAMScript.call(this.typeCheck,this,[v13340]);v3237.body=v13340;v3237=forInStmt.body;JAMScript.call(this.typeCheckCompoundStmtBlock,this,[v3237,"for in statement"]);return forInStmt}function v1083(withStmt){var v13348=this.checker;if(v13348=
v13348.errorsOnWith){var v13348=this.checker,v13348=v13348.errorReporter,v3248=withStmt.expr;JAMScript.call(v13348.simpleError,v13348,[v3248,"All symbols within a 'with' block will be typed as 'any'"])}v13348=withStmt;v3248=withStmt.expr;v3248=JAMScript.call(this.typeCheck,this,[v3248]);v13348.expr=v3248;v13348=this.checker;v13348.inWith=!0;v13348=withStmt;v3248=withStmt.body;v3248=JAMScript.call(this.typeCheck,this,[v3248]);v13348.body=v3248;v13348=withStmt.body;JAMScript.call(this.typeCheckCompoundStmtBlock,
this,[v13348,"with statement"]);v13348=this.checker;v13348.inWith=!1;return withStmt}function v1082(forStmt){var v3255=forStmt,v13352=forStmt.init,v13352=JAMScript.call(this.typeCheck,this,[v13352]);v3255.init=v13352;v3255=this.nestingLevel;this.nestingLevel=v3255+1;v3255=forStmt;v13352=forStmt.cond;v13352=JAMScript.call(this.typeCheck,this,[v13352]);v3255.cond=v13352;v3255=forStmt.cond;JAMScript.call(this.typeCheckCondExpr,this,[v3255]);v3255=forStmt;v13352=forStmt.incr;v13352=JAMScript.call(this.typeCheck,
this,[v13352]);v3255.incr=v13352;v3255=this.nestingLevel;this.nestingLevel=v3255-1;v3255=forStmt;v13352=forStmt.body;v13352=JAMScript.call(this.typeCheck,this,[v13352]);v3255.body=v13352;v3255=forStmt.body;JAMScript.call(this.typeCheckCompoundStmtBlock,this,[v3255,"for statement"]);forStmt.type=this.voidType;return forStmt}function v1081(moduleDecl){var v13358=moduleDecl.mod;if(v13358=!v13358)return moduleDecl;if(v13358=this.currentScript)v13358=this.currentScript,v13358.requiresGlobal=!0;var v13358=
moduleDecl.mod,sym=null,prevScope=this.scope,prevThisType=this.thisType,v3264=this.checker,v3264=v3264.currentModDecl,sym=this.checker;sym.currentModDecl=moduleDecl;this.thisType=null;this.scope=v13358.containedScope;sym=moduleDecl.members;JAMScript.call(this.typeCheck,this,[sym]);var sym=v13358.symbol,v3267=this.checker;v3267.currentModDecl=v3264;this.thisType=prevThisType;this.scope=prevScope;moduleDecl.type=v13358;sym&&(v13358=TypeScript.TypeCheckStatus,sym.typeCheckStatus=v13358.Finished);return moduleDecl}
function v1080(importDecl){var v3269=importDecl.alias,mod=v3269.type,sym=null,v3269=this.inImportTypeCheck;this.inImportTypeCheck=!0;mod=importDecl.alias;JAMScript.call(this.typeCheck,this,[mod]);mod=importDecl.alias;mod=mod.type;if(sym=null==mod){var mod=this.checker,mod=mod.errorReporter,sym=importDecl.alias,v23074=importDecl.id,v23074=v23074.actualText,v23074="Could not resolve module alias '"+v23074,v23074=v23074+"'";JAMScript.call(mod.simpleError,mod,[sym,v23074]);mod=this.checker;mod=mod.anyType;
sym=importDecl.id;sym=sym.sym;sym.type=mod}sym=importDecl.id;sym.type=mod;sym=mod.symbol;v23074=JAMScript.call(mod.isModuleType,mod,[]);if(v23074=!v23074)mod=this.checker,mod=mod.errorReporter,sym=importDecl.alias,JAMScript.call(mod.simpleError,mod,[sym,"A module cannot be aliased to a non-module type"]);else{sym.type=mod;sym=this.checker;sym=sym.typeFlow;if(sym=sym.currentScript)if(sym=this.checker,sym=sym.typeFlow,sym=sym.currentScript,sym=sym.topLevelMod)sym=this.checker,sym=sym.typeFlow,sym=sym.currentScript,
sym=sym.topLevelMod,sym=sym.mod;sym&&(sym=this.checker,sym=sym.typeFlow,sym=sym.currentScript,sym=sym.topLevelMod,sym=sym.mod,sym=sym.importedModules,JAMScript.call(sym.push,sym,[importDecl]));sym=importDecl.id;sym=sym.sym;sym.type=mod;if(sym=mod.symbol)sym=mod.symbol,sym=sym.declAST;sym&&(mod=mod.symbol,mod=mod.declAST,sym=mod.modFlags,v23074=TypeScript.ModuleFlags,v23074=v23074.ShouldEmitModuleDecl,v23074=~v23074,mod.modFlags=sym&v23074)}this.inImportTypeCheck=v3269;return importDecl}function v1079(interfaceDecl){var v3287=
interfaceDecl.type;JAMScript.call(this.typeCheckBases,this,[v3287]);var v3287=interfaceDecl.extendsList,v13369=interfaceDecl.type,v13369=v13369.symbol;JAMScript.call(this.typeCheckBaseListPrivacy,this,[v3287,v13369,!0]);v3287=interfaceDecl.members;JAMScript.call(this.typeCheck,this,[v3287]);v3287=interfaceDecl.type;JAMScript.call(this.checkBaseTypeMemberInheritance,this,[v3287,interfaceDecl]);if(v3287=interfaceDecl.extendsList)for(v3287=0,v13369=interfaceDecl.extendsList,v13369=v13369.members,v13369=
v13369.length,v13369=v3287<v13369;v13369;){v13369=interfaceDecl.extendsList;v13369=v13369.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v13369=v13369[v3287];v13369=v13369.type;if(v13369=v13369.call)if(v13369=interfaceDecl.type,v13369=v13369.call){var v13369=interfaceDecl.type,v13369=v13369.call,v23082=interfaceDecl.type,v23082=v23082.call,v23082=v23082.signatures,v26271=interfaceDecl.extendsList,v26271=v26271.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26271=
v26271[v3287];v26271=v26271.type;v26271=v26271.call;v26271=v26271.signatures;v23082=v23082.concat(v26271);v13369.signatures=v23082}else{v13369=interfaceDecl.type;v23082=interfaceDecl.extendsList;v23082=v23082.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v23082=v23082[v3287];v23082=v23082.type;v13369.call=v23082.call}v13369=interfaceDecl.extendsList;v13369=v13369.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v13369=
v13369[v3287];v13369=v13369.type;if(v13369=v13369.construct)if(v13369=interfaceDecl.type,v13369=v13369.construct){v13369=interfaceDecl.type;v13369=v13369.construct;v23082=interfaceDecl.type;v23082=v23082.construct;v23082=v23082.signatures;v26271=interfaceDecl.extendsList;v26271=v26271.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26271=v26271[v3287];v26271=v26271.type;v26271=v26271.construct;v26271=v26271.signatures;v23082=v23082.concat(v26271);v13369.signatures=
v23082}else{v13369=interfaceDecl.type;v23082=interfaceDecl.extendsList;v23082=v23082.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v23082=v23082[v3287];v23082=v23082.type;v13369.construct=v23082.construct}v13369=interfaceDecl.extendsList;v13369=v13369.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v13369=v13369[v3287];v13369=v13369.type;if(v13369=v13369.index)if(v13369=interfaceDecl.type,v13369=v13369.index){v13369=
interfaceDecl.type;v13369=v13369.index;v23082=interfaceDecl.type;v23082=v23082.index;v23082=v23082.signatures;v26271=interfaceDecl.extendsList;v26271=v26271.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26271=v26271[v3287];v26271=v26271.type;v26271=v26271.index;v26271=v26271.signatures;v23082=v23082.concat(v26271);v13369.signatures=v23082}else{v13369=interfaceDecl.type;v23082=interfaceDecl.extendsList;v23082=v23082.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v23082=
v23082[v3287];v23082=v23082.type;v13369.index=v23082.index}v3287+=1;v13369=interfaceDecl.extendsList;v13369=v13369.members;v13369=v13369.length;v13369=v3287<v13369}return interfaceDecl}function v1078(type,ast){var v3309=type.call;if(v3309){var v3309=type.call,v3307=this.checker,v13390=type.construct,v13390=null!=v13390;JAMScript.call(v3309.typeCheck,v3309,[v3307,ast,v13390])}if(v3309=type.construct)v3309=type.construct,v3307=this.checker,JAMScript.call(v3309.typeCheck,v3309,[v3307,ast,!1]);if(v3309=
type.index)v3309=type.index,v3307=this.checker,JAMScript.call(v3309.typeCheck,v3309,[v3307,ast,!1])}function v1077(classDecl){var v3316=classDecl.type,typeSymbol=v3316.symbol,v3316=typeSymbol.typeCheckStatus,v19376=TypeScript.TypeCheckStatus,v19376=v19376.Finished;if(v3316=v3316==v19376)return classDecl;v3316=typeSymbol.typeCheckStatus;v19376=TypeScript.TypeCheckStatus;v19376=v19376.Started;if(v3316=v3316==v19376)return classDecl;v3316=TypeScript.TypeCheckStatus;typeSymbol.typeCheckStatus=v3316.Started;
v3316=this.checker;JAMScript.call(v3316.addStartedPTO,v3316,[typeSymbol]);v3316=this.scope;v19376=this.thisClassNode;this.thisClassNode=classDecl;var classType=classDecl.type,v3321=classType.instanceType;JAMScript.call(this.typeCheckBases,this,[v3321]);v3321=classDecl.extendsList;JAMScript.call(this.typeCheckBaseListPrivacy,this,[v3321,typeSymbol,!0]);v3321=classDecl.implementsList;JAMScript.call(this.typeCheckBaseListPrivacy,this,[v3321,typeSymbol,!1]);var v3321=this.thisType,v3324=this.thisType=
classType.instanceType;this.scope=v3324.containedScope;if(v3324=classDecl.constructorDecl){var v3324=classType.instanceType,v3324=this.scope=v3324.constructorScope,v3324=v3324.valueMembers,v3324=v3324.allMembers,v19378=classDecl.constructorDecl,v19378=v19378.type,v19378=v19378.symbol,v13396=classDecl.constructorDecl,v13396=v13396.arguments;JAMScript.call(this.addConstructorLocalArgs,this,[v19378,v13396,v3324,!0])}v3324=classDecl.members;JAMScript.call(this.typeCheck,this,[v3324]);v3324=TypeScript.TypeCheckStatus;
typeSymbol.typeCheckStatus=v3324.Finished;JAMScript.call(this.checkBaseTypeMemberInheritance,this,[classType,classDecl]);JAMScript.call(this.checkMembersImplementInterfaces,this,[classType]);JAMScript.call(this.typeCheckOverloadSignatures,this,[classType,classDecl]);typeSymbol=classType.instanceType;JAMScript.call(this.typeCheckOverloadSignatures,this,[typeSymbol,classDecl]);typeSymbol=classDecl.constructorDecl;if(typeSymbol=!typeSymbol){if(typeSymbol=classDecl.extendsList)if(typeSymbol=classDecl.extendsList,
typeSymbol=typeSymbol.members,typeSymbol=typeSymbol.length)if(typeSymbol=classDecl.extendsList,typeSymbol=typeSymbol.members,typeSymbol=typeSymbol[0],typeSymbol=typeSymbol.type)typeSymbol=classDecl.extendsList,typeSymbol=typeSymbol.members,typeSymbol=typeSymbol[0],typeSymbol=typeSymbol.type,typeSymbol=typeSymbol.symbol,typeSymbol=typeSymbol.type,typeSymbol=JAMScript.call(typeSymbol.isClass,typeSymbol,[]);typeSymbol&&(typeSymbol=classDecl.type,classType=classDecl.extendsList,classType=classType.members,
classType=classType[0],classType=classType.type,classType=classType.symbol,classType=classType.type,JAMScript.call(TypeScript.cloneParentConstructGroupForChildType,TypeScript,[typeSymbol,classType]))}this.thisType=v3321;this.thisClassNode=v19376;this.scope=v3316;return classDecl}function v1076(derivedType,derivedTypeDecl){function v1075(key,s,c){key=s;s=0;for(c=s<len;c;){c=instanceType.extendsList;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var base=c[s];c=base.memberScope;
if(c=null==c)c=_this.checker,c=c.errorReporter,base=base.symbol,base=base.name,base="Base type '"+base,base+="' lacks an implementation.",JAMScript.call(c.simpleError,c,[derivedTypeDecl,base]);else if(c=base.memberScope,base=key.name,c=JAMScript.call(c.find,c,[base,!1,!1])){var base=JAMScript.call(key.getType,key,[]),bType=JAMScript.call(c.getType,c,[]),v19382=_this.checker,base=JAMScript.call(v19382.sourceIsSubtypeOfTarget,v19382,[base,bType]);if(base=!base)base=_this.checker,base=base.errorReporter,
bType=key.name,bType="Type of overridden member '"+bType,bType+="' is not subtype of original member defined by type '",c=c.container,c=c.name,c=bType+c,c+="'",JAMScript.call(base.simpleErrorFromSym,base,[key,c]);else{base=JAMScript.call(key.kind,key,[]);bType=TypeScript.SymbolKind;bType=bType.Type;if(base=base==bType)c=JAMScript.call(c.kind,c,[]),base=TypeScript.SymbolKind,base=base.Field,base=c==base;if(c=base)c=_this.checker,c=c.errorReporter,base=key.name,base="Cannot override field '"+base,base+=
"' with method",JAMScript.call(c.simpleErrorFromSym,c,[key,base])}}s+=1;c=s<len}}var _this=this,instanceType=JAMScript.call(derivedType.getInstanceType,derivedType,[]),v13409=instanceType.extendsList,v13409=null==v13409;if(!v13409){var v13409=instanceType.extendsList,len=v13409.length;if(v13409=0<len){var v13409=TypeScript.StringHashTable,v13409=JAMScript.new(v13409,[]),v3356=JAMScript.call(instanceType.isClassInstance,instanceType,[]);if(v3356)for(var v3356=0,v3355=v3356<len;v3355;){v3355=instanceType.extendsList;
introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v3355=v3355[v3356];var v3354=0<v3356;JAMScript.call(this.assertUniqueNamesInBaseTypes,this,[v13409,v3355,derivedTypeDecl,v3354]);v3356+=1;v3355=v3356<len}if(v13409=instanceType.members)v13409=instanceType.members,v13409=v13409.publicMembers,JAMScript.call(v13409.map,v13409,[v1075,null])}}}function v1074(names,type,classDecl,checkUnique){function v1073(key,s,c){key=s;s=key.name;if(c=JAMScript.call(names.lookup,names,
[s])){if(checkUnique){s=_this.checker;s=s.errorReporter;var v26622=classDecl.name,v26622=v26622.actualText,v26622="duplicate member name in bases for "+v26622,v26622=v26622+": ",v26277=type.symbol,v26277=v26277.name,v26622=v26622+v26277,v26622=v26622+" and ";c=c.container;c=c.name;c=v26622+c;c+=" both contain member with name ";key=key.name;key=c+key;JAMScript.call(s.simpleError,s,[classDecl,key])}}else s=key.name,JAMScript.call(names.add,names,[s,key])}var _this=this;if(type){var v3365=type.members;
v3365&&(v3365=type.members,v3365=v3365.publicMembers,JAMScript.call(v3365.map,v3365,[v1073,null]));if(v3365=type.extendsList)for(var v3365=type.extendsList,v3365=v3365.length,i=0,v3369=i<v3365;v3369;){v3369=type.extendsList;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v3369=v3369[i];var v3369=v3369.symbol,v3369=v3369.flags,v23105=TypeScript.SymbolFlags,v23105=v23105.RecursivelyReferenced,v3369=v3369&v23105;if(v3369=!v3369){v3369=type.extendsList;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v3369=
v3369[i];JAMScript.call(this.assertUniqueNamesInBaseTypes,this,[names,v3369,classDecl,checkUnique])}i+=1;v3369=i<v3365}}}function v1072(bases){var v3371=null==bases;if(!v3371)for(var v3371=bases.members,v3371=v3371.length,i=0,v3375=i<v3371;v3375;){v3375=bases.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v3375=v3375[i];var v13418=v3375.nodeType,v19393=TypeScript.NodeType,v19393=v19393.Call;(v13418=v13418==v19393)&&JAMScript.call(this.typeCheckNew,this,
[v3375]);i+=1;v3375=i<v3371}}function v1071(implementingType){implementingType=JAMScript.call(implementingType.getInstanceType,implementingType,[]);var v3388=implementingType.implementsList;if(v3388)for(var v3388=implementingType.implementsList,v3388=v3388.length,i=0,v3387=i<v3388;v3387;){v3387=implementingType.implementsList;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var interfaceType=v3387[i];var v3387=TypeScript.TypeComparisonInfo,v3387=JAMScript.new(v3387,
[]),v19394=this.checker,v19394=JAMScript.call(v19394.sourceIsSubtypeOfTarget,v19394,[implementingType,interfaceType,v3387]);if(v19394=!v19394)if(v19394=JAMScript.call(implementingType.getTypeName,implementingType,[]),v19394="Class '"+v19394,v19394+="' declares interface '",interfaceType=JAMScript.call(interfaceType.getTypeName,interfaceType,[]),interfaceType=v19394+interfaceType,interfaceType+="' but does not implement it",v19394=v3387.message,v19394=!v19394)v3387=this.checker,v3387=v3387.errorReporter,
v19394=implementingType.symbol,JAMScript.call(v3387.simpleErrorFromSym,v3387,[v19394,interfaceType]);else{var v19394=this.checker,v19394=v19394.errorReporter,v3383=implementingType.symbol,interfaceType=interfaceType+": ",v3387=v3387.message,v3387=interfaceType+v3387;JAMScript.call(v19394.simpleErrorFromSym,v19394,[v3383,v3387])}i+=1;v3387=i<v3388}}function v1070(type){var seenInterface=!1,bases=type.extendsList,baseLinks=type.extendsTypeLinks;if(bases){var len=bases.length,v3389=0<len;if(v3389){var v3389=
type.typeFlags,v19396=TypeScript.TypeFlags,v19396=v19396.HasBaseType;type.typeFlags=v3389|v19396}v3389=0;for(v19396=v3389<len;v19396;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v19396=bases[v3389];var v19397=this.checker,v19397=v19397.anyType;if(v19396=v19396==v19397){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v19396=baseLinks[v3389];v19396.type=null;v19396=this.checker;v19396=v19396.errorReporter;v19397=v19396.errorSink;
v19396=TypeScript.CompilerDiagnostics;v19397=v19397.length;v19397=0==v19397;JAMScript.call(v19396.assert,v19396,[v19397,"There shouldnt be any contextual errors when typechecking base type names"]);v19396=this.checker;v19396=v19396.errorReporter;v19396.pushToErrorSink=!0;var v19396=bases,v19397=v3389,v13435=this.checker;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v13436=baseLinks[v3389];var v13437=type.containedScope,v13435=JAMScript.call(v13435.resolveBaseTypeLink,
v13435,[v13436,v13437]);v19396[v19397]=v13435;v19396=this.checker;v19396=v19396.errorReporter;v19396.pushToErrorSink=!1;v19396=this.checker;v19396=v19396.errorReporter;JAMScript.call(v19396.freeCapturedErrors,v19396,[])}introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v19397=bases[v3389];introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v19396=baseLinks[v3389];v19396=v19396.ast;if(v13435=v19397.symbol)if(v13435=v19397.symbol,v13435=
v13435.name,v13435="Object"==v13435)v13435=v19397.symbol,v13435=v13435.container,v13436=this.checker,v13436=v13436.gloMod,v13435=v13435==v13436;v13435&&(v13435=type.typeFlags,v13436=TypeScript.TypeFlags,v13436=v13436.HasBaseTypeOfObject,type.typeFlags=v13435|v13436);if(v13435=JAMScript.call(v19397.isClassInstance,v19397,[]))v19397=JAMScript.call(type.isClassInstance,type,[]),(v19397=!v19397)?(v19397=this.checker,v19397=v19397.errorReporter,JAMScript.call(v19397.simpleError,v19397,[v19396,"Interface base type must be interface"])):
seenInterface&&(v19397=this.checker,v19397=v19397.errorReporter,JAMScript.call(v19397.simpleError,v19397,[v19396,"Class may not follow interface as base type"]));else if(v13435=JAMScript.call(v19397.isModuleType,v19397,[]))v19397=this.checker,v19397=v19397.errorReporter,JAMScript.call(v19397.simpleError,v19397,[v19396,"Types may not be derived from module types"]);else if(v19397=v19397.members)(v19396=!seenInterface)&&(seenInterface=!0);else{type=JAMScript.call(type.isClassInstance,type,[]);(type=
!type)?(type=this.checker,type=type.errorReporter,JAMScript.call(type.simpleError,type,[v19396,"Interface base type must be interface"])):(type=this.checker,type=type.errorReporter,JAMScript.call(type.simpleError,type,[v19396,"Base type must be interface or class"]));break}v3389+=1;v19396=v3389<len}}}function v1069(funcDecl){function v1068(typeName,isModuleName){return JAMScript.call(_this.functionReturnTypePrivacyErrorReporter,_this,[funcDecl,signature,typeName,isModuleName])}function v1067(index){var v13450=
funcDecl.returnStatementsWithExpressions;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)index=v13450[index];return index.type}function v1066(index,type){var v13451=funcDecl.returnStatementsWithExpressions;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v13451=v13451[index];v13451.type=type}function v1065(){var v3416=funcDecl.returnStatementsWithExpressions;return v3416.length}function v1064(sym){sym=JAMScript.call(sym.kind,sym,
[]);var v13452=TypeScript.SymbolKind,v13452=v13452.Parameter;return sym==v13452}function v1063(typeName,isModuleName){var v13453=signature.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v13453=v13453[p];return JAMScript.call(_this.functionArgumentPrivacyErrorReporter,_this,[funcDecl,p,v13453,typeName,isModuleName])}function v1062(typeName,isModuleName){return JAMScript.call(_this.functionArgumentPrivacyErrorReporter,_this,[funcDecl,p,symbol,typeName,
isModuleName])}var _this=this;this.nestingLevel=0;var fnType=funcDecl.type,fgSym=fnType.symbol,signature=funcDecl.signature,v13454=this.checker,v13455=signature.typeCheckStatus,v3427=JAMScript.call(v13454.typeStatusIsFinished,v13454,[v13455]);if(v3427)return funcDecl;var v13456=signature.typeCheckStatus,v19402=TypeScript.TypeCheckStatus,v13457=v19402.Started,v3426=v13456==v13457;if(v3426){var v19403=funcDecl.returnTypeAnnotation,v13458=!v19403;if(v13458){var v19404=funcDecl.bod;if(v19404){var v24903=
JAMScript.call(funcDecl.isSignature,funcDecl,[]),v23110=!v24903;if(v23110){var v25791=funcDecl.isConstructor,v24904=!v25791;v24904&&(v24904=JAMScript.call(this.allReturnsAreVoid,this,[funcDecl]));v23110=v24904}v19404=v23110}v13458=v19404}var v3425=v13458;if(v3425){var v3420=signature.returnType;v3420.type=this.voidType}else{var v13459=funcDecl.returnTypeAnnotation,v3424=null==v13459;if(v3424){var v19405=this.checker,v13460=v19405.styleSettings,v3422=v13460.implicitAny;if(v3422){var v13461=this.checker,
v3421=v13461.errorReporter;JAMScript.call(v3421.styleError,v3421,[funcDecl,"type implicitly set to 'any'"])}var v3423=signature.returnType;v3423.type=this.anyType;var v13462=fgSym.flags,v19406=TypeScript.SymbolFlags,v13463=v19406.RecursivelyReferenced;fgSym.flags=v13462|v13463}}return funcDecl}var v3428=TypeScript.TypeCheckStatus;signature.typeCheckStatus=v3428.Started;var v3429=this.checker;JAMScript.call(v3429.addStartedPTO,v3429,[signature]);var prevScope=this.scope,prevFnc=this.thisFnc,prevMethodStatus=
this.enclosingFncIsMethod,prevClassNode=this.thisClassNode,v3430=JAMScript.call(funcDecl.isMethod,funcDecl,[]),v13464=!v3430;v13464&&(v3430=funcDecl.isConstructor);this.enclosingFncIsMethod=v3430;this.thisFnc=funcDecl;var v3431=funcDecl.type,container=v3431.symbol,prevThisType=this.thisType,v3432=this.checker,prevLocationInfo=v3432.locationInfo,funcTable=null,acceptedContextualType=!1,targetParams=null,targetReturnType=null,v3433=JAMScript.call(funcDecl.isAccessor,funcDecl,[]);if(v3433)var v13465=
funcDecl.fncFlags,v19407=TypeScript.FncFlags,v13466=v19407.GetAccessor,v3433=JAMScript.call(TypeScript.hasFlag,TypeScript,[v13465,v13466]);var isGetter=v3433,v3434=JAMScript.call(funcDecl.isAccessor,funcDecl,[]);if(v3434)var v13467=funcDecl.fncFlags,v19408=TypeScript.FncFlags,v13468=v19408.SetAccessor,v3434=JAMScript.call(TypeScript.hasFlag,TypeScript,[v13467,v13468]);var isSetter=v3434,v3435,v19409=isGetter||isSetter;v19409&&(v19409=funcDecl.accessorSymbol);var v13470=v19409;if(v13470){var v13469=
funcDecl.accessorSymbol;v3435=JAMScript.call(v13469.getType,v13469,[])}else v3435=null;var accessorType=v3435,v3436=this.checker,prevModDecl=v3436.currentModDecl,v13471=funcDecl.isConstructor;if(v13471)var v19410=funcDecl.isOverload,v13471=!v19410;var v3446=v13471;if(v3446){var v13472=fnType.instanceType,v3438=null==v13472;if(v3438){var v13473=this.checker,v3437=v13473.errorReporter;JAMScript.call(v3437.simpleError,v3437,[funcDecl,"Malformed function body (is this a class named the same as an existing interface?)"]);
return funcDecl}var v3439=fnType.instanceType,ssb=this.scope=v3439.constructorScope,v3440=ssb.valueMembers,funcTable=v3440.allMembers}else{var v19411=JAMScript.call(funcDecl.isSpecialFn,funcDecl,[]);if(v19411)var v24905=funcDecl.fncFlags,v25792=TypeScript.FncFlags,v24906=v25792.Signature,v23111=v24905&v24906,v19411=!v23111;var v13474=v19411,v19412=!v13474;v19412&&(v13474=funcDecl.isOverload);var v3445=v13474;if(v3445){var funcTable=funcDecl.symbols,v23112=funcDecl.fncFlags,v24907=TypeScript.FncFlags,
v23113=v24907.Static,v19413=JAMScript.call(TypeScript.hasFlag,TypeScript,[v23112,v23113]),v13475=!v19413;v13475&&(v13475=fnType.containedScope);var v3441=v13475;v3441&&(this.scope=fnType.containedScope)}else{var v3442=funcDecl.bod;v3442&&(this.scope=fnType.containedScope);var v13476=ssb=this.scope;v13476&&(v13476=ssb.valueMembers);var v3444=v13476;if(v3444)var v3443=ssb.valueMembers,funcTable=v3443.allMembers}}var v13477=funcDecl.isConstructor;if(v13477){var v19414=funcDecl.bod;if(v19414)var v23114=
funcDecl.fncFlags,v24908=TypeScript.FncFlags,v23115=v24908.ClassMethod,v19414=JAMScript.call(TypeScript.hasFlag,TypeScript,[v23114,v23115]);v13477=v19414}var v3458=v13477;if(v3458){var v23116=funcDecl.classDecl,v19415=v23116.type,v13478=v19415.instanceType,v3447=v13478.typeFlags,v13479=TypeScript.TypeFlags,v3448=v13479.HasBaseType,hasBaseType=JAMScript.call(TypeScript.hasFlag,TypeScript,[v3447,v3448]),v3449=!hasBaseType,v13482=!v3449;if(v13482)var v24909=funcDecl.classDecl,v23117=v24909.type,v19416=
v23117.instanceType,v13480=v19416.typeFlags,v19417=TypeScript.TypeFlags,v13481=v19417.HasBaseTypeOfObject,v3449=JAMScript.call(TypeScript.hasFlag,TypeScript,[v13480,v13481]);var noSuperCallAllowed=v3449,v13483=funcDecl.classDecl,v3450=v13483.varFlags,v13484=TypeScript.VarFlags,v3451=v13484.ClassSuperMustBeFirstCallInConstructor,superCallMustBeFirst=JAMScript.call(TypeScript.hasFlag,TypeScript,[v3450,v3451]),v13485=noSuperCallAllowed;v13485&&(v13485=JAMScript.call(this.classConstructorHasSuperCall,
this,[funcDecl]));var v3457=v13485;if(v3457){var v13486=this.checker,v3452=v13486.errorReporter;JAMScript.call(v3452.simpleError,v3452,[funcDecl,"Calls to 'super' constructor are not allowed in classes that either inherit directly from 'Object' or have no base class"])}else if(hasBaseType)if(superCallMustBeFirst){var v19418=funcDecl.bod,v13487=!v19418,v19420=!v13487;if(v19420){var v25793=funcDecl.bod,v24910=v25793.members,v23118=v24910.length,v19419=!v23118,v23120=!v19419;if(v23120){var v26688=funcDecl.bod,
v26623=v26688.members,v26517=v26623[0],v26278=v26517.nodeType,v26518=TypeScript.NodeType,v26279=v26518.Call,v25794=v26278==v26279;if(v25794)var v26735=funcDecl.bod,v26689=v26735.members,v26624=v26689[0],v26519=v26624.target,v26280=v26519.nodeType,v26520=TypeScript.NodeType,v26281=v26520.Super,v25794=v26280==v26281;var v24911=v25794,v25796=!v24911;if(v25796){var v26521=funcDecl.bod,v26282=v26521.flags,v26522=TypeScript.ASTFlags,v26283=v26522.StrictMode,v25795=JAMScript.call(TypeScript.hasFlag,TypeScript,
[v26282,v26283]);if(v25795){var v26690=funcDecl.bod,v26625=v26690.members,v26523=v26625.length,v26284=1<v26523;if(v26284){var v26755=funcDecl.bod,v26736=v26755.members,v26691=v26736[1],v26626=v26691.nodeType,v26692=TypeScript.NodeType,v26627=v26692.Call,v26524=v26626==v26627;if(v26524)var v26764=funcDecl.bod,v26756=v26764.members,v26737=v26756[1],v26693=v26737.target,v26628=v26693.nodeType,v26694=TypeScript.NodeType,v26629=v26694.Super,v26524=v26628==v26629;v26284=v26524}v25795=v26284}v24911=v25795}var v23119=
v24911,v19419=!v23119}v13487=v19419}var v3454=v13487;if(v3454){var v13488=this.checker,v3453=v13488.errorReporter;JAMScript.call(v3453.simpleError,v3453,[funcDecl,"If a derived class contains initialized properties or constructor parameter properties, the first statement in the constructor body must be a call to the super constructor"])}}else{var v13489=JAMScript.call(this.classConstructorHasSuperCall,this,[funcDecl]),v3456=!v13489;if(v3456){var v13490=this.checker,v3455=v13490.errorReporter;JAMScript.call(v3455.simpleError,
v3455,[funcDecl,"Constructors for derived classes must contain a call to the class's 'super' constructor"])}}}var v13491=JAMScript.call(funcDecl.isMethod,funcDecl,[]);if(v13491)var v19421=funcDecl.type,v13491=v19421.enclosingType;var v3463=v13491;if(v3463){var enclosingClassNode=null,v25797=funcDecl.type,v24912=v25797.enclosingType,v23121=v24912.symbol,v19422=v23121.declAST,v13492=v19422.nodeType,v19423=TypeScript.NodeType,v13493=v19423.FuncDecl,v3462=v13492==v13493;if(v3462)var v23122=funcDecl.type,
v19424=v23122.enclosingType,v13494=v19424.symbol,v3459=v13494.declAST,enclosingClassNode=v3459.classDecl;else{var v25798=funcDecl.type,v24913=v25798.enclosingType,v23123=v24913.symbol,v19425=v23123.declAST,v13495=v19425.nodeType,v19426=TypeScript.NodeType,v13496=v19426.ClassDeclaration,v3461=v13495==v13496;if(v3461)var v19427=funcDecl.type,v13497=v19427.enclosingType,v3460=v13497.symbol,enclosingClassNode=v3460.declAST}enclosingClassNode&&(this.thisClassNode=enclosingClassNode)}var v3468=fnType.enclosingType;
if(v3468){var v3464=fnType.symbol,enclosingSym=v3464.container,v13498=enclosingSym;if(v13498){var v19428=JAMScript.call(enclosingSym.isType,enclosingSym,[]);if(v19428)var v23124=JAMScript.call(enclosingSym.getType,enclosingSym,[]),v19428=JAMScript.call(v23124.isClass,v23124,[]);v13498=v19428}var v3465=v13498;v3465&&(enclosingSym=enclosingSym.container);var v13499=enclosingSym;if(v13499){var v19429=enclosingSym.declAST;if(v19429)var v24914=enclosingSym.declAST,v23125=v24914.nodeType,v24915=TypeScript.NodeType,
v23126=v24915.ModuleDeclaration,v19429=v23125==v23126;v13499=v19429}var v3467=v13499;if(v3467){var v3466=this.checker;v3466.currentModDecl=enclosingSym.declAST}}var v13500=funcDecl.unitIndex,v3472=0<v13500;if(v3472){var v19430=this.checker,v13501=v19430.units;if(v13501)var v19431=funcDecl.unitIndex,v24916=this.checker,v23127=v24916.units,v19432=v23127.length,v13501=v19431<v19432;var v3471=v13501;if(v3471){var v3469=this.checker,v19433=this.checker,v13502=v19433.units,v13503=funcDecl.unitIndex;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v3469.locationInfo=
v13502[v13503]}else{var v3470=this.checker;v3470.locationInfo=TypeScript.unknownLocationInfo}}var v3473=fnType.enclosingType;this.thisType=v3473?fnType.enclosingType:prevThisType;var v3474=signature.parameters,paramLen=v3474.length,v19434=funcDecl.isConstructor,v13504=!v19434;if(v13504){var v19435=funcDecl.bod;if(v19435)var v23128=JAMScript.call(funcDecl.isSignature,funcDecl,[]),v19435=!v23128;v13504=v19435}var v3523=v13504;if(v3523){var tmpParamScope=this.scope,ssb=this.scope,v19436=JAMScript.call(funcDecl.isMethod,
funcDecl,[]),v13505=!v19436;if(v13505)var v19437=funcDecl.returnTypeAnnotation,v13505=null==v19437;var v3492=v13505;if(v3492){var v13506=prevScope;if(v13506){var v19438=funcDecl.name;if(v19438)var v24917=funcDecl.name,v23129=JAMScript.call(v24917.isMissing,v24917,[]),v19438=!v23129;v13506=v19438}var v3479=v13506;if(v3479){var v13507=funcDecl.name,v3475=v13507.text,considerSym=JAMScript.call(prevScope.findAmbient,prevScope,[v3475,!1,!1]),v13508=considerSym;if(v13508){var v19439=considerSym.declAST;
if(v19439)var v23130=considerSym.declAST,v19439=v23130.type;v13508=v19439}var v3478=v13508;if(v3478){var v3476=this.checker,v13509=considerSym.declAST,v3477=v13509.type;JAMScript.call(v3476.setContextualType,v3476,[v3477,!1])}}var v13510=this.checker,v3491=JAMScript.call(v13510.hasTargetType,v13510,[]);if(v3491){var v3480=this.checker,candidateTypeContext=v3480.currentContextualTypeContext,candidateType=candidateTypeContext.contextualType,v13511=this.checker,v3490=JAMScript.call(v13511.canContextuallyTypeFunction,
v13511,[candidateType,funcDecl,!0]);if(v3490){var v3481,v13512=candidateType.construct,candidateSigs=v3481=v13512?candidateType.construct:candidateType.call,v3482=candidateSigs.signatures;candidateTypeContext.targetSig=v3482[0];var v3483=candidateTypeContext.targetSig,candidateParams=v3483.parameters,targetParams=candidateParams,v13513=candidateTypeContext.targetSig,v3484=v13513.returnType,targetReturnType=v3484.type,v13514=candidateTypeContext.targetSig,v3487=v13514.declAST;if(v3487){var v19440=
candidateTypeContext.targetSig,v13515=v19440.declAST,v3486=v13515.isConstructor;if(v3486)funcDecl.isTargetTypedAsMethod=!0;else{var v19441=candidateTypeContext.targetSig,v13516=v19441.declAST,v3485=JAMScript.call(v13516.isMethod,v13516,[]);v3485&&(funcDecl.isTargetTypedAsMethod=!0)}}fgSym.type=candidateTypeContext.contextualType;acceptedContextualType=!0}else{var v13517=candidateType;v13517&&(v13517=JAMScript.call(funcDecl.isAccessor,funcDecl,[]));var v3489=v13517;if(v3489)accessorType=candidateType,
candidateTypeContext.targetAccessorType=accessorType;else{var v3488=this.checker;JAMScript.call(v3488.killCurrentContextualType,v3488,[])}}}}var paramTable=ssb.valueMembers,v3493=TypeScript.SymbolScopeBuilder,v26850=JAMScript.new(v3493,[paramTable,null,null,null,prevScope,container]);this.scope=v26850;for(var p=0,v3506=p<paramLen;v3506;){var v3494=signature.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var symbol=v3494[p];var ast=symbol.declAST,v19442=
this.checker,v13518=JAMScript.call(v19442.hasTargetType,v19442,[]);if(v13518){var v19443=targetParams;if(v19443){var v26285=this.checker,v25799=v26285.currentContextualTypeContext,v24918=v25799.targetSig,v23131=v24918.hasVariableArgList,v24920=!v23131;if(v24920)var v24919=targetParams.length,v23131=p<v24919;v19443=v23131}v13518=v19443}var v3501=v13518;if(v3501){var v3495=this.checker,candidateTypeContext=v3495.currentContextualTypeContext,v3496=candidateTypeContext.targetSig,hasVarArgList=v3496.hasVariableArgList,
v3497=ast,v13519,v23132=hasVarArgList;if(v23132)var v25800=targetParams.length,v24921=v25800-1,v23132=p>=v24921;var v19446=v23132;if(v19446){var v25801=targetParams.length,v24922=v25801-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v23133=targetParams[v24922];var v19444=JAMScript.call(v23133.getType,v23133,[]);v13519=v19444.elementType}else{introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v19445=targetParams[p];v13519=
JAMScript.call(v19445.getType,v19445,[])}v3497.type=v13519;var v3498=ast.sym,v3499=ast.type;JAMScript.call(v3498.setType,v3498,[v3499]);var v3500=ast.sym,v13520=this.checker,v26851=JAMScript.call(v13520.getTypeCheckFinishedStatus,v13520,[]);v3500.typeCheckStatus=v26851}else JAMScript.call(this.typeCheck,this,[ast]);var v3502=isSetter&&accessorType;v3502&&(ast=JAMScript.call(this.cast,this,[ast,accessorType]));symbol.container=container;var v3503=JAMScript.call(symbol.getType,symbol,[]);JAMScript.call(this.checkTypePrivacy,
this,[v3503,container,v1062]);var v3504=paramTable.publicMembers,v3505=symbol.name;JAMScript.call(v3504.add,v3504,[v3505,symbol]);p+=1;v3506=p<paramLen}this.scope=tmpParamScope}else{var v3507=funcDecl.arguments;JAMScript.call(this.typeCheck,this,[v3507]);for(var p=0,v3513=p<paramLen;v3513;){var v23134=signature.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v19447=v23134[p];var v13521=v19447.parameter,v3508=v13521.typeLink,v23135=funcDecl.arguments,
v19448=v23135.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v13522=v19448[p];v3508.type=v13522.type;var v19449=signature.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v13523=v19449[p];var v3509=JAMScript.call(v13523.getType,v13523,[]);JAMScript.call(this.checkTypePrivacy,this,[v3509,container,v1063]);var v23136=funcDecl.arguments,v19450=v23136.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v13524=
v19450[p];var v3512=v13524.parameterPropertySym;if(v3512){var v23137=funcDecl.arguments,v19451=v23137.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v13525=v19451[p];var v3510=v13525.parameterPropertySym,v23138=funcDecl.arguments,v19452=v23138.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v13526=v19452[p];var v3511=v13526.type;JAMScript.call(v3510.setType,v3510,[v3511])}p+=1;v3513=p<paramLen}var v13527=
funcDecl.fncFlags,v19453=TypeScript.FncFlags,v13528=v19453.IndexerMember,v3522=v13527&v13528;if(v3522){var v13529=!paramLen,v19454=!v13529;v19454&&(v13529=1<paramLen);var v3521=v13529;if(v3521){var v13530=this.checker,v3514=v13530.errorReporter;JAMScript.call(v3514.simpleError,v3514,[funcDecl,"Index signatures may take one and only one parameter"])}else{var v24923=funcDecl.arguments,v23139=v24923.members,v19455=v23139[0],v13531=v19455.type,v19456=this.checker,v13532=v19456.numberType,v3520=v13531==
v13532;if(v3520){var v3515=fnType.index,v19457=v3515.flags,v23140=TypeScript.SignatureFlags,v19458=v23140.IsNumberIndexer;v3515.flags=v19457|v19458}else{var v24924=funcDecl.arguments,v23141=v24924.members,v19459=v23141[0],v13533=v19459.type,v19460=this.checker,v13534=v19460.stringType,v3519=v13533==v13534;if(v3519){var v3516=fnType.index,v19461=v3516.flags,v23142=TypeScript.SignatureFlags,v19462=v23142.IsStringIndexer;v3516.flags=v19461|v19462}else{var v13535=this.checker,v3517=v13535.errorReporter,
v19463=funcDecl.arguments,v13536=v19463.members,v3518=v13536[0];JAMScript.call(v3517.simpleError,v3517,[v3518,"Index signatures may only take 'string' or 'number' as their parameter"])}}}}}var v13537=funcDecl.bod;if(v13537)var v19464=JAMScript.call(funcDecl.isSignature,funcDecl,[]),v13537=!v19464;var v3555=v13537;if(v3555){var v13538=funcDecl.isConstructor,v3532=!v13538;if(v3532)JAMScript.call(this.addFormals,this,[container,signature,funcTable]);else{var v13539=funcDecl.type,v3524=v13539.symbol,
v3525=funcDecl.arguments,v13540=funcDecl.fncFlags,v19465=TypeScript.FncFlags,v13541=v19465.ClassMethod,v3526=JAMScript.call(TypeScript.hasFlag,TypeScript,[v13540,v13541]);JAMScript.call(this.addConstructorLocalArgs,this,[v3524,v3525,funcTable,v3526]);var v13542=this.thisClassNode;if(v13542)var v19466=this.thisClassNode,v13542=v19466.extendsList;var v3531=v13542;if(v3531){var tmpScope=this.scope,v3527=TypeScript.ScopedMembers,funcMembers=JAMScript.new(v3527,[funcTable]),v3528=TypeScript.FilteredSymbolScopeBuilder,
v13543=funcDecl.type,v3529=v13543.symbol,v26852=JAMScript.new(v3528,[funcMembers,prevScope,v3529,v1064]);this.scope=v26852;var v13544=this.thisClassNode,v3530=v13544.extendsList;JAMScript.call(this.typeCheckBaseCalls,this,[v3530]);this.scope=tmpScope}}var v3533=this.checker,prevMod=v3533.currentModDecl,v13545=funcDecl.type;if(v13545){var v23143=funcDecl.type,v19467=v23143.symbol;if(v19467){var v24925=JAMScript.call(funcDecl.isMethod,funcDecl,[]),v23144=!v24925;if(v23144)var v25802=funcDecl.type,v24926=
v25802.symbol,v23144=v24926.declModule;v19467=v23144}v13545=v19467}var v3535=v13545;if(v3535){var v3534=this.checker,v19468=funcDecl.type,v13546=v19468.symbol;v3534.currentModDecl=v13546.declModule}if(acceptedContextualType){var v3536=this.checker,v13547=this.checker,v3537=JAMScript.call(v13547.inProvisionalTypecheckMode,v13547,[]);JAMScript.call(v3536.setContextualType,v3536,[null,v3537])}var v3538=funcDecl.bod;JAMScript.call(this.typeCheck,this,[v3538]);if(acceptedContextualType){var v3539=this.checker;
JAMScript.call(v3539.unsetContextualType,v3539,[])}var v3540=this.checker;v3540.currentModDecl=prevMod;var v13548=this.checker,v3547=v13548.checkControlFlow;if(v3547){var cfg=JAMScript.call(funcDecl.buildControlFlow,funcDecl,[]),v13549=this.checker,v3542=v13549.printControlFlowGraph;if(v3542){var v19469=this.checker,v13550=v19469.errorReporter,v3541=v13550.outfile;JAMScript.call(cfg.print,cfg,[v3541])}var v13551=this.checker,v3543=v13551.errorReporter;JAMScript.call(cfg.reportUnreachable,cfg,[v3543]);
var v13552=this.checker,v3546=v13552.checkControlFlowUseDef;if(v3546){var v13553=this.checker,v3544=v13553.errorReporter,v13554=funcDecl.type,v3545=v13554.symbol;JAMScript.call(cfg.useDef,cfg,[v3544,v3545])}}var v3554=funcDecl.isConstructor;if(v3554)for(var fns=funcDecl.scopes,v3548=fns.members,fnsLen=v3548.length,j=0,v3553=j<fnsLen;v3553;){var v3549=fns.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var fn=v3549[j];var v13555=JAMScript.call(fn.isSignature,
fn,[]),v3552=!v13555;if(v3552){var v19470=fn.fncFlags,v23145=TypeScript.FncFlags,v19471=v23145.Method,v13556=JAMScript.call(TypeScript.hasFlag,TypeScript,[v19470,v19471]);if(v13556)var v23146=fn.fncFlags,v24927=TypeScript.FncFlags,v23147=v24927.Static,v19472=JAMScript.call(TypeScript.hasFlag,TypeScript,[v23146,v23147]),v13556=!v19472;var v3551=v13556;if(v3551){var v13557=funcDecl.type,v3550=v13557.symbol;JAMScript.call(this.checkPromoteFreeVars,this,[fn,v3550])}}j+=1;v3553=j<fnsLen}}this.scope=prevScope;
this.thisFnc=prevFnc;this.thisClassNode=prevClassNode;this.enclosingFncIsMethod=prevMethodStatus;this.thisType=prevThisType;var v3556=this.checker;v3556.locationInfo=prevLocationInfo;var v3557=this.checker;v3557.currentModDecl=prevModDecl;var v3558=signature,v13558=this.checker,v26853=JAMScript.call(v13558.getTypeCheckFinishedStatus,v13558,[]);v3558.typeCheckStatus=v26853;var v3566=funcDecl.returnTypeAnnotation;if(v3566){var v13559=funcDecl.returnTypeAnnotation,v3559=v13559.type,v3560=funcDecl.returnTypeAnnotation;
JAMScript.call(this.checkForVoidConstructor,this,[v3559,v3560]);var v19473=signature.returnType,v13560=v19473.type,v3564=null==v13560;if(v3564){var v3561=this.checker,v3562=this.scope,v3563=signature.returnType;JAMScript.call(v3561.resolveTypeLink,v3561,[v3562,v3563,!1])}}else if(targetReturnType){var v3565=signature.returnType;v3565.type=targetReturnType}var v23148=fgSym.flags,v24928=TypeScript.SymbolFlags,v23149=v24928.RecursivelyReferenced,v19474=v23148&v23149,v13561=!v19474;if(v13561)var v23150=
funcDecl.returnStatementsWithExpressions,v19475=v23150.length,v13561=0<v19475;var v3574=v13561;if(v3574){var collection={getLength:v1065,setTypeAtIndex:v1066,getTypeAtIndex:v1067},v13562=funcDecl.returnStatementsWithExpressions,v3567=v13562[0],bestCommonReturnType=v3567.type,v3568=this.checker;if(bestCommonReturnType=JAMScript.call(v3568.findBestCommonType,v3568,[bestCommonReturnType,null,collection,!0])){var v3569=signature.returnType,v13563=this.checker,v26854=JAMScript.call(v13563.widenType,v13563,
[bestCommonReturnType]);v3569.type=v26854}else{for(var i=0,v19476=funcDecl.returnStatementsWithExpressions,v13564=v19476.length,v3572=i<v13564;v3572;){var v13565=this.checker,v3570=v13565.errorReporter,v13566=funcDecl.returnStatementsWithExpressions;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v3571=v13566[i];JAMScript.call(v3570.simpleError,v3570,[v3571,"Incompatible return type"]);var i=i+1,v19477=funcDecl.returnStatementsWithExpressions,v13567=v19477.length,
v3572=i<v13567}var v3573=signature.returnType;v3573.type=this.anyType}}var onlyHasThrow=!1,v19478=signature.returnType,v13568=v19478.type,v3589=null==v13568;if(v3589){var v13569=funcDecl.fncFlags,v19479=TypeScript.FncFlags,v13570=v19479.HasReturnExpression,v3579=JAMScript.call(TypeScript.hasFlag,TypeScript,[v13569,v13570]);if(v3579){var v19480=this.checker,v13571=v19480.styleSettings,v3576=v13571.implicitAny;if(v3576){var v13572=this.checker,v3575=v13572.errorReporter;JAMScript.call(v3575.styleError,
v3575,[funcDecl,"type implicitly set to 'any'"])}var v3577=signature.returnType;v3577.type=this.anyType}else{var v3578=signature.returnType;v3578.type=this.voidType}}else{var v23151=signature.returnType,v19481=v23151.type,v19482=this.nullType,v13573=v19481==v19482,v19485=!v13573;if(v19485)var v23152=signature.returnType,v19483=v23152.type,v23153=this.checker,v19484=v23153.undefinedType,v13573=v19483==v19484;var v3588=v13573;if(v3588){var v3580=signature.returnType;v3580.type=this.anyType}else{var v23154=
signature.returnType,v19486=v23154.type,v19487=this.voidType,v13574=v19486!=v19487;if(v13574){var v24929=signature.returnType,v23155=v24929.type,v24930=this.checker,v23156=v24930.undefinedType,v19488=v23155!=v23156;if(v19488)var v24931=signature.returnType,v23157=v24931.type,v23158=this.anyType,v19488=v23157!=v23158;v13574=v19488}var v3587=v13574;if(v3587){var v19489=JAMScript.call(funcDecl.isSignature,funcDecl,[]),v13575=!v19489;if(v13575){var v23159=funcDecl.isConstructor,v19490=!v23159;if(v19490){var v25803=
funcDecl.fncFlags,v26286=TypeScript.FncFlags,v25804=v26286.HasReturnExpression,v24932=JAMScript.call(TypeScript.hasFlag,TypeScript,[v25803,v25804]),v23160=!v24932;if(v23160)var v25805=funcDecl.fncFlags,v26287=TypeScript.FncFlags,v25806=v26287.IsFatArrowFunction,v24933=JAMScript.call(TypeScript.hasFlag,TypeScript,[v25805,v25806]),v23160=!v24933;v19490=v23160}v13575=v19490}var v3585=v13575;if(v3585){var v23161=funcDecl.bod,v19491=v23161.members,v13576=v19491.length,v3581=0<v13576;if(v3581)var v24934=
funcDecl.bod,v23162=v24934.members,v19492=v23162[0],v13577=v19492.nodeType,v19493=TypeScript.NodeType,v13578=v19493.Throw,v3581=v13577==v13578;var onlyHasThrow=v3581,v3584=!onlyHasThrow;if(v3584){var v13579=this.checker,v3582=v13579.errorReporter,v13580=funcDecl.returnTypeAnnotation,v19494=!v13580;v19494&&(v13580=funcDecl);var v3583=v13580;JAMScript.call(v3582.simpleError,v3582,[v3583,"Function declared a non-void return type, but has no return expression"])}}var v13581=signature.returnType,v3586=
v13581.type;JAMScript.call(this.checkTypePrivacy,this,[v3586,container,v1068])}}}var v3602=funcDecl.accessorSymbol;if(v3602){var v3590=funcDecl.accessorSymbol,accessorType=JAMScript.call(v3590.getType,v3590,[]),v13582=!onlyHasThrow;if(v13582){var v23163=funcDecl.fncFlags,v24935=TypeScript.FncFlags,v23164=v24935.GetAccessor,v19495=JAMScript.call(TypeScript.hasFlag,TypeScript,[v23163,v23164]);if(v19495)var v24936=funcDecl.fncFlags,v25807=TypeScript.FncFlags,v24937=v25807.HasReturnExpression,v23165=
JAMScript.call(TypeScript.hasFlag,TypeScript,[v24936,v24937]),v19495=!v23165;v13582=v19495}var v3592=v13582;if(v3592){var v13583=this.checker,v3591=v13583.errorReporter;JAMScript.call(v3591.simpleError,v3591,[funcDecl,"Getters must return a value"])}if(accessorType){var v23166=funcDecl.fncFlags,v24938=TypeScript.FncFlags,v23167=v24938.GetAccessor,v19496=JAMScript.call(TypeScript.hasFlag,TypeScript,[v23166,v23167]);if(v19496)var v24939=signature.returnType,v23168=v24939.type,v19496=accessorType!=v23168;
var v13584=v19496,v19498=!v13584;if(v19498){var v25808=funcDecl.arguments,v24940=v25808.members,v23169=v24940.length,v19497=0<v23169;if(v19497)var v26288=funcDecl.arguments,v25809=v26288.members,v24941=v25809[0],v23170=v24941.type,v19497=accessorType!=v23170;v13584=v19497}var v3594=v13584;if(v3594){var v13585=this.checker,v3593=v13585.errorReporter;JAMScript.call(v3593.simpleError,v3593,[funcDecl,"Getter and setter types do not agree"])}}else{var v13586=funcDecl.fncFlags,v19499=TypeScript.FncFlags,
v13587=v19499.GetAccessor,v3601=JAMScript.call(TypeScript.hasFlag,TypeScript,[v13586,v13587]);if(v3601){var v3595=funcDecl.accessorSymbol,v13588=signature.returnType,v3596=v13588.type;JAMScript.call(v3595.setType,v3595,[v3596])}else{var v23171=funcDecl.arguments,v19500=v23171.members,v13589=v19500.length,v3600=1!=v13589;if(v3600){var v13590=this.checker,v3597=v13590.errorReporter;JAMScript.call(v3597.simpleError,v3597,[funcDecl,"Setters may have one and only one argument"])}else{var v3598=funcDecl.accessorSymbol,
v23172=funcDecl.arguments,v19501=v23172.members,v13591=v19501[0],v3599=v13591.type;JAMScript.call(v3598.setType,v3598,[v3599])}}}}JAMScript.call(this.typeCheckOverloadSignatures,this,[fnType,funcDecl]);return funcDecl}function v1061(funcDecl,signature,typeName,isModuleName){var reportOnFuncDecl=!1,v19502=funcDecl.returnTypeAnnotation;if(v19502=null!=v19502)var v19502=funcDecl.returnTypeAnnotation,v19502=v19502.type,v23174=signature.returnType,v23174=v23174.type,v19502=v19502==v23174;v19502&&(v19502=
funcDecl.returnTypeAnnotation,JAMScript.call(this.returnTypePrivacyError,this,[v19502,funcDecl,typeName,isModuleName]));v19502=0;v23174=funcDecl.returnStatementsWithExpressions;v23174=v23174.length;for(v23174=v19502<v23174;v23174;){v23174=funcDecl.returnStatementsWithExpressions;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v23174=v23174[v19502];var v23174=v23174.type,v19507=signature.returnType,v19507=v19507.type;if(v23174=v23174==v19507){v23174=funcDecl.returnStatementsWithExpressions;
introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v23174=v23174[v19502];JAMScript.call(this.returnTypePrivacyError,this,[v23174,funcDecl,typeName,isModuleName])}else reportOnFuncDecl=!0;v19502+=1;v23174=funcDecl.returnStatementsWithExpressions;v23174=v23174.length;v23174=v19502<v23174}reportOnFuncDecl&&JAMScript.call(this.returnTypePrivacyError,this,[funcDecl,funcDecl,typeName,isModuleName])}function v1060(astError,funcDecl,typeName,isModuleName){var v3608=JAMScript.call(funcDecl.isAccessor,
funcDecl,[]);if(v3608)var v3608=funcDecl.fncFlags,v19509=TypeScript.FncFlags,v19509=v19509.GetAccessor,v3608=JAMScript.call(TypeScript.hasFlag,TypeScript,[v3608,v19509]);v19509=v3608;if(v3608=JAMScript.call(funcDecl.isAccessor,funcDecl,[]))var v3608=funcDecl.fncFlags,v19510=TypeScript.FncFlags,v19510=v19510.SetAccessor,v3608=JAMScript.call(TypeScript.hasFlag,TypeScript,[v3608,v19510]);var isSetter=v3608,v3608=funcDecl.fncFlags,v19510=TypeScript.FncFlags,v19510=v19510.Public,v19510=JAMScript.call(TypeScript.hasFlag,
TypeScript,[v3608,v19510]),v3608=funcDecl.type,v3608=v3608.symbol,v13604=this.checker,v3608=JAMScript.call(v3608.getInterfaceDeclFromSymbol,v3608,[v13604]),v13604=null!=v3608,v3608="";isModuleName?(v3608="",isModuleName=JAMScript.call(TypeScript.isQuoted,TypeScript,[typeName]),(isModuleName=!isModuleName)&&(v3608="'"),isModuleName=" is using inaccessible module "+v3608,typeName=isModuleName+typeName,v3608=typeName+v3608):(v3608=" has or is using private type '"+typeName,v3608+="'");if(typeName=!v13604)if(v19509)funcDecl=
this.checker,funcDecl=funcDecl.errorReporter,typeName=v19510?"public":"exported",typeName+=" getter return type",v3608=typeName+v3608,JAMScript.call(funcDecl.simpleError,funcDecl,[astError,v3608]);else{if(funcDecl=!isSetter)funcDecl=this.checker,funcDecl=funcDecl.errorReporter,typeName=v19510?"public":"exported",typeName+=" function return type",v3608=typeName+v3608,JAMScript.call(funcDecl.simpleError,funcDecl,[astError,v3608])}else(typeName=JAMScript.call(funcDecl.isConstructMember,funcDecl,[]))?
(funcDecl=this.checker,funcDecl=funcDecl.errorReporter,v3608="exported interface's constructor return type"+v3608):(typeName=JAMScript.call(funcDecl.isCallMember,funcDecl,[]))?(funcDecl=this.checker,funcDecl=funcDecl.errorReporter,v3608="exported interface's call return type"+v3608):(funcDecl=JAMScript.call(funcDecl.isIndexerMember,funcDecl,[]))?(funcDecl=this.checker,funcDecl=funcDecl.errorReporter,v3608="exported interface's indexer return type"+v3608):(funcDecl=this.checker,funcDecl=funcDecl.errorReporter,
v3608="exported interface's function return type"+v3608),JAMScript.call(funcDecl.simpleError,funcDecl,[astError,v3608])}function v1059(funcDecl,p,paramSymbol,typeName,isModuleName){var v3633=JAMScript.call(funcDecl.isAccessor,funcDecl,[]);if(v3633)var v3633=funcDecl.fncFlags,v19514=TypeScript.FncFlags,v19514=v19514.GetAccessor,v3633=JAMScript.call(TypeScript.hasFlag,TypeScript,[v3633,v19514]);var isGetter=v3633;if(v3633=JAMScript.call(funcDecl.isAccessor,funcDecl,[]))v3633=funcDecl.fncFlags,v19514=
TypeScript.FncFlags,v19514=v19514.SetAccessor,v3633=JAMScript.call(TypeScript.hasFlag,TypeScript,[v3633,v19514]);var isSetter=v3633,v3633=funcDecl.fncFlags,v19514=TypeScript.FncFlags,v19514=v19514.Public,v19514=JAMScript.call(TypeScript.hasFlag,TypeScript,[v3633,v19514]),v3633=funcDecl.type,v3633=v3633.symbol,v13621=this.checker,v3633=JAMScript.call(v3633.getInterfaceDeclFromSymbol,v3633,[v13621]),v13621=null!=v3633,v3633="";isModuleName?(v3633="",isModuleName=JAMScript.call(TypeScript.isQuoted,TypeScript,
[typeName]),(isModuleName=!isModuleName)&&(v3633="'"),isModuleName=" is using inaccessible module "+v3633,typeName=isModuleName+typeName,v3633=typeName+v3633):(v3633=" has or is using private type '"+typeName,v3633+="'");if(typeName=!v13621)if(typeName=funcDecl.isConstructor){v19514=this.checker;v19514=v19514.errorReporter;funcDecl=funcDecl.arguments;funcDecl=funcDecl.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)p=funcDecl[p];paramSymbol=paramSymbol.name;
paramSymbol="exported class's constructor parameter '"+paramSymbol;paramSymbol+="'";paramSymbol+=v3633;JAMScript.call(v19514.simpleError,v19514,[p,paramSymbol])}else if(isSetter){typeName=this.checker;typeName=typeName.errorReporter;funcDecl=funcDecl.arguments;funcDecl=funcDecl.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)p=funcDecl[p];funcDecl=v19514?"public":"exported";funcDecl+=" setter parameter '";paramSymbol=paramSymbol.name;paramSymbol=funcDecl+
paramSymbol;paramSymbol+="'";paramSymbol+=v3633;JAMScript.call(typeName.simpleError,typeName,[p,paramSymbol])}else{if(typeName=!isGetter){typeName=this.checker;typeName=typeName.errorReporter;funcDecl=funcDecl.arguments;funcDecl=funcDecl.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)p=funcDecl[p];funcDecl=v19514?"public":"exported";funcDecl+=" function parameter '";paramSymbol=paramSymbol.name;paramSymbol=funcDecl+paramSymbol;paramSymbol+="'";paramSymbol+=
v3633;JAMScript.call(typeName.simpleError,typeName,[p,paramSymbol])}}else if(v19514=JAMScript.call(funcDecl.isConstructMember,funcDecl,[])){v19514=this.checker;v19514=v19514.errorReporter;funcDecl=funcDecl.arguments;funcDecl=funcDecl.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)p=funcDecl[p];paramSymbol=paramSymbol.name;paramSymbol="exported interface's constructor parameter '"+paramSymbol;paramSymbol+="'";paramSymbol+=v3633;JAMScript.call(v19514.simpleError,
v19514,[p,paramSymbol])}else if(v19514=JAMScript.call(funcDecl.isCallMember,funcDecl,[])){v19514=this.checker;v19514=v19514.errorReporter;funcDecl=funcDecl.arguments;funcDecl=funcDecl.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)p=funcDecl[p];paramSymbol=paramSymbol.name;paramSymbol="exported interface's call parameter '"+paramSymbol;paramSymbol+="'";paramSymbol+=v3633;JAMScript.call(v19514.simpleError,v19514,[p,paramSymbol])}else if(v19514=JAMScript.call(funcDecl.isIndexerMember,
funcDecl,[]),v19514=!v19514){v19514=this.checker;v19514=v19514.errorReporter;funcDecl=funcDecl.arguments;funcDecl=funcDecl.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)p=funcDecl[p];paramSymbol=paramSymbol.name;paramSymbol="exported interface's function parameter '"+paramSymbol;paramSymbol+="'";paramSymbol+=v3633;JAMScript.call(v19514.simpleError,v19514,[p,paramSymbol])}}function v1058(sgroup,declSymbol,errorCallback){if(sgroup)for(var v3665=sgroup.signatures,
v3665=v3665.length,i=0,v19529=sgroup.signatures,v19529=v19529.length,v19529=i<v19529;v19529;){v19529=sgroup.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v19529=v19529[i];var v13644=1<v3665;v13644&&(v13644=sgroup.definitionSignature,v13644=v19529==v13644);if(!v13644){if(v13644=v19529.returnType)v13644=v19529.returnType,v13644=v13644.type,JAMScript.call(this.checkTypePrivacy,this,[v13644,declSymbol,errorCallback]);for(var v13644=v19529.parameters,v13644=
v13644.length,j=0,v3673=j<v13644;v3673;){v3673=v19529.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v3673=v3673[j];v3673=JAMScript.call(v3673.getType,v3673,[]);JAMScript.call(this.checkTypePrivacy,this,[v3673,declSymbol,errorCallback]);j+=1;v3673=j<v13644}}i+=1;v19529=sgroup.signatures;v19529=v19529.length;v19529=i<v19529}}function v1057(type,declSymbol,errorCallback){function v1056(key,s,unused){key=s;s=key.flags;unused=TypeScript.SymbolFlags;unused=
unused.BuiltIn;s=JAMScript.call(TypeScript.hasFlag,TypeScript,[s,unused]);if(s=!s)key=JAMScript.call(key.getType,key,[]),JAMScript.call(_this.checkTypePrivacy,_this,[key,declSymbol,errorCallback])}var _this=this,v19535=type;if(v19535)var v19535=type.primitiveTypeClass,v24944=TypeScript.Primitive,v24944=v24944.None,v19535=v19535==v24944;v19535=!v19535;if(!v19535){if(v19535=JAMScript.call(type.isArray,type,[]))return type=type.elementType,JAMScript.call(this.checkTypePrivacy,this,[type,declSymbol,errorCallback]);
if(v19535=type.symbol)if(v19535=type.symbol,v19535=v19535.name)if(v19535=type.symbol,v19535=v19535.name,v19535="_anonymous"!=v19535){v19535=type.call;if(v19535=null==v19535)if(v19535=type.construct,v19535=null==v19535)v19535=type.index,v19535=null==v19535;if(v24944=!v19535)if(v19535=type.members)v19535=JAMScript.call(type.isClass,type,[]),v19535=!v19535}if(v19535)return type=type.symbol,JAMScript.call(this.checkSymbolPrivacy,this,[type,declSymbol,errorCallback]);if(v19535=type.members)v19535=type.members,
v19535=v19535.allMembers,JAMScript.call(v19535.map,v19535,[v1056,null]);v19535=type.call;JAMScript.call(this.checkSignatureGroupPrivacy,this,[v19535,declSymbol,errorCallback]);v19535=type.construct;JAMScript.call(this.checkSignatureGroupPrivacy,this,[v19535,declSymbol,errorCallback]);type=type.index;JAMScript.call(this.checkSignatureGroupPrivacy,this,[type,declSymbol,errorCallback])}}function v1055(typeSymbol,declSymbol,errorCallback){var externalModuleSymbol=null,declSymbolPath=null,v13652=this.checker;
if(v13652=JAMScript.call(typeSymbol.isExternallyVisible,typeSymbol,[v13652])){var v13652=JAMScript.call(typeSymbol.pathToRoot,typeSymbol,[]),declSymbolPath=JAMScript.call(declSymbol.pathToRoot,declSymbol,[]),typeSymbolLength=v13652.length,declSymbolPathLength=declSymbolPath.length,v3692=0<typeSymbolLength;if(v3692){v3692=typeSymbolLength-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v3692=v13652[v3692];v3692=JAMScript.call(v3692.getType,v3692,[]);if(v3692=JAMScript.call(v3692.isModuleType,
v3692,[])){v3692=typeSymbolLength-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v3692=v13652[v3692];if(v3692=v3692.isDynamic){v3692=typeSymbolLength-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v3692=v13652[v3692];var v24950=declSymbolPathLength-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v24950=declSymbolPath[v24950];v3692=v3692!=v24950}}if(v3692)externalModuleSymbol=typeSymbolLength-
1,externalModuleSymbol=v13652[externalModuleSymbol];else if(v3692=1<typeSymbolLength){v3692=typeSymbolLength-2;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v3692=v13652[v3692];v3692=JAMScript.call(v3692.getType,v3692,[]);if(v3692=JAMScript.call(v3692.isModuleType,v3692,[])){v3692=typeSymbolLength-2;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v3692=v13652[v3692];if(v3692=v3692.isDynamic)if(v3692=1==declSymbolPathLength,v24950=
!v3692){v3692=typeSymbolLength-2;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v3692=v13652[v3692];declSymbolPathLength-=2;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)declSymbolPathLength=declSymbolPath[declSymbolPathLength];v3692=v3692!=declSymbolPathLength}}if(declSymbolPathLength=v3692)externalModuleSymbol=typeSymbolLength-2,externalModuleSymbol=v13652[externalModuleSymbol]}}if(v13652=null==externalModuleSymbol)return}v13652=
this.checker;if(typeSymbolLength=v13652=JAMScript.call(declSymbol.getInterfaceDeclFromSymbol,declSymbol,[v13652]))v13652=v13652.varFlags,typeSymbolLength=TypeScript.VarFlags,typeSymbolLength=typeSymbolLength.Exported,v13652=JAMScript.call(TypeScript.hasFlag,TypeScript,[v13652,typeSymbolLength]),typeSymbolLength=!v13652;v13652=typeSymbolLength;if(!v13652){v13652=declSymbol;if(typeSymbolLength=JAMScript.call(declSymbol.getVarDeclFromSymbol,declSymbol,[])){declSymbolPathLength=typeSymbolLength.varFlags;
v3692=TypeScript.VarFlags;v3692=v3692.Private;if(declSymbolPathLength=JAMScript.call(TypeScript.hasFlag,TypeScript,[declSymbolPathLength,v3692]))return;typeSymbolLength=typeSymbolLength.varFlags;declSymbolPathLength=TypeScript.VarFlags;declSymbolPathLength=declSymbolPathLength.Public;if(typeSymbolLength=JAMScript.call(TypeScript.hasFlag,TypeScript,[typeSymbolLength,declSymbolPathLength]))v13652=declSymbol.container}declSymbol=this.checker;if(declSymbol=JAMScript.call(v13652.isExternallyVisible,v13652,
[declSymbol])){declSymbol=typeSymbol.name;if(v13652=null!=externalModuleSymbol){declSymbolPath=JAMScript.call(externalModuleSymbol.getPrettyNameOfDynamicModule,externalModuleSymbol,[declSymbolPath]);if(declSymbol=null!=declSymbolPath){errorCallback=this.currentScript;typeSymbol=declSymbolPath.symbol;externalModuleSymbol=this.checker;JAMScript.call(errorCallback.AddExternallyVisibleImportedSymbol,errorCallback,[typeSymbol,externalModuleSymbol]);return}declSymbol=externalModuleSymbol.prettyName}typeSymbol=
typeSymbol.name;typeSymbol=typeSymbol!=declSymbol;JAMScript.call(errorCallback,null,[declSymbol,typeSymbol])}}}function v1054(bases,declSymbol,extendsList){function v1053(typeName,isModuleName){return JAMScript.call(_this.baseListPrivacyErrorReporter,_this,[bases,i,declSymbol,extendsList,typeName,isModuleName])}var _this=this;if(bases)for(var v3706=bases.members,v3706=v3706.length,i=0,v3709=i<v3706;v3709;){v3709=bases.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v3709=
v3709[i];var v3709=v3709.type,v3709=!v3709,v19547=!v3709;if(v19547){v3709=bases.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v3709=v3709[i];v3709=v3709.type;v19547=this.checker;v19547=v19547.anyType;v3709=v3709==v19547}if(!v3709){v3709=bases.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v3709=v3709[i];v3709=v3709.type;v3709=v3709.symbol;JAMScript.call(this.checkSymbolPrivacy,this,[v3709,declSymbol,v1053])}i+=
1;v3709=i<v3706}}function v1052(bases,i,declSymbol,extendsList,typeName,isModuleName){var v19549=bases.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v19549=v19549[i];var v19549=v19549.type,baseSymbol=v19549.symbol,v19549=declSymbol.declAST,v19549=v19549.nodeType,v23205=TypeScript.NodeType,v23205=v23205.InterfaceDeclaration,v19549=(v19549=v19549==v23205)?"interface":"class";extendsList=extendsList?"extends":"implements";baseSymbol=baseSymbol.declAST;baseSymbol=
baseSymbol.nodeType;v23205=TypeScript.NodeType;v23205=v23205.InterfaceDeclaration;baseSymbol=(baseSymbol=baseSymbol==v23205)?"interface":"class";isModuleName?(isModuleName="",v23205=JAMScript.call(TypeScript.isQuoted,TypeScript,[typeName]),(v23205=!v23205)&&(isModuleName="'"),baseSymbol=" "+baseSymbol,baseSymbol+=" from private module ",baseSymbol+=isModuleName,typeName=baseSymbol+typeName,baseSymbol=typeName+isModuleName):(isModuleName=" private "+baseSymbol,isModuleName+=" '",typeName=isModuleName+
typeName,baseSymbol=typeName+"'");typeName=this.checker;typeName=typeName.errorReporter;bases=bases.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)i=bases[i];bases="exported "+v19549;bases+=" '";declSymbol=declSymbol.name;declSymbol=bases+declSymbol;declSymbol+="' ";declSymbol+=extendsList;declSymbol+=baseSymbol;JAMScript.call(typeName.simpleError,typeName,[i,declSymbol])}function v1051(funcDecl){function preFindSuperCall(ast,parent,walker){parent=!0;var v3721=
ast.nodeType;switch(v3721){case TypeScript.NodeType.FuncDecl:parent=!1;break;case TypeScript.NodeType.Call:var v3721=ast,v3721=v3721.target,v3721=v3721.nodeType,v19558=TypeScript.NodeType,v19558=v19558.Super;if(v3721=v3721==v19558)parent=!1,foundSuper=!0}walker=walker.options;walker.goChildren=parent;return ast}var foundSuper=!1,v3723=JAMScript.call(TypeScript.getAstWalkerFactory,TypeScript,[]);funcDecl=funcDecl.bod;JAMScript.call(v3723.walk,v3723,[funcDecl,preFindSuperCall]);return foundSuper}function v1050(funcDecl){function v1049(ast,
parent,walker){parent=!0;var v3726=ast.nodeType;switch(v3726){case TypeScript.NodeType.FuncDecl:parent=!1;break;case TypeScript.NodeType.Return:if(v3726=ast,v3726=v3726.returnExpression)parent=allReturnsAreVoid=!1}v3726=walker.options;v3726.goChildren=parent;walker=walker.options;walker.goNextSibling=parent;return ast}var allReturnsAreVoid=!0,v23210=funcDecl.signature,v23210=v23210.returnType,v23210=v23210.type;if(v23210=null==v23210){var v23210=v1049,v3729=JAMScript.call(TypeScript.getAstWalkerFactory,
TypeScript,[]);funcDecl=funcDecl.bod;JAMScript.call(v3729.walk,v3729,[funcDecl,v23210])}return allReturnsAreVoid}function v1048(funcDecl,constructorSym){for(var freeVars=funcDecl.freeVariables,k=0,len=freeVars.length,v3739=k<len;v3739;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v3739=freeVars[k];var v19560=JAMScript.call(v3739.isInstanceProperty,v3739,[]);if(v19560=!v19560)v19560=v3739.container,v19560=v19560==constructorSym;if(v19560){v19560=TypeScript.instanceFilter;
JAMScript.call(v19560.reset,v19560,[]);var v19560=this.scope,v13678=TypeScript.instanceFilter,v13679=v3739.name;if(v19560=JAMScript.call(v19560.search,v19560,[v13678,v13679,!1,!1]))v19560=this.checker,v19560=v19560.errorReporter,v13678=v3739.name,v13678="Constructor-local variable shadows class property '"+v13678,v13678+="'. To access the class property, use 'self.",v13679=v3739.name,v13678+=v13679,v13678+="'",JAMScript.call(v19560.simpleError,v19560,[funcDecl,v13678]);v19560=this.checker;v19560=
v19560.errorReporter;v3739=v3739.name;v3739="Constructor-local variables may not be accessed from instance method bodies. Consider changing local variable '"+v3739;v3739+="' to a class property";JAMScript.call(v19560.simpleError,v19560,[funcDecl,v3739])}k+=1;v3739=k<len}}function v1047(funcDecl){var v13684=JAMScript.call(funcDecl.isMethod,funcDecl,[]);if(v13684=!v13684)for(var v13684=funcDecl.freeVariables,k=0,len=v13684.length,v3741=k<len;v3741;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v3741=
v13684[k];if(v3741=JAMScript.call(v3741.isInstanceProperty,v3741,[]))return!0;k+=1;v3741=k<len}funcDecl=funcDecl.scopes;v13684=funcDecl.members;v13684=v13684.length;k=0;for(len=k<v13684;len;){len=funcDecl.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)len=len[k];if(len=JAMScript.call(this.checkInitSelf,this,[len]))return!0;k+=1;len=k<v13684}return!1}function v1046(container,args,table,isClass){if(args)for(var v3747=args.members,v3747=v3747.length,i=0,v3761=
i<v3747;v3761;){v3761=args.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v3761=v3761[i];var v19565=v3761.sym,v19565=null==v19565,v19567=!v19565;v19567&&(v19565=isClass,v19567=!v19565)&&(v19565=v3761.sym,v19565=JAMScript.call(v19565.kind,v19565,[]),v19567=TypeScript.SymbolKind,v19567=v19567.Field,v19565=v19565!=v19567);if(v19565)if(v19565=null,v19565=v3761.id,v19565=v19565.text,v19567=v19565=JAMScript.call(table.lookup,table,[v19565]),v19567=null==v19567){JAMScript.call(this.resolveBoundDecl,
this,[v3761]);var v19565=TypeScript.ValueLocation,v19567=v19565=JAMScript.new(v19565,[]),v13687=TypeScript.TypeLink,v13687=JAMScript.new(v13687,[]);v19567.typeLink=v13687;var v19567=TypeScript.ParameterSymbol,v13687=v3761.id,v13687=v13687.text,v3753=v3761.minChar,v19569=this.checker,v19569=v19569.locationInfo,v19569=v19569.unitIndex,v19567=JAMScript.new(v19567,[v13687,v3753,v19569,v19565]);v19567.declAST=v3761;v19565.symbol=v19567;v13687=v19565.typeLink;v13687.type=v3761.type;v13687=v19565.symbol;
v13687.container=container;v3761.sym=v19565.symbol;v3761=v3761.id;v3761=v3761.text;JAMScript.call(table.add,table,[v3761,v19567])}else v19567=v3761,v13687=JAMScript.call(v19565.getType,v19565,[]),v19567.type=v13687,v3761.sym=v19565;i+=1;v3761=i<v3747}}function v1045(scope,container,vars,table,isModContainer){for(var v3762=vars.members,len=v3762.length,v3762=!1,i=0,v3787=i<len;v3787;){v3787=vars.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v3787=v3787[i];
var v19570=v3787.sym,v19570=null==v19570,v19573=!v19570;v19573&&(v19570=v3787.sym,v19570=JAMScript.call(v19570.kind,v19570,[]),v19573=TypeScript.SymbolKind,v19573=v19573.Field,v19570=v19570!=v19573);if(v19570)if(v19570=null,v19570=v3787.id,v19570=v19570.text,v19573=v19570=JAMScript.call(table.lookup,table,[v19570]),v19573=null==v19573){var v19570=TypeScript.ValueLocation,v19573=v19570=JAMScript.new(v19570,[]),v13693=TypeScript.TypeLink,v13693=JAMScript.new(v13693,[]);v19573.typeLink=v13693;v19573=
null;v19573=v3787.varFlags;v13693=TypeScript.VarFlags;v13693=v13693.Static;if(v19573=JAMScript.call(TypeScript.hasFlag,TypeScript,[v19573,v13693])){v19573=v3787.varFlags;v13693=TypeScript.VarFlags;v13693=v13693.LocalStatic;v3787.varFlags=v19573|v13693;var v19573=TypeScript.FieldSymbol,v13693=v3787.id,v13693=v13693.text,v3768=v3787.minChar,v19577=this.checker,v19577=v19577.locationInfo,v19577=v19577.unitIndex,v19573=JAMScript.new(v19573,[v13693,v3768,v19577,!0,v19570])}else v19573=TypeScript.VariableSymbol,
v13693=v3787.id,v13693=v13693.text,v3768=v3787.minChar,v19577=this.checker,v19577=v19577.locationInfo,v19577=v19577.unitIndex,v19573=JAMScript.new(v19573,[v13693,v3768,v19577,v19570]);v13693=v3787.varFlags;JAMScript.call(v19573.transferVarFlags,v19573,[v13693]);v19570.symbol=v19573;v19573.declAST=v3787;v13693=v19570.typeLink;v13693.ast=v3787.typeExpr;v13693=this.checker;v3768=v19570.typeLink;JAMScript.call(v13693.resolveTypeLink,v13693,[scope,v3768,!1]);v13693=v3787.type;if(v13693=null==v13693)v13693=
v3787.init,v13693=null==v13693;v13693&&(v3787.type=this.anyType);v13693=v19570.typeLink;v13693.type=v3787.type;v13693=v19570.symbol;v13693.container=container;v3787.sym=v19570.symbol;v19570=v3787.id;v19570=v19570.text;JAMScript.call(table.add,table,[v19570,v19573]);v3787=v3787.id;v3787=v3787.text;(v3787="arguments"==v3787)&&(v3762=!0)}else v19573=v3787,v13693=JAMScript.call(v19570.getType,v19570,[]),v19573.type=v13693,v3787.sym=v19570;i+=1;v3787=i<len}if(container=!isModContainer)if(container=!v3762){container=
TypeScript.ValueLocation;isModContainer=container=JAMScript.new(container,[]);v3762=TypeScript.TypeLink;v3762=JAMScript.new(v3762,[]);isModContainer.typeLink=v3762;isModContainer=TypeScript.VariableSymbol;vars=vars.minChar;v3762=this.checker;v3762=v3762.locationInfo;v3762=v3762.unitIndex;vars=JAMScript.new(isModContainer,["arguments",vars,v3762,container]);isModContainer=this.iargumentsInterfaceType;if(isModContainer=!isModContainer)(scope=JAMScript.call(scope.find,scope,["IArguments",!1,!0]))?(isModContainer=
scope.flags,v3762=TypeScript.SymbolFlags,v3762=v3762.CompilerGenerated,scope.flags=isModContainer|v3762,this.iargumentsInterfaceType=scope=JAMScript.call(scope.getType,scope,[])):this.iargumentsInterfaceType=this.anyType;scope=container.typeLink;scope.type=this.iargumentsInterfaceType;JAMScript.call(table.add,table,["arguments",vars])}}function v1044(container,signature,table){for(var v3797=signature.parameters,v3797=v3797.length,i=0,v3800=i<v3797;v3800;){v3800=signature.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v3800=
v3800[i];v3800.container=container;var v3799=v3800.name;JAMScript.call(table.add,table,[v3799,v3800]);i+=1;v3800=i<v3797}}function v1043(trinex){var v3801=trinex,v13710=trinex.operand1,v13710=JAMScript.call(this.typeCheck,this,[v13710]);v3801.operand1=v13710;v3801=trinex;v13710=trinex.operand2;v13710=JAMScript.call(this.typeCheck,this,[v13710]);v3801.operand2=v13710;v3801=trinex;v13710=trinex.operand3;v13710=JAMScript.call(this.typeCheck,this,[v13710]);v3801.operand3=v13710;var v3801=trinex.operand2,
v3801=v3801.type,v13710=trinex.operand3,v13710=v13710.type,v3811=v3801==v13710;if(v3811)trinex.type=v3801;else if(v3811=this.checker,v3811=JAMScript.call(v3811.sourceIsSubtypeOfTarget,v3811,[v3801,v13710]))trinex.type=v13710;else if(v3811=this.checker,v3811=JAMScript.call(v3811.sourceIsSubtypeOfTarget,v3811,[v13710,v3801]))trinex.type=v3801;else{trinex.type=this.anyType;var v3811=this.checker,v3811=v3811.errorReporter,v3807=JAMScript.call(trinex.printLabel,trinex,[]),v3808=this.scope;JAMScript.call(v3811.incompatibleTypes,
v3811,[trinex,v3801,v13710,v3807,v3808])}return trinex}function v1042(binex,assignment){var v3812=binex,v19584=binex.operand1,v19584=JAMScript.call(this.typeCheck,this,[v19584]),v13717=this.doubleType,v19584=JAMScript.call(this.cast,this,[v19584,v13717]);v3812.operand1=v19584;v3812=binex;v19584=binex.operand2;v19584=JAMScript.call(this.typeCheck,this,[v19584]);v13717=this.doubleType;v19584=JAMScript.call(this.cast,this,[v19584,v13717]);v3812.operand2=v19584;if(v3812=assignment)v3812=binex.operand1,
v3812=JAMScript.call(this.astIsWriteable,this,[v3812]),v3812=!v3812;v3812&&(v3812=this.checker,v3812=v3812.errorReporter,JAMScript.call(v3812.valueCannotBeModified,v3812,[binex]));binex.type=this.doubleType;return binex}function v1041(binex){var v3816=binex,v19587=binex.operand1,v19587=JAMScript.call(this.typeCheck,this,[v19587]),v13723=this.stringType,v19587=JAMScript.call(this.cast,this,[v19587,v13723]);v3816.operand1=v19587;v3816=binex;v19587=binex.operand2;v19587=JAMScript.call(this.typeCheck,
this,[v19587]);v3816.operand2=v19587;v3816=binex.operand1;v3816=v3816.type;v19587=this.checker;v19587=v19587.anyType;v3816=v3816==v19587;if(v19587=!v3816)v3816=binex.operand1,v3816=v3816.type,v19587=this.checker,v19587=v19587.stringType,v3816=v3816==v19587;v3816&&(v3816=binex.operand2,v3816=v3816.type,v19587=this.anyType,v3816=v3816==v19587,v19587=!v3816)&&(v3816=this.checker,v19587=binex.operand2,v19587=v19587.type,v13723=this.objectInterfaceType,v3816=JAMScript.call(v3816.sourceIsSubtypeOfTarget,
v3816,[v19587,v13723]));if(v3816=!v3816)v3816=this.checker,v3816=v3816.errorReporter,JAMScript.call(v3816.simpleError,v3816,[binex,"The in operator requires the left operand to be of type Any or the String primitive type, and the right operand to be of type Any or an object type"]);binex.type=this.booleanType;return binex}function v1040(ast){var binex=ast,v3820=binex,v13727=binex.operand1,v26868=JAMScript.call(this.typeCheck,this,[v13727]);v3820.operand1=v26868;var v3821=binex,v13728=binex.operand2,
v26869=JAMScript.call(this.typeCheck,this,[v13728]);v3821.operand2=v26869;var v23222=this.checker,v19589=v23222.styleSettings,v13729=v19589.literalSubscript,v3824=!v13729;if(v3824){var v19590=binex.operand2,v13730=v19590.nodeType,v19591=TypeScript.NodeType,v13731=v19591.QString,v3823=v13730==v13731;if(v3823){var v13732=this.checker,v3822=v13732.errorReporter;JAMScript.call(v3822.styleError,v3822,[ast,"use literal subscript ('.') notation instead)"])}}var v3825=binex.operand1,objExprType=v3825.type,
v3826=binex.operand2,indexExprType=v3826.type,v3845=objExprType.elementType;if(v3845){var v23223=this.checker,v19592=v23223.anyType,v13733=indexExprType==v19592,v19594=!v13733;if(v19594){var v24975=this.checker,v23224=v24975.numberType,v19593=indexExprType==v23224,v23227=!v19593;if(v23227)var v23225=indexExprType.typeFlags,v24976=TypeScript.TypeFlags,v23226=v24976.IsEnum,v19593=JAMScript.call(TypeScript.hasFlag,TypeScript,[v23225,v23226]);v13733=v19593}var v3831=v13733;if(v3831)binex.type=objExprType.elementType;
else{var v19595=this.checker,v13734=v19595.stringType,v3830=indexExprType==v13734;if(v3830){var v3827=this.checker;binex.type=v3827.anyType}else{var v13735=this.checker,v3828=v13735.errorReporter;JAMScript.call(v3828.simpleError,v3828,[binex,"Illegal property access"]);var v3829=this.checker;binex.type=v3829.anyType}}}else{var v3844=objExprType.index;if(v3844){var v23228=this.checker,v19596=v23228.anyType,v13736=indexExprType==v19596,v19598=!v13736;if(v19598){var v26292=objExprType.index,v25825=v26292.flags,
v26293=TypeScript.SignatureFlags,v25826=v26293.IsStringIndexer,v24977=v25825&v25826,v25829=!v24977;if(v25829)var v26294=objExprType.index,v25827=v26294.flags,v26295=TypeScript.SignatureFlags,v25828=v26295.IsNumberIndexer,v24977=v25827&v25828;var v23229=v24977,v19597=!v23229,v23231=!v19597;if(v23231){var v26296=objExprType.index,v25830=v26296.flags,v26297=TypeScript.SignatureFlags,v25831=v26297.IsStringIndexer,v24978=v25830&v25831;if(v24978)var v26298=this.checker,v25832=v26298.stringType,v24978=indexExprType==
v25832;var v23230=v24978,v24980=!v23230;if(v24980){var v26299=objExprType.index,v25833=v26299.flags,v26300=TypeScript.SignatureFlags,v25834=v26300.IsNumberIndexer,v24979=v25833&v25834;if(v24979){var v26527=this.checker,v26301=v26527.numberType,v25835=indexExprType==v26301,v26304=!v25835;if(v26304)var v26302=indexExprType.typeFlags,v26528=TypeScript.TypeFlags,v26303=v26528.IsEnum,v25835=JAMScript.call(TypeScript.hasFlag,TypeScript,[v26302,v26303]);v24979=v25835}v23230=v24979}v19597=v23230}v13736=v19597}var v3839=
v13736;if(v3839){var v3832=objExprType.index,sig=JAMScript.call(this.resolveOverload,this,[ast,v3832]);if(sig){var v3833=sig.returnType;binex.type=v3833.type}else{var v3834=this.checker;binex.type=v3834.anyType}}else{var v19599=this.checker,v13737=v19599.stringType,v3838=indexExprType==v13737;if(v3838){var v3835=this.checker;binex.type=v3835.anyType}else{var v13738=this.checker,v3836=v13738.errorReporter;JAMScript.call(v3836.simpleError,v3836,[binex,"Illegal property access"]);var v3837=this.checker;
binex.type=v3837.anyType}}}else{var v24981=this.checker,v23232=v24981.anyType,v19600=objExprType==v23232,v23234=!v19600;if(v23234){var v25836=this.checker,v24982=v25836.stringType,v23233=objExprType==v24982,v24984=!v23233;if(v24984){var v26305=this.checker,v25837=v26305.numberType,v24983=objExprType==v25837,v25839=!v24983;if(v25839){var v26529=this.checker,v26306=v26529.booleanType,v25838=objExprType==v26306,v26307=!v25838;v26307&&(v25838=JAMScript.call(objExprType.isReferenceType,objExprType,[]));
v24983=v25838}v23233=v24983}v19600=v23233}var v13739=v19600;if(v13739){var v24985=this.checker,v23235=v24985.anyType,v19601=indexExprType==v23235,v23237=!v19601;if(v23237){var v25840=this.checker,v24986=v25840.stringType,v23236=indexExprType==v24986,v24988=!v23236;if(v24988){var v26308=this.checker,v25841=v26308.numberType,v24987=indexExprType==v25841,v25844=!v24987;if(v25844)var v25842=indexExprType.typeFlags,v26309=TypeScript.TypeFlags,v25843=v26309.IsEnum,v24987=JAMScript.call(TypeScript.hasFlag,
TypeScript,[v25842,v25843]);v23236=v24987}v19601=v23236}v13739=v19601}var v3843=v13739;if(v3843){var v3840=this.checker;binex.type=v3840.anyType}else{var v13740=this.checker,v3841=v13740.errorReporter;JAMScript.call(v3841.simpleError,v3841,[binex,"Illegal property access"]);var v3842=this.checker;binex.type=v3842.anyType}}}return binex}function v1039(ast){var v13741=ast.operand2,v13741=v13741.isParenthesized,applyTargetType=!v13741,v13741=ast,v13742=ast.operand1,v13742=JAMScript.call(this.typeCheck,
this,[v13742]);v13741.operand1=v13742;var v13741=this.checker,v13742=ast.operand1,v13742=v13742.type,v13744=this.checker,v13744=JAMScript.call(v13744.inProvisionalTypecheckMode,v13744,[]),v3851=ast.operand2;JAMScript.call(v13741.typeCheckWithContextualType,v13741,[v13742,v13744,applyTargetType,v3851]);v13741=ast.operand1;v13742=v13741.type;v13741=ast.operand2;v13741=v13741.type;v13744=ast.operand1;v13744=JAMScript.call(this.astIsWriteable,this,[v13744]);if(v13744=!v13744)v13744=this.checker,v13744=
v13744.errorReporter,JAMScript.call(v13744.valueCannotBeModified,v13744,[ast]);var v3851=!1,v13744=null,v13749=ast.operand2;if(v13749=v13749.type)v13744=ast.operand2,v13744=v13744.type,v13744=v13744.containedScope,v3851=!0;var v13749=ast,v13751=ast.operand2;applyTargetType&&(applyTargetType=this.checker,applyTargetType=JAMScript.call(applyTargetType.inProvisionalTypecheckMode,applyTargetType,[]),applyTargetType=!applyTargetType);applyTargetType=JAMScript.call(this.castWithCoercion,this,[v13751,v13742,
applyTargetType,!1]);v13749.operand2=applyTargetType;if(applyTargetType=v3851)applyTargetType=ast.operand2,applyTargetType=applyTargetType.type,applyTargetType=applyTargetType.containedScope,applyTargetType=null==applyTargetType;applyTargetType&&(applyTargetType=ast.operand2,applyTargetType=applyTargetType.type,applyTargetType.containedScope=v13744);ast.type=v13741;return ast}function v1038(ast){var v3862=ast,v13755=ast.operand1,v13755=JAMScript.call(this.typeCheck,this,[v13755]);v3862.operand1=v13755;
v3862=ast;v13755=ast.operand2;v13755=JAMScript.call(this.typeCheck,this,[v13755]);v3862.operand2=v13755;var v3862=ast.operand1,v3862=v3862.type,v13755=ast.operand2,v13755=v13755.type,v23240=this.checker,v23240=JAMScript.call(v23240.sourceIsAssignableToTarget,v23240,[v3862,v13755]);if(v23240=!v23240)v23240=this.checker,v23240=JAMScript.call(v23240.sourceIsAssignableToTarget,v23240,[v13755,v3862]),v23240=!v23240;if(v23240){var v23240=this.checker,v23240=v23240.errorReporter,v3867=JAMScript.call(ast.printLabel,
ast,[]),v3868=this.scope;JAMScript.call(v23240.incompatibleTypes,v23240,[ast,v3862,v13755,v3867,v3868])}ast.type=this.booleanType;return ast}function v1037(ast){var binex=ast,v3870=binex,v13759=binex.operand1,v26874=JAMScript.call(this.typeCheck,this,[v13759]);v3870.operand1=v26874;var v3871=binex.operand1,leftType=v3871.type,leftScope=null;if(leftType){var v13760=this.anyType,v3889=leftType==v13760;if(v3889)return binex.type=this.anyType,binex;var v13761=this.stringType,v3888=leftType==v13761;if(v3888){var v3873=
this.stringInterfaceType;if(v3873)var v3872=this.stringInterfaceType,leftScope=v3872.memberScope;else return binex.type=this.anyType,binex}else{var v13762=this.doubleType,v3887=leftType==v13762;if(v3887){var v3875=this.numberInterfaceType;if(v3875)var v3874=this.numberInterfaceType,leftScope=v3874.memberScope;else return binex.type=this.anyType,binex}else{var v13763=this.booleanType,v3886=leftType==v13763;if(v3886){var v3877=this.booleanInterfaceType;if(v3877)var v3876=this.booleanInterfaceType,leftScope=
v3876.memberScope;else return binex.type=this.anyType,binex}else{var v19609=leftType.call,v23242=!v19609;v23242&&(v19609=leftType.construct);var v13764=v19609;if(v13764)var v19610=leftType.members,v13764=null==v19610;var v3885=v13764;if(v3885){var v3879=this.functionInterfaceType;if(v3879)var v3878=this.functionInterfaceType,leftScope=v3878.memberScope;else return binex.type=this.anyType,binex}else{var v3884=leftType.elementType;if(v3884){var v3883=this.arrayInterfaceType;if(v3883)var v3880=leftType.elementType,
v3881=this.arrayInterfaceType,v3882=this.checker,arrInstType=JAMScript.call(v3880.getArrayBase,v3880,[v3881,v3882]),leftScope=arrInstType.memberScope;else return binex.type=this.anyType,binex}else leftScope=leftType.memberScope}}}}}var v3918=null==leftScope;if(v3918){var v13765=this.checker,v3890=v13765.errorReporter;JAMScript.call(v3890.expectedClassOrInterface,v3890,[binex]);binex.type=this.anyType}else{var propertyName=binex.operand2,v13766=this.thisClassNode;if(v13766)var v23243=binex.operand1,
v19611=v23243.type,v24991=this.thisClassNode,v23244=v24991.type,v19612=v23244.instanceType,v13766=v19611==v19612;var v3891=v13766,v13767=!v3891;v13767&&(v3891=this.inTypeRefTypeCheck);var lhsIsEnclosingType=v3891,v3892=propertyName.text,v3893=!lhsIsEnclosingType,v3894=this.inTypeRefTypeCheck,symbol=JAMScript.call(leftScope.find,leftScope,[v3892,v3893,v3894]),v3905=!symbol;if(v3905){var v13768=this.objectInterfaceType;v13768&&(v13768=leftType);var v3904=v13768;if(v3904){var v3898=JAMScript.call(leftType.isReferenceType,
leftType,[]);if(v3898)var v13769=this.objectInterfaceType,v3895=v13769.memberScope,v3896=propertyName.text,v3897=this.inTypeRefTypeCheck,symbol=JAMScript.call(v3895.find,v3895,[v3896,!1,v3897]);var v3903=!symbol;if(v3903){var v13770=this.functionInterfaceType;if(v13770){var v19613=leftType.call,v23245=!v19613;v23245&&(v19613=leftType.construct);v13770=v19613}var v3902=v13770;if(v3902)var v13771=this.functionInterfaceType,v3899=v13771.memberScope,v3900=propertyName.text,v3901=this.inTypeRefTypeCheck,
symbol=JAMScript.call(v3899.find,v3899,[v3900,!1,v3901])}}}var v13772=!symbol,v19615=!v13772;if(v19615)var v23246=this.checker,v19614=JAMScript.call(symbol.visible,symbol,[leftScope,v23246]),v13772=!v19614;var v3917=v13772;if(v3917){binex.type=this.anyType;var v3911=null==symbol;if(v3911){var v13773=this.checker,v3906=v13773.errorReporter,v24992=propertyName.actualText,v23247="The property '"+v24992,v19616=v23247+"' does not exist on value of type '",v23248=this.scope,v19617=JAMScript.call(leftType.getScopedTypeName,
leftType,[v23248]),v13774=v19616+v19617,v3907=v13774+"'";JAMScript.call(v3906.simpleError,v3906,[propertyName,v3907])}else{var v13775=this.inTypeRefTypeCheck,v3910=!v13775;if(v3910){var v13776=this.checker,v3908=v13776.errorReporter,v24993=propertyName.actualText,v23249="The property '"+v24993,v19618=v23249+" on type '",v23250=this.scope,v19619=JAMScript.call(leftType.getScopedTypeName,leftType,[v23250]),v13777=v19618+v19619,v3909=v13777+"' is not visible";JAMScript.call(v3908.simpleError,v3908,[binex,
v3909])}}}else{var v3915=JAMScript.call(symbol.isVariable,symbol,[]);if(v3915){var v3914=JAMScript.call(symbol.isInferenceSymbol,symbol,[]);if(v3914){var infSym=symbol,v13778=infSym.declAST;if(v13778)var v23251=this.checker,v23252=infSym.typeCheckStatus,v19620=JAMScript.call(v23251.typeStatusIsFinished,v23251,[v23252]),v13778=!v19620;var v3913=v13778;if(v3913){var v3912=infSym.declAST;JAMScript.call(this.inScopeTypeCheckDecl,this,[v3912])}}}propertyName.sym=symbol;var v3916=binex,v26875=JAMScript.call(symbol.getType,
symbol,[]);v3916.type=v26875}}var v13779=binex.type,v3919=null==v13779;v3919&&(binex.type=this.anyType);return binex}function v1036(ast,assignment){var binex=ast,v3920=binex,v13780=binex.operand1,v26876=JAMScript.call(this.typeCheck,this,[v13780]);v3920.operand1=v26876;var v3921=binex,v13781=binex.operand2,v26877=JAMScript.call(this.typeCheck,this,[v13781]);v3921.operand2=v26877;var v3922=binex.operand1,leftType=v3922.type,v3923=binex.operand2,rightType=v3923.type,v13782=assignment;if(v13782)var v23253=
binex.operand1,v19621=JAMScript.call(this.astIsWriteable,this,[v23253]),v13782=!v19621;var v3925=v13782;if(v3925){var v13783=this.checker,v3924=v13783.errorReporter;JAMScript.call(v3924.valueCannotBeModified,v3924,[binex])}var v23254=this.checker,v19622=v23254.styleSettings,v13784=v19622.bitwise;if(v13784){var v23255=binex.nodeType,v24994=TypeScript.NodeType,v23256=v24994.And,v19623=v23255==v23256,v23258=!v19623;if(v23258){var v24995=binex.nodeType,v25845=TypeScript.NodeType,v24996=v25845.Or,v23257=
v24995==v24996,v24998=!v23257;if(v24998){var v25846=binex.nodeType,v26310=TypeScript.NodeType,v25847=v26310.AsgAnd,v24997=v25846==v25847,v25850=!v24997;if(v25850)var v25848=binex.nodeType,v26311=TypeScript.NodeType,v25849=v26311.AsgOr,v24997=v25848==v25849;v23257=v24997}v19623=v23257}v13784=v19623}var v3928=v13784;if(v3928){var v13785=this.checker,v3926=v13785.errorReporter,v19624=TypeScript.nodeTypeTable,v19625=binex.nodeType;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v13786=
v19624[v19625];var v3927="use of "+v13786;JAMScript.call(v3926.styleError,v3926,[ast,v3927])}var v13787=null==leftType,v19626=!v13787;v19626&&(v13787=null==rightType);var v3930=v13787;if(v3930){var v13788=this.checker,v3929=v13788.errorReporter;JAMScript.call(v3929.simpleError,v3929,[binex,"Could not typecheck arithmetic operation.  Possible recursive typecheck error?"]);binex.type=this.anyType;return binex}var nodeType=binex.nodeType,v13789=this.checker,v3931=JAMScript.call(v13789.isNullOrUndefinedType,
v13789,[leftType]);v3931&&(leftType=rightType);var v13790=this.checker,v3932=JAMScript.call(v13790.isNullOrUndefinedType,v13790,[rightType]);v3932&&(rightType=leftType);var v3933=this.checker,leftType=JAMScript.call(v3933.widenType,v3933,[leftType]),v3934=this.checker,rightType=JAMScript.call(v3934.widenType,v3934,[rightType]),v23259=TypeScript.NodeType,v19627=v23259.Add,v13791=nodeType==v19627,v19629=!v13791;if(v19629)var v23260=TypeScript.NodeType,v19628=v23260.AsgAdd,v13791=nodeType==v19628;var v3955=
v13791;if(v3955){var v23261=this.checker,v19630=v23261.stringType,v13792=leftType==v19630,v19632=!v13792;if(v19632)var v23262=this.checker,v19631=v23262.stringType,v13792=rightType==v19631;var v3945=v13792;if(v3945){var v3935=this.checker;binex.type=v3935.stringType}else{var v23263=this.checker,v19633=v23263.numberType,v13793=leftType==v19633;if(v13793)var v23264=this.checker,v19634=v23264.numberType,v13793=rightType==v19634;var v3944=v13793;if(v3944){var v3936=this.checker;binex.type=v3936.numberType}else{var v19635=
this.checker,v23265=this.checker,v19636=v23265.numberType,v13794=JAMScript.call(v19635.sourceIsSubtypeOfTarget,v19635,[leftType,v19636]);if(v13794)var v19637=this.checker,v23266=this.checker,v19638=v23266.numberType,v13794=JAMScript.call(v19637.sourceIsSubtypeOfTarget,v19637,[rightType,v19638]);var v3943=v13794;if(v3943){var v3937=this.checker;binex.type=v3937.numberType}else{var v23267=this.checker,v19639=v23267.anyType,v13795=leftType==v19639,v19641=!v13795;if(v19641)var v23268=this.checker,v19640=
v23268.anyType,v13795=rightType==v19640;var v3942=v13795;if(v3942){var v3938=this.checker;binex.type=v3938.anyType}else{binex.type=this.anyType;var v13796=this.checker,v3939=v13796.errorReporter,v3940=JAMScript.call(binex.printLabel,binex,[]),v3941=this.scope;JAMScript.call(v3939.incompatibleTypes,v3939,[binex,leftType,rightType,v3940,v3941])}}}}}else{var v23269=this.checker,v19642=v23269.numberType,v13797=leftType==v19642;if(v13797)var v23270=this.checker,v19643=v23270.numberType,v13797=rightType==
v19643;var v3954=v13797;if(v3954){var v3946=this.checker;binex.type=v3946.numberType}else{var v19644=this.checker,v23271=this.checker,v19645=v23271.numberType,v13798=JAMScript.call(v19644.sourceIsSubtypeOfTarget,v19644,[leftType,v19645]);if(v13798)var v19646=this.checker,v23272=this.checker,v19647=v23272.numberType,v13798=JAMScript.call(v19646.sourceIsSubtypeOfTarget,v19646,[rightType,v19647]);var v3953=v13798;if(v3953){var v3947=this.checker;binex.type=v3947.numberType}else{var v23273=this.checker,
v19648=v23273.anyType,v13799=leftType==v19648,v19650=!v13799;if(v19650)var v23274=this.checker,v19649=v23274.anyType,v13799=rightType==v19649;var v3952=v13799;if(v3952){var v3948=this.checker;binex.type=v3948.numberType}else{binex.type=this.anyType;var v13800=this.checker,v3949=v13800.errorReporter,v3950=JAMScript.call(binex.printLabel,binex,[]),v3951=this.scope;JAMScript.call(v3949.incompatibleTypes,v3949,[binex,leftType,rightType,v3950,v3951])}}}}return binex}function v1035(ast,assignment){var binex=
ast,resultType=null,v3956=binex,v13801=binex.operand1,v13801=JAMScript.call(this.typeCheck,this,[v13801]);v3956.operand1=v13801;v3956=binex;v13801=binex.operand2;v13801=JAMScript.call(this.typeCheck,this,[v13801]);v3956.operand2=v13801;var v3956=binex.operand1,v3956=v3956.type,v13801=binex.operand2,v13801=v13801.type,v13803=assignment;v13803&&(v13803=JAMScript.call(this.astIsWriteable,this,[binex]),v13803=!v13803);v13803&&(v13803=this.checker,v13803=v13803.errorReporter,JAMScript.call(v13803.valueCannotBeModified,
v13803,[binex]));v13803=this.checker;v13803=v13803.styleSettings;if(v13803=v13803.bitwise){var v13803=this.checker,v13803=v13803.errorReporter,v19653=TypeScript.nodeTypeTable,v19654=binex.nodeType;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v19653=v19653[v19654];v19653="use of "+v19653;JAMScript.call(v13803.styleError,v13803,[ast,v19653])}v13803=this.checker;v19653=this.doubleType;if(v13803=JAMScript.call(v13803.sourceIsSubtypeOfTarget,v13803,[v3956,v19653]))v13803=
this.checker,v19653=this.doubleType,v13803=JAMScript.call(v13803.sourceIsSubtypeOfTarget,v13803,[v13801,v19653]);if(v13803)resultType=this.doubleType;else{v13803=this.booleanType;if(v13803=v3956==v13803)v13803=this.booleanType,v13803=v13801==v13803;if(v13803)resultType=this.booleanType;else if(v13803=this.anyType,v13803=v3956==v13803){v13803=this.anyType;v13803=v13801==v13803;if(v19653=!v13803)if(v13803=this.doubleType,v13803=v13801==v13803,v19653=!v13803)v13803=this.booleanType,v13803=v13801==v13803;
v13803&&(resultType=this.anyType)}else if(v13803=this.anyType,v13803=v13801==v13803){v13803=this.anyType;v13803=v3956==v13803;if(v19653=!v13803)if(v13803=this.doubleType,v13803=v3956==v13803,v19653=!v13803)v13803=this.booleanType,v13803=v3956==v13803;v13803&&(resultType=this.anyType)}}if(v13803=null==resultType)resultType=this.anyType,v13803=this.checker,v13803=v13803.errorReporter,v19653=JAMScript.call(binex.printLabel,binex,[]),v19654=this.scope,JAMScript.call(v13803.incompatibleTypes,v13803,[binex,
v3956,v13801,v19653,v19654]);binex.type=resultType;return binex}function v1034(ast){var unex=ast,v13815=JAMScript.call(this.astIsWriteable,this,[unex]);if(v13815=!v13815)ast=this.checker,ast=ast.errorReporter,JAMScript.call(ast.valueCannotBeModified,ast,[unex]),unex.type=this.doubleType;else{var unex=JAMScript.call(this.typeCheckUnaryNumberOperator,this,[ast]),v13815=unex.operand,v13815=v13815.type,v23282=this.checker,v23282=v23282.numberType;if(v13815=v13815!=v23282)if(v13815=unex.operand,v13815=
v13815.type,v23282=this.checker,v23282=v23282.anyType,v13815=v13815!=v23282)v13815=unex.operand,v13815=v13815.type,v13815=v13815.typeFlags,v23282=TypeScript.TypeFlags,v23282=v23282.IsEnum,v13815&=v23282,v13815=!v13815;v13815&&(v13815=this.checker,v13815=v13815.errorReporter,JAMScript.call(v13815.simpleError,v13815,[ast,"'++' and '--' may only be applied to operands of type 'number' or 'any'"]))}return unex}function v1033(ast){ast=ast.flags;var v13819=TypeScript.ASTFlags,v13819=v13819.Writeable;return JAMScript.call(TypeScript.hasFlag,
TypeScript,[ast,v13819])}function v1032(ast){var v3981=ast,v13820=ast.operand,v13820=JAMScript.call(this.typeCheck,this,[v13820]);v3981.operand=v13820;ast.type=this.booleanType;return ast}function v1031(ast){var unex=ast,v3982=unex,v13821=unex.operand,v13821=JAMScript.call(this.typeCheck,this,[v13821]);v3982.operand=v13821;unex.type=this.doubleType;return ast}function v1030(ast){var v3983=ast,v13822=ast.operand,v13822=JAMScript.call(this.typeCheck,this,[v13822]);v3983.operand=v13822;ast.type=this.doubleType;
return ast}function v1029(script){var v3984=this.checker;v3984.locationInfo=script.locationInfo;v3984=this.checker;this.scope=v3984.globalScope;v3984=script.topLevelMod;if(v3984=!v3984){var v3984=this.scope,v13824=this.checker,v13824=v13824.gloMod,v3988=script.vars,v13825=this.checker,v13825=v13825.globals;JAMScript.call(this.addLocalsFromScope,this,[v3984,v13824,v3988,v13825,!0])}v3984=this.currentScript=script;v13824=script.bod;v13824=JAMScript.call(this.typeCheck,this,[v13824]);v3984.bod=v13824;
this.currentScript=null;return script}function v1028(ast){function v1027(id){var v3992=_this.scope;return JAMScript.call(v3992.find,v3992,[id,!1,typespace])}var _this=this,identifier=ast,v13827=this.checker;if(v13827=v13827.inWith)identifier.type=this.anyType;else{var typespace=this.inTypeRefTypeCheck,idText=identifier.text,v13827=identifier.text,isDynamicModuleName=JAMScript.call(TypeScript.isQuoted,TypeScript,[v13827]),v13827=this.scope,v13827=JAMScript.call(v13827.find,v13827,[idText,!1,typespace]),
v13828=null==v13827;v13828&&(v13828=isDynamicModuleName);if(isDynamicModuleName=v13828)v13827=this.checker,isDynamicModuleName=this.currentScript,isDynamicModuleName=isDynamicModuleName.locationInfo,isDynamicModuleName=isDynamicModuleName.filename,v13827=JAMScript.call(v13827.findSymbolForDynamicModule,v13827,[idText,isDynamicModuleName,v1027]);if(idText=!v13827){v13827=JAMScript.call(identifier.isMissing,identifier,[]);if(v13827=!v13827)v13827=this.checker,v13827=v13827.errorReporter,idText=identifier.text,
JAMScript.call(v13827.unresolvedSymbol,v13827,[identifier,idText]);identifier.type=this.anyType}else{(idText=TypeScript.optimizeModuleCodeGen)&&(idText=v13827)&&(idText=JAMScript.call(v13827.isType,v13827,[]));if(idText){if(isDynamicModuleName=idText=JAMScript.call(v13827.getType,v13827,[]))if(isDynamicModuleName=v13827.aliasLink)isDynamicModuleName=v13827.onlyReferencedAsTypeRef;if(isDynamicModuleName){idText=idText.symbol;if(isDynamicModuleName=idText=idText.declAST)idText=idText.modFlags,isDynamicModuleName=
TypeScript.ModuleFlags,isDynamicModuleName=isDynamicModuleName.IsDynamic,isDynamicModuleName=JAMScript.call(TypeScript.hasFlag,TypeScript,[idText,isDynamicModuleName]);if(idText=isDynamicModuleName)v13827.onlyReferencedAsTypeRef=this.inTypeRefTypeCheck}}if(idText=v13827.declAST)if(idText=v13827.declAST,idText=idText.nodeType,isDynamicModuleName=TypeScript.NodeType,isDynamicModuleName=isDynamicModuleName.FuncDecl,idText=idText==isDynamicModuleName)if(idText=v13827.declAST,idText=idText.returnTypeAnnotation,
idText=!idText)idText=v13827.declAST,idText=idText.signature,idText=idText.typeCheckStatus,isDynamicModuleName=TypeScript.TypeCheckStatus,isDynamicModuleName=isDynamicModuleName.Started,idText=idText==isDynamicModuleName;idText&&(idText=v13827.declAST,idText=idText.type,idText=idText.symbol,isDynamicModuleName=idText.flags,v13828=TypeScript.SymbolFlags,v13828=v13828.RecursivelyReferenced,idText.flags=isDynamicModuleName|v13828,idText=v13827.declAST,idText=idText.signature,idText=idText.returnType,
idText.type=this.anyType);JAMScript.call(this.setTypeFromSymbol,this,[ast,v13827]);identifier.sym=v13827;if(identifier=this.thisFnc){identifier=this.thisFnc;if(identifier=identifier.type)identifier=v13827.container,idText=this.thisFnc,idText=idText.type,idText=idText.symbol,identifier=identifier!=idText;identifier&&(identifier=this.thisFnc,identifier=identifier.freeVariables,idText=this.thisFnc,idText=idText.freeVariables,idText=idText.length,JAMScript.set(identifier,idText,v13827))}}}return ast}
function v1026(ast,symbol){var v4031=JAMScript.call(symbol.isVariable,symbol,[]);if(v4031){if(v4031=JAMScript.call(symbol.isInferenceSymbol,symbol,[])){var v4031=symbol,v13841=v4031.declAST;if(v13841)var v13841=this.checker,v23293=v4031.typeCheckStatus,v13841=JAMScript.call(v13841.typeStatusIsFinished,v13841,[v23293]),v13841=!v13841;v13841&&(v13841=v4031.declAST,JAMScript.call(this.inScopeTypeCheckDecl,this,[v13841]));v13841=this.checker;v13841=v13841.styleSettings;v13841=v13841.innerScopeDeclEscape;
if(v13841=!v13841){if(v13841=v4031.declAST)v13841=v4031.declAST,v13841=v13841.nodeType,v23293=TypeScript.NodeType,v23293=v23293.VarDecl,v13841=v13841==v23293;v13841&&(v13841=this.nestingLevel,v4031=v4031.declAST,v4031=v4031.nestingLevel,v4031=v13841<v4031)&&(v4031=this.checker,v4031=v4031.errorReporter,JAMScript.call(v4031.styleError,v4031,[ast,"Illegal reference to a variable defined in more nested scope"]))}}v4031=ast;v13841=JAMScript.call(symbol.getType,symbol,[]);v4031.type=v13841;v4031=JAMScript.call(symbol.writeable,
symbol,[]);if(v4031=!v4031)v4031=ast.flags,v13841=TypeScript.ASTFlags,v13841=v13841.Writeable,v13841=~v13841,ast.flags=v4031&v13841}else(v4031=JAMScript.call(symbol.isType,symbol,[]))?(v4031=ast,v13841=JAMScript.call(symbol.getType,symbol,[]),v4031.type=v13841,v4031=ast.flags,v13841=TypeScript.ASTFlags,v13841=v13841.Writeable,v13841=~v13841,ast.flags=v4031&v13841):(ast.type=this.anyType,v4031=this.checker,v4031=v4031.errorReporter,v13841=symbol.name,JAMScript.call(v4031.symbolDoesNotReferToAValue,
v4031,[ast,v13841]))}function v1025(ast){ast.type=this.anyType;var illegalThisRef=!1,v13851=this.thisFnc,v4039=null==v13851;if(v4039){var v4035=this.thisType;if(v4035){var v13852=this.thisClassNode;if(v13852)var v23297=this.thisClassNode,v19691=v23297.nodeType,v23298=TypeScript.NodeType,v19692=v23298.ClassDeclaration,v13852=v19691==v19692;var v4032=v13852;v4032?illegalThisRef=!0:ast.type=this.thisType}else{var v13853=this.checker,v4034=v13853.currentModDecl;if(v4034){var v13854=this.checker,v4033=
v13854.errorReporter;JAMScript.call(v4033.simpleError,v4033,[ast,"'this' may not be referenced within module bodies"])}}}else{var v13855=this.thisClassNode;if(v13855){var v25009=this.thisFnc,v23299=v25009.fncFlags,v25010=TypeScript.FncFlags,v23300=v25010.IsPropertyBound,v19693=JAMScript.call(TypeScript.hasFlag,TypeScript,[v23299,v23300]),v23302=!v19693;if(v23302){var v23301=this.inSuperCall;if(v23301)var v25856=this.thisClassNode,v25011=v25856.varFlags,v25857=TypeScript.VarFlags,v25012=v25857.ClassSuperMustBeFirstCallInConstructor,
v23301=JAMScript.call(TypeScript.hasFlag,TypeScript,[v25011,v25012]);v19693=v23301}v13855=v19693}var v4036=v13855;v4036&&(illegalThisRef=!0);var v19694=this.thisFnc,v13856=JAMScript.call(v19694.isMethod,v19694,[]),v19696=!v13856;if(v19696){var v23303=this.thisFnc,v19695=v23303.isConstructor,v23305=!v19695;if(v23305)var v23304=this.thisFnc,v19695=v23304.isTargetTypedAsMethod;v13856=v19695}var v4038=v13856;if(v4038){var v13857=this.thisType;if(v13857)var v25013=this.thisFnc,v23306=v25013.fncFlags,v25014=
TypeScript.FncFlags,v23307=v25014.Static,v19697=v23306&v23307,v13857=!v19697;var v4037=v13857;v4037&&(ast.type=this.thisType)}}var v19698=this.enclosingFncIsMethod,v13858=!v19698;if(v13858){var v19699=this.thisFnc;if(v19699)var v25015=this.thisFnc,v23308=v25015.fncFlags,v25016=TypeScript.FncFlags,v23309=v25016.IsFatArrowFunction,v19699=JAMScript.call(TypeScript.hasFlag,TypeScript,[v23308,v23309]);v13858=v19699}var v4055=v13858;if(v4055){var v13859=this.thisFnc,v4054=v13859.boundToProperty;if(v4054){var v19700=
this.thisFnc,v13860=v19700.boundToProperty,v4040=v13860.sym,container=v4040.container,v19701=container.declAST,v13861=v19701.nodeType,v19702=TypeScript.NodeType,v13862=v19702.FuncDecl,v4042=v13861==v13862;if(v4042){var v4041=container.declAST;JAMScript.call(v4041.setHasSelfReference,v4041,[])}}else{for(var v4043=this.thisFnc,encFnc=v4043.enclosingFnc,firstEncFnc=encFnc;encFnc;){var v13863=this.thisClassNode;if(v13863)var v19703=encFnc.fncFlags,v23310=TypeScript.FncFlags,v19704=v23310.IsPropertyBound,
v13863=JAMScript.call(TypeScript.hasFlag,TypeScript,[v19703,v19704]);var v4044=v13863;v4044&&(illegalThisRef=!0);var v23311=encFnc.fncFlags,v25017=TypeScript.FncFlags,v23312=v25017.IsFatArrowFunction,v19705=JAMScript.call(TypeScript.hasFlag,TypeScript,[v23311,v23312]),v13864=!v19705,v19706=!v13864;v19706&&(v13864=JAMScript.call(encFnc.hasSelfReference,encFnc,[]));var v4045=v13864;if(v4045){JAMScript.call(encFnc.setHasSelfReference,encFnc,[]);break}encFnc=encFnc.enclosingFnc}var v13865=!encFnc;v13865&&
(v13865=firstEncFnc);var v4052=v13865;if(v4052)encFnc=firstEncFnc,JAMScript.call(encFnc.setHasSelfReference,encFnc,[]);else{var v4051=!encFnc;if(v4051){var v4050=this.thisClassNode;if(v4050){var v4046=this.thisClassNode,v19707=v4046.varFlags,v23313=TypeScript.VarFlags,v19708=v23313.MustCaptureThis;v4046.varFlags=v19707|v19708}else{var v13866=this.checker,v4049=v13866.currentModDecl;if(v4049){var v13867=this.checker,v4047=v13867.currentModDecl,v19709=v4047.modFlags,v23314=TypeScript.ModuleFlags,v19710=
v23314.MustCaptureThis;v4047.modFlags=v19709|v19710}else{var v4048=this.checker;v4048.mustCaptureGlobalThis=!0}}}}var v13868=encFnc;if(v13868){var v23315=JAMScript.call(encFnc.isMethod,encFnc,[]),v25018=!v23315;v25018&&(v23315=encFnc.isConstructor);var v19711=v23315;if(v19711){var v23316=this.thisType;if(v23316)var v25858=encFnc.fncFlags,v26314=TypeScript.FncFlags,v25859=v26314.Static,v25019=JAMScript.call(TypeScript.hasFlag,TypeScript,[v25858,v25859]),v23316=!v25019;v19711=v23316}v13868=v19711}var v4053=
v13868;v4053&&(ast.type=this.thisType)}}if(illegalThisRef){var v13869=this.checker,v4056=v13869.errorReporter;JAMScript.call(v4056.simpleError,v4056,[ast,"Keyword 'this' cannot be referenced in initializers in a class body, or in super constructor calls"])}return ast}function v1024(ast){var v13870=this.thisType;if(v13870){if(v13870=this.enclosingFncIsMethod)v13870=this.thisFnc,v13870=JAMScript.call(v13870.isStatic,v13870,[]),v13870=!v13870;v13870&&(v13870=this.thisType,v13870=JAMScript.call(v13870.baseClass,
v13870,[]))}if(v13870){var v13870=ast,v13871=this.thisType,v13871=JAMScript.call(v13871.baseClass,v13871,[]);v13870.type=v13871}else{v13870=this.enclosingFncIsMethod;if(v13870=!v13870)if(v13870=this.thisType)if(v13870=this.thisType,v13870=JAMScript.call(v13870.baseClass,v13870,[]))if(v13870=this.thisFnc)v13870=this.thisFnc,v13870=v13870.fncFlags,v13871=TypeScript.FncFlags,v13871=v13871.IsFatArrowFunction,v13870=JAMScript.call(TypeScript.hasFlag,TypeScript,[v13870,v13871]);if(v13870){for(var v13870=
this.thisFnc,v13870=v13870.enclosingFnc,v13871=v13870.fncFlags,v19715=TypeScript.FncFlags,v19715=v19715.IsFatArrowFunction,v13871=JAMScript.call(TypeScript.hasFlag,TypeScript,[v13871,v19715]);v13871;)v13870=v13870.enclosingFnc,v13871=v13870.fncFlags,v19715=TypeScript.FncFlags,v19715=v19715.IsFatArrowFunction,v13871=JAMScript.call(TypeScript.hasFlag,TypeScript,[v13871,v19715]);if(v13871=v13870){v13871=JAMScript.call(v13870.isMethod,v13870,[]);if(v19715=!v13871)v13871=v13870.isConstructor;v13871&&(v13871=
JAMScript.call(v13870.isStatic,v13870,[]),v13871=!v13871)}if(v13871)return v13871=ast,v19715=this.thisType,v19715=JAMScript.call(v19715.baseClass,v19715,[]),v13871.type=v19715,JAMScript.call(v13870.setHasSuperReferenceInFatArrowFunction,v13870,[]),ast}ast.type=this.anyType;v13870=this.checker;v13870=v13870.errorReporter;JAMScript.call(v13870.invalidSuperReference,v13870,[ast])}return ast}function v1023(varDecl,typeName,isModuleName){var typestring="";isModuleName?(typestring="",isModuleName=JAMScript.call(TypeScript.isQuoted,
TypeScript,[typeName]),(isModuleName=!isModuleName)&&(typestring="'"),isModuleName=" is using inaccessible module "+typestring,typeName=isModuleName+typeName,typestring=typeName+typestring):(typestring=" has or is using private type '"+typeName,typestring+="'");typeName=varDecl.varFlags;isModuleName=TypeScript.VarFlags;isModuleName=isModuleName.Public;(typeName=JAMScript.call(TypeScript.hasFlag,TypeScript,[typeName,isModuleName]))?(typeName=varDecl.sym,typeName=typeName.container,typeName=typeName.declAST,
typeName=typeName.nodeType,isModuleName=TypeScript.NodeType,isModuleName=isModuleName.InterfaceDeclaration,(typeName=typeName==isModuleName)?(typeName=this.checker,typeName=typeName.errorReporter,isModuleName=varDecl.sym,isModuleName=isModuleName.name,isModuleName="property '"+isModuleName,isModuleName+="' of exported interface"):(typeName=this.checker,typeName=typeName.errorReporter,isModuleName=varDecl.sym,isModuleName=isModuleName.name,isModuleName="public member '"+isModuleName,isModuleName+=
"' of exported class")):(typeName=this.checker,typeName=typeName.errorReporter,isModuleName=varDecl.sym,isModuleName=isModuleName.name,isModuleName="exported variable '"+isModuleName,isModuleName+="'");typestring=isModuleName+typestring;JAMScript.call(typeName.simpleError,typeName,[varDecl,typestring])}function v1022(varDecl){function v1021(typeName,isModuleName){return JAMScript.call(_this.varPrivacyErrorReporter,_this,[varDecl,typeName,isModuleName])}function v1020(ast,parent,walker){if(parent=
ast){parent=ast.nodeType;var v23326=TypeScript.NodeType,v23326=v23326.FuncDecl;parent=parent==v23326}if(parent){parent=ast.fncFlags;v23326=TypeScript.FncFlags;v23326=v23326.IsFatArrowFunction;if(parent=JAMScript.call(TypeScript.hasFlag,TypeScript,[parent,v23326]))parent=ast.fncFlags,v23326=TypeScript.FncFlags,v23326=v23326.IsPropertyBound,ast.fncFlags=parent|v23326;walker=walker.options;walker.goChildren=!1}return ast}var _this=this,infSym=varDecl.sym,v4128=null==infSym;if(v4128){var v4083=varDecl.init;
if(v4083){var v4079=varDecl,v13897=varDecl.init,v26888=JAMScript.call(this.typeCheck,this,[v13897]);v4079.init=v26888;var v4080=varDecl,v13898=this.checker,v19728=varDecl.init,v13899=v19728.type,v26889=JAMScript.call(v13898.widenType,v13898,[v13899]);v4080.type=v26889}else{var v19729=this.checker,v13900=v19729.styleSettings,v4082=v13900.implicitAny;if(v4082){var v13901=this.checker,v4081=v13901.errorReporter;JAMScript.call(v4081.styleError,v4081,[varDecl,"type implicitly set to 'any'"])}varDecl.type=
this.anyType}}else{var v13902=infSym.typeCheckStatus,v19730=TypeScript.TypeCheckStatus,v13903=v19730.Started,v4127=v13902==v13903;if(v4127){var v19731=this.checker,v13904=v19731.styleSettings,v4085=v13904.implicitAny;if(v4085){var v13905=this.checker,v4084=v13905.errorReporter;JAMScript.call(v4084.styleError,v4084,[varDecl,"type implicitly set to 'any'"])}var v4086=varDecl.type=this.anyType;JAMScript.call(infSym.setType,infSym,[v4086])}else{var v13906=infSym.typeCheckStatus,v19732=TypeScript.TypeCheckStatus,
v13907=v19732.NotStarted,v4126=v13906==v13907;if(v4126){var v4087=TypeScript.TypeCheckStatus;infSym.typeCheckStatus=v4087.Started;var v4088=this.checker;JAMScript.call(v4088.addStartedPTO,v4088,[infSym]);var resolved=!1,v13908=varDecl.type,v4092=null==v13908;if(v4092){var v4091=varDecl.typeExpr;if(v4091){JAMScript.call(this.resolveBoundDecl,this,[varDecl]);var resolved=!0,v4089=varDecl.typeExpr;varDecl.type=v4089.type;var v4090=infSym,v13909=this.checker,v26890=JAMScript.call(v13909.getTypeCheckFinishedStatus,
v13909,[]);v4090.typeCheckStatus=v26890}}var v4119=varDecl.init;if(v4119){var v4093=varDecl.varFlags,v13910=TypeScript.VarFlags,v4094=v13910.LocalStatic,isLocalStatic=JAMScript.call(TypeScript.hasFlag,TypeScript,[v4093,v4094]),prevScope=this.scope,v13911=varDecl.init,v4095=v13911.isParenthesized,applyTargetType=!v4095;if(isLocalStatic){var v19733=varDecl.sym,v13912=v19733.container,v4096=JAMScript.call(v13912.getType,v13912,[]);this.scope=v4096.memberScope}var v19734=varDecl.varFlags,v23327=TypeScript.VarFlags,
v19735=v23327.Property,v13913=JAMScript.call(TypeScript.hasFlag,TypeScript,[v19734,v19735]);v13913&&(v13913=this.thisClassNode);var v4099=v13913;if(v4099){var v4097=JAMScript.call(TypeScript.getAstWalkerFactory,TypeScript,[]),v4098=varDecl.init;JAMScript.call(v4097.walk,v4097,[v4098,v1020])}var v4100=this.checker,v4101=varDecl.type,v13914=this.checker,v4102=JAMScript.call(v13914.inProvisionalTypecheckMode,v13914,[]),v4103=varDecl.init;JAMScript.call(v4100.typeCheckWithContextualType,v4100,[v4101,
v4102,applyTargetType,v4103]);this.scope=prevScope;var v4116=varDecl.type;if(v4116){var preserveScope=!1,preservedContainedScope=null,v13915=varDecl.init,v4108=v13915.type;if(v4108){var v13916=varDecl.init,v4104=v13916.type,preservedContainedScope=v4104.containedScope,preserveScope=!0,v19736=varDecl.init,v13917=v19736.type,v13918=this.voidType,v4107=v13917==v13918;if(v4107){var v13919=this.checker,v4105=v13919.errorReporter,v23328=varDecl.id,v19737=v23328.actualText,v13920="Cannot assign type 'void' to variable '"+
v19737,v4106=v13920+"'";JAMScript.call(v4105.simpleError,v4105,[varDecl,v4106])}}var v4109=varDecl,v13921=varDecl.init,v13922=varDecl.type,v19738=applyTargetType;if(v19738)var v25028=this.checker,v23329=JAMScript.call(v25028.inProvisionalTypecheckMode,v25028,[]),v19738=!v23329;var v13923=v19738,v26891=JAMScript.call(this.castWithCoercion,this,[v13921,v13922,v13923,!1]);v4109.init=v26891;var v13924=preserveScope;if(v13924)var v25029=varDecl.init,v23330=v25029.type,v19739=v23330.containedScope,v13924=
null==v19739;var v4111=v13924;if(v4111){var v13925=varDecl.init,v4110=v13925.type;v4110.containedScope=preservedContainedScope}}else{var v4112=varDecl,v13926=this.checker,v19740=varDecl.init,v13927=v19740.type,v26892=JAMScript.call(v13926.widenType,v13926,[v13927]);v4112.type=v26892;var v13928=varDecl.type,v13929=this.voidType,v4115=v13928==v13929;if(v4115){var v13930=this.checker,v4113=v13930.errorReporter,v23331=varDecl.id,v19741=v23331.actualText,v13931="Cannot assign type 'void' to variable '"+
v19741,v4114=v13931+"'";JAMScript.call(v4113.simpleError,v4113,[varDecl,v4114]);varDecl.type=this.anyType}}var v4117=varDecl.type;JAMScript.call(infSym.setType,infSym,[v4117])}else{var v4118=!resolved;v4118&&JAMScript.call(this.resolveBoundDecl,this,[varDecl])}var v4120=infSym,v13932=this.checker,v26893=JAMScript.call(v13932.getTypeCheckFinishedStatus,v13932,[]);v4120.typeCheckStatus=v26893}else{var v19742=this.checker,v19743=infSym.typeCheckStatus,v13933=JAMScript.call(v19742.typeStatusIsFinished,
v19742,[v19743]);if(v13933)var v19744=infSym.declAST,v13933=v19744!=varDecl;var v4125=v13933;if(v4125){var v4124=varDecl.init;if(v4124){var v4121=varDecl,v13934=varDecl.init,v26894=JAMScript.call(this.typeCheck,this,[v13934]);v4121.init=v26894;var v4122=varDecl,v26895=JAMScript.call(infSym.getType,infSym,[]);v4122.type=v26895;var v4123=varDecl,v13935=varDecl.init,v13936=varDecl.type,v26896=JAMScript.call(this.cast,this,[v13935,v13936]);v4123.init=v26896}}}}}var v13937=varDecl.id;v13937&&(v13937=varDecl.sym);
var v4130=v13937;if(v4130){var v4129=varDecl.id;v4129.sym=varDecl.sym}var v13938=varDecl.sym;if(v13938)var v19745=varDecl.sym,v13938=v19745.container;var v4133=v13938;if(v4133){var v13939=varDecl.sym,v4131=JAMScript.call(v13939.getType,v13939,[]),v4132=varDecl.sym;JAMScript.call(this.checkTypePrivacy,this,[v4131,v4132,v1021])}return varDecl}function v1019(varDecl){var v4150=varDecl.typeExpr;if(v4150){var v4150=varDecl.typeExpr,v4150=v4150.type,v4150=null==v4150,v19748=!v4150;if(v19748){v4150=varDecl.typeExpr;
if(v4150=v4150.type)if(v4150=varDecl.typeExpr,v4150=v4150.type,v19748=this.anyType,v4150=v4150==v19748)v4150=this.scope;if(v19748=!v4150)if(v4150=varDecl.typeExpr,v4150=v4150.type,v4150=v4150.symbol,v4150=null==v4150,v19748=!v4150)v4150=this.checker,v19748=varDecl.typeExpr,v19748=v19748.type,v19748=v19748.symbol,v19748=v19748.typeCheckStatus,v4150=JAMScript.call(v4150.typeStatusIsFinished,v4150,[v19748]),v4150=!v4150}v4150&&(v4150=varDecl.typeExpr,JAMScript.call(this.typeCheck,this,[v4150]));v4150=
varDecl.typeExpr;varDecl.type=v4150.type;if(v4150=varDecl.sym)v4150=varDecl.sym,varDecl=varDecl.type,JAMScript.call(v4150.setType,v4150,[varDecl])}else if(v4150=varDecl.init,v4150=null==v4150){v4150=this.checker;v4150=v4150.styleSettings;if(v4150=v4150.implicitAny)v4150=this.checker,v4150=v4150.errorReporter,JAMScript.call(v4150.styleError,v4150,[varDecl,"type implicitly set to 'any'"]);varDecl.type=this.anyType;if(v4150=varDecl.sym)v4150=varDecl.sym,(v4150=JAMScript.call(v4150.isType,v4150,[]))?
(v4150=varDecl.sym,(v4150=v4150.isMethod)?(v4150=this.checker,v4150=v4150.errorReporter,JAMScript.call(v4150.simpleError,v4150,[varDecl,"Cannot bind method group to variable.  (Did you mean to use 'declare function' instead of 'declare var'?)"])):(v4150=this.checker,v4150=v4150.errorReporter,JAMScript.call(v4150.simpleError,v4150,[varDecl,"Cannot bind type to variable"]))):(v4150=varDecl.sym,varDecl=varDecl.type,JAMScript.call(v4150.setType,v4150,[varDecl]))}}function v1018(varDecl){var sym=varDecl.sym,
svThisFnc=this.thisFnc,svThisType=this.thisType,prevMethodStatus=this.enclosingFncIsMethod,v4151=this.checker,v4151=v4151.locationInfo,v13947=sym;v13947&&(v13947=sym.container);if(v13947){var v13947=varDecl.varFlags,v23336=TypeScript.VarFlags,v23336=v23336.ClassConstructorProperty;(v13947=JAMScript.call(TypeScript.hasFlag,TypeScript,[v13947,v23336]))?(v13947=sym.container,v13947=JAMScript.call(v13947.getType,v13947,[]),v13947=v13947.constructorScope):(v13947=sym.container,v13947=JAMScript.call(v13947.instanceScope,
v13947,[]));var v23336=v13947,v13947=varDecl.varFlags,v23337=TypeScript.VarFlags,v23337=v23337.Property;if(v13947=JAMScript.call(TypeScript.hasFlag,TypeScript,[v13947,v23337]))v13947=sym.container,v13947=v13947.declAST,v13947=v13947.nodeType,v23337=TypeScript.NodeType,v23337=v23337.FuncDecl,v13947=v13947==v23337;v13947&&(v13947=sym.container,this.thisFnc=v13947.declAST);if(v23336){v13947=this.scope;this.scope=v23336;v23336=sym.container;v23337=this.checker;if(v23337=v23337.units)if(v23337=sym.unitIndex,
v23337=0<=v23337)var v23337=sym.unitIndex,v25868=this.checker,v25868=v25868.units,v25868=v25868.length,v23337=v23337<v25868;if(v23337){v25868=v23337=this.checker;v25868=v25868.units;sym=sym.unitIndex;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v23337.locationInfo=v25868[sym]}else sym=this.checker,sym.locationInfo=TypeScript.unknownLocationInfo;for(;v23336;){sym=JAMScript.call(v23336.kind,v23336,[]);v23337=TypeScript.SymbolKind;v23337=v23337.Type;if(sym=sym==
v23337){v23337=v23336;sym=v23337.type;if(v25868=sym.call)this.enclosingFncIsMethod=v23337.isMethod;if(v23337=JAMScript.call(sym.isClass,sym,[])){this.thisType=sym.instanceType;break}}v23336=v23336.container}JAMScript.call(this.typeCheckBoundDecl,this,[varDecl]);this.scope=v13947}}this.thisFnc=svThisFnc;this.thisType=svThisType;varDecl=this.checker;varDecl.locationInfo=v4151;this.enclosingFncIsMethod=prevMethodStatus}function v1017(ast){var v19761=ast.nodeType,v23343=TypeScript.NodeType,v23343=v23343.VarDecl,
v19761=v19761==v23343;if(v23343=!v19761)v19761=ast.nodeType,v23343=TypeScript.NodeType,v23343=v23343.ArgDecl,v19761=v19761==v23343;v19761?JAMScript.call(this.inScopeTypeCheckBoundDecl,this,[ast]):(v19761=ast.nodeType,v23343=TypeScript.NodeType,v23343=v23343.FuncDecl,(v19761=v19761==v23343)&&(v19761=JAMScript.call(ast.isAccessor,ast,[]))&&JAMScript.call(this.typeCheckFunction,this,[ast]))}function v1016(ast){return ast?JAMScript.call(ast.typeCheck,ast,[this]):null}function v1015(ast,enclosingScope){var prevScope=
this.scope;this.scope=enclosingScope;for(var svThisFnc=this.thisFnc,svThisType=this.thisType,svThisClassNode=this.thisClassNode,v4166=this.checker,v4166=v4166.currentModDecl,prevMethodStatus=this.enclosingFncIsMethod,v4167=this.scope,container=v4167.container,v4167=null;container;){var v13960=JAMScript.call(container.kind,container,[]),v19767=TypeScript.SymbolKind,v19767=v19767.Type;if(v13960=v13960==v19767){var v13960=container,v19767=v13960.type,v4169=v19767.call;v4169&&(v4169=null==v4167)&&(this.enclosingFncIsMethod=
v13960.isMethod,v4167=container.declAST);if(v4169=JAMScript.call(v19767.isClass,v19767,[])){this.thisType=v19767.instanceType;if(container=v13960.declAST)container=v13960.declAST,container=container.nodeType,v19767=TypeScript.NodeType,v19767=v19767.ClassDeclaration,container=container==v19767;container&&(this.thisClassNode=v13960.declAST);break}if(v19767=JAMScript.call(v19767.isModuleType,v19767,[])){container=this.checker;container.currentModDecl=v13960.declAST;break}}container=container.container}this.thisFnc=
v4167;v4167=JAMScript.call(this.typeCheck,this,[ast]);this.thisFnc=svThisFnc;this.thisType=svThisType;this.thisClassNode=svThisClassNode;svThisFnc=this.checker;svThisFnc.currentModDecl=v4166;this.enclosingFncIsMethod=prevMethodStatus;this.scope=prevScope;return v4167}function v1014(ast,type,applyCoercion,typeAssertion){var v4176=TypeScript.TypeComparisonInfo,v4176=JAMScript.new(v4176,[]),v19770=this.checker,v19771=ast.type,v19770=JAMScript.call(v19770.sourceIsAssignableToTarget,v19770,[v19771,type,
v4176]);if(v19771=!v19770)typeAssertion&&(typeAssertion=this.checker,v19770=ast.type,typeAssertion=JAMScript.call(typeAssertion.sourceIsAssignableToTarget,typeAssertion,[type,v19770,v4176])),v19770=typeAssertion;(typeAssertion=v19770)?applyCoercion&&((v4176=null==type)?ast.type=this.anyType:(v4176=JAMScript.call(type.isClass,type,[]),ast.type=v4176?type.instanceType:type)):(applyCoercion=this.checker,applyCoercion=applyCoercion.errorReporter,typeAssertion=ast.type,v19770=this.scope,JAMScript.call(applyCoercion.incompatibleTypes,
applyCoercion,[ast,typeAssertion,type,null,v19770,v4176]));return ast}function v1013(ast,type){return JAMScript.call(this.castWithCoercion,this,[ast,type,!0,!1])}function v1012(){var v4183=this.globalScope,v13965=v4183=JAMScript.call(v4183.find,v4183,["Array",!1,!0]);if(v13965)var v13965=JAMScript.call(v4183.kind,v4183,[]),v23349=TypeScript.SymbolKind,v23349=v23349.Type,v13965=v13965==v23349;v13965&&(this.arrayInterfaceType=v4183.type);v4183=this.globalScope;if(v13965=v4183=JAMScript.call(v4183.find,
v4183,["String",!1,!0]))v13965=JAMScript.call(v4183.kind,v4183,[]),v23349=TypeScript.SymbolKind,v23349=v23349.Type,v13965=v13965==v23349;v13965&&(this.stringInterfaceType=v4183.type);v4183=this.globalScope;if(v13965=v4183=JAMScript.call(v4183.find,v4183,["Object",!1,!0]))v13965=JAMScript.call(v4183.kind,v4183,[]),v23349=TypeScript.SymbolKind,v23349=v23349.Type,v13965=v13965==v23349;v13965&&(this.objectInterfaceType=v4183.type);v4183=this.globalScope;if(v13965=v4183=JAMScript.call(v4183.find,v4183,
["Function",!1,!0]))v13965=JAMScript.call(v4183.kind,v4183,[]),v23349=TypeScript.SymbolKind,v23349=v23349.Type,v13965=v13965==v23349;v13965&&(this.functionInterfaceType=v4183.type);v4183=this.globalScope;if(v13965=v4183=JAMScript.call(v4183.find,v4183,["Number",!1,!0]))v13965=JAMScript.call(v4183.kind,v4183,[]),v23349=TypeScript.SymbolKind,v23349=v23349.Type,v13965=v13965==v23349;v13965&&(this.numberInterfaceType=v4183.type);v4183=this.globalScope;if(v13965=v4183=JAMScript.call(v4183.find,v4183,["Boolean",
!1,!0]))v13965=JAMScript.call(v4183.kind,v4183,[]),v23349=TypeScript.SymbolKind,v23349=v23349.Type,v13965=v13965==v23349;v13965&&(this.booleanInterfaceType=v4183.type);v4183=this.globalScope;if(v13965=v4183=JAMScript.call(v4183.find,v4183,["RegExp",!1,!0]))v13965=JAMScript.call(v4183.kind,v4183,[]),v23349=TypeScript.SymbolKind,v23349=v23349.Type,v13965=v13965==v23349;v13965&&(this.regexType=v4183.type)}function TypeFlow(logger,initScope,parser,checker){this.logger=logger;this.initScope=initScope;
this.parser=parser;this.checker=checker;this.thisClassNode=this.thisFnc=null;this.enclosingFncIsMethod=!1;this.currentScript=this.iargumentsInterfaceType=this.booleanInterfaceType=this.numberInterfaceType=this.functionInterfaceType=this.objectInterfaceType=this.stringInterfaceType=this.arrayInterfaceType=null;this.inArrayElementTypeCheck=this.inTypeRefTypeCheck=this.inImportTypeCheck=!1;this.resolutionDataCache=logger=JAMScript.new(ResolutionDataCache,[]);this.nestingLevel=0;this.inSuperCall=!1;logger=
this.checker;logger.typeFlow=this;this.globalScope=this.scope=this.initScope;logger=this.checker;this.doubleType=logger.numberType;logger=this.checker;this.booleanType=logger.booleanType;logger=this.checker;this.stringType=logger.stringType;logger=this.checker;this.regexType=this.anyType=logger.anyType;logger=this.checker;this.nullType=logger.nullType;logger=this.checker;this.voidType=logger.voidType;logger=this.checker;initScope=this.anyType;this.arrayAnyType=logger=JAMScript.call(logger.makeArrayType,
logger,[initScope])}var v4206=TypeFlow.prototype;v4206.initLibs=v1012;var v4207=TypeFlow.prototype;v4207.cast=v1013;var v4208=TypeFlow.prototype;v4208.castWithCoercion=v1014;var v4209=TypeFlow.prototype;v4209.inScopeTypeCheck=v1015;var v4210=TypeFlow.prototype;v4210.typeCheck=v1016;var v4211=TypeFlow.prototype;v4211.inScopeTypeCheckDecl=v1017;var v4212=TypeFlow.prototype;v4212.inScopeTypeCheckBoundDecl=v1018;var v4213=TypeFlow.prototype;v4213.resolveBoundDecl=v1019;var v4214=TypeFlow.prototype;v4214.typeCheckBoundDecl=
v1022;var v4215=TypeFlow.prototype;v4215.varPrivacyErrorReporter=v1023;var v4216=TypeFlow.prototype;v4216.typeCheckSuper=v1024;var v4217=TypeFlow.prototype;v4217.typeCheckThis=v1025;var v4218=TypeFlow.prototype;v4218.setTypeFromSymbol=v1026;var v4219=TypeFlow.prototype;v4219.typeCheckName=v1028;var v4220=TypeFlow.prototype;v4220.typeCheckScript=v1029;var v4221=TypeFlow.prototype;v4221.typeCheckBitNot=v1030;var v4222=TypeFlow.prototype;v4222.typeCheckUnaryNumberOperator=v1031;var v4223=TypeFlow.prototype;
v4223.typeCheckLogNot=v1032;var v4224=TypeFlow.prototype;v4224.astIsWriteable=v1033;var v4225=TypeFlow.prototype;v4225.typeCheckIncOrDec=v1034;var v4226=TypeFlow.prototype;v4226.typeCheckBitwiseOperator=v1035;var v4227=TypeFlow.prototype;v4227.typeCheckArithmeticOperator=v1036;var v4228=TypeFlow.prototype;v4228.typeCheckDotOperator=v1037;var v4229=TypeFlow.prototype;v4229.typeCheckBooleanOperator=v1038;var v4230=TypeFlow.prototype;v4230.typeCheckAsgOperator=v1039;var v4231=TypeFlow.prototype;v4231.typeCheckIndex=
v1040;var v4232=TypeFlow.prototype;v4232.typeCheckInOperator=v1041;var v4233=TypeFlow.prototype;v4233.typeCheckShift=v1042;var v4234=TypeFlow.prototype;v4234.typeCheckQMark=v1043;var v4235=TypeFlow.prototype;v4235.addFormals=v1044;var v4236=TypeFlow.prototype;v4236.addLocalsFromScope=v1045;var v4237=TypeFlow.prototype;v4237.addConstructorLocalArgs=v1046;var v4238=TypeFlow.prototype;v4238.checkInitSelf=v1047;var v4239=TypeFlow.prototype;v4239.checkPromoteFreeVars=v1048;var v4240=TypeFlow.prototype;
v4240.allReturnsAreVoid=v1050;var v4241=TypeFlow.prototype;v4241.classConstructorHasSuperCall=v1051;var v4242=TypeFlow.prototype;v4242.baseListPrivacyErrorReporter=v1052;var v4243=TypeFlow.prototype;v4243.typeCheckBaseListPrivacy=v1054;var v4244=TypeFlow.prototype;v4244.checkSymbolPrivacy=v1055;var v4245=TypeFlow.prototype;v4245.checkTypePrivacy=v1057;var v4246=TypeFlow.prototype;v4246.checkSignatureGroupPrivacy=v1058;var v4247=TypeFlow.prototype;v4247.functionArgumentPrivacyErrorReporter=v1059;var v4248=
TypeFlow.prototype;v4248.returnTypePrivacyError=v1060;var v4249=TypeFlow.prototype;v4249.functionReturnTypePrivacyErrorReporter=v1061;var v4250=TypeFlow.prototype;v4250.typeCheckFunction=v1069;var v4251=TypeFlow.prototype;v4251.typeCheckBases=v1070;var v4252=TypeFlow.prototype;v4252.checkMembersImplementInterfaces=v1071;var v4253=TypeFlow.prototype;v4253.typeCheckBaseCalls=v1072;var v4254=TypeFlow.prototype;v4254.assertUniqueNamesInBaseTypes=v1074;var v4255=TypeFlow.prototype;v4255.checkBaseTypeMemberInheritance=
v1076;var v4256=TypeFlow.prototype;v4256.typeCheckClass=v1077;var v4257=TypeFlow.prototype;v4257.typeCheckOverloadSignatures=v1078;var v4258=TypeFlow.prototype;v4258.typeCheckInterface=v1079;var v4259=TypeFlow.prototype;v4259.typeCheckImportDecl=v1080;var v4260=TypeFlow.prototype;v4260.typeCheckModule=v1081;var v4261=TypeFlow.prototype;v4261.typeCheckFor=v1082;var v4262=TypeFlow.prototype;v4262.typeCheckWith=v1083;var v4263=TypeFlow.prototype;v4263.typeCheckForIn=v1084;var v4264=TypeFlow.prototype;
v4264.typeCheckWhile=v1085;var v4265=TypeFlow.prototype;v4265.typeCheckDoWhile=v1086;var v4266=TypeFlow.prototype;v4266.typeCheckCondExpr=v1087;var v4267=TypeFlow.prototype;v4267.typeCheckCompoundStmtBlock=v1088;var v4268=TypeFlow.prototype;v4268.typeCheckIf=v1089;var v4269=TypeFlow.prototype;v4269.typeFromAccessorFuncDecl=v1090;var v4270=TypeFlow.prototype;v4270.typeCheckObjectLit=v1091;var v4271=TypeFlow.prototype;v4271.typeCheckArrayLit=v1095;var v4272=TypeFlow.prototype;v4272.checkForVoidConstructor=
v1096;var v4273=TypeFlow.prototype;v4273.typeCheckReturn=v1097;var v4274=TypeFlow.prototype;v4274.typeCheckInstOf=v1098;var v4275=TypeFlow.prototype;v4275.typeCheckCommaOperator=v1099;var v4276=TypeFlow.prototype;v4276.typeCheckLogOr=v1100;var v4277=TypeFlow.prototype;v4277.typeCheckLogAnd=v1101;var v4278=TypeFlow.prototype;v4278.tryAddCandidates=v1102;var v4279=TypeFlow.prototype;v4279.resolveOverload=v1103;var v4280=TypeFlow.prototype;v4280.typeCheckNew=v1104;var v4281=TypeFlow.prototype;v4281.preTypeCheckCallArgs=
v1105;var v4282=TypeFlow.prototype;v4282.postTypeCheckCallArgs=v1106;var v4283=TypeFlow.prototype;v4283.typeCheckCall=v1107;var v4284=TypeFlow.prototype;v4284.assignScopes=v1108;var v4285=TypeFlow.prototype;v4285.findMemberScope=v1109;var v4286=TypeFlow.prototype;v4286.findMemberScopeAt=v1110;var v4287=TypeFlow.prototype;v4287.findMemberScopeAtFullAst=v1111;return TypeFlow}function v1011(){function v1010(rd){var v4288=rd.actuals;v4288.length=0;v4288=rd.exactCandidates;v4288.length=0;v4288=rd.conversionCandidates;
v4288.length=0;this.nextUp=rd.id}function v1009(){var rd=null,v13972=this.nextUp,v13973=this.cacheSize;if(v13972=v13972<v13973){rd=this.rdCache;v13972=this.nextUp;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)rd=rd[v13972]}if(v13972=null==rd){rd=this.cacheSize;this.cacheSize=rd+1;var rd=[],v13972=[],v13973=[],v4297=this.cacheSize,rd={actuals:rd,exactCandidates:v13972,conversionCandidates:v13973,id:v4297},v13972=this.rdCache,v13973=this.cacheSize;JAMScript.set(v13972,
v13973,rd)}v13972=this.nextUp;this.nextUp=v13972+1;return rd}function ResolutionDataCache(){this.cacheSize=16;this.rdCache=[];for(var i=this.nextUp=0,v13976=this.cacheSize,v13976=i<v13976;v13976;){var v13976=this.rdCache,v4302=i,v13977=[],v13978=[],v13979=[];v13976[v4302]={actuals:v13977,exactCandidates:v13978,conversionCandidates:v13979,id:i};i+=1;v13976=this.cacheSize;v13976=i<v13976}}var v4304=ResolutionDataCache.prototype;v4304.getResolutionData=v1009;v4304=ResolutionDataCache.prototype;v4304.returnResolutionData=
v1010;return ResolutionDataCache}function v1008(){function v1007(ast){var v4307=this.current;v4307&&(v4307=this.current,v4307=v4307.content,JAMScript.call(v4307.append,v4307,[ast]))}function v1006(target,isContinue){for(var targetBB=null,i=0,v4308=this.statementStack,v4308=v4308.length,v4311=i<v4308;v4311;){v4311=this.statementStack;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v4311=v4311[i];var v13982=v4311.stmt;if(v13982=v13982==target){targetBB=isContinue?
v4311.continueBB:v4311.breakBB;break}i+=1;v4311=i<v4308}targetBB&&(i=this.current,JAMScript.call(i.addSuccessor,i,[targetBB]));JAMScript.call(this.setUnreachable,this,[])}function v1005(ast){var v13983=this.unreachable;if(v13983=null===v13983)this.unreachable=v13983=[];var v13984=v13983=this.unreachable,v13984=v13984.length;JAMScript.set(v13983,v13984,ast)}function v1004(){this.current=null;this.noContinuation=!0}function v1003(){var v4316=this.current,v4317=this.exit;JAMScript.call(v4316.addSuccessor,
v4316,[v4317]);JAMScript.call(this.setUnreachable,this,[])}function v1002(){var v4318=this.statementStack;return JAMScript.call(v4318.pop,v4318,[])}function v1001(stmt,continueBB,breakBB){var v4319=this.statementStack;stmt={stmt:stmt,continueBB:continueBB,breakBB:breakBB};JAMScript.call(v4319.push,v4319,[stmt])}function v1000(outfile){function node(bb){var v13985=bb.index;if(v13985=0>v13985)bb.index=index,index+=1;v13985=_this.exit;(v13985=bb==v13985)?(bb=bb.index,bb="Exit block with index "+bb,JAMScript.call(outfile.WriteLine,
outfile,[bb])):(v13985=bb.index,v13985="Basic block with index "+v13985,JAMScript.call(outfile.WriteLine,outfile,[v13985]),JAMScript.call(_this.printBlockContent,_this,[bb,outfile]))}function preEdges(){JAMScript.call(outfile.Write,outfile,["  Branches to "])}function postEdges(){JAMScript.call(outfile.WriteLine,outfile,[""])}function edge(node1,node2){var v13989=node2.index;if(v13989=0>v13989)node2.index=index,index+=1;v13989=node2.index;v13989+=" ";JAMScript.call(outfile.Write,outfile,[v13989])}
var _this=this,index=0;JAMScript.call(this.bfs,this,[node,edge,preEdges,postEdges]);var v13991=this.unreachable;if(v13991=null!=v13991)for(var v13991=0,v4327=this.unreachable,v4327=v4327.length,v4329=v13991<v4327;v4329;){JAMScript.call(outfile.WriteLine,outfile,["Unreachable basic block ..."]);v4329=this.unreachable;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v4329=v4329[v13991];JAMScript.call(this.printAST,this,[v4329,outfile]);v13991+=1;v4329=v13991<v4327}}
function v999(er,funcSym){function v998(index){var v4331=useDefContext.uses;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)index=v4331[index];v4331=index.actualText;v4331="use of variable '"+v4331;v4331+="' that is not definitely assigned";JAMScript.call(er.simpleError,er,[index,v4331])}function useDefInit(bb){var v4333=bb,v26900=JAMScript.new(BBUseDefInfo,[bb]);v4333.useDef=v26900;v4333=bb.useDef;JAMScript.call(v4333.initialize,v4333,[useDefContext]);v26900=v4333=
_this.linearBBs;v26900=v26900.length;JAMScript.set(v4333,v26900,bb)}var _this=this,useDefContext=JAMScript.new(UseDefContext,[]);useDefContext.func=funcSym;JAMScript.call(this.bfs,this,[useDefInit,null,null,null]);var i,bbLen;i=0;bbLen=this.linearBBs;bbLen=bbLen.length;for(var v4339=i<bbLen;v4339;){v4339=this.linearBBs;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v4339=v4339[i];v4339=v4339.useDef;JAMScript.call(v4339.initializeGen,v4339,[useDefContext]);v4339=
this.linearBBs;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v4339=v4339[i];v4339=v4339.useDef;JAMScript.call(v4339.initializeKill,v4339,[useDefContext]);i+=1;v4339=i<bbLen}for(v4339=!0;v4339;){v4339=!1;i=0;for(var v4341=i<bbLen;v4341;){v4341=this.linearBBs;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v4341=v4341[i];var v4341=v4341.useDef,v4341=JAMScript.call(v4341.updateTop,v4341,[]),v13999=!v4341;v13999&&(v4341=v4339);v4339=
v4341;i+=1;v4341=i<bbLen}}i=this.entry;i=i.useDef;i=i.top;JAMScript.call(i.map,i,[v998])}function v997(nodeFunc,edgeFunc,preEdges,postEdges){var markValue=this.markBase,v14001=this.markBase;this.markBase=v14001+1;var v14001=[],v4343=v14001.length;v14001[v4343]=this.entry;v4343=v14001.length;for(v4343=0<v4343;v4343;){var v4343=JAMScript.call(v14001.pop,v14001,[]),v14003=JAMScript.call(v4343.marked,v4343,[markValue]);if(v14003=!v14003){JAMScript.call(v4343.mark,v4343,[]);nodeFunc&&JAMScript.call(nodeFunc,
null,[v4343]);var v14003=v4343.successors,v14003=v14003.length,v4349=0<v14003;if(v4349){preEdges&&JAMScript.call(preEdges,null,[]);v14003-=1;for(v4349=0<=v14003;v4349;){v4349=v4343.successors;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v4349=v4349[v14003];var v19792=this.markBase,v19792=JAMScript.call(v4349.marked,v4349,[v19792]);if(v19792=!v19792)edgeFunc&&JAMScript.call(edgeFunc,null,[v4343,v4349]),v19792=v14001.length,v14001[v19792]=v4349;v14003-=1;v4349=
0<=v14003}postEdges&&JAMScript.call(postEdges,null,[])}}v4343=v14001.length;v4343=0<v4343}}function v996(bb,outfile){for(var content=bb.content,i=0,v4352=content.members,v4352=v4352.length,v4354=i<v4352;v4354;){v4354=content.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v4354=v4354[i];JAMScript.call(this.printAST,this,[v4354,outfile]);i+=1;v4354=i<v4352}}function v995(ast,outfile){var v4355=TypeScript.PrintContext,v4355=JAMScript.new(v4355,[outfile,null]);
JAMScript.call(v4355.increaseIndent,v4355,[]);var v4356=JAMScript.call(TypeScript.getAstWalkerFactory,TypeScript,[]),v4357=TypeScript.prePrintAST,v4358=TypeScript.postPrintAST;JAMScript.call(v4356.walk,v4356,[ast,v4357,v4358,null,v4355]);JAMScript.call(v4355.decreaseIndent,v4355,[])}function v994(er){var v14006=this.unreachable;v14006&&(v14006=this.unreachable,v14006=v14006.length,v14006=0<v14006);if(v14006)for(var v14006=this.unreachable,v14006=v14006.length,i=0,v4362=i<v14006;v4362;){v4362=this.unreachable;
introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v4362=v4362[i];var v14007=v4362.nodeType,v19794=TypeScript.NodeType,v19794=v19794.EndCode;(v14007=v14007!=v19794)&&JAMScript.call(er.simpleError,er,[v4362,"unreachable code"]);i+=1;v4362=i<v14006}}function v993(){var v4364=this.currentSwitch;return JAMScript.call(v4364.pop,v4364,[])}function v992(bb){var v4365=this.currentSwitch;JAMScript.call(v4365.push,v4365,[bb])}function v991(ast,parent){var v4366=this.walker;return JAMScript.call(v4366.walk,
v4366,[ast,parent])}function ControlFlowContext(current,exit){this.current=current;this.exit=exit;this.unreachable=this.entry=null;this.noContinuation=!1;var v26901=[];this.statementStack=v26901;this.currentSwitch=v26901=[];this.markBase=0;this.linearBBs=v26901=[];this.entry=this.current}var v4367=ControlFlowContext.prototype;v4367.walk=v991;v4367=ControlFlowContext.prototype;v4367.pushSwitch=v992;v4367=ControlFlowContext.prototype;v4367.popSwitch=v993;v4367=ControlFlowContext.prototype;v4367.reportUnreachable=
v994;v4367=ControlFlowContext.prototype;v4367.printAST=v995;v4367=ControlFlowContext.prototype;v4367.printBlockContent=v996;v4367=ControlFlowContext.prototype;v4367.bfs=v997;v4367=ControlFlowContext.prototype;v4367.useDef=v999;v4367=ControlFlowContext.prototype;v4367.print=v1000;v4367=ControlFlowContext.prototype;v4367.pushStatement=v1001;v4367=ControlFlowContext.prototype;v4367.popStatement=v1002;v4367=ControlFlowContext.prototype;v4367.returnStmt=v1003;v4367=ControlFlowContext.prototype;v4367.setUnreachable=
v1004;v4367=ControlFlowContext.prototype;v4367.addUnreachable=v1005;v4367=ControlFlowContext.prototype;v4367.unconditionalBranch=v1006;v4367=ControlFlowContext.prototype;v4367.addContent=v1007;return ControlFlowContext}function v990(){function v989(successor){var v4383=this.successors,v14009=this.successors,v14009=v14009.length;JAMScript.set(v4383,v14009,successor);successor=v4383=successor.predecessors;successor=successor.length;JAMScript.set(v4383,successor,this)}function v988(){var v14011=this.markValue;
this.markValue=v14011+1}function v987(markBase){var v4387=this.markValue;return v4387>markBase}function BasicBlock(){var v26904=[];this.predecessors=v26904;this.index=-1;this.markValue=0;this.successors=v26904=[];this.useDef=null;v26904=TypeScript.ASTList;this.content=v26904=JAMScript.new(v26904,[])}var v4389=BasicBlock.prototype;v4389.marked=v987;v4389=BasicBlock.prototype;v4389.mark=v988;v4389=BasicBlock.prototype;v4389.addSuccessor=v989;return BasicBlock}function v986(){function v985(b){var v14012=
this.firstBits,v19795=b.firstBits,v19795=~v19795;this.firstBits=v14012&v19795;if(v14012=this.restOfBits)for(var v14012=0,v19795=this.restOfBits,v19795=v19795.length,v4396=v14012<v19795;v4396;){v4396=b.restOfBits;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var bBits=v4396[v14012];v4396=this.restOfBits;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v19796=v4396[v14012];bBits=~bBits;v4396[v14012]=v19796&bBits;v14012+=1;v4396=
v14012<v19795}}function v984(b){var v14014=this.firstBits,v14015=b.firstBits;if(v14014=v14014!=v14015)return!0;if(v14014=this.restOfBits)for(var v14014=0,v14015=this.restOfBits,v14015=v14015.length,v4403=v14014<v14015;v4403;){v4403=this.restOfBits;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v4403=v4403[v14014];var v4401=b.restOfBits;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v4401=v4401[v14014];if(v4403=v4403!=v4401)return!0;
v14014+=1;v4403=v14014<v14015}return!1}function v983(b){var v14016=this.firstBits,v14017=b.firstBits;this.firstBits=v14016&v14017;if(v14016=this.restOfBits)for(var v14016=0,v14017=this.restOfBits,v14017=v14017.length,v4409=v14016<v14017;v4409;){v4409=this.restOfBits;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v4409=v4409[v14016];var v4407=b.restOfBits;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v4407=v4407[v14016];var v4408=
this.restOfBits;v4408[v14016]=v4409&v4407;v14016+=1;v4409=v14016<v14017}}function v982(b){var v14018=this.firstBits,v14019=b.firstBits;this.firstBits=v14018|v14019;if(v14018=this.restOfBits)for(var v14018=0,v14019=this.restOfBits,v14019=v14019.length,v4415=v14018<v14019;v4415;){v4415=this.restOfBits;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v4415=v4415[v14018];var v4413=b.restOfBits;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v4413=
v4413[v14018];var v4414=this.restOfBits;v4414[v14018]=v4415|v4413;v14018+=1;v4415=v14018<v14019}}function v981(fn){var k;k=0;for(var v14020=BitVector.packBits,v14020=k<v14020;v14020;){v14020=this.bitCount;if(v14020=k==v14020)return;var v14020=1<<k,v19799=this.firstBits,v14020=v14020&v19799;(v14020=0!=v14020)&&JAMScript.call(fn,null,[k]);k+=1;v14020=BitVector.packBits;v14020=k<v14020}if(k=this.restOfBits){v14020=BitVector.packBits;k=0;for(var v19799=this.restOfBits,v19799=v19799.length,v4424=k<v19799;v4424;){v4424=
this.restOfBits;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v4424=v4424[k];for(var j=0,v14025=BitVector.packBits,v14025=j<v14025;v14025;){v14025=1<<j;v14025&=v4424;(v14025=0!=v14025)&&JAMScript.call(fn,null,[v14020]);v14020+=1;v14025=this.bitCount;if(v14025=v14020==v14025)return;j+=1;v14025=BitVector.packBits;v14025=j<v14025}k+=1;v4424=k<v19799}}}function v980(bitIndex,value){var v14029=BitVector.packBits;if(v14029=bitIndex<v14029)if(value){var v14029=this.firstBits,
v14031=1<<bitIndex;this.firstBits=v14029|v14031}else v14029=this.firstBits,v14031=1<<bitIndex,v14031=~v14031,this.firstBits=v14029&v14031;else if(v14029=BitVector.packBits,v14029=bitIndex/v14029,v14029=Math.floor(v14029),v14029-=1,v14031=BitVector.packBits,v14031=bitIndex%v14031,value){var v4428=this.restOfBits;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v19803=v4428[v14029];v14031=1<<v14031;v4428[v14029]=v19803|v14031}else{v4428=this.restOfBits;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v19803=
v4428[v14029];v14031=1<<v14031;v14031=~v14031;v4428[v14029]=v19803&v14031}}function BitVector(bitCount){this.bitCount=bitCount;this.firstBits=0;this.restOfBits=null;bitCount=this.bitCount;var v14036=BitVector.packBits;if(bitCount=bitCount>v14036){this.restOfBits=bitCount=[];bitCount=this.bitCount;v14036=BitVector.packBits;bitCount/=v14036;bitCount=Math.floor(bitCount);for(var v14036=0,v4433=v14036<bitCount;v4433;)v4433=this.restOfBits,v4433[v14036]=0,v14036+=1,v4433=v14036<bitCount}}BitVector.packBits=
30;var v4435=BitVector.prototype;v4435.set=v980;v4435=BitVector.prototype;v4435.map=v981;v4435=BitVector.prototype;v4435.union=v982;v4435=BitVector.prototype;v4435.intersection=v983;v4435=BitVector.prototype;v4435.notEq=v984;v4435=BitVector.prototype;v4435.difference=v985;return BitVector}function v979(){function v978(sym,bbUses){var v4441=this.symbolMap,v4442=sym.name,v4441=JAMScript.call(v4441.lookup,v4441,[v4442]),v4442=this.useIndexBySymbol;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v4441=
v4442[v4441];for(var v4442=0,len=v4441.length,v4445=v4442<len;v4445;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v4445=v4441[v4442];JAMScript.call(bbUses.set,bbUses,[v4445,!0]);v4442+=1;v4445=v4442<len}}function v977(sym){var v4446=sym;if(v4446){var v4446=sym.container,v19808=this.func;if(v4446=v4446==v19808)sym=JAMScript.call(sym.kind,sym,[]),v4446=TypeScript.SymbolKind,v4446=v4446.Variable,v4446=sym==v4446}return v4446}function v976(ast){var v4447=this.uses,
v14040=this.uses,v14040=v14040.length;JAMScript.set(v4447,v14040,ast);ast=this.uses;ast=ast.length;return ast-1}function v975(symIndex,astIndex){var v4450=this.useIndexBySymbol;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v4450=v4450[symIndex];var v4452=void 0==v4450;v4452&&(v4450=[],v4452=this.useIndexBySymbol,JAMScript.set(v4452,symIndex,v4450));v4452=v4450.length;JAMScript.set(v4450,v4452,astIndex)}function v974(sym){var name=sym.name,v4454=this.symbolMap,
v4454=JAMScript.call(v4454.lookup,v4454,[name]),v4457=null==v4454;v4457&&(v4457=v4454=this.symbolCount,this.symbolCount=v4457+1,v4457=this.symbols,JAMScript.set(v4457,v4454,sym),sym=this.symbolMap,JAMScript.call(sym.add,sym,[name,v4454]));return v4454}function UseDefContext(){var v26908=[];this.useIndexBySymbol=v26908;this.uses=v26908=[];this.symbols=v26908=[];v26908=TypeScript.StringHashTable;this.symbolMap=v26908=JAMScript.new(v26908,[]);this.symbolCount=0}var v4459=UseDefContext.prototype;v4459.getSymbolIndex=
v974;v4459=UseDefContext.prototype;v4459.addUse=v975;v4459=UseDefContext.prototype;v4459.getUseIndex=v976;v4459=UseDefContext.prototype;v4459.isLocalSym=v977;v4459=UseDefContext.prototype;v4459.killSymbol=v978;return UseDefContext}function v973(){function v972(useDefContext){var v14043=this.gen,v14043=v14043.bitCount;this.kill=v14043=JAMScript.new(BitVector,[v14043]);for(var v14043=0,v4465=this.defsBySymbol,v4465=v4465.length,v4471=v14043<v4465;v4471;){v4471=this.defsBySymbol;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v4471=
v4471[v14043];if(v4471){v4471=useDefContext.useIndexBySymbol;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v4471=v4471[v14043];if(v4471)for(var u=0,useLen=v4471.length,v4469=u<useLen;v4469;){v4469=this.kill;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v4468=v4471[u];JAMScript.call(v4469.set,v4469,[v4468,!0]);u+=1;v4469=u<useLen}}v14043+=1;v4471=v14043<v4465}}function v971(useDefContext){var v4472=this.useIndexBySymbol,
v4472=v4472.length;useDefContext=useDefContext.uses;useDefContext=useDefContext.length;this.gen=useDefContext=JAMScript.new(BitVector,[useDefContext]);useDefContext=0;for(var v4479=useDefContext<v4472;v4479;){v4479=this.useIndexBySymbol;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v4479=v4479[useDefContext];var v14045=void 0!=v4479;v14045&&(v14045=v4479.length,v14045=0<v14045);if(v14045)for(var v14045=0,uLen=v4479.length,v4477=v14045<uLen;v4477;){v4477=this.gen;
introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v4476=v4479[v14045];JAMScript.call(v4477.set,v4477,[v4476,!0]);v14045+=1;v4477=v14045<uLen}useDefContext+=1;v4479=useDefContext<v4472}this.top=this.gen}function v970(useDefContext){function defSym(sym,context){var v4483=JAMScript.call(context.isLocalSym,context,[sym]);if(v4483){var v4483=JAMScript.call(context.getSymbolIndex,context,[sym]),v4480=_this.useIndexBySymbol,v4481=v4483,v26914=[];JAMScript.set(v4480,v4481,
v26914);v4480=_this.defsBySymbol;JAMScript.set(v4480,v4483,!0)}}function initUseDefPre(cur,parent,walker){var context=walker.state,v4484=null==cur;v4484&&(cur=null);var v4484=cur.nodeType,v19812=TypeScript.NodeType,v19812=v19812.VarDecl;if(v4484=v4484==v19812){walker=cur;parent=walker.init;if(v4484=!parent)parent=walker.varFlags,v4484=TypeScript.VarFlags,v4484=v4484.AutoInit,parent=JAMScript.call(TypeScript.hasFlag,TypeScript,[parent,v4484]);parent&&(walker=walker.sym,defSym(walker,context))}else if(v4484=
cur.nodeType,v19812=TypeScript.NodeType,v19812=v19812.Name,v4484=v4484==v19812){if(parent)if(walker=parent.nodeType,v4484=TypeScript.NodeType,v4484=v4484.Asg,walker=walker==v4484){if(walker=parent,walker=walker.operand1,walker=walker==cur)return cur}else if(walker=parent.nodeType,v4484=TypeScript.NodeType,v4484=v4484.VarDecl,walker=walker==v4484)if(walker=parent,walker=walker.id,walker=walker==cur)return cur;walker=cur;parent=walker.sym;walker=cur;if(v4484=JAMScript.call(context.isLocalSym,context,
[parent])){parent=JAMScript.call(context.getSymbolIndex,context,[parent]);v4484=_this.useIndexBySymbol;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v4484=v4484[parent];if(v4484=void 0==v4484){var v4484=_this.useIndexBySymbol,v19812=parent,v26915=[];JAMScript.set(v4484,v19812,v26915)}v4484=_this.useIndexBySymbol;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v4484=v4484[parent];walker=JAMScript.call(context.getUseIndex,context,
[walker]);JAMScript.call(context.addUse,context,[parent,walker]);JAMScript.call(v4484.push,v4484,[walker])}}else{parent=cur.nodeType;v4484=TypeScript.NodeType;v4484=v4484.Asg;if(parent=parent>=v4484)parent=cur.nodeType,v4484=TypeScript.NodeType,v4484=v4484.LastAsg,parent=parent<=v4484;if(parent){walker=cur;if(parent=walker.operand1)parent=walker.operand1,parent=parent.nodeType,v4484=TypeScript.NodeType,v4484=v4484.Name,parent=parent==v4484;parent&&(walker=walker.operand1,walker=walker.sym,defSym(walker,
context))}else if(context=cur.nodeType,parent=TypeScript.NodeType,parent=parent.FuncDecl,context=context==parent)context=walker.options,context.goChildren=!1}return cur}var _this=this,v4503=TypeScript.AstWalkOptions,v4503=JAMScript.new(v4503,[]);v4503.reverseSiblings=!0;var v4504=JAMScript.call(TypeScript.getAstWalkerFactory,TypeScript,[]),v14062=this.bb,v14062=v14062.content;JAMScript.call(v4504.walk,v4504,[v14062,initUseDefPre,null,v4503,useDefContext])}function v969(){for(var v14063=this.top,v14063=
v14063.bitCount,v14063=JAMScript.new(BitVector,[v14063]),i=0,v14064=this.bb,v14064=v14064.successors,v14064=v14064.length,v4511=i<v14064;v4511;){v4511=this.bb;v4511=v4511.successors;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v4511=v4511[i];var v4510=v4511.useDef;v4510&&(v4511=v4511.useDef,v4511=v4511.top,JAMScript.call(v14063.union,v14063,[v4511]));i+=1;v4511=i<v14064}i=this.kill;JAMScript.call(v14063.difference,v14063,[i]);i=this.gen;JAMScript.call(v14063.union,
v14063,[i]);i=this.top;i=JAMScript.call(v14063.notEq,v14063,[i]);this.top=v14063;return i}function BBUseDefInfo(bb){this.bb=bb;this.defsBySymbol=bb=[];this.useIndexBySymbol=bb=[]}var v4515=BBUseDefInfo.prototype;v4515.updateTop=v969;v4515=BBUseDefInfo.prototype;v4515.initialize=v970;v4515=BBUseDefInfo.prototype;v4515.initializeGen=v971;v4515=BBUseDefInfo.prototype;v4515.initializeKill=v972;return BBUseDefInfo}function v968(){function ScopeChain(container,previous,scope){this.container=container;this.previous=
previous;this.scope=scope}return ScopeChain}var ScopeChain=v968();TypeScript.ScopeChain=ScopeChain;var BBUseDefInfo=v973();TypeScript.BBUseDefInfo=BBUseDefInfo;var UseDefContext=v979();TypeScript.UseDefContext=UseDefContext;var BitVector=v986();TypeScript.BitVector=BitVector;var BasicBlock=v990();TypeScript.BasicBlock=BasicBlock;BasicBlock=v1008();TypeScript.ControlFlowContext=BasicBlock;var ResolutionDataCache=v1011();TypeScript.ResolutionDataCache=ResolutionDataCache;BasicBlock=v1112();TypeScript.TypeFlow=
BasicBlock}
function v967(){var TypeScript=v12364;function v966(){function Continuation(normalBlock){this.normalBlock=normalBlock;this.exceptionBlock=-1}return Continuation}function getBaseTypeLinks(bases,baseTypeLinks){if(bases){var v4519=bases.members,v4519=v4519.length,v4520=null==baseTypeLinks;v4520&&(baseTypeLinks=[]);for(var v4520=0,v4524=v4520<v4519;v4524;){v4524=bases.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v4524=v4524[v4520];var v4522=TypeScript.TypeLink,v4522=
JAMScript.new(v4522,[]);v4522.ast=v4524;v4524=baseTypeLinks.length;JAMScript.set(baseTypeLinks,v4524,v4522);v4520+=1;v4524=v4520<v4519}}return baseTypeLinks}function getBases(type,typeDecl){var v4525=type,v14067=typeDecl.extendsList,v14068=type.extendsTypeLinks,v14067=getBaseTypeLinks(v14067,v14068);v4525.extendsTypeLinks=v14067;v4525=type;v14067=typeDecl.implementsList;v14068=type.implementsTypeLinks;v14067=getBaseTypeLinks(v14067,v14068);v4525.implementsTypeLinks=v14067}function createNewConstructGroupForType(type){var v4527=
TypeScript.Signature,v4528=v4527=JAMScript.new(v4527,[]),v14071=TypeScript.TypeLink,v14071=JAMScript.new(v14071,[]);v4528.returnType=v14071;v4528=v4527.returnType;v4528.type=type.instanceType;v4527.parameters=[];v4528=type;v14071=TypeScript.SignatureGroup;v14071=JAMScript.new(v14071,[]);v4528.construct=v14071;type=type.construct;JAMScript.call(type.addSignature,type,[v4527])}function cloneParentConstructGroupForChildType(child,parent){var v4532=child,v14073=TypeScript.SignatureGroup,v14073=JAMScript.new(v14073,
[]);v4532.construct=v14073;v14073=null;v4532=parent.construct;(v4532=!v4532)&&createNewConstructGroupForType(parent);v4532=0;v14073=parent.construct;v14073=v14073.signatures;v14073=v14073.length;for(v14073=v4532<v14073;v14073;){var v14073=TypeScript.Signature,v14073=JAMScript.new(v14073,[]),v19828=parent.construct,v19828=v19828.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v19828=v19828[v4532];v14073.parameters=v19828.parameters;v19828=parent.construct;
v19828=v19828.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v19828=v19828[v4532];v14073.nonOptionalParameterCount=v19828.nonOptionalParameterCount;v19828=parent.construct;v19828=v19828.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v19828=v19828[v4532];v14073.typeCheckStatus=v19828.typeCheckStatus;v19828=parent.construct;v19828=v19828.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v19828=
v19828[v4532];v14073.declAST=v19828.declAST;var v19828=v14073,v14080=TypeScript.TypeLink,v14080=JAMScript.new(v14080,[]);v19828.returnType=v14080;v19828=v14073.returnType;v19828.type=child.instanceType;v19828=child.construct;JAMScript.call(v19828.addSignature,v19828,[v14073]);v4532+=1;v14073=parent.construct;v14073=v14073.signatures;v14073=v14073.length;v14073=v4532<v14073}}function findTypeSymbolInScopeChain(name,scopeChain){var v4543=scopeChain.scope,v4543=JAMScript.call(v4543.find,v4543,[name,
!1,!0]),v14082=null==v4543;v14082&&(v14082=scopeChain.previous);v14082&&(v4543=scopeChain.previous,v4543=findTypeSymbolInScopeChain(name,v4543));return v4543}function findSymbolFromAlias(alias,context){function v965(id){if(id=context.members)return id=context.members,JAMScript.call(id.lookup,id,[name]);id=context.topLevelScope;return findTypeSymbolInScopeChain(name,id)}var symbol=null,v4554=alias.nodeType;switch(v4554){case TypeScript.NodeType.Name:var name=alias.text,v4554=JAMScript.call(TypeScript.isQuoted,
TypeScript,[name]),symbol=v965;if(v4554)var v4554=context.tcContext,v4554=v4554.checker,v23367=context.tcContext,v23367=v23367.script,v23367=v23367.locationInfo,v23367=v23367.filename,symbol=JAMScript.call(v4554.findSymbolForDynamicModule,v4554,[name,v23367,symbol]);else symbol=JAMScript.call(symbol,null,[name]);break;case TypeScript.NodeType.Dot:var v4554=alias,v23367=v4554.operand1,v14085=v23367=findSymbolFromAlias(v23367,context);v14085&&(v14085=JAMScript.call(v23367.getType,v23367,[]));if(v23367=
v14085)symbol=v4554.operand2,symbol=findSymbolFromAlias(symbol,context)}symbol&&(v4554=JAMScript.call(symbol.getType,symbol,[]))&&(v4554=v4554.members)&&(context.members=v4554.publicMembers);return symbol}function preCollectImportTypes(ast,parent,context){parent=context.scopeChain;var typeSymbol=null,typeSymbol=null,importDecl=ast,v4555=importDecl.alias,v4556={topLevelScope:parent,members:null,tcContext:context},v4556=findSymbolFromAlias(v4555,v4556),v4555=context.scopeChain,v4555=v4555.container,
v14087=context.checker,v14087=v14087.gloMod,v4555=v4555==v14087;v4556&&(v4556=JAMScript.call(v4556.getType,v4556,[]))&&(typeSymbol=v4556);var v4556=TypeScript.TypeSymbol,v14087=importDecl.id,v14087=v14087.text,v14089=importDecl.id,v14089=v14089.minChar,v14090=importDecl.limChar,v14091=importDecl.minChar,v14090=v14090-v14091,v14091=context.checker,v14091=v14091.locationInfo,v14091=v14091.unitIndex,typeSymbol=JAMScript.new(v4556,[v14087,v14089,v14090,v14091,typeSymbol]);typeSymbol.aliasLink=importDecl;
v4556=context.scopeChain;if(v4556=v4556.moduleDecl)v4556=typeSymbol.flags,v14087=TypeScript.SymbolFlags,v14087=v14087.ModuleMember,typeSymbol.flags=v4556|v14087,v4556=context.scopeChain,typeSymbol.declModule=v4556.moduleDecl;typeSymbol.declAST=importDecl;importDecl=importDecl.id;importDecl.sym=typeSymbol;importDecl=parent.scope;v4556=parent.container;v14087=context.checker;v14087=v14087.errorReporter;JAMScript.call(importDecl.enter,importDecl,[v4556,ast,typeSymbol,v14087,v4555,!0,!1]);importDecl=
parent.scope;parent=parent.container;context=context.checker;context=context.errorReporter;JAMScript.call(importDecl.enter,importDecl,[parent,ast,typeSymbol,context,v4555,!1,!1]);return!0}function preCollectModuleTypes(ast,parent,context){var scopeChain=context.scopeChain,moduleDecl=ast,v4573=moduleDecl.modFlags,v14098=TypeScript.ModuleFlags,v4574=v14098.Ambient,isAmbient=JAMScript.call(TypeScript.hasFlag,TypeScript,[v4573,v4574]),v4575=moduleDecl.modFlags,v14099=TypeScript.ModuleFlags,v4576=v14099.IsEnum,
isEnum=JAMScript.call(TypeScript.hasFlag,TypeScript,[v4575,v4576]),v14100=context.scopeChain,v4577=v14100.container,v14101=context.checker,v4578=v14101.gloMod,isGlobal=v4577==v4578,v4579=moduleDecl.modFlags,v14102=TypeScript.ModuleFlags,v4580=v14102.Exported,isExported=JAMScript.call(TypeScript.hasFlag,TypeScript,[v4579,v4580]),v4581=moduleDecl.name,modName=v4581.text;JAMScript.call(TypeScript.isQuoted,TypeScript,[modName]);var v4582=scopeChain.scope,symbol=JAMScript.call(v4582.findLocal,v4582,[modName,
!1,!1]),typeSymbol=null,modType=null,v14103=null==symbol,v19838=!v14103;if(v19838)var v19836=JAMScript.call(symbol.kind,symbol,[]),v23368=TypeScript.SymbolKind,v19837=v23368.Type,v14103=v19836!=v19837;var v4629=v14103;if(v4629){var v4590=null==modType;if(v4590){var v4583=TypeScript.ScopedMembers,v14104=TypeScript.DualStringHashTable,v19839=TypeScript.StringHashTable,v14105=JAMScript.new(v19839,[]),v19840=TypeScript.StringHashTable,v14106=JAMScript.new(v19840,[]),v4584=JAMScript.new(v14104,[v14105,
v14106]),enclosedTypes=JAMScript.new(v4583,[v4584]),v4585=TypeScript.ScopedMembers,v14107=TypeScript.DualStringHashTable,v19841=TypeScript.StringHashTable,v14108=JAMScript.new(v19841,[]),v19842=TypeScript.StringHashTable,v14109=JAMScript.new(v19842,[]),v4586=JAMScript.new(v14107,[v14108,v14109]),ambientEnclosedTypes=JAMScript.new(v4585,[v4586]),v4587=TypeScript.ModuleType,modType=JAMScript.new(v4587,[enclosedTypes,ambientEnclosedTypes]);if(isEnum){var v14110=modType.typeFlags,v19843=TypeScript.TypeFlags,
v14111=v19843.IsEnum;modType.typeFlags=v14110|v14111}var v4588=modType,v14112=TypeScript.ScopedMembers,v19844=TypeScript.DualStringHashTable,v23369=TypeScript.StringHashTable,v19845=JAMScript.new(v23369,[]),v23370=TypeScript.StringHashTable,v19846=JAMScript.new(v23370,[]),v14113=JAMScript.new(v19844,[v19845,v19846]),v26924=JAMScript.new(v14112,[v14113]);v4588.members=v26924;var v4589=modType,v14114=TypeScript.ScopedMembers,v19847=TypeScript.DualStringHashTable,v23371=TypeScript.StringHashTable,v19848=
JAMScript.new(v23371,[]),v23372=TypeScript.StringHashTable,v19849=JAMScript.new(v23372,[]),v14115=JAMScript.new(v19847,[v19848,v19849]),v26925=JAMScript.new(v14114,[v14115]);v4589.ambientMembers=v26925;JAMScript.call(modType.setHasImplementation,modType,[])}var v4591=TypeScript.TypeSymbol,v14116=moduleDecl.name,v4592=v14116.minChar,v4593=modName.length,v19850=context.checker,v14117=v19850.locationInfo,v4594=v14117.unitIndex,v4595=typeSymbol=JAMScript.new(v4591,[modName,v4592,v4593,v4594,modType]),
v14118=moduleDecl.prettyName,v26926=JAMScript.call(TypeScript.isQuoted,TypeScript,[v14118]);v4595.isDynamic=v26926;var v14119=context.scopeChain,v4597=v14119.moduleDecl;if(v4597){var v4596=context.scopeChain;typeSymbol.declModule=v4596.moduleDecl}typeSymbol.declAST=moduleDecl;typeSymbol.prettyName=moduleDecl.prettyName;var v4598=scopeChain.scope,v4599=scopeChain.container,v14120=context.checker,v4600=v14120.errorReporter,v4601=isExported||isGlobal;JAMScript.call(v4598.enter,v4598,[v4599,ast,typeSymbol,
v4600,v4601,!0,isAmbient]);var v4602=scopeChain.scope,v4603=scopeChain.container,v14121=context.checker,v4604=v14121.errorReporter,v4605=isExported||isGlobal;JAMScript.call(v4602.enter,v4602,[v4603,ast,typeSymbol,v4604,v4605,!1,isAmbient]);modType.symbol=typeSymbol}else{var v14122=symbol;if(v14122){var v19851=symbol.declAST;if(v19851)var v25037=symbol.declAST,v23373=v25037.nodeType,v25038=TypeScript.NodeType,v23374=v25038.ModuleDeclaration,v19851=v23373!=v23374;v14122=v19851}var v4608=v14122;if(v4608){var v14123=
context.checker,v4606=v14123.errorReporter,v14124="Conflicting symbol name for module '"+modName,v4607=v14124+"'";JAMScript.call(v4606.simpleError,v4606,[moduleDecl,v4607])}var typeSymbol=symbol,v14125=typeSymbol.type,v4609=JAMScript.call(v14125.getAllEnclosedTypes,v14125,[]),publicEnclosedTypes=v4609.publicMembers,v4610,v14127=null==publicEnclosedTypes;if(v14127){var v14126=TypeScript.StringHashTable;v4610=JAMScript.new(v14126,[])}else v4610=publicEnclosedTypes;var publicEnclosedTypesTable=v4610,
v4611=TypeScript.ScopedMembers,v14128=TypeScript.DualStringHashTable,v19852=TypeScript.StringHashTable,v14129=JAMScript.new(v19852,[]),v4612=JAMScript.new(v14128,[publicEnclosedTypesTable,v14129]),enclosedTypes=JAMScript.new(v4611,[v4612]),v14130=typeSymbol.type,v4613=JAMScript.call(v14130.getAllAmbientEnclosedTypes,v14130,[]),publicEnclosedAmbientTypes=v4613.publicMembers,v4614,v14132=null==publicEnclosedAmbientTypes;if(v14132){var v14131=TypeScript.StringHashTable;v4614=JAMScript.new(v14131,[])}else v4614=
publicEnclosedAmbientTypes;var publicAmbientEnclosedTypesTable=v4614,v4615=TypeScript.ScopedMembers,v14133=TypeScript.DualStringHashTable,v19853=TypeScript.StringHashTable,v14134=JAMScript.new(v19853,[]),v4616=JAMScript.new(v14133,[publicAmbientEnclosedTypesTable,v14134]),ambientEnclosedTypes=JAMScript.new(v4615,[v4616]),v14135=typeSymbol.type,v4617=v14135.members,publicMembers=v4617.publicMembers,v4618,v14137=null==publicMembers;if(v14137){var v14136=TypeScript.StringHashTable;v4618=JAMScript.new(v14136,
[])}else v4618=publicMembers;var publicMembersTable=v4618,v4619=TypeScript.ScopedMembers,v14138=TypeScript.DualStringHashTable,v19854=TypeScript.StringHashTable,v14139=JAMScript.new(v19854,[]),v4620=JAMScript.new(v14138,[publicMembersTable,v14139]),members=JAMScript.new(v4619,[v4620]),v14140=typeSymbol.type,v4621=v14140.ambientMembers,publicAmbientMembers=v4621.publicMembers,v4622,v14142=null==publicAmbientMembers;if(v14142){var v14141=TypeScript.StringHashTable;v4622=JAMScript.new(v14141,[])}else v4622=
publicAmbientMembers;var publicAmbientMembersTable=v4622,v4623=TypeScript.ScopedMembers,v14143=TypeScript.DualStringHashTable,v19855=TypeScript.StringHashTable,v14144=JAMScript.new(v19855,[]),v4624=JAMScript.new(v14143,[publicAmbientMembersTable,v14144]),ambientMembers=JAMScript.new(v4623,[v4624]),v4625=TypeScript.ModuleType,modType=JAMScript.new(v4625,[enclosedTypes,ambientEnclosedTypes]);if(isEnum){var v14145=modType.typeFlags,v19856=TypeScript.TypeFlags,v14146=v19856.IsEnum;modType.typeFlags=v14145|
v14146}modType.members=members;modType.ambientMembers=ambientMembers;JAMScript.call(modType.setHasImplementation,modType,[]);modType.symbol=typeSymbol;var v4626=moduleDecl.minChar;JAMScript.call(typeSymbol.addLocation,typeSymbol,[v4626]);var v4627=typeSymbol.expansions;JAMScript.call(v4627.push,v4627,[modType]);var v4628=typeSymbol.expansionsDeclAST;JAMScript.call(v4628.push,v4628,[moduleDecl])}var v14147=context.scopeChain,v4631=v14147.moduleDecl;if(v4631){var v14148=context.scopeChain,v4630=v14148.moduleDecl;
JAMScript.call(v4630.recordNonInterface,v4630,[])}if(isExported){var v14149=typeSymbol.flags,v19857=TypeScript.SymbolFlags,v14150=v19857.Exported;typeSymbol.flags=v14149|v14150}var v19858=context.scopeChain,v14151=v19858.moduleDecl,v19861=!v14151;if(v19861)var v23375=context.scopeChain,v19859=v23375.container,v23376=context.checker,v19860=v23376.gloMod,v14151=v19859==v19860;var v4632=v14151;if(v4632){var v14152=typeSymbol.flags,v19862=TypeScript.SymbolFlags,v14153=v19862.ModuleMember;typeSymbol.flags=
v14152|v14153}moduleDecl.mod=modType;var v4633=modType.members,v4634=modType.ambientMembers,v4635=modType.enclosedTypes,v4636=modType.ambientEnclosedTypes;JAMScript.call(TypeScript.pushTypeCollectionScope,TypeScript,[typeSymbol,v4633,v4634,v4635,v4636,context,null,null,moduleDecl]);return!0}function preCollectClassTypes(ast,parent,context){var scopeChain=context.scopeChain,classDecl=ast,classType,instanceType,typeSymbol=null,v4637=classDecl.name,className=v4637.text,v4638=classDecl.varFlags,v14154=
TypeScript.VarFlags,v4639=v14154.Ambient,isAmbient=JAMScript.call(TypeScript.hasFlag,TypeScript,[v4638,v4639]),v4640=classDecl.varFlags,v14155=TypeScript.VarFlags,v4641=v14155.Exported,isExported=JAMScript.call(TypeScript.hasFlag,TypeScript,[v4640,v4641]),v14156=context.scopeChain,v4642=v14156.container,v14157=context.checker,v4643=v14157.gloMod,isGlobal=v4642==v4643,foundValSymbol=!1,v4644=scopeChain.scope,typeSymbol=JAMScript.call(v4644.findLocal,v4644,[className,!1,!0]),v4651=!typeSymbol;if(v4651){var v4645=
scopeChain.scope,valTypeSymbol=JAMScript.call(v4645.findLocal,v4645,[className,!1,!1]),v14158=valTypeSymbol;if(v14158){var v19863=JAMScript.call(valTypeSymbol.isType,valTypeSymbol,[]);if(v19863){var v23377=valTypeSymbol.declAST;if(v23377){var v26320=valTypeSymbol.declAST,v25869=v26320.nodeType,v26321=TypeScript.NodeType,v25870=v26321.FuncDecl,v25039=v25869==v25870;if(v25039)var v25871=valTypeSymbol.declAST,v25039=JAMScript.call(v25871.isSignature,v25871,[]);v23377=v25039}v19863=v23377}v14158=v19863}var v4650=
v14158;if(v4650){typeSymbol=valTypeSymbol;foundValSymbol=!0;if(isExported){var v14159=typeSymbol.flags,v19864=TypeScript.SymbolFlags,v14160=v19864.Exported;typeSymbol.flags=v14159|v14160}if(isAmbient){var v14161=typeSymbol.flags,v19865=TypeScript.SymbolFlags,v14162=v19865.Ambient;typeSymbol.flags=v14161|v14162}var v14163=context.scopeChain,v4646=v14163.scope,v14164=context.scopeChain,v4647=v14164.container,v14165=context.checker,v4648=v14165.errorReporter,v4649=isExported||isGlobal;JAMScript.call(v4646.enter,
v4646,[v4647,ast,typeSymbol,v4648,v4649,!0,isAmbient])}}var v14166=typeSymbol;if(v14166){var v19866=!foundValSymbol;if(v19866)var v23378=typeSymbol.declAST,v19866=v23378!=classDecl;v14166=v19866}var v4652=v14166;v4652&&(typeSymbol=null);var v4691=null==typeSymbol;if(v4691){var v4653=scopeChain.scope,valueSymbol=JAMScript.call(v4653.findLocal,v4653,[className,!1,!1]),v4654=TypeScript.Type;classType=JAMScript.new(v4654,[]);JAMScript.call(classType.setHasImplementation,classType,[]);var v4655=TypeScript.Type;
instanceType=JAMScript.new(v4655,[]);JAMScript.call(instanceType.setHasImplementation,instanceType,[]);classType.instanceType=instanceType;var v4656=classType,v14167=TypeScript.ScopedMembers,v19867=TypeScript.DualStringHashTable,v23379=TypeScript.StringHashTable,v19868=JAMScript.new(v23379,[]),v23380=TypeScript.StringHashTable,v19869=JAMScript.new(v23380,[]),v14168=JAMScript.new(v19867,[v19868,v19869]),v26927=JAMScript.new(v14167,[v14168]);v4656.members=v26927;var v4657=classType,v14169=TypeScript.ScopedMembers,
v19870=TypeScript.DualStringHashTable,v23381=TypeScript.StringHashTable,v19871=JAMScript.new(v23381,[]),v23382=TypeScript.StringHashTable,v19872=JAMScript.new(v23382,[]),v14170=JAMScript.new(v19870,[v19871,v19872]),v26928=JAMScript.new(v14169,[v14170]);v4657.ambientMembers=v26928;var classType$$0=classType,ast$$0=classDecl,context$$0=context,v4658=TypeScript.ValueLocation,field=JAMScript.new(v4658,[]),v4659=field,v14171=TypeScript.TypeLink,v26929=JAMScript.new(v14171,[]);v4659.typeLink=v26929;var v4660=
field.typeLink;v4660.ast=ast$$0;var v4661=field.typeLink;v4661.type=classType$$0.instanceType;var v4662=TypeScript.FieldSymbol,v4663=ast$$0.minChar,v19873=context$$0.checker,v14172=v19873.locationInfo,v4664=v14172.unitIndex,fieldSymbol=JAMScript.new(v4662,["prototype",v4663,v4664,!0,field]),v14173=fieldSymbol.flags,v23383=TypeScript.SymbolFlags,v19874=v23383.Property,v23384=TypeScript.SymbolFlags,v19875=v23384.BuiltIn,v14174=v19874|v19875;fieldSymbol.flags=v14173|v14174;field.symbol=fieldSymbol;fieldSymbol.declAST=
ast$$0;var v4665=classType$$0.members;JAMScript.call(v4665.addPublicMember,v4665,["prototype",fieldSymbol]);var v4666=instanceType,v14175=TypeScript.ScopedMembers,v19876=TypeScript.DualStringHashTable,v23385=TypeScript.StringHashTable,v19877=JAMScript.new(v23385,[]),v23386=TypeScript.StringHashTable,v19878=JAMScript.new(v23386,[]),v14176=JAMScript.new(v19876,[v19877,v19878]),v26930=JAMScript.new(v14175,[v14176]);v4666.members=v26930;var v4667=instanceType,v14177=TypeScript.ScopedMembers,v19879=TypeScript.DualStringHashTable,
v23387=TypeScript.StringHashTable,v19880=JAMScript.new(v23387,[]),v23388=TypeScript.StringHashTable,v19881=JAMScript.new(v23388,[]),v14178=JAMScript.new(v19879,[v19880,v19881]),v26931=JAMScript.new(v14177,[v14178]);v4667.ambientMembers=v26931;var v4668=TypeScript.TypeSymbol,v14179=classDecl.name,v4669=v14179.minChar,v4670=className.length,v19882=context.checker,v14180=v19882.locationInfo,v4671=v14180.unitIndex,typeSymbol=JAMScript.new(v4668,[className,v4669,v4670,v4671,classType]);typeSymbol.declAST=
classDecl;typeSymbol.instanceType=instanceType;classType.symbol=typeSymbol;instanceType.symbol=typeSymbol;var v14181=context.scopeChain,v4674=v14181.moduleDecl;if(v4674){var v14182=context.scopeChain,v4672=v14182.moduleDecl;JAMScript.call(v4672.recordNonInterface,v4672,[]);var v4673=context.scopeChain;typeSymbol.declModule=v4673.moduleDecl;var v14183=typeSymbol.flags,v19883=TypeScript.SymbolFlags,v14184=v19883.ModuleMember;typeSymbol.flags=v14183|v14184}if(isExported){var v14185=typeSymbol.flags,
v19884=TypeScript.SymbolFlags,v14186=v19884.Exported;typeSymbol.flags=v14185|v14186}if(isAmbient){var v14187=typeSymbol.flags,v19885=TypeScript.SymbolFlags,v14188=v19885.Ambient;typeSymbol.flags=v14187|v14188}ast.type=classType;var v14189=context.scopeChain,v4675=v14189.scope,v14190=context.scopeChain,v4676=v14190.container,v14191=context.checker,v4677=v14191.errorReporter,v4678=isExported||isGlobal;JAMScript.call(v4675.enter,v4675,[v4676,ast,typeSymbol,v4677,v4678,!0,isAmbient]);var v4683=null==
valueSymbol;if(v4683){var v14192=context.scopeChain,v4679=v14192.scope,v14193=context.scopeChain,v4680=v14193.container,v14194=context.checker,v4681=v14194.errorReporter,v4682=isExported||isGlobal;JAMScript.call(v4679.enter,v4679,[v4680,ast,typeSymbol,v4681,v4682,!1,isAmbient])}}else{classType=typeSymbol.type;var v14195=classType.instanceType,v4690=null==v14195;if(v4690){var v4684=classType,v14196=TypeScript.Type,v26932=JAMScript.new(v14196,[]);v4684.instanceType=v26932;var v4685=classType.instanceType;
JAMScript.call(v4685.setHasImplementation,v4685,[]);var v4686=classType.instanceType,v14197=TypeScript.ScopedMembers,v19886=TypeScript.DualStringHashTable,v23389=TypeScript.StringHashTable,v19887=JAMScript.new(v23389,[]),v23390=TypeScript.StringHashTable,v19888=JAMScript.new(v23390,[]),v14198=JAMScript.new(v19886,[v19887,v19888]),v26933=JAMScript.new(v14197,[v14198]);v4686.members=v26933;var v4687=classType.instanceType;v4687.symbol=classType.symbol;var v4688=classType,v14199=TypeScript.ScopedMembers,
v19889=TypeScript.DualStringHashTable,v23391=TypeScript.StringHashTable,v19890=JAMScript.new(v23391,[]),v23392=TypeScript.StringHashTable,v19891=JAMScript.new(v23392,[]),v14200=JAMScript.new(v19889,[v19890,v19891]),v26934=JAMScript.new(v14199,[v14200]);v4688.members=v26934;var v4689=classType,v14201=TypeScript.ScopedMembers,v19892=TypeScript.DualStringHashTable,v23393=TypeScript.StringHashTable,v19893=JAMScript.new(v23393,[]),v23394=TypeScript.StringHashTable,v19894=JAMScript.new(v23394,[]),v14202=
JAMScript.new(v19892,[v19893,v19894]),v26935=JAMScript.new(v14201,[v14202]);v4689.ambientMembers=v26935}instanceType=classType.instanceType;ast.type=classType}var v14203=classDecl.constructorDecl,v4697=!v14203;if(v4697){var v14204=typeSymbol;if(v14204){var v19895=typeSymbol.declAST;if(v19895){var v25040=typeSymbol.declAST,v23395=v25040.type;if(v23395){var v26322=typeSymbol.declAST,v25872=v26322.type,v25041=v25872.call;if(v25041)var v26323=typeSymbol.declAST,v25873=v26323.isOverload,v25041=!v25873;
v23395=v25041}v19895=v23395}v14204=v19895}var v4695=v14204;if(v4695){var v14205=context.checker,v4692=v14205.errorReporter,v4693=typeSymbol.declAST,v4694=typeSymbol.name;JAMScript.call(v4692.duplicateIdentifier,v4692,[v4693,v4694])}var v4696=classDecl.type;createNewConstructGroupForType(v4696)}var v14206=classType.typeFlags,v19896=TypeScript.TypeFlags,v14207=v19896.IsClass;classType.typeFlags=v14206|v14207;var v14208=instanceType.typeFlags,v19897=TypeScript.TypeFlags,v14209=v19897.IsClass;instanceType.typeFlags=
v14208|v14209;getBases(instanceType,classDecl);var v4698=instanceType.members,v4699=instanceType.ambientMembers;JAMScript.call(TypeScript.pushTypeCollectionScope,TypeScript,[typeSymbol,v4698,v4699,null,null,context,instanceType,classType,null]);return!0}function preCollectInterfaceTypes(ast,parent,context){var scopeChain=context.scopeChain,interfaceDecl=ast,interfaceSymbol=null,interfaceType=null;parent=interfaceDecl.varFlags;var v14210=TypeScript.VarFlags,v14210=v14210.Exported;parent=JAMScript.call(TypeScript.hasFlag,
TypeScript,[parent,v14210]);var v14210=context.scopeChain,v14210=v14210.container,interfaceType=context.checker,interfaceType=interfaceType.gloMod,v14210=v14210==interfaceType,alreadyInScope=!0,alreadyInScope=!1,interfaceType=interfaceDecl.name,interfaceName=interfaceType.text,interfaceType=scopeChain.scope,interfaceSymbol=JAMScript.call(interfaceType.findLocal,interfaceType,[interfaceName,!1,!0]);if(interfaceType=null==interfaceSymbol){var interfaceType=TypeScript.Type,interfaceType=JAMScript.new(interfaceType,
[]),interfaceSymbol=TypeScript.TypeSymbol,scopeChain=interfaceDecl.name,scopeChain=scopeChain.minChar,v4709=interfaceName.length,v19898=context.checker,v19898=v19898.locationInfo,v19898=v19898.unitIndex,interfaceSymbol=JAMScript.new(interfaceSymbol,[interfaceName,scopeChain,v4709,v19898,interfaceType]);interfaceType.symbol=interfaceSymbol;var interfaceName=interfaceType,scopeChain=TypeScript.ScopedMembers,v4709=TypeScript.DualStringHashTable,v19898=TypeScript.StringHashTable,v19898=JAMScript.new(v19898,
[]),v23397=TypeScript.StringHashTable,v23397=JAMScript.new(v23397,[]),v4709=JAMScript.new(v4709,[v19898,v23397]),scopeChain=JAMScript.new(scopeChain,[v4709]);interfaceName.members=scopeChain;interfaceName=interfaceType;scopeChain=TypeScript.ScopedMembers;v4709=TypeScript.DualStringHashTable;v19898=TypeScript.StringHashTable;v19898=JAMScript.new(v19898,[]);v23397=TypeScript.StringHashTable;v23397=JAMScript.new(v23397,[]);v4709=JAMScript.new(v4709,[v19898,v23397]);scopeChain=JAMScript.new(scopeChain,
[v4709]);interfaceName.ambientMembers=scopeChain;interfaceSymbol.declAST=interfaceDecl;interfaceName=context.scopeChain;interfaceSymbol.declModule=interfaceName.moduleDecl}else alreadyInScope=!0,interfaceType=interfaceSymbol.type;if(interfaceName=!interfaceType)interfaceType=context.checker,interfaceType=interfaceType.anyType;ast.type=interfaceType;getBases(interfaceType,interfaceDecl);parent&&(interfaceDecl=interfaceSymbol.flags,interfaceName=TypeScript.SymbolFlags,interfaceName=interfaceName.Exported,
interfaceSymbol.flags=interfaceDecl|interfaceName);interfaceDecl=context.scopeChain;if(interfaceDecl=interfaceDecl.moduleDecl)interfaceDecl=interfaceSymbol.flags,interfaceName=TypeScript.SymbolFlags,interfaceName=interfaceName.ModuleMember,interfaceSymbol.flags=interfaceDecl|interfaceName;if(alreadyInScope=!alreadyInScope)alreadyInScope=context.scopeChain,alreadyInScope=alreadyInScope.scope,interfaceDecl=context.scopeChain,interfaceDecl=interfaceDecl.container,interfaceName=context.checker,interfaceName=
interfaceName.errorReporter,parent=v14210||parent,JAMScript.call(alreadyInScope.enter,alreadyInScope,[interfaceDecl,ast,interfaceSymbol,interfaceName,parent,!0,!1]);ast=interfaceType.members;parent=interfaceType.ambientMembers;JAMScript.call(TypeScript.pushTypeCollectionScope,TypeScript,[interfaceSymbol,ast,parent,null,null,context,interfaceType,null,null]);return!0}function preCollectArgDeclTypes(ast,parent,context){parent=ast;var v14227=parent.varFlags,v23400=TypeScript.VarFlags,v23400=v23400.Public,
v23401=TypeScript.VarFlags,v23401=v23401.Private,v23400=v23400|v23401;if(v14227=JAMScript.call(TypeScript.hasFlag,TypeScript,[v14227,v23400])){var v14227=TypeScript.ValueLocation,v14227=JAMScript.new(v14227,[]),v23400=parent.varFlags,v23401=TypeScript.VarFlags,v23401=v23401.Private,v23400=JAMScript.call(TypeScript.hasFlag,TypeScript,[v23400,v23401]),v23401=TypeScript.FieldSymbol,v14230=parent.id,v14230=v14230.text,v14231=parent.id,v14231=v14231.minChar,v19909=context.checker,v19909=v19909.locationInfo,
v19909=v19909.unitIndex,v19910=parent.varFlags,v23402=TypeScript.VarFlags,v23402=v23402.Readonly,v19910=JAMScript.call(TypeScript.hasFlag,TypeScript,[v19910,v23402]),v19910=!v19910,v23401=JAMScript.new(v23401,[v14230,v14231,v19909,v19910,v14227]),v14230=parent.varFlags;JAMScript.call(v23401.transferVarFlags,v23401,[v14230]);v14227.symbol=v23401;v23401.declAST=ast;parent.parameterPropertySym=v23401;v14230=context.scopeChain;v14230=v14230.scope;v14231=context.scopeChain;v14231=v14231.container;v19909=
context.checker;v19909=v19909.errorReporter;v23400=!v23400;JAMScript.call(v14230.enter,v14230,[v14231,ast,v23401,v19909,v23400,!1,!1]);ast=v14227;v14227=parent.typeExpr;context=context.checker;v23400=parent.init;v23400=null==v23400;context=JAMScript.call(TypeScript.getTypeLink,TypeScript,[v14227,context,v23400]);ast.typeLink=context;parent.sym=v23401}return!1}function preCollectVarDeclTypes(ast,parent,context){var scopeChain=context.scopeChain,varDecl=ast,v4740=varDecl.varFlags,v14240=TypeScript.VarFlags,
v4741=v14240.Ambient,isAmbient=JAMScript.call(TypeScript.hasFlag,TypeScript,[v4740,v4741]),v4742=varDecl.varFlags,v14241=TypeScript.VarFlags,v4743=v14241.Exported,isExported=JAMScript.call(TypeScript.hasFlag,TypeScript,[v4742,v4743]),v14242=context.scopeChain,v4744=v14242.container,v14243=context.checker,v4745=v14243.gloMod,isGlobal=v4744==v4745,v4746=varDecl.varFlags,v14244=TypeScript.VarFlags,v4747=v14244.Property,isProperty=JAMScript.call(TypeScript.hasFlag,TypeScript,[v4746,v4747]),v4748=varDecl.varFlags,
v14245=TypeScript.VarFlags,v4749=v14245.Static,isStatic=JAMScript.call(TypeScript.hasFlag,TypeScript,[v4748,v4749]),v4750=varDecl.varFlags,v14246=TypeScript.VarFlags,v4751=v14246.Private,isPrivate=JAMScript.call(TypeScript.hasFlag,TypeScript,[v4750,v4751]),v14247=varDecl.id,v4752=v14247.flags,v14248=TypeScript.ASTFlags,v4753=v14248.OptionalName,isOptional=JAMScript.call(TypeScript.hasFlag,TypeScript,[v4752,v4753]),v14249=context.scopeChain,v4755=v14249.moduleDecl;if(v4755){var v14250=context.scopeChain,
v4754=v14250.moduleDecl;JAMScript.call(v4754.recordNonInterface,v4754,[])}var v14251=isProperty,v19914=!v14251;if(v19914){var v19913=isExported,v23404=!v19913;if(v23404){var v25874=context.scopeChain,v25042=v25874.container,v25875=context.checker,v25043=v25875.gloMod,v23403=v25042==v25043,v25045=!v23403;if(v25045)var v25044=context.scopeChain,v23403=v25044.moduleDecl;v19913=v23403}v14251=v19913}var v4780=v14251;if(v4780){if(isAmbient){var v4756=scopeChain.scope,v14252=varDecl.id,v4757=v14252.text,
existingSym=JAMScript.call(v4756.findLocal,v4756,[v4757,!1,!1]);if(existingSym)return varDecl.sym=existingSym,!1}var v14253=varDecl.id,v4759=null==v14253;if(v4759){var v14254=context.checker,v4758=v14254.errorReporter;JAMScript.call(v4758.simpleError,v4758,[varDecl,"Expected variable identifier at this location"]);return!1}var v4760=TypeScript.ValueLocation,field=JAMScript.new(v4760,[]),v4761=TypeScript.FieldSymbol,v14255=varDecl.id,v4762=v14255.text,v14256=varDecl.id,v4763=v14256.minChar,v19915=
context.checker,v14257=v19915.locationInfo,v4764=v14257.unitIndex,v19916=varDecl.varFlags,v23405=TypeScript.VarFlags,v19917=v23405.Readonly,v14258=v19916&v19917,v19918=TypeScript.VarFlags,v14259=v19918.None,v4765=v14258==v14259,fieldSymbol=JAMScript.new(v4761,[v4762,v4763,v4764,v4765,field]),v4766=varDecl.varFlags;JAMScript.call(fieldSymbol.transferVarFlags,fieldSymbol,[v4766]);if(isOptional){var v14260=fieldSymbol.flags,v19919=TypeScript.SymbolFlags,v14261=v19919.Optional;fieldSymbol.flags=v14260|
v14261}field.symbol=fieldSymbol;fieldSymbol.declAST=ast;var v19920=context.scopeChain,v14262=v19920.moduleDecl,v19923=!v14262;if(v19923)var v23406=context.scopeChain,v19921=v23406.container,v23407=context.checker,v19922=v23407.gloMod,v14262=v19921==v19922;var v4768=v14262;if(v4768){var v14263=fieldSymbol.flags,v19924=TypeScript.SymbolFlags,v14264=v19924.ModuleMember;fieldSymbol.flags=v14263|v14264;var v4767=context.scopeChain;fieldSymbol.declModule=v4767.moduleDecl}var v19925=varDecl.varFlags,v23408=
TypeScript.VarFlags,v19926=v23408.Property,v14265=JAMScript.call(TypeScript.hasFlag,TypeScript,[v19925,v19926]);if(v14265){var v19927=isStatic;if(v19927)var v23409=context.scopeChain,v19927=v23409.classType;v14265=v19927}var v4777=v14265;if(v4777){var v25876=context.scopeChain,v25046=v25876.classType,v23410=v25046.members,v19928=v23410.publicMembers,v23411=varDecl.id,v19929=v23411.text,v14266=JAMScript.call(v19928.add,v19928,[v19929,fieldSymbol]),v4771=!v14266;if(v4771){var v14267=context.checker,
v4769=v14267.errorReporter,v4770=fieldSymbol.name;JAMScript.call(v4769.duplicateIdentifier,v4769,[ast,v4770])}var v14268=context.scopeChain,v4772=v14268.classType;fieldSymbol.container=v4772.symbol}else{var v14269=context.scopeChain,v4773=v14269.scope,v14270=context.scopeChain,v4774=v14270.container,v14271=context.checker,v4775=v14271.errorReporter,v14272=!isPrivate;if(v14272){var v19930=isProperty,v23413=!v19930;if(v23413){var v23412=isExported,v25047=!v23412;v25047&&(v23412=isGlobal||isStatic);
v19930=v23412}v14272=v19930}var v4776=v14272;JAMScript.call(v4773.enter,v4773,[v4774,ast,fieldSymbol,v4775,v4776,!1,isAmbient])}var v14273=varDecl.varFlags,v19931=TypeScript.VarFlags,v14274=v19931.Exported,v4778=JAMScript.call(TypeScript.hasFlag,TypeScript,[v14273,v14274]);if(v4778){var v14275=fieldSymbol.flags,v19932=TypeScript.SymbolFlags,v14276=v19932.Exported;fieldSymbol.flags=v14275|v14276}var v4779=field,v14277=varDecl.typeExpr,v14278=context.checker,v19933=varDecl.init,v14279=null==v19933,
v26939=JAMScript.call(TypeScript.getTypeLink,TypeScript,[v14277,v14278,v14279]);v4779.typeLink=v26939;varDecl.sym=fieldSymbol}return!1}function preCollectFuncDeclTypes(ast,parent,context){var scopeChain=context.scopeChain,v14280=context.scopeChain,v4782=v14280.moduleDecl;if(v4782){var v14281=context.scopeChain,v4781=v14281.moduleDecl;JAMScript.call(v4781.recordNonInterface,v4781,[])}var funcDecl=ast,fgSym=null,nameText=JAMScript.call(funcDecl.getNameText,funcDecl,[]),v4783=funcDecl.fncFlags,v19934=
TypeScript.FncFlags,v14282=v19934.Exported,v19935=TypeScript.FncFlags,v14283=v19935.ClassPropertyMethodExported,v4784=v14282|v14283,isExported=JAMScript.call(TypeScript.hasFlag,TypeScript,[v4783,v4784]),v4785=funcDecl.fncFlags,v14284=TypeScript.FncFlags,v4786=v14284.Static,isStatic=JAMScript.call(TypeScript.hasFlag,TypeScript,[v4785,v4786]),v4787=funcDecl.fncFlags,v14285=TypeScript.FncFlags,v4788=v14285.Private;JAMScript.call(TypeScript.hasFlag,TypeScript,[v4787,v4788]);var v4789=JAMScript.call(funcDecl.isConstructMember,
funcDecl,[]),v14286=!v4789;v14286&&(v4789=funcDecl.isConstructor);var isConstructor=v4789,v4790,v25048=JAMScript.call(funcDecl.isMethod,funcDecl,[]);v25048&&(v25048=isStatic);var v23414=v25048,v25049=!v23414;v25049&&(v23414=JAMScript.call(funcDecl.isAccessor,funcDecl,[]));var v19936=v23414;if(v19936)var v23415=context.scopeChain,v19936=v23415.classType;var v14289=v19936;if(v14289){var v19937=context.scopeChain,v14287=v19937.classType;v4790=v14287.symbol}else{var v14288=context.scopeChain;v4790=v14288.container}var containerSym=
v4790,v4791=context.scopeChain,containerScope=v4791.scope,v4793=funcDecl.name;if(v4793)var v19938=funcDecl.name,v14291=v19938.flags,v19939=TypeScript.ASTFlags,v14292=v19939.OptionalName,v4793=JAMScript.call(TypeScript.hasFlag,TypeScript,[v14291,v14292]);var isOptional=v4793,go=!1,foundSymbol=!1,v14293=isConstructor;if(v14293)var v19940=funcDecl.fncFlags,v23416=TypeScript.FncFlags,v19941=v23416.ClassMethod,v14293=JAMScript.call(TypeScript.hasFlag,TypeScript,[v19940,v19941]);var v4795=v14293;if(v4795)var containerSym=
containerSym.container,v4794=scopeChain.previous,containerScope=v4794.scope;var v14294=context.checker,v4796=v14294.locationInfo;funcDecl.unitIndex=v4796.unitIndex;var v19942=funcDecl.isConstructor,v14295=!v19942;if(v14295){var v19943=containerSym;if(v19943){var v23417=containerSym.declAST;if(v23417){var v26324=containerSym.declAST,v25877=v26324.nodeType,v26325=TypeScript.NodeType,v25878=v26325.FuncDecl,v25050=v25877==v25878;if(v25050){var v26326=containerSym.declAST,v25879=v26326.isConstructor;if(v25879)var v26327=
JAMScript.call(funcDecl.isMethod,funcDecl,[]),v25879=!v26327;v25050=v25879}v23417=v25050}v19943=v23417}v14295=v19943}var v4797=v14295;if(v4797)return go;var v14296=funcDecl.fncFlags,v19944=TypeScript.FncFlags,v14297=v19944.Signature,v4831=JAMScript.call(TypeScript.hasFlag,TypeScript,[v14296,v14297]);if(v4831){var v4798=context.scopeChain,instType=v4798.thisType,v14298=nameText;v14298&&(v14298="__missing"!=nameText);var v4802=v14298;if(v4802){if(isStatic)var v19945=containerSym.type,v14299=v19945.members,
v4799=v14299.allMembers,fgSym=JAMScript.call(v4799.lookup,v4799,[nameText]);else{var fgSym=JAMScript.call(containerScope.findLocal,containerScope,[nameText,!1,!1]),v4800=null==fgSym;v4800&&(fgSym=JAMScript.call(containerScope.findLocal,containerScope,[nameText,!1,!0]))}if(fgSym){var foundSymbol=!0,v19946=JAMScript.call(funcDecl.isSignature,funcDecl,[]),v14300=!v19946;if(v14300)var v23418=funcDecl.fncFlags,v25051=TypeScript.FncFlags,v23419=v25051.Ambient,v19947=JAMScript.call(TypeScript.hasFlag,TypeScript,
[v23418,v23419]),v23420=fgSym.flags,v25052=TypeScript.SymbolFlags,v23421=v25052.Ambient,v19948=JAMScript.call(TypeScript.hasFlag,TypeScript,[v23420,v23421]),v14300=v19947!=v19948;var v4801=v14300;v4801&&(fgSym=null)}}var v4811=null==fgSym;if(v4811){var v14301=JAMScript.call(funcDecl.isSpecialFn,funcDecl,[]),v4805=!v14301;if(v4805)var v23422=context.checker,v23423=!foundSymbol,v19949=JAMScript.call(v23422.createFunctionSignature,v23422,[funcDecl,containerSym,containerScope,null,v23423]),v14302=v19949.declAST,
v4803=v14302.type,fgSym=v4803.symbol;else var v23424=context.checker,v19950=JAMScript.call(v23424.createFunctionSignature,v23424,[funcDecl,containerSym,containerScope,containerSym,!1]),v14303=v19950.declAST,v4804=v14303.type,fgSym=v4804.symbol;var v19951=fgSym.declAST,v14304=null==v19951,v19953=!v14304;if(v19953)var v19952=JAMScript.call(funcDecl.isSpecialFn,funcDecl,[]),v14304=!v19952;var v4806=v14304;v4806&&(fgSym.declAST=ast)}else{var v14305=JAMScript.call(fgSym.kind,fgSym,[]),v19954=TypeScript.SymbolKind,
v14306=v19954.Type,v4810=v14305==v14306;if(v4810)var v23425=context.checker,v19955=JAMScript.call(v23425.createFunctionSignature,v23425,[funcDecl,containerSym,containerScope,fgSym,!1]),v14307=v19955.declAST,v4807=v14307.type,fgSym=v4807.symbol;else{var v14308=context.checker,v4808=v14308.errorReporter,v23426=funcDecl.name,v19956=v23426.actualText,v14309="Function or method '"+v19956,v4809=v14309+"' already declared as a property";JAMScript.call(v4808.simpleError,v4808,[funcDecl,v4809])}}var v14310=
JAMScript.call(funcDecl.isSpecialFn,funcDecl,[]);v14310&&(v14310=!isStatic);var v4813=v14310;if(v4813){var v4812;v4812=instType?instType:fgSym.type;funcDecl.type=v4812}else funcDecl.type=fgSym.type}else{if(nameText){if(isStatic)var v19957=containerSym.type,v14311=v19957.members,v4814=v14311.allMembers,fgSym=JAMScript.call(v4814.lookup,v4814,[nameText]);else{var v14312=funcDecl.isConstructor;if(v14312)var v19958=context.scopeChain,v14312=v19958.previous;var v4816=v14312;if(v4816)var v19959=context.scopeChain,
v14313=v19959.previous,v4815=v14313.scope,fgSym=JAMScript.call(v4815.findLocal,v4815,[nameText,!1,!1]);var v4817=null==fgSym;v4817&&(fgSym=JAMScript.call(containerScope.findLocal,containerScope,[nameText,!1,!1]))}if(fgSym){var foundSymbol=!0,v14314=!isConstructor;if(v14314){var v25053=fgSym.declAST,v23427=v25053.nodeType,v25054=TypeScript.NodeType,v23428=v25054.FuncDecl,v19960=v23427==v23428;if(v19960){var v25880=fgSym.declAST,v25055=JAMScript.call(v25880.isAccessor,v25880,[]),v23429=!v25055;if(v23429)var v25881=
fgSym.declAST,v25056=JAMScript.call(v25881.isSignature,v25881,[]),v23429=!v25056;v19960=v23429}v14314=v19960}var v4818=v14314;v4818&&(fgSym=null,foundSymbol=!1)}}var v14315=fgSym;if(v14315){var v23430=JAMScript.call(fgSym.isAccessor,fgSym,[]),v19961=!v23430;if(v19961){var v23431=fgSym.type;if(v23431){var v25882=fgSym.type,v25057=v25882.construct;if(v25057){var v26631=fgSym.type,v26531=v26631.construct,v26328=v26531.signatures,v25883=v26328!=[];if(v25883){var v26765=fgSym.type,v26757=v26765.construct,
v26738=v26757.signatures,v26695=v26738[0],v26632=v26695.declAST,v26532=null==v26632,v26634=!v26532;if(v26634)var v26769=fgSym.type,v26768=v26769.construct,v26766=v26768.signatures,v26758=v26766[0],v26739=v26758.declAST,v26696=v26739.fncFlags,v26740=TypeScript.FncFlags,v26697=v26740.Ambient,v26633=JAMScript.call(TypeScript.hasFlag,TypeScript,[v26696,v26697]),v26532=!v26633;var v26329=v26532;if(v26329)var v26533=funcDecl.isConstructor,v26329=!v26533;v25883=v26329}v25057=v25883}v23431=v25057}v19961=
v23431}v14315=v19961}var v4820=v14315;if(v4820){var v14316=context.checker,v4819=v14316.errorReporter;JAMScript.call(v4819.simpleError,v4819,[funcDecl,"Functions may not have class overloads"])}var v14317=fgSym;if(v14317){var v25058=JAMScript.call(fgSym.kind,fgSym,[]),v25884=TypeScript.SymbolKind,v25059=v25884.Type,v23432=v25058==v25059,v19962=!v23432;if(v19962){var v23433=JAMScript.call(funcDecl.isMethod,funcDecl,[]);if(v23433){var v25885=JAMScript.call(funcDecl.isAccessor,funcDecl,[]),v25060=!v25885;
if(v25060)var v25886=funcDecl.isConstructor,v25060=!v25886;v23433=v25060}v19962=v23433}v14317=v19962}var v4824=v14317;if(v4824){var v14318=context.checker,v4821=v14318.errorReporter,v23434=funcDecl.name,v19963=v23434.actualText,v14319="Function or method '"+v19963,v4822=v14319+"' already declared as a property";JAMScript.call(v4821.simpleError,v4821,[funcDecl,v4822]);var v4823=context.checker;fgSym.type=v4823.anyType}var v4825=context.checker,v4826=!foundSymbol;JAMScript.call(v4825.createFunctionSignature,
v4825,[funcDecl,containerSym,containerScope,fgSym,v4826]);var v23435=!fgSym,v25063=!v23435;if(v25063)var v25887=fgSym.declAST,v25061=v25887.nodeType,v25888=TypeScript.NodeType,v25062=v25888.FuncDecl,v23435=v25061!=v25062;var v19964=v23435;v19964&&(v19964=JAMScript.call(funcDecl.isAccessor,funcDecl,[]));var v14320=v19964,v19966=!v14320;if(v19966){var v19965=fgSym;v19965&&(v19965=JAMScript.call(fgSym.isAccessor,fgSym,[]));v14320=v19965}var v4828=v14320;if(v4828){var v4827=funcDecl,v14321=context.checker,
v14322=containerSym.type,v19967=JAMScript.call(funcDecl.isMethod,funcDecl,[]);v19967&&(v19967=isStatic);var v14323=v19967,v26940=JAMScript.call(v14321.createAccessorSymbol,v14321,[funcDecl,fgSym,v14322,v14323,!0,containerScope,containerSym]);v4827.accessorSymbol=v26940}var v14324=funcDecl.type,v4829=v14324.symbol;v4829.declAST=ast;var v4830=funcDecl.isConstructor;v4830&&(go=!0)}if(isExported){var v14325=funcDecl.type,v4833=v14325.call;if(v4833){var v14326=funcDecl.type,v4832=v14326.symbol,v19968=
v4832.flags,v23436=TypeScript.SymbolFlags,v19969=v23436.Exported;v4832.flags=v19968|v19969}var v14327=fgSym;if(v14327){var v23437=JAMScript.call(fgSym.isAccessor,fgSym,[]),v19970=!v23437;if(v19970){var v25064=JAMScript.call(fgSym.kind,fgSym,[]),v25889=TypeScript.SymbolKind,v25065=v25889.Type,v23438=v25064==v25065;if(v23438)var v25066=fgSym.type,v23438=v25066.call;v19970=v23438}v14327=v19970}var v4834=v14327;if(v4834){var v14328=fgSym.flags,v19971=TypeScript.SymbolFlags,v14329=v19971.Exported;fgSym.flags=
v14328|v14329}}var v19972=context.scopeChain,v14330=v19972.moduleDecl;if(v14330)var v19973=JAMScript.call(funcDecl.isSpecialFn,funcDecl,[]),v14330=!v19973;var v4837=v14330;if(v4837){var v14331=funcDecl.type,v4835=v14331.symbol,v19974=v4835.flags,v23439=TypeScript.SymbolFlags,v19975=v23439.ModuleMember;v4835.flags=v19974|v19975;var v14332=funcDecl.type,v4836=v14332.symbol,v14333=context.scopeChain;v4836.declModule=v14333.moduleDecl}var v4838=fgSym&&isOptional;if(v4838){var v14334=fgSym.flags,v19976=
TypeScript.SymbolFlags,v14335=v19976.Optional;fgSym.flags=v14334|v14335}return go}function preCollectTypes(ast,parent,walker){var context=walker.state,go=!1,v14336=ast.nodeType,v19977=TypeScript.NodeType,v19977=v19977.Script;if(v14336=v14336==v19977)go=ast,context.script=go,go=!0;else if(v14336=ast.nodeType,v19977=TypeScript.NodeType,v19977=v19977.List,v14336=v14336==v19977)go=!0;else if(v14336=ast.nodeType,v19977=TypeScript.NodeType,v19977=v19977.ImportDeclaration,v14336=v14336==v19977)go=preCollectImportTypes(ast,
parent,context);else if(v14336=ast.nodeType,v19977=TypeScript.NodeType,v19977=v19977.With,v14336=v14336==v19977)go=!1;else if(v14336=ast.nodeType,v19977=TypeScript.NodeType,v19977=v19977.ModuleDeclaration,v14336=v14336==v19977)go=preCollectModuleTypes(ast,parent,context);else if(v14336=ast.nodeType,v19977=TypeScript.NodeType,v19977=v19977.ClassDeclaration,v14336=v14336==v19977)go=preCollectClassTypes(ast,parent,context);else if(v14336=ast.nodeType,v19977=TypeScript.NodeType,v19977=v19977.Block,v14336=
v14336==v19977)go=!0;else if(v14336=ast.nodeType,v19977=TypeScript.NodeType,v19977=v19977.InterfaceDeclaration,v14336=v14336==v19977)go=preCollectInterfaceTypes(ast,parent,context);else if(v14336=ast.nodeType,v19977=TypeScript.NodeType,v19977=v19977.ArgDecl,v14336=v14336==v19977)go=preCollectArgDeclTypes(ast,parent,context);else if(v14336=ast.nodeType,v19977=TypeScript.NodeType,v19977=v19977.VarDecl,v14336=v14336==v19977)go=preCollectVarDeclTypes(ast,parent,context);else if(v14336=ast.nodeType,v19977=
TypeScript.NodeType,v19977=v19977.FuncDecl,v14336=v14336==v19977)go=preCollectFuncDeclTypes(ast,parent,context);else{if(parent=JAMScript.call(ast.isStatementOrExpression,ast,[]))parent=context.scopeChain,parent=parent.moduleDecl;parent&&(context=context.scopeChain,context=context.moduleDecl,JAMScript.call(context.recordNonInterface,context,[]))}walker=walker.options;walker.goChildren=go;return ast}function postCollectTypes(ast,parent,walker){parent=walker.state;walker=ast.nodeType;var v19989=TypeScript.NodeType,
v19989=v19989.ModuleDeclaration;(walker=walker==v19989)?JAMScript.call(TypeScript.popTypeCollectionScope,TypeScript,[parent]):(walker=ast.nodeType,v19989=TypeScript.NodeType,v19989=v19989.ClassDeclaration,(walker=walker==v19989)?JAMScript.call(TypeScript.popTypeCollectionScope,TypeScript,[parent]):(walker=ast.nodeType,v19989=TypeScript.NodeType,v19989=v19989.InterfaceDeclaration,(walker=walker==v19989)&&JAMScript.call(TypeScript.popTypeCollectionScope,TypeScript,[parent])));return ast}var Continuation=
v966();TypeScript.Continuation=Continuation;TypeScript.createNewConstructGroupForType=createNewConstructGroupForType;TypeScript.cloneParentConstructGroupForChildType=cloneParentConstructGroupForChildType;TypeScript.globalId="__GLO";TypeScript.preCollectImportTypes=preCollectImportTypes;TypeScript.preCollectModuleTypes=preCollectModuleTypes;TypeScript.preCollectClassTypes=preCollectClassTypes;TypeScript.preCollectInterfaceTypes=preCollectInterfaceTypes;TypeScript.preCollectArgDeclTypes=preCollectArgDeclTypes;
TypeScript.preCollectVarDeclTypes=preCollectVarDeclTypes;TypeScript.preCollectFuncDeclTypes=preCollectFuncDeclTypes;TypeScript.preCollectTypes=preCollectTypes;TypeScript.postCollectTypes=postCollectTypes}
function v964(){var TypeScript=v12363;function v963(){function v962(sourceSig,targetSig,assignableTo,comparisonCache,comparisonInfo){var v19992=sourceSig.parameters,v19992=!v19992,v19994=!v19992;v19994&&(v19992=targetSig.parameters,v19992=!v19992);if(v19992)return!1;(v19992=targetSig.hasVariableArgList)?(v19992=targetSig.nonOptionalParameterCount,v19992-=1):v19992=targetSig.nonOptionalParameterCount;(v19994=sourceSig.hasVariableArgList)?(v19994=sourceSig.nonOptionalParameterCount,v19994-=1):v19994=
sourceSig.nonOptionalParameterCount;var v14371=v19994>v19992;v14371&&(v14371=targetSig.hasVariableArgList,v14371=!v14371);if(v14371)return comparisonInfo&&(sourceSig=comparisonInfo.flags,targetSig=TypeScript.TypeRelationshipFlags,targetSig=targetSig.SourceSignatureHasTooManyParameters,comparisonInfo.flags=sourceSig|targetSig,sourceSig="Call signature expects "+v19992,sourceSig+=" or fewer parameters",JAMScript.call(comparisonInfo.addMessageToFront,comparisonInfo,[sourceSig])),!1;var v14371=sourceSig.returnType,
v14371=v14371.type,v4862=targetSig.returnType,v4862=v4862.type,v14375=this.voidType;if(v14375=v4862!=v14375)if(v14371=JAMScript.call(this.sourceIsRelatableToTarget,this,[v14371,v4862,assignableTo,comparisonCache,comparisonInfo]),v14371=!v14371)return comparisonInfo&&(sourceSig=comparisonInfo.flags,targetSig=TypeScript.TypeRelationshipFlags,targetSig=targetSig.IncompatibleReturnTypes,comparisonInfo.flags=sourceSig|targetSig),!1;if(v14371=v19994<v19992)v14371=sourceSig.hasVariableArgList;for(var v14371=
v14371?v19992:v19994,sourceParamType=null,targetParamType=null,v14375=v4862=0,v4881=v4862<v14371;v4881;){var v4881=sourceSig.hasVariableArgList,v4881=!v4881,v20000=!v4881;v20000&&(v4881=v4862<v19994);if(v4881){sourceParamType=sourceSig.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)sourceParamType=sourceParamType[v4862];sourceParamType=sourceParamType.parameter;sourceParamType=sourceParamType.typeLink;sourceParamType=sourceParamType.type}else if(v4881=
v4862==v19994){sourceParamType=sourceSig.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)sourceParamType=sourceParamType[v4862];sourceParamType=sourceParamType.parameter;sourceParamType=sourceParamType.typeLink;sourceParamType=sourceParamType.type;if(v4881=sourceParamType.elementType)sourceParamType=sourceParamType.elementType}v4881=targetSig.parameters;v4881=v4881.length;(v4881=v14375<v4881)&&(v4881=v14375<v19992);if(v4881){targetParamType=targetSig.parameters;
introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)targetParamType=targetParamType[v14375];targetParamType=targetParamType.parameter;targetParamType=targetParamType.typeLink;targetParamType=targetParamType.type}else if((v4881=targetSig.hasVariableArgList)&&(v4881=v14375==v19992),v4881){targetParamType=targetSig.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)targetParamType=targetParamType[v14375];targetParamType=targetParamType.parameter;
targetParamType=targetParamType.typeLink;targetParamType=targetParamType.type;if(v4881=targetParamType.elementType)targetParamType=targetParamType.elementType}v4881=JAMScript.call(this.sourceIsRelatableToTarget,this,[sourceParamType,targetParamType,assignableTo,comparisonCache,comparisonInfo]);(v20000=!v4881)&&(v4881=JAMScript.call(this.sourceIsRelatableToTarget,this,[targetParamType,sourceParamType,assignableTo,comparisonCache,comparisonInfo]));if(v4881=!v4881)return comparisonInfo&&(sourceSig=comparisonInfo.flags,
targetSig=TypeScript.TypeRelationshipFlags,targetSig=targetSig.IncompatibleParameterTypes,comparisonInfo.flags=sourceSig|targetSig),!1;v4862+=1;v14375+=1;v4881=v4862<v14371}return!0}function v961(sourceSG,targetSG,assignableTo,comparisonCache,comparisonInfo){var v4882=sourceSG==targetSG;if(v4882)return!0;v4882=sourceSG&&targetSG;if(v4882=!v4882)return!1;for(var mSig=null,nSig=null,v4882=!1,iMSig=0,mSig=targetSG.signatures,mSig=mSig.length,mSig=iMSig<mSig;mSig;){for(var mSig=targetSG.signatures,mSig=
mSig[iMSig],iNSig=0,nSig=sourceSG.signatures,nSig=nSig.length,nSig=iNSig<nSig;nSig;){nSig=sourceSG.signatures;nSig=nSig[iNSig];if(nSig=JAMScript.call(this.signatureIsRelatableToTarget,this,[nSig,mSig,assignableTo,comparisonCache,comparisonInfo])){v4882=!0;break}iNSig+=1;nSig=sourceSG.signatures;nSig=nSig.length;nSig=iNSig<nSig}if(v4882)v4882=!1,iMSig+=1,mSig=targetSG.signatures,mSig=mSig.length,mSig=iMSig<mSig;else return!1}return!0}function v960(source,target,assignableTo,comparisonCache,comparisonInfo){var v4889=
source==target;if(v4889)return!0;var v14399=source&&target,v4890=!v14399;if(v4890)return!0;var v14400=source.typeID,v4891=v14400<<16,v4892=target.typeID,comboId=v4891|v4892;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v14401=comparisonCache[comboId];var v4893=void 0!=v14401;if(v4893)return!0;if(assignableTo){var v20016=this.anyType,v14402=source==v20016,v20018=!v14402;if(v20018)var v20017=this.anyType,v14402=target==v20017;var v4894=v14402;if(v4894)return!0}else{var v14403=
this.anyType,v4895=target==v14403;if(v4895)return!0}var v14404=this.undefinedType,v4896=source==v14404;if(v4896)return!0;var v20019=this.nullType,v14405=source==v20019;if(v14405){var v23450=this.undefinedType,v20020=target!=v23450;if(v20020)var v23451=this.voidType,v20020=target!=v23451;v14405=v20020}var v4897=v14405;if(v4897)return!0;var v20021=this.numberType,v14406=target==v20021;if(v14406)var v20022=source.typeFlags,v23452=TypeScript.TypeFlags,v20023=v23452.IsEnum,v14406=v20022&v20023;var v4898=
v14406;if(v4898)return!0;var v20024=this.numberType,v14407=source==v20024;if(v14407)var v20025=target.typeFlags,v23453=TypeScript.TypeFlags,v20026=v23453.IsEnum,v14407=v20025&v20026;var v4899=v14407;if(v4899)return!0;var v20027=source.typeFlags,v23454=TypeScript.TypeFlags,v20028=v23454.IsEnum,v14408=v20027&v20028,v20031=!v14408;if(v20031)var v20029=target.typeFlags,v23455=TypeScript.TypeFlags,v20030=v23455.IsEnum,v14408=v20029&v20030;var v4900=v14408;if(v4900)return!1;var v14409=JAMScript.call(source.isArray,
source,[]),v20032=!v14409;v20032&&(v14409=JAMScript.call(target.isArray,target,[]));var v4904=v14409;if(v4904){var v20033=JAMScript.call(source.isArray,source,[]);v20033&&(v20033=JAMScript.call(target.isArray,target,[]));var v14410=v20033,v4901=!v14410;if(v4901)return!1;comparisonCache[comboId]=!1;var v4902=source.elementType,v4903=target.elementType,ret=JAMScript.call(this.sourceIsRelatableToTarget,this,[v4902,v4903,assignableTo,comparisonCache,comparisonInfo]);comparisonCache[comboId]=ret?!0:void 0;
return ret}var v14411=source.primitiveTypeClass,v14412=target.primitiveTypeClass,v4912=v14411!=v14412;if(v4912){var v14413=target.primitiveTypeClass,v20034=TypeScript.Primitive,v14414=v20034.None,v4911=v14413==v14414;if(v4911){var v20035=this.numberType,v14415=source==v20035;if(v14415)var v20036=this.typeFlow,v14415=v20036.numberInterfaceType;var v4910=v14415;if(v4910){var v4905=this.typeFlow;source=v4905.numberInterfaceType}else{var v20037=this.stringType,v14416=source==v20037;if(v14416)var v20038=
this.typeFlow,v14416=v20038.stringInterfaceType;var v4909=v14416;if(v4909){var v4906=this.typeFlow;source=v4906.stringInterfaceType}else{var v20039=this.booleanType,v14417=source==v20039;if(v14417)var v20040=this.typeFlow,v14417=v20040.booleanInterfaceType;var v4908=v14417;if(v4908){var v4907=this.typeFlow;source=v4907.booleanInterfaceType}else return!1}}}else return!1}comparisonCache[comboId]=!1;var v4913=JAMScript.call(source.hasBase,source,[target]);if(v4913)return comparisonCache[comboId]=!0;
var v20041=this.typeFlow,v14418=v20041.objectInterfaceType;if(v14418)var v23456=this.typeFlow,v20042=v23456.objectInterfaceType,v14418=target==v20042;var v4914=v14418;if(v4914)return!0;var v20043=this.typeFlow,v14419=v20043.functionInterfaceType;if(v14419){var v23457=source.call,v25067=!v23457;v25067&&(v23457=source.construct);var v20044=v23457;if(v20044)var v25068=this.typeFlow,v23458=v25068.functionInterfaceType,v20044=target==v23458;v14419=v20044}var v4915=v14419;if(v4915)return!0;var v14420=JAMScript.call(target.isClass,
target,[]),v20045=!v14420;v20045&&(v14420=JAMScript.call(target.isClassInstance,target,[]));var v4916=v14420;if(v4916)return comparisonCache[comboId]=void 0,!1;var v14421=target.memberScope;v14421&&(v14421=source.memberScope);var v4946=v14421;if(v4946)for(var v4917=target.memberScope,mPropKeys=JAMScript.call(v4917.getAllValueSymbolNames,v4917,[!0]),mProp=null,nProp=null,mPropType=null,nPropType=null,inferenceSymbol=null,iMProp=0,v14422=mPropKeys.length,v4945=iMProp<v14422;v4945;){var v4918=target.memberScope;
introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v4919=mPropKeys[iMProp];var mProp=JAMScript.call(v4918.find,v4918,[v4919,!1,!1]),v4920=source.memberScope;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v4921=mPropKeys[iMProp];var nProp=JAMScript.call(v4920.find,v4920,[v4921,!1,!1]),v20046=mProp.name,v14423="arguments"==v20046;if(v14423){var v23459=this.typeFlow,v20047=v23459.iargumentsInterfaceType;if(v20047){var v26534=
this.typeFlow,v26330=v26534.iargumentsInterfaceType,v25890=v26330.symbol,v25069=v25890.flags,v25891=TypeScript.SymbolFlags,v25070=v25891.CompilerGenerated,v23460=v25069&v25070;if(v23460){var v25892=JAMScript.call(mProp.kind,mProp,[]),v26331=TypeScript.SymbolKind,v25893=v26331.Variable,v25071=v25892==v25893;if(v25071)var v26535=mProp.variable,v26332=v26535.typeLink,v25894=v26332.type,v26333=this.typeFlow,v25895=v26333.iargumentsInterfaceType,v25071=v25894==v25895;v23460=v25071}v20047=v23460}v14423=
v20047}var v4922=v14423;if(v4922)var iMProp=iMProp+1,v14424=mPropKeys.length,v4945=iMProp<v14424;else{var v4926=JAMScript.call(mProp.isInferenceSymbol,mProp,[]);if(v4926){var inferenceSymbol=mProp,v14425=inferenceSymbol.typeCheckStatus,v20048=TypeScript.TypeCheckStatus,v14426=v20048.NotStarted,v4925=v14425==v14426;if(v4925){var v4923=this.typeFlow,v4924=mProp.declAST;JAMScript.call(v4923.typeCheck,v4923,[v4924])}}var mPropType=JAMScript.call(mProp.getType,mProp,[]),v4937=!nProp;if(v4937){var v14427=
this.typeFlow,v4929=v14427.objectInterfaceType;if(v4929){var v20049=this.typeFlow,v14428=v20049.objectInterfaceType,v4927=v14428.memberScope;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v4928=mPropKeys[iMProp];nProp=JAMScript.call(v4927.find,v4927,[v4928,!1,!1])}var v4936=!nProp;if(v4936){var v20050=this.typeFlow,v14429=v20050.functionInterfaceType;if(v14429){var v20051=mPropType.call,v23461=!v20051;v23461&&(v20051=mPropType.construct);v14429=v20051}var v4932=
v14429;if(v4932){var v20052=this.typeFlow,v14430=v20052.functionInterfaceType,v4930=v14430.memberScope;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v4931=mPropKeys[iMProp];nProp=JAMScript.call(v4930.find,v4930,[v4931,!1,!1])}var v4935=!nProp;if(v4935){var v20053=mProp.flags,v23462=TypeScript.SymbolFlags,v20054=v23462.Optional,v14431=v20053&v20054,v4934=!v14431;if(v4934){comparisonCache[comboId]=void 0;if(comparisonInfo){var v14432=comparisonInfo.flags,v20055=
TypeScript.TypeRelationshipFlags,v14433=v20055.RequiredPropertyIsMissing;comparisonInfo.flags=v14432|v14433;var v26334=JAMScript.call(source.getTypeName,source,[]),v25896="Type '"+v26334,v25072=v25896+"' is missing property '";introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v25073=mPropKeys[iMProp];var v23463=v25072+v25073,v20056=v23463+"' from type '",v20057=JAMScript.call(target.getTypeName,target,[]),v14434=v20056+v20057,v4933=v14434+"'";JAMScript.call(comparisonInfo.addMessageToFront,
comparisonInfo,[v4933])}return!1}var iMProp=iMProp+1,v14435=mPropKeys.length,v4945=iMProp<v14435;continue}}}var v4941=JAMScript.call(nProp.isInferenceSymbol,nProp,[]);if(v4941){var inferenceSymbol=nProp,v14436=inferenceSymbol.typeCheckStatus,v20058=TypeScript.TypeCheckStatus,v14437=v20058.NotStarted,v4940=v14436==v14437;if(v4940){var v4938=this.typeFlow,v4939=nProp.declAST;JAMScript.call(v4938.typeCheck,v4938,[v4939])}}var nPropType=JAMScript.call(nProp.getType,nProp,[]),v14438=mPropType;if(v14438){var v20059=
nPropType;if(v20059){var v26335=nPropType.typeID,v25897=v26335<<16,v25898=mPropType.typeID,v25074=v25897|v25898;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v23464=comparisonCache[v25074];v20059=void 0!=v23464}v14438=v20059}var v4942=v14438;if(v4942)var iMProp=iMProp+1,v14439=mPropKeys.length,v4945=iMProp<v14439;else{var v14440=JAMScript.call(this.sourceIsRelatableToTarget,this,[nPropType,mPropType,assignableTo,comparisonCache,comparisonInfo]),v4944=!v14440;
if(v4944){comparisonCache[comboId]=void 0;if(comparisonInfo){var v14441=comparisonInfo.flags,v20060=TypeScript.TypeRelationshipFlags,v14442=v20060.IncompatiblePropertyTypes;comparisonInfo.flags=v14441|v14442;var v26336=mProp.name,v25899="Types of property '"+v26336,v25075=v25899+"' of types '",v25076=JAMScript.call(source.getTypeName,source,[]),v23465=v25075+v25076,v20061=v23465+"' and '",v20062=JAMScript.call(target.getTypeName,target,[]),v14443=v20061+v20062,v4943=v14443+"' are incompatible";JAMScript.call(comparisonInfo.addMessageToFront,
comparisonInfo,[v4943])}return!1}var iMProp=iMProp+1,v14444=mPropKeys.length,v4945=iMProp<v14444}}}var v14445=source.call,v20063=!v14445;v20063&&(v14445=target.call);var v4953=v14445;if(v4953){var v20064=source.call,v20065=target.call,v14446=JAMScript.call(this.signatureGroupIsRelatableToTarget,this,[v20064,v20065,assignableTo,comparisonCache,comparisonInfo]),v4952=!v14446;if(v4952){if(comparisonInfo){var v14447=source.call;v14447&&(v14447=target.call);var v4951=v14447;if(v4951){var v25077=JAMScript.call(source.getTypeName,
source,[]),v23466="Call signatures of types '"+v25077,v20066=v23466+"' and '",v20067=JAMScript.call(target.getTypeName,target,[]),v14448=v20066+v20067,v4947=v14448+"' are incompatible";JAMScript.call(comparisonInfo.addMessageToFront,comparisonInfo,[v4947])}else{var v4948,v14449=target.call,hasSig=v4948=v14449?JAMScript.call(target.getTypeName,target,[]):JAMScript.call(source.getTypeName,source,[]),v4949,v20068=target.call,v14450=!v20068,lacksSig=v4949=v14450?JAMScript.call(target.getTypeName,target,
[]):JAMScript.call(source.getTypeName,source,[]),v23467="Type '"+hasSig,v20069=v23467+"' requires a call signature, but Type '",v14451=v20069+lacksSig,v4950=v14451+"' lacks one";JAMScript.call(comparisonInfo.setMessage,comparisonInfo,[v4950])}var v14452=comparisonInfo.flags,v20070=TypeScript.TypeRelationshipFlags,v14453=v20070.IncompatibleSignatures;comparisonInfo.flags=v14452|v14453}comparisonCache[comboId]=void 0;return!1}}var v14454=source.construct,v20071=!v14454;v20071&&(v14454=target.construct);
var v4960=v14454;if(v4960){var v20072=source.construct,v20073=target.construct,v14455=JAMScript.call(this.signatureGroupIsRelatableToTarget,this,[v20072,v20073,assignableTo,comparisonCache,comparisonInfo]),v4959=!v14455;if(v4959){if(comparisonInfo){var v14456=source.construct;v14456&&(v14456=target.construct);var v4958=v14456;if(v4958){var v25078=JAMScript.call(source.getTypeName,source,[]),v23468="Construct signatures of types '"+v25078,v20074=v23468+"' and '",v20075=JAMScript.call(target.getTypeName,
target,[]),v14457=v20074+v20075,v4954=v14457+"' are incompatible";JAMScript.call(comparisonInfo.addMessageToFront,comparisonInfo,[v4954])}else{var v4955,v14458=target.construct,hasSig=v4955=v14458?JAMScript.call(target.getTypeName,target,[]):JAMScript.call(source.getTypeName,source,[]),v4956,v20076=target.construct,v14459=!v20076,lacksSig=v4956=v14459?JAMScript.call(target.getTypeName,target,[]):JAMScript.call(source.getTypeName,source,[]),v23469="Type '"+hasSig,v20077=v23469+"' requires a construct signature, but Type '",
v14460=v20077+lacksSig,v4957=v14460+"' lacks one";JAMScript.call(comparisonInfo.setMessage,comparisonInfo,[v4957])}var v14461=comparisonInfo.flags,v20078=TypeScript.TypeRelationshipFlags,v14462=v20078.IncompatibleSignatures;comparisonInfo.flags=v14461|v14462}comparisonCache[comboId]=void 0;return!1}}var v4965=target.index;if(v4965){var v4961,v23470=target.index,v20079=!v23470;if(v20079)var v23471=this.typeFlow,v20079=v23471.objectInterfaceType;var v14464=v20079;if(v14464){var v20080=this.typeFlow,
v14463=v20080.objectInterfaceType;v4961=v14463.index}else v4961=target.index;var targetIndex=v4961,v4962,v23472=source.index,v20081=!v23472;if(v20081)var v23473=this.typeFlow,v20081=v23473.objectInterfaceType;var v14466=v20081;if(v14466){var v20082=this.typeFlow,v14465=v20082.objectInterfaceType;v4962=v14465.index}else v4962=source.index;var sourceIndex=v4962,v14467=JAMScript.call(this.signatureGroupIsRelatableToTarget,this,[sourceIndex,targetIndex,assignableTo,comparisonCache,comparisonInfo]),v4964=
!v14467;if(v4964){if(comparisonInfo){var v25079=JAMScript.call(source.getTypeName,source,[]),v23474="Index signatures of types '"+v25079,v20083=v23474+"' and '",v20084=JAMScript.call(target.getTypeName,target,[]),v14468=v20083+v20084,v4963=v14468+"' are incompatible";JAMScript.call(comparisonInfo.addMessageToFront,comparisonInfo,[v4963]);var v14469=comparisonInfo.flags,v20085=TypeScript.TypeRelationshipFlags,v14470=v20085.IncompatibleSignatures;comparisonInfo.flags=v14469|v14470}comparisonCache[comboId]=
void 0;return!1}}return comparisonCache[comboId]=!0}function v959(s1,s2,comparisonInfo){var v4966=this.assignableCache;return JAMScript.call(this.signatureIsRelatableToTarget,this,[s1,s2,!0,v4966,comparisonInfo])}function v958(sg1,sg2,comparisonInfo){var v4967=this.assignableCache;return JAMScript.call(this.signatureGroupIsRelatableToTarget,this,[sg1,sg2,!0,v4967,comparisonInfo])}function v957(source,target,comparisonInfo){var v4968=this.assignableCache;return JAMScript.call(this.sourceIsRelatableToTarget,
this,[source,target,!0,v4968,comparisonInfo])}function v956(s1,s2,comparisonInfo){var v4969=this.subtypeCache;return JAMScript.call(this.signatureIsRelatableToTarget,this,[s1,s2,!1,v4969,comparisonInfo])}function v955(sg1,sg2,comparisonInfo){var v4970=this.subtypeCache;return JAMScript.call(this.signatureGroupIsRelatableToTarget,this,[sg1,sg2,!1,v4970,comparisonInfo])}function v954(source,target,comparisonInfo){var v4971=this.subtypeCache;return JAMScript.call(this.sourceIsRelatableToTarget,this,
[source,target,!1,v4971,comparisonInfo])}function v953(s1,s2){var v14471=s1.hasVariableArgList,v14472=s2.hasVariableArgList;if(v14471=v14471!=v14472)return!1;v14471=s1.nonOptionalParameterCount;v14472=s2.nonOptionalParameterCount;if(v14471=v14471!=v14472)return!1;v14471=s1.parameters;v14471=v14471.length;v14472=s2.parameters;v14472=v14472.length;if(v14471=v14471!=v14472)return!1;v14471=s1.returnType;v14471=v14471.type;v14472=s2.returnType;v14472=v14472.type;v14471=JAMScript.call(this.typesAreIdentical,
this,[v14471,v14472]);if(v14471=!v14471)return!1;v14471=0;v14472=s1.parameters;v14472=v14472.length;for(v14472=v14471<v14472;v14472;){v14472=s1.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v14472=v14472[v14471];var v14472=v14472.parameter,v14472=v14472.typeLink,v14472=v14472.type,v26338=s2.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26338=v26338[v14471];v26338=v26338.parameter;v26338=v26338.typeLink;
v26338=v26338.type;v14472=JAMScript.call(this.typesAreIdentical,this,[v14472,v26338]);if(v14472=!v14472)return!1;v14471+=1;v14472=s1.parameters;v14472=v14472.length;v14472=v14471<v14472}return!0}function v952(sg1,sg2){var v4978=sg1==sg2;if(v4978)return!0;var v4978=!sg1,v20094=!v4978;v20094&&(v4978=!sg2);if(v4978)return!1;v4978=sg1.signatures;v4978=v4978.length;v20094=sg2.signatures;v20094=v20094.length;if(v4978=v4978!=v20094)return!1;for(var sig1=null,sig2=null,v4978=!1,v20094=0,sig1=sg1.signatures,
sig1=sig1.length,sig1=v20094<sig1;sig1;){for(var sig1=sg1.signatures,sig1=sig1[v20094],iSig2=0,sig2=sg2.signatures,sig2=sig2.length,sig2=iSig2<sig2;sig2;){sig2=sg2.signatures;sig2=sig2[iSig2];if(sig2=JAMScript.call(this.signaturesAreIdentical,this,[sig1,sig2])){v4978=!0;break}iSig2+=1;sig2=sg2.signatures;sig2=sig2.length;sig2=iSig2<sig2}if(v4978)v4978=!1,v20094+=1,sig1=sg1.signatures,sig1=sig1.length,sig1=v20094<sig1;else return!1}return!0}function v951(t1,t2){var v4986=t1==t2;if(v4986)return!0;var v14488=
!t1,v20101=!v14488;v20101&&(v14488=!t2);var v4987=v14488;if(v4987)return!1;var v14489=JAMScript.call(t1.isClass,t1,[]),v20102=!v14489;v20102&&(v14489=JAMScript.call(t1.isClassInstance,t1,[]));var v4988=v14489;if(v4988)return!1;var v14490=t2.typeID,v4989=v14490<<16,v4990=t1.typeID,comboId=v4989|v4990,v14491=this.identicalCache;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v4991=v14491[comboId];if(v4991)return!0;var v20103=t1.typeFlags,v23479=TypeScript.TypeFlags,
v20104=v23479.IsEnum,v14492=v20103&v20104,v20107=!v14492;if(v20107)var v20105=t2.typeFlags,v23480=TypeScript.TypeFlags,v20106=v23480.IsEnum,v14492=v20105&v20106;var v4992=v14492;if(v4992)return!1;var v14493=JAMScript.call(t1.isArray,t1,[]),v20108=!v14493;v20108&&(v14493=JAMScript.call(t2.isArray,t2,[]));var v4999=v14493;if(v4999){var v20109=JAMScript.call(t1.isArray,t1,[]);v20109&&(v20109=JAMScript.call(t2.isArray,t2,[]));var v14494=v20109,v4993=!v14494;if(v4993)return!1;var v4994=this.identicalCache;
v4994[comboId]=!1;var v4995=t1.elementType,v4996=t2.elementType,ret=JAMScript.call(this.typesAreIdentical,this,[v4995,v4996]);if(ret){var v4997=this.subtypeCache;v4997[comboId]=!0}else{var v4998=this.subtypeCache;v4998[comboId]=void 0}return ret}var v14495=t1.primitiveTypeClass,v14496=t2.primitiveTypeClass,v5000=v14495!=v14496;if(v5000)return!1;var v5001=this.identicalCache;v5001[comboId]=!1;var v14497=t1.memberScope;v14497&&(v14497=t2.memberScope);var v5020=v14497;if(v5020){var v14498=t1.memberScope,
v5002=JAMScript.call(v14498.getAllValueSymbolNames,v14498,[!0]),t1MemberKeys=v5002.sort(),v14499=t2.memberScope,v5003=JAMScript.call(v14499.getAllValueSymbolNames,v14499,[!0]),t2MemberKeys=v5003.sort(),v14500=t1MemberKeys.length,v14501=t2MemberKeys.length,v5005=v14500!=v14501;if(v5005){var v5004=this.identicalCache;v5004[comboId]=void 0;return!1}for(var t1MemberSymbol=null,t2MemberSymbol=null,t1MemberType=null,t2MemberType=null,iMember=0,v14502=t1MemberKeys.length,v5017=iMember<v14502;v5017;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v14503=
t1MemberKeys[iMember];introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v14504=t2MemberKeys[iMember];var v5007=v14503!=v14504;if(v5007){var v5006=this.identicalCache;v5006[comboId]=void 0;return!1}var v5008=t1.memberScope;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v5009=t1MemberKeys[iMember];var t1MemberSymbol=JAMScript.call(v5008.find,v5008,[v5009,!1,!1]),v5010=t2.memberScope;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v5011=
t2MemberKeys[iMember];var t2MemberSymbol=JAMScript.call(v5010.find,v5010,[v5011,!1,!1]),v20110=t1MemberSymbol.flags,v23481=TypeScript.SymbolFlags,v20111=v23481.Optional,v14505=v20110&v20111,v20112=t2MemberSymbol.flags,v23482=TypeScript.SymbolFlags,v20113=v23482.Optional,v14506=v20112&v20113,v5013=v14505!=v14506;if(v5013){var v5012=this.identicalCache;v5012[comboId]=void 0;return!1}var t1MemberType=JAMScript.call(t1MemberSymbol.getType,t1MemberSymbol,[]),t2MemberType=JAMScript.call(t2MemberSymbol.getType,
t2MemberSymbol,[]),v14507=t1MemberType;if(v14507){var v20114=t2MemberType;if(v20114){var v25082=this.identicalCache,v26339=t2MemberType.typeID,v25902=v26339<<16,v25903=t1MemberType.typeID,v25083=v25902|v25903;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v23483=v25082[v25083];v20114=void 0!=v23483}v14507=v20114}var v5014=v14507;if(v5014)var iMember=iMember+1,v14508=t1MemberKeys.length,v5017=iMember<v14508;else{var v14509=JAMScript.call(this.typesAreIdentical,
this,[t1MemberType,t2MemberType]),v5016=!v14509;if(v5016){var v5015=this.identicalCache;v5015[comboId]=void 0;return!1}var iMember=iMember+1,v14510=t1MemberKeys.length,v5017=iMember<v14510}}}else{var v14511=t1.memberScope,v20115=!v14511;v20115&&(v14511=t2.memberScope);var v5019=v14511;if(v5019){var v5018=this.identicalCache;v5018[comboId]=void 0;return!1}}var v20116=t1.call,v20117=t2.call,v14512=JAMScript.call(this.signatureGroupsAreIdentical,this,[v20116,v20117]),v5022=!v14512;if(v5022){var v5021=
this.identicalCache;v5021[comboId]=void 0;return!1}var v20118=t1.construct,v20119=t2.construct,v14513=JAMScript.call(this.signatureGroupsAreIdentical,this,[v20118,v20119]),v5024=!v14513;if(v5024){var v5023=this.identicalCache;v5023[comboId]=void 0;return!1}var v20120=t1.index,v20121=t2.index,v14514=JAMScript.call(this.signatureGroupsAreIdentical,this,[v20120,v20121]),v5026=!v14514;if(v5026){var v5025=this.identicalCache;v5025[comboId]=void 0;return!1}var v5027=this.identicalCache;return v5027[comboId]=
!0}function v950(initialType,targetType,collection,acceptVoid,comparisonInfo){var i=0,len=JAMScript.call(collection.getLength,collection,[]),nlastChecked=0;targetType&&(initialType=initialType?JAMScript.call(initialType.mergeOrdered,initialType,[targetType,this,acceptVoid]):targetType);for(var convergenceType=initialType,i=nlastChecked<len;i;){for(var i=0,v5032=i<len;v5032;){v5032=i==nlastChecked;if(!v5032){if(v5032=convergenceType)initialType=JAMScript.call(collection.getTypeAtIndex,collection,[i]),
v5032=initialType=JAMScript.call(convergenceType.mergeOrdered,convergenceType,[initialType,this,acceptVoid,comparisonInfo]);v5032&&(convergenceType=initialType);var v5032=this.anyType,v5032=initialType==v5032,v20124=!v5032;v20124&&(v5032=null==initialType);if(v5032)break;else targetType&&JAMScript.call(collection.setTypeAtIndex,collection,[i,targetType])}i+=1;v5032=i<len}if(i=convergenceType&&initialType)break;nlastChecked+=1;(i=nlastChecked<len)&&(convergenceType=JAMScript.call(collection.getTypeAtIndex,
collection,[nlastChecked]));i=nlastChecked<len}acceptVoid?targetType=initialType:(targetType=this.voidType,targetType=(targetType=initialType==targetType)?null:initialType);return targetType}function v949(t){var v14518=this.undefinedType,v14518=t==v14518,v14520=!v14518;v14520&&(v14518=this.nullType,v14518=t==v14518);return v14518}function v948(t){var v20126=this.undefinedType,v20126=t==v20126,v20128=!v20126;v20128&&(v20126=this.nullType,v20126=t==v20126);return v20126?this.anyType:t}function v947(targetType,
objectLit){var v20129=this.typeFlow,v20129=v20129.objectInterfaceType;if(v20129=targetType==v20129)return!0;var memberDecls=objectLit.operand;if(v20129=memberDecls)v20129=targetType.memberScope;if(v20129=!v20129)return!1;for(var id=null,targetMember=null,id="",v20129={},i=0,id=memberDecls.members,id=id.length,id=i<id;id;){id=memberDecls.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)id=id[i];var id=id.operand1,targetMember=id.nodeType,v20132=TypeScript.NodeType,
v20132=v20132.Name;if(targetMember=targetMember==v20132)id=id.text;else if(targetMember=id.nodeType,v20132=TypeScript.NodeType,v20132=v20132.QString,targetMember=targetMember==v20132)id=id.text,targetMember=id.length,targetMember-=1,id=JAMScript.call(id.substring,id,[1,targetMember]);else return!1;targetMember=targetType.memberScope;targetMember=JAMScript.call(targetMember.find,targetMember,[id,!0,!1]);if(targetMember=!targetMember)return!1;JAMScript.set(v20129,id,!0);i+=1;id=memberDecls.members;
id=id.length;id=i<id}i=targetType.memberScope;memberDecls=JAMScript.call(i.getAllValueSymbolNames,i,[!0]);i=0;id=memberDecls.length;for(id=i<id;id;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)id=memberDecls[i];targetMember=targetType.memberScope;id=JAMScript.call(targetMember.find,targetMember,[id,!0,!1]);introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)targetMember=memberDecls[i];introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)targetMember=
v20129[targetMember];if(targetMember=!targetMember)id=id.flags,targetMember=TypeScript.SymbolFlags,targetMember=targetMember.Optional,id=JAMScript.call(TypeScript.hasFlag,TypeScript,[id,targetMember]),targetMember=!id;if(id=targetMember)return!1;i+=1;id=memberDecls.length;id=i<id}return!0}function v946(candidateType,funcDecl,beStringent){var v14535=funcDecl.isParenthesized,v20138=!v14535;if(v20138&&(v14535=JAMScript.call(funcDecl.isMethod,funcDecl,[]),v20138=!v14535)){if(v14535=beStringent)v14535=
funcDecl.returnTypeAnnotation;if(v20138=!v14535)v14535=funcDecl.isInlineCallLiteral}if(v14535)return!1;if(v14535=!beStringent)beStringent=this.typeFlow,beStringent=beStringent.functionInterfaceType,beStringent=beStringent==candidateType;if(v14535=!beStringent)return!0;v14535=funcDecl.signature;if(v14535=!v14535)v14535=this.typeFlow,v14535=v14535.scope,v14535=v14535.container,v20138=this.typeFlow,v20138=v20138.scope,JAMScript.call(this.createFunctionSignature,this,[funcDecl,v14535,v20138,null,null]),
v14535=this.typeFlow,JAMScript.call(v14535.typeCheck,v14535,[funcDecl]);funcDecl=funcDecl.signature;for(var v14535=funcDecl.parameters,v14535=v14535.length,v20138=0,v5062=v20138<v14535;v5062;){v5062=funcDecl.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v5062=v5062[v20138];var v5062=v5062.declAST,v14541=beStringent;v14541&&(v14541=v5062.typeExpr);if(v5062=v14541)return!1;v20138+=1;v5062=v20138<v14535}if(beStringent=candidateType.construct)beStringent=
candidateType.call;if(beStringent)return!1;candidateType=(beStringent=candidateType.construct)?candidateType.construct:candidateType.call;beStringent=!candidateType;if(funcDecl=!beStringent)candidateType=candidateType.signatures,candidateType=candidateType.length,beStringent=1<candidateType;return(candidateType=beStringent)?!1:!0}function v945(signatures,args,comparisonInfo){for(var applicableSigs=[],memberType=null,miss=!1,hadProvisionalErrors=!1,i=0,v14545=signatures.length,v5093=i<v14545;v5093;){for(var miss=
!1,j=0,v20143=args.members,v14546=v20143.length,v5090=j<v14546;v5090;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v23491=signatures[i];var v20144=v23491.parameters,v14547=v20144.length,v5066=j>=v14547;if(v5066)var j=j+1,v20145=args.members,v14548=v20145.length,v5090=j<v14548;else{introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v20146=signatures[i];var v14549=v20146.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v5067=
v14549[j];memberType=JAMScript.call(v5067.getType,v5067,[]);introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v23492=signatures[i];var v20147=v23492.declAST,v14550=v20147.variableArgList;if(v14550){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v25904=signatures[i];var v25087=v25904.nonOptionalParameterCount,v23493=v25087-1,v20148=j>=v23493;v20148&&(v20148=JAMScript.call(memberType.isArray,memberType,[]));v14550=v20148}var v5068=
v14550;v5068&&(memberType=memberType.elementType);var v14551=this.anyType,v5089=memberType==v14551;if(!v5089){var v23494=args.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v20149=v23494[j];var v14552=v20149.nodeType,v20150=TypeScript.NodeType,v14553=v20150.FuncDecl,v5088=v14552==v14553;if(v5088){var v20151=this.typeFlow,v14554=v20151.functionInterfaceType;if(v14554)var v23495=this.typeFlow,v20152=v23495.functionInterfaceType,v14554=memberType==v20152;
var v5069=v14554;if(v5069){var j=j+1,v20153=args.members,v14555=v20153.length,v5090=j<v14555;continue}var v23496=args.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v20154=v23496[j];var v14556=JAMScript.call(this.canContextuallyTypeFunction,this,[memberType,v20154,!0]),v5077=!v14556;if(v5077){var v20155=args.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v14557=v20155[j];var v5073=JAMScript.call(this.canContextuallyTypeFunction,
this,[memberType,v14557,!1]);if(v5073){var v5070=this.typeFlow,v14558=args.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v5071=v14558[j];JAMScript.call(v5070.typeCheck,v5070,[v5071]);var v25088=args.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v23497=v25088[j];var v20156=v23497.type,v14559=JAMScript.call(this.sourceIsAssignableToTarget,this,[v20156,memberType,comparisonInfo]),v5072=!v14559;if(v5072)break}else break}else{var v14560=
args.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v5074=v14560[j];JAMScript.call(this.typeCheckWithContextualType,this,[memberType,!0,!0,v5074]);JAMScript.call(this.cleanStartedPTO,this,[]);var hadProvisionalErrors=JAMScript.call(this.hadProvisionalErrors,this,[]),v25089=args.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v23498=v25089[j];var v20157=v23498.type,v14561=JAMScript.call(this.sourceIsAssignableToTarget,
this,[v20157,memberType,comparisonInfo]),v5076=!v14561;if(v5076){if(comparisonInfo){var v26340=JAMScript.call(memberType.getTypeName,memberType,[]),v25905="Could not apply type '"+v26340,v25090=v25905+"' to argument ",v25091=j+1,v23499=v25090+v25091,v20158=v23499+", which is of type '",v25906=args.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v25092=v25906[j];var v23500=v25092.type,v20159=JAMScript.call(v23500.getTypeName,v23500,[]),v14562=v20158+v20159,
v5075=v14562+"'";JAMScript.call(comparisonInfo.setMessage,comparisonInfo,[v5075])}miss=!0}JAMScript.call(this.resetProvisionalErrors,this,[]);if(miss)break}}else{var v23501=args.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v20160=v23501[j];var v14563=v20160.nodeType,v20161=TypeScript.NodeType,v14564=v20161.ObjectLit,v5087=v14563==v14564;if(v5087){var v20162=this.typeFlow,v14565=v20162.objectInterfaceType;if(v14565)var v23502=this.typeFlow,v20163=v23502.objectInterfaceType,
v14565=memberType==v20163;var v5078=v14565;if(v5078){var j=j+1,v20164=args.members,v14566=v20164.length,v5090=j<v14566;continue}var v14567=args.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v5079=v14567[j];JAMScript.call(this.typeCheckWithContextualType,this,[memberType,!0,!0,v5079]);JAMScript.call(this.cleanStartedPTO,this,[]);var hadProvisionalErrors=JAMScript.call(this.hadProvisionalErrors,this,[]),v25093=args.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v23503=
v25093[j];var v20165=v23503.type,v14568=JAMScript.call(this.sourceIsAssignableToTarget,this,[v20165,memberType,comparisonInfo]),v5081=!v14568;if(v5081){if(comparisonInfo){var v26341=JAMScript.call(memberType.getTypeName,memberType,[]),v25907="Could not apply type '"+v26341,v25094=v25907+"' to argument ",v25095=j+1,v23504=v25094+v25095,v20166=v23504+", which is of type '",v25908=args.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v25096=v25908[j];var v23505=
v25096.type,v20167=JAMScript.call(v23505.getTypeName,v23505,[]),v14569=v20166+v20167,v5080=v14569+"'";JAMScript.call(comparisonInfo.setMessage,comparisonInfo,[v5080])}miss=!0}JAMScript.call(this.resetProvisionalErrors,this,[]);if(miss)break}else{var v23506=args.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v20168=v23506[j];var v14570=v20168.nodeType,v20169=TypeScript.NodeType,v14571=v20169.ArrayLit,v5086=v14570==v14571;if(v5086){var v20170=this.typeFlow,
v14572=v20170.arrayInterfaceType;if(v14572)var v23507=this.typeFlow,v20171=v23507.arrayInterfaceType,v14572=memberType==v20171;var v5082=v14572;if(v5082){var j=j+1,v20172=args.members,v14573=v20172.length,v5090=j<v14573;continue}var v14574=args.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v5083=v14574[j];JAMScript.call(this.typeCheckWithContextualType,this,[memberType,!0,!0,v5083]);JAMScript.call(this.cleanStartedPTO,this,[]);var hadProvisionalErrors=
JAMScript.call(this.hadProvisionalErrors,this,[]),v25097=args.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v23508=v25097[j];var v20173=v23508.type,v14575=JAMScript.call(this.sourceIsAssignableToTarget,this,[v20173,memberType,comparisonInfo]),v5085=!v14575;if(v5085){if(comparisonInfo){var v26342=JAMScript.call(memberType.getTypeName,memberType,[]),v25909="Could not apply type '"+v26342,v25098=v25909+"' to argument ",v25099=j+1,v23509=v25098+v25099,
v20174=v23509+", which is of type '",v25910=args.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v25100=v25910[j];var v23510=v25100.type,v20175=JAMScript.call(v23510.getTypeName,v23510,[]),v14576=v20174+v20175,v5084=v14576+"'";JAMScript.call(comparisonInfo.setMessage,comparisonInfo,[v5084])}break}JAMScript.call(this.resetProvisionalErrors,this,[]);if(miss)break}}}}var j=j+1,v20176=args.members,v14577=v20176.length,v5090=j<v14577}}var v20177=args.members,
v14578=v20177.length,v5092=j==v14578;if(v5092){var v5091=applicableSigs.length;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v14579=signatures[i];applicableSigs[v5091]={signature:v14579,hadProvisionalErrors:hadProvisionalErrors}}var hadProvisionalErrors=!1,i=i+1,v14580=signatures.length,v5093=i<v14580}return applicableSigs}function v944(signatures,args){function v943(index){index=index?Q.signature:best.signature;index=index.returnType;return index=index.type}
function v942(index,type){}function v941(){return 2}var v14583=signatures.length;if(v14583=1==v14583)return v14583=signatures[0],v14583=v14583.signature,{sig:v14583,ambiguous:!1};for(var best=signatures[0],Q=null,AType=null,PType=null,QType=null,ambiguous=!1,v14583=1,AType=signatures.length,AType=v14583<AType;AType;){Q=signatures[v14583];ambiguous=ambiguous=0;if(AType=args)AType=args.members,AType=AType.length,AType=ambiguous<AType;for(;AType;){AType=args.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)AType=
AType[ambiguous];AType=AType.type;PType=best.signature;PType=PType.parameters;PType=PType.length;if(PType=ambiguous<PType){PType=best.signature;PType=PType.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)PType=PType[ambiguous];PType=JAMScript.call(PType.getType,PType,[])}else{PType=best.signature;PType=PType.parameters;QType=best.signature;QType=QType.parameters;QType=QType.length;QType-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)PType=
PType[QType];PType=JAMScript.call(PType.getType,PType,[]);PType=PType.elementType}QType=Q.signature;QType=QType.parameters;QType=QType.length;if(QType=ambiguous<QType){QType=Q.signature;QType=QType.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)QType=QType[ambiguous];QType=JAMScript.call(QType.getType,QType,[])}else{var QType=Q.signature,QType=QType.parameters,v26344=Q.signature,v26344=v26344.parameters,v26344=v26344.length,v26344=v26344-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)QType=
QType[v26344];QType=JAMScript.call(QType.getType,QType,[]);QType=QType.elementType}v26344=JAMScript.call(this.typesAreIdentical,this,[PType,QType]);if(!v26344)if(v26344=JAMScript.call(this.typesAreIdentical,this,[AType,PType]))break;else if(AType=JAMScript.call(this.typesAreIdentical,this,[AType,QType])){best=Q;break}else if(AType=JAMScript.call(this.sourceIsSubtypeOfTarget,this,[PType,QType]))break;else if(AType=JAMScript.call(this.sourceIsSubtypeOfTarget,this,[QType,PType])){best=Q;break}else if(AType=
Q.hadProvisionalErrors)break;else if(AType=best.hadProvisionalErrors){best=Q;break}ambiguous+=1;if(AType=args)AType=args.members,AType=AType.length,AType=ambiguous<AType}AType=!args;if(PType=!AType)AType=args.members,AType=AType.length,AType=ambiguous==AType;(ambiguous=AType)?(ambiguous={getLength:v941,setTypeAtIndex:v942,getTypeAtIndex:v943},AType=best.signature,AType=AType.returnType,AType=AType.type,ambiguous=JAMScript.call(this.findBestCommonType,this,[AType,null,ambiguous,!0]),ambiguous=!ambiguous):
ambiguous=!1;v14583+=1;AType=signatures.length;AType=v14583<AType}v14583=best.signature;return{sig:v14583,ambiguous:ambiguous}}function v940(typeLink,scope){this.resolvingBases=!0;JAMScript.call(this.resolveTypeLink,this,[scope,typeLink,!0]);this.resolvingBases=!1;var extendsType=null,extendsType=typeLink.type;(extendsType=JAMScript.call(extendsType.isClass,extendsType,[]))?(extendsType=typeLink.type,extendsType=extendsType.instanceType):extendsType=typeLink.type;return extendsType}function v939(scope,
typeLink,supplyVar){var arrayCount=0,v14599=typeLink.type,v5156=null==v14599;if(v5156){var ast=typeLink.ast;if(ast)for(var v14600=typeLink.type,v5150=null==v14600;v5150;){var v5149=ast.nodeType;switch(v5149){case TypeScript.NodeType.Name:var identifier=ast,v5114=identifier.text,symbol=JAMScript.call(scope.find,scope,[v5114,!1,!0]),v5126=null==symbol;if(v5126){typeLink.type=this.anyType;var v5115=this.errorReporter,v5116=identifier.actualText;JAMScript.call(v5115.unresolvedSymbol,v5115,[identifier,
v5116])}else{var v5125=JAMScript.call(symbol.isType,symbol,[]);if(v5125){var v14601=JAMScript.call(symbol.visible,symbol,[scope,this]),v5119=!v14601;if(v5119){var v5117=this.errorReporter,v20191=identifier.actualText,v14602="The symbol '"+v20191,v5118=v14602+"' is not visible at this point";JAMScript.call(v5117.simpleError,v5117,[ast,v5118])}identifier.sym=symbol;var v5120=typeLink,v26941=JAMScript.call(symbol.getType,symbol,[]);v5120.type=v26941;var v5123=typeLink.type;if(v5123){var v14603=typeLink.type,
v5122=JAMScript.call(v14603.isClass,v14603,[]);if(v5122){var v5121=typeLink.type;typeLink.type=v5121.instanceType}}else typeLink.type=this.anyType}else{typeLink.type=this.anyType;var v5124=this.errorReporter;JAMScript.call(v5124.simpleError,v5124,[ast,"Expected type"])}}break;case TypeScript.NodeType.Dot:var v5127=typeLink,v26942=JAMScript.call(this.resolveTypeMember,this,[scope,ast]);v5127.type=v26942;break;case TypeScript.NodeType.TypeRef:var typeRef=ast,arrayCount=typeRef.arrayCount,ast=typeRef.term,
v5128=null==ast;v5128&&(typeLink.type=this.anyType);break;case TypeScript.NodeType.InterfaceDeclaration:var interfaceDecl=ast,v5129=TypeScript.Type,interfaceType=JAMScript.new(v5129,[]),v5130=TypeScript.TypeSymbol,v14604=interfaceDecl.name,v5131=v14604.text,v5132=ast.minChar,v14605=ast.limChar,v14606=ast.minChar,v5133=v14605-v14606,v14607=this.locationInfo,v5134=v14607.unitIndex,interfaceSymbol=JAMScript.new(v5130,[v5131,v5132,v5133,v5134,interfaceType]);interfaceType.symbol=interfaceSymbol;var v5135=
interfaceType,v14608=TypeScript.ScopedMembers,v20192=TypeScript.DualStringHashTable,v23522=TypeScript.StringHashTable,v20193=JAMScript.new(v23522,[]),v23523=TypeScript.StringHashTable,v20194=JAMScript.new(v23523,[]),v14609=JAMScript.new(v20192,[v20193,v20194]),v26943=JAMScript.new(v14608,[v14609]);v5135.members=v26943;var v5136=interfaceType,v14610=TypeScript.SymbolTableScope,v14611=interfaceType.members,v26944=JAMScript.new(v14610,[v14611,null,null,null,interfaceSymbol]);v5136.containedScope=v26944;
var v5137=interfaceType.containedScope;v5137.container=interfaceSymbol;interfaceType.memberScope=interfaceType.containedScope;for(var memberList=interfaceDecl.members,props=memberList.members,propsLen=props.length,j=0,v5147=j<propsLen;v5147;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var propDecl=props[j];var propSym=null,addMember=!0,id=null,v14612=propDecl.nodeType,v20195=TypeScript.NodeType,v14613=v20195.FuncDecl,v5142=v14612==v14613;if(v5142){var funcDecl=
propDecl,id=funcDecl.name,v14614=interfaceType.members,v5138=v14614.allMembers,v5139=JAMScript.call(funcDecl.getNameText,funcDecl,[]),propSym=JAMScript.call(v5138.lookup,v5138,[v5139]),addMember=null==propSym,v5140=JAMScript.call(funcDecl.isSpecialFn,funcDecl,[]);v5140?(addMember=!1,propSym=JAMScript.call(this.resolveFuncDecl,this,[funcDecl,scope,interfaceSymbol])):propSym=JAMScript.call(this.resolveFuncDecl,this,[funcDecl,scope,propSym]);funcDecl.type=propSym.type}else var id=propDecl.id,propSym=
JAMScript.call(this.resolveVarDecl,this,[propDecl,scope]),v5141=JAMScript.call(id.isMissing,id,[]),addMember=!v5141;if(addMember){var v14615=id;if(v14615)var v20196=id.flags,v23524=TypeScript.ASTFlags,v20197=v23524.OptionalName,v14615=JAMScript.call(TypeScript.hasFlag,TypeScript,[v20196,v20197]);var v5143=v14615;if(v5143){var v14616=propSym.flags,v20198=TypeScript.SymbolFlags,v14617=v20198.Optional;propSym.flags=v14616|v14617}var v23525=interfaceType.members,v20199=v23525.allMembers,v20200=propSym.name,
v14618=JAMScript.call(v20199.add,v20199,[v20200,propSym]),v5146=!v14618;if(v5146){var v5144=this.errorReporter,v5145=propSym.name;JAMScript.call(v5144.duplicateIdentifier,v5144,[ast,v5145])}}j+=1;v5147=j<propsLen}ast.type=interfaceType;typeLink.type=interfaceType;break;case TypeScript.NodeType.FuncDecl:var tsym=JAMScript.call(this.resolveFuncDecl,this,[ast,scope,null]);typeLink.type=tsym.type;break;default:typeLink.type=this.anyType;var v5148=this.errorReporter;JAMScript.call(v5148.simpleError,v5148,
[ast,"Expected type"])}var v14619=typeLink.type,v5150=null==v14619}for(var count=arrayCount,v5152=0<count;v5152;){var v5151=typeLink,v14620=typeLink.type,v26945=JAMScript.call(this.makeArrayType,this,[v14620]);v5151.type=v26945;count-=1;v5152=0<count}var v14621=supplyVar;if(v14621)var v20201=typeLink.type,v14621=null==v20201;var v5153=v14621;v5153&&(typeLink.type=this.anyType);var v5155=typeLink.ast;if(v5155){var v5154=typeLink.ast;v5154.type=typeLink.type}}}function v938(varDecl,scope){var v5157=
TypeScript.ValueLocation,v5157=JAMScript.new(v5157,[]),v5158=TypeScript.FieldSymbol,v14622=varDecl.id,v14622=v14622.text,v5160=varDecl.minChar,v14623=this.locationInfo,v14623=v14623.unitIndex,v20202=varDecl.varFlags,v23526=TypeScript.VarFlags,v23526=v23526.Readonly,v20202=v20202&v23526,v23526=TypeScript.VarFlags,v23526=v23526.None,v20202=v20202==v23526,v5158=JAMScript.new(v5158,[v14622,v5160,v14623,v20202,v5157]),v14622=varDecl.varFlags;JAMScript.call(v5158.transferVarFlags,v5158,[v14622]);v5157.symbol=
v5158;v5158.declAST=varDecl;v14622=v5157;v5160=varDecl.typeExpr;v14623=varDecl.init;v14623=null==v14623;v5160=JAMScript.call(TypeScript.getTypeLink,TypeScript,[v5160,this,v14623]);v14622.typeLink=v5160;v14622=v5157.typeLink;JAMScript.call(this.resolveTypeLink,this,[scope,v14622,!0]);varDecl.sym=v5158;v5157=v5157.typeLink;varDecl.type=v5157.type;return v5158}function v937(funcDecl,scope,fgSym){var v23527=scope.container;fgSym=JAMScript.call(this.createFunctionSignature,this,[funcDecl,v23527,scope,
fgSym,!1]);fgSym=fgSym.declAST;fgSym=fgSym.type;fgSym=fgSym.symbol;(v23527=JAMScript.call(funcDecl.isConstructMember,funcDecl,[]))?(v23527=fgSym.type,v23527=v23527.construct):(v23527=JAMScript.call(funcDecl.isIndexerMember,funcDecl,[]))?(v23527=fgSym.type,v23527=JAMScript.call(v23527.getInstanceType,v23527,[]),v23527=v23527.index):(v23527=fgSym.type,v23527=v23527.call);var v23527=v23527.signatures,v14632=v23527.length,v14632=v14632-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v23527=
v23527[v14632];for(var v14632=v23527.parameters,v14632=v14632.length,i=0,v5177=i<v14632;v5177;){v5177=v23527.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v5177=v5177[i];v5177=v5177.parameter;v5177=v5177.typeLink;JAMScript.call(this.resolveTypeLink,this,[scope,v5177,!0]);i+=1;v5177=i<v14632}if(i=v14632)i=funcDecl.variableArgList;if(i){i=v23527.parameters;v5177=v14632-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)i=
i[v5177];i=i.parameter;i=i.typeLink;i=i.type;i=i.elementType;if(i=!i){var i=this.errorReporter,v5177=v23527.parameters,v23530=v14632-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v5177=v5177[v23530];v5177=v5177.parameter;v5177=v5177.symbol;JAMScript.call(i.simpleErrorFromSym,i,[v5177,"... parameter must have array type"]);i=v23527.parameters;v5177=v14632-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)i=i[v5177];i=i.parameter;
i=i.typeLink;v5177=v23527.parameters;v14632-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v14632=v5177[v14632];v14632=v14632.parameter;v14632=v14632.typeLink;v14632=v14632.type;v14632=JAMScript.call(this.makeArrayType,this,[v14632]);i.type=v14632}}v23527=v23527.returnType;funcDecl=JAMScript.call(funcDecl.isSignature,funcDecl,[]);JAMScript.call(this.resolveTypeLink,this,[scope,v23527,funcDecl]);return fgSym}function v936(scope,dotNode){function v935(id){return JAMScript.call(scope.find,
scope,[id,!1,!0])}var lhs=dotNode.operand1,rhs=dotNode.operand2,resultType=this.anyType,lhsType=this.anyType,v14639=lhs;if(v14639&&(v14639=rhs))var v14639=rhs.nodeType,v25109=TypeScript.NodeType,v25109=v25109.Name,v14639=v14639==v25109;if(v14639){v14639=lhs.nodeType;v25109=TypeScript.NodeType;v25109=v25109.Dot;if(v14639=v14639==v25109)lhsType=JAMScript.call(this.resolveTypeMember,this,[scope,lhs]);else if(v14639=lhs.nodeType,v25109=TypeScript.NodeType,v25109=v25109.Name,v14639=v14639==v25109){var v14639=
lhs,v25109=v14639.text,v25109=JAMScript.call(scope.find,scope,[v25109,!1,!0]),v5202=null==v25109;if(v5202)v25109=this.errorReporter,v5202=v14639.actualText,JAMScript.call(v25109.unresolvedSymbol,v25109,[v14639,v5202]);else if(v5202=JAMScript.call(v25109.isType,v25109,[])){lhsType=v25109;if(v5202=lhsType.aliasLink)if(v5202=lhsType.type,v5202=!v5202)var v5202=lhsType.aliasLink,v5202=v5202.alias,v5202=v5202.nodeType,v25111=TypeScript.NodeType,v25111=v25111.Name,v5202=v5202==v25111;v5202&&(v5202=lhsType.aliasLink,
v5202=v5202.alias,v5202=v5202.text,v25111=this.locationInfo,v25111=v25111.filename,v25111=JAMScript.call(this.findSymbolForDynamicModule,this,[v5202,v25111,v935]))&&(v5202=lhsType,v25111=JAMScript.call(v25111.getType,v25111,[]),v5202.type=v25111);(v5202=TypeScript.optimizeModuleCodeGen)&&(v5202=v25109);if(v5202){if(v25111=v5202=JAMScript.call(v25109.getType,v25109,[]))if(v25111=lhsType.aliasLink)v25111=lhsType.onlyReferencedAsTypeRef;if(v25111){v5202=v5202.symbol;if(v25111=v5202=v5202.declAST)v5202=
v5202.modFlags,v25111=TypeScript.ModuleFlags,v25111=v25111.IsDynamic,v25111=JAMScript.call(TypeScript.hasFlag,TypeScript,[v5202,v25111]);if(v5202=v25111)v5202=this.resolvingBases,lhsType.onlyReferencedAsTypeRef=!v5202}}lhsType=JAMScript.call(v25109.visible,v25109,[scope,this]);if(lhsType=!lhsType)lhsType=this.errorReporter,v5202=v14639.actualText,v5202="The symbol '"+v5202,v5202+="' is not visible at this point",JAMScript.call(lhsType.simpleError,lhsType,[lhs,v5202]);lhsType=JAMScript.call(v25109.getType,
v25109,[]);v14639.sym=v25109}else v14639=this.errorReporter,JAMScript.call(v14639.simpleError,v14639,[lhs,"Expected type"])}if(v14639=!lhsType)lhsType=this.anyType;v14639=this.anyType;if(v14639=lhsType!=v14639){v14639=rhs;resultType=v14639.text;v25109=JAMScript.call(this.lookupMemberTypeSymbol,this,[lhsType,resultType]);if(resultType=null==v25109)resultType=this.anyType,lhs=this.errorReporter,JAMScript.call(lhs.simpleError,lhs,[dotNode,"Expected type"]);else if(resultType=JAMScript.call(v25109.getType,
v25109,[]),v25109=JAMScript.call(v25109.visible,v25109,[scope,this]),v25109=!v25109)v25109=this.errorReporter,rhs=rhs.actualText,rhs="The symbol '"+rhs,rhs+="' is not visible at this point",JAMScript.call(v25109.simpleError,v25109,[lhs,rhs]);v14639.sym=resultType.symbol}}if(lhs=JAMScript.call(resultType.isClass,resultType,[]))resultType=resultType.instanceType;return resultType}function v934(idText,currentFileName,search){var originalIdText=idText,symbol=JAMScript.call(search,null,[idText]);if(idText=
null==symbol){if(idText=!symbol)idText=JAMScript.call(TypeScript.swapQuotes,TypeScript,[originalIdText]),symbol=JAMScript.call(search,null,[idText]);if(idText=!symbol)symbol=JAMScript.call(TypeScript.stripQuotes,TypeScript,[originalIdText]),idText=symbol+".ts",symbol=JAMScript.call(search,null,[idText]);if(idText=!symbol)symbol=JAMScript.call(TypeScript.stripQuotes,TypeScript,[originalIdText]),idText=symbol+".str",symbol=JAMScript.call(search,null,[idText]);if(idText=!symbol)symbol=JAMScript.call(TypeScript.stripQuotes,
TypeScript,[originalIdText]),idText=symbol+".d.ts",symbol=JAMScript.call(search,null,[idText]);if(idText=!symbol)symbol=JAMScript.call(TypeScript.stripQuotes,TypeScript,[originalIdText]),idText=symbol+".d.str",symbol=JAMScript.call(search,null,[idText]);if(idText=!symbol)idText=JAMScript.call(TypeScript.isRelative,TypeScript,[originalIdText]),idText=!idText;if(idText)for(idText=originalIdText,originalIdText=JAMScript.call(TypeScript.stripQuotes,TypeScript,[idText]),currentFileName=JAMScript.call(TypeScript.switchToForwardSlashes,
TypeScript,[currentFileName]),currentFileName=JAMScript.call(TypeScript.getRootFilePath,TypeScript,[currentFileName]),(idText=null==symbol)&&(idText=""!=currentFileName);idText;){symbol=currentFileName+originalIdText;symbol+=".ts";idText=JAMScript.call(TypeScript.normalizePath,TypeScript,[symbol]);var symbol=JAMScript.call(search,null,[idText]),v5226=null==symbol;v5226&&(idText=JAMScript.call(TypeScript.changePathToSTR,TypeScript,[idText]),symbol=JAMScript.call(search,null,[idText]));if(v5226=null==
symbol)idText=JAMScript.call(TypeScript.changePathToDTS,TypeScript,[idText]),symbol=JAMScript.call(search,null,[idText]);if(v5226=null==symbol)idText=JAMScript.call(TypeScript.changePathToDSTR,TypeScript,[idText]),symbol=JAMScript.call(search,null,[idText]);if(idText=null==symbol)(idText="/"===currentFileName)?currentFileName="":(currentFileName+="..",(idText=currentFileName=JAMScript.call(TypeScript.normalizePath,TypeScript,[currentFileName]))&&(idText="/"!=currentFileName),currentFileName=idText?
currentFileName+"/":currentFileName);(idText=null==symbol)&&(idText=""!=currentFileName)}}return symbol}function v933(containingType,name){var symbol=null,v5241=containingType.containedScope;if(v5241)symbol=containingType.containedScope,symbol=JAMScript.call(symbol.find,symbol,[name,!1,!0]);else if(v5241=containingType.members){symbol=containingType.members;symbol=symbol.allMembers;symbol=JAMScript.call(symbol.lookup,symbol,[name]);if(v5241=null==symbol)v5241=containingType.ambientMembers;v5241&&
(symbol=containingType.ambientMembers,symbol=symbol.allMembers,symbol=JAMScript.call(symbol.lookup,symbol,[name]))}if(v5241=null==symbol){var typeMembers=JAMScript.call(containingType.getAllEnclosedTypes,containingType,[]),v5241=JAMScript.call(containingType.getAllAmbientEnclosedTypes,containingType,[]);typeMembers&&(symbol=typeMembers.allMembers,symbol=JAMScript.call(symbol.lookup,symbol,[name]),(typeMembers=null==symbol)&&(typeMembers=v5241),typeMembers&&(symbol=v5241.allMembers,symbol=JAMScript.call(symbol.lookup,
symbol,[name])))}(v5241=symbol)&&(v5241=JAMScript.call(symbol.isType,symbol,[]));return v5241?symbol:null}function v932(type){var v5247=TypeScript.SymbolAggregateScope,v5248=type.symbol,v5247=JAMScript.new(v5247,[v5248]);if(v5248=type.symbol)v5248=type.symbol,v5248=v5248.name;v5248?(v5248=type.symbol,v5248=v5248.name):v5248="{}";var v5250=type.typeID,v5248={base:v5248,baseId:v5250};JAMScript.call(this.addBases,this,[v5247,type,v5248]);return v5247}function v931(resultScope,type,baseContext){var v14666=
TypeScript.SymbolTableScope,v14667=type.members,v14668=type.ambientMembers,v14669=JAMScript.call(type.getAllEnclosedTypes,type,[]),v14670=JAMScript.call(type.getAllAmbientEnclosedTypes,type,[]),v14671=type.symbol,v14666=JAMScript.new(v14666,[v14667,v14668,v14669,v14670,v14671]);JAMScript.call(resultScope.addParentScope,resultScope,[v14666]);v14667=0;if(v14666=type.extendsList)for(v14666=type.extendsList,v14668=v14666.length,v14666=v14667<v14668;v14666;){v14666=type.extendsList;v14666=v14666[v14667];
v14669=baseContext.baseId;v14670=v14666.typeID;if(v14669=v14669==v14670){resultScope=this.errorReporter;type=v14666.symbol;baseContext=baseContext.base;baseContext="Type '"+baseContext;baseContext+="' is recursively referenced as a base class of itself";JAMScript.call(resultScope.reportErrorFromSym,resultScope,[type,baseContext]);baseContext=v14666.symbol;resultScope=baseContext.flags;type=TypeScript.SymbolFlags;type=type.RecursivelyReferenced;baseContext.flags=resultScope|type;break}JAMScript.call(this.addBases,
this,[resultScope,v14666,baseContext]);v14667+=1;v14666=v14667<v14668}}function v930(funcDecl,fgSym,enclosingClass,addToMembers,isClassProperty,scope,container){var accessorSym=null,sig=funcDecl.signature,accessorSym=funcDecl.name,nameText=accessorSym.text,accessorSym=funcDecl.fncFlags,v14675=TypeScript.FncFlags,v14675=v14675.Static,v14675=JAMScript.call(TypeScript.hasFlag,TypeScript,[accessorSym,v14675]),accessorSym=funcDecl.fncFlags,v14676=TypeScript.FncFlags,v14676=v14676.Private,v14676=JAMScript.call(TypeScript.hasFlag,
TypeScript,[accessorSym,v14676]);if(accessorSym=null==fgSym){accessorSym=TypeScript.ValueLocation;fgSym=JAMScript.new(accessorSym,[]);var accessorSym=TypeScript.FieldSymbol,v5268=funcDecl.minChar,v14677=this.locationInfo,v14677=v14677.unitIndex,accessorSym=JAMScript.new(accessorSym,[nameText,v5268,v14677,!1,fgSym]);fgSym.symbol=accessorSym;accessorSym.declAST=funcDecl;v5268=funcDecl.fncFlags;v14677=TypeScript.FncFlags;v14677=v14677.GetAccessor;if(v5268=JAMScript.call(TypeScript.hasFlag,TypeScript,
[v5268,v14677])){if(v5268=accessorSym.getter)v5268=this.errorReporter,JAMScript.call(v5268.simpleError,v5268,[funcDecl,"Redeclaration of property getter"]);sig=sig.declAST;sig=sig.type;accessorSym.getter=sig.symbol}else{if(v5268=accessorSym.setter)v5268=this.errorReporter,JAMScript.call(v5268.simpleError,v5268,[funcDecl,"Redeclaration of property setter"]);sig=sig.declAST;sig=sig.type;accessorSym.setter=sig.symbol}sig=fgSym;fgSym=JAMScript.call(TypeScript.getTypeLink,TypeScript,[null,this,!1]);sig.typeLink=
fgSym;if(addToMembers)if(enclosingClass){scope=enclosingClass.members;scope=scope.publicMembers;scope=JAMScript.call(scope.add,scope,[nameText,accessorSym]);if(scope=!scope)scope=this.errorReporter,container=accessorSym.name,JAMScript.call(scope.duplicateIdentifier,scope,[funcDecl,container]);accessorSym.container=enclosingClass.symbol}else enclosingClass=this.errorReporter,JAMScript.call(enclosingClass.simpleError,enclosingClass,[funcDecl,"Accessor property may not be added in this context"]);else enclosingClass=
this.errorReporter,nameText=!v14676,(addToMembers=!nameText)&&(nameText=v14675),JAMScript.call(scope.enter,scope,[container,funcDecl,accessorSym,enclosingClass,nameText,!1,!1]);isClassProperty&&(funcDecl=accessorSym.flags,isClassProperty=TypeScript.SymbolFlags,isClassProperty=isClassProperty.Property,accessorSym.flags=funcDecl|isClassProperty);v14675&&(funcDecl=accessorSym.flags,isClassProperty=TypeScript.SymbolFlags,isClassProperty=isClassProperty.Static,accessorSym.flags=funcDecl|isClassProperty);
v14676?(funcDecl=accessorSym.flags,isClassProperty=TypeScript.SymbolFlags,isClassProperty=isClassProperty.Private):(funcDecl=accessorSym.flags,isClassProperty=TypeScript.SymbolFlags,isClassProperty=isClassProperty.Public);accessorSym.flags=funcDecl|isClassProperty}else{accessorSym=fgSym;isClassProperty=v14676;v14675=accessorSym.flags;v14676=TypeScript.SymbolFlags;v14676=v14676.Private;v14675=JAMScript.call(TypeScript.hasFlag,TypeScript,[v14675,v14676]);if(isClassProperty=isClassProperty!=v14675)isClassProperty=
this.errorReporter,JAMScript.call(isClassProperty.simpleError,isClassProperty,[funcDecl,"Getter and setter accessors do not agree in visibility"]);isClassProperty=funcDecl.fncFlags;v14675=TypeScript.FncFlags;v14675=v14675.GetAccessor;if(isClassProperty=JAMScript.call(TypeScript.hasFlag,TypeScript,[isClassProperty,v14675])){if(isClassProperty=accessorSym.getter)isClassProperty=this.errorReporter,JAMScript.call(isClassProperty.simpleError,isClassProperty,[funcDecl,"Redeclaration of property getter"]);
funcDecl=funcDecl.type;accessorSym.getter=funcDecl.symbol}else{if(isClassProperty=accessorSym.setter)isClassProperty=this.errorReporter,JAMScript.call(isClassProperty.simpleError,isClassProperty,[funcDecl,"Redeclaration of property setter"]);funcDecl=funcDecl.type;accessorSym.setter=funcDecl.symbol}}return accessorSym}function v929(funcDecl,container,scope,overloadGroupSym,addToScope){var v14696=funcDecl.fncFlags,v23544=TypeScript.FncFlags,v20238=v23544.Exported,v23545=TypeScript.FncFlags,v20239=
v23545.ClassPropertyMethodExported,v14697=v20238|v20239,v5294=JAMScript.call(TypeScript.hasFlag,TypeScript,[v14696,v14697]),v14699=!v5294;if(v14699)var v14698=this.gloMod,v5294=container==v14698;var isExported=v5294,v5295=funcDecl.fncFlags,v14700=TypeScript.FncFlags,v5296=v14700.Static,isStatic=JAMScript.call(TypeScript.hasFlag,TypeScript,[v5295,v5296]),v5297=funcDecl.fncFlags,v14701=TypeScript.FncFlags,v5298=v14701.Private,isPrivate=JAMScript.call(TypeScript.hasFlag,TypeScript,[v5297,v5298]),v5299=
funcDecl.fncFlags,v14702=TypeScript.FncFlags,v5300=v14702.Definition,isDefinition=JAMScript.call(TypeScript.hasFlag,TypeScript,[v5299,v5300]),v5301=funcDecl.fncFlags,v14703=TypeScript.FncFlags,v5302=v14703.Ambient,isAmbient=JAMScript.call(TypeScript.hasFlag,TypeScript,[v5301,v5302]),v5303=JAMScript.call(funcDecl.isConstructMember,funcDecl,[]),v14704=!v5303;v14704&&(v5303=funcDecl.isConstructor);var isConstructor=v5303,v5304=this.gloMod,isGlobal=container==v5304,v5305=TypeScript.Signature,signature=
JAMScript.new(v5305,[]),v5306=funcDecl.fncFlags,v14705=TypeScript.FncFlags,v5307=v14705.IsFunctionExpression,isLambda=v5306&v5307,v14706=funcDecl.returnTypeAnnotation,v20240=!v14706;v20240&&(v14706=isDefinition);var v5311=v14706;if(v5311){var v5308=signature,v14707=funcDecl.returnTypeAnnotation,v26950=JAMScript.call(TypeScript.getTypeLink,TypeScript,[v14707,this,!1]);v5308.returnType=v26950}else{var v5309=signature,v14708=TypeScript.TypeLink,v26951=JAMScript.new(v14708,[]);v5309.returnType=v26951;
var v5310=signature.returnType;v5310.type=this.anyType}signature.hasVariableArgList=funcDecl.variableArgList;var sigData=JAMScript.call(this.getParameterList,this,[funcDecl,container]);signature.parameters=sigData.parameters;signature.nonOptionalParameterCount=sigData.nonOptionalParameterCount;funcDecl.signature=signature;signature.declAST=funcDecl;var v5312=overloadGroupSym;if(v5312){var v14709=JAMScript.call(overloadGroupSym.getType,overloadGroupSym,[]);if(v14709){var v23546=JAMScript.call(overloadGroupSym.isAccessor,
overloadGroupSym,[]),v20241=!v23546;if(v20241){var v23547=JAMScript.call(funcDecl.isSignature,funcDecl,[]),v25115=!v23547;if(v25115)var v25113=isAmbient,v25917=overloadGroupSym.flags,v26347=TypeScript.SymbolFlags,v25918=v26347.Ambient,v25114=JAMScript.call(TypeScript.hasFlag,TypeScript,[v25917,v25918]),v23547=v25113==v25114;v20241=v23547}v14709=v20241}v5312=v14709}var useOverloadGroupSym=v5312,v14710=useOverloadGroupSym;if(v14710)var v20242=isPrivate,v23548=overloadGroupSym.flags,v25116=TypeScript.SymbolFlags,
v23549=v25116.Private,v20243=JAMScript.call(TypeScript.hasFlag,TypeScript,[v23548,v23549]),v14710=v20242!=v20243;var v5314=v14710;if(v5314){var v5313=this.errorReporter;JAMScript.call(v5313.simpleError,v5313,[funcDecl,"Public/Private visibility of overloads does not agree"])}var v5315;if(useOverloadGroupSym)v5315=JAMScript.call(overloadGroupSym.getType,overloadGroupSym,[]);else{var v14711=TypeScript.Type;v5315=JAMScript.new(v14711,[])}var groupType=v5315;if(isConstructor){var v14712=groupType.construct,
v5317=null==v14712;if(v5317){var v5316=groupType,v14713=TypeScript.SignatureGroup,v26952=JAMScript.new(v14713,[]);v5316.construct=v26952}var v5318=groupType.construct;JAMScript.call(v5318.addSignature,v5318,[signature]);var v5319=groupType.construct,v14714=JAMScript.call(funcDecl.isSignature,funcDecl,[]);v5319.hasImplementation=!v14714;var v14715=groupType.construct,v5320=v14715.hasImplementation;v5320&&JAMScript.call(groupType.setHasImplementation,groupType,[])}else{var v5332=JAMScript.call(funcDecl.isIndexerMember,
funcDecl,[]);if(v5332){var v14716=groupType.index,v5323=null==v14716;if(v5323){var v5321=groupType,v14717=TypeScript.SignatureGroup,v26953=JAMScript.new(v14717,[]);v5321.index=v26953;var v5322=groupType.index,v20244=v5322.flags,v23550=TypeScript.SignatureFlags,v20245=v23550.IsIndexer;v5322.flags=v20244|v20245}var v5324=groupType.index;JAMScript.call(v5324.addSignature,v5324,[signature]);var v5325=groupType.index,v14718=JAMScript.call(funcDecl.isSignature,funcDecl,[]);v5325.hasImplementation=!v14718;
var v14719=groupType.index,v5326=v14719.hasImplementation;v5326&&JAMScript.call(groupType.setHasImplementation,groupType,[])}else{var v14720=groupType.call,v5328=null==v14720;if(v5328){var v5327=groupType,v14721=TypeScript.SignatureGroup,v26954=JAMScript.new(v14721,[]);v5327.call=v26954}var v5329=groupType.call;JAMScript.call(v5329.addSignature,v5329,[signature]);var v5330=groupType.call,v14722=JAMScript.call(funcDecl.isSignature,funcDecl,[]);v5330.hasImplementation=!v14722;var v14723=groupType.call,
v5331=v14723.hasImplementation;v5331&&JAMScript.call(groupType.setHasImplementation,groupType,[])}}var instanceType=groupType.instanceType,funcName=null,usedHint=!1,v14724=funcDecl.name;if(v14724)var v23551=funcDecl.name,v20246=JAMScript.call(v23551.isMissing,v23551,[]),v14724=!v20246;var v5335=v14724;if(v5335)var v5333=funcDecl.name,funcName=v5333.text;else{var v5334=funcDecl.hint;v5334&&(funcName=funcDecl.hint,usedHint=!0)}var v14725=groupType.symbol,v5339=null==v14725;if(v5339){var v5336=groupType,
v14726=TypeScript.TypeSymbol,v20247,v14727=v20247=funcName?funcName:this.anon,v14728=funcDecl.minChar,v20248=funcDecl.limChar,v20249=funcDecl.minChar,v14729=v20248-v20249,v20250=this.locationInfo,v14730=v20250.unitIndex,v26955=JAMScript.new(v14726,[v14727,v14728,v14729,v14730,groupType]);v5336.symbol=v26955;var v5338=!useOverloadGroupSym;if(v5338){var v5337=groupType.symbol;v5337.declAST=funcDecl}}if(isStatic){var v5340=groupType.symbol,v20251=v5340.flags,v23552=TypeScript.SymbolFlags,v20252=v23552.Static;
v5340.flags=v20251|v20252}if(isAmbient){var v5341=groupType.symbol,v20253=v5341.flags,v23553=TypeScript.SymbolFlags,v20254=v23553.Ambient;v5341.flags=v20253|v20254}if(isPrivate){var v5342=groupType.symbol,v20255=v5342.flags,v23554=TypeScript.SymbolFlags,v20256=v23554.Private;v5342.flags=v20255|v20256}var v5343=groupType.symbol,v26956=JAMScript.call(funcDecl.isMethod,funcDecl,[]);v5343.isMethod=v26956;var v14731=groupType.symbol,v5345=v14731.isMethod;if(v5345){var v5344=groupType.symbol,v20257=v5344.flags,
v23555=TypeScript.SymbolFlags,v20258=v23555.Property;v5344.flags=v20257|v20258}funcDecl.type=groupType;var v5359=!isConstructor;if(v5359){var v14732=funcName;if(v14732){var v20259=!isLambda;if(v20259){var v25117=JAMScript.call(funcDecl.isAccessor,funcDecl,[]),v23556=!v25117;v23556&&(v23556=!usedHint);v20259=v23556}v14732=v20259}var v5358=v14732;if(v5358)if(addToScope){var v14733=JAMScript.call(funcDecl.isMethod,funcDecl,[]);v14733&&(v14733=isStatic);var v5353=v14733;if(v5353){var v25118=container.type,
v23557=v25118.members,v20260=v23557.publicMembers,v20261=groupType.symbol,v14734=JAMScript.call(v20260.add,v20260,[funcName,v20261]),v5347=!v14734;if(v5347){var v5346=this.errorReporter;JAMScript.call(v5346.duplicateIdentifier,v5346,[funcDecl,funcName])}var v5348=groupType.symbol;v5348.container=container}else{var v14735=null==overloadGroupSym,v20263=!v14735;if(v20263){var v20262=overloadGroupSym.declAST;if(v20262){var v25919=overloadGroupSym.declAST,v25119=v25919.isOverload,v23558=!v25119;v23558&&
(v23558=JAMScript.call(container.isType,container,[]));v20262=v23558}v14735=v20262}var v5352=v14735;if(v5352){var v5349=groupType.symbol,v5350=this.errorReporter,v14736=!isPrivate;if(v14736){var v20264=isExported,v23559=!v20264;v23559&&(v20264=isStatic||isGlobal);v14736=v20264}var v5351=v14736;JAMScript.call(scope.enter,scope,[container,funcDecl,v5349,v5350,v5351,!1,isAmbient])}}}else{var v14737=JAMScript.call(funcDecl.isSpecialFn,funcDecl,[]),v5355=!v14737;if(v5355){var v5354=groupType.symbol;v5354.container=
container}}else{var v14738=JAMScript.call(funcDecl.isSpecialFn,funcDecl,[]),v5357=!v14738;if(v5357){var v5356=groupType.symbol;v5356.container=container}}}if(useOverloadGroupSym){var v5360,overloadGroupType=v5360=overloadGroupSym?JAMScript.call(overloadGroupSym.getType,overloadGroupSym,[]):null,classType=groupType,v5381=classType!=overloadGroupType;if(v5381){var v14739=classType.construct,v5366=null==v14739;if(v5366){var v14740=overloadGroupType;v14740&&(v14740=overloadGroupType.construct);var v5362=
v14740;if(v5362)classType.construct=overloadGroupType.construct;else{var v5361=classType,v14741=TypeScript.SignatureGroup,v26957=JAMScript.new(v14741,[]);v5361.construct=v26957}}else if(overloadGroupType){var v5365=overloadGroupType.construct;if(v5365){var v14742=classType.construct,v5363=v14742.signatures,v14743=overloadGroupType.construct,v5364=v14743.signatures;v5363.concat(v5364)}}if(overloadGroupType){var v14744=classType.call,v5370=null==v14744;if(v5370)classType.call=overloadGroupType.call;
else{var v5369=overloadGroupType.call;if(v5369){var v14745=classType.call,v5367=v14745.signatures,v14746=overloadGroupType.call,v5368=v14746.signatures;v5367.concat(v5368)}}var v5376=!isStatic;if(v5376){var v14747=classType.instanceType,v5371=null==v14747;v5371&&(classType.instanceType=overloadGroupType.instanceType);if(instanceType=classType.instanceType){var v14748=instanceType.call,v5375=null==v14748;if(v5375)instanceType.call=overloadGroupType.call;else{var v5374=overloadGroupType.call;if(v5374){var v14749=
instanceType.call,v5372=v14749.signatures,v14750=overloadGroupType.call,v5373=v14750.signatures;v5372.concat(v5373)}}}}var v14751=classType.index,v5380=null==v14751;if(v5380)classType.index=overloadGroupType.index;else{var v5379=overloadGroupType.index;if(v5379){var v14752=classType.index,v5377=v14752.signatures,v14753=overloadGroupType.index,v5378=v14753.signatures;v5377.concat(v5378)}}}}}return signature}function v928(funcDecl,container){var args=funcDecl.arguments,parameterTable=null,parameterTable=
null,v5382=args.members,v5382=v5382.length,nonOptionalParams=0,result=[];if(parameterTable=0<v5382)for(var parameterTable=TypeScript.ScopedMembers,v14754=TypeScript.DualStringHashTable,v20265=TypeScript.StringHashTable,v20265=JAMScript.new(v20265,[]),v20266=TypeScript.StringHashTable,v20266=JAMScript.new(v20266,[]),v14754=JAMScript.new(v14754,[v20265,v20266]),parameterTable=JAMScript.new(parameterTable,[v14754]),v14754=TypeScript.SymbolScopeBuilder,parameterTable=JAMScript.new(v14754,[parameterTable,
null,null,null,null,container]),v14754=0,v20265=v14754<v5382;v20265;){v20265=args.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v20265=v20265[v14754];var v20266=TypeScript.ValueLocation,v20266=JAMScript.new(v20266,[]),v5388=TypeScript.ParameterSymbol,v14757=v20265.id,v14757=v14757.text,v5390=v20265.minChar,v14758=this.locationInfo,v14758=v14758.unitIndex,v5388=JAMScript.new(v5388,[v14757,v5390,v14758,v20266]);v5388.declAST=v20265;v5388.funcDecl=funcDecl;
v14757=v20265.id;v14757.sym=v5388;v20265.sym=v5388;v20266.symbol=v5388;v14757=v20265.typeExpr;v14757=JAMScript.call(TypeScript.getTypeLink,TypeScript,[v14757,this,!1]);v20266.typeLink=v14757;v20266=this.errorReporter;JAMScript.call(parameterTable.enter,parameterTable,[null,v20265,v5388,v20266,!0,!1,!1]);v20266=result.length;result[v20266]=v5388;v20265=JAMScript.call(v20265.isOptionalArg,v20265,[]);(v20265=!v20265)&&(nonOptionalParams+=1);v14754+=1;v20265=v14754<v5382}return{parameters:result,nonOptionalParameterCount:nonOptionalParams}}
function v927(type){var v14761=type.arrayCache;if(v14761=null==v14761){var v14761=type,v26959=JAMScript.new(ArrayCache,[]);v14761.arrayCache=v26959;v14761=type.arrayCache;v26959=TypeScript.Type;v26959=JAMScript.new(v26959,[]);v14761.arrayType=v26959;v14761=type.arrayCache;v14761=v14761.arrayType;v14761.elementType=type;v14761=type.arrayCache;v14761=v14761.arrayType;v14761.symbol=type.symbol}type=type.arrayCache;return type.arrayType}function v926(ast){var v14765=ast.nodeType,v20267=TypeScript.NodeType,
v20267=v20267.Script;if(v14765=v14765==v20267)v14765=ast,this.locationInfo=v14765.locationInfo;var v14765=TypeScript.ScopeChain,v20267=this.gloMod,v5408=this.globalScope,v14765=JAMScript.new(v14765,[v20267,null,v5408]),v20267=TypeScript.TypeCollectionContext,v14765=JAMScript.new(v20267,[v14765,this]),v20267=JAMScript.call(TypeScript.getAstWalkerFactory,TypeScript,[]),v5408=TypeScript.preCollectTypes,v5412=TypeScript.postCollectTypes;JAMScript.call(v20267.walk,v20267,[ast,v5408,v5412,null,v14765])}
function v925(){for(var i=0,v20268=this.provisionalStartedTypecheckObjects,v20268=v20268.length,v20268=i<v20268;v20268;){v20268=this.provisionalStartedTypecheckObjects;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v20268=v20268[i];var v20268=v20268.typeCheckStatus,v20270=this.typingContextStack,v20270=JAMScript.call(v20270.getContextID,v20270,[]);if(v20268=v20268>=v20270){v20268=this.provisionalStartedTypecheckObjects;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v20268=
v20268[i];v20270=TypeScript.TypeCheckStatus;v20268.typeCheckStatus=v20270.NotStarted}i+=1;v20268=this.provisionalStartedTypecheckObjects;v20268=v20268.length;v20268=i<v20268}this.provisionalStartedTypecheckObjects=[]}function v924(pto){var v5418=JAMScript.call(this.inProvisionalTypecheckMode,this,[]);if(v5418){var v14773=v5418=this.provisionalStartedTypecheckObjects,v14773=v14773.length;JAMScript.set(v5418,v14773,pto)}}function v923(status){var v20272=TypeScript.TypeCheckStatus,v20272=v20272.Finished,
v20272=status==v20272,v14776=!v20272;v14776&&(v20272=JAMScript.call(this.inProvisionalTypecheckMode,this,[]))&&(v20272=this.typingContextStack,v20272=JAMScript.call(v20272.getContextID,v20272,[]),v20272=status==v20272);return v20272}function v922(){var v5421=JAMScript.call(this.inProvisionalTypecheckMode,this,[]);if(v5421)return v5421=this.typingContextStack,JAMScript.call(v5421.getContextID,v5421,[]);v5421=TypeScript.TypeCheckStatus;return v5421.Finished}function v921(){var v5423=this.typingContextStack;
return JAMScript.call(v5423.isProvisional,v5423,[])}function v920(){return this.currentContextualTypeContext}function v919(){var v5424=this.currentContextualTypeContext;v5424&&(v5424=this.currentContextualTypeContext,v5424=v5424.contextualType);return v5424}function v918(){this.currentContextualTypeContext=null;var v5425=this.errorReporter;v5425.pushToErrorSink=!1}function v917(){var v5426=this.typingContextStack;this.currentContextualTypeContext=v5426=JAMScript.call(v5426.getContextualType,v5426,
[])}function v916(contextType,provisional,condition,ast){if(condition){var v20275=this.typingContextStack,v20275=JAMScript.call(v20275.isProvisional,v20275,[]),v20276=!v20275;v20276&&(v20275=provisional);provisional=v20275;JAMScript.call(this.setContextualType,this,[contextType,provisional])}contextType=this.typeFlow;JAMScript.call(contextType.typeCheck,contextType,[ast]);condition&&JAMScript.call(this.unsetContextualType,this,[])}function v915(){var v20277=this.typingContextStack,v20277=JAMScript.call(v20277.getContextualType,
v20277,[]);if(v20277=!v20277)v20277=this.typingContextStack,v20277.hadProvisionalErrors=!1}function v914(){var v5431=this.typingContextStack;return v5431.hadProvisionalErrors}function v913(){var v5432=this.typingContextStack,v5432=JAMScript.call(v5432.popContextualType,v5432,[]),v5433=this.typingContextStack;this.currentContextualTypeContext=v5433=JAMScript.call(v5433.getContextualType,v5433,[]);return v5432}function v912(type,provisional){var v5434=this.typingContextStack;JAMScript.call(v5434.pushContextualType,
v5434,[type,provisional]);v5434=this.typingContextStack;this.currentContextualTypeContext=v5434=JAMScript.call(v5434.getContextualType,v5434,[])}function v911(style){this.styleSettings=style}function TypeChecker(persistentState){this.persistentState=persistentState;this.errorReporter=null;this.checkControlFlowUseDef=this.printControlFlowGraph=this.checkControlFlow=!1;this.units=this.styleSettings=null;this.anon="_anonymous";this.currentModDecl=this.currentCompareB=this.currentCompareA=this.typeFlow=
this.locationInfo=null;this.inWith=this.inBind=!1;this.errorsOnWith=!0;this.currentContextualTypeContext=null;this.canCallDefinitionSignature=this.resolvingBases=!1;this.assignableCache={};this.subtypeCache={};this.identicalCache={};this.provisionalStartedTypecheckObjects=[];this.mustCaptureGlobalThis=!1;persistentState=this.persistentState;this.voidType=persistentState.voidType;persistentState=this.persistentState;this.booleanType=persistentState.booleanType;persistentState=this.persistentState;
this.numberType=persistentState.doubleType;persistentState=this.persistentState;this.stringType=persistentState.stringType;persistentState=this.persistentState;this.anyType=persistentState.anyType;persistentState=this.persistentState;this.nullType=persistentState.nullType;persistentState=this.persistentState;this.undefinedType=persistentState.undefinedType;persistentState=this.persistentState;this.globals=persistentState.dualGlobalValues;persistentState=this.persistentState;this.globalTypes=persistentState.dualGlobalTypes;
persistentState=this.persistentState;this.ambientGlobals=persistentState.dualAmbientGlobalValues;persistentState=this.persistentState;this.ambientGlobalTypes=persistentState.dualAmbientGlobalTypes;persistentState=this.persistentState;this.gloModType=persistentState.mod;persistentState=this.persistentState;this.gloMod=persistentState.gloMod;persistentState=this.persistentState;this.wildElm=persistentState.wildElm;persistentState=this.persistentState;this.globalScope=persistentState.globalScope;this.typingContextStack=
persistentState=JAMScript.new(ContextualTypingContextStack,[this])}var v5451=TypeChecker.prototype;v5451.setStyleOptions=v911;v5451=TypeChecker.prototype;v5451.setContextualType=v912;v5451=TypeChecker.prototype;v5451.unsetContextualType=v913;v5451=TypeChecker.prototype;v5451.hadProvisionalErrors=v914;v5451=TypeChecker.prototype;v5451.resetProvisionalErrors=v915;v5451=TypeChecker.prototype;v5451.typeCheckWithContextualType=v916;v5451=TypeChecker.prototype;v5451.resetTargetType=v917;v5451=TypeChecker.prototype;
v5451.killCurrentContextualType=v918;v5451=TypeChecker.prototype;v5451.hasTargetType=v919;v5451=TypeChecker.prototype;v5451.getTargetTypeContext=v920;v5451=TypeChecker.prototype;v5451.inProvisionalTypecheckMode=v921;v5451=TypeChecker.prototype;v5451.getTypeCheckFinishedStatus=v922;v5451=TypeChecker.prototype;v5451.typeStatusIsFinished=v923;v5451=TypeChecker.prototype;v5451.addStartedPTO=v924;v5451=TypeChecker.prototype;v5451.cleanStartedPTO=v925;v5451=TypeChecker.prototype;v5451.collectTypes=v926;
v5451=TypeChecker.prototype;v5451.makeArrayType=v927;v5451=TypeChecker.prototype;v5451.getParameterList=v928;v5451=TypeChecker.prototype;v5451.createFunctionSignature=v929;v5451=TypeChecker.prototype;v5451.createAccessorSymbol=v930;v5451=TypeChecker.prototype;v5451.addBases=v931;v5451=TypeChecker.prototype;v5451.scopeOf=v932;v5451=TypeChecker.prototype;v5451.lookupMemberTypeSymbol=v933;v5451=TypeChecker.prototype;v5451.findSymbolForDynamicModule=v934;v5451=TypeChecker.prototype;v5451.resolveTypeMember=
v936;v5451=TypeChecker.prototype;v5451.resolveFuncDecl=v937;v5451=TypeChecker.prototype;v5451.resolveVarDecl=v938;v5451=TypeChecker.prototype;v5451.resolveTypeLink=v939;v5451=TypeChecker.prototype;v5451.resolveBaseTypeLink=v940;v5451=TypeChecker.prototype;v5451.findMostApplicableSignature=v944;v5451=TypeChecker.prototype;v5451.getApplicableSignatures=v945;v5451=TypeChecker.prototype;v5451.canContextuallyTypeFunction=v946;v5451=TypeChecker.prototype;v5451.canContextuallyTypeObjectLiteral=v947;v5451=
TypeChecker.prototype;v5451.widenType=v948;v5451=TypeChecker.prototype;v5451.isNullOrUndefinedType=v949;v5451=TypeChecker.prototype;v5451.findBestCommonType=v950;v5451=TypeChecker.prototype;v5451.typesAreIdentical=v951;v5451=TypeChecker.prototype;v5451.signatureGroupsAreIdentical=v952;v5451=TypeChecker.prototype;v5451.signaturesAreIdentical=v953;v5451=TypeChecker.prototype;v5451.sourceIsSubtypeOfTarget=v954;v5451=TypeChecker.prototype;v5451.signatureGroupIsSubtypeOfTarget=v955;v5451=TypeChecker.prototype;
v5451.signatureIsSubtypeOfTarget=v956;v5451=TypeChecker.prototype;v5451.sourceIsAssignableToTarget=v957;v5451=TypeChecker.prototype;v5451.signatureGroupIsAssignableToTarget=v958;v5451=TypeChecker.prototype;v5451.signatureIsAssignableToTarget=v959;v5451=TypeChecker.prototype;v5451.sourceIsRelatableToTarget=v960;v5451=TypeChecker.prototype;v5451.signatureGroupIsRelatableToTarget=v961;v5451=TypeChecker.prototype;v5451.signatureIsRelatableToTarget=v962;return TypeChecker}function v910(){function v909(){var v5499;
v5499=this.contextStack;v5499=v5499.length;if(v5499=!v5499)v5499=!1;else{var v25120=v5499=this.contextStack,v25120=v25120.length,v25120=v25120-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v5499=v5499[v25120];v5499=v5499.provisional}return v5499}function v908(){var v5500;v5500=this.contextStack;v5500=v5500.length;if(v5500=!v5500)v5500=TypeScript.TypeCheckStatus,v5500=v5500.Finished;else{var v25121=v5500=this.contextStack,v25121=v25121.length,v25121=v25121-1;
introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v5500=v5500[v25121];v5500=v5500.contextID}return v5500}function v907(){var v5501;v5501=this.contextStack;v5501=v5501.length;if(v5501=!v5501)v5501=null;else{var v23567=v5501=this.contextStack,v23567=v23567.length,v23567=v23567-1;v5501=v5501[v23567]}return v5501}function v906(){var v5502=this.contextStack,v5502=JAMScript.call(v5502.pop,v5502,[]),v14788=this.checker,v14788=v14788.errorReporter,v26965=JAMScript.call(this.isProvisional,
this,[]);v14788.pushToErrorSink=v26965;v14788=this.hadProvisionalErrors;if(v26965=!v14788)if(v14788=v5502.provisional)v14788=this.checker,v14788=v14788.errorReporter,v14788=v14788.errorSink,v14788=v14788.length;this.hadProvisionalErrors=v14788;v14788=this.checker;v14788=v14788.errorReporter;JAMScript.call(v14788.freeCapturedErrors,v14788,[]);return v5502}function v905(type,provisional){var v5506=this.contextStack,v14792=ContextualTypingContextStack.contextID,v23569=ContextualTypingContextStack.contextID;
ContextualTypingContextStack.contextID=v23569+1;v14792=JAMScript.new(ContextualTypeContext,[type,provisional,v14792]);JAMScript.call(v5506.push,v5506,[v14792]);v5506=this.checker;v5506=v5506.errorReporter;v5506.pushToErrorSink=provisional}function ContextualTypingContextStack(checker){this.checker=checker;this.contextStack=[];this.hadProvisionalErrors=!1}var v14794=TypeScript.TypeCheckStatus,v14794=v14794.Finished;ContextualTypingContextStack.contextID=v14794+1;v14794=ContextualTypingContextStack.prototype;
v14794.pushContextualType=v905;v14794=ContextualTypingContextStack.prototype;v14794.popContextualType=v906;v14794=ContextualTypingContextStack.prototype;v14794.getContextualType=v907;v14794=ContextualTypingContextStack.prototype;v14794.getContextID=v908;v14794=ContextualTypingContextStack.prototype;v14794.isProvisional=v909;return ContextualTypingContextStack}function v904(){function ContextualTypeContext(contextualType,provisional,contextID){this.contextualType=contextualType;this.provisional=provisional;
this.contextID=contextID;this.targetAccessorType=this.targetThis=this.targetSig=null}return ContextualTypeContext}function v903(){function v902(name,type){var v5515=TypeScript.ValueLocation,v5516=v5515=JAMScript.new(v5515,[]),v14795=TypeScript.TypeLink,v14795=JAMScript.new(v14795,[]);v5516.typeLink=v14795;v5516=TypeScript.VariableSymbol;v5515=JAMScript.new(v5516,[name,0,-1,v5515]);JAMScript.call(v5515.setType,v5515,[type]);v5516=TypeScript.TypeCheckStatus;v5515.typeCheckStatus=v5516.Finished;v5515.container=
this.gloMod;v5516=this.importedGlobalsTable;JAMScript.call(v5516.addPublicMember,v5516,[name,v5515])}function v901(){var v5520=TypeScript.StringHashTable;this.globals=v5520=JAMScript.new(v5520,[]);v5520=TypeScript.StringHashTable;this.globalTypes=v5520=JAMScript.new(v5520,[]);v5520=TypeScript.StringHashTable;this.ambientGlobals=v5520=JAMScript.new(v5520,[]);v5520=TypeScript.StringHashTable;this.ambientGlobalTypes=v5520=JAMScript.new(v5520,[]);var v5520=this.globalTypes,v20287=this.voidType,v20287=
v20287.symbol,v20287=v20287.name,v14797=this.voidType,v14797=v14797.symbol;JAMScript.call(v5520.add,v5520,[v20287,v14797]);v5520=this.globalTypes;v20287=this.booleanType;v20287=v20287.symbol;v20287=v20287.name;v14797=this.booleanType;v14797=v14797.symbol;JAMScript.call(v5520.add,v5520,[v20287,v14797]);v5520=this.globalTypes;v20287=this.doubleType;v20287=v20287.symbol;v20287=v20287.name;v14797=this.doubleType;v14797=v14797.symbol;JAMScript.call(v5520.add,v5520,[v20287,v14797]);v5520=this.globalTypes;
v20287=this.doubleType;v20287=v20287.symbol;JAMScript.call(v5520.add,v5520,["number",v20287]);v5520=this.globalTypes;v20287=this.stringType;v20287=v20287.symbol;v20287=v20287.name;v14797=this.stringType;v14797=v14797.symbol;JAMScript.call(v5520.add,v5520,[v20287,v14797]);v5520=this.globalTypes;v20287=this.anyType;v20287=v20287.symbol;v20287=v20287.name;v14797=this.anyType;v14797=v14797.symbol;JAMScript.call(v5520.add,v5520,[v20287,v14797]);v5520=this.globalTypes;v20287=this.nullType;v20287=v20287.symbol;
v20287=v20287.name;v14797=this.nullType;v14797=v14797.symbol;JAMScript.call(v5520.add,v5520,[v20287,v14797]);v5520=this.globalTypes;v20287=this.undefinedType;v20287=v20287.symbol;v20287=v20287.name;v14797=this.undefinedType;v14797=v14797.symbol;JAMScript.call(v5520.add,v5520,[v20287,v14797]);v5520=this.dualGlobalValues;v5520.secondaryTable=this.globals;v5520=this.dualGlobalTypes;v5520.secondaryTable=this.globalTypes;v5520=this.dualAmbientGlobalValues;v5520.secondaryTable=this.ambientGlobals;v5520=
this.dualAmbientGlobalTypes;v5520.secondaryTable=this.ambientGlobalTypes}function v900(mode){var v5551=this.dualGlobalValues,v14811=this.dualGlobalTypes,v20294=this.dualAmbientGlobalValues,v23570=this.dualAmbientGlobalTypes,v25123=TypeCheckCollectionMode.Resident;this.residentTypeCheck=v5551.insertPrimary=v14811.insertPrimary=v20294.insertPrimary=v23570.insertPrimary=mode==v25123}function v899(flags,name){var v5552=TypeScript.Type,v5552=JAMScript.new(v5552,[]);v5552.primitiveTypeClass=flags;var v5553=
TypeScript.TypeSymbol,v5554=name.length,v5553=JAMScript.new(v5553,[name,-1,v5554,-1,v5552]),v5554=TypeScript.TypeCheckStatus;v5553.typeCheckStatus=v5554.Finished;v5552.symbol=v5553;var v5554=this.importedGlobals,v5557=this.errorReporter;JAMScript.call(v5554.enter,v5554,[null,null,v5553,v5557,!0,!0,!0]);return v5552}function PersistentGlobalTypeState(errorReporter){this.errorReporter=errorReporter;var v5558=TypeScript.ScopedMembers,v14812=TypeScript.DualStringHashTable,v20295=TypeScript.StringHashTable,
v14813=JAMScript.new(v20295,[]),v20296=TypeScript.StringHashTable,v14814=JAMScript.new(v20296,[]),v5559=JAMScript.new(v14812,[v14813,v14814]),v26971=JAMScript.new(v5558,[v5559]);this.importedGlobalsTable=v26971;var v5560=TypeScript.ScopedMembers,v14815=TypeScript.DualStringHashTable,v20297=TypeScript.StringHashTable,v14816=JAMScript.new(v20297,[]),v20298=TypeScript.StringHashTable,v14817=JAMScript.new(v20298,[]),v5561=JAMScript.new(v14815,[v14816,v14817]),v26972=JAMScript.new(v5560,[v5561]);this.importedGlobalsTypeTable=
v26972;this.ambientGlobalTypes=this.ambientGlobals=this.globalTypes=this.globals=null;var v5562=TypeScript.StringHashTable,v26973=JAMScript.new(v5562,[]);this.residentGlobalValues=v26973;var v5563=TypeScript.StringHashTable,v26974=JAMScript.new(v5563,[]);this.residentGlobalTypes=v26974;var v5564=TypeScript.StringHashTable,v26975=JAMScript.new(v5564,[]);this.residentGlobalAmbientValues=v26975;var v5565=TypeScript.StringHashTable,v26976=JAMScript.new(v5565,[]);this.residentGlobalAmbientTypes=v26976;
this.residentTypeCheck=!0;this.wildElm=this.gloMod=this.mod=null;var v5566=TypeScript.SymbolScopeBuilder,v5567=this.importedGlobalsTable,v5568=this.importedGlobalsTypeTable,v26977=JAMScript.new(v5566,[null,v5567,null,v5568,null,null]);this.importedGlobals=v26977;var v5569=TypeScript.DualStringHashTable,v5570=this.residentGlobalValues,v14818=TypeScript.StringHashTable,v5571=JAMScript.new(v14818,[]),v26978=JAMScript.new(v5569,[v5570,v5571]);this.dualGlobalValues=v26978;var v5572=TypeScript.DualStringHashTable,
v5573=this.residentGlobalTypes,v14819=TypeScript.StringHashTable,v5574=JAMScript.new(v14819,[]),v26979=JAMScript.new(v5572,[v5573,v5574]);this.dualGlobalTypes=v26979;var v5575=TypeScript.DualStringHashTable,v5576=this.residentGlobalAmbientValues,v14820=TypeScript.StringHashTable,v5577=JAMScript.new(v14820,[]),v26980=JAMScript.new(v5575,[v5576,v5577]);this.dualAmbientGlobalValues=v26980;var v5578=TypeScript.DualStringHashTable,v5579=this.residentGlobalAmbientTypes,v14821=TypeScript.StringHashTable,
v5580=JAMScript.new(v14821,[]),v26981=JAMScript.new(v5578,[v5579,v5580]);this.dualAmbientGlobalTypes=v26981;var v5581=TypeScript.ScopedMembers,v14822=TypeScript.DualStringHashTable,v14823=this.dualGlobalValues,v20299=TypeScript.StringHashTable,v14824=JAMScript.new(v20299,[]),v5582=JAMScript.new(v14822,[v14823,v14824]),dualGlobalScopedMembers=JAMScript.new(v5581,[v5582]),v5583=TypeScript.ScopedMembers,v14825=TypeScript.DualStringHashTable,v14826=this.dualAmbientGlobalValues,v20300=TypeScript.StringHashTable,
v14827=JAMScript.new(v20300,[]),v5584=JAMScript.new(v14825,[v14826,v14827]),dualGlobalScopedAmbientMembers=JAMScript.new(v5583,[v5584]),v5585=TypeScript.ScopedMembers,v14828=TypeScript.DualStringHashTable,v14829=this.dualGlobalTypes,v20301=TypeScript.StringHashTable,v14830=JAMScript.new(v20301,[]),v5586=JAMScript.new(v14828,[v14829,v14830]),dualGlobalScopedEnclosedTypes=JAMScript.new(v5585,[v5586]),v5587=TypeScript.ScopedMembers,v14831=TypeScript.DualStringHashTable,v14832=this.dualAmbientGlobalTypes,
v20302=TypeScript.StringHashTable,v14833=JAMScript.new(v20302,[]),v5588=JAMScript.new(v14831,[v14832,v14833]),dualGlobalScopedAmbientEnclosedTypes=JAMScript.new(v5587,[v5588]),v5589=TypeScript.SymbolScopeBuilder,v5590=this.importedGlobals,v26982=JAMScript.new(v5589,[dualGlobalScopedMembers,dualGlobalScopedAmbientMembers,dualGlobalScopedEnclosedTypes,dualGlobalScopedAmbientEnclosedTypes,v5590,null]);this.globalScope=v26982;var v14834=TypeScript.Primitive,v5591=v14834.Void,v26983=JAMScript.call(this.enterPrimitive,
this,[v5591,"void"]);this.voidType=v26983;var v14835=TypeScript.Primitive,v5592=v14835.Boolean,v26984=JAMScript.call(this.enterPrimitive,this,[v5592,"bool"]);this.booleanType=v26984;var v14836=TypeScript.Primitive,v5593=v14836.Double,v26985=JAMScript.call(this.enterPrimitive,this,[v5593,"number"]);this.doubleType=v26985;var v14837=this.importedGlobals,v5594=v14837.ambientEnclosedTypes,v14838=this.doubleType,v5595=v14838.symbol;JAMScript.call(v5594.addPublicMember,v5594,["number",v5595]);var v14839=
TypeScript.Primitive,v5596=v14839.String,v26986=JAMScript.call(this.enterPrimitive,this,[v5596,"string"]);this.stringType=v26986;var v14840=TypeScript.Primitive,v5597=v14840.Any,v26987=JAMScript.call(this.enterPrimitive,this,[v5597,"any"]);this.anyType=v26987;var v14841=TypeScript.Primitive,v5598=v14841.Null,v26988=JAMScript.call(this.enterPrimitive,this,[v5598,"null"]);this.nullType=v26988;var v14842=TypeScript.Primitive,v5599=v14842.Undefined,v26989=JAMScript.call(this.enterPrimitive,this,[v5599,
"undefined"]);this.undefinedType=v26989;var v5600=TypeCheckCollectionMode.Resident;JAMScript.call(this.setCollectionMode,this,[v5600]);var v5601=TypeScript.TypeSymbol,v14843=TypeScript.Type,v5602=JAMScript.new(v14843,[]),v26990=JAMScript.new(v5601,["_element",-1,0,-1,v5602]);this.wildElm=v26990;var v5603=this.importedGlobalsTypeTable,v14844=this.wildElm,v5604=v14844.name,v5605=this.wildElm;JAMScript.call(v5603.addPublicMember,v5603,[v5604,v5605]);var v5606=TypeScript.ModuleType,v26991=JAMScript.new(v5606,
[dualGlobalScopedEnclosedTypes,dualGlobalScopedAmbientEnclosedTypes]),v5607=this.mod=v26991;v5607.members=dualGlobalScopedMembers;var v5608=this.mod;v5608.ambientMembers=dualGlobalScopedAmbientMembers;var v5609=this.mod;v5609.containedScope=this.globalScope;var v5610=TypeScript.TypeSymbol,v5611=TypeScript.globalId,v5612=this.mod,v26992=JAMScript.new(v5610,[v5611,-1,0,-1,v5612]);this.gloMod=v26992;var v14845=this.mod,v5613=v14845.members,v14846=this.gloMod,v5614=v14846.name,v5615=this.gloMod;JAMScript.call(v5613.addPublicMember,
v5613,[v5614,v5615]);var v5616=this.undefinedType;JAMScript.call(this.defineGlobalValue,this,["undefined",v5616])}var v5617=PersistentGlobalTypeState.prototype;v5617.enterPrimitive=v899;v5617=PersistentGlobalTypeState.prototype;v5617.setCollectionMode=v900;v5617=PersistentGlobalTypeState.prototype;v5617.refreshPersistentState=v901;v5617=PersistentGlobalTypeState.prototype;v5617.defineGlobalValue=v902;return PersistentGlobalTypeState}function v898(TypeCheckCollectionMode){TypeCheckCollectionMode._map=
[];var v5621=TypeCheckCollectionMode._map;v5621[0]="Resident";TypeCheckCollectionMode.Resident=0;v5621=TypeCheckCollectionMode._map;v5621[1]="Transient";TypeCheckCollectionMode.Transient=1}function v897(){function v896(message){this.message=message}function v895(message){var v14847=this.onlyCaptureFirstError;if(v14847=!v14847){if(v14847=this.message)message+=":\n\t",v14847=this.message,message+=v14847;this.message=message}else JAMScript.call(this.setMessage,this,[message])}function TypeComparisonInfo(){this.onlyCaptureFirstError=
!1;var v5625=TypeScript.TypeRelationshipFlags;this.flags=v5625.SuccessfulComparison;this.message=""}var v5626=TypeComparisonInfo.prototype;v5626.addMessageToFront=v895;v5626=TypeComparisonInfo.prototype;v5626.setMessage=v896;return TypeComparisonInfo}function v894(){function v893(arrInstType,checker){var v14851=this.arrayBase;if(v14851=null==v14851){var v14851=checker.wildElm,v14851=v14851.type,v14853=this.arrayType,v14853=v14853.elementType;this.arrayBase=v14851=JAMScript.call(arrInstType.specializeType,
arrInstType,[v14851,v14853,checker,!0])}return this.arrayBase}function ArrayCache(){this.arrayBase=null}var v5631=ArrayCache.prototype;v5631.specialize=v893;return ArrayCache}var ArrayCache=v894();TypeScript.ArrayCache=ArrayCache;var TypeComparisonInfo=v897();TypeScript.TypeComparisonInfo=TypeComparisonInfo;var TypeComparisonInfo=TypeScript.TypeCheckCollectionMode,v20303=!TypeComparisonInfo;v20303&&(TypeComparisonInfo=TypeScript.TypeCheckCollectionMode={});v898(TypeComparisonInfo);var TypeCheckCollectionMode=
TypeScript.TypeCheckCollectionMode,TypeComparisonInfo=v903();TypeScript.PersistentGlobalTypeState=TypeComparisonInfo;var ContextualTypeContext=v904();TypeScript.ContextualTypeContext=ContextualTypeContext;var ContextualTypingContextStack=v910();TypeScript.ContextualTypingContextStack=ContextualTypingContextStack;TypeComparisonInfo=v963();TypeScript.TypeChecker=TypeComparisonInfo}
function v892(){var TypeScript=v12362;function v891(_super){function v890(){return TokenClass.RegExpLiteral}function v889(){var v5633=this.regex;return JAMScript.call(v5633.toString,v5633,[])}function RegularExpressionLiteralToken(regex){var v5634=TokenID.RegularExpressionLiteral;JAMScript.call(_super.call,_super,[this,v5634]);this.regex=regex}JAMScript.call(__extends,null,[RegularExpressionLiteralToken,_super]);var v5635=RegularExpressionLiteralToken.prototype;v5635.getText=v889;v5635=RegularExpressionLiteralToken.prototype;
v5635.classification=v890;return RegularExpressionLiteralToken}function v888(_super){function v887(){return TokenClass.Comment}function v886(){return this.value}function CommentToken(tokenID,value,isBlock,startPos,line,endsLine){JAMScript.call(_super.call,_super,[this,tokenID]);this.value=value;this.isBlock=isBlock;this.startPos=startPos;this.line=line;this.endsLine=endsLine}JAMScript.call(__extends,null,[CommentToken,_super]);var v5637=CommentToken.prototype;v5637.getText=v886;v5637=CommentToken.prototype;
v5637.classification=v887;return CommentToken}function v885(_super){function v884(){return TokenClass.Whitespace}function v883(){return this.value}function WhitespaceToken(tokenId,value){JAMScript.call(_super.call,_super,[this,tokenId]);this.value=value}JAMScript.call(__extends,null,[WhitespaceToken,_super]);var v5639=WhitespaceToken.prototype;v5639.getText=v883;v5639=WhitespaceToken.prototype;v5639.classification=v884;return WhitespaceToken}function v882(_super){function v881(){return TokenClass.Identifier}
function v880(){return this.value}function IdentifierToken(value,hasEscapeSequence){var v5641=TokenID.Identifier;JAMScript.call(_super.call,_super,[this,v5641]);this.value=value;this.hasEscapeSequence=hasEscapeSequence}JAMScript.call(__extends,null,[IdentifierToken,_super]);var v5642=IdentifierToken.prototype;v5642.getText=v880;v5642=IdentifierToken.prototype;v5642.classification=v881;return IdentifierToken}function v879(_super){function v878(){return TokenClass.StringLiteral}function v877(){return this.value}
function StringLiteralToken(value){var v5644=TokenID.StringLiteral;JAMScript.call(_super.call,_super,[this,v5644]);this.value=value}JAMScript.call(__extends,null,[StringLiteralToken,_super]);var v5645=StringLiteralToken.prototype;v5645.getText=v877;v5645=StringLiteralToken.prototype;v5645.classification=v878;return StringLiteralToken}function v876(_super){function v875(){return TokenClass.NumberLiteral}function v874(){var v5647;(v5647=this.hasEmptyFraction)?(v5647=this.value,v5647=JAMScript.call(v5647.toString,
v5647,[]),v5647+=".0"):(v5647=this.value,v5647=JAMScript.call(v5647.toString,v5647,[]));return v5647}function NumberLiteralToken(value,hasEmptyFraction){var v5648=TokenID.NumberLiteral;JAMScript.call(_super.call,_super,[this,v5648]);this.value=value;this.hasEmptyFraction=hasEmptyFraction}JAMScript.call(__extends,null,[NumberLiteralToken,_super]);var v5649=NumberLiteralToken.prototype;v5649.getText=v874;v5649=NumberLiteralToken.prototype;v5649.classification=v875;return NumberLiteralToken}function v873(){function v872(){var v14858=
this.tokenId,v14859=TokenID.LimKeyword;if(v14858=v14858<=v14859)return TokenClass.Keyword;v14858=this.tokenId;v14858=lookupToken(v14858);if(v14859=void 0!=v14858){var v14859=v14858.unopNodeType,v23571=TypeScript.NodeType,v23571=v23571.None,v14859=v14859!=v23571;if(v23571=!v14859)v14858=v14858.binopNodeType,v14859=TypeScript.NodeType,v14859=v14859.None,v14859=v14858!=v14859;if(v14858=v14859)return TokenClass.Operator}return TokenClass.Punctuation}function v871(){var v14861=TypeScript.tokenTable,v14862=
this.tokenId;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v14861=v14861[v14862];return v14861.text}function v870(line,outfile){var v20310=JAMScript.call(this.toString,this,[]),v20310=v20310+",on line",v20310=v20310+line;JAMScript.call(outfile.WriteLine,outfile,[v20310])}function v869(){var v25920=this.tokenId,v25920="token: "+v25920,v25920=v25920+" ",v23574=JAMScript.call(this.getText,this,[]),v25920=v25920+v23574,v25920=v25920+" (",v23574=TokenID._map,v20313=
this.tokenId;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v23574=v23574[v20313];v25920+=v23574;return v25920+")"}function Token(tokenId){this.tokenId=tokenId}var v5658=Token.prototype;v5658.toString=v869;v5658=Token.prototype;v5658.print=v870;v5658=Token.prototype;v5658.getText=v871;v5658=Token.prototype;v5658.classification=v872;return Token}function v868(){function SavedToken(tok,minChar,limChar){this.tok=tok;this.minChar=minChar;this.limChar=limChar}return SavedToken}
function v867(TokenClass){TokenClass._map=[];var v5662=TokenClass._map;v5662[0]="Punctuation";TokenClass.Punctuation=0;v5662=TokenClass._map;v5662[1]="Keyword";TokenClass.Keyword=1;v5662=TokenClass._map;v5662[2]="Operator";TokenClass.Operator=2;v5662=TokenClass._map;v5662[3]="Comment";TokenClass.Comment=3;v5662=TokenClass._map;v5662[4]="Whitespace";TokenClass.Whitespace=4;v5662=TokenClass._map;v5662[5]="Identifier";TokenClass.Identifier=5;v5662=TokenClass._map;v5662[6]="NumberLiteral";TokenClass.NumberLiteral=
6;v5662=TokenClass._map;v5662[7]="StringLiteral";TokenClass.StringLiteral=7;v5662=TokenClass._map;v5662[8]="RegExpLiteral";TokenClass.RegExpLiteral=8}function v866(){function TokenInfo(tokenId,reservation,binopPrecedence,binopNodeType,unopPrecedence,unopNodeType,text,ers){this.tokenId=tokenId;this.reservation=reservation;this.binopPrecedence=binopPrecedence;this.binopNodeType=binopNodeType;this.unopPrecedence=unopPrecedence;this.unopNodeType=unopNodeType;this.text=text;this.ers=ers}return TokenInfo}
function v865(Reservation){Reservation._map=[];Reservation.None=0;Reservation.Javascript=1;Reservation.JavascriptFuture=2;Reservation.TypeScript=4;Reservation.JavascriptFutureStrict=8;var v5671=Reservation.Javascript,v5672=Reservation.TypeScript;Reservation.TypeScriptAndJS=v5671|v5672;v5671=Reservation.JavascriptFuture;v5672=Reservation.TypeScript;Reservation.TypeScriptAndJSFuture=v5671|v5672;v5671=Reservation.JavascriptFutureStrict;v5672=Reservation.TypeScript;Reservation.TypeScriptAndJSFutureStrict=
v5671|v5672}function v864(OperatorPrecedence){OperatorPrecedence._map=[];var v5677=OperatorPrecedence._map;v5677[0]="None";OperatorPrecedence.None=0;v5677=OperatorPrecedence._map;v5677[1]="Comma";OperatorPrecedence.Comma=1;v5677=OperatorPrecedence._map;v5677[2]="Assignment";OperatorPrecedence.Assignment=2;v5677=OperatorPrecedence._map;v5677[3]="Conditional";OperatorPrecedence.Conditional=3;v5677=OperatorPrecedence._map;v5677[4]="LogicalOr";OperatorPrecedence.LogicalOr=4;v5677=OperatorPrecedence._map;
v5677[5]="LogicalAnd";OperatorPrecedence.LogicalAnd=5;v5677=OperatorPrecedence._map;v5677[6]="BitwiseOr";OperatorPrecedence.BitwiseOr=6;v5677=OperatorPrecedence._map;v5677[7]="BitwiseExclusiveOr";OperatorPrecedence.BitwiseExclusiveOr=7;v5677=OperatorPrecedence._map;v5677[8]="BitwiseAnd";OperatorPrecedence.BitwiseAnd=8;v5677=OperatorPrecedence._map;v5677[9]="Equality";OperatorPrecedence.Equality=9;v5677=OperatorPrecedence._map;v5677[10]="Relational";OperatorPrecedence.Relational=10;v5677=OperatorPrecedence._map;
v5677[11]="Shift";OperatorPrecedence.Shift=11;v5677=OperatorPrecedence._map;v5677[12]="Additive";OperatorPrecedence.Additive=12;v5677=OperatorPrecedence._map;v5677[13]="Multiplicative";OperatorPrecedence.Multiplicative=13;v5677=OperatorPrecedence._map;v5677[14]="Unary";OperatorPrecedence.Unary=14;v5677=OperatorPrecedence._map;v5677[15]="Lim";OperatorPrecedence.Lim=15}function v863(TokenID){TokenID._map=[];var v5693=TokenID._map;v5693[0]="Any";TokenID.Any=0;var v5694=TokenID._map;v5694[1]="Bool";TokenID.Bool=
1;var v5695=TokenID._map;v5695[2]="Break";TokenID.Break=2;var v5696=TokenID._map;v5696[3]="Case";TokenID.Case=3;var v5697=TokenID._map;v5697[4]="Catch";TokenID.Catch=4;var v5698=TokenID._map;v5698[5]="Class";TokenID.Class=5;var v5699=TokenID._map;v5699[6]="Const";TokenID.Const=6;var v5700=TokenID._map;v5700[7]="Continue";TokenID.Continue=7;var v5701=TokenID._map;v5701[8]="Debugger";TokenID.Debugger=8;var v5702=TokenID._map;v5702[9]="Default";TokenID.Default=9;var v5703=TokenID._map;v5703[10]="Delete";
TokenID.Delete=10;var v5704=TokenID._map;v5704[11]="Do";TokenID.Do=11;var v5705=TokenID._map;v5705[12]="Else";TokenID.Else=12;var v5706=TokenID._map;v5706[13]="Enum";TokenID.Enum=13;var v5707=TokenID._map;v5707[14]="Export";TokenID.Export=14;var v5708=TokenID._map;v5708[15]="Extends";TokenID.Extends=15;var v5709=TokenID._map;v5709[16]="Declare";TokenID.Declare=16;var v5710=TokenID._map;v5710[17]="False";TokenID.False=17;var v5711=TokenID._map;v5711[18]="Finally";TokenID.Finally=18;var v5712=TokenID._map;
v5712[19]="For";TokenID.For=19;var v5713=TokenID._map;v5713[20]="Function";TokenID.Function=20;var v5714=TokenID._map;v5714[21]="Constructor";TokenID.Constructor=21;var v5715=TokenID._map;v5715[22]="Get";TokenID.Get=22;var v5716=TokenID._map;v5716[23]="If";TokenID.If=23;var v5717=TokenID._map;v5717[24]="Implements";TokenID.Implements=24;var v5718=TokenID._map;v5718[25]="Import";TokenID.Import=25;var v5719=TokenID._map;v5719[26]="In";TokenID.In=26;var v5720=TokenID._map;v5720[27]="InstanceOf";TokenID.InstanceOf=
27;var v5721=TokenID._map;v5721[28]="Interface";TokenID.Interface=28;var v5722=TokenID._map;v5722[29]="Let";TokenID.Let=29;var v5723=TokenID._map;v5723[30]="Module";TokenID.Module=30;var v5724=TokenID._map;v5724[31]="New";TokenID.New=31;var v5725=TokenID._map;v5725[32]="Number";TokenID.Number=32;var v5726=TokenID._map;v5726[33]="Null";TokenID.Null=33;var v5727=TokenID._map;v5727[34]="Package";TokenID.Package=34;var v5728=TokenID._map;v5728[35]="Private";TokenID.Private=35;var v5729=TokenID._map;v5729[36]=
"Protected";TokenID.Protected=36;var v5730=TokenID._map;v5730[37]="Public";TokenID.Public=37;var v5731=TokenID._map;v5731[38]="Return";TokenID.Return=38;var v5732=TokenID._map;v5732[39]="Set";TokenID.Set=39;var v5733=TokenID._map;v5733[40]="Static";TokenID.Static=40;var v5734=TokenID._map;v5734[41]="String";TokenID.String=41;var v5735=TokenID._map;v5735[42]="Super";TokenID.Super=42;var v5736=TokenID._map;v5736[43]="Switch";TokenID.Switch=43;var v5737=TokenID._map;v5737[44]="This";TokenID.This=44;
var v5738=TokenID._map;v5738[45]="Throw";TokenID.Throw=45;var v5739=TokenID._map;v5739[46]="True";TokenID.True=46;var v5740=TokenID._map;v5740[47]="Try";TokenID.Try=47;var v5741=TokenID._map;v5741[48]="TypeOf";TokenID.TypeOf=48;var v5742=TokenID._map;v5742[49]="Var";TokenID.Var=49;var v5743=TokenID._map;v5743[50]="Void";TokenID.Void=50;var v5744=TokenID._map;v5744[51]="With";TokenID.With=51;var v5745=TokenID._map;v5745[52]="While";TokenID.While=52;var v5746=TokenID._map;v5746[53]="Yield";TokenID.Yield=
53;var v5747=TokenID._map;v5747[54]="Semicolon";TokenID.Semicolon=54;var v5748=TokenID._map;v5748[55]="OpenParen";TokenID.OpenParen=55;var v5749=TokenID._map;v5749[56]="CloseParen";TokenID.CloseParen=56;var v5750=TokenID._map;v5750[57]="OpenBracket";TokenID.OpenBracket=57;var v5751=TokenID._map;v5751[58]="CloseBracket";TokenID.CloseBracket=58;var v5752=TokenID._map;v5752[59]="OpenBrace";TokenID.OpenBrace=59;var v5753=TokenID._map;v5753[60]="CloseBrace";TokenID.CloseBrace=60;var v5754=TokenID._map;
v5754[61]="Comma";TokenID.Comma=61;var v5755=TokenID._map;v5755[62]="Equals";TokenID.Equals=62;var v5756=TokenID._map;v5756[63]="PlusEquals";TokenID.PlusEquals=63;var v5757=TokenID._map;v5757[64]="MinusEquals";TokenID.MinusEquals=64;var v5758=TokenID._map;v5758[65]="AsteriskEquals";TokenID.AsteriskEquals=65;var v5759=TokenID._map;v5759[66]="SlashEquals";TokenID.SlashEquals=66;var v5760=TokenID._map;v5760[67]="PercentEquals";TokenID.PercentEquals=67;var v5761=TokenID._map;v5761[68]="AmpersandEquals";
TokenID.AmpersandEquals=68;var v5762=TokenID._map;v5762[69]="CaretEquals";TokenID.CaretEquals=69;var v5763=TokenID._map;v5763[70]="BarEquals";TokenID.BarEquals=70;var v5764=TokenID._map;v5764[71]="LessThanLessThanEquals";TokenID.LessThanLessThanEquals=71;var v5765=TokenID._map;v5765[72]="GreaterThanGreaterThanEquals";TokenID.GreaterThanGreaterThanEquals=72;var v5766=TokenID._map;v5766[73]="GreaterThanGreaterThanGreaterThanEquals";TokenID.GreaterThanGreaterThanGreaterThanEquals=73;var v5767=TokenID._map;
v5767[74]="Question";TokenID.Question=74;var v5768=TokenID._map;v5768[75]="Colon";TokenID.Colon=75;var v5769=TokenID._map;v5769[76]="BarBar";TokenID.BarBar=76;var v5770=TokenID._map;v5770[77]="AmpersandAmpersand";TokenID.AmpersandAmpersand=77;var v5771=TokenID._map;v5771[78]="Bar";TokenID.Bar=78;var v5772=TokenID._map;v5772[79]="Caret";TokenID.Caret=79;var v5773=TokenID._map;v5773[80]="And";TokenID.And=80;var v5774=TokenID._map;v5774[81]="EqualsEquals";TokenID.EqualsEquals=81;var v5775=TokenID._map;
v5775[82]="ExclamationEquals";TokenID.ExclamationEquals=82;var v5776=TokenID._map;v5776[83]="EqualsEqualsEquals";TokenID.EqualsEqualsEquals=83;var v5777=TokenID._map;v5777[84]="ExclamationEqualsEquals";TokenID.ExclamationEqualsEquals=84;var v5778=TokenID._map;v5778[85]="LessThan";TokenID.LessThan=85;var v5779=TokenID._map;v5779[86]="LessThanEquals";TokenID.LessThanEquals=86;var v5780=TokenID._map;v5780[87]="GreaterThan";TokenID.GreaterThan=87;var v5781=TokenID._map;v5781[88]="GreaterThanEquals";TokenID.GreaterThanEquals=
88;var v5782=TokenID._map;v5782[89]="LessThanLessThan";TokenID.LessThanLessThan=89;var v5783=TokenID._map;v5783[90]="GreaterThanGreaterThan";TokenID.GreaterThanGreaterThan=90;var v5784=TokenID._map;v5784[91]="GreaterThanGreaterThanGreaterThan";TokenID.GreaterThanGreaterThanGreaterThan=91;var v5785=TokenID._map;v5785[92]="Plus";TokenID.Plus=92;var v5786=TokenID._map;v5786[93]="Minus";TokenID.Minus=93;var v5787=TokenID._map;v5787[94]="Asterisk";TokenID.Asterisk=94;var v5788=TokenID._map;v5788[95]="Slash";
TokenID.Slash=95;var v5789=TokenID._map;v5789[96]="Percent";TokenID.Percent=96;var v5790=TokenID._map;v5790[97]="Tilde";TokenID.Tilde=97;var v5791=TokenID._map;v5791[98]="Exclamation";TokenID.Exclamation=98;var v5792=TokenID._map;v5792[99]="PlusPlus";TokenID.PlusPlus=99;var v5793=TokenID._map;v5793[100]="MinusMinus";TokenID.MinusMinus=100;var v5794=TokenID._map;v5794[101]="Dot";TokenID.Dot=101;var v5795=TokenID._map;v5795[102]="DotDotDot";TokenID.DotDotDot=102;var v5796=TokenID._map;v5796[103]="Error";
TokenID.Error=103;var v5797=TokenID._map;v5797[104]="EndOfFile";TokenID.EndOfFile=104;var v5798=TokenID._map;v5798[105]="EqualsGreaterThan";TokenID.EqualsGreaterThan=105;var v5799=TokenID._map;v5799[106]="Identifier";TokenID.Identifier=106;var v5800=TokenID._map;v5800[107]="StringLiteral";TokenID.StringLiteral=107;var v5801=TokenID._map;v5801[108]="RegularExpressionLiteral";TokenID.RegularExpressionLiteral=108;var v5802=TokenID._map;v5802[109]="NumberLiteral";TokenID.NumberLiteral=109;var v5803=TokenID._map;
v5803[110]="Whitespace";TokenID.Whitespace=110;var v5804=TokenID._map;v5804[111]="Comment";TokenID.Comment=111;var v5805=TokenID._map;v5805[112]="Lim";TokenID.Lim=112;TokenID.LimFixed=TokenID.EqualsGreaterThan;TokenID.LimKeyword=TokenID.Yield}function setTokenInfo(tokenId,reservation,binopPrecedence,binopNodeType,unopPrecedence,unopNodeType,text,ers){var v5813=void 0!==tokenId;if(v5813){var v5813=TypeScript.tokenTable,v5807=tokenId;reservation=JAMScript.new(TokenInfo,[tokenId,reservation,binopPrecedence,
binopNodeType,unopPrecedence,unopNodeType,text,ers]);JAMScript.set(v5813,v5807,reservation);reservation=TypeScript.NodeType;reservation=reservation.None;if(reservation=binopNodeType!=reservation)reservation=TypeScript.nodeTypeTable,JAMScript.set(reservation,binopNodeType,text),reservation=TypeScript.nodeTypeToTokTable,JAMScript.set(reservation,binopNodeType,tokenId);tokenId=TypeScript.NodeType;tokenId=tokenId.None;if(tokenId=unopNodeType!=tokenId)tokenId=TypeScript.nodeTypeTable,JAMScript.set(tokenId,
unopNodeType,text)}}function lookupToken(tokenId){var v5814=TypeScript.tokenTable;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v5814[tokenId]}function initializeStaticTokens(){for(var i=0,v14868=TokenID.LimFixed,v14868=i<=v14868;v14868;){var v14868=TypeScript.staticTokens,v5816=i,v26995=JAMScript.new(Token,[i]);v14868[v5816]=v26995;i+=1;v14868=TokenID.LimFixed;v14868=i<=v14868}}var v14870=TypeScript.TokenID,v20316=!v14870;v20316&&(v14870=TypeScript.TokenID=
{});var v5818=v14870;v863(v5818);var TokenID=TypeScript.TokenID,v5819=TypeScript,v26996=[];v5819.tokenTable=v26996;var v5820=TypeScript,v26997=[];v5820.nodeTypeTable=v26997;var v5821=TypeScript,v26998=[];v5821.nodeTypeToTokTable=v26998;var v5822=TypeScript,v26999=[];v5822.noRegexTable=v26999;var v5823=TypeScript.noRegexTable,v5824=TokenID.Identifier;JAMScript.set(v5823,v5824,!0);var v5825=TypeScript.noRegexTable,v5826=TokenID.StringLiteral;JAMScript.set(v5825,v5826,!0);var v5827=TypeScript.noRegexTable,
v5828=TokenID.NumberLiteral;JAMScript.set(v5827,v5828,!0);var v5829=TypeScript.noRegexTable,v5830=TokenID.RegularExpressionLiteral;JAMScript.set(v5829,v5830,!0);var v5831=TypeScript.noRegexTable,v5832=TokenID.This;JAMScript.set(v5831,v5832,!0);var v5833=TypeScript.noRegexTable,v5834=TokenID.PlusPlus;JAMScript.set(v5833,v5834,!0);var v5835=TypeScript.noRegexTable,v5836=TokenID.MinusMinus;JAMScript.set(v5835,v5836,!0);var v5837=TypeScript.noRegexTable,v5838=TokenID.CloseParen;JAMScript.set(v5837,v5838,
!0);var v5839=TypeScript.noRegexTable,v5840=TokenID.CloseBracket;JAMScript.set(v5839,v5840,!0);var v5841=TypeScript.noRegexTable,v5842=TokenID.CloseBrace;JAMScript.set(v5841,v5842,!0);var v5843=TypeScript.noRegexTable,v5844=TokenID.True;JAMScript.set(v5843,v5844,!0);var v5845=TypeScript.noRegexTable,v5846=TokenID.False;JAMScript.set(v5845,v5846,!0);var v14871=TypeScript.OperatorPrecedence,v20317=!v14871;v20317&&(v14871=TypeScript.OperatorPrecedence={});var v5847=v14871;v864(v5847);var OperatorPrecedence=
TypeScript.OperatorPrecedence,v14872=TypeScript.Reservation,v20318=!v14872;v20318&&(v14872=TypeScript.Reservation={});var v5848=v14872;v865(v5848);var Reservation=TypeScript.Reservation,TokenInfo=v866();TypeScript.TokenInfo=TokenInfo;var v5849=TokenID.Any,v5850=Reservation.TypeScript,v5851=OperatorPrecedence.None,v14873=TypeScript.NodeType,v5852=v14873.None,v5853=OperatorPrecedence.None,v14874=TypeScript.NodeType,v5854=v14874.None,v14875=TypeScript.ErrorRecoverySet,v5855=v14875.PrimType;setTokenInfo(v5849,
v5850,v5851,v5852,v5853,v5854,"any",v5855);var v5856=TokenID.Bool,v5857=Reservation.TypeScript,v5858=OperatorPrecedence.None,v14876=TypeScript.NodeType,v5859=v14876.None,v5860=OperatorPrecedence.None,v14877=TypeScript.NodeType,v5861=v14877.None,v14878=TypeScript.ErrorRecoverySet,v5862=v14878.PrimType;setTokenInfo(v5856,v5857,v5858,v5859,v5860,v5861,"bool",v5862);var v5863=TokenID.Break,v5864=Reservation.TypeScriptAndJS,v5865=OperatorPrecedence.None,v14879=TypeScript.NodeType,v5866=v14879.None,v5867=
OperatorPrecedence.None,v14880=TypeScript.NodeType,v5868=v14880.None,v14881=TypeScript.ErrorRecoverySet,v5869=v14881.Stmt;setTokenInfo(v5863,v5864,v5865,v5866,v5867,v5868,"break",v5869);var v5870=TokenID.Case,v5871=Reservation.TypeScriptAndJS,v5872=OperatorPrecedence.None,v14882=TypeScript.NodeType,v5873=v14882.None,v5874=OperatorPrecedence.None,v14883=TypeScript.NodeType,v5875=v14883.None,v14884=TypeScript.ErrorRecoverySet,v5876=v14884.SCase;setTokenInfo(v5870,v5871,v5872,v5873,v5874,v5875,"case",
v5876);var v5877=TokenID.Catch,v5878=Reservation.TypeScriptAndJS,v5879=OperatorPrecedence.None,v14885=TypeScript.NodeType,v5880=v14885.None,v5881=OperatorPrecedence.None,v14886=TypeScript.NodeType,v5882=v14886.None,v14887=TypeScript.ErrorRecoverySet,v5883=v14887.Catch;setTokenInfo(v5877,v5878,v5879,v5880,v5881,v5882,"catch",v5883);var v5884=TokenID.Class,v5885=Reservation.TypeScriptAndJSFuture,v5886=OperatorPrecedence.None,v14888=TypeScript.NodeType,v5887=v14888.None,v5888=OperatorPrecedence.None,
v14889=TypeScript.NodeType,v5889=v14889.None,v14890=TypeScript.ErrorRecoverySet,v5890=v14890.TypeScriptS;setTokenInfo(v5884,v5885,v5886,v5887,v5888,v5889,"class",v5890);var v5891=TokenID.Const,v5892=Reservation.TypeScriptAndJSFuture,v5893=OperatorPrecedence.None,v14891=TypeScript.NodeType,v5894=v14891.None,v5895=OperatorPrecedence.None,v14892=TypeScript.NodeType,v5896=v14892.None,v14893=TypeScript.ErrorRecoverySet,v5897=v14893.Var;setTokenInfo(v5891,v5892,v5893,v5894,v5895,v5896,"const",v5897);var v5898=
TokenID.Continue,v5899=Reservation.TypeScriptAndJS,v5900=OperatorPrecedence.None,v14894=TypeScript.NodeType,v5901=v14894.None,v5902=OperatorPrecedence.None,v14895=TypeScript.NodeType,v5903=v14895.None,v14896=TypeScript.ErrorRecoverySet,v5904=v14896.Stmt;setTokenInfo(v5898,v5899,v5900,v5901,v5902,v5903,"continue",v5904);var v5905=TokenID.Debugger,v5906=Reservation.TypeScriptAndJS,v5907=OperatorPrecedence.None,v14897=TypeScript.NodeType,v5908=v14897.None,v5909=OperatorPrecedence.None,v14898=TypeScript.NodeType,
v5910=v14898.Debugger,v14899=TypeScript.ErrorRecoverySet,v5911=v14899.Stmt;setTokenInfo(v5905,v5906,v5907,v5908,v5909,v5910,"debugger",v5911);var v5912=TokenID.Default,v5913=Reservation.TypeScriptAndJS,v5914=OperatorPrecedence.None,v14900=TypeScript.NodeType,v5915=v14900.None,v5916=OperatorPrecedence.None,v14901=TypeScript.NodeType,v5917=v14901.None,v14902=TypeScript.ErrorRecoverySet,v5918=v14902.SCase;setTokenInfo(v5912,v5913,v5914,v5915,v5916,v5917,"default",v5918);var v5919=TokenID.Delete,v5920=
Reservation.TypeScriptAndJS,v5921=OperatorPrecedence.None,v14903=TypeScript.NodeType,v5922=v14903.None,v5923=OperatorPrecedence.Unary,v14904=TypeScript.NodeType,v5924=v14904.Delete,v14905=TypeScript.ErrorRecoverySet,v5925=v14905.Prefix;setTokenInfo(v5919,v5920,v5921,v5922,v5923,v5924,"delete",v5925);var v5926=TokenID.Do,v5927=Reservation.TypeScriptAndJS,v5928=OperatorPrecedence.None,v14906=TypeScript.NodeType,v5929=v14906.None,v5930=OperatorPrecedence.None,v14907=TypeScript.NodeType,v5931=v14907.None,
v14908=TypeScript.ErrorRecoverySet,v5932=v14908.Stmt;setTokenInfo(v5926,v5927,v5928,v5929,v5930,v5931,"do",v5932);var v5933=TokenID.Else,v5934=Reservation.TypeScriptAndJS,v5935=OperatorPrecedence.None,v14909=TypeScript.NodeType,v5936=v14909.None,v5937=OperatorPrecedence.None,v14910=TypeScript.NodeType,v5938=v14910.None,v14911=TypeScript.ErrorRecoverySet,v5939=v14911.Else;setTokenInfo(v5933,v5934,v5935,v5936,v5937,v5938,"else",v5939);var v5940=TokenID.Enum,v5941=Reservation.TypeScriptAndJSFuture,v5942=
OperatorPrecedence.None,v14912=TypeScript.NodeType,v5943=v14912.None,v5944=OperatorPrecedence.None,v14913=TypeScript.NodeType,v5945=v14913.None,v14914=TypeScript.ErrorRecoverySet,v5946=v14914.TypeScriptS;setTokenInfo(v5940,v5941,v5942,v5943,v5944,v5945,"enum",v5946);var v5947=TokenID.Export,v5948=Reservation.TypeScriptAndJSFuture,v5949=OperatorPrecedence.None,v14915=TypeScript.NodeType,v5950=v14915.None,v5951=OperatorPrecedence.None,v14916=TypeScript.NodeType,v5952=v14916.None,v14917=TypeScript.ErrorRecoverySet,
v5953=v14917.TypeScriptS;setTokenInfo(v5947,v5948,v5949,v5950,v5951,v5952,"export",v5953);var v5954=TokenID.Extends,v5955=Reservation.TypeScriptAndJSFuture,v5956=OperatorPrecedence.None,v14918=TypeScript.NodeType,v5957=v14918.None,v5958=OperatorPrecedence.None,v14919=TypeScript.NodeType,v5959=v14919.None,v14920=TypeScript.ErrorRecoverySet,v5960=v14920.None;setTokenInfo(v5954,v5955,v5956,v5957,v5958,v5959,"extends",v5960);var v5961=TokenID.Declare,v5962=Reservation.TypeScript,v5963=OperatorPrecedence.None,
v14921=TypeScript.NodeType,v5964=v14921.None,v5965=OperatorPrecedence.None,v14922=TypeScript.NodeType,v5966=v14922.None,v14923=TypeScript.ErrorRecoverySet,v5967=v14923.Stmt;setTokenInfo(v5961,v5962,v5963,v5964,v5965,v5966,"declare",v5967);var v5968=TokenID.False,v5969=Reservation.TypeScriptAndJS,v5970=OperatorPrecedence.None,v14924=TypeScript.NodeType,v5971=v14924.None,v5972=OperatorPrecedence.None,v14925=TypeScript.NodeType,v5973=v14925.None,v14926=TypeScript.ErrorRecoverySet,v5974=v14926.RLit;setTokenInfo(v5968,
v5969,v5970,v5971,v5972,v5973,"false",v5974);var v5975=TokenID.Finally,v5976=Reservation.TypeScriptAndJS,v5977=OperatorPrecedence.None,v14927=TypeScript.NodeType,v5978=v14927.None,v5979=OperatorPrecedence.None,v14928=TypeScript.NodeType,v5980=v14928.None,v14929=TypeScript.ErrorRecoverySet,v5981=v14929.Catch;setTokenInfo(v5975,v5976,v5977,v5978,v5979,v5980,"finally",v5981);var v5982=TokenID.For,v5983=Reservation.TypeScriptAndJS,v5984=OperatorPrecedence.None,v14930=TypeScript.NodeType,v5985=v14930.None,
v5986=OperatorPrecedence.None,v14931=TypeScript.NodeType,v5987=v14931.None,v14932=TypeScript.ErrorRecoverySet,v5988=v14932.Stmt;setTokenInfo(v5982,v5983,v5984,v5985,v5986,v5987,"for",v5988);var v5989=TokenID.Function,v5990=Reservation.TypeScriptAndJS,v5991=OperatorPrecedence.None,v14933=TypeScript.NodeType,v5992=v14933.None,v5993=OperatorPrecedence.None,v14934=TypeScript.NodeType,v5994=v14934.None,v14935=TypeScript.ErrorRecoverySet,v5995=v14935.Func;setTokenInfo(v5989,v5990,v5991,v5992,v5993,v5994,
"function",v5995);var v5996=TokenID.Constructor,v5997=Reservation.TypeScriptAndJSFutureStrict,v5998=OperatorPrecedence.None,v14936=TypeScript.NodeType,v5999=v14936.None,v6000=OperatorPrecedence.None,v14937=TypeScript.NodeType,v6001=v14937.None,v14938=TypeScript.ErrorRecoverySet,v6002=v14938.Func;setTokenInfo(v5996,v5997,v5998,v5999,v6000,v6001,"constructor",v6002);var v6003=TokenID.Get,v6004=Reservation.TypeScript,v6005=OperatorPrecedence.None,v14939=TypeScript.NodeType,v6006=v14939.None,v6007=OperatorPrecedence.None,
v14940=TypeScript.NodeType,v6008=v14940.None,v14941=TypeScript.ErrorRecoverySet,v6009=v14941.Func;setTokenInfo(v6003,v6004,v6005,v6006,v6007,v6008,"get",v6009);var v6010=TokenID.Set,v6011=Reservation.TypeScript,v6012=OperatorPrecedence.None,v14942=TypeScript.NodeType,v6013=v14942.None,v6014=OperatorPrecedence.None,v14943=TypeScript.NodeType,v6015=v14943.None,v14944=TypeScript.ErrorRecoverySet,v6016=v14944.Func;setTokenInfo(v6010,v6011,v6012,v6013,v6014,v6015,"set",v6016);var v6017=TokenID.If,v6018=
Reservation.TypeScriptAndJS,v6019=OperatorPrecedence.None,v14945=TypeScript.NodeType,v6020=v14945.None,v6021=OperatorPrecedence.None,v14946=TypeScript.NodeType,v6022=v14946.None,v14947=TypeScript.ErrorRecoverySet,v6023=v14947.Stmt;setTokenInfo(v6017,v6018,v6019,v6020,v6021,v6022,"if",v6023);var v6024=TokenID.Implements,v6025=Reservation.TypeScriptAndJSFutureStrict,v6026=OperatorPrecedence.None,v14948=TypeScript.NodeType,v6027=v14948.None,v6028=OperatorPrecedence.None,v14949=TypeScript.NodeType,v6029=
v14949.None,v14950=TypeScript.ErrorRecoverySet,v6030=v14950.None;setTokenInfo(v6024,v6025,v6026,v6027,v6028,v6029,"implements",v6030);var v6031=TokenID.Import,v6032=Reservation.TypeScriptAndJSFuture,v6033=OperatorPrecedence.None,v14951=TypeScript.NodeType,v6034=v14951.None,v6035=OperatorPrecedence.None,v14952=TypeScript.NodeType,v6036=v14952.None,v14953=TypeScript.ErrorRecoverySet,v6037=v14953.TypeScriptS;setTokenInfo(v6031,v6032,v6033,v6034,v6035,v6036,"import",v6037);var v6038=TokenID.In,v6039=
Reservation.TypeScriptAndJS,v6040=OperatorPrecedence.Relational,v14954=TypeScript.NodeType,v6041=v14954.In,v6042=OperatorPrecedence.None,v14955=TypeScript.NodeType,v6043=v14955.None,v14956=TypeScript.ErrorRecoverySet,v6044=v14956.None;setTokenInfo(v6038,v6039,v6040,v6041,v6042,v6043,"in",v6044);var v6045=TokenID.InstanceOf,v6046=Reservation.TypeScriptAndJS,v6047=OperatorPrecedence.Relational,v14957=TypeScript.NodeType,v6048=v14957.InstOf,v6049=OperatorPrecedence.None,v14958=TypeScript.NodeType,v6050=
v14958.None,v14959=TypeScript.ErrorRecoverySet,v6051=v14959.BinOp;setTokenInfo(v6045,v6046,v6047,v6048,v6049,v6050,"instanceof",v6051);var v6052=TokenID.Interface,v6053=Reservation.TypeScriptAndJSFutureStrict,v6054=OperatorPrecedence.None,v14960=TypeScript.NodeType,v6055=v14960.None,v6056=OperatorPrecedence.None,v14961=TypeScript.NodeType,v6057=v14961.None,v14962=TypeScript.ErrorRecoverySet,v6058=v14962.TypeScriptS;setTokenInfo(v6052,v6053,v6054,v6055,v6056,v6057,"interface",v6058);var v6059=TokenID.Let,
v6060=Reservation.JavascriptFutureStrict,v6061=OperatorPrecedence.None,v14963=TypeScript.NodeType,v6062=v14963.None,v6063=OperatorPrecedence.None,v14964=TypeScript.NodeType,v6064=v14964.None,v14965=TypeScript.ErrorRecoverySet,v6065=v14965.None;setTokenInfo(v6059,v6060,v6061,v6062,v6063,v6064,"let",v6065);var v6066=TokenID.Module,v6067=Reservation.TypeScript,v6068=OperatorPrecedence.None,v14966=TypeScript.NodeType,v6069=v14966.None,v6070=OperatorPrecedence.None,v14967=TypeScript.NodeType,v6071=v14967.None,
v14968=TypeScript.ErrorRecoverySet,v6072=v14968.TypeScriptS;setTokenInfo(v6066,v6067,v6068,v6069,v6070,v6071,"module",v6072);var v6073=TokenID.New,v6074=Reservation.TypeScriptAndJS,v6075=OperatorPrecedence.None,v14969=TypeScript.NodeType,v6076=v14969.None,v6077=OperatorPrecedence.None,v14970=TypeScript.NodeType,v6078=v14970.None,v14971=TypeScript.ErrorRecoverySet,v6079=v14971.PreOp;setTokenInfo(v6073,v6074,v6075,v6076,v6077,v6078,"new",v6079);var v6080=TokenID.Number,v6081=Reservation.TypeScript,
v6082=OperatorPrecedence.None,v14972=TypeScript.NodeType,v6083=v14972.None,v6084=OperatorPrecedence.None,v14973=TypeScript.NodeType,v6085=v14973.None,v14974=TypeScript.ErrorRecoverySet,v6086=v14974.PrimType;setTokenInfo(v6080,v6081,v6082,v6083,v6084,v6085,"number",v6086);var v6087=TokenID.Null,v6088=Reservation.TypeScriptAndJS,v6089=OperatorPrecedence.None,v14975=TypeScript.NodeType,v6090=v14975.None,v6091=OperatorPrecedence.None,v14976=TypeScript.NodeType,v6092=v14976.None,v14977=TypeScript.ErrorRecoverySet,
v6093=v14977.RLit;setTokenInfo(v6087,v6088,v6089,v6090,v6091,v6092,"null",v6093);var v6094=TokenID.Package,v6095=Reservation.JavascriptFutureStrict,v6096=OperatorPrecedence.None,v14978=TypeScript.NodeType,v6097=v14978.None,v6098=OperatorPrecedence.None,v14979=TypeScript.NodeType,v6099=v14979.None,v14980=TypeScript.ErrorRecoverySet,v6100=v14980.None;setTokenInfo(v6094,v6095,v6096,v6097,v6098,v6099,"package",v6100);var v6101=TokenID.Private,v6102=Reservation.TypeScriptAndJSFutureStrict,v6103=OperatorPrecedence.None,
v14981=TypeScript.NodeType,v6104=v14981.None,v6105=OperatorPrecedence.None,v14982=TypeScript.NodeType,v6106=v14982.None,v14983=TypeScript.ErrorRecoverySet,v6107=v14983.TypeScriptS;setTokenInfo(v6101,v6102,v6103,v6104,v6105,v6106,"private",v6107);var v6108=TokenID.Protected,v6109=Reservation.JavascriptFutureStrict,v6110=OperatorPrecedence.None,v14984=TypeScript.NodeType,v6111=v14984.None,v6112=OperatorPrecedence.None,v14985=TypeScript.NodeType,v6113=v14985.None,v14986=TypeScript.ErrorRecoverySet,v6114=
v14986.None;setTokenInfo(v6108,v6109,v6110,v6111,v6112,v6113,"protected",v6114);var v6115=TokenID.Public,v6116=Reservation.TypeScriptAndJSFutureStrict,v6117=OperatorPrecedence.None,v14987=TypeScript.NodeType,v6118=v14987.None,v6119=OperatorPrecedence.None,v14988=TypeScript.NodeType,v6120=v14988.None,v14989=TypeScript.ErrorRecoverySet,v6121=v14989.TypeScriptS;setTokenInfo(v6115,v6116,v6117,v6118,v6119,v6120,"public",v6121);var v6122=TokenID.Return,v6123=Reservation.TypeScriptAndJS,v6124=OperatorPrecedence.None,
v14990=TypeScript.NodeType,v6125=v14990.None,v6126=OperatorPrecedence.None,v14991=TypeScript.NodeType,v6127=v14991.None,v14992=TypeScript.ErrorRecoverySet,v6128=v14992.Stmt;setTokenInfo(v6122,v6123,v6124,v6125,v6126,v6127,"return",v6128);var v6129=TokenID.Static,v6130=Reservation.TypeScriptAndJSFutureStrict,v6131=OperatorPrecedence.None,v14993=TypeScript.NodeType,v6132=v14993.None,v6133=OperatorPrecedence.None,v14994=TypeScript.NodeType,v6134=v14994.None,v14995=TypeScript.ErrorRecoverySet,v6135=v14995.None;
setTokenInfo(v6129,v6130,v6131,v6132,v6133,v6134,"static",v6135);var v6136=TokenID.String,v6137=Reservation.TypeScript,v6138=OperatorPrecedence.None,v14996=TypeScript.NodeType,v6139=v14996.None,v6140=OperatorPrecedence.None,v14997=TypeScript.NodeType,v6141=v14997.None,v14998=TypeScript.ErrorRecoverySet,v6142=v14998.PrimType;setTokenInfo(v6136,v6137,v6138,v6139,v6140,v6141,"string",v6142);var v6143=TokenID.Super,v6144=Reservation.TypeScriptAndJSFuture,v6145=OperatorPrecedence.None,v14999=TypeScript.NodeType,
v6146=v14999.None,v6147=OperatorPrecedence.None,v15000=TypeScript.NodeType,v6148=v15000.None,v15001=TypeScript.ErrorRecoverySet,v6149=v15001.RLit;setTokenInfo(v6143,v6144,v6145,v6146,v6147,v6148,"super",v6149);var v6150=TokenID.Switch,v6151=Reservation.TypeScriptAndJS,v6152=OperatorPrecedence.None,v15002=TypeScript.NodeType,v6153=v15002.None,v6154=OperatorPrecedence.None,v15003=TypeScript.NodeType,v6155=v15003.None,v15004=TypeScript.ErrorRecoverySet,v6156=v15004.Stmt;setTokenInfo(v6150,v6151,v6152,
v6153,v6154,v6155,"switch",v6156);var v6157=TokenID.This,v6158=Reservation.TypeScriptAndJS,v6159=OperatorPrecedence.None,v15005=TypeScript.NodeType,v6160=v15005.None,v6161=OperatorPrecedence.None,v15006=TypeScript.NodeType,v6162=v15006.None,v15007=TypeScript.ErrorRecoverySet,v6163=v15007.RLit;setTokenInfo(v6157,v6158,v6159,v6160,v6161,v6162,"this",v6163);var v6164=TokenID.Throw,v6165=Reservation.TypeScriptAndJS,v6166=OperatorPrecedence.None,v15008=TypeScript.NodeType,v6167=v15008.None,v6168=OperatorPrecedence.None,
v15009=TypeScript.NodeType,v6169=v15009.None,v15010=TypeScript.ErrorRecoverySet,v6170=v15010.Stmt;setTokenInfo(v6164,v6165,v6166,v6167,v6168,v6169,"throw",v6170);var v6171=TokenID.True,v6172=Reservation.TypeScriptAndJS,v6173=OperatorPrecedence.None,v15011=TypeScript.NodeType,v6174=v15011.None,v6175=OperatorPrecedence.None,v15012=TypeScript.NodeType,v6176=v15012.None,v15013=TypeScript.ErrorRecoverySet,v6177=v15013.RLit;setTokenInfo(v6171,v6172,v6173,v6174,v6175,v6176,"true",v6177);var v6178=TokenID.Try,
v6179=Reservation.TypeScriptAndJS,v6180=OperatorPrecedence.None,v15014=TypeScript.NodeType,v6181=v15014.None,v6182=OperatorPrecedence.None,v15015=TypeScript.NodeType,v6183=v15015.None,v15016=TypeScript.ErrorRecoverySet,v6184=v15016.Stmt;setTokenInfo(v6178,v6179,v6180,v6181,v6182,v6183,"try",v6184);var v6185=TokenID.TypeOf,v6186=Reservation.TypeScriptAndJS,v6187=OperatorPrecedence.None,v15017=TypeScript.NodeType,v6188=v15017.None,v6189=OperatorPrecedence.Unary,v15018=TypeScript.NodeType,v6190=v15018.Typeof,
v15019=TypeScript.ErrorRecoverySet,v6191=v15019.Prefix;setTokenInfo(v6185,v6186,v6187,v6188,v6189,v6190,"typeof",v6191);var v6192=TokenID.Var,v6193=Reservation.TypeScriptAndJS,v6194=OperatorPrecedence.None,v15020=TypeScript.NodeType,v6195=v15020.None,v6196=OperatorPrecedence.None,v15021=TypeScript.NodeType,v6197=v15021.None,v15022=TypeScript.ErrorRecoverySet,v6198=v15022.Var;setTokenInfo(v6192,v6193,v6194,v6195,v6196,v6197,"var",v6198);var v6199=TokenID.Void,v6200=Reservation.TypeScriptAndJS,v6201=
OperatorPrecedence.None,v15023=TypeScript.NodeType,v6202=v15023.None,v6203=OperatorPrecedence.Unary,v15024=TypeScript.NodeType,v6204=v15024.Void,v15025=TypeScript.ErrorRecoverySet,v6205=v15025.Prefix;setTokenInfo(v6199,v6200,v6201,v6202,v6203,v6204,"void",v6205);var v6206=TokenID.With,v6207=Reservation.TypeScriptAndJS,v6208=OperatorPrecedence.None,v15026=TypeScript.NodeType,v6209=v15026.None,v6210=OperatorPrecedence.None,v15027=TypeScript.NodeType,v6211=v15027.With,v15028=TypeScript.ErrorRecoverySet,
v6212=v15028.Stmt;setTokenInfo(v6206,v6207,v6208,v6209,v6210,v6211,"with",v6212);var v6213=TokenID.While,v6214=Reservation.TypeScriptAndJS,v6215=OperatorPrecedence.None,v15029=TypeScript.NodeType,v6216=v15029.None,v6217=OperatorPrecedence.None,v15030=TypeScript.NodeType,v6218=v15030.None,v15031=TypeScript.ErrorRecoverySet,v6219=v15031.While;setTokenInfo(v6213,v6214,v6215,v6216,v6217,v6218,"while",v6219);var v6220=TokenID.Yield,v6221=Reservation.JavascriptFutureStrict,v6222=OperatorPrecedence.None,
v15032=TypeScript.NodeType,v6223=v15032.None,v6224=OperatorPrecedence.None,v15033=TypeScript.NodeType,v6225=v15033.None,v15034=TypeScript.ErrorRecoverySet,v6226=v15034.None;setTokenInfo(v6220,v6221,v6222,v6223,v6224,v6225,"yield",v6226);var v6227=TokenID.Identifier,v6228=Reservation.None,v6229=OperatorPrecedence.None,v15035=TypeScript.NodeType,v6230=v15035.None,v6231=OperatorPrecedence.None,v15036=TypeScript.NodeType,v6232=v15036.None,v15037=TypeScript.ErrorRecoverySet,v6233=v15037.ID;setTokenInfo(v6227,
v6228,v6229,v6230,v6231,v6232,"identifier",v6233);var v6234=TokenID.NumberLiteral,v6235=Reservation.None,v6236=OperatorPrecedence.None,v15038=TypeScript.NodeType,v6237=v15038.None,v6238=OperatorPrecedence.None,v15039=TypeScript.NodeType,v6239=v15039.None,v15040=TypeScript.ErrorRecoverySet,v6240=v15040.Literal;setTokenInfo(v6234,v6235,v6236,v6237,v6238,v6239,"numberLiteral",v6240);var v6241=TokenID.RegularExpressionLiteral,v6242=Reservation.None,v6243=OperatorPrecedence.None,v15041=TypeScript.NodeType,
v6244=v15041.None,v6245=OperatorPrecedence.None,v15042=TypeScript.NodeType,v6246=v15042.None,v15043=TypeScript.ErrorRecoverySet,v6247=v15043.RegExp;setTokenInfo(v6241,v6242,v6243,v6244,v6245,v6246,"regex",v6247);var v6248=TokenID.StringLiteral,v6249=Reservation.None,v6250=OperatorPrecedence.None,v15044=TypeScript.NodeType,v6251=v15044.None,v6252=OperatorPrecedence.None,v15045=TypeScript.NodeType,v6253=v15045.None,v15046=TypeScript.ErrorRecoverySet,v6254=v15046.Literal;setTokenInfo(v6248,v6249,v6250,
v6251,v6252,v6253,"qstring",v6254);var v6255=TokenID.Semicolon,v6256=Reservation.None,v6257=OperatorPrecedence.None,v15047=TypeScript.NodeType,v6258=v15047.None,v6259=OperatorPrecedence.None,v15048=TypeScript.NodeType,v6260=v15048.None,v15049=TypeScript.ErrorRecoverySet,v6261=v15049.SColon;setTokenInfo(v6255,v6256,v6257,v6258,v6259,v6260,";",v6261);var v6262=TokenID.CloseParen,v6263=Reservation.None,v6264=OperatorPrecedence.None,v15050=TypeScript.NodeType,v6265=v15050.None,v6266=OperatorPrecedence.None,
v15051=TypeScript.NodeType,v6267=v15051.None,v15052=TypeScript.ErrorRecoverySet,v6268=v15052.RParen;setTokenInfo(v6262,v6263,v6264,v6265,v6266,v6267,")",v6268);var v6269=TokenID.CloseBracket,v6270=Reservation.None,v6271=OperatorPrecedence.None,v15053=TypeScript.NodeType,v6272=v15053.None,v6273=OperatorPrecedence.None,v15054=TypeScript.NodeType,v6274=v15054.None,v15055=TypeScript.ErrorRecoverySet,v6275=v15055.RBrack;setTokenInfo(v6269,v6270,v6271,v6272,v6273,v6274,"]",v6275);var v6276=TokenID.OpenBrace,
v6277=Reservation.None,v6278=OperatorPrecedence.None,v15056=TypeScript.NodeType,v6279=v15056.None,v6280=OperatorPrecedence.None,v15057=TypeScript.NodeType,v6281=v15057.None,v15058=TypeScript.ErrorRecoverySet,v6282=v15058.LCurly;setTokenInfo(v6276,v6277,v6278,v6279,v6280,v6281,"{",v6282);var v6283=TokenID.CloseBrace,v6284=Reservation.None,v6285=OperatorPrecedence.None,v15059=TypeScript.NodeType,v6286=v15059.None,v6287=OperatorPrecedence.None,v15060=TypeScript.NodeType,v6288=v15060.None,v15061=TypeScript.ErrorRecoverySet,
v6289=v15061.RCurly;setTokenInfo(v6283,v6284,v6285,v6286,v6287,v6288,"}",v6289);var v6290=TokenID.DotDotDot,v6291=Reservation.None,v6292=OperatorPrecedence.None,v15062=TypeScript.NodeType,v6293=v15062.None,v6294=OperatorPrecedence.None,v15063=TypeScript.NodeType,v6295=v15063.None,v15064=TypeScript.ErrorRecoverySet,v6296=v15064.None;setTokenInfo(v6290,v6291,v6292,v6293,v6294,v6295,"...",v6296);var v6297=TokenID.Comma,v6298=Reservation.None,v6299=OperatorPrecedence.Comma,v15065=TypeScript.NodeType,
v6300=v15065.Comma,v6301=OperatorPrecedence.None,v15066=TypeScript.NodeType,v6302=v15066.None,v15067=TypeScript.ErrorRecoverySet,v6303=v15067.Comma;setTokenInfo(v6297,v6298,v6299,v6300,v6301,v6302,",",v6303);var v6304=TokenID.Equals,v6305=Reservation.None,v6306=OperatorPrecedence.Assignment,v15068=TypeScript.NodeType,v6307=v15068.Asg,v6308=OperatorPrecedence.None,v15069=TypeScript.NodeType,v6309=v15069.None,v15070=TypeScript.ErrorRecoverySet,v6310=v15070.Asg;setTokenInfo(v6304,v6305,v6306,v6307,v6308,
v6309,"=",v6310);var v6311=TokenID.PlusEquals,v6312=Reservation.None,v6313=OperatorPrecedence.Assignment,v15071=TypeScript.NodeType,v6314=v15071.AsgAdd,v6315=OperatorPrecedence.None,v15072=TypeScript.NodeType,v6316=v15072.None,v15073=TypeScript.ErrorRecoverySet,v6317=v15073.BinOp;setTokenInfo(v6311,v6312,v6313,v6314,v6315,v6316,"+=",v6317);var v6318=TokenID.MinusEquals,v6319=Reservation.None,v6320=OperatorPrecedence.Assignment,v15074=TypeScript.NodeType,v6321=v15074.AsgSub,v6322=OperatorPrecedence.None,
v15075=TypeScript.NodeType,v6323=v15075.None,v15076=TypeScript.ErrorRecoverySet,v6324=v15076.BinOp;setTokenInfo(v6318,v6319,v6320,v6321,v6322,v6323,"-=",v6324);var v6325=TokenID.AsteriskEquals,v6326=Reservation.None,v6327=OperatorPrecedence.Assignment,v15077=TypeScript.NodeType,v6328=v15077.AsgMul,v6329=OperatorPrecedence.None,v15078=TypeScript.NodeType,v6330=v15078.None,v15079=TypeScript.ErrorRecoverySet,v6331=v15079.BinOp;setTokenInfo(v6325,v6326,v6327,v6328,v6329,v6330,"*=",v6331);var v6332=TokenID.SlashEquals,
v6333=Reservation.None,v6334=OperatorPrecedence.Assignment,v15080=TypeScript.NodeType,v6335=v15080.AsgDiv,v6336=OperatorPrecedence.None,v15081=TypeScript.NodeType,v6337=v15081.None,v15082=TypeScript.ErrorRecoverySet,v6338=v15082.BinOp;setTokenInfo(v6332,v6333,v6334,v6335,v6336,v6337,"/=",v6338);var v6339=TokenID.PercentEquals,v6340=Reservation.None,v6341=OperatorPrecedence.Assignment,v15083=TypeScript.NodeType,v6342=v15083.AsgMod,v6343=OperatorPrecedence.None,v15084=TypeScript.NodeType,v6344=v15084.None,
v15085=TypeScript.ErrorRecoverySet,v6345=v15085.BinOp;setTokenInfo(v6339,v6340,v6341,v6342,v6343,v6344,"%=",v6345);var v6346=TokenID.AmpersandEquals,v6347=Reservation.None,v6348=OperatorPrecedence.Assignment,v15086=TypeScript.NodeType,v6349=v15086.AsgAnd,v6350=OperatorPrecedence.None,v15087=TypeScript.NodeType,v6351=v15087.None,v15088=TypeScript.ErrorRecoverySet,v6352=v15088.BinOp;setTokenInfo(v6346,v6347,v6348,v6349,v6350,v6351,"&=",v6352);var v6353=TokenID.CaretEquals,v6354=Reservation.None,v6355=
OperatorPrecedence.Assignment,v15089=TypeScript.NodeType,v6356=v15089.AsgXor,v6357=OperatorPrecedence.None,v15090=TypeScript.NodeType,v6358=v15090.None,v15091=TypeScript.ErrorRecoverySet,v6359=v15091.BinOp;setTokenInfo(v6353,v6354,v6355,v6356,v6357,v6358,"^=",v6359);var v6360=TokenID.BarEquals,v6361=Reservation.None,v6362=OperatorPrecedence.Assignment,v15092=TypeScript.NodeType,v6363=v15092.AsgOr,v6364=OperatorPrecedence.None,v15093=TypeScript.NodeType,v6365=v15093.None,v15094=TypeScript.ErrorRecoverySet,
v6366=v15094.BinOp;setTokenInfo(v6360,v6361,v6362,v6363,v6364,v6365,"|=",v6366);var v6367=TokenID.LessThanLessThanEquals,v6368=Reservation.None,v6369=OperatorPrecedence.Assignment,v15095=TypeScript.NodeType,v6370=v15095.AsgLsh,v6371=OperatorPrecedence.None,v15096=TypeScript.NodeType,v6372=v15096.None,v15097=TypeScript.ErrorRecoverySet,v6373=v15097.BinOp;setTokenInfo(v6367,v6368,v6369,v6370,v6371,v6372,"<<=",v6373);var v6374=TokenID.GreaterThanGreaterThanEquals,v6375=Reservation.None,v6376=OperatorPrecedence.Assignment,
v15098=TypeScript.NodeType,v6377=v15098.AsgRsh,v6378=OperatorPrecedence.None,v15099=TypeScript.NodeType,v6379=v15099.None,v15100=TypeScript.ErrorRecoverySet,v6380=v15100.BinOp;setTokenInfo(v6374,v6375,v6376,v6377,v6378,v6379,">>=",v6380);var v6381=TokenID.GreaterThanGreaterThanGreaterThanEquals,v6382=Reservation.None,v6383=OperatorPrecedence.Assignment,v15101=TypeScript.NodeType,v6384=v15101.AsgRs2,v6385=OperatorPrecedence.None,v15102=TypeScript.NodeType,v6386=v15102.None,v15103=TypeScript.ErrorRecoverySet,
v6387=v15103.BinOp;setTokenInfo(v6381,v6382,v6383,v6384,v6385,v6386,">>>=",v6387);var v6388=TokenID.Question,v6389=Reservation.None,v6390=OperatorPrecedence.Conditional,v15104=TypeScript.NodeType,v6391=v15104.ConditionalExpression,v6392=OperatorPrecedence.None,v15105=TypeScript.NodeType,v6393=v15105.None,v15106=TypeScript.ErrorRecoverySet,v6394=v15106.BinOp;setTokenInfo(v6388,v6389,v6390,v6391,v6392,v6393,"?",v6394);var v6395=TokenID.Colon,v6396=Reservation.None,v6397=OperatorPrecedence.None,v15107=
TypeScript.NodeType,v6398=v15107.None,v6399=OperatorPrecedence.None,v15108=TypeScript.NodeType,v6400=v15108.None,v15109=TypeScript.ErrorRecoverySet,v6401=v15109.Colon;setTokenInfo(v6395,v6396,v6397,v6398,v6399,v6400,":",v6401);var v6402=TokenID.BarBar,v6403=Reservation.None,v6404=OperatorPrecedence.LogicalOr,v15110=TypeScript.NodeType,v6405=v15110.LogOr,v6406=OperatorPrecedence.None,v15111=TypeScript.NodeType,v6407=v15111.None,v15112=TypeScript.ErrorRecoverySet,v6408=v15112.BinOp;setTokenInfo(v6402,
v6403,v6404,v6405,v6406,v6407,"||",v6408);var v6409=TokenID.AmpersandAmpersand,v6410=Reservation.None,v6411=OperatorPrecedence.LogicalAnd,v15113=TypeScript.NodeType,v6412=v15113.LogAnd,v6413=OperatorPrecedence.None,v15114=TypeScript.NodeType,v6414=v15114.None,v15115=TypeScript.ErrorRecoverySet,v6415=v15115.BinOp;setTokenInfo(v6409,v6410,v6411,v6412,v6413,v6414,"&&",v6415);var v6416=TokenID.Bar,v6417=Reservation.None,v6418=OperatorPrecedence.BitwiseOr,v15116=TypeScript.NodeType,v6419=v15116.Or,v6420=
OperatorPrecedence.None,v15117=TypeScript.NodeType,v6421=v15117.None,v15118=TypeScript.ErrorRecoverySet,v6422=v15118.BinOp;setTokenInfo(v6416,v6417,v6418,v6419,v6420,v6421,"|",v6422);var v6423=TokenID.Caret,v6424=Reservation.None,v6425=OperatorPrecedence.BitwiseExclusiveOr,v15119=TypeScript.NodeType,v6426=v15119.Xor,v6427=OperatorPrecedence.None,v15120=TypeScript.NodeType,v6428=v15120.None,v15121=TypeScript.ErrorRecoverySet,v6429=v15121.BinOp;setTokenInfo(v6423,v6424,v6425,v6426,v6427,v6428,"^",v6429);
var v6430=TokenID.And,v6431=Reservation.None,v6432=OperatorPrecedence.BitwiseAnd,v15122=TypeScript.NodeType,v6433=v15122.And,v6434=OperatorPrecedence.None,v15123=TypeScript.NodeType,v6435=v15123.None,v15124=TypeScript.ErrorRecoverySet,v6436=v15124.BinOp;setTokenInfo(v6430,v6431,v6432,v6433,v6434,v6435,"&",v6436);var v6437=TokenID.EqualsEquals,v6438=Reservation.None,v6439=OperatorPrecedence.Equality,v15125=TypeScript.NodeType,v6440=v15125.Eq,v6441=OperatorPrecedence.None,v15126=TypeScript.NodeType,
v6442=v15126.None,v15127=TypeScript.ErrorRecoverySet,v6443=v15127.BinOp;setTokenInfo(v6437,v6438,v6439,v6440,v6441,v6442,"==",v6443);var v6444=TokenID.ExclamationEquals,v6445=Reservation.None,v6446=OperatorPrecedence.Equality,v15128=TypeScript.NodeType,v6447=v15128.Ne,v6448=OperatorPrecedence.None,v15129=TypeScript.NodeType,v6449=v15129.None,v15130=TypeScript.ErrorRecoverySet,v6450=v15130.BinOp;setTokenInfo(v6444,v6445,v6446,v6447,v6448,v6449,"!=",v6450);var v6451=TokenID.EqualsEqualsEquals,v6452=
Reservation.None,v6453=OperatorPrecedence.Equality,v15131=TypeScript.NodeType,v6454=v15131.Eqv,v6455=OperatorPrecedence.None,v15132=TypeScript.NodeType,v6456=v15132.None,v15133=TypeScript.ErrorRecoverySet,v6457=v15133.BinOp;setTokenInfo(v6451,v6452,v6453,v6454,v6455,v6456,"===",v6457);var v6458=TokenID.ExclamationEqualsEquals,v6459=Reservation.None,v6460=OperatorPrecedence.Equality,v15134=TypeScript.NodeType,v6461=v15134.NEqv,v6462=OperatorPrecedence.None,v15135=TypeScript.NodeType,v6463=v15135.None,
v15136=TypeScript.ErrorRecoverySet,v6464=v15136.BinOp;setTokenInfo(v6458,v6459,v6460,v6461,v6462,v6463,"!==",v6464);var v6465=TokenID.LessThan,v6466=Reservation.None,v6467=OperatorPrecedence.Relational,v15137=TypeScript.NodeType,v6468=v15137.Lt,v6469=OperatorPrecedence.None,v15138=TypeScript.NodeType,v6470=v15138.None,v15139=TypeScript.ErrorRecoverySet,v6471=v15139.BinOp;setTokenInfo(v6465,v6466,v6467,v6468,v6469,v6470,"<",v6471);var v6472=TokenID.LessThanEquals,v6473=Reservation.None,v6474=OperatorPrecedence.Relational,
v15140=TypeScript.NodeType,v6475=v15140.Le,v6476=OperatorPrecedence.None,v15141=TypeScript.NodeType,v6477=v15141.None,v15142=TypeScript.ErrorRecoverySet,v6478=v15142.BinOp;setTokenInfo(v6472,v6473,v6474,v6475,v6476,v6477,"<=",v6478);var v6479=TokenID.GreaterThan,v6480=Reservation.None,v6481=OperatorPrecedence.Relational,v15143=TypeScript.NodeType,v6482=v15143.Gt,v6483=OperatorPrecedence.None,v15144=TypeScript.NodeType,v6484=v15144.None,v15145=TypeScript.ErrorRecoverySet,v6485=v15145.BinOp;setTokenInfo(v6479,
v6480,v6481,v6482,v6483,v6484,">",v6485);var v6486=TokenID.GreaterThanEquals,v6487=Reservation.None,v6488=OperatorPrecedence.Relational,v15146=TypeScript.NodeType,v6489=v15146.Ge,v6490=OperatorPrecedence.None,v15147=TypeScript.NodeType,v6491=v15147.None,v15148=TypeScript.ErrorRecoverySet,v6492=v15148.BinOp;setTokenInfo(v6486,v6487,v6488,v6489,v6490,v6491,">=",v6492);var v6493=TokenID.LessThanLessThan,v6494=Reservation.None,v6495=OperatorPrecedence.Shift,v15149=TypeScript.NodeType,v6496=v15149.Lsh,
v6497=OperatorPrecedence.None,v15150=TypeScript.NodeType,v6498=v15150.None,v15151=TypeScript.ErrorRecoverySet,v6499=v15151.BinOp;setTokenInfo(v6493,v6494,v6495,v6496,v6497,v6498,"<<",v6499);var v6500=TokenID.GreaterThanGreaterThan,v6501=Reservation.None,v6502=OperatorPrecedence.Shift,v15152=TypeScript.NodeType,v6503=v15152.Rsh,v6504=OperatorPrecedence.None,v15153=TypeScript.NodeType,v6505=v15153.None,v15154=TypeScript.ErrorRecoverySet,v6506=v15154.BinOp;setTokenInfo(v6500,v6501,v6502,v6503,v6504,
v6505,">>",v6506);var v6507=TokenID.GreaterThanGreaterThanGreaterThan,v6508=Reservation.None,v6509=OperatorPrecedence.Shift,v15155=TypeScript.NodeType,v6510=v15155.Rs2,v6511=OperatorPrecedence.None,v15156=TypeScript.NodeType,v6512=v15156.None,v15157=TypeScript.ErrorRecoverySet,v6513=v15157.BinOp;setTokenInfo(v6507,v6508,v6509,v6510,v6511,v6512,">>>",v6513);var v6514=TokenID.Plus,v6515=Reservation.None,v6516=OperatorPrecedence.Additive,v15158=TypeScript.NodeType,v6517=v15158.Add,v6518=OperatorPrecedence.Unary,
v15159=TypeScript.NodeType,v6519=v15159.Pos,v15160=TypeScript.ErrorRecoverySet,v6520=v15160.AddOp;setTokenInfo(v6514,v6515,v6516,v6517,v6518,v6519,"+",v6520);var v6521=TokenID.Minus,v6522=Reservation.None,v6523=OperatorPrecedence.Additive,v15161=TypeScript.NodeType,v6524=v15161.Sub,v6525=OperatorPrecedence.Unary,v15162=TypeScript.NodeType,v6526=v15162.Neg,v15163=TypeScript.ErrorRecoverySet,v6527=v15163.AddOp;setTokenInfo(v6521,v6522,v6523,v6524,v6525,v6526,"-",v6527);var v6528=TokenID.Asterisk,v6529=
Reservation.None,v6530=OperatorPrecedence.Multiplicative,v15164=TypeScript.NodeType,v6531=v15164.Mul,v6532=OperatorPrecedence.None,v15165=TypeScript.NodeType,v6533=v15165.None,v15166=TypeScript.ErrorRecoverySet,v6534=v15166.BinOp;setTokenInfo(v6528,v6529,v6530,v6531,v6532,v6533,"*",v6534);var v6535=TokenID.Slash,v6536=Reservation.None,v6537=OperatorPrecedence.Multiplicative,v15167=TypeScript.NodeType,v6538=v15167.Div,v6539=OperatorPrecedence.None,v15168=TypeScript.NodeType,v6540=v15168.None,v15169=
TypeScript.ErrorRecoverySet,v6541=v15169.BinOp;setTokenInfo(v6535,v6536,v6537,v6538,v6539,v6540,"/",v6541);var v6542=TokenID.Percent,v6543=Reservation.None,v6544=OperatorPrecedence.Multiplicative,v15170=TypeScript.NodeType,v6545=v15170.Mod,v6546=OperatorPrecedence.None,v15171=TypeScript.NodeType,v6547=v15171.None,v15172=TypeScript.ErrorRecoverySet,v6548=v15172.BinOp;setTokenInfo(v6542,v6543,v6544,v6545,v6546,v6547,"%",v6548);var v6549=TokenID.Tilde,v6550=Reservation.None,v6551=OperatorPrecedence.None,
v15173=TypeScript.NodeType,v6552=v15173.None,v6553=OperatorPrecedence.Unary,v15174=TypeScript.NodeType,v6554=v15174.Not,v15175=TypeScript.ErrorRecoverySet,v6555=v15175.PreOp;setTokenInfo(v6549,v6550,v6551,v6552,v6553,v6554,"~",v6555);var v6556=TokenID.Exclamation,v6557=Reservation.None,v6558=OperatorPrecedence.None,v15176=TypeScript.NodeType,v6559=v15176.None,v6560=OperatorPrecedence.Unary,v15177=TypeScript.NodeType,v6561=v15177.LogNot,v15178=TypeScript.ErrorRecoverySet,v6562=v15178.PreOp;setTokenInfo(v6556,
v6557,v6558,v6559,v6560,v6561,"!",v6562);var v6563=TokenID.PlusPlus,v6564=Reservation.None,v6565=OperatorPrecedence.None,v15179=TypeScript.NodeType,v6566=v15179.None,v6567=OperatorPrecedence.Unary,v15180=TypeScript.NodeType,v6568=v15180.IncPre,v15181=TypeScript.ErrorRecoverySet,v6569=v15181.PreOp;setTokenInfo(v6563,v6564,v6565,v6566,v6567,v6568,"++",v6569);var v6570=TokenID.MinusMinus,v6571=Reservation.None,v6572=OperatorPrecedence.None,v15182=TypeScript.NodeType,v6573=v15182.None,v6574=OperatorPrecedence.Unary,
v15183=TypeScript.NodeType,v6575=v15183.DecPre,v15184=TypeScript.ErrorRecoverySet,v6576=v15184.PreOp;setTokenInfo(v6570,v6571,v6572,v6573,v6574,v6575,"--",v6576);var v6577=TokenID.OpenParen,v6578=Reservation.None,v6579=OperatorPrecedence.None,v15185=TypeScript.NodeType,v6580=v15185.None,v6581=OperatorPrecedence.None,v15186=TypeScript.NodeType,v6582=v15186.None,v15187=TypeScript.ErrorRecoverySet,v6583=v15187.LParen;setTokenInfo(v6577,v6578,v6579,v6580,v6581,v6582,"(",v6583);var v6584=TokenID.OpenBracket,
v6585=Reservation.None,v6586=OperatorPrecedence.None,v15188=TypeScript.NodeType,v6587=v15188.None,v6588=OperatorPrecedence.None,v15189=TypeScript.NodeType,v6589=v15189.None,v15190=TypeScript.ErrorRecoverySet,v6590=v15190.LBrack;setTokenInfo(v6584,v6585,v6586,v6587,v6588,v6589,"[",v6590);var v6591=TokenID.Dot,v6592=Reservation.None,v6593=OperatorPrecedence.Unary,v15191=TypeScript.NodeType,v6594=v15191.None,v6595=OperatorPrecedence.None,v15192=TypeScript.NodeType,v6596=v15192.None,v15193=TypeScript.ErrorRecoverySet,
v6597=v15193.Dot;setTokenInfo(v6591,v6592,v6593,v6594,v6595,v6596,".",v6597);var v6598=TokenID.EndOfFile,v6599=Reservation.None,v6600=OperatorPrecedence.None,v15194=TypeScript.NodeType,v6601=v15194.None,v6602=OperatorPrecedence.None,v15195=TypeScript.NodeType,v6603=v15195.None,v15196=TypeScript.ErrorRecoverySet,v6604=v15196.EOF;setTokenInfo(v6598,v6599,v6600,v6601,v6602,v6603,"<EOF>",v6604);var v6605=TokenID.EqualsGreaterThan,v6606=Reservation.None,v6607=OperatorPrecedence.None,v15197=TypeScript.NodeType,
v6608=v15197.None,v6609=OperatorPrecedence.None,v15198=TypeScript.NodeType,v6610=v15198.None,v15199=TypeScript.ErrorRecoverySet,v6611=v15199.None;setTokenInfo(v6605,v6606,v6607,v6608,v6609,v6610,"=>",v6611);TypeScript.lookupToken=lookupToken;var v15200=TypeScript.TokenClass,v20319=!v15200;v20319&&(v15200=TypeScript.TokenClass={});var v6612=v15200;v867(v6612);var TokenClass=TypeScript.TokenClass,SavedToken=v868();TypeScript.SavedToken=SavedToken;var Token=v873();TypeScript.Token=Token;var NumberLiteralToken=
v876(Token);TypeScript.NumberLiteralToken=NumberLiteralToken;var StringLiteralToken=v879(Token);TypeScript.StringLiteralToken=StringLiteralToken;var IdentifierToken=v882(Token);TypeScript.IdentifierToken=IdentifierToken;var WhitespaceToken=v885(Token);TypeScript.WhitespaceToken=WhitespaceToken;var CommentToken=v888(Token);TypeScript.CommentToken=CommentToken;var RegularExpressionLiteralToken=v891(Token);TypeScript.RegularExpressionLiteralToken=RegularExpressionLiteralToken;var v6613=TypeScript,v27000=
[];v6613.staticTokens=v27000;TypeScript.initializeStaticTokens=initializeStaticTokens}
function v862(){var TypeScript=v12361;function v861(_super){function v860(name,publicOnly,typespace){var v15201=_super.prototype,v15201=v15201.findLocal;if(v15201=JAMScript.call(v15201.call,v15201,[this,name,publicOnly,typespace]))if(v15201=JAMScript.call(this.filter,this,[v15201]),v15201=!v15201)return null;v15201=_super.prototype;v15201=v15201.find;return JAMScript.call(v15201.call,v15201,[this,name,publicOnly,typespace])}function v859(filter,name,publicOnly,typespace){throw Error("please implement");
}function v858(name,publicOnly,typespace){var v15204=_super.prototype,v15204=v15204.findLocal;if(name=JAMScript.call(v15204.call,v15204,[this,name,publicOnly,typespace]))if(publicOnly=JAMScript.call(this.filter,this,[name]),publicOnly=!publicOnly)return null;return name}function FilteredSymbolScopeBuilder(valueMembers,parent,container,filter){JAMScript.call(_super.call,_super,[this,valueMembers,null,null,null,parent,container]);this.filter=filter}JAMScript.call(__extends,null,[FilteredSymbolScopeBuilder,
_super]);var v6619=FilteredSymbolScopeBuilder.prototype;v6619.findLocal=v858;v6619=FilteredSymbolScopeBuilder.prototype;v6619.search=v859;v6619=FilteredSymbolScopeBuilder.prototype;v6619.find=v860;return FilteredSymbolScopeBuilder}function v857(_super){function v856(name,publicOnly,typespace){var v6622=this.scope;return JAMScript.call(v6622.findLocal,v6622,[name,publicOnly,typespace])}function v855(name,publicOnly,typespace){var v6623=this.filter;JAMScript.call(v6623.reset,v6623,[]);var v6623=this.scope,
v6625=this.filter;return JAMScript.call(v6623.search,v6623,[v6625,name,publicOnly,typespace])}function v854(outfile){var v6626=this.scope;JAMScript.call(v6626.print,v6626,[outfile])}function FilteredSymbolScope(scope,container,filter){JAMScript.call(_super.call,_super,[this,container]);this.scope=scope;this.filter=filter}JAMScript.call(__extends,null,[FilteredSymbolScope,_super]);var v6627=FilteredSymbolScope.prototype;v6627.print=v854;v6627=FilteredSymbolScope.prototype;v6627.find=v855;v6627=FilteredSymbolScope.prototype;
v6627.findLocal=v856;return FilteredSymbolScope}function v853(_super){function v852(){var v6630=this.valueMembers;return v6630.allMembers}function v851(container,ast,symbol,errorReporter,insertAsPublic,typespace,ambient){var table=null;ambient?typespace?(table=this.ambientEnclosedTypes,(table=null==table)?insertAsPublic=null:insertAsPublic?(insertAsPublic=this.ambientEnclosedTypes,insertAsPublic=insertAsPublic.publicMembers):(insertAsPublic=this.ambientEnclosedTypes,insertAsPublic=insertAsPublic.privateMembers)):
(table=this.ambientValueMembers,(table=null==table)?insertAsPublic=null:insertAsPublic?(insertAsPublic=this.ambientValueMembers,insertAsPublic=insertAsPublic.publicMembers):(insertAsPublic=this.ambientValueMembers,insertAsPublic=insertAsPublic.privateMembers)):typespace?(table=this.enclosedTypes,(table=null==table)?insertAsPublic=null:insertAsPublic?(insertAsPublic=this.enclosedTypes,insertAsPublic=insertAsPublic.publicMembers):(insertAsPublic=this.enclosedTypes,insertAsPublic=insertAsPublic.privateMembers)):
(table=this.valueMembers,(table=null==table)?insertAsPublic=null:insertAsPublic?(insertAsPublic=this.valueMembers,insertAsPublic=insertAsPublic.publicMembers):(insertAsPublic=this.valueMembers,insertAsPublic=insertAsPublic.privateMembers));if(table=insertAsPublic){if(insertAsPublic=symbol.name,insertAsPublic=JAMScript.call(table.add,table,[insertAsPublic,symbol]),insertAsPublic=!insertAsPublic)insertAsPublic=symbol.name,JAMScript.call(errorReporter.duplicateIdentifier,errorReporter,[ast,insertAsPublic])}else ast=
TypeScript.CompilerDiagnostics,JAMScript.call(ast.Alert,ast,["YYYYY"]);symbol.container=container}function v850(name,publicOnly,typespace){var sym=null,sym=this.valueMembers;(sym=null==sym)?sym=null:publicOnly?(sym=this.valueMembers,sym=sym.publicMembers):(sym=this.valueMembers,sym=sym.allMembers);var v6639;v6639=this.ambientValueMembers;(v6639=null==v6639)?v6639=null:publicOnly?(v6639=this.ambientValueMembers,v6639=v6639.publicMembers):(v6639=this.ambientValueMembers,v6639=v6639.allMembers);typespace&&
(typespace=this.enclosedTypes,(typespace=null==typespace)?typespace=null:publicOnly?(typespace=this.enclosedTypes,typespace=typespace.publicMembers):(typespace=this.enclosedTypes,typespace=typespace.allMembers),sym=typespace,typespace=this.ambientEnclosedTypes,(typespace=null==typespace)?publicOnly=null:publicOnly?(publicOnly=this.ambientEnclosedTypes,publicOnly=publicOnly.publicMembers):(publicOnly=this.ambientEnclosedTypes,publicOnly=publicOnly.allMembers),v6639=publicOnly);return sym&&(publicOnly=
sym=JAMScript.call(sym.lookup,sym,[name]),(publicOnly=null!=publicOnly)&&sym)||v6639&&(name=sym=JAMScript.call(v6639.lookup,v6639,[name]),(name=null!=name)&&sym)?sym:null}function v849(name,publicOnly,typespace){var sym=null,v6644;v6644=this.ambientValueMembers;(v6644=null==v6644)?v6644=null:publicOnly?(v6644=this.ambientValueMembers,v6644=v6644.publicMembers):(v6644=this.ambientValueMembers,v6644=v6644.allMembers);typespace&&(v6644=this.ambientEnclosedTypes,(v6644=null==v6644)?v6644=null:publicOnly?
(v6644=this.ambientEnclosedTypes,v6644=v6644.publicMembers):(v6644=this.ambientEnclosedTypes,v6644=v6644.allMembers));var v15229=v6644;v15229&&(v6644=sym=JAMScript.call(v6644.lookup,v6644,[name]),v15229=null!=v6644);return(v6644=v15229)?sym:(sym=this.parent)?(sym=this.parent,JAMScript.call(sym.findAmbient,sym,[name,publicOnly,typespace])):null}function v848(name,publicOnly,typespace){var sym=null,v6649;v6649=this.valueMembers;(v6649=null==v6649)?v6649=null:publicOnly?(v6649=this.valueMembers,v6649=
v6649.publicMembers):(v6649=this.valueMembers,v6649=v6649.allMembers);var v6650;v6650=this.ambientValueMembers;(v6650=null==v6650)?v6650=null:publicOnly?(v6650=this.ambientValueMembers,v6650=v6650.publicMembers):(v6650=this.ambientValueMembers,v6650=v6650.allMembers);typespace&&(v6649=this.enclosedTypes,(v6649=null==v6649)?v6649=null:publicOnly?(v6649=this.enclosedTypes,v6649=v6649.publicMembers):(v6649=this.enclosedTypes,v6649=v6649.allMembers),v6650=this.ambientEnclosedTypes,(v6650=null==v6650)?
v6650=null:publicOnly?(v6650=this.ambientEnclosedTypes,v6650=v6650.publicMembers):(v6650=this.ambientEnclosedTypes,v6650=v6650.allMembers));var v15238=v6650;v15238&&(v6650=sym=JAMScript.call(v6650.lookup,v6650,[name]),v15238=null!=v6650);if(v6650=v15238)return sym;if(v6650=v6649)v6649=sym=JAMScript.call(v6649.lookup,v6649,[name]),v6650=null!=v6649;return(v6649=v6650)?sym:(sym=this.parent)?(sym=this.parent,JAMScript.call(sym.find,sym,[name,publicOnly,typespace])):null}function v847(outfile){function v846(key,
s,context){key="  "+key;JAMScript.call(outfile.WriteLine,outfile,[key])}function v845(key,s,context){key="  "+key;JAMScript.call(outfile.WriteLine,outfile,[key])}function v844(key,s,context){key="  "+key;JAMScript.call(outfile.WriteLine,outfile,[key])}function v843(key,s,context){key="  "+key;JAMScript.call(outfile.WriteLine,outfile,[key])}var v15240=_super.prototype,v15240=v15240.print;JAMScript.call(v15240.call,v15240,[this,outfile]);if(v15240=this.ambientValueMembers)v15240=this.ambientValueMembers,
v15240=v15240.allMembers,JAMScript.call(v15240.map,v15240,[v843,null]);if(v15240=this.valueMembers)v15240=this.valueMembers,v15240=v15240.allMembers,JAMScript.call(v15240.map,v15240,[v844,null]);if(v15240=this.ambientEnclosedTypes)v15240=this.ambientEnclosedTypes,v15240=v15240.allMembers,JAMScript.call(v15240.map,v15240,[v845,null]);if(v15240=this.enclosedTypes)v15240=this.enclosedTypes,v15240=v15240.allMembers,JAMScript.call(v15240.map,v15240,[v846,null]);if(v15240=this.parent)v15240=this.parent,
JAMScript.call(v15240.print,v15240,[outfile])}function v842(filter,name,publicOnly,typespace){var sym=null,v6672;v6672=this.valueMembers;(v6672=null==v6672)?v6672=null:publicOnly?(v6672=this.valueMembers,v6672=v6672.publicMembers):(v6672=this.valueMembers,v6672=v6672.allMembers);sym=this.ambientValueMembers;(sym=null==sym)?sym=null:publicOnly?(sym=this.ambientValueMembers,sym=sym.publicMembers):(sym=this.ambientValueMembers,sym=sym.allMembers);typespace&&(v6672=this.enclosedTypes,(v6672=null==v6672)?
v6672=null:publicOnly?(v6672=this.enclosedTypes,v6672=v6672.publicMembers):(v6672=this.enclosedTypes,v6672=v6672.allMembers),sym=this.ambientEnclosedTypes,(sym=null==sym)?sym=null:publicOnly?(sym=this.ambientEnclosedTypes,sym=sym.publicMembers):(sym=this.ambientEnclosedTypes,sym=sym.allMembers));if(sym){var v15253=sym=JAMScript.call(sym.lookup,sym,[name]);if(v15253=null!=v15253)if(v15253=JAMScript.call(filter.update,filter,[sym]))return sym}if(v6672&&(v6672=sym=JAMScript.call(v6672.lookup,v6672,[name]),
v6672=null!=v6672)&&(v6672=JAMScript.call(filter.update,filter,[sym])))return sym;if(v6672=this.parent)if(v6672=this.parent,sym=JAMScript.call(v6672.search,v6672,[filter,name,publicOnly,typespace]))if(name=JAMScript.call(filter.update,filter,[sym]))return sym;return filter.result}function v841(members){var result=[],v6684=this.ambientValueMembers;v6684&&(v6684=this.ambientValueMembers,v6684=v6684.allMembers,v6684=JAMScript.call(v6684.getAllKeys,v6684,[]),result=result.concat(v6684));if(v6684=this.valueMembers)v6684=
this.valueMembers,v6684=v6684.allMembers,v6684=JAMScript.call(v6684.getAllKeys,v6684,[]),result=result.concat(v6684);if(v6684=!members)v6684=this.parent;v6684&&(v6684=this.parent,(members=JAMScript.call(v6684.getAllValueSymbolNames,v6684,[members]))&&(result=result.concat(members)));return result}function v840(members){var result=[],v6690=this.ambientEnclosedTypes;v6690&&(v6690=this.ambientEnclosedTypes,v6690=v6690.allMembers,v6690=JAMScript.call(v6690.getAllKeys,v6690,[]),result=result.concat(v6690));
if(v6690=this.enclosedTypes)v6690=this.enclosedTypes,v6690=v6690.allMembers,v6690=JAMScript.call(v6690.getAllKeys,v6690,[]),result=result.concat(v6690);if(v6690=!members)v6690=this.parent;v6690&&(v6690=this.parent,(members=JAMScript.call(v6690.getAllTypeSymbolNames,v6690,[members]))&&(result=result.concat(members)));return result}function v839(members){var result=JAMScript.call(this.getAllTypeSymbolNames,this,[members]);members=JAMScript.call(this.getAllValueSymbolNames,this,[members]);return result.concat(members)}
function v838(){return"builder"}function SymbolScopeBuilder(valueMembers,ambientValueMembers,enclosedTypes,ambientEnclosedTypes,parent,container){JAMScript.call(_super.call,_super,[this,container]);this.valueMembers=valueMembers;this.ambientValueMembers=ambientValueMembers;this.enclosedTypes=enclosedTypes;this.ambientEnclosedTypes=ambientEnclosedTypes;this.parent=parent;this.container=container}JAMScript.call(__extends,null,[SymbolScopeBuilder,_super]);var v6696=SymbolScopeBuilder.prototype;v6696.printLabel=
v838;v6696=SymbolScopeBuilder.prototype;v6696.getAllSymbolNames=v839;v6696=SymbolScopeBuilder.prototype;v6696.getAllTypeSymbolNames=v840;v6696=SymbolScopeBuilder.prototype;v6696.getAllValueSymbolNames=v841;v6696=SymbolScopeBuilder.prototype;v6696.search=v842;v6696=SymbolScopeBuilder.prototype;v6696.print=v847;v6696=SymbolScopeBuilder.prototype;v6696.find=v848;v6696=SymbolScopeBuilder.prototype;v6696.findAmbient=v849;v6696=SymbolScopeBuilder.prototype;v6696.findLocal=v850;v6696=SymbolScopeBuilder.prototype;
v6696.enter=v851;v6696=SymbolScopeBuilder.prototype;v6696.getTable=v852;return SymbolScopeBuilder}function v837(_super){function v836(){var v6707=this.valueMembers;return v6707.publicMembers}function v835(name,publicOnly,typespace){if(name=JAMScript.call(this.find,this,[name,publicOnly,typespace]))if(publicOnly=JAMScript.call(name.kind,name,[]),typespace=SymbolKind.Type,publicOnly=publicOnly==typespace)publicOnly=name,publicOnly=publicOnly.type,publicOnly=JAMScript.call(publicOnly.hasImplementation,
publicOnly,[]),(publicOnly=!publicOnly)&&(name=null);else if(publicOnly=name.container)if(publicOnly=name.container,publicOnly=JAMScript.call(publicOnly.kind,publicOnly,[]),typespace=SymbolKind.Type,publicOnly=publicOnly==typespace)publicOnly=name.container,publicOnly=publicOnly.type,publicOnly=JAMScript.call(publicOnly.hasImplementation,publicOnly,[]),(publicOnly=!publicOnly)&&(name=null);return name}function v834(outfile){function v833(key,sym,context){key="  "+key;JAMScript.call(outfile.WriteLine,
outfile,[key])}function v832(key,sym,context){key="  "+key;JAMScript.call(outfile.WriteLine,outfile,[key])}function v831(key,sym,context){key="  "+key;JAMScript.call(outfile.WriteLine,outfile,[key])}function v830(key,sym,context){key="  "+key;JAMScript.call(outfile.WriteLine,outfile,[key])}var v15267=_super.prototype,v15267=v15267.print;JAMScript.call(v15267.call,v15267,[this,outfile]);if(v15267=this.ambientValueMembers)v15267=this.ambientValueMembers,v15267=v15267.allMembers,JAMScript.call(v15267.map,
v15267,[v830,null]);if(v15267=this.valueMembers)v15267=this.valueMembers,v15267=v15267.allMembers,JAMScript.call(v15267.map,v15267,[v831,null]);if(v15267=this.ambientEnclosedTypes)v15267=this.ambientEnclosedTypes,v15267=v15267.allMembers,JAMScript.call(v15267.map,v15267,[v832,null]);if(v15267=this.enclosedTypes)v15267=this.enclosedTypes,v15267=v15267.allMembers,JAMScript.call(v15267.map,v15267,[v833,null])}function v829(name,publicOnly,typespace){var v6726;v6726=this.ambientValueMembers;(v6726=null==
v6726)?v6726=null:publicOnly?(v6726=this.ambientValueMembers,v6726=v6726.publicMembers):(v6726=this.ambientValueMembers,v6726=v6726.allMembers);typespace&&(typespace=this.ambientEnclosedTypes,(typespace=null==typespace)?publicOnly=null:publicOnly?(publicOnly=this.ambientEnclosedTypes,publicOnly=publicOnly.publicMembers):(publicOnly=this.ambientEnclosedTypes,publicOnly=publicOnly.allMembers),v6726=publicOnly);return v6726&&(name=JAMScript.call(v6726.lookup,v6726,[name]))?name:null}function v828(name,
publicOnly,typespace){var table=null,ambientTable=null;typespace?(table=this.enclosedTypes,(table=null==table)?table=null:publicOnly?(table=this.enclosedTypes,table=table.publicMembers):(table=this.enclosedTypes,table=table.allMembers),typespace=this.ambientEnclosedTypes,(typespace=null==typespace)?publicOnly=null:publicOnly?(publicOnly=this.ambientEnclosedTypes,publicOnly=publicOnly.publicMembers):(publicOnly=this.ambientEnclosedTypes,publicOnly=publicOnly.allMembers)):(table=this.valueMembers,(table=
null==table)?table=null:publicOnly?(table=this.valueMembers,table=table.publicMembers):(table=this.valueMembers,table=table.allMembers),typespace=this.ambientValueMembers,(typespace=null==typespace)?publicOnly=null:publicOnly?(publicOnly=this.ambientValueMembers,publicOnly=publicOnly.publicMembers):(publicOnly=this.ambientValueMembers,publicOnly=publicOnly.allMembers));if(ambientTable=publicOnly)if(publicOnly=JAMScript.call(ambientTable.lookup,ambientTable,[name]))return publicOnly;return table&&
(publicOnly=JAMScript.call(table.lookup,table,[name]))?publicOnly:null}function v827(filter,name,publicOnly,typespace){name=JAMScript.call(this.find,this,[name,publicOnly,typespace]);JAMScript.call(filter.update,filter,[name]);return filter.result}function v826(members){members=[];var v6733=this.ambientValueMembers;v6733&&(v6733=this.ambientValueMembers,v6733=v6733.allMembers,v6733=JAMScript.call(v6733.getAllKeys,v6733,[]),members=members.concat(v6733));if(v6733=this.valueMembers)v6733=this.valueMembers,
v6733=v6733.allMembers,v6733=JAMScript.call(v6733.getAllKeys,v6733,[]),members=members.concat(v6733);return members}function v825(members){members=[];var v6737=this.ambientEnclosedTypes;v6737&&(v6737=this.ambientEnclosedTypes,v6737=v6737.allMembers,v6737=JAMScript.call(v6737.getAllKeys,v6737,[]),members=members.concat(v6737));if(v6737=this.enclosedTypes)v6737=this.enclosedTypes,v6737=v6737.allMembers,v6737=JAMScript.call(v6737.getAllKeys,v6737,[]),members=members.concat(v6737);return members}function v824(members){var result=
JAMScript.call(this.getAllTypeSymbolNames,this,[members]);members=JAMScript.call(this.getAllValueSymbolNames,this,[members]);return result.concat(members)}function v823(){return"table"}function SymbolTableScope(valueMembers,ambientValueMembers,enclosedTypes,ambientEnclosedTypes,container){JAMScript.call(_super.call,_super,[this,container]);this.valueMembers=valueMembers;this.ambientValueMembers=ambientValueMembers;this.enclosedTypes=enclosedTypes;this.ambientEnclosedTypes=ambientEnclosedTypes;this.container=
container}JAMScript.call(__extends,null,[SymbolTableScope,_super]);var v6741=SymbolTableScope.prototype;v6741.printLabel=v823;v6741=SymbolTableScope.prototype;v6741.getAllSymbolNames=v824;v6741=SymbolTableScope.prototype;v6741.getAllTypeSymbolNames=v825;v6741=SymbolTableScope.prototype;v6741.getAllValueSymbolNames=v826;v6741=SymbolTableScope.prototype;v6741.search=v827;v6741=SymbolTableScope.prototype;v6741.find=v828;v6741=SymbolTableScope.prototype;v6741.findAmbient=v829;v6741=SymbolTableScope.prototype;
v6741.print=v834;v6741=SymbolTableScope.prototype;v6741.findImplementation=v835;v6741=SymbolTableScope.prototype;v6741.getTable=v836;return SymbolTableScope}function v822(_super){function v821(parent){var v15288=this.parents;if(v15288=null==v15288)this.parents=v15288=[];var v15289=v15288=this.parents,v15289=v15289.length;JAMScript.set(v15288,v15289,parent)}function v820(name,publicOnly,typespace){var sym=null,i=0,cache=this.valueAmbientCache;typespace&&(cache=this.typeAmbientCache);if(i=cache)i=sym=
JAMScript.call(cache.lookup,cache,[name]),i=null!=i;if(i)return sym;if(i=this.parents)for(var i=0,v20408=this.parents,v20408=v20408.length,v20408=i<v20408;v20408;){sym=this.parents;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)sym=sym[i];if(sym=JAMScript.call(sym.findAmbient,sym,[name,publicOnly,typespace]))break;i+=1;v20408=this.parents;v20408=v20408.length;v20408=i<v20408}if(publicOnly=null==cache)typespace?(typespace=TypeScript.StringHashTable,cache=this.typeAmbientCache=
typespace=JAMScript.new(typespace,[])):(typespace=TypeScript.StringHashTable,cache=this.valueAmbientCache=typespace=JAMScript.new(typespace,[]));JAMScript.call(cache.add,cache,[name,sym]);return sym}function v819(name,publicOnly,typespace){var sym=null,i=0,cache=this.valueCache;typespace&&(cache=this.typeCache);if(i=cache)if(i=sym=JAMScript.call(cache.lookup,cache,[name]),i=null!=i)if(publicOnly){var i=sym.flags,v26536=TypeScript.SymbolFlags,v26536=v26536.Private,i=JAMScript.call(TypeScript.hasFlag,
TypeScript,[i,v26536]);if(v26536=!i)if(i=sym.declAST)if(i=sym.declAST,i=i.nodeType,v26536=TypeScript.NodeType,v26536=v26536.FuncDecl,i=i==v26536)i=sym.declAST,i=i.fncFlags,v26536=TypeScript.FncFlags,v26536=v26536.Private,i=JAMScript.call(TypeScript.hasFlag,TypeScript,[i,v26536]);i=!i}else i=!0;if(i)return sym;if(i=this.parents)for(i=0,v26536=this.parents,v26536=v26536.length,v26536=i<v26536;v26536;){sym=this.parents;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)sym=
sym[i];if(sym=JAMScript.call(sym.find,sym,[name,publicOnly,typespace]))break;i+=1;v26536=this.parents;v26536=v26536.length;v26536=i<v26536}if(publicOnly=null==cache)typespace?(typespace=TypeScript.StringHashTable,cache=this.typeCache=typespace=JAMScript.new(typespace,[])):(typespace=TypeScript.StringHashTable,cache=this.valueCache=typespace=JAMScript.new(typespace,[]));JAMScript.call(cache.add,cache,[name,sym]);return sym}function v818(name,publicOnly,typespace){var sym=null,i=0,implCache=this.valueImplCache;
typespace&&(implCache=this.typeImplCache);if(i=implCache)if(i=sym=JAMScript.call(implCache.lookup,implCache,[name]),i=null!=i)if(publicOnly){var i=sym.flags,v26538=TypeScript.SymbolFlags,v26538=v26538.Private,i=JAMScript.call(TypeScript.hasFlag,TypeScript,[i,v26538]);if(v26538=!i)if(i=sym.declAST)if(i=sym.declAST,i=i.nodeType,v26538=TypeScript.NodeType,v26538=v26538.FuncDecl,i=i==v26538)i=sym.declAST,i=i.fncFlags,v26538=TypeScript.FncFlags,v26538=v26538.Private,i=JAMScript.call(TypeScript.hasFlag,
TypeScript,[i,v26538]);i=!i}else i=!0;if(i)return sym;if(i=this.parents)for(i=0,v26538=this.parents,v26538=v26538.length,v26538=i<v26538;v26538;){sym=this.parents;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)sym=sym[i];if(sym=JAMScript.call(sym.findImplementation,sym,[name,publicOnly,typespace]))break;i+=1;v26538=this.parents;v26538=v26538.length;v26538=i<v26538}implCache&&(typespace?(publicOnly=TypeScript.StringHashTable,implCache=this.typeImplCache=publicOnly=
JAMScript.new(publicOnly,[])):(publicOnly=TypeScript.StringHashTable,implCache=this.valueImplCache=publicOnly=JAMScript.new(publicOnly,[])));JAMScript.call(implCache.add,implCache,[name,sym]);return sym}function v817(outfile){var v15302=_super.prototype,v15302=v15302.print;JAMScript.call(v15302.call,v15302,[this,outfile]);if(v15302=this.parents)for(var v15302=0,v20416=this.parents,v20416=v20416.length,v20416=v15302<v20416;v20416;){v20416=this.parents;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v20416=
v20416[v15302];JAMScript.call(v20416.print,v20416,[outfile]);v15302+=1;v20416=this.parents;v20416=v20416.length;v20416=v15302<v20416}}function v816(members){var result=[],v6780=this.parents;if(v6780)for(var v6780=0,v20418=this.parents,v20418=v20418.length,v20418=v6780<v20418;v20418;){v20418=this.parents;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v20418=v20418[v6780];(v20418=JAMScript.call(v20418.getAllValueSymbolNames,v20418,[members]))&&(result=result.concat(v20418));
v6780+=1;v20418=this.parents;v20418=v20418.length;v20418=v6780<v20418}return result}function v815(members){var result=[],v6783=this.parents;if(v6783)for(var v6783=0,v20420=this.parents,v20420=v20420.length,v20420=v6783<v20420;v20420;){v20420=this.parents;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v20420=v20420[v6783];(v20420=JAMScript.call(v20420.getAllTypeSymbolNames,v20420,[members]))&&(result=result.concat(v20420));v6783+=1;v20420=this.parents;v20420=v20420.length;
v20420=v6783<v20420}return result}function v814(members){var result=[],v6786=this.parents;if(v6786)for(var v6786=0,v20422=this.parents,v20422=v20422.length,v20422=v6786<v20422;v20422;){v20422=this.parents;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v20422=v20422[v6786];(v20422=JAMScript.call(v20422.getAllSymbolNames,v20422,[members]))&&(result=result.concat(v20422));v6786+=1;v20422=this.parents;v20422=v20422.length;v20422=v6786<v20422}return result}function v813(filter,
name,publicOnly,typespace){var v6790=this.parents;if(v6790)for(var v6790=0,v20424=this.parents,v20424=v20424.length,v20424=v6790<v20424;v20424;){v20424=this.parents;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v20424=v20424[v6790];if(v20424=JAMScript.call(v20424.search,v20424,[filter,name,publicOnly,typespace])){var v6788=JAMScript.call(filter.update,filter,[v20424]);if(v6788)return v20424}v6790+=1;v20424=this.parents;v20424=v20424.length;v20424=v6790<v20424}return filter.result}
function v812(){return"agg"}function SymbolAggregateScope(container){JAMScript.call(_super.call,_super,[this,container]);this.parents=this.typeAmbientCache=this.typeImplCache=this.typeCache=this.valueAmbientCache=this.valueImplCache=this.valueCache=null;this.container=container}JAMScript.call(__extends,null,[SymbolAggregateScope,_super]);var v6791=SymbolAggregateScope.prototype;v6791.printLabel=v812;v6791=SymbolAggregateScope.prototype;v6791.search=v813;v6791=SymbolAggregateScope.prototype;v6791.getAllSymbolNames=
v814;v6791=SymbolAggregateScope.prototype;v6791.getAllTypeSymbolNames=v815;v6791=SymbolAggregateScope.prototype;v6791.getAllValueSymbolNames=v816;v6791=SymbolAggregateScope.prototype;v6791.print=v817;v6791=SymbolAggregateScope.prototype;v6791.findImplementation=v818;v6791=SymbolAggregateScope.prototype;v6791.find=v819;v6791=SymbolAggregateScope.prototype;v6791.findAmbient=v820;v6791=SymbolAggregateScope.prototype;v6791.addParentScope=v821;return SymbolAggregateScope}function v811(){function v810(){throw Error("please implement in derived class");
}function v809(container,ast,symbol,errorReporter,publicOnly,typespace,ambient){throw Error("please implement in derived class");}function v808(outfile){var v6803=this.container;if(v6803)var v6803=JAMScript.call(this.printLabel,this,[]),v6803=v6803+" scope with container: ",v23580=this.container,v23580=v23580.name,v6803=v6803+v23580,v6803=v6803+"...";else v6803=JAMScript.call(this.printLabel,this,[]),v6803+=" scope...";JAMScript.call(outfile.WriteLine,outfile,[v6803])}function v807(name,publicOnly,
typespace){return null}function v806(name,publicOnly,typespace){return null}function v805(name,publicOnly,typespace){return null}function v804(name,publicOnly,typespace){return null}function v803(filter,name,publicOnly,typespace){return null}function v802(members){return["please","implement","in","derived","classes"]}function v801(members){return["please","implement","in","derived","classes"]}function v800(members){return["please","implement","in","derived","classes"]}function v799(){return"base"}
function SymbolScope(container){this.container=container}var v6804=SymbolScope.prototype;v6804.printLabel=v799;v6804=SymbolScope.prototype;v6804.getAllSymbolNames=v800;v6804=SymbolScope.prototype;v6804.getAllTypeSymbolNames=v801;v6804=SymbolScope.prototype;v6804.getAllValueSymbolNames=v802;v6804=SymbolScope.prototype;v6804.search=v803;v6804=SymbolScope.prototype;v6804.findLocal=v804;v6804=SymbolScope.prototype;v6804.find=v805;v6804=SymbolScope.prototype;v6804.findImplementation=v806;v6804=SymbolScope.prototype;
v6804.findAmbient=v807;v6804=SymbolScope.prototype;v6804.print=v808;v6804=SymbolScope.prototype;v6804.enter=v809;v6804=SymbolScope.prototype;v6804.getTable=v810;return SymbolScope}function v798(SymbolKind){SymbolKind._map=[];var v6816=SymbolKind._map;v6816[0]="None";SymbolKind.None=0;v6816=SymbolKind._map;v6816[1]="Type";SymbolKind.Type=1;v6816=SymbolKind._map;v6816[2]="Field";SymbolKind.Field=2;v6816=SymbolKind._map;v6816[3]="Parameter";SymbolKind.Parameter=3;v6816=SymbolKind._map;v6816[4]="Variable";
SymbolKind.Variable=4}function v797(){function v796(key,data){var v15320=this.dualMembers,v15320=v15320.secondaryTable;return JAMScript.call(v15320.add,v15320,[key,data])}function v795(key,data){var v15321=this.dualMembers,v15321=v15321.primaryTable;return JAMScript.call(v15321.add,v15321,[key,data])}function ScopedMembers(dualMembers){dualMembers=this.allMembers=this.dualMembers=dualMembers;this.publicMembers=dualMembers.primaryTable;dualMembers=this.dualMembers;this.privateMembers=dualMembers.secondaryTable}
var v6825=ScopedMembers.prototype;v6825.addPublicMember=v795;v6825=ScopedMembers.prototype;v6825.addPrivateMember=v796;return ScopedMembers}var ScopedMembers=v797();TypeScript.ScopedMembers=ScopedMembers;var ScopedMembers=TypeScript.SymbolKind,v20428=!ScopedMembers;v20428&&(ScopedMembers=TypeScript.SymbolKind={});v798(ScopedMembers);var SymbolKind=TypeScript.SymbolKind,ScopedMembers=v811();TypeScript.SymbolScope=ScopedMembers;v20428=v822(ScopedMembers);TypeScript.SymbolAggregateScope=v20428;v20428=
v837(ScopedMembers);TypeScript.SymbolTableScope=v20428;v20428=v853(ScopedMembers);TypeScript.SymbolScopeBuilder=v20428;ScopedMembers=v857(ScopedMembers);TypeScript.FilteredSymbolScope=ScopedMembers;ScopedMembers=v861(v20428);TypeScript.FilteredSymbolScopeBuilder=ScopedMembers}
function v794(){var TypeScript=v12360;function v793(_super){function v792(){return!0}function v791(type){var v15323=this.variable,v15323=v15323.typeLink;v15323.type=type}function v790(scope){var v6829=TypeScript.MemberName,v15324=JAMScript.call(this.getType,this,[]);scope=JAMScript.call(v15324.getScopedTypeNameEx,v15324,[scope]);v15324=this.name;v15324+=": ";return JAMScript.call(v6829.create,v6829,[scope,v15324,""])}function v789(){var v15326=this.variable,v15326=v15326.typeLink;return v15326.type}
function v788(){return!0}function v787(){var v6833=TypeScript.SymbolKind;return v6833.Variable}function VariableSymbol(name,location,unitIndex,variable){var v6834=name.length;JAMScript.call(_super.call,_super,[this,name,location,v6834,unitIndex]);this.variable=variable}JAMScript.call(__extends,null,[VariableSymbol,_super]);var v6835=VariableSymbol.prototype;v6835.kind=v787;v6835=VariableSymbol.prototype;v6835.writeable=v788;v6835=VariableSymbol.prototype;v6835.getType=v789;v6835=VariableSymbol.prototype;
v6835.getTypeNameEx=v790;v6835=VariableSymbol.prototype;v6835.setType=v791;v6835=VariableSymbol.prototype;v6835.isVariable=v792;return VariableSymbol}function v786(_super){function v785(){var v15327=this.paramDocComment;if(v15327=!v15327){var v15327=[],v6845=this.funcDecl;if(v6845){var v6845=this.funcDecl,v6845=JAMScript.call(v6845.getDocComments,v6845,[]),v6842=TypeScript.Comment,v6843=this.name,v6845=JAMScript.call(v6842.getParameterDocCommentText,v6842,[v6843,v6845]);(v6842=""!=v6845)&&JAMScript.call(v15327.push,
v15327,[v6845])}v6845=TypeScript.Comment;v6842=JAMScript.call(this.getDocComments,this,[]);v6845=JAMScript.call(v6845.getDocCommentText,v6845,[v6842]);(v6842=""!=v6845)&&JAMScript.call(v15327.push,v15327,[v6845]);this.paramDocComment=v15327=v15327.join("\n")}return this.paramDocComment}function v784(pattern,replacement,checker){var v20429=this.parameter,v20429=v20429.typeLink,v20429=v20429.type;pattern=JAMScript.call(v20429.specializeType,v20429,[pattern,replacement,checker,!1]);replacement=this.parameter;
replacement=replacement.typeLink;replacement=replacement.type;return(replacement=replacement!=pattern)?(replacement=JAMScript.new(ValueLocation,[]),v20429=this.name,checker=checker.locationInfo,checker=checker.unitIndex,checker=new ParameterSymbol(v20429,0,checker,replacement),replacement.symbol=checker,JAMScript.call(checker.setType,checker,[pattern]),checker):this}function v783(){var v6854=JAMScript.call(this.getTypeNameEx,this,[null]);return JAMScript.call(v6854.toString,v6854,[])}function v782(scope){var v6855=
TypeScript.MemberName,v15331=JAMScript.call(this.getType,this,[]);scope=JAMScript.call(v15331.getScopedTypeNameEx,v15331,[scope]);var v15331=this.name,v23582;v23582=(v23582=JAMScript.call(this.isOptional,this,[]))?"?":"";v15331+=v23582;v15331+=": ";return JAMScript.call(v6855.create,v6855,[scope,v15331,""])}function v781(){var v15333=this.parameter;v15333&&(v15333=this.parameter,v15333=v15333.symbol)&&(v15333=this.parameter,v15333=v15333.symbol,v15333=v15333.declAST);return v15333?(v15333=this.parameter,
v15333=v15333.symbol,v15333=v15333.declAST,v15333.isOptional):!1}function v780(){return!0}function v779(type){var v15335=this.parameter,v15335=v15335.typeLink;v15335.type=type}function v778(){var v15336=this.parameter,v15336=v15336.typeLink;return v15336.type}function v777(){return!0}function v776(){var v6862=TypeScript.SymbolKind;return v6862.Parameter}function ParameterSymbol(name,location,unitIndex,parameter){var v6863=name.length;JAMScript.call(_super.call,_super,[this,name,location,v6863,unitIndex]);
this.parameter=parameter;this.funcDecl=this.paramDocComment=null;this.argsOffset=-1;this.name=name;this.location=location}JAMScript.call(__extends,null,[ParameterSymbol,_super]);var v6864=ParameterSymbol.prototype;v6864.kind=v776;v6864=ParameterSymbol.prototype;v6864.writeable=v777;v6864=ParameterSymbol.prototype;v6864.getType=v778;v6864=ParameterSymbol.prototype;v6864.setType=v779;v6864=ParameterSymbol.prototype;v6864.isVariable=v780;v6864=ParameterSymbol.prototype;v6864.isOptional=v781;v6864=ParameterSymbol.prototype;
v6864.getTypeNameEx=v782;v6864=ParameterSymbol.prototype;v6864.toString=v783;v6864=ParameterSymbol.prototype;v6864.specializeType=v784;v6864=ParameterSymbol.prototype;v6864.getParameterDocComments=v785;return ParameterSymbol}function v775(_super){function v774(){var v20435=this.getter,v20435=null!=v20435,v20437=!v20435;v20437&&(v20435=this.setter,v20435=null!=v20435);if(v20435){v20435=[];v20437=this.getter;if(v20437=null!=v20437)v20437=this.getter,v20437=JAMScript.call(v20437.getDocComments,v20437,
[]),v20435=v20435.concat(v20437);v20437=this.setter;if(v20437=null!=v20437)v20437=this.setter,v20437=JAMScript.call(v20437.getDocComments,v20437,[]),v20435=v20435.concat(v20437);return v20435}v20435=this.declAST;return(v20435=null!=v20435)?(v20435=this.declAST,JAMScript.call(v20435.getDocComments,v20435,[])):[]}function v773(pattern,replacement,checker){var v20438=this.field,v20438=v20438.typeLink,v20438=v20438.type;pattern=JAMScript.call(v20438.specializeType,v20438,[pattern,replacement,checker,
!1]);replacement=this.field;replacement=replacement.typeLink;replacement=replacement.type;if(replacement=pattern!=replacement){replacement=JAMScript.new(ValueLocation,[]);v20438=this.name;checker=checker.locationInfo;checker=checker.unitIndex;var v6884=this.canWrite;checker=new FieldSymbol(v20438,0,checker,v6884,replacement);checker.flags=this.flags;replacement.symbol=checker;v20438=TypeScript.TypeLink;v20438=JAMScript.new(v20438,[]);replacement.typeLink=v20438;JAMScript.call(checker.setType,checker,
[pattern]);checker.typeCheckStatus=TypeCheckStatus.Finished;return checker}return this}function v772(){var v6887=JAMScript.call(this.getTypeNameEx,this,[null]);return JAMScript.call(v6887.toString,v6887,[])}function v771(){return!0}function v770(){var v15347=this.getter,v15347=null!=v15347,v15349=!v15347;v15349&&(v15347=this.setter,v15347=null!=v15347);return v15347}function v769(type){var v15350=this.field,v15350=v15350.typeLink;v15350.type=type}function v768(){return!0}function v767(scope){var v6890=
TypeScript.MemberName,v23586=this.field,v23586=v23586.typeLink,v23586=v23586.type;scope=JAMScript.call(v23586.getScopedTypeNameEx,v23586,[scope]);var v23586=this.name,v20442=JAMScript.call(this.getOptionalNameString,this,[]),v23586=v23586+v20442,v23586=v23586+": ";return JAMScript.call(v6890.create,v6890,[scope,v23586,""])}function v766(){var v15353=this.field,v15353=v15353.typeLink;return v15353.type}function v765(){var v6894;(v6894=JAMScript.call(this.isAccessor,this,[]))?(v6894=this.setter,v6894=
null!=v6894):v6894=this.canWrite;return v6894}function v764(){var v6895=TypeScript.SymbolKind;return v6895.Field}function FieldSymbol(name,location,unitIndex,canWrite,field){var v6896=name.length;JAMScript.call(_super.call,_super,[this,name,location,v6896,unitIndex]);this.canWrite=canWrite;this.field=field;this.setter=this.getter=null;this.hasBeenEmitted=!1;this.name=name;this.location=location}JAMScript.call(__extends,null,[FieldSymbol,_super]);var v6897=FieldSymbol.prototype;v6897.kind=v764;v6897=
FieldSymbol.prototype;v6897.writeable=v765;v6897=FieldSymbol.prototype;v6897.getType=v766;v6897=FieldSymbol.prototype;v6897.getTypeNameEx=v767;v6897=FieldSymbol.prototype;v6897.isMember=v768;v6897=FieldSymbol.prototype;v6897.setType=v769;v6897=FieldSymbol.prototype;v6897.isAccessor=v770;v6897=FieldSymbol.prototype;v6897.isVariable=v771;v6897=FieldSymbol.prototype;v6897.toString=v772;v6897=FieldSymbol.prototype;v6897.specializeType=v773;v6897=FieldSymbol.prototype;v6897.getDocComments=v774;return FieldSymbol}
function v763(_super){function v762(){return!0}function WithSymbol(location,unitIndex,withType){JAMScript.call(_super.call,_super,[this,"with",location,4,unitIndex,withType])}JAMScript.call(__extends,null,[WithSymbol,_super]);var v6908=WithSymbol.prototype;v6908.isWith=v762;return WithSymbol}function v761(_super){function v760(){var comments=[],v15356=this.declAST;if(v15356=null!=v15356)v15356=this.declAST,v15356=JAMScript.call(v15356.getDocComments,v15356,[]),comments=comments.concat(v15356);for(var v15356=
0,v20443=this.expansionsDeclAST,v20443=v20443.length,v20443=v15356<v20443;v20443;){v20443=this.expansionsDeclAST;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v20443=v20443[v15356];v20443=JAMScript.call(v20443.getDocComments,v20443,[]);comments=comments.concat(v20443);v15356+=1;v20443=this.expansionsDeclAST;v20443=v20443.length;v20443=v15356<v20443}return comments}function v759(scopeSymbolPath){var scopeSymbolPathLength=scopeSymbolPath.length,externalSymbol=null,
v20446=scopeSymbolPath.length;if(v20446=0<v20446){v20446=scopeSymbolPathLength-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v20446=scopeSymbolPath[v20446];v20446=JAMScript.call(v20446.getType,v20446,[]);if(v20446=JAMScript.call(v20446.isModuleType,v20446,[])){v20446=scopeSymbolPathLength-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v20446=scopeSymbolPath[v20446];v20446=v20446.isDynamic}}if(v20446){if(v20446=1<scopeSymbolPathLength){v20446=
scopeSymbolPathLength-2;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v20446=scopeSymbolPath[v20446];v20446=JAMScript.call(v20446.getType,v20446,[]);if(v20446=JAMScript.call(v20446.isModuleType,v20446,[])){v20446=scopeSymbolPathLength-2;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v20446=scopeSymbolPath[v20446];v20446=v20446.isDynamic}}if(v20446){externalSymbol=scopeSymbolPathLength-2;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)externalSymbol=
scopeSymbolPath[externalSymbol];externalSymbol=JAMScript.call(externalSymbol.getType,externalSymbol,[]);v20446=this.type;externalSymbol=JAMScript.call(externalSymbol.findDynamicModuleName,externalSymbol,[v20446])}if(v20446=null==externalSymbol){scopeSymbolPathLength-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)scopeSymbolPath=scopeSymbolPath[scopeSymbolPathLength];externalSymbol=JAMScript.call(scopeSymbolPath.getType,scopeSymbolPath,[]);scopeSymbolPath=this.type;
externalSymbol=JAMScript.call(externalSymbol.findDynamicModuleName,externalSymbol,[scopeSymbolPath])}}return externalSymbol}function v758(scopeSymbol){var v20449=!scopeSymbol;if(v20449=!v20449)if(v20449=this.prettyName,v20449=JAMScript.call(TypeScript.isQuoted,TypeScript,[v20449]))v20449=this.type,v20449=JAMScript.call(v20449.isModuleType,v20449,[]);return v20449&&(scopeSymbol=JAMScript.call(scopeSymbol.pathToRoot,scopeSymbol,[]),scopeSymbol=JAMScript.call(this.getPrettyNameOfDynamicModule,this,[scopeSymbol]),
v20449=null!=scopeSymbol)?scopeSymbol.name:this.prettyName}function v757(pattern,replacement,checker){var v15366=this.type;if(v15366=v15366==pattern)return replacement.symbol;v15366=this.type;pattern=JAMScript.call(v15366.specializeType,v15366,[pattern,replacement,checker,!1]);replacement=this.type;return(replacement=pattern!=replacement)?(replacement=this.name,pattern=new TypeSymbol(replacement,-1,0,-1,pattern)):this}function v756(){var v15368=this.declAST;if(v15368=null!=v15368)var v15368=this.declAST,
v15368=v15368.nodeType,v20452=TypeScript.NodeType,v20452=v20452.FuncDecl,v15368=v15368==v20452;return v15368}function v755(){var v6927=this.instanceType;return null!=v6927}function v754(){var v6928=this.type,v6928=JAMScript.call(v6928.getTypeName,v6928,[]),v6930=this.name;v6930&&(v6930=this.name,v6930+=":",v6928=v6930+v6928);return v6928}function v753(){var v25133=this.type,v25133=v25133.typeFlags,v25134=TypeScript.TypeFlags,v25134=v25134.IsClass,v25133=v25133&v25134;if(v25133=!v25133)v25133=this.type,
v25133=JAMScript.call(v25133.isClass,v25133,[]);if(v25133)return v25133=this.type,v25133=v25133.instanceType,v25133.constructorScope;v25133=this.type;return v25133.containedScope}function v752(scope){var v6934=this.type,v15374;if(v15374=this.name){v15374=this.name;var v20456=JAMScript.call(this.getOptionalNameString,this,[]);v15374+=v20456}else v15374="";return JAMScript.call(v6934.getMemberTypeNameEx,v6934,[v15374,!1,!1,scope])}function v751(){return this.type}function v750(){return!0}function v749(){var v6936=
TypeScript.SymbolKind;return v6936.Type}function v748(loc){var v15375=this.additionalLocations;if(v15375=null==v15375)this.additionalLocations=[];var v15376=v15375=this.additionalLocations,v15376=v15376.length;JAMScript.set(v15375,v15376,loc)}function TypeSymbol(locName,location,length,unitIndex,type){JAMScript.call(_super.call,_super,[this,locName,location,length,unitIndex]);this.type=type;this.expansions=[];this.expansionsDeclAST=[];this.isMethod=this.isDynamic=!1;this.aliasLink=null;this.onlyReferencedAsTypeRef=
TypeScript.optimizeModuleCodeGen;this.prettyName=this.name}JAMScript.call(__extends,null,[TypeSymbol,_super]);var v6940=TypeSymbol.prototype;v6940.addLocation=v748;v6940=TypeSymbol.prototype;v6940.kind=v749;v6940=TypeSymbol.prototype;v6940.isType=v750;v6940=TypeSymbol.prototype;v6940.getType=v751;v6940=TypeSymbol.prototype;v6940.getTypeNameEx=v752;v6940=TypeSymbol.prototype;v6940.instanceScope=v753;v6940=TypeSymbol.prototype;v6940.toString=v754;v6940=TypeSymbol.prototype;v6940.isClass=v755;v6940=
TypeSymbol.prototype;v6940.isFunction=v756;v6940=TypeSymbol.prototype;v6940.specializeType=v757;v6940=TypeSymbol.prototype;v6940.getPrettyName=v758;v6940=TypeSymbol.prototype;v6940.getPrettyNameOfDynamicModule=v759;v6940=TypeSymbol.prototype;v6940.getDocComments=v760;return TypeSymbol}function v747(_super){function v746(varFlags){var v20458=TypeScript.VarFlags,v20458=v20458.Ambient;if(v20458=JAMScript.call(TypeScript.hasFlag,TypeScript,[varFlags,v20458])){var v20458=this.flags,v20459=TypeScript.SymbolFlags,
v20459=v20459.Ambient;this.flags=v20458|v20459}v20458=TypeScript.VarFlags;v20458=v20458.Constant;if(v20458=JAMScript.call(TypeScript.hasFlag,TypeScript,[varFlags,v20458]))v20458=this.flags,v20459=TypeScript.SymbolFlags,v20459=v20459.Constant,this.flags=v20458|v20459;v20458=TypeScript.VarFlags;v20458=v20458.Static;if(v20458=JAMScript.call(TypeScript.hasFlag,TypeScript,[varFlags,v20458]))v20458=this.flags,v20459=TypeScript.SymbolFlags,v20459=v20459.Static,this.flags=v20458|v20459;v20458=TypeScript.VarFlags;
v20458=v20458.Property;if(v20458=JAMScript.call(TypeScript.hasFlag,TypeScript,[varFlags,v20458]))v20458=this.flags,v20459=TypeScript.SymbolFlags,v20459=v20459.Property,this.flags=v20458|v20459;v20458=TypeScript.VarFlags;v20458=v20458.Private;if(v20458=JAMScript.call(TypeScript.hasFlag,TypeScript,[varFlags,v20458]))v20458=this.flags,v20459=TypeScript.SymbolFlags,v20459=v20459.Private,this.flags=v20458|v20459;v20458=TypeScript.VarFlags;v20458=v20458.Public;if(v20458=JAMScript.call(TypeScript.hasFlag,
TypeScript,[varFlags,v20458]))v20458=this.flags,v20459=TypeScript.SymbolFlags,v20459=v20459.Public,this.flags=v20458|v20459;v20458=TypeScript.VarFlags;v20458=v20458.Readonly;if(v20458=JAMScript.call(TypeScript.hasFlag,TypeScript,[varFlags,v20458]))v20458=this.flags,v20459=TypeScript.SymbolFlags,v20459=v20459.Readonly,this.flags=v20458|v20459;v20458=TypeScript.VarFlags;v20458=v20458.Exported;if(varFlags=JAMScript.call(TypeScript.hasFlag,TypeScript,[varFlags,v20458]))varFlags=this.flags,v20458=TypeScript.SymbolFlags,
v20458=v20458.Exported,this.flags=varFlags|v20458}function v745(){return!0}function InferenceSymbol(name,location,length,unitIndex){JAMScript.call(_super.call,_super,[this,name,location,length,unitIndex]);this.typeCheckStatus=TypeCheckStatus.NotStarted}JAMScript.call(__extends,null,[InferenceSymbol,_super]);var v6961=InferenceSymbol.prototype;v6961.isInferenceSymbol=v745;v6961=InferenceSymbol.prototype;v6961.transferVarFlags=v746;return InferenceSymbol}function v744(){function ValueLocation(){}return ValueLocation}
function v743(){function v742(){var v6963=this.flags,v15401=TypeScript.SymbolFlags,v15401=v15401.Static;return JAMScript.call(TypeScript.hasFlag,TypeScript,[v6963,v15401])}function v741(){var v15402=this.declAST;return(v15402=null!=v15402)?(v15402=this.declAST,JAMScript.call(v15402.getDocComments,v15402,[])):[]}function v740(){var v20474=this.declAST;if(v20474=null!=v20474)var v20474=this.declAST,v20474=v20474.nodeType,v23596=TypeScript.NodeType,v23596=v23596.VarDecl,v20474=v20474==v23596;return v20474?
this.declAST:null}function v739(checker){var v15404=this.declAST;if(v15404=null!=v15404){var v15404=this.declAST,v15404=v15404.nodeType,v20478=TypeScript.NodeType,v20478=v20478.InterfaceDeclaration;if(v15404=v15404==v20478)return this.declAST;v15404=this.container;if(v15404=null!=v15404){v15404=this.container;checker=checker.gloMod;if(checker=v15404!=checker)checker=this.container,checker=checker.declAST,checker=checker.nodeType,v15404=TypeScript.NodeType,v15404=v15404.InterfaceDeclaration,checker=
checker==v15404;v15404=checker}if(checker=v15404)return checker=this.container,checker.declAST}return null}function v738(){throw Error("please implement in derived class");}function v737(type){throw Error("please implement in derived class");}function v736(pattern,replacement,checker){throw Error("please implement in derived class");}function v735(outfile){var v6972=JAMScript.call(this.toString,this,[]);JAMScript.call(outfile.Write,outfile,[v6972])}function v734(){var v6973=this.name;return v6973?
this.name:"_anonymous"}function v733(identifier){var v15408=this.refs;if(v15408=!v15408)this.refs=[];var v15409=v15408=this.refs,v15409=v15409.length;JAMScript.set(v15408,v15409,identifier)}function v732(scope,checker){var v15410=null==checker,v20483=!v15410;v20483&&(v15410=this.container,v20483=checker.gloMod,v15410=v15410==v20483);if(v15410)return!0;v15410=this.flags;v20483=TypeScript.SymbolFlags;v20483=v20483.ModuleMember;if(v15410=JAMScript.call(TypeScript.hasFlag,TypeScript,[v15410,v20483])){v15410=
this.flags;v20483=TypeScript.SymbolFlags;v20483=v20483.Exported;if(v15410=JAMScript.call(TypeScript.hasFlag,TypeScript,[v15410,v20483])){v15410=this.flags;v20483=TypeScript.SymbolFlags;v20483=v20483.Private;v15410=JAMScript.call(TypeScript.hasFlag,TypeScript,[v15410,v20483]);if(v15410=!v15410)return!0;v15410=scope.container;return aEnclosesB(this,v15410)}if(v15410=checker)v15410=checker.currentModDecl,v20483=this.declModule,v15410=v15410==v20483;if(v20483=!v15410)if(v15410=checker.currentModDecl)if(v15410=
checker.currentModDecl,v15410=v15410.mod)if(v15410=checker.currentModDecl,v15410=v15410.mod,v15410=v15410.symbol)if(v15410=this.declModule)if(v15410=this.declModule,v15410=v15410.mod)if(v15410=this.declModule,v15410=v15410.mod,v15410=v15410.symbol)v15410=checker.currentModDecl,v15410=v15410.mod,v15410=v15410.symbol,v20483=this.declModule,v20483=v20483.mod,v20483=v20483.symbol,v15410=aEnclosesB(v15410,v20483);return v15410}if(v15410=this.declAST)v15410=this.declAST,v15410=v15410.nodeType,v20483=TypeScript.NodeType,
v20483=v20483.FuncDecl,v15410=v15410==v20483;if(v15410=v20483=v15410)v15410=this.declAST,v15410=JAMScript.call(v15410.isMethod,v15410,[]);if(v20483)var v20483=this.declAST,v20483=v20483.fncFlags,v20494=TypeScript.FncFlags,v20494=v20494.Static,v20483=JAMScript.call(TypeScript.hasFlag,TypeScript,[v20483,v20494]);v20494=v20483;if(v20483=v15410)var v20483=this.declAST,v20483=v20483.fncFlags,v20496=TypeScript.FncFlags,v20496=v20496.Private,v20483=JAMScript.call(TypeScript.hasFlag,TypeScript,[v20483,v20496]);
if(v20496=JAMScript.call(this.isType,this,[]))v20496=this.aliasLink;var v15426=JAMScript.call(this.isMember,this,[]),v20498=!v15426;v20498&&((v15426=!v15410)&&(v15410=v20494||v20496),v15426=v15410);if(v15410=v15426){if(v15410=this.flags,v20494=TypeScript.SymbolFlags,v20494=v20494.Private,v15410=JAMScript.call(TypeScript.hasFlag,TypeScript,[v15410,v20494]),(v20494=!v15410)&&(v15410=v20483),v15410){v15410=scope.container;if(v15410=null==v15410)v15410=this.container,v20483=scope.container,v15410=v15410!=
v20483;if(v15410)return!1;v15410=this.container;(v15410=null==v15410)?v15410=!0:(v15410=scope.container,v20483=this.container,v15410=aEnclosesB(v15410,v20483));return v15410}}else if(v15410=this.container)return v15410=scope.container,aEnclosesB(this,v15410);return!0}function v731(checker){var v15432=checker.gloMod;if(v15432=this==v15432)return!0;var v15432=this.flags,v20506=TypeScript.SymbolFlags,v20506=v20506.Private;if(v15432=JAMScript.call(TypeScript.hasFlag,TypeScript,[v15432,v20506]))return!1;
v15432=this.flags;v20506=TypeScript.SymbolFlags;v20506=v20506.Exported;v15432=JAMScript.call(TypeScript.hasFlag,TypeScript,[v15432,v20506]);if(v15432=!v15432)return v15432=this.container,checker=checker.gloMod,v15432==checker;v15432=this.container;return JAMScript.call(v15432.isExternallyVisible,v15432,[checker])}function v730(){var builder=this.name,ancestor=this.container,v15436=ancestor;if(v15436)var v15436=ancestor.name,v20510=TypeScript.globalId,v15436=v15436!=v20510;for(;v15436;)if(v15436=ancestor.name,
v15436+=".",builder=v15436+builder,v15436=ancestor=ancestor.container)v15436=ancestor.name,v20510=TypeScript.globalId,v15436=v15436!=v20510;return builder}function v729(scope){var v7004=null==scope;if(v7004)return scope=JAMScript.call(this.getPrettyName,this,[null]),v7004=JAMScript.call(this.getOptionalNameString,this,[]),scope+v7004;for(var v7004=scope.container,v7004=JAMScript.call(this.findCommonAncestorPath,this,[v7004]),builder="",i=0,len=v7004.length,v7009=i<len;v7009;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7009=
v7004[i];var v15439;v15439=len-1;(v15439=i==v15439)?v15439=scope.container:(v15439=i+1,v15439=v7004[v15439]);v7009=JAMScript.call(v7009.getPrettyName,v7009,[v15439]);v7009+=".";builder=v7009+builder;i+=1;v7009=i<len}scope=(len=0==len)?scope.container:v7004[0];scope=JAMScript.call(this.getPrettyName,this,[scope]);v7004=JAMScript.call(this.getOptionalNameString,this,[]);scope+=v7004;return builder+=scope}function v728(scopeSymbol){return this.name}function v727(b){var v15442=this.container;if(v15442=
null==v15442)return[];var v15442=this.container,v15442=JAMScript.call(v15442.pathToRoot,v15442,[]),bPath;bPath=b?JAMScript.call(b.pathToRoot,b,[]):[];b=-1;for(var i=0,aLen=v15442.length,v7015=i<aLen;v7015;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7015=v15442[i];for(var j=0,bLen=bPath.length,v7013=j<bLen;v7013;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7013=bPath[j];if(v7013=v7015==v7013){b=i;break}j+=1;v7013=j<
bLen}if(v7015=0<=b)break;i+=1;v7015=i<aLen}return(bPath=0<=b)?v15442.slice(0,b):v15442}function v726(){var path=[],node=this,v15443=node;if(v15443)var v15443=node.name,v20518=TypeScript.globalId,v15443=v15443!=v20518;for(;v15443;)if(v15443=path.length,path[v15443]=node,v15443=node=node.container)v15443=node.name,v20518=TypeScript.globalId,v15443=v15443!=v20518;return path}function v725(){var v7019;v7019=this.flags;var v23609=TypeScript.SymbolFlags,v23609=v23609.Optional;return v7019=(v7019=JAMScript.call(TypeScript.hasFlag,
TypeScript,[v7019,v23609]))?"?":""}function v724(scope){scope=TypeScript.MemberName;var v7021=JAMScript.call(this.toString,this,[]);return JAMScript.call(scope.create,scope,[v7021])}function v723(scope){scope=JAMScript.call(this.getTypeNameEx,this,[scope]);return JAMScript.call(scope.toString,scope,[])}function v722(){var v15446=this.flags,v20523=TypeScript.SymbolFlags,v20523=v20523.Property;if(v15446=JAMScript.call(TypeScript.hasFlag,TypeScript,[v15446,v20523]))v15446=this.flags,v20523=TypeScript.SymbolFlags,
v20523=v20523.ModuleMember,v15446=JAMScript.call(TypeScript.hasFlag,TypeScript,[v15446,v20523]),v15446=!v15446;return v15446}function v721(){return!1}function v720(){return null}function v719(){return!1}function v718(){return!1}function v717(){return!1}function v716(){return!1}function v715(){return!1}function v714(){return!1}function v713(){return null}function Symbol(name,location,length,unitIndex){this.name=name;this.location=location;this.length=length;this.unitIndex=unitIndex;this.bound=!1;name=
TypeScript.SymbolFlags;this.flags=name.None;this.isObjectLitField=!1;this.declModule=this.declAST=null;name=TypeScript.CompilerDiagnostics;this.passSymbolCreated=name.analysisPass}var v7026=Symbol.prototype;v7026.instanceScope=v713;v7026=Symbol.prototype;v7026.isVariable=v714;v7026=Symbol.prototype;v7026.isMember=v715;v7026=Symbol.prototype;v7026.isInferenceSymbol=v716;v7026=Symbol.prototype;v7026.isWith=v717;v7026=Symbol.prototype;v7026.writeable=v718;v7026=Symbol.prototype;v7026.isType=v719;v7026=
Symbol.prototype;v7026.getType=v720;v7026=Symbol.prototype;v7026.isAccessor=v721;v7026=Symbol.prototype;v7026.isInstanceProperty=v722;v7026=Symbol.prototype;v7026.getTypeName=v723;v7026=Symbol.prototype;v7026.getTypeNameEx=v724;v7026=Symbol.prototype;v7026.getOptionalNameString=v725;v7026=Symbol.prototype;v7026.pathToRoot=v726;v7026=Symbol.prototype;v7026.findCommonAncestorPath=v727;v7026=Symbol.prototype;v7026.getPrettyName=v728;v7026=Symbol.prototype;v7026.scopeRelativeName=v729;v7026=Symbol.prototype;
v7026.fullName=v730;v7026=Symbol.prototype;v7026.isExternallyVisible=v731;v7026=Symbol.prototype;v7026.visible=v732;v7026=Symbol.prototype;v7026.addRef=v733;v7026=Symbol.prototype;v7026.toString=v734;v7026=Symbol.prototype;v7026.print=v735;v7026=Symbol.prototype;v7026.specializeType=v736;v7026=Symbol.prototype;v7026.setType=v737;v7026=Symbol.prototype;v7026.kind=v738;v7026=Symbol.prototype;v7026.getInterfaceDeclFromSymbol=v739;v7026=Symbol.prototype;v7026.getVarDeclFromSymbol=v740;v7026=Symbol.prototype;
v7026.getDocComments=v741;v7026=Symbol.prototype;v7026.isStatic=v742;return Symbol}function v712(TypeCheckStatus){TypeCheckStatus._map=[];var v7056=TypeCheckStatus._map;v7056[0]="NotStarted";TypeCheckStatus.NotStarted=0;v7056=TypeCheckStatus._map;v7056[1]="Started";TypeCheckStatus.Started=1;v7056=TypeCheckStatus._map;v7056[2]="Finished";TypeCheckStatus.Finished=2}function aLexicallyEnclosesB(a,b){var v15449=a.declAST;if(v15449&&(v15449=b)&&(v15449=b.declAST))var v15449=a.declAST,v15449=v15449.nodeType,
v25930=TypeScript.NodeType,v25930=v25930.FuncDecl,v15449=v15449==v25930;if(v15449){v15449=a.declAST;v15449=v15449.minChar;v25930=b.declAST;v25930=v25930.minChar;if(v15449=v15449<=v25930)v15449=a.declAST,v15449=v15449.limChar,v25930=b.declAST,v25930=v25930.limChar,v15449=v15449>=v25930;return v15449}return!1}function aEnclosesB(a,b){for(var v7062=a.container;v7062;){var v7062=a==b,v20532=!v7062;v20532&&(v7062=a.container,v7062=aLexicallyEnclosesB(v7062,b));if(v7062)return!0;a=a.container;v7062=a.container}return!1}
var v15455=TypeScript.TypeCheckStatus,v20533=!v15455;v20533&&(v15455=TypeScript.TypeCheckStatus={});v712(v15455);var TypeCheckStatus=TypeScript.TypeCheckStatus;TypeScript.aLexicallyEnclosesB=aLexicallyEnclosesB;TypeScript.aEnclosesB=aEnclosesB;v15455=v743();TypeScript.Symbol=v15455;var ValueLocation=v744();TypeScript.ValueLocation=ValueLocation;v15455=v747(v15455);TypeScript.InferenceSymbol=v15455;v20533=v761(v15455);TypeScript.TypeSymbol=v20533;v20533=v763(v20533);TypeScript.WithSymbol=v20533;v20533=
v775(v15455);TypeScript.FieldSymbol=v20533;v20533=v786(v15455);TypeScript.ParameterSymbol=v20533;v15455=v793(v15455);TypeScript.VariableSymbol=v15455}
function v711(){var TypeScript=v12359;function v710(){function v709(checker,ast,hasConstruct){ast=this.hasBeenTypechecked;if(!ast){this.hasBeenTypechecked=!0;ast=0;var v15456=this.signatures;v15456&&(ast=this.signatures,v15456=ast=ast.length,v15456=0<v15456);if(v15456){for(var v15456=0,v7073=v15456<ast;v7073;){if(v7073=!hasConstruct)if(v7073=this.definitionSignature,v7073=!v7073){v7073=this.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7073=v7073[v15456];
if(v7073=v7073.declAST){v7073=this.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7073=v7073[v15456];v7073=v7073.declAST;if(v7073=v7073.isOverload){v7073=this.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7073=v7073[v15456];var v7073=v7073.declAST,v7073=v7073.fncFlags,v26545=TypeScript.FncFlags,v26545=v26545.Ambient,v7073=JAMScript.call(TypeScript.hasFlag,TypeScript,[v7073,v26545]),v7073=!v7073}}}if(v7073){v7073=
checker.errorReporter;v26545=this.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26545=v26545[v15456];v26545=v26545.declAST;JAMScript.call(v7073.simpleError,v7073,[v26545,"Overload declaration lacks definition"])}v7073=this.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7073=v7073[v15456];if(v7073=v7073.declAST){v7073=this.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7073=
v7073[v15456];v7073=v7073.declAST;if(v7073=v7073.isConstructor){v7073=this.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7073=v7073[v15456];v7073=v7073.declAST;if(v7073=v7073.classDecl){v7073=this.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7073=v7073[v15456];v7073=v7073.declAST;v7073=v7073.classDecl;v7073=v7073.type;v7073=v7073.symbol;v7073=v7073.typeCheckStatus;v26545=TypeScript.TypeCheckStatus;v26545=
v26545.NotStarted;v7073=v7073==v26545}}}if(v7073){v7073=checker.typeFlow;v26545=this.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26545=v26545[v15456];v26545=v26545.declAST;v26545=v26545.classDecl;JAMScript.call(v7073.typeCheck,v7073,[v26545])}v7073=checker.typeFlow;v26545=this.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26545=v26545[v15456];v26545=v26545.declAST;JAMScript.call(v7073.typeCheck,v7073,
[v26545]);v15456+=1;v7073=v15456<ast}JAMScript.call(this.verifySignatures,this,[checker])}}}function v708(checker){var len=0,v15462=this.signatures;v15462&&(len=this.signatures,v15462=len=len.length,v15462=0<v15462);if(v15462)for(var v15462=0,v7084=v15462<len;v7084;){for(var v7084=v15462+1,v7079=v7084<len;v7079;){v7079=this.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7079=v7079[v15462];if(v7079=v7079.declAST){v7079=this.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7079=
v7079[v7084];if(v7079=v7079.declAST){v7079=this.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7079=v7079[v15462];var v7079=v7079.declAST,v7079=v7079.fncFlags,v26548=TypeScript.FncFlags,v26548=v26548.Definition,v7079=JAMScript.call(TypeScript.hasFlag,TypeScript,[v7079,v26548]);if(v7079=!v7079){v7079=this.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7079=v7079[v7084];v7079=v7079.declAST;v7079=v7079.fncFlags;
v26548=TypeScript.FncFlags;v26548=v26548.Definition;v7079=JAMScript.call(TypeScript.hasFlag,TypeScript,[v7079,v26548]);v7079=!v7079}if(v7079){v7079=this.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7079=v7079[v15462];v26548=this.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26548=v26548[v7084];v7079=JAMScript.call(checker.signaturesAreIdentical,checker,[v7079,v26548])}}}if(v7079){v7079=checker.errorReporter;
v26548=this.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26548=v26548[v15462];var v26548=v26548.declAST,v15465;v15465=this.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v15465=v15465[v15462];if(v15465=v15465.declAST){v15465=this.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v15465=v15465[v15462];v15465=v15465.declAST;v15465=v15465.name}if(v15465){v15465=
this.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v15465=v15465[v15462];v15465=v15465.declAST;v15465=v15465.name;v15465=v15465.actualText;v15465="Signature for '"+v15465;v15465+="' is duplicated"}else v15465="Signature is duplicated";JAMScript.call(v7079.simpleError,v7079,[v26548,v15465])}v7084+=1;v7079=v7084<len}if(v7084=this.definitionSignature){v7084=this.definitionSignature;v7079=this.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7079=
v7079[v15462];v7084=JAMScript.call(checker.signatureIsAssignableToTarget,checker,[v7084,v7079]);if(v7084=!v7084){v7084=checker.errorReporter;v7079=this.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7079=v7079[v15462];v7079=v7079.declAST;JAMScript.call(v7084.simpleError,v7084,[v7079,"Overload signature is not compatible with function definition"])}}v15462+=1;v7084=v15462<len}}function v707(pattern,replacement,checker){var result=new SignatureGroup,v7089=
this.signatures;if(v7089)for(var v7089=0,v7086=this.signatures,v7086=v7086.length,v7088=v7089<v7086;v7088;){v7088=this.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7088=v7088[v7089];v7088=JAMScript.call(v7088.specializeType,v7088,[pattern,replacement,checker]);JAMScript.call(result.addSignature,result,[v7088]);v7089+=1;v7088=v7089<v7086}return result}function v706(prefix,shortform,scope){var result=[],v7090=this.signatures,v7090=v7090.length,v7091=
1<v7090;v7091&&(shortform=!1);for(var v7091=0,v7096=v7091<v7090;v7096;){if(v7096=1<v7090){v7096=this.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7096=v7096[v7091];var v20552=this.definitionSignature,v7096=v7096==v20552}if(!v7096){v7096=this.flags;v20552=TypeScript.SignatureFlags;v20552=v20552.IsIndexer;if(v7096&=v20552){v7096=this.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7096=v7096[v7091];v7096=
JAMScript.call(v7096.toStringHelperEx,v7096,[shortform,!0,scope])}else{v7096=this.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7096=v7096[v7091];v7096=JAMScript.call(v7096.toStringHelperEx,v7096,[shortform,!1,scope,prefix])}JAMScript.call(result.push,result,[v7096])}v7091+=1;v7096=v7091<v7090}return result}function v705(){var v7097=this.signatures;return JAMScript.call(v7097.toString,v7097,[])}function v704(signature){var v15474=this.signatures;if(v15474=
null==v15474)this.signatures=v15474=[];var v15475=v15474=this.signatures,v15475=v15475.length;JAMScript.set(v15474,v15475,signature);if(v15474=signature.declAST)if(v15474=signature.declAST,v15474=v15474.isOverload,v15474=!v15474)if(v15474=signature.declAST,v15474=JAMScript.call(v15474.isSignature,v15474,[]),v15474=!v15474)if(v15474=signature.declAST,v15474=v15474.fncFlags,v15475=TypeScript.FncFlags,v15475=v15475.Ambient,v15474=JAMScript.call(TypeScript.hasFlag,TypeScript,[v15474,v15475]),v15474=!v15474)v15474=
signature.declAST,v15474=v15474.fncFlags,v15475=TypeScript.FncFlags,v15475=v15475.Definition,v15474=JAMScript.call(TypeScript.hasFlag,TypeScript,[v15474,v15475]);v15474&&(this.definitionSignature=signature)}function SignatureGroup(){this.signatures=[];this.hasImplementation=!0;this.definitionSignature=null;this.hasBeenTypechecked=!1;var v7102=TypeScript.SignatureFlags;this.flags=v7102.None}var v7103=SignatureGroup.prototype;v7103.addSignature=v704;v7103=SignatureGroup.prototype;v7103.toString=v705;
v7103=SignatureGroup.prototype;v7103.toStrings=v706;v7103=SignatureGroup.prototype;v7103.specializeType=v707;v7103=SignatureGroup.prototype;v7103.verifySignatures=v708;v7103=SignatureGroup.prototype;v7103.typeCheck=v709;return SignatureGroup}function v703(){function v702(shortform,brackets,scope,prefix){var v15477=typeof prefix;(v15477="undefined"===v15477)&&(prefix="");v15477=TypeScript.MemberNameArray;v15477=JAMScript.new(v15477,[]);v15477.prefix=brackets?prefix+"[":prefix+"(";prefix=this.parameters;
var paramLen=prefix.length,len=prefix=(prefix=this.hasVariableArgList)?paramLen-1:paramLen;prefix=0;for(var v7117=prefix<len;v7117;){var v7117=TypeScript.MemberName,v25949=this.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v25949=v25949[prefix];var v25949=v25949.name,v25159;v25159=this.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v25159=v25159[prefix];v25159=(v25159=JAMScript.call(v25159.isOptional,v25159,
[]))?"?":"";v25949+=v25159;v25949+=": ";v7117=JAMScript.call(v7117.create,v7117,[v25949]);JAMScript.call(v15477.add,v15477,[v7117]);v7117=this.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7117=v7117[prefix];v7117=JAMScript.call(v7117.getType,v7117,[]);v7117=JAMScript.call(v7117.getScopedTypeNameEx,v7117,[scope]);JAMScript.call(v15477.add,v15477,[v7117]);v7117=paramLen-1;if(v7117=prefix<v7117)v7117=TypeScript.MemberName,v7117=JAMScript.call(v7117.create,
v7117,[", "]),JAMScript.call(v15477.add,v15477,[v7117]);prefix+=1;v7117=prefix<len}if(paramLen=this.hasVariableArgList){paramLen=TypeScript.MemberName;len=this.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)len=len[prefix];len=len.name;len="..."+len;len+=": ";paramLen=JAMScript.call(paramLen.create,paramLen,[len]);JAMScript.call(v15477.add,v15477,[paramLen]);paramLen=this.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)prefix=
paramLen[prefix];prefix=JAMScript.call(prefix.getType,prefix,[]);prefix=JAMScript.call(prefix.getScopedTypeNameEx,prefix,[scope]);JAMScript.call(v15477.add,v15477,[prefix])}shortform?brackets?(shortform=TypeScript.MemberName,shortform=JAMScript.call(shortform.create,shortform,["] => "])):(shortform=TypeScript.MemberName,shortform=JAMScript.call(shortform.create,shortform,[") => "])):brackets?(shortform=TypeScript.MemberName,shortform=JAMScript.call(shortform.create,shortform,["]: "])):(shortform=
TypeScript.MemberName,shortform=JAMScript.call(shortform.create,shortform,["): "]));JAMScript.call(v15477.add,v15477,[shortform]);shortform=this.returnType;(shortform=shortform.type)?(shortform=this.returnType,shortform=shortform.type,scope=JAMScript.call(shortform.getScopedTypeNameEx,shortform,[scope])):(scope=TypeScript.MemberName,scope=JAMScript.call(scope.create,scope,["any"]));JAMScript.call(v15477.add,v15477,[scope]);return v15477}function v701(shortform,brackets,scope){shortform=JAMScript.call(this.toStringHelperEx,
this,[shortform,brackets,scope]);return JAMScript.call(shortform.toString,shortform,[])}function v700(){return JAMScript.call(this.toStringHelper,this,[!1,!1,null])}function v699(pattern,replacement,checker){var result=new Signature,v7129=this.hasVariableArgList;v7129&&(result.hasVariableArgList=!0);var v7129=result,v15494=TypeScript.TypeLink,v15494=JAMScript.new(v15494,[]);v7129.returnType=v15494;v7129=this.returnType;(v7129=v7129.type)?(v7129=result.returnType,v15494=this.returnType,v15494=v15494.type,
v15494=JAMScript.call(v15494.specializeType,v15494,[pattern,replacement,checker,!1]),v7129.type=v15494):(v7129=result.returnType,v7129.type=checker.anyType);if(v7129=this.parameters){result.parameters=[];for(var v7129=0,v15494=this.parameters,v15494=v15494.length,v7146=v7129<v15494;v7146;){v7146=this.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var oldSym=v7146[v7129];var v7146=TypeScript.ValueLocation,v7146=JAMScript.new(v7146,[]),v7137=TypeScript.ParameterSymbol,
v7138=oldSym.name,v7139=oldSym.location,v15497=checker.locationInfo,v15497=v15497.unitIndex,v7137=JAMScript.new(v7137,[v7138,v7139,v15497,v7146]);v7137.declAST=this.declAST;v7146.symbol=v7137;v7138=v7146;v7139=TypeScript.TypeLink;v7139=JAMScript.new(v7139,[]);v7138.typeLink=v7139;v7138=result.parameters;v7138[v7129]=v7137;(v7138=JAMScript.call(oldSym.getType,oldSym,[]))?(oldSym=v7146.typeLink,v7138=JAMScript.call(v7138.specializeType,v7138,[pattern,replacement,checker,!1]),oldSym.type=v7138,oldSym=
v7137.declAST,v7146=v7146.typeLink,oldSym.type=v7146.type):(v7146=v7146.typeLink,v7146.type=checker.anyType);v7129+=1;v7146=v7129<v15494}}result.nonOptionalParameterCount=this.nonOptionalParameterCount;result.declAST=this.declAST;return result}function Signature(){this.hasVariableArgList=!1;this.declAST=this.parameters=null;var v7148=TypeScript.TypeCheckStatus;this.typeCheckStatus=v7148.NotStarted;this.nonOptionalParameterCount=0}var v7149=Signature.prototype;v7149.specializeType=v699;v7149=Signature.prototype;
v7149.toString=v700;v7149=Signature.prototype;v7149.toStringHelper=v701;v7149=Signature.prototype;v7149.toStringHelperEx=v702;return Signature}var Signature=v703();TypeScript.Signature=Signature;Signature=v710();TypeScript.SignatureGroup=Signature}
function v698(){var TypeScript=v12358;function v697(){function v696(){var v15500=this.scriptFragment;if(v15500=null==v15500){var v15500=this.scopeStartAST,minChar=v15500.minChar,v7153;(v7153=this.isMemberCompletion)?v7153=this.pos:(v7153=this.pos,v7153+=1);var v15503=this.logger,v15504=this.text,v15500=JAMScript.call(TypeScript.quickParse,TypeScript,[v15503,v15500,v15504,minChar,v7153,null]);this.scriptFragment=v15500.Script}return this.scriptFragment}function v695(){var v7156=this.scopeStartAST;
return v7156.minChar}function v694(){return this.scopeStartAST}function v693(){var v7157=this.scopeStartAST;return v7157.minChar}function v692(){return this.scopeStartAST}function v691(){return JAMScript.call(this.objectLiteralScopeGetter,this,[])}function v690(){return JAMScript.call(this.scopeGetter,this,[])}function EnclosingScopeContext(logger,script,text,pos,isMemberCompletion){this.logger=logger;this.script=script;this.text=text;this.pos=pos;this.isMemberCompletion=isMemberCompletion;this.scopeStartAST=
this.objectLiteralScopeGetter=this.scopeGetter=null;this.skipNextFuncDeclForClass=!1;this.enclosingObjectLit=this.enclosingClassDecl=this.deepestModuleDecl=null;this.publicsOnly=!0;this.useFullAst=!1}var v7158=EnclosingScopeContext.prototype;v7158.getScope=v690;v7158=EnclosingScopeContext.prototype;v7158.getObjectLiteralScope=v691;v7158=EnclosingScopeContext.prototype;v7158.getScopeAST=v692;v7158=EnclosingScopeContext.prototype;v7158.getScopePosition=v693;v7158=EnclosingScopeContext.prototype;v7158.getScriptFragmentStartAST=
v694;v7158=EnclosingScopeContext.prototype;v7158.getScriptFragmentPosition=v695;v7158=EnclosingScopeContext.prototype;v7158.getScriptFragment=v696;return EnclosingScopeContext}function v689(){function MemberScopeContext(flow,pos,matchFlag){this.flow=flow;this.pos=pos;this.matchFlag=matchFlag;this.ast=this.type=null;flow=TypeScript.AstWalkOptions;this.options=flow=JAMScript.new(flow,[])}return MemberScopeContext}function v688(){function TypeCollectionContext(scopeChain,checker){this.scopeChain=scopeChain;
this.checker=checker;this.script=null}return TypeCollectionContext}function preFindMemberScope(ast,parent,walker){parent=walker.state;walker=ast.flags;var v20564=parent.matchFlag;if(walker=JAMScript.call(TypeScript.hasFlag,TypeScript,[walker,v20564]))if(walker=parent.pos,walker=0>walker,v20564=!walker)walker=parent.pos,v20564=ast.limChar,walker=walker==v20564;if(walker){parent.ast=ast;walker=ast.type;if(walker=null==walker)walker=parent.pos,walker=0<=walker;walker&&(walker=parent.flow,v20564=parent.scope,
JAMScript.call(walker.inScopeTypeCheck,walker,[ast,v20564]));parent.type=ast.type;parent=parent.options;JAMScript.call(parent.stopWalk,parent,[])}return ast}function pushTypeCollectionScope(container,valueMembers,ambientValueMembers,enclosedTypes,ambientEnclosedTypes,context,thisType,classType,moduleDecl){var v7171=TypeScript.SymbolScopeBuilder;valueMembers=JAMScript.new(v7171,[valueMembers,ambientValueMembers,enclosedTypes,ambientEnclosedTypes,null,container]);ambientValueMembers=TypeScript.ScopeChain;
enclosedTypes=context.scopeChain;container=JAMScript.new(ambientValueMembers,[container,enclosedTypes,valueMembers]);container.thisType=thisType;container.classType=classType;container.moduleDecl=moduleDecl;context.scopeChain=container}function popTypeCollectionScope(context){var v7174=context.scopeChain;context.scopeChain=v7174.previous}function preFindEnclosingScope(ast,parent,walker){function v687(){var v15507=funcDecl.isConstructor;if(v15507)var v15507=funcDecl.fncFlags,v23638=TypeScript.FncFlags,
v23638=v23638.ClassMethod,v15507=JAMScript.call(TypeScript.hasFlag,TypeScript,[v15507,v23638]);if(v15507){if(v15507=ast.type)v15507=ast.type,v15507=v15507.enclosingType;if(v15507)return v15507=ast.type,v15507=v15507.enclosingType,v15507.constructorScope}return(v15507=funcDecl.scopeType)?(v15507=funcDecl.scopeType,v15507.containedScope):(v15507=funcDecl.type)?(v15507=funcDecl.type,v15507.containedScope):null}function v686(){var v7182;v7182=ast.type;(v7182=null===v7182)?v7182=null:(v7182=ast.type,v7182=
v7182.containedScope);return v7182}function v685(){var v7183;v7183=ast.type;(v7183=null===v7183)?v7183=null:(v7183=ast.type,v7183=v7183.containedScope);return v7183}function v684(){var v7184=objectLit.targetType;return v7184.memberScope}function v683(){var v7185=objectLit.targetType;return v7185.containedScope}function v682(){var v7186;v7186=ast.type;v7186=null===v7186;var v23641=!v7186;v23641&&(v7186=ast.type,v7186=v7186.instanceType,v7186=v7186.containedScope,v7186=null===v7186);v7186?v7186=null:
(v7186=ast.type,v7186=v7186.instanceType,v7186=v7186.containedScope);return v7186}function v681(){var v7187;v7187=script.bod;(v7187=null===v7187)?v7187=null:(v7187=script.bod,v7187=v7187.enclosingScope);return v7187}parent=walker.state;var minChar=ast.minChar,limChar=ast.limChar,v20576=ast.nodeType,v23642=TypeScript.NodeType,v23642=v23642.Script;if(v20576=v20576==v23642)v20576=parent.pos,v20576=v20576>limChar;v20576&&(limChar=parent.pos);v20576=parent.pos;if(minChar=minChar<=v20576)minChar=parent.pos,
minChar=limChar>=minChar;if(limChar=minChar){limChar=ast.nodeType;switch(limChar){case TypeScript.NodeType.Script:var script=ast;parent.scopeGetter=v681;parent.scopeStartAST=script;break;case TypeScript.NodeType.ClassDeclaration:parent.scopeGetter=v682;parent.scopeStartAST=ast;parent.enclosingClassDecl=ast;break;case TypeScript.NodeType.ObjectLit:var objectLit=ast;if(limChar=objectLit.targetType)parent.scopeGetter=v683,parent.objectLiteralScopeGetter=v684,parent.enclosingObjectLit=objectLit;break;
case TypeScript.NodeType.ModuleDeclaration:parent.deepestModuleDecl=ast;parent.scopeGetter=v685;parent.scopeStartAST=ast;break;case TypeScript.NodeType.InterfaceDeclaration:parent.scopeGetter=v686;parent.scopeStartAST=ast;break;case TypeScript.NodeType.FuncDecl:var funcDecl=ast;(limChar=parent.skipNextFuncDeclForClass)?parent.skipNextFuncDeclForClass=!1:(parent.scopeGetter=v687,parent.scopeStartAST=ast)}walker=walker.options;walker.goChildren=!0}else walker=walker.options,walker.goChildren=!1;return ast}
function findEnclosingScopeAt(logger,script,text,pos,isMemberCompletion){logger=JAMScript.new(EnclosingScopeContext,[logger,script,text,pos,isMemberCompletion]);text=JAMScript.call(TypeScript.getAstWalkerFactory,TypeScript,[]);JAMScript.call(text.walk,text,[script,preFindEnclosingScope,null,null,logger]);script=logger.scopeStartAST;return(script=null===script)?null:logger}var TypeCollectionContext=v688();TypeScript.TypeCollectionContext=TypeCollectionContext;TypeCollectionContext=v689();TypeScript.MemberScopeContext=
TypeCollectionContext;var EnclosingScopeContext=v697();TypeScript.EnclosingScopeContext=EnclosingScopeContext;TypeScript.preFindMemberScope=preFindMemberScope;TypeScript.pushTypeCollectionScope=pushTypeCollectionScope;TypeScript.popTypeCollectionScope=popTypeCollectionScope;TypeScript.preFindEnclosingScope=preFindEnclosingScope;TypeScript.findEnclosingScopeAt=findEnclosingScopeAt}
function v680(){var TypeScript=v12357;function v679(){function v678(b){var v7197=this.result;return(b=this.result=b=JAMScript.call(this.select,this,[v7197,b]))?(b=this.result,JAMScript.call(this.stop,this,[b])):!1}function v677(){this.result=null}function ScopeSearchFilter(select,stop){this.select=select;this.stop=stop;this.result=null}var v7200=ScopeSearchFilter.prototype;v7200.reset=v677;v7200=ScopeSearchFilter.prototype;v7200.update=v678;return ScopeSearchFilter}function v676(){function AssignScopeContext(scopeChain,
typeFlow,modDeclChain){this.scopeChain=scopeChain;this.typeFlow=typeFlow;this.modDeclChain=modDeclChain}return AssignScopeContext}function pushAssignScope(scope,context,type,classType,fnc){var v7202=TypeScript.ScopeChain,v7203=context.scopeChain;scope=JAMScript.new(v7202,[null,v7203,scope]);scope.thisType=type;scope.classType=classType;scope.fnc=fnc;context.scopeChain=scope}function popAssignScope(context){var v7204=context.scopeChain;context.scopeChain=v7204.previous}function instanceCompare(a,b){var v15521=
null==a,v20582=!v15521;v20582&&(v15521=JAMScript.call(a.isInstanceProperty,a,[]),v15521=!v15521);return v15521?b:a}function instanceFilterStop(s){return JAMScript.call(s.isInstanceProperty,s,[])}function preAssignModuleScopes(ast,context){var moduleDecl=ast,memberScope=null,aggScope=null,v15522=moduleDecl.name;v15522&&(v15522=moduleDecl.mod);v15522&&(v15522=moduleDecl.name,memberScope=moduleDecl.mod,v15522.sym=memberScope.symbol);v15522=moduleDecl.mod;memberScope=!v15522;if(!memberScope){var memberScope=
TypeScript.SymbolTableScope,aggScope=v15522.members,v7211=v15522.ambientMembers,v7212=v15522.enclosedTypes,v7213=v15522.ambientEnclosedTypes,v7214=v15522.symbol,memberScope=JAMScript.new(memberScope,[aggScope,v7211,v7212,v7213,v7214]);v15522.memberScope=memberScope;aggScope=context.modDeclChain;JAMScript.call(aggScope.push,aggScope,[moduleDecl]);aggScope=context.typeFlow;aggScope=aggScope.checker;aggScope.currentModDecl=moduleDecl;aggScope=TypeScript.SymbolAggregateScope;v7211=v15522.symbol;aggScope=
JAMScript.new(aggScope,[v7211]);JAMScript.call(aggScope.addParentScope,aggScope,[memberScope]);memberScope=context.scopeChain;memberScope=memberScope.scope;JAMScript.call(aggScope.addParentScope,aggScope,[memberScope]);pushAssignScope(aggScope,context,null,null,null);v15522.containedScope=aggScope;if(memberScope=v15522.symbol)memberScope=context.typeFlow,aggScope=v15522.containedScope,v7211=v15522.symbol,moduleDecl=moduleDecl.vars,v15522=v15522.members,v15522=v15522.privateMembers,JAMScript.call(memberScope.addLocalsFromScope,
memberScope,[aggScope,v7211,moduleDecl,v15522,!0])}}function preAssignClassScopes(ast,context){var classDecl=ast,memberScope=null,aggScope=null,v15527=classDecl.name;v15527&&(v15527=classDecl.type);v15527&&(v15527=classDecl.name,classDecl=classDecl.type,v15527.sym=classDecl.symbol);(classDecl=ast.type)?(v15527=context.typeFlow,v15527=v15527.checker,memberScope=JAMScript.call(v15527.scopeOf,v15527,[classDecl]),v15527=TypeScript.SymbolAggregateScope,aggScope=classDecl.symbol,aggScope=JAMScript.new(v15527,
[aggScope]),JAMScript.call(aggScope.addParentScope,aggScope,[memberScope]),v15527=context.scopeChain,v15527=v15527.scope,JAMScript.call(aggScope.addParentScope,aggScope,[v15527]),classDecl.containedScope=aggScope,classDecl.memberScope=memberScope,v15527=classDecl.instanceType,memberScope=context.typeFlow,memberScope=memberScope.checker,memberScope=JAMScript.call(memberScope.scopeOf,memberScope,[v15527]),v15527.memberScope=memberScope,memberScope=TypeScript.SymbolAggregateScope,aggScope=v15527.symbol,
aggScope=JAMScript.new(memberScope,[aggScope]),memberScope=context.scopeChain,memberScope=memberScope.scope,JAMScript.call(aggScope.addParentScope,aggScope,[memberScope]),pushAssignScope(aggScope,context,v15527,classDecl,null),v15527.containedScope=aggScope):(classDecl=context.typeFlow,ast.type=classDecl.anyType)}function preAssignInterfaceScopes(ast,context){var interfaceDecl=ast,memberScope=null,aggScope=null;if(memberScope=interfaceDecl.name)memberScope=interfaceDecl.type;memberScope&&(memberScope=
interfaceDecl.name,interfaceDecl=interfaceDecl.type,memberScope.sym=interfaceDecl.symbol);interfaceDecl=ast.type;memberScope=context.typeFlow;memberScope=memberScope.checker;memberScope=JAMScript.call(memberScope.scopeOf,memberScope,[interfaceDecl]);interfaceDecl.memberScope=memberScope;var aggScope=TypeScript.SymbolAggregateScope,v7241=interfaceDecl.symbol,aggScope=JAMScript.new(aggScope,[v7241]);JAMScript.call(aggScope.addParentScope,aggScope,[memberScope]);memberScope=context.scopeChain;memberScope=
memberScope.scope;JAMScript.call(aggScope.addParentScope,aggScope,[memberScope]);pushAssignScope(aggScope,context,null,null,null);interfaceDecl.containedScope=aggScope}function preAssignWithScopes(ast,context){var withStmt=ast,withType=withStmt.type,v7243=TypeScript.ScopedMembers,withType=TypeScript.DualStringHashTable,v20583=TypeScript.StringHashTable,v20583=JAMScript.new(v20583,[]),v20584=TypeScript.StringHashTable,v20584=JAMScript.new(v20584,[]),withType=JAMScript.new(withType,[v20583,v20584]),
v7243=JAMScript.new(v7243,[withType]),withType=TypeScript.ScopedMembers,v20583=TypeScript.DualStringHashTable,v20584=TypeScript.StringHashTable,v20584=JAMScript.new(v20584,[]),v20586=TypeScript.StringHashTable,v20586=JAMScript.new(v20586,[]),v20583=JAMScript.new(v20583,[v20584,v20586]),v20583=JAMScript.new(withType,[v20583]),withType=TypeScript.Type,withType=JAMScript.new(withType,[]),v20584=TypeScript.WithSymbol,v20586=withStmt.minChar,v23643=context.typeFlow,v23643=v23643.checker,v23643=v23643.locationInfo,
v23643=v23643.unitIndex,v20584=JAMScript.new(v20584,[v20586,v23643,withType]);withType.members=v7243;withType.ambientMembers=v20583;withType.symbol=v20584;JAMScript.call(withType.setHasImplementation,withType,[]);withStmt.type=withType;withStmt=TypeScript.SymbolScopeBuilder;v7243=withType.members;v20583=withType.ambientMembers;v20584=context.scopeChain;v20584=v20584.scope;v20586=withType.symbol;withStmt=JAMScript.new(withStmt,[v7243,v20583,null,null,v20584,v20586]);pushAssignScope(withStmt,context,
null,null,null);withType.containedScope=withStmt}function preAssignFuncDeclScopes(ast,context){var funcDecl=ast,container=null,localContainer=null,v7257=funcDecl.type;if(v7257)var v7256=ast.type,localContainer=v7256.symbol;var v7258=funcDecl.fncFlags,v15545=TypeScript.FncFlags,v7259=v15545.Static,isStatic=JAMScript.call(TypeScript.hasFlag,TypeScript,[v7258,v7259]),v7260=isStatic;if(v7260)var v20588=context.scopeChain,v15546=v20588.fnc,v7260=null!=v15546;var isInnerStatic=v7260,v7261;if(isInnerStatic){var v23644=
context.scopeChain,v20589=v23644.fnc,v15547=v20589.type;v7261=v15547.memberScope}else{var v15548=context.scopeChain;v7261=v15548.scope}var parentScope=v7261,v20590=context.scopeChain,v15549=v20590.thisType;if(v15549){var v23645=funcDecl.isConstructor,v20591=!v23645,v23648=!v20591;if(v23648)var v23646=funcDecl.fncFlags,v25162=TypeScript.FncFlags,v23647=v25162.ClassMethod,v20591=JAMScript.call(TypeScript.hasFlag,TypeScript,[v23646,v23647]);v15549=v20591}var v7270=v15549;if(v7270){var v7262=context.scopeChain,
instType=v7262.thisType,v23649=instType.typeFlags,v25163=TypeScript.TypeFlags,v23650=v25163.IsClass,v20592=v23649&v23650,v15550=!v20592;if(v15550)var v23651=funcDecl.fncFlags,v25164=TypeScript.FncFlags,v23652=v25164.ClassMethod,v20593=JAMScript.call(TypeScript.hasFlag,TypeScript,[v23651,v23652]),v15550=!v20593;var v7267=v15550;if(v7267){var v20594=JAMScript.call(funcDecl.isMethod,funcDecl,[]),v15551=!v20594,v20595=!v15551;v20595&&(v15551=isStatic);var v7263=v15551,parentScope=v7263?instType.constructorScope:
instType.containedScope}else{var v25165=context.scopeChain,v23653=v25165.previous,v20596=v23653.scope,v15552=v20596.container;if(v15552){var v26374=context.scopeChain,v25953=v26374.previous,v25166=v25953.scope,v23654=v25166.container,v20597=v23654.declAST;if(v20597){var v26712=context.scopeChain,v26650=v26712.previous,v26555=v26650.scope,v26375=v26555.container,v25954=v26375.declAST,v25167=v25954.nodeType,v25955=TypeScript.NodeType,v25168=v25955.FuncDecl,v23655=v25167==v25168;if(v23655)var v26651=
context.scopeChain,v26556=v26651.previous,v26376=v26556.scope,v25956=v26376.container,v25169=v25956.declAST,v23655=v25169.isConstructor;v20597=v23655}v15552=v20597}var v7266=v15552;if(v7266)parentScope=instType.constructorScope;else{var v15553=isStatic;if(v15553)var v20598=context.scopeChain,v15553=v20598.classType;var v7265=v15553;if(v7265)var v15554=context.scopeChain,v7264=v15554.classType,parentScope=v7264.containedScope;else parentScope=instType.containedScope}}container=instType.symbol}else{var v15555=
funcDecl.isConstructor;if(v15555)var v20599=context.scopeChain,v15555=v20599.thisType;var v7269=v15555;if(v7269)var v15556=context.scopeChain,v7268=v15556.thisType,container=v7268.symbol}var v20600=funcDecl.type,v15557=null==v20600,v20603=!v15557;if(v20603)var v25170=funcDecl.type,v23656=v25170.symbol,v20601=v23656.flags,v23657=TypeScript.SymbolFlags,v20602=v23657.TypeSetDuringScopeAssignment,v15557=JAMScript.call(TypeScript.hasFlag,TypeScript,[v20601,v20602]);var v7287=v15557;if(v7287){var v20604=
context.scopeChain,v15558=v20604.fnc;if(v15558)var v23658=context.scopeChain,v20605=v23658.fnc,v15558=v20605.type;var v7272=v15558;if(v7272)var v20606=context.scopeChain,v15559=v20606.fnc,v7271=v15559.type,container=v7271.symbol;var funcScope=null,v7273=context.scopeChain,outerFnc=v7273.fnc,v7274,v15561=funcDecl.name;if(v15561){var v15560=funcDecl.name;v7274=v15560.actualText}else v7274=null;var nameText=v7274,fgSym=null;if(isStatic){var v23659=outerFnc.type,v20607=v23659.members,v15562=null==v20607;
if(v15562)var v20608=JAMScript.call(container.getType,container,[]),v15562=v20608.memberScope;var v7276=v15562;if(v7276){var v7275=outerFnc.type,v20609=container.type,v15563=v20609.memberScope;v7275.members=v15563.valueMembers}var v20610=context.scopeChain,v15564=v20610.fnc,v7277=v15564.type,funcScope=v7277.memberScope,v7278=outerFnc.innerStaticFuncs,v15565=outerFnc.innerStaticFuncs,v7279=v15565.length;JAMScript.set(v7278,v7279,funcDecl)}else var v7280=context.scopeChain,funcScope=v7280.scope;var v15566=
nameText;if(v15566){var v20611="__missing"!=nameText;if(v20611)var v23660=JAMScript.call(funcDecl.isAccessor,funcDecl,[]),v20611=!v23660;v15566=v20611}var v7281=v15566;v7281&&(fgSym=JAMScript.call(funcScope.findLocal,funcScope,[nameText,!1,!1]));var v15567=context.typeFlow,v7282=v15567.checker,v7283=null==fgSym;JAMScript.call(v7282.createFunctionSignature,v7282,[funcDecl,container,funcScope,fgSym,v7283]);var v23661=funcDecl.accessorSymbol,v20612=!v23661;if(v20612){var v25171=funcDecl.fncFlags,v25957=
TypeScript.FncFlags,v25172=v25957.ClassMethod,v23662=v25171&v25172;if(v23662){var v25173=container;if(v25173){var v26377=!fgSym,v26559=!v26377;if(v26559)var v26652=fgSym.declAST,v26557=v26652.nodeType,v26653=TypeScript.NodeType,v26558=v26653.FuncDecl,v26377=v26557!=v26558;var v25958=v26377;v25958&&(v25958=JAMScript.call(funcDecl.isAccessor,funcDecl,[]));v25173=v25958}v23662=v25173}v20612=v23662}var v15568=v20612,v20614=!v15568;if(v20614){var v20613=fgSym;v20613&&(v20613=JAMScript.call(fgSym.isAccessor,
fgSym,[]));v15568=v20613}var v7285=v15568;if(v7285){var v7284=funcDecl,v20615=context.typeFlow,v15569=v20615.checker,v15570=JAMScript.call(container.getType,container,[]),v20616=JAMScript.call(funcDecl.isMethod,funcDecl,[]);v20616&&(v20616=isStatic);var v15571=v20616,v27017=JAMScript.call(v15569.createAccessorSymbol,v15569,[funcDecl,fgSym,v15570,v15571,!0,funcScope,container]);v7284.accessorSymbol=v27017}var v15572=funcDecl.type,v7286=v15572.symbol,v20617=v7286.flags,v23663=TypeScript.SymbolFlags,
v20618=v23663.TypeSetDuringScopeAssignment;v7286.flags=v20617|v20618}var v15573=funcDecl.name;v15573&&(v15573=funcDecl.type);var v7289=v15573;if(v7289){var v7288=funcDecl.name,v15574=funcDecl.type;v7288.sym=v15574.symbol}funcDecl.scopeType=funcDecl.type;var v7290=funcDecl.isOverload;if(!v7290){var v7291=TypeScript.StringHashTable,funcTable=JAMScript.new(v7291,[]),v7292=TypeScript.ScopedMembers,v15575=TypeScript.DualStringHashTable,v20619=TypeScript.StringHashTable,v15576=JAMScript.new(v20619,[]),
v7293=JAMScript.new(v15575,[funcTable,v15576]),funcMembers=JAMScript.new(v7292,[v7293]),v7294=TypeScript.StringHashTable,ambientFuncTable=JAMScript.new(v7294,[]),v7295=TypeScript.ScopedMembers,v15577=TypeScript.DualStringHashTable,v20620=TypeScript.StringHashTable,v15578=JAMScript.new(v20620,[]),v7296=JAMScript.new(v15577,[ambientFuncTable,v15578]),ambientFuncMembers=JAMScript.new(v7295,[v7296]),v7297=TypeScript.StringHashTable,funcStaticTable=JAMScript.new(v7297,[]),v7298=TypeScript.ScopedMembers,
v15579=TypeScript.DualStringHashTable,v20621=TypeScript.StringHashTable,v15580=JAMScript.new(v20621,[]),v7299=JAMScript.new(v15579,[funcStaticTable,v15580]),funcStaticMembers=JAMScript.new(v7298,[v7299]),v7300=TypeScript.StringHashTable,ambientFuncStaticTable=JAMScript.new(v7300,[]),v7301=TypeScript.ScopedMembers,v15581=TypeScript.DualStringHashTable,v20622=TypeScript.StringHashTable,v15582=JAMScript.new(v20622,[]),v7302=JAMScript.new(v15581,[ambientFuncStaticTable,v15582]),ambientFuncStaticMembers=
JAMScript.new(v7301,[v7302]),v20623=context.typeFlow,v15583=v20623.checker,v7303=v15583.locationInfo;funcDecl.unitIndex=v7303.unitIndex;var v7304=TypeScript.SymbolScopeBuilder,locals=JAMScript.new(v7304,[funcMembers,ambientFuncMembers,null,null,parentScope,localContainer]),v7305=TypeScript.SymbolScopeBuilder,statics=JAMScript.new(v7305,[funcStaticMembers,ambientFuncStaticMembers,null,null,parentScope,null]),v15584=funcDecl.isConstructor;if(v15584)var v20624=context.scopeChain,v15584=v20624.thisType;
var v7307=v15584;if(v7307){var v15585=context.scopeChain,v7306=v15585.thisType;v7306.constructorScope=locals}funcDecl.symbols=funcTable;var v15586=JAMScript.call(funcDecl.isSpecialFn,funcDecl,[]),v7326=!v15586;if(v7326){var group=funcDecl.type,signature=funcDecl.signature,v15587=funcDecl.isConstructor,v7308=!v15587;v7308&&(group.containedScope=locals,locals.container=group.symbol,group.memberScope=statics,statics.container=group.symbol);var v7309=context.scopeChain;funcDecl.enclosingFnc=v7309.fnc;
var v7310;if(isStatic){var v15588=context.scopeChain;v7310=v15588.classType}else{var v15589=context.scopeChain;v7310=v15589.thisType}group.enclosingType=v7310;var v7311=ast.type,fgSym=v7311.symbol,v23664=funcDecl.fncFlags,v25174=TypeScript.FncFlags,v23665=v25174.Signature,v20625=v23664&v23665,v23666=TypeScript.FncFlags,v20626=v23666.None,v15590=v20625==v20626;v15590&&(v15590=funcDecl.vars);var v7316=v15590;if(v7316){var v7312=context.typeFlow,v7313=funcDecl.vars;JAMScript.call(v7312.addLocalsFromScope,
v7312,[locals,fgSym,v7313,funcTable,!1]);var v7314=context.typeFlow,v7315=funcDecl.statics;JAMScript.call(v7314.addLocalsFromScope,v7314,[statics,fgSym,v7315,funcStaticTable,!1])}var v7322=signature.parameters;if(v7322)for(var v7317=signature.parameters,len=v7317.length,i=0,v7321=i<len;v7321;){var v7318=signature.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var paramSym=v7318[i];var v15591=context.typeFlow,v7319=v15591.checker,v15592=paramSym.parameter,
v7320=v15592.typeLink;JAMScript.call(v7319.resolveTypeLink,v7319,[locals,v7320,!0]);i+=1;v7321=i<len}var v15593=context.typeFlow,v7323=v15593.checker,v7324=signature.returnType,v7325=JAMScript.call(funcDecl.isSignature,funcDecl,[]);JAMScript.call(v7323.resolveTypeLink,v7323,[locals,v7324,v7325])}var v20627=funcDecl.isConstructor,v15594=!v20627,v20630=!v15594;if(v20630)var v20628=funcDecl.fncFlags,v23667=TypeScript.FncFlags,v20629=v23667.ClassMethod,v15594=JAMScript.call(TypeScript.hasFlag,TypeScript,
[v20628,v20629]);var v7328=v15594;if(v7328){var v7327,v20631=funcDecl.isConstructor;if(v20631)var v23668=funcDecl.fncFlags,v25175=TypeScript.FncFlags,v23669=v25175.ClassMethod,v20631=JAMScript.call(TypeScript.hasFlag,TypeScript,[v23668,v23669]);var v15596=v20631;if(v15596){var v15595=context.scopeChain;v7327=v15595.thisType}else v7327=null;var thisType=v7327;pushAssignScope(locals,context,thisType,null,funcDecl)}var v15597=funcDecl.name;if(v15597)var v20632=funcDecl.fncFlags,v23670=TypeScript.FncFlags,
v20633=v23670.IsFunctionExpression,v15597=JAMScript.call(TypeScript.hasFlag,TypeScript,[v20632,v20633]);var v7332=v15597;if(v7332){var v15598=funcDecl.name,v7331=v15598.sym;if(v7331){var v15599=funcDecl.name,v7329=v15599.actualText,v15600=funcDecl.name,v7330=v15600.sym;JAMScript.call(funcTable.add,funcTable,[v7329,v7330])}}}}function preAssignCatchScopes(ast,context){var catchBlock=ast,v7341=catchBlock.param;if(v7341){var v7341=TypeScript.ScopedMembers,v15601=TypeScript.DualStringHashTable,v20634=
TypeScript.StringHashTable,v20634=JAMScript.new(v20634,[]),v20635=TypeScript.StringHashTable,v20635=JAMScript.new(v20635,[]),v15601=JAMScript.new(v15601,[v20634,v20635]),v7341=JAMScript.new(v7341,[v15601]),v15601=TypeScript.SymbolScopeBuilder,v20634=context.scopeChain,v20634=v20634.scope,v20635=context.scopeChain,v20635=v20635.scope,v20635=v20635.container,v7341=JAMScript.new(v15601,[v7341,null,null,null,v20634,v20635]);catchBlock.containedScope=v7341;catchBlock=context.scopeChain;catchBlock=catchBlock.thisType;
v15601=context.scopeChain;v15601=v15601.classType;v20634=context.scopeChain;v20634=v20634.fnc;pushAssignScope(v7341,context,catchBlock,v15601,v20634)}}function preAssignScopes(ast,parent,walker){var context=walker.state;parent=!0;if(ast){var v15609=ast.nodeType,v20637=TypeScript.NodeType,v20637=v20637.List;(v15609=v15609==v20637)?(v15609=ast,context=context.scopeChain,v15609.enclosingScope=context.scope):(v15609=ast.nodeType,v20637=TypeScript.NodeType,v20637=v20637.ModuleDeclaration,(v15609=v15609==
v20637)?preAssignModuleScopes(ast,context):(v15609=ast.nodeType,v20637=TypeScript.NodeType,v20637=v20637.ClassDeclaration,(v15609=v15609==v20637)?preAssignClassScopes(ast,context):(v15609=ast.nodeType,v20637=TypeScript.NodeType,v20637=v20637.InterfaceDeclaration,(v15609=v15609==v20637)?preAssignInterfaceScopes(ast,context):(v15609=ast.nodeType,v20637=TypeScript.NodeType,v20637=v20637.With,(v15609=v15609==v20637)?preAssignWithScopes(ast,context):(v15609=ast.nodeType,v20637=TypeScript.NodeType,v20637=
v20637.FuncDecl,(v15609=v15609==v20637)?preAssignFuncDeclScopes(ast,context):(v15609=ast.nodeType,v20637=TypeScript.NodeType,v20637=v20637.Catch,(v15609=v15609==v20637)?preAssignCatchScopes(ast,context):(context=ast.nodeType,v15609=TypeScript.NodeType,v15609=v15609.TypeRef,(context=context==v15609)&&(parent=!1))))))))}walker=walker.options;walker.goChildren=parent;return ast}function postAssignScopes(ast,parent,walker){var context=walker.state;parent=!0;if(ast){var v15625=ast.nodeType,v20645=TypeScript.NodeType,
v20645=v20645.ModuleDeclaration;if(v15625=v15625==v20645){if(popAssignScope(context),v15625=context.modDeclChain,JAMScript.call(v15625.pop,v15625,[]),v15625=context.modDeclChain,v15625=v15625.length,v15625=1<=v15625)v15625=context.typeFlow,v15625=v15625.checker,context=v20645=context.modDeclChain,context=context.length,context-=1,v15625.currentModDecl=v20645[context]}else if(v15625=ast.nodeType,v20645=TypeScript.NodeType,v20645=v20645.ClassDeclaration,v15625=v15625==v20645)popAssignScope(context);
else if(v15625=ast.nodeType,v20645=TypeScript.NodeType,v20645=v20645.InterfaceDeclaration,v15625=v15625==v20645)popAssignScope(context);else if(v15625=ast.nodeType,v20645=TypeScript.NodeType,v20645=v20645.With,v15625=v15625==v20645)popAssignScope(context);else if(v15625=ast.nodeType,v20645=TypeScript.NodeType,v20645=v20645.FuncDecl,v15625=v15625==v20645){var v15625=ast,v20645=v15625.isConstructor,v20645=!v20645,v23675=!v20645;v23675&&(v20645=v15625.fncFlags,v23675=TypeScript.FncFlags,v23675=v23675.ClassMethod,
v20645=JAMScript.call(TypeScript.hasFlag,TypeScript,[v20645,v23675]));v20645&&(v15625=v15625.isOverload,v20645=!v15625);(v15625=v20645)&&popAssignScope(context)}else v15625=ast.nodeType,v20645=TypeScript.NodeType,v20645=v20645.Catch,(v15625=v15625==v20645)?(v15625=ast,(v15625=v15625.param)&&popAssignScope(context)):parent=!1}walker=walker.options;walker.goChildren=parent;return ast}var AssignScopeContext=v676();TypeScript.AssignScopeContext=AssignScopeContext;TypeScript.pushAssignScope=pushAssignScope;
TypeScript.popAssignScope=popAssignScope;TypeScript.instanceCompare=instanceCompare;TypeScript.instanceFilterStop=instanceFilterStop;var ScopeSearchFilter=v679();TypeScript.ScopeSearchFilter=ScopeSearchFilter;AssignScopeContext=TypeScript;ScopeSearchFilter=JAMScript.new(ScopeSearchFilter,[instanceCompare,instanceFilterStop]);AssignScopeContext.instanceFilter=ScopeSearchFilter;TypeScript.preAssignModuleScopes=preAssignModuleScopes;TypeScript.preAssignClassScopes=preAssignClassScopes;TypeScript.preAssignInterfaceScopes=
preAssignInterfaceScopes;TypeScript.preAssignWithScopes=preAssignWithScopes;TypeScript.preAssignFuncDeclScopes=preAssignFuncDeclScopes;TypeScript.preAssignCatchScopes=preAssignCatchScopes;TypeScript.preAssignScopes=preAssignScopes;TypeScript.postAssignScopes=postAssignScopes}
function v675(){var TypeScript=v12356;function v674(){function v673(message){var v7365=this.reportError;v7365&&JAMScript.call(this.reportError,this,[message])}function v672(){var rtok;JAMScript.call(this.tokenStart,this,[]);var v27019=JAMScript.call(this.peekChar,this,[]);this.ch=v27019;var v15642=this.pos,v15643=this.len,v7528=v15642<v15643;start:for(;v7528;){var v20655=this.ch;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v15644=lexIdStartTable[v20655];var v20657=
!v15644;if(v20657){var v23676=this.ch,v23677=TypeScript.LexCodeBSL,v20656=v23676==v23677,v23679=!v20656;if(v23679){var v25177=this.ch,v25178=TypeScript.LexCodeASCIIChars,v23678=v25177>=v25178;if(v23678)var v25179=this.ch,v23678=LexIsUnicodeIdStart(v25179);v20656=v23678}v15644=v20656}var v7527=v15644;if(v7527)return JAMScript.call(this.scanIdentifier,this,[]);var v15645=this.ch,v15646=TypeScript.LexCodeSpace,v7526=v15645==v15646;if(v7526){var v15647=this.interveningWhitespace,v7366=!v15647;v7366&&
(this.interveningWhitespacePos=this.pos);var v15648=this.ch,v15649=TypeScript.LexCodeSpace,v7367=v15648==v15649;do{JAMScript.call(this.nextChar,this,[]);var v15650=this.ch,v15651=TypeScript.LexCodeSpace,v7367=v15650==v15651}while(v7367);var v15652=this.mode,v15653=LexMode.Line,v7373=v15652==v15653;if(v7373){var v7368=this.src,v7369=this.startPos,v7370=this.pos,whitespaceText=JAMScript.call(v7368.substring,v7368,[v7369,v7370]),v7371=TypeScript.WhitespaceToken,v15654=TypeScript.TokenID,v7372=v15654.Whitespace;
return JAMScript.new(v7371,[v7372,whitespaceText])}JAMScript.call(this.tokenStart,this,[]);this.interveningWhitespace=!0}else{var v15655=this.ch,v15656=TypeScript.LexCodeSLH,v7525=v15655==v15656;if(v7525){JAMScript.call(this.nextChar,this,[]);var commentText,v15657=this.ch,v15658=TypeScript.LexCodeSLH,v7397=v15657==v15658;if(v7397){var v15659=this.interveningWhitespace,v7375=!v15659;if(v7375){var v7374=this.pos;this.interveningWhitespacePos=v7374-1}var v7376=this.pos,commentStartPos=v7376-1,commentStartLine=
this.line;JAMScript.call(this.finishSinglelineComment,this,[]);var v7377=this.src,v7378=this.pos;commentText=JAMScript.call(v7377.substring,v7377,[commentStartPos,v7378]);var v7379=TypeScript.CommentToken,v15660=TypeScript.TokenID,v7380=v15660.Comment,commentToken=JAMScript.new(v7379,[v7380,commentText,!1,commentStartPos,commentStartLine,!1]),v7381=this.scanComments;if(v7381)return this.startPos=commentStartPos,commentToken;JAMScript.call(this.pushComment,this,[commentToken]);this.interveningWhitespace=
!0}else{var v15661=this.ch,v15662=TypeScript.LexCodeMUL,v7396=v15661==v15662;if(v7396){var v15663=this.interveningWhitespace,v7383=!v15663;if(v7383){var v7382=this.pos;this.interveningWhitespacePos=v7382-1}var v7384=this.pos,commentStartPos=v7384-1,commentStartLine=this.line;JAMScript.call(this.nextChar,this,[]);JAMScript.call(this.finishMultilineComment,this,[]);var v7385=this.src,v7386=this.pos;commentText=JAMScript.call(v7385.substring,v7385,[commentStartPos,v7386]);var v7387=JAMScript.call(this.peekChar,
this,[]),endsLine=JAMScript.call(this.endsLine,this,[v7387]),v7388=TypeScript.CommentToken,v15664=TypeScript.TokenID,v7389=v15664.Comment,commentToken=JAMScript.new(v7388,[v7389,commentText,!0,commentStartPos,commentStartLine,endsLine]),v7390=this.scanComments;if(v7390)return this.startPos=commentStartPos,commentToken;JAMScript.call(this.pushComment,this,[commentToken]);this.interveningWhitespace=!0}else{var regexTok=JAMScript.call(this.speculateRegex,this,[]);if(regexTok)return regexTok;var v20658=
this.pos,v15665=JAMScript.call(this.peekCharAt,this,[v20658]),v15666=TypeScript.LexCodeEQ,v7395=v15665==v15666;if(v7395){JAMScript.call(this.nextChar,this,[]);var v7391=TypeScript.staticTokens,v15667=TypeScript.TokenID,v7392=v15667.SlashEquals;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7391[v7392]}else{var v7393=TypeScript.staticTokens,v15668=TypeScript.TokenID,v7394=v15668.Slash;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7393[v7394]}}}}else{var v15669=
this.ch,v15670=TypeScript.LexCodeSMC,v7524=v15669==v15670;if(v7524){JAMScript.call(this.nextChar,this,[]);var v7398=TypeScript.staticTokens,v15671=TypeScript.TokenID,v7399=v15671.Semicolon;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7398[v7399]}else{var v20659=this.ch,v20660=TypeScript.LexCodeAPO,v15672=v20659==v20660,v20663=!v15672;if(v20663)var v20661=this.ch,v20662=TypeScript.LexCodeQUO,v15672=v20661==v20662;var v7523=v15672;if(v7523)return JAMScript.call(this.scanStringConstant,
this,[]);var v15673=this.ch;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v7522=autoToken[v15673];if(v7522){var v7400=this.ch;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var atok=autoToken[v7400];var v15674=atok.tokenId,v20664=TypeScript.TokenID,v15675=v20664.OpenBrace,v7402=v15674==v15675;if(v7402){var v15676=this.leftCurlyCount;this.leftCurlyCount=v15676+1}else{var v15677=atok.tokenId,v20665=TypeScript.TokenID,v15678=
v20665.CloseBrace,v7401=v15677==v15678;if(v7401){var v15679=this.rightCurlyCount;this.rightCurlyCount=v15679+1}}JAMScript.call(this.nextChar,this,[]);return atok}var v20666=this.ch,v20667=TypeScript.LexCode_0,v15680=v20666>=v20667;if(v15680)var v20668=this.ch,v20669=TypeScript.LexCode_9,v15680=v20668<=v20669;var v7521=v15680;if(v7521){if(rtok=JAMScript.call(this.scanNumber,this,[]))return rtok;JAMScript.call(this.nextChar,this,[]);var v7403=TypeScript.staticTokens,v15681=TypeScript.TokenID,v7404=
v15681.Error;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7403[v7404]}else{var v7520=this.ch;switch(v7520){case TypeScript.LexCodeTAB:case TypeScript.LexCodeVTAB:var v15682=this.interveningWhitespace,v7405=!v15682;v7405&&(this.interveningWhitespacePos=this.pos);var v15683=this.mode,v15684=LexMode.Line,v7412=v15683==v15684;if(v7412){var v20670=this.ch,v20671=TypeScript.LexCodeSpace,v15685=v20670==v20671,v20673=!v15685;if(v20673)var v20672=this.ch,v15685=
9==v20672;var v7406=v15685;do{JAMScript.call(this.nextChar,this,[]);var v20674=this.ch,v20675=TypeScript.LexCodeSpace,v15686=v20674==v20675,v20677=!v15686;if(v20677)var v20676=this.ch,v15686=9==v20676;v7406=v15686}while(v7406);var v7407=this.src,v7408=this.startPos,v7409=this.pos,wsText=JAMScript.call(v7407.substring,v7407,[v7408,v7409]),v7410=TypeScript.WhitespaceToken,v15687=TypeScript.TokenID,v7411=v15687.Whitespace;return JAMScript.new(v7410,[v7411,wsText])}this.interveningWhitespace=!0;case 255:case 254:case 239:case 187:case 191:case TypeScript.LexCodeLS:case TypeScript.LexCodePS:case TypeScript.LexCodeNWL:case TypeScript.LexCodeRET:var v15688=
this.ch,v15689=TypeScript.LexCodeNWL,v7416=v15688==v15689;if(v7416){JAMScript.call(this.newLine,this,[]);var v15690=this.mode,v15691=LexMode.Line,v7415=v15690==v15691;if(v7415){var v7413=TypeScript.staticTokens,v15692=TypeScript.TokenID,v7414=v15692.EndOfFile;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7413[v7414]}}var v15693=this.interveningWhitespace,v7417=!v15693;v7417&&(this.interveningWhitespacePos=this.pos);JAMScript.call(this.nextChar,this,[]);
JAMScript.call(this.tokenStart,this,[]);this.interveningWhitespace=!0;break;case TypeScript.LexCodeDOT:var v23680=this.pos,v20678=v23680+1,v15694=JAMScript.call(this.peekCharAt,this,[v20678]),v15695=TypeScript.LexCodeDOT,v7425=v15694==v15695;if(v7425){var v23681=this.pos,v20679=v23681+2,v15696=JAMScript.call(this.peekCharAt,this,[v20679]),v15697=TypeScript.LexCodeDOT,v7422=v15696==v15697;if(v7422){JAMScript.call(this.advanceChar,this,[3]);var v7418=TypeScript.staticTokens,v15698=TypeScript.TokenID,
v7419=v15698.DotDotDot;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7418[v7419]}else{JAMScript.call(this.nextChar,this,[]);var v7420=TypeScript.staticTokens,v15699=TypeScript.TokenID,v7421=v15699.Dot;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7420[v7421]}}else{JAMScript.call(this.nextChar,this,[]);if(rtok=JAMScript.call(this.scanFraction,this,[]))return rtok;var v7423=TypeScript.staticTokens,v15700=TypeScript.TokenID,
v7424=v15700.Dot;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7423[v7424]}case TypeScript.LexCodeEQ:var v23682=this.pos,v20680=v23682+1,v15701=JAMScript.call(this.peekCharAt,this,[v20680]),v15702=TypeScript.LexCodeEQ,v7436=v15701==v15702;if(v7436){var v23683=this.pos,v20681=v23683+2,v15703=JAMScript.call(this.peekCharAt,this,[v20681]),v15704=TypeScript.LexCodeEQ,v7430=v15703==v15704;if(v7430){JAMScript.call(this.advanceChar,this,[3]);var v7426=TypeScript.staticTokens,
v15705=TypeScript.TokenID,v7427=v15705.EqualsEqualsEquals;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7426[v7427]}else{JAMScript.call(this.advanceChar,this,[2]);var v7428=TypeScript.staticTokens,v15706=TypeScript.TokenID,v7429=v15706.EqualsEquals;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7428[v7429]}}else{var v23684=this.pos,v20682=v23684+1,v15707=JAMScript.call(this.peekCharAt,this,[v20682]),v15708=TypeScript.LexCodeGT,
v7435=v15707==v15708;if(v7435){JAMScript.call(this.advanceChar,this,[2]);var v7431=TypeScript.staticTokens,v15709=TypeScript.TokenID,v7432=v15709.EqualsGreaterThan;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7431[v7432]}else{JAMScript.call(this.nextChar,this,[]);var v7433=TypeScript.staticTokens,v15710=TypeScript.TokenID,v7434=v15710.Equals;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7433[v7434]}}case TypeScript.LexCodeBNG:var v23685=
this.pos,v20683=v23685+1,v15711=JAMScript.call(this.peekCharAt,this,[v20683]),v15712=TypeScript.LexCodeEQ,v7444=v15711==v15712;if(v7444){var v23686=this.pos,v20684=v23686+2,v15713=JAMScript.call(this.peekCharAt,this,[v20684]),v15714=TypeScript.LexCodeEQ,v7441=v15713==v15714;if(v7441){JAMScript.call(this.advanceChar,this,[3]);var v7437=TypeScript.staticTokens,v15715=TypeScript.TokenID,v7438=v15715.ExclamationEqualsEquals;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7437[v7438]}else{JAMScript.call(this.advanceChar,
this,[2]);var v7439=TypeScript.staticTokens,v15716=TypeScript.TokenID,v7440=v15716.ExclamationEquals;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7439[v7440]}}else{JAMScript.call(this.nextChar,this,[]);var v7442=TypeScript.staticTokens,v15717=TypeScript.TokenID,v7443=v15717.Exclamation;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7442[v7443]}case TypeScript.LexCodePLS:var v23687=this.pos,v20685=v23687+1,v15718=
JAMScript.call(this.peekCharAt,this,[v20685]),v15719=TypeScript.LexCodeEQ,v7452=v15718==v15719;if(v7452){JAMScript.call(this.advanceChar,this,[2]);var v7445=TypeScript.staticTokens,v15720=TypeScript.TokenID,v7446=v15720.PlusEquals;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7445[v7446]}else{var v23688=this.pos,v20686=v23688+1,v15721=JAMScript.call(this.peekCharAt,this,[v20686]),v15722=TypeScript.LexCodePLS,v7451=v15721==v15722;if(v7451){JAMScript.call(this.advanceChar,
this,[2]);var v7447=TypeScript.staticTokens,v15723=TypeScript.TokenID,v7448=v15723.PlusPlus;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7447[v7448]}else{JAMScript.call(this.nextChar,this,[]);var v7449=TypeScript.staticTokens,v15724=TypeScript.TokenID,v7450=v15724.Plus;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7449[v7450]}}case TypeScript.LexCodeMIN:var v23689=this.pos,v20687=v23689+1,v15725=JAMScript.call(this.peekCharAt,
this,[v20687]),v15726=TypeScript.LexCodeEQ,v7460=v15725==v15726;if(v7460){JAMScript.call(this.advanceChar,this,[2]);var v7453=TypeScript.staticTokens,v15727=TypeScript.TokenID,v7454=v15727.MinusEquals;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7453[v7454]}else{var v23690=this.pos,v20688=v23690+1,v15728=JAMScript.call(this.peekCharAt,this,[v20688]),v15729=TypeScript.LexCodeMIN,v7459=v15728==v15729;if(v7459){JAMScript.call(this.advanceChar,this,[2]);var v7455=
TypeScript.staticTokens,v15730=TypeScript.TokenID,v7456=v15730.MinusMinus;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7455[v7456]}else{JAMScript.call(this.nextChar,this,[]);var v7457=TypeScript.staticTokens,v15731=TypeScript.TokenID,v7458=v15731.Minus;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7457[v7458]}}case TypeScript.LexCodeMUL:var v23691=this.pos,v20689=v23691+1,v15732=JAMScript.call(this.peekCharAt,
this,[v20689]),v15733=TypeScript.LexCodeEQ,v7465=v15732==v15733;if(v7465){JAMScript.call(this.advanceChar,this,[2]);var v7461=TypeScript.staticTokens,v15734=TypeScript.TokenID,v7462=v15734.AsteriskEquals;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7461[v7462]}else{JAMScript.call(this.nextChar,this,[]);var v7463=TypeScript.staticTokens,v15735=TypeScript.TokenID,v7464=v15735.Asterisk;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7463[v7464]}case TypeScript.LexCodePCT:var v23692=
this.pos,v20690=v23692+1,v15736=JAMScript.call(this.peekCharAt,this,[v20690]),v15737=TypeScript.LexCodeEQ,v7470=v15736==v15737;if(v7470){JAMScript.call(this.advanceChar,this,[2]);var v7466=TypeScript.staticTokens,v15738=TypeScript.TokenID,v7467=v15738.PercentEquals;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7466[v7467]}else{JAMScript.call(this.nextChar,this,[]);var v7468=TypeScript.staticTokens,v15739=TypeScript.TokenID,v7469=v15739.Percent;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7468[v7469]}case TypeScript.LexCodeLT:var v23693=
this.pos,v20691=v23693+1,v15740=JAMScript.call(this.peekCharAt,this,[v20691]),v15741=TypeScript.LexCodeLT,v7481=v15740==v15741;if(v7481){var v23694=this.pos,v20692=v23694+2,v15742=JAMScript.call(this.peekCharAt,this,[v20692]),v15743=TypeScript.LexCodeEQ,v7475=v15742==v15743;if(v7475){JAMScript.call(this.advanceChar,this,[3]);var v7471=TypeScript.staticTokens,v15744=TypeScript.TokenID,v7472=v15744.LessThanLessThanEquals;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7471[v7472]}else{JAMScript.call(this.advanceChar,
this,[2]);var v7473=TypeScript.staticTokens,v15745=TypeScript.TokenID,v7474=v15745.LessThanLessThan;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7473[v7474]}}else{var v23695=this.pos,v20693=v23695+1,v15746=JAMScript.call(this.peekCharAt,this,[v20693]),v15747=TypeScript.LexCodeEQ,v7480=v15746==v15747;if(v7480){JAMScript.call(this.advanceChar,this,[2]);var v7476=TypeScript.staticTokens,v15748=TypeScript.TokenID,v7477=v15748.LessThanEquals;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7476[v7477]}else{JAMScript.call(this.nextChar,
this,[]);var v7478=TypeScript.staticTokens,v15749=TypeScript.TokenID,v7479=v15749.LessThan;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7478[v7479]}}case TypeScript.LexCodeGT:var v23696=this.pos,v20694=v23696+1,v15750=JAMScript.call(this.peekCharAt,this,[v20694]),v15751=TypeScript.LexCodeGT,v7498=v15750==v15751;if(v7498){var v23697=this.pos,v20695=v23697+2,v15752=JAMScript.call(this.peekCharAt,this,[v20695]),v15753=TypeScript.LexCodeEQ,v7492=v15752==v15753;
if(v7492){JAMScript.call(this.advanceChar,this,[3]);var v7482=TypeScript.staticTokens,v15754=TypeScript.TokenID,v7483=v15754.GreaterThanGreaterThanEquals;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7482[v7483]}else{var v23698=this.pos,v20696=v23698+2,v15755=JAMScript.call(this.peekCharAt,this,[v20696]),v15756=TypeScript.LexCodeGT,v7491=v15755==v15756;if(v7491){var v23699=this.pos,v20697=v23699+3,v15757=JAMScript.call(this.peekCharAt,this,[v20697]),v15758=
TypeScript.LexCodeEQ,v7488=v15757==v15758;if(v7488){JAMScript.call(this.advanceChar,this,[4]);var v7484=TypeScript.staticTokens,v15759=TypeScript.TokenID,v7485=v15759.GreaterThanGreaterThanGreaterThanEquals;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7484[v7485]}else{JAMScript.call(this.advanceChar,this,[3]);var v7486=TypeScript.staticTokens,v15760=TypeScript.TokenID,v7487=v15760.GreaterThanGreaterThanGreaterThan;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7486[v7487]}}else{JAMScript.call(this.advanceChar,
this,[2]);var v7489=TypeScript.staticTokens,v15761=TypeScript.TokenID,v7490=v15761.GreaterThanGreaterThan;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7489[v7490]}}}else{var v23700=this.pos,v20698=v23700+1,v15762=JAMScript.call(this.peekCharAt,this,[v20698]),v15763=TypeScript.LexCodeEQ,v7497=v15762==v15763;if(v7497){JAMScript.call(this.advanceChar,this,[2]);var v7493=TypeScript.staticTokens,v15764=TypeScript.TokenID,v7494=v15764.GreaterThanEquals;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7493[v7494]}else{JAMScript.call(this.nextChar,
this,[]);var v7495=TypeScript.staticTokens,v15765=TypeScript.TokenID,v7496=v15765.GreaterThan;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7495[v7496]}}case TypeScript.LexCodeXOR:var v23701=this.pos,v20699=v23701+1,v15766=JAMScript.call(this.peekCharAt,this,[v20699]),v15767=TypeScript.LexCodeEQ,v7503=v15766==v15767;if(v7503){JAMScript.call(this.advanceChar,this,[2]);var v7499=TypeScript.staticTokens,v15768=TypeScript.TokenID,v7500=v15768.CaretEquals;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7499[v7500]}else{JAMScript.call(this.nextChar,
this,[]);var v7501=TypeScript.staticTokens,v15769=TypeScript.TokenID,v7502=v15769.Caret;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7501[v7502]}case TypeScript.LexCodeBAR:var v23702=this.pos,v20700=v23702+1,v15770=JAMScript.call(this.peekCharAt,this,[v20700]),v15771=TypeScript.LexCodeEQ,v7511=v15770==v15771;if(v7511){JAMScript.call(this.advanceChar,this,[2]);var v7504=TypeScript.staticTokens,v15772=TypeScript.TokenID,v7505=v15772.BarEquals;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7504[v7505]}else{var v23703=
this.pos,v20701=v23703+1,v15773=JAMScript.call(this.peekCharAt,this,[v20701]),v15774=TypeScript.LexCodeBAR,v7510=v15773==v15774;if(v7510){JAMScript.call(this.advanceChar,this,[2]);var v7506=TypeScript.staticTokens,v15775=TypeScript.TokenID,v7507=v15775.BarBar;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7506[v7507]}else{JAMScript.call(this.nextChar,this,[]);var v7508=TypeScript.staticTokens,v15776=TypeScript.TokenID,v7509=v15776.Bar;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7508[v7509]}}case TypeScript.LexCodeAMP:var v23704=
this.pos,v20702=v23704+1,v15777=JAMScript.call(this.peekCharAt,this,[v20702]),v15778=TypeScript.LexCodeEQ,v7519=v15777==v15778;if(v7519){JAMScript.call(this.advanceChar,this,[2]);var v7512=TypeScript.staticTokens,v15779=TypeScript.TokenID,v7513=v15779.AmpersandEquals;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7512[v7513]}else{var v23705=this.pos,v20703=v23705+1,v15780=JAMScript.call(this.peekCharAt,this,[v20703]),v15781=TypeScript.LexCodeAMP,v7518=v15780==
v15781;if(v7518){JAMScript.call(this.advanceChar,this,[2]);var v7514=TypeScript.staticTokens,v15782=TypeScript.TokenID,v7515=v15782.AmpersandAmpersand;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7514[v7515]}else{JAMScript.call(this.nextChar,this,[]);var v7516=TypeScript.staticTokens,v15783=TypeScript.TokenID,v7517=v15783.And;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7516[v7517]}}default:JAMScript.call(this.reportScannerError,
this,["Invalid character"]),JAMScript.call(this.nextChar,this,[])}}}}}var v15784=this.pos,v15785=this.len,v7528=v15784<v15785}var v7529=TypeScript.staticTokens,v15786=TypeScript.TokenID,v7530=v15786.EndOfFile;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7529[v7530]}function v671(){for(var hasEscape=!1,v7531=this.ch,v7532=TypeScript.LexCodeBSL,v7531=v7531==v7532;;){v7532=this.ch;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7532=
lexIdStartTable[v7532];var v20706=!v7532;v20706&&(v7532=this.ch,v7532=LexIsDigit(v7532),v20706=!v7532)&&(v7532=this.ch,v20706=TypeScript.LexCodeASCIIChars,(v7532=v7532>=v20706)&&(v7532=JAMScript.call(this.isValidUnicodeIdentifierChar,this,[])));for(;v7532;){JAMScript.call(this.nextChar,this,[]);v7532=this.ch;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7532=lexIdStartTable[v7532];if(v20706=!v7532)if(v7532=this.ch,v7532=LexIsDigit(v7532),v20706=!v7532)v7532=this.ch,
v20706=TypeScript.LexCodeASCIIChars,(v7532=v7532>=v20706)&&(v7532=JAMScript.call(this.isValidUnicodeIdentifierChar,this,[]))}v7532=this.ch;v20706=TypeScript.LexCodeBSL;if(v7532=v7532==v20706){JAMScript.call(this.nextChar,this,[]);hasEscape=this.ch;v7532=TypeScript.LexCode_u;if(hasEscape=hasEscape==v7532){JAMScript.call(this.nextChar,this,[]);hasEscape=0;for(v7532=4>hasEscape;v7532;){v7532=this.ch;if(v7532=JAMScript.call(this.IsHexDigit,this,[v7532]))JAMScript.call(this.nextChar,this,[]);else{JAMScript.call(this.reportScannerError,
this,["Invalid Unicode escape sequence"]);var v7534=TypeScript.staticTokens,v7531=TypeScript.TokenID,v7531=v7531.Error;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7534[v7531]}hasEscape+=1;v7532=4>hasEscape}hasEscape=this.src;v7532=this.pos;v7532-=4;v20706=this.pos;hasEscape=JAMScript.call(hasEscape.substring,hasEscape,[v7532,v20706]);hasEscape=parseInt(hasEscape,16);introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7532=
lexIdStartTable[hasEscape];if(v20706=!v7532)if((v7532=!v7531)&&(v7532=LexIsDigit(hasEscape)),v20706=!v7532)if(v7532=TypeScript.LexCodeASCIIChars,v7532=hasEscape>=v7532)if(v7532=LexIsUnicodeIdStart(hasEscape),v20706=!v7532)(v7531=!v7531)&&(v7531=LexIsUnicodeDigit(hasEscape)),v7532=v7531;v7531=v7532;if(!v7531){JAMScript.call(this.reportScannerError,this,["Invalid identifier character"]);v7534=TypeScript.staticTokens;v7531=TypeScript.TokenID;v7531=v7531.Error;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7534[v7531]}hasEscape=
!0;v7531=!1;continue}JAMScript.call(this.reportScannerError,this,["Invalid Unicode escape sequence"]);v7534=TypeScript.staticTokens;v7531=TypeScript.TokenID;v7531=v7531.Error;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7534[v7531]}break}v7531=this.src;v7532=this.startPos;v20706=this.pos;v7531=JAMScript.call(v7531.substring,v7531,[v7532,v20706]);if(v7532=!hasEscape)v7534=TypeScript.LexKeywordTable,v7532=v7534=JAMScript.call(v7534.lookup,v7534,[v7531]),
v7532=null!=v7532;if(v7532){v7531=TypeScript.staticTokens;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v7531[v7534]}else return v7534=TypeScript.IdentifierToken,JAMScript.new(v7534,[v7531,hasEscape])}function v670(){var endCode=this.ch;JAMScript.call(this.nextChar,this,[]);scanStringConstantLoop:for(;;){var v7560=this.ch;switch(v7560){case TypeScript.LexEOF:JAMScript.call(this.reportScannerError,this,["Unterminated string constant"]);break scanStringConstantLoop;
case TypeScript.LexCodeLS:case TypeScript.LexCodePS:this.seenUnicodeChar=!0;case TypeScript.LexCodeRET:case TypeScript.LexCodeNWL:JAMScript.call(this.reportScannerError,this,["Unterminated string constant"]);break scanStringConstantLoop;case TypeScript.LexCodeAPO:case TypeScript.LexCodeQUO:v7560=this.ch;if(v7560=v7560==endCode){JAMScript.call(this.nextChar,this,[]);break scanStringConstantLoop}break;case TypeScript.LexCodeBSL:switch(JAMScript.call(this.nextChar,this,[]),v7560=this.ch,v7560){case TypeScript.LexCodeAPO:case TypeScript.LexCodeQUO:case TypeScript.LexCodeBSL:JAMScript.call(this.nextChar,
this,[]);continue scanStringConstantLoop;case TypeScript.LexCodeLS:case TypeScript.LexCodePS:this.seenUnicodeChar=!0;case TypeScript.LexCodeRET:case TypeScript.LexCodeNWL:var v7560=this.ch,v20715=TypeScript.LexCodeRET;if(v7560=v7560==v20715)v7560=this.pos,v7560+=1,v7560=JAMScript.call(this.peekCharAt,this,[v7560]),v20715=TypeScript.LexCodeNWL,v7560=v7560==v20715;v7560&&JAMScript.call(this.nextChar,this,[]);JAMScript.call(this.nextChar,this,[]);JAMScript.call(this.newLine,this,[]);v7560=this.mode;
v20715=LexMode.Line;if(v7560=v7560==v20715){v7560=TypeScript.LexCodeAPO;this.lexState=endCode=(endCode=endCode==v7560)?LexState.InMultilineSingleQuoteString:LexState.InMultilineDoubleQuoteString;break scanStringConstantLoop}break;case TypeScript.LexCode_x:case TypeScript.LexCode_u:v7560=this.ch;v20715=TypeScript.LexCode_x;v7560=(v7560=v7560==v20715)?2:4;JAMScript.call(this.nextChar,this,[]);for(var v20715=0,v7558=v20715<v7560;v7558;){v7558=this.ch;if(v7558=JAMScript.call(this.IsHexDigit,this,[v7558]))JAMScript.call(this.nextChar,
this,[]);else{JAMScript.call(this.reportScannerError,this,["Invalid Unicode escape sequence"]);break}v20715+=1;v7558=v20715<v7560}continue scanStringConstantLoop}}v7560=this.ch;v20715=TypeScript.LexCodeASCIIChars;if(v7560=v7560>=v20715)this.seenUnicodeChar=!0;JAMScript.call(this.nextChar,this,[])}endCode=TypeScript.StringLiteralToken;v7560=this.src;v20715=this.startPos;v7558=this.pos;v7560=JAMScript.call(v7560.substring,v7560,[v20715,v7558]);return JAMScript.new(endCode,[v7560])}function v669(){var v15814=
this.ch,v15814=LexIsUnicodeIdStart(v15814),v15816=!v15814;v15816&&(v15814=this.ch,v15814=LexIsUnicodeDigit(v15814));var v15816=this.seenUnicodeChar,v15817=!v15816;v15817&&(v15816=v15814);this.seenUnicodeChar=v15816;return v15814}function v668(){this.prevLine=this.line;var v27020=JAMScript.call(this.innerScan,this,[]);this.prevTok=v27020;if(v27020=this.saveScan){var v27020=this.saveScan,v7567=this.prevTok;JAMScript.call(v27020.addToken,v27020,[v7567,this])}return this.prevTok}function v667(){var v20721=
this.lexState,v20722=LexState.InMultilineComment;if(v20721=v20721==v20722)v20721=this.scanComments;if(v20721){this.ch=v20721=JAMScript.call(this.peekChar,this,[]);v20721=this.line;JAMScript.call(this.finishMultilineComment,this,[]);var v20722=this.startPos,v15820=this.pos;if(v20722=v20722<v15820){var v20722=this.src,v15820=this.startPos,v7571=this.pos,v20722=JAMScript.call(v20722.substring,v20722,[v15820,v7571]);JAMScript.call(this.tokenStart,this,[]);var v15820=TypeScript.CommentToken,v7571=TypeScript.TokenID,
v7571=v7571.Comment,v7574=this.startPos;return JAMScript.new(v15820,[v7571,v20722,!0,v7574,v20721,!0])}v20721=TypeScript.staticTokens;v20722=TypeScript.TokenID;v20722=v20722.EndOfFile;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v20721[v20722]}else{v20721=this.lexState;v20722=LexState.InMultilineSingleQuoteString;if(v20721=v20721==v20722)v20721=this.pos,v20722=this.len,v20721=v20721<v20722;if(v20721)return this.ch=TypeScript.LexCodeAPO,this.lexState=LexState.Start,
JAMScript.call(this.scanStringConstant,this,[]);v20721=this.lexState;v20722=LexState.InMultilineDoubleQuoteString;if(v20721=v20721==v20722)v20721=this.pos,v20722=this.len,v20721=v20721<v20722;if(v20721)return this.ch=TypeScript.LexCodeQUO,this.lexState=LexState.Start,JAMScript.call(this.scanStringConstant,this,[])}this.prevLine=this.line;v20721=JAMScript.call(this.innerScan,this,[]);v20722=v20721.tokenId;v15820=TypeScript.TokenID;v15820=v15820.Whitespace;if(v20722=v20722!=v15820)this.prevTok=v20721;
return v20721}function v666(){var prevLine=this.prevLine,line=this.line,col=this.col,pos=this.pos,startPos=this.startPos,startCol=this.startCol,startLine=this.startLine,ch=this.ch,prevTok=this.prevTok,lexState=this.lexState,interveningWhitespace=this.interveningWhitespace,interveningWhitespacePos=this.interveningWhitespacePos,leftCurlyCount=this.leftCurlyCount,rightCurlyCount=this.rightCurlyCount,seenUnicodeChar=this.seenUnicodeChar,seenUnicodeCharInComment=this.seenUnicodeCharInComment,v7582=this.commentStack,
v7582=v7582.length,lookAheadToken=JAMScript.call(this.scan,this,[]);this.prevLine=prevLine;this.line=line;this.col=col;this.pos=pos;this.startPos=startPos;this.startCol=startCol;this.startLine=startLine;this.ch=ch;this.prevTok=prevTok;this.lexState=lexState;this.interveningWhitespace=interveningWhitespace;this.interveningWhitespacePos=interveningWhitespacePos;this.leftCurlyCount=leftCurlyCount;this.rightCurlyCount=rightCurlyCount;this.seenUnicodeChar=seenUnicodeChar;this.seenUnicodeCharInComment=
seenUnicodeCharInComment;prevLine=this.commentStack;prevLine.length=v7582;return lookAheadToken}function v665(){var v15827=this.pos;this.pos=v15827+1;v15827=this.col;this.col=v15827+1;this.ch=v15827=JAMScript.call(this.peekChar,this,[])}function v664(amt){var v15829=this.pos;this.pos=v15829+amt;v15829=this.col;this.col=v15829+amt;this.ch=amt=JAMScript.call(this.peekChar,this,[])}function v663(){var v7584;return v7584=(v7584=this.interveningWhitespace)?this.interveningWhitespacePos:this.startPos}function v662(){var v7585=
this.prevLine,v7586=this.startLine;return v7585!=v7586}function v661(){var v20732=TypeScript.noRegexTable,v23717=this.prevTok,v23717=v23717.tokenId;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v20732=v20732[v23717];if(v20732=void 0!=v20732)return null;var v23717=this.pos,v20732=this.col,index=JAMScript.call(this.findClosingSLH,this,[]),v7595=0<index;if(v7595){var v7595=this.src,v7595=JAMScript.call(v7595.substring,v7595,[v23717,index]),flags="";this.pos=index+
1;this.ch=index=JAMScript.call(this.peekChar,this,[]);var index=this.pos,flags=this.ch,v20735=TypeScript.LexCode_i,flags=flags==v20735;if(v20735=!flags)if(flags=this.ch,v20735=TypeScript.LexCode_g,flags=flags==v20735,v20735=!flags)flags=this.ch,v20735=TypeScript.LexCode_m,flags=flags==v20735;for(;flags;)if(JAMScript.call(this.nextChar,this,[]),flags=this.ch,v20735=TypeScript.LexCode_i,flags=flags==v20735,v20735=!flags)if(flags=this.ch,v20735=TypeScript.LexCode_g,flags=flags==v20735,v20735=!flags)flags=
this.ch,v20735=TypeScript.LexCode_m,flags=flags==v20735;flags=this.pos;flags-=index;if(flags=3<flags)return null;flags=this.src;v20735=this.pos;flags=JAMScript.call(flags.substring,flags,[index,v20735]);index=void 0;try{index=RegExp(v7595,flags)}catch(regexException){}if(index)return v23717=this.pos,v7595=this.startPos,v23717-=v7595,this.col=v20732+v23717,v20732=TypeScript.RegularExpressionLiteralToken,JAMScript.new(v20732,[index])}this.pos=v23717;this.col=v20732;return null}function v660(){var index=
this.pos,v7596=this.src,ch2=JAMScript.call(v7596.charCodeAt,v7596,[index]),prevCh=0,v7596=!1,prevCh=JAMScript.call(this.endsLine,this,[ch2]);if(prevCh=!prevCh)prevCh=this.len,prevCh=index<prevCh;for(;prevCh;){prevCh=TypeScript.LexCodeSLH;(prevCh=ch2==prevCh)&&(prevCh=!v7596);if(prevCh)return index;prevCh=ch2;index+=1;v7596?v7596=!1:(v7596=TypeScript.LexCodeBSL,v7596=prevCh==v7596);ch2=this.src;ch2=JAMScript.call(ch2.charCodeAt,ch2,[index]);prevCh=JAMScript.call(this.endsLine,this,[ch2]);if(prevCh=
!prevCh)prevCh=this.len,prevCh=index<prevCh}return-1}function v659(){var v7601=this.src,v7602=this.startPos,v7603=this.pos;return JAMScript.call(v7601.substring,v7601,[v7602,v7603])}function v658(){for(var v15841=this.pos,v15842=this.len,v15841=v15841<v15842;v15841;){v15841=this.ch;if(v15841=JAMScript.call(this.endsLine,this,[v15841]))break;v15841=this.ch;v15842=TypeScript.LexCodeASCIIChars;if(v15841=v15841>=v15842)this.seenUnicodeCharInComment=!0;JAMScript.call(this.nextChar,this,[]);v15841=this.pos;
v15842=this.len;v15841=v15841<v15842}v15841=this.mode;v15842=LexMode.File;(v15841=v15841==v15842)&&JAMScript.call(this.tokenStart,this,[])}function v657(c){var v15850=TypeScript.LexCodeNWL,v15850=c==v15850,v15852=!v15850;v15852&&(v15850=TypeScript.LexCodeRET,v15850=c==v15850,v15852=!v15850)&&(v15850=TypeScript.LexCodeLS,v15850=c==v15850,v15852=!v15850)&&(v15850=TypeScript.LexCodePS,v15850=c==v15850);return v15850}function v656(){this.commentStack=[]}function v655(line){var comments=null,v23731=this.commentStack,
v23731=v23731.length;if(v23731=0<v23731)v23731=this.commentStack,v23731=v23731[0],v23731=v23731.line,v23731=v23731==line;for(;v23731;)if((v23731=null==comments)?(comments=this.commentStack,comments=comments.shift(),comments=[comments]):(v23731=this.commentStack,v23731=v23731.shift(),v23731=[v23731],comments=comments.concat(v23731)),v23731=this.commentStack,v23731=v23731.length,v23731=0<v23731)v23731=this.commentStack,v23731=v23731[0],v23731=v23731.line,v23731=v23731==line;return comments}function v654(){var stack=
this.commentStack;this.commentStack=[];return stack}function v653(comment){var v7613=this.commentStack;JAMScript.call(v7613.push,v7613,[comment])}function v652(){var ch2;this.lexState=LexState.InMultilineComment;ch2=this.pos;var v15858=this.len;for(ch2=ch2<v15858;ch2;){ch2=this.ch;v15858=TypeScript.LexCodeMUL;if(ch2=ch2==v15858){if(ch2=this.pos,ch2+=1,ch2=JAMScript.call(this.peekCharAt,this,[ch2]),v15858=TypeScript.LexCodeSLH,ch2=ch2==v15858)return JAMScript.call(this.advanceChar,this,[2]),ch2=this.mode,
v15858=LexMode.File,(ch2=ch2==v15858)&&JAMScript.call(this.tokenStart,this,[]),this.lexState=LexState.Start,!0}else if(ch2=this.ch,v15858=TypeScript.LexCodeNWL,ch2=ch2==v15858){if(JAMScript.call(this.newLine,this,[]),ch2=this.mode,v15858=LexMode.Line,ch2=ch2==v15858){JAMScript.call(this.nextChar,this,[]);break}}else if(ch2=this.ch,v15858=TypeScript.LexCodeASCIIChars,ch2=ch2>=v15858)this.seenUnicodeCharInComment=!0;JAMScript.call(this.nextChar,this,[]);ch2=this.pos;v15858=this.len;ch2=ch2<v15858}return!1}
function v651(){this.col=0;var v15873=this.mode,v15874=LexMode.File;if(v15873=v15873==v15874){v15873=this.line;this.line=v15873+1;var v15873=this.lineMap,v15874=this.line,v15876=this.pos;JAMScript.set(v15873,v15874,v15876+1)}}function v650(){var v7625=NumberScanState.InFraction;return JAMScript.call(this.scanDecimalNumber,this,[v7625])}function v649(){var v15877=JAMScript.call(this.peekChar,this,[]),v15878=TypeScript.LexCode_0;if(v15877=v15877==v15878)switch(v15877=this.pos,v15877+=1,v15877=JAMScript.call(this.peekCharAt,
this,[v15877]),v15877){case TypeScript.LexCode_x:case TypeScript.LexCode_X:return JAMScript.call(this.advanceChar,this,[2]),JAMScript.call(this.scanHexDigits,this,[]);case TypeScript.LexCode_8:case TypeScript.LexCode_9:case TypeScript.LexCodeDOT:return v15877=NumberScanState.Start,JAMScript.call(this.scanDecimalNumber,this,[v15877]);default:return JAMScript.call(this.scanOctalDigits,this,[])}else return v15877=NumberScanState.Start,JAMScript.call(this.scanDecimalNumber,this,[v15877])}function v648(state){for(var atLeastOneDigit=
!1,svPos=this.pos,svCol=this.col;;){var v15880=this.ch;if(v15880=LexIsDigit(v15880)){var atLeastOneDigit=!0,v15880=this.ch,v20758=TypeScript.LexCode_0;if(v15880=v15880!=v20758)v15880=NumberScanState.InEmptyFraction,v15880=state==v15880;v15880&&(state=NumberScanState.InFraction);JAMScript.call(this.nextChar,this,[])}else if(v15880=this.ch,v20758=TypeScript.LexCodeDOT,v15880=v15880==v20758)if(v15880=NumberScanState.Start,v15880=state==v15880)JAMScript.call(this.nextChar,this,[]),state=NumberScanState.InEmptyFraction;
else{if(atLeastOneDigit)return svPos=TypeScript.NumberLiteralToken,svCol=this.src,atLeastOneDigit=this.startPos,v15880=this.pos,svCol=JAMScript.call(svCol.substring,svCol,[atLeastOneDigit,v15880]),svCol=parseFloat(svCol),atLeastOneDigit=NumberScanState.InEmptyFraction,state=state==atLeastOneDigit,JAMScript.new(svPos,[svCol,state]);this.pos=svPos;this.col=svCol;return null}else{v15880=this.ch;v20758=TypeScript.LexCode_e;v15880=v15880==v20758;if(v20758=!v15880)v15880=this.ch,v20758=TypeScript.LexCode_E,
v15880=v15880==v20758;if(v15880)if(v15880=NumberScanState.Start,v15880=state==v15880)if(atLeastOneDigit)atLeastOneDigit=!1,JAMScript.call(this.nextChar,this,[]),state=NumberScanState.InExponent;else return this.pos=svPos,this.col=svCol,null;else{v15880=NumberScanState.InFraction;v15880=state==v15880;if(v20758=!v15880)v15880=NumberScanState.InEmptyFraction,v15880=state==v15880;if(state=v15880)JAMScript.call(this.nextChar,this,[]),state=NumberScanState.InExponent,atLeastOneDigit=!1;else{if(atLeastOneDigit)return state=
TypeScript.NumberLiteralToken,svPos=this.src,svCol=this.startPos,atLeastOneDigit=this.pos,svPos=JAMScript.call(svPos.substring,svPos,[svCol,atLeastOneDigit]),svPos=parseFloat(svPos),JAMScript.new(state,[svPos]);this.pos=svPos;this.col=svCol;return null}}else{v15880=this.ch;v20758=TypeScript.LexCodePLS;v15880=v15880==v20758;if(v20758=!v15880)v15880=this.ch,v20758=TypeScript.LexCodeMIN,v15880=v15880==v20758;if(v15880)if(v15880=NumberScanState.InExponent,v15880=state==v15880)if(v15880=!atLeastOneDigit)JAMScript.call(this.nextChar,
this,[]);else return this.pos=svPos,this.col=svCol,null;else{v15880=NumberScanState.InEmptyFraction;v15880=state==v15880;if(v20758=!v15880)v15880=NumberScanState.InFraction,v15880=state==v15880;if(v15880)return svPos=TypeScript.NumberLiteralToken,svCol=this.src,atLeastOneDigit=this.startPos,v15880=this.pos,svCol=JAMScript.call(svCol.substring,svCol,[atLeastOneDigit,v15880]),svCol=parseFloat(svCol),atLeastOneDigit=NumberScanState.InEmptyFraction,state=state==atLeastOneDigit,JAMScript.new(svPos,[svCol,
state]);if(state=!atLeastOneDigit)return this.pos=svPos,this.col=svCol,null;state=TypeScript.NumberLiteralToken;svPos=this.src;svCol=this.startPos;atLeastOneDigit=this.pos;svPos=JAMScript.call(svPos.substring,svPos,[svCol,atLeastOneDigit]);svPos=parseFloat(svPos);return JAMScript.new(state,[svPos])}else{if(atLeastOneDigit=!atLeastOneDigit)return this.pos=svPos,this.col=svCol,null;svPos=TypeScript.NumberLiteralToken;svCol=this.src;atLeastOneDigit=this.startPos;v15880=this.pos;svCol=JAMScript.call(svCol.substring,
svCol,[atLeastOneDigit,v15880]);svCol=parseFloat(svCol);atLeastOneDigit=NumberScanState.InEmptyFraction;state=state==atLeastOneDigit;return JAMScript.new(svPos,[svCol,state])}}}}}function v647(){for(var atLeastOneDigit=!1;;){var v15899=this.ch;if(v15899=JAMScript.call(this.IsOctalDigit,this,[v15899]))JAMScript.call(this.nextChar,this,[]),atLeastOneDigit=!0;else{if(atLeastOneDigit){var atLeastOneDigit=TypeScript.NumberLiteralToken,v15899=this.src,v20792=this.startPos,v20793=this.pos,v15899=JAMScript.call(v15899.substring,
v15899,[v20792,v20793]),v15899=parseInt(v15899);return JAMScript.new(atLeastOneDigit,[v15899])}return null}}}function v646(){for(var atLeastOneDigit=!1;;){var v15901=this.ch;if(v15901=JAMScript.call(this.IsHexDigit,this,[v15901]))JAMScript.call(this.nextChar,this,[]),atLeastOneDigit=!0;else{if(atLeastOneDigit){var atLeastOneDigit=TypeScript.NumberLiteralToken,v15901=this.src,v20795=this.startPos,v20796=this.pos,v15901=JAMScript.call(v15901.substring,v15901,[v20795,v20796]),v15901=parseInt(v15901);
return JAMScript.new(atLeastOneDigit,[v15901])}return null}}}function v645(c){var v20797=TypeScript.LexCode_0;if(v20797=c>=v20797)v20797=TypeScript.LexCode_7,v20797=c<=v20797;var v15905=!v20797;v15905&&(v20797=TypeScript.LexCode_a,v20797=c>=v20797)&&(v20797=TypeScript.LexCode_f,v20797=c<=v20797);return v20797}function v644(c){var v20801=TypeScript.LexCode_0;if(v20801=c>=v20801)v20801=TypeScript.LexCode_9,v20801=c<=v20801;var v15908=!v20801;if(v15908){v20801=TypeScript.LexCode_A;if(v20801=c>=v20801)v20801=
TypeScript.LexCode_F,v20801=c<=v20801;if(v15908=!v20801)if(v20801=TypeScript.LexCode_a,v20801=c>=v20801)v20801=TypeScript.LexCode_f,v20801=c<=v20801}return v20801}function v643(index){var v15909=this.len;return(v15909=index<v15909)?(v15909=this.src,JAMScript.call(v15909.charCodeAt,v15909,[index])):TypeScript.LexEOF}function v642(){var v15910=this.pos,v15911=this.len;return(v15910=v15910<v15911)?(v15910=this.src,v15911=this.pos,JAMScript.call(v15910.charCodeAt,v15910,[v15911])):TypeScript.LexEOF}function v641(){this.startPos=
this.pos;this.startLine=this.line;this.startCol=this.col;this.interveningWhitespace=!1}function v640(){return this.lexState}function v639(value){this.scanComments=value}function v638(newSrc,textMode){var v7669=JAMScript.new(StringSourceText,[newSrc]);JAMScript.call(this.setSourceText,this,[v7669,textMode])}function v637(savedTokens){this.saveScan=savedTokens}function v636(reportError){this.reportError=reportError}function v635(newSrc,textMode){var v7670=this.mode=textMode,v7671=LexMode.Line;this.scanComments=
v7670===v7671;this.startPos=this.interveningWhitespacePos=this.pos=0;this.line=1;this.startCol=this.col=0;this.startLine=this.line;this.len=0;v7670=JAMScript.call(newSrc.getLength,newSrc,[]);v7670=this.src=v7670=JAMScript.call(newSrc.getText,newSrc,[0,v7670]);this.len=v7670.length;v7670=this.lineMap=[];v7670[1]=0;this.commentStack=[];this.rightCurlyCount=this.leftCurlyCount=0;this.seenUnicodeCharInComment=this.seenUnicodeChar=!1}function v634(){return this.prevTok}function Scanner(){this.line=this.prevLine=
1;this.len=this.startPos=this.pos=this.col=0;this.lineMap=[];this.ch=TypeScript.LexEOF;this.lexState=LexState.Start;this.mode=LexMode.File;this.scanComments=!0;this.interveningWhitespace=!1;this.rightCurlyCount=this.leftCurlyCount=this.interveningWhitespacePos=0;var v27026=[];this.commentStack=v27026;this.saveScan=null;this.seenUnicodeCharInComment=this.seenUnicodeChar=!1;var v27026=TypeScript.staticTokens,v15912=TypeScript.TokenID,v15912=v15912.EndOfFile;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)this.prevTok=
v27026[v15912];this.startCol=this.col;this.startLine=this.line;v27026=this.lineMap;v27026[1]=0;v27026=TypeScript.LexKeywordTable;(v27026=!v27026)&&LexInitialize()}var v7679=Scanner.prototype;v7679.previousToken=v634;v7679=Scanner.prototype;v7679.setSourceText=v635;v7679=Scanner.prototype;v7679.setErrorHandler=v636;v7679=Scanner.prototype;v7679.setSaveScan=v637;v7679=Scanner.prototype;v7679.setText=v638;v7679=Scanner.prototype;v7679.setScanComments=v639;v7679=Scanner.prototype;v7679.getLexState=v640;
v7679=Scanner.prototype;v7679.tokenStart=v641;v7679=Scanner.prototype;v7679.peekChar=v642;v7679=Scanner.prototype;v7679.peekCharAt=v643;v7679=Scanner.prototype;v7679.IsHexDigit=v644;v7679=Scanner.prototype;v7679.IsOctalDigit=v645;v7679=Scanner.prototype;v7679.scanHexDigits=v646;v7679=Scanner.prototype;v7679.scanOctalDigits=v647;v7679=Scanner.prototype;v7679.scanDecimalNumber=v648;v7679=Scanner.prototype;v7679.scanNumber=v649;v7679=Scanner.prototype;v7679.scanFraction=v650;v7679=Scanner.prototype;
v7679.newLine=v651;v7679=Scanner.prototype;v7679.finishMultilineComment=v652;v7679=Scanner.prototype;v7679.pushComment=v653;v7679=Scanner.prototype;v7679.getComments=v654;v7679=Scanner.prototype;v7679.getCommentsForLine=v655;v7679=Scanner.prototype;v7679.resetComments=v656;v7679=Scanner.prototype;v7679.endsLine=v657;v7679=Scanner.prototype;v7679.finishSinglelineComment=v658;v7679=Scanner.prototype;v7679.tokenText=v659;v7679=Scanner.prototype;v7679.findClosingSLH=v660;v7679=Scanner.prototype;v7679.speculateRegex=
v661;v7679=Scanner.prototype;v7679.lastTokenHadNewline=v662;v7679=Scanner.prototype;v7679.lastTokenLimChar=v663;v7679=Scanner.prototype;v7679.advanceChar=v664;v7679=Scanner.prototype;v7679.nextChar=v665;v7679=Scanner.prototype;v7679.getLookAheadToken=v666;v7679=Scanner.prototype;v7679.scanInLine=v667;v7679=Scanner.prototype;v7679.scan=v668;v7679=Scanner.prototype;v7679.isValidUnicodeIdentifierChar=v669;v7679=Scanner.prototype;v7679.scanStringConstant=v670;v7679=Scanner.prototype;v7679.scanIdentifier=
v671;v7679=Scanner.prototype;v7679.innerScan=v672;v7679=Scanner.prototype;v7679.reportScannerError=v673;return Scanner}function v633(){function v632(){throw Error("Invalid operation.");}function v631(reportError){}function v630(newSrc,textMode){}function v629(){this.commentStack=[]}function v628(line){var comments=null,v23739=this.commentStack,v23739=v23739.length;if(v23739=0<v23739)v23739=this.commentStack,v23739=v23739[0],v23739=v23739.line,v23739=v23739==line;for(;v23739;)if((v23739=null==comments)?
(comments=this.commentStack,comments=comments.shift(),comments=[comments]):(v23739=this.commentStack,v23739=v23739.shift(),v23739=[v23739],comments=comments.concat(v23739)),v23739=this.commentStack,v23739=v23739.length,v23739=0<v23739)v23739=this.commentStack,v23739=v23739[0],v23739=v23739.line,v23739=v23739==line;return comments}function v627(){var stack=this.commentStack;this.commentStack=[];return stack}function v626(comment){var v7723=this.commentStack;JAMScript.call(v7723.push,v7723,[comment])}
function v625(){var v7724=this.prevLine,v7725=this.startLine;return v7724!=v7725}function v624(){var v15918=this.prevSavedToken;return(v15918=null!==v15918)?(v15918=this.prevSavedToken,v15918.limChar):0}function v623(offset){var v7728=this.lineMap;this.line=v7728=getLineNumberFromPosition(v7728,offset);this.currentTokenIndex=0;var v7728=this.lineMap,v15920=this.line;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7728=v7728[v15920];offset-=v7728;v7728=this.lexStateByLine;
v15920=this.line;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7728=v7728[v15920];v15920=LexState.InMultilineComment;if(v7728=v7728==v15920)v7728=this.line,v7728=0<v7728;for(;v7728;){offset=this.line;this.line=offset-1;offset=0;v7728=this.lexStateByLine;v15920=this.line;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7728=v7728[v15920];v15920=LexState.InMultilineComment;if(v7728=v7728==v15920)v7728=this.line,v7728=0<v7728}var v7728=
this.lineMap,v7728=v7728.length,v7728=v7728-1,v15920=this.tokensByLine,v7733=this.line;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)this.currentTokens=v15920[v7733];v15920=this.currentTokens;v15920=v15920.length;if(v15920=0==v15920)v15920=this.line,v15920=v15920<v7728;for(;v15920;){offset=this.line;this.line=offset+1;offset=this.tokensByLine;v15920=this.line;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)this.currentTokens=
offset[v15920];offset=0;v15920=this.currentTokens;v15920=v15920.length;if(v15920=0==v15920)v15920=this.line,v15920=v15920<v7728}v15920=this.line;if(v7728=v15920<=v7728){v7728=this.currentTokenIndex;v15920=this.currentTokens;v15920=v15920.length;if(v7728=v7728<v15920){v7728=this.currentTokens;v15920=this.currentTokenIndex;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7728=v7728[v15920];v7728=v7728.limChar;v7728=offset>v7728}for(;v7728;)if(v7728=this.currentTokenIndex,
v7728=this.currentTokenIndex=v7728+1,v15920=this.currentTokens,v15920=v15920.length,v7728=v7728<v15920){v7728=this.currentTokens;v15920=this.currentTokenIndex;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7728=v7728[v15920];v7728=v7728.limChar;v7728=offset>v7728}offset=this.currentTokenIndex;v7728=this.currentTokens;v7728=v7728.length;if(offset=offset<v7728){offset=this.currentTokens;v7728=this.currentTokenIndex;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)offset=
offset[v7728];offset=this.col=offset.minChar;v7728=this.lineMap;v15920=this.line;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7728=v7728[v15920];return offset+v7728}}return-1}function v622(){this.startLine=this.line;this.startPos=this.col;var v15938=this.currentTokenIndex,v20828=this.currentTokens,v20828=v20828.length;if(v15938=v15938==v20828)if(v15938=this.line,v20828=this.lineMap,v20828=v20828.length,v15938=v15938<v20828){v15938=this.line;this.line=v15938+
1;this.currentTokenIndex=this.col=0;v15938=this.tokensByLine;v20828=this.line;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)this.currentTokens=v15938[v20828]}else{v15938=TypeScript.staticTokens;v20828=TypeScript.TokenID;v20828=v20828.EndOfFile;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v15938[v20828]}v15938=this.currentTokenIndex;v20828=this.currentTokens;v20828=v20828.length;if(v15938=v15938<v20828){v15938=this.curSavedToken;
this.prevToken=v15938.tok;this.prevSavedToken=this.curSavedToken;var v15938=this.currentTokens,v20831=v20828=this.currentTokenIndex;this.currentTokenIndex=v20831+1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)this.curSavedToken=v15938[v20828];v15938=this.curSavedToken;v15938=v15938.tok;v20828=this.curSavedToken;this.pos=v20828.limChar;var v20828=this.col,v20831=this.curSavedToken,v20831=v20831.limChar,v23754=this.curSavedToken,v23754=v23754.minChar,v20831=v20831-
v23754;this.col=v20828+v20831;v20828=this.curSavedToken;this.startPos=v20828.minChar;this.prevLine=this.line;return v15938}v15938=TypeScript.staticTokens;v20828=TypeScript.TokenID;v20828=v20828.EndOfFile;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v15938[v20828]}function v621(tok,scanner){var v7758=this.tokens,v7759=this.currentToken,v20834=this.currentToken;this.currentToken=v20834+1;var v20834=TypeScript.SavedToken,v15950=scanner.startPos,v15951=scanner.pos,
v20834=JAMScript.new(v20834,[tok,v15950,v15951]);JAMScript.set(v7758,v7759,v20834)}function v620(){this.currentToken=0}function v619(){return this.prevToken}function SavedTokens(){this.prevToken=this.prevSavedToken=this.curSavedToken=this.prevToken=null;this.currentToken=0;var v27029=[];this.tokens=v27029;this.seenUnicodeCharInComment=this.seenUnicodeChar=!1;this.line=this.prevLine=1;this.col=0;this.lexState=LexState.Start;this.commentStack=v27029=[];this.lineMap=[]}var v7760=SavedTokens.prototype;
v7760.previousToken=v619;v7760=SavedTokens.prototype;v7760.close=v620;v7760=SavedTokens.prototype;v7760.addToken=v621;v7760=SavedTokens.prototype;v7760.scan=v622;v7760=SavedTokens.prototype;v7760.syncToTok=v623;v7760=SavedTokens.prototype;v7760.lastTokenLimChar=v624;v7760=SavedTokens.prototype;v7760.lastTokenHadNewline=v625;v7760=SavedTokens.prototype;v7760.pushComment=v626;v7760=SavedTokens.prototype;v7760.getComments=v627;v7760=SavedTokens.prototype;v7760.getCommentsForLine=v628;v7760=SavedTokens.prototype;
v7760.resetComments=v629;v7760=SavedTokens.prototype;v7760.setSourceText=v630;v7760=SavedTokens.prototype;v7760.setErrorHandler=v631;v7760=SavedTokens.prototype;v7760.getLookAheadToken=v632;return SavedTokens}function v618(){function v617(start,end){var v7774=JAMScript.call(this.fetchSegment,this,[start,end]);return JAMScript.call(v7774.substring,v7774,[start,end])}function v616(index){var v15952=index+1,v15952=JAMScript.call(this.fetchSegment,this,[index,v15952]);return JAMScript.call(v15952.charCodeAt,
v15952,[index])}function v615(start,end){var v25195=this.agg,v25195=v25195.seg1,v25195=v25195.segmentStart;if(v25195=v25195<=start)v25195=this.agg,v25195=v25195.seg1,v25195=v25195.segmentEnd,v25195=end<=v25195;if(v25195)return v25195=this.agg,v25195.seg1;v25195=this.agg;v25195=v25195.seg2;v25195=v25195.segmentStart;if(v25195=v25195<=start)v25195=this.agg,v25195=v25195.seg1,v25195=v25195.segmentEnd,v25195=end<=v25195;if(v25195)return this.agg;var v25195=this.agg,v25195=v25195.seg1,s=v25195.segmentEnd,
v7780=s+512,v7780=JAMScript.call(TypeScript.max,TypeScript,[v7780,end]),v7781=this.len,v7780=JAMScript.call(TypeScript.min,TypeScript,[v7780,v7781]),v7781=this.sourceText,v7781=JAMScript.call(v7781.getText,v7781,[s,v7780]),s=JAMScript.new(SourceTextSegment,[s,v7780,v7781]),v7780=this.agg;v7780.seg2=v25195;v25195=this.agg;v25195.seg1=s;return this.agg}function v614(a,b){var v7785;return v7785=(v7785=a<=b)?a:b}function v613(a,b){var v7786;return v7786=(v7786=a>=b)?a:b}function ScannerTextStream(sourceText){this.sourceText=
sourceText;var v7788=sourceText=ScannerTextStream.emptySegment;this.agg=sourceText=JAMScript.new(AggerateSourceTextSegment,[sourceText,v7788]);sourceText=this.sourceText;this.len=sourceText=JAMScript.call(sourceText.getLength,sourceText,[])}var v7790=ScannerTextStream,v27033=JAMScript.new(SourceTextSegment,[0,0,""]);v7790.emptySegment=v27033;v7790=ScannerTextStream.prototype;v7790.max=v613;v7790=ScannerTextStream.prototype;v7790.min=v614;v7790=ScannerTextStream.prototype;v7790.fetchSegment=v615;v7790=
ScannerTextStream.prototype;v7790.charCodeAt=v616;v7790=ScannerTextStream.prototype;v7790.substring=v617;return ScannerTextStream}function v612(){function v611(start,end){var v23759=this.seg1,v23759=v23759.segmentStart;if(v23759=v23759<=start)v23759=this.seg1,v23759=v23759.segmentEnd,v23759=end<=v23759;if(v23759){var v23759=this.seg1,v23759=v23759.segment,v20841=this.seg1,v20841=v20841.segmentStart,v20841=start-v20841,v20842=this.seg1,v20842=v20842.segmentStart,v20842=end-v20842;return JAMScript.call(v23759.substring,
v23759,[v20841,v20842])}v23759=this.seg2;v23759=v23759.segment;v20841=this.seg2;v20841=v20841.segmentStart;v20841=start-v20841;v23759=JAMScript.call(v23759.substring,v23759,[v20841]);v20841=this.seg1;v20841=v20841.segment;v20842=this.seg1;v20842=v20842.segmentStart;v20842=end-v20842;v20841=JAMScript.call(v20841.substring,v20841,[0,v20842]);return v23759+v20841}function v610(index){var v23763=this.seg1,v23763=v23763.segmentStart;if(v23763=v23763<=index)v23763=this.seg1,v23763=v23763.segmentEnd,v23763=
index<v23763;if(v23763){var v23763=this.seg1,v23763=v23763.segment,v20849=this.seg1,v20849=v20849.segmentStart;index-=v20849;return JAMScript.call(v23763.charCodeAt,v23763,[index])}v23763=this.seg2;v23763=v23763.segment;v20849=this.seg2;v20849=v20849.segmentStart;index-=v20849;return JAMScript.call(v23763.charCodeAt,v23763,[index])}function AggerateSourceTextSegment(seg1,seg2){this.seg1=seg1;this.seg2=seg2}var v7807=AggerateSourceTextSegment.prototype;v7807.charCodeAt=v610;v7807=AggerateSourceTextSegment.prototype;
v7807.substring=v611;return AggerateSourceTextSegment}function v609(){function v608(start,end){var v7809=this.segment,v15970=this.segmentStart,v15970=start-v15970,v15971=this.segmentStart,v15971=end-v15971;return JAMScript.call(v7809.substring,v7809,[v15970,v15971])}function v607(index){var v7812=this.segment,v15972=this.segmentStart;index-=v15972;return JAMScript.call(v7812.charCodeAt,v7812,[index])}function SourceTextSegment(segmentStart,segmentEnd,segment){this.segmentStart=segmentStart;this.segmentEnd=
segmentEnd;this.segment=segment}var v7814=SourceTextSegment.prototype;v7814.charCodeAt=v607;v7814=SourceTextSegment.prototype;v7814.substring=v608;return SourceTextSegment}function v606(){function v605(){var v7816=this.text;return v7816.length}function v604(start,end){var v7817=this.text;return JAMScript.call(v7817.substring,v7817,[start,end])}function StringSourceText(text){this.text=text}var v7818=StringSourceText.prototype;v7818.getText=v604;v7818=StringSourceText.prototype;v7818.getLength=v605;
return StringSourceText}function v603(CommentStyle){CommentStyle._map=[];var v7820=CommentStyle._map;v7820[0]="Line";CommentStyle.Line=0;v7820=CommentStyle._map;v7820[1]="Block";CommentStyle.Block=1}function v602(LexMode){LexMode._map=[];var v7822=LexMode._map;v7822[0]="Line";LexMode.Line=0;v7822=LexMode._map;v7822[1]="File";LexMode.File=1}function v601(LexState){LexState._map=[];var v7824=LexState._map;v7824[0]="Start";LexState.Start=0;v7824=LexState._map;v7824[1]="InMultilineComment";LexState.InMultilineComment=
1;v7824=LexState._map;v7824[2]="InMultilineSingleQuoteString";LexState.InMultilineSingleQuoteString=2;v7824=LexState._map;v7824[3]="InMultilineDoubleQuoteString";LexState.InMultilineDoubleQuoteString=3}function v600(NumberScanState){NumberScanState._map=[];var v7828=NumberScanState._map;v7828[0]="Start";NumberScanState.Start=0;v7828=NumberScanState._map;v7828[1]="InFraction";NumberScanState.InFraction=1;v7828=NumberScanState._map;v7828[2]="InEmptyFraction";NumberScanState.InEmptyFraction=2;v7828=
NumberScanState._map;v7828[3]="InExponent";NumberScanState.InExponent=3}function LexLookUpUnicodeMap(code,map){var lo=0,hi=map.length,mid;mid=lo+1;for(mid=mid<hi;mid;){mid=hi-lo;mid/=2;mid=lo+mid;var v15975=mid%2;mid-=v15975;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v15975=map[mid];if(v15975=v15975<=code){v15975=mid+1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v15975=map[v15975];v15975=code<=v15975}if(v15975)return!0;
introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v15975=map[mid];(v15975=code<v15975)?hi=mid:lo=mid+2;mid=lo+1;mid=mid<hi}return!1}function LexIsUnicodeDigit(code){var v15979=TypeScript.codeGenTarget,v20853=TypeScript.CodeGenTarget,v20853=v20853.ES3;return(v15979=v15979==v20853)?LexLookUpUnicodeMap(code,unicodeES3IdCont):LexLookUpUnicodeMap(code,unicodeES5IdCont)}function LexIsUnicodeIdStart(code){var v15981=TypeScript.codeGenTarget,v20854=TypeScript.CodeGenTarget,
v20854=v20854.ES3;return(v15981=v15981==v20854)?LexLookUpUnicodeMap(code,unicodeES3IdStart):LexLookUpUnicodeMap(code,unicodeES5IdStart)}function LexInitialize(){JAMScript.call(TypeScript.initializeStaticTokens,TypeScript,[]);var v7838=TypeScript.LexCodeLPR,v15983=TypeScript.staticTokens,v20855=TypeScript.TokenID,v20855=v20855.OpenParen;JAMScript.set(autoToken,v7838,v15983[v20855],JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074);v7838=TypeScript.LexCodeRPR;v15983=TypeScript.staticTokens;
v20855=TypeScript.TokenID;v20855=v20855.CloseParen;JAMScript.set(autoToken,v7838,v15983[v20855],JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074);v7838=TypeScript.LexCodeCMA;v15983=TypeScript.staticTokens;v20855=TypeScript.TokenID;v20855=v20855.Comma;JAMScript.set(autoToken,v7838,v15983[v20855],JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074);v7838=TypeScript.LexCodeSMC;v15983=TypeScript.staticTokens;v20855=TypeScript.TokenID;v20855=v20855.Semicolon;
JAMScript.set(autoToken,v7838,v15983[v20855],JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074);v7838=TypeScript.LexCodeLBR;v15983=TypeScript.staticTokens;v20855=TypeScript.TokenID;v20855=v20855.OpenBracket;JAMScript.set(autoToken,v7838,v15983[v20855],JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074);v7838=TypeScript.LexCodeRBR;v15983=TypeScript.staticTokens;v20855=TypeScript.TokenID;v20855=v20855.CloseBracket;JAMScript.set(autoToken,v7838,v15983[v20855],
JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074);v7838=TypeScript.LexCodeTIL;v15983=TypeScript.staticTokens;v20855=TypeScript.TokenID;v20855=v20855.Tilde;JAMScript.set(autoToken,v7838,v15983[v20855],JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074);v7838=TypeScript.LexCodeQUE;v15983=TypeScript.staticTokens;v20855=TypeScript.TokenID;v20855=v20855.Question;JAMScript.set(autoToken,v7838,v15983[v20855],JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074);
v7838=TypeScript.LexCodeLC;v15983=TypeScript.staticTokens;v20855=TypeScript.TokenID;v20855=v20855.OpenBrace;JAMScript.set(autoToken,v7838,v15983[v20855],JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074);v7838=TypeScript.LexCodeRC;v15983=TypeScript.staticTokens;v20855=TypeScript.TokenID;v20855=v20855.CloseBrace;JAMScript.set(autoToken,v7838,v15983[v20855],JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074);v7838=TypeScript.LexCodeCOL;v15983=TypeScript.staticTokens;
v20855=TypeScript.TokenID;v20855=v20855.Colon;JAMScript.set(autoToken,v7838,v15983[v20855],JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074);v7838=TypeScript;v15983=TypeScript.StringHashTable;v15983=JAMScript.new(v15983,[]);v7838.LexKeywordTable=v15983;var i,v7838=TypeScript.TokenID,v7838=v7838._map;for(i in v7838)if(v7838=TypeScript.TokenID,v7838=v7838.LimKeyword,v7838=i<=v7838){v7838=TypeScript.LexKeywordTable;v15983=TypeScript.TokenID;v15983=v15983._map;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v15983=
v15983[i];v15983=v15983.toLowerCase();JAMScript.call(v7838.add,v7838,[v15983,i])}i=0;v7838=TypeScript.LexCodeASCIIChars;for(v7838=i<v7838;v7838;)v7838=LexIsIdentifierStartChar(i),lexIdStartTable[i]=v7838?!0:!1,i+=1,v7838=TypeScript.LexCodeASCIIChars,v7838=i<v7838}function LexAdjustIndent(code,indentAmt){var v20868=TypeScript.LexCodeLBR,v20868=code==v20868,v20870=!v20868;v20870&&(v20868=TypeScript.LexCodeLC,v20868=code==v20868,v20870=!v20868)&&(v20868=TypeScript.LexCodeLPR,v20868=code==v20868);if(v20868)return indentAmt+
1;v20868=TypeScript.LexCodeRBR;v20868=code==v20868;if(v20870=!v20868)if(v20868=TypeScript.LexCodeRC,v20868=code==v20868,v20870=!v20868)v20868=TypeScript.LexCodeRPR,v20868=code==v20868;return v20868?indentAmt-1:indentAmt}function LexIsIdentifierStartChar(code){var v16013=97<=code;v16013&&(v16013=122>=code);var v16015=!v16013;v16015&&((v16013=65<=code)&&(v16013=90>=code),v16015=!v16013)&&(v16013=TypeScript.LexCodeDollar,v16013=code==v16013,v16015=!v16013)&&(v16013=TypeScript.LexCodeUnderscore,v16013=
code==v16013);return v16013}function LexIsDigit(code){var v7859=48<=code;v7859&&(v7859=57>=code);return v7859}function LexIsIdentifierChar(code){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v7860=lexIdStartTable[code];var v16016=!v7860;v16016&&(v7860=LexIsDigit(code));return v7860}function LexMatchingOpen(code){var v16017=TypeScript.LexCodeRBR;if(v16017=code==v16017)return TypeScript.LexCodeLBR;v16017=TypeScript.LexCodeRC;if(v16017=code==v16017)return TypeScript.LexCodeLC;
v16017=TypeScript.LexCodeRPR;return(code=code==v16017)?TypeScript.LexCodeLPR:0}function convertTokToIDName(tok){return convertTokToIDBase(tok,!0,!1)}function convertTokToID(tok,strictMode){return convertTokToIDBase(tok,!1,strictMode)}function convertTokToIDBase(tok,identifierName,strictMode){var v16020=tok.tokenId,v20877=TypeScript.TokenID,v20877=v20877.LimKeyword;if(v16020=v16020<=v20877)if(tok=tok.tokenId,tok=JAMScript.call(TypeScript.lookupToken,TypeScript,[tok]),v16020=void 0!=tok){v16020=TypeScript.Reservation;
v16020=v16020.Javascript;v20877=TypeScript.Reservation;v20877=v20877.JavascriptFuture;v16020|=v20877;strictMode&&(strictMode=TypeScript.Reservation,strictMode=strictMode.JavascriptFutureStrict,v16020|=strictMode);if(strictMode=!identifierName)identifierName=tok.reservation,identifierName=JAMScript.call(TypeScript.hasFlag,TypeScript,[identifierName,v16020]),identifierName=!identifierName;if(identifierName)return!0}else return!1;else return!1}function getLineNumberFromPosition(lineMap,position){var v7870=
-1===position;if(v7870)return 0;for(var min=0,v7870=lineMap.length,v7870=v7870-1,v7875=min<v7870;v7875;){v7875=min+v7870;v7875>>=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v16026=lineMap[v7875];if(v16026=position<v16026)v7870=v7875-1;else{min=v7875+1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)min=lineMap[min];min=(min=position<min)?v7870=v7875:v7875+1}v7875=min<v7870}return min}function getSourceLineColFromMap(lineCol,
minChar,lineMap){var line=getLineNumberFromPosition(lineMap,minChar),v7877=0<line;if(v7877){lineCol.line=line;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)lineMap=lineMap[line];lineCol.col=minChar-lineMap}}function getLineColumnFromPosition(script,position){var result={line:-1,col:-1},v16028=script.locationInfo,v16028=v16028.lineMap;getSourceLineColFromMap(result,position,v16028);v16028=result.col;if(v16028=0<=v16028)v16028=result.col,result.col=v16028+1;return result}
function getPositionFromLineColumn(script,line,column){script=script.locationInfo;script=script.lineMap;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)line=script[line];column-=1;return line+column}function isPrimitiveTypeToken(token){token=token.tokenId;switch(token){case TypeScript.TokenID.Any:case TypeScript.TokenID.Bool:case TypeScript.TokenID.Number:case TypeScript.TokenID.String:return!0}return!1}function isModifier(token){token=token.tokenId;switch(token){case TypeScript.TokenID.Public:case TypeScript.TokenID.Private:case TypeScript.TokenID.Static:return!0}return!1}
TypeScript.LexEOF=-1;TypeScript.LexCodeNWL=10;TypeScript.LexCodeRET=13;TypeScript.LexCodeLS=8232;TypeScript.LexCodePS=8233;TypeScript.LexCodeTAB=9;TypeScript.LexCodeVTAB=11;var v7884=TypeScript,v27035=JAMScript.call("e".charCodeAt,"e",[0]);v7884.LexCode_e=v27035;var v7885=TypeScript,v27036=JAMScript.call("E".charCodeAt,"E",[0]);v7885.LexCode_E=v27036;var v7886=TypeScript,v27037=JAMScript.call("x".charCodeAt,"x",[0]);v7886.LexCode_x=v27037;var v7887=TypeScript,v27038=JAMScript.call("X".charCodeAt,
"X",[0]);v7887.LexCode_X=v27038;var v7888=TypeScript,v27039=JAMScript.call("a".charCodeAt,"a",[0]);v7888.LexCode_a=v27039;var v7889=TypeScript,v27040=JAMScript.call("A".charCodeAt,"A",[0]);v7889.LexCode_A=v27040;var v7890=TypeScript,v27041=JAMScript.call("f".charCodeAt,"f",[0]);v7890.LexCode_f=v27041;var v7891=TypeScript,v27042=JAMScript.call("F".charCodeAt,"F",[0]);v7891.LexCode_F=v27042;var v7892=TypeScript,v27043=JAMScript.call("g".charCodeAt,"g",[0]);v7892.LexCode_g=v27043;var v7893=TypeScript,
v27044=JAMScript.call("m".charCodeAt,"m",[0]);v7893.LexCode_m=v27044;var v7894=TypeScript,v27045=JAMScript.call("i".charCodeAt,"i",[0]);v7894.LexCode_i=v27045;var v7895=TypeScript,v27046=JAMScript.call("u".charCodeAt,"u",[0]);v7895.LexCode_u=v27046;var v7896=TypeScript,v27047=JAMScript.call("0".charCodeAt,"0",[0]);v7896.LexCode_0=v27047;var v7897=TypeScript,v27048=JAMScript.call("9".charCodeAt,"9",[0]);v7897.LexCode_9=v27048;var v7898=TypeScript,v27049=JAMScript.call("8".charCodeAt,"8",[0]);v7898.LexCode_8=
v27049;var v7899=TypeScript,v27050=JAMScript.call("7".charCodeAt,"7",[0]);v7899.LexCode_7=v27050;var v7900=TypeScript,v27051=JAMScript.call("\\".charCodeAt,"\\",[0]);v7900.LexCodeBSL=v27051;var v7901=TypeScript,v27052=JAMScript.call("#".charCodeAt,"#",[0]);v7901.LexCodeSHP=v27052;var v7902=TypeScript,v27053=JAMScript.call("!".charCodeAt,"!",[0]);v7902.LexCodeBNG=v27053;var v7903=TypeScript,v27054=JAMScript.call('"'.charCodeAt,'"',[0]);v7903.LexCodeQUO=v27054;var v7904=TypeScript,v27055=JAMScript.call("'".charCodeAt,
"'",[0]);v7904.LexCodeAPO=v27055;var v7905=TypeScript,v27056=JAMScript.call("%".charCodeAt,"%",[0]);v7905.LexCodePCT=v27056;var v7906=TypeScript,v27057=JAMScript.call("&".charCodeAt,"&",[0]);v7906.LexCodeAMP=v27057;var v7907=TypeScript,v27058=JAMScript.call("(".charCodeAt,"(",[0]);v7907.LexCodeLPR=v27058;var v7908=TypeScript,v27059=JAMScript.call(")".charCodeAt,")",[0]);v7908.LexCodeRPR=v27059;var v7909=TypeScript,v27060=JAMScript.call("+".charCodeAt,"+",[0]);v7909.LexCodePLS=v27060;var v7910=TypeScript,
v27061=JAMScript.call("-".charCodeAt,"-",[0]);v7910.LexCodeMIN=v27061;var v7911=TypeScript,v27062=JAMScript.call("*".charCodeAt,"*",[0]);v7911.LexCodeMUL=v27062;var v7912=TypeScript,v27063=JAMScript.call("/".charCodeAt,"/",[0]);v7912.LexCodeSLH=v27063;var v7913=TypeScript,v27064=JAMScript.call("^".charCodeAt,"^",[0]);v7913.LexCodeXOR=v27064;var v7914=TypeScript,v27065=JAMScript.call(",".charCodeAt,",",[0]);v7914.LexCodeCMA=v27065;var v7915=TypeScript,v27066=JAMScript.call(".".charCodeAt,".",[0]);
v7915.LexCodeDOT=v27066;var v7916=TypeScript,v27067=JAMScript.call("<".charCodeAt,"<",[0]);v7916.LexCodeLT=v27067;var v7917=TypeScript,v27068=JAMScript.call("=".charCodeAt,"=",[0]);v7917.LexCodeEQ=v27068;var v7918=TypeScript,v27069=JAMScript.call(">".charCodeAt,">",[0]);v7918.LexCodeGT=v27069;var v7919=TypeScript,v27070=JAMScript.call("?".charCodeAt,"?",[0]);v7919.LexCodeQUE=v27070;var v7920=TypeScript,v27071=JAMScript.call("[".charCodeAt,"[",[0]);v7920.LexCodeLBR=v27071;var v7921=TypeScript,v27072=
JAMScript.call("]".charCodeAt,"]",[0]);v7921.LexCodeRBR=v27072;var v7922=TypeScript,v27073=JAMScript.call("_".charCodeAt,"_",[0]);v7922.LexCodeUSC=v27073;var v7923=TypeScript,v27074=JAMScript.call("{".charCodeAt,"{",[0]);v7923.LexCodeLC=v27074;var v7924=TypeScript,v27075=JAMScript.call("}".charCodeAt,"}",[0]);v7924.LexCodeRC=v27075;var v7925=TypeScript,v27076=JAMScript.call("|".charCodeAt,"|",[0]);v7925.LexCodeBAR=v27076;var v7926=TypeScript,v27077=JAMScript.call("~".charCodeAt,"~",[0]);v7926.LexCodeTIL=
v27077;var v7927=TypeScript,v27078=JAMScript.call(":".charCodeAt,":",[0]);v7927.LexCodeCOL=v27078;var v7928=TypeScript,v27079=JAMScript.call(";".charCodeAt,";",[0]);v7928.LexCodeSMC=v27079;var v7929=TypeScript,v27080=JAMScript.call("_".charCodeAt,"_",[0]);v7929.LexCodeUnderscore=v27080;var v7930=TypeScript,v27081=JAMScript.call("$".charCodeAt,"$",[0]);v7930.LexCodeDollar=v27081;TypeScript.LexCodeSpace=32;var v7931=TypeScript,v27082=JAMScript.call("@".charCodeAt,"@",[0]);v7931.LexCodeAtSign=v27082;
TypeScript.LexCodeASCIIChars=128;TypeScript.LexKeywordTable=void 0;var v7932=TypeScript.LexCodeASCIIChars,autoToken=Array(v7932),v7933=TypeScript.LexCodeASCIIChars,lexIdStartTable=Array(v7933),v27446=[170,170,181,181,186,186,192,214,216,246,248,543,546,563,592,685,688,696,699,705,720,721,736,740,750,750,890,890,902,902,904,906,908,908,910,929,931,974,976,983,986,1011,1024,1153,1164,1220,1223,1224,1227,1228,1232,1269,1272,1273,1329,1366,1369,1369,1377,1415,1488,1514,1520,1522,1569,1594,1600,1610,1649,
1747,1749,1749,1765,1766,1786,1788,1808,1808,1810,1836,1920,1957,2309,2361,2365,2365,2384,2384,2392,2401,2437,2444,2447,2448,2451,2472,2474,2480,2482,2482,2486,2489,2524,2525,2527,2529,2544,2545,2565,2570,2575,2576,2579,2600,2602,2608,2610,2611,2613,2614,2616,2617,2649,2652,2654,2654,2674,2676,2693,2699,2701,2701,2703,2705,2707,2728,2730,2736,2738,2739,2741,2745,2749,2749,2768,2768,2784,2784,2821,2828,2831,2832,2835,2856,2858,2864,2866,2867,2870,2873,2877,2877,2908,2909,2911,2913,2949,2954,2958,2960,
2962,2965,2969,2970,2972,2972,2974,2975,2979,2980,2984,2986,2990,2997,2999,3001,3077,3084,3086,3088,3090,3112,3114,3123,3125,3129,3168,3169,3205,3212,3214,3216,3218,3240,3242,3251,3253,3257,3294,3294,3296,3297,3333,3340,3342,3344,3346,3368,3370,3385,3424,3425,3461,3478,3482,3505,3507,3515,3517,3517,3520,3526,3585,3632,3634,3635,3648,3654,3713,3714,3716,3716,3719,3720,3722,3722,3725,3725,3732,3735,3737,3743,3745,3747,3749,3749,3751,3751,3754,3755,3757,3760,3762,3763,3773,3773,3776,3780,3782,3782,3804,
3805,3840,3840,3904,3911,3913,3946,3976,3979,4096,4129,4131,4135,4137,4138,4176,4181,4256,4293,4304,4342,4352,4441,4447,4514,4520,4601,4608,4614,4616,4678,4680,4680,4682,4685,4688,4694,4696,4696,4698,4701,4704,4742,4744,4744,4746,4749,4752,4782,4784,4784,4786,4789,4792,4798,4800,4800,4802,4805,4808,4814,4816,4822,4824,4846,4848,4878,4880,4880,4882,4885,4888,4894,4896,4934,4936,4954,5024,5108,5121,5740,5743,5750,5761,5786,5792,5866,6016,6067,6176,6263,6272,6312,7680,7835,7840,7929,7936,7957,7960,7965,
7968,8005,8008,8013,8016,8023,8025,8025,8027,8027,8029,8029,8031,8061,8064,8116,8118,8124,8126,8126,8130,8132,8134,8140,8144,8147,8150,8155,8160,8172,8178,8180,8182,8188,8319,8319,8450,8450,8455,8455,8458,8467,8469,8469,8473,8477,8484,8484,8486,8486,8488,8488,8490,8493,8495,8497,8499,8505,8544,8579,12293,12295,12321,12329,12337,12341,12344,12346,12353,12436,12445,12446,12449,12538,12540,12542,12549,12588,12593,12686,12704,12727,13312,13312,19893,19893,19968,19968,40869,40869,40960,42124,44032,44032,
55203,55203,63744,64045,64256,64262,64275,64279,64285,64285,64287,64296,64298,64310,64312,64316,64318,64318,64320,64321,64323,64324,64326,64433,64467,64829,64848,64911,64914,64967,65008,65019,65136,65138],v27447=[65140,65140,65142,65276,65313,65338,65345,65370,65382,65470,65474,65479,65482,65487,65490,65495,65498,65500],unicodeES3IdStart=v27446.concat(v27447),unicodeES3IdCont=[768,846,864,866,1155,1158,1425,1441,1443,1465,1467,1469,1471,1471,1473,1474,1476,1476,1611,1621,1632,1641,1648,1648,1750,
1756,1759,1764,1767,1768,1770,1773,1776,1785,1809,1809,1840,1866,1958,1968,2305,2307,2364,2364,2366,2381,2385,2388,2402,2403,2406,2415,2433,2435,2492,2492,2494,2500,2503,2504,2507,2509,2519,2519,2530,2531,2534,2543,2562,2562,2620,2620,2622,2626,2631,2632,2635,2637,2662,2673,2689,2691,2748,2748,2750,2757,2759,2761,2763,2765,2790,2799,2817,2819,2876,2876,2878,2883,2887,2888,2891,2893,2902,2903,2918,2927,2946,2947,3006,3010,3014,3016,3018,3021,3031,3031,3047,3055,3073,3075,3134,3140,3142,3144,3146,3149,
3157,3158,3174,3183,3202,3203,3262,3268,3270,3272,3274,3277,3285,3286,3302,3311,3330,3331,3390,3395,3398,3400,3402,3405,3415,3415,3430,3439,3458,3459,3530,3530,3535,3540,3542,3542,3544,3551,3570,3571,3633,3633,3636,3642,3655,3662,3664,3673,3761,3761,3764,3769,3771,3772,3784,3789,3792,3801,3864,3865,3872,3881,3893,3893,3895,3895,3897,3897,3902,3903,3953,3972,3974,3975,3984,3991,3993,4028,4038,4038,4140,4146,4150,4153,4160,4169,4182,4185,4969,4977,6068,6099,6112,6121,6160,6169,6313,6313,8255,8256,8400,
8412,8417,8417,12330,12335,12441,12442,12539,12539,64286,64286,65056,65059,65075,65076,65101,65103,65296,65305,65343,65343,65381,65381],v27448=[170,170,181,181,186,186,192,214,216,246,248,705,710,721,736,740,748,748,750,750,880,884,886,887,890,893,902,902,904,906,908,908,910,929,931,1013,1015,1153,1162,1319,1329,1366,1369,1369,1377,1415,1488,1514,1520,1522,1568,1610,1646,1647,1649,1747,1749,1749,1765,1766,1774,1775,1786,1788,1791,1791,1808,1808,1810,1839,1869,1957,1969,1969,1994,2026,2036,2037,2042,
2042,2048,2069,2074,2074,2084,2084,2088,2088,2112,2136,2208,2208,2210,2220,2308,2361,2365,2365,2384,2384,2392,2401,2417,2423,2425,2431,2437,2444,2447,2448,2451,2472,2474,2480,2482,2482,2486,2489,2493,2493,2510,2510,2524,2525,2527,2529,2544,2545,2565,2570,2575,2576,2579,2600,2602,2608,2610,2611,2613,2614,2616,2617,2649,2652,2654,2654,2674,2676,2693,2701,2703,2705,2707,2728,2730,2736,2738,2739,2741,2745,2749,2749,2768,2768,2784,2785,2821,2828,2831,2832,2835,2856,2858,2864,2866,2867,2869,2873,2877,2877,
2908,2909,2911,2913,2929,2929,2947,2947,2949,2954,2958,2960,2962,2965,2969,2970,2972,2972,2974,2975,2979,2980,2984,2986,2990,3001,3024,3024,3077,3084,3086,3088,3090,3112,3114,3123,3125,3129,3133,3133,3160,3161,3168,3169,3205,3212,3214,3216,3218,3240,3242,3251,3253,3257,3261,3261,3294,3294,3296,3297,3313,3314,3333,3340,3342,3344,3346,3386,3389,3389,3406,3406,3424,3425,3450,3455,3461,3478,3482,3505,3507,3515,3517,3517,3520,3526,3585,3632,3634,3635,3648,3654,3713,3714,3716,3716,3719,3720,3722,3722,3725,
3725,3732,3735,3737,3743,3745,3747,3749,3749,3751,3751,3754,3755,3757,3760,3762,3763,3773,3773,3776,3780,3782,3782,3804,3807,3840,3840,3904,3911,3913,3948,3976,3980,4096,4138,4159,4159,4176,4181,4186,4189,4193,4193,4197,4198,4206,4208,4213,4225,4238,4238,4256,4293,4295,4295,4301,4301,4304,4346,4348,4680,4682,4685,4688,4694,4696,4696,4698,4701,4704,4744,4746,4749,4752,4784,4786,4789,4792,4798,4800,4800,4802,4805,4808,4822,4824,4880,4882,4885,4888,4954,4992,5007,5024,5108,5121,5740,5743,5759,5761,5786,
5792,5866,5870,5872,5888,5900,5902,5905,5920,5937,5952,5969,5984,5996,5998,6E3,6016,6067,6103,6103,6108,6108,6176,6263,6272,6312,6314,6314,6320,6389,6400,6428,6480,6509,6512,6516,6528,6571,6593,6599,6656,6678,6688,6740,6823,6823,6917,6963,6981,6987,7043,7072,7086,7087,7098,7141,7168,7203,7245,7247,7258,7293,7401,7404,7406,7409,7413,7414,7424,7615,7680,7957,7960,7965,7968,8005,8008,8013,8016,8023,8025,8025,8027,8027,8029,8029,8031,8061,8064,8116,8118,8124,8126,8126,8130,8132,8134,8140,8144,8147,8150,
8155,8160,8172,8178,8180,8182,8188,8305,8305,8319,8319,8336,8348,8450,8450,8455,8455],v27449=[8458,8467,8469,8469,8473,8477,8484,8484,8486,8486,8488,8488,8490,8493,8495,8505,8508,8511,8517,8521,8526,8526,8544,8584,11264,11310,11312,11358,11360,11492,11499,11502,11506,11507,11520,11557,11559,11559,11565,11565,11568,11623,11631,11631,11648,11670,11680,11686,11688,11694,11696,11702,11704,11710,11712,11718,11720,11726,11728,11734,11736,11742,11823,11823,12293,12295,12321,12329,12337,12341,12344,12348,
12353,12438,12445,12447,12449,12538,12540,12543,12549,12589,12593,12686,12704,12730,12784,12799,13312,13312,19893,19893,19968,19968,40908,40908,40960,42124,42192,42237,42240,42508,42512,42527,42538,42539,42560,42606,42623,42647,42656,42735,42775,42783,42786,42888,42891,42894,42896,42899,42912,42922,43E3,43009,43011,43013,43015,43018,43020,43042,43072,43123,43138,43187,43250,43255,43259,43259,43274,43301,43312,43334,43360,43388,43396,43442,43471,43471,43520,43560,43584,43586,43588,43595,43616,43638,
43642,43642,43648,43695,43697,43697,43701,43702,43705,43709,43712,43712,43714,43714,43739,43741,43744,43754,43762,43764,43777,43782,43785,43790,43793,43798,43808,43814,43816,43822,43968,44002,44032,44032,55203,55203,55216,55238,55243,55291,63744,64109,64112,64217,64256,64262,64275,64279,64285,64285,64287,64296,64298,64310,64312,64316,64318,64318,64320,64321,64323,64324,64326,64433,64467,64829,64848,64911,64914,64967,65008,65019,65136,65140,65142,65276,65313,65338,65345,65370,65382,65470,65474,65479,
65482,65487,65490,65495,65498,65500],unicodeES5IdStart=v27448.concat(v27449),unicodeES5IdCont=[768,879,1155,1159,1425,1469,1471,1471,1473,1474,1476,1477,1479,1479,1552,1562,1611,1641,1648,1648,1750,1756,1759,1764,1767,1768,1770,1773,1776,1785,1809,1809,1840,1866,1958,1968,1984,1993,2027,2035,2070,2073,2075,2083,2085,2087,2089,2093,2137,2139,2276,2302,2304,2307,2362,2364,2366,2383,2385,2391,2402,2403,2406,2415,2433,2435,2492,2492,2494,2500,2503,2504,2507,2509,2519,2519,2530,2531,2534,2543,2561,2563,
2620,2620,2622,2626,2631,2632,2635,2637,2641,2641,2662,2673,2677,2677,2689,2691,2748,2748,2750,2757,2759,2761,2763,2765,2786,2787,2790,2799,2817,2819,2876,2876,2878,2884,2887,2888,2891,2893,2902,2903,2914,2915,2918,2927,2946,2946,3006,3010,3014,3016,3018,3021,3031,3031,3046,3055,3073,3075,3134,3140,3142,3144,3146,3149,3157,3158,3170,3171,3174,3183,3202,3203,3260,3260,3262,3268,3270,3272,3274,3277,3285,3286,3298,3299,3302,3311,3330,3331,3390,3396,3398,3400,3402,3405,3415,3415,3426,3427,3430,3439,3458,
3459,3530,3530,3535,3540,3542,3542,3544,3551,3570,3571,3633,3633,3636,3642,3655,3662,3664,3673,3761,3761,3764,3769,3771,3772,3784,3789,3792,3801,3864,3865,3872,3881,3893,3893,3895,3895,3897,3897,3902,3903,3953,3972,3974,3975,3981,3991,3993,4028,4038,4038,4139,4158,4160,4169,4182,4185,4190,4192,4194,4196,4199,4205,4209,4212,4226,4237,4239,4253,4957,4959,5906,5908,5938,5940,5970,5971,6002,6003,6068,6099,6109,6109,6112,6121,6155,6157,6160,6169,6313,6313,6432,6443,6448,6459,6470,6479,6576,6592,6600,6601,
6608,6617,6679,6683,6741,6750,6752,6780,6783,6793,6800,6809,6912,6916,6964,6980,6992,7001,7019,7027,7040,7042,7073,7085,7088,7097,7142,7155,7204,7223,7232,7241,7248,7257,7376,7378,7380,7400,7405,7405,7410,7412,7616,7654,7676,7679,8204,8205,8255,8256,8276,8276,8400,8412,8417,8417,8421,8432,11503,11505,11647,11647,11744,11775,12330,12335,12441,12442,42528,42537,42607,42607,42612,42621,42655,42655,42736,42737,43010,43010,43014,43014,43019,43019,43043,43047,43136,43137,43188,43204,43216,43225,43232,43249,
43264,43273,43302,43309,43335,43347,43392,43395,43443,43456,43472,43481,43561,43574,43587,43587,43596,43597,43600,43609,43643,43643,43696,43696,43698,43700,43703,43704,43710,43711,43713,43713,43755,43759,43765,43766,44003,44010,44012,44013,44016,44025,64286,64286,65024,65039,65056,65062,65075,65076,65101,65103,65296,65305,65343,65343];TypeScript.LexLookUpUnicodeMap=LexLookUpUnicodeMap;TypeScript.LexIsUnicodeDigit=LexIsUnicodeDigit;TypeScript.LexIsUnicodeIdStart=LexIsUnicodeIdStart;TypeScript.LexInitialize=
LexInitialize;TypeScript.LexAdjustIndent=LexAdjustIndent;TypeScript.LexIsIdentifierStartChar=LexIsIdentifierStartChar;TypeScript.LexIsDigit=LexIsDigit;TypeScript.LexIsIdentifierChar=LexIsIdentifierChar;TypeScript.LexMatchingOpen=LexMatchingOpen;var v16032=TypeScript.NumberScanState,v20883=!v16032;v20883&&(v16032=TypeScript.NumberScanState={});var v7934=v16032;v600(v7934);var NumberScanState=TypeScript.NumberScanState,v16033=TypeScript.LexState,v20884=!v16033;v20884&&(v16033=TypeScript.LexState={});
var v7935=v16033;v601(v7935);var LexState=TypeScript.LexState,v16034=TypeScript.LexMode,v20885=!v16034;v20885&&(v16034=TypeScript.LexMode={});var v7936=v16034;v602(v7936);var LexMode=TypeScript.LexMode,v16035=TypeScript.CommentStyle,v20886=!v16035;v20886&&(v16035=TypeScript.CommentStyle={});var v7937=v16035;v603(v7937);var StringSourceText=v606();TypeScript.StringSourceText=StringSourceText;var SourceTextSegment=v609();TypeScript.SourceTextSegment=SourceTextSegment;var AggerateSourceTextSegment=v612();
TypeScript.AggerateSourceTextSegment=AggerateSourceTextSegment;var ScannerTextStream=v618();TypeScript.ScannerTextStream=ScannerTextStream;var SavedTokens=v633();TypeScript.SavedTokens=SavedTokens;var Scanner=v674();TypeScript.Scanner=Scanner;TypeScript.convertTokToIDName=convertTokToIDName;TypeScript.convertTokToID=convertTokToID;TypeScript.getLineNumberFromPosition=getLineNumberFromPosition;TypeScript.getSourceLineColFromMap=getSourceLineColFromMap;TypeScript.getLineColumnFromPosition=getLineColumnFromPosition;
TypeScript.getPositionFromLineColumn=getPositionFromLineColumn;TypeScript.isPrimitiveTypeToken=isPrimitiveTypeToken;TypeScript.isModifier=isModifier}
function v599(){var TypeScript=v12355;function v598(){function v597(s){var v16036=this.builder;this.builder=v16036+s;s=this.outfile;v16036=this.builder;JAMScript.call(s.WriteLine,s,[v16036]);this.builder=""}function v596(s){var v16037=this.builder;this.builder=v16037+s}function v595(){var v20887=this.builder,v20887=v20887.length;if(v20887=0<v20887){var v20887=TypeScript.CompilerDiagnostics,v7941=this.builder;JAMScript.call(v20887.Alert,v20887,[v7941])}v20887=this.indentStrings;v7941=this.indentAmt;
introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v20887=v20887[v7941];if(v7941=void 0===v20887){for(var v20887="",v7941=0,v16039=this.indentAmt,v16039=v7941<v16039;v16039;)v16039=this.indent1,v20887+=v16039,v7941+=1,v16039=this.indentAmt,v16039=v7941<v16039;v7941=this.indentStrings;v16039=this.indentAmt;JAMScript.set(v7941,v16039,v20887)}v7941=this.builder;this.builder=v7941+v20887}function v594(){var v16043=this.indentAmt;this.indentAmt=v16043-1}function v593(){var v16044=
this.indentAmt;this.indentAmt=v16044+1}function PrintContext(outfile,parser){this.outfile=outfile;this.parser=parser;this.builder="";this.indent1="  ";this.indentStrings=[];this.indentAmt=0}var v7949=PrintContext.prototype;v7949.increaseIndent=v593;v7949=PrintContext.prototype;v7949.decreaseIndent=v594;v7949=PrintContext.prototype;v7949.startLine=v595;v7949=PrintContext.prototype;v7949.write=v596;v7949=PrintContext.prototype;v7949.writeLine=v597;return PrintContext}function prePrintAST(ast,parent,
walker){parent=walker.state;JAMScript.call(ast.print,ast,[parent]);JAMScript.call(parent.increaseIndent,parent,[]);return ast}function postPrintAST(ast,parent,walker){parent=walker.state;JAMScript.call(parent.decreaseIndent,parent,[]);return ast}var PrintContext=v598();TypeScript.PrintContext=PrintContext;TypeScript.prePrintAST=prePrintAST;TypeScript.postPrintAST=postPrintAST}
function v592(){var TypeScript=v12354;function v591(){function v590(sourceText,filename,unitIndex,allowedElements){function v589(message){return JAMScript.call(_this.reportParseError,_this,[message])}var v16045=typeof allowedElements;if(v16045="undefined"===v16045)v16045=TypeScript.AllowedElements,allowedElements=v16045.Global;var _this=this;this.ambientModule=!1;this.topLevel=!0;this.requiresExtendsBlock=this.hasTopLevelImportOrExport=!1;this.fname=filename;this.currentUnitIndex=unitIndex;this.amdDependencies=
[];v16045=this.scanner;JAMScript.call(v16045.resetComments,v16045,[]);v16045=this.scanner;JAMScript.call(v16045.setErrorHandler,v16045,[v589]);var v16045=this.scanner,v16046=TypeScript.LexMode,v16046=v16046.File;JAMScript.call(v16045.setSourceText,v16045,[sourceText,v16046]);sourceText=this.scanner;v16045=sourceText.leftCurlyCount;sourceText=this.scanner;sourceText=sourceText.rightCurlyCount;var v16046=this.scanner,v16046=v16046.pos,v7963=this.scanner;this.currentToken=v7963=JAMScript.call(v7963.scan,
v7963,[]);JAMScript.call(this.pushDeclLists,this,[]);v7963=TypeScript.ASTList;v7963=JAMScript.new(v7963,[]);v7963.minChar=v16046;this.state=ParseState.StartScript;var v7965=JAMScript.call(TypeScript.isDSTRFile,TypeScript,[filename]),v16047=!v7965;v16047&&(v7965=JAMScript.call(TypeScript.isDTSFile,TypeScript,[filename]));for(this.parsingDeclareFile=v7965;;){v7965=TypeScript.ErrorRecoverySet;v7965=v7965.EOF;v16047=TypeScript.ErrorRecoverySet;v16047=v16047.Func;v7965|=v16047;v16047=TypeScript.Modifiers;
v16047=v16047.None;JAMScript.call(this.parseStatementList,this,[v7965,v7963,!0,!1,allowedElements,v16047]);v7965=this.currentToken;v7965=v7965.tokenId;v16047=TypeScript.TokenID;v16047=v16047.EndOfFile;if(v7965=v7965===v16047)break;v7965=TypeScript.tokenTable;v16047=this.currentToken;v16047=v16047.tokenId;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v7965=v7965[v16047];v7965=v7965.text;v7965="Unexpected statement block terminator '"+v7965;v7965+="'";JAMScript.call(this.reportParseError,
this,[v7965]);v7965=this.scanner;this.currentToken=v7965=JAMScript.call(v7965.scan,v7965,[])}this.state=ParseState.EndScript;allowedElements=this.scanner;v7963.limChar=allowedElements.pos;allowedElements=null;v7965=TypeScript.moduleGenTarget;v16047=TypeScript.ModuleGenTarget;v16047=v16047.Local;if(v7965=v7965!=v16047)v7965=this.hasTopLevelImportOrExport;if(v7965){v7965=JAMScript.call(TypeScript.switchToForwardSlashes,TypeScript,[filename]);allowedElements=TypeScript.Identifier;allowedElements=JAMScript.new(allowedElements,
[v7965]);var v16047=TypeScript.ModuleDeclaration,v7976=JAMScript.call(this.topVarList,this,[]),v7977=JAMScript.call(this.topScopeList,this,[]);allowedElements=JAMScript.new(v16047,[allowedElements,v7963,v7976,v7977,null]);v7963=allowedElements.modFlags;v16047=TypeScript.ModuleFlags;v16047=v16047.IsDynamic;allowedElements.modFlags=v7963|v16047;v7963=allowedElements.modFlags;v16047=TypeScript.ModuleFlags;v16047=v16047.IsWholeFile;allowedElements.modFlags=v7963|v16047;v7963=allowedElements.modFlags;
v16047=TypeScript.ModuleFlags;v16047=v16047.Exported;allowedElements.modFlags=v7963|v16047;if(v7963=this.parsingDeclareFile)v7963=allowedElements.modFlags,v16047=TypeScript.ModuleFlags,v16047=v16047.Ambient,allowedElements.modFlags=v7963|v16047;allowedElements.minChar=v16046;v7963=this.scanner;allowedElements.limChar=v7963.pos;v7963=allowedElements;v7965=JAMScript.call(TypeScript.getPrettyName,TypeScript,[v7965]);v7963.prettyName=v7965;v7963=this.scanner;allowedElements.containsUnicodeChar=v7963.seenUnicodeChar;
v7963=this.scanner;allowedElements.containsUnicodeCharInComment=v7963.seenUnicodeCharInComment;allowedElements.amdDependencies=this.amdDependencies;v7963=TypeScript.ASTList;v7963=JAMScript.new(v7963,[]);v7963.minChar=allowedElements.minChar;v7963.limChar=allowedElements.limChar;JAMScript.call(v7963.append,v7963,[allowedElements])}v7965=TypeScript.Script;v16047=JAMScript.call(this.topVarList,this,[]);v7976=JAMScript.call(this.topScopeList,this,[]);v7965=JAMScript.new(v7965,[v16047,v7976]);v7965.bod=
v7963;JAMScript.call(this.popDeclLists,this,[]);v7965.minChar=v16046;v16046=this.scanner;v7965.limChar=v16046.pos;v16046=v7965;v7963=TypeScript.LocationInfo;v16047=this.scanner;v16047=v16047.lineMap;filename=JAMScript.new(v7963,[filename,v16047,unitIndex]);v16046.locationInfo=filename;filename=this.scanner;filename=filename.leftCurlyCount;v7965.leftCurlyCount=filename-v16045;filename=this.scanner;filename=filename.rightCurlyCount;v7965.rightCurlyCount=filename-sourceText;v7965.isDeclareFile=this.parsingDeclareFile;
v7965.topLevelMod=allowedElements;filename=this.scanner;v7965.containsUnicodeChar=filename.seenUnicodeChar;filename=this.scanner;v7965.containsUnicodeCharInComment=filename.seenUnicodeCharInComment;v7965.requiresExtendsBlock=this.requiresExtendsBlock;return v7965}function v588(sourceText,filename,unitIndex){var svGenTarget=TypeScript.moduleGenTarget;try{var v7994=TypeScript.ModuleGenTarget;TypeScript.moduleGenTarget=v7994.Local;var v16068=TypeScript.AllowedElements,v7995=v16068.QuickParse,script=
JAMScript.call(this.parse,this,[sourceText,filename,unitIndex,v7995]),v16069=this.scanner,v7996=v16069.lexState;return JAMScript.new(QuickParseResult,[script,v7996])}finally{TypeScript.moduleGenTarget=svGenTarget}}function v587(errorRecoverySet,statements,sourceElms,noLeadingCase,allowedElements,parentModifiers){var directivePrologue=sourceElms,v7997=this.scanner;statements.minChar=v7997.startPos;var v7998=this.scanner,limChar=v7998.pos,v20900=TypeScript.AllowedElements,v16070=v20900.ModuleDeclarations,
v7999=allowedElements&v16070,v16071=TypeScript.AllowedElements,v8000=v16071.None,innerStmts=v7999==v8000,v20901=TypeScript.AllowedElements,v16072=v20901.ClassDeclarations,v8001=allowedElements&v16072,v16073=TypeScript.AllowedElements,v8002=v16073.None,classNope=v8001==v8002,v23778=TypeScript.ErrorRecoverySet,v20902=v23778.TypeScriptS,v23779=TypeScript.ErrorRecoverySet,v20903=v23779.RCurly,v16074=v20902|v20903;errorRecoverySet|=v16074;this.state=ParseState.StartStatementList;var oldStrictMode=this.strictMode,
v16075=this.nestingLevel;for(this.nestingLevel=v16075+1;;){var v23780=this.currentToken,v20904=v23780.tokenId,v23781=TypeScript.TokenID,v20905=v23781.CloseBrace,v16076=v20904==v20905,v20907=!v16076;if(v20907){var v23782=noLeadingCase;if(v23782){var v26378=this.currentToken,v25961=v26378.tokenId,v26379=TypeScript.TokenID,v25962=v26379.Case,v25199=v25961==v25962,v25965=!v25199;if(v25965)var v26380=this.currentToken,v25963=v26380.tokenId,v26381=TypeScript.TokenID,v25964=v26381.Default,v25199=v25963==
v25964;v23782=v25199}var v20906=v23782,v23784=!v20906;if(v23784){var v25200=innerStmts;if(v25200)var v26382=this.currentToken,v25966=v26382.tokenId,v26383=TypeScript.TokenID,v25967=v26383.Export,v25200=v25966==v25967;var v23783=v25200,v25202=!v23783;if(v25202){var v25968=classNope;if(v25968)var v26560=this.currentToken,v26384=v26560.tokenId,v26561=TypeScript.TokenID,v26385=v26561.Class,v25968=v26384==v26385;var v25201=v25968,v25971=!v25201;if(v25971)var v26386=this.currentToken,v25969=v26386.tokenId,
v26387=TypeScript.TokenID,v25970=v26387.EndOfFile,v25201=v25969==v25970;v23783=v25201}v20906=v23783}v16076=v20906}var v8006=v16076;if(v8006){this.state=ParseState.EndStmtList;statements.limChar=limChar;var v20908=statements.members,v16077=v20908.length,v8005=0==v16077;if(v8005){var v8003=statements,v27087=JAMScript.call(this.parseComments,this,[]);v8003.preComments=v27087}else{var v8004=statements,v27088=JAMScript.call(this.parseComments,this,[]);v8004.postComments=v27088}this.strictMode=oldStrictMode;
var v16078=this.nestingLevel;this.nestingLevel=v16078-1;break}var v26388=TypeScript.ErrorRecoverySet,v25972=v26388.Else,v26389=TypeScript.ErrorRecoverySet,v25973=v26389.RParen,v25203=v25972|v25973,v25974=TypeScript.ErrorRecoverySet,v25204=v25974.Catch,v23785=v25203|v25204,v25205=TypeScript.ErrorRecoverySet,v23786=v25205.Colon,v20909=v23785|v23786,v16079=~v20909,v8007=errorRecoverySet&v16079,stmt=JAMScript.call(this.parseStatement,this,[v8007,allowedElements,parentModifiers]);if(stmt){var v8008=stmt,
v16080=stmt.postComments,v23787=this.scanner,v20910=v23787.prevLine,v16081=JAMScript.call(this.parseCommentsForLine,this,[v20910]),v27089=JAMScript.call(this.combineComments,this,[v16080,v16081]);v8008.postComments=v27089;JAMScript.call(statements.append,statements,[stmt]);limChar=stmt.limChar;if(directivePrologue){var v16082=stmt.nodeType,v20911=TypeScript.NodeType,v16083=v20911.QString,v8010=v16082==v16083;if(v8010){var qstring=stmt,v16084=qstring.text,v8009='"use strict"'==v16084;if(v8009){var v16085=
statements.flags,v20912=TypeScript.ASTFlags,v16086=v20912.StrictMode;statements.flags=v16085|v16086;this.strictMode=!0}else directivePrologue=!1}else directivePrologue=!1}}}}function v586(ast){var nt=ast.nodeType,v20913=TypeScript.NodeType,v20913=v20913.ClassDeclaration,v20913=nt==v20913,v16089=!v20913;if(v16089&&(v20913=TypeScript.NodeType,v20913=v20913.ImportDeclaration,v20913=nt==v20913,v16089=!v20913)&&(v20913=TypeScript.NodeType,v20913=v20913.InterfaceDeclaration,v20913=nt==v20913,v16089=!v20913)&&
(v20913=TypeScript.NodeType,v20913=v20913.ModuleDeclaration,v20913=nt==v20913,v16089=!v20913)&&(v20913=TypeScript.NodeType,v20913=v20913.Empty,v20913=nt==v20913,v16089=!v20913)&&(v20913=TypeScript.NodeType,v20913=v20913.VarDecl,v20913=nt==v20913,v16089=!v20913)){v20913=TypeScript.NodeType;v20913=v20913.Block;if(v20913=nt==v20913)v20913=ast.isStatementBlock,v20913=!v20913;if(v16089=!v20913)v20913=TypeScript.NodeType,v20913=v20913.FuncDecl,(nt=nt==v20913)&&(nt=JAMScript.call(ast.isMethod,ast,[])),v20913=
nt}return v20913}function v585(errorRecoverySet,allowedElements,parentModifiers){function isAmbient(){var v20917=TypeScript.Modifiers,v20917=v20917.Ambient,v20917=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v20917]),v16092=!v20917;v16092&&(v20917=TypeScript.Modifiers,v20917=v20917.Ambient,v20917=JAMScript.call(TypeScript.hasFlag,TypeScript,[parentModifiers,v20917]));return v20917}function mayNotBeExported(){var v20919=TypeScript.Modifiers,v20919=v20919.Exported;(v20919=JAMScript.call(TypeScript.hasFlag,
TypeScript,[modifiers,v20919]))&&JAMScript.call(this.reportError,this,["Statement may not be exported"])}var ast=null,labelList=null,temp,v8014=TypeScript.Modifiers,modifiers=v8014.None,v8015=this.scanner,minChar=v8015.startPos,forInOk=!1,needTerminator=!1,fnOrVar=null,preComments=JAMScript.call(this.parseComments,this,[]);for(this.state=ParseState.StartStatement;;){var v16094=this.currentToken,v8331=v16094.tokenId;switch(v8331){case TypeScript.TokenID.EndOfFile:var v8016=TypeScript.AST,v16095=TypeScript.NodeType,
v8017=v16095.Error,ast=JAMScript.new(v8016,[v8017]);ast.minChar=minChar;var v8018=this.scanner;ast.limChar=v8018.pos;break;case TypeScript.TokenID.Function:var v16096=this.parsingDeclareFile,v20921=!v16096;if(v20921){var v20920=isAmbient(),v23792=!v20920;v23792&&(v20920=this.ambientModule);v16096=v20920}var v8028=v16096;if(v8028){var v8019=this.scanner,v27090=JAMScript.call(v8019.scan,v8019,[]);this.currentToken=v27090;var v20922=TypeScript.ErrorRecoverySet,v16097=v20922.SColon,v8020=errorRecoverySet|
v16097,fnOrVar=JAMScript.call(this.parsePropertyDeclaration,this,[v8020,modifiers,!0,!1]),v16098=fnOrVar.nodeType,v20923=TypeScript.NodeType,v16099=v20923.VarDecl,v8022=v16098==v16099;if(v8022)JAMScript.call(this.reportParseError,this,["function keyword can only introduce function declaration"]);else{var v20924=fnOrVar.nodeType,v23793=TypeScript.NodeType,v20925=v23793.FuncDecl,v16100=v20924==v20925;if(v16100)var v23794=TypeScript.FncFlags,v16100=v23794.IsFatArrowFunction;var v8021=v16100;v8021&&(needTerminator=
!0)}var ast=fnOrVar,v16101=this.parsingDeclareFile,v20927=!v16101;if(v20927){var v20926=this.ambientModule;if(v20926)var v23795=ast.nodeType,v25210=TypeScript.NodeType,v23796=v25210.FuncDecl,v20926=v23795==v23796;v16101=v20926}var v8023=v16101;if(v8023){var v16102=ast.fncFlags,v20928=TypeScript.FncFlags,v16103=v20928.Exported;ast.fncFlags=v16102|v16103}}else{var v8024=isAmbient(),ast=JAMScript.call(this.parseFncDecl,this,[errorRecoverySet,!0,!1,!1,null,!1,!1,v8024,modifiers,null,!0]),v16104=ast.fncFlags,
v20929=TypeScript.FncFlags,v16105=v20929.IsFatArrowFunction,v8025=JAMScript.call(TypeScript.hasFlag,TypeScript,[v16104,v16105]);v8025&&(needTerminator=!0);var v8026=this.ambientModule;v8026&&JAMScript.call(this.reportParseError,this,["function declaration not permitted within ambient module"]);var v20930=TypeScript.Modifiers,v16106=v20930.Exported,v8027=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v16106]);if(v8027){var v16107=ast.fncFlags,v20931=TypeScript.FncFlags,v16108=v20931.Exported;
ast.fncFlags=v16107|v16108}}break;case TypeScript.TokenID.Module:var v23797=TypeScript.AllowedElements,v20932=v23797.ModuleDeclarations,v16109=allowedElements&v20932,v20933=TypeScript.AllowedElements,v16110=v20933.None,v8033=v16109==v16110;if(v8033){JAMScript.call(this.reportParseError,this,["module not allowed in this context"]);var v8029=this.scanner,v27091=JAMScript.call(v8029.scan,v8029,[]);this.currentToken=v27091;var v8030=TypeScript.AST,v16111=TypeScript.NodeType,v8031=v16111.Error,ast=JAMScript.new(v8030,
[v8031]);ast.minChar=minChar;var v8032=ast,v16112=this.scanner,v27092=JAMScript.call(v16112.lastTokenLimChar,v16112,[]);v8032.limChar=v27092}else ast=JAMScript.call(this.parseModuleDecl,this,[errorRecoverySet,modifiers,preComments]),preComments=null;break;case TypeScript.TokenID.Import:var v23798=TypeScript.AllowedElements,v20934=v23798.ModuleDeclarations,v16113=allowedElements&v20934,v20935=TypeScript.AllowedElements,v16114=v20935.None,v8039=v16113==v16114;if(v8039){JAMScript.call(this.reportParseError,
this,["module not allowed in this context"]);var v8034=this.scanner,v27093=JAMScript.call(v8034.scan,v8034,[]);this.currentToken=v27093;var v8035=TypeScript.AST,v16115=TypeScript.NodeType,v8036=v16115.Error,ast=JAMScript.new(v8035,[v8036]);ast.minChar=minChar;var v8037=ast,v16116=this.scanner,v27094=JAMScript.call(v16116.lastTokenLimChar,v16116,[]);v8037.limChar=v27094}else{var v20936=TypeScript.Modifiers,v16117=v20936.Exported,v8038=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v16117]);
v8038&&JAMScript.call(this.reportParseError,this,["export keyword not permitted on import declaration"]);ast=JAMScript.call(this.parseImportDeclaration,this,[errorRecoverySet,modifiers]);needTerminator=!0}break;case TypeScript.TokenID.Export:var v23799=TypeScript.AllowedElements,v20937=v23799.ModuleDeclarations,v16118=allowedElements&v20937,v20938=TypeScript.AllowedElements,v16119=v20938.None,v8044=v16118==v16119;if(v8044){JAMScript.call(this.reportParseError,this,["'export' statements are only allowed at the global and module levels"]);
var v8040=this.scanner,v27095=JAMScript.call(v8040.scan,v8040,[]);this.currentToken=v27095;var v8041=TypeScript.AST,v16120=TypeScript.NodeType,v8042=v16120.Error,ast=JAMScript.new(v8041,[v8042]);ast.minChar=minChar;var v8043=ast,v16121=this.scanner,v27096=JAMScript.call(v16121.lastTokenLimChar,v16121,[]);v8043.limChar=v27096}var v8045=this.topLevel;v8045&&(this.hasTopLevelImportOrExport=!0);var v20939=TypeScript.Modifiers,v16122=v20939.Exported,modifiers=modifiers|v16122,v8046=this.scanner,v27097=
JAMScript.call(v8046.scan,v8046,[]);this.currentToken=v27097;break;case TypeScript.TokenID.Private:var v20940=TypeScript.Modifiers,v16123=v20940.Private,modifiers=modifiers|v16123,v8047=this.scanner,v27098=JAMScript.call(v8047.scan,v8047,[]);this.currentToken=v27098;var v8074=this.parsingClassConstructorDefinition;if(v8074){var v16124=this.inferPropertiesFromThisAssignment,v8048=!v16124;v8048&&JAMScript.call(this.reportParseError,this,["Property declarations are not permitted within constructor bodies"]);
var v8049=this.scanner,minChar=v8049.pos,v16125=this.inferPropertiesFromThisAssignment;if(v16125){var v25211=this.currentToken,v23800=v25211.tokenId,v25212=TypeScript.TokenID,v23801=v25212.This,v20941=v23800!=v23801,v23804=!v20941;if(v23804)var v25979=this.scanner,v27099=JAMScript.call(v25979.scan,v25979,[]),v25213=this.currentToken=v27099,v23802=v25213.tokenId,v25214=TypeScript.TokenID,v23803=v25214.Dot,v20941=v23802!=v23803;v16125=v20941}var v8061=v16125;if(v8061){JAMScript.call(this.reportParseError,
this,["Expected 'this.' for property declaration"]);var v8050=this.scanner,v27100=JAMScript.call(v8050.scan,v8050,[]);this.currentToken=v27100;var v8051=TypeScript.AST,v16126=TypeScript.NodeType,v8052=v16126.Error,ast=JAMScript.new(v8051,[v8052]);ast.minChar=minChar;var v8053=ast,v16127=this.scanner,v27101=JAMScript.call(v16127.lastTokenLimChar,v16127,[]);v8053.limChar=v27101}else{var v8054=this.scanner,v27102=JAMScript.call(v8054.scan,v8054,[]);this.currentToken=v27102;var v8055=TypeScript.Identifier,
v8056=this.currentToken,id=JAMScript.call(v8055.fromToken,v8055,[v8056]),v8057=this.scanner;id.minChar=v8057.startPos;var v8058=this.scanner;id.limChar=v8058.pos;var v8059=this.scanner,v27103=JAMScript.call(v8059.scan,v8059,[]);this.currentToken=v27103;var v8060=this.parsingClassConstructorDefinition,ast=JAMScript.call(this.parseClassMemberVariableDeclaration,this,[id,minChar,v8060,errorRecoverySet,modifiers])}}else{var v20942=this.currentToken,v16128=v20942.tokenId,v20943=TypeScript.TokenID,v16129=
v20943.Interface,v8073=v16128!=v16129;if(v8073){var v20944=this.currentToken,v16130=v20944.tokenId,v20945=TypeScript.TokenID,v16131=v20945.Get,v8069=v16130==v16131;if(v8069){this.prevIDTok=this.currentToken;var v8062=this.scanner,v27104=JAMScript.call(v8062.scan,v8062,[]);this.currentToken=v27104;var v16132=TypeScript.codeGenTarget,v20946=TypeScript.CodeGenTarget,v16133=v20946.ES5,v8063=v16132<v16133;v8063&&JAMScript.call(this.reportParseError,this,["Property accessors are only available when targeting ES5 or greater"]);
var v23805=this.currentToken,v20947=v23805.tokenId,v23806=TypeScript.TokenID,v20948=v23806.Identifier,v16134=v20947==v20948,v20951=!v16134;if(v20951)var v20949=this.currentToken,v20950=this.strictMode,v16134=JAMScript.call(TypeScript.convertTokToID,TypeScript,[v20949,v20950]);var v8064=v16134;if(v8064){var v20952=TypeScript.Modifiers,v16135=v20952.Getter,modifiers=modifiers|v16135;this.prevIDTok=null}}else{var v20953=this.currentToken,v16136=v20953.tokenId,v20954=TypeScript.TokenID,v16137=v20954.Set,
v8068=v16136==v16137;if(v8068){this.prevIDTok=this.currentToken;var v8065=this.scanner,v27105=JAMScript.call(v8065.scan,v8065,[]);this.currentToken=v27105;var v16138=TypeScript.codeGenTarget,v20955=TypeScript.CodeGenTarget,v16139=v20955.ES5,v8066=v16138<v16139;v8066&&JAMScript.call(this.reportParseError,this,["Property accessors are only available when targeting ES5 or greater"]);var v23807=this.currentToken,v20956=v23807.tokenId,v23808=TypeScript.TokenID,v20957=v23808.Identifier,v16140=v20956==v20957,
v20960=!v16140;if(v20960)var v20958=this.currentToken,v20959=this.strictMode,v16140=JAMScript.call(TypeScript.convertTokToID,TypeScript,[v20958,v20959]);var v8067=v16140;if(v8067){var v20961=TypeScript.Modifiers,v16141=v20961.Setter,modifiers=modifiers|v16141;this.prevIDTok=null}}}var v20962=TypeScript.ErrorRecoverySet,v16142=v20962.SColon,v8070=errorRecoverySet|v16142,v8071=isAmbient(),fnOrVar=JAMScript.call(this.parsePropertyDeclaration,this,[v8070,modifiers,v8071,!1]),v20963=fnOrVar.nodeType,v23809=
TypeScript.NodeType,v20964=v23809.VarDecl,v16143=v20963==v20964,v20966=!v16143;if(v20966){var v23810=fnOrVar.nodeType,v25215=TypeScript.NodeType,v23811=v25215.FuncDecl,v20965=v23810==v23811;if(v20965)var v23812=fnOrVar.fncFlags,v25216=TypeScript.FncFlags,v23813=v25216.IsFatArrowFunction,v20965=JAMScript.call(TypeScript.hasFlag,TypeScript,[v23812,v23813]);v16143=v20965}var v8072=v16143;v8072&&(needTerminator=!0);ast=fnOrVar}}break;case TypeScript.TokenID.Public:var v8107=this.parsingClassConstructorDefinition;
if(v8107){var v16144=this.inferPropertiesFromThisAssignment,v8075=!v16144;v8075&&JAMScript.call(this.reportParseError,this,["Property declarations are not permitted within constructor bodies"]);var v8076=this.scanner,v27106=JAMScript.call(v8076.scan,v8076,[]);this.currentToken=v27106;var v8077=this.scanner,minChar=v8077.pos,v20967=TypeScript.Modifiers,v16145=v20967.Public,modifiers=modifiers|v16145,v16146=this.inferPropertiesFromThisAssignment;if(v16146){var v25217=this.currentToken,v23814=v25217.tokenId,
v25218=TypeScript.TokenID,v23815=v25218.This,v20968=v23814!=v23815,v23818=!v20968;if(v23818)var v25980=this.scanner,v27107=JAMScript.call(v25980.scan,v25980,[]),v25219=this.currentToken=v27107,v23816=v25219.tokenId,v25220=TypeScript.TokenID,v23817=v25220.Dot,v20968=v23816!=v23817;v16146=v20968}var v8089=v16146;if(v8089){JAMScript.call(this.reportParseError,this,["Expected 'this.' for property declaration"]);var v8078=this.scanner,v27108=JAMScript.call(v8078.scan,v8078,[]);this.currentToken=v27108;
var v8079=TypeScript.AST,v16147=TypeScript.NodeType,v8080=v16147.Error,ast=JAMScript.new(v8079,[v8080]);ast.minChar=minChar;var v8081=ast,v16148=this.scanner,v27109=JAMScript.call(v16148.lastTokenLimChar,v16148,[]);v8081.limChar=v27109}else{var v8082=this.scanner,v27110=JAMScript.call(v8082.scan,v8082,[]);this.currentToken=v27110;var v8083=TypeScript.Identifier,v8084=this.currentToken,id=JAMScript.call(v8083.fromToken,v8083,[v8084]),v8085=this.scanner;id.minChar=v8085.startPos;var v8086=this.scanner;
id.limChar=v8086.pos;var v8087=this.scanner,v27111=JAMScript.call(v8087.scan,v8087,[]);this.currentToken=v27111;var v8088=this.parsingClassConstructorDefinition,ast=JAMScript.call(this.parseClassMemberVariableDeclaration,this,[id,minChar,v8088,errorRecoverySet,modifiers])}}else{var v23819=TypeScript.AllowedElements,v20969=v23819.Properties,v16149=allowedElements&v20969,v20970=TypeScript.AllowedElements,v16150=v20970.None,v8106=v16149==v16150;if(v8106){JAMScript.call(this.reportParseError,this,["'property' statements are only allowed within classes"]);
var v8090=this.scanner,v27112=JAMScript.call(v8090.scan,v8090,[]);this.currentToken=v27112;var v8091=TypeScript.AST,v16151=TypeScript.NodeType,v8092=v16151.Error,ast=JAMScript.new(v8091,[v8092]);ast.minChar=minChar;var v8093=ast,v16152=this.scanner,v27113=JAMScript.call(v16152.lastTokenLimChar,v16152,[]);v8093.limChar=v27113}else{var v20971=TypeScript.Modifiers,v16153=v20971.Public,modifiers=modifiers|v16153,v8094=this.scanner,v27114=JAMScript.call(v8094.scan,v8094,[]),v20972=this.currentToken=v27114,
v16154=v20972.tokenId,v20973=TypeScript.TokenID,v16155=v20973.Get,v8102=v16154==v16155;if(v8102){this.prevIDTok=this.currentToken;var v8095=this.scanner,v27115=JAMScript.call(v8095.scan,v8095,[]);this.currentToken=v27115;var v16156=TypeScript.codeGenTarget,v20974=TypeScript.CodeGenTarget,v16157=v20974.ES5,v8096=v16156<v16157;v8096&&JAMScript.call(this.reportParseError,this,["Property accessors are only available when targeting ES5 or greater"]);var v23820=this.currentToken,v20975=v23820.tokenId,v23821=
TypeScript.TokenID,v20976=v23821.Identifier,v16158=v20975==v20976,v20979=!v16158;if(v20979)var v20977=this.currentToken,v20978=this.strictMode,v16158=JAMScript.call(TypeScript.convertTokToID,TypeScript,[v20977,v20978]);var v8097=v16158;if(v8097){var v20980=TypeScript.Modifiers,v16159=v20980.Getter,modifiers=modifiers|v16159;this.prevIDTok=null}}else{var v20981=this.currentToken,v16160=v20981.tokenId,v20982=TypeScript.TokenID,v16161=v20982.Set,v8101=v16160==v16161;if(v8101){this.prevIDTok=this.currentToken;
var v8098=this.scanner,v27116=JAMScript.call(v8098.scan,v8098,[]);this.currentToken=v27116;var v16162=TypeScript.codeGenTarget,v20983=TypeScript.CodeGenTarget,v16163=v20983.ES5,v8099=v16162<v16163;v8099&&JAMScript.call(this.reportParseError,this,["Property accessors are only available when targeting ES5 or greater"]);var v23822=this.currentToken,v20984=v23822.tokenId,v23823=TypeScript.TokenID,v20985=v23823.Identifier,v16164=v20984==v20985,v20988=!v16164;if(v20988)var v20986=this.currentToken,v20987=
this.strictMode,v16164=JAMScript.call(TypeScript.convertTokToID,TypeScript,[v20986,v20987]);var v8100=v16164;if(v8100){var v20989=TypeScript.Modifiers,v16165=v20989.Setter,modifiers=modifiers|v16165;this.prevIDTok=null}}}var v20990=TypeScript.ErrorRecoverySet,v16166=v20990.SColon,v8103=errorRecoverySet|v16166,v8104=isAmbient(),fnOrVar=JAMScript.call(this.parsePropertyDeclaration,this,[v8103,modifiers,v8104,!1]),v20991=fnOrVar.nodeType,v23824=TypeScript.NodeType,v20992=v23824.VarDecl,v16167=v20991==
v20992,v20994=!v16167;if(v20994){var v23825=fnOrVar.nodeType,v25221=TypeScript.NodeType,v23826=v25221.FuncDecl,v20993=v23825==v23826;if(v20993)var v23827=fnOrVar.fncFlags,v25222=TypeScript.FncFlags,v23828=v25222.IsFatArrowFunction,v20993=JAMScript.call(TypeScript.hasFlag,TypeScript,[v23827,v23828]);v16167=v20993}var v8105=v16167;v8105&&(needTerminator=!0);ast=fnOrVar}}break;case TypeScript.TokenID.Declare:var v23829=TypeScript.AllowedElements,v20995=v23829.AmbientDeclarations,v16168=allowedElements&
v20995,v8108=!v16168;v8108&&JAMScript.call(this.reportParseError,this,["Ambient declarations are only allowed at the top-level or module scopes"]);var v20996=this.parsingDeclareFile,v16169=!v20996;if(v16169)var v23830=TypeScript.Modifiers,v20997=v23830.Ambient,v16169=JAMScript.call(TypeScript.hasFlag,TypeScript,[parentModifiers,v20997]);var v8109=v16169;v8109&&JAMScript.call(this.reportParseError,this,["Duplicate ambient declaration in this context. (Is the enclosing module or class already ambient?)"]);
var v20998=TypeScript.Modifiers,v16170=v20998.Ambient,modifiers=modifiers|v16170,v8110=this.scanner,v27117=JAMScript.call(v8110.scan,v8110,[]);this.currentToken=v27117;break;case TypeScript.TokenID.Class:var v23831=TypeScript.AllowedElements,v20999=v23831.ClassDeclarations,v16171=allowedElements&v20999,v21000=TypeScript.AllowedElements,v16172=v21000.None,v8115=v16171==v16172;if(v8115){JAMScript.call(this.reportParseError,this,["class not allowed in this context"]);var v8111=this.scanner,v27118=JAMScript.call(v8111.scan,
v8111,[]);this.currentToken=v27118;var v8112=TypeScript.AST,v16173=TypeScript.NodeType,v8113=v16173.Error,ast=JAMScript.new(v8112,[v8113]);ast.minChar=minChar;var v8114=ast,v16174=this.scanner,v27119=JAMScript.call(v16174.lastTokenLimChar,v16174,[]);v8114.limChar=v27119}else ast=JAMScript.call(this.parseClassDecl,this,[errorRecoverySet,minChar,modifiers]);break;case TypeScript.TokenID.Interface:var v23832=TypeScript.AllowedElements,v21001=v23832.InterfaceDeclarations,v16175=allowedElements&v21001,
v21002=TypeScript.AllowedElements,v16176=v21002.None,v8120=v16175==v16176;if(v8120){JAMScript.call(this.reportParseError,this,["interface not allowed in this context"]);var v8116=this.scanner,v27120=JAMScript.call(v8116.scan,v8116,[]);this.currentToken=v27120;var v8117=TypeScript.AST,v16177=TypeScript.NodeType,v8118=v16177.Error,ast=JAMScript.new(v8117,[v8118]);ast.minChar=minChar;var v8119=ast,v16178=this.scanner,v27121=JAMScript.call(v16178.lastTokenLimChar,v16178,[]);v8119.limChar=v27121}else ast=
JAMScript.call(this.parseInterfaceDecl,this,[errorRecoverySet,modifiers]);break;case TypeScript.TokenID.Var:var v21003=TypeScript.ErrorRecoverySet,v16179=v21003.StmtStart,v8121=errorRecoverySet|v16179,declAst=JAMScript.call(this.parseVariableDeclaration,this,[v8121,modifiers,!0,!1]),v16180=declAst.nodeType,v21004=TypeScript.NodeType,v16181=v21004.VarDecl,v8123=v16180==v16181;if(v8123)ast=declAst;else var v8122=TypeScript.Block,ast=JAMScript.new(v8122,[declAst,!1]);needTerminator=!0;break;case TypeScript.TokenID.Static:var v16182=
this.currentClassDecl,v8124=null==v16182;v8124&&JAMScript.call(this.reportParseError,this,["Statics may only be class members"]);mayNotBeExported();var v21005=TypeScript.Modifiers,v16183=v21005.Public,modifiers=modifiers|v16183,v8125=this.scanner,v27122=JAMScript.call(v8125.scan,v8125,[]),v21006=this.currentToken=v27122,v16184=v21006.tokenId,v21007=TypeScript.TokenID,v16185=v21007.Get,v8133=v16184==v16185;if(v8133){this.prevIDTok=this.currentToken;var v8126=this.scanner,v27123=JAMScript.call(v8126.scan,
v8126,[]);this.currentToken=v27123;var v16186=TypeScript.codeGenTarget,v21008=TypeScript.CodeGenTarget,v16187=v21008.ES5,v8127=v16186<v16187;v8127&&JAMScript.call(this.reportParseError,this,["Property accessors are only available when targeting ES5 or greater"]);var v23833=this.currentToken,v21009=v23833.tokenId,v23834=TypeScript.TokenID,v21010=v23834.Identifier,v16188=v21009==v21010,v21013=!v16188;if(v21013)var v21011=this.currentToken,v21012=this.strictMode,v16188=JAMScript.call(TypeScript.convertTokToID,
TypeScript,[v21011,v21012]);var v8128=v16188;if(v8128){var v21014=TypeScript.Modifiers,v16189=v21014.Getter,modifiers=modifiers|v16189;this.prevIDTok=null}}else{var v21015=this.currentToken,v16190=v21015.tokenId,v21016=TypeScript.TokenID,v16191=v21016.Set,v8132=v16190==v16191;if(v8132){var v8129=this.scanner,v27124=JAMScript.call(v8129.scan,v8129,[]);this.currentToken=v27124;var v16192=TypeScript.codeGenTarget,v21017=TypeScript.CodeGenTarget,v16193=v21017.ES5,v8130=v16192<v16193;v8130&&JAMScript.call(this.reportParseError,
this,["Property accessors are only available when targeting ES5 or greater"]);var v23835=this.currentToken,v21018=v23835.tokenId,v23836=TypeScript.TokenID,v21019=v23836.Identifier,v16194=v21018==v21019,v21022=!v16194;if(v21022)var v21020=this.currentToken,v21021=this.strictMode,v16194=JAMScript.call(TypeScript.convertTokToID,TypeScript,[v21020,v21021]);var v8131=v16194;if(v8131)var v21023=TypeScript.Modifiers,v16195=v21023.Setter,modifiers=modifiers|v16195}}var v8134=isAmbient();if(v8134)var v21024=
TypeScript.Modifiers,v16196=v21024.Ambient,modifiers=modifiers|v16196;var v21025=TypeScript.ErrorRecoverySet,v16197=v21025.SColon,v8135=errorRecoverySet|v16197,v16198=this.parsingDeclareFile,v21028=!v16198;if(v21028)var v25223=TypeScript.Modifiers,v23837=v25223.Ambient,v21026=modifiers&v23837,v23838=TypeScript.Modifiers,v21027=v23838.None,v16198=v21026!=v21027;var v8136=v16198,fnOrVar=JAMScript.call(this.parsePropertyDeclaration,this,[v8135,modifiers,v8136,!0]),staticsList=JAMScript.call(this.topStaticsList,
this,[]),v16199=staticsList;if(v16199)var v21029=fnOrVar.nodeType,v23839=TypeScript.NodeType,v21030=v23839.VarDecl,v16199=v21029==v21030;var v8137=v16199;v8137&&JAMScript.call(staticsList.append,staticsList,[fnOrVar]);var v21031=fnOrVar.nodeType,v23840=TypeScript.NodeType,v21032=v23840.VarDecl,v16200=v21031==v21032,v21034=!v16200;if(v21034){var v23841=fnOrVar.nodeType,v25224=TypeScript.NodeType,v23842=v25224.FuncDecl,v21033=v23841==v23842;if(v21033)var v23843=fnOrVar.fncFlags,v25225=TypeScript.FncFlags,
v23844=v25225.IsFatArrowFunction,v21033=JAMScript.call(TypeScript.hasFlag,TypeScript,[v23843,v23844]);v16200=v21033}var v8138=v16200;v8138&&(needTerminator=!0);ast=fnOrVar;break;case TypeScript.TokenID.For:mayNotBeExported();var v21035=TypeScript.Modifiers,v16201=v21035.None,v8139=modifiers!=v16201;v8139&&JAMScript.call(this.reportParseError,this,["syntax error: for statement does not take modifiers"]);var v8140=this.scanner,minChar=v8140.startPos,v16202=TypeScript.TokenID,v8141=v16202.OpenParen,
v23845=TypeScript.ErrorRecoverySet,v21036=v23845.ExprStart,v16203=errorRecoverySet|v21036,v21037=TypeScript.ErrorRecoverySet,v16204=v21037.Var,v8142=v16203|v16204;JAMScript.call(this.checkNextToken,this,[v8141,v8142]);this.state=ParseState.ForInit;var forInOk=!0,v16205=this.currentToken,v8148=v16205.tokenId;switch(v8148){case TypeScript.TokenID.Var:var v23846=TypeScript.ErrorRecoverySet,v21038=v23846.SColon,v16206=errorRecoverySet|v21038,v21039=TypeScript.ErrorRecoverySet,v16207=v21039.In,v8143=v16206|
v16207,v16208=TypeScript.Modifiers,v8144=v16208.None;temp=JAMScript.call(this.parseVariableDeclaration,this,[v8143,v8144,!1,!1]);break;case TypeScript.TokenID.Semicolon:temp=null;this.state=ParseState.ForCondStart;break;default:var v23847=TypeScript.ErrorRecoverySet,v21040=v23847.SColon,v16209=errorRecoverySet|v21040,v21041=TypeScript.ErrorRecoverySet,v16210=v21041.In,v8145=v16209|v16210,v16211=TypeScript.OperatorPrecedence,v8146=v16211.None,v8147=TypeContext.NoTypes;temp=JAMScript.call(this.parseExpr,
this,[v8145,v8146,!1,v8147])}this.state=ParseState.ForInitAfterVar;var v21042=this.currentToken,v16212=v21042.tokenId,v21043=TypeScript.TokenID,v16213=v21043.In,v8176=v16212==v16213;if(v8176){var v16214=null==temp,v21044=!v16214;v21044&&(v16214=!forInOk);var v8162=v16214;if(v8162){JAMScript.call(this.reportParseError,this,["malformed for statement"]);var v8152=this.errorRecovery;if(v8152){var v21045=TypeScript.ErrorRecoverySet,v16215=v21045.StmtStart,v8149=errorRecoverySet|v16215;JAMScript.call(this.skip,
this,[v8149]);var v8150=TypeScript.AST,v16216=TypeScript.NodeType,v8151=v16216.Empty,ast=JAMScript.new(v8150,[v8151]),v16217=ast.flags,v21046=TypeScript.ASTFlags,v16218=v21046.Error;ast.flags=v16217|v16218}}else{var v8153=this.scanner,v27125=JAMScript.call(v8153.scan,v8153,[]);this.currentToken=v27125;var v8154=TypeScript.ForInStatement,v23848=TypeScript.ErrorRecoverySet,v21047=v23848.RParen,v16219=v21047|errorRecoverySet,v21048=TypeScript.OperatorPrecedence,v16220=v21048.Comma,v16221=TypeContext.NoTypes,
v8155=JAMScript.call(this.parseExpr,this,[v16219,v16220,!1,v16221]),forInStmt=JAMScript.new(v8154,[temp,v8155]),v8156=this.scanner;forInStmt.limChar=v8156.pos;var v8157=forInStmt.statement;v8157.minChar=minChar;var v8158=forInStmt.statement,v16222=this.scanner;v8158.limChar=v16222.pos;var v16223=TypeScript.TokenID,v8159=v16223.CloseParen,v21049=TypeScript.ErrorRecoverySet,v16224=v21049.StmtStart,v8160=v16224|errorRecoverySet;JAMScript.call(this.checkCurrentToken,this,[v8159,v8160]);JAMScript.call(this.pushStmt,
this,[forInStmt,labelList]);var v8161=forInStmt,v27126=JAMScript.call(this.parseStatement,this,[errorRecoverySet,allowedElements,parentModifiers]);v8161.body=v27126;JAMScript.call(this.popStmt,this,[]);forInStmt.minChar=minChar;ast=forInStmt}}else{var v8163=TypeScript.ForStatement,forStmt=JAMScript.new(v8163,[temp]);forStmt.minChar=minChar;var v16225=TypeScript.TokenID,v8164=v16225.Semicolon;JAMScript.call(this.checkCurrentToken,this,[v8164,errorRecoverySet]);var v21050=this.currentToken,v16226=v21050.tokenId,
v21051=TypeScript.TokenID,v16227=v21051.Semicolon,v8168=v16226==v16227;if(v8168)forStmt.cond=null;else{var v8165=forStmt,v25226=TypeScript.ErrorRecoverySet,v23849=v25226.SColon,v21052=errorRecoverySet|v23849,v23850=TypeScript.ErrorRecoverySet,v21053=v23850.RParen,v16228=v21052|v21053,v21054=TypeScript.OperatorPrecedence,v16229=v21054.None,v16230=TypeContext.NoTypes,v27127=JAMScript.call(this.parseExpr,this,[v16228,v16229,!0,v16230]);v8165.cond=v27127;var v21055=this.currentToken,v16231=v21055.tokenId,
v21056=TypeScript.TokenID,v16232=v21056.Semicolon,v8167=v16231!=v16232;if(v8167){var v21057=TypeScript.ErrorRecoverySet,v16233=v21057.StmtStart,v8166=errorRecoverySet|v16233;JAMScript.call(this.skip,this,[v8166]);var ast=forStmt,v16234=ast.flags,v21058=TypeScript.ASTFlags,v16235=v21058.Error;ast.flags=v16234|v16235}}var v8169=this.scanner,v27128=JAMScript.call(v8169.scan,v8169,[]),v21059=this.currentToken=v27128,v16236=v21059.tokenId,v21060=TypeScript.TokenID,v16237=v21060.CloseParen,v8171=v16236==
v16237;if(v8171)forStmt.incr=null;else{var v8170=forStmt,v25227=TypeScript.ErrorRecoverySet,v23851=v25227.SColon,v21061=errorRecoverySet|v23851,v23852=TypeScript.ErrorRecoverySet,v21062=v23852.RParen,v16238=v21061|v21062,v21063=TypeScript.OperatorPrecedence,v16239=v21063.None,v16240=TypeContext.NoTypes,v27129=JAMScript.call(this.parseExpr,this,[v16238,v16239,!0,v16240]);v8170.incr=v27129}var v16241=TypeScript.TokenID,v8172=v16241.CloseParen,v21064=TypeScript.ErrorRecoverySet,v16242=v21064.LCurly,
v8173=errorRecoverySet|v16242;JAMScript.call(this.checkCurrentToken,this,[v8172,v8173]);JAMScript.call(this.pushStmt,this,[forStmt,labelList]);var v8174=forStmt,v27130=JAMScript.call(this.parseStatement,this,[errorRecoverySet,allowedElements,parentModifiers]);v8174.body=v27130;JAMScript.call(this.popStmt,this,[]);var v8175=forStmt.body;forStmt.limChar=v8175.limChar;ast=forStmt}break;case TypeScript.TokenID.With:var v16243=TypeScript.codeGenTarget,v21065=TypeScript.CodeGenTarget,v16244=v21065.ES5,
v8177=v16243<v16244;v8177&&JAMScript.call(this.reportParseError,this,["'with' statements are only available in ES5 codegen mode or better"]);var v8178=this.strictMode;v8178&&JAMScript.call(this.reportParseError,this,["'with' statements are not available in strict mode"]);mayNotBeExported();var v21066=TypeScript.Modifiers,v16245=v21066.None,v8179=modifiers!=v16245;v8179&&JAMScript.call(this.reportParseError,this,["'with' statement does not take modifiers"]);var v8180=this.scanner,minChar=v8180.startPos,
v16246=TypeScript.TokenID,v8181=v16246.OpenParen,v23853=TypeScript.ErrorRecoverySet,v21067=v23853.ExprStart,v16247=errorRecoverySet|v21067,v21068=TypeScript.ErrorRecoverySet,v16248=v21068.Var,v8182=v16247|v16248;JAMScript.call(this.checkNextToken,this,[v8181,v8182]);var v21069=TypeScript.ErrorRecoverySet,v16249=v21069.Colon,v8183=errorRecoverySet|v16249,v16250=TypeScript.OperatorPrecedence,v8184=v16250.None,v8185=TypeContext.NoTypes,expr=JAMScript.call(this.parseExpr,this,[v8183,v8184,!0,v8185]),
v16251=TypeScript.TokenID,v8186=v16251.CloseParen,v21070=TypeScript.ErrorRecoverySet,v16252=v21070.LCurly,v8187=errorRecoverySet|v16252;JAMScript.call(this.checkCurrentToken,this,[v8186,v8187]);var v8188=TypeScript.WithStatement,withStmt=JAMScript.new(v8188,[expr]),v8189=withStmt,v27131=JAMScript.call(this.parseStatement,this,[errorRecoverySet,allowedElements,parentModifiers]);v8189.body=v27131;withStmt.minChar=minChar;var v8190=withStmt.body;withStmt.limChar=v8190.limChar;ast=withStmt;break;case TypeScript.TokenID.Switch:mayNotBeExported();
var v21071=TypeScript.Modifiers,v16253=v21071.None,v8191=modifiers!=v16253;v8191&&JAMScript.call(this.reportParseError,this,["'switch' statement does not take modifiers"]);var v16254=TypeScript.TokenID,v8192=v16254.OpenParen,v21072=TypeScript.ErrorRecoverySet,v16255=v21072.ExprStart,v8193=errorRecoverySet|v16255;JAMScript.call(this.checkNextToken,this,[v8192,v8193]);var v8194=TypeScript.SwitchStatement,v23854=TypeScript.ErrorRecoverySet,v21073=v23854.RParen,v16256=errorRecoverySet|v21073,v21074=TypeScript.OperatorPrecedence,
v16257=v21074.None,v16258=TypeContext.NoTypes,v8195=JAMScript.call(this.parseExpr,this,[v16256,v16257,!0,v16258]),switchStmt=JAMScript.new(v8194,[v8195]),v8196=switchStmt.statement;v8196.minChar=minChar;var v8197=switchStmt.statement,v16259=this.scanner;v8197.limChar=v16259.pos;var v16260=TypeScript.TokenID,v8198=v16260.CloseParen,v21075=TypeScript.ErrorRecoverySet,v16261=v21075.LCurly,v8199=errorRecoverySet|v16261;JAMScript.call(this.checkCurrentToken,this,[v8198,v8199]);var v8200=this.scanner,caseListMinChar=
v8200.startPos,v16262=TypeScript.TokenID,v8201=v16262.OpenBrace,v21076=TypeScript.ErrorRecoverySet,v16263=v21076.SCase,v8202=errorRecoverySet|v16263;JAMScript.call(this.checkCurrentToken,this,[v8201,v8202]);switchStmt.defaultCase=null;var v8203=switchStmt,v16264=TypeScript.ASTList,v27132=JAMScript.new(v16264,[]);v8203.caseList=v27132;var caseStmt=null;for(JAMScript.call(this.pushStmt,this,[switchStmt,labelList]);;){var v23855=this.currentToken,v21077=v23855.tokenId,v23856=TypeScript.TokenID,v21078=
v23856.Case,v16265=v21077==v21078,v21081=!v16265;if(v21081)var v23857=this.currentToken,v21079=v23857.tokenId,v23858=TypeScript.TokenID,v21080=v23858.Default,v16265=v21079==v21080;var v8217=v16265;if(v8217){var v16266=this.currentToken,v8204=v16266.tokenId,v16267=TypeScript.TokenID,v8205=v16267.Default,isDefault=v8204==v8205,v8206=TypeScript.CaseStatement,caseStmt=JAMScript.new(v8206,[]),v8207=this.scanner;caseStmt.minChar=v8207.startPos;var v8208=this.scanner,v27133=JAMScript.call(v8208.scan,v8208,
[]);this.currentToken=v27133;if(isDefault)switchStmt.defaultCase=caseStmt;else{var v8209=caseStmt,v23859=TypeScript.ErrorRecoverySet,v21082=v23859.Colon,v16268=errorRecoverySet|v21082,v21083=TypeScript.OperatorPrecedence,v16269=v21083.None,v16270=TypeContext.NoTypes,v27134=JAMScript.call(this.parseExpr,this,[v16268,v16269,!0,v16270]);v8209.expr=v27134}var v16271=TypeScript.TokenID,v8210=v16271.Colon,v21084=TypeScript.ErrorRecoverySet,v16272=v21084.StmtStart,v8211=errorRecoverySet|v16272;JAMScript.call(this.checkCurrentToken,
this,[v8210,v8211]);var v8212=caseStmt,v16273=TypeScript.ASTList,v27135=JAMScript.new(v16273,[]);v8212.body=v27135;var v21085=TypeScript.ErrorRecoverySet,v16274=v21085.RCurly,v8213=errorRecoverySet|v16274,v8214=caseStmt.body;JAMScript.call(this.parseStatementList,this,[v8213,v8214,!1,!0,allowedElements,modifiers]);var v8215=caseStmt.body;caseStmt.limChar=v8215.limChar;var v8216=switchStmt.caseList;JAMScript.call(v8216.append,v8216,[caseStmt])}else break}var v8218=switchStmt.caseList;v8218.minChar=
caseListMinChar;var v8219=switchStmt.caseList,v16275=this.scanner;v8219.limChar=v16275.pos;var v8220=switchStmt.caseList;switchStmt.limChar=v8220.limChar;var v16276=TypeScript.TokenID,v8221=v16276.CloseBrace;JAMScript.call(this.checkCurrentToken,this,[v8221,errorRecoverySet]);JAMScript.call(this.popStmt,this,[]);ast=switchStmt;break;case TypeScript.TokenID.While:mayNotBeExported();var v21086=TypeScript.Modifiers,v16277=v21086.None,v8222=modifiers!=v16277;v8222&&JAMScript.call(this.reportParseError,
this,["'while' statement does not take modifiers"]);var v8223=this.scanner,minChar=v8223.startPos,v16278=TypeScript.TokenID,v8224=v16278.OpenParen,v21087=TypeScript.ErrorRecoverySet,v16279=v21087.ExprStart,v8225=v16279|errorRecoverySet;JAMScript.call(this.checkNextToken,this,[v8224,v8225]);var v8226=TypeScript.WhileStatement,v23860=TypeScript.ErrorRecoverySet,v21088=v23860.RParen,v16280=errorRecoverySet|v21088,v21089=TypeScript.OperatorPrecedence,v16281=v21089.None,v16282=TypeContext.NoTypes,v8227=
JAMScript.call(this.parseExpr,this,[v16280,v16281,!0,v16282]),whileStmt=JAMScript.new(v8226,[v8227]);whileStmt.minChar=minChar;var v16283=TypeScript.TokenID,v8228=v16283.CloseParen,v21090=TypeScript.ErrorRecoverySet,v16284=v21090.StmtStart,v8229=errorRecoverySet|v16284;JAMScript.call(this.checkCurrentToken,this,[v8228,v8229]);JAMScript.call(this.pushStmt,this,[whileStmt,labelList]);var v8230=whileStmt,v27136=JAMScript.call(this.parseStatement,this,[errorRecoverySet,allowedElements,parentModifiers]);
v8230.body=v27136;var v8231=whileStmt.body;whileStmt.limChar=v8231.limChar;JAMScript.call(this.popStmt,this,[]);ast=whileStmt;break;case TypeScript.TokenID.Do:mayNotBeExported();var v21091=TypeScript.Modifiers,v16285=v21091.None,v8232=modifiers!=v16285;v8232&&JAMScript.call(this.reportParseError,this,["'do' statement does not take modifiers"]);var v8233=this.scanner,minChar=v8233.startPos,v8234=this.scanner,v27137=JAMScript.call(v8234.scan,v8234,[]);this.currentToken=v27137;var v8235=TypeScript.DoWhileStatement,
doStmt=JAMScript.new(v8235,[]);doStmt.minChar=minChar;JAMScript.call(this.pushStmt,this,[doStmt,labelList]);var v8236=doStmt,v23861=TypeScript.ErrorRecoverySet,v21092=v23861.While,v16286=errorRecoverySet|v21092,v27138=JAMScript.call(this.parseStatement,this,[v16286,allowedElements,parentModifiers]);v8236.body=v27138;JAMScript.call(this.popStmt,this,[]);var v8237=doStmt,v16287=TypeScript.Identifier,v27139=JAMScript.new(v16287,["while"]);v8237.whileAST=v27139;var v8238=doStmt.whileAST,v16288=this.scanner;
v8238.minChar=v16288.startPos;var v16289=TypeScript.TokenID,v8239=v16289.While,v21093=TypeScript.ErrorRecoverySet,v16290=v21093.LParen,v8240=errorRecoverySet|v16290;JAMScript.call(this.checkCurrentToken,this,[v8239,v8240]);var v8241=doStmt.whileAST,v21094=doStmt.whileAST,v16291=v21094.minChar;v8241.limChar=v16291+5;var v16292=TypeScript.TokenID,v8242=v16292.OpenParen,v21095=TypeScript.ErrorRecoverySet,v16293=v21095.ExprStart,v8243=errorRecoverySet|v16293;JAMScript.call(this.checkCurrentToken,this,
[v8242,v8243]);var v8244=doStmt,v23862=TypeScript.ErrorRecoverySet,v21096=v23862.RParen,v16294=errorRecoverySet|v21096,v21097=TypeScript.OperatorPrecedence,v16295=v21097.None,v16296=TypeContext.NoTypes,v27140=JAMScript.call(this.parseExpr,this,[v16294,v16295,!0,v16296]);v8244.cond=v27140;var v8245=this.scanner;doStmt.limChar=v8245.pos;var v16297=TypeScript.TokenID,v8246=v16297.CloseParen;JAMScript.call(this.checkCurrentToken,this,[v8246,errorRecoverySet]);var ast=doStmt,v21098=this.currentToken,v16298=
v21098.tokenId,v21099=TypeScript.TokenID,v16299=v21099.Semicolon,v8248=v16298==v16299;if(v8248){var v8247=this.scanner,v27141=JAMScript.call(v8247.scan,v8247,[]);this.currentToken=v27141}break;case TypeScript.TokenID.If:mayNotBeExported();var v21100=TypeScript.Modifiers,v16300=v21100.None,v8249=modifiers!=v16300;v8249&&JAMScript.call(this.reportParseError,this,["if statement does not take modifiers"]);var v8250=this.scanner,minChar=v8250.startPos,v16301=TypeScript.TokenID,v8251=v16301.OpenParen,v21101=
TypeScript.ErrorRecoverySet,v16302=v21101.ExprStart,v8252=errorRecoverySet|v16302;JAMScript.call(this.checkNextToken,this,[v8251,v8252]);var v8253=TypeScript.IfStatement,v23863=TypeScript.ErrorRecoverySet,v21102=v23863.LParen,v16303=errorRecoverySet|v21102,v21103=TypeScript.OperatorPrecedence,v16304=v21103.None,v16305=TypeContext.NoTypes,v8254=JAMScript.call(this.parseExpr,this,[v16303,v16304,!0,v16305]),ifStmt=JAMScript.new(v8253,[v8254]);ifStmt.minChar=minChar;var v8255=ifStmt.statement;v8255.minChar=
minChar;var v8256=ifStmt.statement,v16306=this.scanner;v8256.limChar=v16306.pos;var v16307=TypeScript.TokenID,v8257=v16307.CloseParen,v21104=TypeScript.ErrorRecoverySet,v16308=v21104.StmtStart,v8258=errorRecoverySet|v16308;JAMScript.call(this.checkCurrentToken,this,[v8257,v8258]);JAMScript.call(this.pushStmt,this,[ifStmt,labelList]);var v8259=ifStmt,v23864=TypeScript.ErrorRecoverySet,v21105=v23864.Else,v16309=v21105|errorRecoverySet,v27142=JAMScript.call(this.parseStatement,this,[v16309,allowedElements,
parentModifiers]);v8259.thenBod=v27142;var v8260=ifStmt.thenBod;ifStmt.limChar=v8260.limChar;var v21106=this.currentToken,v16310=v21106.tokenId,v21107=TypeScript.TokenID,v16311=v21107.Else,v8264=v16310==v16311;if(v8264){var v8261=this.scanner,v27143=JAMScript.call(v8261.scan,v8261,[]);this.currentToken=v27143;var v8262=ifStmt,v27144=JAMScript.call(this.parseStatement,this,[errorRecoverySet,allowedElements,parentModifiers]);v8262.elseBod=v27144;var v8263=ifStmt.elseBod;ifStmt.limChar=v8263.limChar}JAMScript.call(this.popStmt,
this,[]);ast=ifStmt;break;case TypeScript.TokenID.Try:mayNotBeExported();var v21108=TypeScript.Modifiers,v16312=v21108.None,v8265=modifiers!=v16312;v8265&&JAMScript.call(this.reportParseError,this,["try statement does not take modifiers"]);var v8266=this.scanner,minChar=v8266.startPos,ast=JAMScript.call(this.parseTryCatchFinally,this,[errorRecoverySet,parentModifiers,labelList]);break;case TypeScript.TokenID.OpenBrace:mayNotBeExported();var v21109=TypeScript.Modifiers,v16313=v21109.None,v8267=modifiers!=
v16313;v8267&&JAMScript.call(this.reportParseError,this,["block does not take modifiers"]);var v8268=this.scanner,minChar=v8268.startPos,v8269=this.scanner,v27145=JAMScript.call(v8269.scan,v8269,[]);this.currentToken=v27145;var v8270=TypeScript.Block,v16314=TypeScript.ASTList,v8271=JAMScript.new(v16314,[]),block=JAMScript.new(v8270,[v8271,!0]);JAMScript.call(this.pushStmt,this,[block,labelList]);var v21110=TypeScript.ErrorRecoverySet,v16315=v21110.RCurly,v8272=errorRecoverySet|v16315,v8273=block.statements,
v16316=TypeScript.AllowedElements,v8274=v16316.None;JAMScript.call(this.parseStatementList,this,[v8272,v8273,!1,!1,v8274,modifiers]);JAMScript.call(this.popStmt,this,[]);var v8275=block.statements;v8275.minChar=minChar;var v8276=block.statements,v16317=this.scanner;v8276.limChar=v16317.pos;var v8277=block.statements;block.minChar=v8277.minChar;var v8278=block.statements;block.limChar=v8278.limChar;var v16318=TypeScript.TokenID,v8279=v16318.CloseBrace;JAMScript.call(this.checkCurrentToken,this,[v8279,
errorRecoverySet]);ast=block;break;case TypeScript.TokenID.Semicolon:mayNotBeExported();var v21111=TypeScript.Modifiers,v16319=v21111.None,v8280=modifiers!=v16319;v8280&&JAMScript.call(this.reportParseError,this,["modifier can not appear here"]);var v8281=TypeScript.AST,v16320=TypeScript.NodeType,v8282=v16320.Empty,ast=JAMScript.new(v8281,[v8282]),v8283=this.scanner,v27146=JAMScript.call(v8283.scan,v8283,[]);this.currentToken=v27146;break;case TypeScript.TokenID.Break:case TypeScript.TokenID.Continue:mayNotBeExported();
var v21112=TypeScript.Modifiers,v16321=v21112.None,v8284=modifiers!=v16321;v8284&&JAMScript.call(this.reportParseError,this,["modifiers can not appear before jump statement"]);var v8285=TypeScript.Jump,v16322,v25228=this.currentToken,v23865=v25228.tokenId,v25229=TypeScript.TokenID,v23866=v25229.Break,v21115=v23865==v23866;if(v21115){var v21113=TypeScript.NodeType;v16322=v21113.Break}else{var v21114=TypeScript.NodeType;v16322=v21114.Continue}var v8286=v16322,jump=JAMScript.new(v8285,[v8286]),v8287=
this.scanner,v27147=JAMScript.call(v8287.scan,v8287,[]),v23867=this.currentToken=v27147,v21116=v23867.tokenId,v23868=TypeScript.TokenID,v21117=v23868.Identifier,v16323=v21116==v21117;if(v16323)var v23869=this.scanner,v21118=JAMScript.call(v23869.lastTokenHadNewline,v23869,[]),v16323=!v21118;var v8290=v16323;if(v8290){var v8288=jump,v16324=this.currentToken,v27148=JAMScript.call(v16324.getText,v16324,[]);v8288.target=v27148;var v8289=this.scanner,v27149=JAMScript.call(v8289.scan,v8289,[]);this.currentToken=
v27149}JAMScript.call(this.resolveJumpTarget,this,[jump]);ast=jump;needTerminator=!0;break;case TypeScript.TokenID.Return:mayNotBeExported();var v21119=TypeScript.Modifiers,v16325=v21119.None,v8291=modifiers!=v16325;v8291&&JAMScript.call(this.reportParseError,this,["modifiers can not appear before return statement"]);var v16326=this.inFunction,v8292=!v16326;v8292&&JAMScript.call(this.reportParseError,this,["return statement outside of function body"]);var v8293=this.scanner,minChar=v8293.startPos,
v8294=this.scanner,v27150=JAMScript.call(v8294.scan,v8294,[]);this.currentToken=v27150;var v8295=TypeScript.ReturnStatement,retStmt=JAMScript.new(v8295,[]);retStmt.minChar=minChar;var v23870=this.currentToken,v21120=v23870.tokenId,v23871=TypeScript.TokenID,v21121=v23871.Semicolon,v16327=v21120!=v21121;if(v16327){var v25230=this.currentToken,v23872=v25230.tokenId,v25231=TypeScript.TokenID,v23873=v25231.CloseBrace,v21122=v23872!=v23873;if(v21122)var v25232=this.scanner,v23874=JAMScript.call(v25232.lastTokenHadNewline,
v25232,[]),v21122=!v23874;v16327=v21122}var v8297=v16327;if(v8297){var v8296=retStmt,v23875=TypeScript.ErrorRecoverySet,v21123=v23875.SColon,v16328=errorRecoverySet|v21123,v21124=TypeScript.OperatorPrecedence,v16329=v21124.None,v16330=TypeContext.NoTypes,v27151=JAMScript.call(this.parseExpr,this,[v16328,v16329,!0,v16330]);v8296.returnExpression=v27151}var needTerminator=!0,v8298=retStmt,v16331=this.scanner,v27152=JAMScript.call(v16331.lastTokenLimChar,v16331,[]);v8298.limChar=v27152;ast=retStmt;break;
case TypeScript.TokenID.Throw:mayNotBeExported();var v21125=TypeScript.Modifiers,v16332=v21125.None,v8299=modifiers!=v16332;v8299&&JAMScript.call(this.reportParseError,this,["modifiers can not appear before a throw statement"]);var v8300=this.scanner,minChar=v8300.startPos,v8301=this.scanner,v27153=JAMScript.call(v8301.scan,v8301,[]),v23876=this.currentToken=v27153,v21126=v23876.tokenId,v23877=TypeScript.TokenID,v21127=v23877.Semicolon,v16333=v21126!=v21127;if(v16333){var v25233=this.currentToken,
v23878=v25233.tokenId,v25234=TypeScript.TokenID,v23879=v25234.CloseBrace,v21128=v23878!=v23879;if(v21128)var v25235=this.scanner,v23880=JAMScript.call(v25235.lastTokenHadNewline,v25235,[]),v21128=!v23880;v16333=v21128}var v8305=v16333;if(v8305){var v21129=TypeScript.ErrorRecoverySet,v16334=v21129.SColon,v8302=errorRecoverySet|v16334,v16335=TypeScript.OperatorPrecedence,v8303=v16335.None,v8304=TypeContext.NoTypes;temp=JAMScript.call(this.parseExpr,this,[v8302,v8303,!0,v8304])}else JAMScript.call(this.reportParseError,
this,["throw with no target"]),temp=null;var v8306=TypeScript.UnaryExpression,v16336=TypeScript.NodeType,v8307=v16336.Throw,v8308=ast=JAMScript.new(v8306,[v8307,temp]),v16337=this.scanner,v27154=JAMScript.call(v16337.lastTokenLimChar,v16337,[]);v8308.limChar=v27154;needTerminator=!0;break;case TypeScript.TokenID.Enum:var v8309=this.scanner,v27155=JAMScript.call(v8309.scan,v8309,[]);this.currentToken=v27155;ast=JAMScript.call(this.parseEnumDecl,this,[errorRecoverySet,modifiers]);ast.minChar=minChar;
var v8310=ast,v16338=this.scanner,v27156=JAMScript.call(v16338.lastTokenLimChar,v16338,[]);v8310.limChar=v27156;var v16339=this.parsingDeclareFile,v21131=!v16339;if(v21131){var v21130=this.ambientModule,v23882=!v21130;if(v23882)var v25236=TypeScript.Modifiers,v23881=v25236.Ambient,v21130=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v23881]);v16339=v21130}var v8311=v16339;if(v8311){var v16340=ast.modFlags,v21132=TypeScript.ModuleFlags,v16341=v21132.Ambient;ast.modFlags=v16340|v16341}var v16342=
this.parsingDeclareFile,v21134=!v16342;if(v21134){var v21133=this.ambientModule,v23884=!v21133;if(v23884)var v25237=TypeScript.Modifiers,v23883=v25237.Exported,v21133=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v23883]);v16342=v21133}var v8312=v16342;if(v8312){var v16343=ast.modFlags,v21135=TypeScript.ModuleFlags,v16344=v21135.Exported;ast.modFlags=v16343|v16344}break;case TypeScript.TokenID.Debugger:mayNotBeExported();var v21136=TypeScript.Modifiers,v16345=v21136.None,v8313=modifiers!=
v16345;v8313&&JAMScript.call(this.reportParseError,this,["modifiers can not appear before debugger statement"]);var v8314=this.scanner,minChar=v8314.startPos,v8315=this.scanner,v27157=JAMScript.call(v8315.scan,v8315,[]);this.currentToken=v27157;var v8316=TypeScript.DebuggerStatement,debuggerStmt=JAMScript.new(v8316,[]);debuggerStmt.minChar=minChar;var needTerminator=!0,v8317=debuggerStmt,v16346=this.scanner,v27158=JAMScript.call(v16346.lastTokenLimChar,v16346,[]);v8317.limChar=v27158;ast=debuggerStmt;
break;default:var v21137=TypeScript.Modifiers,v16347=v21137.None,v8318=modifiers!=v16347;v8318&&JAMScript.call(this.reportParseError,this,["modifiers can not appear before an expression statement or label"]);var v8319=this.scanner,minChar=v8319.startPos,v8320=this.scanner,svPos=v8320.pos,v23885=TypeScript.ErrorRecoverySet,v21138=v23885.Colon,v23886=TypeScript.ErrorRecoverySet,v21139=v23886.StmtStart,v16348=v21138|v21139,v8321=v16348|errorRecoverySet,v16349=TypeScript.OperatorPrecedence,v8322=v16349.None,
v8323=TypeContext.NoTypes;temp=JAMScript.call(this.parseExpr,this,[v8321,v8322,!0,v8323]);var v21140=this.scanner,v16350=v21140.pos,v8330=v16350==svPos;if(v8330){var v8324=this.scanner,v27159=JAMScript.call(v8324.scan,v8324,[]);this.currentToken=v27159;ast=temp}else{var v23887=this.currentToken,v21141=v23887.tokenId,v23888=TypeScript.TokenID,v21142=v23888.Colon,v16351=v21141==v21142;if(v16351){var v25238=this.scanner,v23889=JAMScript.call(v25238.lastTokenHadNewline,v25238,[]),v21143=!v23889;if(v21143){var v23890=
temp;if(v23890)var v25239=temp.nodeType,v25981=TypeScript.NodeType,v25240=v25981.Name,v23890=v25239==v25240;v21143=v23890}v16351=v21143}var v8329=v16351;if(v8329){var v8326=null==labelList;if(v8326)var v8325=TypeScript.ASTList,labelList=JAMScript.new(v8325,[]);var v16352=TypeScript.Label,v8327=JAMScript.new(v16352,[temp]);JAMScript.call(labelList.append,labelList,[v8327]);var v8328=this.scanner,v27160=JAMScript.call(v8328.scan,v8328,[]);this.currentToken=v27160}else ast=temp,needTerminator=!0}}if(ast)break}if(needTerminator){var v16353=
this.currentToken,v8337=v16353.tokenId;switch(v8337){case TypeScript.TokenID.Semicolon:var v8332=this.scanner,v27161=JAMScript.call(v8332.scan,v8332,[]);this.currentToken=v27161;var v16354=ast.flags,v21144=TypeScript.ASTFlags,v16355=v21144.ExplicitSemicolon;ast.flags=v16354|v16355;break;case TypeScript.TokenID.EndOfFile:var v8333=this.scanner;ast.limChar=v8333.pos;case TypeScript.TokenID.CloseBrace:var v16356=ast.flags,v21145=TypeScript.ASTFlags,v16357=v21145.AutomaticSemicolon;ast.flags=v16356|v16357;
var v8334=this.style_requireSemi;v8334&&JAMScript.call(this.reportParseStyleError,this,["no automatic semicolon"]);break;default:var v21146=this.scanner,v16358=JAMScript.call(v21146.lastTokenHadNewline,v21146,[]),v8336=!v16358;if(v8336)JAMScript.call(this.reportParseError,this,["Expected ';'"]);else{var v16359=ast.flags,v21147=TypeScript.ASTFlags,v16360=v21147.AutomaticSemicolon;ast.flags=v16359|v16360;var v8335=this.style_requireSemi;v8335&&JAMScript.call(this.reportParseStyleError,this,["no automatic semicolon"])}}}if(labelList)var v8338=
TypeScript.LabeledStatement,ast=JAMScript.new(v8338,[labelList,ast]);ast.minChar=minChar;var v8339=ast,v16361=ast.limChar,v21148=this.scanner,v16362=JAMScript.call(v21148.lastTokenLimChar,v21148,[]),v27162=JAMScript.call(TypeScript.max,TypeScript,[v16361,v16362]);v8339.limChar=v27162;preComments&&(ast.preComments=preComments);var v16363=this.ambientModule;if(v16363)var v21149=JAMScript.call(this.okAmbientModuleMember,this,[ast]),v16363=!v21149;var v8340=v16363;v8340&&JAMScript.call(this.reportParseError,
this,["statement not permitted within ambient module"]);var v16364=ast.flags,v21150=TypeScript.ASTFlags,v16365=v21150.IsStatement;ast.flags=v16364|v16365;return ast}function v584(errorRecoverySet,parentModifiers,labelList){var v8341=TypeScript.Try,v8341=JAMScript.new(v8341,[null]),v8342=this.scanner,v8342=v8342.startPos;JAMScript.call(this.pushStmt,this,[v8341,labelList]);labelList=TypeScript.ErrorRecoverySet;labelList=labelList.Catch;labelList|=errorRecoverySet;JAMScript.call(this.parseTry,this,
[v8341,labelList,parentModifiers]);JAMScript.call(this.popStmt,this,[]);var tf=labelList=null,tf=this.currentToken,tf=tf.tokenId,v21153=TypeScript.TokenID,v21153=v21153.Catch;if(tf=tf==v21153)labelList=TypeScript.ErrorRecoverySet,labelList=labelList.Catch,labelList|=errorRecoverySet,tf=JAMScript.call(this.parseCatch,this,[labelList,parentModifiers]),labelList=TypeScript.TryCatch,labelList=JAMScript.new(labelList,[v8341,tf]),labelList.minChar=v8341.minChar,labelList.limChar=tf.limChar;tf=this.currentToken;
tf=tf.tokenId;v21153=TypeScript.TokenID;v21153=v21153.Finally;if(tf=tf!=v21153){if(errorRecoverySet=null==labelList){JAMScript.call(this.reportParseError,this,["try with neither catch nor finally"]);if(errorRecoverySet=this.errorRecovery)return errorRecoverySet=TypeScript.TryFinally,parentModifiers=TypeScript.Finally,v8342=TypeScript.AST,labelList=TypeScript.NodeType,labelList=labelList.Empty,v8342=JAMScript.new(v8342,[labelList]),parentModifiers=JAMScript.new(parentModifiers,[v8342]),v8341=JAMScript.new(errorRecoverySet,
[v8341,parentModifiers]),errorRecoverySet=v8341.flags,parentModifiers=TypeScript.ASTFlags,parentModifiers=parentModifiers.Error,v8341.flags=errorRecoverySet|parentModifiers,errorRecoverySet=this.scanner,v8341.minChar=errorRecoverySet.startPos,errorRecoverySet=this.scanner,v8341.limChar=errorRecoverySet.pos,v8341;errorRecoverySet=TypeScript.TryFinally;parentModifiers=TypeScript.Finally;v8342=TypeScript.AST;labelList=TypeScript.NodeType;labelList=labelList.Empty;v8342=JAMScript.new(v8342,[labelList]);
parentModifiers=JAMScript.new(parentModifiers,[v8342]);return JAMScript.new(errorRecoverySet,[v8341,parentModifiers])}return labelList}labelList&&(v8341=labelList);errorRecoverySet=JAMScript.call(this.parseFinally,this,[errorRecoverySet,parentModifiers]);parentModifiers=TypeScript.TryFinally;tf=JAMScript.new(parentModifiers,[v8341,errorRecoverySet]);tf.minChar=v8342;tf.limChar=errorRecoverySet.limChar;return tf}function v583(errorRecoverySet,parentModifiers){var v8357=this.scanner,finMinChar=v8357.startPos,
v8357=JAMScript.call(this.parseComments,this,[]),v8358=this.scanner,v8358=this.currentToken=v8358=JAMScript.call(v8358.scan,v8358,[]),v8358=v8358.tokenId,v21163=TypeScript.TokenID,v21163=v21163.OpenBrace;if(v8358=v8358!=v21163)if(JAMScript.call(this.reportParseError,this,["Expected '{' to start body of finally statement"]),v8358=this.errorRecovery)return JAMScript.call(this.skip,this,[errorRecoverySet]),v8357=TypeScript.Finally,finMinChar=TypeScript.Statement,v8358=TypeScript.NodeType,v8358=v8358.Empty,
finMinChar=JAMScript.new(finMinChar,[v8358]),v8357=JAMScript.new(v8357,[finMinChar]),finMinChar=v8357.flags,v8358=TypeScript.ASTFlags,v8358=v8358.Error,v8357.flags=finMinChar|v8358,finMinChar=this.scanner,v8357.minChar=finMinChar.startPos,finMinChar=this.scanner,v8357.limChar=finMinChar.pos,v8357;v8358=TypeScript.AllowedElements;v8358=v8358.None;v8358=JAMScript.call(this.parseStatement,this,[errorRecoverySet,v8358,parentModifiers]);v21163=TypeScript.Finally;v8358=JAMScript.new(v21163,[v8358]);v8358.minChar=
finMinChar;finMinChar=v8358.body;v8358.limChar=finMinChar.limChar;v8358.preComments=v8357;v8357=v8358;finMinChar=JAMScript.call(this.parseComments,this,[]);v8357.postComments=finMinChar;return v8358}function v582(errorRecoverySet,parentModifiers){var v8369=this.scanner,v8369=v8369.startPos,preComments=JAMScript.call(this.parseComments,this,[]),v8370=this.scanner;this.currentToken=v8370=JAMScript.call(v8370.scan,v8370,[]);var v8370=TypeScript.TokenID,v8370=v8370.OpenParen,v21166=TypeScript.ErrorRecoverySet,
v21166=v21166.ExprStart,v21166=errorRecoverySet|v21166;JAMScript.call(this.checkCurrentToken,this,[v8370,v21166]);v8370=this.currentToken;v8370=v8370.tokenId;v21166=TypeScript.TokenID;v21166=v21166.Identifier;v8370=v8370!=v21166;if(v21166=!v8370)v8370=this.currentToken,v21166=this.strictMode,v8370=JAMScript.call(TypeScript.convertTokToID,TypeScript,[v8370,v21166]);if(v8370&&(JAMScript.call(this.reportParseError,this,["Expected identifier in catch header"]),v8370=this.errorRecovery)){JAMScript.call(this.skip,
this,[errorRecoverySet]);var preComments=TypeScript.Catch,v8370=TypeScript.VarDecl,v21166=TypeScript.MissingIdentifier,v21166=JAMScript.new(v21166,[]),v16390=this.nestingLevel,v8370=JAMScript.new(v8370,[v21166,v16390]),v21166=TypeScript.Statement,v16390=TypeScript.NodeType,v16390=v16390.Empty,v21166=JAMScript.new(v21166,[v16390]),preComments=JAMScript.new(preComments,[v8370,v21166]),v8370=preComments.statement;v8370.minChar=v8369;v8369=preComments.statement;v8370=this.scanner;v8369.limChar=v8370.pos;
v8369=this.scanner;preComments.minChar=v8369.startPos;v8369=this.scanner;preComments.limChar=v8369.pos;v8369=preComments.flags;v8370=TypeScript.ASTFlags;v8370=v8370.Error;preComments.flags=v8369|v8370;return preComments}v8370=TypeScript.VarDecl;v21166=TypeScript.Identifier;v16390=this.currentToken;v21166=JAMScript.call(v21166.fromToken,v21166,[v16390]);v16390=this.nestingLevel;v21166=JAMScript.new(v8370,[v21166,v16390]);v8370=v21166.id;v16390=this.scanner;v8370.minChar=v16390.startPos;v8370=v21166.id;
v16390=this.scanner;v8370.limChar=v16390.pos;v8370=v21166.id;v21166.minChar=v8370.minChar;v8370=v21166.id;v21166.limChar=v8370.limChar;v8370=this.scanner;this.currentToken=v8370=JAMScript.call(v8370.scan,v8370,[]);var v8370=this.scanner,v8370=v8370.pos,v16390=TypeScript.TokenID,v16390=v16390.CloseParen,v21175=TypeScript.ErrorRecoverySet,v21175=v21175.StmtStart,v21175=errorRecoverySet|v21175;JAMScript.call(this.checkCurrentToken,this,[v16390,v21175]);v16390=this.currentToken;v16390=v16390.tokenId;
v21175=TypeScript.TokenID;v21175=v21175.OpenBrace;if(v16390=v16390!=v21175)if(JAMScript.call(this.reportParseError,this,["Expected '{' to start catch body"]),v16390=this.errorRecovery)return JAMScript.call(this.skip,this,[errorRecoverySet]),preComments=TypeScript.Catch,v21166=TypeScript.VarDecl,v16390=TypeScript.MissingIdentifier,v16390=JAMScript.new(v16390,[]),v21175=this.nestingLevel,v21166=JAMScript.new(v21166,[v16390,v21175]),v16390=TypeScript.Statement,v21175=TypeScript.NodeType,v21175=v21175.Empty,
v16390=JAMScript.new(v16390,[v21175]),preComments=JAMScript.new(preComments,[v21166,v16390]),v21166=preComments.statement,v21166.minChar=v8369,v8369=preComments.statement,v8369.limChar=v8370,v8369=this.scanner,preComments.minChar=v8369.startPos,v8369=this.scanner,preComments.limChar=v8369.pos,v8369=preComments.flags,v8370=TypeScript.ASTFlags,v8370=v8370.Error,preComments.flags=v8369|v8370,preComments;v16390=TypeScript.AllowedElements;v16390=v16390.None;v16390=JAMScript.call(this.parseStatement,this,
[errorRecoverySet,v16390,parentModifiers]);v21175=TypeScript.Catch;v21166=JAMScript.new(v21175,[v21166,v16390]);v21175=v21166.statement;v21175.minChar=v8369;v21175=v21166.statement;v21175.limChar=v8370;v21166.minChar=v8369;v21166.limChar=v16390.limChar;v21166.preComments=preComments;v8369=v21166;preComments=JAMScript.call(this.parseComments,this,[]);v8369.postComments=preComments;return v21166}function v581(tryNode,errorRecoverySet,parentModifiers){var v8407=this.scanner,v8407=v8407.startPos,preComments=
JAMScript.call(this.parseComments,this,[]),v8408=this.scanner,v8408=this.currentToken=v8408=JAMScript.call(v8408.scan,v8408,[]),v8408=v8408.tokenId,v21182=TypeScript.TokenID,v21182=v21182.OpenBrace;if(v8408=v8408!=v21182)if(JAMScript.call(this.reportParseError,this,["Expected '{'"]),v8408=this.errorRecovery)return tryNode.minChar=v8407,v8407=tryNode,preComments=this.scanner,preComments=JAMScript.call(preComments.lastTokenLimChar,preComments,[]),v8407.limChar=preComments,v8407=tryNode.flags,preComments=
TypeScript.ASTFlags,preComments=preComments.Error,tryNode.flags=v8407|preComments,tryNode;v8408=tryNode;v21182=TypeScript.AllowedElements;v21182=v21182.None;errorRecoverySet=JAMScript.call(this.parseStatement,this,[errorRecoverySet,v21182,parentModifiers]);v8408.body=errorRecoverySet;tryNode.minChar=v8407;v8407=tryNode.body;tryNode.limChar=v8407.limChar;tryNode.preComments=preComments;v8407=tryNode;preComments=JAMScript.call(this.parseComments,this,[]);v8407.postComments=preComments;return tryNode}
function v580(errorRecoverySet,ast,allowCall,inNew,typeContext,lhsMinChar,lhsLimChar){var v8417=!ast;if(v8417){var v8415=TypeScript.AST,v16418=TypeScript.NodeType,v8416=v16418.EmptyExpr;ast=JAMScript.new(v8415,[v8416]);ast.isParenthesized=!0}ast.minChar=lhsMinChar;for(ast.limChar=lhsLimChar;;){var v16419=this.currentToken,v8456=v16419.tokenId;switch(v8456){case TypeScript.TokenID.OpenParen:if(inNew){var callExpr=ast,v8418=callExpr,v27172=JAMScript.call(this.parseArgList,this,[errorRecoverySet]);v8418.arguments=
v27172;inNew=!1}else{var v8419=!allowCall;if(v8419)return ast;var v8420=TypeScript.CallExpression,v16420=TypeScript.NodeType,v8421=v16420.Call,v8422=JAMScript.call(this.parseArgList,this,[errorRecoverySet]);ast=JAMScript.new(v8420,[v8421,ast,v8422]);ast.minChar=lhsMinChar}var v8423=this.scanner;ast.limChar=v8423.pos;var v16421=TypeScript.TokenID,v8424=v16421.CloseParen;JAMScript.call(this.checkCurrentToken,this,[v8424,errorRecoverySet]);break;case TypeScript.TokenID.OpenBracket:var v8425=this.scanner,
v27173=JAMScript.call(v8425.scan,v8425,[]),v21185=this.currentToken=v27173,v16422=v21185.tokenId,v21186=TypeScript.TokenID,v16423=v21186.CloseBracket,v8432=v16422==v16423;if(v8432){var v16424=TypeContext.ArraySuffix,v8431=JAMScript.call(TypeScript.hasFlag,TypeScript,[typeContext,v16424]);if(v8431){var v8426=this.scanner,v27174=JAMScript.call(v8426.scan,v8426,[]);this.currentToken=v27174;var v16425=ast.nodeType,v21187=TypeScript.NodeType,v16426=v21187.TypeRef,v8429=v16425==v16426;if(v8429){var typeRef=
ast,v16427=typeRef.arrayCount;typeRef.arrayCount=v16427+1}else{var v8427=TypeScript.BinaryExpression,v16428=TypeScript.NodeType,v8428=v16428.Index;ast=JAMScript.new(v8427,[v8428,ast,null])}var v8430=this.scanner;ast.limChar=v8430.pos;break}}var v8433=TypeScript.BinaryExpression,v16429=TypeScript.NodeType,v8434=v16429.Index,v23895=TypeScript.ErrorRecoverySet,v21188=v23895.RBrack,v16430=errorRecoverySet|v21188,v21189=TypeScript.OperatorPrecedence,v16431=v21189.None,v16432=TypeContext.NoTypes,v8435=
JAMScript.call(this.parseExpr,this,[v16430,v16431,!0,v16432]);ast=JAMScript.new(v8433,[v8434,ast,v8435]);ast.minChar=lhsMinChar;var v8436=this.scanner;ast.limChar=v8436.pos;var v16433=TypeScript.TokenID,v8437=v16433.CloseBracket;JAMScript.call(this.checkCurrentToken,this,[v8437,errorRecoverySet]);break;case TypeScript.TokenID.Dot:var name=null,v8439=this.scanner,v27175=JAMScript.call(v8439.scan,v8439,[]),v16434=this.currentToken=v27175,v8441=void 0===v16434;if(v8441){var v8440=this.scanner,v27176=
JAMScript.call(v8440.scan,v8440,[]);this.currentToken=v27176;continue}var v23896=this.currentToken,v21190=v23896.tokenId,v23897=TypeScript.TokenID,v21191=v23897.Identifier,v16435=v21190==v21191,v21193=!v16435;if(v21193){var v25241=this.errorRecovery,v23898=!v25241,v25243=!v23898;if(v25243)var v25982=this.scanner,v25242=JAMScript.call(v25982.lastTokenHadNewline,v25982,[]),v23898=!v25242;var v21192=v23898;if(v21192)var v23899=this.currentToken,v21192=JAMScript.call(TypeScript.convertTokToIDName,TypeScript,
[v23899]);v16435=v21192}var v8449=v16435;if(v8449){var v16436=ast.flags,v21194=TypeScript.ASTFlags,v16437=v21194.DotLHS;ast.flags=v16436|v16437;var v16438=this.currentToken,v8442=JAMScript.call(v16438.getText,v16438,[]),v16439=this.currentToken,v8443=v16439.hasEscapeSequence,v16440=this.scanner,v8444=v16440.startPos,name=JAMScript.call(this.createRef,this,[v8442,v8443,v8444]),v8445=this.scanner;name.limChar=v8445.pos;var v8446=this.scanner,v27177=JAMScript.call(v8446.scan,v8446,[]);this.currentToken=
v27177}else{JAMScript.call(this.reportParseError,this,["Expected identifier following dot"]);var v8448=this.errorRecovery;if(v8448){JAMScript.call(this.skip,this,[errorRecoverySet]);var v16441=ast.flags,v23900=TypeScript.ASTFlags,v21195=v23900.Error,v23901=TypeScript.ASTFlags,v21196=v23901.DotLHS,v16442=v21195|v21196;ast.flags=v16441|v16442;return ast}var v8447=TypeScript.MissingIdentifier,name=JAMScript.new(v8447,[])}var v8450=TypeScript.BinaryExpression,v16443=TypeScript.NodeType,v8451=v16443.Dot;
ast=JAMScript.new(v8450,[v8451,ast,name]);ast.minChar=lhsMinChar;var v8452=ast,v16444=this.scanner,v27178=JAMScript.call(v16444.lastTokenLimChar,v16444,[]);v8452.limChar=v27178;break;case TypeScript.TokenID.EqualsGreaterThan:var v16445=TypeScript.Modifiers,v8453=v16445.None,v8454={preProcessedLambdaArgs:ast};ast=JAMScript.call(this.parseFncDecl,this,[errorRecoverySet,!1,!1,!1,null,!1,!1,!1,v8453,v8454,!1]);var v16446=ast.fncFlags,v21197=TypeScript.FncFlags,v16447=v21197.IsFunctionExpression;ast.fncFlags=
v16446|v16447;ast.minChar=lhsMinChar;var v8455=ast,v16448=this.scanner,v27179=JAMScript.call(v16448.lastTokenLimChar,v16448,[]);v8455.limChar=v27179;break;default:return ast}}}function v579(errorRecoverySet,minPrecedence,allowIn,typeContext,possiblyInLambda){var v16449=typeof possiblyInLambda,v8457="undefined"===v16449;v8457&&(possiblyInLambda=!1);var ast=null,v16450=this.currentToken,v8458=v16450.tokenId,tokenInfo=JAMScript.call(TypeScript.lookupToken,TypeScript,[v8458]),canAssign=!0,idHint=null,
v8459=this.scanner,minChar=v8459.startPos,preComments=JAMScript.call(this.parseComments,this,[]),exprIsAnonLambda=!1,v16451=void 0!=tokenInfo;if(v16451)var v21198=tokenInfo.unopNodeType,v23902=TypeScript.NodeType,v21199=v23902.None,v16451=v21198!=v21199;var v8486=v16451;if(v8486){var canAssign=!1,v8460=this.scanner,v27180=JAMScript.call(v8460.scan,v8460,[]);this.currentToken=v27180;var v21200=TypeScript.ErrorRecoverySet,v16452=v21200.BinOp,v8461=v16452|errorRecoverySet,v8462=tokenInfo.unopPrecedence,
v8463=TypeContext.NoTypes,tempExpr=JAMScript.call(this.parseExpr,this,[v8461,v8462,allowIn,v8463]),v21201=tokenInfo.unopNodeType,v23903=TypeScript.NodeType,v21202=v23903.Pos,v16453=v21201==v21202;if(v16453)var v21203=tempExpr.nodeType,v23904=TypeScript.NodeType,v21204=v23904.NumberLit,v16453=v21203==v21204;var v8469=v16453;if(v8469)ast=tempExpr;else{var v21205=tokenInfo.unopNodeType,v23905=TypeScript.NodeType,v21206=v23905.Neg,v16454=v21205==v21206;if(v16454)var v21207=tempExpr.nodeType,v23906=TypeScript.NodeType,
v21208=v23906.NumberLit,v16454=v21207==v21208;var v8468=v16454;if(v8468){var numLit=tempExpr,v8464=numLit.value;numLit.value=-v8464;var v16455=numLit.value,v8465=0==v16455;v8465&&(numLit.isNegativeZero=!0);ast=tempExpr}else{var v8466=TypeScript.UnaryExpression,v8467=tokenInfo.unopNodeType,ast=JAMScript.new(v8466,[v8467,tempExpr]);ast.limChar=tempExpr.limChar}}ast.minChar=minChar}else{var v23907=TypeScript.ErrorRecoverySet,v21209=v23907.BinOp,v23908=TypeScript.ErrorRecoverySet,v21210=v23908.AddOp,
v16456=v21209|v21210,v8470=v16456|errorRecoverySet,ast=JAMScript.call(this.parseTerm,this,[v8470,!0,typeContext,!1]),id,temp,v16457=ast.nodeType,v21211=TypeScript.NodeType,v16458=v21211.Name,v8480=v16457==v16458;if(v8480)id=ast,idHint=id.actualText;else{var v16459=ast.nodeType,v21212=TypeScript.NodeType,v16460=v21212.Dot,v8479=v16459==v16460;if(v8479){var subsumedExpr=!1,v16461=this.inferPropertiesFromThisAssignment;if(v16461){var v25983=this.currentToken,v25244=v25983.tokenId,v25984=TypeScript.TokenID,
v25245=v25984.Colon,v23909=v25244==v25245,v25248=!v23909;if(v25248)var v25985=this.currentToken,v25246=v25985.tokenId,v25986=TypeScript.TokenID,v25247=v25986.Equals,v23909=v25246==v25247;var v21213=v23909;if(v21213){var v23910=this.parsingClassConstructorDefinition;if(v23910){var v25987=this.nestingLevel,v26394=this.currentClassDefinition,v25988=v26394.constructorNestingLevel,v25249=v25987==v25988;if(v25249)var v26395=ast.operand1,v25989=v26395.nodeType,v26396=TypeScript.NodeType,v25990=v26396.This,
v25249=v25989==v25990;v23910=v25249}v21213=v23910}v16461=v21213}var v8475=v16461;if(v8475){var v21214=ast.operand2,v16462=v21214.nodeType,v21215=TypeScript.NodeType,v16463=v21215.Name,v8474=v16462==v16463;if(v8474){var op2ID=ast.operand2,v23911=this.currentClassDefinition,v21216=v23911.knownMemberNames,v21217=op2ID.actualText;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v16464=v21216[v21217];var v8473=!v16464;if(v8473)var v8471=ast.minChar,v16465=TypeScript.Modifiers,
v8472=v16465.Public,ast=JAMScript.call(this.parseClassMemberVariableDeclaration,this,[op2ID,v8471,!0,errorRecoverySet,v8472]),subsumedExpr=!0}}var v8478=!subsumedExpr;if(v8478){temp=ast;for(var v16466=temp.nodeType,v21218=TypeScript.NodeType,v16467=v21218.Dot,v8476=v16466==v16467;v8476;){var binExpr=temp;temp=binExpr.operand2;var v16468=temp.nodeType,v21219=TypeScript.NodeType,v16469=v21219.Dot,v8476=v16468==v16469}var v16470=temp.nodeType,v21220=TypeScript.NodeType,v16471=v21220.Name,v8477=v16470==
v16471;v8477&&(id=temp,idHint=id.actualText)}}}var v23912=this.scanner,v21221=JAMScript.call(v23912.lastTokenHadNewline,v23912,[]),v16472=!v21221;if(v16472){var v25250=this.currentToken,v23913=v25250.tokenId,v25251=TypeScript.TokenID,v23914=v25251.PlusPlus,v21222=v23913==v23914,v23917=!v21222;if(v23917)var v25252=this.currentToken,v23915=v25252.tokenId,v25253=TypeScript.TokenID,v23916=v25253.MinusMinus,v21222=v23915==v23916;v16472=v21222}var v8485=v16472;if(v8485){var canAssign=!1,operand=ast,v8481=
TypeScript.UnaryExpression,v16473,v25254=this.currentToken,v23918=v25254.tokenId,v25255=TypeScript.TokenID,v23919=v25255.PlusPlus,v21225=v23918==v23919;if(v21225){var v21223=TypeScript.NodeType;v16473=v21223.IncPost}else{var v21224=TypeScript.NodeType;v16473=v21224.DecPost}var v8482=v16473,ast=JAMScript.new(v8481,[v8482,operand]),v8483=this.scanner;ast.limChar=v8483.pos;ast.minChar=operand.minChar;var v8484=this.scanner,v27181=JAMScript.call(v8484.scan,v8484,[]);this.currentToken=v27181}}for(;;){var v16474=
this.currentToken,v8487=v16474.tokenId,tokenInfo=JAMScript.call(TypeScript.lookupToken,TypeScript,[v8487]),v16475=void 0==tokenInfo,v21228=!v16475;if(v21228)var v21226=tokenInfo.binopNodeType,v23920=TypeScript.NodeType,v21227=v23920.None,v16475=v21226==v21227;var v8488=v16475;if(v8488)break;var v16476=!allowIn;if(v16476)var v21229=tokenInfo.binopNodeType,v23921=TypeScript.NodeType,v21230=v23921.In,v16476=v21229==v21230;var v8489=v16476;if(v8489)break;var v16477=tokenInfo.binopPrecedence,v21231=TypeScript.OperatorPrecedence,
v16478=v21231.Assignment,v8493=v16477==v16478;if(v8493){var v16479=tokenInfo.binopPrecedence,v8490=v16479<minPrecedence;if(v8490)break;var v8491=!canAssign;v8491&&JAMScript.call(this.reportParseError,this,["illegal assignment"])}else{var v16480=tokenInfo.binopPrecedence,v8492=v16480<=minPrecedence;if(v8492)break}var v16481=possiblyInLambda;if(v16481){var v25256=this.currentToken,v23922=v25256.tokenId,v25257=TypeScript.TokenID,v23923=v25257.Comma,v21232=v23922==v23923;if(v21232)var v25991=this.scanner,
v25258=JAMScript.call(v25991.getLookAheadToken,v25991,[]),v23924=v25258.tokenId,v25259=TypeScript.TokenID,v23925=v25259.DotDotDot,v21232=v23924==v23925;v16481=v21232}var v8494=v16481;if(v8494){exprIsAnonLambda=!0;canAssign=!1;ast=JAMScript.call(this.parseLambdaExpr,this,[errorRecoverySet,ast,!1,!0]);break}var v8495=this.scanner,v27182=JAMScript.call(v8495.scan,v8495,[]);this.currentToken=v27182;var canAssign=!1,v16482=tokenInfo.binopNodeType,v21233=TypeScript.NodeType,v16483=v21233.ConditionalExpression,
v8511=v16482==v16483;if(v8511){var v16484=possiblyInLambda;if(v16484){var v25260=this.currentToken,v23926=v25260.tokenId,v25261=TypeScript.TokenID,v23927=v25261.Equals,v21234=v23926==v23927,v23929=!v21234;if(v23929){var v25992=this.currentToken,v25262=v25992.tokenId,v25993=TypeScript.TokenID,v25263=v25993.Colon,v23928=v25262==v25263,v25265=!v23928;if(v25265){var v26397=this.currentToken,v25994=v26397.tokenId,v26398=TypeScript.TokenID,v25995=v26398.CloseParen,v25264=v25994==v25995,v25998=!v25264;if(v25998)var v26399=
this.currentToken,v25996=v26399.tokenId,v26400=TypeScript.TokenID,v25997=v26400.Comma,v25264=v25996==v25997;v23928=v25264}v21234=v23928}v16484=v21234}var v8505=v16484;if(v8505)canAssign=exprIsAnonLambda=!0;else{this.prevExpr=ast;var v21235=TypeScript.ErrorRecoverySet,v16485=v21235.Colon,v8496=errorRecoverySet|v16485,v16486=TypeScript.OperatorPrecedence,v8497=v16486.Assignment,v8498=TypeContext.NoTypes,whenTrue=JAMScript.call(this.parseExpr,this,[v8496,v8497,allowIn,v8498]);this.prevExpr=null;var v16487=
TypeScript.TokenID,v8499=v16487.Colon,v21236=TypeScript.ErrorRecoverySet,v16488=v21236.ExprStart,v8500=errorRecoverySet|v16488;JAMScript.call(this.checkCurrentToken,this,[v8499,v8500]);var v21237=TypeScript.ErrorRecoverySet,v16489=v21237.BinOp,v8501=errorRecoverySet|v16489,v16490=TypeScript.OperatorPrecedence,v8502=v16490.Assignment,v8503=TypeContext.NoTypes,whenFalse=JAMScript.call(this.parseExpr,this,[v8501,v8502,allowIn,v8503]),v8504=TypeScript.ConditionalExpression,ast=JAMScript.new(v8504,[ast,
whenTrue,whenFalse])}}else{var binExpr2,v8506=TypeScript.BinaryExpression,v8507=tokenInfo.binopNodeType,v23930=TypeScript.ErrorRecoverySet,v21238=v23930.BinOp,v16491=errorRecoverySet|v21238,v16492=tokenInfo.binopPrecedence,v16493=TypeContext.NoTypes,v8508=JAMScript.call(this.parseExpr,this,[v16491,v16492,allowIn,v16493,possiblyInLambda]);binExpr2=JAMScript.new(v8506,[v8507,ast,v8508]);var v21239=binExpr2.operand2,v16494=v21239.nodeType,v21240=TypeScript.NodeType,v16495=v21240.FuncDecl,v8509=v16494==
v16495;if(v8509){var funcDecl=binExpr2.operand2;funcDecl.hint=idHint}binExpr2.minChar=ast.minChar;var v8510=binExpr2,v16496=this.scanner,v27183=JAMScript.call(v16496.lastTokenLimChar,v16496,[]);v8510.limChar=v27183;idHint=null;ast=binExpr2}}if(canAssign){var v16497=ast.flags,v21241=TypeScript.ASTFlags,v16498=v21241.Writeable;ast.flags=v16497|v16498}var v8514=!exprIsAnonLambda;if(v8514){ast.minChar=minChar;var v8512=ast,v16499=ast.limChar,v21242=this.scanner,v16500=JAMScript.call(v21242.lastTokenLimChar,
v21242,[]),v27184=JAMScript.call(TypeScript.max,TypeScript,[v16499,v16500]);v8512.limChar=v27184;ast.preComments=preComments;var v8513=ast,v21243=this.scanner,v16501=v21243.line,v27185=JAMScript.call(this.parseCommentsForLine,this,[v16501]);v8513.postComments=v27185}return ast}function v578(errorRecoverySet,lambdaArgs,skipNextRParen,expectClosingRParen){var v16502=TypeScript.Modifiers,v16502=v16502.None;lambdaArgs={preProcessedLambdaArgs:lambdaArgs};errorRecoverySet=JAMScript.call(this.parseFncDecl,
this,[errorRecoverySet,!1,!1,!1,null,!1,!1,!1,v16502,lambdaArgs,expectClosingRParen]);expectClosingRParen=errorRecoverySet.fncFlags;lambdaArgs=TypeScript.FncFlags;lambdaArgs=lambdaArgs.IsFunctionExpression;errorRecoverySet.fncFlags=expectClosingRParen|lambdaArgs;expectClosingRParen=errorRecoverySet.fncFlags;lambdaArgs=TypeScript.FncFlags;lambdaArgs=lambdaArgs.IsFatArrowFunction;errorRecoverySet.fncFlags=expectClosingRParen|lambdaArgs;if(skipNextRParen=!skipNextRParen)skipNextRParen=errorRecoverySet.flags,
expectClosingRParen=TypeScript.ASTFlags,expectClosingRParen=expectClosingRParen.SkipNextRParen,errorRecoverySet.flags=skipNextRParen|expectClosingRParen;skipNextRParen=errorRecoverySet;expectClosingRParen=this.scanner;expectClosingRParen=JAMScript.call(expectClosingRParen.lastTokenLimChar,expectClosingRParen,[]);skipNextRParen.limChar=expectClosingRParen;return errorRecoverySet}function v577(errorRecoverySet,allowCall,typeContext,inCast){var ast=null,sawId=!1,inNew=!1,v8519=this.scanner,minChar=v8519.startPos,
v8520=this.scanner,limChar=v8520.pos,parseAsLambda=!1,expectlambdaRParen=!1,v16510=this.currentToken,v8554=v16510.tokenId;switch(v8554){case TypeScript.TokenID.Number:case TypeScript.TokenID.Bool:case TypeScript.TokenID.Any:case TypeScript.TokenID.String:var v8521=TypeScript.Identifier,v21247=TypeScript.tokenTable,v23931=this.currentToken,v21248=v23931.tokenId;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v16511=v21247[v21248];var v8522=v16511.text,tid=JAMScript.new(v8521,
[v8522]),v16512=TypeContext.Primitive,v8524=JAMScript.call(TypeScript.hasFlag,TypeScript,[typeContext,v16512]);if(v8524)var v8523=TypeScript.TypeReference,ast=JAMScript.new(v8523,[tid,0]);else ast=tid;sawId=!0;ast.minChar=minChar;var v8525=this.scanner,v27187=JAMScript.call(v8525.scan,v8525,[]);this.currentToken=v27187;var v8526=this.scanner,limChar=JAMScript.call(v8526.lastTokenLimChar,v8526,[]);break;case TypeScript.TokenID.This:var v8527=TypeScript.AST,v16513=TypeScript.NodeType,v8528=v16513.This,
ast=JAMScript.new(v8527,[v8528]);ast.minChar=minChar;var v8529=this.scanner,v27188=JAMScript.call(v8529.scan,v8529,[]);this.currentToken=v27188;var v8530=this.scanner,limChar=JAMScript.call(v8530.lastTokenLimChar,v8530,[]);break;case TypeScript.TokenID.Super:var v8531=TypeScript.AST,v16514=TypeScript.NodeType,v8532=v16514.Super,ast=JAMScript.new(v8531,[v8532]);ast.minChar=minChar;var v8533=this.scanner,v27189=JAMScript.call(v8533.scan,v8533,[]);this.currentToken=v27189;var v8534=this.scanner,limChar=
JAMScript.call(v8534.lastTokenLimChar,v8534,[]);break;case TypeScript.TokenID.True:var v8535=TypeScript.AST,v16515=TypeScript.NodeType,v8536=v16515.True,ast=JAMScript.new(v8535,[v8536]),v8537=this.scanner,v27190=JAMScript.call(v8537.scan,v8537,[]);this.currentToken=v27190;ast.minChar=minChar;break;case TypeScript.TokenID.False:var v8538=TypeScript.AST,v16516=TypeScript.NodeType,v8539=v16516.False,ast=JAMScript.new(v8538,[v8539]),v8540=this.scanner,v27191=JAMScript.call(v8540.scan,v8540,[]);this.currentToken=
v27191;ast.minChar=minChar;break;case TypeScript.TokenID.Null:var v8541=TypeScript.AST,v16517=TypeScript.NodeType,v8542=v16517.Null,ast=JAMScript.new(v8541,[v8542]),v8543=this.scanner,v27192=JAMScript.call(v8543.scan,v8543,[]);this.currentToken=v27192;ast.minChar=minChar;break;case TypeScript.TokenID.New:var v8544=this.scanner,minChar=v8544.pos,v8545=this.scanner,v27193=JAMScript.call(v8545.scan,v8545,[]);this.currentToken=v27193;var v8546=TypeContext.AllSimpleTypes,target=JAMScript.call(this.parseTerm,
this,[errorRecoverySet,!1,v8546,inCast]),v21249=target.nodeType,v23932=TypeScript.NodeType,v21250=v23932.Error,v16518=v21249==v21250,v21252=!v16518;if(v21252){var v23933=target.nodeType,v25266=TypeScript.NodeType,v23934=v25266.Index,v21251=v23933==v23934;if(v21251)var v25267=target.operand1,v23935=v25267.nodeType,v25268=TypeScript.NodeType,v23936=v25268.TypeRef,v21251=v23935==v23936;v16518=v21251}var v8550=v16518;if(v8550)JAMScript.call(this.reportParseError,this,["Cannot invoke 'new' on this expression"]);
else{var v8547=TypeScript.CallExpression,v16519=TypeScript.NodeType,v8548=v16519.New,ast=JAMScript.new(v8547,[v8548,target,null]);ast.minChar=minChar;var v8549=this.scanner,limChar=JAMScript.call(v8549.lastTokenLimChar,v8549,[]),inNew=!0}break;case TypeScript.TokenID.Function:var v8551=this.scanner,minChar=v8551.pos,v16520=TypeScript.Modifiers,v8552=v16520.None,ast=JAMScript.call(this.parseFncDecl,this,[errorRecoverySet,!1,!1,!1,null,!1,!1,!1,v8552,null,!0]),v16521=ast.fncFlags,v21253=TypeScript.FncFlags,
v16522=v21253.IsFunctionExpression;ast.fncFlags=v16521|v16522;ast.minChar=minChar;var v8553=this.scanner,limChar=JAMScript.call(v8553.lastTokenLimChar,v8553,[]);ast.limChar=limChar}var v8561=null==ast;if(v8561){var v23937=this.currentToken,v21254=v23937.tokenId,v23938=TypeScript.TokenID,v21255=v23938.Identifier,v16523=v21254==v21255,v21258=!v16523;if(v21258)var v21256=this.currentToken,v21257=this.strictMode,v16523=JAMScript.call(TypeScript.convertTokToID,TypeScript,[v21256,v21257]);var v8560=v16523;
if(v8560){var v8555=this.currentToken,idText=JAMScript.call(v8555.getText,v8555,[]),v16524=this.currentToken,v8556=v16524.hasEscapeSequence,ast=JAMScript.call(this.createRef,this,[idText,v8556,minChar]),sawId=!0;ast.minChar=minChar;var v8557=this.scanner,v27194=JAMScript.call(v8557.scan,v8557,[]),v21259=this.currentToken=v27194,v16525=v21259.tokenId,v21260=TypeScript.TokenID,v16526=v21260.Question,v8558=v16525==v16526;if(v8558){var v16527=ast.flags,v21261=TypeScript.ASTFlags,v16528=v21261.PossibleOptionalParameter;
ast.flags=v16527|v16528}var v8559=this.scanner,limChar=JAMScript.call(v8559.lastTokenLimChar,v8559,[])}}if(inCast){var v16529=TypeScript.TokenID,v8562=v16529.GreaterThan;JAMScript.call(this.checkCurrentToken,this,[v8562,errorRecoverySet])}var v8623=null==ast;if(v8623){var v16530=this.currentToken,v8622=v16530.tokenId;switch(v8622){case TypeScript.TokenID.OpenParen:var v8563=this.scanner,minChar=v8563.pos,v16531=this.scanner,v8564=JAMScript.call(v16531.previousToken,v16531,[]),prevTokId=v8564.tokenId,
v8565=this.scanner,v27195=JAMScript.call(v8565.scan,v8565,[]);this.currentToken=v27195;var v21262=TypeScript.TokenID,v16532=v21262.OpenParen,v8566=prevTokId==v16532,v16534=!v8566;if(v16534){var v23939=TypeScript.TokenID,v21263=v23939.Comma,v16533=prevTokId==v21263,v21265=!v16533;if(v21265){var v25269=TypeScript.TokenID,v23940=v25269.EqualsEquals,v21264=prevTokId==v23940,v23942=!v21264;if(v23942)var v25270=TypeScript.TokenID,v23941=v25270.Colon,v21264=prevTokId==v23941;v16533=v21264}v8566=v16533}var couldBeLambda=
v8566,v16535=couldBeLambda;if(v16535)var v23943=this.currentToken,v21266=v23943.tokenId,v23944=TypeScript.TokenID,v21267=v23944.CloseParen,v16535=v21266==v21267;var v8574=v16535;if(v8574){var parseAsLambda=!0,expectlambdaRParen=!1,v8567=this.scanner,v27196=JAMScript.call(v8567.scan,v8567,[]);this.currentToken=v27196}else{var v16536=couldBeLambda;if(v16536)var v23945=this.currentToken,v21268=v23945.tokenId,v23946=TypeScript.TokenID,v21269=v23946.DotDotDot,v16536=v21268==v21269;var v8573=v16536;if(v8573)parseAsLambda=
!0;else{var v21270=TypeScript.ErrorRecoverySet,v16537=v21270.RParen,v8568=errorRecoverySet|v16537,v16538=TypeScript.OperatorPrecedence,v8569=v16538.None,v8570=TypeContext.NoTypes,ast=JAMScript.call(this.parseExpr,this,[v8568,v8569,!0,v8570,couldBeLambda]),v8571=this.scanner,limChar=JAMScript.call(v8571.lastTokenLimChar,v8571,[]),v8572=couldBeLambda;if(v8572){var v23947=ast.nodeType,v25271=TypeScript.NodeType,v23948=v25271.Name,v21271=v23947==v23948,v23951=!v21271;if(v23951)var v23949=ast.nodeType,
v25272=TypeScript.NodeType,v23950=v25272.Comma,v21271=v23949==v23950;var v16539=v21271;if(v16539){var v25273=this.currentToken,v23952=v25273.tokenId,v25274=TypeScript.TokenID,v23953=v25274.Colon,v21272=v23952==v23953,v23956=!v21272;if(v23956)var v25275=this.currentToken,v23954=v25275.tokenId,v25276=TypeScript.TokenID,v23955=v25276.Question,v21272=v23954==v23955;v16539=v21272}v8572=v16539}parseAsLambda=v8572}expectlambdaRParen=!0}var v16540=ast;v16540&&(v16540=!parseAsLambda);var v8579=v16540;if(v8579){var v16541=
ast.flags,v21273=TypeScript.ASTFlags,v16542=v21273.SkipNextRParen,v8577=JAMScript.call(TypeScript.hasFlag,TypeScript,[v16541,v16542]);if(v8577){var v8575=ast.flags,v21274=TypeScript.ASTFlags,v16543=v21274.SkipNextRParen,v8576=~v16543;ast.flags=v8575&v8576;break}var v16544=TypeScript.TokenID,v8578=v16544.CloseParen;JAMScript.call(this.checkCurrentToken,this,[v8578,errorRecoverySet]);ast.isParenthesized=!0}break;case TypeScript.TokenID.NumberLiteral:var numTok=this.currentToken,v8580=this.scanner,v27197=
JAMScript.call(v8580.scan,v8580,[]);this.currentToken=v27197;var v8581=TypeScript.NumberLiteral,v8582=numTok.value,v8583=numTok.hasEmptyFraction,ast=JAMScript.new(v8581,[v8582,v8583]);ast.minChar=minChar;var v8584=this.scanner,limChar=JAMScript.call(v8584.lastTokenLimChar,v8584,[]);break;case TypeScript.TokenID.StringLiteral:var v8585=TypeScript.StringLiteral,v16545=this.currentToken,v8586=JAMScript.call(v16545.getText,v16545,[]),ast=JAMScript.new(v8585,[v8586]),v8587=this.scanner,v27198=JAMScript.call(v8587.scan,
v8587,[]);this.currentToken=v27198;ast.minChar=minChar;var v8588=this.scanner,limChar=JAMScript.call(v8588.lastTokenLimChar,v8588,[]);break;case TypeScript.TokenID.RegularExpressionLiteral:var rtok=this.currentToken,v8589=TypeScript.RegexLiteral,v8590=rtok.regex,ast=JAMScript.new(v8589,[v8590]),v8591=this.scanner,v27199=JAMScript.call(v8591.scan,v8591,[]);this.currentToken=v27199;ast.minChar=minChar;var v8592=this.scanner,limChar=JAMScript.call(v8592.lastTokenLimChar,v8592,[]);break;case TypeScript.TokenID.OpenBracket:var v8593=
this.scanner,minChar=v8593.startPos,v8594=this.scanner,v27200=JAMScript.call(v8594.scan,v8594,[]);this.currentToken=v27200;var v21275=TypeScript.ErrorRecoverySet,v16546=v21275.RBrack,v8595=v16546|errorRecoverySet,ast=JAMScript.call(this.parseArrayLiteral,this,[v8595]);ast.minChar=minChar;var v8596=this.scanner,limChar=v8596.pos,v16547=TypeScript.TokenID,v8597=v16547.CloseBracket;JAMScript.call(this.checkCurrentToken,this,[v8597,errorRecoverySet]);break;case TypeScript.TokenID.OpenBrace:var v8598=
this.scanner,minChar=v8598.startPos,v8599=this.scanner,v27201=JAMScript.call(v8599.scan,v8599,[]);this.currentToken=v27201;var v21276=TypeScript.ErrorRecoverySet,v16548=v21276.RCurly,v8600=v16548|errorRecoverySet,members=JAMScript.call(this.parseMemberList,this,[v8600]),v16549=TypeScript.TokenID,v8601=v16549.CloseBrace;JAMScript.call(this.checkCurrentToken,this,[v8601,errorRecoverySet]);var v8602=TypeScript.UnaryExpression,v16550=TypeScript.NodeType,v8603=v16550.ObjectLit,ast=JAMScript.new(v8602,
[v8603,members]);ast.minChar=minChar;var v8604=this.scanner,limChar=JAMScript.call(v8604.lastTokenLimChar,v8604,[]);members.minChar=minChar;members.limChar=limChar;break;case TypeScript.TokenID.LessThan:var v8605=this.scanner,minChar=v8605.startPos,v8606=this.scanner,v27202=JAMScript.call(v8606.scan,v8606,[]);this.currentToken=v27202;var v16551=TypeScript.ErrorRecoverySet,v8607=v16551.BinOp,term=JAMScript.call(this.parseTypeReference,this,[v8607,!1]),v16552=TypeScript.TokenID,v8608=v16552.GreaterThan;
JAMScript.call(this.checkCurrentToken,this,[v8608,errorRecoverySet]);var v8609=TypeScript.UnaryExpression,v16553=TypeScript.NodeType,v8610=v16553.TypeAssertion,v21277=TypeScript.OperatorPrecedence,v16554=v21277.Unary,v16555=TypeContext.NoTypes,v8611=JAMScript.call(this.parseExpr,this,[errorRecoverySet,v16554,!1,v16555]),ast=JAMScript.new(v8609,[v8610,v8611]);ast.castTerm=term;break;default:var v16556=this.prevExpr;if(v16556)var v23957=this.prevExpr,v21278=v23957.flags,v23958=TypeScript.ASTFlags,v21279=
v23958.PossibleOptionalParameter,v16556=JAMScript.call(TypeScript.hasFlag,TypeScript,[v21278,v21279]);var v8621=v16556;if(v8621)parseAsLambda=!0,ast=this.prevExpr;else{JAMScript.call(this.reportParseError,this,["Check format of expression term"]);var v8620=this.errorRecovery;if(v8620){var v8612=TypeScript.MissingIdentifier,ident=JAMScript.new(v8612,[]);ident.minChar=minChar;var v16557=ident.flags,v21280=TypeScript.ASTFlags,v16558=v21280.Error;ident.flags=v16557|v16558;var v21281=TypeScript.ErrorRecoverySet,
v16559=v21281.Postfix,v8613=errorRecoverySet|v16559;JAMScript.call(this.skip,this,[v8613]);var v23959=this.currentToken,v21282=v23959.tokenId,v23960=TypeScript.TokenID,v21283=v23960.Identifier,v16560=v21282==v21283,v21286=!v16560;if(v21286)var v21284=this.currentToken,v21285=this.strictMode,v16560=JAMScript.call(TypeScript.convertTokToID,TypeScript,[v21284,v21285]);var v8619=v16560;if(v8619){var v16561=this.currentToken,v8614=JAMScript.call(v16561.getText,v16561,[]),v16562=this.currentToken,v8615=
v16562.hasEscapeSequence;JAMScript.call(ident.setText,ident,[v8614,v8615]);var v8616=this.scanner,v27203=JAMScript.call(v8616.scan,v8616,[]);this.currentToken=v27203;var v8617=this.scanner,limChar=JAMScript.call(v8617.lastTokenLimChar,v8617,[])}else var v8618=this.scanner,limChar=JAMScript.call(v8618.lastTokenLimChar,v8618,[]);ast=ident}}}}if(parseAsLambda){var v23961=this.currentToken,v21287=v23961.tokenId,v23962=TypeScript.TokenID,v21288=v23962.Colon,v16563=v21287==v21288,v21290=!v16563;if(v21290){var v25277=
this.currentToken,v23963=v25277.tokenId,v25278=TypeScript.TokenID,v23964=v25278.Comma,v21289=v23963==v23964,v23966=!v21289;if(v23966){var v25999=this.currentToken,v25279=v25999.tokenId,v26000=TypeScript.TokenID,v25280=v26000.CloseParen,v23965=v25279==v25280,v25283=!v23965;if(v25283)var v26001=this.currentToken,v25281=v26001.tokenId,v26002=TypeScript.TokenID,v25282=v26002.DotDotDot,v23965=v25281==v25282;v21289=v23965}v16563=v21289}var v8625=v16563;if(v8625){ast=JAMScript.call(this.parseLambdaExpr,
this,[errorRecoverySet,ast,!0,expectlambdaRParen]);ast.minChar=minChar;var v8624=this.scanner,limChar=JAMScript.call(v8624.lastTokenLimChar,v8624,[]);ast.limChar=limChar}else ast&&(ast.isParenthesized=!0)}var v16564=sawId;if(v16564)var v21291=TypeContext.NoTypes,v16564=typeContext!=v21291;var v8626=v16564;if(v8626){var v16565=TypeContext.ArraySuffix;typeContext|=v16565}var postFix=JAMScript.call(this.parsePostfixOperators,this,[errorRecoverySet,ast,allowCall,inNew,typeContext,minChar,limChar]);if(postFix){var v16566=
sawId;if(v16566)var v21292=postFix.nodeType,v23967=TypeScript.NodeType,v21293=v23967.Index,v16566=v21292==v21293;var v8628=v16566;if(v8628){var binExpr=postFix,v16567=binExpr.operand2,v8627=null==v16567;v8627&&(postFix=JAMScript.call(this.convertToTypeReference,this,[postFix]))}postFix.minChar=minChar;var v8629=postFix,v16568=postFix.limChar,v21294=this.scanner,v16569=JAMScript.call(v21294.lastTokenLimChar,v21294,[]),v27204=JAMScript.call(TypeScript.max,TypeScript,[v16568,v16569]);v8629.limChar=v27204;
return postFix}var v8630=TypeScript.AST,v16570=TypeScript.NodeType,v8631=v16570.Error;return JAMScript.new(v8630,[v8631])}function v576(errorRecoverySet){var arrayLiteral=null,arrayLiteral=TypeScript.UnaryExpression,v16571=TypeScript.NodeType,v16571=v16571.ArrayLit;errorRecoverySet=JAMScript.call(this.parseArrayList,this,[errorRecoverySet]);return arrayLiteral=JAMScript.new(arrayLiteral,[v16571,errorRecoverySet])}function v575(errorRecoverySet){var elements=null,v21295=this.currentToken,v21295=v21295.tokenId,
v21296=TypeScript.TokenID,v21296=v21296.CloseBracket;if(v21295=v21295==v21296)return elements;elements=TypeScript.ASTList;elements=JAMScript.new(elements,[]);v21295=this.scanner;for(elements.minChar=v21295.startPos;;){v21295=this.currentToken;v21295=v21295.tokenId;v21296=TypeScript.TokenID;v21296=v21296.Comma;v21295=v21295==v21296;if(v21296=!v21295)v21295=this.currentToken,v21295=v21295.tokenId,v21296=TypeScript.TokenID,v21296=v21296.CloseBracket,v21295=v21295==v21296;if(v21295)v21295=TypeScript.AST,
v21296=TypeScript.NodeType,v21296=v21296.EmptyExpr,v21295=JAMScript.new(v21295,[v21296]);else var v21295=TypeScript.ErrorRecoverySet,v21295=v21295.Comma,v21295=v21295|errorRecoverySet,v21296=TypeScript.OperatorPrecedence,v21296=v21296.Comma,v8642=TypeContext.NoTypes,v21295=JAMScript.call(this.parseExpr,this,[v21295,v21296,!0,v8642]);JAMScript.call(elements.append,elements,[v21295]);v21295=this.currentToken;v21295=v21295.tokenId;v21296=TypeScript.TokenID;v21296=v21296.Comma;if(v21295=v21295!=v21296)break;
v21295=this.scanner;this.currentToken=v21295=JAMScript.call(v21295.scan,v21295,[])}errorRecoverySet=elements;v21295=this.scanner;v21295=JAMScript.call(v21295.lastTokenLimChar,v21295,[]);errorRecoverySet.limChar=v21295;return elements}function v574(errorRecoverySet){var v8647=TypeScript.ASTList,elements=JAMScript.new(v8647,[]),v21305=this.currentToken,v16581=v21305.tokenId,v21306=TypeScript.TokenID,v16582=v21306.CloseBrace,v8648=v16581==v16582;if(v8648)return elements;for(var idHint=null,memberName=
null,memberExpr=null,member=null,v8649=this.scanner,minChar=v8649.startPos,isSet=!1,skippedTokenForGetSetId=!1,getSetTok=null,getSetStartPos=0,getSetPos=0;;){var accessorPattern=!1,v23972=this.currentToken,v21307=v23972.tokenId,v23973=TypeScript.TokenID,v21308=v23973.Get,v16583=v21307==v21308,v21311=!v16583;if(v21311)var v23974=this.currentToken,v21309=v23974.tokenId,v23975=TypeScript.TokenID,v21310=v23975.Set,v16583=v21309==v21310;var v8686=v16583;if(v8686){var v16584=this.currentToken,v8650=v16584.tokenId,
v16585=TypeScript.TokenID,v8651=v16585.Set,isSet=v8650==v8651,getSetTok=this.currentToken,v8652=this.scanner,getSetStartPos=v8652.startPos,v8653=this.scanner,getSetPos=v8653.pos,v8654=this.scanner,v27207=JAMScript.call(v8654.scan,v8654,[]),v23976=this.currentToken=v27207,v21312=v23976.tokenId,v23977=TypeScript.TokenID,v21313=v23977.Identifier,v16586=v21312==v21313,v21315=!v16586;if(v21315)var v21314=this.currentToken,v16586=JAMScript.call(TypeScript.convertTokToIDName,TypeScript,[v21314]);var v8664=
v16586;if(v8664){var v8655,v8656=idHint=v8655=isSet?"set":"get",v16587=this.currentToken,v8657=JAMScript.call(v16587.getText,v16587,[]),idHint=v8656+v8657,v8658=TypeScript.Identifier,v8659=this.currentToken,memberName=JAMScript.call(v8658.fromToken,v8658,[v8659]),v8660=this.scanner;memberName.minChar=v8660.startPos;var accessorPattern=!0,v16588=TypeScript.codeGenTarget,v21316=TypeScript.CodeGenTarget,v16589=v21316.ES5,v8661=v16588<v16589;v8661&&JAMScript.call(this.reportParseError,this,["Property accessors are only available when targeting ES5 or greater"])}else{var v21317=
this.currentToken,v16590=v21317.tokenId,v21318=TypeScript.TokenID,v16591=v21318.Colon,v8663=v16590!=v16591;if(v8663)JAMScript.call(this.reportParseError,this,["Expected identifier, string or number as accessor name"]);else{var skippedTokenForGetSetId=!0,v8662=TypeScript.Identifier,memberName=JAMScript.call(v8662.fromToken,v8662,[getSetTok]);memberName.minChar=getSetStartPos;memberName.limChar=getSetPos}}}else{var v23978=this.currentToken,v21319=v23978.tokenId,v23979=TypeScript.TokenID,v21320=v23979.Identifier,
v16592=v21319==v21320,v21322=!v16592;if(v21322)var v21321=this.currentToken,v16592=JAMScript.call(TypeScript.convertTokToIDName,TypeScript,[v21321]);var v8685=v16592;if(v8685){var v8665=this.currentToken,idHint=JAMScript.call(v8665.getText,v8665,[]),v8666=TypeScript.Identifier,v8667=this.currentToken,memberName=JAMScript.call(v8666.fromToken,v8666,[v8667]),v8668=this.scanner;memberName.minChar=v8668.startPos;var v8669=this.scanner;memberName.limChar=v8669.pos}else{var v21323=this.currentToken,v16593=
v21323.tokenId,v21324=TypeScript.TokenID,v16594=v21324.StringLiteral,v8684=v16593==v16594;if(v8684){var v8670=this.currentToken,idHint=JAMScript.call(v8670.getText,v8670,[]),v8671=TypeScript.StringLiteral,memberName=JAMScript.new(v8671,[idHint]),v8672=this.scanner;memberName.minChar=v8672.startPos;var v8673=this.scanner;memberName.limChar=v8673.pos}else{var v21325=this.currentToken,v16595=v21325.tokenId,v21326=TypeScript.TokenID,v16596=v21326.NumberLiteral,v8683=v16595==v16596;if(v8683){var ntok=
this.currentToken,v8674=ntok.value,idHint=JAMScript.call(v8674.toString,v8674,[]),v8675=TypeScript.StringLiteral,memberName=JAMScript.new(v8675,[idHint]),v8676=this.scanner;memberName.minChar=v8676.startPos;var v8677=this.scanner;memberName.limChar=v8677.pos}else{JAMScript.call(this.reportParseError,this,["Expected identifier, string or number as member name"]);var v8682=this.errorRecovery;if(v8682){var v8678=TypeScript.MissingIdentifier,memberName=JAMScript.new(v8678,[]),v8679=this.scanner;memberName.minChar=
v8679.startPos;var v16597=memberName.flags,v21327=TypeScript.ASTFlags,v16598=v21327.Error;memberName.flags=v16597|v16598;var v21328=TypeScript.ErrorRecoverySet,v16599=v21328.Comma,v8680=errorRecoverySet|v16599;JAMScript.call(this.skip,this,[v8680]);var v8681=memberName,v16600=this.scanner,v27208=JAMScript.call(v16600.lastTokenLimChar,v16600,[]);v8681.limChar=v27208}}}}}var v8688=!skippedTokenForGetSetId;if(v8688){var v8687=this.scanner,v27209=JAMScript.call(v8687.scan,v8687,[]);this.currentToken=
v27209}else skippedTokenForGetSetId=!1;var v21329=this.currentToken,v16601=v21329.tokenId,v21330=TypeScript.TokenID,v16602=v21330.Question,v8690=v16601==v16602;if(v8690){var v16603=memberName.flags,v21331=TypeScript.ASTFlags,v16604=v21331.OptionalName;memberName.flags=v16603|v16604;var v8689=this.scanner,v27210=JAMScript.call(v8689.scan,v8689,[]);this.currentToken=v27210}if(accessorPattern){var v8691=TypeScript.ASTList,args=JAMScript.new(v8691,[]),v21332=TypeScript.ErrorRecoverySet,v16605=v21332.RParen,
v8692=errorRecoverySet|v16605,v8693=!isSet;JAMScript.call(this.parseFormalParameterList,this,[v8692,args,!1,!0,!1,v8693,isSet,!1,null,!0]);var v21333=TypeScript.ErrorRecoverySet,v16606=v21333.RCurly,v8694=errorRecoverySet|v16606,v16607=TypeScript.AllowedElements,v8695=v16607.None,v16608=this.scanner,v8696=v16608.startPos,v16609=TypeScript.Modifiers,v8697=v16609.None,funcDecl=JAMScript.call(this.parseFunctionStatements,this,[v8694,memberName,!1,!0,args,v8695,v8696,!1,v8697]),v16610=isSet;v16610&&(v16610=
funcDecl.returnTypeAnnotation);var v8698=v16610;v8698&&JAMScript.call(this.reportParseError,this,["Property setters may not declare a return type"]);var v16611=funcDecl.fncFlags,v21334;if(isSet){var v23980=TypeScript.FncFlags;v21334=v23980.SetAccessor}else{var v23981=TypeScript.FncFlags;v21334=v23981.GetAccessor}var v16612=v21334;funcDecl.fncFlags=v16611|v16612;var v16613=funcDecl.fncFlags,v21335=TypeScript.FncFlags,v16614=v21335.IsFunctionExpression;funcDecl.fncFlags=v16613|v16614;funcDecl.hint=
idHint;var memberExpr=funcDecl,v8699=TypeScript.BinaryExpression,v16615=TypeScript.NodeType,v8700=v16615.Member,member=JAMScript.new(v8699,[v8700,memberName,memberExpr]);member.minChar=memberName.minChar;var v16616=memberExpr.nodeType,v21336=TypeScript.NodeType,v16617=v21336.FuncDecl,v8701=v16616==v16617;v8701&&(funcDecl=memberExpr,funcDecl.hint=idHint)}else{var v21337=this.currentToken,v16618=v21337.tokenId,v21338=TypeScript.TokenID,v16619=v21338.Colon,v8712=v16618==v16619;if(v8712){var v8702=this.scanner,
v27211=JAMScript.call(v8702.scan,v8702,[]);this.currentToken=v27211;var v21339=TypeScript.ErrorRecoverySet,v16620=v21339.Comma,v8703=v16620|errorRecoverySet,v16621=TypeScript.OperatorPrecedence,v8704=v16621.Comma,v8705=TypeContext.NoTypes,memberExpr=JAMScript.call(this.parseExpr,this,[v8703,v8704,!0,v8705]),v16622=memberExpr.nodeType,v21340=TypeScript.NodeType,v16623=v21340.TypeRef,v8706=v16622==v16623;v8706&&JAMScript.call(this.reportParseError,this,["Expected 'new' on array declaration in member definition"]);
var v8707=TypeScript.BinaryExpression,v16624=TypeScript.NodeType,v8708=v16624.Member,member=JAMScript.new(v8707,[v8708,memberName,memberExpr]);member.minChar=memberName.minChar;var v16625=memberExpr.nodeType,v21341=TypeScript.NodeType,v16626=v21341.FuncDecl,v8709=v16625==v16626;v8709&&(funcDecl=memberExpr,funcDecl.hint=idHint)}else{JAMScript.call(this.reportParseError,this,["Expected ':' in member definition"]);var v8711=this.errorRecovery;if(v8711){JAMScript.call(this.skip,this,[errorRecoverySet]);
var v16627=elements.flags,v21342=TypeScript.ASTFlags,v16628=v21342.Error;elements.flags=v16627|v16628;elements.minChar=minChar;var v8710=elements,v16629=this.scanner,v27212=JAMScript.call(v16629.lastTokenLimChar,v16629,[]);v8710.limChar=v27212;return elements}}}idHint=null;JAMScript.call(elements.append,elements,[member]);var v8713=member,v16630=this.scanner,v27213=JAMScript.call(v16630.lastTokenLimChar,v16630,[]);v8713.limChar=v27213;var v21343=this.currentToken,v16631=v21343.tokenId,v21344=TypeScript.TokenID,
v16632=v21344.Comma,v8715=v16631!=v16632;if(v8715)break;else{var v8714=this.scanner,v27214=JAMScript.call(v8714.scan,v8714,[]);this.currentToken=v27214}var v21345=this.currentToken,v16633=v21345.tokenId,v21346=TypeScript.TokenID,v16634=v21346.CloseBrace,v8716=v16633==v16634;if(v8716)break}member&&(elements.limChar=member.limChar);elements.minChar=minChar;return elements}function v573(errorRecoverySet,modifiers,allowIn,isStatic){var v16635=TypeScript.Modifiers,v8717=v16635.Readonly,isConst=JAMScript.call(TypeScript.hasFlag,
TypeScript,[modifiers,v8717]),v8718=this.scanner,minChar=v8718.startPos,varDecl=null,declList=null,multivar=!1,v8719=this.scanner,v27215=JAMScript.call(v8719.scan,v8719,[]);this.currentToken=v27215;for(var varDeclPreComments=JAMScript.call(this.parseComments,this,[]);;){var v23982=this.currentToken,v21347=v23982.tokenId,v23983=TypeScript.TokenID,v21348=v23983.Identifier,v16636=v21347!=v21348;if(v16636)var v23984=this.currentToken,v23985=this.strictMode,v21349=JAMScript.call(TypeScript.convertTokToID,
TypeScript,[v23984,v23985]),v16636=!v21349;var v8725=v16636;if(v8725){JAMScript.call(this.reportParseError,this,["Expected identifier in variable declaration"]);var v8724=this.errorRecovery;if(v8724){var v8720=TypeScript.VarDecl,v16637=TypeScript.MissingIdentifier,v8721=JAMScript.new(v16637,[]),v8722=this.nestingLevel,varDecl=JAMScript.new(v8720,[v8721,v8722]);varDecl.minChar=minChar;JAMScript.call(this.skip,this,[errorRecoverySet]);var v16638=varDecl.flags,v21350=TypeScript.ASTFlags,v16639=v21350.Error;
varDecl.flags=v16638|v16639;var v8723=varDecl,v16640=this.scanner,v27216=JAMScript.call(v16640.lastTokenLimChar,v16640,[]);v8723.limChar=v27216;return varDecl}}var v8726=TypeScript.Identifier,v8727=this.currentToken,varDeclName=JAMScript.call(v8726.fromToken,v8726,[v8727]),v16641=this.strictMode;if(v16641)var v21351=varDeclName.text,v16641="eval"==v21351;var v8728=v16641;v8728&&JAMScript.call(this.reportParseError,this,["'eval' may not name a variable in strict mode"]);var v8729=this.nestingLevel,
varDecl=JAMScript.call(this.makeVarDecl,this,[varDeclName,v8729]),v8730=varDecl.id,v16642=this.scanner;v8730.minChar=v16642.startPos;var v8731=varDecl.id,v16643=this.scanner;v8731.limChar=v16643.pos;varDecl.preComments=varDeclPreComments;if(isStatic){var v16644=varDecl.varFlags,v21352=TypeScript.VarFlags,v16645=v21352.Static;varDecl.varFlags=v16644|v16645}var v21353=TypeScript.Modifiers,v16646=v21353.Readonly,v8732=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v16646]);if(v8732){var v16647=
varDecl.varFlags,v21354=TypeScript.VarFlags,v16648=v21354.Readonly;varDecl.varFlags=v16647|v16648}var v16649=this.parsingDeclareFile,v21356=!v16649;if(v21356){var v21355=this.ambientModule,v23987=!v21355;if(v23987)var v25284=TypeScript.Modifiers,v23986=v25284.Ambient,v21355=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v23986]);v16649=v21355}var v8733=v16649;if(v8733){var v16650=varDecl.varFlags,v21357=TypeScript.VarFlags,v16651=v21357.Ambient;varDecl.varFlags=v16650|v16651}var v16652=this.parsingDeclareFile,
v21359=!v16652;if(v21359){var v21358=this.ambientModule,v23989=!v21358;if(v23989)var v25285=TypeScript.Modifiers,v23988=v25285.Exported,v21358=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v23988]);v16652=v21358}var v8734=v16652;if(v8734){var v16653=varDecl.varFlags,v21360=TypeScript.VarFlags,v16654=v21360.Exported;varDecl.varFlags=v16653|v16654}varDecl.minChar=minChar;declList&&JAMScript.call(declList.append,declList,[varDecl]);var v8735=this.scanner,v27217=JAMScript.call(v8735.scan,v8735,
[]),v21361=this.currentToken=v27217,v16655=v21361.tokenId,v21362=TypeScript.TokenID,v16656=v21362.Colon,v8738=v16655==v16656;if(v8738){var v8736=this.scanner,v27218=JAMScript.call(v8736.scan,v8736,[]);this.currentToken=v27218;var prevInFncDecl=this.inFncDecl;this.inFncDecl=!1;var v8737=varDecl,v25286=TypeScript.ErrorRecoverySet,v23990=v25286.Asg,v21363=errorRecoverySet|v23990,v23991=TypeScript.ErrorRecoverySet,v21364=v23991.Comma,v16657=v21363|v21364,v27219=JAMScript.call(this.parseTypeReference,
this,[v16657,!1]);v8737.typeExpr=v27219;this.inFncDecl=prevInFncDecl}var v21365=this.currentToken,v16658=v21365.tokenId,v21366=TypeScript.TokenID,v16659=v21366.Equals,v8746=v16658==v16659;if(v8746){var v16660=varDecl.varFlags,v21367=TypeScript.VarFlags,v16661=v21367.Ambient,v8739=JAMScript.call(TypeScript.hasFlag,TypeScript,[v16660,v16661]);v8739&&JAMScript.call(this.reportParseError,this,["Ambient variable can not have an initializer"]);var v8740=this.scanner,v27220=JAMScript.call(v8740.scan,v8740,
[]);this.currentToken=v27220;var v8741=varDecl,v23992=TypeScript.ErrorRecoverySet,v21368=v23992.Comma,v16662=v21368|errorRecoverySet,v21369=TypeScript.OperatorPrecedence,v16663=v21369.Comma,v16664=TypeContext.NoTypes,v27221=JAMScript.call(this.parseExpr,this,[v16662,v16663,allowIn,v16664]);v8741.init=v27221;var v8742=varDecl.init;varDecl.limChar=v8742.limChar;var v21370=varDecl.init,v16665=v21370.nodeType,v21371=TypeScript.NodeType,v16666=v21371.FuncDecl,v8744=v16665==v16666;if(v8744){var funcDecl=
varDecl.init,v8743=varDecl.id;funcDecl.hint=v8743.actualText}}else{isConst&&JAMScript.call(this.reportParseError,this,["const declaration requires initializer"]);var v8745=this.scanner;varDecl.limChar=v8745.pos}var v8747=varDecl,v21372=this.scanner,v16667=v21372.line,v27222=JAMScript.call(this.parseCommentsForLine,this,[v16667]);v8747.postComments=v27222;var v21373=this.currentToken,v16668=v21373.tokenId,v21374=TypeScript.TokenID,v16669=v21374.Comma,v8748=v16668!=v16669;if(v8748)return declList?(declList.limChar=
varDecl.limChar,declList):varDecl;var v8750=!multivar;if(v8750){var v8749=TypeScript.ASTList,declList=JAMScript.new(v8749,[]);declList.minChar=varDecl.minChar;JAMScript.call(declList.append,declList,[varDecl]);multivar=!0}var v8751=this.scanner,v27223=JAMScript.call(v8751.scan,v8751,[]);this.currentToken=v27223;var v8752=this.scanner,minChar=v8752.startPos}}function v572(errorRecoverySet,modifiers,requireSignature,isStatic){var text=null,v8753=this.scanner,minChar=v8753.startPos,nameLimChar=minChar,
isNew=!1,isIndexer=!1,v8754=this.prevIDTok,wasAccessorID=null!=v8754,v21375=TypeScript.Modifiers,v16670=v21375.Getter,v8755=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v16670]),v16672=!v8755;if(v16672)var v21376=TypeScript.Modifiers,v16671=v21376.Setter,v8755=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v16671]);var isAccessor=v8755,v16673=this.parsingDeclareFile,v21378=!v16673;if(v21378){var v21377=this.ambientModule,v23994=!v21377;if(v23994)var v25287=TypeScript.Modifiers,
v23993=v25287.Ambient,v21377=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v23993]);v16673=v21377}var v8756=v16673;v8756&&(requireSignature=!0);var v23995=this.currentToken,v21379=v23995.tokenId,v23996=TypeScript.TokenID,v21380=v23996.OpenParen,v16674=v21379==v21380;v16674&&(v16674=!wasAccessorID);var v8796=v16674;if(v8796){var v16675=!requireSignature;v16675&&(v16675=!isStatic);var v8759=v16675;if(v8759){JAMScript.call(this.reportParseError,this,["Expected identifier in property declaration"]);
var v8758=this.errorRecovery;if(v8758){JAMScript.call(this.skip,this,[errorRecoverySet]);var v8757=TypeScript.MissingIdentifier,text=JAMScript.new(v8757,[])}}}else{var v21381=this.currentToken,v16676=v21381.tokenId,v21382=TypeScript.TokenID,v16677=v21382.New,v8795=v16676==v16677;if(v8795){if(requireSignature){var v8760=this.scanner,v27224=JAMScript.call(v8760.scan,v8760,[]),v21383=this.currentToken=v27224,v16678=v21383.tokenId,v21384=TypeScript.TokenID,v16679=v21384.OpenParen,v8761=v16678==v16679;
v8761&&(isNew=!0)}var v8768=!isNew;if(v8768){var v8763=!requireSignature;if(v8763){var v8762=this.scanner,v27225=JAMScript.call(v8762.scan,v8762,[]);this.currentToken=v27225}var v8764=TypeScript.Identifier,text=JAMScript.new(v8764,["new"]),v16680=this.scanner,v8765=v16680.pos;text.minChar=v8765-3;var v8766=this.scanner;text.limChar=v8766.pos;var v8767=this.scanner,nameLimChar=v8767.pos}}else{var v23997=this.currentToken,v21385=v23997.tokenId,v23998=TypeScript.TokenID,v21386=v23998.OpenBracket,v16681=
v21385==v21386;v16681&&(v16681=requireSignature);var v8794=v16681;if(v8794)var isIndexer=!0,v8769=TypeScript.Identifier,text=JAMScript.new(v8769,["__item"]);else{var v23999=this.currentToken,v21387=v23999.tokenId,v24000=TypeScript.TokenID,v21388=v24000.Identifier,v16682=v21387!=v21388;if(v16682){var v25288=this.currentToken,v24001=JAMScript.call(TypeScript.convertTokToIDName,TypeScript,[v25288]),v21389=!v24001;v21389&&(v21389=!wasAccessorID);v16682=v21389}var v8793=v16682;if(v8793){JAMScript.call(this.reportParseError,
this,["Expected identifier in property declaration"]);var v8779=this.errorRecovery;if(v8779){var v8770=this.scanner,eminChar=v8770.startPos,v8771=this.scanner,curpos=v8771.pos,v24002=TypeScript.ErrorRecoverySet,v21390=v24002.Comma,v16683=~v21390,v8772=errorRecoverySet&v16683;JAMScript.call(this.skip,this,[v8772]);var v21391=this.scanner,v16684=v21391.pos,v8774=v16684==curpos;if(v8774){var v8773=this.scanner,v27226=JAMScript.call(v8773.scan,v8773,[]);this.currentToken=v27226}var v8775=TypeScript.VarDecl,
v16685=TypeScript.MissingIdentifier,v8776=JAMScript.new(v16685,[]),v8777=this.nestingLevel,epd=JAMScript.new(v8775,[v8776,v8777]),v16686=epd.flags,v21392=TypeScript.ASTFlags,v16687=v21392.Error;epd.flags=v16686|v16687;epd.minChar=eminChar;var v8778=epd,v16688=this.scanner,v27227=JAMScript.call(v16688.lastTokenLimChar,v16688,[]);v8778.limChar=v27227;return epd}}else if(wasAccessorID){var v8780=TypeScript.Identifier,v8781=this.prevIDTok,v8782=text=JAMScript.call(v8780.fromToken,v8780,[v8781]),v21393=
this.scanner,v16689=JAMScript.call(v21393.lastTokenLimChar,v21393,[]);v8782.minChar=v16689-3;var v8783=text,v16690=this.scanner,v27228=JAMScript.call(v16690.lastTokenLimChar,v16690,[]);v8783.limChar=v27228;var nameLimChar=text.limChar,v16691=TypeScript.codeGenTarget,v21394=TypeScript.CodeGenTarget,v16692=v21394.ES5,v8784=v16691<v16692;v8784&&JAMScript.call(this.reportParseError,this,["Property accessors are only available when targeting ES5 or greater"]);var v24003=this.currentToken,v21395=JAMScript.call(v24003.getText,
v24003,[]),v21396=text.actualText,v16693=v21395==v21396;if(v16693)var v21397=this.currentToken,v21398=this.prevIDTok,v16693=v21397!=v21398;var v8786=v16693;if(v8786){var v8785=this.scanner,v27229=JAMScript.call(v8785.scan,v8785,[]);this.currentToken=v27229}this.prevIDTok=null}else{var v8787=TypeScript.Identifier,v8788=this.currentToken,text=JAMScript.call(v8787.fromToken,v8787,[v8788]),v8789=this.scanner;text.minChar=v8789.startPos;var v8790=this.scanner;text.limChar=v8790.pos;var v8791=this.scanner,
nameLimChar=v8791.pos,v8792=this.scanner,v27230=JAMScript.call(v8792.scan,v8792,[]);this.currentToken=v27230}}}}var v21399=this.currentToken,v16694=v21399.tokenId,v21400=TypeScript.TokenID,v16695=v21400.Question,v8799=v16694==v16695;if(v8799){var v16696=this.inInterfaceDecl;v16696&&(v16696=text);var v8797=v16696;if(v8797){var v16697=text.flags,v21401=TypeScript.ASTFlags,v16698=v21401.OptionalName;text.flags=v16697|v16698}else JAMScript.call(this.reportParseError,this,["Optional properties may only be declared on interface or object types"]);
var v8798=this.scanner,v27231=JAMScript.call(v8798.scan,v8798,[]);this.currentToken=v27231}var v24004=this.currentToken,v21402=v24004.tokenId,v24005=TypeScript.TokenID,v21403=v24005.OpenParen,v16699=v21402==v21403,v21405=!v16699;if(v21405){var v21404=isIndexer;if(v21404)var v25289=this.currentToken,v24006=v25289.tokenId,v25290=TypeScript.TokenID,v24007=v25290.OpenBracket,v21404=v24006==v24007;v16699=v21404}var v8837=v16699;if(v8837){var v16700=TypeScript.ErrorRecoverySet,v8800=v16700.RParen,ers=errorRecoverySet|
v8800;if(isIndexer)var v16701=TypeScript.ErrorRecoverySet,v8801=v16701.RBrack,ers=errorRecoverySet|v8801;var v16702=this.inFncDecl,v8802=!v16702,v16703=this.parsingDeclareFile,v21407=!v16703;if(v21407)var v24008=TypeScript.Modifiers,v21406=v24008.Ambient,v16703=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v21406]);var v8803=v16703,ast=JAMScript.call(this.parseFncDecl,this,[ers,!0,requireSignature,v8802,text,isIndexer,isStatic,v8803,modifiers,null,!0]),funcDecl,v16704=ast.nodeType,v21408=
TypeScript.NodeType,v16705=v21408.Error,v8804=v16704==v16705;if(v8804)return ast;funcDecl=ast;var v8807=funcDecl.name;if(v8807){var v8805=funcDecl.name;v8805.minChar=minChar;var v8806=funcDecl.name;v8806.limChar=nameLimChar}var v24009=TypeScript.Modifiers,v21409=v24009.Public,v16706=modifiers&v21409,v21410=TypeScript.Modifiers,v16707=v21410.None,v8808=v16706!=v16707;if(v8808){var v16708=funcDecl.fncFlags,v21411=TypeScript.FncFlags,v16709=v21411.Public;funcDecl.fncFlags=v16708|v16709}var v24010=TypeScript.Modifiers,
v21412=v24010.Private,v16710=modifiers&v21412,v21413=TypeScript.Modifiers,v16711=v21413.None,v8809=v16710!=v16711;if(v8809){var v16712=funcDecl.fncFlags,v21414=TypeScript.FncFlags,v16713=v21414.Private;funcDecl.fncFlags=v16712|v16713}if(isStatic){var v16714=funcDecl.fncFlags,v21415=TypeScript.FncFlags,v16715=v21415.Static;funcDecl.fncFlags=v16714|v16715}var v16716=this.parsingDeclareFile,v21417=!v16716;if(v21417)var v24011=TypeScript.Modifiers,v21416=v24011.Ambient,v16716=JAMScript.call(TypeScript.hasFlag,
TypeScript,[modifiers,v21416]);var v8810=v16716;if(v8810){var v16717=funcDecl.fncFlags,v21418=TypeScript.FncFlags,v16718=v21418.Ambient;funcDecl.fncFlags=v16717|v16718}if(isAccessor){var v21419=TypeScript.Modifiers,v16719=v21419.Getter,v8813=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v16719]);if(v8813){var v16720=funcDecl.fncFlags,v21420=TypeScript.FncFlags,v16721=v21420.GetAccessor;funcDecl.fncFlags=v16720|v16721;var v16722=funcDecl.name,v8811=v16722.actualText;funcDecl.hint="get"+v8811}else{var v16723=
funcDecl.fncFlags,v21421=TypeScript.FncFlags,v16724=v21421.SetAccessor;funcDecl.fncFlags=v16723|v16724;var v16725=funcDecl.name,v8812=v16725.actualText;funcDecl.hint="set"+v8812}var v16726=funcDecl.fncFlags,v21422=TypeScript.FncFlags,v16727=v21422.IsFunctionExpression;funcDecl.fncFlags=v16726|v16727;var v21423=TypeScript.Modifiers,v16728=v21423.Ambient,v8814=modifiers&v16728;v8814&&JAMScript.call(this.reportParseError,this,["Property accessors may not be declared in ambient types"])}var v8815=null==
text;if(v8815)if(isNew){var v16729=funcDecl.fncFlags,v21424=TypeScript.FncFlags,v16730=v21424.ConstructMember;funcDecl.fncFlags=v16729|v16730;funcDecl.hint="_construct";funcDecl.classDecl=this.currentClassDecl}else{funcDecl.hint="_call";var v16731=funcDecl.fncFlags,v21425=TypeScript.FncFlags,v16732=v21425.CallMember;funcDecl.fncFlags=v16731|v16732}return funcDecl}var v8816=TypeScript.VarDecl,v8817=this.nestingLevel,varDecl=JAMScript.new(v8816,[text,v8817]),v8818=varDecl,v27232=JAMScript.call(this.parseComments,
this,[]);v8818.preComments=v27232;varDecl.minChar=minChar;var v21426=this.currentToken,v16733=v21426.tokenId,v21427=TypeScript.TokenID,v16734=v21427.Colon,v8824=v16733==v16734;if(v8824){var v8819=this.scanner,v27233=JAMScript.call(v8819.scan,v8819,[]);this.currentToken=v27233;var v8820=varDecl,v25291=TypeScript.ErrorRecoverySet,v24012=v25291.Asg,v21428=errorRecoverySet|v24012,v24013=TypeScript.ErrorRecoverySet,v21429=v24013.Comma,v16735=v21428|v21429,v27234=JAMScript.call(this.parseTypeReference,
this,[v16735,!1]);v8820.typeExpr=v27234;var v16736=varDecl.typeExpr;if(v16736)var v24014=varDecl.typeExpr,v21430=v24014.nodeType,v24015=TypeScript.NodeType,v21431=v24015.TypeRef,v16736=v21430==v21431;var v8823=v16736;if(v8823){var typeExpr=varDecl.typeExpr,v16737=typeExpr.term;if(v16737)var v24016=typeExpr.term,v21432=v24016.nodeType,v24017=TypeScript.NodeType,v21433=v24017.FuncDecl,v16737=v21432==v21433;var v8822=v16737;if(v8822){var v8821=typeExpr.term;v8821.preComments=varDecl.preComments}}}var v21434=
this.currentToken,v16738=v21434.tokenId,v21435=TypeScript.TokenID,v16739=v21435.Equals,v8833=v16738==v16739;if(v8833){if(requireSignature){JAMScript.call(this.reportParseError,this,["context does not permit variable initializer"]);var v8826=this.errorRecovery;if(v8826){JAMScript.call(this.skip,this,[errorRecoverySet]);var v16740=varDecl.flags,v21436=TypeScript.ASTFlags,v16741=v21436.Error;varDecl.flags=v16740|v16741;var v8825=varDecl,v16742=this.scanner,v27235=JAMScript.call(v16742.lastTokenLimChar,
v16742,[]);v8825.limChar=v27235;return varDecl}}var v8827=this.scanner,v27236=JAMScript.call(v8827.scan,v8827,[]);this.currentToken=v27236;var v8828=varDecl,v24018=TypeScript.ErrorRecoverySet,v21437=v24018.Comma,v16743=v21437|errorRecoverySet,v21438=TypeScript.OperatorPrecedence,v16744=v21438.Comma,v16745=TypeContext.NoTypes,v27237=JAMScript.call(this.parseExpr,this,[v16743,v16744,!0,v16745]);v8828.init=v27237;var v8829=varDecl.init;varDecl.limChar=v8829.limChar;var v21439=varDecl.init,v16746=v21439.nodeType,
v21440=TypeScript.NodeType,v16747=v21440.FuncDecl,v8831=v16746==v16747;if(v8831){funcDecl=varDecl.init;var v8830=varDecl.id;funcDecl.hint=v8830.text;funcDecl.boundToProperty=varDecl}else isAccessor&&JAMScript.call(this.reportParseError,this,["Accessors may only be functions"])}else{var v8832=this.scanner;varDecl.limChar=v8832.pos}var v24019=TypeScript.Modifiers,v21441=v24019.Readonly,v16748=modifiers&v21441,v21442=TypeScript.Modifiers,v16749=v21442.None,v8834=v16748!=v16749;if(v8834){var v16750=varDecl.varFlags,
v21443=TypeScript.VarFlags,v16751=v21443.Readonly;varDecl.varFlags=v16750|v16751}if(isStatic){var v16752=varDecl.varFlags,v21444=TypeScript.VarFlags,v16753=v21444.Static;varDecl.varFlags=v16752|v16753}var v24020=TypeScript.Modifiers,v21445=v24020.Public,v16754=modifiers&v21445,v21446=TypeScript.Modifiers,v16755=v21446.None,v8835=v16754!=v16755;if(v8835){var v16756=varDecl.varFlags,v21447=TypeScript.VarFlags,v16757=v21447.Public;varDecl.varFlags=v16756|v16757}var v24021=TypeScript.Modifiers,v21448=
v24021.Private,v16758=modifiers&v21448,v21449=TypeScript.Modifiers,v16759=v21449.None,v8836=v16758!=v16759;if(v8836){var v16760=varDecl.varFlags,v21450=TypeScript.VarFlags,v16761=v21450.Private;varDecl.varFlags=v16760|v16761}var v16762=varDecl.varFlags,v21451=TypeScript.VarFlags,v16763=v21451.Property;varDecl.varFlags=v16762|v16763;return varDecl}function v571(id,nest){var v8838=TypeScript.VarDecl,v8838=JAMScript.new(v8838,[id,nest]),currentVarList=JAMScript.call(this.topVarList,this,[]);currentVarList&&
JAMScript.call(currentVarList.append,currentVarList,[v8838]);return v8838}function v570(errorRecoverySet,modifiers){var v8839=this.scanner,leftCurlyCount=v8839.leftCurlyCount,v8839=this.scanner,v8839=v8839.rightCurlyCount,v8841=this.scanner;this.currentToken=v8841=JAMScript.call(v8841.scan,v8841,[]);var v8841=null,v24022=this.currentToken,v24022=v24022.tokenId,v24023=TypeScript.TokenID,v24023=v24023.Identifier,v24022=v24022==v24023;if(v24023=!v24022)if(v24022=this.currentToken,v24022=JAMScript.call(TypeScript.isPrimitiveTypeToken,
TypeScript,[v24022]),v24022=!v24022)v24022=this.currentToken,v24023=this.strictMode,v24022=JAMScript.call(TypeScript.convertTokToID,TypeScript,[v24022,v24023]);if(v24022)v8841=TypeScript.Identifier,v24022=this.currentToken,v8841=JAMScript.call(v8841.fromToken,v8841,[v24022]),v24022=this.scanner,v8841.minChar=v24022.startPos,v24022=this.scanner,v8841.limChar=v24022.pos,v24022=this.scanner,this.currentToken=v24022=JAMScript.call(v24022.scan,v24022,[]);else if(JAMScript.call(this.reportParseError,this,
["interface missing name"]),v24022=this.errorRecovery)v8841=TypeScript.MissingIdentifier,v8841=JAMScript.new(v8841,[]),v24022=this.scanner,v8841.minChar=v24022.pos,v24022=this.scanner,v8841.limChar=v24022.pos,v24022=v8841.flags,v24023=TypeScript.ASTFlags,v24023=v24023.Error,v8841.flags=v24022|v24023;var v24022=v24023=null,v24022=this.currentToken,v24022=v24022.tokenId,v24028=TypeScript.TokenID,v24028=v24028.Extends,v24022=v24022===v24028;if(v24028=!v24022)v24022=this.currentToken,v24022=v24022.tokenId,
v24028=TypeScript.TokenID,v24028=v24028.Implements,v24022=v24022===v24028;v24022&&(v24022=this.currentToken,v24022=v24022.tokenId,v24023=TypeScript.TokenID,v24023=v24023.Implements,(v24022=v24022===v24023)&&JAMScript.call(this.reportParseError,this,["Expected 'extends'"]),v24022=TypeScript.ASTList,v24023=JAMScript.new(v24022,[]),v24022=TypeScript.ASTList,v24022=JAMScript.new(v24022,[]),v24028=this.scanner,v24023.minChar=v24028.startPos,JAMScript.call(this.parseBaseList,this,[v24023,v24022,errorRecoverySet,
!1]));var v24022=this.scanner,v24028=v24022.startPos,v24022=TypeScript.TokenID,v24022=v24022.OpenBrace,v21464=TypeScript.ErrorRecoverySet,v21464=v21464.TypeScriptS,v21464=errorRecoverySet|v21464;JAMScript.call(this.checkCurrentToken,this,[v24022,v21464]);v24022=TypeScript.ASTList;v24022=JAMScript.new(v24022,[]);v24022.minChar=v24028;v24028=this.inInterfaceDecl;this.inInterfaceDecl=!0;v21464=TypeScript.ErrorRecoverySet;v21464=v21464.RCurly;v21464|=errorRecoverySet;JAMScript.call(this.parseTypeMemberList,
this,[v21464,v24022]);this.inInterfaceDecl=v24028;v24028=TypeScript.TokenID;v24028=v24028.CloseBrace;JAMScript.call(this.checkCurrentToken,this,[v24028,errorRecoverySet]);v24028=TypeScript.InterfaceDeclaration;v8841=JAMScript.new(v24028,[v8841,v24022,v24023,null]);v24023=TypeScript.Modifiers;v24023=v24023.Private;if(v24023=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v24023]))v24023=v8841.varFlags,v24028=TypeScript.VarFlags,v24028=v24028.Private,v8841.varFlags=v24023|v24028;v24023=TypeScript.Modifiers;
v24023=v24023.Public;if(v24023=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v24023]))v24023=v8841.varFlags,v24028=TypeScript.VarFlags,v24028=v24028.Public,v8841.varFlags=v24023|v24028;v24023=this.parsingDeclareFile;if(v24028=!v24023)if(v24023=this.ambientModule,v24028=!v24023)v24023=TypeScript.Modifiers,v24023=v24023.Exported,v24023=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v24023]);v24023&&(v24023=v8841.varFlags,v24028=TypeScript.VarFlags,v24028=v24028.Exported,v8841.varFlags=
v24023|v24028);v8841.limChar=v24022.limChar;v24022=this.scanner;v24022=v24022.leftCurlyCount;v8841.leftCurlyCount=v24022-leftCurlyCount;leftCurlyCount=this.scanner;leftCurlyCount=leftCurlyCount.rightCurlyCount;v8841.rightCurlyCount=leftCurlyCount-v8839;return v8841}function v569(errorRecoverySet,members){var v21473=TypeScript.ErrorRecoverySet,v21473=v21473.TypeScriptS;for(errorRecoverySet|=v21473;;){v21473=this.currentToken;v21473=v21473.tokenId;switch(v21473){case TypeScript.TokenID.CloseBrace:case TypeScript.TokenID.EndOfFile:v21473=
this.scanner;members.limChar=v21473.pos;return}(v21473=JAMScript.call(this.parseTypeMember,this,[errorRecoverySet]))&&JAMScript.call(members.append,members,[v21473])}}function v568(errorRecoverySet){var v8872=this.scanner,minChar=v8872.startPos,v8872=TypeScript.Modifiers,v8872=v8872.Public;if(v8872=JAMScript.call(this.parsePropertyDeclaration,this,[errorRecoverySet,v8872,!0,!1])){v8872.minChar=minChar;var minChar=v8872.nodeType,v21474=TypeScript.NodeType,v21474=v21474.VarDecl;if(minChar=minChar==
v21474)minChar=TypeScript.TokenID,minChar=minChar.Semicolon,JAMScript.call(this.checkCurrentToken,this,[minChar,errorRecoverySet])}return v8872}function v567(methodName,minChar,errorRecoverySet,modifiers){var v21475=TypeScript.Modifiers,v21475=v21475.Getter,v21475=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v21475]),v16793=!v21475;v16793&&(v21475=TypeScript.Modifiers,v21475=v21475.Setter,v21475=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v21475]));var v16793=TypeScript.Modifiers,
v16793=v16793.Static,v16793=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v16793]),v8879=this.ambientModule,v16796=!v8879;v16796&&(v8879=TypeScript.Modifiers,v8879=v8879.Ambient,v8879=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v8879]));v16796=TypeScript.ErrorRecoverySet;v16796=v16796.RParen;errorRecoverySet|=v16796;if(v16796=v21475)v16796=TypeScript.Modifiers,v16796=v16796.Ambient,v16796&=modifiers;v16796&&JAMScript.call(this.reportParseError,this,["Property accessors may not be declared in ambient classes"]);
errorRecoverySet=JAMScript.call(this.parseFncDecl,this,[errorRecoverySet,!0,v8879,!0,methodName,!1,v16793,v8879,modifiers,null,!0]);v8879=errorRecoverySet.nodeType;v16796=TypeScript.NodeType;v16796=v16796.Error;if(v8879=v8879==v16796)return errorRecoverySet;errorRecoverySet.minChar=minChar;minChar=errorRecoverySet.bod;if(minChar=null!==minChar)minChar=errorRecoverySet.bod,errorRecoverySet.limChar=minChar.limChar;minChar=TypeScript.Modifiers;minChar=minChar.Private;(minChar&=modifiers)?(minChar=errorRecoverySet.fncFlags,
v8879=TypeScript.FncFlags,v8879=v8879.Private):(minChar=errorRecoverySet.fncFlags,v8879=TypeScript.FncFlags,v8879=v8879.Public);errorRecoverySet.fncFlags=minChar|v8879;v16793&&(v16793=errorRecoverySet.fncFlags,minChar=TypeScript.FncFlags,minChar=minChar.Static,errorRecoverySet.fncFlags=v16793|minChar);v21475&&(v21475=TypeScript.Modifiers,v21475=v21475.Getter,(modifiers=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v21475]))?(modifiers=errorRecoverySet.fncFlags,v21475=TypeScript.FncFlags,
v21475=v21475.GetAccessor,errorRecoverySet.fncFlags=modifiers|v21475,modifiers=errorRecoverySet.name,modifiers=modifiers.actualText,errorRecoverySet.hint="get"+modifiers):(modifiers=errorRecoverySet.fncFlags,v21475=TypeScript.FncFlags,v21475=v21475.SetAccessor,errorRecoverySet.fncFlags=modifiers|v21475,modifiers=errorRecoverySet.name,modifiers=modifiers.actualText,errorRecoverySet.hint="set"+modifiers),modifiers=errorRecoverySet.fncFlags,v21475=TypeScript.FncFlags,v21475=v21475.IsFunctionExpression,
errorRecoverySet.fncFlags=modifiers|v21475,modifiers=TypeScript.codeGenTarget,v21475=TypeScript.CodeGenTarget,v21475=v21475.ES5,modifiers=modifiers<v21475)&&(modifiers=errorRecoverySet.minChar,v21475=errorRecoverySet.limChar,JAMScript.call(this.reportParseError,this,["Property accessors are only available when targeting ES5 or greater",modifiers,v21475]));modifiers=errorRecoverySet.fncFlags;v21475=TypeScript.FncFlags;v21475=v21475.ClassMethod;errorRecoverySet.fncFlags=modifiers|v21475;modifiers=this.currentClassDefinition;
modifiers=modifiers.knownMemberNames;methodName=methodName.actualText;JAMScript.set(modifiers,methodName,!0);methodName=this.currentClassDefinition;methodName=methodName.members;methodName=methodName.members;modifiers=this.currentClassDefinition;modifiers=modifiers.members;modifiers=modifiers.members;modifiers=modifiers.length;JAMScript.set(methodName,modifiers,errorRecoverySet);return errorRecoverySet}function v566(text,minChar,isDeclaredInConstructor,errorRecoverySet,modifiers){var v8895=TypeScript.VarDecl,
v8896=this.nestingLevel,varDecl=JAMScript.new(v8895,[text,v8896]);varDecl.minChar=minChar;var isStatic=!1,v8897=varDecl,v27240=JAMScript.call(this.parseComments,this,[]);v8897.preComments=v27240;var v21493=this.currentToken,v16825=v21493.tokenId,v21494=TypeScript.TokenID,v16826=v21494.Colon,v8903=v16825==v16826;if(v8903){var v8898=this.scanner,v27241=JAMScript.call(v8898.scan,v8898,[]);this.currentToken=v27241;var v8899=varDecl,v25294=TypeScript.ErrorRecoverySet,v24035=v25294.Asg,v21495=errorRecoverySet|
v24035,v24036=TypeScript.ErrorRecoverySet,v21496=v24036.Comma,v16827=v21495|v21496,v27242=JAMScript.call(this.parseTypeReference,this,[v16827,!1]);v8899.typeExpr=v27242;var v16828=varDecl.typeExpr;if(v16828)var v24037=varDecl.typeExpr,v21497=v24037.nodeType,v24038=TypeScript.NodeType,v21498=v24038.TypeRef,v16828=v21497==v21498;var v8902=v16828;if(v8902){var typeExpr=varDecl.typeExpr,v16829=typeExpr.term;if(v16829)var v24039=typeExpr.term,v21499=v24039.nodeType,v24040=TypeScript.NodeType,v21500=v24040.FuncDecl,
v16829=v21499==v21500;var v8901=v16829;if(v8901){var v8900=typeExpr.term;v8900.preComments=varDecl.preComments}}}var v21501=this.currentToken,v16830=v21501.tokenId,v21502=TypeScript.TokenID,v16831=v21502.Equals,v8913=v16830==v16831;if(v8913){var v16832=this.parsingDeclareFile,v21504=!v16832;if(v21504)var v24041=TypeScript.Modifiers,v21503=v24041.Ambient,v16832=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v21503]);var v8906=v16832;if(v8906){JAMScript.call(this.reportParseError,this,["context does not permit variable initializer"]);
var v8905=this.errorRecovery;if(v8905){JAMScript.call(this.skip,this,[errorRecoverySet]);var v16833=varDecl.flags,v21505=TypeScript.ASTFlags,v16834=v21505.Error;varDecl.flags=v16833|v16834;var v8904=varDecl,v16835=this.scanner,v27243=JAMScript.call(v16835.lastTokenLimChar,v16835,[]);v8904.limChar=v27243;return varDecl}}var v8907=this.scanner,v27244=JAMScript.call(v8907.scan,v8907,[]);this.currentToken=v27244;var v8908=varDecl,v24042=TypeScript.ErrorRecoverySet,v21506=v24042.Comma,v16836=v21506|errorRecoverySet,
v21507=TypeScript.OperatorPrecedence,v16837=v21507.Comma,v16838=TypeContext.NoTypes,v27245=JAMScript.call(this.parseExpr,this,[v16836,v16837,!0,v16838]);v8908.init=v27245;var v8909=varDecl.init;varDecl.limChar=v8909.limChar;var v24043=TypeScript.Modifiers,v21508=v24043.Static,v16839=modifiers&v21508,v8911=!v16839;if(v8911){var v8910=this.currentClassDefinition,v21509=v8910.varFlags,v24044=TypeScript.VarFlags,v21510=v24044.ClassSuperMustBeFirstCallInConstructor;v8910.varFlags=v21509|v21510}}else{var v8912=
this.scanner;varDecl.limChar=v8912.pos}var v21511=TypeScript.Modifiers,v16840=v21511.Static,v8914=modifiers&v16840;if(v8914){var v16841=varDecl.varFlags,v21512=TypeScript.VarFlags,v16842=v21512.Static;varDecl.varFlags=v16841|v16842;isStatic=!0}var v24045=TypeScript.Modifiers,v21513=v24045.Private,v16843=modifiers&v21513,v21514=TypeScript.Modifiers,v16844=v21514.None,v8915=v16843!=v16844;if(v8915){var v16845=varDecl.varFlags,v21515=TypeScript.VarFlags,v16846=v21515.Private;varDecl.varFlags=v16845|
v16846}else{var v16847=varDecl.varFlags,v21516=TypeScript.VarFlags,v16848=v21516.Public;varDecl.varFlags=v16847|v16848}var v16849=varDecl.varFlags,v21517=TypeScript.VarFlags,v16850=v21517.Property;varDecl.varFlags=v16849|v16850;if(isDeclaredInConstructor){var v16851=varDecl.varFlags,v21518=TypeScript.VarFlags,v16852=v21518.ClassConstructorProperty;varDecl.varFlags=v16851|v16852}var v16853=!isDeclaredInConstructor;v16853&&(v16853=!isStatic);var v8916=v16853;if(v8916){var v16854=varDecl.varFlags,v21519=
TypeScript.VarFlags,v16855=v21519.ClassBodyProperty;varDecl.varFlags=v16854|v16855}var v16856=this.currentClassDefinition,v8917=v16856.knownMemberNames,v8918=text.actualText;JAMScript.set(v8917,v8918,!0);var v8921=!isDeclaredInConstructor;if(v8921){var v21520=this.currentClassDefinition,v16857=v21520.members,v8919=v16857.members,v24046=this.currentClassDefinition,v21521=v24046.members,v16858=v21521.members,v8920=v16858.length;JAMScript.set(v8919,v8920,varDecl)}var v8922=varDecl,v27246=JAMScript.call(this.parseComments,
this,[]);v8922.postComments=v27246;return varDecl}function v565(minChar,errorRecoverySet,modifiers){this.parsingClassConstructorDefinition=!0;var v8923=this.parsingDeclareFile,v16860=!v8923;v16860&&(v8923=TypeScript.Modifiers,v8923=v8923.Ambient,v8923=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v8923]));var v16860=TypeScript.ASTList,args=JAMScript.new(v16860,[]),v16860=!1,preComments=JAMScript.call(this.parseComments,this,[]),v8925=this.scanner,v8925=this.currentToken=v8925=JAMScript.call(v8925.scan,
v8925,[]),v8925=v8925.tokenId,v21524=TypeScript.TokenID,v21524=v21524.OpenParen;(v8925=v8925==v21524)&&(v16860=JAMScript.call(this.parseFormalParameterList,this,[errorRecoverySet,args,!0,v8923,!1,!1,!1,!1,null,!0]));v8925=v8923;if(v21524=!v8925)v8925=this.currentToken,v8925=v8925.tokenId,v21524=TypeScript.TokenID,v21524=v21524.Semicolon,v8925=v8925==v21524;if(v8925)for(var v21524=0,v21529=args.members,v21529=v21529.length,v21529=v21524<v21529;v21529;){v21529=args.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v21529=
v21529[v21524];var v16869=v21529.varFlags,v21530=TypeScript.VarFlags,v21530=v21530.Property;if(v16869=JAMScript.call(TypeScript.hasFlag,TypeScript,[v16869,v21530]))v16869=v21529.minChar,v21529=v21529.limChar,JAMScript.call(this.reportParseError,this,["Overload or ambient signatures may not specify parameter properties",v16869,v21529]);v21524+=1;v21529=args.members;v21529=v21529.length;v21529=v21524<v21529}if(v21524=!v8925)v21524=this.currentClassDefinition,v21529=this.nestingLevel,v21524.constructorNestingLevel=
v21529+1;v21524=TypeScript.ErrorRecoverySet;v21524=v21524.RCurly;errorRecoverySet|=v21524;v21524=this.currentClassDefinition;v21524=v21524.name;v21529=TypeScript.AllowedElements;v21529=v21529.Properties;minChar=JAMScript.call(this.parseFunctionStatements,this,[errorRecoverySet,v21524,!0,!1,args,v21529,minChar,v8925,modifiers]);minChar.preComments=preComments;(preComments=v8925)&&(preComments=!v8923);preComments&&(minChar.isOverload=!0);minChar.variableArgList=v16860;this.currentClassDecl=null;v16860=
minChar;preComments=this.currentClassDefinition;preComments=preComments.name;preComments=JAMScript.call(this.convertToTypeReference,this,[preComments]);v16860.returnTypeAnnotation=preComments;minChar.classDecl=this.currentClassDefinition;v8923&&(v16860=minChar.fncFlags,preComments=TypeScript.FncFlags,preComments=preComments.Ambient,minChar.fncFlags=v16860|preComments);v8925&&(v16860=minChar.fncFlags,preComments=TypeScript.FncFlags,preComments=preComments.Signature,minChar.fncFlags=v16860|preComments);
v16860=this.ambientModule;if(preComments=!v16860)v16860=TypeScript.Modifiers,v16860=v16860.Exported,v16860=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v16860]);if(modifiers=v16860)modifiers=minChar.fncFlags,v16860=TypeScript.FncFlags,v16860=v16860.Exported,minChar.fncFlags=modifiers|v16860;modifiers=this.currentClassDefinition;if(modifiers=modifiers.constructorDecl){if(modifiers=!v8923)if(modifiers=this.currentClassDefinition,modifiers=modifiers.constructorDecl,modifiers=JAMScript.call(modifiers.isSignature,
modifiers,[]),modifiers=!modifiers)modifiers=JAMScript.call(minChar.isSignature,minChar,[]),modifiers=!modifiers;modifiers&&JAMScript.call(this.reportParseError,this,["Duplicate constructor definition"])}if(modifiers=!v8923)v8923=JAMScript.call(minChar.isSignature,minChar,[]),v8923=!v8923;v8923&&(v8923=this.currentClassDefinition,v8923.constructorDecl=minChar);v8923=minChar.fncFlags;modifiers=TypeScript.FncFlags;modifiers=modifiers.ClassMethod;minChar.fncFlags=v8923|modifiers;v8923=this.currentClassDefinition;
v8923=v8923.members;v8923=v8923.members;modifiers=this.currentClassDefinition;modifiers=modifiers.members;modifiers=modifiers.members;modifiers=modifiers.length;JAMScript.set(v8923,modifiers,minChar);this.parsingClassConstructorDefinition=!1;return minChar}function v564(classDecl,errorRecoverySet,parentModifiers){var modifiers=parentModifiers,resetModifiers=!1,v8950=this.scanner,membersMinChar=v8950.startPos,v16892=TypeScript.TokenID,v8951=v16892.OpenBrace;JAMScript.call(this.checkCurrentToken,this,
[v8951,errorRecoverySet]);var v16893=this.nestingLevel;this.nestingLevel=v16893+1;var v8952=this.scanner,currentMemberMinChar=v8952.startPos,wasGetOrSetId=!1,v25296=this.currentToken,v24051=v25296.tokenId,v25297=TypeScript.TokenID,v24052=v25297.CloseBrace,v21545=v24051==v24052,v24055=!v21545;if(v24055)var v25298=this.currentToken,v24053=v25298.tokenId,v25299=TypeScript.TokenID,v24054=v25299.EndOfFile,v21545=v24053==v24054;for(var v16894=v21545,v8991=!v16894;v8991;){var scanNext=!0,v16895=TypeScript.Modifiers,
v8953=v16895.Public,v16896=TypeScript.Modifiers,v8954=v16896.Private,publicOrPrivateFlags=v8953|v8954,v21546=this.currentToken,v16897=v21546.tokenId,v21547=TypeScript.TokenID,v16898=v21547.Get,v8986=v16897==v16898;if(v8986){var v21548=TypeScript.Modifiers,v16899=v21548.Getter,v8955=modifiers&v16899;v8955&&JAMScript.call(this.reportParseError,this,["Duplicate 'get' declaration in class body"]);var v21549=TypeScript.Modifiers,v16900=v21549.Setter,v8956=modifiers&v16900;v8956&&JAMScript.call(this.reportParseError,
this,["Getter already marked as a setter"]);var v21550=TypeScript.Modifiers,v16901=v21550.Getter,modifiers=modifiers|v16901}else{var v21551=this.currentToken,v16902=v21551.tokenId,v21552=TypeScript.TokenID,v16903=v21552.Set,v8985=v16902==v16903;if(v8985){var v21553=TypeScript.Modifiers,v16904=v21553.Setter,v8957=modifiers&v16904;v8957&&JAMScript.call(this.reportParseError,this,["Duplicate 'set' declaration in class body"]);var v21554=TypeScript.Modifiers,v16905=v21554.Getter,v8958=modifiers&v16905;
v8958&&JAMScript.call(this.reportParseError,this,["Setter already marked as a getter"]);var v21555=TypeScript.Modifiers,v16906=v21555.Setter,modifiers=modifiers|v16906}else{var v21556=this.currentToken,v16907=v21556.tokenId,v21557=TypeScript.TokenID,v16908=v21557.Private,v8984=v16907==v16908;if(v8984){var v8959=modifiers&publicOrPrivateFlags;v8959&&JAMScript.call(this.reportParseError,this,["Multiple modifiers may not be applied to class members"]);var v21558=TypeScript.Modifiers,v16909=v21558.Private,
modifiers=modifiers|v16909}else{var v21559=this.currentToken,v16910=v21559.tokenId,v21560=TypeScript.TokenID,v16911=v21560.Public,v8983=v16910==v16911;if(v8983){var v8960=modifiers&publicOrPrivateFlags;v8960&&JAMScript.call(this.reportParseError,this,["Multiple modifiers may not be applied to class members"]);var v21561=TypeScript.Modifiers,v16912=v21561.Public,modifiers=modifiers|v16912}else{var v21562=this.currentToken,v16913=v21562.tokenId,v21563=TypeScript.TokenID,v16914=v21563.Static,v8982=v16913==
v16914;if(v8982){var v21564=TypeScript.Modifiers,v16915=v21564.Static,v8961=modifiers&v16915;v8961&&JAMScript.call(this.reportParseError,this,["Multiple modifiers may not be applied to class members"]);var v21565=TypeScript.Modifiers,v16916=v21565.Static,modifiers=modifiers|v16916}else{var v21566=this.currentToken,v16917=v21566.tokenId,v21567=TypeScript.TokenID,v16918=v21567.Constructor,v8981=v16917==v16918;if(v8981){var v8962=modifiers!=parentModifiers;v8962&&JAMScript.call(this.reportParseError,
this,["Constructors may not have modifiers"]);JAMScript.call(this.parseClassConstructorDeclaration,this,[currentMemberMinChar,errorRecoverySet,modifiers]);scanNext=!1;resetModifiers=!0}else{var v16919=wasGetOrSetId,v21569=!v16919;if(v21569){var v25300=this.currentToken,v24056=v25300.tokenId,v25301=TypeScript.TokenID,v24057=v25301.Identifier,v21568=v24056==v24057,v24059=!v21568;if(v24059)var v24058=this.currentToken,v21568=JAMScript.call(TypeScript.convertTokToIDName,TypeScript,[v24058]);v16919=v21568}var v8980=
v16919;if(v8980){var v8963;if(wasGetOrSetId){var v16920,v25302=TypeScript.Modifiers,v24060=v25302.Getter,v21570=modifiers&v24060;v8963=v16920=v21570?"get":"set"}else{var v16921=this.currentToken;v8963=JAMScript.call(v16921.getText,v16921,[])}var idText=v8963,v8964;if(wasGetOrSetId){var v16922=TypeScript.Identifier;v8964=JAMScript.new(v16922,[idText])}else{var v16923=TypeScript.Identifier,v16924=this.currentToken;v8964=JAMScript.call(v16923.fromToken,v16923,[v16924])}var id=v8964,v8965=this.scanner;
id.minChar=v8965.startPos;var v8966=this.scanner;id.limChar=v8966.pos;if(wasGetOrSetId){var v16925,v25303=TypeScript.Modifiers,v24061=v25303.Getter,v21573=modifiers&v24061;if(v21573){var v21571=TypeScript.Modifiers;v16925=v21571.Getter}else{var v21572=TypeScript.Modifiers;v16925=v21572.Setter}var v8967=v16925,modifiers=modifiers^v8967,wasGetOrSetId=!1}else{var v8968=this.scanner,v27249=JAMScript.call(v8968.scan,v8968,[]);this.currentToken=v27249}var v21574=this.currentToken,v16926=v21574.tokenId,
v21575=TypeScript.TokenID,v16927=v21575.OpenParen,v8975=v16926==v16927;if(v8975)JAMScript.call(this.parseClassMemberFunctionDeclaration,this,[id,currentMemberMinChar,errorRecoverySet,modifiers]),scanNext=!1;else{var v24062=TypeScript.Modifiers,v21576=v24062.Getter,v16928=modifiers&v21576,v21578=!v16928;if(v21578)var v24063=TypeScript.Modifiers,v21577=v24063.Setter,v16928=modifiers&v21577;var v8969=v16928;v8969&&JAMScript.call(this.reportParseError,this,["Property accessors must be functions"]);var varDecl=
JAMScript.call(this.parseClassMemberVariableDeclaration,this,[id,currentMemberMinChar,!1,errorRecoverySet,modifiers]),v16929=varDecl.init;if(v16929)var v24064=varDecl.init,v21579=v24064.nodeType,v24065=TypeScript.NodeType,v21580=v24065.FuncDecl,v16929=v21579==v21580;var v8974=v16929;if(v8974){var v21581=this.currentToken,v16930=v21581.tokenId,v21582=TypeScript.TokenID,v16931=v21582.CloseBrace,v8970=v16930==v16931;v8970&&(scanNext=!1)}else{var v16932=varDecl.init;if(v16932){var v25304=varDecl.init,
v24066=v25304.nodeType,v25305=TypeScript.NodeType,v24067=v25305.ObjectLit,v21583=v24066==v24067;if(v21583)var v25306=this.currentToken,v24068=v25306.tokenId,v25307=TypeScript.TokenID,v24069=v25307.Semicolon,v21583=v24068!=v24069;v16932=v21583}var v8973=v16932;if(v8973){var scanNext=!1,v8971=varDecl.init,v21584=v8971.flags,v24070=TypeScript.ASTFlags,v21585=v24070.AutomaticSemicolon;v8971.flags=v21584|v21585}else{var v21586=this.currentToken,v16933=v21586.tokenId,v21587=TypeScript.TokenID,v16934=v21587.Semicolon,
v8972=v16933!=v16934;v8972&&(JAMScript.call(this.reportParseError,this,["Expected ';'"]),scanNext=!1)}}}resetModifiers=!0}else{var v21588=this.currentToken,v16935=v21588.tokenId,v21589=TypeScript.TokenID,v16936=v21589.Super,v8979=v16935==v16936;if(v8979)JAMScript.call(this.reportParseError,this,["Base class initializers must be the first statement in a class definition"]);else{var v16937=!wasGetOrSetId;if(v16937){var v26004=TypeScript.Modifiers,v25308=v26004.Getter,v24071=modifiers&v25308,v25310=
!v24071;if(v25310)var v26005=TypeScript.Modifiers,v25309=v26005.Setter,v24071=modifiers&v25309;var v21590=v24071;if(v21590){var v26006=this.currentToken,v25311=v26006.tokenId,v26007=TypeScript.TokenID,v25312=v26007.OpenParen,v24072=v25311==v25312,v25314=!v24072;if(v25314){var v26401=this.currentToken,v26008=v26401.tokenId,v26402=TypeScript.TokenID,v26009=v26402.Equals,v25313=v26008==v26009,v26011=!v25313;if(v26011){var v26566=this.currentToken,v26403=v26566.tokenId,v26567=TypeScript.TokenID,v26404=
v26567.Colon,v26010=v26403==v26404,v26407=!v26010;if(v26407)var v26568=this.currentToken,v26405=v26568.tokenId,v26569=TypeScript.TokenID,v26406=v26569.Semicolon,v26010=v26405==v26406;v25313=v26010}v24072=v25313}v21590=v24072}v16937=v21590}var v8978=v16937;if(v8978)wasGetOrSetId=!0,scanNext=!1;else{var v21591=this.currentToken,v16938=v21591.tokenId,v21592=TypeScript.TokenID,v16939=v21592.Semicolon,v8977=v16938!=v16939;if(v8977){var v24073=this.currentToken,v21593=JAMScript.call(v24073.getText,v24073,
[]),v16940="Unexpected '"+v21593,v8976=v16940+"' in class definition";JAMScript.call(this.reportParseError,this,[v8976]);resetModifiers=!0}}}}}}}}}}if(scanNext){var v8987=this.scanner,v27250=JAMScript.call(v8987.scan,v8987,[]),v16941=this.currentToken=v27250,v8989=void 0===v16941;if(v8989){var v8988=this.scanner,v27251=JAMScript.call(v8988.scan,v8988,[]);this.currentToken=v27251}}if(resetModifiers)var modifiers=parentModifiers,v8990=this.scanner,currentMemberMinChar=v8990.startPos,resetModifiers=
!1;var v25315=this.currentToken,v24074=v25315.tokenId,v25316=TypeScript.TokenID,v24075=v25316.CloseBrace,v21594=v24074==v24075,v24078=!v21594;if(v24078)var v25317=this.currentToken,v24076=v25317.tokenId,v25318=TypeScript.TokenID,v24077=v25318.EndOfFile,v21594=v24076==v24077;var v16942=v21594,v8991=!v16942}var v8992=this.scanner,membersLimChar=v8992.pos,v21595=this.currentToken,v16943=v21595.tokenId,v21596=TypeScript.TokenID,v16944=v21596.CloseBrace,v8999=v16943==v16944;if(v8999){var v8993=classDecl,
v16945=TypeScript.ASTSpan,v27252=JAMScript.new(v16945,[]);v8993.endingToken=v27252;var v8994=classDecl.endingToken,v16946=this.scanner;v8994.minChar=v16946.startPos;var v8995=classDecl.endingToken,v16947=this.scanner;v8995.limChar=v16947.pos;var v25319=this.currentClassDefinition,v24079=v25319.members,v21597=v24079.members,v16948=v21597.length,v8997=!v16948;if(v8997){var v8996=this.currentClassDefinition,v27253=JAMScript.call(this.parseComments,this,[]);v8996.preComments=v27253}var v8998=this.scanner,
v27254=JAMScript.call(v8998.scan,v8998,[]);this.currentToken=v27254}var v16949=this.nestingLevel;this.nestingLevel=v16949-1;var v16950=this.currentClassDefinition,v9000=v16950.members;v9000.minChar=membersMinChar;var v16951=this.currentClassDefinition,v9001=v16951.members;v9001.limChar=membersLimChar;var v9002=this.currentClassDefinition;v9002.limChar=membersLimChar;this.currentClassDefinition=null}function v563(errorRecoverySet,minChar,modifiers){var v9003=this.scanner,leftCurlyCount=v9003.leftCurlyCount,
v9004=this.scanner,rightCurlyCount=v9004.rightCurlyCount,v24080=TypeScript.Modifiers,v21598=v24080.Readonly,v16952=modifiers&v21598,v21599=TypeScript.Modifiers,v16953=v21599.None,v9005=v16952!=v16953;v9005&&JAMScript.call(this.reportParseError,this,["const modifier is implicit for class"]);var v16954=this.parsingDeclareFile,v21600=!v16954;v21600&&(v16954=this.ambientModule);var v9006=v16954;if(v9006){var v21601=TypeScript.Modifiers,v16955=v21601.Ambient;modifiers|=v16955;var v21602=TypeScript.Modifiers,
v16956=v21602.Exported;modifiers|=v16956}var v9007=this.parsingDeclareFile,v16959=!v9007;if(v16959)var v24081=TypeScript.Modifiers,v21603=v24081.Ambient,v16957=modifiers&v21603,v21604=TypeScript.Modifiers,v16958=v21604.None,v9007=v16957!=v16958;var classIsMarkedAsAmbient=v9007,svAmbientClass=this.ambientClass;this.ambientClass=classIsMarkedAsAmbient;var v9008=this.scanner,v27255=JAMScript.call(v9008.scan,v9008,[]);this.currentToken=v27255;var name=null,v24082=this.currentToken,v21605=v24082.tokenId,
v24083=TypeScript.TokenID,v21606=v24083.Identifier,v16960=v21605==v21606,v21608=!v16960;if(v21608){var v25320=this.currentToken,v24084=JAMScript.call(TypeScript.isPrimitiveTypeToken,TypeScript,[v25320]),v21607=!v24084;if(v21607)var v24085=this.currentToken,v24086=this.strictMode,v21607=JAMScript.call(TypeScript.convertTokToID,TypeScript,[v24085,v24086]);v16960=v21607}var v9018=v16960;if(v9018){var v9009=TypeScript.Identifier,v9010=this.currentToken,name=JAMScript.call(v9009.fromToken,v9009,[v9010]),
v9011=this.scanner;name.minChar=v9011.startPos;var v9012=this.scanner;name.limChar=v9012.pos;var v9013=this.scanner,v27256=JAMScript.call(v9013.scan,v9013,[]);this.currentToken=v27256}else{JAMScript.call(this.reportParseError,this,["class missing name"]);var v9017=this.errorRecovery;if(v9017){var v9014=TypeScript.MissingIdentifier,name=JAMScript.new(v9014,[]),v9015=this.scanner;name.minChar=v9015.pos;var v9016=this.scanner;name.limChar=v9016.pos;var v16961=name.flags,v21609=TypeScript.ASTFlags,v16962=
v21609.Error;name.flags=v16961|v16962}}var extendsList=null,implementsList=null,v24087=this.currentToken,v21610=v24087.tokenId,v24088=TypeScript.TokenID,v21611=v24088.Extends,v16963=v21610==v21611,v21614=!v16963;if(v21614)var v24089=this.currentToken,v21612=v24089.tokenId,v24090=TypeScript.TokenID,v21613=v24090.Implements,v16963=v21612==v21613;var v9021=v16963;if(v9021){var v9019=TypeScript.ASTList,extendsList=JAMScript.new(v9019,[]),v9020=TypeScript.ASTList,implementsList=JAMScript.new(v9020,[]);
JAMScript.call(this.parseBaseList,this,[extendsList,implementsList,errorRecoverySet,!0])}var v9022=TypeScript.ClassDeclaration,v16964=TypeScript.ASTList,v9023=JAMScript.new(v16964,[]),classDecl=JAMScript.new(v9022,[name,v9023,extendsList,implementsList]);this.currentClassDefinition=classDecl;JAMScript.call(this.parseClassElements,this,[classDecl,errorRecoverySet,modifiers]);var v16965=this.ambientModule,v21616=!v16965;if(v21616){var v21615=this.parsingDeclareFile,v24092=!v21615;if(v24092)var v25321=
TypeScript.Modifiers,v24091=v25321.Exported,v21615=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v24091]);v16965=v21615}var v9024=v16965;if(v9024){var v16966=classDecl.varFlags,v21617=TypeScript.VarFlags,v16967=v21617.Exported;classDecl.varFlags=v16966|v16967}var v16968=this.ambientModule,v21619=!v16968;if(v21619)var v24093=TypeScript.Modifiers,v21618=v24093.Ambient,v16968=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v21618]);var v9025=v16968;if(v9025){var v16969=classDecl.varFlags,
v21620=TypeScript.VarFlags,v16970=v21620.Ambient;classDecl.varFlags=v16969|v16970}var v16971=classDecl.varFlags,v21621=TypeScript.VarFlags,v16972=v21621.Class;classDecl.varFlags=v16971|v16972;this.ambientClass=svAmbientClass;var v16973=this.scanner,v9026=v16973.leftCurlyCount;classDecl.leftCurlyCount=v9026-leftCurlyCount;var v16974=this.scanner,v9027=v16974.rightCurlyCount;classDecl.rightCurlyCount=v9027-rightCurlyCount;return classDecl}function v562(extendsList,implementsList,errorRecoverySet,isClass){for(var keyword=
!0,currentList=extendsList;;){if(keyword){var keyword=this.currentToken,keyword=keyword.tokenId,v21623=TypeScript.TokenID,v21623=v21623.Implements;if(keyword=keyword===v21623)currentList=implementsList;else{keyword=this.currentToken;keyword=keyword.tokenId;v21623=TypeScript.TokenID;v21623=v21623.Extends;if(keyword=keyword==v21623)keyword=this.requiresExtendsBlock,keyword=!keyword;keyword&&(this.requiresExtendsBlock=isClass)}keyword=this.scanner;this.currentToken=keyword=JAMScript.call(keyword.scan,
keyword,[]);keyword=!1}var v21623=null,v24096=this.currentToken,v24096=v24096.tokenId,v24097=TypeScript.TokenID,v24097=v24097.Identifier,v24096=v24096==v24097;if(v24097=!v24096)v24096=this.currentToken,v24097=this.strictMode,v24096=JAMScript.call(TypeScript.convertTokToID,TypeScript,[v24096,v24097]);if(v24096)v21623=this.scanner,v24096=v21623.startPos,v21623=TypeScript.Identifier,v24097=this.currentToken,v21623=JAMScript.call(v21623.fromToken,v21623,[v24097]),v21623.minChar=v24096,v24097=this.scanner,
v21623.limChar=v24097.pos,v24097=TypeScript.ErrorRecoverySet,v24097=v24097.LCurly,v24097|=errorRecoverySet,v21623=JAMScript.call(this.parseNamedType,this,[v24097,v24096,v21623,!1]);else if(JAMScript.call(this.reportParseError,this,["Expected base name"]),v24096=this.errorRecovery)v21623=TypeScript.MissingIdentifier,v21623=JAMScript.new(v21623,[]),v24096=this.scanner,v21623.minChar=v24096.pos,v24096=this.scanner,v21623.limChar=v24096.pos,v24096=v21623.flags,v24097=TypeScript.ASTFlags,v24097=v24097.Error,
v21623.flags=v24096|v24097;v24096=this.currentToken;v24096=v24096.tokenId;v24097=TypeScript.TokenID;v24097=v24097.OpenParen;(v24096=v24096==v24097)?isClass?JAMScript.call(this.reportParseError,this,["Base classes may only be initialized via a 'super' call within the constructor body"]):JAMScript.call(this.reportParseError,this,["Interfaces may not be extended with a call expression"]):JAMScript.call(currentList.append,currentList,[v21623]);if(v21623=isClass)if(v21623=currentList==extendsList)v21623=
extendsList.members,v21623=v21623.length,v21623=1<v21623;v21623&&JAMScript.call(this.reportParseError,this,["A class may only extend one other class"]);v21623=this.currentToken;v21623=v21623.tokenId;v24096=TypeScript.TokenID;v24096=v24096.Comma;if(v21623=v21623==v24096)v21623=this.scanner,this.currentToken=v21623=JAMScript.call(v21623.scan,v21623,[]);else{currentList=this.currentToken;currentList=currentList.tokenId;keyword=TypeScript.TokenID;keyword=keyword.Extends;currentList=currentList==keyword;
if(keyword=!currentList)currentList=this.currentToken,currentList=currentList.tokenId,keyword=TypeScript.TokenID,keyword=keyword.Implements,currentList=currentList==keyword;if(currentList){currentList=this.currentToken;currentList=currentList.tokenId;keyword=TypeScript.TokenID;keyword=keyword.Extends;if(currentList=currentList==keyword)currentList=this.requiresExtendsBlock,currentList=!currentList;currentList&&(this.requiresExtendsBlock=isClass);currentList=extendsList;keyword=!0}else break}}}function v561(errorRecoverySet){var v9047=
TypeScript.ASTList,v9047=JAMScript.new(v9047,[]),v9048=this.scanner;v9047.minChar=v9048.startPos;var v9048=this.scanner,v9048=this.currentToken=v9048=JAMScript.call(v9048.scan,v9048,[]),v9048=v9048.tokenId,v21648=TypeScript.TokenID,v21648=v21648.CloseParen;if(v9048=v9048!==v21648)for(;;){v9048=v9047.members;v9048=v9048.length;if(v9048=65535<v9048){JAMScript.call(this.reportParseError,this,["max number of args exceeded"]);break}var v9048=TypeScript.ErrorRecoverySet,v9048=v9048.Comma,v9048=v9048|errorRecoverySet,
v21648=TypeScript.OperatorPrecedence,v21648=v21648.Comma,v9053=TypeContext.NoTypes,v9048=JAMScript.call(this.parseExpr,this,[v9048,v21648,!0,v9053]);JAMScript.call(v9047.append,v9047,[v9048]);v9048=this.currentToken;v9048=v9048.tokenId;v21648=TypeScript.TokenID;v21648=v21648.Comma;if(v9048=v9048!=v21648)break;v9048=this.scanner;this.currentToken=v9048=JAMScript.call(v9048.scan,v9048,[])}errorRecoverySet=this.scanner;v9047.limChar=errorRecoverySet.pos;return v9047}function v560(ast){var result;result=
ast.nodeType;switch(result){case TypeScript.NodeType.TypeRef:return ast;case TypeScript.NodeType.Name:return result=TypeScript.TypeReference,result=JAMScript.new(result,[ast,0]),result.minChar=ast.minChar,result.limChar=ast.limChar,result;case TypeScript.NodeType.Index:result=ast.operand1;if(result=JAMScript.call(this.convertToTypeReference,this,[result])){var v16996=result.arrayCount;result.arrayCount=v16996+1;result.minChar=ast.minChar;result.limChar=ast.limChar;return result}ast=TypeScript.AST;
result=TypeScript.NodeType;result=result.Error;return ast=JAMScript.new(ast,[result])}return null}function v559(errorRecoverySet,isDecl,requiresSignature,isMethod,methodName,indexer,isStatic,markedAsAmbient,modifiers,lambdaArgContext,expectClosingRParen){var v9063=this.scanner,leftCurlyCount=v9063.leftCurlyCount,v9064=this.scanner,rightCurlyCount=v9064.rightCurlyCount,prevInConstr=this.parsingClassConstructorDefinition;this.parsingClassConstructorDefinition=!1;var name=null,v9065=this.scanner,fnMin=
v9065.startPos,v9066=this.scanner,minChar=v9066.pos,prevNestingLevel=this.nestingLevel,preComments=JAMScript.call(this.parseComments,this,[]),v9067=!lambdaArgContext,isLambda=!v9067;this.nestingLevel=0;var v21653=this.style_funcInLoop,v16998=!v21653;v16998&&(v16998=JAMScript.call(this.inLoop,this,[]));var v9068=v16998;v9068&&JAMScript.call(this.reportParseStyleError,this,["function declaration in loop"]);var v16999=!isMethod;if(v16999){var v21654=!isStatic;if(v21654){var v24105=!indexer;v24105&&(v24105=
!lambdaArgContext);v21654=v24105}v16999=v21654}var v9078=v16999;if(v9078){var v9069=this.scanner,v27261=JAMScript.call(v9069.scan,v9069,[]);this.currentToken=v27261;this.state=ParseState.StartFncDecl;var v24106=this.currentToken,v21655=v24106.tokenId,v24107=TypeScript.TokenID,v21656=v24107.Identifier,v17000=v21655!=v21656;if(v17000)var v24108=this.currentToken,v24109=this.strictMode,v21657=JAMScript.call(TypeScript.convertTokToID,TypeScript,[v24108,v24109]),v17000=!v21657;var v9077=v17000;if(v9077){if(isDecl){JAMScript.call(this.reportParseError,
this,["Function declaration must include identifier"]);this.nestingLevel=prevNestingLevel;var v9070=TypeScript.IncompleteAST,v17001=this.scanner,v9071=v17001.pos;return JAMScript.new(v9070,[fnMin,v9071])}}else{var v9072=TypeScript.Identifier,v9073=this.currentToken,name=JAMScript.call(v9072.fromToken,v9072,[v9073]),v9074=this.scanner;name.minChar=v9074.startPos;var v9075=this.scanner;name.limChar=v9075.pos;var v9076=this.scanner,v27262=JAMScript.call(v9076.scan,v9076,[]);this.currentToken=v27262}}else methodName&&
(name=methodName);this.state=ParseState.FncDeclName;var v9079=TypeScript.ASTList,args=JAMScript.new(v9079,[]),variableArgList=!1,isOverload=!1,v17002=TypeScript.Modifiers,v9080=v17002.Getter,isGetter=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v9080]),v17003=TypeScript.Modifiers,v9081=v17003.Setter,isSetter=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v9081]),v24110=this.currentToken,v21658=v24110.tokenId,v24111=TypeScript.TokenID,v21659=v24111.OpenParen,v17004=v21658==v21659,
v21661=!v17004;if(v21661){var v24112=indexer;if(v24112)var v26012=this.currentToken,v25323=v26012.tokenId,v26013=TypeScript.TokenID,v25324=v26013.OpenBracket,v24112=v25323==v25324;var v21660=v24112,v24114=!v21660;if(v24114){var v24113=lambdaArgContext;if(v24113){var v25325=lambdaArgContext.preProcessedLambdaArgs,v26016=!v25325;if(v26016)var v26408=this.currentToken,v26014=v26408.tokenId,v26409=TypeScript.TokenID,v26015=v26409.DotDotDot,v25325=v26014==v26015;v24113=v25325}v21660=v24113}v17004=v21660}var v9083=
v17004;if(v9083)var v17005,v9082=v17005=lambdaArgContext?lambdaArgContext.preProcessedLambdaArgs:null,variableArgList=JAMScript.call(this.parseFormalParameterList,this,[errorRecoverySet,args,!1,requiresSignature,indexer,isGetter,isSetter,isLambda,v9082,expectClosingRParen]);this.state=ParseState.FncDeclArgs;var returnType=null,v21662=this.currentToken,v17006=v21662.tokenId,v21663=TypeScript.TokenID,v17007=v21663.Colon,v9086=v17006==v17007;if(v9086){var v9084=this.scanner,v27263=JAMScript.call(v9084.scan,
v9084,[]);this.currentToken=v27263;var v21664=TypeScript.Modifiers,v17008=v21664.Setter,v9085=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v17008]);v9085&&JAMScript.call(this.reportParseError,this,["Property setters may not declare a return type"]);returnType=JAMScript.call(this.parseTypeReference,this,[errorRecoverySet,!0])}var v17009=indexer;if(v17009)var v24115=args.members,v21665=v24115.length,v17009=0==v21665;var v9087=v17009;v9087&&JAMScript.call(this.reportParseError,this,["Index signatures require a parameter type to be specified"]);
this.state=ParseState.FncDeclReturnType;var v17010=isLambda;if(v17010)var v24116=this.currentToken,v21666=v24116.tokenId,v24117=TypeScript.TokenID,v21667=v24117.EqualsGreaterThan,v17010=v21666!=v21667;var v9088=v17010;v9088&&JAMScript.call(this.reportParseError,this,["Expected '=>'"]);var v17011=isDecl;if(v17011){var v25326=this.parsingDeclareFile,v26017=!v25326;v26017&&(v25326=markedAsAmbient);var v24118=v25326,v21668=!v24118;if(v21668){var v25327=!isMethod,v26019=!v25327;if(v26019){var v26410=this.ambientModule,
v26571=!v26410;if(v26571){var v26570=this.ambientClass,v26657=!v26570;v26657&&(v26570=this.inInterfaceDecl);v26410=v26570}var v26018=v26410,v25327=!v26018}var v24119=v25327;if(v24119)var v26020=this.currentToken,v25328=v26020.tokenId,v26021=TypeScript.TokenID,v25329=v26021.Semicolon,v24119=v25328==v25329;v21668=v24119}v17011=v21668}var v9089=v17011;v9089&&(isOverload=!0,isDecl=!1,requiresSignature=!0);var svInFncDecl=this.inFncDecl;this.inFncDecl=!0;var v21669=TypeScript.ErrorRecoverySet,v17012=v21669.RCurly,
v9090=errorRecoverySet|v17012,v17013=TypeScript.AllowedElements,v9091=v17013.None,v17014=TypeScript.Modifiers,v9092=v17014.None,funcDecl=JAMScript.call(this.parseFunctionStatements,this,[v9090,name,!1,isMethod,args,v9091,minChar,requiresSignature,v9092]);this.inFncDecl=svInFncDecl;funcDecl.variableArgList=variableArgList;funcDecl.isOverload=isOverload;var v9093=!requiresSignature;if(v9093){var v17015=funcDecl.fncFlags,v21670=TypeScript.FncFlags,v17016=v21670.Definition;funcDecl.fncFlags=v17015|v17016}if(isStatic){var v17017=
funcDecl.fncFlags,v21671=TypeScript.FncFlags,v17018=v21671.Static;funcDecl.fncFlags=v17017|v17018}if(requiresSignature){var v17019=funcDecl.fncFlags,v21672=TypeScript.FncFlags,v17020=v21672.Signature;funcDecl.fncFlags=v17019|v17020}if(indexer){var v17021=funcDecl.fncFlags,v21673=TypeScript.FncFlags,v17022=v21673.IndexerMember;funcDecl.fncFlags=v17021|v17022}funcDecl.returnTypeAnnotation=returnType;if(isMethod){var v17023=funcDecl.fncFlags,v21674=TypeScript.FncFlags,v17024=v21674.Method;funcDecl.fncFlags=
v17023|v17024;var v17025=funcDecl.fncFlags,v21675=TypeScript.FncFlags,v17026=v21675.ClassPropertyMethodExported;funcDecl.fncFlags=v17025|v17026}var v17027=this.scanner,v9094=v17027.leftCurlyCount;funcDecl.leftCurlyCount=v9094-leftCurlyCount;var v17028=this.scanner,v9095=v17028.rightCurlyCount;funcDecl.rightCurlyCount=v9095-rightCurlyCount;this.nestingLevel=prevNestingLevel;this.parsingClassConstructorDefinition=prevInConstr;funcDecl.preComments=preComments;return funcDecl}function v558(errorRecoverySet,
formals,isClassConstr,isSig,isIndexer,isGetter,isSetter,isLambda,preProcessedLambdaArgs,expectClosingRParen){var v9096=this.scanner;formals.minChar=v9096.startPos;if(isIndexer){var v9097=this.scanner,v27264=JAMScript.call(v9097.scan,v9097,[]);this.currentToken=v27264}else{var v9100=!isLambda;if(v9100){var v17029=TypeScript.TokenID,v9098=v17029.OpenParen,v21676=TypeScript.ErrorRecoverySet,v17030=v21676.RParen,v9099=errorRecoverySet|v17030;JAMScript.call(this.checkCurrentToken,this,[v9098,v9099])}}var sawEllipsis=
!1,firstArg=!0,hasOptional=!1,haveFirstArgID=!1,v17031=isLambda;if(v17031){var v21677=preProcessedLambdaArgs;if(v21677)var v24120=preProcessedLambdaArgs.nodeType,v25330=TypeScript.NodeType,v24121=v25330.EmptyExpr,v21677=v24120!=v24121;v17031=v21677}var v9101=v17031;v9101&&(hasOptional=JAMScript.call(this.transformAnonymousArgsIntoFormals,this,[formals,preProcessedLambdaArgs]),haveFirstArgID=!0);for(;;){var munchedArg=!1,v9102=TypeScript.VarFlags,argFlags=v9102.None,v9103=this.scanner,argMinChar=v9103.startPos,
v17032=this.inferPropertiesFromThisAssignment;if(v17032)var v24122=this.currentToken,v21678=v24122.tokenId,v24123=TypeScript.TokenID,v21679=v24123.This,v17032=v21678==v21679;var v9108=v17032;if(v9108){var v9104=!isClassConstr;v9104&&JAMScript.call(this.reportParseError,this,["Instance property declarations using 'this' may only be used in class constructors"]);var v9105=this.scanner,v27265=JAMScript.call(v9105.scan,v9105,[]);this.currentToken=v27265;var v24124=TypeScript.VarFlags,v21680=v24124.Public,
v24125=TypeScript.VarFlags,v21681=v24125.Property,v17033=v21680|v21681,argFlags=argFlags|v17033,v9107=this.currentClassDefinition;if(v9107){var v9106=this.currentClassDefinition,v21682=v9106.varFlags,v24126=TypeScript.VarFlags,v21683=v24126.ClassSuperMustBeFirstCallInConstructor;v9106.varFlags=v21682|v21683}}var v21684=this.currentToken,v17034=v21684.tokenId,v21685=TypeScript.TokenID,v17035=v21685.Public,v9116=v17034==v17035;if(v9116){var v24127=TypeScript.VarFlags,v21686=v24127.Public,v24128=TypeScript.VarFlags,
v21687=v24128.Property,v17036=v21686|v21687,argFlags=argFlags|v17036,v9110=this.currentClassDefinition;if(v9110){var v9109=this.currentClassDefinition,v21688=v9109.varFlags,v24129=TypeScript.VarFlags,v21689=v24129.ClassSuperMustBeFirstCallInConstructor;v9109.varFlags=v21688|v21689}}else{var v21690=this.currentToken,v17037=v21690.tokenId,v21691=TypeScript.TokenID,v17038=v21691.Private,v9115=v17037==v17038;if(v9115){var v24130=TypeScript.VarFlags,v21692=v24130.Private,v24131=TypeScript.VarFlags,v21693=
v24131.Property,v17039=v21692|v21693,argFlags=argFlags|v17039,v9112=this.currentClassDefinition;if(v9112){var v9111=this.currentClassDefinition,v21694=v9111.varFlags,v24132=TypeScript.VarFlags,v21695=v24132.ClassSuperMustBeFirstCallInConstructor;v9111.varFlags=v21694|v21695}}else{var v24133=this.currentToken,v21696=v24133.tokenId,v24134=TypeScript.TokenID,v21697=v24134.Static,v17040=v21696==v21697;v17040&&(v17040=isClassConstr);var v9114=v17040;if(v9114){JAMScript.call(this.reportParseError,this,
["Static properties can not be declared as parameter properties"]);var v9113=this.scanner,v27266=JAMScript.call(v9113.scan,v9113,[]);this.currentToken=v27266}}}var v21698=TypeScript.VarFlags,v17041=v21698.None,v9128=argFlags!=v17041;if(v9128){var v9117=!isClassConstr;v9117&&JAMScript.call(this.reportParseError,this,["only constructor parameters can be properties"]);var v9118=this.scanner,v27267=JAMScript.call(v9118.scan,v9118,[]),v17042=this.currentToken=v27267,v9120=JAMScript.call(TypeScript.isModifier,
TypeScript,[v17042]);if(v9120){JAMScript.call(this.reportParseError,this,["Multiple modifiers may not be applied to parameters"]);var v9119=this.scanner,v27268=JAMScript.call(v9119.scan,v9119,[]);this.currentToken=v27268}var v17043=this.inferPropertiesFromThisAssignment;if(v17043)var v24135=this.currentToken,v21699=v24135.tokenId,v24136=TypeScript.TokenID,v21700=v24136.This,v17043=v21699==v21700;var v9124=v17043;if(v9124){var v9121=!isClassConstr;v9121&&JAMScript.call(this.reportParseError,this,["Instance property declarations using 'this' may only be used in class constructors"]);
var v9122=this.scanner,v27269=JAMScript.call(v9122.scan,v9122,[]);this.currentToken=v27269;var v9123=this.scanner,v27270=JAMScript.call(v9123.scan,v9123,[]);this.currentToken=v27270}}else{var v21701=this.currentToken,v17044=v21701.tokenId,v21702=TypeScript.TokenID,v17045=v21702.DotDotDot,v9127=v17044==v17045;if(v9127){var sawEllipsis=!0,v9125=this.scanner,v27271=JAMScript.call(v9125.scan,v9125,[]),v25331=this.currentToken=v27271,v24137=v25331.tokenId,v25332=TypeScript.TokenID,v24138=v25332.Identifier,
v21703=v24137==v24138,v17046=!v21703,v21706=!v17046;if(v21706)var v21704=this.currentToken,v21705=this.strictMode,v17046=JAMScript.call(TypeScript.convertTokToID,TypeScript,[v21704,v21705]);var v9126=v17046;v9126&&(JAMScript.call(this.reportParseError,this,["'...' parameters require both a parameter name and an array type annotation to be specified"]),sawEllipsis=!1)}}var argId=null,v21707=!haveFirstArgID;if(v21707)var v25333=this.currentToken,v24139=v25333.tokenId,v25334=TypeScript.TokenID,v24140=
v25334.Identifier,v21707=v24139==v24140;var v17047=v21707,v21710=!v17047;if(v21710)var v21708=this.currentToken,v21709=this.strictMode,v17047=JAMScript.call(TypeScript.convertTokToID,TypeScript,[v21708,v21709]);var v9133=v17047;if(v9133){var v9129=TypeScript.Identifier,v9130=this.currentToken,argId=JAMScript.call(v9129.fromToken,v9129,[v9130]),v9131=this.scanner;argId.minChar=v9131.startPos;var v9132=this.scanner;argId.limChar=v9132.pos}var v9155=haveFirstArgID||argId;if(v9155){var munchedArg=!0,
type=null,arg=null,v17048=haveFirstArgID;if(v17048)var v21711=formals.members,v17048=v21711.length;var v9141=v17048;if(v9141){var v9134=formals.members,v21712=formals.members,v17049=v21712.length,v9135=v17049-1,arg=v9134[v9135],v9136=arg.isOptional;v9136&&(hasOptional=!0)}else{var v9137=TypeScript.ArgDecl,arg=JAMScript.new(v9137,[argId]);isGetter&&JAMScript.call(this.reportParseError,this,["Property getters may not take any arguments"]);var v17050=isSetter;v17050&&(v17050=!firstArg);var v9138=v17050;
v9138&&JAMScript.call(this.reportParseError,this,["Property setters may only take one argument"]);arg.minChar=argMinChar;var v9139=arg,v27272=JAMScript.call(this.parseComments,this,[]);v9139.preComments=v27272;var v9140=this.scanner,v27273=JAMScript.call(v9140.scan,v9140,[]);this.currentToken=v27273}var v21713=this.currentToken,v17051=v21713.tokenId,v21714=TypeScript.TokenID,v17052=v21714.Question,v9143=v17051==v17052;if(v9143){var hasOptional=arg.isOptional=!0,v9142=this.scanner,v27274=JAMScript.call(v9142.scan,
v9142,[]);this.currentToken=v27274}var v21715=this.currentToken,v17053=v21715.tokenId,v21716=TypeScript.TokenID,v17054=v21716.Colon,v9145=v17053==v17054;if(v9145){var v9144=this.scanner,v27275=JAMScript.call(v9144.scan,v9144,[]);this.currentToken=v27275;type=JAMScript.call(this.parseTypeReference,this,[errorRecoverySet,!1])}var v21717=this.currentToken,v17055=v21717.tokenId,v21718=TypeScript.TokenID,v17056=v21718.Equals,v9148=v17055==v17056;if(v9148){isSig&&JAMScript.call(this.reportParseError,this,
["Arguments in signatures may not have default values"]);var hasOptional=!0,v9146=this.scanner,v27276=JAMScript.call(v9146.scan,v9146,[]);this.currentToken=v27276;var v9147=arg,v24141=TypeScript.ErrorRecoverySet,v21719=v24141.Comma,v17057=v21719|errorRecoverySet,v21720=TypeScript.OperatorPrecedence,v17058=v21720.Comma,v17059=TypeContext.NoTypes,v27277=JAMScript.call(this.parseExpr,this,[v17057,v17058,!1,v17059]);v9147.init=v27277}var v17060=hasOptional;if(v17060){var v24142=JAMScript.call(arg.isOptionalArg,
arg,[]),v21721=!v24142;v21721&&(v21721=!sawEllipsis);v17060=v21721}var v9149=v17060;v9149&&JAMScript.call(this.reportParseError,this,["Optional parameters may only be followed by other optional parameters"]);var v17061=sawEllipsis;v17061&&(v17061=JAMScript.call(arg.isOptionalArg,arg,[]));var v9150=v17061;v9150&&JAMScript.call(this.reportParseError,this,["Varargs may not be optional or have default parameters"]);var v17062=sawEllipsis;v17062&&(v17062=!type);var v9151=v17062;v9151&&JAMScript.call(this.reportParseError,
this,["'...' parameters require both a parameter name and an array type annotation to be specified"]);var v9152=arg,v27278=JAMScript.call(this.parseComments,this,[]);v9152.postComments=v27278;arg.typeExpr=type;var v9153=arg,v17063=this.scanner,v27279=JAMScript.call(v17063.lastTokenLimChar,v17063,[]);v9153.limChar=v27279;var v17064=arg.varFlags;arg.varFlags=v17064|argFlags;var v9154=!haveFirstArgID;v9154?JAMScript.call(formals.append,formals,[arg]):haveFirstArgID=!1}var firstArg=!1,v21722=this.currentToken,
v17065=v21722.tokenId,v21723=TypeScript.TokenID,v17066=v21723.Comma,v9160=v17065==v17066;if(v9160){var v17067=munchedArg;v17067&&(v17067=!sawEllipsis);var v9159=v17067;if(v9159){var v9156=this.scanner,v27280=JAMScript.call(v9156.scan,v9156,[]);this.currentToken=v27280}else{JAMScript.call(this.reportParseError,this,["Unexpected ',' in argument list"]);var v9158=this.errorRecovery;if(v9158){var v9157=this.scanner,v27281=JAMScript.call(v9157.scan,v9157,[]);this.currentToken=v27281}}}else break}if(isIndexer){var v17068=
TypeScript.TokenID,v9161=v17068.CloseBracket,v24143=TypeScript.ErrorRecoverySet,v21724=v24143.LCurly,v17069=errorRecoverySet|v21724,v21725=TypeScript.ErrorRecoverySet,v17070=v21725.SColon,v9162=v17069|v17070;JAMScript.call(this.checkCurrentToken,this,[v9161,v9162])}else if(expectClosingRParen){var v17071=TypeScript.TokenID,v9163=v17071.CloseParen,v24144=TypeScript.ErrorRecoverySet,v21726=v24144.LCurly,v17072=errorRecoverySet|v21726,v21727=TypeScript.ErrorRecoverySet,v17073=v21727.SColon,v9164=v17072|
v17073;JAMScript.call(this.checkCurrentToken,this,[v9163,v9164])}var v9165=formals,v17074=this.scanner,v27282=JAMScript.call(v17074.lastTokenLimChar,v17074,[]);v9165.limChar=v27282;return sawEllipsis}function v557(formals,argList){function translateBinExOperand(operand){var v17075=operand.nodeType,v21728=TypeScript.NodeType,v21728=v21728.Comma;if(v17075=v17075==v21728)return JAMScript.call(_this.transformAnonymousArgsIntoFormals,_this,[formals,operand]);v17075=operand.nodeType;v21728=TypeScript.NodeType;
v21728=v21728.Name;v17075=v17075==v21728;if(v21728=!v17075)v17075=operand.nodeType,v21728=TypeScript.NodeType,v21728=v21728.Asg,v17075=v17075==v21728;if(v17075){v17075=operand.nodeType;v21728=TypeScript.NodeType;v21728=v21728.Asg;v21728=v17075=(v17075=v17075==v21728)?operand.operand1:operand;v17075=TypeScript.ArgDecl;v17075=JAMScript.new(v17075,[v21728]);v17075.preComments=v21728.preComments;v17075.postComments=v21728.postComments;v17075.minChar=operand.minChar;v17075.limChar=operand.limChar;var v21728=
v21728.flags,v21736=TypeScript.ASTFlags,v21736=v21736.PossibleOptionalParameter;if(v21728=JAMScript.call(TypeScript.hasFlag,TypeScript,[v21728,v21736]))v17075.isOptional=!0;v21728=operand.nodeType;v21736=TypeScript.NodeType;v21736=v21736.Asg;if(v21728=v21728==v21736)v17075.init=operand.operand2;JAMScript.call(formals.append,formals,[v17075]);operand=v17075.isOptional;if(v21728=!operand)operand=v17075.init;return operand}JAMScript.call(_this.reportParseError,_this,["Invalid lambda argument"]);return!1}
var _this=this;if(argList){var v17084=argList.nodeType,v21738=TypeScript.NodeType,v21738=v21738.Comma;if(v17084=v17084==v21738){v17084=argList;v21738=v17084.operand1;if(v21738=v21738.isParenthesized){var v21738=v17084.operand1,v21738=v21738.minChar,v17088=v17084.operand1,v17088=v17088.limChar;JAMScript.call(this.reportParseError,this,["Invalid lambda argument",v21738,v17088])}v21738=v17084.operand2;if(v21738=v21738.isParenthesized)v21738=v17084.operand2,v21738=v21738.minChar,v17088=v17084.operand2,
v17088=v17088.limChar,JAMScript.call(this.reportParseError,this,["Invalid lambda argument",v21738,v17088]);v21738=v17084.operand1;v21738=translateBinExOperand(v21738);v17084=v17084.operand2;v17084=translateBinExOperand(v17084);(v17088=!v17084)&&(v17084=v21738);return v21738=v17084}return translateBinExOperand(argList)}}function v556(errorRecoverySet,name,isConstructor,isMethod,args,allowedElements,minChar,requiresSignature,parentModifiers){JAMScript.call(this.pushDeclLists,this,[]);var svStmtStack=
this.statementInfoStack;JAMScript.call(this.resetStmtStack,this,[]);var bod=null,wasShorthand=!1,isAnonLambda=!1;if(requiresSignature){isMethod=this.scanner;isMethod=isMethod.pos;var v21739=this.currentToken,v21739=v21739.tokenId,v21740=TypeScript.TokenID,v21740=v21740.OpenBrace;if(v21739=v21739===v21740){if(JAMScript.call(this.reportParseError,this,["Function declarations are not permitted within interfaces, ambient modules or classes"]),bod=TypeScript.ASTList,bod=JAMScript.new(bod,[]),v21739=this.scanner,
v21739=v21739.startPos,JAMScript.call(this.parseFunctionBlock,this,[errorRecoverySet,allowedElements,parentModifiers,bod,v21739]),allowedElements=TypeScript.TokenID,allowedElements=allowedElements.CloseBrace,JAMScript.call(this.checkCurrentToken,this,[allowedElements,errorRecoverySet]),allowedElements=this.currentToken,allowedElements=allowedElements.tokenId,parentModifiers=TypeScript.TokenID,parentModifiers=parentModifiers.Semicolon,allowedElements=allowedElements===parentModifiers)allowedElements=
this.scanner,this.currentToken=allowedElements=JAMScript.call(allowedElements.scan,allowedElements,[])}else allowedElements=TypeScript.TokenID,allowedElements=allowedElements.Semicolon,JAMScript.call(this.checkCurrentToken,this,[allowedElements,errorRecoverySet,"Expected ';'"])}else{var bod=TypeScript.ASTList,bod=JAMScript.new(bod,[]),v21739=this.scanner,v21739=v21739.startPos,v21740=this.currentToken,v21740=v21740.tokenId,v21744=TypeScript.TokenID,v21744=v21744.EqualsGreaterThan;if(v21740=v21740==
v21744)isMethod&&JAMScript.call(this.reportParseError,this,["'=>' may not be used for class methods"]),wasShorthand=!0,isMethod=this.scanner,this.currentToken=isMethod=JAMScript.call(isMethod.scan,isMethod,[]);if(isMethod=wasShorthand)isMethod=this.currentToken,isMethod=isMethod.tokenId,v21740=TypeScript.TokenID,v21740=v21740.OpenBrace,isMethod=isMethod!=v21740;isMethod?(isMethod=TypeScript.ErrorRecoverySet,isMethod=isMethod.SColon,isMethod|=errorRecoverySet,allowedElements=TypeScript.OperatorPrecedence,
allowedElements=allowedElements.Assignment,parentModifiers=TypeContext.NoTypes,isMethod=JAMScript.call(this.parseExpr,this,[isMethod,allowedElements,!0,parentModifiers]),allowedElements=TypeScript.ReturnStatement,allowedElements=JAMScript.new(allowedElements,[]),allowedElements.returnExpression=isMethod,allowedElements.minChar=isMethod.minChar,allowedElements.limChar=isMethod.limChar,bod.minChar=v21739,JAMScript.call(bod.append,bod,[allowedElements])):(isAnonLambda=wasShorthand,JAMScript.call(this.parseFunctionBlock,
this,[errorRecoverySet,allowedElements,parentModifiers,bod,v21739]));isMethod=this.scanner;isMethod=isMethod.pos}allowedElements=TypeScript.FuncDecl;parentModifiers=JAMScript.call(this.topVarList,this,[]);v21739=JAMScript.call(this.topScopeList,this,[]);v21740=JAMScript.call(this.topStaticsList,this,[]);v21744=TypeScript.NodeType;v21744=v21744.FuncDecl;name=JAMScript.new(allowedElements,[name,bod,isConstructor,args,parentModifiers,v21739,v21740,v21744]);JAMScript.call(this.popDeclLists,this,[]);isConstructor=
JAMScript.call(this.topScopeList,this,[]);JAMScript.call(isConstructor.append,isConstructor,[name]);if(isConstructor=!requiresSignature)wasShorthand=!wasShorthand,(isConstructor=!wasShorthand)&&(wasShorthand=isAnonLambda),wasShorthand?(bod=name,wasShorthand=TypeScript.ASTSpan,wasShorthand=JAMScript.new(wasShorthand,[]),bod.endingToken=wasShorthand,bod=name.endingToken,wasShorthand=this.scanner,bod.minChar=wasShorthand.startPos,bod=name.endingToken,wasShorthand=this.scanner,bod.limChar=wasShorthand.pos,
bod=TypeScript.TokenID,bod=bod.CloseBrace,JAMScript.call(this.checkCurrentToken,this,[bod,errorRecoverySet]),isAnonLambda&&(errorRecoverySet=name.fncFlags,isAnonLambda=TypeScript.FncFlags,isAnonLambda=isAnonLambda.IsFatArrowFunction,name.fncFlags=errorRecoverySet|isAnonLambda)):(errorRecoverySet=name.fncFlags,isAnonLambda=TypeScript.FncFlags,isAnonLambda=isAnonLambda.IsFatArrowFunction,name.fncFlags=errorRecoverySet|isAnonLambda,errorRecoverySet=name,isAnonLambda=TypeScript.ASTSpan,isAnonLambda=JAMScript.new(isAnonLambda,
[]),errorRecoverySet.endingToken=isAnonLambda,errorRecoverySet=name.endingToken,isAnonLambda=bod.members,isAnonLambda=isAnonLambda[0],errorRecoverySet.minChar=isAnonLambda.minChar,errorRecoverySet=name.endingToken,isAnonLambda=bod.members,isAnonLambda=isAnonLambda[0],errorRecoverySet.limChar=isAnonLambda.limChar);name.minChar=minChar;name.limChar=isMethod;if(minChar=!requiresSignature)minChar=name.fncFlags,requiresSignature=TypeScript.FncFlags,requiresSignature=requiresSignature.Definition,name.fncFlags=
minChar|requiresSignature;this.statementInfoStack=svStmtStack;return name}function v555(errorRecoverySet,allowedElements,parentModifiers,bod,bodMinChar){this.state=ParseState.StartStatementList;var v17120=TypeScript.TokenID,v17120=v17120.OpenBrace,v21754=TypeScript.ErrorRecoverySet,v21754=v21754.StmtStart,v21754=errorRecoverySet|v21754;JAMScript.call(this.checkCurrentToken,this,[v17120,v21754]);v17120=this.inFunction;this.inFunction=!0;v21754=TypeScript.ErrorRecoverySet;v21754=v21754.RCurly;errorRecoverySet|=
v21754;v21754=TypeScript.ErrorRecoverySet;v21754=v21754.StmtStart;errorRecoverySet|=v21754;JAMScript.call(this.parseStatementList,this,[errorRecoverySet,bod,!0,!1,allowedElements,parentModifiers]);bod.minChar=bodMinChar;allowedElements=this.scanner;bod.limChar=allowedElements.pos;this.inFunction=v17120;allowedElements=TypeScript.EndCode;allowedElements=JAMScript.new(allowedElements,[]);allowedElements.minChar=bod.limChar;allowedElements.limChar=allowedElements.minChar;JAMScript.call(bod.append,bod,
[allowedElements])}function v554(minChar,errorRecoverySet){var v9220=this.scanner;this.currentToken=v9220=JAMScript.call(v9220.scan,v9220,[]);v9220=TypeScript.ASTList;v9220=JAMScript.new(v9220,[]);v9220.minChar=minChar;var prevInInterfaceDecl=this.inInterfaceDecl;this.inInterfaceDecl=!0;var v21757=TypeScript.ErrorRecoverySet,v21757=v21757.RCurly,v21757=errorRecoverySet|v21757;JAMScript.call(this.parseTypeMemberList,this,[v21757,v9220]);this.inInterfaceDecl=prevInInterfaceDecl;prevInInterfaceDecl=
TypeScript.TokenID;prevInInterfaceDecl=prevInInterfaceDecl.CloseBrace;JAMScript.call(this.checkCurrentToken,this,[prevInInterfaceDecl,errorRecoverySet]);prevInInterfaceDecl=TypeScript.InterfaceDeclaration;v21757=this.anonId;prevInInterfaceDecl=JAMScript.new(prevInInterfaceDecl,[v21757,v9220,null,null]);prevInInterfaceDecl.minChar=minChar;prevInInterfaceDecl.limChar=v9220.limChar;return JAMScript.call(this.parseTypeReferenceTail,this,[errorRecoverySet,minChar,prevInInterfaceDecl])}function v553(errorRecoverySet,
allowVoid){var v9226=this.scanner,v9226=v9226.startPos,isConstructorMember=!1,v17126=this.currentToken,v17126=v17126.tokenId;switch(v17126){case TypeScript.TokenID.Void:(isConstructorMember=!allowVoid)&&JAMScript.call(this.reportParseError,this,["void not a valid type in this context"]);case TypeScript.TokenID.Any:case TypeScript.TokenID.Number:case TypeScript.TokenID.Bool:case TypeScript.TokenID.String:isConstructorMember=TypeScript.tokenTable;v17126=this.currentToken;v17126=v17126.tokenId;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)isConstructorMember=
isConstructorMember[v17126];isConstructorMember=isConstructorMember.text;v17126=TypeScript.Identifier;isConstructorMember=JAMScript.new(v17126,[isConstructorMember]);isConstructorMember.minChar=v9226;v17126=this.scanner;isConstructorMember.limChar=v17126.pos;v17126=this.scanner;this.currentToken=v17126=JAMScript.call(v17126.scan,v17126,[]);return JAMScript.call(this.parseTypeReferenceTail,this,[errorRecoverySet,v9226,isConstructorMember]);case TypeScript.TokenID.Identifier:return isConstructorMember=
this.currentToken,isConstructorMember=JAMScript.call(isConstructorMember.getText,isConstructorMember,[]),v17126=this.currentToken,v17126=v17126.hasEscapeSequence,isConstructorMember=JAMScript.call(this.createRef,this,[isConstructorMember,v17126,v9226]),v17126=this.scanner,isConstructorMember.limChar=v17126.pos,JAMScript.call(this.parseNamedType,this,[errorRecoverySet,v9226,isConstructorMember,!0]);case TypeScript.TokenID.OpenBrace:return JAMScript.call(this.parseObjectType,this,[v9226,errorRecoverySet]);
case TypeScript.TokenID.New:var v17126=this.scanner,v17126=this.currentToken=v17126=JAMScript.call(v17126.scan,v17126,[]),v17126=v17126.tokenId,v21760=TypeScript.TokenID,v21760=v21760.OpenParen;(v17126=v17126!=v21760)?JAMScript.call(this.reportParseError,this,["Expected '('"]):isConstructorMember=!0;case TypeScript.TokenID.OpenParen:var v17126=TypeScript.ASTList,v17126=JAMScript.new(v17126,[]),v21760=TypeScript.ErrorRecoverySet,v21760=v21760.RParen,v21760=errorRecoverySet|v21760,v21760=JAMScript.call(this.parseFormalParameterList,
this,[v21760,v17126,!1,!0,!1,!1,!1,!1,null,!0]),v17134=TypeScript.TokenID,v17134=v17134.EqualsGreaterThan;JAMScript.call(this.checkCurrentToken,this,[v17134,errorRecoverySet]);var v17134=JAMScript.call(this.parseTypeReference,this,[errorRecoverySet,!0]),v9240=TypeScript.FuncDecl,v17135=TypeScript.NodeType,v17135=v17135.FuncDecl,v17126=JAMScript.new(v9240,[null,null,!1,v17126,null,null,null,v17135]);v17126.returnTypeAnnotation=v17134;v17126.variableArgList=v21760;v21760=v17126.fncFlags;v17134=TypeScript.FncFlags;
v17134=v17134.Signature;v17126.fncFlags=v21760|v17134;isConstructorMember&&(isConstructorMember=v17126.fncFlags,v21760=TypeScript.FncFlags,v21760=v21760.ConstructMember,v17126.fncFlags=isConstructorMember|v21760,v17126.hint="_construct",v17126.classDecl=null);v17126.minChar=v9226;return JAMScript.call(this.parseTypeReferenceTail,this,[errorRecoverySet,v9226,v17126]);default:return JAMScript.call(this.reportParseError,this,["Expected type name"]),v9226=TypeScript.TypeReference,v9226=JAMScript.new(v9226,
[null,0]),isConstructorMember=v9226.flags,v17126=TypeScript.ASTFlags,v17126=v17126.Error,v9226.flags=isConstructorMember|v17126,isConstructorMember=this.scanner,v9226.minChar=isConstructorMember.pos,isConstructorMember=this.scanner,v9226.limChar=isConstructorMember.pos,v9226}}function v552(errorRecoverySet,minChar,term,tail){var v9246=this.scanner,v9246=this.currentToken=v9246=JAMScript.call(v9246.scan,v9246,[]),v9246=v9246.tokenId,v21766=TypeScript.TokenID,v21766=v21766.Dot;if(v9246=v9246==v21766){v9246=
this.scanner;v9246=this.currentToken=v9246=JAMScript.call(v9246.scan,v9246,[]);v9246=v9246.tokenId;v21766=TypeScript.TokenID;v21766=v21766.Identifier;v9246=v9246==v21766;if(v21766=!v9246){v9246=this.errorRecovery;v9246=!v9246;if(v21766=!v9246)v9246=this.scanner,v9246=JAMScript.call(v9246.lastTokenHadNewline,v9246,[]),v9246=!v9246;v9246&&(v9246=this.currentToken,v21766=this.strictMode,v9246=JAMScript.call(TypeScript.convertTokToID,TypeScript,[v9246,v21766]))}if(v9246){v9246=TypeScript.Identifier;v21766=
this.currentToken;v9246=JAMScript.call(v9246.fromToken,v9246,[v21766]);v21766=this.scanner;v9246.minChar=v21766.startPos;v21766=this.scanner;v9246.limChar=v21766.pos;var v21766=TypeScript.BinaryExpression,v17145=TypeScript.NodeType,v17145=v17145.Dot,v21766=JAMScript.new(v21766,[v17145,term,v9246]);v21766.minChar=term.minChar;v21766.limChar=v9246.limChar;return JAMScript.call(this.parseNamedType,this,[errorRecoverySet,minChar,v21766,tail])}JAMScript.call(this.reportParseError,this,["need identifier after '.'"]);
if(v9246=this.errorRecovery)return errorRecoverySet=term.flags,minChar=TypeScript.ASTFlags,minChar=minChar.DotLHS,term.flags=errorRecoverySet|minChar,errorRecoverySet=term,minChar=this.scanner,minChar=JAMScript.call(minChar.lastTokenLimChar,minChar,[]),errorRecoverySet.limChar=minChar,term;v9246=TypeScript.MissingIdentifier;v9246=JAMScript.new(v9246,[]);v21766=this.scanner;v9246.minChar=v21766.pos;v21766=this.scanner;v9246.limChar=v21766.pos;var v21766=TypeScript.BinaryExpression,v17145=TypeScript.NodeType,
v17145=v17145.Dot,v21766=JAMScript.new(v21766,[v17145,term,v9246]),v17145=v21766.flags,v21772=TypeScript.ASTFlags,v21772=v21772.Error;v21766.flags=v17145|v21772;v21766.minChar=term.minChar;v21766.limChar=v9246.limChar;return JAMScript.call(this.parseNamedType,this,[errorRecoverySet,minChar,v21766,tail])}return tail?JAMScript.call(this.parseTypeReferenceTail,this,[errorRecoverySet,minChar,term]):term}function v551(errorRecoverySet,minChar,term){var v9264=TypeScript.TypeReference;term=JAMScript.new(v9264,
[term,0]);term.minChar=minChar;minChar=this.currentToken;minChar=minChar.tokenId;v9264=TypeScript.TokenID;v9264=v9264.OpenBracket;for(minChar=minChar==v9264;minChar;)minChar=this.scanner,this.currentToken=minChar=JAMScript.call(minChar.scan,minChar,[]),minChar=term.arrayCount,term.arrayCount=minChar+1,minChar=TypeScript.TokenID,minChar=minChar.CloseBracket,v9264=TypeScript.ErrorRecoverySet,v9264=v9264.LBrack,v9264|=errorRecoverySet,JAMScript.call(this.checkCurrentToken,this,[minChar,v9264]),minChar=
this.currentToken,minChar=minChar.tokenId,v9264=TypeScript.TokenID,v9264=v9264.OpenBracket,minChar=minChar==v9264;errorRecoverySet=term;minChar=this.scanner;minChar=JAMScript.call(minChar.lastTokenLimChar,minChar,[]);errorRecoverySet.limChar=minChar;return term}function v550(errorRecoverySet,modifiers,preComments){var v9270=this.scanner,leftCurlyCount=v9270.leftCurlyCount,v9271=this.scanner,rightCurlyCount=v9271.rightCurlyCount,svAmbient=this.ambientModule,svTopLevel=this.topLevel;this.topLevel=!1;
var v17160=this.parsingDeclareFile,v21779=!v17160;if(v21779){var v21778=svAmbient,v24157=!v21778;if(v24157)var v25338=TypeScript.Modifiers,v24156=v25338.Ambient,v21778=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v24156]);v17160=v21778}var v9272=v17160;v9272&&(this.ambientModule=!0);var v9273=this.scanner,v27295=JAMScript.call(v9273.scan,v9273,[]);this.currentToken=v27295;var name=null,enclosedList=null;JAMScript.call(this.pushDeclLists,this,[]);var v9274=this.scanner,minChar=v9274.startPos,
isDynamicMod=!1,v24158=this.currentToken,v21780=v24158.tokenId,v24159=TypeScript.TokenID,v21781=v24159.Identifier,v17161=v21780==v21781,v21783=!v17161;if(v21783){var v25339=this.currentToken,v24160=v25339.tokenId,v25340=TypeScript.TokenID,v24161=v25340.StringLiteral,v21782=v24160==v24161,v24163=!v21782;if(v24163){var v26023=this.currentToken,v25341=JAMScript.call(TypeScript.isPrimitiveTypeToken,TypeScript,[v26023]),v24162=!v25341;if(v24162)var v25342=this.currentToken,v25343=this.strictMode,v24162=
JAMScript.call(TypeScript.convertTokToID,TypeScript,[v25342,v25343]);v21782=v24162}v17161=v21782}var v9286=v17161;if(v9286){var v9275=this.currentToken;JAMScript.call(v9275.getText,v9275,[]);var v21784=this.currentToken,v17162=v21784.tokenId,v21785=TypeScript.TokenID,v17163=v21785.StringLiteral,v9278=v17162==v17163;if(v9278){var isDynamicMod=!0,v17164=this.ambientModule,v9276=!v17164;v9276&&JAMScript.call(this.reportParseError,this,["Only ambient dynamic modules may have string literal names"]);var v9277=
!svTopLevel;v9277&&JAMScript.call(this.reportParseError,this,["Dynamic modules may not be nested within other modules"])}var v9279=TypeScript.Identifier,v9280=this.currentToken,name=JAMScript.call(v9279.fromToken,v9279,[v9280]),v9281=this.scanner;name.minChar=v9281.startPos;var v9282=this.scanner;name.limChar=v9282.pos;var v9283=this.scanner,v27296=JAMScript.call(v9283.scan,v9283,[]);this.currentToken=v27296}else{var v21786=this.currentToken,v17165=v21786.tokenId,v21787=TypeScript.TokenID,v17166=
v21787.OpenBrace,v9285=v17165==v17166;if(v9285){JAMScript.call(this.reportParseError,this,["Module name missing"]);var v9284=TypeScript.Identifier,name=JAMScript.new(v9284,[""]);name.minChar=minChar;name.limChar=minChar}}var v21788=this.currentToken,v17167=v21788.tokenId,v21789=TypeScript.TokenID,v17168=v21789.Dot,v9287=v17167==v17168;v9287&&(enclosedList=[],JAMScript.call(this.parseDottedName,this,[enclosedList]));var v9289=null==name;if(v9289)var v9288=TypeScript.MissingIdentifier,name=JAMScript.new(v9288,
[]);var v9290=TypeScript.ASTList,moduleBody=JAMScript.new(v9290,[]),v9291=this.scanner,bodyMinChar=v9291.startPos,v17169=TypeScript.TokenID,v9292=v17169.OpenBrace,v21790=TypeScript.ErrorRecoverySet,v17170=v21790.ID,v9293=errorRecoverySet|v17170;JAMScript.call(this.checkCurrentToken,this,[v9292,v9293]);var v9294=svTopLevel&&isDynamicMod;this.allowImportDeclaration=v9294?!0:!1;var v21791=TypeScript.ErrorRecoverySet,v17171=v21791.RCurly,v9295=errorRecoverySet|v17171,v17172=TypeScript.AllowedElements,
v9296=v17172.Global;JAMScript.call(this.parseStatementList,this,[v9295,moduleBody,!0,!0,v9296,modifiers]);moduleBody.minChar=bodyMinChar;var v9297=this.scanner;moduleBody.limChar=v9297.pos;var v9298=TypeScript.ASTSpan,endingToken=JAMScript.new(v9298,[]),v9299=this.scanner;endingToken.minChar=v9299.startPos;var v9300=this.scanner;endingToken.limChar=v9300.pos;var v17173=TypeScript.TokenID,v9301=v17173.CloseBrace;JAMScript.call(this.checkCurrentToken,this,[v9301,errorRecoverySet]);var v9302=this.scanner,
limChar=JAMScript.call(v9302.lastTokenLimChar,v9302,[]),moduleDecl;this.allowImportDeclaration=svTopLevel;var v17174=enclosedList;if(v17174)var v21792=enclosedList.length,v17174=0<v21792;var v9321=v17174;if(v9321){var len=enclosedList.length,v9303=len-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var innerName=enclosedList[v9303];var v9304=TypeScript.ModuleDeclaration,v9305=JAMScript.call(this.topVarList,this,[]),v9306=JAMScript.call(this.topScopeList,this,[]),
innerDecl=JAMScript.new(v9304,[innerName,moduleBody,v9305,v9306,endingToken]);innerDecl.preComments=preComments;var v17175=this.parsingDeclareFile,v21794=!v17175;if(v21794)var v24164=TypeScript.Modifiers,v21793=v24164.Ambient,v17175=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v21793]);var v9307=v17175;if(v9307){var v17176=innerDecl.modFlags,v21795=TypeScript.ModuleFlags,v17177=v21795.Ambient;innerDecl.modFlags=v17176|v17177}var v17178=innerDecl.modFlags,v21796=TypeScript.ModuleFlags,v17179=
v21796.Exported;innerDecl.modFlags=v17178|v17179;innerDecl.minChar=minChar;innerDecl.limChar=limChar;JAMScript.call(this.popDeclLists,this,[]);for(var outerModBod,i=len-2,v9313=0<=i;v9313;){var v9308=TypeScript.ASTList;outerModBod=JAMScript.new(v9308,[]);JAMScript.call(outerModBod.append,outerModBod,[innerDecl]);var innerName=enclosedList[i],v9309=TypeScript.ModuleDeclaration,v17180=TypeScript.ASTList,v9310=JAMScript.new(v17180,[]),v17181=TypeScript.ASTList,v9311=JAMScript.new(v17181,[]),innerDecl=
JAMScript.new(v9309,[innerName,outerModBod,v9310,v9311,endingToken]);outerModBod.minChar=innerDecl.minChar=minChar;outerModBod.limChar=innerDecl.limChar=limChar;var v17182=this.parsingDeclareFile,v21798=!v17182;if(v21798)var v24165=TypeScript.Modifiers,v21797=v24165.Ambient,v17182=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v21797]);var v9312=v17182;if(v9312){var v17183=innerDecl.modFlags,v21799=TypeScript.ModuleFlags,v17184=v21799.Ambient;innerDecl.modFlags=v17183|v17184}var v17185=innerDecl.modFlags,
v21800=TypeScript.ModuleFlags,v17186=v21800.Exported;innerDecl.modFlags=v17185|v17186;i-=1;v9313=0<=i}var v9314=TypeScript.ASTList;outerModBod=JAMScript.new(v9314,[]);JAMScript.call(outerModBod.append,outerModBod,[innerDecl]);outerModBod.minChar=minChar;outerModBod.limChar=limChar;var v9315=TypeScript.ModuleDeclaration,v17187=TypeScript.ASTList,v9316=JAMScript.new(v17187,[]),v17188=TypeScript.ASTList,v9317=JAMScript.new(v17188,[]);moduleDecl=JAMScript.new(v9315,[name,outerModBod,v9316,v9317,endingToken])}else{var v9318=
TypeScript.ModuleDeclaration,v9319=JAMScript.call(this.topVarList,this,[]),v9320=JAMScript.call(this.topScopeList,this,[]);moduleDecl=JAMScript.new(v9318,[name,moduleBody,v9319,v9320,endingToken]);moduleDecl.preComments=preComments;JAMScript.call(this.popDeclLists,this,[])}var v17189=this.parsingDeclareFile,v21802=!v17189;if(v21802){var v21801=svAmbient,v24167=!v21801;if(v24167)var v25344=TypeScript.Modifiers,v24166=v25344.Ambient,v21801=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v24166]);
v17189=v21801}var v9322=v17189;if(v9322){var v17190=moduleDecl.modFlags,v21803=TypeScript.ModuleFlags,v17191=v21803.Ambient;moduleDecl.modFlags=v17190|v17191}var v17192=svAmbient,v21805=!v17192;if(v21805)var v24168=TypeScript.Modifiers,v21804=v24168.Exported,v17192=JAMScript.call(TypeScript.hasFlag,TypeScript,[modifiers,v21804]);var v9323=v17192;if(v9323){var v17193=moduleDecl.modFlags,v21806=TypeScript.ModuleFlags,v17194=v21806.Exported;moduleDecl.modFlags=v17193|v17194}if(isDynamicMod){var v17195=
moduleDecl.modFlags,v21807=TypeScript.ModuleFlags,v17196=v21807.IsDynamic;moduleDecl.modFlags=v17195|v17196}this.ambientModule=svAmbient;this.topLevel=svTopLevel;var v17197=this.scanner,v9324=v17197.leftCurlyCount;moduleDecl.leftCurlyCount=v9324-leftCurlyCount;var v17198=this.scanner,v9325=v17198.rightCurlyCount;moduleDecl.rightCurlyCount=v9325-rightCurlyCount;moduleDecl.limChar=moduleBody.limChar;return moduleDecl}function v549(errorRecoverySet,modifiers){var name=null,alias=null,importDecl=null,
v9326=this.scanner,minChar=v9326.startPos,isDynamicImport=!1,v9327=this.scanner,v27297=JAMScript.call(v9327.scan,v9327,[]),v24169=this.currentToken=v27297,v21808=v24169.tokenId,v24170=TypeScript.TokenID,v21809=v24170.Identifier,v17199=v21808==v21809,v21812=!v17199;if(v21812)var v21810=this.currentToken,v21811=this.strictMode,v17199=JAMScript.call(TypeScript.convertTokToID,TypeScript,[v21810,v21811]);var v9331=v17199;if(v9331)var v9328=TypeScript.Identifier,v9329=this.currentToken,name=JAMScript.call(v9328.fromToken,
v9328,[v9329]);else{JAMScript.call(this.reportParseError,this,["Expected identifer after 'import'"]);var v9330=TypeScript.MissingIdentifier,name=JAMScript.new(v9330,[])}var v9332=this.scanner;name.minChar=v9332.startPos;var v9333=this.scanner;name.limChar=v9333.pos;var v9334=this.scanner,v27298=JAMScript.call(v9334.scan,v9334,[]);this.currentToken=v27298;var v17200=TypeScript.TokenID,v9335=v17200.Equals,v21813=TypeScript.ErrorRecoverySet,v17201=v21813.ID,v9336=errorRecoverySet|v17201;JAMScript.call(this.checkCurrentToken,
this,[v9335,v9336]);var aliasPreComments=JAMScript.call(this.parseComments,this,[]),limChar,v24171=this.currentToken,v21814=v24171.tokenId,v24172=TypeScript.TokenID,v21815=v24172.Identifier,v17202=v21814==v21815,v21818=!v17202;if(v21818)var v21816=this.currentToken,v21817=this.strictMode,v17202=JAMScript.call(TypeScript.convertTokToID,TypeScript,[v21816,v21817]);var v9370=v17202;if(v9370){var v21819=this.currentToken,v17203=v21819.tokenId,v21820=TypeScript.TokenID,v17204=v21820.Module,v9363=v17203==
v17204;if(v9363){var v9337=this.scanner;limChar=v9337.pos;var v9338=this.scanner,v27299=JAMScript.call(v9338.scan,v9338,[]),v21821=this.currentToken=v27299,v17205=v21821.tokenId,v21822=TypeScript.TokenID,v17206=v21822.OpenParen,v9358=v17205==v17206;if(v9358){var v9339=this.scanner,v27300=JAMScript.call(v9339.scan,v9339,[]),v24173=this.currentToken=v27300,v21823=v24173.tokenId,v24174=TypeScript.TokenID,v21824=v24174.StringLiteral,v17207=v21823==v21824,v21826=!v17207;if(v21826){var v25345=this.currentToken,
v24175=v25345.tokenId,v25346=TypeScript.TokenID,v24176=v25346.Identifier,v21825=v24175==v24176,v24179=!v21825;if(v24179)var v24177=this.currentToken,v24178=this.strictMode,v21825=JAMScript.call(TypeScript.convertTokToID,TypeScript,[v24177,v24178]);v17207=v21825}var v9353=v17207;if(v9353){var v21827=this.currentToken,v17208=v21827.tokenId,v21828=TypeScript.TokenID,v17209=v21828.StringLiteral,v9352=v17208==v17209;if(v9352){var v9341=this.topLevel;if(v9341)this.hasTopLevelImportOrExport=!0;else{var v17210=
this.allowImportDeclaration,v9340=!v17210;v9340&&JAMScript.call(this.reportParseError,this,["Import declaration of external module is permitted only in global or top level dynamic modules"])}var v9342=this.currentToken;JAMScript.call(v9342.getText,v9342,[]);var v9343=TypeScript.Identifier,v9344=this.currentToken,alias=JAMScript.call(v9343.fromToken,v9343,[v9344]),v9345=this.scanner;alias.minChar=v9345.startPos;var v9346=this.scanner;alias.limChar=v9346.pos;var v21829=alias.text,v17211=JAMScript.call(this.isValidImportPath,
this,[v21829]),v9347=!v17211;v9347&&JAMScript.call(this.reportParseError,this,["Invalid import path"]);var isDynamicImport=!0,v9348=this.scanner,v27301=JAMScript.call(v9348.scan,v9348,[]);this.currentToken=v27301}else var v21830=TypeScript.ErrorRecoverySet,v17212=v21830.SColon,v9349=errorRecoverySet|v17212,v17213=TypeScript.OperatorPrecedence,v9350=v17213.Assignment,v9351=TypeContext.NoTypes,alias=JAMScript.call(this.parseExpr,this,[v9349,v9350,!0,v9351]);alias.preComments=aliasPreComments}var v9354=
this.scanner;limChar=v9354.pos;var v17214=TypeScript.TokenID,v9355=v17214.CloseParen,v21831=TypeScript.ErrorRecoverySet,v17215=v21831.ID,v9356=errorRecoverySet|v17215;JAMScript.call(this.checkCurrentToken,this,[v9355,v9356]);if(alias){var v9357=alias,v27302=JAMScript.call(this.parseComments,this,[]);v9357.postComments=v27302}}}else{var v21832=TypeScript.ErrorRecoverySet,v17216=v21832.SColon,v9359=errorRecoverySet|v17216,v17217=TypeScript.OperatorPrecedence,v9360=v17217.Assignment,v9361=TypeContext.NoTypes,
alias=JAMScript.call(this.parseExpr,this,[v9359,v9360,!0,v9361]),v9362=this.scanner;limChar=v9362.pos}}else{JAMScript.call(this.reportParseError,this,["Expected module name"]);var v9364=TypeScript.MissingIdentifier,alias=JAMScript.new(v9364,[]),v9365=this.scanner;alias.minChar=v9365.startPos;var v21833=this.currentToken,v17218=v21833.tokenId,v21834=TypeScript.TokenID,v17219=v21834.Semicolon,v9369=v17218==v17219;if(v9369){var v9366=this.scanner;alias.limChar=v9366.startPos}else{var v9367=this.scanner;
alias.limChar=v9367.pos;var v9368=this.scanner,v27303=JAMScript.call(v9368.scan,v9368,[]);this.currentToken=v27303}var v17220=alias.flags,v21835=TypeScript.ASTFlags,v17221=v21835.Error;alias.flags=v17220|v17221;limChar=alias.limChar}var v9371=TypeScript.ImportDeclaration,importDecl=JAMScript.new(v9371,[name,alias]);importDecl.isDynamicImport=isDynamicImport;importDecl.minChar=minChar;importDecl.limChar=limChar;return importDecl}function v548(importPath){importPath=JAMScript.call(TypeScript.stripQuotes,
TypeScript,[importPath]);var v17222=!importPath,v21837=!v17222;v21837&&(v17222=importPath.indexOf(":"),v17222=-1!=v17222,v21837=!v17222)&&(v17222=importPath.indexOf("\\"),v17222=-1!=v17222,v21837=!v17222)&&(importPath=importPath.charAt(0),v17222="/"==importPath);return(importPath=v17222)?!1:!0}function v547(enclosedList){var v9373=this.scanner,v9373=this.currentToken=v9373=JAMScript.call(v9373.scan,v9373,[]),v9373=v9373.tokenId,v24184=TypeScript.TokenID,v24184=v24184.Identifier,v9373=v9373==v24184;
if(v24184=!v9373)v9373=this.currentToken,v24184=this.strictMode,v9373=JAMScript.call(TypeScript.convertTokToID,TypeScript,[v9373,v24184]);if(v9373){var v9373=TypeScript.Identifier,v24184=this.currentToken,v24184=v9373=JAMScript.call(v9373.fromToken,v9373,[v24184]),v27305=JAMScript.call(this.parseComments,this,[]);v24184.preComments=v27305;v24184=enclosedList.length;JAMScript.set(enclosedList,v24184,v9373);v24184=this.scanner;v9373.minChar=v24184.startPos;v24184=this.scanner;v9373.limChar=v24184.pos;
v9373=this.scanner;v9373=this.currentToken=v9373=JAMScript.call(v9373.scan,v9373,[]);v9373=v9373.tokenId;v24184=TypeScript.TokenID;v24184=v24184.Dot;(v9373=v9373==v24184)&&JAMScript.call(this.parseDottedName,this,[enclosedList])}else JAMScript.call(this.reportParseError,this,["need identifier after '.'"])}function v546(errorRecoverySet,modifiers){var v9383=this.scanner,leftCurlyCount=v9383.leftCurlyCount,v9384=this.scanner,rightCurlyCount=v9384.rightCurlyCount,name=null,v24185=this.currentToken,v21845=
v24185.tokenId,v24186=TypeScript.TokenID,v21846=v24186.Identifier,v17226=v21845==v21846,v21849=!v17226;if(v21849)var v21847=this.currentToken,v21848=this.strictMode,v17226=JAMScript.call(TypeScript.convertTokToID,TypeScript,[v21847,v21848]);var v9394=v17226;if(v9394){var v9385=TypeScript.Identifier,v9386=this.currentToken,name=JAMScript.call(v9385.fromToken,v9385,[v9386]),v9387=this.scanner;name.minChar=v9387.startPos;var v9388=this.scanner;name.limChar=v9388.pos;var v9389=this.scanner,v27307=JAMScript.call(v9389.scan,
v9389,[]);this.currentToken=v27307}else{JAMScript.call(this.reportParseError,this,["Enum declaration requires identifier"]);var v9393=this.errorRecovery;if(v9393){var v9390=TypeScript.MissingIdentifier,name=JAMScript.new(v9390,[]),v9391=this.scanner;name.minChar=v9391.startPos;var v9392=this.scanner;name.limChar=v9392.startPos;var v17227=name.flags,v21850=TypeScript.ASTFlags,v17228=v21850.Error;name.flags=v17227|v17228}}var v9395=this.scanner,membersMinChar=v9395.startPos,v17229=TypeScript.TokenID,
v9396=v17229.OpenBrace,v21851=TypeScript.ErrorRecoverySet,v17230=v21851.ID,v9397=errorRecoverySet|v17230;JAMScript.call(this.checkCurrentToken,this,[v9396,v9397]);JAMScript.call(this.pushDeclLists,this,[]);var v9398=TypeScript.ASTList,members=JAMScript.new(v9398,[]);members.minChar=membersMinChar;var v9399=TypeScript.VarDecl,v17231=TypeScript.Identifier,v9400=JAMScript.new(v17231,["_map"]),mapDecl=JAMScript.new(v9399,[v9400,0]),v17232=mapDecl.varFlags,v21852=TypeScript.VarFlags,v17233=v21852.Exported;
mapDecl.varFlags=v17232|v17233;var v17234=mapDecl.varFlags,v21853=TypeScript.VarFlags,v17235=v21853.Private;mapDecl.varFlags=v17234|v17235;var v17236=mapDecl.varFlags,v24187=TypeScript.VarFlags,v21854=v24187.Property,v24188=TypeScript.VarFlags,v21855=v24188.Public,v17237=v21854|v21855;mapDecl.varFlags=v17236|v17237;var v9401=mapDecl,v17238=TypeScript.UnaryExpression,v21856=TypeScript.NodeType,v17239=v21856.ArrayLit,v27308=JAMScript.new(v17238,[v17239,null]);v9401.init=v27308;JAMScript.call(members.append,
members,[mapDecl]);for(var lastValue=null;;){var v9402=this.scanner,minChar=v9402.startPos,limChar,memberName=null,memberValue=null,preComments=null,postComments=null,v24189=this.currentToken,v21857=v24189.tokenId,v24190=TypeScript.TokenID,v21858=v24190.Identifier,v17240=v21857==v21858,v21860=!v17240;if(v21860)var v21859=this.currentToken,v17240=JAMScript.call(TypeScript.convertTokToIDName,TypeScript,[v21859]);var v9412=v17240;if(v9412){var v9403=TypeScript.Identifier,v9404=this.currentToken,memberName=
JAMScript.call(v9403.fromToken,v9403,[v9404]),v9405=this.scanner;memberName.minChar=v9405.startPos;var v9406=this.scanner;memberName.limChar=v9406.pos}else{var v21861=this.currentToken,v17241=v21861.tokenId,v21862=TypeScript.TokenID,v17242=v21862.CloseBrace,v9411=v17241==v17242;if(v9411)break;else{JAMScript.call(this.reportParseError,this,["Expected identifer of enum member"]);var v9410=this.errorRecovery;if(v9410){var v9407=TypeScript.MissingIdentifier,memberName=JAMScript.new(v9407,[]),v9408=this.scanner;
memberName.minChar=v9408.startPos;var v9409=this.scanner;memberName.limChar=v9409.startPos;var v17243=memberName.flags,v21863=TypeScript.ASTFlags,v17244=v21863.Error;memberName.flags=v17243|v17244}}}var v9413=this.scanner;limChar=v9413.pos;var preComments=JAMScript.call(this.parseComments,this,[]),v9414=this.scanner,v27309=JAMScript.call(v9414.scan,v9414,[]);this.currentToken=v27309;var postComments=JAMScript.call(this.parseComments,this,[]),v21864=this.currentToken,v17245=v21864.tokenId,v21865=TypeScript.TokenID,
v17246=v21865.Equals,v9426=v17245==v17246;if(v9426){var v9415=this.scanner,v27310=JAMScript.call(v9415.scan,v9415,[]);this.currentToken=v27310;var v17247=TypeScript.OperatorPrecedence,v9416=v17247.Comma,v9417=TypeContext.NoTypes,lastValue=memberValue=JAMScript.call(this.parseExpr,this,[errorRecoverySet,v9416,!0,v9417]);limChar=memberValue.limChar}else{var v9421=null==lastValue;if(v9421)var v9418=TypeScript.NumberLiteral,memberValue=JAMScript.new(v9418,[0]);else var v9419=TypeScript.NumberLiteral,
v17248=lastValue.value,v9420=v17248+1,memberValue=JAMScript.new(v9419,[v9420]);var lastValue=memberValue,v9422=TypeScript.BinaryExpression,v17249=TypeScript.NodeType,v9423=v17249.Asg,v17250=TypeScript.BinaryExpression,v21866=TypeScript.NodeType,v17251=v21866.Index,v21867=TypeScript.Identifier,v17252=JAMScript.new(v21867,["_map"]),v9424=JAMScript.new(v17250,[v17251,v17252,memberValue]),v17253=TypeScript.StringLiteral,v24191=memberName.actualText,v21868='"'+v24191,v17254=v21868+'"',v9425=JAMScript.new(v17253,
[v17254]),map=JAMScript.new(v9422,[v9423,v9424,v9425]);JAMScript.call(members.append,members,[map])}var v9427=TypeScript.VarDecl,v9428=this.nestingLevel,member=JAMScript.new(v9427,[memberName,v9428]);member.minChar=minChar;member.limChar=limChar;member.init=memberValue;var v9429=member,v17255=TypeScript.TypeReference,v21869=name.actualText,v21870=name.hasEscapeSequence,v17256=JAMScript.call(this.createRef,this,[v21869,v21870,-1]),v27311=JAMScript.new(v17255,[v17256,0]);v9429.typeExpr=v27311;var v17257=
member.varFlags,v24192=TypeScript.VarFlags,v21871=v24192.Readonly,v24193=TypeScript.VarFlags,v21872=v24193.Property,v17258=v21871|v21872;member.varFlags=v17257|v17258;var v17259=memberValue.nodeType,v21873=TypeScript.NodeType,v17260=v21873.NumberLit,v9430=v17259==v17260;if(v9430){var v17261=member.varFlags,v21874=TypeScript.VarFlags,v17262=v21874.Constant;member.varFlags=v17261|v17262}member.preComments=preComments;JAMScript.call(members.append,members,[member]);member.postComments=postComments;var v17263=
member.varFlags,v21875=TypeScript.VarFlags,v17264=v21875.Exported;member.varFlags=v17263|v17264;var v21876=this.currentToken,v17265=v21876.tokenId,v21877=TypeScript.TokenID,v17266=v21877.Comma,v9434=v17265==v17266;if(v9434){var v9431=this.scanner,v27312=JAMScript.call(v9431.scan,v9431,[]);this.currentToken=v27312;var v9432=member,v17267=member.postComments,v24194=this.scanner,v21878=v24194.prevLine,v17268=JAMScript.call(this.parseCommentsForLine,this,[v21878]),v27313=JAMScript.call(this.combineComments,
this,[v17267,v17268]);v9432.postComments=v27313;var v24195=this.currentToken,v21879=v24195.tokenId,v24196=TypeScript.TokenID,v21880=v24196.Identifier,v17269=v21879==v21880,v21882=!v17269;if(v21882)var v21881=this.currentToken,v17269=JAMScript.call(TypeScript.convertTokToIDName,TypeScript,[v21881]);var v9433=v17269;if(v9433)continue}break}var v9435=TypeScript.ASTSpan,endingToken=JAMScript.new(v9435,[]),v9436=this.scanner;endingToken.minChar=v9436.startPos;var v9437=this.scanner;endingToken.limChar=
v9437.pos;var v17270=TypeScript.TokenID,v9438=v17270.CloseBrace;JAMScript.call(this.checkCurrentToken,this,[v9438,errorRecoverySet]);var v9439=members,v17271=this.scanner,v27314=JAMScript.call(v17271.lastTokenLimChar,v17271,[]);v9439.limChar=v27314;var v9440=TypeScript.ModuleDeclaration,v9441=JAMScript.call(this.topVarList,this,[]),v9442=JAMScript.call(this.topScopeList,this,[]),modDecl=JAMScript.new(v9440,[name,members,v9441,v9442,endingToken]),v17272=modDecl.modFlags,v21883=TypeScript.ModuleFlags,
v17273=v21883.IsEnum;modDecl.modFlags=v17272|v17273;JAMScript.call(this.popDeclLists,this,[]);var v17274=this.scanner,v9443=v17274.leftCurlyCount;modDecl.leftCurlyCount=v9443-leftCurlyCount;var v17275=this.scanner,v9444=v17275.rightCurlyCount;modDecl.rightCurlyCount=v9444-rightCurlyCount;return modDecl}function v545(comment1,comment2){var v9446=null==comment1;return v9446?comment2:(v9446=null==comment2)?comment1:comment1.concat(comment2)}function v544(line){var v9447=this.scanner;line=JAMScript.call(v9447.getCommentsForLine,
v9447,[line]);return JAMScript.call(this.parseCommentsInner,this,[line])}function v543(){var v9448=this.scanner,v9448=JAMScript.call(v9448.getComments,v9448,[]);return JAMScript.call(this.parseCommentsInner,this,[v9448])}function v542(comments){if(comments){for(var commentASTs=[],i=0,v17276=comments.length,v17276=i<v17276;v17276;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17276=comments[i];v17276=JAMScript.call(this.parseComment,this,[v17276]);JAMScript.call(commentASTs.push,
commentASTs,[v17276]);i+=1;v17276=comments.length;v17276=i<v17276}return commentASTs}return null}function v541(comment){if(comment){var v9451=TypeScript.Comment,v9452=comment.value,v9453=comment.isBlock,v9454=comment.endsLine,v9451=JAMScript.new(v9451,[v9452,v9453,v9454]),v9452=v9451.minChar=comment.startPos,v9453=comment.value,v9453=v9453.length;v9451.limChar=v9452+v9453;v9452={line:-1,col:-1};v9453=v9451.minChar;JAMScript.call(this.getSourceLineCol,this,[v9452,v9453]);v9451.minLine=v9452.line;v9453=
v9451.limChar;JAMScript.call(this.getSourceLineCol,this,[v9452,v9453]);v9451.limLine=v9452.line;v9452=comment.isBlock;if(v9452=!v9452)if(v9452=comment.value,v9452=v9452.length,v9452=3<v9452)v9452=comment.value,v9452=JAMScript.call(v9452.substring,v9452,[0,3]),v9452="///"==v9452;if(v9452){v9452=comment.value;if(v9452=JAMScript.call(TypeScript.getAdditionalDependencyPath,TypeScript,[v9452]))v9453=this.amdDependencies,JAMScript.call(v9453.push,v9453,[v9452]);comment=comment.value;if(comment=JAMScript.call(TypeScript.getImplicitImport,
TypeScript,[comment]))this.hasTopLevelImportOrExport=!0}return v9451}return null}function v540(){var v9463=this.staticsLists,v21886=this.staticsLists,v21886=v21886.length,v21886=v21886-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v9463[v21886]}function v539(){var v9465=this.scopeLists,v21887=this.scopeLists,v21887=v21887.length,v21887=v21887-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v9465[v21887]}function v538(){var v9467=
this.varLists,v21888=this.varLists,v21888=v21888.length,v21888=v21888-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v9467[v21888]}function v537(){var v9469=this.staticsLists;JAMScript.call(v9469.pop,v9469,[]);v9469=this.varLists;JAMScript.call(v9469.pop,v9469,[]);v9469=this.scopeLists;JAMScript.call(v9469.pop,v9469,[])}function v536(){var v9472=this.staticsLists,v17285=TypeScript.ASTList,v17285=JAMScript.new(v17285,[]);JAMScript.call(v9472.push,v9472,
[v17285]);v9472=this.varLists;v17285=TypeScript.ASTList;v17285=JAMScript.new(v17285,[]);JAMScript.call(v9472.push,v9472,[v17285]);v9472=this.scopeLists;v17285=TypeScript.ASTList;v17285=JAMScript.new(v17285,[]);JAMScript.call(v9472.push,v9472,[v17285])}function v535(tokenId,errorRecoverySet,errorText){var v17288=typeof errorText;(v17288="undefined"===v17288)&&(errorText=null);v17288=this.currentToken;v17288=v17288.tokenId;if(v17288=v17288!=tokenId){if(v17288=null==errorText){errorText=TypeScript.tokenTable;
introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)tokenId=errorText[tokenId];tokenId=tokenId.text;tokenId="Expected '"+tokenId;tokenId+="'"}else tokenId=errorText;errorText=tokenId;JAMScript.call(this.reportParseError,this,[errorText]);(tokenId=this.errorRecovery)&&JAMScript.call(this.skip,this,[errorRecoverySet])}else errorRecoverySet=this.scanner,this.currentToken=errorRecoverySet=JAMScript.call(errorRecoverySet.scan,errorRecoverySet,[])}function v534(errorRecoverySet){var v21891=
TypeScript.ErrorRecoverySet,v21891=v21891.EOF;errorRecoverySet|=v21891;var v21891=TypeScript.ErrorRecoverySet,ersTok=v21891.None,v21891=this.currentToken,v21891=v21891.tokenId,tokenInfo=JAMScript.call(TypeScript.lookupToken,TypeScript,[v21891]);if(v21891=void 0!=tokenInfo)ersTok=tokenInfo.ers;v21891=0;ersTok&=errorRecoverySet;tokenInfo=TypeScript.ErrorRecoverySet;tokenInfo=tokenInfo.None;ersTok=ersTok==tokenInfo;if(tokenInfo=!ersTok)ersTok=this.currentToken,ersTok=ersTok.tokenId,tokenInfo=TypeScript.TokenID,
tokenInfo=tokenInfo.CloseBrace,(ersTok=ersTok==tokenInfo)&&(ersTok=0<v21891);for(;ersTok;){ersTok=this.currentToken;ersTok=ersTok.tokenId;tokenInfo=TypeScript.TokenID;tokenInfo=tokenInfo.OpenBrace;(ersTok=ersTok==tokenInfo)?v21891+=1:(ersTok=this.currentToken,ersTok=ersTok.tokenId,tokenInfo=TypeScript.TokenID,tokenInfo=tokenInfo.CloseBrace,(ersTok=ersTok==tokenInfo)&&(v21891-=1));ersTok=this.scanner;this.currentToken=ersTok=JAMScript.call(ersTok.scan,ersTok,[]);var ersTok=TypeScript.ErrorRecoverySet,
ersTok=ersTok.None,tokenInfo=this.currentToken,tokenInfo=tokenInfo.tokenId,tokenInfo=JAMScript.call(TypeScript.lookupToken,TypeScript,[tokenInfo]),v9491=void 0!=tokenInfo;v9491&&(ersTok=tokenInfo.ers);ersTok&=errorRecoverySet;tokenInfo=TypeScript.ErrorRecoverySet;tokenInfo=tokenInfo.None;ersTok=ersTok==tokenInfo;if(tokenInfo=!ersTok)ersTok=this.currentToken,ersTok=ersTok.tokenId,tokenInfo=TypeScript.TokenID,tokenInfo=tokenInfo.CloseBrace,(ersTok=ersTok==tokenInfo)&&(ersTok=0<v21891)}}function v533(tokenId,
errorRecoverySet,errorText){var v17301=typeof errorText;(v17301="undefined"===v17301)&&(errorText=null);v17301=this.scanner;this.currentToken=v17301=JAMScript.call(v17301.scan,v17301,[]);JAMScript.call(this.checkCurrentToken,this,[tokenId,errorRecoverySet,errorText])}function v532(message,startPos,pos){var v17302=typeof startPos;if(v17302="undefined"===v17302)startPos=this.scanner,startPos=startPos.startPos;v17302=typeof pos;if(v17302="undefined"===v17302)pos=this.scanner,pos=pos.pos;pos-=startPos;
pos=JAMScript.call(Math.max,Math,[1,pos]);if(v17302=this.errorCallback)v17302=this.currentUnitIndex,JAMScript.call(this.errorCallback,this,[startPos,pos,message,v17302]);else if(pos=this.errorRecovery){if(pos={line:-1,col:-1},JAMScript.call(this.getSourceLineCol,this,[pos,startPos]),startPos=this.outfile){startPos=this.outfile;var v17302=this.fname,v17302="// "+v17302,v17302=v17302+" (",v26025=pos.line,v17302=v17302+v26025,v17302=v17302+",";pos=pos.col;pos=v17302+pos;pos+="): ";message=pos+message;
JAMScript.call(startPos.WriteLine,startPos,[message])}}else throw startPos=this.fname,startPos+=" (",pos=this.scanner,pos=pos.line,startPos+=pos,startPos+=",",pos=this.scanner,pos=pos.col,startPos+=pos,startPos+="): ",message=startPos+message,new SyntaxError(message);}function v531(message){message="STYLE: "+message;JAMScript.call(this.reportParseError,this,[message])}function v530(text,hasEscapeSequence,minChar){var v9508=TypeScript.Identifier;text=JAMScript.new(v9508,[text,hasEscapeSequence]);text.minChar=
minChar;return text}function v529(lineCol,minChar){var v17306=this.scanner,v17306=v17306.lineMap;JAMScript.call(TypeScript.getSourceLineColFromMap,TypeScript,[lineCol,minChar,v17306])}function v528(outfile){this.outfile=outfile;this.errorRecovery=!0}function v527(jump){for(var v9510=TypeScript.AST,v9511=jump.target,v9510=JAMScript.call(v9510.getResolvedIdentifierName,v9510,[v9511]),v9511=this.statementInfoStack,v9511=v9511.length,v9511=v9511-1,v9525=0<=v9511;v9525;){v9525=this.statementInfoStack;
introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v9525=v9525[v9511];var v9524=jump.target;if(v9524){if(v9524=v9525.labels)v9524=v9525.labels,v9524=v9524.members,v9524=v9524.length,v9524=0<v9524;if(v9524)for(var v9524=0,v17308=v9525.labels,v17308=v17308.members,v17308=v17308.length,v9518=v9524<v17308;v9518;){v9518=v9525.labels;v9518=v9518.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v9518=v9518[v9524];v9518=v9518.id;v9518=
v9518.text;if(v9518=v9518==v9510){v9510=v9525.stmt;JAMScript.call(jump.setResolvedTarget,jump,[this,v9510]);return}v9524+=1;v9518=v9524<v17308}}else{v9524=v9525.stmt;if(v9524=JAMScript.call(v9524.isLoop,v9524,[])){v9510=v9525.stmt;JAMScript.call(jump.setResolvedTarget,jump,[this,v9510]);return}v9524=v9525.stmt;v9524=v9524.nodeType;v17308=TypeScript.NodeType;v17308=v17308.Switch;if(v9524=v9524==v17308)v9524=jump.nodeType,v17308=TypeScript.NodeType,v17308=v17308.Break,v9524=v9524==v17308;if(v9524){v9510=
v9525.stmt;JAMScript.call(jump.setResolvedTarget,jump,[this,v9510]);return}}v9511-=1;v9525=0<=v9511}(v9510=jump.target)?(jump=jump.target,jump="could not find enclosing statement with label "+jump,JAMScript.call(this.reportParseError,this,[jump])):(jump=jump.nodeType,v9510=TypeScript.NodeType,v9510=v9510.Break,(jump=jump==v9510)?JAMScript.call(this.reportParseError,this,["break statement requires enclosing loop or switch"]):JAMScript.call(this.reportParseError,this,["continue statement requires enclosing loop"]))}
function v526(){var v9529=this.statementInfoStack;return JAMScript.call(v9529.pop,v9529,[])}function v525(stmt,labels){var info={stmt:stmt,labels:labels},v9530=this.statementInfoStack;JAMScript.call(v9530.push,v9530,[info])}function v524(){for(var v17316=this.statementInfoStack,v17316=v17316.length,v17316=v17316-1,v9533=0<=v17316;v9533;){v9533=this.statementInfoStack;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v9533=v9533[v17316];v9533=v9533.stmt;if(v9533=JAMScript.call(v9533.isLoop,
v9533,[]))return!0;v17316-=1;v9533=0<=v17316}return!1}function v523(){var v27318=[];this.statementInfoStack=v27318}function Parser(){this.varLists=[];this.scopeLists=[];this.staticsLists=[];var v9534=TypeScript.Scanner;this.scanner=v9534=JAMScript.new(v9534,[]);this.currentToken=null;this.inInterfaceDecl=this.inFunction=this.needTerminator=!1;this.currentClassDecl=null;this.inFncDecl=!1;v9534=TypeScript.Identifier;this.anonId=v9534=JAMScript.new(v9534,["_anonymous"]);this.style_requireSemi=!1;this.style_funcInLoop=
!0;this.errorRecovery=this.incremental=!1;this.outfile=void 0;this.errorCallback=null;this.state=ParseState.StartStatementList;this.ambientClass=this.ambientModule=!1;this.allowImportDeclaration=this.topLevel=!0;this.currentUnitIndex=-1;this.prevIDTok=null;this.statementInfoStack=v9534=[];this.strictMode=this.hasTopLevelImportOrExport=!1;this.nestingLevel=0;this.currentClassDefinition=this.prevExpr=null;this.parsingDeclareFile=this.parsingClassConstructorDefinition=!1;this.amdDependencies=[];this.requiresExtendsBlock=
this.inferPropertiesFromThisAssignment=!1;this.fname=""}var v9536=Parser.prototype;v9536.resetStmtStack=v523;var v9537=Parser.prototype;v9537.inLoop=v524;var v9538=Parser.prototype;v9538.pushStmt=v525;var v9539=Parser.prototype;v9539.popStmt=v526;var v9540=Parser.prototype;v9540.resolveJumpTarget=v527;var v9541=Parser.prototype;v9541.setErrorRecovery=v528;var v9542=Parser.prototype;v9542.getSourceLineCol=v529;var v9543=Parser.prototype;v9543.createRef=v530;var v9544=Parser.prototype;v9544.reportParseStyleError=
v531;var v9545=Parser.prototype;v9545.reportParseError=v532;var v9546=Parser.prototype;v9546.checkNextToken=v533;var v9547=Parser.prototype;v9547.skip=v534;var v9548=Parser.prototype;v9548.checkCurrentToken=v535;var v9549=Parser.prototype;v9549.pushDeclLists=v536;var v9550=Parser.prototype;v9550.popDeclLists=v537;var v9551=Parser.prototype;v9551.topVarList=v538;var v9552=Parser.prototype;v9552.topScopeList=v539;var v9553=Parser.prototype;v9553.topStaticsList=v540;var v9554=Parser.prototype;v9554.parseComment=
v541;var v9555=Parser.prototype;v9555.parseCommentsInner=v542;var v9556=Parser.prototype;v9556.parseComments=v543;var v9557=Parser.prototype;v9557.parseCommentsForLine=v544;var v9558=Parser.prototype;v9558.combineComments=v545;var v9559=Parser.prototype;v9559.parseEnumDecl=v546;var v9560=Parser.prototype;v9560.parseDottedName=v547;var v9561=Parser.prototype;v9561.isValidImportPath=v548;var v9562=Parser.prototype;v9562.parseImportDeclaration=v549;var v9563=Parser.prototype;v9563.parseModuleDecl=v550;
var v9564=Parser.prototype;v9564.parseTypeReferenceTail=v551;var v9565=Parser.prototype;v9565.parseNamedType=v552;var v9566=Parser.prototype;v9566.parseTypeReference=v553;var v9567=Parser.prototype;v9567.parseObjectType=v554;var v9568=Parser.prototype;v9568.parseFunctionBlock=v555;var v9569=Parser.prototype;v9569.parseFunctionStatements=v556;var v9570=Parser.prototype;v9570.transformAnonymousArgsIntoFormals=v557;var v9571=Parser.prototype;v9571.parseFormalParameterList=v558;var v9572=Parser.prototype;
v9572.parseFncDecl=v559;var v9573=Parser.prototype;v9573.convertToTypeReference=v560;var v9574=Parser.prototype;v9574.parseArgList=v561;var v9575=Parser.prototype;v9575.parseBaseList=v562;var v9576=Parser.prototype;v9576.parseClassDecl=v563;var v9577=Parser.prototype;v9577.parseClassElements=v564;var v9578=Parser.prototype;v9578.parseClassConstructorDeclaration=v565;var v9579=Parser.prototype;v9579.parseClassMemberVariableDeclaration=v566;var v9580=Parser.prototype;v9580.parseClassMemberFunctionDeclaration=
v567;var v9581=Parser.prototype;v9581.parseTypeMember=v568;var v9582=Parser.prototype;v9582.parseTypeMemberList=v569;var v9583=Parser.prototype;v9583.parseInterfaceDecl=v570;var v9584=Parser.prototype;v9584.makeVarDecl=v571;var v9585=Parser.prototype;v9585.parsePropertyDeclaration=v572;var v9586=Parser.prototype;v9586.parseVariableDeclaration=v573;var v9587=Parser.prototype;v9587.parseMemberList=v574;var v9588=Parser.prototype;v9588.parseArrayList=v575;var v9589=Parser.prototype;v9589.parseArrayLiteral=
v576;var v9590=Parser.prototype;v9590.parseTerm=v577;var v9591=Parser.prototype;v9591.parseLambdaExpr=v578;var v9592=Parser.prototype;v9592.parseExpr=v579;var v9593=Parser.prototype;v9593.parsePostfixOperators=v580;var v9594=Parser.prototype;v9594.parseTry=v581;var v9595=Parser.prototype;v9595.parseCatch=v582;var v9596=Parser.prototype;v9596.parseFinally=v583;var v9597=Parser.prototype;v9597.parseTryCatchFinally=v584;var v9598=Parser.prototype;v9598.parseStatement=v585;var v9599=Parser.prototype;
v9599.okAmbientModuleMember=v586;var v9600=Parser.prototype;v9600.parseStatementList=v587;var v9601=Parser.prototype;v9601.quickParse=v588;var v9602=Parser.prototype;v9602.parse=v590;return Parser}function v522(){function QuickParseResult(Script,endLexState){this.Script=Script;this.endLexState=endLexState}return QuickParseResult}function v521(ParseState){ParseState._map=[];var v9603=ParseState._map;v9603[0]="None";ParseState.None=0;v9603=ParseState._map;v9603[1]="StartScript";ParseState.StartScript=
1;v9603=ParseState._map;v9603[2]="StartStatementList";ParseState.StartStatementList=2;v9603=ParseState._map;v9603[3]="StartStatement";ParseState.StartStatement=3;v9603=ParseState._map;v9603[4]="StartFncDecl";ParseState.StartFncDecl=4;v9603=ParseState._map;v9603[5]="FncDeclName";ParseState.FncDeclName=5;v9603=ParseState._map;v9603[6]="FncDeclArgs";ParseState.FncDeclArgs=6;v9603=ParseState._map;v9603[7]="FncDeclReturnType";ParseState.FncDeclReturnType=7;v9603=ParseState._map;v9603[8]="ForInit";ParseState.ForInit=
8;v9603=ParseState._map;v9603[9]="ForInitAfterVar";ParseState.ForInitAfterVar=9;v9603=ParseState._map;v9603[10]="ForCondStart";ParseState.ForCondStart=10;v9603=ParseState._map;v9603[11]="EndStmtList";ParseState.EndStmtList=11;v9603=ParseState._map;v9603[12]="EndScript";ParseState.EndScript=12}function v520(TypeContext){TypeContext._map=[];TypeContext.NoTypes=0;TypeContext.ArraySuffix=1;TypeContext.Primitive=2;TypeContext.Named=4;var v9616=TypeContext.Primitive,v9617=TypeContext.Named;TypeContext.AllSimpleTypes=
v9616|v9617;v9616=TypeContext.Primitive;v9617=TypeContext.Named;v9616|=v9617;v9617=TypeContext.ArraySuffix;TypeContext.AllTypes=v9616|v9617}function quickParse(logger,scopeStartAST,sourceText,minChar,limChar,errorCapture){scopeStartAST=JAMScript.call(sourceText.getText,sourceText,[minChar,limChar]);minChar="Quick parse range ("+minChar;minChar+=",";limChar=minChar+limChar;limChar+='): "';minChar=JAMScript.call(TypeScript.stringToLiteral,TypeScript,[scopeStartAST,100]);limChar+=minChar;limChar+='"';
JAMScript.call(logger.log,logger,[limChar]);logger=JAMScript.new(Parser,[]);JAMScript.call(logger.setErrorRecovery,logger,[null]);logger.errorCallback=errorCapture;errorCapture=TypeScript.ClassDeclaration;errorCapture=JAMScript.new(errorCapture,[null,null,null,null]);logger.currentClassDecl=errorCapture;errorCapture=TypeScript.StringSourceText;scopeStartAST=JAMScript.new(errorCapture,[scopeStartAST]);return scopeStartAST=JAMScript.call(logger.quickParse,logger,[scopeStartAST,"",0])}var v17322=TypeScript.TypeContext,
v21916=!v17322;v21916&&(v17322=TypeScript.TypeContext={});v520(v17322);var TypeContext=TypeScript.TypeContext,v17322=TypeScript.ParseState;if(v21916=!v17322)v17322=TypeScript.ParseState={};v521(v17322);var ParseState=TypeScript.ParseState,QuickParseResult=v522();TypeScript.QuickParseResult=QuickParseResult;var Parser=v591();TypeScript.Parser=Parser;TypeScript.quickParse=quickParse}
function v519(){var TypeScript=v12353;function v518(){function v517(ast,op,type){op="Operator '"+op;op+="' cannot be applied to type '";type=JAMScript.call(type.getTypeName,type,[]);type=op+type;type+="'";JAMScript.call(this.reportError,this,[ast,type])}function v516(ast){JAMScript.call(this.simpleError,this,[ast,"Expected var, class, interface, or module"])}function v515(ast,t1,t2,op,scope,comparisonInfo){var v9627=!t1;v9627&&(t1=this.checker,t1=t1.anyType);if(v9627=!t2)t2=this.checker,t2=t2.anyType;
comparisonInfo=comparisonInfo?comparisonInfo.message:"";op?(op="Operator '"+op,op+="' cannot be applied to types '",t1=JAMScript.call(t1.getScopedTypeName,t1,[scope]),t1=op+t1,t1+="' and '"):(t1=JAMScript.call(t1.getScopedTypeName,t1,[scope]),t1="Cannot convert '"+t1,t1+="' to '");scope=JAMScript.call(t2.getScopedTypeName,t2,[scope]);scope=t1+scope;scope+="'";comparisonInfo=comparisonInfo?": "+comparisonInfo:"";scope+=comparisonInfo;JAMScript.call(this.reportError,this,[ast,scope])}function v514(ast,
scope){var v17329=ast.operand1,v17329=v17329.type,v17329=JAMScript.call(v17329.getScopedTypeName,v17329,[scope]),v17330=ast.operand2,v17330=v17330.type,v17330=JAMScript.call(v17330.getScopedTypeName,v17330,[scope]),v17329="Value of type '"+v17329,v17329=v17329+"' is not indexable by type '",v17329=v17329+v17330,v17329=v17329+"'";JAMScript.call(this.simpleError,this,[ast,v17329])}function v513(ast,nodeType,scope){var v9636=ast.target,v9636=v9636.type;scope=JAMScript.call(v9636.getScopedTypeName,v9636,
[scope]);if(v9636=v9636.construct)v9636=TypeScript.NodeType,v9636=v9636.Call,v9636=nodeType==v9636;v9636?(scope="Value of type '"+scope,scope+="' is not callable.  Did you mean to include 'new'?"):(v9636=TypeScript.NodeType,v9636=v9636.Call,nodeType=(nodeType=nodeType==v9636)?"callable":"newable",scope="Value of type '"+scope,scope+="' is not ",scope+=nodeType);JAMScript.call(this.reportError,this,[ast,scope])}function v512(ast){JAMScript.call(this.simpleError,this,[ast,"The left-hand side of an assignment expression must be a variable, property or indexer"])}
function v511(ast){JAMScript.call(this.simpleError,this,[ast,"Keyword 'super' can only be used inside a class instance method"])}function v510(sym,msg){JAMScript.call(this.reportErrorFromSym,this,[sym,msg])}function v509(ast,msg){JAMScript.call(this.reportError,this,[ast,msg])}function v508(ast,msg){var bkThrow=this.pushToErrorSink;this.pushToErrorSink=!1;var v9641="STYLE: "+msg;JAMScript.call(this.reportError,this,[ast,v9641]);this.pushToErrorSink=bkThrow}function v507(ast,name){var v17336="The name '"+
name,v17336=v17336+"' does not refer to a value";JAMScript.call(this.reportError,this,[ast,v17336])}function v506(ast,name){var v17337="The name '"+name,v17337=v17337+"' does not exist in the current scope";JAMScript.call(this.reportError,this,[ast,v17337])}function v505(ast,text,symbol){var defLineCol={line:-1,col:-1},v9644=this.parser;symbol=symbol.location;JAMScript.call(v9644.getSourceLineCol,v9644,[defLineCol,symbol]);text="symbol "+text;text+=" defined at (";v9644=defLineCol.line;text+=v9644;
text+=",";defLineCol=defLineCol.col;defLineCol=text+defLineCol;defLineCol+=")";JAMScript.call(this.reportError,this,[ast,defLineCol])}function v504(ast,name){var v17339="Duplicate identifier '"+name,v17339=v17339+"'";JAMScript.call(this.reportError,this,[ast,v17339])}function v503(ast,message){JAMScript.call(this.reportError,this,[ast,message]);throw Error("EmitError");}function v502(symbol,message){var v9648=this.pushToErrorSink;if(v9648)JAMScript.call(this.captureError,this,[message]);else{this.hasErrors=
!0;v9648=this.parser;if(v9648=v9648.errorRecovery)v9648=this.parser,v9648=v9648.errorCallback;if(v9648){var v9648=this.parser,v9650=symbol.location,v9651=symbol.length,v21932=this.checker,v21932=v21932.locationInfo,v21932=v21932.unitIndex;JAMScript.call(v9648.errorCallback,v9648,[v9650,v9651,message,v21932])}else JAMScript.call(this.writePrefixFromSym,this,[symbol]),v9648=this.outfile,JAMScript.call(v9648.WriteLine,v9648,[message])}}function v501(ast,message){var v9655=this.pushToErrorSink;if(v9655)JAMScript.call(this.captureError,
this,[message]);else{this.hasErrors=!0;if(v9655=ast)if(v9655=this.parser,v9655=v9655.errorRecovery)v9655=this.parser,v9655=v9655.errorCallback;if(v9655){var v9655=ast.limChar,v9657=ast.minChar,v9655=v9655-v9657,v9657=this.parser,v9659=ast.minChar,v21934=this.checker,v21934=v21934.locationInfo,v21934=v21934.unitIndex;JAMScript.call(v9657.errorCallback,v9657,[v9659,v9655,message,v21934])}else JAMScript.call(this.writePrefix,this,[ast]),v9655=this.outfile,JAMScript.call(v9655.WriteLine,v9655,[message])}}
function v500(ast){if(ast){var v17344=ast.flags,v21935=TypeScript.ASTFlags,v21935=v21935.Error;ast.flags=v17344|v21935;v17344=this.checker;v17344=v17344.locationInfo;if(v17344=v17344.lineMap)v17344=this.lineCol,ast=ast.minChar,v21935=this.checker,v21935=v21935.locationInfo,v21935=v21935.lineMap,JAMScript.call(TypeScript.getSourceLineColFromMap,TypeScript,[v17344,ast,v21935])}}function v499(symbol){var v17348=symbol;v17348&&(v17348=this.checker,v17348=v17348.locationInfo,v17348=v17348.lineMap);if(v17348){v17348=
this.lineCol;symbol=symbol.location;var v21939=this.checker,v21939=v21939.locationInfo,v21939=v21939.lineMap;JAMScript.call(TypeScript.getSourceLineColFromMap,TypeScript,[v17348,symbol,v21939])}else symbol=this.lineCol,symbol.line=-1,symbol=this.lineCol,symbol.col=-1;JAMScript.call(this.emitPrefix,this,[])}function v498(ast){ast?JAMScript.call(this.setError,this,[ast]):(ast=this.lineCol,ast.line=0,ast=this.lineCol,ast.col=0);JAMScript.call(this.emitPrefix,this,[])}function v497(){var v9676=this.emitAsComments;
v9676&&(v9676=this.outfile,JAMScript.call(v9676.Write,v9676,["// "]));var v9676=this.outfile,v26573=this.checker,v26573=v26573.locationInfo,v26573=v26573.filename,v26573=v26573+"(",v26034=this.lineCol,v26034=v26034.line,v26573=v26573+v26034,v26573=v26573+",",v26034=this.lineCol,v26034=v26034.col,v26573=v26573+v26034,v26573=v26573+"): ";JAMScript.call(v9676.Write,v9676,[v26573])}function v496(outerr){this.outfile=outerr;this.emitAsComments=!1}function v495(emsg){var v9679=this.errorSink,v17351=this.errorSink,
v17351=v17351.length;JAMScript.set(v9679,v17351,emsg)}function v494(){this.errorSink=[]}function v493(){return this.errorSink}function ErrorReporter(outfile){this.outfile=outfile;this.checker=this.parser=null;this.lineCol={line:0,col:0};this.emitAsComments=!0;this.pushToErrorSink=this.hasErrors=!1;this.errorSink=[]}var v9681=ErrorReporter.prototype;v9681.getCapturedErrors=v493;v9681=ErrorReporter.prototype;v9681.freeCapturedErrors=v494;v9681=ErrorReporter.prototype;v9681.captureError=v495;v9681=ErrorReporter.prototype;
v9681.setErrOut=v496;v9681=ErrorReporter.prototype;v9681.emitPrefix=v497;v9681=ErrorReporter.prototype;v9681.writePrefix=v498;v9681=ErrorReporter.prototype;v9681.writePrefixFromSym=v499;v9681=ErrorReporter.prototype;v9681.setError=v500;v9681=ErrorReporter.prototype;v9681.reportError=v501;v9681=ErrorReporter.prototype;v9681.reportErrorFromSym=v502;v9681=ErrorReporter.prototype;v9681.emitterError=v503;v9681=ErrorReporter.prototype;v9681.duplicateIdentifier=v504;v9681=ErrorReporter.prototype;v9681.showRef=
v505;v9681=ErrorReporter.prototype;v9681.unresolvedSymbol=v506;v9681=ErrorReporter.prototype;v9681.symbolDoesNotReferToAValue=v507;v9681=ErrorReporter.prototype;v9681.styleError=v508;v9681=ErrorReporter.prototype;v9681.simpleError=v509;v9681=ErrorReporter.prototype;v9681.simpleErrorFromSym=v510;v9681=ErrorReporter.prototype;v9681.invalidSuperReference=v511;v9681=ErrorReporter.prototype;v9681.valueCannotBeModified=v512;v9681=ErrorReporter.prototype;v9681.invalidCall=v513;v9681=ErrorReporter.prototype;
v9681.indexLHS=v514;v9681=ErrorReporter.prototype;v9681.incompatibleTypes=v515;v9681=ErrorReporter.prototype;v9681.expectedClassOrInterface=v516;v9681=ErrorReporter.prototype;v9681.unaryOperatorTypeError=v517;return ErrorReporter}var ErrorReporter=v518();TypeScript.ErrorReporter=ErrorReporter}
function v492(){var TypeScript=v12352;function v491(){function v490(fileName,useUTF8){try{var v17352=this.emitOptions,v9706=v17352.ioHost;return JAMScript.call(v9706.createFile,v9706,[fileName,useUTF8])}catch(ex){v17352=this.errorReporter,v9706=ex.message,JAMScript.call(v17352.emitterError,v17352,[null,v9706])}}function shouldCaptureThis(func){var v9709=JAMScript.call(func.hasSelfReference,func,[]),v17353=!v9709;v17353&&(v9709=JAMScript.call(func.hasSuperReferenceInFatArrowFunction,func,[]));return v9709}
function v489(){var v17354=this.thisFnc;v17354&&(v17354=this.thisFnc,v17354=JAMScript.call(v17354.isMethod,v17354,[]),v17354=!v17354)&&(v17354=this.thisFnc,v17354=v17354.isConstructor,v17354=!v17354);v17354?JAMScript.call(this.writeToOutput,this,["_this"]):JAMScript.call(this.writeToOutput,this,["this"])}function v488(callEx){var v21943=callEx.target,v21943=v21943.nodeType,v21944=TypeScript.NodeType,v21944=v21944.Dot;if(v21943=v21943==v21944){var v21943=callEx.target,v21944=v21943.operand1,v21944=
v21944.nodeType,v21946=TypeScript.NodeType,v21946=v21946.Super;if(v21944=v21944==v21946){v21944=TypeScript.TokenID;v21944=v21944.OpenParen;JAMScript.call(this.emitJavascript,this,[v21943,v21944,!1]);JAMScript.call(this.writeToOutput,this,[".call("]);JAMScript.call(this.emitThis,this,[]);if(v21943=callEx.arguments)v21943=callEx.arguments,v21943=v21943.members,v21943=v21943.length,v21943=0<v21943;v21943&&(JAMScript.call(this.writeToOutput,this,[", "]),callEx=callEx.arguments,v21943=TypeScript.TokenID,
v21943=v21943.Comma,JAMScript.call(this.emitJavascriptList,this,[callEx,", ",v21943,!1,!1,!1]));JAMScript.call(this.writeToOutput,this,[")"]);return!0}}return!1}function v487(){JAMScript.call(this.writeToOutput,this,["_super.prototype"])}function v486(reqInherits){var v17362=this.prologueEmitted;if(v17362=!v17362)if(reqInherits&&(this.prologueEmitted=!0,JAMScript.call(this.writeLineToOutput,this,["var __extends = this.__extends || function (d, b) {"]),JAMScript.call(this.writeLineToOutput,this,["    function __() { this.constructor = d; }"]),
JAMScript.call(this.writeLineToOutput,this,["    __.prototype = b.prototype;"]),JAMScript.call(this.writeLineToOutput,this,["    d.prototype = new __();"]),JAMScript.call(this.writeLineToOutput,this,["};"])),reqInherits=this.checker,reqInherits=reqInherits.mustCaptureGlobalThis)this.prologueEmitted=!0,reqInherits=this.captureThisStmtString,JAMScript.call(this.writeLineToOutput,this,[reqInherits])}function v485(classDecl){var v21948=classDecl.varFlags,v24233=TypeScript.VarFlags,v21949=v24233.Ambient,
v17364=JAMScript.call(TypeScript.hasFlag,TypeScript,[v21948,v21949]),v9769=!v17364;if(v9769){var svClassNode=this.thisClassNode,i=0;this.thisClassNode=classDecl;var v9720=classDecl.name,className=v9720.actualText;JAMScript.call(this.emitParensAndCommentsInPlace,this,[classDecl,!0]);var v9721=EmitContainer.Class,temp=JAMScript.call(this.setContainer,this,[v9721]);JAMScript.call(this.recordSourceMappingStart,this,[classDecl]);var v21950=classDecl.varFlags,v24234=TypeScript.VarFlags,v21951=v24234.Exported,
v17365=JAMScript.call(TypeScript.hasFlag,TypeScript,[v21950,v21951]);if(v17365)var v25371=classDecl.type,v24235=v25371.symbol,v21952=v24235.container,v24236=this.checker,v21953=v24236.gloMod,v17365=v21952==v21953;var v9724=v17365;if(v9724){var v9722="this."+className;JAMScript.call(this.writeToOutput,this,[v9722])}else{var v9723="var "+className;JAMScript.call(this.writeToOutput,this,[v9723])}var v9725=classDecl.extendsList;if(v9725)var v21954=classDecl.extendsList,v17366=v21954.members,v9725=v17366.length;
var hasBaseClass=v9725,baseNameDecl=null,baseName=null;hasBaseClass?JAMScript.call(this.writeLineToOutput,this,[" = (function (_super) {"]):JAMScript.call(this.writeLineToOutput,this,[" = (function () {"]);JAMScript.call(this.recordSourceMappingNameStart,this,[className]);var v9726=this.indenter;JAMScript.call(v9726.increaseIndent,v9726,[]);if(hasBaseClass){var v17367=classDecl.extendsList,v9727=v17367.members,baseNameDecl=v9727[0],v9728,v21955=baseNameDecl.nodeType,v24237=TypeScript.NodeType,v21956=
v24237.Call,v17368=v21955==v21956,baseName=v9728=v17368?baseNameDecl.target:baseNameDecl;JAMScript.call(this.emitIndent,this,[]);var v17369="__extends("+className,v9729=v17369+", _super);";JAMScript.call(this.writeLineToOutput,this,[v9729])}JAMScript.call(this.emitIndent,this,[]);var constrDecl=classDecl.constructorDecl;if(constrDecl){var v9730=classDecl.constructorDecl,v17370=TypeScript.TokenID,v9731=v17370.OpenParen;JAMScript.call(this.emitJavascript,this,[v9730,v9731,!1])}else{var wroteProps=0;
JAMScript.call(this.recordSourceMappingStart,this,[classDecl]);var v9732=this.indenter;JAMScript.call(v9732.increaseIndent,v9732,[]);var v24238=classDecl.name,v21957=v24238.actualText,v17371="function "+v21957,v9733=v17371+"() {";JAMScript.call(this.writeToOutput,this,[v9733]);JAMScript.call(this.recordSourceMappingNameStart,this,["constructor"]);hasBaseClass&&(JAMScript.call(this.writeLineToOutput,this,[""]),JAMScript.call(this.emitIndent,this,[]),JAMScript.call(this.writeLineToOutput,this,["_super.apply(this, arguments);"]),
wroteProps+=1);var v17372=classDecl.varFlags,v21958=TypeScript.VarFlags,v17373=v21958.MustCaptureThis,v9734=v17372&v17373;v9734&&JAMScript.call(this.writeCaptureThisStatement,this,[classDecl]);for(var v17374=this.thisClassNode,v9735=v17374.members,members=v9735.members,i=0,v17375=members.length,v9739=i<v17375;v9739;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v21959=members[i];var v17376=v21959.nodeType,v21960=TypeScript.NodeType,v17377=v21960.VarDecl,v9738=
v17376==v17377;if(v9738){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var varDecl=members[i];var v24239=varDecl.varFlags,v25372=TypeScript.VarFlags,v24240=v25372.Static,v21961=JAMScript.call(TypeScript.hasFlag,TypeScript,[v24239,v24240]),v17378=!v21961;v17378&&(v17378=varDecl.init);var v9737=v17378;if(v9737){JAMScript.call(this.writeLineToOutput,this,[""]);JAMScript.call(this.emitIndent,this,[]);var v17379=TypeScript.TokenID,v9736=v17379.Tilde;JAMScript.call(this.emitJavascriptVarDecl,
this,[varDecl,v9736]);wroteProps+=1}}var i=i+1,v17380=members.length,v9739=i<v17380}if(wroteProps){JAMScript.call(this.writeLineToOutput,this,[""]);var v9740=this.indenter;JAMScript.call(v9740.decreaseIndent,v9740,[]);JAMScript.call(this.emitIndent,this,[]);JAMScript.call(this.writeLineToOutput,this,["}"])}else{JAMScript.call(this.writeLineToOutput,this,[" }"]);var v9741=this.indenter;JAMScript.call(v9741.decreaseIndent,v9741,[])}JAMScript.call(this.recordSourceMappingNameEnd,this,[]);JAMScript.call(this.recordSourceMappingEnd,
this,[classDecl])}for(var v17381=classDecl.members,v9742=v17381.members,membersLen=v9742.length,j=0,v9758=j<membersLen;v9758;){var v17382=classDecl.members,v9743=v17382.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var memberDecl=v9743[j];var v17383=memberDecl.nodeType,v21962=TypeScript.NodeType,v17384=v21962.FuncDecl,v9757=v17383==v17384;if(v9757){var fn=memberDecl,v21963=fn.fncFlags,v24241=TypeScript.FncFlags,v21964=v24241.Method,v17385=JAMScript.call(TypeScript.hasFlag,
TypeScript,[v21963,v21964]);if(v17385)var v21965=JAMScript.call(fn.isSignature,fn,[]),v17385=!v21965;var v9750=v17385;if(v9750){var v21966=fn.fncFlags,v24242=TypeScript.FncFlags,v21967=v24242.Static,v17386=JAMScript.call(TypeScript.hasFlag,TypeScript,[v21966,v21967]),v9749=!v17386;if(v9749)JAMScript.call(this.emitPrototypeMember,this,[fn,className]);else{var v9748=JAMScript.call(fn.isAccessor,fn,[]);if(v9748){var v21968=this.thisClassNode,v17387=v21968.name,v9744=v17387.actualText;JAMScript.call(this.emitPropertyAccessor,
this,[fn,v9744,!1])}else{JAMScript.call(this.emitIndent,this,[]);JAMScript.call(this.recordSourceMappingStart,this,[fn]);var v25373=classDecl.name,v24243=v25373.actualText,v21969=v24243+".",v24244=fn.name,v21970=v24244.actualText,v17388=v21969+v21970,v9745=v17388+" = ";JAMScript.call(this.writeToOutput,this,[v9745]);var v17389=fn.name;if(v17389)var v24245=fn.name,v21971=JAMScript.call(v24245.isMissing,v24245,[]),v17389=!v21971;var v9746=v17389,v9747=JAMScript.call(Emitter.shouldCaptureThis,Emitter,
[fn]);JAMScript.call(this.emitInnerFunction,this,[fn,v9746,!0,null,v9747,null]);JAMScript.call(this.writeLineToOutput,this,[";"])}}}}else{var v17390=memberDecl.nodeType,v21972=TypeScript.NodeType,v17391=v21972.VarDecl,v9756=v17390==v17391;if(v9756){var varDecl=memberDecl,v17392=varDecl.varFlags,v21973=TypeScript.VarFlags,v17393=v21973.Static,v9755=JAMScript.call(TypeScript.hasFlag,TypeScript,[v17392,v17393]);if(v9755){var v9754=varDecl.init;if(v9754){JAMScript.call(this.emitIndent,this,[]);JAMScript.call(this.recordSourceMappingStart,
this,[varDecl]);var v25374=classDecl.name,v24246=v25374.actualText,v21974=v24246+".",v24247=varDecl.id,v21975=v24247.actualText,v17394=v21974+v21975,v9751=v17394+" = ";JAMScript.call(this.writeToOutput,this,[v9751]);var v9752=varDecl.init,v17395=TypeScript.TokenID,v9753=v17395.Equals;JAMScript.call(this.emitJavascript,this,[v9752,v9753,!1]);JAMScript.call(this.writeLineToOutput,this,[";"]);JAMScript.call(this.recordSourceMappingEnd,this,[varDecl])}}}else throw Error("We want to catch this");}j+=1;
v9758=j<membersLen}JAMScript.call(this.emitIndent,this,[]);var v9759=classDecl.endingToken;JAMScript.call(this.recordSourceMappingStart,this,[v9759]);var v17396="return "+className,v9760=v17396+";";JAMScript.call(this.writeLineToOutput,this,[v9760]);var v9761=classDecl.endingToken;JAMScript.call(this.recordSourceMappingEnd,this,[v9761]);var v9762=this.indenter;JAMScript.call(v9762.decreaseIndent,v9762,[]);JAMScript.call(this.emitIndent,this,[]);var v9763=classDecl.endingToken;JAMScript.call(this.recordSourceMappingStart,
this,[v9763]);JAMScript.call(this.writeToOutput,this,["}"]);JAMScript.call(this.recordSourceMappingNameEnd,this,[]);var v9764=classDecl.endingToken;JAMScript.call(this.recordSourceMappingEnd,this,[v9764]);JAMScript.call(this.recordSourceMappingStart,this,[classDecl]);JAMScript.call(this.writeToOutput,this,[")("]);if(hasBaseClass){var v17397=TypeScript.TokenID,v9765=v17397.Tilde;JAMScript.call(this.emitJavascript,this,[baseName,v9765,!1])}JAMScript.call(this.writeToOutput,this,[");"]);JAMScript.call(this.recordSourceMappingEnd,
this,[classDecl]);var v24248=EmitContainer.Module,v21976=temp==v24248,v24250=!v21976;if(v24250)var v24249=EmitContainer.DynamicModule,v21976=temp==v24249;var v17398=v21976;if(v17398)var v21977=classDecl.varFlags,v24251=TypeScript.VarFlags,v21978=v24251.Exported,v17398=JAMScript.call(TypeScript.hasFlag,TypeScript,[v21977,v21978]);var v9768=v17398;if(v9768){JAMScript.call(this.writeLineToOutput,this,[""]);JAMScript.call(this.emitIndent,this,[]);var v9766,v21979=EmitContainer.Module,v17399=temp==v21979,
modName=v9766=v17399?this.moduleName:"exports";JAMScript.call(this.recordSourceMappingStart,this,[classDecl]);var v25375=modName+".",v24252=v25375+className,v21980=v24252+" = ",v17400=v21980+className,v9767=v17400+";";JAMScript.call(this.writeToOutput,this,[v9767]);JAMScript.call(this.recordSourceMappingEnd,this,[classDecl])}JAMScript.call(this.emitIndent,this,[]);JAMScript.call(this.recordSourceMappingEnd,this,[classDecl]);JAMScript.call(this.emitParensAndCommentsInPlace,this,[classDecl,!1]);JAMScript.call(this.setContainer,
this,[temp]);this.thisClassNode=svClassNode}}function v484(className,base,classDecl){function v483(key,s,c){key=s;s=JAMScript.call(key.kind,key,[]);c=TypeScript.SymbolKind;c=c.Type;if(s=s==c)s=key.type,s=s.call;s&&(s=key.declAST,JAMScript.call(this.recordSourceMappingStart,this,[s]),s=className+".prototype.",c=key.name,s+=c,s+=" = ",s+=baseName,s+=".prototype.",c=key.name,s+=c,s+=";",JAMScript.call(this.writeLineToOutput,this,[s]),key=key.declAST,JAMScript.call(this.recordSourceMappingEnd,this,[key]))}
var v9776=base.members;if(v9776){var v9776=base.symbol,baseName=v9776.name,v17403=v9776.declModule,v24255=classDecl.type,v24255=v24255.symbol,v24255=v24255.declModule;(v17403=v17403!=v24255)&&(baseName=JAMScript.call(v9776.fullName,v9776,[]));v9776=base.members;v9776=v9776.allMembers;JAMScript.call(v9776.map,v9776,[v483,null])}if(v9776=base.extendsList)for(v9776=0,v17403=base.extendsList,v17403=v17403.length,v24255=v9776<v17403;v24255;){v24255=base.extendsList;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v24255=
v24255[v9776];JAMScript.call(this.emitAddBaseMethods,this,[className,v24255,classDecl]);v9776+=1;v24255=v9776<v17403}}function v482(member,className){var v17407=member.nodeType,v21987=TypeScript.NodeType,v21987=v21987.FuncDecl;if(v17407=v17407==v21987)if(v17407=member,v21987=JAMScript.call(v17407.isAccessor,v17407,[]))JAMScript.call(this.emitPropertyAccessor,this,[v17407,className,!0]);else{JAMScript.call(this.emitIndent,this,[]);JAMScript.call(this.recordSourceMappingStart,this,[v17407]);var v21987=
className+".prototype.",v21989=JAMScript.call(v17407.getNameText,v17407,[]),v21987=v21987+v21989,v21987=v21987+" = ";JAMScript.call(this.writeToOutput,this,[v21987]);v21987=JAMScript.call(Emitter.shouldCaptureThis,Emitter,[v17407]);JAMScript.call(this.emitInnerFunction,this,[v17407,!1,!0,null,v21987,null]);JAMScript.call(this.writeLineToOutput,this,[";"])}else if(v17407=member.nodeType,v21987=TypeScript.NodeType,v21987=v21987.VarDecl,v17407=v17407==v21987)if(v17407=member,v21987=v17407.init)JAMScript.call(this.emitIndent,
this,[]),JAMScript.call(this.recordSourceMappingStart,this,[v17407]),v21987=v17407.id,JAMScript.call(this.recordSourceMappingStart,this,[v21987]),v21987=className+".prototype.",v21989=v17407.id,v21989=v21989.actualText,v21987+=v21989,JAMScript.call(this.writeToOutput,this,[v21987]),v21987=v17407.id,JAMScript.call(this.recordSourceMappingEnd,this,[v21987]),JAMScript.call(this.writeToOutput,this,[" = "]),v21987=v17407.init,v21989=TypeScript.TokenID,v21989=v21989.Equals,JAMScript.call(this.emitJavascript,
this,[v21987,v21989,!1]),JAMScript.call(this.recordSourceMappingEnd,this,[v17407]),JAMScript.call(this.writeLineToOutput,this,[";"])}function v481(funcDecl,className,isProto){var v21992=funcDecl.accessorSymbol,v21992=v21992.hasBeenEmitted;if(v21992=!v21992){v21992=funcDecl.accessorSymbol;JAMScript.call(this.emitIndent,this,[]);JAMScript.call(this.recordSourceMappingStart,this,[funcDecl]);className="Object.defineProperty("+className;var v26036;v26036=isProto?'.prototype, "':', "';className+=v26036;
v26036=funcDecl.name;v26036=v26036.actualText;className+=v26036;className+='"';className+=", {";JAMScript.call(this.writeLineToOutput,this,[className]);className=this.indenter;JAMScript.call(className.increaseIndent,className,[]);if(className=v21992.getter)className=v21992.getter,className=className.declAST,JAMScript.call(this.emitIndent,this,[]),JAMScript.call(this.recordSourceMappingStart,this,[className]),JAMScript.call(this.writeToOutput,this,["get: "]),v26036=JAMScript.call(Emitter.shouldCaptureThis,
Emitter,[className]),JAMScript.call(this.emitInnerFunction,this,[className,!1,isProto,null,v26036,null]),JAMScript.call(this.writeLineToOutput,this,[","]);if(className=v21992.setter)className=v21992.setter,className=className.declAST,JAMScript.call(this.emitIndent,this,[]),JAMScript.call(this.recordSourceMappingStart,this,[className]),JAMScript.call(this.writeToOutput,this,["set: "]),v26036=JAMScript.call(Emitter.shouldCaptureThis,Emitter,[className]),JAMScript.call(this.emitInnerFunction,this,[className,
!1,isProto,null,v26036,null]),JAMScript.call(this.writeLineToOutput,this,[","]);JAMScript.call(this.emitIndent,this,[]);JAMScript.call(this.writeLineToOutput,this,["enumerable: true,"]);JAMScript.call(this.emitIndent,this,[]);JAMScript.call(this.writeLineToOutput,this,["configurable: true"]);isProto=this.indenter;JAMScript.call(isProto.decreaseIndent,isProto,[]);JAMScript.call(this.emitIndent,this,[]);JAMScript.call(this.writeLineToOutput,this,["});"]);JAMScript.call(this.recordSourceMappingEnd,this,
[funcDecl]);v21992.hasBeenEmitted=!0}}function v480(ast,tokenId,startLine){var v9802=null==ast;if(!v9802){if(v9802=startLine)if(v9802=this.indenter,v9802=v9802.indentAmt,v9802=0<v9802){var v9802=ast.nodeType,v26037=TypeScript.NodeType,v26037=v26037.List;if(v9802=v9802!=v26037)v9802=ast.nodeType,v26037=TypeScript.NodeType,v26037=v26037.Block,v9802=v9802!=v26037}if(v9802){v9802=ast.nodeType;v26037=TypeScript.NodeType;v26037=v26037.InterfaceDeclaration;if(v9802=v9802!=v26037){v9802=ast.nodeType;v26037=
TypeScript.NodeType;v26037=v26037.VarDecl;if(v9802=v9802==v26037)if(v9802=ast.varFlags,v26037=TypeScript.VarFlags,v26037=v26037.Ambient,v9802&=v26037,v26037=TypeScript.VarFlags,v26037=v26037.Ambient,v9802=v9802==v26037)v9802=ast.init,v9802=null==v9802;if(v9802=!v9802)v9802=JAMScript.call(this.varListCount,this,[]),v9802=0<=v9802;v9802&&(v9802=ast.nodeType,v26037=TypeScript.NodeType,v26037=v26037.EndCode,v9802=v9802!=v26037)&&(v9802=ast.nodeType,v26037=TypeScript.NodeType,v26037=v26037.FuncDecl,v9802=
v9802!=v26037,v26037=!v9802)&&(v9802=this.emitState,v9802=v9802.container,v26037=EmitContainer.Constructor,v9802=v9802!=v26037)}v9802&&JAMScript.call(this.emitIndent,this,[])}JAMScript.call(ast.emit,ast,[this,tokenId,startLine]);startLine=TypeScript.TokenID;startLine=startLine.Semicolon;if(tokenId=tokenId==startLine)ast=ast.nodeType,tokenId=TypeScript.NodeType,tokenId=tokenId.GeneralNode,tokenId=ast<tokenId;(ast=tokenId)&&JAMScript.call(this.writeToOutput,this,[";"])}}function v479(ast,delimiter,
tokenId,startLine,onlyStatics,emitClassPropertiesAfterSuperCall,emitPrologue,requiresExtendsBlock){var v17420=typeof emitClassPropertiesAfterSuperCall,v9806="undefined"===v17420;v9806&&(emitClassPropertiesAfterSuperCall=!1);var v17421=typeof emitPrologue,v9807="undefined"===v17421;v9807&&(emitPrologue=!1);var v9837=null==ast;if(!v9837){var v17422=ast.nodeType,v22001=TypeScript.NodeType,v17423=v22001.List,v9836=v17422!=v17423;if(v9836)JAMScript.call(this.emitPrologue,this,[emitPrologue]),JAMScript.call(this.emitJavascript,
this,[ast,tokenId,startLine]);else{var list=ast,v22002=list.members,v17424=v22002.length,v9808=0==v17424;if(!v9808){JAMScript.call(this.emitParensAndCommentsInPlace,this,[ast,!0]);for(var v9809=list.members,len=v9809.length,i=0,v9835=i<len;v9835;){if(emitPrologue){var v17425=1==i,v22004=!v17425;if(v22004)var v24265=list.flags,v25390=TypeScript.ASTFlags,v24266=v25390.StrictMode,v22003=JAMScript.call(TypeScript.hasFlag,TypeScript,[v24265,v24266]),v17425=!v22003;var v9810=v17425;v9810&&(JAMScript.call(this.emitPrologue,
this,[requiresExtendsBlock]),emitPrologue=!1)}var v17426=1==i;v17426&&(v17426=emitClassPropertiesAfterSuperCall);var v9829=v17426;if(v9829){var v9811=this.thisClassNode,constructorDecl=v9811.constructorDecl,v17427=constructorDecl;v17427&&(v17427=constructorDecl.arguments);var v9822=v17427;if(v9822)for(var v17428=constructorDecl.arguments,v9812=v17428.members,argsLen=v9812.length,iArg=0,v9821=iArg<argsLen;v9821;){var v17429=constructorDecl.arguments,v9813=v17429.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var arg=
v9813[iArg];var v22005=arg.varFlags,v24267=TypeScript.VarFlags,v22006=v24267.Property,v17430=v22005&v22006,v22007=TypeScript.VarFlags,v17431=v22007.None,v9820=v17430!=v17431;if(v9820){JAMScript.call(this.emitIndent,this,[]);JAMScript.call(this.recordSourceMappingStart,this,[arg]);var v9814=arg.id;JAMScript.call(this.recordSourceMappingStart,this,[v9814]);var v22008=arg.id,v17432=v22008.actualText,v9815="this."+v17432;JAMScript.call(this.writeToOutput,this,[v9815]);var v9816=arg.id;JAMScript.call(this.recordSourceMappingEnd,
this,[v9816]);JAMScript.call(this.writeToOutput,this,[" = "]);var v9817=arg.id;JAMScript.call(this.recordSourceMappingStart,this,[v9817]);var v17433=arg.id,v9818=v17433.actualText;JAMScript.call(this.writeToOutput,this,[v9818]);var v9819=arg.id;JAMScript.call(this.recordSourceMappingEnd,this,[v9819]);JAMScript.call(this.writeLineToOutput,this,[";"]);JAMScript.call(this.recordSourceMappingEnd,this,[arg])}iArg+=1;v9821=iArg<argsLen}for(var v22009=this.thisClassNode,v17434=v22009.members,v9823=v17434.members,
nProps=v9823.length,iMember=0,v9828=iMember<nProps;v9828;){var v26046=this.thisClassNode,v25391=v26046.members,v24268=v25391.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v22010=v24268[iMember];var v17435=v22010.nodeType,v22011=TypeScript.NodeType,v17436=v22011.VarDecl,v9827=v17435==v17436;if(v9827){var v22012=this.thisClassNode,v17437=v22012.members,v9824=v17437.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var varDecl=
v9824[iMember];var v24269=varDecl.varFlags,v25392=TypeScript.VarFlags,v24270=v25392.Static,v22013=JAMScript.call(TypeScript.hasFlag,TypeScript,[v24269,v24270]),v17438=!v22013;v17438&&(v17438=varDecl.init);var v9826=v17438;if(v9826){JAMScript.call(this.emitIndent,this,[]);var v17439=TypeScript.TokenID,v9825=v17439.Tilde;JAMScript.call(this.emitJavascriptVarDecl,this,[varDecl,v9825]);JAMScript.call(this.writeLineToOutput,this,[""])}}iMember+=1;v9828=iMember<nProps}}var v9830=list.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var emitNode=
v9830[i];var v22014=emitNode.nodeType,v24271=TypeScript.NodeType,v22015=v24271.FuncDecl,v17440=v22014==v22015;if(v17440)var v22016=emitNode.fncFlags,v24272=TypeScript.FncFlags,v22017=v24272.Static,v17440=JAMScript.call(TypeScript.hasFlag,TypeScript,[v22016,v22017]);var v9831=v17440,v17442=!v9831;if(v17442){var v22018=emitNode.nodeType,v24273=TypeScript.NodeType,v22019=v24273.VarDecl,v17441=v22018==v22019;if(v17441)var v22020=emitNode.varFlags,v24274=TypeScript.VarFlags,v22021=v24274.Static,v17441=
JAMScript.call(TypeScript.hasFlag,TypeScript,[v22020,v22021]);v9831=v17441}var isStaticDecl=v9831,v17443,v9832=v17443=onlyStatics?!isStaticDecl:isStaticDecl;if(!v9832){JAMScript.call(this.emitJavascript,this,[emitNode,tokenId,startLine]);var v17444=delimiter;if(v17444)var v22022=len-1,v17444=i<v22022;var v9834=v17444;if(v9834)startLine?JAMScript.call(this.writeLineToOutput,this,[delimiter]):JAMScript.call(this.writeToOutput,this,[delimiter]);else{var v17445=startLine;if(v17445){var v24275=emitNode.nodeType,
v25393=TypeScript.NodeType,v24276=v25393.ModuleDeclaration,v22023=v24275!=v24276;if(v22023){var v25394=emitNode.nodeType,v26047=TypeScript.NodeType,v25395=v26047.InterfaceDeclaration,v24277=v25394!=v25395;if(v24277){var v26661=emitNode.nodeType,v26716=TypeScript.NodeType,v26662=v26716.VarDecl,v26578=v26661==v26662;if(v26578){var v26742=emitNode.varFlags,v26759=TypeScript.VarFlags,v26743=v26759.Ambient,v26717=v26742&v26743,v26744=TypeScript.VarFlags,v26718=v26744.Ambient,v26663=v26717==v26718;if(v26663)var v26719=
emitNode.init,v26663=null==v26719;v26578=v26663}var v26423=v26578,v26048=!v26423;if(v26048)var v26424=JAMScript.call(this.varListCount,this,[]),v26048=0<=v26424;var v25396=v26048;if(v25396){var v26579=emitNode.nodeType,v26664=TypeScript.NodeType,v26580=v26664.Block,v26425=v26579!=v26580,v26581=!v26425;v26581&&(v26425=emitNode.isStatementBlock);var v26049=v26425;if(v26049){var v26582=emitNode.nodeType,v26665=TypeScript.NodeType,v26583=v26665.EndCode,v26426=v26582!=v26583;if(v26426)var v26584=emitNode.nodeType,
v26666=TypeScript.NodeType,v26585=v26666.FuncDecl,v26426=v26584!=v26585;v26049=v26426}v25396=v26049}v24277=v25396}v22023=v24277}v17445=v22023}var v9833=v17445;v9833&&JAMScript.call(this.writeLineToOutput,this,[""])}}i+=1;v9835=i<len}JAMScript.call(this.emitParensAndCommentsInPlace,this,[ast,!1])}}}}function v478(){var v17446=this.sourceMapper;if(v17446=null!=v17446){var v17446=TypeScript.SourceMapper,v9839=this.allSourceMappers;JAMScript.call(v17446.EmitSourceMapping,v17446,[v9839])}try{var v9841=
this.outfile;JAMScript.call(v9841.Close,v9841,[])}catch(ex){v9841=this.errorReporter,v17446=ex.message,JAMScript.call(v9841.emitterError,v9841,[null,v17446])}}function v477(ast){var v17447=this.sourceMapper;v17447&&(v17447=JAMScript.call(TypeScript.isValidAstNode,TypeScript,[ast]));if(ast=v17447){ast=this.sourceMapper;ast=ast.currentMappings;JAMScript.call(ast.pop,ast,[]);ast=this.sourceMapper;ast=ast.currentMappings;v17447=this.sourceMapper;v17447=v17447.currentMappings;v17447=v17447.length;v17447-=
1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)ast=ast[v17447];v17447=ast.length;v17447-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)ast=ast[v17447];var v17447=ast.end,v17452=this.emitState;v17447.emittedColumn=v17452.column;ast=ast.end;v17447=this.emitState;ast.emittedLine=v17447.line}}function v476(ast){var v17454=this.sourceMapper;v17454&&(v17454=JAMScript.call(TypeScript.isValidAstNode,TypeScript,[ast]));if(v17454){var lineCol=
{line:-1,col:-1},v17454=TypeScript.SourceMapping,v17454=JAMScript.new(v17454,[]),v9852=v17454.start,v17455=this.emitState;v9852.emittedColumn=v17455.column;v9852=v17454.start;v17455=this.emitState;v9852.emittedLine=v17455.line;v9852=ast.minChar;v17455=this.checker;v17455=v17455.locationInfo;v17455=v17455.lineMap;JAMScript.call(TypeScript.getSourceLineColFromMap,TypeScript,[lineCol,v9852,v17455]);v9852=v17454.start;v9852.sourceColumn=lineCol.col;v9852=v17454.start;v9852.sourceLine=lineCol.line;ast=
ast.limChar;v9852=this.checker;v9852=v9852.locationInfo;v9852=v9852.lineMap;JAMScript.call(TypeScript.getSourceLineColFromMap,TypeScript,[lineCol,ast,v9852]);ast=v17454.end;ast.sourceColumn=lineCol.col;ast=v17454.end;ast.sourceLine=lineCol.line;lineCol=this.sourceMapper;lineCol=lineCol.currentNameIndex;lineCol=lineCol.length;if(lineCol=0<lineCol)lineCol=this.sourceMapper,lineCol=lineCol.currentNameIndex,ast=this.sourceMapper,ast=ast.currentNameIndex,ast=ast.length,ast-=1,v17454.nameIndex=lineCol[ast];
lineCol=this.sourceMapper;lineCol=lineCol.currentMappings;ast=this.sourceMapper;ast=ast.currentMappings;ast=ast.length;ast-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)lineCol=lineCol[ast];JAMScript.call(lineCol.push,lineCol,[v17454]);lineCol=this.sourceMapper;lineCol=lineCol.currentMappings;v17454=v17454.childMappings;JAMScript.call(lineCol.push,lineCol,[v17454])}}function v475(){var v9871=this.sourceMapper;v9871&&(v9871=this.sourceMapper,v9871=v9871.currentNameIndex,
JAMScript.call(v9871.pop,v9871,[]))}function v474(name){var v9878=this.sourceMapper;if(v9878){var v9878=name,v9874=!name;if(v9874)v9878="";else if(v9874=this.sourceMapper,v9874=v9874.currentNameIndex,v9874=v9874.length,v9874=0<v9874){v9878=this.sourceMapper;v9878=v9878.names;v9874=this.sourceMapper;v9874=v9874.currentNameIndex;v9874=v9874.length;v9874-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v9878=v9878[v9874];v9878+=".";v9878+=name}name=this.sourceMapper;
name=name.names;JAMScript.call(name.push,name,[v9878]);name=this.sourceMapper;name=name.currentNameIndex;v9878=this.sourceMapper;v9878=v9878.names;v9878=v9878.length;v9878-=1;JAMScript.call(name.push,name,[v9878])}}function v473(stmts,emitClassPropertiesAfterSuperCall){var v17471=typeof emitClassPropertiesAfterSuperCall;(v17471="undefined"===v17471)&&(emitClassPropertiesAfterSuperCall=!1);var v17471=stmts.nodeType,v22034=TypeScript.NodeType,v22034=v22034.Block;if(v17471=v17471!=v22034)if(v17471=stmts.nodeType,
v22034=TypeScript.NodeType,v22034=v22034.List,v17471=v17471==v22034){v17471=stmts;v22034=v17471.members;v22034=v22034.length;if(v22034=2==v22034){var v22034=v17471.members,v22034=v22034[0],v22034=v22034.nodeType,v25399=TypeScript.NodeType,v25399=v25399.Block;if(v22034=v22034==v25399)v22034=v17471.members,v22034=v22034[1],v22034=v22034.nodeType,v25399=TypeScript.NodeType,v25399=v25399.EndCode,v22034=v22034==v25399}v22034?(v17471=v17471.members,v17471=v17471[0],v22034=TypeScript.TokenID,v22034=v22034.Semicolon,
JAMScript.call(this.emitJavascript,this,[v17471,v22034,!0]),JAMScript.call(this.writeLineToOutput,this,[""])):(v17471=TypeScript.TokenID,v17471=v17471.Semicolon,JAMScript.call(this.emitJavascriptList,this,[stmts,null,v17471,!0,!1,emitClassPropertiesAfterSuperCall]))}else v17471=TypeScript.TokenID,v17471=v17471.Semicolon,JAMScript.call(this.emitJavascript,this,[stmts,v17471,!0]);else v17471=TypeScript.TokenID,v17471=v17471.Semicolon,JAMScript.call(this.emitJavascript,this,[stmts,v17471,!0])}function v472(stmts,
emitEmptyBod){if(stmts){var v17482=stmts.nodeType,v22038=TypeScript.NodeType,v22038=v22038.Block;if(v17482=v17482!=v22038){if(v17482=stmts)if(v17482=stmts.nodeType,v22038=TypeScript.NodeType,v22038=v22038.List,v17482=v17482!=v22038,v22038=!v17482)v17482=stmts.members,v17482=v17482.length,v17482=0<v17482;if(v17482=emitEmptyBod||v17482){v17482=stmts.nodeType;v22038=TypeScript.NodeType;v22038=v22038.Block;v17482=v17482==v22038;if(v22038=!v17482)if(v17482=stmts.nodeType,v22038=TypeScript.NodeType,v22038=
v22038.List,v17482=v17482==v22038)if(v17482=stmts.members,v17482=v17482.length,v17482=1==v17482)v17482=stmts.members,v17482=v17482[0],v17482=v17482.nodeType,v22038=TypeScript.NodeType,v22038=v22038.Block,v17482=v17482==v22038;JAMScript.call(this.recordSourceMappingStart,this,[stmts]);if(v22038=!v17482)JAMScript.call(this.writeLineToOutput,this,[" {"]),v22038=this.indenter,JAMScript.call(v22038.increaseIndent,v22038,[]);v22038=TypeScript.TokenID;v22038=v22038.Semicolon;JAMScript.call(this.emitJavascriptList,
this,[stmts,null,v22038,!0,!1,!1]);if(v17482=!v17482)JAMScript.call(this.writeLineToOutput,this,[""]),v17482=this.indenter,JAMScript.call(v17482.decreaseIndent,v17482,[]),JAMScript.call(this.emitIndent,this,[]),JAMScript.call(this.writeToOutput,this,["}"]);JAMScript.call(this.recordSourceMappingEnd,this,[stmts])}}else v17482=TypeScript.TokenID,v17482=v17482.Semicolon,JAMScript.call(this.emitJavascript,this,[stmts,v17482,!0])}else emitEmptyBod&&JAMScript.call(this.writeToOutput,this,["{ }"])}function v471(name,
addThis){var sym=name.sym;JAMScript.call(this.emitParensAndCommentsInPlace,this,[name,!0]);JAMScript.call(this.recordSourceMappingStart,this,[name]);var v17491=JAMScript.call(name.isMissing,name,[]),v9923=!v17491;if(v9923){var v17492=addThis;if(v17492){var v25405=this.emitState,v24297=v25405.container,v24298=EmitContainer.Args,v22047=v24297!=v24298;v22047&&(v22047=sym);v17492=v22047}var v9914=v17492;if(v9914){var v17493=sym.container;if(v17493)var v24299=sym.container,v22048=v24299.name,v22049=TypeScript.globalId,
v17493=v22048!=v22049;var v9913=v17493;if(v9913){var v22050=sym.flags,v24300=TypeScript.SymbolFlags,v22051=v24300.Static,v17494=JAMScript.call(TypeScript.hasFlag,TypeScript,[v22050,v22051]);if(v17494)var v22052=sym.flags,v24301=TypeScript.SymbolFlags,v22053=v24301.Property,v17494=JAMScript.call(TypeScript.hasFlag,TypeScript,[v22052,v22053]);var v9911=v17494;if(v9911){var v17495=sym.declModule;if(v17495)var v24302=sym.declModule,v22054=v24302.modFlags,v24303=TypeScript.ModuleFlags,v22055=v24303.IsDynamic,
v17495=JAMScript.call(TypeScript.hasFlag,TypeScript,[v22054,v22055]);var v9899=v17495;if(v9899)JAMScript.call(this.writeToOutput,this,["exports."]);else{var v22056=sym.container,v17496=v22056.name,v9898=v17496+".";JAMScript.call(this.writeToOutput,this,[v9898])}}else{var v17497=JAMScript.call(sym.kind,sym,[]),v22057=TypeScript.SymbolKind,v17498=v22057.Field,v9910=v17497==v17498;if(v9910){var fieldSym=sym,v17499=fieldSym.flags,v22058=TypeScript.SymbolFlags,v17500=v22058.ModuleMember,v9904=JAMScript.call(TypeScript.hasFlag,
TypeScript,[v17499,v17500]);if(v9904){var v22059=sym.container,v24304=this.checker,v22060=v24304.gloMod,v17501=v22059!=v22060;if(v17501){var v24305=sym.flags,v25406=TypeScript.SymbolFlags,v24306=v25406.Property,v22061=JAMScript.call(TypeScript.hasFlag,TypeScript,[v24305,v24306]),v24309=!v22061;if(v24309)var v24307=sym.flags,v25407=TypeScript.SymbolFlags,v24308=v25407.Exported,v22061=JAMScript.call(TypeScript.hasFlag,TypeScript,[v24307,v24308]);v17501=v22061}var v9902=v17501;if(v9902){var v22062=sym.declModule,
v17502=v22062.modFlags,v22063=TypeScript.ModuleFlags,v17503=v22063.IsDynamic,v9901=JAMScript.call(TypeScript.hasFlag,TypeScript,[v17502,v17503]);if(v9901)JAMScript.call(this.writeToOutput,this,["exports."]);else{var v22064=sym.container,v17504=v22064.name,v9900=v17504+".";JAMScript.call(this.writeToOutput,this,[v9900])}}}else{var v9903=JAMScript.call(sym.isInstanceProperty,sym,[]);v9903&&(JAMScript.call(this.emitThis,this,[]),JAMScript.call(this.writeToOutput,this,["."]))}}else{var v17505=JAMScript.call(sym.kind,
sym,[]),v22065=TypeScript.SymbolKind,v17506=v22065.Type,v9909=v17505==v17506;if(v9909){var v9908=JAMScript.call(sym.isInstanceProperty,sym,[]);if(v9908){var typeSym=sym,type=typeSym.type,v17507=type.call;if(v17507)var v24310=sym.flags,v25408=TypeScript.SymbolFlags,v24311=v25408.ModuleMember,v22066=JAMScript.call(TypeScript.hasFlag,TypeScript,[v24310,v24311]),v17507=!v22066;var v9905=v17507;v9905&&(JAMScript.call(this.emitThis,this,[]),JAMScript.call(this.writeToOutput,this,["."]))}else{var v22067=
sym.unitIndex,v25409=this.checker,v24312=v25409.locationInfo,v22068=v24312.unitIndex,v17508=v22067!=v22068,v22070=!v17508;if(v22070)var v24313=sym.declModule,v22069=JAMScript.call(this.declEnclosed,this,[v24313]),v17508=!v22069;var v9907=v17508;if(v9907){var v22071=sym.container,v17509=v22071.name,v9906=v17509+".";JAMScript.call(this.writeToOutput,this,[v9906])}}}}}}else{var v22072=sym.container,v24314=this.checker,v22073=v24314.gloMod,v17510=v22072==v22073;if(v17510){var v24315=sym.flags,v25410=
TypeScript.SymbolFlags,v24316=v25410.Exported,v22074=JAMScript.call(TypeScript.hasFlag,TypeScript,[v24315,v24316]);if(v22074){var v26054=sym.flags,v26427=TypeScript.SymbolFlags,v26055=v26427.Ambient,v25411=JAMScript.call(TypeScript.hasFlag,TypeScript,[v26054,v26055]),v24317=!v25411;if(v24317){var v26586=JAMScript.call(sym.isType,sym,[]),v26667=!v26586;v26667&&(v26586=JAMScript.call(sym.isMember,sym,[]));var v26428=v26586;if(v26428){var v26587=sym.declModule;if(v26587)var v26720=sym.declModule,v26668=
v26720.modFlags,v26721=TypeScript.ModuleFlags,v26669=v26721.Ambient,v26587=JAMScript.call(TypeScript.hasFlag,TypeScript,[v26668,v26669]);v26428=v26587}var v26056=v26428,v25412=!v26056;if(v25412){var v26588=this.emitState,v26429=v26588.container,v26430=EmitContainer.Prog,v26057=v26429==v26430;if(v26057)var v26589=sym.declAST,v26431=v26589.nodeType,v26590=TypeScript.NodeType,v26432=v26590.FuncDecl,v26057=v26431!=v26432;v25412=v26057}v24317=v25412}v22074=v24317}v17510=v22074}var v9912=v17510;v9912&&
JAMScript.call(this.writeToOutput,this,["this."])}}var v17511=sym;if(v17511){var v22075=sym.declAST;if(v22075){var v26058=sym.declAST,v25413=v26058.nodeType,v26059=TypeScript.NodeType,v25414=v26059.ModuleDeclaration,v24318=v25413==v25414;if(v24318)var v26060=sym.declAST,v25415=v26060.modFlags,v26061=TypeScript.ModuleFlags,v25416=v26061.IsDynamic,v24318=JAMScript.call(TypeScript.hasFlag,TypeScript,[v25415,v25416]);v22075=v24318}v17511=v22075}var v9922=v17511;if(v9922){var moduleDecl=sym.declAST,v17512=
TypeScript.moduleGenTarget,v22076=TypeScript.ModuleGenTarget,v17513=v22076.Asynchronous,v9920=v17512==v17513;if(v9920){var v22077=this.modAliasId,v17514="__"+v22077,v9915=v17514+"__;";JAMScript.call(this.writeLineToOutput,this,[v9915])}else{var modPath=name.actualText,v22078=moduleDecl.mod,v17515=v22078.symbol,v9916=v17515.declAST;if(v9916)var v25417=moduleDecl.mod,v24319=v25417.symbol,v22079=v24319.declAST,v17516=v22079.modFlags,v22080=TypeScript.ModuleFlags,v17517=v22080.Ambient,v9916=JAMScript.call(TypeScript.hasFlag,
TypeScript,[v17516,v17517]);var isAmbient=v9916,v9917;if(isAmbient)v9917=modPath;else{var v17518,v22081=this.firstModAlias;v9917=v17518=v22081?this.firstModAlias:JAMScript.call(TypeScript.quoteBaseName,TypeScript,[modPath])}var modPath=v9917,v9918;if(isAmbient)v9918=modPath;else{var v17519,v25418=JAMScript.call(TypeScript.stripQuotes,TypeScript,[modPath]),v24320=JAMScript.call(TypeScript.isRelative,TypeScript,[v25418]),v22083=!v24320;if(v22083){var v24321=JAMScript.call(TypeScript.stripQuotes,TypeScript,
[modPath]),v22082="./"+v24321;v17519=JAMScript.call(TypeScript.quoteStr,TypeScript,[v22082])}else v17519=modPath;v9918=v17519}var modPath=v9918,v17520="require("+modPath,v9919=v17520+")";JAMScript.call(this.writeToOutput,this,[v9919])}}else{var v9921=name.actualText;JAMScript.call(this.writeToOutput,this,[v9921])}}JAMScript.call(this.recordSourceMappingEnd,this,[name]);JAMScript.call(this.emitParensAndCommentsInPlace,this,[name,!1])}function v470(moduleDecl){var v9924=null==moduleDecl;if(v9924)return!0;
for(var v9924=0,v9925=this.moduleDeclList,v9925=v9925.length,v9927=v9924<v9925;v9927;){v9927=this.moduleDeclList;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v9927=v9927[v9924];if(v9927=v9927==moduleDecl)return!0;v9924+=1;v9927=v9924<v9925}return!1}function v469(varDecl,tokenId){var v22085=varDecl.varFlags,v24322=TypeScript.VarFlags,v24322=v24322.Ambient,v22085=v22085&v24322,v24322=TypeScript.VarFlags,v24322=v24322.Ambient;if(v22085=v22085==v24322)JAMScript.call(this.emitAmbientVarDecl,
this,[varDecl]),JAMScript.call(this.onEmitVar,this,[]);else{v24322=varDecl.sym;v22085=varDecl.init;v22085=null!=v22085;JAMScript.call(this.emitParensAndCommentsInPlace,this,[varDecl,!0]);JAMScript.call(this.recordSourceMappingStart,this,[varDecl]);var v17524=v24322;if(v17524&&(v17524=JAMScript.call(v24322.isMember,v24322,[]))&&(v17524=v24322.container))var v17524=v24322.container,v17524=JAMScript.call(v17524.kind,v17524,[]),v26063=TypeScript.SymbolKind,v26063=v26063.Type,v17524=v17524==v26063;if(v17524){v17524=
v24322.container;v17524=v17524.type;if(v26063=JAMScript.call(v17524.isClass,v17524,[]))var v26063=v24322.flags,v25421=TypeScript.SymbolFlags,v25421=v25421.ModuleMember,v26063=JAMScript.call(TypeScript.hasFlag,TypeScript,[v26063,v25421]),v26063=!v26063;if(v26063){if(v17524=this.emitState,v17524=v17524.container,v26063=EmitContainer.Args,v17524=v17524!=v26063)v17524=v24322.flags,v26063=TypeScript.SymbolFlags,v26063=v26063.Static,(v17524=JAMScript.call(TypeScript.hasFlag,TypeScript,[v17524,v26063]))?
(v24322=v24322.container,v24322=v24322.name,v24322+=".",JAMScript.call(this.writeToOutput,this,[v24322])):JAMScript.call(this.writeToOutput,this,["this."])}else if(v17524=JAMScript.call(v17524.hasImplementation,v17524,[])){v17524=v24322.flags;v26063=TypeScript.SymbolFlags;v26063=v26063.Exported;v17524=JAMScript.call(TypeScript.hasFlag,TypeScript,[v17524,v26063]);if(v17524=!v17524)if(v17524=v24322.container,v26063=this.checker,v26063=v26063.gloMod,v17524=v17524==v26063,v26063=!v17524)v24322=v24322.flags,
v17524=TypeScript.SymbolFlags,v17524=v17524.Property,v24322=JAMScript.call(TypeScript.hasFlag,TypeScript,[v24322,v17524]),v17524=!v24322;(v24322=v17524)?JAMScript.call(this.emitVarDeclVar,this,[]):(v24322=varDecl.varFlags,v17524=TypeScript.VarFlags,v17524=v17524.LocalStatic,(v24322=JAMScript.call(TypeScript.hasFlag,TypeScript,[v24322,v17524]))?JAMScript.call(this.writeToOutput,this,["."]):(v24322=this.emitState,v24322=v24322.container,v17524=EmitContainer.DynamicModule,(v24322=v24322==v17524)?JAMScript.call(this.writeToOutput,
this,["exports."]):(v24322=this.moduleName,v24322+=".",JAMScript.call(this.writeToOutput,this,[v24322]))))}else if(v17524=TypeScript.TokenID,v17524=v17524.OpenParen,v17524=tokenId!=v17524){v17524=v24322.flags;v26063=TypeScript.SymbolFlags;v26063=v26063.Exported;if(v17524=JAMScript.call(TypeScript.hasFlag,TypeScript,[v17524,v26063]))v24322=v24322.container,v17524=this.checker,v17524=v17524.gloMod,v17524=v24322==v17524;(v24322=v17524)?JAMScript.call(this.writeToOutput,this,["this."]):JAMScript.call(this.emitVarDeclVar,
this,[])}}else v24322=TypeScript.TokenID,v24322=v24322.OpenParen,(v24322=tokenId!=v24322)&&JAMScript.call(this.emitVarDeclVar,this,[]);v24322=varDecl.id;JAMScript.call(this.recordSourceMappingStart,this,[v24322]);v24322=varDecl.id;v24322=v24322.actualText;JAMScript.call(this.writeToOutput,this,[v24322]);v24322=varDecl.id;JAMScript.call(this.recordSourceMappingEnd,this,[v24322]);v22085&&(JAMScript.call(this.writeToOutputTrimmable,this,[" = "]),v22085=this.varListCountStack,JAMScript.call(v22085.push,
v22085,[0]),v22085=varDecl.init,v24322=TypeScript.TokenID,v24322=v24322.Comma,JAMScript.call(this.emitJavascript,this,[v22085,v24322,!1]),v22085=this.varListCountStack,JAMScript.call(v22085.pop,v22085,[]));JAMScript.call(this.onEmitVar,this,[]);v22085=TypeScript.TokenID;v22085=v22085.OpenParen;if(v22085=tokenId!=v22085)v22085=JAMScript.call(this.varListCount,this,[]),(v22085=0>v22085)?JAMScript.call(this.writeToOutput,this,[", "]):(v22085=TypeScript.TokenID,v22085=v22085.For,(v22085=tokenId!=v22085)&&
JAMScript.call(this.writeToOutputTrimmable,this,[";"]));JAMScript.call(this.recordSourceMappingEnd,this,[varDecl]);JAMScript.call(this.emitParensAndCommentsInPlace,this,[varDecl,!1])}}function v468(){var v17545=JAMScript.call(this.varListCount,this,[]);if(v17545=0<v17545)v17545=JAMScript.call(this.varListCount,this,[]),v17545-=1,JAMScript.call(this.setInVarBlock,this,[v17545]);else if(v17545=JAMScript.call(this.varListCount,this,[]),v17545=0>v17545)v17545=JAMScript.call(this.varListCount,this,[]),
v17545+=1,JAMScript.call(this.setInVarBlock,this,[v17545])}function v467(){var v17549=JAMScript.call(this.varListCount,this,[]);if(v17549=0<=v17549)JAMScript.call(this.writeToOutput,this,["var "]),v17549=JAMScript.call(this.varListCount,this,[]),v17549=-v17549,JAMScript.call(this.setInVarBlock,this,[v17549]);return!0}function v466(){var v9960=this.varListCountStack,v22105=this.varListCountStack,v22105=v22105.length,v22105=v22105-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v9960[v22105]}
function v465(varDecl){var v9967=varDecl.init;if(v9967){JAMScript.call(this.emitParensAndCommentsInPlace,this,[varDecl,!0]);JAMScript.call(this.recordSourceMappingStart,this,[varDecl]);v9967=varDecl.id;JAMScript.call(this.recordSourceMappingStart,this,[v9967]);v9967=varDecl.id;v9967=v9967.actualText;JAMScript.call(this.writeToOutput,this,[v9967]);v9967=varDecl.id;JAMScript.call(this.recordSourceMappingEnd,this,[v9967]);JAMScript.call(this.writeToOutput,this,[" = "]);var v9967=varDecl.init,v17553=
TypeScript.TokenID,v17553=v17553.Comma;JAMScript.call(this.emitJavascript,this,[v9967,v17553,!1]);JAMScript.call(this.recordSourceMappingEnd,this,[varDecl]);JAMScript.call(this.writeToOutput,this,[";"]);JAMScript.call(this.emitParensAndCommentsInPlace,this,[varDecl,!1])}}function v464(funcDecl){var v22106=funcDecl.fncFlags,v24334=TypeScript.FncFlags,v22107=v24334.Signature,v17554=JAMScript.call(TypeScript.hasFlag,TypeScript,[v22106,v22107]),v22108=!v17554;v22108&&(v17554=funcDecl.isOverload);var v9968=
v17554;if(!v9968){var temp,tempFnc=this.thisFnc;this.thisFnc=funcDecl;var v9971=funcDecl.isConstructor;if(v9971){var v9969=EmitContainer.Constructor;temp=JAMScript.call(this.setContainer,this,[v9969])}else{var v9970=EmitContainer.Function;temp=JAMScript.call(this.setContainer,this,[v9970])}var bases=null,hasSelfRef=!1,funcName=JAMScript.call(funcDecl.getNameText,funcDecl,[]),v24335=this.emitState,v22109=v24335.inObjectLiteral,v24337=!v22109;if(v24337)var v24336=JAMScript.call(funcDecl.isAccessor,
funcDecl,[]),v22109=!v24336;var v17555=v22109;if(v17555){var v24338=EmitContainer.Constructor,v22110=temp!=v24338,v24341=!v22110;if(v24341)var v25426=funcDecl.fncFlags,v26065=TypeScript.FncFlags,v25427=v26065.Method,v24339=v25426&v25427,v25428=TypeScript.FncFlags,v24340=v25428.None,v22110=v24339==v24340;v17555=v22110}var v9979=v17555;if(v9979){var tempLit=JAMScript.call(this.setInObjectLiteral,this,[!1]),v9973=this.thisClassNode;if(v9973)var v9972=this.thisClassNode,bases=v9972.extendsList;hasSelfRef=
JAMScript.call(Emitter.shouldCaptureThis,Emitter,[funcDecl]);JAMScript.call(this.recordSourceMappingStart,this,[funcDecl]);var v22111=funcDecl.fncFlags,v25429=TypeScript.FncFlags,v24342=v25429.Exported,v25430=TypeScript.FncFlags,v24343=v25430.ClassPropertyMethodExported,v22112=v24342|v24343,v17556=JAMScript.call(TypeScript.hasFlag,TypeScript,[v22111,v22112]);if(v17556){var v26066=funcDecl.type,v25431=v26066.symbol,v24344=v25431.container,v25432=this.checker,v24345=v25432.gloMod,v22113=v24344==v24345;
if(v22113)var v24346=funcDecl.isConstructor,v22113=!v24346;v17556=v22113}var v9978=v17556;if(v9978){var v17557="this."+funcName,v9974=v17557+" = ";JAMScript.call(this.writeToOutput,this,[v9974]);var v9975=this.thisClassNode;JAMScript.call(this.emitInnerFunction,this,[funcDecl,!1,!1,bases,hasSelfRef,v9975])}else{var v17558=funcDecl.name;if(v17558)var v24347=funcDecl.name,v22114=JAMScript.call(v24347.isMissing,v24347,[]),v17558=!v22114;var v9976=v17558,v9977=this.thisClassNode;JAMScript.call(this.emitInnerFunction,
this,[funcDecl,v9976,!1,bases,hasSelfRef,v9977])}JAMScript.call(this.setInObjectLiteral,this,[tempLit])}JAMScript.call(this.setContainer,this,[temp]);this.thisFnc=tempFnc;var v17559=funcDecl.fncFlags,v22115=TypeScript.FncFlags,v17560=v22115.Definition,v9988=JAMScript.call(TypeScript.hasFlag,TypeScript,[v17559,v17560]);if(v9988){var v17561=funcDecl.fncFlags,v22116=TypeScript.FncFlags,v17562=v22116.Static,v9987=JAMScript.call(TypeScript.hasFlag,TypeScript,[v17561,v17562]);if(v9987){var v9983=this.thisClassNode;
if(v9983){var v9982=JAMScript.call(funcDecl.isAccessor,funcDecl,[]);if(v9982){var v22117=this.thisClassNode,v17563=v22117.name,v9980=v17563.actualText;JAMScript.call(this.emitPropertyAccessor,this,[funcDecl,v9980,!1])}else{JAMScript.call(this.emitIndent,this,[]);JAMScript.call(this.recordSourceMappingStart,this,[funcDecl]);var v26591=this.thisClassNode,v26433=v26591.name,v26067=v26433.actualText,v25433=v26067+".",v24348=v25433+funcName,v22118=v24348+" = ",v17564=v22118+funcName,v9981=v17564+";";JAMScript.call(this.writeLineToOutput,
this,[v9981]);JAMScript.call(this.recordSourceMappingEnd,this,[funcDecl])}}}else{var v25434=this.emitState,v24349=v25434.container,v24350=EmitContainer.Module,v22119=v24349==v24350,v24353=!v22119;if(v24353)var v25435=this.emitState,v24351=v25435.container,v24352=EmitContainer.DynamicModule,v22119=v24351==v24352;var v17565=v22119;if(v17565)var v22120=funcDecl.fncFlags,v25436=TypeScript.FncFlags,v24354=v25436.Exported,v25437=TypeScript.FncFlags,v24355=v25437.ClassPropertyMethodExported,v22121=v24354|
v24355,v17565=JAMScript.call(TypeScript.hasFlag,TypeScript,[v22120,v22121]);var v9986=v17565;if(v9986){JAMScript.call(this.emitIndent,this,[]);var v9984,v24356=this.emitState,v22122=v24356.container,v22123=EmitContainer.Module,v17566=v22122==v22123,modName=v9984=v17566?this.moduleName:"exports";JAMScript.call(this.recordSourceMappingStart,this,[funcDecl]);var v25438=modName+".",v24357=v25438+funcName,v22124=v24357+" = ",v17567=v22124+funcName,v9985=v17567+";";JAMScript.call(this.writeLineToOutput,
this,[v9985]);JAMScript.call(this.recordSourceMappingEnd,this,[funcDecl])}}}}}function v463(text){JAMScript.call(this.writeToOutput,this,[text])}function v462(operand1,operand2){var temp=JAMScript.call(this.setInObjectLiteral,this,[!1]),v17568=TypeScript.TokenID,v17568=v17568.Tilde;JAMScript.call(this.emitJavascript,this,[operand1,v17568,!1]);JAMScript.call(this.writeToOutput,this,["["]);v17568=TypeScript.TokenID;v17568=v17568.Comma;JAMScript.call(this.emitJavascriptList,this,[operand2,", ",v17568,
!1,!1,!1]);JAMScript.call(this.writeToOutput,this,["]"]);JAMScript.call(this.setInObjectLiteral,this,[temp])}function v461(moduleDecl){var v9991=moduleDecl.name,modName=v9991.actualText,v9997=JAMScript.call(TypeScript.isTSFile,TypeScript,[modName]);if(v9997){var v9992=moduleDecl.name,v22125=modName.length,v17570=v22125-3,v9993=JAMScript.call(modName.substring,modName,[0,v17570]);JAMScript.call(v9992.setText,v9992,[v9993])}else{var v9996=JAMScript.call(TypeScript.isSTRFile,TypeScript,[modName]);if(v9996){var v9994=
moduleDecl.name,v22126=modName.length,v17571=v22126-4,v9995=JAMScript.call(modName.substring,modName,[0,v17571]);JAMScript.call(v9994.setText,v9994,[v9995])}}var v22127=moduleDecl.modFlags,v24358=TypeScript.ModuleFlags,v22128=v24358.Ambient,v17572=JAMScript.call(TypeScript.hasFlag,TypeScript,[v22127,v22128]),v10077=!v17572;if(v10077){var v9998=moduleDecl.modFlags,v17573=TypeScript.ModuleFlags,v9999=v17573.IsDynamic,isDynamicMod=JAMScript.call(TypeScript.hasFlag,TypeScript,[v9998,v9999]),prevOutFile=
this.outfile,prevOutFileName=this.emittingFileName,prevAllSourceMappers=this.allSourceMappers,prevSourceMapper=this.sourceMapper,v10000=this.emitState,prevColumn=v10000.column,v10001=this.emitState,prevLine=v10001.line,v10002=EmitContainer.Module,temp=JAMScript.call(this.setContainer,this,[v10002]),svModuleName=this.moduleName,v10003=moduleDecl.modFlags,v17574=TypeScript.ModuleFlags,v10004=v17574.Exported,isExported=JAMScript.call(TypeScript.hasFlag,TypeScript,[v10003,v10004]),v10005=this.moduleDeclList,
v17575=this.moduleDeclList,v10006=v17575.length;JAMScript.set(v10005,v10006,moduleDecl);var v10007=moduleDecl.modFlags,v17576=TypeScript.ModuleFlags,v10008=v17576.IsWholeFile,isWholeFile=JAMScript.call(TypeScript.hasFlag,TypeScript,[v10007,v10008]),v10009=moduleDecl.name;this.moduleName=v10009.actualText;if(isDynamicMod){var v17577=moduleDecl.name,v10010=v17577.actualText,tsModFileName=JAMScript.call(TypeScript.stripQuotes,TypeScript,[v10010]),v10011=JAMScript.call(TypeScript.trimModName,TypeScript,
[tsModFileName]),modFilePath=v10011+".js",v10012=this.emitOptions,v17578=TypeScript.TypeScriptCompiler,v10013=v17578.mapToJSFileName,modFilePath=JAMScript.call(v10012.mapOutputFileName,v10012,[modFilePath,v10013]),v17579=this.emitOptions,v10024=v17579.ioHost;if(v10024){var v17580=JAMScript.call(TypeScript.switchToForwardSlashes,TypeScript,[modFilePath]),v22129=this.emittingFileName,v17581=JAMScript.call(TypeScript.switchToForwardSlashes,TypeScript,[v22129]),v10023=v17580!=v17581;if(v10023){this.emittingFileName=
modFilePath;var v10014=moduleDecl.containsUnicodeChar,v17583=!v10014;if(v17583){var v22130=this.emitOptions,v17582=v22130.emitComments;v17582&&(v17582=moduleDecl.containsUnicodeCharInComment);v10014=v17582}var useUTF8InOutputfile=v10014,v10015=this.emittingFileName,v27322=JAMScript.call(this.createFile,this,[v10015,useUTF8InOutputfile]);this.outfile=v27322;var v10020=null!=prevSourceMapper;if(v10020){this.allSourceMappers=[];var v17584=this.emittingFileName,v22131=TypeScript.SourceMapper,v17585=v22131.MapFileExtension,
v10016=v17584+v17585,sourceMappingFile=JAMScript.call(this.createFile,this,[v10016,!1]),v17586=TypeScript.SourceMapper,v17587=this.emittingFileName,v17588=this.outfile,v17589=this.errorReporter,v10017=JAMScript.new(v17586,[tsModFileName,v17587,v17588,sourceMappingFile,v17589]);JAMScript.call(this.setSourceMappings,this,[v10017]);var v10018=this.emitState;v10018.column=0;var v10019=this.emitState;v10019.line=0}}else{var v10021=TypeScript.CompilerDiagnostics,v17590=this.emitOptions,v10022=v17590.outputMany;
JAMScript.call(v10021.assert,v10021,[v10022,"Cannot have dynamic modules compiling into single file"])}}var v10025=EmitContainer.DynamicModule;JAMScript.call(this.setContainer,this,[v10025]);JAMScript.call(this.recordSourceMappingStart,this,[moduleDecl]);var v17591=TypeScript.moduleGenTarget,v22132=TypeScript.ModuleGenTarget,v17592=v22132.Asynchronous,v10032=v17591==v17592;if(v10032){for(var dependencyList='["require", "exports"',importList="require, exports",importStatement=null,i=0,v24359=moduleDecl.mod,
v22133=v24359.importedModules,v17593=v22133.length,v10029=i<v17593;v10029;){var v17594=moduleDecl.mod,v10026=v17594.importedModules,importStatement=v10026[i],v22134=importStatement.id,v17595=v22134.sym;if(v17595)var v25439=importStatement.id,v24360=v25439.sym,v22135=v24360.onlyReferencedAsTypeRef,v17595=!v22135;var v10028=v17595;if(v10028){var v25440=moduleDecl.mod,v24361=v25440.importedModules,v22136=v24361.length,v17596=v22136-1,v10027=i<=v17596;v10027&&(dependencyList+=", ",importList+=", ");var v25441=
importStatement.id,v24362=v25441.actualText,v22137="__"+v24362,v17597=v22137+"__",importList=importList+v17597,v17598=dependencyList,v17599=JAMScript.call(importStatement.firstAliasedModToString,importStatement,[]),dependencyList=v17598+v17599}var i=i+1,v24363=moduleDecl.mod,v22138=v24363.importedModules,v17600=v22138.length,v10029=i<v17600}for(var i=0,v22139=moduleDecl.amdDependencies,v17601=v22139.length,v10030=i<v17601;v10030;){var v25442=moduleDecl.amdDependencies;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v24364=
v25442[i];var v22140=', "'+v24364,v17602=v22140+'"',dependencyList=dependencyList+v17602,i=i+1,v22141=moduleDecl.amdDependencies,v17603=v22141.length,v10030=i<v17603}var dependencyList=dependencyList+"]",v25443="define("+dependencyList,v24365=v25443+",",v22142=v24365+" function(",v17604=v22142+importList,v10031=v17604+") {";JAMScript.call(this.writeLineToOutput,this,[v10031])}}else{var v10036=!isExported;if(v10036){JAMScript.call(this.recordSourceMappingStart,this,[moduleDecl]);JAMScript.call(this.writeToOutput,
this,["var "]);var v10033=moduleDecl.name;JAMScript.call(this.recordSourceMappingStart,this,[v10033]);var v10034=this.moduleName;JAMScript.call(this.writeToOutput,this,[v10034]);var v10035=moduleDecl.name;JAMScript.call(this.recordSourceMappingEnd,this,[v10035]);JAMScript.call(this.writeLineToOutput,this,[";"]);JAMScript.call(this.recordSourceMappingEnd,this,[moduleDecl]);JAMScript.call(this.emitIndent,this,[])}JAMScript.call(this.writeToOutput,this,["("]);JAMScript.call(this.recordSourceMappingStart,
this,[moduleDecl]);JAMScript.call(this.writeToOutput,this,["function ("]);var v10037=moduleDecl.name;JAMScript.call(this.recordSourceMappingStart,this,[v10037]);var v10038=this.moduleName;JAMScript.call(this.writeToOutput,this,[v10038]);var v10039=moduleDecl.name;JAMScript.call(this.recordSourceMappingEnd,this,[v10039]);JAMScript.call(this.writeLineToOutput,this,[") {"])}var v10041=!isWholeFile;if(v10041){var v10040=this.moduleName;JAMScript.call(this.recordSourceMappingNameStart,this,[v10040])}var v17605=
!isDynamicMod,v22145=!v17605;if(v22145)var v22143=TypeScript.moduleGenTarget,v24366=TypeScript.ModuleGenTarget,v22144=v24366.Asynchronous,v17605=v22143==v22144;var v10043=v17605;if(v10043){var v10042=this.indenter;JAMScript.call(v10042.increaseIndent,v10042,[])}var v17606=moduleDecl.modFlags,v22146=TypeScript.ModuleFlags,v17607=v22146.MustCaptureThis,v10044=v17606&v17607;v10044&&JAMScript.call(this.writeCaptureThisStatement,this,[moduleDecl]);var v10045=moduleDecl.members,v17608=TypeScript.TokenID,
v10046=v17608.Semicolon;JAMScript.call(this.emitJavascriptList,this,[v10045,null,v10046,!0,!1,!1]);var v17609=!isDynamicMod,v22149=!v17609;if(v22149)var v22147=TypeScript.moduleGenTarget,v24367=TypeScript.ModuleGenTarget,v22148=v24367.Asynchronous,v17609=v22147==v22148;var v10048=v17609;if(v10048){var v10047=this.indenter;JAMScript.call(v10047.decreaseIndent,v10047,[])}JAMScript.call(this.emitIndent,this,[]);if(isDynamicMod){var v17610=TypeScript.moduleGenTarget,v22150=TypeScript.ModuleGenTarget,
v17611=v22150.Asynchronous,v10049=v17610==v17611;v10049&&JAMScript.call(this.writeLineToOutput,this,["})"]);var v10050=!isWholeFile;v10050&&JAMScript.call(this.recordSourceMappingNameEnd,this,[]);JAMScript.call(this.recordSourceMappingEnd,this,[moduleDecl]);var v17612=this.outfile,v10054=v17612!=prevOutFile;if(v10054){JAMScript.call(this.Close,this,[]);var v10053=null!=prevSourceMapper;if(v10053){this.allSourceMappers=prevAllSourceMappers;this.sourceMapper=prevSourceMapper;var v10051=this.emitState;
v10051.column=prevColumn;var v10052=this.emitState;v10052.line=prevLine}this.outfile=prevOutFile;this.emittingFileName=prevOutFileName}}else{var containingMod=null,v17613=moduleDecl.type;if(v17613){var v25444=moduleDecl.type,v24368=v25444.symbol,v22151=v24368.container;if(v22151)var v26068=moduleDecl.type,v25445=v26068.symbol,v24369=v25445.container,v22151=v24369.declAST;v17613=v22151}var v10056=v17613;if(v10056)var v22152=moduleDecl.type,v17614=v22152.symbol,v10055=v17614.container,containingMod=
v10055.declAST;var v10057=containingMod;if(v10057)var v17615=containingMod.modFlags,v22153=TypeScript.ModuleFlags,v17616=v22153.IsDynamic,v10057=JAMScript.call(TypeScript.hasFlag,TypeScript,[v17615,v17616]);var parentIsDynamic=v10057,v10058=moduleDecl.endingToken;JAMScript.call(this.recordSourceMappingStart,this,[v10058]);var v22154=EmitContainer.Prog,v17617=temp==v22154;v17617&&(v17617=isExported);var v10073=v17617;if(v10073){JAMScript.call(this.writeToOutput,this,["}"]);var v10059=!isWholeFile;
v10059&&JAMScript.call(this.recordSourceMappingNameEnd,this,[]);var v10060=moduleDecl.endingToken;JAMScript.call(this.recordSourceMappingEnd,this,[v10060]);var v25446=this.moduleName,v24370=")(this."+v25446,v22155=v24370+" || (this.",v22156=this.moduleName,v17618=v22155+v22156,v10061=v17618+" = {}));";JAMScript.call(this.writeLineToOutput,this,[v10061])}else{var v17619=isExported,v22158=!v17619;if(v22158)var v22157=EmitContainer.Prog,v17619=temp==v22157;var v10072=v17619;if(v10072){var v10062,v17621=
""!=svModuleName;if(v17621){var v22159,v17620=v22159=parentIsDynamic?"exports":svModuleName;v10062=v17620+"."}else v10062=svModuleName;var dotMod=v10062;JAMScript.call(this.writeToOutput,this,["}"]);var v10063=!isWholeFile;v10063&&JAMScript.call(this.recordSourceMappingNameEnd,this,[]);var v10064=moduleDecl.endingToken;JAMScript.call(this.recordSourceMappingEnd,this,[v10064]);var v26069=")("+dotMod,v26070=this.moduleName,v25447=v26069+v26070,v24371=v25447+" || (",v22160=v24371+dotMod,v22161=this.moduleName,
v17622=v22160+v22161,v10065=v17622+" = {}));";JAMScript.call(this.writeLineToOutput,this,[v10065])}else{var v17623=!isExported;if(v17623)var v22162=EmitContainer.Prog,v17623=temp!=v22162;var v10071=v17623;if(v10071){JAMScript.call(this.writeToOutput,this,["}"]);var v10066=!isWholeFile;v10066&&JAMScript.call(this.recordSourceMappingNameEnd,this,[]);var v10067=moduleDecl.endingToken;JAMScript.call(this.recordSourceMappingEnd,this,[v10067]);var v25448=this.moduleName,v24372=")("+v25448,v22163=v24372+
" || (",v22164=this.moduleName,v17624=v22163+v22164,v10068=v17624+" = {}));";JAMScript.call(this.writeLineToOutput,this,[v10068])}else{JAMScript.call(this.writeToOutput,this,["}"]);var v10069=!isWholeFile;v10069&&JAMScript.call(this.recordSourceMappingNameEnd,this,[]);var v10070=moduleDecl.endingToken;JAMScript.call(this.recordSourceMappingEnd,this,[v10070]);JAMScript.call(this.writeLineToOutput,this,[")();"])}}}JAMScript.call(this.recordSourceMappingEnd,this,[moduleDecl]);var v22165=EmitContainer.Prog,
v17625=temp!=v22165;v17625&&(v17625=isExported);var v10076=v17625;if(v10076){JAMScript.call(this.emitIndent,this,[]);JAMScript.call(this.recordSourceMappingStart,this,[moduleDecl]);if(parentIsDynamic){var v25449=this.moduleName,v24373="var "+v25449,v22166=v24373+" = exports.",v22167=this.moduleName,v17626=v22166+v22167,v10074=v17626+";";JAMScript.call(this.writeLineToOutput,this,[v10074])}else{var v26434=this.moduleName,v26071="var "+v26434,v25450=v26071+" = ",v24374=v25450+svModuleName,v22168=v24374+
".",v22169=this.moduleName,v17627=v22168+v22169,v10075=v17627+";";JAMScript.call(this.writeLineToOutput,this,[v10075])}JAMScript.call(this.recordSourceMappingEnd,this,[moduleDecl])}}JAMScript.call(this.setContainer,this,[temp]);this.moduleName=svModuleName;var v17628=this.moduleDeclList,v24375=this.moduleDeclList,v22170=v24375.length;v17628.length=v22170-1}}function v460(funcDecl,printName,isMember,bases,hasSelfRef,classDecl){var v10078=funcDecl.isConstructor;if(v10078)var v17629=funcDecl.fncFlags,
v22171=TypeScript.FncFlags,v17630=v22171.ClassMethod,v10078=JAMScript.call(TypeScript.hasFlag,TypeScript,[v17629,v17630]);var isClassConstructor=v10078,v10079=isClassConstructor;if(v10079){var v26072=this.thisClassNode,v25451=v26072.type,v24376=v25451.instanceType,v22172=v24376.typeFlags,v24377=TypeScript.TypeFlags,v22173=v24377.HasBaseType,v17631=JAMScript.call(TypeScript.hasFlag,TypeScript,[v22172,v22173]);if(v17631)var v26435=this.thisClassNode,v26073=v26435.type,v25452=v26073.instanceType,v24378=
v25452.typeFlags,v25453=TypeScript.TypeFlags,v24379=v25453.HasBaseTypeOfObject,v22174=JAMScript.call(TypeScript.hasFlag,TypeScript,[v24378,v24379]),v17631=!v22174;v10079=v17631}var hasNonObjectBaseType=v10079,v10080=hasNonObjectBaseType;if(v10080)var v22175=this.thisClassNode,v17632=v22175.varFlags,v22176=TypeScript.VarFlags,v17633=v22176.ClassSuperMustBeFirstCallInConstructor,v10080=JAMScript.call(TypeScript.hasFlag,TypeScript,[v17632,v17633]);var classPropertiesMustComeAfterSuperCall=v10080,v17634=
funcDecl.fncFlags,v22177=TypeScript.FncFlags,v17635=v22177.IsFunctionExpression,v10081=JAMScript.call(TypeScript.hasFlag,TypeScript,[v17634,v17635]);if(v10081){var v22178=funcDecl.isParenthesized,v17636=!v22178;if(v17636){var v24380=JAMScript.call(funcDecl.isAccessor,funcDecl,[]),v22179=!v24380;if(v22179){var v25454=funcDecl.flags,v26074=TypeScript.ASTFlags,v25455=v26074.ExplicitSemicolon,v24381=JAMScript.call(TypeScript.hasFlag,TypeScript,[v25454,v25455]),v25458=!v24381;if(v25458)var v25456=funcDecl.flags,
v26075=TypeScript.ASTFlags,v25457=v26075.AutomaticSemicolon,v24381=JAMScript.call(TypeScript.hasFlag,TypeScript,[v25456,v25457]);v22179=v24381}v17636=v22179}v10081=v17636}var shouldParenthesize=v10081;JAMScript.call(this.emitParensAndCommentsInPlace,this,[funcDecl,!0]);shouldParenthesize&&JAMScript.call(this.writeToOutput,this,["("]);JAMScript.call(this.recordSourceMappingStart,this,[funcDecl]);var v22180=JAMScript.call(funcDecl.isAccessor,funcDecl,[]);if(v22180)var v24382=funcDecl.accessorSymbol,
v22180=v24382.isObjectLitField;var v17637=v22180,v10082=!v17637;v10082&&JAMScript.call(this.writeToOutput,this,["function "]);if(printName){var id=JAMScript.call(funcDecl.getNameText,funcDecl,[]),v17638=id;if(v17638)var v22181=JAMScript.call(funcDecl.isAccessor,funcDecl,[]),v17638=!v22181;var v10087=v17638;if(v10087){var v10084=funcDecl.name;if(v10084){var v10083=funcDecl.name;JAMScript.call(this.recordSourceMappingStart,this,[v10083])}JAMScript.call(this.writeToOutput,this,[id]);var v10086=funcDecl.name;
if(v10086){var v10085=funcDecl.name;JAMScript.call(this.recordSourceMappingEnd,this,[v10085])}}}JAMScript.call(this.writeToOutput,this,["("]);var argsLen=0,i=0,arg,defaultArgs=[],v10096=funcDecl.arguments;if(v10096){var v10088=EmitContainer.Args,tempContainer=JAMScript.call(this.setContainer,this,[v10088]),v17639=funcDecl.arguments,v10089=v17639.members,printLen=argsLen=v10089.length,v10090=funcDecl.variableArgList;v10090&&(printLen-=1);for(var i=0,v10095=i<printLen;v10095;){var v17640=funcDecl.arguments,
v10091=v17640.members;arg=v10091[i];var v10092=arg.init;v10092&&JAMScript.call(defaultArgs.push,defaultArgs,[arg]);var v17641=TypeScript.TokenID,v10093=v17641.OpenParen;JAMScript.call(this.emitJavascript,this,[arg,v10093,!1]);var v17642=printLen-1,v10094=i<v17642;v10094&&JAMScript.call(this.writeToOutput,this,[", "]);i+=1;v10095=i<printLen}JAMScript.call(this.setContainer,this,[tempContainer])}JAMScript.call(this.writeLineToOutput,this,[") {"]);var v10102=funcDecl.isConstructor;if(v10102)JAMScript.call(this.recordSourceMappingNameStart,
this,["constructor"]);else{var v10101=JAMScript.call(funcDecl.isGetAccessor,funcDecl,[]);if(v10101){var v17643=JAMScript.call(funcDecl.getNameText,funcDecl,[]),v10097="get_"+v17643;JAMScript.call(this.recordSourceMappingNameStart,this,[v10097])}else{var v10100=JAMScript.call(funcDecl.isSetAccessor,funcDecl,[]);if(v10100){var v17644=JAMScript.call(funcDecl.getNameText,funcDecl,[]),v10098="set_"+v17644;JAMScript.call(this.recordSourceMappingNameStart,this,[v10098])}else{var v10099=JAMScript.call(funcDecl.getNameText,
funcDecl,[]);JAMScript.call(this.recordSourceMappingNameStart,this,[v10099])}}}var v10103=this.indenter;JAMScript.call(v10103.increaseIndent,v10103,[]);for(var i=0,v17645=defaultArgs.length,v10110=i<v17645;v10110;){arg=defaultArgs[i];JAMScript.call(this.emitIndent,this,[]);JAMScript.call(this.recordSourceMappingStart,this,[arg]);var v24383=arg.id,v22182=v24383.actualText,v17646="if (typeof "+v22182,v10104=v17646+' === "undefined") { ';JAMScript.call(this.writeToOutput,this,[v10104]);var v10105=arg.id;
JAMScript.call(this.recordSourceMappingStart,this,[v10105]);var v17647=arg.id,v10106=v17647.actualText;JAMScript.call(this.writeToOutput,this,[v10106]);var v10107=arg.id;JAMScript.call(this.recordSourceMappingEnd,this,[v10107]);JAMScript.call(this.writeToOutput,this,[" = "]);var v10108=arg.init,v17648=TypeScript.TokenID,v10109=v17648.OpenParen;JAMScript.call(this.emitJavascript,this,[v10108,v10109,!1]);JAMScript.call(this.writeLineToOutput,this,["; }"]);JAMScript.call(this.recordSourceMappingEnd,
this,[arg]);var i=i+1,v17649=defaultArgs.length,v10110=i<v17649}var v17650=funcDecl.isConstructor;if(v17650)var v24384=funcDecl.classDecl,v22183=v24384.varFlags,v24385=TypeScript.VarFlags,v22184=v24385.MustCaptureThis,v17650=v22183&v22184;var v10111=v17650;v10111&&JAMScript.call(this.writeCaptureThisStatement,this,[funcDecl]);var v17651=funcDecl.isConstructor;v17651&&(v17651=!classPropertiesMustComeAfterSuperCall);var v10124=v17651;if(v10124){var v10122=funcDecl.arguments;if(v10122)for(var v17652=
funcDecl.arguments,v10112=v17652.members,argsLen=v10112.length,i=0,v10121=i<argsLen;v10121;){var v17653=funcDecl.arguments,v10113=v17653.members;arg=v10113[i];var v22185=arg.varFlags,v24386=TypeScript.VarFlags,v22186=v24386.Property,v17654=v22185&v22186,v22187=TypeScript.VarFlags,v17655=v22187.None,v10120=v17654!=v17655;if(v10120){JAMScript.call(this.emitIndent,this,[]);JAMScript.call(this.recordSourceMappingStart,this,[arg]);var v10114=arg.id;JAMScript.call(this.recordSourceMappingStart,this,[v10114]);
var v22188=arg.id,v17656=v22188.actualText,v10115="this."+v17656;JAMScript.call(this.writeToOutput,this,[v10115]);var v10116=arg.id;JAMScript.call(this.recordSourceMappingEnd,this,[v10116]);JAMScript.call(this.writeToOutput,this,[" = "]);var v10117=arg.id;JAMScript.call(this.recordSourceMappingStart,this,[v10117]);var v17657=arg.id,v10118=v17657.actualText;JAMScript.call(this.writeToOutput,this,[v10118]);var v10119=arg.id;JAMScript.call(this.recordSourceMappingEnd,this,[v10119]);JAMScript.call(this.writeLineToOutput,
this,[";"]);JAMScript.call(this.recordSourceMappingEnd,this,[arg])}i+=1;v10121=i<argsLen}var v22189=funcDecl.fncFlags,v24387=TypeScript.FncFlags,v22190=v24387.ClassMethod,v17658=JAMScript.call(TypeScript.hasFlag,TypeScript,[v22189,v22190]),v10123=!v17658;v10123&&JAMScript.call(this.emitConstructorCalls,this,[bases,classDecl])}hasSelfRef&&JAMScript.call(this.writeCaptureThisStatement,this,[funcDecl]);var v10135=funcDecl.variableArgList;if(v10135){var v17659=funcDecl.arguments,v10125=v17659.members,
argsLen=v10125.length,v17660=funcDecl.arguments,v10126=v17660.members,v10127=argsLen-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var lastArg=v10126[v10127];JAMScript.call(this.emitIndent,this,[]);JAMScript.call(this.recordSourceMappingStart,this,[lastArg]);JAMScript.call(this.writeToOutput,this,["var "]);var v10128=lastArg.id;JAMScript.call(this.recordSourceMappingStart,this,[v10128]);var v17661=lastArg.id,v10129=v17661.actualText;JAMScript.call(this.writeToOutput,
this,[v10129]);var v10130=lastArg.id;JAMScript.call(this.recordSourceMappingEnd,this,[v10130]);JAMScript.call(this.writeLineToOutput,this,[" = [];"]);JAMScript.call(this.recordSourceMappingEnd,this,[lastArg]);JAMScript.call(this.emitIndent,this,[]);JAMScript.call(this.writeToOutput,this,["for ("]);JAMScript.call(this.recordSourceMappingStart,this,[lastArg]);JAMScript.call(this.writeToOutput,this,["var _i = 0;"]);JAMScript.call(this.recordSourceMappingEnd,this,[lastArg]);JAMScript.call(this.writeToOutput,
this,[" "]);JAMScript.call(this.recordSourceMappingStart,this,[lastArg]);var v22191=argsLen-1,v17662="_i < (arguments.length - "+v22191,v10131=v17662+")";JAMScript.call(this.writeToOutput,this,[v10131]);JAMScript.call(this.recordSourceMappingEnd,this,[lastArg]);JAMScript.call(this.writeToOutput,this,["; "]);JAMScript.call(this.recordSourceMappingStart,this,[lastArg]);JAMScript.call(this.writeToOutput,this,["_i++"]);JAMScript.call(this.recordSourceMappingEnd,this,[lastArg]);JAMScript.call(this.writeLineToOutput,
this,[") {"]);var v10132=this.indenter;JAMScript.call(v10132.increaseIndent,v10132,[]);JAMScript.call(this.emitIndent,this,[]);JAMScript.call(this.recordSourceMappingStart,this,[lastArg]);var v25459=lastArg.id,v24388=v25459.actualText,v22192=v24388+"[_i] = arguments[_i + ",v22193=argsLen-1,v17663=v22192+v22193,v10133=v17663+"];";JAMScript.call(this.writeToOutput,this,[v10133]);JAMScript.call(this.recordSourceMappingEnd,this,[lastArg]);JAMScript.call(this.writeLineToOutput,this,[""]);var v10134=this.indenter;
JAMScript.call(v10134.decreaseIndent,v10134,[]);JAMScript.call(this.emitIndent,this,[]);JAMScript.call(this.writeLineToOutput,this,["}"])}var v17664=funcDecl.isConstructor;if(v17664){var v24389=funcDecl.fncFlags,v25460=TypeScript.FncFlags,v24390=v25460.ClassMethod,v22194=JAMScript.call(TypeScript.hasFlag,TypeScript,[v24389,v24390]);v22194&&(v22194=!classPropertiesMustComeAfterSuperCall);v17664=v22194}var v10142=v17664;if(v10142)for(var v22195=this.thisClassNode,v17665=v22195.members,v10136=v17665.members,
nProps=v10136.length,i=0,v10141=i<nProps;v10141;){var v26076=this.thisClassNode,v25461=v26076.members,v24391=v25461.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v22196=v24391[i];var v17666=v22196.nodeType,v22197=TypeScript.NodeType,v17667=v22197.VarDecl,v10140=v17666==v17667;if(v10140){var v22198=this.thisClassNode,v17668=v22198.members,v10137=v17668.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var varDecl=
v10137[i];var v24392=varDecl.varFlags,v25462=TypeScript.VarFlags,v24393=v25462.Static,v22199=JAMScript.call(TypeScript.hasFlag,TypeScript,[v24392,v24393]),v17669=!v22199;v17669&&(v17669=varDecl.init);var v10139=v17669;if(v10139){JAMScript.call(this.emitIndent,this,[]);var v17670=TypeScript.TokenID,v10138=v17670.Tilde;JAMScript.call(this.emitJavascriptVarDecl,this,[varDecl,v10138]);JAMScript.call(this.writeLineToOutput,this,[""])}}i+=1;v10141=i<nProps}var v10143=funcDecl.bod;JAMScript.call(this.emitBareJavascriptStatements,
this,[v10143,classPropertiesMustComeAfterSuperCall]);var v10144=this.indenter;JAMScript.call(v10144.decreaseIndent,v10144,[]);JAMScript.call(this.emitIndent,this,[]);var v10145=funcDecl.endingToken;JAMScript.call(this.recordSourceMappingStart,this,[v10145]);JAMScript.call(this.writeToOutput,this,["}"]);JAMScript.call(this.recordSourceMappingNameEnd,this,[]);var v10146=funcDecl.endingToken;JAMScript.call(this.recordSourceMappingEnd,this,[v10146]);JAMScript.call(this.recordSourceMappingEnd,this,[funcDecl]);
shouldParenthesize&&JAMScript.call(this.writeToOutput,this,[")"]);JAMScript.call(this.recordSourceMappingEnd,this,[funcDecl]);JAMScript.call(this.emitParensAndCommentsInPlace,this,[funcDecl,!1]);var v17671=!isMember;if(v17671){var v25463=funcDecl.fncFlags,v26077=TypeScript.FncFlags,v25464=v26077.IsFunctionExpression,v24394=JAMScript.call(TypeScript.hasFlag,TypeScript,[v25463,v25464]),v22200=!v24394;if(v22200){var v25465=funcDecl.fncFlags,v26078=TypeScript.FncFlags,v25466=v26078.Definition,v24395=
JAMScript.call(TypeScript.hasFlag,TypeScript,[v25465,v25466]),v25467=!v24395;v25467&&(v24395=funcDecl.isConstructor);v22200=v24395}v17671=v22200}var v10149=v17671;if(v10149)JAMScript.call(this.writeLineToOutput,this,[""]);else{var v17672=funcDecl.fncFlags,v22201=TypeScript.FncFlags,v17673=v22201.IsFunctionExpression,v10148=JAMScript.call(TypeScript.hasFlag,TypeScript,[v17672,v17673]);if(v10148){var v22202=funcDecl.flags,v24396=TypeScript.ASTFlags,v22203=v24396.ExplicitSemicolon,v17674=JAMScript.call(TypeScript.hasFlag,
TypeScript,[v22202,v22203]),v22206=!v17674;if(v22206)var v22204=funcDecl.flags,v24397=TypeScript.ASTFlags,v22205=v24397.AutomaticSemicolon,v17674=JAMScript.call(TypeScript.hasFlag,TypeScript,[v22204,v22205]);var v10147=v17674;v10147&&JAMScript.call(this.writeLineToOutput,this,[";"])}}}function v459(bases,classDecl){var v10150=null==bases;if(!v10150){v10150=bases.members;v10150=v10150.length;JAMScript.call(this.recordSourceMappingStart,this,[classDecl]);for(var i=0,v10162=i<v10150;v10162;){v10162=
bases.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v10162=v10162[i];var baseSymbol=null,baseSymbol=v10162.nodeType,v22207=TypeScript.NodeType,v22207=v22207.Call;(baseSymbol=baseSymbol==v22207)?(baseSymbol=v10162.target,baseSymbol=baseSymbol.type):baseSymbol=v10162.type;var baseSymbol=baseSymbol.symbol,v22207=baseSymbol.declModule,v24398=classDecl.type,v24398=v24398.symbol,v24398=v24398.declModule;(v22207=v22207!=v24398)&&JAMScript.call(baseSymbol.fullName,
baseSymbol,[]);baseSymbol=v10162.nodeType;v22207=TypeScript.NodeType;v22207=v22207.Call;if(baseSymbol=baseSymbol==v22207){JAMScript.call(this.emitIndent,this,[]);JAMScript.call(this.writeToOutput,this,["_super.call(this"]);if(baseSymbol=v10162=v10162.arguments)baseSymbol=v10162.members,baseSymbol=baseSymbol.length,baseSymbol=0<baseSymbol;baseSymbol&&(JAMScript.call(this.writeToOutput,this,[", "]),baseSymbol=TypeScript.TokenID,baseSymbol=baseSymbol.Comma,JAMScript.call(this.emitJavascriptList,this,
[v10162,", ",baseSymbol,!1,!1,!1]));JAMScript.call(this.writeToOutput,this,[")"])}else{if(baseSymbol=v10162.type)v10162=v10162.type,baseSymbol=JAMScript.call(v10162.isClassInstance,v10162,[]);if(v10162=baseSymbol)JAMScript.call(this.emitIndent,this,[]),v10162=classDecl.name,v10162=v10162.actualText,v10162+="._super.constructor",JAMScript.call(this.writeToOutput,this,[v10162]),JAMScript.call(this.writeToOutput,this,[".call(this)"])}i+=1;v10162=i<v10150}JAMScript.call(this.recordSourceMappingEnd,this,
[classDecl])}}function v458(callNode,target,args){var v17686=JAMScript.call(this.emitSuperCall,this,[callNode]);if(v17686=!v17686){var v17686=callNode.flags,v24400=TypeScript.ASTFlags,v24400=v24400.ClassBaseConstructorCall,v17686=JAMScript.call(TypeScript.hasFlag,TypeScript,[v17686,v24400]);if(v17686=!v17686){v17686=target.nodeType;v24400=TypeScript.NodeType;v24400=v24400.FuncDecl;if(v17686=v17686==v24400)v17686=target.isParenthesized,v17686=!v17686;v17686&&JAMScript.call(this.writeToOutput,this,
["("]);v17686=callNode.target;v17686=v17686.nodeType;v24400=TypeScript.NodeType;v24400=v24400.Super;if(v17686=v17686==v24400)v17686=this.emitState,v17686=v17686.container,v24400=EmitContainer.Constructor,v17686=v17686==v24400;v17686?JAMScript.call(this.writeToOutput,this,["_super.call"]):(v17686=TypeScript.TokenID,v17686=v17686.OpenParen,JAMScript.call(this.emitJavascript,this,[target,v17686,!1]));v17686=target.nodeType;v24400=TypeScript.NodeType;v24400=v24400.FuncDecl;if(v17686=v17686==v24400)target=
target.isParenthesized,v17686=!target;(target=v17686)&&JAMScript.call(this.writeToOutput,this,[")"]);JAMScript.call(this.recordSourceMappingStart,this,[args]);JAMScript.call(this.writeToOutput,this,["("]);callNode=callNode.target;callNode=callNode.nodeType;target=TypeScript.NodeType;target=target.Super;if(callNode=callNode==target)callNode=this.emitState,callNode=callNode.container,target=EmitContainer.Constructor,callNode=callNode==target;if(callNode){JAMScript.call(this.writeToOutput,this,["this"]);
if(callNode=args)callNode=args.members,callNode=callNode.length;callNode&&JAMScript.call(this.writeToOutput,this,[", "])}callNode=TypeScript.TokenID;callNode=callNode.Comma;JAMScript.call(this.emitJavascriptList,this,[args,", ",callNode,!1,!1,!1]);JAMScript.call(this.writeToOutput,this,[")"]);JAMScript.call(this.recordSourceMappingEnd,this,[args])}else args=this.indenter,JAMScript.call(args.decreaseIndent,args,[]),args=this.indenter,JAMScript.call(args.decreaseIndent,args,[]),args=TypeScript.ASTList,
args=JAMScript.new(args,[]),target=args.members,target[0]=callNode,callNode=this.thisClassNode,JAMScript.call(this.emitConstructorCalls,this,[args,callNode]),args=this.indenter,JAMScript.call(args.increaseIndent,args,[]),args=this.indenter,JAMScript.call(args.increaseIndent,args,[])}}function v457(dotExpr){var v22230=this.emitOptions,v22230=v22230.propagateConstants;if(v22230=!v22230)return!1;if(v22230=dotExpr=dotExpr.operand2)if(v22230=dotExpr.sym)v22230=dotExpr.sym,v22230=JAMScript.call(v22230.isVariable,
v22230,[]);if(v22230){var v22230=dotExpr.sym,v22230=v22230.flags,v22233=TypeScript.SymbolFlags,v22233=v22233.Constant;if(v22230=JAMScript.call(TypeScript.hasFlag,TypeScript,[v22230,v22233]))if(v22230=dotExpr.sym,v22230=v22230.declAST){v22230=dotExpr.sym;v22230=v22230.declAST;if(v22233=v22230.init)var v22233=v22230.init,v22233=v22233.nodeType,v24411=TypeScript.NodeType,v24411=v24411.NumberLit,v22233=v22233==v24411;if(v22233)return v22230=v22230.init,v22230=v22230.value,v22230=JAMScript.call(v22230.toString,
v22230,[]),JAMScript.call(this.writeToOutput,this,[v22230]),v22230=" /* ",dotExpr=dotExpr.actualText,v22230+=dotExpr,v22230+=" */ ",JAMScript.call(this.writeToOutput,this,[v22230]),!0}}return!1}function v456(target,args){JAMScript.call(this.writeToOutput,this,["new "]);var v17703=target.nodeType,v22236=TypeScript.NodeType,v22236=v22236.TypeRef;(v17703=v17703==v22236)?(v17703=target,(v22236=v17703.arrayCount)?JAMScript.call(this.writeToOutput,this,["Array()"]):(v17703=v17703.term,v22236=TypeScript.TokenID,
v22236=v22236.Tilde,JAMScript.call(this.emitJavascript,this,[v17703,v22236,!1]),JAMScript.call(this.writeToOutput,this,["()"]))):(v17703=TypeScript.TokenID,v17703=v17703.Tilde,JAMScript.call(this.emitJavascript,this,[target,v17703,!1]),JAMScript.call(this.recordSourceMappingStart,this,[args]),JAMScript.call(this.writeToOutput,this,["("]),v17703=TypeScript.TokenID,v17703=v17703.Comma,JAMScript.call(this.emitJavascriptList,this,[args,", ",v17703,!1,!1,!1]),JAMScript.call(this.writeToOutput,this,[")"]),
JAMScript.call(this.recordSourceMappingEnd,this,[args]))}function v455(content){JAMScript.call(this.writeToOutput,this,["["]);if(content){JAMScript.call(this.writeLineToOutput,this,[""]);var v10192=this.indenter;JAMScript.call(v10192.increaseIndent,v10192,[]);v10192=TypeScript.TokenID;v10192=v10192.Comma;JAMScript.call(this.emitJavascriptList,this,[content,", ",v10192,!0,!1,!1]);content=this.indenter;JAMScript.call(content.decreaseIndent,content,[]);JAMScript.call(this.emitIndent,this,[])}JAMScript.call(this.writeToOutput,
this,["]"])}function v454(content){JAMScript.call(this.writeLineToOutput,this,["{"]);var v10195=this.indenter;JAMScript.call(v10195.increaseIndent,v10195,[]);var v10195=JAMScript.call(this.setInObjectLiteral,this,[!0]),v17709=TypeScript.TokenID,v17709=v17709.Comma;JAMScript.call(this.emitJavascriptList,this,[content,",",v17709,!0,!1,!1]);JAMScript.call(this.setInObjectLiteral,this,[v10195]);content=this.indenter;JAMScript.call(content.decreaseIndent,content,[]);JAMScript.call(this.emitIndent,this,
[]);JAMScript.call(this.writeToOutput,this,["}"])}function v453(ast,pre){var v10198;v10198=pre?ast.preComments:ast.postComments;var v17710=ast.isParenthesized;v17710&&(v17710=!pre);v17710&&JAMScript.call(this.writeToOutput,this,[")"]);v17710=this.emitOptions;if(v17710=v17710.emitComments)if(v17710=v10198)v17710=v10198.length,v17710=0!=v17710;if(v17710)for(var v17710=0,v17712=v10198.length,v17712=v17710<v17712;v17712;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17712=
v10198[v17710];JAMScript.call(this.emitCommentInPlace,this,[v17712]);v17710+=1;v17712=v10198.length;v17712=v17710<v17712}(v10198=ast.isParenthesized)&&(v10198=pre);v10198&&JAMScript.call(this.writeToOutput,this,["("])}function v452(comment){JAMScript.call(this.recordSourceMappingStart,this,[comment]);var text=JAMScript.call(comment.getText,comment,[]),hadNewLine=!1,v10211=comment.isBlockComment;if(v10211){v10211=this.emitState;v10211=v10211.column;(v10211=0==v10211)&&JAMScript.call(this.emitIndent,
this,[]);v10211=text[0];JAMScript.call(this.writeToOutput,this,[v10211]);var v10211=text.length,v10211=1<v10211,v22241=!v10211;v22241&&(v10211=comment.endsLine);if(v10211){JAMScript.call(this.writeLineToOutput,this,[""]);hadNewLine=1;v10211=text.length;for(v10211=hadNewLine<v10211;v10211;){JAMScript.call(this.emitIndent,this,[]);introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v10211=text[hadNewLine];JAMScript.call(this.writeLineToOutput,this,[v10211]);hadNewLine+=
1;v10211=text.length;v10211=hadNewLine<v10211}hadNewLine=!0}}else hadNewLine=this.emitState,hadNewLine=hadNewLine.column,(hadNewLine=0==hadNewLine)&&JAMScript.call(this.emitIndent,this,[]),text=text[0],JAMScript.call(this.writeLineToOutput,this,[text]),hadNewLine=!0;hadNewLine?JAMScript.call(this.emitIndent,this,[]):JAMScript.call(this.writeToOutput,this,[" "]);JAMScript.call(this.recordSourceMappingEnd,this,[comment])}function v451(){var v10212=JAMScript.call(this.getIndentString,this,[]);JAMScript.call(this.writeToOutput,
this,[v10212])}function v450(){var v17720=this.emitOptions;if(v17720=v17720.minWhitespace)return"";v17720=this.indenter;return JAMScript.call(v17720.getIndent,v17720,[])}function v449(c){var v10215=this.emitState,v10215=v10215.container,v10216=this.emitState;v10216.container=c;return v10215}function v448(val){var v10217=this.emitState,v10217=v10217.inObjectLiteral,v10218=this.emitState;v10218.inObjectLiteral=val;return v10217}function v447(count){var v10219=this.varListCountStack,v22243=this.varListCountStack,
v22243=v22243.length,v22243=v22243-1;v10219[v22243]=count}function v446(ast){JAMScript.call(this.emitIndent,this,[]);JAMScript.call(this.recordSourceMappingStart,this,[ast]);var v10221=this.captureThisStmtString;JAMScript.call(this.writeToOutput,this,[v10221]);JAMScript.call(this.recordSourceMappingEnd,this,[ast]);JAMScript.call(this.writeLineToOutput,this,[""])}function v445(s){var v17722=this.emitOptions;if(v17722=v17722.minWhitespace){JAMScript.call(this.writeToOutput,this,[s]);v17722=s.length;
v17722-=1;s=JAMScript.call(s.charCodeAt,s,[v17722]);var v17722=TypeScript.LexCodeSpace,v17722=s==v17722,v24415=!v17722;v24415&&(v17722=TypeScript.LexCodeSMC,v17722=s==v17722,v24415=!v17722)&&(v17722=TypeScript.LexCodeLBR,v17722=s==v17722);s=v17722;(s=!s)&&JAMScript.call(this.writeToOutput,this,[" "])}else v17722=this.outfile,JAMScript.call(v17722.WriteLine,v17722,[s]),s=this.emitState,s.column=0,v17722=s=this.emitState,v17722=v17722.line,s.line=v17722+1}function v444(s){var v17726=this.emitOptions;
(v17726=v17726.minWhitespace)&&(s=s.replace(/[\s]*/g,""));JAMScript.call(this.writeToOutput,this,[s])}function v443(s){var v10228=this.outfile;JAMScript.call(v10228.Write,v10228,[s]);var v10228=this.emitState,v22246=v10228.column;s=s.length;v10228.column=v22246+s}function v442(mapper){var v10230=this.allSourceMappers;JAMScript.call(v10230.push,v10230,[mapper]);this.sourceMapper=mapper}function Emitter(checker,emittingFileName,outfile,emitOptions,errorReporter){this.checker=checker;this.emittingFileName=
emittingFileName;this.outfile=outfile;this.emitOptions=emitOptions;this.errorReporter=errorReporter;this.prologueEmitted=!1;this.thisFnc=this.thisClassNode=null;this.moduleDeclList=[];this.moduleName="";this.emitState=checker=JAMScript.new(EmitState,[]);this.indenter=checker=JAMScript.new(Indenter,[]);this.ambientModule=!1;this.firstModAlias=this.modAliasId=null;this.allSourceMappers=[];this.sourceMapper=null;this.captureThisStmtString="var _this = this;";this.varListCountStack=[0]}var v10231=Emitter.prototype;
v10231.setSourceMappings=v442;v10231=Emitter.prototype;v10231.writeToOutput=v443;v10231=Emitter.prototype;v10231.writeToOutputTrimmable=v444;v10231=Emitter.prototype;v10231.writeLineToOutput=v445;v10231=Emitter.prototype;v10231.writeCaptureThisStatement=v446;v10231=Emitter.prototype;v10231.setInVarBlock=v447;v10231=Emitter.prototype;v10231.setInObjectLiteral=v448;v10231=Emitter.prototype;v10231.setContainer=v449;v10231=Emitter.prototype;v10231.getIndentString=v450;v10231=Emitter.prototype;v10231.emitIndent=
v451;v10231=Emitter.prototype;v10231.emitCommentInPlace=v452;v10231=Emitter.prototype;v10231.emitParensAndCommentsInPlace=v453;v10231=Emitter.prototype;v10231.emitObjectLiteral=v454;v10231=Emitter.prototype;v10231.emitArrayLiteral=v455;v10231=Emitter.prototype;v10231.emitNew=v456;v10231=Emitter.prototype;v10231.tryEmitConstant=v457;v10231=Emitter.prototype;v10231.emitCall=v458;v10231=Emitter.prototype;v10231.emitConstructorCalls=v459;v10231=Emitter.prototype;v10231.emitInnerFunction=v460;v10231=Emitter.prototype;
v10231.emitJavascriptModule=v461;v10231=Emitter.prototype;v10231.emitIndex=v462;v10231=Emitter.prototype;v10231.emitStringLiteral=v463;v10231=Emitter.prototype;v10231.emitJavascriptFunction=v464;v10231=Emitter.prototype;v10231.emitAmbientVarDecl=v465;v10231=Emitter.prototype;v10231.varListCount=v466;v10231=Emitter.prototype;v10231.emitVarDeclVar=v467;v10231=Emitter.prototype;v10231.onEmitVar=v468;v10231=Emitter.prototype;v10231.emitJavascriptVarDecl=v469;v10231=Emitter.prototype;v10231.declEnclosed=
v470;v10231=Emitter.prototype;v10231.emitJavascriptName=v471;v10231=Emitter.prototype;v10231.emitJavascriptStatements=v472;v10231=Emitter.prototype;v10231.emitBareJavascriptStatements=v473;v10231=Emitter.prototype;v10231.recordSourceMappingNameStart=v474;v10231=Emitter.prototype;v10231.recordSourceMappingNameEnd=v475;v10231=Emitter.prototype;v10231.recordSourceMappingStart=v476;v10231=Emitter.prototype;v10231.recordSourceMappingEnd=v477;v10231=Emitter.prototype;v10231.Close=v478;v10231=Emitter.prototype;
v10231.emitJavascriptList=v479;v10231=Emitter.prototype;v10231.emitJavascript=v480;v10231=Emitter.prototype;v10231.emitPropertyAccessor=v481;v10231=Emitter.prototype;v10231.emitPrototypeMember=v482;v10231=Emitter.prototype;v10231.emitAddBaseMethods=v484;v10231=Emitter.prototype;v10231.emitJavascriptClass=v485;v10231=Emitter.prototype;v10231.emitPrologue=v486;v10231=Emitter.prototype;v10231.emitSuperReference=v487;v10231=Emitter.prototype;v10231.emitSuperCall=v488;v10231=Emitter.prototype;v10231.emitThis=
v489;Emitter.shouldCaptureThis=shouldCaptureThis;v10231=Emitter.prototype;v10231.createFile=v490;return Emitter}function v441(){function v440(){var v10279=Indenter.indentStrings,v10280=this.indentAmt;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v10279=v10279[v10280];if(v10280=void 0===v10279){for(var v10279="",v10280=0,v17727=this.indentAmt,v17727=v10280<v17727;v17727;)v17727=Indenter.indentStepString,v10279+=v17727,v17727=Indenter.indentStep,v10280+=v17727,v17727=
this.indentAmt,v17727=v10280<v17727;v10280=Indenter.indentStrings;v17727=this.indentAmt;JAMScript.set(v10280,v17727,v10279)}return v10279}function v439(){var v17731=this.indentAmt,v17732=Indenter.indentStep;this.indentAmt=v17731-v17732}function v438(){var v17733=this.indentAmt,v17734=Indenter.indentStep;this.indentAmt=v17733+v17734}function Indenter(){this.indentAmt=0}Indenter.indentStep=4;Indenter.indentStepString="    ";Indenter.indentStrings=[];var v10285=Indenter.prototype;v10285.increaseIndent=
v438;v10285=Indenter.prototype;v10285.decreaseIndent=v439;v10285=Indenter.prototype;v10285.getIndent=v440;return Indenter}function v437(){function v436(fileName,extensionChanger){var v10292=this.outputMany;if(v10292){var v10292=fileName,v17735=this.outputOption;if(v17735=""!=v17735)v10292=this.commonDirectoryPath,v10292=fileName.replace(v10292,""),v17735=this.outputOption,v10292=v17735+v10292;return JAMScript.call(extensionChanger,null,[v10292,!1])}v10292=this.outputOption;return JAMScript.call(extensionChanger,
null,[v10292,!0])}function EmitOptions(settings){this.ioHost=null;this.outputMany=!0;this.commonDirectoryPath="";this.minWhitespace=settings.minWhitespace;this.propagateConstants=settings.propagateConstants;this.emitComments=settings.emitComments;this.outputOption=settings.outputOption}var v10293=EmitOptions.prototype;v10293.mapOutputFileName=v436;return EmitOptions}function v435(){function EmitState(){this.line=this.column=0;this.inObjectLiteral=this.pretty=!1;this.container=EmitContainer.Prog}return EmitState}
function v434(EmitContainer){EmitContainer._map=[];var v10294=EmitContainer._map;v10294[0]="Prog";EmitContainer.Prog=0;v10294=EmitContainer._map;v10294[1]="Module";EmitContainer.Module=1;v10294=EmitContainer._map;v10294[2]="DynamicModule";EmitContainer.DynamicModule=2;v10294=EmitContainer._map;v10294[3]="Class";EmitContainer.Class=3;v10294=EmitContainer._map;v10294[4]="Constructor";EmitContainer.Constructor=4;v10294=EmitContainer._map;v10294[5]="Function";EmitContainer.Function=5;v10294=EmitContainer._map;
v10294[6]="Args";EmitContainer.Args=6;v10294=EmitContainer._map;v10294[7]="Interface";EmitContainer.Interface=7}var v17736=TypeScript.EmitContainer,v22248=!v17736;v22248&&(v17736=TypeScript.EmitContainer={});v434(v17736);var EmitContainer=TypeScript.EmitContainer,EmitState=v435();TypeScript.EmitState=EmitState;v17736=v437();TypeScript.EmitOptions=v17736;var Indenter=v441();TypeScript.Indenter=Indenter;v17736=v491();TypeScript.Emitter=v17736}
function v433(){var TypeScript=v12351;function v432(){function EmitSourceMapping(allSourceMappers){function v431(sourceMappings){for(var i=0,v17737=sourceMappings.length,v17737=i<v17737;v17737;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17737=sourceMappings[i];var v10303=v17737.start,v10304=v17737.nameIndex;JAMScript.call(recordSourceMapping,null,[v10303,v10304]);v10303=v17737.childMappings;JAMScript.call(recordSourceMappingSiblings,null,[v10303]);v10303=
v17737.end;v17737=v17737.nameIndex;JAMScript.call(recordSourceMapping,null,[v10303,v17737]);i+=1;v17737=sourceMappings.length;v17737=i<v17737}}function v430(mappedPosition,nameIndex){var v17739=null!=recordedPosition;if(v17739){var v17739=recordedPosition.emittedColumn,v24418=mappedPosition.emittedColumn;if(v17739=v17739==v24418)v17739=recordedPosition.emittedLine,v24418=mappedPosition.emittedLine,v17739=v17739==v24418}if(!v17739){v17739=mappedPosition.emittedLine;if(v17739=prevEmittedLine!==v17739){v17739=
mappedPosition.emittedLine;for(v17739=prevEmittedLine<v17739;v17739;)prevEmittedColumn=0,mappingsString+=";",prevEmittedLine+=1,v17739=mappedPosition.emittedLine,v17739=prevEmittedLine<v17739;emitComma=!1}else emitComma&&(mappingsString+=",");var v17739=mappingsString,v24418=TypeScript.Base64VLQFormat,v22250=mappedPosition.emittedColumn,v22250=v22250-prevEmittedColumn,v24418=JAMScript.call(v24418.encode,v24418,[v22250]);mappingsString=v17739+v24418;prevEmittedColumn=mappedPosition.emittedColumn;v17739=
mappingsString;v24418=TypeScript.Base64VLQFormat;v22250=currentSourceIndex-prevSourceIndex;v24418=JAMScript.call(v24418.encode,v24418,[v22250]);mappingsString=v17739+v24418;prevSourceIndex=currentSourceIndex;v17739=mappingsString;v24418=TypeScript.Base64VLQFormat;v22250=mappedPosition.sourceLine;v22250-=1;v22250-=prevSourceLine;v24418=JAMScript.call(v24418.encode,v24418,[v22250]);mappingsString=v17739+v24418;v17739=mappedPosition.sourceLine;prevSourceLine=v17739-1;v17739=mappingsString;v24418=TypeScript.Base64VLQFormat;
v22250=mappedPosition.sourceColumn;v22250-=prevSourceColumn;v24418=JAMScript.call(v24418.encode,v24418,[v22250]);mappingsString=v17739+v24418;prevSourceColumn=mappedPosition.sourceColumn;if(v17739=0<=nameIndex)v17739=mappingsString,v24418=TypeScript.Base64VLQFormat,v22250=namesCount+nameIndex,v22250-=prevNameIndex,v24418=JAMScript.call(v24418.encode,v24418,[v22250]),mappingsString=v17739+v24418,prevNameIndex=namesCount+nameIndex;emitComma=!0;recordedPosition=mappedPosition}}var sourceMapper=allSourceMappers[0],
v10324=sourceMapper.jsFile,v22254=sourceMapper.jsFileName,v22254="//@ sourceMappingURL="+v22254,v17754=SourceMapper.MapFileExtension,v22254=v22254+v17754;JAMScript.call(v10324.WriteLine,v10324,[v22254]);for(var v10324=sourceMapper.sourceMapOut,mappingsString="",v22254=[],prevEmittedColumn=0,prevEmittedLine=0,prevSourceColumn=0,prevSourceLine=0,prevSourceIndex=0,prevNameIndex=0,v17754=[],namesCount=0,emitComma=!1,recordedPosition=null,sourceMapperIndex=0,v17755=allSourceMappers.length,v17755=sourceMapperIndex<
v17755;v17755;){var sourceMapper=allSourceMappers[sourceMapperIndex],currentSourceIndex=v22254.length,v17755=sourceMapper.tsFileName;JAMScript.call(v22254.push,v22254,[v17755]);v17755=sourceMapper.names;v17755=v17755.length;if(v17755=0<v17755){var v17755=v17754.push,v10328=sourceMapper.names;JAMScript.call(v17755.apply,v17755,[v17754,v10328])}var recordSourceMapping=v430,recordSourceMappingSiblings=v431,v17755=sourceMapper.sourceMappings;JAMScript.call(recordSourceMappingSiblings,null,[v17755,-1]);
v17755=sourceMapper.names;v17755=v17755.length;namesCount+=v17755;sourceMapperIndex+=1;v17755=allSourceMappers.length;v17755=sourceMapperIndex<v17755}if(allSourceMappers=""!=mappingsString)allSourceMappers=sourceMapper.jsFileName,allSourceMappers={version:3,file:allSourceMappers,sources:v22254,names:v17754,mappings:mappingsString},allSourceMappers=JAMScript.call(JSON2.stringify,JSON2,[allSourceMappers]),JAMScript.call(v10324.Write,v10324,[allSourceMappers]);try{JAMScript.call(v10324.Close,v10324,
[])}catch(ex){sourceMapper=sourceMapper.errorReporter,allSourceMappers=ex.message,JAMScript.call(sourceMapper.emitterError,sourceMapper,[null,allSourceMappers])}}function SourceMapper(tsFileName,jsFileName,jsFile,sourceMapOut,errorReporter){this.jsFile=jsFile;this.sourceMapOut=sourceMapOut;this.errorReporter=errorReporter;this.sourceMappings=[];this.currentMappings=[];this.names=[];this.currentNameIndex=[];jsFile=this.currentMappings;sourceMapOut=this.sourceMappings;JAMScript.call(jsFile.push,jsFile,
[sourceMapOut]);jsFileName=JAMScript.call(TypeScript.switchToForwardSlashes,TypeScript,[jsFileName]);jsFile=this.jsFileName=jsFile=JAMScript.call(TypeScript.getPrettyName,TypeScript,[jsFileName,!1,!0]);jsFile=jsFileName.lastIndexOf(jsFile);jsFileName=JAMScript.call(jsFileName.substring,jsFileName,[0,jsFile]);this.tsFileName=tsFileName=JAMScript.call(TypeScript.getRelativePathToFixedPath,TypeScript,[jsFileName,tsFileName])}SourceMapper.MapFileExtension=".map";SourceMapper.EmitSourceMapping=EmitSourceMapping;
return SourceMapper}function v429(){function SourceMapping(){var v27327=JAMScript.new(SourceMapPosition,[]);this.start=v27327;this.end=v27327=JAMScript.new(SourceMapPosition,[]);this.nameIndex=-1;this.childMappings=[]}return SourceMapping}function v428(){function SourceMapPosition(){}return SourceMapPosition}var SourceMapPosition=v428();TypeScript.SourceMapPosition=SourceMapPosition;var SourceMapping=v429();TypeScript.SourceMapping=SourceMapping;SourceMapping=v432();TypeScript.SourceMapper=SourceMapping}
function v427(){function v426(text,reviver){function v425(a){a=JAMScript.call(a.charCodeAt,a,[0]);a=JAMScript.call(a.toString,a,[16]);a="0000"+a;a=a.slice(-4);return"\\u"+a}function walk(holder,key){var k=null,v;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var value=holder[key];if(v=value)v=typeof value,v="object"===v;if(v)for(k in value)if(v=Object.prototype,v=v.hasOwnProperty,v=JAMScript.call(v.call,v,[value,k])){v=walk(value,k);var v10341=void 0!==v;v10341?
JAMScript.set(value,k,v):delete value[k]}return JAMScript.call(reviver.call,reviver,[holder,key,value])}var j;text=String(text);cx.lastIndex=0;(j=cx.test(text))&&(text=text.replace(cx,v425));j=text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,"@");j=j.replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]");j=j.replace(/(?:^|:|,)(?:\s*\[)+/g,"");if(j=/^[\],:{}\s]*$/.test(j)){j="("+text;j+=")";j=JAMScript.isEval(eval)?eval("introspect(JAMScript.introspectors.processAll) { "+
j+" }"):JAMScript.call(eval,null,[j]);var v22261=typeof reviver;if(v22261="function"===v22261)j={"":j},j=walk(j,"");return j}throw new SyntaxError("JSON.parse");}function v424(value,replacer,space){var i;indent=gap="";i=typeof space;if(i="number"===i){i=0;for(var v10348=i<space;v10348;)indent+=" ",i+=1,v10348=i<space}else i=typeof space,(i="string"===i)&&(indent=space);if(space=rep=replacer)if(space=typeof replacer,space="function"!==space)if(space=typeof replacer,space="object"!==space,i=!space)replacer=
replacer.length,replacer=typeof replacer,space="number"!==replacer;if(replacer=space)throw Error("JSON.stringify");value={"":value};return str("",value)}function v423(key){return JAMScript.call(this.valueOf,this,[])}function v422(key){key=JAMScript.call(this.valueOf,this,[]);if(key=isFinite(key)){key=this.getUTCFullYear();key+="-";var v26767=this.getUTCMonth(),v26767=v26767+1,v26767=f(v26767);key+=v26767;key+="-";v26767=this.getUTCDate();v26767=f(v26767);key+=v26767;key+="T";v26767=this.getUTCHours();
v26767=f(v26767);key+=v26767;key+=":";v26767=this.getUTCMinutes();v26767=f(v26767);key+=v26767;key+=":";v26767=this.getUTCSeconds();v26767=f(v26767);key+=v26767;key+="Z"}else key=null;return key}function f(n){var v17772=10>n;return n=v17772?"0"+n:n}function quote(string){function v421(a){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var c=meta[a];var v22266=typeof c;(v22266="string"===v22266)?a=c:(a=JAMScript.call(a.charCodeAt,a,[0]),a=JAMScript.call(a.toString,
a,[16]),a="0000"+a,a=a.slice(-4),a="\\u"+a);return a}escapable.lastIndex=0;var v17777=escapable.test(string);v17777&&(string=string.replace(escapable,v421));string='"'+string;return string+='"'}function str(key,holder){var i,k=null,v,length,mind=gap,partial;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var value=holder[key];if(partial=value)if(partial=typeof value,partial="object"===partial)partial=value.toJSON,partial=typeof partial,partial="function"===partial;
partial&&(value=JAMScript.call(value.toJSON,value,[key]));partial=typeof rep;(partial="function"===partial)&&(value=JAMScript.call(rep.call,rep,[holder,key,value]));partial=typeof value;switch(partial){case "string":return quote(value);case "number":return mind=(mind=isFinite(value))?String(value):"null";case "boolean":case "null":return String(value);case "object":if(partial=!value)return"null";gap+=indent;partial=[];i=Object.prototype;i=i.toString;i=JAMScript.call(i.apply,i,[value,[]]);if(i="[object Array]"===
i){length=value.length;i=0;for(k=i<length;k;){k=partial;v=i;var v17782=str(i,value),v22271=!v17782;v22271&&(v17782="null");k[v]=v17782;i+=1;k=i<length}value=partial.length;(value=0===value)?value="[]":(gap?(value="[\n"+gap,k=",\n"+gap,partial=partial.join(k),value+=partial,value+="\n",value+=mind):(value=partial.join(","),value="["+value),value+="]");v=value;gap=mind;return v}if(i=rep)i=typeof rep,i="object"===i;if(i)for(length=rep.length,i=0,k=i<length;k;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)k=
rep[i];k=typeof k;if(k="string"===k){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)k=rep[i];if(v=str(k,value))k=quote(k),v17782=gap?": ":":",k+=v17782,k+=v,JAMScript.call(partial.push,partial,[k])}i+=1;k=i<length}else for(k in value)if(i=Object.prototype,i=i.hasOwnProperty,i=JAMScript.call(i.call,i,[value,k]))if(v=str(k,value))i=quote(k),length=gap?": ":":",i+=length,i+=v,JAMScript.call(partial.push,partial,[i]);value=partial.length;(value=0===value)?value="{}":
(gap?(value="{\n"+gap,k=",\n"+gap,partial=partial.join(k),value+=partial,value+="\n",value+=mind):(value=partial.join(","),value="{"+value),value+="}");v=value;gap=mind;return v}}var v24438=Date.prototype,v24438=v24438.toJSON,v24438=typeof v24438;if(v24438="function"!==v24438){v24438=Date.prototype;v24438.toJSON=v422;var v24438=String.prototype,numProto=Number.prototype,v10375=Boolean.prototype;numProto.JSON=v24438.JSON=v10375.toJSON=v423}var cx=/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
escapable=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,gap,indent,meta={"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"},rep,v24438=JSON2.stringify,v24438=typeof v24438;if(v24438="function"!==v24438)JSON2.stringify=v424;v24438=JSON2.parse;v24438=typeof v24438;if(v24438="function"!==v24438)JSON2.parse=v426}
function v420(){var TypeScript=v12350;function v419(){function decode(inString){for(var result=0,negative=!1,shift=0,i=0,v17795=inString.length,v17795=i<v17795;v17795;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17795=inString[i];var v17795=JAMScript.call(Base64Format.decodeChar,Base64Format,[v17795]),v10383=0===i;v10383?(result=v17795&1,(result=1===result)&&(negative=!0),result=v17795>>1,result&=15):(v10383=v17795&31,v10383<<=shift,result|=v10383);v10383=
(v10383=0==i)?4:5;shift+=v10383;v17795&=32;v17795=32===v17795;if(!v17795)return negative=negative?-result:result,i+=1,inString=inString.substr(i),{value:negative,rest:inString};i+=1;v17795=inString.length;v17795=i<v17795}inString='Base64 value "'+inString;inString+='" finished with a continuation bit';throw Error(inString);}function encode(inValue){var v10390=0>inValue;v10390?(inValue=-inValue,inValue<<=1,inValue+=1):inValue<<=1;var v10390="",v10394=0<inValue;do{v10394=inValue&31;inValue>>=5;var v10391=
0<inValue;v10391&&(v10394|=32);v10394=JAMScript.call(Base64Format.encode,Base64Format,[v10394]);v10390+=v10394;v10394=0<inValue}while(v10394);return v10390}function Base64VLQFormat(){}Base64VLQFormat.encode=encode;Base64VLQFormat.decode=decode;return Base64VLQFormat}function v418(){function decodeChar(inChar){var v17805=inChar.length;if(v17805=1===v17805)return v17805=Base64Format.encodedValues,v17805.indexOf(inChar);inChar='"'+inChar;inChar+='" must have length 1';throw TypeError(inChar);}function encode(inValue){var v10399=
64>inValue;if(v10399)return v10399=Base64Format.encodedValues,v10399.charAt(inValue);inValue+=": not a 64 based value";throw TypeError(inValue);}function Base64Format(){}Base64Format.encodedValues="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";Base64Format.encode=encode;Base64Format.decodeChar=decodeChar;return Base64Format}var Base64Format=v418(),Base64VLQFormat=v419();TypeScript.Base64VLQFormat=Base64VLQFormat}
function v417(){var TypeScript=v12349;function v416(){function v415(scope,table){function v414(key,sym,binder){JAMScript.call(binder.bindSymbol,binder,[scope,sym])}JAMScript.call(table.map,table,[v414,this])}function v413(scope,symbol){function v412(id){return JAMScript.call(scope.find,scope,[id,!1,!0])}var v17807=symbol.bound;if(v17807=!v17807){var v17807=this.checker,v17807=v17807.locationInfo,v22289=this.checker;if(v22289=v22289.units)if(v22289=symbol.unitIndex,v22289=0<=v22289)var v22289=symbol.unitIndex,
v26086=this.checker,v26086=v26086.units,v26086=v26086.length,v22289=v22289<v26086;if(v22289){var v26086=v22289=this.checker,v26086=v26086.units,v17810=symbol.unitIndex;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v22289.locationInfo=v26086[v17810]}v22289=JAMScript.call(symbol.kind,symbol,[]);switch(v22289){case TypeScript.SymbolKind.Type:v22289=symbol.flags;v26086=TypeScript.SymbolFlags;v26086=v26086.Bound;if(v22289&=v26086)break;v22289=symbol;v26086=v22289.flags;
v17810=TypeScript.SymbolFlags;v17810=v17810.Bound;v22289.flags=v26086|v17810;if(v26086=v22289.aliasLink)if(v26086=v22289.type,v26086=!v26086)v26086=v22289.aliasLink,v26086=v26086.alias,v26086=v26086.nodeType,v17810=TypeScript.NodeType,v17810=v17810.Name,v26086=v26086==v17810;if(v26086){var v26086=v22289.aliasLink,v26086=v26086.alias,v26086=v26086.text,v22295=v17810=this.checker,v22295=v22295.locationInfo,v22295=v22295.filename;if(v17810=JAMScript.call(v17810.findSymbolForDynamicModule,v17810,[v26086,
v22295,v412]))v26086=v22289,v17810=JAMScript.call(v17810.getType,v17810,[]),v26086.type=v17810}if(v26086=v22289.type)v26086=v22289.type,v17810=this.checker,v17810=v17810.gloModType,v26086=v26086!=v17810;if(v26086&&(v26086=v22289.type,v17810=v22289.instanceType,JAMScript.call(this.bindType,this,[scope,v26086,v17810]),v26086=v22289.type,v26086=JAMScript.call(v26086.isModuleType,v26086,[])))for(v26086=0,v17810=v22289.expansions,v17810=v17810.length,v17810=v26086<v17810;v17810;){v17810=v22289.expansions;
introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17810=v17810[v26086];v22295=v22289.instanceType;JAMScript.call(this.bindType,this,[scope,v17810,v22295]);v26086+=1;v17810=v22289.expansions;v17810=v17810.length;v17810=v26086<v17810}break;case TypeScript.SymbolKind.Field:v22289=this.checker;v26086=symbol.field;v26086=v26086.typeLink;JAMScript.call(v22289.resolveTypeLink,v22289,[scope,v26086,!1]);break;case TypeScript.SymbolKind.Parameter:v22289=this.checker,v26086=
symbol.parameter,v26086=v26086.typeLink,JAMScript.call(v22289.resolveTypeLink,v22289,[scope,v26086,!0])}v22289=this.checker;v22289.locationInfo=v17807}symbol.bound=!0}function v411(scope,type,instanceType){instanceType&&JAMScript.call(this.bindType,this,[scope,instanceType,null]);var v10439=JAMScript.call(type.hasMembers,type,[]);if(v10439){var members=type.members,ambientMembers=type.ambientMembers,typeMembers=JAMScript.call(type.getAllEnclosedTypes,type,[]),v10439=JAMScript.call(type.getAllAmbientEnclosedTypes,
type,[]),v10424=TypeScript.SymbolTableScope,v10425=type.symbol,memberScope=JAMScript.new(v10424,[members,ambientMembers,typeMembers,v10439,v10425]),v10424=TypeScript.SymbolAggregateScope,v10425=type.symbol,v10424=JAMScript.new(v10424,[v10425]),v10425=this.checker,v10425=v10425.currentModDecl,v10429=this.checker,v10429=v10429.inBind;JAMScript.call(v10424.addParentScope,v10424,[memberScope]);JAMScript.call(v10424.addParentScope,v10424,[scope]);if(memberScope=JAMScript.call(type.isModuleType,type,[])){var memberScope=
this.checker,v17825=type.symbol;memberScope.currentModDecl=v17825.declAST;memberScope=this.checker;memberScope.inBind=!0}members&&(members=type.members,members=members.allMembers,JAMScript.call(this.bind,this,[v10424,members]));typeMembers&&(typeMembers=typeMembers.allMembers,JAMScript.call(this.bind,this,[v10424,typeMembers]));ambientMembers&&(ambientMembers=ambientMembers.allMembers,JAMScript.call(this.bind,this,[v10424,ambientMembers]));v10439&&(v10439=v10439.allMembers,JAMScript.call(this.bind,
this,[v10424,v10439]));v10439=this.checker;v10439.currentModDecl=v10425;v10439=this.checker;v10439.inBind=v10429}(v10439=type.extendsTypeLinks)&&JAMScript.call(this.resolveBases,this,[scope,type]);if(v10439=type.construct)v10439=type.construct,JAMScript.call(this.resolveSignatureGroup,this,[v10439,scope,instanceType]);if(instanceType=type.call)instanceType=type.call,JAMScript.call(this.resolveSignatureGroup,this,[instanceType,scope,null]);if(instanceType=type.index)instanceType=type.index,JAMScript.call(this.resolveSignatureGroup,
this,[instanceType,scope,null]);if(instanceType=type.elementType)type=type.elementType,JAMScript.call(this.bindType,this,[scope,type,null])}function v410(signatureGroup,scope,instanceType){for(var v10449=signatureGroup.hasImplementation,v10449=!v10449,i=0,v10450=signatureGroup.signatures,v10450=v10450.length,v10464=i<v10450;v10464;){v10464=signatureGroup.signatures;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v10464=v10464[i];if(instanceType){var v10452=v10464.returnType;
v10452.type=instanceType}else{var v10452=this.checker,v10454=v10464.returnType;JAMScript.call(v10452.resolveTypeLink,v10452,[scope,v10454,v10449])}for(var v10452=v10464.parameters,v10452=v10452.length,v10454=0,v10457=v10454<v10452;v10457;){v10457=v10464.parameters;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v10457=v10457[v10454];JAMScript.call(this.bindSymbol,this,[scope,v10457]);v10454+=1;v10457=v10454<v10452}if(v10454=v10464.hasVariableArgList){v10464=v10464.parameters;
v10454=v10452-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v10464=v10464[v10454];v10464.argsOffset=v10452-1;v10452=JAMScript.call(v10464.getType,v10464,[]);v10452=JAMScript.call(v10452.isArray,v10452,[]);if(v10452=!v10452)v10452=this.checker,v10452=v10452.errorReporter,JAMScript.call(v10452.simpleErrorFromSym,v10452,[v10464,"... parameter must have array type"]),v10452=v10464.parameter,v10452=v10452.typeLink,v10454=this.checker,v10464=v10464.parameter,v10464=
v10464.typeLink,v10464=v10464.type,v10464=JAMScript.call(v10454.makeArrayType,v10454,[v10464]),v10452.type=v10464}i+=1;v10464=i<v10450}}function v409(scope,type){var v10465=type,v17833=type.extendsTypeLinks,v17833=JAMScript.call(this.resolveBaseTypeLinks,this,[v17833,scope]);v10465.extendsList=v17833;for(var v17833=0,v10465=type.extendsList,len=v10465.length,v10465=JAMScript.call(type.isClassInstance,type,[]),v10475=v17833<len;v10475;){v10475=type.extendsList;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v10475=
v10475[v17833];var baseIsClass=JAMScript.call(v10475.isClassInstance,v10475,[]),v10475=type.extendsList;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v10475=v10475[v17833];var v22303=this.checker,v22303=v22303.anyType;if(v10475=v10475!=v22303){v10475=type.extendsTypeLinks;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v10475=v10475[v17833];v10475=v10475.ast;if(v10465){if(baseIsClass=!baseIsClass){baseIsClass=this.checker;baseIsClass=
baseIsClass.errorReporter;v22303=type.extendsList;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v22303=v22303[v17833];v22303=v22303.symbol;v22303=JAMScript.call(v22303.fullName,v22303,[]);v22303="A class may only extend other classes, "+v22303;v22303+=" is not a class.";JAMScript.call(baseIsClass.simpleError,baseIsClass,[v10475,v22303])}}else if(baseIsClass){baseIsClass=this.checker;baseIsClass=baseIsClass.errorReporter;v22303=type.extendsList;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v22303=
v22303[v17833];v22303=v22303.symbol;v22303=JAMScript.call(v22303.fullName,v22303,[]);v22303="An interface may only extend other interfaces, "+v22303;v22303+=" is a class.";JAMScript.call(baseIsClass.simpleError,baseIsClass,[v10475,v22303])}}v17833+=1;v10475=v17833<len}v17833=type;len=type.implementsTypeLinks;len=JAMScript.call(this.resolveBaseTypeLinks,this,[len,scope]);v17833.implementsList=len;if(v17833=type.implementsList)for(v17833=0,len=type.implementsList,len=len.length,v10475=v17833<len;v10475;){v10475=
type.implementsList;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)baseIsClass=v10475[v17833];v10475=type.implementsTypeLinks;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v10475=v10475[v17833];v10475=v10475.ast;(v22303=JAMScript.call(baseIsClass.isClassInstance,baseIsClass,[]))&&v10465&&(v22303=this.checker,v22303=v22303.errorReporter,baseIsClass=baseIsClass.symbol,baseIsClass=JAMScript.call(baseIsClass.fullName,baseIsClass,
[]),baseIsClass="A class may only implement an interface; "+baseIsClass,baseIsClass+=" is a class.",JAMScript.call(v22303.simpleError,v22303,[v10475,baseIsClass]));v17833+=1;v10475=v17833<len}}function v408(typeLinks,scope){var extendsList=null;if(typeLinks)for(var extendsList=[],i=0,len=typeLinks.length,v10486=i<len;v10486;){var v10486=extendsList,v10485=i,v17847=this.checker;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v17848=typeLinks[i];v17847=JAMScript.call(v17847.resolveBaseTypeLink,
v17847,[v17848,scope]);v10486[v10485]=v17847;i+=1;v10486=i<len}return extendsList}function Binder(checker){this.checker=checker}var v10487=Binder.prototype;v10487.resolveBaseTypeLinks=v408;v10487=Binder.prototype;v10487.resolveBases=v409;v10487=Binder.prototype;v10487.resolveSignatureGroup=v410;v10487=Binder.prototype;v10487.bindType=v411;v10487=Binder.prototype;v10487.bindSymbol=v413;v10487=Binder.prototype;v10487.bind=v415;return Binder}var Binder=v416();TypeScript.Binder=Binder}
function v407(){var TypeScript=v12348;function v406(){function v405(script,position){var lineInfo={line:-1,col:-1},v17849=script.locationInfo,v17849=v17849.lineMap;JAMScript.call(TypeScript.getSourceLineColFromMap,TypeScript,[lineInfo,position,v17849]);v17849=lineInfo.col;if(v17849=-1!==v17849)v17849=lineInfo.col,lineInfo.col=v17849+1;v17849=lineInfo.line;v17849="("+v17849;v17849+=", ";lineInfo=lineInfo.col;lineInfo=v17849+lineInfo;return lineInfo+")"}function v404(s,targetLength,paddingString,leftPadding){var v10496;
v10496=leftPadding?"":s;for(var i=s.length,v10497=i<targetLength;v10497;)v10496+=paddingString,i+=1,v10497=i<targetLength;s=leftPadding?s:"";return v10496+=s}function v403(linemap){for(var result="[",i=0,v17855=linemap.length,v17855=i<v17855;v17855;){(v17855=0<i)&&(result+=",");introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17855=linemap[i];result+=v17855;i+=1;v17855=linemap.length;v17855=i<v17855}result+="]";linemap=this.logger;result="linemap: "+result;JAMScript.call(linemap.log,
linemap,[result])}function v402(script,comments,indent){var v10503=null==comments;if(!v10503)for(var v10503=0,v17858=comments.length,v17858=v10503<v17858;v17858;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17858=comments[v10503];JAMScript.call(this.logNode,this,[script,v17858,indent]);v10503+=1;v17858=comments.length;v17858=v10503<v17858}}function v401(script,cur,indent){indent=JAMScript.call(this.addPadding,this,["",indent,"| ",!0]);var v17860=JAMScript.call(cur.treeViewLabel,
cur,[]),v17860="+ "+v17860;indent=indent.concat(v17860);indent=JAMScript.call(this.addPadding,this,[indent,70," ",!1]);v17860=cur.minChar;v17860=JAMScript.call(this.addLineColumn,this,[script,v17860]);indent+=v17860;indent=JAMScript.call(this.addPadding,this,[indent,80," ",!1]);indent+="=> ";v17860=cur.limChar;script=JAMScript.call(this.addLineColumn,this,[script,v17860]);indent+=script;indent=JAMScript.call(this.addPadding,this,[indent,102," ",!1]);script=cur.minChar;script=JAMScript.call(script.toString,
script,[]);script=JAMScript.call(this.addPadding,this,[script,1," ",!0]);script="["+script;script+=", ";v17860=cur.limChar;v17860=JAMScript.call(v17860.toString,v17860,[]);v17860=JAMScript.call(this.addPadding,this,[v17860,1," ",!0]);script+=v17860;script+="]";indent=indent.concat(script);indent=JAMScript.call(this.addPadding,this,[indent,115," ",!1]);script=cur.sym;script="sym="+script;indent=indent.concat(script);indent=JAMScript.call(this.addPadding,this,[indent,135," ",!1]);script=cur.type;(script=
null===script)?cur="null":(cur=cur.type,cur=JAMScript.call(cur.getTypeName,cur,[]));cur="type="+cur;indent=indent.concat(cur);cur=this.logger;JAMScript.call(cur.log,cur,[indent])}function v400(script){function post(cur,parent){JAMScript.call(stack.pop,stack,[]);return cur}function pre(cur,parent){JAMScript.call(stack.push,stack,[cur]);var v17866=stack.length,v17866=v17866-1,v17866=2*v17866,v10516=cur.preComments;JAMScript.call(_this.logComments,_this,[script,v10516,v17866]);JAMScript.call(_this.logNode,
_this,[script,cur,v17866]);v10516=cur.postComments;JAMScript.call(_this.logComments,_this,[script,v10516,v17866]);return cur}var _this=this,v17867=script.locationInfo,v17867=v17867.lineMap;JAMScript.call(this.logLinemap,this,[v17867]);var stack=[],v17867=JAMScript.call(TypeScript.getAstWalkerFactory,TypeScript,[]);JAMScript.call(v17867.walk,v17867,[script,pre,post])}function AstLogger(logger){this.logger=logger}var v10520=AstLogger.prototype;v10520.logScript=v400;v10520=AstLogger.prototype;v10520.logNode=
v401;v10520=AstLogger.prototype;v10520.logComments=v402;v10520=AstLogger.prototype;v10520.logLinemap=v403;v10520=AstLogger.prototype;v10520.addPadding=v404;v10520=AstLogger.prototype;v10520.addLineColumn=v405;return AstLogger}var AstLogger=v406();TypeScript.AstLogger=AstLogger}
function v399(){var TypeScript=v12347;function v398(GetAstPathOptions){GetAstPathOptions._map=[];GetAstPathOptions.Default=0;GetAstPathOptions.EdgeInclusive=1;GetAstPathOptions.DontPruneSearchBasedOnPosition=2}function v397(){function AstPathContext(){var v10526=TypeScript.AstPath;this.path=v10526=JAMScript.new(v10526,[])}return AstPathContext}function v396(){function v395(){var v17868=JAMScript.call(this.count,this,[]);if(v17868=1<=v17868){var v17868=this.asts,v26091=this.top,v26091=v26091-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17868=
v17868[v26091];v17868=v17868.nodeType;v26091=TypeScript.NodeType;v26091=v26091.Block;if(v17868=v17868===v26091){v17868=this.asts;v26091=this.top;v26091-=0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17868=v17868[v26091];v17868=v17868.isStatementBlock;v17868=!1===v17868}}return v17868}function v394(){var v17870=JAMScript.call(this.count,this,[]);if(v17870=2<=v17870){var v17870=this.asts,v26093=this.top,v26093=v26093-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17870=
v17870[v26093];v17870=v17870.nodeType;v26093=TypeScript.NodeType;v26093=v26093.List;if(v17870=v17870===v26093){v17870=this.asts;v26093=this.top;v26093-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17870=v17870[v26093];v17870=v17870.nodeType;v26093=TypeScript.NodeType;v26093=v26093.New;if(v17870=v17870===v26093){v17870=this.asts;v26093=this.top;v26093-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17870=v17870[v26093];
var v17870=v17870.arguments,v26093=this.asts,v26098=this.top,v26098=v26098-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26093=v26093[v26098];v17870=v17870===v26093}}}return v17870}function v393(){var v17872=JAMScript.call(this.count,this,[]);if(v17872=2<=v17872){var v17872=this.asts,v26099=this.top,v26099=v26099-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17872=v17872[v26099];v17872=v17872.nodeType;v26099=TypeScript.NodeType;
v26099=v26099.List;if(v17872=v17872===v26099){v17872=this.asts;v26099=this.top;v26099-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17872=v17872[v26099];v17872=v17872.nodeType;v26099=TypeScript.NodeType;v26099=v26099.Call;if(v17872=v17872===v26099){v17872=this.asts;v26099=this.top;v26099-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17872=v17872[v26099];var v17872=v17872.arguments,v26099=this.asts,v26104=this.top,v26104=
v26104-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26099=v26099[v26104];v17872=v17872===v26099}}}return v17872}function v392(){var v17874=JAMScript.call(this.count,this,[]);if(v17874=3<=v17874){var v17874=this.asts,v26105=this.top,v26105=v26105-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17874=v17874[v26105];v17874=v17874.nodeType;v26105=TypeScript.NodeType;v26105=v26105.List;if(v17874=v17874===v26105){v17874=this.asts;
v26105=this.top;v26105-=2;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17874=v17874[v26105];v17874=v17874.nodeType;v26105=TypeScript.NodeType;v26105=v26105.FuncDecl;if(v17874=v17874===v26105){v17874=this.asts;v26105=this.top;v26105-=2;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17874=v17874[v26105];var v17874=v17874.arguments,v26105=this.asts,v26110=this.top,v26110=v26110-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26105=
v26105[v26110];v17874=v17874===v26105}}}return v17874}function v391(){var v17876=JAMScript.call(this.count,this,[]);if(v17876=2<=v17876){var v17876=this.asts,v26111=this.top,v26111=v26111-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17876=v17876[v26111];v17876=v17876.nodeType;v26111=TypeScript.NodeType;v26111=v26111.List;if(v17876=v17876===v26111){v17876=this.asts;v26111=this.top;v26111-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17876=
v17876[v26111];v17876=v17876.nodeType;v26111=TypeScript.NodeType;v26111=v26111.FuncDecl;if(v17876=v17876===v26111){v17876=this.asts;v26111=this.top;v26111-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17876=v17876[v26111];var v17876=v17876.arguments,v26111=this.asts,v26116=this.top,v26116=v26116-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26111=v26111[v26116];v17876=v17876===v26111}}}return v17876}function v390(){var v17878=
JAMScript.call(this.count,this,[]);if(v17878=1<=v17878){var v17878=this.asts,v25521=this.top;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17878=v17878[v25521];v17878=v17878.nodeType;v25521=TypeScript.NodeType;v25521=v25521.List;if(v17878=v17878===v25521){v17878=this.asts;v25521=this.top;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17878=v17878[v25521];v17878=v17878.members;v17878=v17878.length;v17878=1===v17878}}return v17878}
function v389(){return JAMScript.call(this.isBodyOfCase,this,[])}function v388(){var v17880=JAMScript.call(this.count,this,[]);if(v17880=2<=v17880){var v17880=this.asts,v26119=this.top,v26119=v26119-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17880=v17880[v26119];v17880=v17880.nodeType;v26119=TypeScript.NodeType;v26119=v26119.If;if(v17880=v17880===v26119){v17880=this.asts;v26119=this.top;v26119-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17880=
v17880[v26119];var v17880=v17880.elseBod,v26119=this.asts,v25527=this.top,v25527=v25527-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26119=v26119[v25527];v17880=v17880==v26119}}return v17880}function v387(){var v17882=JAMScript.call(this.count,this,[]);if(v17882=2<=v17882){var v17882=this.asts,v26121=this.top,v26121=v26121-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17882=v17882[v26121];v17882=v17882.nodeType;v26121=
TypeScript.NodeType;v26121=v26121.If;if(v17882=v17882===v26121){v17882=this.asts;v26121=this.top;v26121-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17882=v17882[v26121];var v17882=v17882.thenBod,v26121=this.asts,v25532=this.top,v25532=v25532-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26121=v26121[v25532];v17882=v17882==v26121}}return v17882}function v386(){var v17884=JAMScript.call(this.count,this,[]);if(v17884=
2<=v17884){var v17884=this.asts,v25533=this.top,v25533=v25533-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17884=v17884[v25533];v17884=v17884.nodeType;v25533=TypeScript.NodeType;v25533=v25533.List;v17884=v17884===v25533}return v17884}function v385(){var v17887=JAMScript.call(this.count,this,[]);if(v17887=2<=v17887){var v17887=this.asts,v26123=this.top,v26123=v26123-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17887=
v17887[v26123];v17887=v17887.nodeType;v26123=TypeScript.NodeType;v26123=v26123.Member;if(v17887=v17887===v26123){v17887=this.asts;v26123=this.top;v26123-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17887=v17887[v26123];var v17887=v17887.operand2,v26123=this.asts,v25538=this.top,v25538=v25538-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26123=v26123[v25538];v17887=v17887===v26123}}return v17887}function v384(){var v17889=
JAMScript.call(this.count,this,[]);if(v17889=2<=v17889){var v17889=this.asts,v26125=this.top,v26125=v26125-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17889=v17889[v26125];v17889=v17889.nodeType;v26125=TypeScript.NodeType;v26125=v26125.Member;if(v17889=v17889===v26125){v17889=this.asts;v26125=this.top;v26125-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17889=v17889[v26125];var v17889=v17889.operand1,v26125=this.asts,
v25543=this.top,v25543=v25543-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26125=v26125[v25543];v17889=v17889===v26125}}return v17889}function v383(){var v17891=JAMScript.call(this.count,this,[]);if(v17891=2<=v17891){var v17891=this.asts,v26127=this.top,v26127=v26127-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17891=v17891[v26127];v17891=v17891.nodeType;v26127=TypeScript.NodeType;v26127=v26127.ArrayLit;if(v17891=v17891===
v26127){v17891=this.asts;v26127=this.top;v26127-=0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17891=v17891[v26127];v17891=v17891.nodeType;v26127=TypeScript.NodeType;v26127=v26127.List;if(v17891=v17891===v26127){v17891=this.asts;v26127=this.top;v26127-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17891=v17891[v26127];var v17891=v17891.operand,v26127=this.asts,v26132=this.top,v26132=v26132-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26127=
v26127[v26132];v17891=v17891==v26127}}}return v17891}function v382(){var v17893=JAMScript.call(this.count,this,[]);if(v17893=4<=v17893){var v17893=this.asts,v26133=this.top,v26133=v26133-3;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17893=v17893[v26133];v17893=v17893.nodeType;v26133=TypeScript.NodeType;v26133=v26133.ObjectLit;if(v17893=v17893===v26133){v17893=this.asts;v26133=this.top;v26133-=2;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17893=
v17893[v26133];v17893=v17893.nodeType;v26133=TypeScript.NodeType;v26133=v26133.List;if(v17893=v17893===v26133){v17893=this.asts;v26133=this.top;v26133-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17893=v17893[v26133];v17893=v17893.nodeType;v26133=TypeScript.NodeType;v26133=v26133.Member;if(v17893=v17893===v26133){v17893=this.asts;v26133=this.top;v26133-=0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17893=v17893[v26133];
v17893=v17893.nodeType;v26133=TypeScript.NodeType;v26133=v26133.Name;if(v17893=v17893===v26133){v17893=this.asts;v26133=this.top;v26133-=3;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17893=v17893[v26133];var v17893=v17893.operand,v26133=this.asts,v26599=this.top,v26599=v26599-2;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26133=v26133[v26599];v17893=v17893==v26133}}}}}return v17893}function v381(){var v17895=JAMScript.call(this.count,
this,[]);if(v17895=3<=v17895){var v17895=this.asts,v26142=this.top,v26142=v26142-2;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17895=v17895[v26142];v17895=v17895.nodeType;v26142=TypeScript.NodeType;v26142=v26142.ObjectLit;if(v17895=v17895===v26142){v17895=this.asts;v26142=this.top;v26142-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17895=v17895[v26142];v17895=v17895.nodeType;v26142=TypeScript.NodeType;v26142=v26142.List;
if(v17895=v17895===v26142){v17895=this.asts;v26142=this.top;v26142-=0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17895=v17895[v26142];v17895=v17895.nodeType;v26142=TypeScript.NodeType;v26142=v26142.Member;if(v17895=v17895===v26142){v17895=this.asts;v26142=this.top;v26142-=2;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17895=v17895[v26142];var v17895=v17895.operand,v26142=this.asts,v26464=this.top,v26464=v26464-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26142=
v26142[v26464];v17895=v17895==v26142}}}}return v17895}function v380(){var v17897=JAMScript.call(this.count,this,[]);if(v17897=2<=v17897){var v17897=this.asts,v26150=this.top,v26150=v26150-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17897=v17897[v26150];v17897=v17897.nodeType;v26150=TypeScript.NodeType;v26150=v26150.ObjectLit;if(v17897=v17897===v26150){v17897=this.asts;v26150=this.top;v26150-=0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17897=
v17897[v26150];v17897=v17897.nodeType;v26150=TypeScript.NodeType;v26150=v26150.List;if(v17897=v17897===v26150){v17897=this.asts;v26150=this.top;v26150-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17897=v17897[v26150];var v17897=v17897.operand,v26150=this.asts,v26468=this.top,v26468=v26468-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26150=v26150[v26468];if(v17897=v17897==v26150){v17897=this.asts;v26150=this.top;v26150-=
0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17897=v17897[v26150];v17897=v17897.members;v17897=v17897.length;v17897=0==v17897}}}}return v17897}function v379(){return JAMScript.call(this.isListOfObjectLit,this,[])}function v378(){var v17899=JAMScript.call(this.count,this,[]);if(v17899=2<=v17899){var v17899=this.asts,v26157=this.top,v26157=v26157-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17899=v17899[v26157];v17899=
v17899.nodeType;v26157=TypeScript.NodeType;v26157=v26157.ObjectLit;if(v17899=v17899===v26157){v17899=this.asts;v26157=this.top;v26157-=0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17899=v17899[v26157];v17899=v17899.nodeType;v26157=TypeScript.NodeType;v26157=v26157.List;if(v17899=v17899===v26157){v17899=this.asts;v26157=this.top;v26157-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17899=v17899[v26157];var v17899=v17899.operand,
v26157=this.asts,v26162=this.top,v26162=v26162-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26157=v26157[v26162];v17899=v17899==v26157}}}return v17899}function v377(){var v17901=JAMScript.call(this.count,this,[]);if(v17901=3<=v17901){var v17901=this.asts,v26163=this.top,v26163=v26163-2;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17901=v17901[v26163];v17901=v17901.nodeType;v26163=TypeScript.NodeType;v26163=v26163.Switch;
if(v17901=v17901===v26163){v17901=this.asts;v26163=this.top;v26163-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17901=v17901[v26163];v17901=v17901.nodeType;v26163=TypeScript.NodeType;v26163=v26163.List;if(v17901=v17901===v26163){v17901=this.asts;v26163=this.top;v26163-=2;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17901=v17901[v26163];var v17901=v17901.caseList,v26163=this.asts,v26475=this.top,v26475=v26475-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26163=
v26163[v26475];if(v17901=v17901==v26163){v17901=this.asts;v26163=this.top;v26163-=2;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17901=v17901[v26163];v17901=v17901.defaultCase;v26163=this.asts;v26475=this.top;v26475-=0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26163=v26163[v26475];v17901=v17901==v26163}}}}return v17901}function v376(){var v17903=JAMScript.call(this.count,this,[]);if(v17903=3<=v17903){var v17903=this.asts,
v26172=this.top,v26172=v26172-2;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17903=v17903[v26172];v17903=v17903.nodeType;v26172=TypeScript.NodeType;v26172=v26172.Switch;if(v17903=v17903===v26172){v17903=this.asts;v26172=this.top;v26172-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17903=v17903[v26172];v17903=v17903.nodeType;v26172=TypeScript.NodeType;v26172=v26172.List;if(v17903=v17903===v26172){v17903=this.asts;v26172=
this.top;v26172-=2;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17903=v17903[v26172];var v17903=v17903.caseList,v26172=this.asts,v26177=this.top,v26177=v26177-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26172=v26172[v26177];v17903=v17903==v26172}}}return v17903}function v375(){var v17905=JAMScript.call(this.count,this,[]);if(v17905=2<=v17905){var v17905=this.asts,v26178=this.top,v26178=v26178-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17905=
v17905[v26178];v17905=v17905.nodeType;v26178=TypeScript.NodeType;v26178=v26178.Finally;if(v17905=v17905===v26178){v17905=this.asts;v26178=this.top;v26178-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17905=v17905[v26178];var v17905=v17905.body,v26178=this.asts,v25599=this.top,v25599=v25599-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26178=v26178[v25599];v17905=v17905==v26178}}return v17905}function v374(){var v17907=
JAMScript.call(this.count,this,[]);if(v17907=2<=v17907){var v17907=this.asts,v26180=this.top,v26180=v26180-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17907=v17907[v26180];v17907=v17907.nodeType;v26180=TypeScript.NodeType;v26180=v26180.With;if(v17907=v17907===v26180){v17907=this.asts;v26180=this.top;v26180-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17907=v17907[v26180];var v17907=v17907.body,v26180=this.asts,v25604=
this.top,v25604=v25604-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26180=v26180[v25604];v17907=v17907==v26180}}return v17907}function v373(){var v17909=JAMScript.call(this.count,this,[]);if(v17909=2<=v17909){var v17909=this.asts,v26182=this.top,v26182=v26182-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17909=v17909[v26182];v17909=v17909.nodeType;v26182=TypeScript.NodeType;v26182=v26182.ForIn;if(v17909=v17909===v26182){v17909=
this.asts;v26182=this.top;v26182-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17909=v17909[v26182];var v17909=v17909.body,v26182=this.asts,v25609=this.top,v25609=v25609-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26182=v26182[v25609];v17909=v17909==v26182}}return v17909}function v372(){var v17911=JAMScript.call(this.count,this,[]);if(v17911=2<=v17911){var v17911=this.asts,v26184=this.top,v26184=v26184-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17911=
v17911[v26184];v17911=v17911.nodeType;v26184=TypeScript.NodeType;v26184=v26184.While;if(v17911=v17911===v26184){v17911=this.asts;v26184=this.top;v26184-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17911=v17911[v26184];var v17911=v17911.body,v26184=this.asts,v25614=this.top,v25614=v25614-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26184=v26184[v25614];v17911=v17911==v26184}}return v17911}function v371(){var v17913=
JAMScript.call(this.count,this,[]);if(v17913=2<=v17913){var v17913=this.asts,v26186=this.top,v26186=v26186-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17913=v17913[v26186];v17913=v17913.nodeType;v26186=TypeScript.NodeType;v26186=v26186.DoWhile;if(v17913=v17913===v26186){v17913=this.asts;v26186=this.top;v26186-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17913=v17913[v26186];var v17913=v17913.body,v26186=this.asts,
v25619=this.top,v25619=v25619-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26186=v26186[v25619];v17913=v17913==v26186}}return v17913}function v370(){var v17915=JAMScript.call(this.count,this,[]);if(v17915=2<=v17915){var v17915=this.asts,v26188=this.top,v26188=v26188-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17915=v17915[v26188];v17915=v17915.nodeType;v26188=TypeScript.NodeType;v26188=v26188.Catch;if(v17915=v17915===
v26188){v17915=this.asts;v26188=this.top;v26188-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17915=v17915[v26188];var v17915=v17915.body,v26188=this.asts,v25624=this.top,v25624=v25624-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26188=v26188[v25624];v17915=v17915==v26188}}return v17915}function v369(){var v17917=JAMScript.call(this.count,this,[]);if(v17917=2<=v17917){var v17917=this.asts,v26190=this.top,v26190=v26190-
1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17917=v17917[v26190];v17917=v17917.nodeType;v26190=TypeScript.NodeType;v26190=v26190.Try;if(v17917=v17917===v26190){v17917=this.asts;v26190=this.top;v26190-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17917=v17917[v26190];var v17917=v17917.body,v26190=this.asts,v25629=this.top,v25629=v25629-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26190=
v26190[v25629];v17917=v17917==v26190}}return v17917}function v368(){var v17919=JAMScript.call(this.count,this,[]);if(v17919=2<=v17919){var v17919=this.asts,v26192=this.top,v26192=v26192-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17919=v17919[v26192];v17919=v17919.nodeType;v26192=TypeScript.NodeType;v26192=v26192.Case;if(v17919=v17919===v26192){v17919=this.asts;v26192=this.top;v26192-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17919=
v17919[v26192];var v17919=v17919.body,v26192=this.asts,v25634=this.top,v25634=v25634-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26192=v26192[v25634];v17919=v17919==v26192}}return v17919}function v367(){var v17921=JAMScript.call(this.count,this,[]);if(v17921=2<=v17921){var v17921=this.asts,v26194=this.top,v26194=v26194-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17921=v17921[v26194];v17921=v17921.nodeType;v26194=TypeScript.NodeType;
v26194=v26194.For;if(v17921=v17921===v26194){v17921=this.asts;v26194=this.top;v26194-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17921=v17921[v26194];var v17921=v17921.body,v26194=this.asts,v25639=this.top,v25639=v25639-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26194=v26194[v25639];v17921=v17921==v26194}}return v17921}function v366(){var v17923=JAMScript.call(this.count,this,[]);if(v17923=2<=v17923){var v17923=
this.asts,v26196=this.top,v26196=v26196-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17923=v17923[v26196];v17923=v17923.nodeType;v26196=TypeScript.NodeType;v26196=v26196.Block;if(v17923=v17923===v26196){v17923=this.asts;v26196=this.top;v26196-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17923=v17923[v26196];var v17923=v17923.statements,v26196=this.asts,v25644=this.top,v25644=v25644-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26196=
v26196[v25644];v17923=v17923==v26196}}return v17923}function v365(){var v17925=JAMScript.call(this.count,this,[]);if(v17925=2<=v17925){var v17925=this.asts,v26198=this.top,v26198=v26198-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17925=v17925[v26198];v17925=v17925.nodeType;v26198=TypeScript.NodeType;v26198=v26198.InterfaceDeclaration;if(v17925=v17925===v26198){v17925=this.asts;v26198=this.top;v26198-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17925=
v17925[v26198];var v17925=v17925.members,v26198=this.asts,v25649=this.top,v25649=v25649-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26198=v26198[v25649];v17925=v17925==v26198}}return v17925}function v364(){var v17927=JAMScript.call(this.count,this,[]);if(v17927=2<=v17927){var v17927=this.asts,v26200=this.top,v26200=v26200-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17927=v17927[v26200];v17927=v17927.nodeType;v26200=
TypeScript.NodeType;v26200=v26200.FuncDecl;if(v17927=v17927===v26200){v17927=this.asts;v26200=this.top;v26200-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17927=v17927[v26200];var v17927=v17927.bod,v26200=this.asts,v25654=this.top,v25654=v25654-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26200=v26200[v25654];v17927=v17927==v26200}}return v17927}function v363(){var v17929=JAMScript.call(this.count,this,[]);if(v17929=
2<=v17929){var v17929=this.asts,v26202=this.top,v26202=v26202-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17929=v17929[v26202];v17929=v17929.nodeType;v26202=TypeScript.NodeType;v26202=v26202.ClassDeclaration;if(v17929=v17929===v26202){v17929=this.asts;v26202=this.top;v26202-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17929=v17929[v26202];var v17929=v17929.members,v26202=this.asts,v25659=this.top,v25659=v25659-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26202=
v26202[v25659];v17929=v17929==v26202}}return v17929}function v362(){var v17931=JAMScript.call(this.count,this,[]);if(v17931=2<=v17931){var v17931=this.asts,v26204=this.top,v26204=v26204-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17931=v17931[v26204];v17931=v17931.nodeType;v26204=TypeScript.NodeType;v26204=v26204.ModuleDeclaration;if(v17931=v17931===v26204){v17931=this.asts;v26204=this.top;v26204-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17931=
v17931[v26204];var v17931=v17931.members,v26204=this.asts,v25664=this.top,v25664=v25664-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26204=v26204[v25664];v17931=v17931==v26204}}return v17931}function v361(){var v17933=JAMScript.call(this.count,this,[]);if(v17933=2<=v17933){var v17933=this.asts,v26206=this.top,v26206=v26206-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17933=v17933[v26206];v17933=v17933.nodeType;v26206=
TypeScript.NodeType;v26206=v26206.Switch;if(v17933=v17933===v26206){v17933=this.asts;v26206=this.top;v26206-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17933=v17933[v26206];var v17933=v17933.caseList,v26206=this.asts,v25669=this.top,v25669=v25669-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26206=v26206[v25669];v17933=v17933==v26206}}return v17933}function v360(){var v17935=JAMScript.call(this.count,this,[]);if(v17935=
2<=v17935){var v17935=this.asts,v26208=this.top,v26208=v26208-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17935=v17935[v26208];v17935=v17935.nodeType;v26208=TypeScript.NodeType;v26208=v26208.Script;if(v17935=v17935===v26208){v17935=this.asts;v26208=this.top;v26208-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17935=v17935[v26208];var v17935=v17935.bod,v26208=this.asts,v25674=this.top,v25674=v25674-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26208=
v26208[v25674];v17935=v17935==v26208}}return v17935}function v359(){var v17937=JAMScript.call(this.count,this,[]);if(v17937=2<=v17937){var v17937=this.asts,v26210=this.top,v26210=v26210-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17937=v17937[v26210];v17937=v17937.nodeType;v26210=TypeScript.NodeType;v26210=v26210.List;if(v17937=v17937===v26210){v17937=this.asts;v26210=this.top;v26210-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17937=
v17937[v26210];v17937=v17937.nodeType;v26210=TypeScript.NodeType;v26210=v26210.ModuleDeclaration;if(v17937=v17937===v26210){v17937=this.asts;v26210=this.top;v26210-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17937=v17937[v26210];var v17937=v17937.members,v26210=this.asts,v26484=this.top,v26484=v26484-0;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v26210=v26210[v26484];if(v17937=v17937==v26210){v17937=this.asts;v26210=
this.top;v26210-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17937=v17937[v26210];v17937=v17937.modFlags;v26210=TypeScript.ModuleFlags;v26210=v26210.IsWholeFile;v17937=JAMScript.call(TypeScript.hasFlag,TypeScript,[v17937,v26210])}}}}return v17937}function v358(){var v17939=JAMScript.call(this.count,this,[]);if(v17939=1<=v17939){var v17939=this.asts,v25684=this.top;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17939=v17939[v25684];
v17939=v17939.nodeType;v25684=TypeScript.NodeType;v25684=v25684.ModuleDeclaration;if(v17939=v17939===v25684){v17939=this.asts;v25684=this.top;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17939=v17939[v25684];v17939=v17939.modFlags;v25684=TypeScript.ModuleFlags;v25684=v25684.IsWholeFile;v17939=JAMScript.call(TypeScript.hasFlag,TypeScript,[v17939,v25684])}}return v17939}function v357(){var v10563=this.asts,v10563=lastOf(v10563),v17941=JAMScript.call(this.count,
this,[]);if(v17941=3<=v17941){var v17941=this.asts,v24636=this.top;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17941=v17941[v24636];if(v10563=v17941===v10563){v10563=this.asts;v17941=this.top;v17941-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v10563=v10563[v17941];v10563=v10563.nodeType;v17941=TypeScript.NodeType;v17941=v17941.List;if(v10563=v10563===v17941){v10563=this.asts;v17941=this.top;v17941-=2;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v10563=
v10563[v17941];v10563=v10563.nodeType;v17941=TypeScript.NodeType;v17941=v17941.InterfaceDeclaration;v10563=v10563===v17941}}v17941=v10563}return v17941}function v356(){var v10565=this.asts,v10565=lastOf(v10565),v17943=JAMScript.call(this.count,this,[]);if(v17943=5<=v17943){var v17943=this.asts,v24642=this.top;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17943=v17943[v24642];if(v10565=v17943===v10565){v10565=this.asts;v17943=this.top;v17943-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v10565=
v10565[v17943];v10565=v10565.nodeType;v17943=TypeScript.NodeType;v17943=v17943.List;if(v10565=v10565===v17943){v10565=this.asts;v17943=this.top;v17943-=2;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v10565=v10565[v17943];v10565=v10565.nodeType;v17943=TypeScript.NodeType;v17943=v17943.FuncDecl;if(v10565=v10565===v17943){v10565=this.asts;v17943=this.top;v17943-=3;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v10565=v10565[v17943];
v10565=v10565.nodeType;v17943=TypeScript.NodeType;v17943=v17943.List;if(v10565=v10565===v17943){v10565=this.asts;v17943=this.top;v17943-=4;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v10565=v10565[v17943];v10565=v10565.nodeType;v17943=TypeScript.NodeType;v17943=v17943.ClassDeclaration;if(v10565=v10565===v17943){v10565=this.asts;v17943=this.top;v17943-=2;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v10565=v10565[v17943];if(v10565=
v10565.isConstructor){v10565=this.asts;v17943=this.top;v17943-=2;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v10565=v10565[v17943];v10565=v10565.arguments;v17943=this.asts;v24642=this.top;v24642-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17943=v17943[v24642];if(v10565=v10565===v17943){v10565=this.asts;v17943=this.top;v17943-=4;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v10565=
v10565[v17943];v10565=v10565.constructorDecl;v17943=this.asts;v24642=this.top;v24642-=2;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17943=v17943[v24642];v10565=v10565===v17943}}}}}}}v17943=v10565}return v17943}function v355(){var v10567=this.asts,v10567=lastOf(v10567),v17945=JAMScript.call(this.count,this,[]);if(v17945=3<=v17945){var v17945=this.asts,v24647=this.top;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17945=v17945[v24647];
if(v10567=v17945===v10567){v10567=this.asts;v17945=this.top;v17945-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v10567=v10567[v17945];v10567=v10567.nodeType;v17945=TypeScript.NodeType;v17945=v17945.List;if(v10567=v10567===v17945){v10567=this.asts;v17945=this.top;v17945-=2;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v10567=v10567[v17945];v10567=v10567.nodeType;v17945=TypeScript.NodeType;v17945=v17945.ClassDeclaration;v10567=
v10567===v17945}}v17945=v10567}return v17945}function v354(){var v10569=this.asts,v10569=lastOf(v10569),v17947=JAMScript.call(this.count,this,[]);if(v17947=3<=v17947){var v17947=this.asts,v24653=this.top;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17947=v17947[v24653];if(v10569=v17947===v10569){v10569=this.asts;v17947=this.top;v17947-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v10569=v10569[v17947];v10569=v10569.nodeType;
v17947=TypeScript.NodeType;v17947=v17947.List;if(v10569=v10569===v17947){v10569=this.asts;v17947=this.top;v17947-=2;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v10569=v10569[v17947];v10569=v10569.nodeType;v17947=TypeScript.NodeType;v17947=v17947.ModuleDeclaration;v10569=v10569===v17947}}v17947=v10569}return v17947}function v353(){var v10571=this.asts,v10571=lastOf(v10571),v17949=JAMScript.call(this.count,this,[]);if(v17949=3<=v17949){var v17949=this.asts,v24659=
this.top;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v17949=v17949[v24659];if(v10571=v17949===v10571){v10571=this.asts;v17949=this.top;v17949-=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v10571=v10571[v17949];v10571=v10571.nodeType;v17949=TypeScript.NodeType;v17949=v17949.List;if(v10571=v10571===v17949){v10571=this.asts;v17949=this.top;v17949-=2;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v10571=
v10571[v17949];v10571=v10571.nodeType;v17949=TypeScript.NodeType;v17949=v17949.Script;v10571=v10571===v17949}}v17949=v10571}return v17949}function v352(){var v22449=JAMScript.call(this.ast,this,[]),v22449=null===v22449,v22451=!v22449;v22451&&(v22449=JAMScript.call(this.parent,this,[]),v22449=null===v22449);if(v22449)return!1;v22449=JAMScript.call(this.ast,this,[]);v22449=v22449.nodeType;v22451=TypeScript.NodeType;v22451=v22451.Name;if(v22449=v22449===v22451)if(v22449=JAMScript.call(this.parent,this,
[]),v22449=v22449.nodeType,v22451=TypeScript.NodeType,v22451=v22451.FuncDecl,v22449=v22449===v22451)v22449=JAMScript.call(this.parent,this,[]),v22449=v22449.name,v22451=JAMScript.call(this.ast,this,[]),v22449=v22449===v22451;return v22449}function v351(){var v22458=JAMScript.call(this.ast,this,[]),v22458=null===v22458,v22460=!v22458;v22460&&(v22458=JAMScript.call(this.parent,this,[]),v22458=null===v22458);if(v22458)return!1;v22458=JAMScript.call(this.ast,this,[]);v22458=v22458.nodeType;v22460=TypeScript.NodeType;
v22460=v22460.Name;if(v22458=v22458===v22460)if(v22458=JAMScript.call(this.parent,this,[]),v22458=v22458.nodeType,v22460=TypeScript.NodeType,v22460=v22460.ModuleDeclaration,v22458=v22458===v22460)v22458=JAMScript.call(this.parent,this,[]),v22458=v22458.name,v22460=JAMScript.call(this.ast,this,[]),v22458=v22458===v22460;return v22458}function v350(){var v22467=JAMScript.call(this.ast,this,[]),v22467=null===v22467,v22469=!v22467;v22469&&(v22467=JAMScript.call(this.parent,this,[]),v22467=null===v22467);
if(v22467)return!1;v22467=JAMScript.call(this.ast,this,[]);v22467=v22467.nodeType;v22469=TypeScript.NodeType;v22469=v22469.Name;if(v22467=v22467===v22469)if(v22467=JAMScript.call(this.parent,this,[]),v22467=v22467.nodeType,v22469=TypeScript.NodeType,v22469=v22469.VarDecl,v22467=v22467===v22469)v22467=JAMScript.call(this.parent,this,[]),v22467=v22467.id,v22469=JAMScript.call(this.ast,this,[]),v22467=v22467===v22469;return v22467}function v349(){var v22476=JAMScript.call(this.ast,this,[]),v22476=null===
v22476,v22478=!v22476;v22478&&(v22476=JAMScript.call(this.parent,this,[]),v22476=null===v22476);if(v22476)return!1;v22476=JAMScript.call(this.ast,this,[]);v22476=v22476.nodeType;v22478=TypeScript.NodeType;v22478=v22478.Name;if(v22476=v22476===v22478)if(v22476=JAMScript.call(this.parent,this,[]),v22476=v22476.nodeType,v22478=TypeScript.NodeType,v22478=v22478.ArgDecl,v22476=v22476===v22478)v22476=JAMScript.call(this.parent,this,[]),v22476=v22476.id,v22478=JAMScript.call(this.ast,this,[]),v22476=v22476===
v22478;return v22476}function v348(){var v22485=JAMScript.call(this.ast,this,[]),v22485=null===v22485,v22487=!v22485;v22487&&(v22485=JAMScript.call(this.parent,this,[]),v22485=null===v22485);if(v22485)return!1;v22485=JAMScript.call(this.ast,this,[]);v22485=v22485.nodeType;v22487=TypeScript.NodeType;v22487=v22487.Name;if(v22485=v22485===v22487)if(v22485=JAMScript.call(this.parent,this,[]),v22485=v22485.nodeType,v22487=TypeScript.NodeType,v22487=v22487.InterfaceDeclaration,v22485=v22485===v22487)v22485=
JAMScript.call(this.parent,this,[]),v22485=v22485.name,v22487=JAMScript.call(this.ast,this,[]),v22485=v22485===v22487;return v22485}function v347(){var v22494=JAMScript.call(this.ast,this,[]),v22494=null===v22494,v22496=!v22494;v22496&&(v22494=JAMScript.call(this.parent,this,[]),v22494=null===v22494);if(v22494)return!1;v22494=JAMScript.call(this.ast,this,[]);v22494=v22494.nodeType;v22496=TypeScript.NodeType;v22496=v22496.Name;if(v22494=v22494===v22496)if(v22494=JAMScript.call(this.parent,this,[]),
v22494=v22494.nodeType,v22496=TypeScript.NodeType,v22496=v22496.ClassDeclaration,v22494=v22494===v22496)v22494=JAMScript.call(this.parent,this,[]),v22494=v22494.name,v22496=JAMScript.call(this.ast,this,[]),v22494=v22494===v22496;return v22494}function v346(index){var v10585=this.asts;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v10585[index]}function v345(){var v10586=this.top;return v10586+1}function v344(){var v10587=this.asts,v22503=this.asts,v22503=
v22503.length,v17976=this.top,v22503=v22503-v17976;return JAMScript.call(AstPath.reverseIndexOf,AstPath,[v10587,v22503])}function v343(){var v10589=this.asts,v22504=this.asts,v22504=v22504.length,v22505=this.top,v22505=v22505+1,v22504=v22504-v22505;return JAMScript.call(AstPath.reverseIndexOf,AstPath,[v10589,v22504])}function v342(){var v17979=JAMScript.call(this.ast,this,[]);if(v17979=null==v17979)return v17979=TypeScript.NodeType,v17979.None;v17979=JAMScript.call(this.ast,this,[]);return v17979.nodeType}
function v341(){var v17980=this.top,v24682=this.ast,v24682=v24682.length,v24682=v24682-1;if(v17980=v17980==v24682)throw Error("Invalid call to 'down'");v17980=this.top;this.top=v17980+1}function v340(){var v17983=this.top;if(v17983=-1>=v17983)throw Error("Invalid call to 'up'");v17983=this.top;this.top=v17983-1}function v339(ast){for(var v22507=this.asts,v22507=v22507.length,v17986=JAMScript.call(this.count,this,[]),v22507=v22507>v17986;v22507;)v22507=this.asts,JAMScript.call(v22507.pop,v22507,[]),
v22507=this.asts,v22507=v22507.length,v17986=JAMScript.call(this.count,this,[]),v22507=v22507>v17986;v22507=this.asts;this.top=v22507.length;v22507=this.asts;JAMScript.call(v22507.push,v22507,[ast])}function v338(){var head=JAMScript.call(this.ast,this,[]);JAMScript.call(this.up,this,[]);for(var v22509=this.asts,v22509=v22509.length,v17990=JAMScript.call(this.count,this,[]),v22509=v22509>v17990;v22509;)v22509=this.asts,JAMScript.call(v22509.pop,v22509,[]),v22509=this.asts,v22509=v22509.length,v17990=
JAMScript.call(this.count,this,[]),v22509=v22509>v17990;return head}function v337(){function v336(value){return value}var clone=new AstPath,v10602=clone,v17993=this.asts,v17993=JAMScript.call(v17993.map,v17993,[v336]);v10602.asts=v17993;clone.top=this.top;return clone}function reverseIndexOf(items,index){var v10603;v10603=null===items;var v24684=!v10603;v24684&&(v10603=items.length,v10603=v10603<=index);v10603?v10603=null:(v10603=items.length,v10603-=index,v10603-=1,v10603=items[v10603]);return v10603}
function AstPath(){this.asts=[];this.top=-1}AstPath.reverseIndexOf=reverseIndexOf;var v10604=AstPath.prototype;v10604.clone=v337;var v10605=AstPath.prototype;v10605.pop=v338;var v10606=AstPath.prototype;v10606.push=v339;var v10607=AstPath.prototype;v10607.up=v340;var v10608=AstPath.prototype;v10608.down=v341;var v10609=AstPath.prototype;v10609.nodeType=v342;var v10610=AstPath.prototype;v10610.ast=v343;var v10611=AstPath.prototype;v10611.parent=v344;var v10612=AstPath.prototype;v10612.count=v345;var v10613=
AstPath.prototype;v10613.get=v346;var v10614=AstPath.prototype;v10614.isNameOfClass=v347;var v10615=AstPath.prototype;v10615.isNameOfInterface=v348;var v10616=AstPath.prototype;v10616.isNameOfArgument=v349;var v10617=AstPath.prototype;v10617.isNameOfVariable=v350;var v10618=AstPath.prototype;v10618.isNameOfModule=v351;var v10619=AstPath.prototype;v10619.isNameOfFunction=v352;var v10620=AstPath.prototype;v10620.isChildOfScript=v353;var v10621=AstPath.prototype;v10621.isChildOfModule=v354;var v10622=
AstPath.prototype;v10622.isChildOfClass=v355;var v10623=AstPath.prototype;v10623.isArgumentOfClassConstructor=v356;var v10624=AstPath.prototype;v10624.isChildOfInterface=v357;var v10625=AstPath.prototype;v10625.isTopLevelImplicitModule=v358;var v10626=AstPath.prototype;v10626.isBodyOfTopLevelImplicitModule=v359;var v10627=AstPath.prototype;v10627.isBodyOfScript=v360;var v10628=AstPath.prototype;v10628.isBodyOfSwitch=v361;var v10629=AstPath.prototype;v10629.isBodyOfModule=v362;var v10630=AstPath.prototype;
v10630.isBodyOfClass=v363;var v10631=AstPath.prototype;v10631.isBodyOfFunction=v364;var v10632=AstPath.prototype;v10632.isBodyOfInterface=v365;var v10633=AstPath.prototype;v10633.isBodyOfBlock=v366;var v10634=AstPath.prototype;v10634.isBodyOfFor=v367;var v10635=AstPath.prototype;v10635.isBodyOfCase=v368;var v10636=AstPath.prototype;v10636.isBodyOfTry=v369;var v10637=AstPath.prototype;v10637.isBodyOfCatch=v370;var v10638=AstPath.prototype;v10638.isBodyOfDoWhile=v371;var v10639=AstPath.prototype;v10639.isBodyOfWhile=
v372;var v10640=AstPath.prototype;v10640.isBodyOfForIn=v373;var v10641=AstPath.prototype;v10641.isBodyOfWith=v374;var v10642=AstPath.prototype;v10642.isBodyOfFinally=v375;var v10643=AstPath.prototype;v10643.isCaseOfSwitch=v376;var v10644=AstPath.prototype;v10644.isDefaultCaseOfSwitch=v377;var v10645=AstPath.prototype;v10645.isListOfObjectLit=v378;var v10646=AstPath.prototype;v10646.isBodyOfObjectLit=v379;var v10647=AstPath.prototype;v10647.isEmptyListOfObjectLit=v380;var v10648=AstPath.prototype;
v10648.isMemberOfObjectLit=v381;var v10649=AstPath.prototype;v10649.isNameOfMemberOfObjectLit=v382;var v10650=AstPath.prototype;v10650.isListOfArrayLit=v383;var v10651=AstPath.prototype;v10651.isTargetOfMember=v384;var v10652=AstPath.prototype;v10652.isMemberOfMember=v385;var v10653=AstPath.prototype;v10653.isItemOfList=v386;var v10654=AstPath.prototype;v10654.isThenOfIf=v387;var v10655=AstPath.prototype;v10655.isElseOfIf=v388;var v10656=AstPath.prototype;v10656.isBodyOfDefaultCase=v389;var v10657=
AstPath.prototype;v10657.isSingleStatementList=v390;var v10658=AstPath.prototype;v10658.isArgumentListOfFunction=v391;var v10659=AstPath.prototype;v10659.isArgumentOfFunction=v392;var v10660=AstPath.prototype;v10660.isArgumentListOfCall=v393;var v10661=AstPath.prototype;v10661.isArgumentListOfNew=v394;var v10662=AstPath.prototype;v10662.isSynthesizedBlock=v395;return AstPath}function lastOf(items){var v22513=null===items,v24687=!v22513;v24687&&(v22513=items.length,v22513=0===v22513);v22513?items=
null:(v22513=items.length,v22513-=1,items=items[v22513]);return items}function max(a,b){var v10664;return v10664=(v10664=a>=b)?a:b}function min(a,b){var v10665;return v10665=(v10665=a<=b)?a:b}function isValidAstNode(ast){var v10666=null===ast;if(v10666)return!1;var v10666=ast.minChar,v10666=-1===v10666,v22517=!v10666;v22517&&(ast=ast.limChar,v10666=-1===ast);return(ast=v10666)?!1:!0}function getAstPathToPosition(script,pos,options){function pre(cur,parent,walker){if(parent=isValidAstNode(cur)){parent=
GetAstPathOptions.EdgeInclusive;parent=JAMScript.call(TypeScript.hasFlag,TypeScript,[options,parent]);var v18003=!parent;v18003&&(parent=cur.nodeType,v18003=TypeScript.NodeType,v18003=v18003.Name,parent=parent===v18003,v18003=!parent)&&(parent=script.limChar,parent=pos===parent);var inclusive=parent;parent=cur.minChar;v18003=cur.limChar;inclusive=inclusive?1:0;v18003+=inclusive;(inclusive=pos>=parent)&&(inclusive=pos<v18003);if(inclusive){var inclusive=ctx.path,inclusive=JAMScript.call(inclusive.ast,
inclusive,[]),v18006=null==inclusive,v22523=!v18006;v22523&&(v18006=cur.minChar,v22523=inclusive.minChar,v18006=v18006>=v22523)&&(v18006=cur.limChar,inclusive=inclusive.limChar,v18006=v18006<=inclusive);if(inclusive=v18006)inclusive=ctx.path,JAMScript.call(inclusive.push,inclusive,[cur])}if(inclusive=pos<v18003)inclusive=cur.preComments,lookInComments(inclusive);if(inclusive=pos>=parent)inclusive=cur.postComments,lookInComments(inclusive);inclusive=GetAstPathOptions.DontPruneSearchBasedOnPosition;
inclusive=JAMScript.call(TypeScript.hasFlag,TypeScript,[options,inclusive]);if(inclusive=!inclusive)walker=walker.options,(parent=parent<=pos)&&(parent=pos<=v18003),walker.goChildren=parent}return cur}function lookInComments(comments){var v18009=comments;v18009&&(v18009=comments.length,v18009=0<v18009);if(v18009)for(var v18009=0,v18010=comments.length,v18010=v18009<v18010;v18010;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v18010=comments[v18009];v18010=v18010.minChar;
introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v10683=comments[v18009];v10683=v10683.limChar;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v22526=comments[v18009];v22526=v22526.isBlockComment;(v22526=!v22526)&&(v10683+=1);(v18010=pos>=v18010)&&(v18010=pos<v10683);if(v18010){v18010=ctx.path;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v10683=comments[v18009];JAMScript.call(v18010.push,
v18010,[v10683])}v18009+=1;v18010=comments.length;v18010=v18009<v18010}}var v18014=typeof options;if(v18014="undefined"===v18014)options=GetAstPathOptions.Default;var ctx=JAMScript.new(AstPathContext,[]),v18014=JAMScript.call(TypeScript.getAstWalkerFactory,TypeScript,[]);JAMScript.call(v18014.walk,v18014,[script,pre,null,null,ctx]);return ctx.path}function getTokenizationOffset(script,position){function pre(cur,parent,walker){if(parent=JAMScript.call(TypeScript.isValidAstNode,TypeScript,[cur])){parent=
cur.minChar;if(parent=parent<=position)parent=cur.minChar,bestOffset=max(bestOffset,parent);parent=cur.minChar;parent=parent>position;var v22529=!parent;v22529&&(parent=cur.limChar,parent=parent<bestOffset);parent&&(walker=walker.options,walker.goChildren=!1)}return cur}var bestOffset=0,v10697=JAMScript.call(TypeScript.getAstWalkerFactory,TypeScript,[]);JAMScript.call(v10697.walk,v10697,[script,pre]);return bestOffset}function walkAST(ast,callback){function post(cur,parent,walker){parent=walker.state;
JAMScript.call(parent.pop,parent,[]);return cur}function pre(cur,parent,walker){parent=walker.state;JAMScript.call(parent.push,parent,[cur]);JAMScript.call(callback,null,[parent,walker]);return cur}var path=JAMScript.new(AstPath,[]),v10698=JAMScript.call(TypeScript.getAstWalkerFactory,TypeScript,[]);JAMScript.call(v10698.walk,v10698,[ast,pre,post,null,path])}TypeScript.lastOf=lastOf;TypeScript.max=max;TypeScript.min=min;var AstPath=v396();TypeScript.AstPath=AstPath;TypeScript.isValidAstNode=isValidAstNode;
var AstPathContext=v397();TypeScript.AstPathContext=AstPathContext;var v18017=TypeScript.GetAstPathOptions,v22530=!v18017;v22530&&(v18017=TypeScript.GetAstPathOptions={});v398(v18017);var GetAstPathOptions=TypeScript.GetAstPathOptions;TypeScript.getAstPathToPosition=getAstPathToPosition;TypeScript.getTokenizationOffset=getTokenizationOffset;TypeScript.walkAST=walkAST}
function v335(){var TypeScript=v12346;function v334(AstWalkerWithDetailCallback){function walk(script,callback){function post(cur,parent){AstWalkerCallback(!1,cur,callback);return cur}function pre(cur,parent){var v10700=walker.options,v27336=AstWalkerCallback(!0,cur,callback);v10700.goChildren=v27336;return cur}var v10701=JAMScript.call(TypeScript.getAstWalkerFactory,TypeScript,[]),walker=JAMScript.call(v10701.getWalker,v10701,[pre,post]);JAMScript.call(walker.walk,walker,[script,null])}function AstWalkerCallback(pre,
ast,callback){var nodeType=ast.nodeType,v22531=TypeScript.NodeType,v22531=v22531._map;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)nodeType=v22531[nodeType];nodeType+="Callback";introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v22531=callback[nodeType];if(v22531){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)pre=[[pre,ast],callback,callback[nodeType]];return JAMScript.call(pre[2],pre[1],pre[0])}return(nodeType=
callback.DefaultCallback)?JAMScript.call(callback.DefaultCallback,callback,[pre,ast]):!0}AstWalkerWithDetailCallback.walk=walk}var v18019=TypeScript.AstWalkerWithDetailCallback,v22532=!v18019;v22532&&(v18019=TypeScript.AstWalkerWithDetailCallback={});v334(v18019)}
function v333(){var TypeScript=v12345;function v332(ChildrenWalkers){function walkNone(preAst,parent,walker){}function walkListChildren(preAst,parent,walker){parent=preAst.members;var len=parent.length;parent=walker.options;if(parent=parent.reverseSiblings)for(parent=len-1,len=0<=parent;len;){len=walker.options;if(len=len.goNextSibling){var len=preAst.members,v10708=parent,v22533=preAst.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v22533=v22533[parent];
v22533=JAMScript.call(walker.walk,walker,[v22533,preAst]);len[v10708]=v22533}parent-=1;len=0<=parent}else for(parent=0,v10708=parent<len;v10708;){v10708=walker.options;if(v10708=v10708.goNextSibling){var v10708=preAst.members,v22533=parent,v22534=preAst.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v22534=v22534[parent];v22534=JAMScript.call(walker.walk,walker,[v22534,preAst]);v10708[v22533]=v22534}parent+=1;v10708=parent<len}}function walkUnaryExpressionChildren(preAst,
parent,walker){if(parent=preAst.castTerm){parent=preAst;var v18025=preAst.castTerm,v18025=JAMScript.call(walker.walk,walker,[v18025,preAst]);parent.castTerm=v18025}if(parent=preAst.operand)parent=preAst,v18025=preAst.operand,preAst=JAMScript.call(walker.walk,walker,[v18025,preAst]),parent.operand=preAst}function walkBinaryExpressionChildren(preAst,parent,walker){parent=walker.options;if(parent=parent.reverseSiblings){if(parent=preAst.operand2){parent=preAst;var v18028=preAst.operand2,v18028=JAMScript.call(walker.walk,
walker,[v18028,preAst]);parent.operand2=v18028}if(parent=preAst.operand1)parent=walker.options,parent=parent.goNextSibling;parent&&(parent=preAst,v18028=preAst.operand1,preAst=JAMScript.call(walker.walk,walker,[v18028,preAst]),parent.operand1=preAst)}else{if(parent=preAst.operand1)parent=preAst,v18028=preAst.operand1,v18028=JAMScript.call(walker.walk,walker,[v18028,preAst]),parent.operand1=v18028;if(parent=preAst.operand2)parent=walker.options,parent=parent.goNextSibling;parent&&(parent=preAst,v18028=
preAst.operand2,preAst=JAMScript.call(walker.walk,walker,[v18028,preAst]),parent.operand2=preAst)}}function walkTypeReferenceChildren(preAst,parent,walker){if(parent=preAst.term){parent=preAst;var v18034=preAst.term;preAst=JAMScript.call(walker.walk,walker,[v18034,preAst]);parent.term=preAst}}function walkCallExpressionChildren(preAst,parent,walker){parent=walker.options;parent=parent.reverseSiblings;if(parent=!parent){parent=preAst;var v18036=preAst.target,v18036=JAMScript.call(walker.walk,walker,
[v18036,preAst]);parent.target=v18036}if(parent=preAst.arguments)parent=walker.options,parent=parent.goNextSibling;parent&&(parent=preAst,v18036=preAst.arguments,v18036=JAMScript.call(walker.walk,walker,[v18036,preAst]),parent.arguments=v18036);parent=walker.options;if(parent=parent.reverseSiblings)parent=walker.options,parent=parent.goNextSibling;parent&&(parent=preAst,v18036=preAst.target,preAst=JAMScript.call(walker.walk,walker,[v18036,preAst]),parent.target=preAst)}function walkTrinaryExpressionChildren(preAst,
parent,walker){if(parent=preAst.operand1){parent=preAst;var v18041=preAst.operand1,v18041=JAMScript.call(walker.walk,walker,[v18041,preAst]);parent.operand1=v18041}if(parent=preAst.operand2)parent=walker.options,parent=parent.goNextSibling;parent&&(parent=preAst,v18041=preAst.operand2,v18041=JAMScript.call(walker.walk,walker,[v18041,preAst]),parent.operand2=v18041);if(parent=preAst.operand3)parent=walker.options,parent=parent.goNextSibling;parent&&(parent=preAst,v18041=preAst.operand3,preAst=JAMScript.call(walker.walk,
walker,[v18041,preAst]),parent.operand3=preAst)}function walkFuncDeclChildren(preAst,parent,walker){if(parent=preAst.name){parent=preAst;var v18046=preAst.name,v18046=JAMScript.call(walker.walk,walker,[v18046,preAst]);parent.name=v18046}if(parent=preAst.arguments)if(parent=preAst.arguments,parent=parent.members,parent=parent.length,parent=0<parent)parent=walker.options,parent=parent.goNextSibling;parent&&(parent=preAst,v18046=preAst.arguments,v18046=JAMScript.call(walker.walk,walker,[v18046,preAst]),
parent.arguments=v18046);if(parent=preAst.returnTypeAnnotation)parent=walker.options,parent=parent.goNextSibling;parent&&(parent=preAst,v18046=preAst.returnTypeAnnotation,v18046=JAMScript.call(walker.walk,walker,[v18046,preAst]),parent.returnTypeAnnotation=v18046);if(parent=preAst.bod)if(parent=preAst.bod,parent=parent.members,parent=parent.length,parent=0<parent)parent=walker.options,parent=parent.goNextSibling;parent&&(parent=preAst,v18046=preAst.bod,preAst=JAMScript.call(walker.walk,walker,[v18046,
preAst]),parent.bod=preAst)}function walkBoundDeclChildren(preAst,parent,walker){if(parent=preAst.id){parent=preAst;var v18053=preAst.id,v18053=JAMScript.call(walker.walk,walker,[v18053,preAst]);parent.id=v18053}if(parent=preAst.init)parent=preAst,v18053=preAst.init,v18053=JAMScript.call(walker.walk,walker,[v18053,preAst]),parent.init=v18053;if(parent=preAst.typeExpr)parent=walker.options,parent=parent.goNextSibling;parent&&(parent=preAst,v18053=preAst.typeExpr,preAst=JAMScript.call(walker.walk,walker,
[v18053,preAst]),parent.typeExpr=preAst)}function walkReturnStatementChildren(preAst,parent,walker){if(parent=preAst.returnExpression){parent=preAst;var v18057=preAst.returnExpression;preAst=JAMScript.call(walker.walk,walker,[v18057,preAst]);parent.returnExpression=preAst}}function walkForStatementChildren(preAst,parent,walker){if(parent=preAst.init){parent=preAst;var v18058=preAst.init,v18058=JAMScript.call(walker.walk,walker,[v18058,preAst]);parent.init=v18058}if(parent=preAst.cond)parent=walker.options,
parent=parent.goNextSibling;parent&&(parent=preAst,v18058=preAst.cond,v18058=JAMScript.call(walker.walk,walker,[v18058,preAst]),parent.cond=v18058);if(parent=preAst.incr)parent=walker.options,parent=parent.goNextSibling;parent&&(parent=preAst,v18058=preAst.incr,v18058=JAMScript.call(walker.walk,walker,[v18058,preAst]),parent.incr=v18058);if(parent=preAst.body)parent=walker.options,parent=parent.goNextSibling;parent&&(parent=preAst,v18058=preAst.body,preAst=JAMScript.call(walker.walk,walker,[v18058,
preAst]),parent.body=preAst)}function walkForInStatementChildren(preAst,parent,walker){parent=preAst;var v18065=preAst.lval,v18065=JAMScript.call(walker.walk,walker,[v18065,preAst]);parent.lval=v18065;parent=walker.options;if(parent=parent.goNextSibling)parent=preAst,v18065=preAst.obj,v18065=JAMScript.call(walker.walk,walker,[v18065,preAst]),parent.obj=v18065;if(parent=preAst.body)parent=walker.options,parent=parent.goNextSibling;parent&&(parent=preAst,v18065=preAst.body,preAst=JAMScript.call(walker.walk,
walker,[v18065,preAst]),parent.body=preAst)}function walkIfStatementChildren(preAst,parent,walker){parent=preAst;var v18070=preAst.cond,v18070=JAMScript.call(walker.walk,walker,[v18070,preAst]);parent.cond=v18070;if(parent=preAst.thenBod)parent=walker.options,parent=parent.goNextSibling;parent&&(parent=preAst,v18070=preAst.thenBod,v18070=JAMScript.call(walker.walk,walker,[v18070,preAst]),parent.thenBod=v18070);if(parent=preAst.elseBod)parent=walker.options,parent=parent.goNextSibling;parent&&(parent=
preAst,v18070=preAst.elseBod,preAst=JAMScript.call(walker.walk,walker,[v18070,preAst]),parent.elseBod=preAst)}function walkWhileStatementChildren(preAst,parent,walker){parent=preAst;var v18075=preAst.cond,v18075=JAMScript.call(walker.walk,walker,[v18075,preAst]);parent.cond=v18075;if(parent=preAst.body)parent=walker.options,parent=parent.goNextSibling;parent&&(parent=preAst,v18075=preAst.body,preAst=JAMScript.call(walker.walk,walker,[v18075,preAst]),parent.body=preAst)}function walkDoWhileStatementChildren(preAst,
parent,walker){parent=preAst;var v18078=preAst.cond,v18078=JAMScript.call(walker.walk,walker,[v18078,preAst]);parent.cond=v18078;if(parent=preAst.body)parent=walker.options,parent=parent.goNextSibling;parent&&(parent=preAst,v18078=preAst.body,preAst=JAMScript.call(walker.walk,walker,[v18078,preAst]),parent.body=preAst)}function walkBlockChildren(preAst,parent,walker){if(parent=preAst.statements){parent=preAst;var v18081=preAst.statements;preAst=JAMScript.call(walker.walk,walker,[v18081,preAst]);parent.statements=
preAst}}function walkCaseStatementChildren(preAst,parent,walker){if(parent=preAst.expr){parent=preAst;var v18082=preAst.expr,v18082=JAMScript.call(walker.walk,walker,[v18082,preAst]);parent.expr=v18082}if(parent=preAst.body)parent=walker.options,parent=parent.goNextSibling;parent&&(parent=preAst,v18082=preAst.body,preAst=JAMScript.call(walker.walk,walker,[v18082,preAst]),parent.body=preAst)}function walkSwitchStatementChildren(preAst,parent,walker){if(parent=preAst.val){parent=preAst;var v18085=preAst.val,
v18085=JAMScript.call(walker.walk,walker,[v18085,preAst]);parent.val=v18085}if(parent=preAst.caseList)parent=walker.options,parent=parent.goNextSibling;parent&&(parent=preAst,v18085=preAst.caseList,preAst=JAMScript.call(walker.walk,walker,[v18085,preAst]),parent.caseList=preAst)}function walkTryChildren(preAst,parent,walker){if(parent=preAst.body){parent=preAst;var v18088=preAst.body;preAst=JAMScript.call(walker.walk,walker,[v18088,preAst]);parent.body=preAst}}function walkTryCatchChildren(preAst,
parent,walker){if(parent=preAst.tryNode){parent=preAst;var v18089=preAst.tryNode,v18089=JAMScript.call(walker.walk,walker,[v18089,preAst]);parent.tryNode=v18089}if(parent=preAst.catchNode)parent=walker.options,parent=parent.goNextSibling;parent&&(parent=preAst,v18089=preAst.catchNode,preAst=JAMScript.call(walker.walk,walker,[v18089,preAst]),parent.catchNode=preAst)}function walkTryFinallyChildren(preAst,parent,walker){if(parent=preAst.tryNode){parent=preAst;var v18092=preAst.tryNode,v18092=JAMScript.call(walker.walk,
walker,[v18092,preAst]);parent.tryNode=v18092}if(parent=preAst.finallyNode)parent=walker.options,parent=parent.goNextSibling;parent&&(parent=preAst,v18092=preAst.finallyNode,preAst=JAMScript.call(walker.walk,walker,[v18092,preAst]),parent.finallyNode=preAst)}function walkFinallyChildren(preAst,parent,walker){if(parent=preAst.body){parent=preAst;var v18095=preAst.body;preAst=JAMScript.call(walker.walk,walker,[v18095,preAst]);parent.body=preAst}}function walkCatchChildren(preAst,parent,walker){if(parent=
preAst.param){parent=preAst;var v18096=preAst.param,v18096=JAMScript.call(walker.walk,walker,[v18096,preAst]);parent.param=v18096}if(parent=preAst.body)parent=walker.options,parent=parent.goNextSibling;parent&&(parent=preAst,v18096=preAst.body,preAst=JAMScript.call(walker.walk,walker,[v18096,preAst]),parent.body=preAst)}function walkRecordChildren(preAst,parent,walker){parent=preAst;var v18099=preAst.name,v18099=JAMScript.call(walker.walk,walker,[v18099,preAst]);parent.name=v18099;parent=walker.options;
if(parent=parent.goNextSibling)parent=preAst.members;parent&&(parent=preAst,v18099=preAst.members,preAst=JAMScript.call(walker.walk,walker,[v18099,preAst]),parent.members=preAst)}function walkNamedTypeChildren(preAst,parent,walker){walkRecordChildren(preAst,parent,walker)}function walkClassDeclChildren(preAst,parent,walker){walkRecordChildren(preAst,parent,walker);parent=walker.options;if(parent=parent.goNextSibling)parent=preAst.extendsList;if(parent){parent=preAst;var v18103=preAst.extendsList,
v18103=JAMScript.call(walker.walk,walker,[v18103,preAst]);parent.extendsList=v18103}parent=walker.options;if(parent=parent.goNextSibling)parent=preAst.implementsList;parent&&(parent=preAst,v18103=preAst.implementsList,preAst=JAMScript.call(walker.walk,walker,[v18103,preAst]),parent.implementsList=preAst)}function walkScriptChildren(preAst,parent,walker){if(parent=preAst.bod){parent=preAst;var v18106=preAst.bod;preAst=JAMScript.call(walker.walk,walker,[v18106,preAst]);parent.bod=preAst}}function walkTypeDeclChildren(preAst,
parent,walker){walkRecordChildren(preAst,parent,walker);parent=walker.options;if(parent=parent.goNextSibling)parent=preAst.extendsList;if(parent){parent=preAst;var v18108=preAst.extendsList,v18108=JAMScript.call(walker.walk,walker,[v18108,preAst]);parent.extendsList=v18108}parent=walker.options;if(parent=parent.goNextSibling)parent=preAst.implementsList;parent&&(parent=preAst,v18108=preAst.implementsList,preAst=JAMScript.call(walker.walk,walker,[v18108,preAst]),parent.implementsList=preAst)}function walkModuleDeclChildren(preAst,
parent,walker){walkRecordChildren(preAst,parent,walker)}function walkImportDeclChildren(preAst,parent,walker){if(parent=preAst.id){parent=preAst;var v18111=preAst.id,v18111=JAMScript.call(walker.walk,walker,[v18111,preAst]);parent.id=v18111}if(parent=preAst.alias)parent=preAst,v18111=preAst.alias,preAst=JAMScript.call(walker.walk,walker,[v18111,preAst]),parent.alias=preAst}function walkWithStatementChildren(preAst,parent,walker){if(parent=preAst.expr){parent=preAst;var v18113=preAst.expr,v18113=JAMScript.call(walker.walk,
walker,[v18113,preAst]);parent.expr=v18113}if(parent=preAst.body)parent=walker.options,parent=parent.goNextSibling;parent&&(parent=preAst,v18113=preAst.body,preAst=JAMScript.call(walker.walk,walker,[v18113,preAst]),parent.body=preAst)}function walkLabelChildren(preAst,parent,walker){}function walkLabeledStatementChildren(preAst,parent,walker){parent=preAst;var v18116=preAst.labels,v18116=JAMScript.call(walker.walk,walker,[v18116,preAst]);parent.labels=v18116;parent=walker.options;if(parent=parent.goNextSibling)parent=
preAst,v18116=preAst.stmt,preAst=JAMScript.call(walker.walk,walker,[v18116,preAst]),parent.stmt=preAst}ChildrenWalkers.walkNone=walkNone;ChildrenWalkers.walkListChildren=walkListChildren;ChildrenWalkers.walkUnaryExpressionChildren=walkUnaryExpressionChildren;ChildrenWalkers.walkBinaryExpressionChildren=walkBinaryExpressionChildren;ChildrenWalkers.walkTypeReferenceChildren=walkTypeReferenceChildren;ChildrenWalkers.walkCallExpressionChildren=walkCallExpressionChildren;ChildrenWalkers.walkTrinaryExpressionChildren=
walkTrinaryExpressionChildren;ChildrenWalkers.walkFuncDeclChildren=walkFuncDeclChildren;ChildrenWalkers.walkBoundDeclChildren=walkBoundDeclChildren;ChildrenWalkers.walkReturnStatementChildren=walkReturnStatementChildren;ChildrenWalkers.walkForStatementChildren=walkForStatementChildren;ChildrenWalkers.walkForInStatementChildren=walkForInStatementChildren;ChildrenWalkers.walkIfStatementChildren=walkIfStatementChildren;ChildrenWalkers.walkWhileStatementChildren=walkWhileStatementChildren;ChildrenWalkers.walkDoWhileStatementChildren=
walkDoWhileStatementChildren;ChildrenWalkers.walkBlockChildren=walkBlockChildren;ChildrenWalkers.walkCaseStatementChildren=walkCaseStatementChildren;ChildrenWalkers.walkSwitchStatementChildren=walkSwitchStatementChildren;ChildrenWalkers.walkTryChildren=walkTryChildren;ChildrenWalkers.walkTryCatchChildren=walkTryCatchChildren;ChildrenWalkers.walkTryFinallyChildren=walkTryFinallyChildren;ChildrenWalkers.walkFinallyChildren=walkFinallyChildren;ChildrenWalkers.walkCatchChildren=walkCatchChildren;ChildrenWalkers.walkRecordChildren=
walkRecordChildren;ChildrenWalkers.walkNamedTypeChildren=walkNamedTypeChildren;ChildrenWalkers.walkClassDeclChildren=walkClassDeclChildren;ChildrenWalkers.walkScriptChildren=walkScriptChildren;ChildrenWalkers.walkTypeDeclChildren=walkTypeDeclChildren;ChildrenWalkers.walkModuleDeclChildren=walkModuleDeclChildren;ChildrenWalkers.walkImportDeclChildren=walkImportDeclChildren;ChildrenWalkers.walkWithStatementChildren=walkWithStatementChildren;ChildrenWalkers.walkLabelChildren=walkLabelChildren;ChildrenWalkers.walkLabeledStatementChildren=
walkLabeledStatementChildren}function v331(){function v330(){var v10833=this.childrenWalkers,v18119=TypeScript.NodeType,v10834=v18119.None;JAMScript.set(v10833,v10834,ChildrenWalkers.walkNone);var v10835=this.childrenWalkers,v18120=TypeScript.NodeType,v10836=v18120.Empty;JAMScript.set(v10835,v10836,ChildrenWalkers.walkNone);var v10837=this.childrenWalkers,v18121=TypeScript.NodeType,v10838=v18121.EmptyExpr;JAMScript.set(v10837,v10838,ChildrenWalkers.walkNone);var v10839=this.childrenWalkers,v18122=
TypeScript.NodeType,v10840=v18122.True;JAMScript.set(v10839,v10840,ChildrenWalkers.walkNone);var v10841=this.childrenWalkers,v18123=TypeScript.NodeType,v10842=v18123.False;JAMScript.set(v10841,v10842,ChildrenWalkers.walkNone);var v10843=this.childrenWalkers,v18124=TypeScript.NodeType,v10844=v18124.This;JAMScript.set(v10843,v10844,ChildrenWalkers.walkNone);var v10845=this.childrenWalkers,v18125=TypeScript.NodeType,v10846=v18125.Super;JAMScript.set(v10845,v10846,ChildrenWalkers.walkNone);var v10847=
this.childrenWalkers,v18126=TypeScript.NodeType,v10848=v18126.QString;JAMScript.set(v10847,v10848,ChildrenWalkers.walkNone);var v10849=this.childrenWalkers,v18127=TypeScript.NodeType,v10850=v18127.Regex;JAMScript.set(v10849,v10850,ChildrenWalkers.walkNone);var v10851=this.childrenWalkers,v18128=TypeScript.NodeType,v10852=v18128.Null;JAMScript.set(v10851,v10852,ChildrenWalkers.walkNone);var v10853=this.childrenWalkers,v18129=TypeScript.NodeType,v10854=v18129.ArrayLit;JAMScript.set(v10853,v10854,ChildrenWalkers.walkUnaryExpressionChildren);
var v10855=this.childrenWalkers,v18130=TypeScript.NodeType,v10856=v18130.ObjectLit;JAMScript.set(v10855,v10856,ChildrenWalkers.walkUnaryExpressionChildren);var v10857=this.childrenWalkers,v18131=TypeScript.NodeType,v10858=v18131.Void;JAMScript.set(v10857,v10858,ChildrenWalkers.walkUnaryExpressionChildren);var v10859=this.childrenWalkers,v18132=TypeScript.NodeType,v10860=v18132.Comma;JAMScript.set(v10859,v10860,ChildrenWalkers.walkBinaryExpressionChildren);var v10861=this.childrenWalkers,v18133=TypeScript.NodeType,
v10862=v18133.Pos;JAMScript.set(v10861,v10862,ChildrenWalkers.walkUnaryExpressionChildren);var v10863=this.childrenWalkers,v18134=TypeScript.NodeType,v10864=v18134.Neg;JAMScript.set(v10863,v10864,ChildrenWalkers.walkUnaryExpressionChildren);var v10865=this.childrenWalkers,v18135=TypeScript.NodeType,v10866=v18135.Delete;JAMScript.set(v10865,v10866,ChildrenWalkers.walkUnaryExpressionChildren);var v10867=this.childrenWalkers,v18136=TypeScript.NodeType,v10868=v18136.Await;JAMScript.set(v10867,v10868,
ChildrenWalkers.walkUnaryExpressionChildren);var v10869=this.childrenWalkers,v18137=TypeScript.NodeType,v10870=v18137.In;JAMScript.set(v10869,v10870,ChildrenWalkers.walkBinaryExpressionChildren);var v10871=this.childrenWalkers,v18138=TypeScript.NodeType,v10872=v18138.Dot;JAMScript.set(v10871,v10872,ChildrenWalkers.walkBinaryExpressionChildren);var v10873=this.childrenWalkers,v18139=TypeScript.NodeType,v10874=v18139.From;JAMScript.set(v10873,v10874,ChildrenWalkers.walkBinaryExpressionChildren);var v10875=
this.childrenWalkers,v18140=TypeScript.NodeType,v10876=v18140.Is;JAMScript.set(v10875,v10876,ChildrenWalkers.walkBinaryExpressionChildren);var v10877=this.childrenWalkers,v18141=TypeScript.NodeType,v10878=v18141.InstOf;JAMScript.set(v10877,v10878,ChildrenWalkers.walkBinaryExpressionChildren);var v10879=this.childrenWalkers,v18142=TypeScript.NodeType,v10880=v18142.Typeof;JAMScript.set(v10879,v10880,ChildrenWalkers.walkUnaryExpressionChildren);var v10881=this.childrenWalkers,v18143=TypeScript.NodeType,
v10882=v18143.NumberLit;JAMScript.set(v10881,v10882,ChildrenWalkers.walkNone);var v10883=this.childrenWalkers,v18144=TypeScript.NodeType,v10884=v18144.Name;JAMScript.set(v10883,v10884,ChildrenWalkers.walkNone);var v10885=this.childrenWalkers,v18145=TypeScript.NodeType,v10886=v18145.TypeRef;JAMScript.set(v10885,v10886,ChildrenWalkers.walkTypeReferenceChildren);var v10887=this.childrenWalkers,v18146=TypeScript.NodeType,v10888=v18146.Index;JAMScript.set(v10887,v10888,ChildrenWalkers.walkBinaryExpressionChildren);
var v10889=this.childrenWalkers,v18147=TypeScript.NodeType,v10890=v18147.Call;JAMScript.set(v10889,v10890,ChildrenWalkers.walkCallExpressionChildren);var v10891=this.childrenWalkers,v18148=TypeScript.NodeType,v10892=v18148.New;JAMScript.set(v10891,v10892,ChildrenWalkers.walkCallExpressionChildren);var v10893=this.childrenWalkers,v18149=TypeScript.NodeType,v10894=v18149.Asg;JAMScript.set(v10893,v10894,ChildrenWalkers.walkBinaryExpressionChildren);var v10895=this.childrenWalkers,v18150=TypeScript.NodeType,
v10896=v18150.AsgAdd;JAMScript.set(v10895,v10896,ChildrenWalkers.walkBinaryExpressionChildren);var v10897=this.childrenWalkers,v18151=TypeScript.NodeType,v10898=v18151.AsgSub;JAMScript.set(v10897,v10898,ChildrenWalkers.walkBinaryExpressionChildren);var v10899=this.childrenWalkers,v18152=TypeScript.NodeType,v10900=v18152.AsgDiv;JAMScript.set(v10899,v10900,ChildrenWalkers.walkBinaryExpressionChildren);var v10901=this.childrenWalkers,v18153=TypeScript.NodeType,v10902=v18153.AsgMul;JAMScript.set(v10901,
v10902,ChildrenWalkers.walkBinaryExpressionChildren);var v10903=this.childrenWalkers,v18154=TypeScript.NodeType,v10904=v18154.AsgMod;JAMScript.set(v10903,v10904,ChildrenWalkers.walkBinaryExpressionChildren);var v10905=this.childrenWalkers,v18155=TypeScript.NodeType,v10906=v18155.AsgAnd;JAMScript.set(v10905,v10906,ChildrenWalkers.walkBinaryExpressionChildren);var v10907=this.childrenWalkers,v18156=TypeScript.NodeType,v10908=v18156.AsgXor;JAMScript.set(v10907,v10908,ChildrenWalkers.walkBinaryExpressionChildren);
var v10909=this.childrenWalkers,v18157=TypeScript.NodeType,v10910=v18157.AsgOr;JAMScript.set(v10909,v10910,ChildrenWalkers.walkBinaryExpressionChildren);var v10911=this.childrenWalkers,v18158=TypeScript.NodeType,v10912=v18158.AsgLsh;JAMScript.set(v10911,v10912,ChildrenWalkers.walkBinaryExpressionChildren);var v10913=this.childrenWalkers,v18159=TypeScript.NodeType,v10914=v18159.AsgRsh;JAMScript.set(v10913,v10914,ChildrenWalkers.walkBinaryExpressionChildren);var v10915=this.childrenWalkers,v18160=TypeScript.NodeType,
v10916=v18160.AsgRs2;JAMScript.set(v10915,v10916,ChildrenWalkers.walkBinaryExpressionChildren);var v10917=this.childrenWalkers,v18161=TypeScript.NodeType,v10918=v18161.ConditionalExpression;JAMScript.set(v10917,v10918,ChildrenWalkers.walkTrinaryExpressionChildren);var v10919=this.childrenWalkers,v18162=TypeScript.NodeType,v10920=v18162.LogOr;JAMScript.set(v10919,v10920,ChildrenWalkers.walkBinaryExpressionChildren);var v10921=this.childrenWalkers,v18163=TypeScript.NodeType,v10922=v18163.LogAnd;JAMScript.set(v10921,
v10922,ChildrenWalkers.walkBinaryExpressionChildren);var v10923=this.childrenWalkers,v18164=TypeScript.NodeType,v10924=v18164.Or;JAMScript.set(v10923,v10924,ChildrenWalkers.walkBinaryExpressionChildren);var v10925=this.childrenWalkers,v18165=TypeScript.NodeType,v10926=v18165.Xor;JAMScript.set(v10925,v10926,ChildrenWalkers.walkBinaryExpressionChildren);var v10927=this.childrenWalkers,v18166=TypeScript.NodeType,v10928=v18166.And;JAMScript.set(v10927,v10928,ChildrenWalkers.walkBinaryExpressionChildren);
var v10929=this.childrenWalkers,v18167=TypeScript.NodeType,v10930=v18167.Eq;JAMScript.set(v10929,v10930,ChildrenWalkers.walkBinaryExpressionChildren);var v10931=this.childrenWalkers,v18168=TypeScript.NodeType,v10932=v18168.Ne;JAMScript.set(v10931,v10932,ChildrenWalkers.walkBinaryExpressionChildren);var v10933=this.childrenWalkers,v18169=TypeScript.NodeType,v10934=v18169.Eqv;JAMScript.set(v10933,v10934,ChildrenWalkers.walkBinaryExpressionChildren);var v10935=this.childrenWalkers,v18170=TypeScript.NodeType,
v10936=v18170.NEqv;JAMScript.set(v10935,v10936,ChildrenWalkers.walkBinaryExpressionChildren);var v10937=this.childrenWalkers,v18171=TypeScript.NodeType,v10938=v18171.Lt;JAMScript.set(v10937,v10938,ChildrenWalkers.walkBinaryExpressionChildren);var v10939=this.childrenWalkers,v18172=TypeScript.NodeType,v10940=v18172.Le;JAMScript.set(v10939,v10940,ChildrenWalkers.walkBinaryExpressionChildren);var v10941=this.childrenWalkers,v18173=TypeScript.NodeType,v10942=v18173.Gt;JAMScript.set(v10941,v10942,ChildrenWalkers.walkBinaryExpressionChildren);
var v10943=this.childrenWalkers,v18174=TypeScript.NodeType,v10944=v18174.Ge;JAMScript.set(v10943,v10944,ChildrenWalkers.walkBinaryExpressionChildren);var v10945=this.childrenWalkers,v18175=TypeScript.NodeType,v10946=v18175.Add;JAMScript.set(v10945,v10946,ChildrenWalkers.walkBinaryExpressionChildren);var v10947=this.childrenWalkers,v18176=TypeScript.NodeType,v10948=v18176.Sub;JAMScript.set(v10947,v10948,ChildrenWalkers.walkBinaryExpressionChildren);var v10949=this.childrenWalkers,v18177=TypeScript.NodeType,
v10950=v18177.Mul;JAMScript.set(v10949,v10950,ChildrenWalkers.walkBinaryExpressionChildren);var v10951=this.childrenWalkers,v18178=TypeScript.NodeType,v10952=v18178.Div;JAMScript.set(v10951,v10952,ChildrenWalkers.walkBinaryExpressionChildren);var v10953=this.childrenWalkers,v18179=TypeScript.NodeType,v10954=v18179.Mod;JAMScript.set(v10953,v10954,ChildrenWalkers.walkBinaryExpressionChildren);var v10955=this.childrenWalkers,v18180=TypeScript.NodeType,v10956=v18180.Lsh;JAMScript.set(v10955,v10956,ChildrenWalkers.walkBinaryExpressionChildren);
var v10957=this.childrenWalkers,v18181=TypeScript.NodeType,v10958=v18181.Rsh;JAMScript.set(v10957,v10958,ChildrenWalkers.walkBinaryExpressionChildren);var v10959=this.childrenWalkers,v18182=TypeScript.NodeType,v10960=v18182.Rs2;JAMScript.set(v10959,v10960,ChildrenWalkers.walkBinaryExpressionChildren);var v10961=this.childrenWalkers,v18183=TypeScript.NodeType,v10962=v18183.Not;JAMScript.set(v10961,v10962,ChildrenWalkers.walkUnaryExpressionChildren);var v10963=this.childrenWalkers,v18184=TypeScript.NodeType,
v10964=v18184.LogNot;JAMScript.set(v10963,v10964,ChildrenWalkers.walkUnaryExpressionChildren);var v10965=this.childrenWalkers,v18185=TypeScript.NodeType,v10966=v18185.IncPre;JAMScript.set(v10965,v10966,ChildrenWalkers.walkUnaryExpressionChildren);var v10967=this.childrenWalkers,v18186=TypeScript.NodeType,v10968=v18186.DecPre;JAMScript.set(v10967,v10968,ChildrenWalkers.walkUnaryExpressionChildren);var v10969=this.childrenWalkers,v18187=TypeScript.NodeType,v10970=v18187.IncPost;JAMScript.set(v10969,
v10970,ChildrenWalkers.walkUnaryExpressionChildren);var v10971=this.childrenWalkers,v18188=TypeScript.NodeType,v10972=v18188.DecPost;JAMScript.set(v10971,v10972,ChildrenWalkers.walkUnaryExpressionChildren);var v10973=this.childrenWalkers,v18189=TypeScript.NodeType,v10974=v18189.TypeAssertion;JAMScript.set(v10973,v10974,ChildrenWalkers.walkUnaryExpressionChildren);var v10975=this.childrenWalkers,v18190=TypeScript.NodeType,v10976=v18190.FuncDecl;JAMScript.set(v10975,v10976,ChildrenWalkers.walkFuncDeclChildren);
var v10977=this.childrenWalkers,v18191=TypeScript.NodeType,v10978=v18191.Member;JAMScript.set(v10977,v10978,ChildrenWalkers.walkBinaryExpressionChildren);var v10979=this.childrenWalkers,v18192=TypeScript.NodeType,v10980=v18192.VarDecl;JAMScript.set(v10979,v10980,ChildrenWalkers.walkBoundDeclChildren);var v10981=this.childrenWalkers,v18193=TypeScript.NodeType,v10982=v18193.ArgDecl;JAMScript.set(v10981,v10982,ChildrenWalkers.walkBoundDeclChildren);var v10983=this.childrenWalkers,v18194=TypeScript.NodeType,
v10984=v18194.Return;JAMScript.set(v10983,v10984,ChildrenWalkers.walkReturnStatementChildren);var v10985=this.childrenWalkers,v18195=TypeScript.NodeType,v10986=v18195.Break;JAMScript.set(v10985,v10986,ChildrenWalkers.walkNone);var v10987=this.childrenWalkers,v18196=TypeScript.NodeType,v10988=v18196.Continue;JAMScript.set(v10987,v10988,ChildrenWalkers.walkNone);var v10989=this.childrenWalkers,v18197=TypeScript.NodeType,v10990=v18197.Throw;JAMScript.set(v10989,v10990,ChildrenWalkers.walkUnaryExpressionChildren);
var v10991=this.childrenWalkers,v18198=TypeScript.NodeType,v10992=v18198.For;JAMScript.set(v10991,v10992,ChildrenWalkers.walkForStatementChildren);var v10993=this.childrenWalkers,v18199=TypeScript.NodeType,v10994=v18199.ForIn;JAMScript.set(v10993,v10994,ChildrenWalkers.walkForInStatementChildren);var v10995=this.childrenWalkers,v18200=TypeScript.NodeType,v10996=v18200.If;JAMScript.set(v10995,v10996,ChildrenWalkers.walkIfStatementChildren);var v10997=this.childrenWalkers,v18201=TypeScript.NodeType,
v10998=v18201.While;JAMScript.set(v10997,v10998,ChildrenWalkers.walkWhileStatementChildren);var v10999=this.childrenWalkers,v18202=TypeScript.NodeType,v11000=v18202.DoWhile;JAMScript.set(v10999,v11000,ChildrenWalkers.walkDoWhileStatementChildren);var v11001=this.childrenWalkers,v18203=TypeScript.NodeType,v11002=v18203.Block;JAMScript.set(v11001,v11002,ChildrenWalkers.walkBlockChildren);var v11003=this.childrenWalkers,v18204=TypeScript.NodeType,v11004=v18204.Case;JAMScript.set(v11003,v11004,ChildrenWalkers.walkCaseStatementChildren);
var v11005=this.childrenWalkers,v18205=TypeScript.NodeType,v11006=v18205.Switch;JAMScript.set(v11005,v11006,ChildrenWalkers.walkSwitchStatementChildren);var v11007=this.childrenWalkers,v18206=TypeScript.NodeType,v11008=v18206.Try;JAMScript.set(v11007,v11008,ChildrenWalkers.walkTryChildren);var v11009=this.childrenWalkers,v18207=TypeScript.NodeType,v11010=v18207.TryCatch;JAMScript.set(v11009,v11010,ChildrenWalkers.walkTryCatchChildren);var v11011=this.childrenWalkers,v18208=TypeScript.NodeType,v11012=
v18208.TryFinally;JAMScript.set(v11011,v11012,ChildrenWalkers.walkTryFinallyChildren);var v11013=this.childrenWalkers,v18209=TypeScript.NodeType,v11014=v18209.Finally;JAMScript.set(v11013,v11014,ChildrenWalkers.walkFinallyChildren);var v11015=this.childrenWalkers,v18210=TypeScript.NodeType,v11016=v18210.Catch;JAMScript.set(v11015,v11016,ChildrenWalkers.walkCatchChildren);var v11017=this.childrenWalkers,v18211=TypeScript.NodeType,v11018=v18211.List;JAMScript.set(v11017,v11018,ChildrenWalkers.walkListChildren);
var v11019=this.childrenWalkers,v18212=TypeScript.NodeType,v11020=v18212.Script;JAMScript.set(v11019,v11020,ChildrenWalkers.walkScriptChildren);var v11021=this.childrenWalkers,v18213=TypeScript.NodeType,v11022=v18213.ClassDeclaration;JAMScript.set(v11021,v11022,ChildrenWalkers.walkClassDeclChildren);var v11023=this.childrenWalkers,v18214=TypeScript.NodeType,v11024=v18214.InterfaceDeclaration;JAMScript.set(v11023,v11024,ChildrenWalkers.walkTypeDeclChildren);var v11025=this.childrenWalkers,v18215=TypeScript.NodeType,
v11026=v18215.ModuleDeclaration;JAMScript.set(v11025,v11026,ChildrenWalkers.walkModuleDeclChildren);var v11027=this.childrenWalkers,v18216=TypeScript.NodeType,v11028=v18216.ImportDeclaration;JAMScript.set(v11027,v11028,ChildrenWalkers.walkImportDeclChildren);var v11029=this.childrenWalkers,v18217=TypeScript.NodeType,v11030=v18217.With;JAMScript.set(v11029,v11030,ChildrenWalkers.walkWithStatementChildren);var v11031=this.childrenWalkers,v18218=TypeScript.NodeType,v11032=v18218.Label;JAMScript.set(v11031,
v11032,ChildrenWalkers.walkLabelChildren);var v11033=this.childrenWalkers,v18219=TypeScript.NodeType,v11034=v18219.LabeledStatement;JAMScript.set(v11033,v11034,ChildrenWalkers.walkLabeledStatementChildren);var v11035=this.childrenWalkers,v18220=TypeScript.NodeType,v11036=v18220.EBStart;JAMScript.set(v11035,v11036,ChildrenWalkers.walkNone);var v11037=this.childrenWalkers,v18221=TypeScript.NodeType,v11038=v18221.GotoEB;JAMScript.set(v11037,v11038,ChildrenWalkers.walkNone);var v11039=this.childrenWalkers,
v18222=TypeScript.NodeType,v11040=v18222.EndCode;JAMScript.set(v11039,v11040,ChildrenWalkers.walkNone);var v11041=this.childrenWalkers,v18223=TypeScript.NodeType,v11042=v18223.Error;JAMScript.set(v11041,v11042,ChildrenWalkers.walkNone);var v11043=this.childrenWalkers,v18224=TypeScript.NodeType,v11044=v18224.Comment;JAMScript.set(v11043,v11044,ChildrenWalkers.walkNone);var v11045=this.childrenWalkers,v18225=TypeScript.NodeType,v11046=v18225.Debugger;JAMScript.set(v11045,v11046,ChildrenWalkers.walkNone);
var e,v18226=TypeScript.NodeType,v11048=v18226._map;for(e in v11048){var v22566=this.childrenWalkers;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v18227=v22566[e];var v11047=void 0===v18227;if(v11047)throw Error("initWalkers function is not up to date with enum content!");}}function v329(pre,post,options,state){var v11049=!options;v11049&&(options=JAMScript.new(AstWalkOptions,[]));v11049=this.childrenWalkers;return JAMScript.new(AstWalker,[v11049,pre,post,
options,state])}function v328(pre,post,options,state){return JAMScript.call(this.getSlowWalker,this,[pre,post,options,state])}function v327(ast,pre,post,options,state){pre=JAMScript.call(this.getWalker,this,[pre,post,options,state]);return JAMScript.call(pre.walk,pre,[ast,null])}function AstWalkerFactory(){this.childrenWalkers=[];JAMScript.call(this.initChildrenWalkers,this,[])}var v11052=AstWalkerFactory.prototype;v11052.walk=v327;v11052=AstWalkerFactory.prototype;v11052.getWalker=v328;v11052=AstWalkerFactory.prototype;
v11052.getSlowWalker=v329;v11052=AstWalkerFactory.prototype;v11052.initChildrenWalkers=v330;return AstWalkerFactory}function v326(){function v325(ast,parent){var preAst=JAMScript.call(this.pre,this,[ast,parent,this]),v11056=void 0===preAst;v11056&&(preAst=ast);v11056=this.options;if(v11056=v11056.goChildren){var v11056=this.options,v11056=v11056.goNextSibling,v11058=this.options;v11058.goNextSibling=!0;var v11058=this.childrenWalkers,v11060=ast.nodeType;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v11058=
[[ast,parent,this],v11058,v11058[v11060]];JAMScript.call(v11058[2],v11058[1],v11058[0]);v11058=this.options;v11058.goNextSibling=v11056}else v11056=this.options,v11056.goChildren=!0;return(v11056=this.post)?(v11056=JAMScript.call(this.post,this,[preAst,parent,this]),(v11058=void 0===v11056)&&(v11056=preAst),v11056):preAst}function AstWalker(childrenWalkers,pre,post,options,state){this.childrenWalkers=childrenWalkers;this.pre=pre;this.post=post;this.options=options;this.state=state}var v11066=AstWalker.prototype;
v11066.walk=v325;return AstWalker}function v324(){function v323(stop){var v18229=typeof stop;(v18229="undefined"===v18229)&&(stop=!0);this.goChildren=!stop;this.goNextSibling=!stop}function AstWalkOptions(){this.goNextSibling=this.goChildren=!0;this.reverseSiblings=!1}var v11068=AstWalkOptions.prototype;v11068.stopWalk=v323;return AstWalkOptions}function getAstWalkerFactory(){var v11069=!globalAstWalkerFactory;v11069&&(globalAstWalkerFactory=JAMScript.new(AstWalkerFactory,[]));return globalAstWalkerFactory}
var AstWalkOptions=v324();TypeScript.AstWalkOptions=AstWalkOptions;var AstWalker=v326(),AstWalkerFactory=v331();TypeScript.AstWalkerFactory=AstWalkerFactory;var globalAstWalkerFactory;TypeScript.getAstWalkerFactory=getAstWalkerFactory;var ChildrenWalkers,v18230=ChildrenWalkers,v22567=!v18230;v22567&&(v18230=ChildrenWalkers={});v332(v18230)}
function v322(){var TypeScript=v12344;function v321(_super){function v320(emitter,tokenId,startLine){JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);JAMScript.call(emitter.writeLineToOutput,emitter,["debugger;"]);JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function DebuggerStatement(){var v18231=TypeScript.NodeType,v18231=v18231.Debugger;
JAMScript.call(_super.call,_super,[this,v18231])}JAMScript.call(__extends,null,[DebuggerStatement,_super]);var v11072=DebuggerStatement.prototype;v11072.emit=v320;return DebuggerStatement}function v319(_super){function getDocCommentTextOfSignatures(signatures){for(var comments=[],i=0,v18232=signatures.length,v18232=i<v18232;v18232;){v18232=TypeScript.Comment;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v22568=signatures[i];v22568=v22568.declAST;v22568=JAMScript.call(v22568.getDocComments,
v22568,[]);v18232=JAMScript.call(v18232.getDocCommentText,v18232,[v22568]);(v22568=""!=v18232)&&JAMScript.call(comments.push,comments,[v18232]);i+=1;v18232=signatures.length;v18232=i<v18232}return comments.join("\n")}function getParameterDocCommentText(param,fncDocComments){var v22569=fncDocComments.length,v22569=0==v22569,v22571=!v22569;v22571&&(v22569=fncDocComments[0],v22569=v22569.isBlockComment,v22569=!v22569);if(v22569)return"";for(var i=0,v22569=fncDocComments.length,v22569=i<v22569;v22569;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v22569=
fncDocComments[i];for(var v22569=v22569.content,v22571=v22569.indexOf("@param",0),v11100=0<=v22571;v11100;)if(v22571+=6,v11100=JAMScript.call(Comment.isSpaceChar,Comment,[v22569,v22571]),v11100=!v11100)v22571=v22569.indexOf("@param",v22571),v11100=0<=v22571;else{v22571=JAMScript.call(Comment.consumeLeadingSpace,Comment,[v22569,v22571]);if(v11100=-1==v22571)break;var v11100=JAMScript.call(v22569.charCodeAt,v22569,[v22571]),v18239=TypeScript.LexCodeLC;if(v11100=v11100==v18239){for(var v22571=v22571+
1,v11100=0,v18239=1,v18240=v22569.length,v18240=v22571<v18240;v18240;){v11100=JAMScript.call(v22569.charCodeAt,v22569,[v22571]);v18240=TypeScript.LexCodeLC;if(v18240=v11100==v18240)v18239+=1;else{v18240=TypeScript.LexCodeRC;if(v18240=v11100==v18240)if(v18239-=1,v18240=0==v18239)break;else{v22571+=1;v18240=v22569.length;v18240=v22571<v18240;continue}v18240=TypeScript.LexCodeAtSign;if(v18240=v11100==v18240)break}v22571+=1;v18240=v22569.length;v18240=v22571<v18240}v18239=v22569.length;if(v18239=v22571==
v18239)break;v18239=TypeScript.LexCodeAtSign;if(v11100=v11100==v18239){v22571=v22569.indexOf("@param",v22571);v11100=0<=v22571;continue}v22571+=1;v22571=JAMScript.call(Comment.consumeLeadingSpace,Comment,[v22569,v22571]);if(v11100=-1==v22571)break}v11100=param;v18239=param.length;v18239=v22569.substr(v22571,v18239);v11100=v11100!=v18239;if(v18239=!v11100)v11100=param.length,v11100=v22571+v11100,v11100=JAMScript.call(Comment.isSpaceChar,Comment,[v22569,v11100]),v11100=!v11100;if(v11100)v22571=v22569.indexOf("@param",
v22571),v11100=0<=v22571;else{i=param.length;v22571+=i;v22571=JAMScript.call(Comment.consumeLeadingSpace,Comment,[v22569,v22571]);if(i=-1==v22571)return"";i=v22569.indexOf("@",v22571);i=(v11100=0>i)?v22569.length:i;i=JAMScript.call(v22569.substring,v22569,[v22571,i]);v11100=void 0;v18239=JAMScript.call(v22569.substring,v22569,[0,v22571]);v18239=v18239.lastIndexOf("\n");v18239+=1;if(v18240=0!=v18239){if(v18240=v18239<v22571)v18240=v18239+1,v18240=v22569.charAt(v18240),v18240="\r"==v18240;v18240&&(v18239+=
1)}v18239=JAMScript.call(Comment.consumeLeadingSpace,Comment,[v22569,v18239]);if(v18240=v18239!=v22571)v22569=v22569.charAt(v18239),v18240="*"==v22569;if(v22569=v18240)v22569=v22571-v18239,v11100=v22569-1;return JAMScript.call(Comment.cleanJSDocComment,Comment,[i,v11100])}}i+=1;v22569=fncDocComments.length;v22569=i<v22569}return""}function getDocCommentText(comments){for(var docCommentText=[],c=0,v18256=comments.length,v18256=c<v18256;v18256;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v18256=
comments[c];var v18256=JAMScript.call(v18256.getDocCommentText,v18256,[]),v11103=""!=v18256;v11103&&JAMScript.call(docCommentText.push,docCommentText,[v18256]);c+=1;v18256=comments.length;v18256=c<v18256}return docCommentText.join("\n")}function cleanJSDocComment(content,spacesToRemove){var docCommentLines=[];content=content.replace("/**","");var v22579=content.length;if(v22579=2<=v22579)if(v22579=content.length,v22579-=1,v22579=content.charAt(v22579),v22579="/"==v22579)v22579=content.length,v22579-=
2,v22579=content.charAt(v22579),v22579="*"==v22579;v22579&&(v22579=content.length,v22579-=2,content=JAMScript.call(content.substring,content,[0,v22579]));for(var v22579=content.split("\n"),inParamTag=!1,l=0,v18260=v22579.length,v18260=l<v18260;v18260;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var line=v22579[l];var v18260=JAMScript.call(Comment.cleanDocCommentLine,Comment,[line,!0,spacesToRemove]),v11107=!v18260;if(!v11107){var docCommentText="",v11108=v11107=
v18260.minChar,v11108=line.indexOf("@",v11108),v18262=0<=v11108;v18262&&(v18262=v18260.limChar,v18262=v11108<v18262);for(;v18262;){var v18262=inParamTag,v24703=v11108+1,v24703=line.indexOf("param",v24703),v22583=v11108+1;if(v24703=v24703==v22583)v24703=v11108+6,v24703=JAMScript.call(Comment.isSpaceChar,Comment,[line,v24703]);if(v24703){if(inParamTag=!v18262)inParamTag=docCommentText,v11107=JAMScript.call(line.substring,line,[v11107,v11108]),docCommentText=inParamTag+v11107;v11107=v11108;inParamTag=
!0}else v18262&&(v11107=v11108,inParamTag=!1);v11108+=1;v11108=line.indexOf("@",v11108);if(v18262=0<=v11108)v18262=v18260.limChar,v18262=v11108<v18262}if(v11108=!inParamTag)v11108=v18260.limChar,line=JAMScript.call(line.substring,line,[v11107,v11108]),docCommentText+=line;if(line=JAMScript.call(Comment.cleanDocCommentLine,Comment,[docCommentText,!1])){if(line=void 0==spacesToRemove)spacesToRemove=v18260.jsDocSpacesRemoved;JAMScript.call(docCommentLines.push,docCommentLines,[docCommentText])}}l+=1;
v18260=v22579.length;v18260=l<v18260}return docCommentLines.join("\n")}function cleanDocCommentLine(line,jsDocStyleComment,jsDocLineSpaceToRemove){var nonSpaceIndex=JAMScript.call(Comment.consumeLeadingSpace,Comment,[line,0]),v11118=-1!=nonSpaceIndex;if(v11118){v11118=nonSpaceIndex;jsDocStyleComment&&(jsDocStyleComment=line.charAt(nonSpaceIndex),jsDocStyleComment="*"==jsDocStyleComment);if(jsDocStyleComment)if(v11118=nonSpaceIndex+1,nonSpaceIndex=JAMScript.call(Comment.consumeLeadingSpace,Comment,
[line,v11118,jsDocLineSpaceToRemove]),jsDocLineSpaceToRemove=-1!=nonSpaceIndex)v11118=nonSpaceIndex-v11118;else return null;jsDocLineSpaceToRemove=line.length;jsDocLineSpaceToRemove-=1;jsDocLineSpaceToRemove=line.charAt(jsDocLineSpaceToRemove);(jsDocLineSpaceToRemove="\r"==jsDocLineSpaceToRemove)?(line=line.length,line-=1):line=line.length;return{minChar:nonSpaceIndex,limChar:line,jsDocSpacesRemoved:v11118}}return null}function isSpaceChar(line,index){var length=line.length,v11120=index<length;if(v11120){var length=
JAMScript.call(line.charCodeAt,line,[index]),v11120=TypeScript.LexCodeSpace,v11120=length==v11120,v18275=!v11120;v18275&&(v11120=TypeScript.LexCodeTAB,v11120=length==v11120);return v11120}return index==length}function consumeLeadingSpace(line,startIndex,maxSpacesToRemove){var endIndex=line.length,v11122=void 0!=maxSpacesToRemove;v11122&&(maxSpacesToRemove=startIndex+maxSpacesToRemove,endIndex=JAMScript.call(TypeScript.min,TypeScript,[maxSpacesToRemove,endIndex]));for(maxSpacesToRemove=startIndex<
endIndex;maxSpacesToRemove;){maxSpacesToRemove=JAMScript.call(line.charCodeAt,line,[startIndex]);v11122=TypeScript.LexCodeSpace;if(v11122=maxSpacesToRemove!=v11122)v11122=TypeScript.LexCodeTAB,v11122=maxSpacesToRemove!=v11122;if(maxSpacesToRemove=v11122)return startIndex;startIndex+=1;maxSpacesToRemove=startIndex<endIndex}line=line.length;return(line=endIndex!=line)?endIndex:-1}function v318(){var v18278=this.docCommentText;if(v18278=null==v18278)v18278=this.content,this.docCommentText=v18278=JAMScript.call(Comment.cleanJSDocComment,
Comment,[v18278]);return this.docCommentText}function v317(){var v11129=this.isBlockComment;return v11129?(v11129=this.content,v11129=v11129.charAt(2),"*"==v11129):!1}function v316(){var v18280=this.text;if(v18280=null==v18280)if(v18280=this.isBlockComment){v18280=this.content;this.text=v18280=v18280.split("\n");for(var v18280=0,v22592=this.text,v22592=v22592.length,v22592=v18280<v22592;v22592;){var v22592=this.text,v11132=v18280,v22593=this.text;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v22593=
v22593[v18280];v22593=v22593.replace(/^\s+|\s+$/g,"");v22592[v11132]=v22593;v18280+=1;v22592=this.text;v22592=v22592.length;v22592=v18280<v22592}}else v18280=this.content,v18280=v18280.replace(/^\s+|\s+$/g,""),this.text=[v18280];return this.text}function Comment(content,isBlockComment,endsLine){var v18285=TypeScript.NodeType,v18285=v18285.Comment;JAMScript.call(_super.call,_super,[this,v18285]);this.content=content;this.isBlockComment=isBlockComment;this.endsLine=endsLine;this.docCommentText=this.text=
null}JAMScript.call(__extends,null,[Comment,_super]);var v11138=Comment.prototype;v11138.getText=v316;v11138=Comment.prototype;v11138.isDocComment=v317;v11138=Comment.prototype;v11138.getDocCommentText=v318;Comment.consumeLeadingSpace=consumeLeadingSpace;Comment.isSpaceChar=isSpaceChar;Comment.cleanDocCommentLine=cleanDocCommentLine;Comment.cleanJSDocComment=cleanJSDocComment;Comment.getDocCommentText=getDocCommentText;Comment.getParameterDocCommentText=getParameterDocCommentText;Comment.getDocCommentTextOfSignatures=
getDocCommentTextOfSignatures;return Comment}function v315(_super){function v314(typeFlow){var v11141=this.body;this.body=typeFlow=JAMScript.call(typeFlow.typeCheck,typeFlow,[v11141]);return this}function v313(context){var v11143=this.body;v11143&&(v11143=this.body,JAMScript.call(context.walk,context,[v11143,this]));v11143=context.walker;v11143=v11143.options;v11143.goChildren=!1;context.noContinuation=!1}function v312(emitter,tokenId,startLine){JAMScript.call(emitter.emitParensAndCommentsInPlace,
emitter,[this,!0]);JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);JAMScript.call(emitter.writeToOutput,emitter,["finally"]);tokenId=this.body;startLine=TypeScript.TokenID;startLine=startLine.Finally;JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,!1]);JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function Finally(body){var v18288=TypeScript.NodeType,v18288=v18288.Finally;JAMScript.call(_super.call,
_super,[this,v18288]);this.body=body}JAMScript.call(__extends,null,[Finally,_super]);var v11148=Finally.prototype;v11148.emit=v312;v11148=Finally.prototype;v11148.addToControlFlow=v313;v11148=Finally.prototype;v11148.typeCheck=v314;return Finally}function v311(_super){function v310(typeFlow){var prevScope=typeFlow.scope;typeFlow.scope=this.containedScope;var v11151=this.param;this.param=v11151=JAMScript.call(typeFlow.typeCheck,typeFlow,[v11151]);var v11151=TypeScript.ValueLocation,v11151=JAMScript.new(v11151,
[]),v11153=TypeScript.VariableSymbol,v22595=this.param,v22595=v22595.id,v22595=v22595.text,v18290=this.param,v18290=v18290.minChar,v22596=typeFlow.checker,v22596=v22596.locationInfo,v22596=v22596.unitIndex,v11153=JAMScript.new(v11153,[v22595,v18290,v22596,v11151]);v11151.symbol=v11153;v11153=v11151;v22595=TypeScript.TypeLink;v22595=JAMScript.new(v22595,[]);v11153.typeLink=v22595;v11153=v11151.typeLink;v11153.type=typeFlow.anyType;if(v22595=v11153=typeFlow.thisFnc)v22595=v11153.type;v22595?(v22595=
v11151.symbol,v11153=v11153.type,v22595.container=v11153.symbol):(v11153=v11151.symbol,v11153.container=null);v11153=this.param;v11153.sym=v11151.symbol;var v11153=typeFlow.scope,v22595=v11151.symbol,v22595=v22595.container,v18290=this.param,v22596=v11151.symbol,v18296=typeFlow.checker,v18296=v18296.errorReporter;JAMScript.call(v11153.enter,v11153,[v22595,v18290,v22596,v18296,!1,!1,!1]);v11153=this.body;this.body=v11153=JAMScript.call(typeFlow.typeCheck,typeFlow,[v11153]);v11153=typeFlow.checker;
if(v11153=JAMScript.call(v11153.inProvisionalTypecheckMode,v11153,[]))v11153=typeFlow.scope,v11153=JAMScript.call(v11153.getTable,v11153,[]),v11153=v11153.secondaryTable,v11153=v11153.table,v11151=v11151.symbol,v11151=v11151.name,JAMScript.set(v11153,v11151,void 0);this.type=typeFlow.voidType;typeFlow.scope=prevScope;return this}function v309(context){var v11176=this.param;if(v11176){v11176=this.param;JAMScript.call(context.addContent,context,[v11176]);var v11176=TypeScript.BasicBlock,v11176=JAMScript.new(v11176,
[]),v11175=context.current;JAMScript.call(v11175.addSuccessor,v11175,[v11176]);context.current=v11176}if(v11176=this.body)v11176=this.body,JAMScript.call(context.walk,context,[v11176,this]);context.noContinuation=!1;context=context.walker;context=context.options;context.goChildren=!1}function v308(emitter,tokenId,startLine){JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);JAMScript.call(emitter.writeToOutput,emitter,
[" "]);tokenId=this.statement;JAMScript.call(emitter.recordSourceMappingStart,emitter,[tokenId]);JAMScript.call(emitter.writeToOutput,emitter,["catch ("]);tokenId=this.param;startLine=TypeScript.TokenID;startLine=startLine.OpenParen;JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,!1]);JAMScript.call(emitter.writeToOutput,emitter,[")"]);tokenId=this.statement;JAMScript.call(emitter.recordSourceMappingEnd,emitter,[tokenId]);tokenId=this.body;startLine=TypeScript.TokenID;startLine=startLine.Catch;
JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,!1]);JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function Catch(param,body){var v18303=TypeScript.NodeType,v18303=v18303.Catch;JAMScript.call(_super.call,_super,[this,v18303]);this.param=param;this.body=body;this.statement=v18303=JAMScript.new(ASTSpan,[]);this.containedScope=null;if(v18303=this.param){var v18303=this.param,v22597=v18303.varFlags,
v24705=TypeScript.VarFlags,v24705=v24705.AutoInit;v18303.varFlags=v22597|v24705}}JAMScript.call(__extends,null,[Catch,_super]);var v11189=Catch.prototype;v11189.emit=v308;v11189=Catch.prototype;v11189.addToControlFlow=v309;v11189=Catch.prototype;v11189.typeCheck=v310;return Catch}function v307(_super){function v306(context){var v11193=this.body;v11193&&(v11193=this.body,JAMScript.call(context.walk,context,[v11193,this]));v11193=context.walker;v11193=v11193.options;v11193.goChildren=!1;context.noContinuation=
!1}function v305(typeFlow){var v11195=this.body;this.body=typeFlow=JAMScript.call(typeFlow.typeCheck,typeFlow,[v11195]);return this}function v304(emitter,tokenId,startLine){JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);JAMScript.call(emitter.writeToOutput,emitter,["try "]);tokenId=this.body;startLine=TypeScript.TokenID;startLine=startLine.Try;JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,!1]);
JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function Try(body){var v18306=TypeScript.NodeType,v18306=v18306.Try;JAMScript.call(_super.call,_super,[this,v18306]);this.body=body}JAMScript.call(__extends,null,[Try,_super]);var v11199=Try.prototype;v11199.emit=v304;v11199=Try.prototype;v11199.typeCheck=v305;v11199=Try.prototype;v11199.addToControlFlow=v306;return Try}function v303(_super){function v302(typeFlow){var v11202=
this.tryNode;this.tryNode=v11202=JAMScript.call(typeFlow.typeCheck,typeFlow,[v11202]);v11202=this.catchNode;this.catchNode=v11202=JAMScript.call(typeFlow.typeCheck,typeFlow,[v11202]);this.type=typeFlow.voidType;return this}function v301(context){var beforeTry=context.current,v11204=TypeScript.BasicBlock,v11204=JAMScript.new(v11204,[]);JAMScript.call(beforeTry.addSuccessor,beforeTry,[v11204]);context.current=v11204;v11204=TypeScript.BasicBlock;v11204=JAMScript.new(v11204,[]);JAMScript.call(context.pushStatement,
context,[this,null,v11204]);var v11206=this.tryNode;JAMScript.call(context.walk,context,[v11206,this]);v11206=context.noContinuation;if(v11206=!v11206)if(v11206=context.current)v11206=context.current,JAMScript.call(v11206.addSuccessor,v11206,[v11204]);var v11206=context,v18308=TypeScript.BasicBlock,v18308=JAMScript.new(v18308,[]);v11206.current=v18308;v11206=context.current;JAMScript.call(beforeTry.addSuccessor,beforeTry,[v11206]);beforeTry=this.catchNode;JAMScript.call(context.walk,context,[beforeTry,
this]);JAMScript.call(context.popStatement,context,[]);beforeTry=context.noContinuation;if(beforeTry=!beforeTry)if(beforeTry=context.current)beforeTry=context.current,JAMScript.call(beforeTry.addSuccessor,beforeTry,[v11204]);context.current=v11204;context=context.walker;context=context.options;context.goChildren=!1}function v300(emitter,tokenId,startLine){JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);tokenId=
this.tryNode;startLine=TypeScript.TokenID;startLine=startLine.Try;JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,!1]);tokenId=this.catchNode;startLine=TypeScript.TokenID;startLine=startLine.Catch;JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,!1]);JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v299(){return!0}function TryCatch(tryNode,catchNode){var v18313=TypeScript.NodeType,
v18313=v18313.TryCatch;JAMScript.call(_super.call,_super,[this,v18313]);this.tryNode=tryNode;this.catchNode=catchNode}JAMScript.call(__extends,null,[TryCatch,_super]);var v11222=TryCatch.prototype;v11222.isCompoundStatement=v299;v11222=TryCatch.prototype;v11222.emit=v300;v11222=TryCatch.prototype;v11222.addToControlFlow=v301;v11222=TryCatch.prototype;v11222.typeCheck=v302;return TryCatch}function v298(_super){function v297(context){var v11226=TypeScript.BasicBlock,v11226=JAMScript.new(v11226,[]),
v11227=this.tryNode;JAMScript.call(context.walk,context,[v11227,this]);var v11227=TypeScript.BasicBlock,v11227=JAMScript.new(v11227,[]),v11230=context.current;v11230&&(v11230=context.current,JAMScript.call(v11230.addSuccessor,v11230,[v11227]));context.current=v11227;JAMScript.call(context.pushStatement,context,[this,null,v11226]);v11227=this.finallyNode;JAMScript.call(context.walk,context,[v11227,this]);v11227=context.noContinuation;if(v11227=!v11227)v11227=context.current;v11227&&(v11227=context.current,
JAMScript.call(v11227.addSuccessor,v11227,[v11226]));v11227=v11226.predecessors;v11227=v11227.length;(v11227=0<v11227)?context.current=v11226:context.noContinuation=!0;JAMScript.call(context.popStatement,context,[]);context=context.walker;context=context.options;context.goChildren=!1}function v296(typeFlow){var v11236=this.tryNode;this.tryNode=v11236=JAMScript.call(typeFlow.typeCheck,typeFlow,[v11236]);v11236=this.finallyNode;this.finallyNode=v11236=JAMScript.call(typeFlow.typeCheck,typeFlow,[v11236]);
this.type=typeFlow.voidType;return this}function v295(emitter,tokenId,startLine){JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);tokenId=this.tryNode;startLine=TypeScript.TokenID;startLine=startLine.Try;JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,!1]);tokenId=this.finallyNode;startLine=TypeScript.TokenID;startLine=startLine.Finally;JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,!1]);JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this])}
function v294(){return!0}function TryFinally(tryNode,finallyNode){var v18319=TypeScript.NodeType,v18319=v18319.TryFinally;JAMScript.call(_super.call,_super,[this,v18319]);this.tryNode=tryNode;this.finallyNode=finallyNode}JAMScript.call(__extends,null,[TryFinally,_super]);var v11243=TryFinally.prototype;v11243.isCompoundStatement=v294;v11243=TryFinally.prototype;v11243.emit=v295;v11243=TryFinally.prototype;v11243.typeCheck=v296;v11243=TryFinally.prototype;v11243.addToControlFlow=v297;return TryFinally}
function v293(_super){function v292(typeFlow){var prevInTCTR=typeFlow.inTypeRefTypeCheck;typeFlow.inTypeRefTypeCheck=!0;var v11247=typeFlow.checker,v11247=JAMScript.call(TypeScript.getTypeLink,TypeScript,[this,v11247,!0]),v11248=typeFlow.checker,v11249=typeFlow.scope;JAMScript.call(v11248.resolveTypeLink,v11248,[v11249,v11247,!1]);if(v11248=this.term)v11248=this.term,JAMScript.call(typeFlow.typeCheck,typeFlow,[v11248]);v11248=v11247.type;JAMScript.call(typeFlow.checkForVoidConstructor,typeFlow,[v11248,
this]);this.type=v11247.type;if(v11247=this.term)v11247=this.term,v11247.type=this.type;typeFlow.inTypeRefTypeCheck=prevInTCTR;return this}function v291(emitter,tokenId,startLine){throw Error("should not emit a type ref");}function TypeReference(term,arrayCount){var v18320=TypeScript.NodeType,v18320=v18320.TypeRef;JAMScript.call(_super.call,_super,[this,v18320]);this.term=term;this.arrayCount=arrayCount}JAMScript.call(__extends,null,[TypeReference,_super]);var v11256=TypeReference.prototype;v11256.emit=
v291;v11256=TypeReference.prototype;v11256.typeCheck=v292;return TypeReference}function v290(_super){function v289(context){var v11258=TypeScript.BasicBlock,v11258=JAMScript.new(v11258,[]),v11259=context.currentSwitch,v22601=context.currentSwitch,v22601=v22601.length,v22601=v22601-1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v11259=v11259[v22601];(v22601=this.expr)?(v22601=TypeScript.BasicBlock,v22601=JAMScript.new(v22601,[]),context.current=v22601,JAMScript.call(v11259.addSuccessor,
v11259,[v22601]),v11259=this.expr,JAMScript.call(context.addContent,context,[v11259]),JAMScript.call(v22601.addSuccessor,v22601,[v11258])):JAMScript.call(v11259.addSuccessor,v11259,[v11258]);context.current=v11258;if(v11258=this.body)v11258=this.body,JAMScript.call(context.walk,context,[v11258,this]);context.noContinuation=!1;context=context.walker;context=context.options;context.goChildren=!1}function v288(typeFlow){var v11267=this.expr;this.expr=v11267=JAMScript.call(typeFlow.typeCheck,typeFlow,
[v11267]);v11267=this.body;JAMScript.call(typeFlow.typeCheck,typeFlow,[v11267]);this.type=typeFlow.voidType;return this}function v287(emitter,tokenId,startLine){JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);(tokenId=this.expr)?(JAMScript.call(emitter.writeToOutput,emitter,["case "]),tokenId=this.expr,startLine=TypeScript.TokenID,startLine=startLine.Identifier,JAMScript.call(emitter.emitJavascript,emitter,[tokenId,
startLine,!1])):JAMScript.call(emitter.writeToOutput,emitter,["default"]);JAMScript.call(emitter.writeToOutput,emitter,[":"]);tokenId=this.body;tokenId=tokenId.members;tokenId=tokenId.length;if(tokenId=1==tokenId)tokenId=this.body,tokenId=tokenId.members,tokenId=tokenId[0],tokenId=tokenId.nodeType,startLine=TypeScript.NodeType,startLine=startLine.Block,tokenId=tokenId==startLine;tokenId?(tokenId=this.body,JAMScript.call(emitter.emitJavascriptStatements,emitter,[tokenId,!1])):(JAMScript.call(emitter.writeLineToOutput,
emitter,[""]),tokenId=emitter.indenter,JAMScript.call(tokenId.increaseIndent,tokenId,[]),tokenId=this.body,JAMScript.call(emitter.emitBareJavascriptStatements,emitter,[tokenId]),tokenId=emitter.indenter,JAMScript.call(tokenId.decreaseIndent,tokenId,[]));JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function CaseStatement(){var v18325=TypeScript.NodeType,v18325=v18325.Case;JAMScript.call(_super.call,_super,[this,
v18325]);this.expr=null}JAMScript.call(__extends,null,[CaseStatement,_super]);var v11278=CaseStatement.prototype;v11278.emit=v287;v11278=CaseStatement.prototype;v11278.typeCheck=v288;v11278=CaseStatement.prototype;v11278.addToControlFlow=v289;return CaseStatement}function v286(_super){function v285(context){var condBlock=context.current,v11281=this.val;JAMScript.call(context.addContent,context,[v11281]);var v11281=TypeScript.BasicBlock,execBlock=JAMScript.new(v11281,[]),v11281=TypeScript.BasicBlock,
v11281=JAMScript.new(v11281,[]);JAMScript.call(condBlock.addSuccessor,condBlock,[execBlock]);JAMScript.call(context.pushSwitch,context,[execBlock]);context.current=execBlock;JAMScript.call(context.pushStatement,context,[this,execBlock,v11281]);execBlock=this.caseList;JAMScript.call(context.walk,context,[execBlock,this]);JAMScript.call(context.popSwitch,context,[]);JAMScript.call(context.popStatement,context,[]);execBlock=this.defaultCase;(execBlock=null==execBlock)&&JAMScript.call(condBlock.addSuccessor,
condBlock,[v11281]);condBlock=v11281.predecessors;condBlock=condBlock.length;(condBlock=0<condBlock)?(context.noContinuation=!1,context.current=v11281):context.noContinuation=!0;context=context.walker;context=context.options;context.goChildren=!1}function v284(typeFlow){var v18329=this.caseList,v18329=v18329.members,v18329=v18329.length,v11290=this.val;this.val=v11290=JAMScript.call(typeFlow.typeCheck,typeFlow,[v11290]);for(var v11290=0,v11293=v11290<v18329;v11293;){var v11293=this.caseList,v11293=
v11293.members,v11292=v11290,v24709=this.caseList,v24709=v24709.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v24709=v24709[v11290];v24709=JAMScript.call(typeFlow.typeCheck,typeFlow,[v24709]);v11293[v11292]=v24709;v11290+=1;v11293=v11290<v18329}v18329=this.defaultCase;this.defaultCase=v18329=JAMScript.call(typeFlow.typeCheck,typeFlow,[v18329]);this.type=typeFlow.voidType;return this}function v283(emitter,tokenId,startLine){JAMScript.call(emitter.emitParensAndCommentsInPlace,
emitter,[this,!0]);JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);tokenId=JAMScript.call(emitter.setInObjectLiteral,emitter,[!1]);startLine=this.statement;JAMScript.call(emitter.recordSourceMappingStart,emitter,[startLine]);JAMScript.call(emitter.writeToOutput,emitter,["switch("]);startLine=this.val;var v18332=TypeScript.TokenID,v18332=v18332.Identifier;JAMScript.call(emitter.emitJavascript,emitter,[startLine,v18332,!1]);JAMScript.call(emitter.writeToOutput,emitter,[")"]);startLine=
this.statement;JAMScript.call(emitter.recordSourceMappingEnd,emitter,[startLine]);JAMScript.call(emitter.writeLineToOutput,emitter,[" {"]);startLine=emitter.indenter;JAMScript.call(startLine.increaseIndent,startLine,[]);startLine=this.caseList;startLine=startLine.members;startLine=startLine.length;for(var v18332=0,v11303=v18332<startLine;v11303;){v11303=this.caseList;v11303=v11303.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v11303=v11303[v18332];var v18335=
TypeScript.TokenID,v18335=v18335.Case;JAMScript.call(emitter.emitJavascript,emitter,[v11303,v18335,!0]);v18332+=1;v11303=v18332<startLine}startLine=emitter.indenter;JAMScript.call(startLine.decreaseIndent,startLine,[]);JAMScript.call(emitter.emitIndent,emitter,[]);JAMScript.call(emitter.writeToOutput,emitter,["}"]);JAMScript.call(emitter.setInObjectLiteral,emitter,[tokenId]);JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,
!1])}function v282(){return!0}function SwitchStatement(val){var v18336=TypeScript.NodeType,v18336=v18336.Switch;JAMScript.call(_super.call,_super,[this,v18336]);this.val=val;this.defaultCase=null;this.statement=val=JAMScript.new(ASTSpan,[])}JAMScript.call(__extends,null,[SwitchStatement,_super]);var v11306=SwitchStatement.prototype;v11306.isCompoundStatement=v282;v11306=SwitchStatement.prototype;v11306.emit=v283;v11306=SwitchStatement.prototype;v11306.typeCheck=v284;v11306=SwitchStatement.prototype;
v11306.addToControlFlow=v285;return SwitchStatement}function v281(_super){function v280(typeFlow){return JAMScript.call(typeFlow.typeCheckWith,typeFlow,[this])}function v279(emitter,tokenId,startLine){JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);JAMScript.call(emitter.writeToOutput,emitter,["with ("]);if(tokenId=this.expr)tokenId=this.expr,startLine=TypeScript.TokenID,startLine=startLine.With,JAMScript.call(emitter.emitJavascript,
emitter,[tokenId,startLine,!1]);JAMScript.call(emitter.writeToOutput,emitter,[")"]);tokenId=this.body;JAMScript.call(emitter.emitJavascriptStatements,emitter,[tokenId,!0]);JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v278(){return!0}function WithStatement(expr){var v18338=TypeScript.NodeType,v18338=v18338.With;JAMScript.call(_super.call,_super,[this,v18338]);this.expr=expr;this.withSym=null}JAMScript.call(__extends,
null,[WithStatement,_super]);var v11315=WithStatement.prototype;v11315.isCompoundStatement=v278;v11315=WithStatement.prototype;v11315.emit=v279;v11315=WithStatement.prototype;v11315.typeCheck=v280;return WithStatement}function v277(_super){function v276(context){var v11319=this.init;v11319&&(v11319=this.init,JAMScript.call(context.addContent,context,[v11319]));var loopHeader=context.current,v11319=TypeScript.BasicBlock,loopStart=JAMScript.new(v11319,[]),v11319=TypeScript.BasicBlock,v11319=JAMScript.new(v11319,
[]);JAMScript.call(loopHeader.addSuccessor,loopHeader,[loopStart]);context.current=loopStart;var loopHeader=null,continueTarget=loopStart,incrBB=null,v11323=this.incr;v11323&&(incrBB=TypeScript.BasicBlock,continueTarget=incrBB=JAMScript.new(incrBB,[]));if(v11323=this.cond){loopHeader=context.current;v11323=this.cond;JAMScript.call(context.addContent,context,[v11323]);var v11323=context,v18339=TypeScript.BasicBlock,v18339=JAMScript.new(v18339,[]);v11323.current=v18339;v11323=context.current;JAMScript.call(loopHeader.addSuccessor,
loopHeader,[v11323])}if(v11323=this.body)JAMScript.call(context.pushStatement,context,[this,continueTarget,v11319]),continueTarget=this.body,JAMScript.call(context.walk,context,[continueTarget,this]),JAMScript.call(context.popStatement,context,[]);if(continueTarget=this.incr)if(continueTarget=context.noContinuation){if(incrBB=incrBB.predecessors,incrBB=incrBB.length,incrBB=0==incrBB)incrBB=this.incr,JAMScript.call(context.addUnreachable,context,[incrBB])}else continueTarget=context.current,JAMScript.call(continueTarget.addSuccessor,
continueTarget,[incrBB]),context.current=incrBB,incrBB=this.incr,JAMScript.call(context.addContent,context,[incrBB]);incrBB=context.current;continueTarget=context.noContinuation;(continueTarget=!continueTarget)&&JAMScript.call(incrBB.addSuccessor,incrBB,[loopStart]);loopHeader&&(JAMScript.call(loopHeader.addSuccessor,loopHeader,[v11319]),context.noContinuation=!1);loopStart=v11319.predecessors;loopStart=loopStart.length;if(loopStart=0<loopStart)context.noContinuation=!1,context.current=v11319;context=
context.walker;context=context.options;context.goChildren=!1}function v275(typeFlow){return JAMScript.call(typeFlow.typeCheckFor,typeFlow,[this])}function v274(emitter,tokenId,startLine){JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);tokenId=JAMScript.call(emitter.setInObjectLiteral,emitter,[!1]);JAMScript.call(emitter.writeToOutput,emitter,["for("]);if(startLine=this.init){startLine=this.init;startLine=startLine.nodeType;
var v22610=TypeScript.NodeType,v22610=v22610.List;(startLine=startLine!=v22610)?(startLine=this.init,v22610=TypeScript.TokenID,v22610=v22610.For,JAMScript.call(emitter.emitJavascript,emitter,[startLine,v22610,!1])):(startLine=this.init,startLine=startLine.members,startLine=startLine.length,JAMScript.call(emitter.setInVarBlock,emitter,[startLine]),startLine=this.init,v22610=TypeScript.TokenID,v22610=v22610.For,JAMScript.call(emitter.emitJavascriptList,emitter,[startLine,null,v22610,!1,!1,!1]))}JAMScript.call(emitter.writeToOutput,
emitter,["; "]);startLine=this.cond;v22610=TypeScript.TokenID;v22610=v22610.For;JAMScript.call(emitter.emitJavascript,emitter,[startLine,v22610,!1]);JAMScript.call(emitter.writeToOutput,emitter,["; "]);startLine=this.incr;v22610=TypeScript.TokenID;v22610=v22610.For;JAMScript.call(emitter.emitJavascript,emitter,[startLine,v22610,!1]);JAMScript.call(emitter.writeToOutput,emitter,[")"]);startLine=this.body;JAMScript.call(emitter.emitJavascriptStatements,emitter,[startLine,!0]);JAMScript.call(emitter.setInObjectLiteral,
emitter,[tokenId]);JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v273(){return!0}function ForStatement(init){var v18351=TypeScript.NodeType,v18351=v18351.For;JAMScript.call(_super.call,_super,[this,v18351]);this.init=init}JAMScript.call(__extends,null,[ForStatement,_super]);var v11352=ForStatement.prototype;v11352.isLoop=v273;v11352=ForStatement.prototype;v11352.emit=v274;v11352=ForStatement.prototype;
v11352.typeCheck=v275;v11352=ForStatement.prototype;v11352.addToControlFlow=v276;return ForStatement}function v272(_super){function v271(context){var v11357=this.lval;v11357&&(v11357=this.lval,JAMScript.call(context.addContent,context,[v11357]));if(v11357=this.obj)v11357=this.obj,JAMScript.call(context.addContent,context,[v11357]);var v11357=context.current,v11360=TypeScript.BasicBlock,v11360=JAMScript.new(v11360,[]),v11361=TypeScript.BasicBlock,v11361=JAMScript.new(v11361,[]);JAMScript.call(v11357.addSuccessor,
v11357,[v11360]);context.current=v11360;var v11363=this.body;v11363&&(JAMScript.call(context.pushStatement,context,[this,v11360,v11361]),v11363=this.body,JAMScript.call(context.walk,context,[v11363,this]),JAMScript.call(context.popStatement,context,[]));v11363=context.noContinuation;if(v11363=!v11363)v11363=context.current,JAMScript.call(v11363.addSuccessor,v11363,[v11360]);context.current=v11361;context.noContinuation=!1;JAMScript.call(v11357.addSuccessor,v11357,[v11361]);context=context.walker;
context=context.options;context.goChildren=!1}function v270(typeFlow){var v22612=typeFlow.checker,v22612=v22612.styleSettings;if(v22612=v22612.forin)if(v22612=JAMScript.call(this.isFiltered,this,[]),v22612=!v22612)v22612=typeFlow.checker,v22612=v22612.errorReporter,JAMScript.call(v22612.styleError,v22612,[this,"no hasOwnProperty filter"]);return JAMScript.call(typeFlow.typeCheckForIn,typeFlow,[this])}function v269(emitter,tokenId,startLine){JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,
[this,!0]);JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);tokenId=JAMScript.call(emitter.setInObjectLiteral,emitter,[!1]);startLine=this.statement;JAMScript.call(emitter.recordSourceMappingStart,emitter,[startLine]);JAMScript.call(emitter.writeToOutput,emitter,["for("]);startLine=this.lval;var v18357=TypeScript.TokenID,v18357=v18357.For;JAMScript.call(emitter.emitJavascript,emitter,[startLine,v18357,!1]);JAMScript.call(emitter.writeToOutput,emitter,[" in "]);startLine=this.obj;v18357=
TypeScript.TokenID;v18357=v18357.For;JAMScript.call(emitter.emitJavascript,emitter,[startLine,v18357,!1]);JAMScript.call(emitter.writeToOutput,emitter,[")"]);startLine=this.statement;JAMScript.call(emitter.recordSourceMappingEnd,emitter,[startLine]);startLine=this.body;JAMScript.call(emitter.emitJavascriptStatements,emitter,[startLine,!0]);JAMScript.call(emitter.setInObjectLiteral,emitter,[tokenId]);JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);JAMScript.call(emitter.emitParensAndCommentsInPlace,
emitter,[this,!1])}function v268(){var v11392=this.body;if(v11392){var v11392=null,v22613=this.body,v22613=v22613.nodeType,v22614=TypeScript.NodeType,v22614=v22614.List;if(v22613=v22613==v22614){if(v22613=this.body,v22614=v22613.members,v22614=v22614.length,v22614=1==v22614)v11392=v22613.members,v11392=v11392[0]}else v11392=this.body;if(v22613=null!==v11392){v22613=v11392.nodeType;v22614=TypeScript.NodeType;v22614=v22614.Block;if(v22613=v22613==v22614){v22613=v11392;v22614=v22613.statements;if(v22614=
null!==v22614)v22614=v22613.statements,v22614=v22614.members,v22614=v22614.length,v22614=1==v22614;v22614&&(v11392=v22613.statements,v11392=v11392.members,v11392=v11392[0])}v22613=v11392.nodeType;v22614=TypeScript.NodeType;v22614=v22614.If;if(v22613=v22613==v22614)if(v11392=v11392.cond,v22613=v11392.nodeType,v22614=TypeScript.NodeType,v22614=v22614.Call,v22613=v22613==v22614){var v22613=v11392.target,v22614=v22613.nodeType,v22621=TypeScript.NodeType,v22621=v22621.Dot;if(v22614=v22614==v22621){v22614=
v22613.operand1;v22614=v22614.nodeType;v22621=TypeScript.NodeType;v22621=v22621.Name;if(v22614=v22614==v22621)if(v22614=this.obj,v22614=v22614.nodeType,v22621=TypeScript.NodeType,v22621=v22621.Name,v22614=v22614==v22621)v22614=v22613.operand1,v22614=v22614.actualText,v22621=this.obj,v22621=v22621.actualText,v22614=v22614==v22621;if(v22614&&(v22613=v22613.operand2,v22613=v22613.actualText,v22613="hasOwnProperty"==v22613)){v11392=v11392.arguments;if(v22613=null!==v11392)v22613=v11392.members,v22613=
v22613.length,v22613=1==v22613;if(v22613){v11392=v11392.members;v11392=v11392[0];v22613=v11392.nodeType;v22614=TypeScript.NodeType;v22614=v22614.Name;if(v22613=v22613==v22614)v22613=this.lval,v22613=v22613.nodeType,v22614=TypeScript.NodeType,v22614=v22614.Name,v22613=v22613==v22614;if(v22613&&(v22613=this.lval,v22613=v22613.actualText,v11392=v11392.actualText,v11392=v22613==v11392))return!0}}}}}}return!1}function v267(){return!0}function ForInStatement(lval,obj){var v18378=TypeScript.NodeType,v18378=
v18378.ForIn;JAMScript.call(_super.call,_super,[this,v18378]);this.lval=lval;this.obj=obj;this.statement=v18378=JAMScript.new(ASTSpan,[]);if(v18378=this.lval)var v18378=this.lval,v18378=v18378.nodeType,v24722=TypeScript.NodeType,v24722=v24722.VarDecl,v18378=v18378==v24722;if(v18378){var v18378=this.lval,v24722=v18378.varFlags,v24723=TypeScript.VarFlags,v24723=v24723.AutoInit;v18378.varFlags=v24722|v24723}}JAMScript.call(__extends,null,[ForInStatement,_super]);var v11396=ForInStatement.prototype;v11396.isLoop=
v267;v11396=ForInStatement.prototype;v11396.isFiltered=v268;v11396=ForInStatement.prototype;v11396.emit=v269;v11396=ForInStatement.prototype;v11396.typeCheck=v270;v11396=ForInStatement.prototype;v11396.addToControlFlow=v271;return ForInStatement}function v266(_super){function EndCode(){var v18380=TypeScript.NodeType,v18380=v18380.EndCode;JAMScript.call(_super.call,_super,[this,v18380])}JAMScript.call(__extends,null,[EndCode,_super]);return EndCode}function v265(_super){function v264(typeFlow){return JAMScript.call(typeFlow.typeCheckReturn,
typeFlow,[this])}function v263(context){var v18381=_super.prototype,v18381=v18381.addToControlFlow;JAMScript.call(v18381.call,v18381,[this,context]);JAMScript.call(context.returnStmt,context,[])}function v262(emitter,tokenId,startLine){JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);tokenId=JAMScript.call(emitter.setInObjectLiteral,emitter,[!1]);if(startLine=this.returnExpression){JAMScript.call(emitter.writeToOutput,
emitter,["return "]);startLine=this.returnExpression;var v18382=TypeScript.TokenID,v18382=v18382.Semicolon;JAMScript.call(emitter.emitJavascript,emitter,[startLine,v18382,!1]);startLine=this.returnExpression;startLine=startLine.nodeType;v18382=TypeScript.NodeType;v18382=v18382.FuncDecl;(startLine=startLine===v18382)&&JAMScript.call(emitter.writeToOutput,emitter,[";"])}else JAMScript.call(emitter.writeToOutput,emitter,["return;"]);JAMScript.call(emitter.setInObjectLiteral,emitter,[tokenId]);JAMScript.call(emitter.recordSourceMappingEnd,
emitter,[this]);JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function ReturnStatement(){var v18385=TypeScript.NodeType,v18385=v18385.Return;JAMScript.call(_super.call,_super,[this,v18385]);this.returnExpression=null}JAMScript.call(__extends,null,[ReturnStatement,_super]);var v11408=ReturnStatement.prototype;v11408.emit=v262;v11408=ReturnStatement.prototype;v11408.addToControlFlow=v263;v11408=ReturnStatement.prototype;v11408.typeCheck=v264;return ReturnStatement}function v261(_super){function v260(context){var v11411=
this.cond;JAMScript.call(v11411.addToControlFlow,v11411,[context]);var v11411=TypeScript.BasicBlock,v11411=JAMScript.new(v11411,[]),beforeIf=context.current;JAMScript.call(context.pushStatement,context,[this,beforeIf,v11411]);var hasContinuation=!1,v11413=context,v18386=TypeScript.BasicBlock,v18386=JAMScript.new(v18386,[]);v11413.current=v18386;v11413=context.current;JAMScript.call(beforeIf.addSuccessor,beforeIf,[v11413]);v11413=this.thenBod;JAMScript.call(context.walk,context,[v11413,this]);v11413=
context.noContinuation;if(v11413=!v11413)hasContinuation=!0,v11413=context.current,JAMScript.call(v11413.addSuccessor,v11413,[v11411]);(v11413=this.elseBod)?(v11413=context,v18386=TypeScript.BasicBlock,v18386=JAMScript.new(v18386,[]),v11413.current=v18386,context.noContinuation=!1,v11413=context.current,JAMScript.call(beforeIf.addSuccessor,beforeIf,[v11413]),beforeIf=this.elseBod,JAMScript.call(context.walk,context,[beforeIf,this]),beforeIf=context.noContinuation,(beforeIf=!beforeIf)?(hasContinuation=
!0,beforeIf=context.current,JAMScript.call(beforeIf.addSuccessor,beforeIf,[v11411])):hasContinuation&&(context.noContinuation=!1)):(JAMScript.call(beforeIf.addSuccessor,beforeIf,[v11411]),context.noContinuation=!1,hasContinuation=!0);JAMScript.call(context.popStatement,context,[]);beforeIf=v11411.predecessors;beforeIf=beforeIf.length;if(beforeIf=0<beforeIf)context.noContinuation=!1,hasContinuation=!0;hasContinuation&&(context.current=v11411);context=context.walker;context=context.options;context.goChildren=
!1}function v259(typeFlow){return JAMScript.call(typeFlow.typeCheckIf,typeFlow,[this])}function v258(emitter,tokenId,startLine){JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);startLine=JAMScript.call(emitter.setInObjectLiteral,emitter,[!1]);var v11426=this.statement;JAMScript.call(emitter.recordSourceMappingStart,emitter,[v11426]);JAMScript.call(emitter.writeToOutput,emitter,["if("]);var v11426=this.cond,v18392=
TypeScript.TokenID,v18392=v18392.If;JAMScript.call(emitter.emitJavascript,emitter,[v11426,v18392,!1]);JAMScript.call(emitter.writeToOutput,emitter,[")"]);v11426=this.statement;JAMScript.call(emitter.recordSourceMappingEnd,emitter,[v11426]);v11426=this.thenBod;JAMScript.call(emitter.emitJavascriptStatements,emitter,[v11426,!0]);if(v11426=this.elseBod)v11426=this.elseBod,v11426=v11426.nodeType,v18392=TypeScript.NodeType,v18392=v18392.If,(v11426=v11426===v18392)?(JAMScript.call(emitter.writeToOutput,
emitter,[" else "]),v11426=this.elseBod,JAMScript.call(v11426.emit,v11426,[emitter,tokenId,!1])):(JAMScript.call(emitter.writeToOutput,emitter,[" else"]),tokenId=this.elseBod,JAMScript.call(emitter.emitJavascriptStatements,emitter,[tokenId,!0]));JAMScript.call(emitter.setInObjectLiteral,emitter,[startLine]);JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v257(){return!0}function IfStatement(cond){var v18395=
TypeScript.NodeType,v18395=v18395.If;JAMScript.call(_super.call,_super,[this,v18395]);this.cond=cond;this.elseBod=null;this.statement=cond=JAMScript.new(ASTSpan,[])}JAMScript.call(__extends,null,[IfStatement,_super]);var v11436=IfStatement.prototype;v11436.isCompoundStatement=v257;v11436=IfStatement.prototype;v11436.emit=v258;v11436=IfStatement.prototype;v11436.typeCheck=v259;v11436=IfStatement.prototype;v11436.addToControlFlow=v260;return IfStatement}function v256(_super){function v255(context){var loopHeader=
context.current,v11440=TypeScript.BasicBlock,v11440=JAMScript.new(v11440,[]),v11441=TypeScript.BasicBlock,v11441=JAMScript.new(v11441,[]);JAMScript.call(loopHeader.addSuccessor,loopHeader,[v11440]);context.current=v11440;if(loopHeader=this.body)JAMScript.call(context.pushStatement,context,[this,v11440,v11441]),loopHeader=this.body,JAMScript.call(context.walk,context,[loopHeader,this]),JAMScript.call(context.popStatement,context,[]);loopHeader=context.noContinuation;(loopHeader=!loopHeader)?(loopHeader=
context.current,JAMScript.call(loopHeader.addSuccessor,loopHeader,[v11440]),v11440=this.cond,JAMScript.call(context.addContent,context,[v11440]),context.current=v11441,JAMScript.call(loopHeader.addSuccessor,loopHeader,[v11441])):(v11440=this.cond,JAMScript.call(context.addUnreachable,context,[v11440]));context=context.walker;context=context.options;context.goChildren=!1}function v254(typeFlow){return JAMScript.call(typeFlow.typeCheckDoWhile,typeFlow,[this])}function v253(emitter,tokenId,startLine){JAMScript.call(emitter.emitParensAndCommentsInPlace,
emitter,[this,!0]);JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);tokenId=JAMScript.call(emitter.setInObjectLiteral,emitter,[!1]);JAMScript.call(emitter.writeToOutput,emitter,["do"]);startLine=this.body;JAMScript.call(emitter.emitJavascriptStatements,emitter,[startLine,!0]);startLine=this.whileAST;JAMScript.call(emitter.recordSourceMappingStart,emitter,[startLine]);JAMScript.call(emitter.writeToOutput,emitter,["while"]);startLine=this.whileAST;JAMScript.call(emitter.recordSourceMappingEnd,
emitter,[startLine]);JAMScript.call(emitter.writeToOutput,emitter,["("]);startLine=this.cond;var v18398=TypeScript.TokenID,v18398=v18398.CloseParen;JAMScript.call(emitter.emitJavascript,emitter,[startLine,v18398,!1]);JAMScript.call(emitter.writeToOutput,emitter,[")"]);JAMScript.call(emitter.setInObjectLiteral,emitter,[tokenId]);JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);JAMScript.call(emitter.writeToOutput,emitter,[";"]);JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,
[this,!1])}function v252(){return!0}function DoWhileStatement(){var v18399=TypeScript.NodeType,v18399=v18399.DoWhile;JAMScript.call(_super.call,_super,[this,v18399]);this.cond=this.whileAST=this.body=null}JAMScript.call(__extends,null,[DoWhileStatement,_super]);var v11454=DoWhileStatement.prototype;v11454.isLoop=v252;v11454=DoWhileStatement.prototype;v11454.emit=v253;v11454=DoWhileStatement.prototype;v11454.typeCheck=v254;v11454=DoWhileStatement.prototype;v11454.addToControlFlow=v255;return DoWhileStatement}
function v251(_super){function v250(context){var loopHeader=context.current,v11458=TypeScript.BasicBlock,v11458=JAMScript.new(v11458,[]),v11459=TypeScript.BasicBlock,v11459=JAMScript.new(v11459,[]);JAMScript.call(loopHeader.addSuccessor,loopHeader,[v11458]);context.current=v11458;loopHeader=this.cond;JAMScript.call(context.addContent,context,[loopHeader]);var loopHeader=context.current,v11464=this.body;if(v11464){var v11464=context,v18400=TypeScript.BasicBlock,v18400=JAMScript.new(v18400,[]);v11464.current=
v18400;v11464=context.current;JAMScript.call(loopHeader.addSuccessor,loopHeader,[v11464]);JAMScript.call(context.pushStatement,context,[this,v11458,v11459]);v11464=this.body;JAMScript.call(context.walk,context,[v11464,this]);JAMScript.call(context.popStatement,context,[])}v11464=context.noContinuation;if(v11464=!v11464)v11464=context.current,JAMScript.call(v11464.addSuccessor,v11464,[v11458]);context.current=v11459;JAMScript.call(loopHeader.addSuccessor,loopHeader,[v11459]);context.noContinuation=
!1;context=context.walker;context=context.options;context.goChildren=!1}function v249(typeFlow){return JAMScript.call(typeFlow.typeCheckWhile,typeFlow,[this])}function v248(emitter,tokenId,startLine){JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);tokenId=JAMScript.call(emitter.setInObjectLiteral,emitter,[!1]);JAMScript.call(emitter.writeToOutput,emitter,["while("]);startLine=this.cond;var v18403=TypeScript.TokenID,
v18403=v18403.While;JAMScript.call(emitter.emitJavascript,emitter,[startLine,v18403,!1]);JAMScript.call(emitter.writeToOutput,emitter,[")"]);startLine=this.body;JAMScript.call(emitter.emitJavascriptStatements,emitter,[startLine,!1]);JAMScript.call(emitter.setInObjectLiteral,emitter,[tokenId]);JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v247(){return!0}function WhileStatement(cond){var v18404=TypeScript.NodeType,
v18404=v18404.While;JAMScript.call(_super.call,_super,[this,v18404]);this.cond=cond;this.body=null}JAMScript.call(__extends,null,[WhileStatement,_super]);var v11471=WhileStatement.prototype;v11471.isLoop=v247;v11471=WhileStatement.prototype;v11471.emit=v248;v11471=WhileStatement.prototype;v11471.typeCheck=v249;v11471=WhileStatement.prototype;v11471.addToControlFlow=v250;return WhileStatement}function v246(_super){function v245(emitter,tokenId,startLine){JAMScript.call(emitter.emitParensAndCommentsInPlace,
emitter,[this,!0]);JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);tokenId=this.nodeType;startLine=TypeScript.NodeType;startLine=startLine.Break;(tokenId=tokenId==startLine)?JAMScript.call(emitter.writeToOutput,emitter,["break"]):JAMScript.call(emitter.writeToOutput,emitter,["continue"]);if(tokenId=this.target)tokenId=this.target,tokenId=" "+tokenId,JAMScript.call(emitter.writeToOutput,emitter,[tokenId]);JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);JAMScript.call(emitter.writeToOutput,
emitter,[";"]);JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v244(context){var v18408=_super.prototype,v18408=v18408.addToControlFlow;JAMScript.call(v18408.call,v18408,[this,context]);var v18408=this.resolvedTarget,v18409=this.nodeType,v22641=TypeScript.NodeType,v22641=v22641.Continue,v18409=v18409==v22641;JAMScript.call(context.unconditionalBranch,context,[v18408,v18409])}function v243(parser,stmt){var v11481=JAMScript.call(stmt.isLoop,stmt,[]);if(v11481)return this.resolvedTarget=
stmt,!0;var v11481=this.nodeType,v22642=TypeScript.NodeType,v22642=v22642.Continue;if(v11481=v11481===v22642)return JAMScript.call(parser.reportParseError,parser,["continue statement applies only to loops"]),!1;v11481=stmt.nodeType;v22642=TypeScript.NodeType;v22642=v22642.Switch;v11481=v11481==v22642;if(v22642=!v11481)v11481=this.target;if(v11481)return this.resolvedTarget=stmt,!0;JAMScript.call(parser.reportParseError,parser,["break statement with no label can apply only to a loop or switch statement"]);
return!1}function v242(){return this.target}function Jump(nodeType){JAMScript.call(_super.call,_super,[this,nodeType]);this.resolvedTarget=this.target=null}JAMScript.call(__extends,null,[Jump,_super]);var v11484=Jump.prototype;v11484.hasExplicitTarget=v242;v11484=Jump.prototype;v11484.setResolvedTarget=v243;v11484=Jump.prototype;v11484.addToControlFlow=v244;v11484=Jump.prototype;v11484.emit=v245;return Jump}function v241(_super){function v240(typeFlow){var v24725=typeFlow.checker,v24725=v24725.styleSettings,
v24725=v24725.emptyBlocks;if(v24725=!v24725){var v24725=this.statements,v24725=null===v24725,v22649=!v24725;v22649&&(v24725=this.statements,v24725=v24725.members,v24725=v24725.length,v24725=0==v24725);v24725&&(v24725=typeFlow.checker,v24725=v24725.errorReporter,JAMScript.call(v24725.styleError,v24725,[this,"empty block"]))}v24725=this.statements;JAMScript.call(typeFlow.typeCheck,typeFlow,[v24725]);return this}function v239(context){var v11492=TypeScript.BasicBlock,v11492=JAMScript.new(v11492,[]),
v11493=context.current;JAMScript.call(context.pushStatement,context,[this,v11493,v11492]);if(v11493=this.statements)v11493=this.statements,JAMScript.call(context.walk,context,[v11493,this]);v11493=context.walker;v11493=v11493.options;v11493.goChildren=!1;JAMScript.call(context.popStatement,context,[]);v11493=v11492.predecessors;v11493=v11493.length;if(v11493=0<v11493)v11493=context.current,JAMScript.call(v11493.addSuccessor,v11493,[v11492]),context.current=v11492}function v238(emitter,tokenId,startLine){JAMScript.call(emitter.emitParensAndCommentsInPlace,
emitter,[this,!0]);JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);(tokenId=this.isStatementBlock)?(JAMScript.call(emitter.writeLineToOutput,emitter,[" {"]),tokenId=emitter.indenter,JAMScript.call(tokenId.increaseIndent,tokenId,[])):(tokenId=this.statements,tokenId=tokenId.members,tokenId=tokenId.length,JAMScript.call(emitter.setInVarBlock,emitter,[tokenId]));tokenId=JAMScript.call(emitter.setInObjectLiteral,emitter,[!1]);if(startLine=this.statements){startLine=this.statements;var v18420=
TypeScript.TokenID,v18420=v18420.Semicolon;JAMScript.call(emitter.emitJavascriptList,emitter,[startLine,null,v18420,!0,!1,!1])}if(startLine=this.isStatementBlock)startLine=emitter.indenter,JAMScript.call(startLine.decreaseIndent,startLine,[]),JAMScript.call(emitter.emitIndent,emitter,[]),JAMScript.call(emitter.writeToOutput,emitter,["}"]);JAMScript.call(emitter.setInObjectLiteral,emitter,[tokenId]);JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);JAMScript.call(emitter.emitParensAndCommentsInPlace,
emitter,[this,!1])}function Block(statements,isStatementBlock){var v18421=TypeScript.NodeType,v18421=v18421.Block;JAMScript.call(_super.call,_super,[this,v18421]);this.statements=statements;this.isStatementBlock=isStatementBlock}JAMScript.call(__extends,null,[Block,_super]);var v11508=Block.prototype;v11508.emit=v238;v11508=Block.prototype;v11508.addToControlFlow=v239;v11508=Block.prototype;v11508.typeCheck=v240;return Block}function v237(_super){function v236(context){var beforeBB=context.current,
v11511=TypeScript.BasicBlock,v11511=JAMScript.new(v11511,[]);context.current=v11511;JAMScript.call(beforeBB.addSuccessor,beforeBB,[v11511])}function v235(typeFlow){var v11512=this.labels;JAMScript.call(typeFlow.typeCheck,typeFlow,[v11512]);v11512=this.stmt;this.stmt=typeFlow=JAMScript.call(v11512.typeCheck,v11512,[typeFlow]);return this}function v234(emitter,tokenId,startLine){JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAMScript.call(emitter.recordSourceMappingStart,emitter,
[this]);var v11517=this.labels;if(v11517)for(var v11517=this.labels,v11517=v11517.members,v11517=v11517.length,i=0,v11516=i<v11517;v11516;){v11516=this.labels;v11516=v11516.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v11516=v11516[i];JAMScript.call(v11516.emit,v11516,[emitter,tokenId,startLine]);i+=1;v11516=i<v11517}startLine=this.stmt;JAMScript.call(startLine.emit,startLine,[emitter,tokenId,!0]);JAMScript.call(emitter.recordSourceMappingEnd,emitter,
[this]);JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function LabeledStatement(labels,stmt){var v18424=TypeScript.NodeType,v18424=v18424.LabeledStatement;JAMScript.call(_super.call,_super,[this,v18424]);this.labels=labels;this.stmt=stmt}JAMScript.call(__extends,null,[LabeledStatement,_super]);var v11520=LabeledStatement.prototype;v11520.emit=v234;v11520=LabeledStatement.prototype;v11520.typeCheck=v235;v11520=LabeledStatement.prototype;v11520.addToControlFlow=v236;return LabeledStatement}
function v233(_super){function v232(typeFlow){this.type=typeFlow.voidType;return this}function v231(){return JAMScript.call(this.isLoop,this,[])}function v230(){return!0}function v229(){return!1}function Statement(nodeType){JAMScript.call(_super.call,_super,[this,nodeType]);nodeType=this.flags;var v22653=TypeScript.ASTFlags,v22653=v22653.IsStatement;this.flags=nodeType|v22653}JAMScript.call(__extends,null,[Statement,_super]);var v11523=Statement.prototype;v11523.isLoop=v229;v11523=Statement.prototype;
v11523.isStatementOrExpression=v230;v11523=Statement.prototype;v11523.isCompoundStatement=v231;v11523=Statement.prototype;v11523.typeCheck=v232;return Statement}function v228(_super){function v227(emitter,tokenId,startLine){}function v226(typeFlow){return JAMScript.call(typeFlow.typeCheckInterface,typeFlow,[this])}function InterfaceDeclaration(name,members,extendsList,implementsList){var v18427=TypeScript.NodeType,v18427=v18427.InterfaceDeclaration;JAMScript.call(_super.call,_super,[this,v18427,name,
extendsList,implementsList,members])}JAMScript.call(__extends,null,[InterfaceDeclaration,_super]);var v11528=InterfaceDeclaration.prototype;v11528.typeCheck=v226;v11528=InterfaceDeclaration.prototype;v11528.emit=v227;return InterfaceDeclaration}function v225(_super){function v224(emitter,tokenId,startLine){JAMScript.call(emitter.emitJavascriptClass,emitter,[this])}function v223(typeFlow){return JAMScript.call(typeFlow.typeCheckClass,typeFlow,[this])}function ClassDeclaration(name,members,extendsList,
implementsList){var v18428=TypeScript.NodeType,v18428=v18428.ClassDeclaration;JAMScript.call(_super.call,_super,[this,v18428,name,extendsList,implementsList,members]);this.knownMemberNames={};this.constructorDecl=null;this.constructorNestingLevel=0;this.endingToken=null}JAMScript.call(__extends,null,[ClassDeclaration,_super]);var v11531=ClassDeclaration.prototype;v11531.typeCheck=v223;v11531=ClassDeclaration.prototype;v11531.emit=v224;return ClassDeclaration}function v222(_super){function v221(){var v11533=
this.varFlags,v18429=TypeScript.VarFlags,v18429=v18429.Ambient;return JAMScript.call(TypeScript.hasFlag,TypeScript,[v11533,v18429])}function v220(){var v11535=this.varFlags,v18430=TypeScript.VarFlags,v18430=v18430.Exported;return JAMScript.call(TypeScript.hasFlag,TypeScript,[v11535,v18430])}function TypeDeclaration(nodeType,name,extendsList,implementsList,members){JAMScript.call(_super.call,_super,[this,nodeType,name,members]);this.extendsList=extendsList;this.implementsList=implementsList;nodeType=
TypeScript.VarFlags;this.varFlags=nodeType.None}JAMScript.call(__extends,null,[TypeDeclaration,_super]);var v11538=TypeDeclaration.prototype;v11538.isExported=v220;v11538=TypeDeclaration.prototype;v11538.isAmbient=v221;return TypeDeclaration}function v219(_super){function v218(emitter,tokenId,startLine){tokenId=this.modFlags;startLine=TypeScript.ModuleFlags;startLine=startLine.ShouldEmitModuleDecl;tokenId=JAMScript.call(TypeScript.hasFlag,TypeScript,[tokenId,startLine]);if(tokenId=!tokenId)JAMScript.call(emitter.emitParensAndCommentsInPlace,
emitter,[this,!0]),JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]),JAMScript.call(emitter.emitJavascriptModule,emitter,[this]),JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]),JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v217(typeFlow){return JAMScript.call(typeFlow.typeCheckModule,typeFlow,[this])}function v216(){var v18432=this.modFlags,v24728=TypeScript.ModuleFlags,v24728=v24728.ShouldEmitModuleDecl,v24728=~v24728;this.modFlags=v18432&
v24728}function v215(){var v11541=this.modFlags,v18434=TypeScript.ModuleFlags,v18434=v18434.IsEnum;return JAMScript.call(TypeScript.hasFlag,TypeScript,[v11541,v18434])}function v214(){var v11543=this.modFlags,v18435=TypeScript.ModuleFlags,v18435=v18435.Ambient;return JAMScript.call(TypeScript.hasFlag,TypeScript,[v11543,v18435])}function v213(){var v11545=this.modFlags,v18436=TypeScript.ModuleFlags,v18436=v18436.Exported;return JAMScript.call(TypeScript.hasFlag,TypeScript,[v11545,v18436])}function ModuleDeclaration(name,
members,vars,scopes,endingToken){var v18437=TypeScript.NodeType,v18437=v18437.ModuleDeclaration;JAMScript.call(_super.call,_super,[this,v18437,name,members]);this.endingToken=endingToken;name=TypeScript.ModuleFlags;this.modFlags=name.ShouldEmitModuleDecl;this.amdDependencies=[];this.containsUnicodeCharInComment=this.containsUnicodeChar=!1;this.vars=vars;this.scopes=scopes;vars=this.name;this.prettyName=vars.actualText}JAMScript.call(__extends,null,[ModuleDeclaration,_super]);var v11550=ModuleDeclaration.prototype;
v11550.isExported=v213;v11550=ModuleDeclaration.prototype;v11550.isAmbient=v214;v11550=ModuleDeclaration.prototype;v11550.isEnum=v215;v11550=ModuleDeclaration.prototype;v11550.recordNonInterface=v216;v11550=ModuleDeclaration.prototype;v11550.typeCheck=v217;v11550=ModuleDeclaration.prototype;v11550.emit=v218;return ModuleDeclaration}function v212(_super){function v211(){return!0}function NamedDeclaration(nodeType,name,members){JAMScript.call(_super.call,_super,[this,nodeType]);this.name=name;this.members=
members;this.rightCurlyCount=this.leftCurlyCount=0}JAMScript.call(__extends,null,[NamedDeclaration,_super]);var v11556=NamedDeclaration.prototype;v11556.isDeclaration=v211;return NamedDeclaration}function v210(_super){function v209(symbol){for(var i=0,v22657=this.externallyVisibleImportedSymbols,v22657=v22657.length,v22657=i<v22657;v22657;){v22657=this.externallyVisibleImportedSymbols;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v22657=v22657[i];if(v22657=v22657==
symbol)return!0;i+=1;v22657=this.externallyVisibleImportedSymbols;v22657=v22657.length;v22657=i<v22657}return!1}function v208(symbol,checker){var v11559=JAMScript.call(this.isExternallyVisibleSymbol,this,[symbol]);if(!v11559){v11559=JAMScript.call(symbol.getType,symbol,[]);v11559=v11559.symbol;v11559=JAMScript.call(v11559.isExternallyVisible,v11559,[checker]);if(v11559=!v11559){var v11559="",v18442=JAMScript.call(symbol.getType,symbol,[]),v18442=v18442.symbol,v18442=v18442.prettyName,v18443=JAMScript.call(TypeScript.isQuoted,
TypeScript,[v18442]);(v18443=!v18443)&&(v11559="'");var v18443=checker.errorReporter,v11563=symbol.declAST,v22661="Externally visible import statement uses non exported module "+v11559,v18442=v22661+v18442,v11559=v18442+v11559;JAMScript.call(v18443.simpleError,v18443,[v11563,v11559])}v11559=this.externallyVisibleImportedSymbols;JAMScript.call(v11559.push,v11559,[symbol])}}function v207(emitter,tokenId,startLine){tokenId=emitter.emitOptions;if(tokenId=JAMScript.call(this.emitRequired,this,[tokenId])){tokenId=
this.bod;JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[tokenId,!0]);tokenId=this.bod;startLine=TypeScript.TokenID;startLine=startLine.Semicolon;var v11570=this.requiresExtendsBlock;JAMScript.call(emitter.emitJavascriptList,emitter,[tokenId,null,startLine,!0,!1,!1,!0,v11570]);tokenId=this.bod;JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[tokenId,!1])}}function v206(emitOptions){var v18447=this.cachedEmitRequired;if(v18447=void 0!=v18447)return this.cachedEmitRequired;
v18447=this.isDeclareFile;if(v18447=!v18447)if(v18447=this.isResident,v18447=!v18447)v18447=this.bod;if(v18447){for(var v18447=0,v18449=this.bod,v18449=v18449.members,v18449=v18449.length,v11585=v18447<v18449;v11585;){v11585=this.bod;v11585=v11585.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v11585=v11585[v18447];var v18451=v11585.nodeType,v22664=TypeScript.NodeType,v22664=v22664.ModuleDeclaration;if(v18451=v18451==v22664)v11585=v11585.modFlags,v18451=
TypeScript.ModuleFlags,v18451=v18451.ShouldEmitModuleDecl,v22664=TypeScript.ModuleFlags,v22664=v22664.Ambient,v18451|=v22664,v11585=JAMScript.call(TypeScript.hasFlag,TypeScript,[v11585,v18451]),v11585=!v11585;else if(v18451=v11585.nodeType,v22664=TypeScript.NodeType,v22664=v22664.ClassDeclaration,v18451=v18451==v22664)v11585=v11585.varFlags,v18451=TypeScript.VarFlags,v18451=v18451.Ambient,v11585=JAMScript.call(TypeScript.hasFlag,TypeScript,[v11585,v18451]),v11585=!v11585;else if(v18451=v11585.nodeType,
v22664=TypeScript.NodeType,v22664=v22664.VarDecl,v18451=v18451==v22664)v11585=v11585.varFlags,v18451=TypeScript.VarFlags,v18451=v18451.Ambient,v11585=JAMScript.call(TypeScript.hasFlag,TypeScript,[v11585,v18451]),v11585=!v11585;else if(v18451=v11585.nodeType,v22664=TypeScript.NodeType,v22664=v22664.FuncDecl,v18451=v18451==v22664)v11585=JAMScript.call(v11585.isSignature,v11585,[]),v11585=!v11585;else{v18451=v11585.nodeType;v22664=TypeScript.NodeType;v22664=v22664.InterfaceDeclaration;if(v18451=v18451!=
v22664)v11585=v11585.nodeType,v18451=TypeScript.NodeType,v18451=v18451.Empty,v18451=v11585!=v18451;v11585=v18451}if(v11585)return JAMScript.call(this.setCachedEmitRequired,this,[!0]);v18447+=1;v11585=v18447<v18449}if(emitOptions=emitOptions.emitComments){emitOptions=this.bod;if(emitOptions=emitOptions.preComments)emitOptions=this.bod,emitOptions=emitOptions.preComments,emitOptions=emitOptions.length,emitOptions=0<emitOptions;if(v18447=!emitOptions)if(emitOptions=this.bod,emitOptions=emitOptions.postComments)emitOptions=
this.bod,emitOptions=emitOptions.postComments,emitOptions=emitOptions.length,emitOptions=0<emitOptions}if(emitOptions)return JAMScript.call(this.setCachedEmitRequired,this,[!0])}return JAMScript.call(this.setCachedEmitRequired,this,[!1])}function v205(){return"Script"}function v204(typeFlow){return JAMScript.call(typeFlow.typeCheckScript,typeFlow,[this])}function v203(value){return this.cachedEmitRequired=value}function Script(vars,scopes){var v11588=JAMScript.new(Identifier,["script"]),v18465=TypeScript.NodeType,
v18465=v18465.Script;JAMScript.call(_super.call,_super,[this,v11588,null,!1,null,vars,scopes,null,v18465]);this.locationInfo=null;this.referencedFiles=[];this.hasBeenTypeChecked=this.isDeclareFile=this.isResident=this.requiresExtendsBlock=this.requiresGlobal=!1;this.topLevelMod=null;this.rightCurlyCount=this.leftCurlyCount=0;this.containsUnicodeCharInComment=this.containsUnicodeChar=!1;this.externallyVisibleImportedSymbols=[];this.vars=vars;this.scopes=scopes}JAMScript.call(__extends,null,[Script,
_super]);var v11590=Script.prototype;v11590.setCachedEmitRequired=v203;v11590=Script.prototype;v11590.typeCheck=v204;v11590=Script.prototype;v11590.treeViewLabel=v205;v11590=Script.prototype;v11590.emitRequired=v206;v11590=Script.prototype;v11590.emit=v207;v11590=Script.prototype;v11590.AddExternallyVisibleImportedSymbol=v208;v11590=Script.prototype;v11590.isExternallyVisibleSymbol=v209;return Script}function v202(){function LocationInfo(filename,lineMap,unitIndex){this.filename=filename;this.lineMap=
lineMap;this.unitIndex=unitIndex}return LocationInfo}function v201(_super){function v200(){var v18466=this.fncFlags,v22679=TypeScript.FncFlags,v22679=v22679.Signature,v18466=v18466&v22679,v22679=TypeScript.FncFlags,v22679=v22679.None;return v18466!=v22679}function v199(){var v11599=TypeScript.FncFlags;this.fncFlags=v11599.None}function v198(){var v18469=this.name;if(v18469=null==v18469)return"funcExpr";v18469=this.name;v18469=v18469.actualText;return"func: "+v18469}function v197(){var v11602=this.fncFlags,
v18471=TypeScript.FncFlags,v18471=v18471.Static;return JAMScript.call(TypeScript.hasFlag,TypeScript,[v11602,v18471])}function v196(){var v11604=this.fncFlags,v18472=TypeScript.FncFlags,v18472=v18472.Public;return JAMScript.call(TypeScript.hasFlag,TypeScript,[v11604,v18472])}function v195(){var v11606=this.fncFlags,v18473=TypeScript.FncFlags,v18473=v18473.Private;return JAMScript.call(TypeScript.hasFlag,TypeScript,[v11606,v18473])}function v194(){var v11608=this.fncFlags,v18474=TypeScript.FncFlags,
v18474=v18474.Exported;return JAMScript.call(TypeScript.hasFlag,TypeScript,[v11608,v18474])}function v193(){var v11610=this.fncFlags,v18475=TypeScript.FncFlags,v18475=v18475.Ambient;return JAMScript.call(TypeScript.hasFlag,TypeScript,[v11610,v18475])}function v192(){var v11612=this.fncFlags,v18476=TypeScript.FncFlags,v18476=v18476.SetAccessor;return JAMScript.call(TypeScript.hasFlag,TypeScript,[v11612,v18476])}function v191(){var v11614=this.fncFlags,v18477=TypeScript.FncFlags,v18477=v18477.GetAccessor;
return JAMScript.call(TypeScript.hasFlag,TypeScript,[v11614,v18477])}function v190(){var v18478=this.fncFlags,v22680=TypeScript.FncFlags,v22680=v22680.GetAccessor,v18478=JAMScript.call(TypeScript.hasFlag,TypeScript,[v18478,v22680]);if(v22680=!v18478)v18478=this.fncFlags,v22680=TypeScript.FncFlags,v22680=v22680.SetAccessor,v18478=JAMScript.call(TypeScript.hasFlag,TypeScript,[v18478,v22680]);return v18478}function v189(){var v11617=this.name;return null===v11617}function v188(){var v11618=JAMScript.call(this.isCallMember,
this,[]),v18484=!v11618;v18484&&(v11618=JAMScript.call(this.isIndexerMember,this,[]),(v18484=!v11618)&&(v11618=JAMScript.call(this.isConstructMember,this,[])));return v11618}function v187(){var v11619=this.fncFlags,v18485=TypeScript.FncFlags,v18485=v18485.IndexerMember;return JAMScript.call(TypeScript.hasFlag,TypeScript,[v11619,v18485])}function v186(){var v11621=this.fncFlags,v18486=TypeScript.FncFlags,v18486=v18486.ConstructMember;return JAMScript.call(TypeScript.hasFlag,TypeScript,[v11621,v18486])}
function v185(){var v11623=this.fncFlags,v18487=TypeScript.FncFlags,v18487=v18487.CallMember;return JAMScript.call(TypeScript.hasFlag,TypeScript,[v11623,v18487])}function v184(){var v18488=this.fncFlags,v22683=TypeScript.FncFlags,v22683=v22683.Method,v18488=v18488&v22683,v22683=TypeScript.FncFlags,v22683=v22683.None;return v18488!=v22683}function v183(){var v11628=this.name;return v11628?(v11628=this.name,v11628.actualText):this.hint}function v182(emitter,tokenId,startLine){JAMScript.call(emitter.emitJavascriptFunction,
emitter,[this])}function v181(typeFlow){return JAMScript.call(typeFlow.typeCheckFunction,typeFlow,[this])}function v180(){function controlFlowPrefix(ast,parent,walker){parent=walker.state;JAMScript.call(ast.addToControlFlow,ast,[parent]);return ast}var v11630=TypeScript.BasicBlock,v11630=JAMScript.new(v11630,[]),v11631=TypeScript.BasicBlock,v11631=JAMScript.new(v11631,[]),v11632=TypeScript.ControlFlowContext,v11630=JAMScript.new(v11632,[v11630,v11631]),v11631=JAMScript.call(TypeScript.getAstWalkerFactory,
TypeScript,[]),v11631=JAMScript.call(v11631.getWalker,v11631,[controlFlowPrefix,null,null,v11630]);v11630.walker=v11631;v11632=this.bod;JAMScript.call(v11631.walk,v11631,[v11632,this]);return v11630}function v179(sym){var v18491=this.jumpRefs;if(v18491=null==v18491)this.jumpRefs=v18491=[];var v18491=sym.name,v18491=JAMScript.new(Identifier,[v18491]),v11637=this.jumpRefs,v18492=this.jumpRefs,v18492=v18492.length;JAMScript.set(v11637,v18492,v18491);v18491.sym=sym;sym=v18491;v18491=JAMScript.call(this.addCloRef,
this,[v18491,null]);sym.cloId=v18491}function v178(id,sym){var v18493=this.envids;if(v18493=null==v18493)this.envids=v18493=[];var v18494=v18493=this.envids,v18494=v18494.length;JAMScript.set(v18493,v18494,id);v18493=this.enclosingFnc;if(sym){if(v18494=v18493)var v18494=v18493.type,v18494=v18494.symbol,v22685=sym.container,v18494=v18494!=v22685;for(;v18494;)if(JAMScript.call(v18493.addJumpRef,v18493,[sym]),v18494=v18493=v18493.enclosingFnc)v18494=v18493.type,v18494=v18494.symbol,v22685=sym.container,
v18494=v18494!=v22685}v18493=this.envids;v18493=v18493.length;return v18493-1}function v177(){var v18498=this.fncFlags,v22688=TypeScript.FncFlags,v22688=v22688.HasSuperReferenceInFatArrowFunction;this.fncFlags=v18498|v22688}function v176(){var v11645=this.fncFlags,v18500=TypeScript.FncFlags,v18500=v18500.HasSuperReferenceInFatArrowFunction;return JAMScript.call(TypeScript.hasFlag,TypeScript,[v11645,v18500])}function v175(){var v18501=this.fncFlags,v22689=TypeScript.FncFlags,v22689=v22689.HasSelfReference;
this.fncFlags=v18501|v22689}function v174(){var v11647=this.fncFlags,v18503=TypeScript.FncFlags,v18503=v18503.HasSelfReference;return JAMScript.call(TypeScript.hasFlag,TypeScript,[v11647,v18503])}function v173(){var v18504=this.internalNameCache;if(v18504=null==v18504)v18504=JAMScript.call(this.getNameText,this,[]),v18504||(v18504=internalId,internalId+=1),this.internalNameCache="_internal_"+v18504;return this.internalNameCache}function v172(){return!0}function FuncDecl(name,bod,isConstructor,args,
vars,scopes,statics,nodeType){JAMScript.call(_super.call,_super,[this,nodeType]);this.name=name;this.bod=bod;this.isConstructor=isConstructor;this.arguments=args;this.vars=vars;this.scopes=scopes;this.statics=statics;this.hint=null;name=TypeScript.FncFlags;this.fncFlags=name.None;this.returnTypeAnnotation=null;this.variableArgList=!1;this.internalNameCache=this.jumpRefs=null;this.tmp1Declared=!1;this.enclosingFnc=null;this.freeVariables=[];this.unitIndex=-1;this.boundToProperty=this.classDecl=null;
this.isOverload=!1;this.innerStaticFuncs=[];this.isInlineCallLiteral=this.isTargetTypedAsMethod=!1;this.accessorSymbol=null;this.rightCurlyCount=this.leftCurlyCount=0;this.returnStatementsWithExpressions=[];this.endingToken=this.scopeType=null}JAMScript.call(__extends,null,[FuncDecl,_super]);var v11652=FuncDecl.prototype;v11652.isDeclaration=v172;v11652=FuncDecl.prototype;v11652.internalName=v173;v11652=FuncDecl.prototype;v11652.hasSelfReference=v174;v11652=FuncDecl.prototype;v11652.setHasSelfReference=
v175;v11652=FuncDecl.prototype;v11652.hasSuperReferenceInFatArrowFunction=v176;v11652=FuncDecl.prototype;v11652.setHasSuperReferenceInFatArrowFunction=v177;v11652=FuncDecl.prototype;v11652.addCloRef=v178;v11652=FuncDecl.prototype;v11652.addJumpRef=v179;v11652=FuncDecl.prototype;v11652.buildControlFlow=v180;v11652=FuncDecl.prototype;v11652.typeCheck=v181;v11652=FuncDecl.prototype;v11652.emit=v182;v11652=FuncDecl.prototype;v11652.getNameText=v183;v11652=FuncDecl.prototype;v11652.isMethod=v184;v11652=
FuncDecl.prototype;v11652.isCallMember=v185;v11652=FuncDecl.prototype;v11652.isConstructMember=v186;v11652=FuncDecl.prototype;v11652.isIndexerMember=v187;v11652=FuncDecl.prototype;v11652.isSpecialFn=v188;v11652=FuncDecl.prototype;v11652.isAnonymousFn=v189;v11652=FuncDecl.prototype;v11652.isAccessor=v190;v11652=FuncDecl.prototype;v11652.isGetAccessor=v191;v11652=FuncDecl.prototype;v11652.isSetAccessor=v192;v11652=FuncDecl.prototype;v11652.isAmbient=v193;v11652=FuncDecl.prototype;v11652.isExported=
v194;v11652=FuncDecl.prototype;v11652.isPrivate=v195;v11652=FuncDecl.prototype;v11652.isPublic=v196;v11652=FuncDecl.prototype;v11652.isStatic=v197;v11652=FuncDecl.prototype;v11652.treeViewLabel=v198;v11652=FuncDecl.prototype;v11652.ClearFlags=v199;v11652=FuncDecl.prototype;v11652.isSignature=v200;return FuncDecl}function v171(_super){function v170(emitter,tokenId,startLine){JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAMScript.call(emitter.recordSourceMappingStart,emitter,
[this]);tokenId=this.id;tokenId=tokenId.actualText;JAMScript.call(emitter.writeToOutput,emitter,[tokenId]);JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v169(){var v18506=this.id,v18506=v18506.actualText;return"arg: "+v18506}function v168(){var v11683=this.isOptional,v18507=!v11683;v18507&&(v11683=this.init);return v11683}function ArgDecl(id){var v18508=TypeScript.NodeType,v18508=v18508.ArgDecl;JAMScript.call(_super.call,
_super,[this,id,v18508,0]);this.isOptional=!1;this.parameterPropertySym=null}JAMScript.call(__extends,null,[ArgDecl,_super]);var v11685=ArgDecl.prototype;v11685.isOptionalArg=v168;v11685=ArgDecl.prototype;v11685.treeViewLabel=v169;v11685=ArgDecl.prototype;v11685.emit=v170;return ArgDecl}function v167(_super){function v166(){var v18509=this.id,v18509=v18509.actualText;return"var "+v18509}function v165(emitter,tokenId,startLine){JAMScript.call(emitter.emitJavascriptVarDecl,emitter,[this,tokenId])}function v164(){var v11689=
this.varFlags,v18510=TypeScript.VarFlags,v18510=v18510.Static;return JAMScript.call(TypeScript.hasFlag,TypeScript,[v11689,v18510])}function v163(){var v11691=this.varFlags,v18511=TypeScript.VarFlags,v18511=v18511.Exported;return JAMScript.call(TypeScript.hasFlag,TypeScript,[v11691,v18511])}function v162(){var v11693=this.varFlags,v18512=TypeScript.VarFlags,v18512=v18512.Ambient;return JAMScript.call(TypeScript.hasFlag,TypeScript,[v11693,v18512])}function VarDecl(id,nest){var v18513=TypeScript.NodeType,
v18513=v18513.VarDecl;JAMScript.call(_super.call,_super,[this,id,v18513,nest])}JAMScript.call(__extends,null,[VarDecl,_super]);var v11696=VarDecl.prototype;v11696.isAmbient=v162;v11696=VarDecl.prototype;v11696.isExported=v163;v11696=VarDecl.prototype;v11696.isStatic=v164;v11696=VarDecl.prototype;v11696.emit=v165;v11696=VarDecl.prototype;v11696.treeViewLabel=v166;return VarDecl}function v161(_super){function v160(){return JAMScript.call(this.treeViewLabel,this,[])}function v159(typeFlow){return JAMScript.call(typeFlow.typeCheckBoundDecl,
typeFlow,[this])}function v158(){var v11701=this.varFlags,v18514=TypeScript.VarFlags,v18514=v18514.Property;return JAMScript.call(TypeScript.hasFlag,TypeScript,[v11701,v18514])}function v157(){var v11703=this.varFlags,v18515=TypeScript.VarFlags,v18515=v18515.Public;return JAMScript.call(TypeScript.hasFlag,TypeScript,[v11703,v18515])}function v156(){var v11705=this.varFlags,v18516=TypeScript.VarFlags,v18516=v18516.Private;return JAMScript.call(TypeScript.hasFlag,TypeScript,[v11705,v18516])}function v155(){return!0}
function v154(){return!0}function BoundDecl(id,nodeType,nestingLevel){JAMScript.call(_super.call,_super,[this,nodeType]);this.id=id;this.nestingLevel=nestingLevel;this.typeExpr=this.init=null;id=TypeScript.VarFlags;this.varFlags=id.None;this.sym=null}JAMScript.call(__extends,null,[BoundDecl,_super]);var v11708=BoundDecl.prototype;v11708.isDeclaration=v154;v11708=BoundDecl.prototype;v11708.isStatementOrExpression=v155;v11708=BoundDecl.prototype;v11708.isPrivate=v156;v11708=BoundDecl.prototype;v11708.isPublic=
v157;v11708=BoundDecl.prototype;v11708.isProperty=v158;v11708=BoundDecl.prototype;v11708.typeCheck=v159;v11708=BoundDecl.prototype;v11708.printLabel=v160;return BoundDecl}function v153(_super){function v152(){var v22690=this.alias,v22690=v22690.nodeType,v22691=TypeScript.NodeType,v22691=v22691.Name;if(v22690=v22690==v22691)return v22690=this.alias,v22690.actualText;v22690=this.alias;v22690=v22690.operand1;return v22690.actualText}function v151(aliasAST){var v18519=typeof aliasAST;if(v18519="undefined"===
v18519)aliasAST=this.alias;var v18519=aliasAST.nodeType,v22692=TypeScript.NodeType,v22692=v22692.Name;if(v18519=v18519==v22692)return aliasAST.actualText;v18519=aliasAST.operand1;v18519=JAMScript.call(this.getAliasName,this,[v18519]);v18519+=".";aliasAST=aliasAST.operand2;aliasAST=JAMScript.call(this.getAliasName,this,[aliasAST]);return v18519+aliasAST}function v150(typeFlow){return JAMScript.call(typeFlow.typeCheckImportDecl,typeFlow,[this])}function v149(emitter,tokenId,startLine){tokenId=this.isDynamicImport;
tokenId=!tokenId;if(startLine=!tokenId)if(tokenId=this.id,tokenId=tokenId.sym)tokenId=this.id,tokenId=tokenId.sym,tokenId=tokenId.onlyReferencedAsTypeRef,tokenId=!tokenId;if(tokenId){tokenId=emitter.modAliasId;startLine=emitter.firstModAlias;JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);var v24744=this.id,v24744=v24744.actualText,v24744="var "+v24744,v24744=v24744+" = ";JAMScript.call(emitter.writeToOutput,emitter,
[v24744]);v24744=this.id;emitter.modAliasId=v24744.actualText;var v24744=emitter,v27429=JAMScript.call(this.firstAliasedModToString,this,[]);v24744.firstModAlias=v27429;v24744=this.alias;v27429=TypeScript.TokenID;v27429=v27429.Tilde;JAMScript.call(emitter.emitJavascript,emitter,[v24744,v27429,!1]);v24744=this.isDynamicImport;(v24744=!v24744)&&JAMScript.call(emitter.writeToOutput,emitter,[";"]);JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1]);JAMScript.call(emitter.recordSourceMappingEnd,
emitter,[this]);emitter.modAliasId=tokenId;emitter.firstModAlias=startLine}}function v148(){return!0}function v147(){return!0}function ImportDeclaration(id,alias){var v18528=TypeScript.NodeType,v18528=v18528.ImportDeclaration;JAMScript.call(_super.call,_super,[this,v18528]);this.id=id;this.alias=alias;v18528=TypeScript.VarFlags;this.varFlags=v18528.None;this.isDynamicImport=!1}JAMScript.call(__extends,null,[ImportDeclaration,_super]);var v11731=ImportDeclaration.prototype;v11731.isStatementOrExpression=
v147;v11731=ImportDeclaration.prototype;v11731.isDeclaration=v148;v11731=ImportDeclaration.prototype;v11731.emit=v149;v11731=ImportDeclaration.prototype;v11731.typeCheck=v150;v11731=ImportDeclaration.prototype;v11731.getAliasName=v151;v11731=ImportDeclaration.prototype;v11731.firstAliasedModToString=v152;return ImportDeclaration}function v146(_super){function ModuleElement(nodeType){JAMScript.call(_super.call,_super,[this,nodeType])}JAMScript.call(__extends,null,[ModuleElement,_super]);return ModuleElement}
function v145(_super){function v144(){return this.text}function v143(){var v11737=this.text;return"st: "+v11737}function v142(typeFlow){this.type=typeFlow.stringType;return this}function v141(emitter,tokenId,startLine){JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);tokenId=this.text;JAMScript.call(emitter.emitStringLiteral,emitter,[tokenId]);JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);JAMScript.call(emitter.emitParensAndCommentsInPlace,
emitter,[this,!1])}function StringLiteral(text){var v18529=TypeScript.NodeType,v18529=v18529.QString;JAMScript.call(_super.call,_super,[this,v18529]);this.text=text}JAMScript.call(__extends,null,[StringLiteral,_super]);var v11740=StringLiteral.prototype;v11740.emit=v141;v11740=StringLiteral.prototype;v11740.typeCheck=v142;v11740=StringLiteral.prototype;v11740.treeViewLabel=v143;v11740=StringLiteral.prototype;v11740.printLabel=v144;return StringLiteral}function v140(_super){function v139(emitter,tokenId,
startLine){JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);tokenId=this.regex;tokenId=JAMScript.call(tokenId.toString,tokenId,[]);JAMScript.call(emitter.writeToOutput,emitter,[tokenId]);JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v138(typeFlow){this.type=typeFlow.regexType;return this}function RegexLiteral(regex){var v18531=
TypeScript.NodeType,v18531=v18531.Regex;JAMScript.call(_super.call,_super,[this,v18531]);this.regex=regex}JAMScript.call(__extends,null,[RegexLiteral,_super]);var v11746=RegexLiteral.prototype;v11746.typeCheck=v138;v11746=RegexLiteral.prototype;v11746.emit=v139;return RegexLiteral}function v137(_super){function v136(){var v22698=this.value,v22698=Math.floor(v22698),v18533=this.value;if(v22698=v22698!=v18533)return v22698=this.value,v22698=v22698.toFixed(2),JAMScript.call(v22698.toString,v22698,[]);
if(v22698=this.hasEmptyFraction)return v22698=this.value,v22698=JAMScript.call(v22698.toString,v22698,[]),v22698+".0";v22698=this.value;return JAMScript.call(v22698.toString,v22698,[])}function v135(emitter,tokenId,startLine){JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);(tokenId=this.isNegativeZero)&&JAMScript.call(emitter.writeToOutput,emitter,["-"]);tokenId=this.value;tokenId=JAMScript.call(tokenId.toString,
tokenId,[]);JAMScript.call(emitter.writeToOutput,emitter,[tokenId]);(tokenId=this.hasEmptyFraction)&&JAMScript.call(emitter.writeToOutput,emitter,[".0"]);JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v134(){var v11756=JAMScript.call(this.printLabel,this,[]);return"num: "+v11756}function v133(typeFlow){this.type=typeFlow.doubleType;return this}function NumberLiteral(value,hasEmptyFraction){var v18537=TypeScript.NodeType,
v18537=v18537.NumberLit;JAMScript.call(_super.call,_super,[this,v18537]);this.value=value;this.hasEmptyFraction=hasEmptyFraction;this.isNegativeZero=!1}JAMScript.call(__extends,null,[NumberLiteral,_super]);var v11758=NumberLiteral.prototype;v11758.typeCheck=v133;v11758=NumberLiteral.prototype;v11758.treeViewLabel=v134;v11758=NumberLiteral.prototype;v11758.emit=v135;v11758=NumberLiteral.prototype;v11758.printLabel=v136;return NumberLiteral}function v132(_super){function v131(emitter,tokenId,startLine){JAMScript.call(emitter.emitParensAndCommentsInPlace,
emitter,[this,!0]);JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);tokenId=this.operand1;startLine=TypeScript.TokenID;startLine=startLine.Question;JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,!1]);JAMScript.call(emitter.writeToOutput,emitter,[" ? "]);tokenId=this.operand2;startLine=TypeScript.TokenID;startLine=startLine.Question;JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,!1]);JAMScript.call(emitter.writeToOutput,emitter,[" : "]);tokenId=this.operand3;
startLine=TypeScript.TokenID;startLine=startLine.Question;JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,!1]);JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v130(typeFlow){return JAMScript.call(typeFlow.typeCheckQMark,typeFlow,[this])}function ConditionalExpression(operand1,operand2,operand3){var v18541=TypeScript.NodeType,v18541=v18541.ConditionalExpression;JAMScript.call(_super.call,
_super,[this,v18541]);this.operand1=operand1;this.operand2=operand2;this.operand3=operand3}JAMScript.call(__extends,null,[ConditionalExpression,_super]);var v11769=ConditionalExpression.prototype;v11769.typeCheck=v130;v11769=ConditionalExpression.prototype;v11769.emit=v131;return ConditionalExpression}function v129(_super){function v128(emitter,tokenId,startLine){tokenId=TypeScript.nodeTypeToTokTable;startLine=this.nodeType;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)tokenId=
tokenId[startLine];JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);if(startLine=void 0!=tokenId){startLine=this.operand1;JAMScript.call(emitter.emitJavascript,emitter,[startLine,tokenId,!1]);startLine=TypeScript.tokenTable;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)startLine=startLine[tokenId];startLine=startLine.text;if(startLine="instanceof"==startLine)JAMScript.call(emitter.writeToOutput,
emitter,[" instanceof "]);else{startLine=TypeScript.tokenTable;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)startLine=startLine[tokenId];startLine=startLine.text;if(startLine="in"==startLine)JAMScript.call(emitter.writeToOutput,emitter,[" in "]);else{startLine=TypeScript.tokenTable;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)startLine=startLine[tokenId];startLine=startLine.text;startLine=" "+startLine;startLine+=" ";JAMScript.call(emitter.writeToOutputTrimmable,
emitter,[startLine])}}startLine=this.operand2;JAMScript.call(emitter.emitJavascript,emitter,[startLine,tokenId,!1])}else switch(tokenId=this.nodeType,tokenId){case TypeScript.NodeType.Dot:tokenId=JAMScript.call(emitter.tryEmitConstant,emitter,[this]);if(tokenId=!tokenId)tokenId=this.operand1,startLine=TypeScript.TokenID,startLine=startLine.Dot,JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,!1]),JAMScript.call(emitter.writeToOutput,emitter,["."]),tokenId=this.operand2,JAMScript.call(emitter.emitJavascriptName,
emitter,[tokenId,!1]);break;case TypeScript.NodeType.Index:tokenId=this.operand1;startLine=this.operand2;JAMScript.call(emitter.emitIndex,emitter,[tokenId,startLine]);break;case TypeScript.NodeType.Member:tokenId=this.operand2;tokenId=tokenId.nodeType;startLine=TypeScript.NodeType;startLine=startLine.FuncDecl;if(tokenId=tokenId==startLine)tokenId=this.operand2,tokenId=JAMScript.call(tokenId.isAccessor,tokenId,[]);tokenId?(tokenId=this.operand2,tokenId=tokenId.fncFlags,startLine=TypeScript.FncFlags,
startLine=startLine.GetAccessor,(tokenId=JAMScript.call(TypeScript.hasFlag,TypeScript,[tokenId,startLine]))?JAMScript.call(emitter.writeToOutput,emitter,["get "]):JAMScript.call(emitter.writeToOutput,emitter,["set "]),tokenId=this.operand1,startLine=TypeScript.TokenID,startLine=startLine.Colon,JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,!1])):(tokenId=this.operand1,startLine=TypeScript.TokenID,startLine=startLine.Colon,JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,
!1]),JAMScript.call(emitter.writeToOutputTrimmable,emitter,[": "]));tokenId=this.operand2;startLine=TypeScript.TokenID;startLine=startLine.Comma;JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,!1]);break;case TypeScript.NodeType.Comma:tokenId=this.operand1;startLine=TypeScript.TokenID;startLine=startLine.Comma;JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,!1]);tokenId=emitter.emitState;(tokenId=tokenId.inObjectLiteral)?JAMScript.call(emitter.writeLineToOutput,emitter,
[", "]):JAMScript.call(emitter.writeToOutput,emitter,[","]);tokenId=this.operand2;startLine=TypeScript.TokenID;startLine=startLine.Comma;JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,!1]);break;case TypeScript.NodeType.Is:throw Error("should be de-sugared during type check");default:throw Error("please implement in derived class");}JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v127(typeFlow){var v11811=
this.nodeType;switch(v11811){case TypeScript.NodeType.Dot:return JAMScript.call(typeFlow.typeCheckDotOperator,typeFlow,[this]);case TypeScript.NodeType.Asg:return JAMScript.call(typeFlow.typeCheckAsgOperator,typeFlow,[this]);case TypeScript.NodeType.Add:case TypeScript.NodeType.Sub:case TypeScript.NodeType.Mul:case TypeScript.NodeType.Div:case TypeScript.NodeType.Mod:case TypeScript.NodeType.Or:case TypeScript.NodeType.And:return JAMScript.call(typeFlow.typeCheckArithmeticOperator,typeFlow,[this,
!1]);case TypeScript.NodeType.Xor:return JAMScript.call(typeFlow.typeCheckBitwiseOperator,typeFlow,[this,!1]);case TypeScript.NodeType.Ne:case TypeScript.NodeType.Eq:if(v11811=typeFlow.checker,v11811=v11811.styleSettings,v11811=v11811.eqeqeq){var v11811=TypeScript.nodeTypeTable,v11800=this.nodeType;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v11811=v11811[v11800];v11800=typeFlow.checker;v11800=v11800.errorReporter;v11811="use of "+v11811;JAMScript.call(v11800.styleError,
v11800,[this,v11811])}else if(v11811=typeFlow.checker,v11811=v11811.styleSettings,v11811=v11811.eqnull){v11811=TypeScript.nodeTypeTable;v11800=this.nodeType;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v11811=v11811[v11800];v11800=this.operand2;if(v11800=null!==v11800)var v11800=this.operand2,v11800=v11800.nodeType,v24751=TypeScript.NodeType,v24751=v24751.Null,v11800=v11800==v24751;v11800&&(v11800=typeFlow.checker,v11800=v11800.errorReporter,v11811="use of "+
v11811,v11811+=" to compare with null",JAMScript.call(v11800.styleError,v11800,[this,v11811]))}case TypeScript.NodeType.Eqv:case TypeScript.NodeType.NEqv:case TypeScript.NodeType.Lt:case TypeScript.NodeType.Le:case TypeScript.NodeType.Ge:case TypeScript.NodeType.Gt:return JAMScript.call(typeFlow.typeCheckBooleanOperator,typeFlow,[this]);case TypeScript.NodeType.Index:return JAMScript.call(typeFlow.typeCheckIndex,typeFlow,[this]);case TypeScript.NodeType.Member:this.type=typeFlow.voidType;break;case TypeScript.NodeType.LogOr:return JAMScript.call(typeFlow.typeCheckLogOr,
typeFlow,[this]);case TypeScript.NodeType.LogAnd:return JAMScript.call(typeFlow.typeCheckLogAnd,typeFlow,[this]);case TypeScript.NodeType.AsgAdd:case TypeScript.NodeType.AsgSub:case TypeScript.NodeType.AsgMul:case TypeScript.NodeType.AsgDiv:case TypeScript.NodeType.AsgMod:case TypeScript.NodeType.AsgOr:case TypeScript.NodeType.AsgAnd:return JAMScript.call(typeFlow.typeCheckArithmeticOperator,typeFlow,[this,!0]);case TypeScript.NodeType.AsgXor:return JAMScript.call(typeFlow.typeCheckBitwiseOperator,
typeFlow,[this,!0]);case TypeScript.NodeType.Lsh:case TypeScript.NodeType.Rsh:case TypeScript.NodeType.Rs2:return JAMScript.call(typeFlow.typeCheckShift,typeFlow,[this,!1]);case TypeScript.NodeType.AsgLsh:case TypeScript.NodeType.AsgRsh:case TypeScript.NodeType.AsgRs2:return JAMScript.call(typeFlow.typeCheckShift,typeFlow,[this,!0]);case TypeScript.NodeType.Comma:return JAMScript.call(typeFlow.typeCheckCommaOperator,typeFlow,[this]);case TypeScript.NodeType.InstOf:return JAMScript.call(typeFlow.typeCheckInstOf,
typeFlow,[this]);case TypeScript.NodeType.In:return JAMScript.call(typeFlow.typeCheckInOperator,typeFlow,[this]);case TypeScript.NodeType.From:typeFlow=typeFlow.checker;typeFlow=typeFlow.errorReporter;JAMScript.call(typeFlow.simpleError,typeFlow,[this,"Illegal use of 'from' keyword in binary expression"]);break;default:throw Error("please implement in derived class");}return this}function BinaryExpression(nodeType,operand1,operand2){JAMScript.call(_super.call,_super,[this,nodeType]);this.operand1=
operand1;this.operand2=operand2}JAMScript.call(__extends,null,[BinaryExpression,_super]);var v11812=BinaryExpression.prototype;v11812.typeCheck=v127;v11812=BinaryExpression.prototype;v11812.emit=v128;return BinaryExpression}function v126(_super){function v125(emitter,tokenId,startLine){JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);tokenId=this.nodeType;startLine=TypeScript.NodeType;startLine=startLine.New;(tokenId=
tokenId==startLine)?(tokenId=this.target,startLine=this.arguments,JAMScript.call(emitter.emitNew,emitter,[tokenId,startLine])):(tokenId=this.target,startLine=this.arguments,JAMScript.call(emitter.emitCall,emitter,[this,tokenId,startLine]));JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v124(typeFlow){var v18565=this.nodeType,v22712=TypeScript.NodeType,v22712=v22712.New;return(v18565=v18565==v22712)?JAMScript.call(typeFlow.typeCheckNew,
typeFlow,[this]):JAMScript.call(typeFlow.typeCheckCall,typeFlow,[this])}function CallExpression(nodeType,target,args){JAMScript.call(_super.call,_super,[this,nodeType]);this.target=target;this.arguments=args;this.signature=null;nodeType=this.target;this.minChar=nodeType.minChar}JAMScript.call(__extends,null,[CallExpression,_super]);var v11821=CallExpression.prototype;v11821.typeCheck=v124;v11821=CallExpression.prototype;v11821.emit=v125;return CallExpression}function v123(_super){function v122(emitter,
tokenId,startLine){JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);tokenId=this.nodeType;switch(tokenId){case TypeScript.NodeType.IncPost:tokenId=this.operand;startLine=TypeScript.TokenID;startLine=startLine.PlusPlus;JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,!1]);JAMScript.call(emitter.writeToOutput,emitter,["++"]);break;case TypeScript.NodeType.LogNot:JAMScript.call(emitter.writeToOutput,
emitter,["!"]);tokenId=this.operand;startLine=TypeScript.TokenID;startLine=startLine.Exclamation;JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,!1]);break;case TypeScript.NodeType.DecPost:tokenId=this.operand;startLine=TypeScript.TokenID;startLine=startLine.MinusMinus;JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,!1]);JAMScript.call(emitter.writeToOutput,emitter,["--"]);break;case TypeScript.NodeType.ObjectLit:tokenId=this.operand;JAMScript.call(emitter.emitObjectLiteral,
emitter,[tokenId]);break;case TypeScript.NodeType.ArrayLit:tokenId=this.operand;JAMScript.call(emitter.emitArrayLiteral,emitter,[tokenId]);break;case TypeScript.NodeType.Not:JAMScript.call(emitter.writeToOutput,emitter,["~"]);tokenId=this.operand;startLine=TypeScript.TokenID;startLine=startLine.Tilde;JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,!1]);break;case TypeScript.NodeType.Neg:JAMScript.call(emitter.writeToOutput,emitter,["-"]);tokenId=this.operand;tokenId=tokenId.nodeType;
startLine=TypeScript.NodeType;startLine=startLine.Neg;if(tokenId=tokenId==startLine)tokenId=this.operand,tokenId.isParenthesized=!0;tokenId=this.operand;startLine=TypeScript.TokenID;startLine=startLine.Minus;JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,!1]);break;case TypeScript.NodeType.Pos:JAMScript.call(emitter.writeToOutput,emitter,["+"]);tokenId=this.operand;tokenId=tokenId.nodeType;startLine=TypeScript.NodeType;startLine=startLine.Pos;if(tokenId=tokenId==startLine)tokenId=
this.operand,tokenId.isParenthesized=!0;tokenId=this.operand;startLine=TypeScript.TokenID;startLine=startLine.Plus;JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,!1]);break;case TypeScript.NodeType.IncPre:JAMScript.call(emitter.writeToOutput,emitter,["++"]);tokenId=this.operand;startLine=TypeScript.TokenID;startLine=startLine.PlusPlus;JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,!1]);break;case TypeScript.NodeType.DecPre:JAMScript.call(emitter.writeToOutput,emitter,
["--"]);tokenId=this.operand;startLine=TypeScript.TokenID;startLine=startLine.MinusMinus;JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,!1]);break;case TypeScript.NodeType.Throw:JAMScript.call(emitter.writeToOutput,emitter,["throw "]);tokenId=this.operand;startLine=TypeScript.TokenID;startLine=startLine.Tilde;JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,!1]);JAMScript.call(emitter.writeToOutput,emitter,[";"]);break;case TypeScript.NodeType.Typeof:JAMScript.call(emitter.writeToOutput,
emitter,["typeof "]);tokenId=this.operand;startLine=TypeScript.TokenID;startLine=startLine.Tilde;JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,!1]);break;case TypeScript.NodeType.Delete:JAMScript.call(emitter.writeToOutput,emitter,["delete "]);tokenId=this.operand;startLine=TypeScript.TokenID;startLine=startLine.Tilde;JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,!1]);break;case TypeScript.NodeType.Void:JAMScript.call(emitter.writeToOutput,emitter,["void "]);
tokenId=this.operand;startLine=TypeScript.TokenID;startLine=startLine.Tilde;JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,!1]);break;case TypeScript.NodeType.TypeAssertion:tokenId=this.operand;startLine=TypeScript.TokenID;startLine=startLine.Tilde;JAMScript.call(emitter.emitJavascript,emitter,[tokenId,startLine,!1]);break;default:throw Error("please implement in derived class");}JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);JAMScript.call(emitter.emitParensAndCommentsInPlace,
emitter,[this,!1])}function v121(typeFlow){var v11870=this.nodeType;switch(v11870){case TypeScript.NodeType.Not:return JAMScript.call(typeFlow.typeCheckBitNot,typeFlow,[this]);case TypeScript.NodeType.LogNot:return JAMScript.call(typeFlow.typeCheckLogNot,typeFlow,[this]);case TypeScript.NodeType.Pos:case TypeScript.NodeType.Neg:return JAMScript.call(typeFlow.typeCheckUnaryNumberOperator,typeFlow,[this]);case TypeScript.NodeType.IncPost:case TypeScript.NodeType.IncPre:case TypeScript.NodeType.DecPost:case TypeScript.NodeType.DecPre:return JAMScript.call(typeFlow.typeCheckIncOrDec,
typeFlow,[this]);case TypeScript.NodeType.ArrayLit:JAMScript.call(typeFlow.typeCheckArrayLit,typeFlow,[this]);break;case TypeScript.NodeType.ObjectLit:JAMScript.call(typeFlow.typeCheckObjectLit,typeFlow,[this]);break;case TypeScript.NodeType.Throw:v11870=this.operand;this.operand=v11870=JAMScript.call(typeFlow.typeCheck,typeFlow,[v11870]);this.type=typeFlow.voidType;break;case TypeScript.NodeType.Typeof:v11870=this.operand;this.operand=v11870=JAMScript.call(typeFlow.typeCheck,typeFlow,[v11870]);this.type=
typeFlow.stringType;break;case TypeScript.NodeType.Delete:v11870=this.operand;this.operand=v11870=JAMScript.call(typeFlow.typeCheck,typeFlow,[v11870]);this.type=typeFlow.booleanType;break;case TypeScript.NodeType.TypeAssertion:v11870=this.castTerm;this.castTerm=v11870=JAMScript.call(typeFlow.typeCheck,typeFlow,[v11870]);v11870=this.operand;v11870=v11870.isParenthesized;(v11870=!v11870)?(v11870=this.castTerm,v11870=v11870.type):v11870=null;var v11862=typeFlow.checker,v18586=typeFlow.checker,v18586=
JAMScript.call(v18586.inProvisionalTypecheckMode,v18586,[]),v11864=this.operand;JAMScript.call(v11862.typeCheckWithContextualType,v11862,[v11870,v18586,!0,v11864]);v11870=this.operand;v11862=this.castTerm;v11862=v11862.type;JAMScript.call(typeFlow.castWithCoercion,typeFlow,[v11870,v11862,!1,!0]);typeFlow=this.castTerm;this.type=typeFlow.type;break;case TypeScript.NodeType.Void:v11870=this.operand;this.operand=v11870=JAMScript.call(typeFlow.typeCheck,typeFlow,[v11870]);typeFlow=typeFlow.checker;this.type=
typeFlow.undefinedType;break;default:throw Error("please implement in derived class");}return this}function v120(context){var v18588=_super.prototype,v18588=v18588.addToControlFlow;JAMScript.call(v18588.call,v18588,[this,context]);var v18588=this.nodeType,v22717=TypeScript.NodeType,v22717=v22717.Throw;(v18588=v18588==v22717)&&JAMScript.call(context.returnStmt,context,[])}function UnaryExpression(nodeType,operand){JAMScript.call(_super.call,_super,[this,nodeType]);this.operand=operand;this.castTerm=
this.targetType=null}JAMScript.call(__extends,null,[UnaryExpression,_super]);var v11873=UnaryExpression.prototype;v11873.addToControlFlow=v120;v11873=UnaryExpression.prototype;v11873.typeCheck=v121;v11873=UnaryExpression.prototype;v11873.emit=v122;return UnaryExpression}function v119(_super){function v118(){return!0}function v117(){return!0}function Expression(nodeType){JAMScript.call(_super.call,_super,[this,nodeType])}JAMScript.call(__extends,null,[Expression,_super]);var v11876=Expression.prototype;
v11876.isExpression=v117;v11876=Expression.prototype;v11876.isStatementOrExpression=v118;return Expression}function v116(_super){function v115(emitter,tokenId,startLine){JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);tokenId=this.id;JAMScript.call(emitter.recordSourceMappingStart,emitter,[tokenId]);tokenId=this.id;tokenId=tokenId.actualText;JAMScript.call(emitter.writeToOutput,emitter,[tokenId]);tokenId=this.id;
JAMScript.call(emitter.recordSourceMappingEnd,emitter,[tokenId]);JAMScript.call(emitter.writeLineToOutput,emitter,[":"]);JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v114(typeFlow){this.type=typeFlow.voidType;return this}function v113(){var v18592=this.id,v18592=v18592.actualText;return v18592+":"}function Label(id){var v18593=TypeScript.NodeType,v18593=v18593.Label;JAMScript.call(_super.call,_super,[this,
v18593]);this.id=id}JAMScript.call(__extends,null,[Label,_super]);var v11883=Label.prototype;v11883.printLabel=v113;v11883=Label.prototype;v11883.typeCheck=v114;v11883=Label.prototype;v11883.emit=v115;return Label}function v112(_super){function v111(emitter,tokenId,startLine){}function v110(){return!0}function MissingIdentifier(){JAMScript.call(_super.call,_super,[this,"__missing"])}JAMScript.call(__extends,null,[MissingIdentifier,_super]);var v11886=MissingIdentifier.prototype;v11886.isMissing=v110;
v11886=MissingIdentifier.prototype;v11886.emit=v111;return MissingIdentifier}function v109(_super){function fromToken(token){var v11888=JAMScript.call(token.getText,token,[]);token=token.hasEscapeSequence;return new Identifier(v11888,token)}function v108(emitter,tokenId,startLine){JAMScript.call(emitter.emitJavascriptName,emitter,[this,!0])}function v107(typeFlow){return JAMScript.call(typeFlow.typeCheckName,typeFlow,[this])}function v106(){var v11891=this.actualText;return v11891?(v11891=this.actualText,
"id: "+v11891):"name node"}function v105(){var v11892=this.actualText;return"id: "+v11892}function v104(){return!0}function v103(){return!1}function v102(actualText,hasEscapeSequence){this.actualText=actualText;if(hasEscapeSequence){var v27435=JAMScript.call(AST.getResolvedIdentifierName,AST,[actualText]);this.text=v27435}else this.text=actualText}function Identifier(actualText,hasEscapeSequence){var v18594=TypeScript.NodeType,v18594=v18594.Name;JAMScript.call(_super.call,_super,[this,v18594]);this.actualText=
actualText;this.hasEscapeSequence=hasEscapeSequence;this.sym=null;this.cloId=-1;JAMScript.call(this.setText,this,[actualText,hasEscapeSequence])}JAMScript.call(__extends,null,[Identifier,_super]);var v11894=Identifier.prototype;v11894.setText=v102;v11894=Identifier.prototype;v11894.isMissing=v103;v11894=Identifier.prototype;v11894.isLeaf=v104;v11894=Identifier.prototype;v11894.treeViewLabel=v105;v11894=Identifier.prototype;v11894.printLabel=v106;v11894=Identifier.prototype;v11894.typeCheck=v107;v11894=
Identifier.prototype;v11894.emit=v108;Identifier.fromToken=fromToken;return Identifier}function v101(_super){function v100(typeFlow){var v11901=this.members,v11901=v11901.length,v18595=typeFlow.nestingLevel;typeFlow.nestingLevel=v18595+1;for(var v18595=0,v11905=v18595<v11901;v11905;){v11905=this.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v11905=v11905[v18595];if(v11905){var v11905=this.members,v11903=v18595,v22718=this.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v22718=
v22718[v18595];v22718=JAMScript.call(v22718.typeCheck,v22718,[typeFlow]);v11905[v11903]=v22718}v18595+=1;v11905=v18595<v11901}v11901=typeFlow.nestingLevel;typeFlow.nestingLevel=v11901-1;return this}function v99(emitter,tokenId,startLine){JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);tokenId=TypeScript.TokenID;tokenId=tokenId.Semicolon;JAMScript.call(emitter.emitJavascriptList,emitter,[this,null,tokenId,startLine,!1,!1]);JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this])}
function v98(ast){var v18600=ast.nodeType,v22719=TypeScript.NodeType,v22719=v22719.List;if(v18600=v18600==v22719)for(var v18600=0,v22719=ast.members,v22719=v22719.length,v11909=v18600<v22719;v11909;){v11909=ast.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v11909=v11909[v18600];JAMScript.call(this.append,this,[v11909]);v18600+=1;v11909=v18600<v22719}else JAMScript.call(this.append,this,[ast]);return this}function v97(ast){var v11911=this.members,v18603=
this.members,v18603=v18603.length;JAMScript.set(v11911,v18603,ast);return this}function v96(context){for(var v11913=this.members,len=v11913.length,v11913=0,v11918=v11913<len;v11918;){if(v11918=context.noContinuation){len=this.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v11913=len[v11913];JAMScript.call(context.addUnreachable,context,[v11913]);break}else{var v11918=this.members,v11916=v11913,v22720=this.members;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v22720=
v22720[v11913];v22720=JAMScript.call(context.walk,context,[v22720,this]);v11918[v11916]=v22720}v11913+=1;v11918=v11913<len}context=context.walker;context=context.options;context.goChildren=!1}function ASTList(){var v18607=TypeScript.NodeType,v18607=v18607.List;JAMScript.call(_super.call,_super,[this,v18607]);this.enclosingScope=null;this.members=v18607=[]}JAMScript.call(__extends,null,[ASTList,_super]);var v11921=ASTList.prototype;v11921.addToControlFlow=v96;v11921=ASTList.prototype;v11921.append=
v97;v11921=ASTList.prototype;v11921.appendAll=v98;v11921=ASTList.prototype;v11921.emit=v99;v11921=ASTList.prototype;v11921.typeCheck=v100;return ASTList}function v95(_super){function IncompleteAST(min,lim){var v18608=TypeScript.NodeType,v18608=v18608.Error;JAMScript.call(_super.call,_super,[this,v18608]);this.minChar=min;this.limChar=lim}JAMScript.call(__extends,null,[IncompleteAST,_super]);return IncompleteAST}function v94(_super){function v93(){var v22721=JAMScript.call(this.isDeclaration,this,
[]),v22721=!v22721,v22723=!v22721;v22723&&(v22721=this.preComments,v22721=!v22721,v22723=!v22721)&&(v22721=this.preComments,v22721=v22721.length,v22721=0==v22721);if(v22721)return[];v22721=this.docComments;if(v22721=!v22721){for(var v22721=this.preComments,v22723=v22721.length,v22721=[],v22723=v22723-1,v11933=0<=v22723;v11933;){v11933=this.preComments;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v11933=v11933[v22723];if(v11933=JAMScript.call(v11933.isDocComment,
v11933,[])){v11933=v22721.length;(v11933=0<v11933)?(v11933=v22721.length,v11933-=1,v11933=v22721[v11933]):v11933=null;var v18614=null==v11933,v22728=!v18614;if(v22728){v18614=this.preComments;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v18614=v18614[v22723];v18614=v18614.limLine;v22728=v11933.minLine;v18614=v18614==v22728;if(v22728=!v18614){v18614=this.preComments;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v18614=v18614[v22723];
v18614=v18614.limLine;v18614+=1;v11933=v11933.minLine;v18614=v18614==v11933}}if(v11933=v18614){v11933=this.preComments;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v11933=v11933[v22723];JAMScript.call(v22721.push,v22721,[v11933]);v22723-=1;v11933=0<=v22723;continue}}break}this.docComments=v22721=v22721.reverse()}return this.docComments}function getResolvedIdentifierName(name){var v11935=!name;if(v11935)return"";for(var resolved="",start=0,v11935=0,v22729=name.length,
v22729=v22729-6,v22729=v11935<=v22729;v22729;){v22729=name.charAt(v11935);if(v22729="\\"==v22729)v22729=v11935+1,v22729=name.charAt(v22729),v22729="u"==v22729;if(v22729)var v22729=v11935+2,v22729=name.substr(v22729,4),v22729=parseInt(v22729,16),v22732=v11935-start,start=name.substr(start,v22732),start=resolved+=start,resolved=String.fromCharCode(v22729),resolved=start+resolved,start=v11935+=6;else v11935+=1;v22729=name.length;v22729-=6;v22729=v11935<=v22729}v11935=resolved;name=JAMScript.call(name.substring,
name,[start]);return resolved=v11935+name}function v92(){var v18627=TypeScript.NodeType,v18627=v18627._map,v11940=this.nodeType;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v18627[v11940]}function v91(container,freeUses){}function v90(context){var v18628=context.walker,v18628=v18628.options;v18628.goChildren=!1;JAMScript.call(context.addContent,context,[this])}function v89(){var v22735=TypeScript.nodeTypeTable,v22736=this.nodeType;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v22735=
v22735[v22736];(v22735=void 0!==v22735)?v22735=TypeScript.nodeTypeTable:(v22735=TypeScript.NodeType,v22735=v22735._map);v22736=this.nodeType;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)return v22735[v22736]}function v88(context){JAMScript.call(context.startLine,context,[]);var lineCol={line:-1,col:-1},limLineCol={line:-1,col:-1},v18631=context.parser;if(v18631=null!==v18631){var v18631=context.parser,v11948=this.minChar;JAMScript.call(v18631.getSourceLineCol,
v18631,[lineCol,v11948]);v18631=context.parser;v11948=this.limChar;JAMScript.call(v18631.getSourceLineCol,v18631,[limLineCol,v11948]);v18631=lineCol.line;v18631="("+v18631;v18631+=",";lineCol=lineCol.col;lineCol=v18631+lineCol;lineCol+=")--";lineCol+="(";v18631=limLineCol.line;lineCol+=v18631;lineCol+=",";limLineCol=limLineCol.col;limLineCol=lineCol+limLineCol;limLineCol+="): ";JAMScript.call(context.write,context,[limLineCol])}limLineCol=JAMScript.call(this.printLabel,this,[]);lineCol=this.flags;
v18631=TypeScript.ASTFlags;v18631=v18631.Error;(lineCol=JAMScript.call(TypeScript.hasFlag,TypeScript,[lineCol,v18631]))&&(limLineCol+=" (Error)");JAMScript.call(context.writeLine,context,[limLineCol])}function v87(emitter,tokenId,startLine){JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!0]);tokenId=this.nodeType;switch(tokenId){case TypeScript.NodeType.This:JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);if(tokenId=emitter.thisFnc)tokenId=emitter.thisFnc,tokenId=
tokenId.fncFlags,startLine=TypeScript.FncFlags,startLine=startLine.IsFatArrowFunction,tokenId=JAMScript.call(TypeScript.hasFlag,TypeScript,[tokenId,startLine]);tokenId?JAMScript.call(emitter.writeToOutput,emitter,["_this"]):JAMScript.call(emitter.writeToOutput,emitter,["this"]);JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);break;case TypeScript.NodeType.Null:JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);JAMScript.call(emitter.writeToOutput,emitter,["null"]);JAMScript.call(emitter.recordSourceMappingEnd,
emitter,[this]);break;case TypeScript.NodeType.False:JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);JAMScript.call(emitter.writeToOutput,emitter,["false"]);JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);break;case TypeScript.NodeType.True:JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);JAMScript.call(emitter.writeToOutput,emitter,["true"]);JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);break;case TypeScript.NodeType.Super:JAMScript.call(emitter.recordSourceMappingStart,
emitter,[this]);JAMScript.call(emitter.emitSuperReference,emitter,[]);JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);break;case TypeScript.NodeType.EndCode:case TypeScript.NodeType.Error:case TypeScript.NodeType.EmptyExpr:break;case TypeScript.NodeType.Empty:JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);break;case TypeScript.NodeType.Void:JAMScript.call(emitter.recordSourceMappingStart,emitter,[this]);JAMScript.call(emitter.writeToOutput,
emitter,["void "]);JAMScript.call(emitter.recordSourceMappingEnd,emitter,[this]);break;default:throw Error("please implement in derived class");}JAMScript.call(emitter.emitParensAndCommentsInPlace,emitter,[this,!1])}function v86(typeFlow){var v11956=this.nodeType;switch(v11956){case TypeScript.NodeType.Error:case TypeScript.NodeType.EmptyExpr:this.type=typeFlow.anyType;break;case TypeScript.NodeType.This:return JAMScript.call(typeFlow.typeCheckThis,typeFlow,[this]);case TypeScript.NodeType.Null:this.type=
typeFlow.nullType;break;case TypeScript.NodeType.False:case TypeScript.NodeType.True:this.type=typeFlow.booleanType;break;case TypeScript.NodeType.Super:return JAMScript.call(typeFlow.typeCheckSuper,typeFlow,[this]);case TypeScript.NodeType.EndCode:case TypeScript.NodeType.Empty:case TypeScript.NodeType.Void:this.type=typeFlow.voidType;break;default:throw Error("please implement in derived class");}return this}function v85(){return!1}function v84(){var v11957=JAMScript.call(this.isStatementOrExpression,
this,[]);v11957&&(v11957=JAMScript.call(this.isCompoundStatement,this,[]),v11957=!v11957);return v11957}function v83(){return!1}function v82(){return!1}function v81(){return!1}function AST(nodeType){JAMScript.call(_super.call,_super,[this]);this.nodeType=nodeType;this.type=null;nodeType=TypeScript.ASTFlags;this.flags=nodeType.Writeable;nodeType=TypeScript.CompilerDiagnostics;this.passCreated=nodeType.analysisPass;this.docComments=this.postComments=this.preComments=null;this.isParenthesized=!1}JAMScript.call(__extends,
null,[AST,_super]);var v11960=AST.prototype;v11960.isExpression=v81;v11960=AST.prototype;v11960.isStatementOrExpression=v82;v11960=AST.prototype;v11960.isCompoundStatement=v83;v11960=AST.prototype;v11960.isLeaf=v84;v11960=AST.prototype;v11960.isDeclaration=v85;v11960=AST.prototype;v11960.typeCheck=v86;v11960=AST.prototype;v11960.emit=v87;v11960=AST.prototype;v11960.print=v88;v11960=AST.prototype;v11960.printLabel=v89;v11960=AST.prototype;v11960.addToControlFlow=v90;v11960=AST.prototype;v11960.netFreeUses=
v91;v11960=AST.prototype;v11960.treeViewLabel=v92;AST.getResolvedIdentifierName=getResolvedIdentifierName;v11960=AST.prototype;v11960.getDocComments=v93;return AST}function v80(){function ASTSpan(){this.limChar=this.minChar=-1}return ASTSpan}var ASTSpan=v80();TypeScript.ASTSpan=ASTSpan;var AST=v94(ASTSpan);TypeScript.AST=AST;var IncompleteAST=v95(AST);TypeScript.IncompleteAST=IncompleteAST;var ASTList=v101(AST);TypeScript.ASTList=ASTList;var Identifier=v109(AST);TypeScript.Identifier=Identifier;var MissingIdentifier=
v112(Identifier);TypeScript.MissingIdentifier=MissingIdentifier;var Label=v116(AST);TypeScript.Label=Label;var Expression=v119(AST);TypeScript.Expression=Expression;var UnaryExpression=v123(Expression);TypeScript.UnaryExpression=UnaryExpression;var CallExpression=v126(Expression);TypeScript.CallExpression=CallExpression;var BinaryExpression=v129(Expression);TypeScript.BinaryExpression=BinaryExpression;var ConditionalExpression=v132(Expression);TypeScript.ConditionalExpression=ConditionalExpression;
var NumberLiteral=v137(Expression);TypeScript.NumberLiteral=NumberLiteral;var RegexLiteral=v140(Expression);TypeScript.RegexLiteral=RegexLiteral;var StringLiteral=v145(Expression);TypeScript.StringLiteral=StringLiteral;var ModuleElement=v146(AST);TypeScript.ModuleElement=ModuleElement;var ImportDeclaration=v153(ModuleElement);TypeScript.ImportDeclaration=ImportDeclaration;var BoundDecl=v161(AST);TypeScript.BoundDecl=BoundDecl;var VarDecl=v167(BoundDecl);TypeScript.VarDecl=VarDecl;var ArgDecl=v171(BoundDecl);
TypeScript.ArgDecl=ArgDecl;var internalId=0,FuncDecl=v201(AST);TypeScript.FuncDecl=FuncDecl;var LocationInfo=v202();TypeScript.LocationInfo=LocationInfo;var v11973=TypeScript,v27440=JAMScript.new(LocationInfo,["unknown",null,-1]);v11973.unknownLocationInfo=v27440;var Script=v210(FuncDecl);TypeScript.Script=Script;var NamedDeclaration=v212(ModuleElement);TypeScript.NamedDeclaration=NamedDeclaration;var ModuleDeclaration=v219(NamedDeclaration);TypeScript.ModuleDeclaration=ModuleDeclaration;var TypeDeclaration=
v222(NamedDeclaration);TypeScript.TypeDeclaration=TypeDeclaration;var ClassDeclaration=v225(TypeDeclaration);TypeScript.ClassDeclaration=ClassDeclaration;var InterfaceDeclaration=v228(TypeDeclaration);TypeScript.InterfaceDeclaration=InterfaceDeclaration;var Statement=v233(ModuleElement);TypeScript.Statement=Statement;var LabeledStatement=v237(Statement);TypeScript.LabeledStatement=LabeledStatement;var Block=v241(Statement);TypeScript.Block=Block;var Jump=v246(Statement);TypeScript.Jump=Jump;var WhileStatement=
v251(Statement);TypeScript.WhileStatement=WhileStatement;var DoWhileStatement=v256(Statement);TypeScript.DoWhileStatement=DoWhileStatement;var IfStatement=v261(Statement);TypeScript.IfStatement=IfStatement;var ReturnStatement=v265(Statement);TypeScript.ReturnStatement=ReturnStatement;var EndCode=v266(AST);TypeScript.EndCode=EndCode;var ForInStatement=v272(Statement);TypeScript.ForInStatement=ForInStatement;var ForStatement=v277(Statement);TypeScript.ForStatement=ForStatement;var WithStatement=v281(Statement);
TypeScript.WithStatement=WithStatement;var SwitchStatement=v286(Statement);TypeScript.SwitchStatement=SwitchStatement;var CaseStatement=v290(Statement);TypeScript.CaseStatement=CaseStatement;var TypeReference=v293(AST);TypeScript.TypeReference=TypeReference;var TryFinally=v298(Statement);TypeScript.TryFinally=TryFinally;var TryCatch=v303(Statement);TypeScript.TryCatch=TryCatch;var Try=v307(Statement);TypeScript.Try=Try;var Catch=v311(Statement);TypeScript.Catch=Catch;var Finally=v315(Statement);TypeScript.Finally=
Finally;var Comment$$0=v319(AST);TypeScript.Comment=Comment$$0;var DebuggerStatement=v321(Statement);TypeScript.DebuggerStatement=DebuggerStatement}function v79(d,b){function __(){this.constructor=d}__.prototype=b.prototype;var v11974=d,v27441=new __;v11974.prototype=v27441}
function v78(){var TypeScript=v12342;function v77(){function v76(key,data){var lookupData=JAMScript.call(this.lookup,this,[key]);if(lookupData)return!1;var v18637=lookupData=this.keys,v18637=v18637.length;JAMScript.set(lookupData,v18637,key);v18637=lookupData=this.values;v18637=v18637.length;JAMScript.set(lookupData,v18637,data);return!0}function v75(key,findValue){var searchArray=this.keys;findValue&&(searchArray=this.values);for(var i=0,v18639=searchArray.length,v18639=i<v18639;v18639;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v18639=
searchArray[i];if(v18639=v18639==key){searchArray=this.keys;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)searchArray=searchArray[i];v18639=this.values;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)i=v18639[i];return{key:searchArray,data:i}}i+=1;v18639=searchArray.length;v18639=i<v18639}return null}function SimpleHashTable(){this.keys=[];this.values=[]}var v11983=SimpleHashTable.prototype;v11983.lookup=v75;v11983=SimpleHashTable.prototype;
v11983.add=v76;return SimpleHashTable}function v74(){function v73(key){var current;current=JAMScript.call(this.hashFn,this,[key]);var v11985=this.size;current%=v11985;v11985=this.table;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)current=v11985[current];for(v11985=null!=current;v11985;){v11985=current.key;if(v11985=JAMScript.call(this.equalsFn,this,[key,v11985]))return current.data;current=current.next;v11985=null!=current}return null}function v72(){return this.itemCount}
function v71(key){var current,val=JAMScript.call(this.hashFn,this,[key]),v11989=this.size,val=val%v11989,prevEntry=v11989=null;current=this.table;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)current=current[val];for(var v11993=null!=current;v11993;){v11993=current.key;if(v11993=JAMScript.call(this.equalsFn,this,[key,v11993])){v11989=current.data;key=this.itemCount;this.itemCount=key-1;prevEntry?prevEntry.next=current.next:(key=this.table,JAMScript.set(key,val,
current.next));break}prevEntry=current;current=current.next;v11993=null!=current}return v11989}function v70(key,data){var current,entry=JAMScript.new(HashEntry,[key,data]),val=JAMScript.call(this.hashFn,this,[key]);current=this.size;val%=current;current=this.table;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)current=current[val];for(var v11997=null!=current;v11997;){v11997=current.key;if(v11997=JAMScript.call(this.equalsFn,this,[key,v11997]))return!1;current=
current.next;v11997=null!=current}current=this.table;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)entry.next=current[val];current=this.table;JAMScript.set(current,val,entry);entry=this.itemCount;this.itemCount=entry+1;return!0}function HashTable(size,hashFn,equalsFn){this.size=size;this.hashFn=hashFn;this.equalsFn=equalsFn;this.itemCount=0;this.table=size=[];size=0;hashFn=this.size;for(hashFn=size<hashFn;hashFn;)hashFn=this.table,hashFn[size]=null,size+=1,hashFn=
this.size,hashFn=size<hashFn}var v12002=HashTable.prototype;v12002.add=v70;v12002=HashTable.prototype;v12002.remove=v71;v12002=HashTable.prototype;v12002.count=v72;v12002=HashTable.prototype;v12002.lookup=v73;return HashTable}function v69(){function HashEntry(key,data){this.key=key;this.data=data}return HashEntry}function v68(){function v67(key){var v12006=this.primaryTable,v12006=JAMScript.call(v12006.lookup,v12006,[key]),v12008=void 0!=v12006;if(v12008)return v12006;v12006=this.secondaryTable;return JAMScript.call(v12006.lookup,
v12006,[key])}function v66(){var v18651=this.primaryTable,v18651=JAMScript.call(v18651.count,v18651,[]),v18652=this.secondaryTable,v18652=JAMScript.call(v18652.count,v18652,[]);return v18651+v18652}function v65(fn,context){var v18653=this.primaryTable,v18653=JAMScript.call(v18653.some,v18653,[fn,context]),v18655=!v18653;v18655&&(v18653=this.secondaryTable,v18653=JAMScript.call(v18653.some,v18653,[fn,context]));return v18653}function v64(fn,context){var v18656=this.primaryTable;if(v18656=JAMScript.call(v18656.every,
v18656,[fn,context]))v18656=this.secondaryTable,v18656=JAMScript.call(v18656.every,v18656,[fn,context]);return v18656}function v63(fn,context){var v12013=this.primaryTable;JAMScript.call(v12013.map,v12013,[fn,context]);v12013=this.secondaryTable;JAMScript.call(v12013.map,v12013,[fn,context])}function v62(key,data){var v12017=this.insertPrimary;if(v12017)return v12017=this.primaryTable,JAMScript.call(v12017.addOrUpdate,v12017,[key,data]);v12017=this.secondaryTable;return JAMScript.call(v12017.addOrUpdate,
v12017,[key,data])}function v61(key,data){var v12020=this.insertPrimary;if(v12020)return v12020=this.primaryTable,JAMScript.call(v12020.add,v12020,[key,data]);v12020=this.secondaryTable;return JAMScript.call(v12020.add,v12020,[key,data])}function v60(){var v18658=this.primaryTable,v18658=JAMScript.call(v18658.getAllKeys,v18658,[]),v18659=this.secondaryTable,v18659=JAMScript.call(v18659.getAllKeys,v18659,[]);return v18658.concat(v18659)}function DualStringHashTable(primaryTable,secondaryTable){this.primaryTable=
primaryTable;this.secondaryTable=secondaryTable;this.insertPrimary=!0}var v12023=DualStringHashTable.prototype;v12023.getAllKeys=v60;v12023=DualStringHashTable.prototype;v12023.add=v61;v12023=DualStringHashTable.prototype;v12023.addOrUpdate=v62;v12023=DualStringHashTable.prototype;v12023.map=v63;v12023=DualStringHashTable.prototype;v12023.every=v64;v12023=DualStringHashTable.prototype;v12023.some=v65;v12023=DualStringHashTable.prototype;v12023.count=v66;v12023=DualStringHashTable.prototype;v12023.lookup=
v67;return DualStringHashTable}function v59(){function v58(key){var v12031=this.table;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)key=v12031[key];return(v12031=void 0!=key)?key:null}function v57(){return this.itemCount}function v56(fn,context){var k,v12036=this.table;for(k in v12036){v12036=this.table;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v12036=v12036[k];if(v12036=void 0!=v12036){v12036=this.table;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v12036=
v12036[k];if(v12036=JAMScript.call(fn,null,[k,v12036,context]))return!0}}return!1}function v55(fn,context){var k,v12040=this.table;for(k in v12040){v12040=this.table;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v12040=v12040[k];if(v12040=void 0!=v12040){v12040=this.table;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v12040=v12040[k];v12040=JAMScript.call(fn,null,[k,v12040,context]);if(v12040=!v12040)return!1}}return!0}function v54(fn,
context){var k,v12044=this.table;for(k in v12044){v12044=this.table;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v12044=v12044[k];if(v12044=void 0!=v12044){v12044=this.table;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v12044=v12044[k];JAMScript.call(fn,null,[k,v12044,context])}}}function v53(key,data){var v22744=this.table;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v22744=v22744[key];
if(v22744=void 0!=v22744)return v22744=this.table,JAMScript.set(v22744,key,data),!1;v22744=this.table;JAMScript.set(v22744,key,data);v22744=this.itemCount;this.itemCount=v22744+1;return!0}function v52(key,data){var v22745=this.table;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v22745=v22745[key];if(v22745=void 0!=v22745)return!1;v22745=this.table;JAMScript.set(v22745,key,data);v22745=this.itemCount;this.itemCount=v22745+1;return!0}function v51(){var result=[],
k,v12052=this.table;for(k in v12052){v12052=this.table;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v12052=v12052[k];if(v12052=void 0!=v12052)v12052=result.length,result[v12052]=k}return result}function StringHashTable(){this.itemCount=0;var v27443=JAMScript.new(BlockIntrinsics,[]);this.table=v27443}var v12053=StringHashTable.prototype;v12053.getAllKeys=v51;v12053=StringHashTable.prototype;v12053.add=v52;v12053=StringHashTable.prototype;v12053.addOrUpdate=v53;
v12053=StringHashTable.prototype;v12053.map=v54;v12053=StringHashTable.prototype;v12053.every=v55;v12053=StringHashTable.prototype;v12053.some=v56;v12053=StringHashTable.prototype;v12053.count=v57;v12053=StringHashTable.prototype;v12053.lookup=v58;return StringHashTable}function v50(){function BlockIntrinsics(){this.constructor=this.isPrototypeOf=this.propertyIsEnumerable=this.hasOwnProperty=this.valueOf=this.toLocaleString=this.toString=this.prototype=void 0}return BlockIntrinsics}function numberHashFn(key){var c2=
668265261,v12061=key^61;key>>>=16;key^=v12061;v12061=key<<3;key+=v12061;v12061=key>>>4;key^=v12061;key*=c2;c2=key>>>15;return key^=c2}function combineHashes(key1,key2){var v18668=key1>>5,v18668=v18668+key1;return key2^v18668}var BlockIntrinsics=v50();TypeScript.BlockIntrinsics=BlockIntrinsics;var StringHashTable=v59();TypeScript.StringHashTable=StringHashTable;StringHashTable=v68();TypeScript.DualStringHashTable=StringHashTable;TypeScript.numberHashFn=numberHashFn;TypeScript.combineHashes=combineHashes;
var HashEntry=v69();TypeScript.HashEntry=HashEntry;StringHashTable=v74();TypeScript.HashTable=StringHashTable;StringHashTable=v77();TypeScript.SimpleHashTable=StringHashTable}
function v49(){var TypeScript=v12341,v12067=TypeScript.NodeType,v18669=!v12067;v18669&&(v12067=TypeScript.NodeType={});var NodeType=v12067;NodeType._map=[];var v12068=NodeType._map;v12068[0]="None";NodeType.None=0;var v12069=NodeType._map;v12069[1]="Empty";NodeType.Empty=1;var v12070=NodeType._map;v12070[2]="EmptyExpr";NodeType.EmptyExpr=2;var v12071=NodeType._map;v12071[3]="True";NodeType.True=3;var v12072=NodeType._map;v12072[4]="False";NodeType.False=4;var v12073=NodeType._map;v12073[5]="This";
NodeType.This=5;var v12074=NodeType._map;v12074[6]="Super";NodeType.Super=6;var v12075=NodeType._map;v12075[7]="QString";NodeType.QString=7;var v12076=NodeType._map;v12076[8]="Regex";NodeType.Regex=8;var v12077=NodeType._map;v12077[9]="Null";NodeType.Null=9;var v12078=NodeType._map;v12078[10]="ArrayLit";NodeType.ArrayLit=10;var v12079=NodeType._map;v12079[11]="ObjectLit";NodeType.ObjectLit=11;var v12080=NodeType._map;v12080[12]="Void";NodeType.Void=12;var v12081=NodeType._map;v12081[13]="Comma";NodeType.Comma=
13;var v12082=NodeType._map;v12082[14]="Pos";NodeType.Pos=14;var v12083=NodeType._map;v12083[15]="Neg";NodeType.Neg=15;var v12084=NodeType._map;v12084[16]="Delete";NodeType.Delete=16;var v12085=NodeType._map;v12085[17]="Await";NodeType.Await=17;var v12086=NodeType._map;v12086[18]="In";NodeType.In=18;var v12087=NodeType._map;v12087[19]="Dot";NodeType.Dot=19;var v12088=NodeType._map;v12088[20]="From";NodeType.From=20;var v12089=NodeType._map;v12089[21]="Is";NodeType.Is=21;var v12090=NodeType._map;v12090[22]=
"InstOf";NodeType.InstOf=22;var v12091=NodeType._map;v12091[23]="Typeof";NodeType.Typeof=23;var v12092=NodeType._map;v12092[24]="NumberLit";NodeType.NumberLit=24;var v12093=NodeType._map;v12093[25]="Name";NodeType.Name=25;var v12094=NodeType._map;v12094[26]="TypeRef";NodeType.TypeRef=26;var v12095=NodeType._map;v12095[27]="Index";NodeType.Index=27;var v12096=NodeType._map;v12096[28]="Call";NodeType.Call=28;var v12097=NodeType._map;v12097[29]="New";NodeType.New=29;var v12098=NodeType._map;v12098[30]=
"Asg";NodeType.Asg=30;var v12099=NodeType._map;v12099[31]="AsgAdd";NodeType.AsgAdd=31;var v12100=NodeType._map;v12100[32]="AsgSub";NodeType.AsgSub=32;var v12101=NodeType._map;v12101[33]="AsgDiv";NodeType.AsgDiv=33;var v12102=NodeType._map;v12102[34]="AsgMul";NodeType.AsgMul=34;var v12103=NodeType._map;v12103[35]="AsgMod";NodeType.AsgMod=35;var v12104=NodeType._map;v12104[36]="AsgAnd";NodeType.AsgAnd=36;var v12105=NodeType._map;v12105[37]="AsgXor";NodeType.AsgXor=37;var v12106=NodeType._map;v12106[38]=
"AsgOr";NodeType.AsgOr=38;var v12107=NodeType._map;v12107[39]="AsgLsh";NodeType.AsgLsh=39;var v12108=NodeType._map;v12108[40]="AsgRsh";NodeType.AsgRsh=40;var v12109=NodeType._map;v12109[41]="AsgRs2";NodeType.AsgRs2=41;var v12110=NodeType._map;v12110[42]="ConditionalExpression";NodeType.ConditionalExpression=42;var v12111=NodeType._map;v12111[43]="LogOr";NodeType.LogOr=43;var v12112=NodeType._map;v12112[44]="LogAnd";NodeType.LogAnd=44;var v12113=NodeType._map;v12113[45]="Or";NodeType.Or=45;var v12114=
NodeType._map;v12114[46]="Xor";NodeType.Xor=46;var v12115=NodeType._map;v12115[47]="And";NodeType.And=47;var v12116=NodeType._map;v12116[48]="Eq";NodeType.Eq=48;var v12117=NodeType._map;v12117[49]="Ne";NodeType.Ne=49;var v12118=NodeType._map;v12118[50]="Eqv";NodeType.Eqv=50;var v12119=NodeType._map;v12119[51]="NEqv";NodeType.NEqv=51;var v12120=NodeType._map;v12120[52]="Lt";NodeType.Lt=52;var v12121=NodeType._map;v12121[53]="Le";NodeType.Le=53;var v12122=NodeType._map;v12122[54]="Gt";NodeType.Gt=54;
var v12123=NodeType._map;v12123[55]="Ge";NodeType.Ge=55;var v12124=NodeType._map;v12124[56]="Add";NodeType.Add=56;var v12125=NodeType._map;v12125[57]="Sub";NodeType.Sub=57;var v12126=NodeType._map;v12126[58]="Mul";NodeType.Mul=58;var v12127=NodeType._map;v12127[59]="Div";NodeType.Div=59;var v12128=NodeType._map;v12128[60]="Mod";NodeType.Mod=60;var v12129=NodeType._map;v12129[61]="Lsh";NodeType.Lsh=61;var v12130=NodeType._map;v12130[62]="Rsh";NodeType.Rsh=62;var v12131=NodeType._map;v12131[63]="Rs2";
NodeType.Rs2=63;var v12132=NodeType._map;v12132[64]="Not";NodeType.Not=64;var v12133=NodeType._map;v12133[65]="LogNot";NodeType.LogNot=65;var v12134=NodeType._map;v12134[66]="IncPre";NodeType.IncPre=66;var v12135=NodeType._map;v12135[67]="DecPre";NodeType.DecPre=67;var v12136=NodeType._map;v12136[68]="IncPost";NodeType.IncPost=68;var v12137=NodeType._map;v12137[69]="DecPost";NodeType.DecPost=69;var v12138=NodeType._map;v12138[70]="TypeAssertion";NodeType.TypeAssertion=70;var v12139=NodeType._map;
v12139[71]="FuncDecl";NodeType.FuncDecl=71;var v12140=NodeType._map;v12140[72]="Member";NodeType.Member=72;var v12141=NodeType._map;v12141[73]="VarDecl";NodeType.VarDecl=73;var v12142=NodeType._map;v12142[74]="ArgDecl";NodeType.ArgDecl=74;var v12143=NodeType._map;v12143[75]="Return";NodeType.Return=75;var v12144=NodeType._map;v12144[76]="Break";NodeType.Break=76;var v12145=NodeType._map;v12145[77]="Continue";NodeType.Continue=77;var v12146=NodeType._map;v12146[78]="Throw";NodeType.Throw=78;var v12147=
NodeType._map;v12147[79]="For";NodeType.For=79;var v12148=NodeType._map;v12148[80]="ForIn";NodeType.ForIn=80;var v12149=NodeType._map;v12149[81]="If";NodeType.If=81;var v12150=NodeType._map;v12150[82]="While";NodeType.While=82;var v12151=NodeType._map;v12151[83]="DoWhile";NodeType.DoWhile=83;var v12152=NodeType._map;v12152[84]="Block";NodeType.Block=84;var v12153=NodeType._map;v12153[85]="Case";NodeType.Case=85;var v12154=NodeType._map;v12154[86]="Switch";NodeType.Switch=86;var v12155=NodeType._map;
v12155[87]="Try";NodeType.Try=87;var v12156=NodeType._map;v12156[88]="TryCatch";NodeType.TryCatch=88;var v12157=NodeType._map;v12157[89]="TryFinally";NodeType.TryFinally=89;var v12158=NodeType._map;v12158[90]="Finally";NodeType.Finally=90;var v12159=NodeType._map;v12159[91]="Catch";NodeType.Catch=91;var v12160=NodeType._map;v12160[92]="List";NodeType.List=92;var v12161=NodeType._map;v12161[93]="Script";NodeType.Script=93;var v12162=NodeType._map;v12162[94]="ClassDeclaration";NodeType.ClassDeclaration=
94;var v12163=NodeType._map;v12163[95]="InterfaceDeclaration";NodeType.InterfaceDeclaration=95;var v12164=NodeType._map;v12164[96]="ModuleDeclaration";NodeType.ModuleDeclaration=96;var v12165=NodeType._map;v12165[97]="ImportDeclaration";NodeType.ImportDeclaration=97;var v12166=NodeType._map;v12166[98]="With";NodeType.With=98;var v12167=NodeType._map;v12167[99]="Label";NodeType.Label=99;var v12168=NodeType._map;v12168[100]="LabeledStatement";NodeType.LabeledStatement=100;var v12169=NodeType._map;v12169[101]=
"EBStart";NodeType.EBStart=101;var v12170=NodeType._map;v12170[102]="GotoEB";NodeType.GotoEB=102;var v12171=NodeType._map;v12171[103]="EndCode";NodeType.EndCode=103;var v12172=NodeType._map;v12172[104]="Error";NodeType.Error=104;var v12173=NodeType._map;v12173[105]="Comment";NodeType.Comment=105;var v12174=NodeType._map;v12174[106]="Debugger";NodeType.Debugger=106;NodeType.GeneralNode=NodeType.FuncDecl;NodeType.LastAsg=NodeType.AsgRs2}
function v48(){var TypeScript=v12340;function v47(ModuleGenTarget){ModuleGenTarget._map=[];ModuleGenTarget.Synchronous=0;ModuleGenTarget.Asynchronous=1;ModuleGenTarget.Local=2}function v46(CodeGenTarget){CodeGenTarget._map=[];CodeGenTarget.ES3=0;CodeGenTarget.ES5=1}function v45(TypeRelationshipFlags){TypeRelationshipFlags._map=[];TypeRelationshipFlags.SuccessfulComparison=0;TypeRelationshipFlags.SourceIsNullTargetIsVoidOrUndefined=1;TypeRelationshipFlags.RequiredPropertyIsMissing=2;TypeRelationshipFlags.IncompatibleSignatures=
4;TypeRelationshipFlags.SourceSignatureHasTooManyParameters=3;TypeRelationshipFlags.IncompatibleReturnTypes=16;TypeRelationshipFlags.IncompatiblePropertyTypes=32;TypeRelationshipFlags.IncompatibleParameterTypes=64}function v44(TypeFlags){TypeFlags._map=[];TypeFlags.None=0;TypeFlags.HasImplementation=1;TypeFlags.HasSelfReference=2;TypeFlags.MergeResult=4;TypeFlags.IsEnum=8;TypeFlags.BuildingName=16;TypeFlags.HasBaseType=32;TypeFlags.HasBaseTypeOfObject=64;TypeFlags.IsClass=128}function v43(SignatureFlags){SignatureFlags._map=
[];SignatureFlags.None=0;SignatureFlags.IsIndexer=1;SignatureFlags.IsStringIndexer=2;SignatureFlags.IsNumberIndexer=4}function v42(FncFlags){FncFlags._map=[];FncFlags.None=0;FncFlags.Exported=1;FncFlags.Private=2;FncFlags.Public=4;FncFlags.Ambient=8;FncFlags.Static=16;FncFlags.LocalStatic=32;FncFlags.GetAccessor=64;FncFlags.SetAccessor=128;FncFlags.Definition=256;FncFlags.Signature=512;FncFlags.Method=1024;FncFlags.HasReturnExpression=2048;FncFlags.CallMember=4096;FncFlags.ConstructMember=8192;FncFlags.HasSelfReference=
16384;FncFlags.IsFatArrowFunction=32768;FncFlags.IndexerMember=65536;FncFlags.IsFunctionExpression=131072;FncFlags.ClassMethod=262144;FncFlags.ClassPropertyMethodExported=524288;FncFlags.HasSuperReferenceInFatArrowFunction=1048576;FncFlags.IsPropertyBound=2097152}function v41(VarFlags){VarFlags._map=[];VarFlags.None=0;VarFlags.Exported=1;VarFlags.Private=2;VarFlags.Public=4;VarFlags.Ambient=8;VarFlags.Static=16;VarFlags.LocalStatic=32;VarFlags.GetAccessor=64;VarFlags.SetAccessor=128;VarFlags.AutoInit=
256;VarFlags.Property=512;VarFlags.Readonly=1024;VarFlags.Class=2048;VarFlags.ClassProperty=4096;VarFlags.ClassBodyProperty=8192;VarFlags.ClassConstructorProperty=16384;VarFlags.ClassSuperMustBeFirstCallInConstructor=32768;VarFlags.Constant=65536;VarFlags.MustCaptureThis=131072}function v40(SymbolFlags){SymbolFlags._map=[];SymbolFlags.None=0;SymbolFlags.Exported=1;SymbolFlags.Private=2;SymbolFlags.Public=4;SymbolFlags.Ambient=8;SymbolFlags.Static=16;SymbolFlags.LocalStatic=32;SymbolFlags.GetAccessor=
64;SymbolFlags.SetAccessor=128;SymbolFlags.Property=256;SymbolFlags.Readonly=512;SymbolFlags.ModuleMember=1024;SymbolFlags.InterfaceMember=2048;SymbolFlags.ClassMember=4096;SymbolFlags.BuiltIn=8192;SymbolFlags.TypeSetDuringScopeAssignment=16384;SymbolFlags.Constant=32768;SymbolFlags.Optional=65536;SymbolFlags.RecursivelyReferenced=131072;SymbolFlags.Bound=262144;SymbolFlags.CompilerGenerated=524288}function v39(ModuleFlags){ModuleFlags._map=[];ModuleFlags.None=0;ModuleFlags.Exported=1;ModuleFlags.Private=
2;ModuleFlags.Public=4;ModuleFlags.Ambient=8;ModuleFlags.Static=16;ModuleFlags.LocalStatic=32;ModuleFlags.GetAccessor=64;ModuleFlags.SetAccessor=128;ModuleFlags.IsEnum=256;ModuleFlags.ShouldEmitModuleDecl=512;ModuleFlags.IsWholeFile=1024;ModuleFlags.IsDynamic=2048;ModuleFlags.MustCaptureThis=4096}function v38(DeclFlags){DeclFlags._map=[];DeclFlags.None=0;DeclFlags.Exported=1;DeclFlags.Private=2;DeclFlags.Public=4;DeclFlags.Ambient=8;DeclFlags.Static=16;DeclFlags.LocalStatic=32;DeclFlags.GetAccessor=
64;DeclFlags.SetAccessor=128}function v37(ASTFlags){ASTFlags._map=[];ASTFlags.None=0;ASTFlags.ExplicitSemicolon=1;ASTFlags.AutomaticSemicolon=2;ASTFlags.Writeable=4;ASTFlags.Error=8;ASTFlags.DotLHSPartial=16;ASTFlags.DotLHS=32;ASTFlags.IsStatement=64;ASTFlags.StrictMode=128;ASTFlags.PossibleOptionalParameter=256;ASTFlags.ClassBaseConstructorCall=512;ASTFlags.OptionalName=1024;ASTFlags.SkipNextRParen=2048}function v36(Modifiers){Modifiers._map=[];Modifiers.None=0;Modifiers.Private=1;Modifiers.Public=
2;Modifiers.Readonly=4;Modifiers.Ambient=8;Modifiers.Exported=16;Modifiers.Getter=32;Modifiers.Setter=64;Modifiers.Static=128}function v35(AllowedElements){AllowedElements._map=[];AllowedElements.None=0;AllowedElements.ModuleDeclarations=4;AllowedElements.ClassDeclarations=8;AllowedElements.InterfaceDeclarations=16;AllowedElements.AmbientDeclarations=1024;AllowedElements.Properties=2048;var v22747=AllowedElements.ModuleDeclarations,v22748=AllowedElements.ClassDeclarations,v22747=v22747|v22748,v22748=
AllowedElements.InterfaceDeclarations,v22747=v22747|v22748,v22748=AllowedElements.AmbientDeclarations;AllowedElements.Global=v22747|v22748;v22747=AllowedElements.Global;v22748=AllowedElements.Properties;AllowedElements.QuickParse=v22747|v22748}function v34(ErrorRecoverySet){ErrorRecoverySet._map=[];ErrorRecoverySet.None=0;ErrorRecoverySet.Comma=1;ErrorRecoverySet.SColon=2;ErrorRecoverySet.Asg=4;ErrorRecoverySet.BinOp=8;ErrorRecoverySet.RBrack=16;ErrorRecoverySet.RCurly=32;ErrorRecoverySet.RParen=
64;ErrorRecoverySet.Dot=128;ErrorRecoverySet.Colon=256;ErrorRecoverySet.PrimType=512;ErrorRecoverySet.AddOp=1024;ErrorRecoverySet.LCurly=2048;ErrorRecoverySet.PreOp=4096;ErrorRecoverySet.RegExp=8192;ErrorRecoverySet.LParen=16384;ErrorRecoverySet.LBrack=32768;ErrorRecoverySet.Scope=65536;ErrorRecoverySet.In=131072;ErrorRecoverySet.SCase=262144;ErrorRecoverySet.Else=524288;ErrorRecoverySet.Catch=1048576;ErrorRecoverySet.Var=2097152;ErrorRecoverySet.Stmt=4194304;ErrorRecoverySet.While=8388608;ErrorRecoverySet.ID=
16777216;ErrorRecoverySet.Prefix=33554432;ErrorRecoverySet.Literal=67108864;ErrorRecoverySet.RLit=134217728;ErrorRecoverySet.Func=268435456;ErrorRecoverySet.EOF=536870912;ErrorRecoverySet.TypeScriptS=1073741824;var v26753=ErrorRecoverySet.SColon,v26754=ErrorRecoverySet.AddOp,v26753=v26753|v26754,v26754=ErrorRecoverySet.LCurly,v26753=v26753|v26754,v26754=ErrorRecoverySet.PreOp,v26753=v26753|v26754,v26754=ErrorRecoverySet.RegExp,v26753=v26753|v26754,v26754=ErrorRecoverySet.LParen,v26753=v26753|v26754,
v26754=ErrorRecoverySet.LBrack,v26753=v26753|v26754,v26754=ErrorRecoverySet.ID,v26753=v26753|v26754,v26754=ErrorRecoverySet.Prefix,v26753=v26753|v26754,v26754=ErrorRecoverySet.RLit,v26753=v26753|v26754,v26754=ErrorRecoverySet.Func,v26753=v26753|v26754,v26754=ErrorRecoverySet.Literal;ErrorRecoverySet.ExprStart=v26753|v26754;v26753=ErrorRecoverySet.ExprStart;v26754=ErrorRecoverySet.SColon;v26753|=v26754;v26754=ErrorRecoverySet.Var;v26753|=v26754;v26754=ErrorRecoverySet.Stmt;v26753|=v26754;v26754=ErrorRecoverySet.While;
v26753|=v26754;v26754=ErrorRecoverySet.TypeScriptS;ErrorRecoverySet.StmtStart=v26753|v26754;v26753=ErrorRecoverySet.Dot;v26754=ErrorRecoverySet.LParen;v26753|=v26754;v26754=ErrorRecoverySet.LBrack;ErrorRecoverySet.Postfix=v26753|v26754}function hasFlag(val,flag){var v12185=val&flag;return 0!=v12185}function ToDeclFlags(fncOrVarOrSymbolOrModuleFlags){return fncOrVarOrSymbolOrModuleFlags}function flagsToString(e,flags){for(var builder="",i=1,v18678=-2147483648,v18678=i<v18678;v18678;){v18678=flags&
i;if(v18678=0!=v18678)for(var k in e){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v18678=e[k];if(v18678=v18678==i){v18678=builder.length;(v18678=0<v18678)&&(builder+="|");builder+=k;break}}i<<=1;v18678=-2147483648;v18678=i<v18678}return builder}TypeScript.hasFlag=hasFlag;var v18683=TypeScript.ErrorRecoverySet,v22753=!v18683;v22753&&(v18683=TypeScript.ErrorRecoverySet={});v34(v18683);v18683=TypeScript.AllowedElements;if(v22753=!v18683)v18683=TypeScript.AllowedElements=
{};v35(v18683);v18683=TypeScript.Modifiers;if(v22753=!v18683)v18683=TypeScript.Modifiers={};v36(v18683);v18683=TypeScript.ASTFlags;if(v22753=!v18683)v18683=TypeScript.ASTFlags={};v37(v18683);v18683=TypeScript.DeclFlags;if(v22753=!v18683)v18683=TypeScript.DeclFlags={};v38(v18683);v18683=TypeScript.ModuleFlags;if(v22753=!v18683)v18683=TypeScript.ModuleFlags={};v39(v18683);v18683=TypeScript.SymbolFlags;if(v22753=!v18683)v18683=TypeScript.SymbolFlags={};v40(v18683);v18683=TypeScript.VarFlags;if(v22753=
!v18683)v18683=TypeScript.VarFlags={};v41(v18683);v18683=TypeScript.FncFlags;if(v22753=!v18683)v18683=TypeScript.FncFlags={};v42(v18683);v18683=TypeScript.SignatureFlags;if(v22753=!v18683)v18683=TypeScript.SignatureFlags={};v43(v18683);TypeScript.ToDeclFlags=ToDeclFlags;v18683=TypeScript.TypeFlags;if(v22753=!v18683)v18683=TypeScript.TypeFlags={};v44(v18683);v18683=TypeScript.TypeRelationshipFlags;if(v22753=!v18683)v18683=TypeScript.TypeRelationshipFlags={};v45(v18683);v18683=TypeScript.CodeGenTarget;
if(v22753=!v18683)v18683=TypeScript.CodeGenTarget={};v46(v18683);var v18683=TypeScript.CodeGenTarget,v22753=TypeScript.ModuleGenTarget,v22766=!v22753;v22766&&(v22753=TypeScript.ModuleGenTarget={});v47(v22753);v22753=TypeScript.ModuleGenTarget;TypeScript.codeGenTarget=v18683.ES3;TypeScript.moduleGenTarget=v22753.Synchronous;TypeScript.optimizeModuleCodeGen=!0;TypeScript.flagsToString=flagsToString}
function v33(s){for(var i=0,v18697=s.length,v18697=i<v18697;v18697;){var v18697=JAMScript.call(s.charCodeAt,s,[i]),v18698=this.cumulative_checksum,v18698=v18698<<1;this.cumulative_checksum=v18698^v18697;i+=1;v18697=s.length;v18697=i<v18697}}function v32(){var v18700=this.checksum,v18701=this.cumulative_checksum;if(v18700=v18700!=v18701)throw Error("Wrong checksum.");this.cumulative_checksum=0}function v31(s){s+="\n";JAMScript.call(this.Verify,this,[s])}
function v30(s){JAMScript.call(this.Verify,this,[s])}function v29(s){for(var i=0,v18702=s.length,v18702=i<v18702;v18702;){var v18702=JAMScript.call(s.charCodeAt,s,[i]),v18703=this.cumulative_checksum,v18703=v18703<<1;this.cumulative_checksum=v18703^v18702;i+=1;v18702=s.length;v18702=i<v18702}}function v28(){var v18705=this.checksum,v18706=this.cumulative_checksum;if(v18705=v18705!=v18706)throw Error("Wrong checksum.");this.cumulative_checksum=0}
function v27(s){s+="\n";JAMScript.call(this.Verify,this,[s])}function v26(s){JAMScript.call(this.Verify,this,[s])}
function v25(runner){function RunNextSetup(){var v12213=index<length;if(v12213){try{var v18707=suite.benchmarks;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v12212=v18707[index];JAMScript.call(v12212.Setup,v12212,[])}catch(e){return JAMScript.call(suite.NotifyError,suite,[e]),null}return RunNextBenchmark}JAMScript.call(suite.NotifyResult,suite,[]);return null}function RunNextBenchmark(){try{var v18708=suite.benchmarks;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v12214=
v18708[index];data=JAMScript.call(suite.RunSingleBenchmark,suite,[v12214,data])}catch(e){return JAMScript.call(suite.NotifyError,suite,[e]),null}return v18708=(v18708=null==data)?RunNextTearDown:RunNextBenchmark()}function RunNextTearDown(){try{var v18710=suite.benchmarks,v18711=index;index+=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)var v12216=v18710[v18711];JAMScript.call(v12216.TearDown,v12216,[])}catch(e){return JAMScript.call(suite.NotifyError,suite,
[e]),null}return RunNextSetup}JAMScript.call(BenchmarkSuite.ResetRNG,BenchmarkSuite,[]);this.results=[];this.runner=runner;runner=this.benchmarks;var length=runner.length,index=0,suite=this,data;return RunNextSetup()}
function v24(benchmark,data$$0){function Measure(data){var elapsed=0,start=new Date,i=0,v18712;doDeterministic?(v18712=benchmark.deterministicIterations,v18712=i<v18712):v18712=1E3>elapsed;for(;v18712;)JAMScript.call(benchmark.run,benchmark,[]),elapsed=new Date,elapsed-=start,i+=1,doDeterministic?(v18712=benchmark.deterministicIterations,v18712=i<v18712):v18712=1E3>elapsed;if(start=null!=data)start=data.runs,data.runs=start+i,i=data.elapsed,data.elapsed=i+elapsed}var config=BenchmarkSuite.config,
v12221;v12221=config.doWarmup;v12221=(v12221=void 0!==v12221)?config.doWarmup:benchmark.doWarmup;var v22770=config.doDeterministic,doDeterministic=config=(v22770=void 0!==v22770)?config.doDeterministic:benchmark.doDeterministic;(config=!v12221)&&(config=null==data$$0);config&&(data$$0={runs:0,elapsed:0});if(config=null==data$$0)return Measure(null),{runs:0,elapsed:0};Measure(data$$0);config=data$$0.runs;v12221=benchmark.minIterations;if(config=config<v12221)return data$$0;config=data$$0.elapsed;config*=
1E3;v12221=data$$0.runs;config/=v12221;v12221=benchmark.rmsResult;v12221=(v12221=null!=v12221)?JAMScript.call(benchmark.rmsResult,benchmark,[]):0;config=new BenchmarkResult(benchmark,config,v12221);JAMScript.call(this.NotifyStep,this,[config]);return null}
function v23(error){var v18723=this.runner;if(v18723=v18723.NotifyError){var v18723=this.runner,v12231=this.name;JAMScript.call(v18723.NotifyError,v18723,[v12231,error])}error=this.runner;if(error=error.NotifyStep)error=this.runner,v18723=this.name,JAMScript.call(error.NotifyStep,error,[v18723])}function v22(runner){var v12236=BenchmarkSuite.scores;JAMScript.call(v12236.push,v12236,[1]);if(v12236=runner.NotifyResult)v12236=this.name,JAMScript.call(runner.NotifyResult,runner,[v12236,"Skipped"])}
function v21(){var v12239=this.results,v12239=JAMScript.call(BenchmarkSuite.GeometricMeanTime,BenchmarkSuite,[v12239]),v18725=this.reference,v18725=v18725[0],v12239=v18725/v12239,v18725=BenchmarkSuite.scores;JAMScript.call(v18725.push,v18725,[v12239]);v18725=this.runner;if(v18725=v18725.NotifyResult){var v12239=100*v12239,v12239=JAMScript.call(BenchmarkSuite.FormatScore,BenchmarkSuite,[v12239]),v18725=this.runner,v12244=this.name;JAMScript.call(v18725.NotifyResult,v18725,[v12244,v12239])}v12239=this.reference;
v12239=v12239.length;if(v12239=2==v12239)if(v12239=this.results,v12239=JAMScript.call(BenchmarkSuite.GeometricMeanLatency,BenchmarkSuite,[v12239]),v18725=0!=v12239)if(v18725=this.reference,v18725=v18725[1],v12239=v18725/v12239,v18725=BenchmarkSuite.scores,JAMScript.call(v18725.push,v18725,[v12239]),v18725=this.runner,v18725=v18725.NotifyResult)v12239*=100,v12239=JAMScript.call(BenchmarkSuite.FormatScore,BenchmarkSuite,[v12239]),v18725=this.runner,v12244=this.name,v12244+="Latency",JAMScript.call(v18725.NotifyResult,
v18725,[v12244,v12239])}function v20(result){var v12255=this.results;JAMScript.call(v12255.push,v12255,[result]);v12255=this.runner;if(v12255=v12255.NotifyStep)v12255=this.runner,result=result.benchmark,result=result.name,JAMScript.call(v12255.NotifyStep,v12255,[result])}function v19(value){var v12259=100<value;return v12259?value.toFixed(0):value.toPrecision(3)}
function v18(measurements){for(var log=0,hasLatencyResult=!1,i=0,v18733=measurements.length,v18733=i<v18733;v18733;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v18733=measurements[i];v18733=v18733.latency;if(v18733=0!=v18733){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)hasLatencyResult=measurements[i];hasLatencyResult=hasLatencyResult.latency;hasLatencyResult=JAMScript.call(Math.log,Math,[hasLatencyResult]);log+=hasLatencyResult;
hasLatencyResult=!0}i+=1;v18733=measurements.length;v18733=i<v18733}return hasLatencyResult?(i=Math.E,measurements=measurements.length,measurements=log/measurements,Math.pow(i,measurements)):0}
function v17(measurements){for(var log=0,i=0,v18739=measurements.length,v18739=i<v18739;v18739;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v18739=measurements[i];v18739=v18739.time;v18739=JAMScript.call(Math.log,Math,[v18739]);log+=v18739;i+=1;v18739=measurements.length;v18739=i<v18739}i=Math.E;measurements=measurements.length;measurements=log/measurements;return Math.pow(i,measurements)}
function v16(numbers){for(var log=0,i=0,v18744=numbers.length,v18744=i<v18744;v18744;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v18744=numbers[i];v18744=JAMScript.call(Math.log,Math,[v18744]);log+=v18744;i+=1;v18744=numbers.length;v18744=i<v18744}i=Math.E;numbers=numbers.length;numbers=log/numbers;return Math.pow(i,numbers)}
function v15(){for(var result=0,suites=BenchmarkSuite.suites,i=0,v18749=suites.length,v18749=i<v18749;v18749;){introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v18749=suites[i];v18749=v18749.benchmarks;v18749=v18749.length;result+=v18749;i+=1;v18749=suites.length;v18749=i<v18749}return result}
function v14(runner,skipBenchmarks){function RunStep(){var v18752=continuation,v22778=!v18752;for(v22778&&(v18752=index<length);v18752;){if(continuation)continuation=JAMScript.call(continuation,null,[]);else{v18752=index;index+=1;introspect(JAMScript.introspectors.processC545F199BE443C5FB0DC91C55134FB746FD8B074)v18752=suites[v18752];if(v22778=runner.NotifyStart)v22778=v18752.name,JAMScript.call(runner.NotifyStart,runner,[v22778]);v22778=v18752.name;v22778=skipBenchmarks.indexOf(v22778);(v22778=-1<
v22778)?JAMScript.call(v18752.NotifySkipped,v18752,[runner]):continuation=JAMScript.call(v18752.RunStep,v18752,[runner])}if(v18752=continuation)if(v18752=typeof window,v18752="undefined"!=v18752)v18752=window.setTimeout;if(v18752){window.setTimeout(RunStep,25);return}v18752=continuation;(v22778=!v18752)&&(v18752=index<length)}if(v18752=runner.NotifyScore)v18752=BenchmarkSuite.scores,v18752=JAMScript.call(BenchmarkSuite.GeometricMean,BenchmarkSuite,[v18752]),v18752*=100,v18752=JAMScript.call(BenchmarkSuite.FormatScore,
BenchmarkSuite,[v18752]),JAMScript.call(runner.NotifyScore,runner,[v18752])}var v12280;v12280=typeof skipBenchmarks;skipBenchmarks=v12280=(v12280="undefined"===v12280)?[]:skipBenchmarks;var continuation=null,suites=BenchmarkSuite.suites,length=suites.length;BenchmarkSuite.scores=[];var index=0;RunStep()}
function v13(){function v12(){function v11(){var v18757=seed+2127912214,v18758=seed<<12,v18757=v18757+v18758;seed=v18757&4294967295;v18757=seed^3345072700;v18758=seed>>>19;v18757^=v18758;seed=v18757&4294967295;v18757=seed+374761393;v18758=seed<<5;v18757+=v18758;seed=v18757&4294967295;v18757=seed+3550635116;v18758=seed<<9;v18757^=v18758;seed=v18757&4294967295;v18757=seed+4251993797;v18758=seed<<3;v18757+=v18758;seed=v18757&4294967295;v18757=seed^3042594569;v18758=seed>>>16;v18757^=v18758;seed=v18757&
4294967295;v18757=seed&268435455;return v18757/268435456}var seed=49734321;return v11}var v12288=Math,v27444=v12();v12288.random=v27444}function v10(s){throw"Alert called with argument: "+s;}function v9(){return this.time}function v8(){var v12289=performance.now,v18770=!v12289;v18770&&(v12289=performance.mozNow,v18770=!v12289)&&(v12289=performance.msNow,v18770=!v12289)&&(v12289=performance.oNow,v18770=!v12289)&&(v12289=performance.webkitNow,v18770=!v12289)&&(v12289=Date.now);return v12289}
function Benchmark(){var name="Typescript",doWarmup=!1,doDeterministic=!0,deterministicIterations=5,run=runTypescript,setup=setupTypescript,tearDown=tearDownTypescript,rmsResult=null,minIterations=1;function v1(){}function v0(){}this.name=name;this.doWarmup=doWarmup;this.doDeterministic=doDeterministic;this.deterministicIterations=deterministicIterations;this.run=run;this.Setup=name=setup?setup:v0;this.TearDown=tearDown=tearDown?tearDown:v1;this.rmsResult=rmsResult=rmsResult?rmsResult:null;this.minIterations=
minIterations=minIterations?minIterations:32}function BenchmarkResult(benchmark,time,latency){this.benchmark=benchmark;this.time=time;this.latency=latency}function BenchmarkSuite(name,reference,benchmarks){this.name=name;this.reference=reference;this.benchmarks=benchmarks;name=BenchmarkSuite.suites;JAMScript.call(name.push,name,[this])}function setupTypescript(){}function tearDownTypescript(){compiler_input=null}
function runTypescript(){function v5(path){return path}function v4(path){return!1}function v3(path){return!1}function v2(fileName){return outfile}var compiler=createCompiler();JAMScript.call(compiler.addUnit,compiler,[compiler_input,"compiler_input.ts"]);parseErrors=[];JAMScript.call(compiler.reTypeCheck,compiler,[]);var v12295={createFile:v2,fileExists:v3,directoryExists:v4,resolvePath:v5};JAMScript.call(compiler.emit,compiler,[v12295]);compiler=parseErrors.length;if(compiler=192!=compiler)compiler=
parseErrors.length,compiler=193!=compiler;if(compiler)throw Error("Parse errors.");compiler=null}
function createCompiler(){function v6(start,len,message){start={start:start,len:len,message:message};JAMScript.call(parseErrors.push,parseErrors,[start])}var v12298=TypeScript.CompilationSettings,v12298=JAMScript.new(v12298,[]),v12299=TypeScript.CodeGenTarget;v12298.codeGenTarget=v12299.ES5;var v12299=TypeScript.TypeScriptCompiler,v18772=TypeScript.NullLogger,v18772=JAMScript.new(v18772,[]),v12298=JAMScript.new(v12299,[outerr,v18772,v12298]);JAMScript.call(v12298.setErrorCallback,v12298,[v6]);v12299=
v12298.parser;v12299.errorRecovery=!0;JAMScript.call(v12298.typeCheck,v12298,[]);return v12298}
function ShowBox(name){function v7(entry){var v18773=JAMScript.call(name.valueOf,name,[]);entry=JAMScript.call(entry.valueOf,entry,[]);if(v18773=v18773===entry)v18773="Box-"+name,v18773+="Latency",v18773=document.getElementById(v18773),v18773=v18773.style,v18773.visibility="visible"}var v12306="Box-"+name,v12306=document.getElementById(v12306),v12306=v12306.style;v12306.visibility="visible";var v12306=document.getElementById("progress-bar"),v12306=v12306.style,v25741=completed+=1,v25741=v25741/benchmarks,
v25741=100*v25741,v25741=""+v25741;v12306.width=v25741+"%";latencyBenchmarks.forEach(v7)}function AddResult(name,result){var v18778=name+": ",v18778=v18778+result;JAMScript.call(console.log,console,[v18778]);v18778="Result-"+name;v18778=document.getElementById(v18778);JAMScript.set(v18778,"innerHTML",result)}
function AddError(name,error){var v18779=name+": ",v18780=error.message,v18779=v18779+v18780;JAMScript.call(console.log,console,[v18779]);(v18779="TypedArrayUnsupported"==error)?AddResult(name,"<b>Unsupported</b>"):(v18779="PerformanceNowUnsupported"==error)?AddResult(name,"<b>Timer error</b>"):AddResult(name,"<b>Error</b>");success=!1}
function AddScore(score){var status=document.getElementById("main-banner");success?JAMScript.set(status,"innerHTML","Octane Score: "+score):JAMScript.set(status,"innerHTML","Octane Score (incomplete): "+score);score=document.getElementById("progress-bar-container");score=score.style;score.visibility="hidden";score=document.getElementById("bottom-text");score=score.style;score.visibility="visible";score=document.getElementById("inside-anchor");status=document.getElementById("bar-appendix");score.removeChild(status);
score=document.getElementById("alertbox");score=score.style;score.visibility="hidden"}
function Run(){var v12319=document.getElementById("main-banner");JAMScript.set(v12319,"innerHTML","Running Octane...");v12319=document.getElementById("bar-appendix");JAMScript.set(v12319,"innerHTML",'<br/><div class="progress progress-striped" id="progress-bar-container" style="visibility:hidden"><div class="bar"style="width: 0%;" id="progress-bar"></div></div>');var v12319=document.getElementById("run-octane"),parent=document.getElementById("main-container"),v12321=document.getElementById("inside-anchor");
JAMScript.call(parent.appendChild,parent,[v12321]);parent.removeChild(v12319);v12319=document.getElementById("startup-text");JAMScript.set(v12319,"innerHTML","");v12319=document.getElementById("progress-bar-container");v12319=v12319.style;v12319.visibility="visible";v12319={NotifyStart:ShowBox,NotifyError:AddError,NotifyResult:AddResult,NotifyScore:AddScore};JAMScript.call(BenchmarkSuite.RunSuites,BenchmarkSuite,[v12319,skipBenchmarks])}
function CheckCompatibility(){var v18785=typeof Uint8Array;if(v18785="undefined"!=v18785)if(v18785=typeof Float64Array,v18785="undefined"!=v18785)v18785=new Uint8Array(0),v18785=v18785.subarray,v18785=typeof v18785,v18785="undefined"!=v18785;if(v18785=!v18785)JAMScript.call(console.log,console,["Typed Arrays not supported"]),v18785=document.getElementById("alertbox"),v18785=v18785.style,v18785.display="block";v18785=window.document;v18785=v18785.URL;v18785=v18785.indexOf("skip_zlib=1");(v18785=0<=
v18785)&&JAMScript.call(skipBenchmarks.push,skipBenchmarks,["zlib"]);v18785=window.document;v18785=v18785.URL;v18785=v18785.indexOf("auto=1");(v18785=0<=v18785)&&Run()}function Load(){JAMScript.call(setTimeout,null,[CheckCompatibility,200])}var performance=performance||{},v12330=performance,v27445=v8();v12330.now=v27445;var v12331=BenchmarkResult.prototype;v12331.valueOf=v9;BenchmarkSuite.suites=[];BenchmarkSuite.version="9";BenchmarkSuite.config={doWarmup:void 0,doDeterministic:void 0};alert=v10;
BenchmarkSuite.ResetRNG=v13;BenchmarkSuite.RunSuites=v14;BenchmarkSuite.CountBenchmarks=v15;BenchmarkSuite.GeometricMean=v16;BenchmarkSuite.GeometricMeanTime=v17;BenchmarkSuite.GeometricMeanLatency=v18;BenchmarkSuite.FormatScore=v19;var v12332=BenchmarkSuite.prototype;v12332.NotifyStep=v20;var v12333=BenchmarkSuite.prototype;v12333.NotifyResult=v21;var v12334=BenchmarkSuite.prototype;v12334.NotifySkipped=v22;var v12335=BenchmarkSuite.prototype;v12335.NotifyError=v23;var v12336=BenchmarkSuite.prototype;
v12336.RunSingleBenchmark=v24;var v12337=BenchmarkSuite.prototype;v12337.RunStep=v25;
var v12338=[255011322],v18790=new Benchmark,v12339=[v18790],typescript=new BenchmarkSuite("Typescript",v12338,v12339),parseErrors=[],outfile={checksum:-412589664,cumulative_checksum:0,Write:v26,WriteLine:v27,Close:v28,Verify:v29},outerr={checksum:0,cumulative_checksum:0,Write:v30,WriteLine:v31,Close:v32,Verify:v33},v27697='//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nmodule TypeScript {\n    export class AstLogger {\n\n        constructor (public logger: ILogger) { }\n\n        public logScript(script: TypeScript.Script): void {\n            this.logLinemap(script.locationInfo.lineMap);\n\n            var stack: AST[]= [];\n\n            var pre = (cur: TypeScript.AST, parent: TypeScript.AST) => {\n                stack.push(cur);\n                var indent = (stack.length - 1) * 2;\n                this.logComments(script, cur.preComments, indent);\n                this.logNode(script, cur, indent);\n                this.logComments(script, cur.postComments, indent);\n                return cur;\n            }\n\n            var post = (cur: TypeScript.AST, parent: TypeScript.AST) => {\n                stack.pop();\n                return cur;\n            }\n\n            TypeScript.getAstWalkerFactory().walk(script, pre, post);\n        }\n\n\n        public logNode(script: TypeScript.Script, cur: TypeScript.AST, indent: number) {\n            var msg = this.addPadding("", indent, "| ", true);\n\n            msg = msg.concat("+ " + cur.treeViewLabel());\n            msg = this.addPadding(msg, 70, " ", false);\n\n            msg = msg + this.addLineColumn(script, cur.minChar);\n            msg = this.addPadding(msg, 80, " ", false);\n\n            msg = msg + "=> ";\n            msg = msg + this.addLineColumn(script, cur.limChar);\n            msg = this.addPadding(msg, 102, " ", false);\n\n            msg = msg.concat("[" + this.addPadding(cur.minChar.toString(), 1, " ", true) + ", " + this.addPadding(cur.limChar.toString(), 1, " ", true) + "]");\n\n            msg = this.addPadding(msg, 115, " ", false);\n            msg = msg.concat("sym=" + (<any>cur).sym);\n\n            msg = this.addPadding(msg, 135, " ", false);\n            msg = msg.concat("type=" + (cur.type === null ? "null" : cur.type.getTypeName()));\n            this.logger.log(msg);\n        }\n\n        private logComments(script: TypeScript.Script, comments: TypeScript.AST[], indent: number) {\n            if (comments == null)\n                return;\n\n            for (var i = 0; i < comments.length; i++) {\n                this.logNode(script, comments[i], indent);\n            }\n        }\n\n        public logLinemap(linemap: number[]) {\n            var result = "[";\n            for (var i = 0; i < linemap.length; i++) {\n                if (i > 0)\n                    result += ",";\n                result += linemap[i];\n            }\n            result += "]";\n            this.logger.log("linemap: " + result);\n        }\n\n        private addPadding(s: string, targetLength: number, paddingString: string, leftPadding: bool): string {\n            var result = (leftPadding ? "" : s);\n            for (var i = s.length; i < targetLength; i++) {\n                result = result + paddingString;\n            }\n            result = result + (leftPadding ? s : "");\n            return result;\n        }\n\n        private addLineColumn(script: TypeScript.Script, position: number): string {\n            // just for calling getSourceLineColFromMap\n            var lineInfo = {\n                line: -1,\n                col: -1\n            }\n            TypeScript.getSourceLineColFromMap(lineInfo, position, script.locationInfo.lineMap);\n\n            if (lineInfo.col !== -1) {\n                lineInfo.col++; //TODO: function above seems to consider line as 1-based, and column as 0-based\n            }\n\n            return "(" + lineInfo.line + ", " + lineInfo.col + ")";\n        }\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export function lastOf(items: any[]): any {\n        return (items === null || items.length === 0) ? null : items[items.length - 1];\n    }\n\n    export function max(a: number, b: number): number {\n        return a >= b ? a : b;\n    }\n\n    export function min(a: number, b: number): number {\n        return a <= b ? a : b;\n    }\n\n    //\n    // Helper class representing a path from a root ast node to a (grand)child ast node.\n    // This is helpful as our tree don\'t have parents.\n    //\n    export class AstPath {\n        public asts: TypeScript.AST[] = [];\n        public top: number = -1;\n\n        static reverseIndexOf(items: any[], index: number): any {\n            return (items === null || items.length <= index) ? null : items[items.length - index - 1];\n        }\n\n        public clone(): AstPath {\n            var clone = new AstPath();\n            clone.asts = this.asts.map((value) => { return value; });\n            clone.top = this.top;\n            return clone;\n        }\n\n        public pop(): TypeScript.AST {\n            var head = this.ast();\n            this.up();\n\n            while (this.asts.length > this.count()) {\n                this.asts.pop();\n            }\n            return head;\n        }\n\n        public push(ast: TypeScript.AST) {\n            while (this.asts.length > this.count()) {\n                this.asts.pop();\n            }\n            this.top = this.asts.length;\n            this.asts.push(ast);\n        }\n\n        public up() {\n            if (this.top <= -1)\n                throw new Error("Invalid call to \'up\'");\n            this.top--;\n        }\n\n        public down() {\n            if (this.top == this.ast.length - 1)\n                throw new Error("Invalid call to \'down\'");\n            this.top++;\n        }\n\n        public nodeType(): TypeScript.NodeType {\n            if (this.ast() == null)\n                return TypeScript.NodeType.None;\n            return this.ast().nodeType;\n        }\n\n        public ast() {\n            return <TypeScript.AST>AstPath.reverseIndexOf(this.asts, this.asts.length - (this.top + 1));\n        }\n\n        public parent() {\n            return <TypeScript.AST>AstPath.reverseIndexOf(this.asts, this.asts.length - this.top);\n        }\n\n        public count() {\n            return this.top + 1;\n        }\n\n        public get(index: number): TypeScript.AST {\n            return this.asts[index];\n        }\n\n        public isNameOfClass(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === TypeScript.NodeType.Name) &&\n                (this.parent().nodeType === TypeScript.NodeType.ClassDeclaration) &&\n                ((<TypeScript.InterfaceDeclaration>this.parent()).name === this.ast());\n        }\n\n        public isNameOfInterface(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === TypeScript.NodeType.Name) &&\n                (this.parent().nodeType === TypeScript.NodeType.InterfaceDeclaration) &&\n                ((<TypeScript.InterfaceDeclaration>this.parent()).name === this.ast());\n        }\n\n        public isNameOfArgument(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === TypeScript.NodeType.Name) &&\n                (this.parent().nodeType === TypeScript.NodeType.ArgDecl) &&\n                ((<TypeScript.ArgDecl>this.parent()).id === this.ast());\n        }\n\n        public isNameOfVariable(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === TypeScript.NodeType.Name) &&\n                (this.parent().nodeType === Ty',v27696=
v27697+"peScript.NodeType.VarDecl) &&\n                ((<TypeScript.VarDecl>this.parent()).id === this.ast());\n        }\n\n        public isNameOfModule(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === TypeScript.NodeType.Name) &&\n                (this.parent().nodeType === TypeScript.NodeType.ModuleDeclaration) &&\n                ((<TypeScript.ModuleDeclaration>this.parent()).name === this.ast());\n        }\n\n        public isNameOfFunction(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === TypeScript.NodeType.Name) &&\n                (this.parent().nodeType === TypeScript.NodeType.FuncDecl) &&\n                ((<TypeScript.FuncDecl>this.parent()).name === this.ast());\n        }\n\n        public isChildOfScript(): bool {\n            var ast = lastOf(this.asts);\n            return this.count() >= 3 &&\n                this.asts[this.top] === ast &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.Script;\n        }\n\n        public isChildOfModule(): bool {\n            var ast = lastOf(this.asts);\n            return this.count() >= 3 &&\n                this.asts[this.top] === ast &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.ModuleDeclaration;\n        }\n\n        public isChildOfClass(): bool {\n            var ast = lastOf(this.asts);\n            return this.count() >= 3 &&\n                this.asts[this.top] === ast &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.ClassDeclaration;\n        }\n\n        public isArgumentOfClassConstructor(): bool {\n            var ast = lastOf(this.asts);\n            return this.count() >= 5 &&\n                this.asts[this.top] === ast &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.FuncDecl &&\n                this.asts[this.top - 3].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 4].nodeType === TypeScript.NodeType.ClassDeclaration &&\n                ((<TypeScript.FuncDecl>this.asts[this.top - 2]).isConstructor) &&\n                ((<TypeScript.FuncDecl>this.asts[this.top - 2]).arguments === this.asts[this.top - 1]) &&\n                ((<TypeScript.ClassDeclaration>this.asts[this.top - 4]).constructorDecl === this.asts[this.top - 2]);\n        }\n\n        public isChildOfInterface(): bool {\n            var ast = lastOf(this.asts);\n            return this.count() >= 3 &&\n                this.asts[this.top] === ast &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.InterfaceDeclaration;\n        }\n\n        public isTopLevelImplicitModule() {\n            return this.count() >= 1 &&\n                this.asts[this.top].nodeType === TypeScript.NodeType.ModuleDeclaration &&\n                TypeScript.hasFlag((<TypeScript.ModuleDeclaration>this.asts[this.top]).modFlags, TypeScript.ModuleFlags.IsWholeFile);\n        }\n\n        public isBodyOfTopLevelImplicitModule() {\n            return this.count() >= 2 &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ModuleDeclaration &&\n                 (<TypeScript.ModuleDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0] &&\n                TypeScript.hasFlag((<TypeScript.ModuleDeclaration>this.asts[this.top - 1]).modFlags, TypeScript.ModuleFlags.IsWholeFile);\n        }\n\n        public isBodyOfScript(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Script &&\n                 (<TypeScript.Script>this.asts[this.top - 1]).bod == this.asts[this.top - 0];\n        }\n\n        public isBodyOfSwitch(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Switch &&\n                 (<TypeScript.SwitchStatement>this.asts[this.top - 1]).caseList == this.asts[this.top - 0];\n        }\n\n        public isBodyOfModule(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ModuleDeclaration &&\n                 (<TypeScript.ModuleDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0];\n        }\n\n        public isBodyOfClass(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ClassDeclaration &&\n                 (<T",
v27695=v27696+"ypeScript.ClassDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0];\n        }\n\n        public isBodyOfFunction(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.FuncDecl &&\n                 (<TypeScript.FuncDecl>this.asts[this.top - 1]).bod == this.asts[this.top - 0];\n        }\n\n        public isBodyOfInterface(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.InterfaceDeclaration &&\n                 (<TypeScript.InterfaceDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0];\n        }\n\n        public isBodyOfBlock(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Block &&\n                (<TypeScript.Block>this.asts[this.top - 1]).statements == this.asts[this.top - 0];\n        }\n\n        public isBodyOfFor(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.For &&\n                (<TypeScript.ForStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfCase(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Case &&\n                (<TypeScript.CaseStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfTry(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Try &&\n                (<TypeScript.Try>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfCatch(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Catch &&\n                (<TypeScript.Catch>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfDoWhile(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.DoWhile &&\n                (<TypeScript.DoWhileStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfWhile(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.While &&\n                (<TypeScript.WhileStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfForIn(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ForIn &&\n                (<TypeScript.ForInStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfWith(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.With &&\n                (<TypeScript.WithStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfFinally(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Finally &&\n                (<TypeScript.Finally>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isCaseOfSwitch(): bool {\n            return this.count() >= 3 &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.Switch &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                (<TypeScript.SwitchStatement>this.asts[this.top - 2]).caseList == this.asts[this.top - 1];\n        }\n\n        public isDefaultCaseOfSwitch(): bool {\n            return this.count() >= 3 &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.Switch &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                (<TypeScript.SwitchStatement>this.asts[this.top - 2]).caseList == this.asts[this.top - 1] &&\n                (<TypeScript.SwitchStatement>this.asts[this.top - 2]).defaultCase == this.asts[this.top - 0];\n        }\n\n        public isListOfObjectLit(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ObjectLit &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&\n                (<TypeScript.UnaryExpression>this.asts[this.top - 1]).operand == this.asts[this.top - 0];\n        }\n\n        public isBodyOfObjectLit(): bool {\n            return this.isListOfObjectLit();\n        }\n\n        public isEmptyListOfObjectLit(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ObjectLit &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&\n                (<TypeScript.UnaryExpression>this.asts[t",
v27694=v27695+"his.top - 1]).operand == this.asts[this.top - 0] &&\n                (<TypeScript.ASTList>this.asts[this.top - 0]).members.length == 0;\n        }\n\n        public isMemberOfObjectLit(): bool {\n            return this.count() >= 3 &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.ObjectLit &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.Member &&\n                (<TypeScript.UnaryExpression>this.asts[this.top - 2]).operand == this.asts[this.top - 1];\n        }\n\n        public isNameOfMemberOfObjectLit(): bool {\n            return this.count() >= 4 &&\n                this.asts[this.top - 3].nodeType === TypeScript.NodeType.ObjectLit &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Member &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.Name &&\n                (<TypeScript.UnaryExpression>this.asts[this.top - 3]).operand == this.asts[this.top - 2];\n        }\n\n        public isListOfArrayLit(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ArrayLit &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&\n                (<TypeScript.UnaryExpression>this.asts[this.top - 1]).operand == this.asts[this.top - 0];\n        }\n\n        public isTargetOfMember(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Member &&\n                (<TypeScript.BinaryExpression>this.asts[this.top - 1]).operand1 === this.asts[this.top - 0];\n        }\n\n        public isMemberOfMember(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Member &&\n                (<TypeScript.BinaryExpression>this.asts[this.top - 1]).operand2 === this.asts[this.top - 0];\n        }\n\n        public isItemOfList(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List;\n            //(<Tools.ASTList>this.asts[this.top - 1]).operand2 === this.asts[this.top - 0];\n        }\n\n        public isThenOfIf(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.If &&\n                (<TypeScript.IfStatement>this.asts[this.top - 1]).thenBod == this.asts[this.top - 0];\n        }\n\n        public isElseOfIf(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.If &&\n                (<TypeScript.IfStatement>this.asts[this.top - 1]).elseBod == this.asts[this.top - 0];\n        }\n\n        public isBodyOfDefaultCase(): bool {\n            return this.isBodyOfCase();\n        }\n\n        public isSingleStatementList(): bool {\n            return this.count() >= 1 &&\n                this.asts[this.top].nodeType === TypeScript.NodeType.List &&\n                (<TypeScript.ASTList>this.asts[this.top]).members.length === 1;\n        }\n\n        public isArgumentListOfFunction(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.FuncDecl &&\n                (<TypeScript.FuncDecl>this.asts[this.top - 1]).arguments === this.asts[this.top - 0];\n        }\n\n        public isArgumentOfFunction(): bool {\n            return this.count() >= 3 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.FuncDecl &&\n                (<TypeScript.FuncDecl>this.asts[this.top - 2]).arguments === this.asts[this.top - 1];\n        }\n\n        public isArgumentListOfCall(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Call &&\n                (<TypeScript.CallExpression>this.asts[this.top - 1]).arguments === this.asts[this.top - 0];\n        }\n\n        public isArgumentListOfNew(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.New &&\n                (<TypeScript.CallExpression>this.asts[this.top - 1]).arguments === this.asts[this.top - 0];\n        }\n\n        public isSynthesizedBlock(): bool {\n            return this.count() >= 1 &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.Block &&\n                (<TypeScript.Block>this.asts[this.top - 0]).isStatementBlock === false;\n        }\n    }\n\n    export function isValidAstNode(ast: Typ",
v27693=v27694+'eScript.ASTSpan): bool {\n        if (ast === null)\n            return false;\n\n        if (ast.minChar === -1 || ast.limChar === -1)\n            return false;\n\n        return true;\n    }\n\n    export class AstPathContext {\n        public path = new TypeScript.AstPath();\n    }\n\n    export enum GetAstPathOptions {\n        Default = 0,\n        EdgeInclusive = 1,\n        //We need this options dealing with an AST coming from an incomplete AST. For example:\n        //     class foo { // r\n        // If we ask for the AST at the position after the "r" character, we won\'t see we are \n        // inside a comment, because the "class" AST node has a limChar corresponding to the position of \n        // the "{" character, meaning we don\'t traverse the tree down to the stmt list of the class, meaning\n        // we don\'t find the "precomment" attached to the errorneous empty stmt.\n        //TODO: It would be nice to be able to get rid of this.\n        DontPruneSearchBasedOnPosition = 1 << 1,\n    }\n\n    ///\n    /// Return the stack of AST nodes containing "position"\n    ///\n    export function getAstPathToPosition(script: TypeScript.AST, pos: number, options = GetAstPathOptions.Default): TypeScript.AstPath {\n        var lookInComments = (comments: TypeScript.Comment[]) => {\n            if (comments && comments.length > 0) {\n                for (var i = 0; i < comments.length; i++) {\n                    var minChar = comments[i].minChar;\n                    var limChar = comments[i].limChar;\n                    if (!comments[i].isBlockComment) {\n                        limChar++; // For single line comments, include 1 more character (for the newline)\n                    }\n                    if (pos >= minChar && pos < limChar) {\n                        ctx.path.push(comments[i]);\n                    }\n                }\n            }\n        }\n\n        var pre = function (cur: TypeScript.AST, parent: TypeScript.AST, walker: IAstWalker) {\n            if (isValidAstNode(cur)) {\n\n                // Add "cur" to the stack if it contains our position\n                // For "identifier" nodes, we need a special case: A position equal to "limChar" is\n                // valid, since the position corresponds to a caret position (in between characters)\n                // For example:\n                //  bar\n                //  0123\n                // If "position == 3", the caret is at the "right" of the "r" character, which should be considered valid\n                var inclusive =\n                    hasFlag(options, GetAstPathOptions.EdgeInclusive) ||\n                    cur.nodeType === TypeScript.NodeType.Name ||\n                    pos === script.limChar; // Special "EOF" case\n\n                var minChar = cur.minChar;\n                var limChar = cur.limChar + (inclusive ? 1 : 0)\n                if (pos >= minChar && pos < limChar) {\n\n                    // TODO: Since AST is sometimes not correct wrt to position, only add "cur" if it\'s better\n                    //       than top of the stack.\n                    var previous = ctx.path.ast();\n                    if (previous == null || (cur.minChar >= previous.minChar && cur.limChar <= previous.limChar)) {\n                        ctx.path.push(cur);\n                    }\n                    else {\n                        //logger.log("TODO: Ignoring node because minChar, limChar not better than previous node in stack");\n                    }\n                }\n\n                // The AST walker skips comments, but we might be in one, so check the pre/post comments for this node manually\n                if (pos < limChar) {\n                    lookInComments(cur.preComments);\n                }\n                if (pos >= minChar) {\n                    lookInComments(cur.postComments);\n                }\n\n                if (!hasFlag(options, GetAstPathOptions.DontPruneSearchBasedOnPosition)) {\n                    // Don\'t go further down the tree if pos is outside of [minChar, limChar]\n                    walker.options.goChildren = (minChar <= pos && pos <= limChar);\n                }\n            }\n            return cur;\n        }\n\n        var ctx = new AstPathContext();\n        TypeScript.getAstWalkerFactory().walk(script, pre, null, null, ctx);\n        return ctx.path;\n    }\n\n    //\n    // Find a source text offset that is safe for lexing tokens at the given position.\n    // This is used when "position" might be inside a comment or string, etc.\n    //\n    export function getTokenizationOffset(script: TypeScript.Script, position: number): number {\n        var bestOffset = 0;\n        var pre = (cur: TypeScript.AST, parent: TypeScript.AST, walker: TypeScript.IAstWalker): TypeScript.AST => {\n            if (TypeScript.isValidAstNode(cur)) {\n                // Did we find a closer offset?\n                if (cur.minChar <= position) {\n                    bestOffset = max(bestOffset, cur.minChar);\n                }\n\n                // Stop the walk if this node is not related to ',
v27692=v27693+'"minChar"\n                if (cur.minChar > position || cur.limChar < bestOffset) {\n                    walker.options.goChildren = false;\n                }\n            }\n\n            return cur;\n        }\n\n        TypeScript.getAstWalkerFactory().walk(script, pre);\n        return bestOffset;\n    }\n\n    ///\n    /// Simple function to Walk an AST using a simple callback function.\n    ///\n    export function walkAST(ast: TypeScript.AST, callback: (path: AstPath, walker: TypeScript.IAstWalker) => void ): void {\n        var pre = function (cur: TypeScript.AST, parent: TypeScript.AST, walker: TypeScript.IAstWalker) {\n            var path: TypeScript.AstPath = walker.state;\n            path.push(cur);\n            callback(path, walker);\n            return cur;\n        }\n        var post = function (cur: TypeScript.AST, parent: TypeScript.AST, walker: TypeScript.IAstWalker) {\n            var path: TypeScript.AstPath = walker.state;\n            path.pop();\n            return cur;\n        }\n\n        var path = new AstPath();\n        TypeScript.getAstWalkerFactory().walk(ast, pre, post, null, path);\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class ASTSpan {\n        public minChar: number = -1;  // -1 = "undefined" or "compiler generated"\n        public limChar: number = -1;  // -1 = "undefined" or "compiler generated"   \n    }\n\n    export class AST extends ASTSpan {\n        public type: Type = null;\n        public flags = ASTFlags.Writeable;\n\n        // REVIEW: for diagnostic purposes\n        public passCreated: number = CompilerDiagnostics.analysisPass;\n\n        public preComments: Comment[] = null;\n        public postComments: Comment[] = null;\n        private docComments: Comment[] = null;\n\n        public isParenthesized = false;\n\n        constructor (public nodeType: NodeType) {\n            super();\n        }\n\n        public isExpression() { return false; }\n\n        public isStatementOrExpression() { return false; }\n\n        public isCompoundStatement() { return false; }\n\n        public isLeaf() { return this.isStatementOrExpression() && (!this.isCompoundStatement()); }\n        \n        public isDeclaration() { return false; }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            switch (this.nodeType) {\n                case NodeType.Error:\n                case NodeType.EmptyExpr:\n                    this.type = typeFlow.anyType;\n                    break;\n                case NodeType.This:\n                    return typeFlow.typeCheckThis(this);\n                case NodeType.Null:\n                    this.type = typeFlow.nullType;\n                    break;\n                case NodeType.False:\n                case NodeType.True:\n                    this.type = typeFlow.booleanType;\n                    break;\n                case NodeType.Super:\n                    return typeFlow.typeCheckSuper(this);\n                case NodeType.EndCode:\n                case NodeType.Empty:\n                case NodeType.Void:\n                    this.type = typeFlow.voidType;\n                    break;\n                default:\n                    throw new Error("please implement in derived class");\n            }\n            return this;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            switch (this.nodeType) {\n                case NodeType.This:\n                    emitter.recordSourceMappingStart(this);\n                    if (emitter.thisFnc && (hasFlag(emitter.thisFnc.fncFlags, FncFlags.IsFatArrowFunction))) {\n                        emitter.writeToOutput("_this");\n                    }\n                    else {\n                        emitter.writeToOutput("this");\n                    }\n                    emitter.recordSourceMappingEnd(this);\n                    break;\n                case NodeType.Null:\n                    emitter.recordSourceMappingStart(this);\n                    emitter.writeToOutput("null");\n                    emitter.recordSourceMappingEnd(this);\n                    break;\n                case NodeType.False:\n                    emitter.recordSourceMappingStart(this);\n                    emitter.writeToOutput("false");\n                    emitter.recordSourceMappingEnd(this);\n                    break;\n                case NodeType.True',
v27691=v27692+':\n                    emitter.recordSourceMappingStart(this);\n                    emitter.writeToOutput("true");\n                    emitter.recordSourceMappingEnd(this);\n                    break;\n                case NodeType.Super:\n                    emitter.recordSourceMappingStart(this);\n                    emitter.emitSuperReference();\n                    emitter.recordSourceMappingEnd(this);\n                    break;\n                case NodeType.EndCode:\n                case NodeType.Error:\n                case NodeType.EmptyExpr:\n                    break;\n                case NodeType.Empty:\n                    emitter.recordSourceMappingStart(this);\n                    emitter.recordSourceMappingEnd(this);\n                    break;\n                case NodeType.Void:\n                    emitter.recordSourceMappingStart(this);\n                    emitter.writeToOutput("void ");\n                    emitter.recordSourceMappingEnd(this);\n                    break;\n                default:\n                    throw new Error("please implement in derived class");\n            }\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public print(context: PrintContext) {\n            context.startLine();\n            var lineCol = { line: -1, col: -1 };\n            var limLineCol = { line: -1, col: -1 };\n            if (context.parser !== null) {\n                context.parser.getSourceLineCol(lineCol, this.minChar);\n                context.parser.getSourceLineCol(limLineCol, this.limChar);\n                context.write("(" + lineCol.line + "," + lineCol.col + ")--" +\n                              "(" + limLineCol.line + "," + limLineCol.col + "): ");\n            }\n            var lab = this.printLabel();\n            if (hasFlag(this.flags, ASTFlags.Error)) {\n                lab += " (Error)";\n            }\n            context.writeLine(lab);\n        }\n\n        public printLabel() {\n            if (nodeTypeTable[this.nodeType] !== undefined) {\n                return nodeTypeTable[this.nodeType];\n            }\n            else {\n                return (<any>NodeType)._map[this.nodeType];\n            }\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            // by default, AST adds itself to current basic block and does not check its children\n            context.walker.options.goChildren = false;\n            context.addContent(this);\n        }\n\n        public netFreeUses(container: Symbol, freeUses: StringHashTable) {\n        }\n\n        public treeViewLabel() {\n            return (<any>NodeType)._map[this.nodeType];\n        }\n\n        public static getResolvedIdentifierName(name: string): string {\n            if (!name) return "";\n\n            var resolved = "";\n            var start = 0;\n            var i = 0;\n            while(i <= name.length - 6) {\n                // Look for escape sequence \\uxxxx\n                if (name.charAt(i) == \'\\\\\' && name.charAt(i+1) == \'u\') {\n                    var charCode = parseInt(name.substr(i + 2, 4), 16);\n                    resolved += name.substr(start, i - start);\n                    resolved += String.fromCharCode(charCode);\n                    i += 6;\n                    start = i;\n                    continue;\n                } \n                i++;\n            }\n            // Append remaining string\n            resolved += name.substring(start);\n            return resolved;\n        }\n\n        public getDocComments() : Comment[] {\n            if (!this.isDeclaration() || !this.preComments || this.preComments.length == 0) {\n                return [];\n            }\n\n            if (!this.docComments) {\n                var preCommentsLength = this.preComments.length;\n                var docComments: Comment[] = [];\n                for (var i = preCommentsLength - 1; i >= 0; i--) {\n                    if (this.preComments[i].isDocComment()) {\n                        var prevDocComment = docComments.length > 0 ? docComments[docComments.length - 1] : null;\n                        if (prevDocComment == null || // If the help comments were not yet set then this is the comment\n                             (this.preComments[i].limLine == prevDocComment.minLine ||\n                              this.preComments[i].limLine + 1 == prevDocComment.minLine)) { // On same line or next line\n                            docComments.push(this.preComments[i]);\n                            continue;\n                        }\n                    }\n                    break;\n                }\n\n                this.docComments = docComments.reverse();\n            }\n\n            return this.docComments;\n        }\n    }\n\n    export class IncompleteAST extends AST {\n        constructor (min: number, lim: number) {\n            super(NodeType.Error);\n\n            this.minChar = min;\n            this.limChar = lim;\n        }\n    }\n\n    export class ASTList extends AST {\n        public enclosingScope: SymbolScope = null;\n        publ',
v27690=v27691+"ic members: AST[] = new AST[];\n\n        constructor () {\n            super(NodeType.List);\n        }\n\n        public addToControlFlow(context: ControlFlowContext) {\n            var len = this.members.length;\n            for (var i = 0; i < len; i++) {\n                if (context.noContinuation) {\n                    context.addUnreachable(this.members[i]);\n                    break;\n                }\n                else {\n                    this.members[i] = context.walk(this.members[i], this);\n                }\n            }\n            context.walker.options.goChildren = false;\n        }\n\n        public append(ast: AST) {\n            this.members[this.members.length] = ast;\n            return this;\n        }\n\n        public appendAll(ast: AST) {\n            if (ast.nodeType == NodeType.List) {\n                var list = <ASTList>ast;\n                for (var i = 0, len = list.members.length; i < len; i++) {\n                    this.append(list.members[i]);\n                }\n            }\n            else {\n                this.append(ast);\n            }\n            return this;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.recordSourceMappingStart(this);\n            emitter.emitJavascriptList(this, null, TokenID.Semicolon, startLine, false, false);\n            emitter.recordSourceMappingEnd(this);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            var len = this.members.length;\n            typeFlow.nestingLevel++;\n            for (var i = 0; i < len; i++) {\n                if (this.members[i]) {\n                    this.members[i] = this.members[i].typeCheck(typeFlow);\n                }\n            }\n            typeFlow.nestingLevel--;\n            return this;\n        }\n    }\n\n    export class Identifier extends AST {\n        public sym: Symbol = null;\n        public cloId = -1;\n        public text: string;\n\n        // 'actualText' is the text that the user has entered for the identifier. the text might \n        // include any Unicode escape sequences (e.g.: \\u0041 for 'A'). 'text', however, contains \n        // the resolved value of any escape sequences in the actual text; so in the previous \n        // example, actualText = '\\u0041', text = 'A'.\n        //\n        // For purposes of finding a symbol, use text, as this will allow you to match all \n        // variations of the variable text. For full-fidelity translation of the user input, such\n        // as emitting, use the actualText field.\n        // \n        // Note: \n        //    To change text, and to avoid running into a situation where 'actualText' does not \n        //    match 'text', always use setText.\n        constructor (public actualText: string, public hasEscapeSequence?: bool) {\n            super(NodeType.Name);\n            this.setText(actualText, hasEscapeSequence);\n        }\n\n        public setText(actualText: string, hasEscapeSequence?: bool) {\n            this.actualText = actualText;\n            if (hasEscapeSequence) {\n                this.text = AST.getResolvedIdentifierName(actualText);\n            }\n            else {\n                this.text = actualText;\n            }\n        }\n\n        public isMissing() { return false; }\n        public isLeaf() { return true; }\n\n        public treeViewLabel() {\n            return \"id: \" + this.actualText;\n        }\n\n        public printLabel() {\n            if (this.actualText) {\n                return \"id: \" + this.actualText;\n            }\n            else {\n                return \"name node\";\n            }\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckName(this);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitJavascriptName(this, true);\n        }\n\n        public static fromToken(token: Token): Identifier {\n            return new Identifier(token.getText(), (<IdentifierToken>token).hasEscapeSequence);\n        }\n    }\n\n    export class MissingIdentifier extends Identifier {\n        constructor () {\n            super(\"__missing\");\n        }\n\n        public isMissing() {\n            return true;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            // Emit nothing for a missing ID\n        }\n    }\n\n    export class Label extends AST {\n        constructor (public id: Identifier) {\n            super(NodeType.Label);\n        }\n\n        public printLabel() { return this.id.actualText + \":\"; }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.type = typeFlow.voidType;\n            return this;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.recordSourceMappingStart(this.id);\n            emitter.writeToOutput(this.id.actualText);\n            emitter.recordSourceMappingEnd(this.id);",
v27689=v27690+'\n            emitter.writeLineToOutput(":");\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export class Expression extends AST {\n        constructor (nodeType: NodeType) {\n            super(nodeType);\n        }\n\n        public isExpression() { return true; }\n\n        public isStatementOrExpression() { return true; }\n    }\n\n    export class UnaryExpression extends Expression {\n        public targetType: Type = null; // Target type for an object literal (null if no target type)\n        public castTerm: AST = null;\n\n        constructor (nodeType: NodeType, public operand: AST) {\n            super(nodeType);\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            super.addToControlFlow(context);\n            // TODO: add successor as catch block/finally block if present\n            if (this.nodeType == NodeType.Throw) {\n                context.returnStmt();\n            }\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            switch (this.nodeType) {\n                case NodeType.Not:\n                    return typeFlow.typeCheckBitNot(this);\n\n                case NodeType.LogNot:\n                    return typeFlow.typeCheckLogNot(this);\n\n                case NodeType.Pos:\n                case NodeType.Neg:\n                    return typeFlow.typeCheckUnaryNumberOperator(this);\n\n                case NodeType.IncPost:\n                case NodeType.IncPre:\n                case NodeType.DecPost:\n                case NodeType.DecPre:\n                    return typeFlow.typeCheckIncOrDec(this);\n\n                case NodeType.ArrayLit:\n                    typeFlow.typeCheckArrayLit(this);\n                    return this;\n\n                case NodeType.ObjectLit:\n                    typeFlow.typeCheckObjectLit(this);\n                    return this;\n\n                case NodeType.Throw:\n                    this.operand = typeFlow.typeCheck(this.operand);\n                    this.type = typeFlow.voidType;\n                    return this;\n\n                case NodeType.Typeof:\n                    this.operand = typeFlow.typeCheck(this.operand);\n                    this.type = typeFlow.stringType;\n                    return this;\n\n                case NodeType.Delete:\n                    this.operand = typeFlow.typeCheck(this.operand);\n                    this.type = typeFlow.booleanType;\n                    break;\n\n                case NodeType.TypeAssertion:\n                    this.castTerm = typeFlow.typeCheck(this.castTerm);\n                    var applyTargetType = !this.operand.isParenthesized;\n\n                    var targetType = applyTargetType ? this.castTerm.type : null;\n\n                    typeFlow.checker.typeCheckWithContextualType(targetType, typeFlow.checker.inProvisionalTypecheckMode(), true, this.operand);\n                    typeFlow.castWithCoercion(this.operand, this.castTerm.type, false, true);\n                    this.type = this.castTerm.type;\n                    return this;\n\n                case NodeType.Void:\n                    // REVIEW - Although this is good to do for completeness\'s sake,\n                    // this shouldn\'t be strictly necessary from the void operator\'s\n                    // point of view\n                    this.operand = typeFlow.typeCheck(this.operand);\n                    this.type = typeFlow.checker.undefinedType;\n                    break;\n\n                default:\n                    throw new Error("please implement in derived class");\n            }\n            return this;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            switch (this.nodeType) {\n                case NodeType.IncPost:\n                    emitter.emitJavascript(this.operand, TokenID.PlusPlus, false);\n                    emitter.writeToOutput("++");\n                    break;\n                case NodeType.LogNot:\n                    emitter.writeToOutput("!");\n                    emitter.emitJavascript(this.operand, TokenID.Exclamation, false);\n                    break;\n                case NodeType.DecPost:\n                    emitter.emitJavascript(this.operand, TokenID.MinusMinus, false);\n                    emitter.writeToOutput("--");\n                    break;\n                case NodeType.ObjectLit:\n                    emitter.emitObjectLiteral(<ASTList>this.operand);\n                    break;\n                case NodeType.ArrayLit:\n                    emitter.emitArrayLiteral(<ASTList>this.operand);\n                    break;\n                case NodeType.Not:\n                    emitter.writeToOutput("~");\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    break;\n                case NodeType.Neg:\n                    emitter.writeToOutput("-"',
v27688=v27689+');\n                    if (this.operand.nodeType == NodeType.Neg) {\n                        this.operand.isParenthesized = true;\n                    }\n                    emitter.emitJavascript(this.operand, TokenID.Minus, false);\n                    break;\n                case NodeType.Pos:\n                    emitter.writeToOutput("+");\n                    if (this.operand.nodeType == NodeType.Pos) {\n                        this.operand.isParenthesized = true;\n                    }\n                    emitter.emitJavascript(this.operand, TokenID.Plus, false);\n                    break;\n                case NodeType.IncPre:\n                    emitter.writeToOutput("++");\n                    emitter.emitJavascript(this.operand, TokenID.PlusPlus, false);\n                    break;\n                case NodeType.DecPre:\n                    emitter.writeToOutput("--");\n                    emitter.emitJavascript(this.operand, TokenID.MinusMinus, false);\n                    break;\n                case NodeType.Throw:\n                    emitter.writeToOutput("throw ");\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    emitter.writeToOutput(";");\n                    break;\n                case NodeType.Typeof:\n                    emitter.writeToOutput("typeof ");\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    break;\n                case NodeType.Delete:\n                    emitter.writeToOutput("delete ");\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    break;\n                case NodeType.Void:\n                    emitter.writeToOutput("void ");\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    break;\n                case NodeType.TypeAssertion:\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    break;\n                default:\n                    throw new Error("please implement in derived class");\n            }\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export class CallExpression extends Expression {\n        constructor (nodeType: NodeType,\n                     public target: AST,\n                     public arguments: ASTList) {\n            super(nodeType);\n            this.minChar = this.target.minChar;\n        }\n\n        public signature: Signature = null;\n\n        public typeCheck(typeFlow: TypeFlow) {\n            if (this.nodeType == NodeType.New) {\n                return typeFlow.typeCheckNew(this);\n            }\n            else {\n                return typeFlow.typeCheckCall(this);\n            }\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n\n            if (this.nodeType == NodeType.New) {\n                emitter.emitNew(this.target, this.arguments);\n            }\n            else {\n                emitter.emitCall(this, this.target, this.arguments);\n            }\n\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export class BinaryExpression extends Expression {\n        constructor (nodeType: NodeType, public operand1: AST, public operand2: AST) {\n            super(nodeType);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            switch (this.nodeType) {\n                case NodeType.Dot:\n                    return typeFlow.typeCheckDotOperator(this);\n                case NodeType.Asg:\n                    return typeFlow.typeCheckAsgOperator(this);\n                case NodeType.Add:\n                case NodeType.Sub:\n                case NodeType.Mul:\n                case NodeType.Div:\n                case NodeType.Mod:\n                case NodeType.Or:\n                case NodeType.And:\n                    return typeFlow.typeCheckArithmeticOperator(this, false);\n                case NodeType.Xor:\n                    return typeFlow.typeCheckBitwiseOperator(this, false);\n                case NodeType.Ne:\n                case NodeType.Eq:\n                    var text: string;\n                    if (typeFlow.checker.styleSettings.eqeqeq) {\n                        text = nodeTypeTable[this.nodeType];\n                        typeFlow.checker.errorReporter.styleError(this, "use of " + text);\n                    }\n                    else if (typeFlow.checker.styleSettings.eqnull) {\n                        text = nodeTypeTable[this.nodeType];\n                        if ((this.operand2 !== null) && (this.operand2.nodeType == NodeType.Null)) {\n                            typeFlow.checker.errorReporter.styleError(this, "use of " + text + " to compare with null");\n                        }\n                    }\n         ',
v27687=v27688+'       case NodeType.Eqv:\n                case NodeType.NEqv:\n                case NodeType.Lt:\n                case NodeType.Le:\n                case NodeType.Ge:\n                case NodeType.Gt:\n                    return typeFlow.typeCheckBooleanOperator(this);\n                case NodeType.Index:\n                    return typeFlow.typeCheckIndex(this);\n                case NodeType.Member:\n                    this.type = typeFlow.voidType;\n                    return this;\n                case NodeType.LogOr:\n                    return typeFlow.typeCheckLogOr(this);\n                case NodeType.LogAnd:\n                    return typeFlow.typeCheckLogAnd(this);\n                case NodeType.AsgAdd:\n                case NodeType.AsgSub:\n                case NodeType.AsgMul:\n                case NodeType.AsgDiv:\n                case NodeType.AsgMod:\n                case NodeType.AsgOr:\n                case NodeType.AsgAnd:\n                    return typeFlow.typeCheckArithmeticOperator(this, true);\n                case NodeType.AsgXor:\n                    return typeFlow.typeCheckBitwiseOperator(this, true);\n                case NodeType.Lsh:\n                case NodeType.Rsh:\n                case NodeType.Rs2:\n                    return typeFlow.typeCheckShift(this, false);\n                case NodeType.AsgLsh:\n                case NodeType.AsgRsh:\n                case NodeType.AsgRs2:\n                    return typeFlow.typeCheckShift(this, true);\n                case NodeType.Comma:\n                    return typeFlow.typeCheckCommaOperator(this);\n                case NodeType.InstOf:\n                    return typeFlow.typeCheckInstOf(this);\n                case NodeType.In:\n                    return typeFlow.typeCheckInOperator(this);\n                case NodeType.From:\n                    typeFlow.checker.errorReporter.simpleError(this, "Illegal use of \'from\' keyword in binary expression");\n                    break;\n                default:\n                    throw new Error("please implement in derived class");\n            }\n            return this;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            var binTokenId = nodeTypeToTokTable[this.nodeType];\n\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (binTokenId != undefined) {\n\n                emitter.emitJavascript(this.operand1, binTokenId, false);\n\n                if (tokenTable[binTokenId].text == "instanceof") {\n                    emitter.writeToOutput(" instanceof ");\n                }\n                else if (tokenTable[binTokenId].text == "in") {\n                    emitter.writeToOutput(" in ");\n                }\n                else {\n                    emitter.writeToOutputTrimmable(" " + tokenTable[binTokenId].text + " ");\n                }\n\n                emitter.emitJavascript(this.operand2, binTokenId, false);\n            }\n            else {\n                switch (this.nodeType) {\n                    case NodeType.Dot:\n                        if (!emitter.tryEmitConstant(this)) {\n                            emitter.emitJavascript(this.operand1, TokenID.Dot, false);\n                            emitter.writeToOutput(".");\n                            emitter.emitJavascriptName(<Identifier>this.operand2, false);\n                        }\n                        break;\n                    case NodeType.Index:\n                        emitter.emitIndex(this.operand1, this.operand2);\n                        break;\n\n                    case NodeType.Member:\n                        if (this.operand2.nodeType == NodeType.FuncDecl && (<FuncDecl>this.operand2).isAccessor()) {\n                            var funcDecl = <FuncDecl>this.operand2;\n                            if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {\n                                emitter.writeToOutput("get ");\n                            }\n                            else {\n                                emitter.writeToOutput("set ");\n                            }\n                            emitter.emitJavascript(this.operand1, TokenID.Colon, false);\n                        }\n                        else {\n                            emitter.emitJavascript(this.operand1, TokenID.Colon, false);\n                            emitter.writeToOutputTrimmable(": ");\n                        }\n                        emitter.emitJavascript(this.operand2, TokenID.Comma, false);\n                        break;\n                    case NodeType.Comma:\n                        emitter.emitJavascript(this.operand1, TokenID.Comma, false);\n                        if (emitter.emitState.inObjectLiteral) {\n                            emitter.writeLineToOutput(", ");\n                        }\n                        else {\n                            emitter.writeToOutput(",");\n                        }\n                        emitter.emitJavascript(this.op',
v27686=v27687+'erand2, TokenID.Comma, false);\n                        break;\n                    case NodeType.Is:\n                        throw new Error("should be de-sugared during type check");\n                    default:\n                        throw new Error("please implement in derived class");\n                }\n            }\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export class ConditionalExpression extends Expression {\n        constructor (public operand1: AST,\n                     public operand2: AST,\n                     public operand3: AST) {\n            super(NodeType.ConditionalExpression);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckQMark(this);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.emitJavascript(this.operand1, TokenID.Question, false);\n            emitter.writeToOutput(" ? ");\n            emitter.emitJavascript(this.operand2, TokenID.Question, false);\n            emitter.writeToOutput(" : ");\n            emitter.emitJavascript(this.operand3, TokenID.Question, false);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export class NumberLiteral extends Expression {\n        constructor (public value: number, public hasEmptyFraction?: bool) {\n            super(NodeType.NumberLit);\n        }\n\n        public isNegativeZero = false;\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.type = typeFlow.doubleType;\n            return this;\n        }\n\n        public treeViewLabel() {\n            return "num: " + this.printLabel();\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (this.isNegativeZero) {\n                emitter.writeToOutput("-");\n            }\n\n            emitter.writeToOutput(this.value.toString());\n\n            if (this.hasEmptyFraction)\n                emitter.writeToOutput(".0");\n\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public printLabel() {\n            if (Math.floor(this.value) != this.value) {\n                return this.value.toFixed(2).toString();\n            }\n            else if (this.hasEmptyFraction) {\n                return this.value.toString() + ".0";\n            }\n            else {\n                return this.value.toString();\n            }\n        }\n    }\n\n    export class RegexLiteral extends Expression {\n        constructor (public regex) {\n            super(NodeType.Regex);\n        }\n        \n        public typeCheck(typeFlow: TypeFlow) {\n            this.type = typeFlow.regexType;\n            return this;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput(this.regex.toString());\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export class StringLiteral extends Expression {\n        constructor (public text: string) {\n            super(NodeType.QString);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.emitStringLiteral(this.text);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.type = typeFlow.stringType;\n            return this;\n        }\n\n        public treeViewLabel() {\n            return "st: " + this.text;\n        }\n\n        public printLabel() {\n            return this.text;\n        }\n    }\n\n    export class ModuleElement extends AST {\n        constructor (nodeType: NodeType) {\n            super(nodeType);\n        }\n    }\n\n    export class ImportDeclaration extends ModuleElement {\n        public isStatementOrExpression() { return true; }\n        public varFlags = VarFlags.None;\n        public isDynamicImport = false;\n        public isDeclaration() { return true; }\n\n        constructor (public id: Identifier, public alias: AST) {\n            super(NodeType.ImportDeclaration);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            var mod = <ModuleType>this.alias.type;\n            // REVIEW: Only modules may be aliased for now, though there\'s no real\n            // restriction on what the typ',
v27685=v27686+'e symbol may be\n            if (!this.isDynamicImport || (this.id.sym && !(<TypeSymbol>this.id.sym).onlyReferencedAsTypeRef)) {\n                var prevModAliasId = emitter.modAliasId;\n                var prevFirstModAlias = emitter.firstModAlias;\n\n                emitter.recordSourceMappingStart(this);\n                emitter.emitParensAndCommentsInPlace(this, true);\n                emitter.writeToOutput("var " + this.id.actualText + " = ");\n                emitter.modAliasId = this.id.actualText;\n                emitter.firstModAlias = this.firstAliasedModToString();\n                emitter.emitJavascript(this.alias, TokenID.Tilde, false);\n                // the dynamic import case will insert the semi-colon automatically\n                if (!this.isDynamicImport) {\n                    emitter.writeToOutput(";");\n                }\n                emitter.emitParensAndCommentsInPlace(this, false);\n                emitter.recordSourceMappingEnd(this);\n\n                emitter.modAliasId = prevModAliasId;\n                emitter.firstModAlias = prevFirstModAlias;\n            }\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckImportDecl(this);\n        }\n\n        public getAliasName(aliasAST?: AST = this.alias) : string {\n            if (aliasAST.nodeType == NodeType.Name) {\n                return (<Identifier>aliasAST).actualText;\n            } else {\n                var dotExpr = <BinaryExpression>aliasAST;\n                return this.getAliasName(dotExpr.operand1) + "." + this.getAliasName(dotExpr.operand2);\n            }\n        }\n\n        public firstAliasedModToString() {\n            if (this.alias.nodeType == NodeType.Name) {\n                return (<Identifier>this.alias).actualText;\n            }\n            else {\n                var dotExpr = <BinaryExpression>this.alias;\n                var firstMod = <Identifier>dotExpr.operand1;\n                return firstMod.actualText;\n            }\n        }\n    }\n\n    export class BoundDecl extends AST {\n        public init: AST = null;\n        public typeExpr: AST = null;\n        public varFlags = VarFlags.None;\n        public sym: Symbol = null;\n        public isDeclaration() { return true; }\n\n        constructor (public id: Identifier, nodeType: NodeType, public nestingLevel: number) {\n            super(nodeType);\n        }\n\n        public isStatementOrExpression() { return true; }\n\n        public isPrivate() { return hasFlag(this.varFlags, VarFlags.Private); }\n        public isPublic() { return hasFlag(this.varFlags, VarFlags.Public); }\n        public isProperty() { return hasFlag(this.varFlags, VarFlags.Property); }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckBoundDecl(this);\n        }\n\n        public printLabel() {\n            return this.treeViewLabel();\n        }\n    }\n\n    export class VarDecl extends BoundDecl {\n        constructor (id: Identifier, nest: number) {\n            super(id, NodeType.VarDecl, nest);\n        }\n\n        public isAmbient() { return hasFlag(this.varFlags, VarFlags.Ambient); }\n        public isExported() { return hasFlag(this.varFlags, VarFlags.Exported); }\n        public isStatic() { return hasFlag(this.varFlags, VarFlags.Static); }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitJavascriptVarDecl(this, tokenId);\n        }\n\n        public treeViewLabel() {\n            return "var " + this.id.actualText;\n        }\n    }\n\n    export class ArgDecl extends BoundDecl {\n        constructor (id: Identifier) {\n            super(id, NodeType.ArgDecl, 0);\n        }\n\n        public isOptional = false;\n\n        public isOptionalArg() { return this.isOptional || this.init; }\n\n        public treeViewLabel() {\n            return "arg: " + this.id.actualText;\n        }\n\n        public parameterPropertySym: FieldSymbol = null;\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput(this.id.actualText);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    var internalId = 0;\n\n    export class FuncDecl extends AST {\n        public hint: string = null;\n        public fncFlags = FncFlags.None;\n        public returnTypeAnnotation: AST = null;\n        public symbols: IHashTable;\n        public variableArgList = false;\n        public signature: Signature;\n        public envids: Identifier[];\n        public jumpRefs: Identifier[] = null;\n        public internalNameCache: string = null;\n        public tmp1Declared = false;\n        public enclosingFnc: FuncDecl = null;\n        public freeVariables: Symbol[] = [];\n        public unitIndex = -1;\n        public classDecl: NamedDeclaration = null;\n        public boundToProperty: VarDecl = null;\n        public isOverload = fa',
v27684=v27685+'lse;\n        public innerStaticFuncs: FuncDecl[] = [];\n        public isTargetTypedAsMethod = false;\n        public isInlineCallLiteral = false;\n        public accessorSymbol: Symbol = null;\n        public leftCurlyCount = 0;\n        public rightCurlyCount = 0;\n        public returnStatementsWithExpressions: ReturnStatement[] = [];\n        public scopeType: Type = null; // Type of the FuncDecl, before target typing\n        public endingToken: ASTSpan = null;\n        public isDeclaration() { return true; }\n\n        constructor (public name: Identifier, public bod: ASTList, public isConstructor: bool,\n                     public arguments: ASTList, public vars: ASTList, public scopes: ASTList, public statics: ASTList,\n                     nodeType: number) {\n\n            super(nodeType);\n        }\n\n        public internalName(): string {\n            if (this.internalNameCache == null) {\n                var extName = this.getNameText();\n                if (extName) {\n                    this.internalNameCache = "_internal_" + extName;\n                }\n                else {\n                    this.internalNameCache = "_internal_" + internalId++;\n                }\n            }\n            return this.internalNameCache;\n        }\n\n        public hasSelfReference() { return hasFlag(this.fncFlags, FncFlags.HasSelfReference); }\n        public setHasSelfReference() { this.fncFlags |= FncFlags.HasSelfReference; }\n\n        public hasSuperReferenceInFatArrowFunction() { return hasFlag(this.fncFlags, FncFlags.HasSuperReferenceInFatArrowFunction); }\n        public setHasSuperReferenceInFatArrowFunction() { this.fncFlags |= FncFlags.HasSuperReferenceInFatArrowFunction; }\n\n        public addCloRef(id: Identifier, sym: Symbol): number {\n            if (this.envids == null) {\n                this.envids = new Identifier[];\n            }\n            this.envids[this.envids.length] = id;\n            var outerFnc = this.enclosingFnc;\n            if (sym) {\n                while (outerFnc && (outerFnc.type.symbol != sym.container)) {\n                    outerFnc.addJumpRef(sym);\n                    outerFnc = outerFnc.enclosingFnc;\n                }\n            }\n            return this.envids.length - 1;\n        }\n\n        public addJumpRef(sym: Symbol): void {\n            if (this.jumpRefs == null) {\n                this.jumpRefs = new Identifier[];\n            }\n            var id = new Identifier(sym.name);\n            this.jumpRefs[this.jumpRefs.length] = id;\n            id.sym = sym;\n            id.cloId = this.addCloRef(id, null);\n        }\n\n        public buildControlFlow(): ControlFlowContext {\n            var entry = new BasicBlock();\n            var exit = new BasicBlock();\n\n            var context = new ControlFlowContext(entry, exit);\n\n            var controlFlowPrefix = (ast: AST, parent: AST, walker: IAstWalker) => {\n                ast.addToControlFlow(walker.state);\n                return ast;\n            }\n\n            var walker = getAstWalkerFactory().getWalker(controlFlowPrefix, null, null, context);\n            context.walker = walker;\n            walker.walk(this.bod, this);\n\n            return context;\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckFunction(this);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitJavascriptFunction(this);\n        }\n\n        public getNameText() {\n            if (this.name) {\n                return this.name.actualText;\n            }\n            else {\n                return this.hint;\n            }\n        }\n\n        public isMethod() {\n            return (this.fncFlags & FncFlags.Method) != FncFlags.None;\n        }\n\n        public isCallMember() { return hasFlag(this.fncFlags, FncFlags.CallMember); }\n        public isConstructMember() { return hasFlag(this.fncFlags, FncFlags.ConstructMember); }\n        public isIndexerMember() { return hasFlag(this.fncFlags, FncFlags.IndexerMember); }\n        public isSpecialFn() { return this.isCallMember() || this.isIndexerMember() || this.isConstructMember(); }\n        public isAnonymousFn() { return this.name === null; }\n        public isAccessor() { return hasFlag(this.fncFlags, FncFlags.GetAccessor) || hasFlag(this.fncFlags, FncFlags.SetAccessor); }\n        public isGetAccessor() { return hasFlag(this.fncFlags, FncFlags.GetAccessor); }\n        public isSetAccessor() { return hasFlag(this.fncFlags, FncFlags.SetAccessor); }\n        public isAmbient() { return hasFlag(this.fncFlags, FncFlags.Ambient); }\n        public isExported() { return hasFlag(this.fncFlags, FncFlags.Exported); }\n        public isPrivate() { return hasFlag(this.fncFlags, FncFlags.Private); }\n        public isPublic() { return hasFlag(this.fncFlags, FncFlags.Public); }\n        public isStatic() { return hasFlag(this.fncFlags, FncFlags.Static); }\n\n        public treeViewLabel() {\n            if (this.name == null) {\n                return "funcExpr";\n      ',
v27683=v27684+'      }\n            else {\n                return "func: " + this.name.actualText\n            }\n        }\n\n        public ClearFlags(): void {\n            this.fncFlags = FncFlags.None;\n        }\n\n        public isSignature() { return (this.fncFlags & FncFlags.Signature) != FncFlags.None; }\n    }\n\n    export class LocationInfo {\n        constructor (public filename: string, public lineMap: number[], public unitIndex) { }\n    }\n\n    export var unknownLocationInfo = new LocationInfo("unknown", null, -1);\n\n    export class Script extends FuncDecl {\n        public locationInfo: LocationInfo = null;\n        public referencedFiles: IFileReference[] = [];\n        public requiresGlobal = false;\n        public requiresExtendsBlock = false;\n        public isResident = false;\n        public isDeclareFile = false;\n        public hasBeenTypeChecked = false;\n        public topLevelMod: ModuleDeclaration = null;\n        public leftCurlyCount = 0;\n        public rightCurlyCount = 0;\n        public vars: ASTList;\n        public scopes: ASTList;\n        // Remember if the script contains Unicode chars, that is needed when generating code for this script object to decide the output file correct encoding.\n        public containsUnicodeChar = false;\n        public containsUnicodeCharInComment = false;\n        public cachedEmitRequired: bool;\n\n        private setCachedEmitRequired(value: bool) {\n            this.cachedEmitRequired = value;\n            return this.cachedEmitRequired;\n        }\n\n        constructor (vars: ASTList, scopes: ASTList) {\n            super(new Identifier("script"), null, false, null, vars, scopes, null, NodeType.Script);\n            this.vars = vars;\n            this.scopes = scopes;\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckScript(this);\n        }\n\n        public treeViewLabel() {\n            return "Script";\n        }\n\n        public emitRequired(emitOptions: EmitOptions) {\n            if (this.cachedEmitRequired != undefined) {\n                return this.cachedEmitRequired;\n            }\n\n            if (!this.isDeclareFile && !this.isResident && this.bod) {\n                if (this.bod.members.length == 0) {\n                    // allow empty files that are not declare files \n                    return this.setCachedEmitRequired(true);\n                }\n\n                for (var i = 0, len = this.bod.members.length; i < len; i++) {\n                    var stmt = this.bod.members[i];\n                    if (stmt.nodeType == NodeType.ModuleDeclaration) {\n                        if (!hasFlag((<ModuleDeclaration>stmt).modFlags, ModuleFlags.ShouldEmitModuleDecl | ModuleFlags.Ambient)) {\n                            return this.setCachedEmitRequired(true);\n                        }\n                    }\n                    else if (stmt.nodeType == NodeType.ClassDeclaration) {\n                        if (!hasFlag((<ClassDeclaration>stmt).varFlags, VarFlags.Ambient)) {\n                            return this.setCachedEmitRequired(true);\n                        }\n                    }\n                    else if (stmt.nodeType == NodeType.VarDecl) {\n                        if (!hasFlag((<VarDecl>stmt).varFlags, VarFlags.Ambient)) {\n                            return this.setCachedEmitRequired(true);\n                        }\n                    }\n                    else if (stmt.nodeType == NodeType.FuncDecl) {\n                        if (!(<FuncDecl>stmt).isSignature()) {\n                            return this.setCachedEmitRequired(true);\n                        }\n                    }\n                    else if (stmt.nodeType != NodeType.InterfaceDeclaration && stmt.nodeType != NodeType.Empty) {\n                        return this.setCachedEmitRequired(true);\n                    }\n                }\n\n                if ( emitOptions.emitComments &&\n                    ((this.bod.preComments && this.bod.preComments.length > 0) || (this.bod.postComments && this.bod.postComments.length > 0))) {\n                    return this.setCachedEmitRequired(true);\n                }\n            }\n            return this.setCachedEmitRequired(false);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            if (this.emitRequired(emitter.emitOptions)) {\n                emitter.emitParensAndCommentsInPlace(this.bod, true);\n                emitter.emitJavascriptList(this.bod, null, TokenID.Semicolon, true, false, false, true, this.requiresExtendsBlock);\n                emitter.emitParensAndCommentsInPlace(this.bod, false);\n            }\n        }\n\n        private externallyVisibleImportedSymbols: Symbol[] = [];\n\n        public AddExternallyVisibleImportedSymbol(symbol: Symbol, checker: TypeChecker) {\n            if (this.isExternallyVisibleSymbol(symbol)) {\n                return;\n            }\n\n            // Before adding check if the external symbol is also marked for visibility\n            if (!symbol.getType().symbol.isExter',
v27682=v27683+'nallyVisible(checker)) {\n                // Report error\n                var quotes = "";\n                var moduleName = symbol.getType().symbol.prettyName;\n                if (!isQuoted(moduleName)) {\n                    quotes = "\'";\n                }\n                checker.errorReporter.simpleError(symbol.declAST, "Externally visible import statement uses non exported module " + quotes + moduleName + quotes);\n            }\n            this.externallyVisibleImportedSymbols.push(symbol);\n        }\n\n        public isExternallyVisibleSymbol(symbol: Symbol) {\n            for (var i = 0 ; i < this.externallyVisibleImportedSymbols.length; i++) {\n                if (this.externallyVisibleImportedSymbols[i] == symbol) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    export class NamedDeclaration extends ModuleElement {\n        public leftCurlyCount = 0;\n        public rightCurlyCount = 0;\n        public isDeclaration() { return true; }\n\n        constructor (nodeType: NodeType,\n                     public name: Identifier,\n                     public members: ASTList) {\n            super(nodeType);\n        }\n    }\n\n    export class ModuleDeclaration extends NamedDeclaration {\n        public modFlags = ModuleFlags.ShouldEmitModuleDecl;\n        public mod: ModuleType;\n        public prettyName: string;\n        public amdDependencies: string[] = [];\n        public vars: ASTList;\n        public scopes: ASTList;\n        // Remember if the module contains Unicode chars, that is needed for dynamic module as we will generate a file for each.\n        public containsUnicodeChar = false;\n        public containsUnicodeCharInComment = false;\n\n        constructor (name: Identifier, members: ASTList, vars: ASTList, scopes: ASTList, public endingToken: ASTSpan) {\n            super(NodeType.ModuleDeclaration, name, members);\n\n            this.vars = vars;\n            this.scopes = scopes;\n            this.prettyName = this.name.actualText;\n        }\n\n        public isExported() { return hasFlag(this.modFlags, ModuleFlags.Exported); }\n        public isAmbient() { return hasFlag(this.modFlags, ModuleFlags.Ambient); }\n        public isEnum() { return hasFlag(this.modFlags, ModuleFlags.IsEnum); }\n\n        public recordNonInterface() {\n            this.modFlags &= ~ModuleFlags.ShouldEmitModuleDecl;\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckModule(this);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            if (!hasFlag(this.modFlags, ModuleFlags.ShouldEmitModuleDecl)) {\n                emitter.emitParensAndCommentsInPlace(this, true);\n                emitter.emitJavascriptModule(this);\n                emitter.emitParensAndCommentsInPlace(this, false);\n            }\n        }\n    }\n\n    export class TypeDeclaration extends NamedDeclaration {\n        public varFlags = VarFlags.None;\n\n        constructor (nodeType: NodeType,\n                     name: Identifier,\n                     public extendsList: ASTList,\n                     public implementsList: ASTList,\n                     members: ASTList) {\n            super(nodeType, name, members);\n        }\n\n        public isExported() { \n            return hasFlag(this.varFlags, VarFlags.Exported);\n        }\n\n        public isAmbient() {\n            return hasFlag(this.varFlags, VarFlags.Ambient);\n        }\n    }\n\n    export class ClassDeclaration extends TypeDeclaration {\n        public knownMemberNames: any = {};\n        public constructorDecl: FuncDecl = null;\n        public constructorNestingLevel = 0;\n        public endingToken: ASTSpan = null;\n\n        constructor (name: Identifier,\n                     members: ASTList,\n                     extendsList: ASTList,\n                     implementsList: ASTList) {\n            super(NodeType.ClassDeclaration, name, extendsList, implementsList, members);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckClass(this);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitJavascriptClass(this);\n        }\n    }\n\n    export class InterfaceDeclaration extends TypeDeclaration {\n        constructor (name: Identifier,\n                     members: ASTList,\n                     extendsList: ASTList,\n                     implementsList: ASTList) {\n            super(NodeType.InterfaceDeclaration, name, extendsList, implementsList, members);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckInterface(this);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n        }\n    }\n\n    export class Statement extends ModuleElement {\n        constructor (nodeType: NodeType) {\n            super(nodeType);\n            this.flags |= ASTFlags.IsStatement;\n        }\n\n        public isLoop() { return false; }\n\n        public i',
v27681=v27682+'sStatementOrExpression() { return true; }\n\n        public isCompoundStatement() { return this.isLoop(); }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.type = typeFlow.voidType;\n            return this;\n        }\n    }\n\n    export class LabeledStatement extends Statement {\n        constructor (public labels: ASTList, public stmt: AST) {\n            super(NodeType.LabeledStatement);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (this.labels) {\n                var labelsLen = this.labels.members.length;\n                for (var i = 0; i < labelsLen; i++) {\n                    this.labels.members[i].emit(emitter, tokenId, startLine);\n                }\n            }\n            this.stmt.emit(emitter, tokenId, true);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            typeFlow.typeCheck(this.labels);\n            this.stmt = this.stmt.typeCheck(typeFlow);\n            return this;\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            var beforeBB = context.current;\n            var bb = new BasicBlock();\n            context.current = bb;\n            beforeBB.addSuccessor(bb);\n        }\n    }\n\n    export class Block extends Statement {\n        constructor (public statements: ASTList,\n                     public isStatementBlock: bool) {\n            super(NodeType.Block);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (this.isStatementBlock) {\n                emitter.writeLineToOutput(" {");\n                emitter.indenter.increaseIndent();\n            } else {\n                emitter.setInVarBlock(this.statements.members.length);\n            }\n            var temp = emitter.setInObjectLiteral(false);\n            if (this.statements) {\n                emitter.emitJavascriptList(this.statements, null, TokenID.Semicolon, true, false, false);\n            }\n            if (this.isStatementBlock) {\n                emitter.indenter.decreaseIndent();\n                emitter.emitIndent();\n                emitter.writeToOutput("}");\n            }\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public addToControlFlow(context: ControlFlowContext) {\n            var afterIfNeeded = new BasicBlock();\n            context.pushStatement(this, context.current, afterIfNeeded);\n            if (this.statements) {\n                context.walk(this.statements, this);\n            }\n            context.walker.options.goChildren = false;\n            context.popStatement();\n            if (afterIfNeeded.predecessors.length > 0) {\n                context.current.addSuccessor(afterIfNeeded);\n                context.current = afterIfNeeded;\n            }\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            if (!typeFlow.checker.styleSettings.emptyBlocks) {\n                if ((this.statements === null) || (this.statements.members.length == 0)) {\n                    typeFlow.checker.errorReporter.styleError(this, "empty block");\n                }\n            }\n\n            typeFlow.typeCheck(this.statements);\n            return this;\n        }\n    }\n\n    export class Jump extends Statement {\n        public target: string = null;\n        public hasExplicitTarget() { return (this.target); }\n        public resolvedTarget: Statement = null;\n\n        constructor (nodeType: NodeType) {\n            super(nodeType);\n        }\n\n        public setResolvedTarget(parser: Parser, stmt: Statement): bool {\n            if (stmt.isLoop()) {\n                this.resolvedTarget = stmt;\n                return true;\n            }\n            if (this.nodeType === NodeType.Continue) {\n                parser.reportParseError("continue statement applies only to loops");\n                return false;\n            }\n            else {\n                if ((stmt.nodeType == NodeType.Switch) || this.hasExplicitTarget()) {\n                    this.resolvedTarget = stmt;\n                    return true;\n                }\n                else {\n                    parser.reportParseError("break statement with no label can apply only to a loop or switch statement");\n                    return false;\n                }\n            }\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            super.addToControlFlow(context);\n            context.unconditionalBranch(this.resolvedTarget, (this.nodeType == NodeType.Continue));\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, s',
v27680=v27681+'tartLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (this.nodeType == NodeType.Break) {\n                emitter.writeToOutput("break");\n            }\n            else {\n                emitter.writeToOutput("continue");\n            }\n            if (this.hasExplicitTarget()) {\n                emitter.writeToOutput(" " + this.target);\n            }\n            emitter.recordSourceMappingEnd(this);\n            emitter.writeToOutput(";");\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export class WhileStatement extends Statement {\n        public body: AST = null;\n\n        constructor (public cond: AST) {\n            super(NodeType.While);\n        }\n\n        public isLoop() { return true; }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.writeToOutput("while(");\n            emitter.emitJavascript(this.cond, TokenID.While, false);\n            emitter.writeToOutput(")");\n            emitter.emitJavascriptStatements(this.body, false);\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckWhile(this);\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            var loopHeader = context.current;\n            var loopStart = new BasicBlock();\n            var afterLoop = new BasicBlock();\n\n            loopHeader.addSuccessor(loopStart);\n            context.current = loopStart;\n            context.addContent(this.cond);\n            var condBlock = context.current;\n            var targetInfo: ITargetInfo = null;\n            if (this.body) {\n                context.current = new BasicBlock();\n                condBlock.addSuccessor(context.current);\n                context.pushStatement(this, loopStart, afterLoop);\n                context.walk(this.body, this);\n                targetInfo = context.popStatement();\n            }\n            if (!(context.noContinuation)) {\n                var loopEnd = context.current;\n                loopEnd.addSuccessor(loopStart);\n            }\n            context.current = afterLoop;\n            condBlock.addSuccessor(afterLoop);\n            // TODO: check for while (true) and then only continue if afterLoop has predecessors\n            context.noContinuation = false;\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class DoWhileStatement extends Statement {\n        public body: AST = null;\n        public whileAST: AST = null;\n        public cond: AST = null;\n        public isLoop() { return true; }\n\n        constructor () {\n            super(NodeType.DoWhile);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.writeToOutput("do");\n            emitter.emitJavascriptStatements(this.body, true);\n            emitter.recordSourceMappingStart(this.whileAST);\n            emitter.writeToOutput("while");\n            emitter.recordSourceMappingEnd(this.whileAST);\n            emitter.writeToOutput(\'(\');\n            emitter.emitJavascript(this.cond, TokenID.CloseParen, false);\n            emitter.writeToOutput(")");\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.writeToOutput(";");\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckDoWhile(this);\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            var loopHeader = context.current;\n            var loopStart = new BasicBlock();\n            var afterLoop = new BasicBlock();\n            loopHeader.addSuccessor(loopStart);\n            context.current = loopStart;\n            var targetInfo: ITargetInfo = null;\n            if (this.body) {\n                context.pushStatement(this, loopStart, afterLoop);\n                context.walk(this.body, this);\n                targetInfo = context.popStatement();\n            }\n            if (!(context.noContinuation)) {\n                var loopEnd = context.current;\n                loopEnd.addSuccessor(loopStart);\n                context.addContent(this.cond);\n                // TODO: check for while (true) \n                context.current = afterLoop;\n                loopEnd.addSuccessor(afterLoop);\n            }\n            else {\n                context.addUnreachable(t',
v27679=v27680+'his.cond);\n            }\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class IfStatement extends Statement {\n        public thenBod: AST;\n        public elseBod: AST = null;\n        public statement: ASTSpan = new ASTSpan();\n\n        constructor (public cond: AST) {\n            super(NodeType.If);\n        }\n\n        public isCompoundStatement() { return true; }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.recordSourceMappingStart(this.statement);\n            emitter.writeToOutput("if(");\n            emitter.emitJavascript(this.cond, TokenID.If, false);\n            emitter.writeToOutput(")");\n            emitter.recordSourceMappingEnd(this.statement);\n            emitter.emitJavascriptStatements(this.thenBod, true);\n            if (this.elseBod) {\n                if (this.elseBod.nodeType === NodeType.If) {\n                    emitter.writeToOutput(" else ");\n                    this.elseBod.emit(emitter, tokenId, /*startLine:*/ false);\n                }\n                else {\n                    emitter.writeToOutput(" else");\n                    emitter.emitJavascriptStatements(this.elseBod, true);\n                }\n            }\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckIf(this);\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            this.cond.addToControlFlow(context);\n            var afterIf = new BasicBlock();\n            var beforeIf = context.current;\n            context.pushStatement(this, beforeIf, afterIf);\n            var hasContinuation = false;\n            context.current = new BasicBlock();\n            beforeIf.addSuccessor(context.current);\n            context.walk(this.thenBod, this);\n            if (!context.noContinuation) {\n                hasContinuation = true;\n                context.current.addSuccessor(afterIf);\n            }\n            if (this.elseBod) {\n                // current block will be thenBod\n                context.current = new BasicBlock();\n                context.noContinuation = false;\n                beforeIf.addSuccessor(context.current);\n                context.walk(this.elseBod, this);\n                if (!context.noContinuation) {\n                    hasContinuation = true;\n                    context.current.addSuccessor(afterIf);\n                }\n                else {\n                    // thenBod created continuation for if statement\n                    if (hasContinuation) {\n                        context.noContinuation = false;\n                    }\n                }\n            }\n            else {\n                beforeIf.addSuccessor(afterIf);\n                context.noContinuation = false;\n                hasContinuation = true;\n            }\n            var targetInfo = context.popStatement();\n            if (afterIf.predecessors.length > 0) {\n                context.noContinuation = false;\n                hasContinuation = true;\n            }\n            if (hasContinuation) {\n                context.current = afterIf;\n            }\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class ReturnStatement extends Statement {\n        public returnExpression: AST = null;\n\n        constructor () {\n            super(NodeType.Return);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            if (this.returnExpression) {\n                emitter.writeToOutput("return ");\n                emitter.emitJavascript(this.returnExpression, TokenID.Semicolon, false);\n\n                if (this.returnExpression.nodeType === NodeType.FuncDecl) {\n                    emitter.writeToOutput(";");\n                }\n            }\n            else {\n                emitter.writeToOutput("return;");\n            }\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            super.addToControlFlow(context);\n            context.returnStmt();\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckReturn(this);\n        }\n    }\n\n    export class EndCode extends AST {\n        constructor () {\n            super(NodeType.EndCode);\n        }\n    }\n\n    export class ForInStatement extends Statement {\n        constructor ',
v27678=v27679+'(public lval: AST, public obj: AST) {\n            super(NodeType.ForIn);\n            if (this.lval && (this.lval.nodeType == NodeType.VarDecl)) {\n                (<BoundDecl>this.lval).varFlags |= VarFlags.AutoInit;\n            }\n        }\n        public statement: ASTSpan = new ASTSpan();\n        public body: AST;\n\n        public isLoop() { return true; }\n\n        public isFiltered() {\n            if (this.body) {\n                var singleItem: AST = null;\n                if (this.body.nodeType == NodeType.List) {\n                    var stmts = <ASTList>this.body;\n                    if (stmts.members.length == 1) {\n                        singleItem = stmts.members[0];\n                    }\n                }\n                else {\n                    singleItem = this.body;\n                }\n                // match template for filtering \'own\' properties from obj\n                if (singleItem !== null) {\n                    if (singleItem.nodeType == NodeType.Block) {\n                        var block = <Block>singleItem;\n                        if ((block.statements !== null) && (block.statements.members.length == 1)) {\n                            singleItem = block.statements.members[0];\n                        }\n                    }\n                    if (singleItem.nodeType == NodeType.If) {\n                        var cond = (<IfStatement>singleItem).cond;\n                        if (cond.nodeType == NodeType.Call) {\n                            var target = (<CallExpression>cond).target;\n                            if (target.nodeType == NodeType.Dot) {\n                                var binex = <BinaryExpression>target;\n                                if ((binex.operand1.nodeType == NodeType.Name) &&\n                                    (this.obj.nodeType == NodeType.Name) &&\n                                    ((<Identifier>binex.operand1).actualText == (<Identifier>this.obj).actualText)) {\n                                    var prop = <Identifier>binex.operand2;\n                                    if (prop.actualText == "hasOwnProperty") {\n                                        var args = (<CallExpression>cond).arguments;\n                                        if ((args !== null) && (args.members.length == 1)) {\n                                            var arg = args.members[0];\n                                            if ((arg.nodeType == NodeType.Name) &&\n                                                 (this.lval.nodeType == NodeType.Name)) {\n                                                if (((<Identifier>this.lval).actualText) == (<Identifier>arg).actualText) {\n                                                    return true;\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.recordSourceMappingStart(this.statement);\n            emitter.writeToOutput("for(");\n            emitter.emitJavascript(this.lval, TokenID.For, false);\n            emitter.writeToOutput(" in ");\n            emitter.emitJavascript(this.obj, TokenID.For, false);\n            emitter.writeToOutput(")");\n            emitter.recordSourceMappingEnd(this.statement);\n            emitter.emitJavascriptStatements(this.body, true);\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            if (typeFlow.checker.styleSettings.forin) {\n                if (!this.isFiltered()) {\n                    typeFlow.checker.errorReporter.styleError(this, "no hasOwnProperty filter");\n                }\n            }\n            return typeFlow.typeCheckForIn(this);\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            if (this.lval) {\n                context.addContent(this.lval);\n            }\n            if (this.obj) {\n                context.addContent(this.obj);\n            }\n\n            var loopHeader = context.current;\n            var loopStart = new BasicBlock();\n            var afterLoop = new BasicBlock();\n\n            loopHeader.addSuccessor(loopStart);\n            context.current = loopStart;\n            if (this.body) {\n                context.pushStatement(this, loopStart, afterLoop);\n                context.walk(this.body, this);\n                context.popStatement();\n            }\n            if (!(context.noContinuation)) {\n                var loopE',
v27677=v27678+'nd = context.current;\n                loopEnd.addSuccessor(loopStart);\n            }\n            context.current = afterLoop;\n            context.noContinuation = false;\n            loopHeader.addSuccessor(afterLoop);\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class ForStatement extends Statement {\n        public cond: AST;\n        public body: AST;\n        public incr: AST;\n\n        constructor (public init: AST) {\n            super(NodeType.For);\n        }\n\n        public isLoop() { return true; }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.writeToOutput("for(");\n            if (this.init) {\n                if (this.init.nodeType != NodeType.List) {\n                    emitter.emitJavascript(this.init, TokenID.For, false);\n                }\n                else {\n                    emitter.setInVarBlock((<ASTList>this.init).members.length); \n                    emitter.emitJavascriptList(this.init, null, TokenID.For, false, false, false);\n                }\n            }\n            emitter.writeToOutput("; ");\n            emitter.emitJavascript(this.cond, TokenID.For, false);\n            emitter.writeToOutput("; ");\n            emitter.emitJavascript(this.incr, TokenID.For, false);\n            emitter.writeToOutput(")");\n            emitter.emitJavascriptStatements(this.body, true);\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckFor(this);\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            if (this.init) {\n                context.addContent(this.init);\n            }\n            var loopHeader = context.current;\n            var loopStart = new BasicBlock();\n            var afterLoop = new BasicBlock();\n\n            loopHeader.addSuccessor(loopStart);\n            context.current = loopStart;\n            var condBlock: BasicBlock = null;\n            var continueTarget = loopStart;\n            var incrBB: BasicBlock = null;\n            if (this.incr) {\n                incrBB = new BasicBlock();\n                continueTarget = incrBB;\n            }\n            if (this.cond) {\n                condBlock = context.current;\n                context.addContent(this.cond);\n                context.current = new BasicBlock();\n                condBlock.addSuccessor(context.current);\n            }\n            var targetInfo: ITargetInfo = null;\n            if (this.body) {\n                context.pushStatement(this, continueTarget, afterLoop);\n                context.walk(this.body, this);\n                targetInfo = context.popStatement();\n            }\n            if (this.incr) {\n                if (context.noContinuation) {\n                    if (incrBB.predecessors.length == 0) {\n                        context.addUnreachable(this.incr);\n                    }\n                }\n                else {\n                    context.current.addSuccessor(incrBB);\n                    context.current = incrBB;\n                    context.addContent(this.incr);\n                }\n            }\n            var loopEnd = context.current;\n            if (!(context.noContinuation)) {\n                loopEnd.addSuccessor(loopStart);\n\n            }\n            if (condBlock) {\n                condBlock.addSuccessor(afterLoop);\n                context.noContinuation = false;\n            }\n            if (afterLoop.predecessors.length > 0) {\n                context.noContinuation = false;\n                context.current = afterLoop;\n            }\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class WithStatement extends Statement {\n        public body: AST;\n\n        public isCompoundStatement() { return true; }\n\n        public withSym: WithSymbol = null;\n\n        constructor (public expr: AST) {\n            super(NodeType.With);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput("with (");\n            if (this.expr) {\n                emitter.emitJavascript(this.expr, TokenID.With, false);\n            }\n\n            emitter.writeToOutput(")");\n            emitter.emitJavascriptStatements(this.body, true);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckWith(this);\n        }\n    }\n\n    export class SwitchStatement extends Statement {\n        public caseList:',
v27676=v27677+' ASTList;\n        public defaultCase: CaseStatement = null;\n        public statement: ASTSpan = new ASTSpan();\n\n        constructor (public val: AST) {\n            super(NodeType.Switch);\n        }\n\n        public isCompoundStatement() { return true; }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.recordSourceMappingStart(this.statement);\n            emitter.writeToOutput("switch(");\n            emitter.emitJavascript(this.val, TokenID.Identifier, false);\n            emitter.writeToOutput(")"); \n            emitter.recordSourceMappingEnd(this.statement);\n            emitter.writeLineToOutput(" {");\n            emitter.indenter.increaseIndent();\n            var casesLen = this.caseList.members.length;\n            for (var i = 0; i < casesLen; i++) {\n                var caseExpr = this.caseList.members[i];\n                emitter.emitJavascript(caseExpr, TokenID.Case, true);\n            }\n            emitter.indenter.decreaseIndent();\n            emitter.emitIndent();\n            emitter.writeToOutput("}");\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            var len = this.caseList.members.length;\n            this.val = typeFlow.typeCheck(this.val);\n            for (var i = 0; i < len; i++) {\n                this.caseList.members[i] = typeFlow.typeCheck(this.caseList.members[i]);\n            }\n            this.defaultCase = <CaseStatement>typeFlow.typeCheck(this.defaultCase);\n            this.type = typeFlow.voidType;\n            return this;\n        }\n\n        // if there are break statements that match this switch, then just link cond block with block after switch\n        public addToControlFlow(context: ControlFlowContext) {\n            var condBlock = context.current;\n            context.addContent(this.val);\n            var execBlock = new BasicBlock();\n            var afterSwitch = new BasicBlock();\n\n            condBlock.addSuccessor(execBlock);\n            context.pushSwitch(execBlock);\n            context.current = execBlock;\n            context.pushStatement(this, execBlock, afterSwitch);\n            context.walk(this.caseList, this);\n            context.popSwitch();\n            var targetInfo = context.popStatement();\n            var hasCondContinuation = (this.defaultCase == null);\n            if (this.defaultCase == null) {\n                condBlock.addSuccessor(afterSwitch);\n            }\n            if (afterSwitch.predecessors.length > 0) {\n                context.noContinuation = false;\n                context.current = afterSwitch;\n            }\n            else {\n                context.noContinuation = true;\n            }\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class CaseStatement extends Statement {\n        public expr: AST = null;\n        public body: ASTList;\n\n        constructor () {\n            super(NodeType.Case);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (this.expr) {\n                emitter.writeToOutput("case ");\n                emitter.emitJavascript(this.expr, TokenID.Identifier, false);\n            }\n            else {\n                emitter.writeToOutput("default");\n            }\n            emitter.writeToOutput(":");\n            if (this.body.members.length == 1 && this.body.members[0].nodeType == NodeType.Block) {\n                // The case statement was written with curly braces, so emit it with the appropriate formatting\n                emitter.emitJavascriptStatements(this.body, false);\n            }\n            else {\n                // No curly braces. Format in the expected way\n                emitter.writeLineToOutput("");\n                emitter.indenter.increaseIndent();\n                emitter.emitBareJavascriptStatements(this.body);\n                emitter.indenter.decreaseIndent();\n            }\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.expr = typeFlow.typeCheck(this.expr);\n            typeFlow.typeCheck(this.body);\n            this.type = typeFlow.voidType;\n            return this;\n        }\n\n        // TODO: more reasoning about unreachable cases (such as duplicate literals as case expressions)\n        // for now, assume all cases are reachable, regardless of whether some cases fall through\n        public addToControlFlow(context: ControlFlowContext) {\n            var execBlock = new BasicBlock();\n            v',
v27675=v27676+'ar sw = context.currentSwitch[context.currentSwitch.length - 1];\n            // TODO: fall-through from previous (+ to end of switch)\n            if (this.expr) {\n                var exprBlock = new BasicBlock();\n                context.current = exprBlock;\n                sw.addSuccessor(exprBlock);\n                context.addContent(this.expr);\n                exprBlock.addSuccessor(execBlock);\n            }\n            else {\n                sw.addSuccessor(execBlock);\n            }\n            context.current = execBlock;\n            if (this.body) {\n                context.walk(this.body, this);\n            }\n            context.noContinuation = false;\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class TypeReference extends AST {\n        constructor (public term: AST, public arrayCount: number) {\n            super(NodeType.TypeRef);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            throw new Error("should not emit a type ref");\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            var prevInTCTR = typeFlow.inTypeRefTypeCheck;\n            typeFlow.inTypeRefTypeCheck = true;\n            var typeLink = getTypeLink(this, typeFlow.checker, true);\n            typeFlow.checker.resolveTypeLink(typeFlow.scope, typeLink, false);\n\n            if (this.term) {\n                typeFlow.typeCheck(this.term);\n            }\n\n            typeFlow.checkForVoidConstructor(typeLink.type, this);\n\n            this.type = typeLink.type;\n\n            // in error recovery cases, there may not be a term\n            if (this.term) {\n                this.term.type = this.type;\n            }\n\n            typeFlow.inTypeRefTypeCheck = prevInTCTR;\n            return this;\n        }\n    }\n\n    export class TryFinally extends Statement {\n        constructor (public tryNode: AST, public finallyNode: Finally) {\n            super(NodeType.TryFinally);\n        }\n\n        public isCompoundStatement() { return true; }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.recordSourceMappingStart(this);\n            emitter.emitJavascript(this.tryNode, TokenID.Try, false);\n            emitter.emitJavascript(this.finallyNode, TokenID.Finally, false);\n            emitter.recordSourceMappingEnd(this);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.tryNode = typeFlow.typeCheck(this.tryNode);\n            this.finallyNode = <Finally>typeFlow.typeCheck(this.finallyNode);\n            this.type = typeFlow.voidType;\n            return this;\n        }\n\n        public addToControlFlow(context: ControlFlowContext) {\n            var afterFinally = new BasicBlock();\n            context.walk(this.tryNode, this);\n            var finBlock = new BasicBlock();\n            if (context.current) {\n                context.current.addSuccessor(finBlock);\n            }\n            context.current = finBlock;\n            context.pushStatement(this, null, afterFinally);\n            context.walk(this.finallyNode, this);\n            if (!context.noContinuation && context.current) {\n                context.current.addSuccessor(afterFinally);\n            }\n            if (afterFinally.predecessors.length > 0) {\n                context.current = afterFinally;\n            }\n            else {\n                context.noContinuation = true;\n            }\n            context.popStatement();\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class TryCatch extends Statement {\n        constructor (public tryNode: Try, public catchNode: Catch) {\n            super(NodeType.TryCatch);\n        }\n\n        public isCompoundStatement() { return true; }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.emitJavascript(this.tryNode, TokenID.Try, false);\n            emitter.emitJavascript(this.catchNode, TokenID.Catch, false);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public addToControlFlow(context: ControlFlowContext) {\n            var beforeTry = context.current;\n            var tryBlock = new BasicBlock();\n            beforeTry.addSuccessor(tryBlock);\n            context.current = tryBlock;\n            var afterTryCatch = new BasicBlock();\n            context.pushStatement(this, null, afterTryCatch);\n            context.walk(this.tryNode, this);\n            if (!context.noContinuation) {\n                if (context.current) {\n                    context.current.addSuccessor(afterTryCatch);\n                }\n            }\n            context.current = new BasicBlock();\n            beforeTry.addSuccessor(context.current);\n            context.walk(this.catchNode, this);\n            context.popStatement();\n            if (!context.noContinuation)',
v27674=v27675+' {\n                if (context.current) {\n                    context.current.addSuccessor(afterTryCatch);\n                }\n            }\n            context.current = afterTryCatch;\n            context.walker.options.goChildren = false;\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.tryNode = <Try>typeFlow.typeCheck(this.tryNode);\n            this.catchNode = <Catch>typeFlow.typeCheck(this.catchNode);\n            this.type = typeFlow.voidType;\n            return this;\n        }\n    }\n\n    export class Try extends Statement {\n        constructor (public body: AST) {\n            super(NodeType.Try);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput("try ");\n            emitter.emitJavascript(this.body, TokenID.Try, false);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.body = typeFlow.typeCheck(this.body);\n            return this;\n        }\n\n        public addToControlFlow(context: ControlFlowContext) {\n            if (this.body) {\n                context.walk(this.body, this);\n            }\n            context.walker.options.goChildren = false;\n            context.noContinuation = false;\n        }\n    }\n\n    export class Catch extends Statement {\n        constructor (public param: VarDecl, public body: AST) {\n            super(NodeType.Catch);\n            if (this.param) {\n                this.param.varFlags |= VarFlags.AutoInit;\n            }\n        }\n        public statement: ASTSpan = new ASTSpan();\n        public containedScope: SymbolScope = null;\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput(" ");\n            emitter.recordSourceMappingStart(this.statement);\n            emitter.writeToOutput("catch (");\n            emitter.emitJavascript(this.param, TokenID.OpenParen, false);\n            emitter.writeToOutput(")");\n            emitter.recordSourceMappingEnd(this.statement);\n            emitter.emitJavascript(this.body, TokenID.Catch, false);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public addToControlFlow(context: ControlFlowContext) {\n            if (this.param) {\n                context.addContent(this.param);\n                var bodBlock = new BasicBlock();\n                context.current.addSuccessor(bodBlock);\n                context.current = bodBlock;\n            }\n            if (this.body) {\n                context.walk(this.body, this);\n            }\n            context.noContinuation = false;\n            context.walker.options.goChildren = false;\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            var prevScope = typeFlow.scope;\n            typeFlow.scope = this.containedScope;\n            this.param = <VarDecl>typeFlow.typeCheck(this.param);\n            var exceptVar = new ValueLocation();\n            var varSym = new VariableSymbol((<VarDecl>this.param).id.text,\n                                          this.param.minChar,\n                                          typeFlow.checker.locationInfo.unitIndex,\n                                          exceptVar);\n            exceptVar.symbol = varSym;\n            exceptVar.typeLink = new TypeLink();\n            // var type for now (add syntax for type annotation)\n            exceptVar.typeLink.type = typeFlow.anyType;\n            var thisFnc = typeFlow.thisFnc;\n            if (thisFnc && thisFnc.type) {\n                exceptVar.symbol.container = thisFnc.type.symbol;\n            }\n            else {\n                exceptVar.symbol.container = null;\n            }\n            this.param.sym = exceptVar.symbol;\n            typeFlow.scope.enter(exceptVar.symbol.container, this.param, exceptVar.symbol,\n                                 typeFlow.checker.errorReporter, false, false, false);\n            this.body = typeFlow.typeCheck(this.body);\n\n            // if we\'re in provisional typecheck mode, clean up the symbol entry\n            // REVIEW: This is obviously bad form, since we\'re counting on the internal\n            // layout of the symbol table, but this is also the only place where we insert\n            // symbols during typecheck\n            if (typeFlow.checker.inProvisionalTypecheckMode()) {\n                var table = typeFlow.scope.getTable();\n                (<any>table).secondaryTable.table[exceptVar.symbol.name] = undefined;\n            }\n            this.type = typeFlow.voidType;\n            typeFlow.scope = prevScope;\n            return this;\n        }\n    }\n\n    export class Finally extends Statement ',
v27673=v27674+'{\n        constructor (public body: AST) {\n            super(NodeType.Finally);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput("finally");\n            emitter.emitJavascript(this.body, TokenID.Finally, false);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public addToControlFlow(context: ControlFlowContext) {\n            if (this.body) {\n                context.walk(this.body, this);\n            }\n            context.walker.options.goChildren = false;\n            context.noContinuation = false;\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.body = typeFlow.typeCheck(this.body);\n            return this;\n        }\n    }\n\n    export class Comment extends AST {\n\n        public text: string[] = null;\n        public minLine: number;\n        public limLine: number;\n        private docCommentText: string = null;\n\n        constructor (public content: string, public isBlockComment: bool, public endsLine) {\n            super(NodeType.Comment);\n        }\n\n        public getText(): string[] {\n            if (this.text == null) {\n                if (this.isBlockComment) {\n                    this.text = this.content.split("\\n");\n                    for (var i = 0; i < this.text.length; i++) {\n                        this.text[i] = this.text[i].replace(/^\\s+|\\s+$/g, \'\');\n                    }\n                }\n                else {\n                    this.text = [(this.content.replace(/^\\s+|\\s+$/g, \'\'))];\n                }\n            }\n\n            return this.text;\n        }\n\n        public isDocComment() {\n            if (this.isBlockComment) {\n                return this.content.charAt(2) == "*";\n            }\n\n            return false;\n        }\n\n        public getDocCommentText() {\n            if (this.docCommentText == null) {\n                this.docCommentText = Comment.cleanJSDocComment(this.content);\n            }\n\n            return this.docCommentText;\n        }\n\n        static consumeLeadingSpace(line: string, startIndex: number, maxSpacesToRemove?: number) {\n            var endIndex = line.length;\n            if (maxSpacesToRemove != undefined) {\n                endIndex = min(startIndex + maxSpacesToRemove, endIndex);\n            }\n\n            for (; startIndex < endIndex; startIndex++) {\n                var charCode = line.charCodeAt(startIndex);\n                if (charCode != LexCodeSpace && charCode != LexCodeTAB) {\n                    return startIndex;\n                }\n            }\n            \n            if (endIndex != line.length) {\n                return endIndex;\n            }\n\n            return -1;\n        }\n\n        static isSpaceChar(line: string, index: number) {\n            var length = line.length;\n            if (index < length) {\n                var charCode = line.charCodeAt(index);\n                // If the character is space\n                return charCode == LexCodeSpace || charCode == LexCodeTAB;\n            }\n\n            // If the index is end of the line it is space\n            return index == length;\n        }\n\n        static cleanDocCommentLine(line: string, jsDocStyleComment: bool, jsDocLineSpaceToRemove?: number) {\n            var nonSpaceIndex = Comment.consumeLeadingSpace(line, 0);\n            if (nonSpaceIndex != -1) {\n                var jsDocSpacesRemoved = nonSpaceIndex;\n                if (jsDocStyleComment && line.charAt(nonSpaceIndex) == \'*\') { // remove leading * in case of jsDocComment\n                    var startIndex = nonSpaceIndex + 1;\n                    nonSpaceIndex = Comment.consumeLeadingSpace(line, startIndex, jsDocLineSpaceToRemove);\n\n                    if (nonSpaceIndex != -1) {\n                        jsDocSpacesRemoved = nonSpaceIndex - startIndex;\n                    } else {\n                        return null;\n                    }\n                }\n\n                return {\n                    minChar: nonSpaceIndex,\n                    limChar: line.charAt(line.length - 1) == "\\r" ? line.length - 1 : line.length,\n                    jsDocSpacesRemoved: jsDocSpacesRemoved\n                };\n            }\n\n            return null;\n        }\n\n        static cleanJSDocComment(content: string, spacesToRemove?: number) {\n            var docCommentLines: string[] = [];\n            content = content.replace("/**", ""); // remove /**\n            if (content.length >= 2 && content.charAt(content.length - 1) == "/" && content.charAt(content.length - 2) == "*") {\n                content = content.substring(0, content.length - 2); // remove last */\n            }\n            var lines = content.split("\\n");\n            var inParamTag = false;\n            for (var l = 0; l < lines.length; l++) {\n                var line = lines[l];\n                var clean',
v27672=v27673+'LinePos = Comment.cleanDocCommentLine(line, true, spacesToRemove);\n                if (!cleanLinePos) {\n                    // Whole line empty, read next line\n                    continue;\n                }\n\n                var docCommentText = "";\n                var prevPos = cleanLinePos.minChar;\n                for (var i = line.indexOf("@", cleanLinePos.minChar); 0 <= i && i < cleanLinePos.limChar; i = line.indexOf("@", i + 1)) {\n                    // We have encoutered @. \n                    // If we were omitting param comment, we dont have to do anything\n                    // other wise the content of the text till @ tag goes as doc comment\n                    var wasInParamtag = inParamTag;\n\n                    // Parse contents next to @\n                    if (line.indexOf("param", i + 1) == i + 1 && Comment.isSpaceChar(line, i + 6)) {\n                        // It is param tag. \n\n                        // If we were not in param tag earlier, push the contents from prev pos of the tag this tag start as docComment\n                        if (!wasInParamtag) {\n                            docCommentText += line.substring(prevPos, i);\n                        }\n\n                        // New start of contents \n                        prevPos = i;\n                        inParamTag = true;\n                    } else if (wasInParamtag) {\n                        // Non param tag start\n                        prevPos = i;\n                        inParamTag = false;\n                    }\n                }\n\n                if (!inParamTag) {\n                    docCommentText += line.substring(prevPos, cleanLinePos.limChar);\n                }\n\n                // Add line to comment text if it is not only white space line\n                var newCleanPos = Comment.cleanDocCommentLine(docCommentText, false);\n                if (newCleanPos) {\n                    if (spacesToRemove == undefined) {\n                        spacesToRemove = cleanLinePos.jsDocSpacesRemoved;\n                    }\n                    docCommentLines.push(docCommentText);\n                }\n            }\n            \n            return docCommentLines.join("\\n");\n        }\n\n        static getDocCommentText(comments: Comment[]) {\n            var docCommentText: string[] = [];\n            for (var c = 0 ; c < comments.length; c++) {\n                var commentText = comments[c].getDocCommentText();\n                if (commentText != "") {\n                    docCommentText.push(commentText);\n                }\n            }\n            return docCommentText.join("\\n");\n        }\n\n        static getParameterDocCommentText(param: string, fncDocComments: Comment[]) {\n            if (fncDocComments.length == 0 || !fncDocComments[0].isBlockComment) {\n                // there were no fnc doc comments and the comment is not block comment then it cannot have \n                // @param comment that can be parsed\n                return "";\n            }\n            \n            for (var i = 0; i < fncDocComments.length; i++) {\n                var commentContents = fncDocComments[i].content;\n                for (var j = commentContents.indexOf("@param", 0); 0 <= j; j = commentContents.indexOf("@param", j)) {\n                    j += 6;\n                    if (!Comment.isSpaceChar(commentContents, j)) {\n                        // This is not param tag but a tag line @paramxxxxx\n                        continue;\n                    }\n\n                    // This is param tag. Check if it is what we are looking for\n                    j = Comment.consumeLeadingSpace(commentContents, j);\n                    if (j == -1) {\n                        break;\n                    }\n                    \n                    // Ignore the type expression\n                    if (commentContents.charCodeAt(j) == LexCodeLC) {\n                        j++;\n                        // Consume the type\n                        var charCode = 0;\n                        for (var curlies = 1; j < commentContents.length; j++) {\n                            charCode = commentContents.charCodeAt(j);\n                            // { character means we need to find another } to match the found one\n                            if (charCode == LexCodeLC) {\n                                curlies++;\n                                continue;\n                            }\n\n                            // } char\n                            if (charCode == LexCodeRC) {\n                                curlies--;\n                                if (curlies == 0) {\n                                    // We do not have any more } to match the type expression is ignored completely\n                                    break;\n                                } else {\n                                    // there are more { to be matched with }\n                                    continue;\n                                }\n                            }\n\n                            // Found start',
v27671=v27672+' of another tag\n                            if (charCode == LexCodeAtSign) {\n                                break;\n                            }\n                        }\n\n                        // End of the comment\n                        if (j == commentContents.length) {\n                            break;\n                        }\n\n                        // End of the tag, go onto looking for next tag\n                        if (charCode == LexCodeAtSign) {\n                            continue;\n                        }\n\n                        j = Comment.consumeLeadingSpace(commentContents, j + 1);\n                        if (j == -1) {\n                            break;\n                        }\n                    }\n\n                    // Parameter name\n                    if (param != commentContents.substr(j, param.length) || !Comment.isSpaceChar(commentContents, j + param.length)) {\n                        // this is not the parameter we are looking for\n                        continue;\n                    }\n\n                    // Found the parameter we were looking for\n                    j = Comment.consumeLeadingSpace(commentContents, j + param.length);\n                    if (j == -1) {\n                        return "";\n                    }\n                    \n                    var endOfParam = commentContents.indexOf("@", j);\n                    var paramHelpString = commentContents.substring(j, endOfParam < 0 ? commentContents.length : endOfParam);\n\n                    // Find alignement spaces to remove\n                    var paramSpacesToRemove: number = undefined;\n                    var paramLineIndex = commentContents.substring(0, j).lastIndexOf("\\n") + 1;\n                    if (paramLineIndex != 0) {\n                        if (paramLineIndex < j && commentContents.charAt(paramLineIndex + 1) == "\\r") {\n                            paramLineIndex++;\n                        }\n                    }\n                    var startSpaceRemovalIndex = Comment.consumeLeadingSpace(commentContents, paramLineIndex);\n                    if (startSpaceRemovalIndex != j && commentContents.charAt(startSpaceRemovalIndex) == "*") {\n                        paramSpacesToRemove = j - startSpaceRemovalIndex - 1;\n                    }\n\n                    // Clean jsDocComment and return\n                    return Comment.cleanJSDocComment(paramHelpString, paramSpacesToRemove);\n                }\n            }\n\n            return "";\n        }\n\n        static getDocCommentTextOfSignatures(signatures: Signature[]) {\n            var comments: string[] = [];\n            for (var i = 0; i < signatures.length; i++) {\n                var signatureDocComment = TypeScript.Comment.getDocCommentText(signatures[i].declAST.getDocComments());\n                if (signatureDocComment != "") {\n                    comments.push(signatureDocComment);\n                }\n            }\n\n            return comments.join("\\n");\n        }\n    }\n\n    export class DebuggerStatement extends Statement {\n        constructor () {\n            super(NodeType.Debugger);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeLineToOutput("debugger;");\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript.AstWalkerWithDetailCallback {\n    export interface AstWalkerDetailCallback {\n        EmptyCallback? (pre, ast: AST): bool;\n        EmptyExprCallback? (pre, ast: AST): bool;\n        TrueCallback? (pre, ast: AST): bool;\n        FalseCallback? (pre, ast: AST): bool;\n        ThisCallback? (pre, ast: AST): bool;\n        SuperCallback? (pre, ast: AST): bool;\n        QStringCallback? (pre, ast: AST): bool;\n        RegexCallback? (pre, ast: AST): bool;\n        NullCallback? (pre, ast: AST): bool;\n        ArrayLitCallback? (pre, ast: AST): bool;\n        ObjectLitCallback? (pre, ast: AST): bool;\n        VoidCallback? (pre, ast: AST): bool;\n        CommaCallback? (pre, ast: AST): bool;\n        PosCallback? (pre, ast: AST): bool;\n        NegCallback? (pre, ast: AST): bool;\n        DeleteCallback? (pre, ast: AST): bool;\n        AwaitCal',
v27670=v27671+"lback? (pre, ast: AST): bool;\n        InCallback? (pre, ast: AST): bool;\n        DotCallback? (pre, ast: AST): bool;\n        FromCallback? (pre, ast: AST): bool;\n        IsCallback? (pre, ast: AST): bool;\n        InstOfCallback? (pre, ast: AST): bool;\n        TypeofCallback? (pre, ast: AST): bool;\n        NumberLitCallback? (pre, ast: AST): bool;\n        NameCallback? (pre, identifierAst: Identifier): bool;\n        TypeRefCallback? (pre, ast: AST): bool;\n        IndexCallback? (pre, ast: AST): bool;\n        CallCallback? (pre, ast: AST): bool;\n        NewCallback? (pre, ast: AST): bool;\n        AsgCallback? (pre, ast: AST): bool;\n        AsgAddCallback? (pre, ast: AST): bool;\n        AsgSubCallback? (pre, ast: AST): bool;\n        AsgDivCallback? (pre, ast: AST): bool;\n        AsgMulCallback? (pre, ast: AST): bool;\n        AsgModCallback? (pre, ast: AST): bool;\n        AsgAndCallback? (pre, ast: AST): bool;\n        AsgXorCallback? (pre, ast: AST): bool;\n        AsgOrCallback? (pre, ast: AST): bool;\n        AsgLshCallback? (pre, ast: AST): bool;\n        AsgRshCallback? (pre, ast: AST): bool;\n        AsgRs2Callback? (pre, ast: AST): bool;\n        QMarkCallback? (pre, ast: AST): bool;\n        LogOrCallback? (pre, ast: AST): bool;\n        LogAndCallback? (pre, ast: AST): bool;\n        OrCallback? (pre, ast: AST): bool;\n        XorCallback? (pre, ast: AST): bool;\n        AndCallback? (pre, ast: AST): bool;\n        EqCallback? (pre, ast: AST): bool;\n        NeCallback? (pre, ast: AST): bool;\n        EqvCallback? (pre, ast: AST): bool;\n        NEqvCallback? (pre, ast: AST): bool;\n        LtCallback? (pre, ast: AST): bool;\n        LeCallback? (pre, ast: AST): bool;\n        GtCallback? (pre, ast: AST): bool;\n        GeCallback? (pre, ast: AST): bool;\n        AddCallback? (pre, ast: AST): bool;\n        SubCallback? (pre, ast: AST): bool;\n        MulCallback? (pre, ast: AST): bool;\n        DivCallback? (pre, ast: AST): bool;\n        ModCallback? (pre, ast: AST): bool;\n        LshCallback? (pre, ast: AST): bool;\n        RshCallback? (pre, ast: AST): bool;\n        Rs2Callback? (pre, ast: AST): bool;\n        NotCallback? (pre, ast: AST): bool;\n        LogNotCallback? (pre, ast: AST): bool;\n        IncPreCallback? (pre, ast: AST): bool;\n        DecPreCallback? (pre, ast: AST): bool;\n        IncPostCallback? (pre, ast: AST): bool;\n        DecPostCallback? (pre, ast: AST): bool;\n        TypeAssertionCallback? (pre, ast: AST): bool;\n        FuncDeclCallback? (pre, funcDecl: FuncDecl): bool;\n        MemberCallback? (pre, ast: AST): bool;\n        VarDeclCallback? (pre, varDecl: VarDecl): bool;\n        ArgDeclCallback? (pre, ast: AST): bool;\n        ReturnCallback? (pre, ast: AST): bool;\n        BreakCallback? (pre, ast: AST): bool;\n        ContinueCallback? (pre, ast: AST): bool;\n        ThrowCallback? (pre, ast: AST): bool;\n        ForCallback? (pre, ast: AST): bool;\n        ForInCallback? (pre, ast: AST): bool;\n        IfCallback? (pre, ast: AST): bool;\n        WhileCallback? (pre, ast: AST): bool;\n        DoWhileCallback? (pre, ast: AST): bool;\n        BlockCallback? (pre, block: Block): bool;\n        CaseCallback? (pre, ast: AST): bool;\n        SwitchCallback? (pre, ast: AST): bool;\n        TryCallback? (pre, ast: AST): bool;\n        TryCatchCallback? (pre, ast: AST): bool;\n        TryFinallyCallback? (pre, ast: AST): bool;\n        FinallyCallback? (pre, ast: AST): bool;\n        CatchCallback? (pre, ast: AST): bool;\n        ListCallback? (pre, astList: ASTList): bool;\n        ScriptCallback? (pre, script: Script): bool;\n        ClassDeclarationCallback? (pre, ast: AST): bool;\n        InterfaceDeclarationCallback? (pre, interfaceDecl: InterfaceDeclaration): bool;\n        ModuleDeclarationCallback? (pre, moduleDecl: ModuleDeclaration): bool;\n        ImportDeclarationCallback? (pre, ast: AST): bool;\n        WithCallback? (pre, ast: AST): bool;\n        LabelCallback? (pre, labelAST: AST): bool;\n        LabeledStatementCallback? (pre, ast: AST): bool;\n        EBStartCallback? (pre, ast: AST): bool;\n        GotoEBCallback? (pre, ast: AST): bool;\n        EndCodeCallback? (pre, ast: AST): bool;\n        ErrorCallback? (pre, ast: AST): bool;\n        CommentCallback? (pre, ast: AST): bool;\n        DebuggerCallback? (pre, ast: AST): bool;\n        DefaultCallback? (pre, ast: AST): bool;\n    }\n\n    export function walk(script: Script, callback: AstWalkerDetailCallback): void {\n        var pre = (cur: AST, parent: AST) => {\n            walker.options.goChildren = AstWalkerCallback(true, cur, callback);\n            return cur;\n        }\n\n        var post = (cur: AST, parent: AST) => {\n            AstWalkerCallback(false, cur, callback);\n            return cur;\n        }\n\n        var walker = TypeScript.getAstWalkerFactory().getWalker(pre, post);\n        walker.walk(script, null);\n    }\n\n    function AstWalkerCallback(pre: bool, ast: AST, callback: AstWalkerDetailCallback): bool {\n        // See if the Callback needs to be handled using spe",
v27669=v27670+'cific one or default one\n        var nodeType = ast.nodeType;\n        var callbackString = (<any>NodeType)._map[nodeType] + "Callback";\n        if (callback[callbackString]) {\n            return callback[callbackString](pre, ast);\n        }\n\n        if (callback.DefaultCallback) {\n            return callback.DefaultCallback(pre, ast);\n        }\n\n        return true;\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export interface IAstWalker {\n        walk(ast: AST, parent: AST): AST;\n        options: AstWalkOptions;\n        state: any; // user state object\n    }\n\n    export class AstWalkOptions {\n        public goChildren = true;\n        public goNextSibling = true;\n        public reverseSiblings = false; // visit siblings in reverse execution order\n\n        public stopWalk(stop:bool = true) {\n            this.goChildren = !stop;\n            this.goNextSibling = !stop;\n        }\n    }\n\n    export interface IAstWalkCallback {\n        (ast: AST, parent: AST, walker: IAstWalker): AST;\n    }\n\n    export interface IAstWalkChildren {\n        (preAst: AST, parent: AST, walker: IAstWalker): void;\n    }\n\n    class AstWalker implements IAstWalker {\n        constructor (\n            private childrenWalkers: IAstWalkChildren[],\n            private pre: IAstWalkCallback,\n            private post: IAstWalkCallback,\n            public options: AstWalkOptions,\n            public state: any) {\n        }\n\n        public walk(ast: AST, parent: AST): AST {\n            var preAst = this.pre(ast, parent, this);\n            if (preAst === undefined) {\n                preAst = ast;\n            }\n            if (this.options.goChildren) {\n                var svGoSib = this.options.goNextSibling;\n                this.options.goNextSibling = true;\n                // Call the "walkChildren" function corresponding to "nodeType".\n                this.childrenWalkers[ast.nodeType](ast, parent, this);\n                this.options.goNextSibling = svGoSib;\n            }\n            else {\n                // no go only applies to children of node issuing it\n                this.options.goChildren = true;\n            }\n            if (this.post) {\n                var postAst = this.post(preAst, parent, this);\n                if (postAst === undefined) {\n                    postAst = preAst;\n                }\n                return postAst;\n            }\n            else {\n                return preAst;\n            }\n        }\n    }\n\n    export class AstWalkerFactory {\n        private childrenWalkers: IAstWalkChildren[] = [];\n\n        constructor () {\n            this.initChildrenWalkers();\n        }\n\n        public walk(ast: AST, pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any): AST {\n            return this.getWalker(pre, post, options, state).walk(ast, null)\n        }\n\n        public getWalker(pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any): IAstWalker {\n            return this.getSlowWalker(pre, post, options, state);\n        }\n\n        private getSlowWalker(pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any): IAstWalker {\n            if (!options) {\n                options = new AstWalkOptions();\n            }\n\n            return new AstWalker(this.childrenWalkers, pre, post, options, state);\n        }\n\n        private initChildrenWalkers(): void {\n            this.childrenWalkers[NodeType.None] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Empty] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.EmptyExpr] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.True] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.False] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.This] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Super] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.QString] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Regex] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Null] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.ArrayLit] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.ObjectLit] = ChildrenWalkers.walkUnaryExpressionChild',
v27668=v27669+"ren;\n            this.childrenWalkers[NodeType.Void] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.Comma] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Pos] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.Neg] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.Delete] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.Await] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.In] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Dot] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.From] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Is] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.InstOf] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Typeof] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.NumberLit] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Name] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.TypeRef] = ChildrenWalkers.walkTypeReferenceChildren;\n            this.childrenWalkers[NodeType.Index] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Call] = ChildrenWalkers.walkCallExpressionChildren;\n            this.childrenWalkers[NodeType.New] = ChildrenWalkers.walkCallExpressionChildren;\n            this.childrenWalkers[NodeType.Asg] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgAdd] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgSub] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgDiv] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgMul] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgMod] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgAnd] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgXor] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgOr] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgLsh] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgRsh] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgRs2] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.ConditionalExpression] = ChildrenWalkers.walkTrinaryExpressionChildren;\n            this.childrenWalkers[NodeType.LogOr] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.LogAnd] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Or] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Xor] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.And] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Eq] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Ne] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Eqv] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.NEqv] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Lt] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Le] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Gt] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Ge] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Add] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Sub] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Mul] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Div] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Mod] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Lsh] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Rsh] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Rs2] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalker",
v27667=v27668+'s[NodeType.Not] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.LogNot] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.IncPre] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.DecPre] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.IncPost] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.DecPost] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.TypeAssertion] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.FuncDecl] = ChildrenWalkers.walkFuncDeclChildren;\n            this.childrenWalkers[NodeType.Member] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.VarDecl] = ChildrenWalkers.walkBoundDeclChildren;\n            this.childrenWalkers[NodeType.ArgDecl] = ChildrenWalkers.walkBoundDeclChildren;\n            this.childrenWalkers[NodeType.Return] = ChildrenWalkers.walkReturnStatementChildren;\n            this.childrenWalkers[NodeType.Break] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Continue] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Throw] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.For] = ChildrenWalkers.walkForStatementChildren;\n            this.childrenWalkers[NodeType.ForIn] = ChildrenWalkers.walkForInStatementChildren;\n            this.childrenWalkers[NodeType.If] = ChildrenWalkers.walkIfStatementChildren;\n            this.childrenWalkers[NodeType.While] = ChildrenWalkers.walkWhileStatementChildren;\n            this.childrenWalkers[NodeType.DoWhile] = ChildrenWalkers.walkDoWhileStatementChildren;\n            this.childrenWalkers[NodeType.Block] = ChildrenWalkers.walkBlockChildren;\n            this.childrenWalkers[NodeType.Case] = ChildrenWalkers.walkCaseStatementChildren;\n            this.childrenWalkers[NodeType.Switch] = ChildrenWalkers.walkSwitchStatementChildren;\n            this.childrenWalkers[NodeType.Try] = ChildrenWalkers.walkTryChildren;\n            this.childrenWalkers[NodeType.TryCatch] = ChildrenWalkers.walkTryCatchChildren;\n            this.childrenWalkers[NodeType.TryFinally] = ChildrenWalkers.walkTryFinallyChildren;\n            this.childrenWalkers[NodeType.Finally] = ChildrenWalkers.walkFinallyChildren;\n            this.childrenWalkers[NodeType.Catch] = ChildrenWalkers.walkCatchChildren;\n            this.childrenWalkers[NodeType.List] = ChildrenWalkers.walkListChildren;\n            this.childrenWalkers[NodeType.Script] = ChildrenWalkers.walkScriptChildren;\n            this.childrenWalkers[NodeType.ClassDeclaration] = ChildrenWalkers.walkClassDeclChildren;\n            this.childrenWalkers[NodeType.InterfaceDeclaration] = ChildrenWalkers.walkTypeDeclChildren;\n            this.childrenWalkers[NodeType.ModuleDeclaration] = ChildrenWalkers.walkModuleDeclChildren;\n            this.childrenWalkers[NodeType.ImportDeclaration] = ChildrenWalkers.walkImportDeclChildren;\n            this.childrenWalkers[NodeType.With] = ChildrenWalkers.walkWithStatementChildren;\n            this.childrenWalkers[NodeType.Label] = ChildrenWalkers.walkLabelChildren;\n            this.childrenWalkers[NodeType.LabeledStatement] = ChildrenWalkers.walkLabeledStatementChildren;\n            this.childrenWalkers[NodeType.EBStart] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.GotoEB] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.EndCode] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Error] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Comment] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Debugger] = ChildrenWalkers.walkNone;\n\n            // Verify the code is up to date with the enum\n            for (var e in (<any>NodeType)._map) {\n                if ((<any>this.childrenWalkers)[e] === undefined) {\n                    throw new Error("initWalkers function is not up to date with enum content!");\n                }\n            }\n        }\n    }\n\n    var globalAstWalkerFactory: AstWalkerFactory;\n\n    export function getAstWalkerFactory(): AstWalkerFactory {\n        if (!globalAstWalkerFactory) {\n            globalAstWalkerFactory = new AstWalkerFactory();\n        }\n        return globalAstWalkerFactory;\n    }\n\n    module ChildrenWalkers {\n        export function walkNone(preAst: ASTList, parent: AST, walker: IAstWalker): void {\n            // Nothing to do\n        }\n\n        export function walkListChildren(preAst: ASTList, parent: AST, walker: IAstWalker): void {\n            var len = preAst.members.length;\n            if (walker.options.reverseSiblings) {\n                for (var i = len - 1; i >= 0; i--) {\n                    if (walker.options.goNextSibling) {\n                        preAst.m',
v27666=v27667+"embers[i] = walker.walk(preAst.members[i], preAst);\n                    }\n                }\n            }\n            else {\n                for (var i = 0; i < len; i++) {\n                    if (walker.options.goNextSibling) {\n                        preAst.members[i] = walker.walk(preAst.members[i], preAst);\n                    }\n                }\n            }\n        }\n\n        export function walkUnaryExpressionChildren(preAst: UnaryExpression, parent: AST, walker: IAstWalker): void {\n            if (preAst.castTerm) {\n                preAst.castTerm = walker.walk(preAst.castTerm, preAst);\n            }\n            if (preAst.operand) {\n                preAst.operand = walker.walk(preAst.operand, preAst);\n            }\n        }\n\n        export function walkBinaryExpressionChildren(preAst: BinaryExpression, parent: AST, walker: IAstWalker): void {\n            if (walker.options.reverseSiblings) {\n                if (preAst.operand2) {\n                    preAst.operand2 = walker.walk(preAst.operand2, preAst);\n                }\n                if ((preAst.operand1) && (walker.options.goNextSibling)) {\n                    preAst.operand1 = walker.walk(preAst.operand1, preAst);\n                }\n            } else {\n                if (preAst.operand1) {\n                    preAst.operand1 = walker.walk(preAst.operand1, preAst);\n                }\n                if ((preAst.operand2) && (walker.options.goNextSibling)) {\n                    preAst.operand2 = walker.walk(preAst.operand2, preAst);\n                }\n            }\n        }\n\n        export function walkTypeReferenceChildren(preAst: TypeReference, parent: AST, walker: IAstWalker): void {\n            if (preAst.term) {\n                preAst.term = walker.walk(preAst.term, preAst);\n            }\n        }\n\n        export function walkCallExpressionChildren(preAst: CallExpression, parent: AST, walker: IAstWalker): void {\n            if (!walker.options.reverseSiblings) {\n                preAst.target = walker.walk(preAst.target, preAst);\n            }\n            if (preAst.arguments && (walker.options.goNextSibling)) {\n                preAst.arguments = <ASTList> walker.walk(preAst.arguments, preAst);\n            }\n            if ((walker.options.reverseSiblings) && (walker.options.goNextSibling)) {\n                preAst.target = walker.walk(preAst.target, preAst);\n            }\n        }\n\n        export function walkTrinaryExpressionChildren(preAst: ConditionalExpression, parent: AST, walker: IAstWalker): void {\n            if (preAst.operand1) {\n                preAst.operand1 = walker.walk(preAst.operand1, preAst);\n            }\n            if (preAst.operand2 && (walker.options.goNextSibling)) {\n                preAst.operand2 = walker.walk(preAst.operand2, preAst);\n            }\n            if (preAst.operand3 && (walker.options.goNextSibling)) {\n                preAst.operand3 = walker.walk(preAst.operand3, preAst);\n            }\n        }\n\n        export function walkFuncDeclChildren(preAst: FuncDecl, parent: AST, walker: IAstWalker): void {\n            if (preAst.name) {\n                preAst.name = <Identifier>walker.walk(preAst.name, preAst);\n            }\n            if (preAst.arguments && (preAst.arguments.members.length > 0) && (walker.options.goNextSibling)) {\n                preAst.arguments = <ASTList>walker.walk(preAst.arguments, preAst);\n            }\n            if (preAst.returnTypeAnnotation && (walker.options.goNextSibling)) {\n                preAst.returnTypeAnnotation = walker.walk(preAst.returnTypeAnnotation, preAst);\n            }\n            if (preAst.bod && (preAst.bod.members.length > 0) && (walker.options.goNextSibling)) {\n                preAst.bod = <ASTList>walker.walk(preAst.bod, preAst);\n            }\n        }\n\n        export function walkBoundDeclChildren(preAst: BoundDecl, parent: AST, walker: IAstWalker): void {\n            if (preAst.id) {\n                preAst.id = <Identifier>walker.walk(preAst.id, preAst);\n            }\n            if (preAst.init) {\n                preAst.init = walker.walk(preAst.init, preAst);\n            }\n            if ((preAst.typeExpr) && (walker.options.goNextSibling)) {\n                preAst.typeExpr = walker.walk(preAst.typeExpr, preAst);\n            }\n        }\n\n        export function walkReturnStatementChildren(preAst: ReturnStatement, parent: AST, walker: IAstWalker): void {\n            if (preAst.returnExpression) {\n                preAst.returnExpression = walker.walk(preAst.returnExpression, preAst);\n            }\n        }\n\n        export function walkForStatementChildren(preAst: ForStatement, parent: AST, walker: IAstWalker): void {\n            if (preAst.init) {\n                preAst.init = walker.walk(preAst.init, preAst);\n            }\n\n            if (preAst.cond && walker.options.goNextSibling) {\n                preAst.cond = walker.walk(preAst.cond, preAst);\n            }\n\n            if (preAst.incr && walker.options.goNextSibling) {\n                pr",
v27665=v27666+"eAst.incr = walker.walk(preAst.incr, preAst);\n            }\n\n            if (preAst.body && walker.options.goNextSibling) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkForInStatementChildren(preAst: ForInStatement, parent: AST, walker: IAstWalker): void {\n            preAst.lval = walker.walk(preAst.lval, preAst);\n            if (walker.options.goNextSibling) {\n                preAst.obj = walker.walk(preAst.obj, preAst);\n            }\n            if (preAst.body && (walker.options.goNextSibling)) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkIfStatementChildren(preAst: IfStatement, parent: AST, walker: IAstWalker): void {\n            preAst.cond = walker.walk(preAst.cond, preAst);\n            if (preAst.thenBod && (walker.options.goNextSibling)) {\n                preAst.thenBod = walker.walk(preAst.thenBod, preAst);\n            }\n            if (preAst.elseBod && (walker.options.goNextSibling)) {\n                preAst.elseBod = walker.walk(preAst.elseBod, preAst);\n            }\n        }\n\n        export function walkWhileStatementChildren(preAst: WhileStatement, parent: AST, walker: IAstWalker): void {\n            preAst.cond = walker.walk(preAst.cond, preAst);\n            if (preAst.body && (walker.options.goNextSibling)) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkDoWhileStatementChildren(preAst: DoWhileStatement, parent: AST, walker: IAstWalker): void {\n            preAst.cond = walker.walk(preAst.cond, preAst);\n            if (preAst.body && (walker.options.goNextSibling)) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkBlockChildren(preAst: Block, parent: AST, walker: IAstWalker): void {\n            if (preAst.statements) {\n                preAst.statements = <ASTList>walker.walk(preAst.statements, preAst);\n            }\n        }\n\n        export function walkCaseStatementChildren(preAst: CaseStatement, parent: AST, walker: IAstWalker): void {\n            if (preAst.expr) {\n                preAst.expr = walker.walk(preAst.expr, preAst);\n            }\n\n            if (preAst.body && walker.options.goNextSibling) {\n                preAst.body = <ASTList>walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkSwitchStatementChildren(preAst: SwitchStatement, parent: AST, walker: IAstWalker): void {\n            if (preAst.val) {\n                preAst.val = walker.walk(preAst.val, preAst);\n            }\n\n            if ((preAst.caseList) && walker.options.goNextSibling) {\n                preAst.caseList = <ASTList>walker.walk(preAst.caseList, preAst);\n            }\n        }\n\n        export function walkTryChildren(preAst: Try, parent: AST, walker: IAstWalker): void {\n            if (preAst.body) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkTryCatchChildren(preAst: TryCatch, parent: AST, walker: IAstWalker): void {\n            if (preAst.tryNode) {\n                preAst.tryNode = <Try>walker.walk(preAst.tryNode, preAst);\n            }\n\n            if ((preAst.catchNode) && walker.options.goNextSibling) {\n                preAst.catchNode = <Catch>walker.walk(preAst.catchNode, preAst);\n            }\n        }\n\n        export function walkTryFinallyChildren(preAst: TryFinally, parent: AST, walker: IAstWalker): void {\n            if (preAst.tryNode) {\n                preAst.tryNode = walker.walk(preAst.tryNode, preAst);\n            }\n\n            if (preAst.finallyNode && walker.options.goNextSibling) {\n                preAst.finallyNode = <Finally>walker.walk(preAst.finallyNode, preAst);\n            }\n        }\n\n        export function walkFinallyChildren(preAst: Finally, parent: AST, walker: IAstWalker): void {\n            if (preAst.body) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkCatchChildren(preAst: Catch, parent: AST, walker: IAstWalker): void {\n            if (preAst.param) {\n                preAst.param = <VarDecl>walker.walk(preAst.param, preAst);\n            }\n\n            if ((preAst.body) && walker.options.goNextSibling) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkRecordChildren(preAst: NamedDeclaration, parent: AST, walker: IAstWalker): void {\n            preAst.name = <Identifier>walker.walk(preAst.name, preAst);\n            if (walker.options.goNextSibling && preAst.members) {\n                preAst.members = <ASTList>walker.walk(preAst.members, preAst);\n            }\n\n        }\n\n        export function walkNamedTypeChildren(preAst: TypeDeclaration, parent: AST, walker: IAstWalker): void {\n            walkRecordChildren(preAst, parent, walker);\n        }\n",
v27664=v27665+'\n        export function walkClassDeclChildren(preAst: ClassDeclaration, parent: AST, walker: IAstWalker): void {\n            walkNamedTypeChildren(preAst, parent, walker);\n\n            if (walker.options.goNextSibling && preAst.extendsList) {\n                preAst.extendsList = <ASTList>walker.walk(preAst.extendsList, preAst);\n            }\n\n            if (walker.options.goNextSibling && preAst.implementsList) {\n                preAst.implementsList = <ASTList>walker.walk(preAst.implementsList, preAst);\n            }\n        }\n\n        export function walkScriptChildren(preAst: Script, parent: AST, walker: IAstWalker): void {\n            if (preAst.bod) {\n                preAst.bod = <ASTList>walker.walk(preAst.bod, preAst);\n            }\n        }\n\n        export function walkTypeDeclChildren(preAst: InterfaceDeclaration, parent: AST, walker: IAstWalker): void {\n            walkNamedTypeChildren(preAst, parent, walker);\n\n            // walked arguments as part of members\n            if (walker.options.goNextSibling && preAst.extendsList) {\n                preAst.extendsList = <ASTList>walker.walk(preAst.extendsList, preAst);\n            }\n\n            if (walker.options.goNextSibling && preAst.implementsList) {\n                preAst.implementsList = <ASTList>walker.walk(preAst.implementsList, preAst);\n            }\n        }\n\n        export function walkModuleDeclChildren(preAst: ModuleDeclaration, parent: AST, walker: IAstWalker): void {\n            walkRecordChildren(preAst, parent, walker);\n        }\n\n        export function walkImportDeclChildren(preAst: ImportDeclaration, parent: AST, walker: IAstWalker): void {\n            if (preAst.id) {\n                preAst.id = <Identifier>walker.walk(preAst.id, preAst);\n            }\n            if (preAst.alias) {\n                preAst.alias = walker.walk(preAst.alias, preAst);\n            }\n        }\n\n        export function walkWithStatementChildren(preAst: WithStatement, parent: AST, walker: IAstWalker): void {\n            if (preAst.expr) {\n                preAst.expr = walker.walk(preAst.expr, preAst);\n            }\n\n            if (preAst.body && walker.options.goNextSibling) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkLabelChildren(preAst: Label, parent: AST, walker: IAstWalker): void {\n            //TODO: Walk "id"?\n        }\n\n        export function walkLabeledStatementChildren(preAst: LabeledStatement, parent: AST, walker: IAstWalker): void {\n            preAst.labels = <ASTList>walker.walk(preAst.labels, preAst);\n            if (walker.options.goNextSibling) {\n                preAst.stmt = walker.walk(preAst.stmt, preAst);\n            }\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nmodule TypeScript {\n    class Base64Format {\n        static encodedValues = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\';\n        static encode(inValue: number) {\n            if (inValue < 64) {\n                return encodedValues.charAt(inValue);\n            }\n            throw TypeError(inValue + ": not a 64 based value");\n        }\n\n        static decodeChar(inChar: string) {\n            if (inChar.length === 1) {\n                return encodedValues.indexOf(inChar);\n            } else {\n                throw TypeError(\'"\' + inChar + \'" must have length 1\');\n            }\n        }\n    }\n\n    export class Base64VLQFormat {\n        static encode(inValue: number) {\n            // Add a new least significant bit that has the sign of the value.\n            // if negative number the least significant bit that gets added to the number has value 1\n            // else least significant bit value that gets added is 0\n            // eg. -1 changes to binary : 01 [1] => 3\n            //     +1 changes to binary : 01 [0] => 2\n            if (inValue < 0) {\n                inValue = ((-inValue) << 1) + 1;\n            }\n            else {\n                inValue = inValue << 1;\n            }\n\n            // Encode 5 bits at a time starting from least significant bits\n            var encodedStr = "";\n            do {\n                var currentDigit = inValue & 31; // 11111\n                inValue = inValue >> 5;\n                if (inValue > 0) {\n                    // There are still more digits to decode, set the msb (6th bit)\n                    currentDigit = currentDigit | 32; \n               ',
v27663=v27664+' }\n                encodedStr = encodedStr + Base64Format.encode(currentDigit);\n            } while (inValue > 0);\n\n            return encodedStr;\n        }\n\n        static decode(inString: string) {\n            var result = 0;\n            var negative = false;\n\n            var shift = 0;\n            for (var i = 0; i < inString.length; i++) {\n                var byte = Base64Format.decodeChar(inString[i]);\n                if (i === 0) {\n                    // Sign bit appears in the LSBit of the first value\n                    if ((byte & 1) === 1) {\n                        negative = true;\n                    }\n                    result = (byte >> 1) & 15; // 1111x\n                } else {\n                    result = result | ((byte & 31) << shift); // 11111\n                }\n\n                shift += (i == 0) ? 4 : 5;\n\n                if ((byte & 32) === 32) {\n                    // Continue\n                } else {\n                    return { value: negative ? -(result) : result, rest: inString.substr(i + 1) };\n                }\n            }\n\n            throw new Error(\'Base64 value "\' + inString + \'" finished with a continuation bit\');\n        }\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class Binder {\n        constructor(public checker: TypeChecker) { }\n        \n        public resolveBaseTypeLinks(typeLinks: TypeLink[], scope: SymbolScope) {\n            var extendsList: Type[] = null;\n            if (typeLinks) {\n                extendsList = new Type[];\n                for (var i = 0, len = typeLinks.length; i < len; i++) {\n                    extendsList[i] = this.checker.resolveBaseTypeLink(typeLinks[i], scope);\n                }\n            }\n            return extendsList;\n        }\n\n        public resolveBases(scope: SymbolScope, type: Type) {\n            type.extendsList = this.resolveBaseTypeLinks(type.extendsTypeLinks, scope);\n\n            var i = 0, len = type.extendsList.length;\n            var derivedIsClass = type.isClassInstance();\n            for (; i < len; i++) {\n                var baseIsClass = type.extendsList[i].isClassInstance();\n                if (type.extendsList[i] != this.checker.anyType) {\n                    var baseRef = type.extendsTypeLinks[i].ast;\n                    if (derivedIsClass) {\n                        if (!baseIsClass) {\n                            this.checker.errorReporter.simpleError(baseRef,\n                                                                     "A class may only extend other classes, " + type.extendsList[i].symbol.fullName() + " is not a class.");\n                        }\n                    }\n                    else {\n                        if (baseIsClass) {\n                            this.checker.errorReporter.simpleError(baseRef,\n                                                                     "An interface may only extend other interfaces, " + type.extendsList[i].symbol.fullName() + " is a class.");\n                        }\n                    }\n                }\n            }\n\n            type.implementsList = this.resolveBaseTypeLinks(type.implementsTypeLinks, scope);\n\n            if (type.implementsList) {\n                for (i = 0, len = type.implementsList.length; i < len; i++) {\n                    var iface = type.implementsList[i];\n                    var baseRef = type.implementsTypeLinks[i].ast;\n                    if (iface.isClassInstance()) {\n                        if (derivedIsClass) {\n                            this.checker.errorReporter.simpleError(baseRef,\n                                                                     "A class may only implement an interface; " + iface.symbol.fullName() + " is a class.");\n                        }\n                    }\n                }\n            }\n        }\n\n        public resolveSignatureGroup(signatureGroup: SignatureGroup, scope: SymbolScope, instanceType: Type) {\n            var supplyVar = !(signatureGroup.hasImplementation);\n            for (var i = 0, len = signatureGroup.signatures.length; i < len; i++) {\n                var signature = signatureGroup.signatures[i];\n                if (instanceType) {\n                    signature.returnType.type = instanceType;\n                }\n                else {\n                    this.checker.resolveTypeLink(scope, signature.returnType, supplyVar);\n               ',
v27662=v27663+' }\n                var paramLen = signature.parameters.length;\n                for (var j = 0; j < paramLen; j++) {\n                    this.bindSymbol(scope, signature.parameters[j]);\n                }\n                if (signature.hasVariableArgList) {\n                    // check that last parameter has an array type\n                    var lastParam = <ParameterSymbol>signature.parameters[paramLen - 1];\n                    lastParam.argsOffset = paramLen - 1;\n                    if (!lastParam.getType().isArray()) {\n                        this.checker.errorReporter.simpleErrorFromSym(lastParam,\n                                                                 "... parameter must have array type");\n                        lastParam.parameter.typeLink.type = this.checker.makeArrayType(lastParam.parameter.typeLink.type);\n                    }\n                }\n            }\n        }\n\n        public bindType(scope: SymbolScope, type: Type, instanceType: Type): void {\n            if (instanceType) {\n                this.bindType(scope, instanceType, null);\n            }\n            if (type.hasMembers()) {\n                var members = type.members;\n                var ambientMembers = type.ambientMembers;\n                var typeMembers = type.getAllEnclosedTypes(); // REVIEW: Should only be getting exported types?\n                var ambientTypeMembers = type.getAllAmbientEnclosedTypes(); // REVIEW: Should only be getting exported types?\n                var memberScope = new SymbolTableScope(members, ambientMembers, typeMembers, ambientTypeMembers, type.symbol);\n                var agg = new SymbolAggregateScope(type.symbol);\n                var prevCurrentModDecl = this.checker.currentModDecl;\n                var prevBindStatus = this.checker.inBind;\n                agg.addParentScope(memberScope);\n                agg.addParentScope(scope);\n                if (type.isModuleType()) {\n                    this.checker.currentModDecl = <ModuleDeclaration>type.symbol.declAST;\n                    this.checker.inBind = true;\n                }\n                if (members) {\n                    this.bind(agg, type.members.allMembers); // REVIEW: Should only be getting exported types?\n                }\n                if (typeMembers) {\n                    this.bind(agg, typeMembers.allMembers);\n                }\n                if (ambientMembers) {\n                    this.bind(agg, ambientMembers.allMembers);\n                }\n                if (ambientTypeMembers) {\n                    this.bind(agg, ambientTypeMembers.allMembers);\n                }\n                this.checker.currentModDecl = prevCurrentModDecl;\n                this.checker.inBind = prevBindStatus;\n            }\n            if (type.extendsTypeLinks) {\n                this.resolveBases(scope, type);\n            }\n            if (type.construct) {\n                this.resolveSignatureGroup(type.construct, scope, instanceType);\n            }\n            if (type.call) {\n                this.resolveSignatureGroup(type.call, scope, null);\n            }\n            if (type.index) {\n                this.resolveSignatureGroup(type.index, scope, null);\n            }\n            if (type.elementType) {\n                this.bindType(scope, type.elementType, null);\n            }\n        }\n\n        public bindSymbol(scope: SymbolScope, symbol: Symbol) {\n            if (!symbol.bound) {\n                var prevLocationInfo = this.checker.locationInfo;\n                if ((this.checker.units) && (symbol.unitIndex >= 0) && (symbol.unitIndex < this.checker.units.length)) {\n                    this.checker.locationInfo = this.checker.units[symbol.unitIndex];\n                }\n                switch (symbol.kind()) {\n                    case SymbolKind.Type:\n\n                        if (symbol.flags & SymbolFlags.Bound) {\n                            break;\n                        }\n\n                        var typeSymbol = <TypeSymbol>symbol;\n                        typeSymbol.flags |= SymbolFlags.Bound;\n\n                        // Since type collection happens out of order, a dynamic module referenced by an import statement\n                        // may not yet be in scope when the import symbol is created.  In that case, we need to search\n                        // out the module symbol now\n                        // Note that we\'ll also want to do this in resolveTypeMembers, in case the symbol is set outside the\n                        // context of a given module  (E.g., an outer import statement)\n                        if (typeSymbol.aliasLink && !typeSymbol.type && typeSymbol.aliasLink.alias.nodeType == NodeType.Name) {\n                            var modPath = (<Identifier>typeSymbol.aliasLink.alias).text;\n                            var modSym = this.checker.findSymbolForDynamicModule(modPath, this.checker.locationInfo.filename, (id) => scope.find(id, false, true));\n                            if (modSym) {\n                                typeSymb',
v27661=v27662+'ol.type = modSym.getType();\n                            }\n                        }\n\n                        if (typeSymbol.type && typeSymbol.type != this.checker.gloModType) {\n                            this.bindType(scope, typeSymbol.type, typeSymbol.instanceType);\n\n                            // bind expansions on the parent type symbol\n                            if (typeSymbol.type.isModuleType()) {\n                                for (var i = 0; i < typeSymbol.expansions.length; i++) {\n                                    this.bindType(scope, typeSymbol.expansions[i], typeSymbol.instanceType);\n                                }\n                            }\n                        }\n                        break;\n                    case SymbolKind.Field:\n                        this.checker.resolveTypeLink(scope, (<FieldSymbol>symbol).field.typeLink,\n                                                false);\n                        break;\n                    case SymbolKind.Parameter:\n                        this.checker.resolveTypeLink(scope,\n                                                (<ParameterSymbol>symbol).parameter.typeLink,\n                                                true);\n                        break;\n                }\n                this.checker.locationInfo = prevLocationInfo;\n            }\n            symbol.bound = true;\n        }\n\n        public bind(scope: SymbolScope, table: IHashTable) {\n            table.map(\n                (key, sym, binder) => {\n                    binder.bindSymbol(scope, sym);\n                },\n                this);\n        }\n    }\n\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class DeclFileWriter {\n        public onNewLine = true;\n        constructor(private declFile: ITextWriter) {\n        }\n\n        public Write(s: string) {\n            this.declFile.Write(s);\n            this.onNewLine = false;\n        }\n\n        public WriteLine(s: string) {\n            this.declFile.WriteLine(s);\n            this.onNewLine = true;\n        }\n\n        public Close() {\n            this.declFile.Close();\n        }\n    }\n\n    export class DeclarationEmitter implements AstWalkerWithDetailCallback.AstWalkerDetailCallback {\n        private declFile: DeclFileWriter = null;\n        private indenter = new Indenter();\n        private declarationContainerStack: AST[] = [];\n        private isDottedModuleName: bool[] = [];\n        private dottedModuleEmit: string;\n        private ignoreCallbackAst: AST = null;\n        private singleDeclFile: DeclFileWriter = null;\n        private varListCount: number = 0;\n\n        private getAstDeclarationContainer() {\n            return this.declarationContainerStack[this.declarationContainerStack.length - 1];\n        }\n\n        private emitDottedModuleName() {\n            return (this.isDottedModuleName.length == 0) ? false : this.isDottedModuleName[this.isDottedModuleName.length - 1];\n        }\n\n        constructor (public checker: TypeChecker, public emitOptions: EmitOptions, public errorReporter: ErrorReporter) {\n        }\n\n        public setDeclarationFile(file: ITextWriter) {\n            this.declFile = new DeclFileWriter(file);\n        }\n\n        public Close() {\n            try {\n                // Closing files could result in exceptions, report them if they occur\n                this.declFile.Close();\n            } catch (ex) {\n                this.errorReporter.emitterError(null, ex.message);\n            }\n        }\n\n        public emitDeclarations(script: TypeScript.Script): void {\n            AstWalkerWithDetailCallback.walk(script, this);\n        }\n\n        private getIndentString(declIndent? = false) {\n            if (this.emitOptions.minWhitespace) {\n                return "";\n            }\n            else {\n                return this.indenter.getIndent();\n            }\n        }\n\n        private emitIndent() {\n            this.declFile.Write(this.getIndentString());\n        }\n\n        private canEmitSignature(declFlags: DeclFlags, canEmitGlobalAmbientDecl?: bool = true, useDeclarationContainerTop?: bool = true) {\n            var container: AST;\n            if (useDeclarationContainerTop) {\n                container = this.getAstDeclarationContainer();\n            } else {\n                container = this.declarationContainerStack[this.declarationContainerStack.length - 2];\n            }\n',
v27660=v27661+'\n            if (container.nodeType == NodeType.ModuleDeclaration && !hasFlag(declFlags, DeclFlags.Exported)) {\n                return false;\n            }\n\n            if (!canEmitGlobalAmbientDecl && container.nodeType == NodeType.Script && hasFlag(declFlags, DeclFlags.Ambient)) {\n                return false;\n            }\n\n            return true;\n        }\n\n        private canEmitPrePostAstSignature(declFlags: DeclFlags, astWithPrePostCallback: AST, preCallback: bool) {\n            if (this.ignoreCallbackAst) {\n                CompilerDiagnostics.assert(this.ignoreCallbackAst != astWithPrePostCallback, "Ignore Callback AST mismatch");\n                this.ignoreCallbackAst = null;\n                return false;\n            } else if (preCallback &&\n                !this.canEmitSignature(declFlags, true, preCallback)) {\n                this.ignoreCallbackAst = astWithPrePostCallback;\n                return false;\n            }\n\n            return true;\n        }\n\n        private getDeclFlagsString(declFlags: DeclFlags, typeString: string) {\n            var result = this.getIndentString();\n\n            // Accessor strings\n            var accessorString = "";\n            if (hasFlag(declFlags, DeclFlags.GetAccessor)) {\n                accessorString = "get ";\n            }\n            else if (hasFlag(declFlags, DeclFlags.SetAccessor)) {\n                accessorString = "set ";\n            }\n\n            // Emit export only for global export statements. The container for this would be dynamic module which is whole file\n            var container = this.getAstDeclarationContainer();\n            if (container.nodeType == NodeType.ModuleDeclaration &&\n                hasFlag((<ModuleDeclaration>container).modFlags, ModuleFlags.IsWholeFile) &&\n                hasFlag(declFlags, DeclFlags.Exported)) {\n                result += "export ";\n            }\n\n            // Static/public/private/global declare\n            if (hasFlag(declFlags, DeclFlags.LocalStatic) || hasFlag(declFlags, DeclFlags.Static)) {\n                result += "static " + accessorString;\n            }\n            else {\n                if (hasFlag(declFlags, DeclFlags.Private)) {\n                    result += "private " + accessorString;\n                }\n                else if (hasFlag(declFlags, DeclFlags.Public)) {\n                    result += "public " + accessorString;\n                }\n                else {\n                    if (accessorString == "") {\n                        result += typeString + " ";\n                    } else {\n                        result += accessorString;\n                    }\n                }\n            }\n\n            return result;\n        }\n\n        private emitDeclFlags(declFlags: DeclFlags, typeString: string) {\n            this.declFile.Write(this.getDeclFlagsString(declFlags, typeString));\n        }\n\n        private canEmitTypeAnnotationSignature(declFlag: DeclFlags = DeclFlags.None) {\n            // Private declaration, shouldnt emit type any time.\n            return !hasFlag(declFlag, DeclFlags.Private);\n        }\n\n        private pushDeclarationContainer(ast: AST) {\n            this.declarationContainerStack.push(ast);\n        }\n\n        private popDeclarationContainer(ast: AST) {\n            CompilerDiagnostics.assert(ast != this.getAstDeclarationContainer(), \'Declaration container mismatch\');\n            this.declarationContainerStack.pop();\n        }\n\n        private emitTypeNamesMember(memberName: MemberName, emitIndent? : bool = false) {\n            if (memberName.prefix == "{ ") {\n                if (emitIndent) {\n                    this.emitIndent();\n                }\n                this.declFile.WriteLine("{");\n                this.indenter.increaseIndent();\n                emitIndent = true;\n            } else if (memberName.prefix != "") {\n                if (emitIndent) {\n                    this.emitIndent();\n                }\n                this.declFile.Write(memberName.prefix);\n                emitIndent = false;\n            }\n\n            if (memberName.isString()) {\n                if (emitIndent) {\n                    this.emitIndent();\n                }\n                this.declFile.Write((<MemberNameString>memberName).text);\n            } else {\n                var ar = <MemberNameArray>memberName;\n                for (var index = 0; index < ar.entries.length; index++) {\n                    this.emitTypeNamesMember(ar.entries[index], emitIndent);\n                    if (ar.delim == "; ") {\n                        this.declFile.WriteLine(";");\n                    }\n                }\n            }\n\n            if (memberName.suffix == "}") {\n                this.indenter.decreaseIndent();\n                this.emitIndent();\n                this.declFile.Write(memberName.suffix);\n            } else {\n                this.declFile.Write(memberName.suffix);\n            }\n        }\n\n        private emitTypeSignature(type: Type) {\n            var containingScope: SymbolScope = null',
v27659=v27660+';\n            var declarationContainerAst = this.getAstDeclarationContainer();\n            switch (declarationContainerAst.nodeType) {\n                case NodeType.ModuleDeclaration:\n                case NodeType.InterfaceDeclaration:\n                case NodeType.FuncDecl:\n                    if (declarationContainerAst.type) {\n                        containingScope = declarationContainerAst.type.containedScope;\n                    }\n                    break;\n\n                case NodeType.Script:\n                    var script = <Script>declarationContainerAst;\n                    if (script.bod) {\n                        containingScope = script.bod.enclosingScope;\n                    }\n                    break;\n\n                case NodeType.ClassDeclaration:\n                    if (declarationContainerAst.type) {\n                        containingScope = declarationContainerAst.type.instanceType.containedScope;\n                    }\n                    break;\n\n                default:\n                    CompilerDiagnostics.debugPrint("Unknown containing scope");\n            }\n\n            var typeNameMembers = type.getScopedTypeNameEx(containingScope);\n            this.emitTypeNamesMember(typeNameMembers);\n        }\n\n        private emitComment(comment: Comment) {\n            var text = comment.getText();\n            if (this.declFile.onNewLine) {\n                this.emitIndent();\n            } else if (!comment.isBlockComment) {\n                this.declFile.WriteLine("");\n                this.emitIndent();\n            }\n            \n            this.declFile.Write(text[0]);\n\n            for (var i = 1; i < text.length; i++) {\n                this.declFile.WriteLine("");\n                this.emitIndent();\n                this.declFile.Write(text[i]);\n            }\n\n            if (comment.endsLine || !comment.isBlockComment) {\n                this.declFile.WriteLine("");\n            } else {\n                this.declFile.Write(" ");\n            }\n        }\n\n        private emitDeclarationComments(ast: AST, endLine?: bool);\n        private emitDeclarationComments(symbol: Symbol, endLine?: bool);\n        private emitDeclarationComments(astOrSymbol, endLine = true) {\n            if (!this.emitOptions.emitComments) {\n                return;\n            }\n\n            var declComments = <Comment[]>astOrSymbol.getDocComments();\n            if (declComments.length > 0) {\n                for (var i = 0; i < declComments.length; i++) {\n                    this.emitComment(declComments[i]);\n                }\n\n                if (endLine) {\n                    if (!this.declFile.onNewLine) {\n                        this.declFile.WriteLine("");\n                    }\n                } else {\n                    if (this.declFile.onNewLine) {\n                        this.emitIndent();\n                    }\n                }\n            }\n        }\n\n        public VarDeclCallback(pre: bool, varDecl: VarDecl): bool {\n            if (pre && this.canEmitSignature(ToDeclFlags(varDecl.varFlags), false)) {\n                var interfaceMember = (this.getAstDeclarationContainer().nodeType == NodeType.InterfaceDeclaration);\n                this.emitDeclarationComments(varDecl);\n                if (!interfaceMember) {\n                    // If it is var list of form var a, b, c = emit it only if count > 0 - which will be when emitting first var\n                    // If it is var list of form  var a = varList count will be 0\n                    if (this.varListCount >= 0) {\n                        this.emitDeclFlags(ToDeclFlags(varDecl.varFlags), "var");\n                        this.varListCount = -this.varListCount;\n                    }\n                    this.declFile.Write(varDecl.id.text);\n                } else {\n                    this.emitIndent();\n                    this.declFile.Write(varDecl.id.text);\n                    if (hasFlag(varDecl.id.flags, ASTFlags.OptionalName)) {\n                        this.declFile.Write("?");\n                    }\n                }\n\n                var type: Type = null;\n                if (varDecl.typeExpr && varDecl.typeExpr.type) {\n                    type = varDecl.typeExpr.type;\n                }\n                else if (varDecl.sym) {\n                    type = (<FieldSymbol>varDecl.sym).getType();\n                    // Dont emit inferred any\n                    if (type == this.checker.anyType) {\n                        type = null;\n                    }\n                }\n\n                if (type && this.canEmitTypeAnnotationSignature(ToDeclFlags(varDecl.varFlags))) {\n                    this.declFile.Write(": ");\n                    this.emitTypeSignature(type);\n                }\n               \n                // emitted one var decl\n                if (this.varListCount > 0) { this.varListCount--; } else if (this.varListCount < 0) { this.varListCount++; }\n\n                // Write ; or ,\n                if (this.varListCount < 0) {\n                    this.declF',
v27658=v27659+'ile.Write(", ");\n                } else {\n                    this.declFile.WriteLine(";");\n                }\n            }\n            return false;\n        }\n\n        public BlockCallback(pre: bool, block: Block): bool {\n            if (!block.isStatementBlock) {\n                if (pre) {\n                    this.varListCount = block.statements.members.length;\n                } else {\n                    this.varListCount = 0;\n                }\n                return true;\n            }\n            return false;\n        }\n\n        private emitArgDecl(argDecl: ArgDecl, funcDecl: FuncDecl) {\n            this.emitDeclarationComments(argDecl, false);\n            this.declFile.Write(argDecl.id.text);\n            if (argDecl.isOptionalArg()) {\n                this.declFile.Write("?");\n            }\n            if ((argDecl.typeExpr || argDecl.type != this.checker.anyType) &&\n                this.canEmitTypeAnnotationSignature(ToDeclFlags(funcDecl.fncFlags))) {\n                this.declFile.Write(": ");\n                this.emitTypeSignature(argDecl.type);\n            }\n        }\n\n        public FuncDeclCallback(pre: bool, funcDecl: FuncDecl): bool {\n            if (!pre) {\n                return false;\n            }\n\n            if (funcDecl.isAccessor()) {\n                return this.emitPropertyAccessorSignature(funcDecl);\n            }\n\n            var isInterfaceMember = (this.getAstDeclarationContainer().nodeType == NodeType.InterfaceDeclaration);\n            if (funcDecl.bod) {\n                if (funcDecl.isConstructor) {\n                    if (funcDecl.type.construct && funcDecl.type.construct.signatures.length > 1) {\n                        return false;\n                    }\n                } else {\n                    if (funcDecl.type.call && funcDecl.type.call.signatures.length > 1) {\n                        // This means its implementation of overload signature. do not emit\n                        return false;\n                    }\n                }\n            } else if (!isInterfaceMember && hasFlag(funcDecl.fncFlags, FncFlags.Private) && funcDecl.type.call && funcDecl.type.call.signatures.length > 1) {\n                // Print only first overload of private function\n                var signatures = funcDecl.type.call.signatures;\n                var firstSignature = signatures[0].declAST;\n                if (firstSignature.bod) {\n                    // Its a implementation, use next one\n                    firstSignature = signatures[1].declAST;\n                }\n\n                if (firstSignature != funcDecl) {\n                    return false;\n                }\n            }\n\n            if (!this.canEmitSignature(ToDeclFlags(funcDecl.fncFlags), false)) {\n                return false;\n            }\n\n            this.emitDeclarationComments(funcDecl);\n            if (funcDecl.isConstructor) {\n                this.emitIndent();\n                this.declFile.Write("constructor");\n            }\n            else {\n                var id = funcDecl.getNameText();\n                if (!isInterfaceMember) {\n                    this.emitDeclFlags(ToDeclFlags(funcDecl.fncFlags), "function");\n                    this.declFile.Write(id);\n                } else {\n                    this.emitIndent();\n                    if (funcDecl.isConstructMember()) {\n                        this.declFile.Write("new");\n                    } else if (!funcDecl.isCallMember() && !funcDecl.isIndexerMember()) {\n                        this.declFile.Write(id);\n                        if (hasFlag(funcDecl.name.flags, ASTFlags.OptionalName)) {\n                            this.declFile.Write("? ");\n                        }\n                    }\n                }\n            }\n\n            if (!funcDecl.isIndexerMember()) {\n                this.declFile.Write("(");\n            } else {\n                this.declFile.Write("[");\n            }\n\n            this.indenter.increaseIndent();\n\n            if (funcDecl.arguments) {\n                var argsLen = funcDecl.arguments.members.length;\n                if (funcDecl.variableArgList) {\n                    argsLen--;\n                }\n                for (var i = 0; i < argsLen; i++) {\n                    var argDecl = <ArgDecl>funcDecl.arguments.members[i];\n                    this.emitArgDecl(argDecl, funcDecl);\n                    if (i < (argsLen - 1)) {\n                        this.declFile.Write(", ");\n                    }\n                }\n            }\n\n            if (funcDecl.variableArgList) {\n                var lastArg = <ArgDecl>funcDecl.arguments.members[funcDecl.arguments.members.length - 1];\n                if (funcDecl.arguments.members.length > 1) {\n                    this.declFile.Write(", ...");\n                }\n                else {\n                    this.declFile.Write("...");\n                }\n                this.emitArgDecl(lastArg, funcDecl);\n            }\n\n            this.indenter.decreaseIndent();\n\n            if (!funcDecl.isIndexerMember(',
v27657=v27658+')) {\n                this.declFile.Write(")");\n            } else {\n                this.declFile.Write("]");\n            }\n\n            if (!funcDecl.isConstructor &&\n                (funcDecl.returnTypeAnnotation || funcDecl.signature.returnType.type != this.checker.anyType) &&\n                this.canEmitTypeAnnotationSignature(ToDeclFlags(funcDecl.fncFlags))) {\n                this.declFile.Write(": ");\n                this.emitTypeSignature(funcDecl.signature.returnType.type);\n            }\n\n            this.declFile.WriteLine(";");\n\n            return false;\n        }\n\n        private emitBaseList(bases: ASTList, qual: string) {\n            if (bases && (bases.members.length > 0)) {\n                this.declFile.Write(" " + qual + " ");\n                var basesLen = bases.members.length;\n                for (var i = 0; i < basesLen; i++) {\n                    var baseExpr = bases.members[i];\n                    var baseSymbol = baseExpr.type.symbol;\n                    var baseType = baseExpr.type;\n                    if (i > 0) {\n                        this.declFile.Write(", ");\n                    }\n                    this.emitTypeSignature(baseType);\n                }\n            }\n        }\n\n        private emitPropertyAccessorSignature(funcDecl: FuncDecl) {\n            var accessorSymbol = <FieldSymbol>funcDecl.accessorSymbol;\n            if (accessorSymbol.getter && accessorSymbol.getter.declAST != funcDecl) {\n                // Setter is being used to emit the type info. \n                return false;\n            }\n\n            this.emitDeclarationComments(accessorSymbol);\n            this.emitDeclFlags(ToDeclFlags(accessorSymbol.flags), "var");\n            this.declFile.Write(funcDecl.name.text);\n            var propertyType = accessorSymbol.getType();\n            if (this.canEmitTypeAnnotationSignature(ToDeclFlags(accessorSymbol.flags))) {\n                this.declFile.Write(" : ");\n                this.emitTypeSignature(propertyType);\n            }\n            this.declFile.WriteLine(";");\n\n            return false;\n        }\n\n        private emitClassMembersFromConstructorDefinition(funcDecl: FuncDecl) {\n            if (funcDecl.arguments) {\n                var argsLen = funcDecl.arguments.members.length; if (funcDecl.variableArgList) { argsLen--; }\n\n                for (var i = 0; i < argsLen; i++) {\n                    var argDecl = <ArgDecl>funcDecl.arguments.members[i];\n                    if (hasFlag(argDecl.varFlags, VarFlags.Property)) {\n                        this.emitDeclarationComments(argDecl);\n                        this.emitDeclFlags(ToDeclFlags(argDecl.varFlags), "var");\n                        this.declFile.Write(argDecl.id.text);\n\n                        if (argDecl.typeExpr && this.canEmitTypeAnnotationSignature(ToDeclFlags(argDecl.varFlags))) {\n                            this.declFile.Write(": ");\n                            this.emitTypeSignature(argDecl.type);\n                        }\n                        this.declFile.WriteLine(";");\n                    }\n                }\n            }\n        }\n\n        public ClassDeclarationCallback(pre: bool, classDecl: ClassDeclaration): bool {\n            if (!this.canEmitPrePostAstSignature(ToDeclFlags(classDecl.varFlags), classDecl, pre)) {\n                return false;\n            }\n\n            if (pre) {\n                var className = classDecl.name.text;\n                this.emitDeclarationComments(classDecl);\n                this.emitDeclFlags(ToDeclFlags(classDecl.varFlags), "class");\n                this.declFile.Write(className);\n                this.emitBaseList(classDecl.extendsList, "extends");\n                this.emitBaseList(classDecl.implementsList, "implements");\n                this.declFile.WriteLine(" {");\n\n                this.pushDeclarationContainer(classDecl);\n                this.indenter.increaseIndent();\n                if (classDecl.constructorDecl) {\n                    this.emitClassMembersFromConstructorDefinition(classDecl.constructorDecl);\n                }\n            } else {\n                this.indenter.decreaseIndent();\n                this.popDeclarationContainer(classDecl);\n\n                this.emitIndent();\n                this.declFile.WriteLine("}");\n            }\n\n            return true;\n        }\n\n        public InterfaceDeclarationCallback(pre: bool, interfaceDecl: InterfaceDeclaration): bool {\n            if (!this.canEmitPrePostAstSignature(ToDeclFlags(interfaceDecl.varFlags), interfaceDecl, pre)) {\n                return false;\n            }\n\n            if (pre) {\n                var interfaceName = interfaceDecl.name.text;\n                this.emitDeclarationComments(interfaceDecl);\n                this.emitDeclFlags(ToDeclFlags(interfaceDecl.varFlags), "interface");\n                this.declFile.Write(interfaceName);\n                this.emitBaseList(interfaceDecl.extendsList, "extends");\n                this.declFile.WriteLine(" {");\n\n                this.indenter',
v27656=v27657+'.increaseIndent();\n                this.pushDeclarationContainer(interfaceDecl);\n            } else {\n                this.indenter.decreaseIndent();\n                this.popDeclarationContainer(interfaceDecl);\n\n                this.emitIndent();\n                this.declFile.WriteLine("}");\n            }\n\n            return true;\n        }\n\n        public ImportDeclarationCallback(pre: bool, importDecl: ImportDeclaration): bool {\n            if (pre) {\n                if ((<Script>this.declarationContainerStack[0]).isExternallyVisibleSymbol(importDecl.id.sym)) {\n                    this.emitDeclarationComments(importDecl);\n                    this.emitIndent();\n                    this.declFile.Write("import ");\n\n                    this.declFile.Write(importDecl.id.text + " = ");\n                    if (importDecl.isDynamicImport) {\n                        this.declFile.WriteLine("module (" + importDecl.getAliasName() + ");");\n                    } else {\n                        this.declFile.WriteLine(importDecl.getAliasName() + ";");\n                    }\n                }\n            }\n\n            return false;\n        }\n\n        private emitEnumSignature(moduleDecl: ModuleDeclaration) {\n            if (!this.canEmitSignature(ToDeclFlags(moduleDecl.modFlags))) {\n                return false;\n            }\n\n            this.emitDeclarationComments(moduleDecl);\n            this.emitDeclFlags(ToDeclFlags(moduleDecl.modFlags), "enum");\n            this.declFile.WriteLine(moduleDecl.name.text + " {");\n\n            this.indenter.increaseIndent();\n            var membersLen = moduleDecl.members.members.length;\n            for (var j = 1; j < membersLen; j++) {\n                var memberDecl: AST = moduleDecl.members.members[j];\n                if (memberDecl.nodeType == NodeType.VarDecl) {\n                    this.emitDeclarationComments(memberDecl);\n                    this.emitIndent();\n                    this.declFile.WriteLine((<VarDecl>memberDecl).id.text + ",");\n                } else {\n                    CompilerDiagnostics.assert(memberDecl.nodeType != NodeType.Asg, "We want to catch this");\n                }\n            }\n            this.indenter.decreaseIndent();\n\n            this.emitIndent();\n            this.declFile.WriteLine("}");\n\n            return false;\n        }\n\n        public ModuleDeclarationCallback(pre: bool, moduleDecl: ModuleDeclaration): bool {\n            if (hasFlag(moduleDecl.modFlags, ModuleFlags.IsWholeFile)) {\n                // This is dynamic modules and we are going to outputing single file, \n                // we need to change the declFile because dynamic modules are always emitted to their corresponding .d.ts\n                if (hasFlag(moduleDecl.modFlags, ModuleFlags.IsDynamic)) {\n                    if (pre) {\n                        if (!this.emitOptions.outputMany) {\n                            this.singleDeclFile = this.declFile;\n                            CompilerDiagnostics.assert(this.indenter.indentAmt == 0, "Indent has to be 0 when outputing new file");\n                            // Create new file\n                            var declareFileName = this.emitOptions.mapOutputFileName(stripQuotes(moduleDecl.name.sym.name), TypeScriptCompiler.mapToDTSFileName);\n                            var useUTF8InOutputfile = moduleDecl.containsUnicodeChar || (this.emitOptions.emitComments && moduleDecl.containsUnicodeCharInComment);\n                            try {\n                                // Creating files can cause exceptions, report them.   \n                                this.declFile = new DeclFileWriter(this.emitOptions.ioHost.createFile(declareFileName, useUTF8InOutputfile));\n                            } catch (ex) {\n                                this.errorReporter.emitterError(null, ex.message);\n                            }\n                        }\n                        this.pushDeclarationContainer(moduleDecl);\n                    } else {\n                        if (!this.emitOptions.outputMany) {\n                            CompilerDiagnostics.assert(this.singleDeclFile != this.declFile, "singleDeclFile cannot be null as we are going to revert back to it");\n                            CompilerDiagnostics.assert(this.indenter.indentAmt == 0, "Indent has to be 0 when outputing new file");\n                            try {\n                                // Closing files could result in exceptions, report them if they occur\n                                this.declFile.Close();\n                            } catch (ex) {\n                                this.errorReporter.emitterError(null, ex.message);\n                            }\n                            this.declFile = this.singleDeclFile;\n                        }\n                        this.popDeclarationContainer(moduleDecl);\n                    }\n                }\n\n                return true;\n            }\n\n            if (moduleDecl.isEnum()) {\n                if (pre) {\n           ',
v27655=v27656+'         this.emitEnumSignature(moduleDecl);\n                }\n                return false;\n            }\n\n            if (!this.canEmitPrePostAstSignature(ToDeclFlags(moduleDecl.modFlags), moduleDecl, pre)) {\n                return false;\n            }\n\n            if (pre) {\n                if (this.emitDottedModuleName()) {\n                    this.dottedModuleEmit += ".";\n                } else {\n                    this.dottedModuleEmit = this.getDeclFlagsString(ToDeclFlags(moduleDecl.modFlags), "module");\n                }\n                this.dottedModuleEmit += moduleDecl.name.text;\n\n                var isCurrentModuleDotted = (moduleDecl.members.members.length == 1 &&\n                    moduleDecl.members.members[0].nodeType == NodeType.ModuleDeclaration &&\n                    !(<ModuleDeclaration>moduleDecl.members.members[0]).isEnum() &&\n                    hasFlag((<ModuleDeclaration>moduleDecl.members.members[0]).modFlags, ModuleFlags.Exported));\n\n                // Module is dotted only if it does not have doc comments for it\n                var moduleDeclComments = moduleDecl.getDocComments();\n                isCurrentModuleDotted = isCurrentModuleDotted && (moduleDeclComments == null || moduleDeclComments.length == 0);\n\n                this.isDottedModuleName.push(isCurrentModuleDotted);\n                this.pushDeclarationContainer(moduleDecl);\n\n                if (!isCurrentModuleDotted) {\n                    this.emitDeclarationComments(moduleDecl);\n                    this.declFile.Write(this.dottedModuleEmit);\n                    this.declFile.WriteLine(" {");\n                    this.indenter.increaseIndent();\n                }\n            } else {\n                if (!this.emitDottedModuleName()) {\n                    this.indenter.decreaseIndent();\n                    this.emitIndent();\n                    this.declFile.WriteLine("}");\n                }\n                this.popDeclarationContainer(moduleDecl);\n                this.isDottedModuleName.pop();\n            }\n\n            return true;\n        }\n\n        public ScriptCallback(pre: bool, script: Script): bool {\n            if (pre) {\n                if (this.emitOptions.outputMany) {\n                    for (var i = 0; i < script.referencedFiles.length; i++) {\n                        var referencePath = script.referencedFiles[i].path;\n                        var declareFileName: string;\n                        if (isRooted(referencePath)) {\n                            declareFileName = this.emitOptions.mapOutputFileName(referencePath, TypeScriptCompiler.mapToDTSFileName)\n                        } else {\n                            declareFileName = getDeclareFilePath(script.referencedFiles[i].path);\n                        }\n                        this.declFile.WriteLine(\'/// <reference path="\' + declareFileName + \'" />\');\n                    }\n                }\n                this.pushDeclarationContainer(script);\n            }\n            else {\n                this.popDeclarationContainer(script);\n            }\n            return true;\n        }\n\n        public DefaultCallback(pre: bool, ast: AST): bool {\n            return !hasFlag(ast.flags, ASTFlags.IsStatement);\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export module CompilerDiagnostics {\n        export var debug = false;\n        export interface IDiagnosticWriter {\n            Alert(output: string): void;\n        }\n\n        export var diagnosticWriter: IDiagnosticWriter = null;\n\n        export var analysisPass: number = 0;\n\n        export function Alert(output: string) {\n            if (diagnosticWriter) {\n                diagnosticWriter.Alert(output);\n            }\n        }\n\n        export function debugPrint(s: string) {\n            if (debug) {\n                Alert(s);\n            }\n        }\n\n        export function assert(condition: bool, s: string) {\n            if (debug) {\n                if (!condition) {\n                    Alert(s);\n                }\n            }\n        }\n\n    }\n\n    export interface ILogger {\n        information(): bool;\n        debug(): bool;\n        warning(): bool;\n        error(): bool;\n        fatal(): bool;\n        log(s: string): void;\n    }\n\n    export class NullLogger implements ILogger {\n        public information(): bool { return false; }\n        public debug(): bool { r',
v27654=v27655+'eturn false; }\n        public warning(): bool { return false; }\n        public error(): bool { return false; }\n        public fatal(): bool { return false; }\n        public log(s: string): void {\n        }\n    }\n\n    export class LoggerAdapter implements ILogger {\n        private _information: bool;\n        private _debug: bool;\n        private _warning: bool;\n        private _error: bool;\n        private _fatal: bool;\n\n        constructor (public logger: ILogger) { \n            this._information = this.logger.information();\n            this._debug = this.logger.debug();\n            this._warning = this.logger.warning();\n            this._error = this.logger.error();\n            this._fatal = this.logger.fatal();\n        }\n\n\n        public information(): bool { return this._information; }\n        public debug(): bool { return this._debug; }\n        public warning(): bool { return this._warning; }\n        public error(): bool { return this._error; }\n        public fatal(): bool { return this._fatal; }\n        public log(s: string): void {\n            this.logger.log(s);\n        }\n    }\n\n    export class BufferedLogger implements ILogger {\n        public logContents = [];\n\n        public information(): bool { return false; }\n        public debug(): bool { return false; }\n        public warning(): bool { return false; }\n        public error(): bool { return false; }\n        public fatal(): bool { return false; }\n        public log(s: string): void {\n            this.logContents.push(s);\n        }\n    }\n\n    export function timeFunction(logger: ILogger, funcDescription: string, func: () =>any): any {\n        var start = +new Date();\n        var result = func();\n        var end = +new Date();\n        logger.log(funcDescription + " completed in " + (end - start) + " msec");\n        return result;\n    }\n\n    export function stringToLiteral(value: string, length: number): string {\n        var result = "";\n\n        var addChar = (index: number) => {\n            var ch = value.charCodeAt(index);\n            switch (ch) {\n                case 0x09: // tab\n                    result += "\\\\t";\n                    break;\n                case 0x0a: // line feed\n                    result += "\\\\n";\n                    break;\n                case 0x0b: // vertical tab\n                    result += "\\\\v";\n                    break;\n                case 0x0c: // form feed\n                    result += "\\\\f";\n                    break;\n                case 0x0d: // carriage return\n                    result += "\\\\r";\n                    break;\n                case 0x22:  // double quote\n                    result += "\\\\\\"";\n                    break;\n                case 0x27: // single quote\n                    result += "\\\\\\\'";\n                    break;\n                case 0x5c: // Backslash\n                    result += "\\\\";\n                    break;\n                default:\n                    result += value.charAt(index);\n            }\n        }\n\n        var tooLong = (value.length > length);\n        if (tooLong) {\n            var mid = length >> 1;\n            for (var i = 0; i < mid; i++) addChar(i);\n            result += "(...)";\n            for (var i = value.length - mid; i < value.length; i++) addChar(i);\n        }\n        else {\n            length = value.length;\n            for (var i = 0; i < length; i++) addChar(i);\n        }\n        return result;\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export enum EmitContainer {\n        Prog,\n        Module,\n        DynamicModule,\n        Class,\n        Constructor,\n        Function,\n        Args,\n        Interface,\n    }\n\n    export class EmitState {\n        public column: number;\n        public line: number;\n        public pretty: bool;\n        public inObjectLiteral: bool;\n        public container: EmitContainer;\n\n        constructor () {\n            this.column = 0;\n            this.line = 0;\n            this.pretty = false;\n            this.inObjectLiteral = false;\n            this.container = EmitContainer.Prog;\n        }\n    }\n\n    export class EmitOptions {\n        public minWhitespace: bool;\n        public propagateConstants: bool;\n        public emitComments: bool;\n        public outputOption: string;\n        public ioHost: EmitterIOHost = null;\n        public outputMany: bool = true;\n        public commonDirectoryPath',
v27653=v27654+' = "";\n\n        constructor(settings: CompilationSettings) {\n            this.minWhitespace = settings.minWhitespace;\n            this.propagateConstants = settings.propagateConstants;\n            this.emitComments = settings.emitComments;\n            this.outputOption = settings.outputOption;\n        }\n\n        public mapOutputFileName(fileName: string, extensionChanger: (fname: string, wholeFileNameReplaced: bool) => string) {\n            if (this.outputMany) {\n                var updatedFileName = fileName;\n                if (this.outputOption != "") {\n                    // Replace the common directory path with the option specified\n                    updatedFileName = fileName.replace(this.commonDirectoryPath, "");\n                    updatedFileName = this.outputOption + updatedFileName;\n                }\n                return extensionChanger(updatedFileName, false);\n            } else {\n                return extensionChanger(this.outputOption, true);\n            }\n        }\n    }\n\n    export class Indenter {\n        static indentStep : number = 4;\n        static indentStepString : string = "    ";\n        static indentStrings: string[] = [];\n        public indentAmt: number = 0;\n\n        public increaseIndent() {\n            this.indentAmt += Indenter.indentStep;\n        }\n\n        public decreaseIndent() {\n            this.indentAmt -= Indenter.indentStep;\n        }\n\n        public getIndent() {\n            var indentString = Indenter.indentStrings[this.indentAmt];\n            if (indentString === undefined) {\n                indentString = "";\n                for (var i = 0; i < this.indentAmt; i = i + Indenter.indentStep) {\n                    indentString += Indenter.indentStepString;\n                }\n                Indenter.indentStrings[this.indentAmt] = indentString;\n            }\n            return indentString;\n        }\n    }\n\n    export class Emitter {\n        public prologueEmitted = false;\n        public thisClassNode: TypeDeclaration = null;\n        public thisFnc: FuncDecl = null;\n        public moduleDeclList: ModuleDeclaration[] = [];\n        public moduleName = "";\n        public emitState = new EmitState();\n        public indenter = new Indenter();\n        public ambientModule = false;\n        public modAliasId: string = null;\n        public firstModAlias: string = null;\n        public allSourceMappers: SourceMapper[] = [];\n        public sourceMapper: SourceMapper = null;\n        public captureThisStmtString = "var _this = this;";\n        private varListCountStack: number[] = [0]; \n\n        constructor(public checker: TypeChecker, public emittingFileName: string, public outfile: ITextWriter, public emitOptions: EmitOptions, public errorReporter: ErrorReporter) {\n        }\n\n        public setSourceMappings(mapper: SourceMapper) {\n            this.allSourceMappers.push(mapper);\n            this.sourceMapper = mapper;\n        }\n\n        public writeToOutput(s: string) {\n            this.outfile.Write(s);\n            // TODO: check s for newline\n            this.emitState.column += s.length;\n        }\n\n        public writeToOutputTrimmable(s: string) {\n            if (this.emitOptions.minWhitespace) {\n                s = s.replace(/[\\s]*/g, \'\');\n            }\n            this.writeToOutput(s);\n        }\n\n        public writeLineToOutput(s: string) {\n            if (this.emitOptions.minWhitespace) {\n                this.writeToOutput(s);\n                var c = s.charCodeAt(s.length - 1);\n                if (!((c == LexCodeSpace) || (c == LexCodeSMC) || (c == LexCodeLBR))) {\n                    this.writeToOutput(\' \');\n                }\n            }\n            else {\n                this.outfile.WriteLine(s);\n                this.emitState.column = 0\n                this.emitState.line++;\n            }\n        }\n\n        public writeCaptureThisStatement(ast: AST) {\n            this.emitIndent();\n            this.recordSourceMappingStart(ast);\n            this.writeToOutput(this.captureThisStmtString);\n            this.recordSourceMappingEnd(ast);\n            this.writeLineToOutput("");\n        }\n\n        public setInVarBlock(count: number) {\n            this.varListCountStack[this.varListCountStack.length - 1] = count;\n        }\n\n        public setInObjectLiteral(val: bool): bool {\n            var temp = this.emitState.inObjectLiteral;\n            this.emitState.inObjectLiteral = val;\n            return temp;\n        }\n\n        public setContainer(c: number): number {\n            var temp = this.emitState.container;\n            this.emitState.container = c;\n            return temp;\n        }\n\n        private getIndentString() {\n            if (this.emitOptions.minWhitespace) {\n                return "";\n            }\n            else {\n                return this.indenter.getIndent();\n            }\n        }\n\n        public emitIndent() {\n            this.writeToOutput(this.getIndentString());\n        }\n\n        public emitCommentInPlace(comment: Comment) {\n            var tex',
v27652=v27653+'t = comment.getText();\n            var hadNewLine = false;\n\n            if (comment.isBlockComment) {\n                if (this.emitState.column == 0) {\n                    this.emitIndent();\n                }\n                this.recordSourceMappingStart(comment);\n                this.writeToOutput(text[0]);\n\n                if (text.length > 1 || comment.endsLine) {\n                    for (var i = 1; i < text.length; i++) {\n                        this.writeLineToOutput("");\n                        this.emitIndent();\n                        this.writeToOutput(text[i]);\n                    }\n                    this.recordSourceMappingEnd(comment);\n                    this.writeLineToOutput("");\n                    hadNewLine = true;\n                } else {\n                    this.recordSourceMappingEnd(comment);\n                }\n            }\n            else {\n                if (this.emitState.column == 0) {\n                    this.emitIndent();\n                }\n                this.recordSourceMappingStart(comment);\n                this.writeToOutput(text[0]);\n                this.recordSourceMappingEnd(comment);\n                this.writeLineToOutput("");\n                hadNewLine = true;\n            }\n\n            if (hadNewLine) {\n                this.emitIndent();\n            }\n            else {\n                this.writeToOutput(" ");\n            }\n        }\n\n        public emitParensAndCommentsInPlace(ast: AST, pre: bool) {\n            var comments = pre ? ast.preComments : ast.postComments;\n\n            // comments should be printed before the LParen, but after the RParen\n            if (ast.isParenthesized && !pre) {\n                this.writeToOutput(")");\n            }\n            if (this.emitOptions.emitComments && comments && comments.length != 0) {\n                for (var i = 0; i < comments.length; i++) {\n                    this.emitCommentInPlace(comments[i]);\n                }\n            }\n            if (ast.isParenthesized && pre) {\n                this.writeToOutput("(");\n            }\n        }\n\n        // TODO: emit accessor pattern\n        public emitObjectLiteral(content: ASTList) {\n            this.writeLineToOutput("{");\n            this.indenter.increaseIndent();\n            var inObjectLiteral = this.setInObjectLiteral(true);\n            this.emitJavascriptList(content, ",", TokenID.Comma, true, false, false);\n            this.setInObjectLiteral(inObjectLiteral);\n            this.indenter.decreaseIndent();\n            this.emitIndent();\n            this.writeToOutput("}");\n        }\n\n        public emitArrayLiteral(content: ASTList) {\n            this.writeToOutput("[");\n            if (content) {\n                this.writeLineToOutput("");\n                this.indenter.increaseIndent();\n                this.emitJavascriptList(content, ", ", TokenID.Comma, true, false, false);\n                this.indenter.decreaseIndent();\n                this.emitIndent();\n            }\n            this.writeToOutput("]");\n        }\n\n        public emitNew(target: AST, args: ASTList) {\n            this.writeToOutput("new ");\n            if (target.nodeType == NodeType.TypeRef) {\n                var typeRef = <TypeReference>target;\n                if (typeRef.arrayCount) {\n                    this.writeToOutput("Array()");\n                }\n                else {\n                    this.emitJavascript(typeRef.term, TokenID.Tilde, false);\n                    this.writeToOutput("()");\n                }\n            }\n            else {\n                this.emitJavascript(target, TokenID.Tilde, false);\n                this.recordSourceMappingStart(args);\n                this.writeToOutput("(");\n                this.emitJavascriptList(args, ", ", TokenID.Comma, false, false, false);\n                this.writeToOutput(")");\n                this.recordSourceMappingEnd(args);\n            }\n        }\n\n        public tryEmitConstant(dotExpr: BinaryExpression) {\n            if (!this.emitOptions.propagateConstants) {\n                return false;\n            }\n            var propertyName = <Identifier>dotExpr.operand2;\n            if (propertyName && propertyName.sym && propertyName.sym.isVariable()) {\n                if (hasFlag(propertyName.sym.flags, SymbolFlags.Constant)) {\n                    if (propertyName.sym.declAST) {\n                        var boundDecl = <BoundDecl>propertyName.sym.declAST;\n                        if (boundDecl.init && (boundDecl.init.nodeType == NodeType.NumberLit)) {\n                            var numLit = <NumberLiteral>boundDecl.init;\n                            this.writeToOutput(numLit.value.toString());\n                            var comment = " /* ";\n                            comment += propertyName.actualText;\n                            comment += " */ ";\n                            this.writeToOutput(comment);\n                            return true;\n                        }\n                    }\n                }\n            }\n            ret',
v27651=v27652+'urn false;\n        }\n\n        public emitCall(callNode: CallExpression, target: AST, args: ASTList) {\n            if (!this.emitSuperCall(callNode)) {\n                if (!hasFlag(callNode.flags, ASTFlags.ClassBaseConstructorCall)) {\n                    if (target.nodeType == NodeType.FuncDecl && !target.isParenthesized) {\n                        this.writeToOutput("(");\n                    }\n                    if (callNode.target.nodeType == NodeType.Super && this.emitState.container == EmitContainer.Constructor) {\n                        this.writeToOutput("_super.call");\n                    }\n                    else {\n                        this.emitJavascript(target, TokenID.OpenParen, false);\n                    }\n                    if (target.nodeType == NodeType.FuncDecl && !target.isParenthesized) {\n                        this.writeToOutput(")");\n                    }\n                    this.recordSourceMappingStart(args);\n                    this.writeToOutput("(");\n                    if (callNode.target.nodeType == NodeType.Super && this.emitState.container == EmitContainer.Constructor) {\n                        this.writeToOutput("this");\n                        if (args && args.members.length) {\n                            this.writeToOutput(", ");\n                        }\n                    }\n                    this.emitJavascriptList(args, ", ", TokenID.Comma, false, false, false);\n                    this.writeToOutput(")");\n                    this.recordSourceMappingEnd(args);\n                }\n                else {\n                    this.indenter.decreaseIndent();\n                    this.indenter.decreaseIndent();\n                    var constructorCall = new ASTList();\n                    constructorCall.members[0] = callNode;\n                    this.emitConstructorCalls(constructorCall, this.thisClassNode);\n                    this.indenter.increaseIndent();\n                    this.indenter.increaseIndent();\n                }\n            }\n        }\n\n        public emitConstructorCalls(bases: ASTList, classDecl: TypeDeclaration) {\n            if (bases == null) {\n                return;\n            }\n            var basesLen = bases.members.length;\n            this.recordSourceMappingStart(classDecl);\n            for (var i = 0; i < basesLen; i++) {\n                var baseExpr = bases.members[i];\n                var baseSymbol: Symbol = null;\n                if (baseExpr.nodeType == NodeType.Call) {\n                    baseSymbol = (<CallExpression>baseExpr).target.type.symbol;\n                }\n                else {\n                    baseSymbol = baseExpr.type.symbol;\n                }\n                var baseName = baseSymbol.name;\n                if (baseSymbol.declModule != classDecl.type.symbol.declModule) {\n                    baseName = baseSymbol.fullName();\n                }\n                if (baseExpr.nodeType == NodeType.Call) {\n                    this.emitIndent();\n                    this.writeToOutput("_super.call(this");\n                    var args = (<CallExpression>baseExpr).arguments;\n                    if (args && (args.members.length > 0)) {\n                        this.writeToOutput(", ");\n                        this.emitJavascriptList(args, ", ", TokenID.Comma, false, false, false);\n                    }\n                    this.writeToOutput(")");\n                }\n                else {\n                    if (baseExpr.type && (baseExpr.type.isClassInstance())) {\n                        // parameterless constructor call;\n                        this.emitIndent();\n                        this.writeToOutput(classDecl.name.actualText + "._super.constructor");\n                        //emitJavascript(baseExpr,TokenID.LParen,false);\n                        this.writeToOutput(".call(this)");\n                    }\n                }\n            }\n            this.recordSourceMappingEnd(classDecl);\n        }\n\n        public emitInnerFunction(funcDecl: FuncDecl, printName: bool, isMember: bool,\n            bases: ASTList, hasSelfRef: bool, classDecl: TypeDeclaration) {\n            /// REVIEW: The code below causes functions to get pushed to a newline in cases where they shouldn\'t\n            /// such as: \n            ///     Foo.prototype.bar = \n            ///         function() {\n            ///         };\n            /// Once we start emitting comments, we should pull this code out to place on the outer context where the function\n            /// is used.\n            //if (funcDecl.preComments!=null && funcDecl.preComments.length>0) {\n            //    this.writeLineToOutput("");\n            //    this.increaseIndent();\n            //    emitIndent();\n            //}\n\n            var isClassConstructor = funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod);\n            var hasNonObjectBaseType = isClassConstructor && hasFlag(this.thisClassNode.type.instanceType.typeFlags, TypeFlags.HasBaseType) && !hasFlag(this.thisClassNode.',
v27650=v27651+'type.instanceType.typeFlags, TypeFlags.HasBaseTypeOfObject);\n            var classPropertiesMustComeAfterSuperCall = hasNonObjectBaseType && hasFlag((<ClassDeclaration>this.thisClassNode).varFlags, VarFlags.ClassSuperMustBeFirstCallInConstructor);\n\n            // We have no way of knowing if the current function is used as an expression or a statement, so as to enusre that the emitted\n            // JavaScript is always valid, add an extra parentheses for unparenthesized function expressions\n            var shouldParenthesize = hasFlag(funcDecl.fncFlags, FncFlags.IsFunctionExpression) && !funcDecl.isParenthesized && !funcDecl.isAccessor() && (hasFlag(funcDecl.flags, ASTFlags.ExplicitSemicolon) || hasFlag(funcDecl.flags, ASTFlags.AutomaticSemicolon));\n\n            this.emitParensAndCommentsInPlace(funcDecl, true);\n            if (shouldParenthesize) {\n                this.writeToOutput("(");\n            }\n            this.recordSourceMappingStart(funcDecl);\n            if (!(funcDecl.isAccessor() && (<FieldSymbol>funcDecl.accessorSymbol).isObjectLitField)) {\n                this.writeToOutput("function ");\n            }\n            if (printName) {\n                var id = funcDecl.getNameText();\n                if (id && !funcDecl.isAccessor()) {\n                    if (funcDecl.name) {\n                        this.recordSourceMappingStart(funcDecl.name);\n                    }\n                    this.writeToOutput(id);\n                    if (funcDecl.name) {\n                        this.recordSourceMappingEnd(funcDecl.name);\n                    }\n                }\n            }\n\n            this.writeToOutput("(");\n            var argsLen = 0;\n            var i = 0;\n            var arg: ArgDecl;\n            var defaultArgs: ArgDecl[] = [];\n            if (funcDecl.arguments) {\n                var tempContainer = this.setContainer(EmitContainer.Args);\n                argsLen = funcDecl.arguments.members.length;\n                var printLen = argsLen;\n                if (funcDecl.variableArgList) {\n                    printLen--;\n                }\n                for (i = 0; i < printLen; i++) {\n                    arg = <ArgDecl>funcDecl.arguments.members[i];\n                    if (arg.init) {\n                        defaultArgs.push(arg);\n                    }\n                    this.emitJavascript(arg, TokenID.OpenParen, false);\n                    if (i < (printLen - 1)) {\n                        this.writeToOutput(", ");\n                    }\n                }\n                this.setContainer(tempContainer);\n            }\n            this.writeLineToOutput(") {");\n\n            if (funcDecl.isConstructor) {\n                this.recordSourceMappingNameStart("constructor");\n            } else if (funcDecl.isGetAccessor()) {\n                this.recordSourceMappingNameStart("get_" + funcDecl.getNameText());\n            } else if (funcDecl.isSetAccessor()) {\n                this.recordSourceMappingNameStart("set_" + funcDecl.getNameText());\n            } else {\n                this.recordSourceMappingNameStart(funcDecl.getNameText());\n            }\n            this.indenter.increaseIndent();\n\n            // set default args first\n            for (i = 0; i < defaultArgs.length; i++) {\n                var arg = defaultArgs[i];\n                this.emitIndent();\n                this.recordSourceMappingStart(arg);\n                this.writeToOutput("if (typeof " + arg.id.actualText + " === \\"undefined\\") { ");//\n                this.recordSourceMappingStart(arg.id);\n                this.writeToOutput(arg.id.actualText);\n                this.recordSourceMappingEnd(arg.id);\n                this.writeToOutput(" = ");\n                this.emitJavascript(arg.init, TokenID.OpenParen, false);\n                this.writeLineToOutput("; }")\n                this.recordSourceMappingEnd(arg);\n            }\n\n            if (funcDecl.isConstructor && ((<ClassDeclaration>funcDecl.classDecl).varFlags & VarFlags.MustCaptureThis)) {\n                this.writeCaptureThisStatement(funcDecl);\n            }\n\n            if (funcDecl.isConstructor && !classPropertiesMustComeAfterSuperCall) {\n                if (funcDecl.arguments) {\n                    argsLen = funcDecl.arguments.members.length;\n                    for (i = 0; i < argsLen; i++) {\n                        arg = <ArgDecl>funcDecl.arguments.members[i];\n                        if ((arg.varFlags & VarFlags.Property) != VarFlags.None) {\n                            this.emitIndent();\n                            this.recordSourceMappingStart(arg);\n                            this.recordSourceMappingStart(arg.id);\n                            this.writeToOutput("this." + arg.id.actualText);\n                            this.recordSourceMappingEnd(arg.id);\n                            this.writeToOutput(" = ");\n                            this.recordSourceMappingStart(arg.id);\n                            this.writeToOutput(arg.id.actualText);\n                            this.re',
v27649=v27650+'cordSourceMappingEnd(arg.id);\n                            this.writeLineToOutput(";");\n                            this.recordSourceMappingEnd(arg);\n                        }\n                    }\n                }\n\n                // For classes, the constructor needs to be explicitly called\n                if (!hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {\n                    this.emitConstructorCalls(bases, classDecl);\n                }\n            }\n            if (hasSelfRef) {\n                this.writeCaptureThisStatement(funcDecl);\n            }\n            if (funcDecl.variableArgList) {\n                argsLen = funcDecl.arguments.members.length;\n                var lastArg = <ArgDecl>funcDecl.arguments.members[argsLen - 1];\n                this.emitIndent();\n                this.recordSourceMappingStart(lastArg);\n                this.writeToOutput("var ");\n                this.recordSourceMappingStart(lastArg.id);\n                this.writeToOutput(lastArg.id.actualText);\n                this.recordSourceMappingEnd(lastArg.id);\n                this.writeLineToOutput(" = [];");\n                this.recordSourceMappingEnd(lastArg);\n                this.emitIndent();\n                this.writeToOutput("for (")\n                this.recordSourceMappingStart(lastArg);\n                this.writeToOutput("var _i = 0;");\n                this.recordSourceMappingEnd(lastArg);\n                this.writeToOutput(" ");\n                this.recordSourceMappingStart(lastArg);\n                this.writeToOutput("_i < (arguments.length - " + (argsLen - 1) + ")");\n                this.recordSourceMappingEnd(lastArg);\n                this.writeToOutput("; ");\n                this.recordSourceMappingStart(lastArg);\n                this.writeToOutput("_i++");\n                this.recordSourceMappingEnd(lastArg);\n                this.writeLineToOutput(") {");\n                this.indenter.increaseIndent();\n                this.emitIndent();\n\n                this.recordSourceMappingStart(lastArg);\n                this.writeToOutput(lastArg.id.actualText + "[_i] = arguments[_i + " + (argsLen - 1) + "];");\n                this.recordSourceMappingEnd(lastArg);\n                this.writeLineToOutput("");\n                this.indenter.decreaseIndent();\n                this.emitIndent();\n                this.writeLineToOutput("}");\n            }\n\n            // if it\'s a class, emit the uninitializedMembers, first emit the non-proto class body members\n            if (funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod) && !classPropertiesMustComeAfterSuperCall) {\n\n                var nProps = (<ASTList>this.thisClassNode.members).members.length;\n\n                for (var i = 0; i < nProps; i++) {\n                    if ((<ASTList>this.thisClassNode.members).members[i].nodeType == NodeType.VarDecl) {\n                        var varDecl = <VarDecl>(<ASTList>this.thisClassNode.members).members[i];\n                        if (!hasFlag(varDecl.varFlags, VarFlags.Static) && varDecl.init) {\n                            this.emitIndent();\n                            this.emitJavascriptVarDecl(varDecl, TokenID.Tilde);\n                            this.writeLineToOutput("");\n                        }\n                    }\n                }\n                //this.writeLineToOutput("");\n            }\n\n            this.emitBareJavascriptStatements(funcDecl.bod, classPropertiesMustComeAfterSuperCall);\n\n            this.indenter.decreaseIndent();\n            this.emitIndent();\n            this.recordSourceMappingStart(funcDecl.endingToken);\n            this.writeToOutput("}");\n\n            this.recordSourceMappingNameEnd();\n            this.recordSourceMappingEnd(funcDecl.endingToken);\n            this.recordSourceMappingEnd(funcDecl);\n\n            if (shouldParenthesize) {\n                this.writeToOutput(")");\n            }\n\n            // The extra call is to make sure the caller\'s funcDecl end is recorded, since caller wont be able to record it\n            this.recordSourceMappingEnd(funcDecl);\n\n            this.emitParensAndCommentsInPlace(funcDecl, false);\n\n            if (!isMember &&\n                //funcDecl.name != null &&\n                !hasFlag(funcDecl.fncFlags, FncFlags.IsFunctionExpression) &&\n                (hasFlag(funcDecl.fncFlags, FncFlags.Definition) || funcDecl.isConstructor)) {\n                this.writeLineToOutput("");\n            } else if (hasFlag(funcDecl.fncFlags, FncFlags.IsFunctionExpression)) {\n                if (hasFlag(funcDecl.flags, ASTFlags.ExplicitSemicolon) || hasFlag(funcDecl.flags, ASTFlags.AutomaticSemicolon)) {\n                    // If either of these two flags are set, then the function expression is a statement. Terminate it.\n                    this.writeLineToOutput(";");\n                }\n            }\n            /// TODO: See the other part of this at the beginning of function\n            //if (funcDecl.preComments!=null && funcDecl.preComments.length>0) {\n  ',
v27648=v27649+'          //    this.decreaseIndent();\n            //}           \n        }\n\n        public emitJavascriptModule(moduleDecl: ModuleDeclaration) {\n            var modName = moduleDecl.name.actualText;\n            if (isTSFile(modName)) {\n                moduleDecl.name.setText(modName.substring(0, modName.length - 3));\n            }\n            else if (isSTRFile(modName)) {\n                moduleDecl.name.setText(modName.substring(0, modName.length - 4));\n            }\n\n            if (!hasFlag(moduleDecl.modFlags, ModuleFlags.Ambient)) {\n                var isDynamicMod = hasFlag(moduleDecl.modFlags, ModuleFlags.IsDynamic);\n                var prevOutFile = this.outfile;\n                var prevOutFileName = this.emittingFileName;\n                var prevAllSourceMappers = this.allSourceMappers;\n                var prevSourceMapper = this.sourceMapper;\n                var prevColumn = this.emitState.column;\n                var prevLine = this.emitState.line;\n                var temp = this.setContainer(EmitContainer.Module);\n                var svModuleName = this.moduleName;\n                var isExported = hasFlag(moduleDecl.modFlags, ModuleFlags.Exported);\n                this.moduleDeclList[this.moduleDeclList.length] = moduleDecl;\n                var isWholeFile = hasFlag(moduleDecl.modFlags, ModuleFlags.IsWholeFile);\n                this.moduleName = moduleDecl.name.actualText;\n\n                // prologue\n                if (isDynamicMod) {\n                    // create the new outfile for this module\n                    var tsModFileName = stripQuotes(moduleDecl.name.actualText);\n                    var modFilePath = trimModName(tsModFileName) + ".js";\n                    modFilePath = this.emitOptions.mapOutputFileName(modFilePath, TypeScriptCompiler.mapToJSFileName);\n\n                    if (this.emitOptions.ioHost) {\n                        // Ensure that the slashes are normalized so that the comparison is fair\n                        // REVIEW: Note that modFilePath is normalized to forward slashes in Parser.parse, so the \n                        // first call to switchToForwardSlashes is technically a no-op, but it will prevent us from\n                        // regressing if the parser changes\n                        if (switchToForwardSlashes(modFilePath) != switchToForwardSlashes(this.emittingFileName)) {\n                            this.emittingFileName = modFilePath;\n                            var useUTF8InOutputfile = moduleDecl.containsUnicodeChar || (this.emitOptions.emitComments && moduleDecl.containsUnicodeCharInComment);\n                            this.outfile = this.createFile(this.emittingFileName, useUTF8InOutputfile);\n                            if (prevSourceMapper != null) {\n                                this.allSourceMappers = [];\n                                var sourceMappingFile = this.createFile(this.emittingFileName + SourceMapper.MapFileExtension, false);\n                                this.setSourceMappings(new TypeScript.SourceMapper(tsModFileName, this.emittingFileName, this.outfile, sourceMappingFile, this.errorReporter));\n                                this.emitState.column = 0;\n                                this.emitState.line = 0;\n                            }\n                        } else {\n                            CompilerDiagnostics.assert(this.emitOptions.outputMany, "Cannot have dynamic modules compiling into single file");\n                        }\n                    }\n\n                    this.setContainer(EmitContainer.DynamicModule); // discard the previous \'Module\' container\n\n                    this.recordSourceMappingStart(moduleDecl);\n                    if (moduleGenTarget == ModuleGenTarget.Asynchronous) { // AMD\n                        var dependencyList = "[\\"require\\", \\"exports\\"";\n                        var importList = "require, exports";\n                        var importStatement: ImportDeclaration = null;\n\n                        // all dependencies are quoted\n                        for (var i = 0; i < (<ModuleType>moduleDecl.mod).importedModules.length; i++) {\n                            importStatement = (<ModuleType>moduleDecl.mod).importedModules[i]\n\n                            // if the imported module is only used in a type position, do not add it as a requirement\n                            if (importStatement.id.sym &&\n                                !(<TypeSymbol>importStatement.id.sym).onlyReferencedAsTypeRef) {\n                                if (i <= (<ModuleType>moduleDecl.mod).importedModules.length - 1) {\n                                    dependencyList += ", ";\n                                    importList += ", ";\n                                }\n\n                                importList += "__" + importStatement.id.actualText + "__";\n                                dependencyList += importStatement.firstAliasedModToString();\n                            }\n                        }\n\n                 ',
v27647=v27648+'       // emit any potential amd dependencies\n                        for (var i = 0; i < moduleDecl.amdDependencies.length; i++) {\n                            dependencyList += ", \\"" + moduleDecl.amdDependencies[i] + "\\"";\n                        }\n\n                        dependencyList += "]";\n\n                        this.writeLineToOutput("define(" + dependencyList + "," + " function(" + importList + ") {");\n                    }\n                    else { // Node\n\n                    }\n                }\n                else {\n\n                    if (!isExported) {\n                        this.recordSourceMappingStart(moduleDecl);\n                        this.writeToOutput("var ");\n                        this.recordSourceMappingStart(moduleDecl.name);\n                        this.writeToOutput(this.moduleName);\n                        this.recordSourceMappingEnd(moduleDecl.name);\n                        this.writeLineToOutput(";");\n                        this.recordSourceMappingEnd(moduleDecl);\n                        this.emitIndent();\n                    }\n\n                    this.writeToOutput("(");\n                    this.recordSourceMappingStart(moduleDecl);\n                    this.writeToOutput("function (");\n                    this.recordSourceMappingStart(moduleDecl.name);\n                    this.writeToOutput(this.moduleName);\n                    this.recordSourceMappingEnd(moduleDecl.name);\n                    this.writeLineToOutput(") {");\n                }\n\n                if (!isWholeFile) {\n                    this.recordSourceMappingNameStart(this.moduleName);\n                }\n\n                // body - don\'t indent for Node\n                if (!isDynamicMod || moduleGenTarget == ModuleGenTarget.Asynchronous) {\n                    this.indenter.increaseIndent();\n                }\n\n                if (moduleDecl.modFlags & ModuleFlags.MustCaptureThis) {\n                    this.writeCaptureThisStatement(moduleDecl);\n                }\n\n                this.emitJavascriptList(moduleDecl.members, null, TokenID.Semicolon, true, false, false);\n                if (!isDynamicMod || moduleGenTarget == ModuleGenTarget.Asynchronous) {\n                    this.indenter.decreaseIndent();\n                }\n                this.emitIndent();\n\n                // epilogue\n                if (isDynamicMod) {\n                    if (moduleGenTarget == ModuleGenTarget.Asynchronous) { // AMD\n                        this.writeLineToOutput("})");\n                    }\n                    else { // Node\n                    }\n                    if (!isWholeFile) {\n                        this.recordSourceMappingNameEnd();\n                    }\n                    this.recordSourceMappingEnd(moduleDecl);\n\n                    // close the module outfile, and restore the old one\n                    if (this.outfile != prevOutFile) {\n                        this.Close();\n                        if (prevSourceMapper != null) {\n                            this.allSourceMappers = prevAllSourceMappers;\n                            this.sourceMapper = prevSourceMapper;\n                            this.emitState.column = prevColumn;\n                            this.emitState.line = prevLine;\n                        }\n                        this.outfile = prevOutFile;\n                        this.emittingFileName = prevOutFileName;\n                    }\n                }\n                else {\n                    var containingMod: ModuleDeclaration = null;\n                    if (moduleDecl.type && moduleDecl.type.symbol.container && moduleDecl.type.symbol.container.declAST) {\n                        containingMod = <ModuleDeclaration>moduleDecl.type.symbol.container.declAST;\n                    }\n                    var parentIsDynamic = containingMod && hasFlag(containingMod.modFlags, ModuleFlags.IsDynamic);\n\n                    this.recordSourceMappingStart(moduleDecl.endingToken);\n                    if (temp == EmitContainer.Prog && isExported) {\n                        this.writeToOutput("}");\n                        if (!isWholeFile) {\n                            this.recordSourceMappingNameEnd();\n                        }\n                        this.recordSourceMappingEnd(moduleDecl.endingToken);\n                        this.writeToOutput(")(this." + this.moduleName + " || (this." + this.moduleName + " = {}));");\n                    }\n                    else if (isExported || temp == EmitContainer.Prog) {\n                        var dotMod = svModuleName != "" ? (parentIsDynamic ? "exports" : svModuleName) + "." : svModuleName;\n                        this.writeToOutput("}");\n                        if (!isWholeFile) {\n                            this.recordSourceMappingNameEnd();\n                        }\n                        this.recordSourceMappingEnd(moduleDecl.endingToken);\n                        this.writeToOutput(")(" + dotMod + this.moduleName + " || (" + dotMod + this.moduleName + " = {})',
v27646=v27647+');");\n                    }\n                    else if (!isExported && temp != EmitContainer.Prog) {\n                        this.writeToOutput("}");\n                        if (!isWholeFile) {\n                            this.recordSourceMappingNameEnd();\n                        }\n                        this.recordSourceMappingEnd(moduleDecl.endingToken);\n                        this.writeToOutput(")(" + this.moduleName + " || (" + this.moduleName + " = {}));");\n                    }\n                    else {\n                        this.writeToOutput("}");\n                        if (!isWholeFile) {\n                            this.recordSourceMappingNameEnd();\n                        }\n                        this.recordSourceMappingEnd(moduleDecl.endingToken);\n                        this.writeToOutput(")();");\n                    }\n                    this.recordSourceMappingEnd(moduleDecl);\n                    this.writeLineToOutput("");\n                    if (temp != EmitContainer.Prog && isExported) {\n                        this.emitIndent();\n                        this.recordSourceMappingStart(moduleDecl);\n                        if (parentIsDynamic) {\n                            this.writeLineToOutput("var " + this.moduleName + " = exports." + this.moduleName + ";");\n                        } else {\n                            this.writeLineToOutput("var " + this.moduleName + " = " + svModuleName + "." + this.moduleName + ";");\n                        }\n                        this.recordSourceMappingEnd(moduleDecl);\n                    }\n                }\n\n                this.setContainer(temp);\n                this.moduleName = svModuleName;\n                this.moduleDeclList.length--;\n            }\n        }\n\n        public emitIndex(operand1: AST, operand2: AST) {\n            var temp = this.setInObjectLiteral(false);\n            this.emitJavascript(operand1, TokenID.Tilde, false);\n            this.writeToOutput("[");\n            this.emitJavascriptList(operand2, ", ", TokenID.Comma, false, false, false);\n            this.writeToOutput("]");\n            this.setInObjectLiteral(temp);\n        }\n\n        public emitStringLiteral(text: string) {\n            // should preserve escape etc.\n            // TODO: simplify object literal simple name\n            this.writeToOutput(text);\n        }\n\n        public emitJavascriptFunction(funcDecl: FuncDecl) {\n            if (hasFlag(funcDecl.fncFlags, FncFlags.Signature) || funcDecl.isOverload) {\n                return;\n            }\n            var temp: number;\n            var tempFnc = this.thisFnc;\n            this.thisFnc = funcDecl;\n\n            if (funcDecl.isConstructor) {\n                temp = this.setContainer(EmitContainer.Constructor);\n            }\n            else {\n                temp = this.setContainer(EmitContainer.Function);\n            }\n\n            var bases: ASTList = null;\n            var hasSelfRef = false;\n            var funcName = funcDecl.getNameText();\n\n            if ((this.emitState.inObjectLiteral || !funcDecl.isAccessor()) &&\n                ((temp != EmitContainer.Constructor) ||\n                ((funcDecl.fncFlags & FncFlags.Method) == FncFlags.None))) {\n                var tempLit = this.setInObjectLiteral(false);\n                if (this.thisClassNode) {\n                    bases = this.thisClassNode.extendsList;\n                }\n                hasSelfRef = Emitter.shouldCaptureThis(funcDecl);\n                this.recordSourceMappingStart(funcDecl);\n                if (hasFlag(funcDecl.fncFlags, FncFlags.Exported | FncFlags.ClassPropertyMethodExported) && funcDecl.type.symbol.container == this.checker.gloMod && !funcDecl.isConstructor) {\n                    this.writeToOutput("this." + funcName + " = ");\n                    this.emitInnerFunction(funcDecl, false, false, bases, hasSelfRef, this.thisClassNode);\n                }\n                else {\n                    this.emitInnerFunction(funcDecl, (funcDecl.name && !funcDecl.name.isMissing()), false, bases, hasSelfRef, this.thisClassNode);\n                }\n                this.setInObjectLiteral(tempLit);\n            }\n            this.setContainer(temp);\n            this.thisFnc = tempFnc;\n\n            if (hasFlag(funcDecl.fncFlags, FncFlags.Definition)) {\n                if (hasFlag(funcDecl.fncFlags, FncFlags.Static)) {\n                    if (this.thisClassNode) {\n                        if (funcDecl.isAccessor()) {\n                            this.emitPropertyAccessor(funcDecl, this.thisClassNode.name.actualText, false);\n                        }\n                        else {\n                            this.emitIndent();\n                            this.recordSourceMappingStart(funcDecl);\n                            this.writeLineToOutput(this.thisClassNode.name.actualText + "." + funcName +\n                                          " = " + funcName + ";");\n                            this.recordSourceMappingEnd(funcDecl);\n                     ',
v27645=v27646+'   }\n                    }\n                }\n                else if ((this.emitState.container == EmitContainer.Module || this.emitState.container == EmitContainer.DynamicModule) && hasFlag(funcDecl.fncFlags, FncFlags.Exported | FncFlags.ClassPropertyMethodExported)) {\n                    this.emitIndent();\n                    var modName = this.emitState.container == EmitContainer.Module ? this.moduleName : "exports";\n                    this.recordSourceMappingStart(funcDecl);\n                    this.writeLineToOutput(modName + "." + funcName +\n                                      " = " + funcName + ";");\n                    this.recordSourceMappingEnd(funcDecl);\n                }\n            }\n        }\n\n        public emitAmbientVarDecl(varDecl: VarDecl) {\n            if (varDecl.init) {\n                this.emitParensAndCommentsInPlace(varDecl, true);\n                this.recordSourceMappingStart(varDecl);\n                this.recordSourceMappingStart(varDecl.id);\n                this.writeToOutput(varDecl.id.actualText);\n                this.recordSourceMappingEnd(varDecl.id);\n                this.writeToOutput(" = ");\n                this.emitJavascript(varDecl.init, TokenID.Comma, false);\n                this.recordSourceMappingEnd(varDecl);\n                this.writeToOutput(";");\n                this.emitParensAndCommentsInPlace(varDecl, false);\n            }\n        }\n\n        private varListCount(): number {\n            return this.varListCountStack[this.varListCountStack.length - 1];\n        }\n\n        // Emits "var " if it is allowed\n        private emitVarDeclVar() {\n            // If it is var list of form var a, b, c = emit it only if count > 0 - which will be when emitting first var\n            // If it is var list of form  var a = varList count will be 0\n            if (this.varListCount() >= 0) {\n                this.writeToOutput("var ");\n                this.setInVarBlock(-this.varListCount());\n            }\n            return true;\n        }\n\n        private onEmitVar() {\n            if (this.varListCount() > 0) {\n                this.setInVarBlock(this.varListCount() - 1);\n            }\n            else if (this.varListCount() < 0) {\n                this.setInVarBlock(this.varListCount() + 1);\n            }\n        }\n\n        public emitJavascriptVarDecl(varDecl: VarDecl, tokenId: TokenID) {\n            if ((varDecl.varFlags & VarFlags.Ambient) == VarFlags.Ambient) {\n                this.emitAmbientVarDecl(varDecl);\n                this.onEmitVar();\n            }\n            else {\n                var sym = varDecl.sym;\n                var hasInitializer = (varDecl.init != null);\n                this.emitParensAndCommentsInPlace(varDecl, true);\n                this.recordSourceMappingStart(varDecl);\n                if (sym && sym.isMember() && sym.container &&\n                    (sym.container.kind() == SymbolKind.Type)) {\n                    var type = (<TypeSymbol>sym.container).type;\n                    if (type.isClass() && (!hasFlag(sym.flags, SymbolFlags.ModuleMember))) {\n                        // class\n                        if (this.emitState.container != EmitContainer.Args) {\n                            if (hasFlag(sym.flags, SymbolFlags.Static)) {\n                                this.writeToOutput(sym.container.name + ".");\n                            }\n                            else {\n                                this.writeToOutput("this.");\n                            }\n                        }\n                    }\n                    else if (type.hasImplementation()) {\n                        // module\n                        if (!hasFlag(sym.flags, SymbolFlags.Exported) && (sym.container == this.checker.gloMod || !hasFlag(sym.flags, SymbolFlags.Property))) {\n                            this.emitVarDeclVar();\n                        }\n                        else if (hasFlag(varDecl.varFlags, VarFlags.LocalStatic)) {\n                            this.writeToOutput(".");\n                        }\n                        else {\n                            if (this.emitState.container == EmitContainer.DynamicModule) {\n                                this.writeToOutput("exports.");\n                            }\n                            else {\n                                this.writeToOutput(this.moduleName + ".");\n                            }\n                        }\n                    }\n                    else {\n                        // function, constructor, method etc.\n                        if (tokenId != TokenID.OpenParen) {\n                            if (hasFlag(sym.flags, SymbolFlags.Exported) && sym.container == this.checker.gloMod) {\n                                this.writeToOutput("this.");\n                            }\n                            else {\n                                this.emitVarDeclVar();\n                            }\n                        }\n                    }\n                }\n                else {\n            ',
v27644=v27645+'        if (tokenId != TokenID.OpenParen) {\n                        this.emitVarDeclVar();\n                    }\n                }\n                this.recordSourceMappingStart(varDecl.id);\n                this.writeToOutput(varDecl.id.actualText);\n                this.recordSourceMappingEnd(varDecl.id);\n                if (hasInitializer) {\n                    this.writeToOutputTrimmable(" = ");\n\n                    // Ensure we have a fresh var list count when recursing into the variable \n                    // initializer.  We don\'t want our current list of variables to affect how we\n                    // emit nested variable lists.\n                    this.varListCountStack.push(0);\n                    this.emitJavascript(varDecl.init, TokenID.Comma, false);\n                    this.varListCountStack.pop();\n                }\n                this.onEmitVar();\n                if ((tokenId != TokenID.OpenParen)) {\n                    if (this.varListCount() < 0) {\n                        this.writeToOutput(", ");\n                    } else if (tokenId != TokenID.For) {\n                        this.writeToOutputTrimmable(";");\n                    }\n                }\n                this.recordSourceMappingEnd(varDecl);\n                this.emitParensAndCommentsInPlace(varDecl, false);\n            }\n        }\n\n        public declEnclosed(moduleDecl: ModuleDeclaration): bool {\n            if (moduleDecl == null) {\n                return true;\n            }\n            for (var i = 0, len = this.moduleDeclList.length; i < len; i++) {\n                if (this.moduleDeclList[i] == moduleDecl) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        public emitJavascriptName(name: Identifier, addThis: bool) {\n            var sym = name.sym;\n            this.emitParensAndCommentsInPlace(name, true);\n            this.recordSourceMappingStart(name);\n            if (!name.isMissing()) {\n                if (addThis && (this.emitState.container != EmitContainer.Args) && sym) {\n                    // TODO: flag global module with marker other than string name\n                    if (sym.container && (sym.container.name != globalId)) {\n                        if (hasFlag(sym.flags, SymbolFlags.Static) && (hasFlag(sym.flags, SymbolFlags.Property))) {\n                            if (sym.declModule && hasFlag(sym.declModule.modFlags, ModuleFlags.IsDynamic)) {\n                                this.writeToOutput("exports.");\n                            }\n                            else {\n                                this.writeToOutput(sym.container.name + ".");\n                            }\n                        }\n                        else if (sym.kind() == SymbolKind.Field) {\n                            var fieldSym = <FieldSymbol>sym;\n                            if (hasFlag(fieldSym.flags, SymbolFlags.ModuleMember)) {\n                                if ((sym.container != this.checker.gloMod) && ((hasFlag(sym.flags, SymbolFlags.Property)) || hasFlag(sym.flags, SymbolFlags.Exported))) {\n                                    if (hasFlag(sym.declModule.modFlags, ModuleFlags.IsDynamic)) {\n                                        this.writeToOutput("exports.");\n                                    }\n                                    else {\n                                        this.writeToOutput(sym.container.name + ".");\n                                    }\n                                }\n                            }\n                            else {\n                                if (sym.isInstanceProperty()) {\n                                    this.emitThis();\n                                    this.writeToOutput(".");\n                                }\n                            }\n                        }\n                        else if (sym.kind() == SymbolKind.Type) {\n                            if (sym.isInstanceProperty()) {\n                                var typeSym = <TypeSymbol>sym;\n                                var type = typeSym.type;\n                                if (type.call && !hasFlag(sym.flags, SymbolFlags.ModuleMember)) {\n                                    this.emitThis();\n                                    this.writeToOutput(".");\n                                }\n                            }\n                            else if ((sym.unitIndex != this.checker.locationInfo.unitIndex) || (!this.declEnclosed(sym.declModule))) {\n                                this.writeToOutput(sym.container.name + ".")\n                            }\n                        }\n                    }\n                    else if (sym.container == this.checker.gloMod &&\n                                hasFlag(sym.flags, SymbolFlags.Exported) &&\n                                !hasFlag(sym.flags, SymbolFlags.Ambient) &&\n                                // check that it\'s a not a member of an ambient module...\n                                !((sym.isType()',
v27643=v27644+' || sym.isMember()) &&\n                                    sym.declModule &&\n                                    hasFlag(sym.declModule.modFlags, ModuleFlags.Ambient)) &&\n                                this.emitState.container == EmitContainer.Prog &&\n                                sym.declAST.nodeType != NodeType.FuncDecl) {\n                        this.writeToOutput("this.");\n                    }\n                }\n\n                // If it\'s a dynamic module, we need to print the "require" invocation\n                if (sym &&\n                    sym.declAST &&\n                    sym.declAST.nodeType == NodeType.ModuleDeclaration &&\n                    (hasFlag((<ModuleDeclaration>sym.declAST).modFlags, ModuleFlags.IsDynamic))) {\n                    var moduleDecl: ModuleDeclaration = <ModuleDeclaration>sym.declAST;\n\n                    if (moduleGenTarget == ModuleGenTarget.Asynchronous) {\n                        this.writeLineToOutput("__" + this.modAliasId + "__;");\n                    }\n                    else {\n                        var modPath = name.actualText;//(<ModuleDecl>moduleDecl.mod.symbol.declAST).name.actualText;\n                        var isAmbient = moduleDecl.mod.symbol.declAST && hasFlag((<ModuleDeclaration>moduleDecl.mod.symbol.declAST).modFlags, ModuleFlags.Ambient);\n                        modPath = isAmbient ? modPath : this.firstModAlias ? this.firstModAlias : quoteBaseName(modPath);\n                        modPath = isAmbient ? modPath : (!isRelative(stripQuotes(modPath)) ? quoteStr("./" + stripQuotes(modPath)) : modPath);\n                        this.writeToOutput("require(" + modPath + ")");\n                    }\n                }\n                else {\n                    this.writeToOutput(name.actualText);\n                }\n            }\n            this.recordSourceMappingEnd(name);\n            this.emitParensAndCommentsInPlace(name, false);\n        }\n\n        public emitJavascriptStatements(stmts: AST, emitEmptyBod: bool) {\n            if (stmts) {\n                if (stmts.nodeType != NodeType.Block) {\n                    var hasContents = (stmts && (stmts.nodeType != NodeType.List || ((<ASTList>stmts).members.length > 0)));\n                    if (emitEmptyBod || hasContents) {\n                        var hasOnlyBlockStatement = ((stmts.nodeType == NodeType.Block) ||\n                            ((stmts.nodeType == NodeType.List) && ((<ASTList>stmts).members.length == 1) && ((<ASTList>stmts).members[0].nodeType == NodeType.Block)));\n\n                        this.recordSourceMappingStart(stmts);\n                        if (!hasOnlyBlockStatement) {\n                            this.writeLineToOutput(" {");\n                            this.indenter.increaseIndent();\n                        }\n                        this.emitJavascriptList(stmts, null, TokenID.Semicolon, true, false, false);\n                        if (!hasOnlyBlockStatement) {\n                            this.writeLineToOutput("");\n                            this.indenter.decreaseIndent();\n                            this.emitIndent();\n                            this.writeToOutput("}");\n                        }\n                        this.recordSourceMappingEnd(stmts);\n                    }\n                }\n                else {\n                    this.emitJavascript(stmts, TokenID.Semicolon, true);\n                }\n            }\n            else if (emitEmptyBod) {\n                this.writeToOutput("{ }");\n            }\n        }\n\n        public emitBareJavascriptStatements(stmts: AST, emitClassPropertiesAfterSuperCall: bool = false) {\n            // just the statements without enclosing curly braces\n            if (stmts.nodeType != NodeType.Block) {\n                if (stmts.nodeType == NodeType.List) {\n                    var stmtList = <ASTList>stmts;\n                    if ((stmtList.members.length == 2) &&\n                        (stmtList.members[0].nodeType == NodeType.Block) &&\n                        (stmtList.members[1].nodeType == NodeType.EndCode)) {\n                        this.emitJavascript(stmtList.members[0], TokenID.Semicolon, true);\n                        this.writeLineToOutput("");\n                    }\n                    else {\n                        this.emitJavascriptList(stmts, null, TokenID.Semicolon, true, false, emitClassPropertiesAfterSuperCall);\n                    }\n                }\n                else {\n                    this.emitJavascript(stmts, TokenID.Semicolon, true);\n                }\n            }\n            else {\n                this.emitJavascript(stmts, TokenID.Semicolon, true);\n            }\n        }\n\n        public recordSourceMappingNameStart(name: string) {\n            if (this.sourceMapper) {\n                var finalName = name;\n                if (!name) {\n                    finalName = "";\n                } else if (this.sourceMapper.currentNameIndex.length > 0) {\n                    finalName = this.sourceMapper.names[this.source',
v27642=v27643+"Mapper.currentNameIndex.length - 1] + \".\" + name;\n                }\n\n                // We are currently not looking for duplicate but that is possible.\n                this.sourceMapper.names.push(finalName);\n                this.sourceMapper.currentNameIndex.push(this.sourceMapper.names.length - 1);\n            }\n        }\n\n        public recordSourceMappingNameEnd() {\n            if (this.sourceMapper) {\n                this.sourceMapper.currentNameIndex.pop();\n            }\n        }\n\n        public recordSourceMappingStart(ast: ASTSpan) {\n            if (this.sourceMapper && isValidAstNode(ast)) {\n                var lineCol = { line: -1, col: -1 };\n                var sourceMapping = new SourceMapping();\n                sourceMapping.start.emittedColumn = this.emitState.column;\n                sourceMapping.start.emittedLine = this.emitState.line;\n                // REVIEW: check time consumed by this binary search (about two per leaf statement)\n                getSourceLineColFromMap(lineCol, ast.minChar, this.checker.locationInfo.lineMap);\n                sourceMapping.start.sourceColumn = lineCol.col;\n                sourceMapping.start.sourceLine = lineCol.line;\n                getSourceLineColFromMap(lineCol, ast.limChar, this.checker.locationInfo.lineMap);\n                sourceMapping.end.sourceColumn = lineCol.col;\n                sourceMapping.end.sourceLine = lineCol.line;\n                if (this.sourceMapper.currentNameIndex.length > 0) {\n                    sourceMapping.nameIndex = this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length - 1];\n                }\n                // Set parent and child relationship\n                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];\n                siblings.push(sourceMapping);\n                this.sourceMapper.currentMappings.push(sourceMapping.childMappings);\n            }\n        }\n\n        public recordSourceMappingEnd(ast: ASTSpan) {\n            if (this.sourceMapper && isValidAstNode(ast)) {\n                // Pop source mapping childs\n                this.sourceMapper.currentMappings.pop();\n\n                // Get the last source mapping from sibling list = which is the one we are recording end for\n                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];\n                var sourceMapping = siblings[siblings.length - 1];\n\n                sourceMapping.end.emittedColumn = this.emitState.column;\n                sourceMapping.end.emittedLine = this.emitState.line;\n            }\n        }\n\n        public Close() {\n            if (this.sourceMapper != null) {\n                SourceMapper.EmitSourceMapping(this.allSourceMappers);\n            }\n            try {\n                // Closing files could result in exceptions, report them if they occur\n                this.outfile.Close();\n            } catch (ex) {\n                this.errorReporter.emitterError(null, ex.message);\n            }\n        }\n\n        public emitJavascriptList(ast: AST, delimiter: string, tokenId: TokenID, startLine: bool, onlyStatics: bool, emitClassPropertiesAfterSuperCall: bool = false, emitPrologue? = false, requiresExtendsBlock?: bool) {\n            if (ast == null) {\n                return;\n            }\n            else if (ast.nodeType != NodeType.List) {\n                this.emitPrologue(emitPrologue);\n                this.emitJavascript(ast, tokenId, startLine);\n            }\n            else {\n                var list = <ASTList>ast;\n                if (list.members.length == 0) {\n                    return;\n                }\n\n                this.emitParensAndCommentsInPlace(ast, true);\n                var len = list.members.length;\n                for (var i = 0; i < len; i++) {\n                    if (emitPrologue) {\n                        // If the list has Strict mode flags, emit prologue after first statement\n                        // otherwise emit before first statement\n                        if (i == 1 || !hasFlag(list.flags, ASTFlags.StrictMode)) {\n                            this.emitPrologue(requiresExtendsBlock);\n                            emitPrologue = false;\n                        }\n                    }\n\n                    // In some circumstances, class property initializers must be emitted immediately after the 'super' constructor\n                    // call which, in these cases, must be the first statement in the constructor body\n                    if (i == 1 && emitClassPropertiesAfterSuperCall) {\n\n                        // emit any parameter properties first\n                        var constructorDecl = (<ClassDeclaration>this.thisClassNode).constructorDecl;\n\n                        if (constructorDecl && constructorDecl.arguments) {\n                            var argsLen = constructorDecl.arguments.members.length;\n                            for (var iArg = 0; iArg < argsLen; iArg++) {\n                     ",
v27641=v27642+'           var arg = <BoundDecl>constructorDecl.arguments.members[iArg];\n                                if ((arg.varFlags & VarFlags.Property) != VarFlags.None) {\n                                    this.emitIndent();\n                                    this.recordSourceMappingStart(arg);\n                                    this.recordSourceMappingStart(arg.id);\n                                    this.writeToOutput("this." + arg.id.actualText);\n                                    this.recordSourceMappingEnd(arg.id);\n                                    this.writeToOutput(" = ");\n                                    this.recordSourceMappingStart(arg.id);\n                                    this.writeToOutput(arg.id.actualText);\n                                    this.recordSourceMappingEnd(arg.id);\n                                    this.writeLineToOutput(";");\n                                    this.recordSourceMappingEnd(arg);\n                                }\n                            }\n                        }\n\n                        var nProps = (<ASTList>this.thisClassNode.members).members.length;\n\n                        for (var iMember = 0; iMember < nProps; iMember++) {\n                            if ((<ASTList>this.thisClassNode.members).members[iMember].nodeType == NodeType.VarDecl) {\n                                var varDecl = <VarDecl>(<ASTList>this.thisClassNode.members).members[iMember];\n                                if (!hasFlag(varDecl.varFlags, VarFlags.Static) && varDecl.init) {\n                                    this.emitIndent();\n                                    this.emitJavascriptVarDecl(varDecl, TokenID.Tilde);\n                                    this.writeLineToOutput("");\n                                }\n                            }\n                        }\n                    }\n\n                    var emitNode = list.members[i];\n\n                    var isStaticDecl =\n                                (emitNode.nodeType == NodeType.FuncDecl && hasFlag((<FuncDecl>emitNode).fncFlags, FncFlags.Static)) ||\n                                (emitNode.nodeType == NodeType.VarDecl && hasFlag((<VarDecl>emitNode).varFlags, VarFlags.Static))\n\n                    if (onlyStatics ? !isStaticDecl : isStaticDecl) {\n                        continue;\n                    }\n                    this.emitJavascript(emitNode, tokenId, startLine);\n\n                    if (delimiter && (i < (len - 1))) {\n                        if (startLine) {\n                            this.writeLineToOutput(delimiter);\n                        }\n                        else {\n                            this.writeToOutput(delimiter);\n                        }\n                    }\n                    else if (startLine &&\n                             (emitNode.nodeType != NodeType.ModuleDeclaration) &&\n                             (emitNode.nodeType != NodeType.InterfaceDeclaration) &&\n                             (!((emitNode.nodeType == NodeType.VarDecl) &&\n                                ((((<VarDecl>emitNode).varFlags) & VarFlags.Ambient) == VarFlags.Ambient) &&\n                                (((<VarDecl>emitNode).init) == null)) && this.varListCount() >= 0) &&\n                             (emitNode.nodeType != NodeType.Block || (<Block>emitNode).isStatementBlock) &&\n                             (emitNode.nodeType != NodeType.EndCode) &&\n                             (emitNode.nodeType != NodeType.FuncDecl)) {\n                        this.writeLineToOutput("");\n                    }\n                }\n                this.emitParensAndCommentsInPlace(ast, false);\n            }\n        }\n\n        // tokenId is the id the preceding token\n        public emitJavascript(ast: AST, tokenId: TokenID, startLine: bool) {\n            if (ast == null) {\n                return;\n            }\n\n            // REVIEW: simplify rules for indenting\n            if (startLine && (this.indenter.indentAmt > 0) && (ast.nodeType != NodeType.List) &&\n                (ast.nodeType != NodeType.Block)) {\n                if ((ast.nodeType != NodeType.InterfaceDeclaration) &&\n                    (!((ast.nodeType == NodeType.VarDecl) &&\n                       ((((<VarDecl>ast).varFlags) & VarFlags.Ambient) == VarFlags.Ambient) &&\n                       (((<VarDecl>ast).init) == null)) && this.varListCount() >= 0) &&\n                    (ast.nodeType != NodeType.EndCode) &&\n                    ((ast.nodeType != NodeType.FuncDecl) ||\n                     (this.emitState.container != EmitContainer.Constructor))) {\n                    this.emitIndent();\n                }\n            }\n\n            ast.emit(this, tokenId, startLine);\n\n            if ((tokenId == TokenID.Semicolon) && (ast.nodeType < NodeType.GeneralNode)) {\n                this.writeToOutput(";");\n            }\n        }\n\n        public emitPropertyAccessor(funcDecl: FuncDecl, className: string, isProto: bool) {\n            if (!(<FieldSymbol>funcDecl.accessorSymbol).h',
v27640=v27641+'asBeenEmitted) {\n                var accessorSymbol = <FieldSymbol>funcDecl.accessorSymbol;\n                this.emitIndent();\n                this.recordSourceMappingStart(funcDecl);\n                this.writeLineToOutput("Object.defineProperty(" + className + (isProto ? ".prototype, \\"" : ", \\"") + funcDecl.name.actualText + "\\"" + ", {");\n                this.indenter.increaseIndent();\n\n                if (accessorSymbol.getter) {\n                    var getter: FuncDecl = <FuncDecl>accessorSymbol.getter.declAST;\n\n                    this.emitIndent();\n                    this.recordSourceMappingStart(getter);\n                    this.writeToOutput("get: ");\n                    this.emitInnerFunction(getter, false, isProto, null, Emitter.shouldCaptureThis(getter), null);\n                    this.writeLineToOutput(",");\n                }\n\n                if (accessorSymbol.setter) {\n                    var setter: FuncDecl = <FuncDecl>accessorSymbol.setter.declAST;\n\n                    this.emitIndent();\n                    this.recordSourceMappingStart(setter);\n                    this.writeToOutput("set: ");\n                    this.emitInnerFunction(setter, false, isProto, null, Emitter.shouldCaptureThis(setter), null);\n                    this.writeLineToOutput(",");\n                }\n\n                this.emitIndent();\n                this.writeLineToOutput("enumerable: true,");\n                this.emitIndent();\n                this.writeLineToOutput("configurable: true");\n                this.indenter.decreaseIndent();\n                this.emitIndent();\n                this.writeLineToOutput("});");\n                this.recordSourceMappingEnd(funcDecl);\n\n                accessorSymbol.hasBeenEmitted = true;\n            }\n        }\n\n        public emitPrototypeMember(member: AST, className: string) {\n            if (member.nodeType == NodeType.FuncDecl) {\n                var funcDecl = <FuncDecl>member;\n                if (funcDecl.isAccessor()) {\n                    this.emitPropertyAccessor(funcDecl, className, true);\n                }\n                else {\n                    this.emitIndent();\n                    this.recordSourceMappingStart(funcDecl);\n                    this.writeToOutput(className + ".prototype." + funcDecl.getNameText() + " = ");\n                    this.emitInnerFunction(funcDecl, false, true, null, Emitter.shouldCaptureThis(funcDecl), null);\n                    this.writeLineToOutput(";");\n                }\n            }\n            else if (member.nodeType == NodeType.VarDecl) {\n                var varDecl = <VarDecl>member;\n\n                if (varDecl.init) {\n                    this.emitIndent();\n                    this.recordSourceMappingStart(varDecl);\n                    this.recordSourceMappingStart(varDecl.id);\n                    this.writeToOutput(className + ".prototype." + varDecl.id.actualText);\n                    this.recordSourceMappingEnd(varDecl.id);\n                    this.writeToOutput(" = ");\n                    this.emitJavascript(varDecl.init, TokenID.Equals, false);\n                    this.recordSourceMappingEnd(varDecl);\n                    this.writeLineToOutput(";");\n                }\n            }\n        }\n\n        public emitAddBaseMethods(className: string, base: Type, classDecl: TypeDeclaration): void {\n            if (base.members) {\n                var baseSymbol = base.symbol;\n                var baseName = baseSymbol.name;\n                if (baseSymbol.declModule != classDecl.type.symbol.declModule) {\n                    baseName = baseSymbol.fullName();\n                }\n                base.members.allMembers.map(function(key, s, c) {\n                    var sym = <Symbol>s;\n                    if ((sym.kind() == SymbolKind.Type) && (<TypeSymbol>sym).type.call) {\n                        this.recordSourceMappingStart(sym.declAST);\n                        this.writeLineToOutput(className + ".prototype." + sym.name + " = " +\n                                          baseName + ".prototype." + sym.name + ";");\n                        this.recordSourceMappingEnd(sym.declAST);\n                    }\n                }, null);\n            }\n            if (base.extendsList) {\n                for (var i = 0, len = base.extendsList.length; i < len; i++) {\n                    this.emitAddBaseMethods(className, base.extendsList[i], classDecl);\n                }\n            }\n        }\n\n        public emitJavascriptClass(classDecl: ClassDeclaration) {\n            if (!hasFlag(classDecl.varFlags, VarFlags.Ambient)) {\n                var svClassNode = this.thisClassNode;\n                var i = 0;\n                this.thisClassNode = classDecl;\n                var className = classDecl.name.actualText;\n                this.emitParensAndCommentsInPlace(classDecl, true);\n                var temp = this.setContainer(EmitContainer.Class);\n\n                this.recordSourceMappingStart(classDecl);\n                if (hasFlag(classDecl.varFlags, VarF',
v27639=v27640+'lags.Exported) && classDecl.type.symbol.container == this.checker.gloMod) {\n                    this.writeToOutput("this." + className);\n                }\n                else {\n                    this.writeToOutput("var " + className);\n                }\n\n                //if (hasFlag(classDecl.varFlags, VarFlags.Exported) && (temp == EmitContainer.Module || temp == EmitContainer.DynamicModule)) {\n                //    var modName = temp == EmitContainer.Module ? this.moduleName : "exports";\n                //    this.writeToOutput(" = " + modName + "." + className);\n                //}\n\n                var hasBaseClass = classDecl.extendsList && classDecl.extendsList.members.length;\n                var baseNameDecl: AST = null;\n                var baseName: AST = null;\n\n                if (hasBaseClass) {\n                    this.writeLineToOutput(" = (function (_super) {");\n                } else {\n                    this.writeLineToOutput(" = (function () {");\n                }\n\n                this.recordSourceMappingNameStart(className);\n                this.indenter.increaseIndent();\n\n                if (hasBaseClass) {\n                    baseNameDecl = classDecl.extendsList.members[0];\n                    baseName = baseNameDecl.nodeType == NodeType.Call ? (<CallExpression>baseNameDecl).target : baseNameDecl;\n                    this.emitIndent();\n                    this.writeLineToOutput("__extends(" + className + ", _super);");\n                }\n\n                this.emitIndent();\n\n                var constrDecl = classDecl.constructorDecl;\n\n                // output constructor\n                if (constrDecl) {\n                    // declared constructor\n                    this.emitJavascript(classDecl.constructorDecl, TokenID.OpenParen, false);\n\n                }\n                else {\n                    var wroteProps = 0;\n\n                    this.recordSourceMappingStart(classDecl);\n                    // default constructor\n                    this.indenter.increaseIndent();\n                    this.writeToOutput("function " + classDecl.name.actualText + "() {");\n                    this.recordSourceMappingNameStart("constructor");\n                    if (hasBaseClass) {\n                        this.writeLineToOutput("");\n                        this.emitIndent();\n                        this.writeLineToOutput("_super.apply(this, arguments);");\n                        wroteProps++;\n                    }\n\n                    if (classDecl.varFlags & VarFlags.MustCaptureThis) {\n                        this.writeCaptureThisStatement(classDecl);\n                    }\n\n                    var members = (<ASTList>this.thisClassNode.members).members\n\n                    // output initialized properties\n                    for (var i = 0; i < members.length; i++) {\n                        if (members[i].nodeType == NodeType.VarDecl) {\n                            var varDecl = <VarDecl>members[i];\n                            if (!hasFlag(varDecl.varFlags, VarFlags.Static) && varDecl.init) {\n                                this.writeLineToOutput("");\n                                this.emitIndent();\n                                this.emitJavascriptVarDecl(varDecl, TokenID.Tilde);\n                                wroteProps++;\n                            }\n                        }\n                    }\n                    if (wroteProps) {\n                        this.writeLineToOutput("");\n                        this.indenter.decreaseIndent();\n                        this.emitIndent();\n                        this.writeLineToOutput("}");\n                    }\n                    else {\n                        this.writeLineToOutput(" }");\n                        this.indenter.decreaseIndent();\n                    }\n                    this.recordSourceMappingNameEnd();\n                    this.recordSourceMappingEnd(classDecl);\n                }\n\n                var membersLen = classDecl.members.members.length;\n                for (var j = 0; j < membersLen; j++) {\n\n                    var memberDecl: AST = classDecl.members.members[j];\n\n                    if (memberDecl.nodeType == NodeType.FuncDecl) {\n                        var fn = <FuncDecl>memberDecl;\n\n                        if (hasFlag(fn.fncFlags, FncFlags.Method) && !fn.isSignature()) {\n                            if (!hasFlag(fn.fncFlags, FncFlags.Static)) {\n                                this.emitPrototypeMember(fn, className);\n                            }\n                            else { // static functions\n                                if (fn.isAccessor()) {\n                                    this.emitPropertyAccessor(fn, this.thisClassNode.name.actualText, false);\n                                }\n                                else {\n                                    this.emitIndent();\n                                    this.recordSourceMappingStart(fn)\n                                    this.writeToOutput(classD',
v27638=v27639+'ecl.name.actualText + "." + fn.name.actualText + " = ");\n                                    this.emitInnerFunction(fn, (fn.name && !fn.name.isMissing()), true,\n                                            null, Emitter.shouldCaptureThis(fn), null);\n                                    this.writeLineToOutput(";");\n                                }\n                            }\n                        }\n                    }\n                    else if (memberDecl.nodeType == NodeType.VarDecl) {\n                        var varDecl = <VarDecl>memberDecl;\n                        if (hasFlag(varDecl.varFlags, VarFlags.Static)) {\n\n                            if (varDecl.init) {\n                                // EMITREVIEW\n                                this.emitIndent();\n                                this.recordSourceMappingStart(varDecl);\n                                this.writeToOutput(classDecl.name.actualText + "." + varDecl.id.actualText + " = ");\n                                this.emitJavascript(varDecl.init, TokenID.Equals, false);\n                                // EMITREVIEW\n\n                                this.writeLineToOutput(";");\n                                this.recordSourceMappingEnd(varDecl);\n                            }\n                        }\n                    }\n                    else {\n                        throw Error("We want to catch this");\n                    }\n                }\n\n                this.emitIndent();\n                this.recordSourceMappingStart(classDecl.endingToken);\n                this.writeLineToOutput("return " + className + ";");\n                this.recordSourceMappingEnd(classDecl.endingToken);\n                this.indenter.decreaseIndent();\n                this.emitIndent();\n                this.recordSourceMappingStart(classDecl.endingToken);\n                this.writeToOutput("}");\n                this.recordSourceMappingNameEnd();\n                this.recordSourceMappingEnd(classDecl.endingToken);\n                this.recordSourceMappingStart(classDecl);\n                this.writeToOutput(")(");\n                if (hasBaseClass)\n                    this.emitJavascript(baseName, TokenID.Tilde, false);\n                this.writeToOutput(");");\n                this.recordSourceMappingEnd(classDecl);\n\n                if ((temp == EmitContainer.Module || temp == EmitContainer.DynamicModule) && hasFlag(classDecl.varFlags, VarFlags.Exported)) {\n                    this.writeLineToOutput("");\n                    this.emitIndent();\n                    var modName = temp == EmitContainer.Module ? this.moduleName : "exports";\n                    this.recordSourceMappingStart(classDecl);\n                    this.writeToOutput(modName + "." + className + " = " + className + ";");\n                    this.recordSourceMappingEnd(classDecl);\n                }\n\n                this.emitIndent();\n                this.recordSourceMappingEnd(classDecl);\n                this.emitParensAndCommentsInPlace(classDecl, false);\n                this.setContainer(temp);\n                this.thisClassNode = svClassNode;\n            }\n        }\n\n        public emitPrologue(reqInherits: bool) {\n            if (!this.prologueEmitted) {\n                if (reqInherits) {\n                    this.prologueEmitted = true;\n                    this.writeLineToOutput("var __extends = this.__extends || function (d, b) {");\n                    this.writeLineToOutput("    function __() { this.constructor = d; }");\n                    this.writeLineToOutput("    __.prototype = b.prototype;");\n                    this.writeLineToOutput("    d.prototype = new __();");\n                    this.writeLineToOutput("};");\n                }\n                if (this.checker.mustCaptureGlobalThis) {\n                    this.prologueEmitted = true;\n                    this.writeLineToOutput(this.captureThisStmtString);\n                }\n            }\n        }\n\n        public emitSuperReference() {\n            this.writeToOutput("_super.prototype");\n        }\n\n        public emitSuperCall(callEx: CallExpression): bool {\n            if (callEx.target.nodeType == NodeType.Dot) {\n                var dotNode = <BinaryExpression>callEx.target;\n                if (dotNode.operand1.nodeType == NodeType.Super) {\n                    this.emitJavascript(dotNode, TokenID.OpenParen, false);\n                    this.writeToOutput(".call(");\n                    this.emitThis();\n                    if (callEx.arguments && callEx.arguments.members.length > 0) {\n                        this.writeToOutput(", ");\n                        this.emitJavascriptList(callEx.arguments, ", ", TokenID.Comma, false, false, false);\n                    }\n                    this.writeToOutput(")");\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        public emitThis() {\n            if (this.thisFnc && !this.thisFnc.isMethod() && (!this.thisFnc.isConstructor)) {\n          ',
v27637=v27638+'      this.writeToOutput("_this");\n            }\n            else {\n                this.writeToOutput("this");\n            }\n        }\n\n        private static shouldCaptureThis(func: FuncDecl): bool {\n            // Super calls use \'this\' reference. If super call is in a lambda, \'this\' value needs to be captured in the parent.\n            return func.hasSelfReference() || func.hasSuperReferenceInFatArrowFunction();\n        }\n\n        private createFile(fileName: string, useUTF8: bool): ITextWriter {\n            try {\n                return this.emitOptions.ioHost.createFile(fileName, useUTF8);\n            } catch (ex) {\n                this.errorReporter.emitterError(null, ex.message);\n            }\n        }\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export interface ILineCol {\n        line: number;\n        col: number;\n    }\n\n    export class ErrorReporter {\n        public parser: Parser = null;\n        public checker: TypeChecker = null;\n        public lineCol = { line: 0, col: 0 };\n        public emitAsComments = true;\n        public hasErrors = false;\n        public pushToErrorSink = false;\n        public errorSink: string[] = [];\n\n        constructor (public outfile: ITextWriter) { }\n\n        public getCapturedErrors() { return this.errorSink; }\n        public freeCapturedErrors() { this.errorSink = []; }\n        public captureError(emsg: string) { this.errorSink[this.errorSink.length] = emsg; }\n\n        public setErrOut(outerr) {\n            this.outfile = outerr;\n            this.emitAsComments = false;\n        }\n\n        public emitPrefix() {\n            if (this.emitAsComments) {\n                this.outfile.Write("// ");\n            }\n            this.outfile.Write(this.checker.locationInfo.filename + "(" + this.lineCol.line + "," + this.lineCol.col + "): ");\n        }\n\n        public writePrefix(ast: AST): void {\n            if (ast) {\n                this.setError(ast);\n            }\n            else {\n                this.lineCol.line = 0;\n                this.lineCol.col = 0;\n            }\n            this.emitPrefix();\n        }\n\n        public writePrefixFromSym(symbol: Symbol): void {\n            if (symbol && this.checker.locationInfo.lineMap) {\n                getSourceLineColFromMap(this.lineCol, symbol.location,\n                                        this.checker.locationInfo.lineMap);\n            }\n            else {\n                this.lineCol.line = -1;\n                this.lineCol.col = -1;\n            }\n            this.emitPrefix();\n        }\n\n        public setError(ast: AST) {\n            if (ast) {\n                ast.flags |= ASTFlags.Error;\n                if (this.checker.locationInfo.lineMap) {\n                    getSourceLineColFromMap(this.lineCol, ast.minChar, this.checker.locationInfo.lineMap);\n                }\n            }\n        }\n\n        public reportError(ast: AST, message: string) {\n            if (this.pushToErrorSink) {\n                this.captureError(message);\n                return;\n            }\n\n            this.hasErrors = true;\n            if (ast && this.parser.errorRecovery && this.parser.errorCallback) {\n                var len = (ast.limChar - ast.minChar);\n                this.parser.errorCallback(ast.minChar, len, message, this.checker.locationInfo.unitIndex);\n            }\n            else {\n                this.writePrefix(ast);\n                this.outfile.WriteLine(message); // Right after the semi-colon\n            }\n        }\n\n        public reportErrorFromSym(symbol: Symbol, message: string) {\n            if (this.pushToErrorSink) {\n                this.captureError(message);\n                return;\n            }\n\n            this.hasErrors = true;\n            if (this.parser.errorRecovery && this.parser.errorCallback) {\n                this.parser.errorCallback(symbol.location, symbol.length, message, this.checker.locationInfo.unitIndex);\n            }\n            else {\n                this.writePrefixFromSym(symbol);\n                this.outfile.WriteLine(message);\n            }\n        }\n\n        public emitterError(ast: AST, message: string) {\n            this.reportError(ast, message);\n            // Emitter errors are not recoverable, stop immediately\n            throw Error("EmitError");\n        }\n\n        public duplicateIdentifier(ast: AST, name: string) {\n            this.reportError(',
v27636=v27637+'ast, "Duplicate identifier \'" + name + "\'");\n        }\n\n        public showRef(ast: AST, text: string, symbol: Symbol) {\n            var defLineCol = { line: -1, col: -1 };\n            // TODO: multiple def locations\n            this.parser.getSourceLineCol(defLineCol, symbol.location);\n            this.reportError(ast, "symbol " + text + " defined at (" + defLineCol.line + "," +\n                              defLineCol.col + ")");\n        }\n\n        public unresolvedSymbol(ast: AST, name: string) {\n            this.reportError(ast, "The name \'" + name + "\' does not exist in the current scope");\n        }\n\n        public symbolDoesNotReferToAValue(ast: AST, name: string): void {\n            this.reportError(ast, "The name \'" + name + "\' does not refer to a value");\n        }\n\n        public styleError(ast: AST, msg: string): void {\n            var bkThrow = this.pushToErrorSink;\n            this.pushToErrorSink = false;\n            this.reportError(ast, "STYLE: " + msg);\n            this.pushToErrorSink = bkThrow;\n        }\n\n        public simpleError(ast: AST, msg: string): void {\n            this.reportError(ast, msg);\n        }\n\n        public simpleErrorFromSym(sym: Symbol, msg: string): void {\n            this.reportErrorFromSym(sym, msg);\n        }\n\n        public invalidSuperReference(ast: AST) {\n            this.simpleError(ast, "Keyword \'super\' can only be used inside a class instance method");\n        }\n\n        public valueCannotBeModified(ast: AST) {\n            this.simpleError(ast, "The left-hand side of an assignment expression must be a variable, property or indexer");\n        }\n\n        public invalidCall(ast: CallExpression, nodeType: number, scope: SymbolScope): void {\n            var targetType = ast.target.type;\n            var typeName = targetType.getScopedTypeName(scope);\n            if (targetType.construct && (nodeType == NodeType.Call)) {\n                this.reportError(ast, "Value of type \'" + typeName + "\' is not callable.  Did you mean to include \'new\'?");\n            } else {\n                var catString = (nodeType == NodeType.Call) ? "callable" : "newable";\n\n                this.reportError(ast, "Value of type \'" + typeName + "\' is not " + catString);\n            }\n        }\n\n        public indexLHS(ast: BinaryExpression, scope: SymbolScope): void {\n            var targetType = ast.operand1.type.getScopedTypeName(scope);\n            var indexType = ast.operand2.type.getScopedTypeName(scope);\n            this.simpleError(ast, "Value of type \'" + targetType + "\' is not indexable by type \'" + indexType + "\'");\n        }\n\n        public incompatibleTypes(ast: AST, t1: Type, t2: Type, op: string, scope: SymbolScope, comparisonInfo?:TypeComparisonInfo) {\n            if (!t1) {\n                t1 = this.checker.anyType;\n            }\n            if (!t2) {\n                t2 = this.checker.anyType;\n            }\n\n            var reason = comparisonInfo ? comparisonInfo.message : "";\n            if (op) {\n                this.reportError(ast, "Operator \'" + op + "\' cannot be applied to types \'" + t1.getScopedTypeName(scope) +\n                                  "\' and \'" + t2.getScopedTypeName(scope) + "\'" + (reason ? ": " + reason : ""));\n            }\n            else {\n                this.reportError(ast, "Cannot convert \'" + t1.getScopedTypeName(scope) +\n                                  "\' to \'" + t2.getScopedTypeName(scope) + "\'" + (reason ? ": " + reason : ""));\n            }\n        }\n\n        public expectedClassOrInterface(ast: AST): void {\n            this.simpleError(ast, "Expected var, class, interface, or module");\n        }\n\n        public unaryOperatorTypeError(ast: AST, op: string, type: Type) {\n            this.reportError(ast, "Operator \'" + op + "\' cannot be applied to type \'" + type.getTypeName() + "\'");\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export function hasFlag(val: number, flag: number) {\n        return (val & flag) != 0;\n    }\n\n    export enum ErrorRecoverySet {\n        None = 0,\n        Comma = 1, // Comma\n        SColon = 1 << 1, // SColon\n        Asg = 1 << 2, // Asg\n        BinOp = 1 << 3, // Lsh, Rsh, Rs2, Le, Ge, INSTANCEOF, EQ, NE, Eqv, NEqv, LogAnd, LogOr, AsgMul, AsgDiv\n        // AsgMod, AsgAdd, AsgSub, AsgLsh, AsgRsh, AsgRs2, AsgAnd, AsgXor, AsgOr, QMark, Mult, Div, \n        // Pct, GT, LT, ',
v27635=v27636+"And, Xor, Or\n        RBrack = 1 << 4, // RBrack\n        RCurly = 1 << 5, // RCurly\n        RParen = 1 << 6, // RParen\n        Dot = 1 << 7, // Dot\n        Colon = 1 << 8, // Colon\n        PrimType = 1 << 9, // number, string, bool\n        AddOp = 1 << 10, // Add, Sub\n        LCurly = 1 << 11, // LCurly\n        PreOp = 1 << 12, // Tilde, Bang, Inc, Dec\n        RegExp = 1 << 13, // RegExp\n        LParen = 1 << 14, // LParen\n        LBrack = 1 << 15, // LBrack\n        Scope = 1 << 16, // Scope\n        In = 1 << 17, // IN\n        SCase = 1 << 18, // CASE, DEFAULT\n        Else = 1 << 19, // ELSE\n        Catch = 1 << 20, // CATCH, FINALLY\n        Var = 1 << 21, // \n        Stmt = 1 << 22, // BREAK, RETURN, THROW, DEBUGGER, FOR, SWITCH, DO, IF, TRY, WITH\n        While = 1 << 23, // WHILE\n        ID = 1 << 24, // ID\n        Prefix = 1 << 25, // VOID, DELETE, TYPEOF, AWAIT\n        Literal = 1 << 26, // IntCon, FltCon, StrCon\n        RLit = 1 << 27, // THIS, TRUE, FALSE, NULL\n        Func = 1 << 28, // FUNCTION\n        EOF = 1 << 29, // EOF\n\n        // REVIEW: Name this something clearer.\n        TypeScriptS = 1 << 30, // PROPERTY, PRIVATE, STATIC, INTERFACE, CLASS, MODULE, EXPORT, IMPORT\n        ExprStart = SColon | AddOp | LCurly | PreOp | RegExp | LParen | LBrack | ID | Prefix | RLit | Func | Literal,\n        StmtStart = ExprStart | SColon | Var | Stmt | While | TypeScriptS,\n        Postfix = Dot | LParen | LBrack,\n    }\n\n    export enum AllowedElements {\n        None = 0,\n        ModuleDeclarations = 1 << 2,\n        ClassDeclarations = 1 << 3,\n        InterfaceDeclarations = 1 << 4,\n        AmbientDeclarations = 1 << 10,\n        Properties = 1 << 11,\n\n        Global = ModuleDeclarations | ClassDeclarations | InterfaceDeclarations | AmbientDeclarations,\n        QuickParse = Global | Properties,\n    }\n\n    export enum Modifiers {\n        None = 0,\n        Private = 1,\n        Public = 1 << 1,\n        Readonly = 1 << 2,\n        Ambient = 1 << 3,\n        Exported = 1 << 4,\n        Getter = 1 << 5,\n        Setter = 1 << 6,\n        Static = 1 << 7,\n    }\n\n    export enum ASTFlags {\n        None = 0,\n        ExplicitSemicolon = 1, // statment terminated by an explicit semicolon\n        AutomaticSemicolon = 1 << 1, // statment terminated by an automatic semicolon\n        Writeable = 1 << 2,  // node is lhs that can be modified\n        Error = 1 << 3, // node has an error\n        DotLHSPartial = 1 << 4, // node is the lhs of an incomplete dot expr at cursor\n        DotLHS = 1 << 5, // node is the lhs of a dot expr\n        IsStatement = 1 << 6, // node is a statement\n        StrictMode = 1 << 7, // node is in the strict mode environment\n        PossibleOptionalParameter = 1 << 8,\n        ClassBaseConstructorCall = 1 << 9,\n        OptionalName = 1 << 10,\n        // REVIEW: This flag is to mark lambda nodes to note that the LParen of an expression has already been matched in the lambda header.\n        //         The flag is used to communicate this piece of information to the calling parseTerm, which intern will remove it.\n        //         Once we have a better way to associate information with nodes, this flag should not be used.\n        SkipNextRParen = 1 << 11, \n    }\n\n    export enum DeclFlags {\n        None = 0,\n        Exported = 1,\n        Private = 1 << 1,\n        Public = 1 << 2,\n        Ambient = 1 << 3,\n        Static = 1 << 4,\n        LocalStatic = 1 << 5,\n        GetAccessor = 1 << 6,\n        SetAccessor = 1 << 7,\n    }\n\n    export enum ModuleFlags {\n        None = 0,\n        Exported = 1,\n        Private = 1 << 1,\n        Public = 1 << 2,\n        Ambient = 1 << 3,\n        Static = 1 << 4,\n        LocalStatic = 1 << 5,\n        GetAccessor = 1 << 6,\n        SetAccessor = 1 << 7,\n        IsEnum = 1 << 8,\n        ShouldEmitModuleDecl = 1 << 9,\n        IsWholeFile = 1 << 10,\n        IsDynamic = 1 << 11,\n        MustCaptureThis = 1 << 12,\n    }\n\n    export enum SymbolFlags {\n        None = 0,\n        Exported = 1,\n        Private = 1 << 1,\n        Public = 1 << 2,\n        Ambient = 1 << 3,\n        Static = 1 << 4,\n        LocalStatic = 1 << 5,\n        GetAccessor = 1 << 6,\n        SetAccessor = 1 << 7,\n        Property = 1 << 8,\n        Readonly = 1 << 9,\n        ModuleMember = 1 << 10,\n        InterfaceMember = 1 << 11,\n        ClassMember = 1 << 12,\n        BuiltIn = 1 << 13,\n        TypeSetDuringScopeAssignment = 1 << 14,\n        Constant = 1 << 15,\n        Optional = 1 << 16,\n        RecursivelyReferenced = 1 << 17,\n        Bound = 1 << 18,\n        CompilerGenerated = 1 << 19,\n    }\n\n    export enum VarFlags {\n        None = 0,\n        Exported = 1,\n        Private = 1 << 1,\n        Public = 1 << 2,\n        Ambient = 1 << 3,\n        Static = 1 << 4,\n        LocalStatic = 1 << 5,\n        GetAccessor = 1 << 6,\n        SetAccessor = 1 << 7,\n        AutoInit = 1 << 8,\n        Property = 1 << 9,\n        Readonly = 1 << 10,\n        Class = 1 << 11,\n        ClassProperty = 1 << 12,\n        ClassBodyProperty = 1 << 13,",
v27634=v27635+'\n        ClassConstructorProperty = 1 << 14,\n        ClassSuperMustBeFirstCallInConstructor = 1 << 15,\n        Constant = 1 << 16,\n        MustCaptureThis = 1 << 17,\n    }\n\n    export enum FncFlags {\n        None = 0,\n        Exported = 1,\n        Private = 1 << 1,\n        Public = 1 << 2,\n        Ambient = 1 << 3,\n        Static = 1 << 4,\n        LocalStatic = 1 << 5,\n        GetAccessor = 1 << 6,\n        SetAccessor = 1 << 7,\n        Definition = 1 << 8,\n        Signature = 1 << 9,\n        Method = 1 << 10,\n        HasReturnExpression = 1 << 11,\n        CallMember = 1 << 12,\n        ConstructMember = 1 << 13,\n        HasSelfReference = 1 << 14,\n        IsFatArrowFunction = 1 << 15,\n        IndexerMember = 1 << 16,\n        IsFunctionExpression = 1 << 17,\n        ClassMethod = 1 << 18,\n        ClassPropertyMethodExported = 1 << 19,\n        HasSuperReferenceInFatArrowFunction = 1 << 20,\n        IsPropertyBound = 1 << 21,\n    }\n\n    export enum SignatureFlags {\n        None = 0,\n        IsIndexer = 1,\n        IsStringIndexer = 1 << 1,\n        IsNumberIndexer = 1 << 2,\n    }\n\n    export function ToDeclFlags(fncFlags: FncFlags) : DeclFlags;\n    export function ToDeclFlags(varFlags: VarFlags) : DeclFlags;\n    export function ToDeclFlags(symFlags: SymbolFlags): DeclFlags;\n    export function ToDeclFlags(moduleFlags: ModuleFlags): DeclFlags;\n    export function ToDeclFlags(fncOrVarOrSymbolOrModuleFlags: any) {\n        return <DeclFlags>fncOrVarOrSymbolOrModuleFlags;\n    }\n\n    export enum TypeFlags {\n        None = 0,\n        HasImplementation = 1,\n        HasSelfReference = 1 << 1,\n        MergeResult = 1 << 2,\n        IsEnum = 1 << 3,\n        BuildingName = 1 << 4,\n        HasBaseType = 1 << 5,\n        HasBaseTypeOfObject = 1 << 6,\n        IsClass = 1 << 7,\n    }\n\n    export enum TypeRelationshipFlags {\n        SuccessfulComparison = 0,\n        SourceIsNullTargetIsVoidOrUndefined = 1,\n        RequiredPropertyIsMissing = 1 << 1,\n        IncompatibleSignatures = 1 << 2,\n        SourceSignatureHasTooManyParameters = 3,\n        IncompatibleReturnTypes = 1 << 4,\n        IncompatiblePropertyTypes = 1 << 5,\n        IncompatibleParameterTypes = 1 << 6,\n    }\n\n    export enum CodeGenTarget {\n        ES3 = 0,\n        ES5 = 1,\n    }\n\n    export enum ModuleGenTarget {\n        Synchronous = 0,\n        Asynchronous = 1,\n        Local = 1 << 1,\n    }\n\n    // Compiler defaults to generating ES5-compliant code for\n    //  - getters and setters\n    export var codeGenTarget: CodeGenTarget = CodeGenTarget.ES3;\n\n    export var moduleGenTarget: ModuleGenTarget = ModuleGenTarget.Synchronous;\n\n    export var optimizeModuleCodeGen = true;\n\n    export function flagsToString(e, flags: number): string {\n        var builder = "";\n        for (var i = 1; i < (1 << 31) ; i = i << 1) {\n            if ((flags & i) != 0) {\n                for (var k in e) {\n                    if (e[k] == i) {\n                        if (builder.length > 0) {\n                            builder += "|";\n                        }\n                        builder += k;\n                        break;\n                    }\n                }\n            }\n        }\n        return builder;\n    }\n\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export class BlockIntrinsics {\n        public prototype = undefined;\n        public toString = undefined;\n        public toLocaleString = undefined;\n        public valueOf = undefined;\n        public hasOwnProperty = undefined;\n        public propertyIsEnumerable = undefined;\n        public isPrototypeOf = undefined;\n\n        constructor () {\n            // initialize the \'constructor\' field\n            this["constructor"] = undefined;\n        }\n    }\n\n    export interface IHashTable {\n        getAllKeys(): string[];\n        add(key: string, data): bool;\n        addOrUpdate(key: string, data): bool;\n        map(fn: (k: string, v, c) => void , context): void;\n        every(fn: (k: string, v, c) => bool, context): bool;\n        some(fn: (k: string, v, c) => bool, context): bool;\n        count(): number;\n        lookup(key: string): any;\n    }\n\n    export class StringHashTable implements IHashTable {\n        public itemCount = 0;\n        public table = <any>(<any> new BlockIntrinsics());\n\n        public getAllKeys(): string[]{\n            var result: string[] = [];\n            for (var k in this.table) {\n ',
v27633=v27634+"               if (this.table[k] != undefined) {\n                    result[result.length] = k;\n                }\n            }\n            return result;\n        }\n\n        public add(key: string, data): bool {\n            if (this.table[key] != undefined) {\n                return false;\n            }\n            this.table[key] = data;\n            this.itemCount++;\n            return true;\n        }\n\n        public addOrUpdate(key: string, data): bool {\n            if (this.table[key] != undefined) {\n                this.table[key] = data;\n                return false;\n            }\n            this.table[key] = data;\n            this.itemCount++;\n            return true;\n        }\n\n        public map(fn: (k: string, v, c) => void , context) {\n            for (var k in this.table) {\n                var data = this.table[k];\n                if (data != undefined) {\n                    fn(k, this.table[k], context);\n                }\n            }\n        }\n\n        public every(fn: (k: string, v, c) => bool, context) {\n            for (var k in this.table) {\n                var data = this.table[k];\n                if (data != undefined) {\n                    if (!fn(k, this.table[k], context)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n\n        public some(fn: (k: string, v, c) => bool, context) {\n            for (var k in this.table) {\n                var data = this.table[k];\n                if (data != undefined) {\n                    if (fn(k, this.table[k], context)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        public count(): number { return this.itemCount; }\n\n        public lookup(key: string) {\n            var data = this.table[key];\n            if (data != undefined) {\n                return data;\n            }\n            else {\n                return (null);\n            }\n        }\n    }\n\n    // The resident table is expected to reference the same table object, whereas the \n    // transientTable may reference different objects over time\n    // REVIEW:  WARNING:  For performance reasons, neither the primary nor secondary table may be null\n    export class DualStringHashTable implements IHashTable {\n\n        public insertPrimary = true;\n\n        constructor (public primaryTable: IHashTable,\n                                        public secondaryTable: IHashTable) { }\n\n        public getAllKeys(): string[]{\n            return this.primaryTable.getAllKeys().concat(this.secondaryTable.getAllKeys());\n        }\n\n        public add(key: string, data): bool {\n            if (this.insertPrimary) {\n                return this.primaryTable.add(key, data);\n            }\n            else {\n                return this.secondaryTable.add(key, data);\n            }\n        }\n\n        public addOrUpdate(key: string, data): bool {\n            if (this.insertPrimary) {\n                return this.primaryTable.addOrUpdate(key, data);\n            }\n            else {\n                return this.secondaryTable.addOrUpdate(key, data);\n            }\n        }\n\n        public map(fn: (k: string, v, c) => void , context) {\n            this.primaryTable.map(fn, context);\n            this.secondaryTable.map(fn, context);\n        }\n\n        public every(fn: (k: string, v, c) => bool, context) {\n            return this.primaryTable.every(fn, context) && this.secondaryTable.every(fn, context);\n        }\n\n        public some(fn: (k: string, v, c) => bool, context) {\n            return this.primaryTable.some(fn, context) || this.secondaryTable.some(fn, context);\n        }\n\n        public count() {\n            return this.primaryTable.count() + this.secondaryTable.count();\n        }\n\n        public lookup(key: string) {\n            var data = this.primaryTable.lookup(key);\n            if (data != undefined) {\n                return data;\n            }\n            else {\n                return this.secondaryTable.lookup(key);\n            }\n        }\n    }\n\n    export function numberHashFn(key: number): number {\n        var c2 = 0x27d4eb2d; // a prime or an odd constant\n        key = (key ^ 61) ^ (key >>> 16);\n        key = key + (key << 3);\n        key = key ^ (key >>> 4);\n        key = key * c2;\n        key = key ^ (key >>> 15);\n        return key;\n    }\n\n    export function combineHashes(key1: number, key2: number) {\n        return key2 ^ ((key1 >> 5) + key1);\n    }\n\n    export class HashEntry {\n        public next: HashEntry;\n\n        constructor (public key, public data) { }\n    }\n\n    export class HashTable {\n        public itemCount: number = 0;\n        public table = new HashEntry[];\n\n        constructor (public size: number, public hashFn: (key) =>number,\n                    public equalsFn: (key1, key2) =>bool) {\n            for (var i: number = 0; i < this.size; i++) {\n                this.table[i] = null;\n            }\n        }\n\n        publi",
v27632=v27633+'c add(key, data): bool {\n            var current: HashEntry;\n            var entry: HashEntry = new HashEntry(key, data);\n            var val: number = this.hashFn(key);\n            val = val % this.size;\n\n            for (current = this.table[val]; current != null ; current = current.next) {\n                if (this.equalsFn(key, current.key)) {\n                    return false;\n                }\n            }\n            entry.next = this.table[val];\n            this.table[val] = entry;\n            this.itemCount++;\n            return true;\n        }\n\n        public remove(key) {\n            var current: HashEntry;\n            var val: number = this.hashFn(key);\n            val = val % this.size;\n            var result = null;\n            var prevEntry: HashEntry = null;\n\n            for (current = this.table[val]; current != null ; current = current.next) {\n                if (this.equalsFn(key, current.key)) {\n                    result = current.data;\n                    this.itemCount--;\n                    if (prevEntry) {\n                        prevEntry.next = current.next;\n                    }\n                    else {\n                        this.table[val] = current.next;\n                    }\n                    break;\n                }\n                prevEntry = current;\n            }\n            return result;\n        }\n\n        public count(): number { return this.itemCount; }\n\n        public lookup(key) {\n            var current: HashEntry;\n            var val: number = this.hashFn(key);\n            val = val % this.size;\n            for (current = this.table[val]; current != null ; current = current.next) {\n                if (this.equalsFn(key, current.key)) {\n                    return (current.data);\n                }\n            }\n            return (null);\n        }\n    }\n\n    // Simple Hash table with list of keys and values matching each other at the given index\n    export class SimpleHashTable {\n        private keys = [];\n        private values = [];\n\n        public lookup(key, findValue?: bool) {\n            var searchArray = this.keys;\n            if (findValue) {\n                searchArray = this.values;\n            }\n\n            for (var i = 0; i < searchArray.length; i++) {\n                if (searchArray[i] == key) {\n                    return {\n                        key: this.keys[i],\n                        data: this.values[i],\n                    };\n                }\n            }\n            return null;\n        }\n\n        public add(key, data): bool {\n            var lookupData = this.lookup(key);\n            if (lookupData) {\n                return false;\n            }\n\n            this.keys[this.keys.length] = key;\n            this.values[this.values.length] = data;\n\n            return true;\n        }\n    }\n\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export class IncrementalParser {\n        \n        private astLogger: AstLogger;\n\n        constructor (private logger: TypeScript.ILogger) {\n            this.astLogger = new AstLogger(this.logger);\n        }\n\n        //\n        // Return "null" if "editRange" cannot be safely determined to be inside a single scope.\n        //\n        public getEnclosingScopeContextIfSingleScopeEdit(previousScript: Script, scriptId: string, newSourceText: ISourceText, editRange: ScriptEditRange): EnclosingScopeContext {\n            this.logger.log("checkEditsInsideSingleScope(\\"" + scriptId + "\\")");\n\n            if (editRange === null) {\n                throw new Error("editRange should be valid");\n            }\n\n            if (editRange.isUnknown()) {\n                this.logger.log("  Bailing out because edit range is unknown");\n                return null;\n            }\n\n            var scope1 = TypeScript.findEnclosingScopeAt(this.logger, previousScript, newSourceText, editRange.minChar, false/*isMemberCompletion*/);\n            var scope2 = TypeScript.findEnclosingScopeAt(this.logger, previousScript, newSourceText, editRange.limChar, false/*isMemberCompletion*/);\n            if (scope1 == null || scope2 == null) {\n                this.logger.log("  Bailing out because containing scopes cannot be determined");\n                return null;\n            }\n\n            // We only support changes within a single containing scope\n            if (scope1.scopeStartAST !== scope2.scopeStartAST) {\n      ',
v27631=v27632+'          this.logger.log("  Bailing out because edit overlaps 2 disctint scopes");\n                return null;\n            }\n\n            var newScopeLength = scope1.scopeStartAST.limChar - scope1.scopeStartAST.minChar + editRange.delta;\n            if (newScopeLength <= 0) {\n                this.logger.log("  Bailing out because scope has been entirely removed from new source text");\n                return null;\n            }\n\n            return scope1;\n        }\n\n        public attemptIncrementalUpdateUnit(previousScript: Script, scriptId: string, newSourceText: ISourceText, editRange: ScriptEditRange): UpdateUnitResult {\n            this.logger.log("attemptIncrementalUpdateUnit(\\"" + scriptId + "\\")");\n\n            if (editRange === null) {\n                throw new Error("editRange should be valid");\n            }\n\n            var scope1 = this.getEnclosingScopeContextIfSingleScopeEdit(previousScript, scriptId, newSourceText, editRange);\n            if (scope1 === null) {\n                return null;\n            }\n\n            var newScopeLength = scope1.scopeStartAST.limChar - scope1.scopeStartAST.minChar + editRange.delta;\n\n            // Heuristic: if the range to reparse is too big, bail out. \n            // This is because a full parse will be faster than an incremental parse followed by all the necessary fix-ups \n            if (newScopeLength >= newSourceText.getLength() / 2) {\n                this.logger.log("  Bailing out because range of scope to reparse (" + newScopeLength + " characters) is greater than half the size of the source text");\n                return null;\n            }\n\n            // Capture parsing errors so that they are part of "updateResult"\n            var parseErrors: TypeScript.ErrorEntry[] = [];\n            var errorCapture = function(minChar: number, charLen: number, message: string, unitIndex: number): void {\n                parseErrors.push(new TypeScript.ErrorEntry(unitIndex, minChar, minChar + charLen, message));\n            };\n\n            var quickParseResult = TypeScript.quickParse(this.logger, scope1.scopeStartAST, newSourceText, scope1.scopeStartAST.minChar, scope1.scopeStartAST.minChar + newScopeLength, errorCapture);\n            if (quickParseResult.endLexState != TypeScript.LexState.Start) {\n                this.logger.log("  Bailing out because scope contains unterminated comment");\n                return null;\n            }\n\n            var scriptFragment = quickParseResult.Script;\n            if (scriptFragment.vars.members.length !== 0) {\n                this.logger.log("  Bailing out because new source text defines variables");\n                return null;\n            }\n\n            //if (scriptFragment.scopes.members.length !== 1) {\n            //    logger.log("  Bailing out because new source text defines more than one scope (or none)");\n            //    return null;\n            //}\n\n            // This detects adding close curlies, since they have the side effect of having the parser \n            // parse more members in the scope range.\n            if (scriptFragment.bod.members.length !== 1) {\n                this.logger.log("  Bailing out because new source text defines more than one scope (or none)");\n                return null;\n            }\n\n            var oldScope = scope1.scopeStartAST;\n            var newScope = scriptFragment.bod.members[0];\n\n            if (oldScope.nodeType != newScope.nodeType) {\n                this.logger.log("  Bailing out because new source text does not define the same scope type as the existing scope");\n                return null;\n            }\n\n            if (!(<any>oldScope).leftCurlyCount || !(<any>oldScope).rightCurlyCount) {\n                this.logger.log("  Bailing out because sopce doesn\'t have left/right curly count");\n                return null;\n            }\n\n            if ((<any>oldScope).leftCurlyCount !== (<any>newScope).leftCurlyCount) {\n                this.logger.log("  Bailing out because new source text contains more (or fewer) left curly braces");\n                return null;\n            }\n\n            if ((<any>oldScope).rightCurlyCount !== (<any>newScope).rightCurlyCount) {\n                this.logger.log("  Bailing out because new source text contains more (or fewer) right curly braces");\n                return null;\n            }\n\n            if (newScope.minChar !== 0) {\n                this.logger.log("  Bailing out because new function declaration does not start at position 0");\n                return null;\n            }\n\n            if (newScope.limChar !== newScopeLength) {\n                this.logger.log("  Bailing out because new function declaration does not end at the new end position");\n                return null;\n            }\n\n            return TypeScript.UpdateUnitResult.singleScopeEdits(previousScript, scriptFragment, oldScope, newScope, editRange, parseErrors);\n        }\n\n        public mergeTrees(updateResult: UpdateUnitResult): void {\n            TypeScript.timeF',
v27630=v27631+'unction(this.logger, "mergeTrees()", () => {\n                var editRange = new ScriptEditRange(updateResult.scope1.minChar, updateResult.scope1.limChar, updateResult.editRange.delta);\n                // Update positions in current ast\n                this.applyDeltaPosition(updateResult.script1, editRange.limChar, editRange.delta);\n                // Update positions in new (partial) ast\n                this.applyDeltaPosition(updateResult.script2, 0, editRange.minChar);\n                // Merge linemaps\n                this.mergeLocationInfo(updateResult.script1, updateResult.script2, editRange);\n                //  Replace old AST for scope with new one\n                this.replaceAST(updateResult.script1, updateResult.scope1, updateResult.scope2);\n            });\n        }\n\n        private replaceAST(script: TypeScript.AST, oldAst: TypeScript.AST, newAst: TypeScript.AST) {\n            var pre = (cur: TypeScript.AST, parent: TypeScript.AST, walker: TypeScript.IAstWalker) => {\n                if (cur === oldAst) {\n                    // Transfer comments ownership to new AST. We need this because when "quick parsing" the\n                    // new AST, we don\'t take into account the text before and after the "minChar/limChar" pair\n                    // of the scope, which don\'t include pre/post-comments.\n                    newAst.preComments = cur.preComments;\n                    newAst.postComments = cur.postComments;\n\n                    this.logger.log("replaced old AST node with new one in script AST");\n                    walker.options.stopWalk();\n                    return newAst;\n                }\n\n                // Avoid visiting sub-trees outside of the edit range\n                if (TypeScript.isValidAstNode(cur)) {\n                    if (cur.limChar < oldAst.minChar || cur.minChar > oldAst.limChar) {\n                        walker.options.goChildren = false;\n                    }\n                }\n                return cur;\n            }\n\n            TypeScript.getAstWalkerFactory().walk(script, pre);\n        }\n\n        private mergeLocationInfo(script: TypeScript.Script, partial: TypeScript.Script, editRange: ScriptEditRange) {\n            // Don\'t merger these fields, as the original script has the right values\n            //script.locationInfo.unitIndex = partial.locationInfo.unitIndex;\n            //script.locationInfo.filename = partial.locationInfo.filename;\n\n            var lineMap1 = script.locationInfo.lineMap;\n            var lineMap2 = partial.locationInfo.lineMap;\n\n            if (this.logger.information()) {\n                this.logger.log("lineMap1 (before):");\n                this.astLogger.logLinemap(lineMap1);\n                this.logger.log("lineMap2 (quick parse):");\n                this.astLogger.logLinemap(lineMap2);\n                this.logger.log("EditRange=" + editRange);\n            }\n\n            // Skip entries < minChar\n            var i1 = 2; // lineMap[0] is always undefined, lineMap[1] is always 0.\n            var i2 = 2; // lineMap[0] is always undefined, lineMap[1] is always 0.\n            var len1 = lineMap1.length;\n            var len2 = lineMap2.length;\n            while (i1 < len1) {\n                if (lineMap1[i1] <= editRange.minChar) {\n                    // Nothing to do for this entry, since it\'s before the range of the change\n                    i1++;\n                } else if (lineMap1[i1] >= editRange.limChar) {\n                    // Apply delta to this entry, since it\'s outside the range of the change\n                    lineMap1[i1] += editRange.delta;\n                    i1++;\n                }\n                else {\n                    if (i2 < len2) {\n                        // Add a new entry to lineMap1 corresponding to lineMap2 in new range\n                        lineMap1.splice(i1, 0, lineMap2[i2] + editRange.minChar);\n                        i1++;\n                        len1++;\n                        i2++;\n                    }\n                    else { /* i2 >= len 2 */\n                        // Remove this entry, since there is no corresponding entry in the new map\n                        lineMap1.splice(i1, 1);\n                        len1--;\n                    }\n                }\n            }\n            // Merge the remaining entries in lineMap2 while maintaing the constraint that a lineMap is sorted\n            if (i2 < len2) {\n                // i1 >= len1 && i2 < len2 \n                if (lineMap1[len1 - 1] >= (lineMap2[i2] + editRange.minChar)) {\n                    // lineMap2 needs to be merged within lineMap1\n                    i1 = 2;\n                    while (i1 < len1 && i2 < len2) {\n                        if (lineMap1[i1] < (lineMap2[i2] + editRange.minChar)) {\n                            i1++;\n                        }\n                        else {\n                            lineMap1.splice(i1, 0, lineMap2[i2] + editRange.minChar);\n                            i1++;\n                            len1++;\n  ',
v27629=v27630+'                          i2++;\n                        }\n                    }\n                }\n\n                // Append all the remaining entries in lineMap2 to the end of lineMap1\n                for (; i2 < len2; i2++) {\n                    lineMap1.push(lineMap2[i2] + editRange.minChar);\n                }\n            }\n\n            if (this.logger.information()) {\n                this.logger.log("lineMap1 (after merge):");\n                this.astLogger.logLinemap(lineMap1);\n            }\n        }\n\n        private applyDeltaPosition(ast: TypeScript.AST, start: number, delta: number) {\n            var applyDelta = (ast: TypeScript.AST) => {\n                if (ast.minChar !== -1 && ast.minChar >= start) {\n                    ast.minChar += delta;\n                }\n                if (ast.limChar !== -1 && ast.limChar >= start) {\n                    ast.limChar += delta;\n                }\n            }\n\n            var applyDeltaToComments = (comments: TypeScript.Comment[]) => {\n                if (comments && comments.length > 0) {\n                    for (var i = 0; i < comments.length; i++) {\n                        applyDelta(comments[i]);\n                    }\n                }\n            }\n\n            var pre = function(cur: TypeScript.AST, parent: TypeScript.AST, walker: TypeScript.IAstWalker) {\n                // *Before* applying delta to this, check if we need to go to children\n                if (cur.limChar !== -1 && cur.limChar < start) {\n                    walker.options.goChildren = false; // Done with applying Delta for this sub-tree\n                }\n\n                // Apply delta to this node\n                applyDelta(cur);\n                applyDeltaToComments(cur.preComments);\n                applyDeltaToComments(cur.postComments);\n\n                return cur;\n            }\n\n            TypeScript.getAstWalkerFactory().walk(ast, pre);\n        }\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\ninterface IResolvedFile {\n    content: string;\n    path: string;\n}\n\ninterface IFileWatcher {\n    close(): void;\n}\n\ninterface IIO {\n    readFile(path: string): string;\n    writeFile(path: string, contents: string): void;\n    createFile(path: string, useUTF8?: bool): ITextWriter;\n    deleteFile(path: string): void;\n    dir(path: string, re?: RegExp, options?: { recursive?: bool; }): string[];\n    fileExists(path: string): bool;\n    directoryExists(path: string): bool;\n    createDirectory(path: string): void;\n    resolvePath(path: string): string;\n    dirName(path: string): string;\n    findFile(rootPath: string, partialFilePath: string): IResolvedFile;\n    print(str: string): void;\n    printLine(str: string): void;\n    arguments: string[];\n    stderr: ITextWriter;\n    stdout: ITextWriter;\n    watchFile(filename: string, callback: (string) => void ): IFileWatcher;\n    run(source: string, filename: string): void;\n    getExecutingFilePath(): string;\n    quit(exitCode?: number);\n}\n\nmodule IOUtils {\n    // Creates the directory including its parent if not already present\n    function createDirectoryStructure(ioHost: IIO, dirName: string) {\n        if (ioHost.directoryExists(dirName)) {\n            return;\n        }\n\n        var parentDirectory = ioHost.dirName(dirName);\n        if (parentDirectory != "") {\n            createDirectoryStructure(ioHost, parentDirectory);\n        }\n        ioHost.createDirectory(dirName);\n    }\n\n    // Creates a file including its directory structure if not already present\n    export function createFileAndFolderStructure(ioHost: IIO, fileName: string, useUTF8?: bool) {\n        var path = ioHost.resolvePath(fileName);\n        var dirName = ioHost.dirName(path);\n        createDirectoryStructure(ioHost, dirName);\n        return ioHost.createFile(path, useUTF8);\n    }\n\n    export function throwIOError(message: string, error: Error) {\n        var errorMessage = message;\n        if (error && error.message) {\n            errorMessage += (" " + error.message);\n        }\n        throw new Error(errorMessage);\n    }\n}\n\n// Declare dependencies needed for all supported hosts\ndeclare class Enumerator {\n    public atEnd(): bool;\n    public moveNext();\n    public item(): any;\n    constructor (o: any);\n}\ndeclare function setTimeout(callback: () =>void , ms?: number);\ndeclare var require: any;\ndeclare module process {\n    export var argv: string[];\n    export var platform: string;\n    export function on(event: st',
v27628=v27629+'ring, handler: (any) => void ): void;\n    export module stdout {\n        export function write(str: string);\n    }\n    export module stderr {\n        export function write(str: string);\n    }\n    export module mainModule {\n        export var filename: string;\n    }\n    export function exit(exitCode?: number);\n}\n\nvar IO = (function() {\n\n    // Create an IO object for use inside WindowsScriptHost hosts\n    // Depends on WSCript and FileSystemObject\n    function getWindowsScriptHostIO(): IIO {\n        var fso = new ActiveXObject("Scripting.FileSystemObject");\n        var streamObjectPool = [];\n\n        function getStreamObject(): any { \n            if (streamObjectPool.length > 0) {\n                return streamObjectPool.pop();\n            }  else {\n                return new ActiveXObject("ADODB.Stream");\n            }\n        }\n\n        function releaseStreamObject(obj: any) { \n            streamObjectPool.push(obj);\n        }\n\n        var args = [];\n        for (var i = 0; i < WScript.Arguments.length; i++) {\n            args[i] = WScript.Arguments.Item(i);\n        }\n\n        return {\n            readFile: function(path) {\n                try {\n                    var streamObj = getStreamObject();\n                    streamObj.Open();\n                    streamObj.Type = 2; // Text data\n                    streamObj.Charset = \'x-ansi\'; // Assume we are reading ansi text\n                    streamObj.LoadFromFile(path);\n                    var bomChar = streamObj.ReadText(2); // Read the BOM char\n                    streamObj.Position = 0; // Position has to be at 0 before changing the encoding\n                    if ((bomChar.charCodeAt(0) == 0xFE && bomChar.charCodeAt(1) == 0xFF)\n                        || (bomChar.charCodeAt(0) == 0xFF && bomChar.charCodeAt(1) == 0xFE)) {\n                        streamObj.Charset = \'unicode\';\n                    } else if (bomChar.charCodeAt(0) == 0xEF && bomChar.charCodeAt(1) == 0xBB) {\n                        streamObj.Charset = \'utf-8\'; \n                    }\n\n                    // Read the whole file\n                    var str = streamObj.ReadText(-1 /* read from the current position to EOS */);\n                    streamObj.Close();\n                    releaseStreamObject(streamObj);\n                    return <string>str;\n                }\n                catch (err) {\n                    IOUtils.throwIOError("Error reading file \\"" + path + "\\".", err);\n                }\n            },\n\n            writeFile: function(path, contents) {\n                var file = this.createFile(path);\n                file.Write(contents);\n                file.Close();\n            },\n\n            fileExists: function(path: string): bool {\n                return fso.FileExists(path);\n            },\n\n            resolvePath: function(path: string): string {\n                return fso.GetAbsolutePathName(path);\n            },\n\n            dirName: function(path: string): string {\n                return fso.GetParentFolderName(path);\n            },\n\n            findFile: function(rootPath: string, partialFilePath: string): IResolvedFile {\n                var path = fso.GetAbsolutePathName(rootPath) + "/" + partialFilePath;\n\n                while (true) {\n                    if (fso.FileExists(path)) {\n                        try {\n                            var content = this.readFile(path);\n                            return { content: content, path: path };\n                        }\n                        catch (err) {\n                            //Tools.CompilerDiagnostics.debugPrint("Could not find " + path + ", trying parent");\n                        }\n                    }\n                    else {\n                        rootPath = fso.GetParentFolderName(fso.GetAbsolutePathName(rootPath));\n\n                        if (rootPath == "") {\n                            return null;\n                        }\n                        else {\n                            path = fso.BuildPath(rootPath, partialFilePath);\n                        }\n                    }\n                }\n            },\n\n            deleteFile: function(path: string): void {\n                try {\n                    if (fso.FileExists(path)) {\n                        fso.DeleteFile(path, true); // true: delete read-only files\n                    }\n                } catch (e) {\n                    IOUtils.throwIOError("Couldn\'t delete file \'" + path + "\'.", e);\n                }\n            },\n\n            createFile: function (path, useUTF8?) {\n                try {\n                    var streamObj = getStreamObject();\n                    streamObj.Charset = useUTF8 ? \'utf-8\' : \'x-ansi\';\n                    streamObj.Open();\n                    return {\n                        Write: function (str) { streamObj.WriteText(str, 0); },\n                        WriteLine: function (str) { streamObj.WriteText(str, 1); },\n                        Close: function() {\n                            try {\n            ',
v27627=v27628+'                    streamObj.SaveToFile(path, 2);\n                            } catch (saveError) {\n                                IOUtils.throwIOError("Couldn\'t write to file \'" + path + "\'.", saveError);\n                            }\n                            finally {\n                                if (streamObj.State != 0 /*adStateClosed*/) {\n                                    streamObj.Close();\n                                }\n                                releaseStreamObject(streamObj);\n                            }\n                        }\n                    };\n                } catch (creationError) {\n                    IOUtils.throwIOError("Couldn\'t write to file \'" + path + "\'.", creationError);\n                }\n            },\n\n            directoryExists: function(path) {\n                return <bool>fso.FolderExists(path);\n            },\n\n            createDirectory: function(path) {\n                try {\n                    if (!this.directoryExists(path)) {\n                        fso.CreateFolder(path);\n                    }\n                } catch (e) {\n                    IOUtils.throwIOError("Couldn\'t create directory \'" + path + "\'.", e);\n                }\n            },\n\n            dir: function(path, spec?, options?) {\n                options = options || <{ recursive?: bool; }>{};\n                function filesInFolder(folder, root): string[]{\n                    var paths = [];\n                    var fc: Enumerator;\n\n                    if (options.recursive) {\n                        fc = new Enumerator(folder.subfolders);\n\n                        for (; !fc.atEnd() ; fc.moveNext()) {\n                            paths = paths.concat(filesInFolder(fc.item(), root + "/" + fc.item().Name));\n                        }\n                    }\n\n                    fc = new Enumerator(folder.files);\n\n                    for (; !fc.atEnd() ; fc.moveNext()) {\n                        if (!spec || fc.item().Name.match(spec)) {\n                            paths.push(root + "/" + fc.item().Name);\n                        }\n                    }\n\n                    return paths;\n                }\n\n                var folder = fso.GetFolder(path);\n                var paths = [];\n\n                return filesInFolder(folder, path);\n            },\n\n            print: function(str) {\n                WScript.StdOut.Write(str);\n            },\n\n            printLine: function(str) {\n                WScript.Echo(str);\n            },\n\n            arguments: <string[]>args,\n            stderr: WScript.StdErr,\n            stdout: WScript.StdOut,\n            watchFile: null,\n            run: function(source, filename) {\n                try {\n                    eval(source);\n                } catch (e) {\n                    IOUtils.throwIOError("Error while executing file \'" + filename + "\'.", e);\n                }\n            },\n            getExecutingFilePath: function () {\n                return WScript.ScriptFullName;\n            },\n            quit: function (exitCode? : number = 0) {\n                try {\n                    WScript.Quit(exitCode);\n                } catch (e) {\n                }\n            }\n        }\n\n    };\n\n    // Create an IO object for use inside Node.js hosts\n    // Depends on \'fs\' and \'path\' modules\n    function getNodeIO(): IIO {\n\n        var _fs = require(\'fs\');\n        var _path = require(\'path\');\n        var _module = require(\'module\');\n\n        return {\n            readFile: function(file) {\n                try {\n                    var buffer = _fs.readFileSync(file);\n                    switch (buffer[0]) {\n                        case 0xFE:\n                            if (buffer[1] == 0xFF) {\n                                // utf16-be. Reading the buffer as big endian is not supported, so convert it to \n                                // Little Endian first\n                                var i = 0;\n                                while ((i + 1) < buffer.length) {\n                                    var temp = buffer[i]\n                                    buffer[i] = buffer[i + 1];\n                                    buffer[i + 1] = temp;\n                                    i += 2;\n                                }\n                                return buffer.toString("ucs2", 2);\n                            }\n                            break;\n                        case 0xFF:\n                            if (buffer[1] == 0xFE) {\n                                // utf16-le \n                                return buffer.toString("ucs2", 2);\n                            }\n                            break;\n                        case 0xEF:\n                            if (buffer[1] == 0xBB) {\n                                // utf-8\n                                return buffer.toString("utf8", 3);\n                            }\n                    }\n                    // Default behaviour\n                    return buffer.toString();\n                } catch ',
v27626=v27627+'(e) {\n                    IOUtils.throwIOError("Error reading file \\"" + file + "\\".", e);\n                }\n            },\n            writeFile: <(path: string, contents: string) => void >_fs.writeFileSync,\n            deleteFile: function(path) {\n                try {\n                    _fs.unlinkSync(path);\n                } catch (e) {\n                    IOUtils.throwIOError("Couldn\'t delete file \'" + path + "\'.", e);\n                }\n            },\n            fileExists: function(path): bool {\n                return _fs.existsSync(path);\n            },\n            createFile: function(path, useUTF8?) {\n                function mkdirRecursiveSync(path) {\n                    var stats = _fs.statSync(path);\n                    if (stats.isFile()) {\n                        IOUtils.throwIOError("\\"" + path + "\\" exists but isn\'t a directory.", null);\n                    } else if (stats.isDirectory()) {\n                        return;\n                    } else {\n                        mkdirRecursiveSync(_path.dirname(path));\n                        _fs.mkdirSync(path, 0775);\n                    }\n                }\n\n                mkdirRecursiveSync(_path.dirname(path));\n\n                try {\n                    var fd = _fs.openSync(path, \'w\');\n                } catch (e) {\n                    IOUtils.throwIOError("Couldn\'t write to file \'" + path + "\'.", e);\n                }\n                return {\n                    Write: function(str) { _fs.writeSync(fd, str); },\n                    WriteLine: function(str) { _fs.writeSync(fd, str + \'\\r\\n\'); },\n                    Close: function() { _fs.closeSync(fd); fd = null; }\n                };\n            },\n            dir: function dir(path, spec?, options?) {\n                options = options || <{ recursive?: bool; }>{};\n\n                function filesInFolder(folder: string): string[]{\n                    var paths = [];\n\n                    var files = _fs.readdirSync(folder);\n                    for (var i = 0; i < files.length; i++) {\n                        var stat = _fs.statSync(folder + "/" + files[i]);\n                        if (options.recursive && stat.isDirectory()) {\n                            paths = paths.concat(filesInFolder(folder + "/" + files[i]));\n                        } else if (stat.isFile() && (!spec || files[i].match(spec))) {\n                            paths.push(folder + "/" + files[i]);\n                        }\n                    }\n\n                    return paths;\n                }\n\n                return filesInFolder(path);\n            },\n            createDirectory: function(path: string): void {\n                try {\n                    if (!this.directoryExists(path)) {\n                        _fs.mkdirSync(path);\n                    }\n                } catch (e) {\n                    IOUtils.throwIOError("Couldn\'t create directory \'" + path + "\'.", e);\n                }\n            },\n\n            directoryExists: function(path: string): bool {\n                return _fs.existsSync(path) && _fs.lstatSync(path).isDirectory();\n            },\n            resolvePath: function(path: string): string {\n                return _path.resolve(path);\n            },\n            dirName: function(path: string): string {\n                return _path.dirname(path);\n            },\n            findFile: function(rootPath: string, partialFilePath): IResolvedFile {\n                var path = rootPath + "/" + partialFilePath;\n\n                while (true) {\n                    if (_fs.existsSync(path)) {\n                        try {\n                            var content = this.readFile(path);\n                            return { content: content, path: path };\n                        } catch (err) {\n                            //Tools.CompilerDiagnostics.debugPrint(("Could not find " + path) + ", trying parent");\n                        }\n                    }\n                    else {\n                        var parentPath = _path.resolve(rootPath, "..");\n\n                        // Node will just continue to repeat the root path, rather than return null\n                        if (rootPath === parentPath) {\n                            return null;\n                        }\n                        else {\n                            rootPath = parentPath;\n                            path = _path.resolve(rootPath, partialFilePath);\n                        }\n                    }\n                }\n            },\n            print: function(str) { process.stdout.write(str) },\n            printLine: function(str) { process.stdout.write(str + \'\\n\') },\n            arguments: process.argv.slice(2),\n            stderr: {\n                Write: function(str) { process.stderr.write(str); },\n                WriteLine: function(str) { process.stderr.write(str + \'\\n\'); },\n                Close: function() { }\n            },\n            stdout: {\n                Write: function(str) { process.stdout.write(str); },\n                Write',
v27625=v27626+'Line: function(str) { process.stdout.write(str + \'\\n\'); },\n                Close: function() { }\n            },\n            watchFile: function(filename: string, callback: (string) => void ): IFileWatcher {\n                var firstRun = true;\n                var processingChange = false;\n\n                var fileChanged: any = function(curr, prev) {\n                    if (!firstRun) {\n                        if (curr.mtime < prev.mtime) {\n                            return;\n                        }\n\n                        _fs.unwatchFile(filename, fileChanged);\n                        if (!processingChange) {\n                            processingChange = true;\n                            callback(filename);\n                            setTimeout(function() { processingChange = false; }, 100);\n                        }\n                    }\n                    firstRun = false;\n                    _fs.watchFile(filename, { persistent: true, interval: 500 }, fileChanged);\n                };\n\n                fileChanged();\n                return {\n                    filename: filename,\n                    close: function() {\n                        _fs.unwatchFile(filename, fileChanged);\n                    }\n                };\n            },\n            run: function(source, filename) {\n                require.main.filename = filename;\n                require.main.paths = _module._nodeModulePaths(_path.dirname(_fs.realpathSync(filename)));\n                require.main._compile(source, filename);\n            }, \n            getExecutingFilePath: function () {\n                return process.mainModule.filename;\n            },\n            quit: process.exit\n        }\n    };\n\n    if (typeof ActiveXObject === "function")\n        return getWindowsScriptHostIO();\n    else if (typeof require === "function")\n        return getNodeIO();\n    else\n        return null; // Unsupported host\n})();\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    // Note: Any addition to the NodeType should also be supported with addition to AstWalkerDetailCallback\n    export enum NodeType {\n        None,\n        Empty,\n        EmptyExpr,\n        True,\n        False,\n        This,\n        Super,\n        QString,\n        Regex,\n        Null,\n        ArrayLit,\n        ObjectLit,\n        Void,\n        Comma,\n        Pos,\n        Neg,\n        Delete,\n        Await,\n        In,\n        Dot,\n        From,\n        Is,\n        InstOf,\n        Typeof,\n        NumberLit,\n        Name,\n        TypeRef,\n        Index,\n        Call,\n        New,\n        Asg,\n        AsgAdd,\n        AsgSub,\n        AsgDiv,\n        AsgMul,\n        AsgMod,\n        AsgAnd,\n        AsgXor,\n        AsgOr,\n        AsgLsh,\n        AsgRsh,\n        AsgRs2,\n        ConditionalExpression,\n        LogOr,\n        LogAnd,\n        Or,\n        Xor,\n        And,\n        Eq,\n        Ne,\n        Eqv,\n        NEqv,\n        Lt,\n        Le,\n        Gt,\n        Ge,\n        Add,\n        Sub,\n        Mul,\n        Div,\n        Mod,\n        Lsh,\n        Rsh,\n        Rs2,\n        Not,\n        LogNot,\n        IncPre,\n        DecPre,\n        IncPost,\n        DecPost,\n        TypeAssertion,\n        FuncDecl,\n        Member,\n        VarDecl,\n        ArgDecl,\n        Return,\n        Break,\n        Continue,\n        Throw,\n        For,\n        ForIn,\n        If,\n        While,\n        DoWhile,\n        Block,\n        Case,\n        Switch,\n        Try,\n        TryCatch,\n        TryFinally,\n        Finally,\n        Catch,\n        List,\n        Script,\n        ClassDeclaration,\n        InterfaceDeclaration,\n        ModuleDeclaration,\n        ImportDeclaration,\n        With,\n        Label,\n        LabeledStatement,\n        EBStart,\n        GotoEB,\n        EndCode,\n        Error,\n        Comment,\n        Debugger,\n        GeneralNode = FuncDecl,\n        LastAsg = AsgRs2,\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.',
v27624=v27625+'\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path="io.ts" />\n\ninterface IOptions {\n    name?: string;\n    flag?: bool;\n    short?: string;\n    usage?: string;\n    set?: (s: string) => void;\n    type?: string;\n    experimental?: bool;\n}\n\nclass OptionsParser {\n    private DEFAULT_SHORT_FLAG = "-";\n    private DEFAULT_LONG_FLAG = "--";\n\n    // Find the option record for the given string. Returns null if not found.\n    private findOption(arg: string) {\n\n        for (var i = 0; i < this.options.length; i++) {\n\n            if (arg === this.options[i].short || arg === this.options[i].name) {\n                return this.options[i];\n            }\n        }\n\n        return null;\n    }\n\n    public unnamed: string[] = [];\n\n    public options: IOptions[] = [];\n\n    constructor (public host: IIO) {\n    }\n\n    public printUsage() {\n        this.host.printLine("Syntax:   tsc [options] [file ..]");\n        this.host.printLine("");\n        this.host.printLine("Examples: tsc hello.ts");\n        this.host.printLine("          tsc --out foo.js foo.ts");\n        this.host.printLine("          tsc @args.txt");\n        this.host.printLine("");\n        this.host.printLine("Options:");\n\n        var output = [];\n        var maxLength = 0;\n\n        this.options = this.options.sort(function(a, b) {\n            var aName = a.name.toLowerCase();\n            var bName = b.name.toLowerCase();\n\n            if (aName > bName) {\n                return 1;\n            } else if (aName < bName) {\n                return -1;\n            } else {\n                return 0;\n            }\n        });\n\n        // Build up output array\n        for (var i = 0; i < this.options.length; i++) {\n            var option = this.options[i];\n\n            if (option.experimental) {\n                continue;\n            }\n\n            if (!option.usage) {\n                break;\n            }\n\n            var usageString = "  ";\n            var type = option.type ? " " + option.type.toUpperCase() : "";\n\n            if (option.short) {\n                usageString += this.DEFAULT_SHORT_FLAG + option.short + type + ", ";\n            }\n\n            usageString += this.DEFAULT_LONG_FLAG + option.name + type;\n\n            output.push([usageString, option.usage]);\n\n            if (usageString.length > maxLength) {\n                maxLength = usageString.length;\n            }\n        }\n\n        output.push(["  @<file>", "Insert command line options and files from a file."]);\n\n        // Print padded output\n        for (var i = 0; i < output.length; i++) {\n            this.host.printLine(output[i][0] + (new Array(maxLength - output[i][0].length + 3)).join(" ") + output[i][1]);\n        }\n    }\n\n    public option(name: string, config: IOptions, short?: string) {\n        if (!config) {\n            config = <any>short;\n            short = null;\n        }\n\n        config.name = name;\n        config.short = short;\n        config.flag = false;\n\n        this.options.push(config);\n    }\n\n    public flag(name: string, config: IOptions, short?: string) {\n        if (!config) {\n            config = <any>short;\n            short = null;\n        }\n\n        config.name = name;\n        config.short = short;\n        config.flag = true\n\n        this.options.push(config);\n    }\n\n    // Parse an arguments string\n    public parseString(argString: string) {\n        var position = 0;\n        var tokens = argString.match(/\\s+|"|[^\\s"]+/g);\n\n        function peek() {\n            return tokens[position];\n        }\n\n        function consume() {\n            return tokens[position++];\n        }\n\n        function consumeQuotedString() {\n            var value = \'\';\n            consume(); // skip opening quote.\n\n            var token = peek();\n\n            while (token && token !== \'"\') {\n                consume();\n\n                value += token;\n\n                token = peek();\n            }\n\n            consume(); // skip ending quote;\n\n            return value;\n        }\n\n        var args: string[] = [];\n        var currentArg = \'\';\n\n        while (position < tokens.length) {\n            var token = peek();\n\n            if (token === \'"\') {\n                currentArg += consumeQuotedString();\n            } else if (token.match(/\\s/)) {\n                if (currentArg.length > 0) {\n                    args.push(currentArg);\n                    currentArg = \'\';\n                }\n\n                consume();\n            } else {\n                consume();\n                currentArg += token;\n            }\n        }\n\n        if (currentArg.length > 0) {\n            args.push(currentArg);\n        }\n\n        this.parse(args);\n    }\n\n    // Parse arguments as they come from the platform: split into arguments.\n    public parse(args: string[]) {\n        var position = 0;\n\n        function consume() {\n            return args[position++];\n        }\n\n        while (position < args.length) {\n            var current = consume();\n           ',
v27623=v27624+' var match = current.match(/^(--?|@)(.*)/);\n            var value = null;\n\n            if (match) {\n                if (match[1] === \'@\') {\n                    this.parseString(this.host.readFile(match[2]));\n                } else {\n                    var arg = match[2];\n                    var option = this.findOption(arg);\n\n                    if (option === null) {\n                        this.host.printLine("Unknown option \'" + arg +"\'");\n                        this.host.printLine("Use the \'--help\' flag to see options");\n                    } else {\n                        if (!option.flag)\n                            value = consume();\n\n                        option.set(value);\n                    }\n                }\n            } else {\n                this.unnamed.push(current);\n            }\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export enum TypeContext {\n        NoTypes = 0,\n        ArraySuffix = 1,\n        Primitive = 2,\n        Named = 4,\n        AllSimpleTypes = Primitive | Named,\n        AllTypes = Primitive | Named | ArraySuffix,\n    }\n\n    export enum ParseState {\n        None,\n        StartScript,\n        StartStatementList,\n        StartStatement,\n        StartFncDecl,\n        FncDeclName,\n        FncDeclArgs,\n        FncDeclReturnType,\n        ForInit,\n        ForInitAfterVar,\n        ForCondStart,\n        EndStmtList,\n        EndScript,\n    }\n\n    export interface IStatementInfo {\n        stmt: Statement;\n        labels: ASTList;\n    }\n\n    export interface ILambdaArgumentContext {\n        preProcessedLambdaArgs: AST;\n    }\n\n    export class QuickParseResult {\n        constructor (public Script: Script, public endLexState: LexState) { }\n    }\n\n    export class Parser {\n        private varLists: ASTList[] = [];\n        private scopeLists: ASTList[] = [];\n        private staticsLists: ASTList[] = [];\n\n        private scanner: IScanner = new Scanner();\n        private currentToken: Token = null;\n\n        private needTerminator = false;\n\n        // TODO: consolidate these\n        private inFunction = false;\n        private inInterfaceDecl = false;\n        public currentClassDecl: NamedDeclaration = null;\n\n        private inFncDecl = false;  // this is only for FuncDecls - not constructors, like inFnc\n        private anonId = new Identifier("_anonymous");\n        public style_requireSemi = false;\n        public style_funcInLoop = true;\n        private incremental = false;\n        public errorRecovery = false;\n        public outfile: ITextWriter = undefined;\n        public errorCallback: (minChar: number, charLen: number, message: string, unit: number) =>void = null;\n        private state: ParseState = ParseState.StartStatementList;\n        private ambientModule = false;\n        private ambientClass = false;\n        private topLevel = true;\n        private allowImportDeclaration = true;\n        private currentUnitIndex = (-1);\n        private prevIDTok: Token = null;\n        private statementInfoStack: IStatementInfo[] = new IStatementInfo[];\n        private hasTopLevelImportOrExport = false; // for imports, only true if it\'s a dynamic module\n        private strictMode = false;\n        private nestingLevel = 0;\n        private prevExpr: AST = null;\n        private currentClassDefinition: ClassDeclaration = null;\n        private parsingClassConstructorDefinition = false;\n        private parsingDeclareFile = false;\n        private amdDependencies: string[] = [];\n        public inferPropertiesFromThisAssignment = false;\n        public requiresExtendsBlock = false;\n\n        private resetStmtStack() {\n            this.statementInfoStack = new IStatementInfo[];\n        }\n\n        private inLoop() {\n            for (var j = this.statementInfoStack.length - 1; j >= 0; j--) {\n                if (this.statementInfoStack[j].stmt.isLoop()) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private pushStmt(stmt: Statement, labels: ASTList) {\n            // allocate here to avoid always storing this information in statements\n            var info = { stmt: stmt, labels: labels };\n            this.statementInfoStack.push(info);\n        }\n\n        private popStmt(): IStatementInfo {\n            return this.statementInfoStack.pop();\n        }\n\n        private resolveJumpTarget(jump: Jump): void {',
v27622=v27623+'\n            var resolvedTarget = AST.getResolvedIdentifierName(jump.target);\n            var len = this.statementInfoStack.length;\n            for (var i = len - 1; i >= 0; i--) {\n                var info = this.statementInfoStack[i];\n                if (jump.target) {\n                    if (info.labels && (info.labels.members.length > 0)) {\n                        for (var j = 0, labLen = info.labels.members.length; j < labLen; j++) {\n                            var label = <Label>info.labels.members[j];\n                            if (label.id.text == resolvedTarget) {\n                                jump.setResolvedTarget(this, info.stmt);\n                                return;\n                            }\n                        }\n                    }\n                }\n                else {\n                    if (info.stmt.isLoop()) {\n                        jump.setResolvedTarget(this, info.stmt);\n                        return;\n                    }\n                    else if ((info.stmt.nodeType == NodeType.Switch) && (jump.nodeType == NodeType.Break)) {\n                        jump.setResolvedTarget(this, info.stmt);\n                        return;\n                    }\n                }\n            }\n            // no luck\n            if (jump.target) {\n                this.reportParseError("could not find enclosing statement with label " + jump.target);\n            }\n            else {\n                if (jump.nodeType == NodeType.Break) {\n                    this.reportParseError("break statement requires enclosing loop or switch");\n                }\n                else {\n                    this.reportParseError("continue statement requires enclosing loop");\n                }\n            }\n        }\n\n        public setErrorRecovery(outfile: ITextWriter) {\n            this.outfile = outfile;\n            this.errorRecovery = true;\n        }\n\n        public getSourceLineCol(lineCol: ILineCol, minChar: number): void {\n            getSourceLineColFromMap(lineCol, minChar, this.scanner.lineMap);\n        }\n\n        private createRef(text: string, hasEscapeSequence: bool, minChar: number): Identifier {\n            var id = new Identifier(text, hasEscapeSequence);\n            id.minChar = minChar;\n            return id;\n        }\n\n        private reportParseStyleError(message: string) {\n            this.reportParseError("STYLE: " + message);\n        }\n\n        public reportParseError(message: string, startPos = this.scanner.startPos, pos = this.scanner.pos) {\n            var len = Math.max(1, pos - startPos);\n            if (this.errorCallback) {\n                this.errorCallback(startPos, len, message, this.currentUnitIndex);\n            }\n            else if (this.errorRecovery) {\n                var lineCol = { line: -1, col: -1 };\n                this.getSourceLineCol(lineCol, startPos);\n                if (this.outfile) {\n                    this.outfile.WriteLine("// " + this.fname + " (" + lineCol.line + "," + lineCol.col + "): " + message);\n                }\n            }\n            else {\n                throw new SyntaxError(this.fname + " (" + this.scanner.line + "," + this.scanner.col + "): " + message);\n            }\n        }\n\n        private checkNextToken(tokenId: TokenID, errorRecoverySet: ErrorRecoverySet, errorText: string = null): void {\n            this.currentToken = this.scanner.scan();\n            this.checkCurrentToken(tokenId, errorRecoverySet, errorText);\n        }\n\n        private skip(errorRecoverySet: ErrorRecoverySet) {\n            errorRecoverySet |= ErrorRecoverySet.EOF;\n            var ersTok = ErrorRecoverySet.None;\n            var tokenInfo = lookupToken(this.currentToken.tokenId);\n            if (tokenInfo != undefined) {\n                ersTok = tokenInfo.ers;\n            }\n            var pendingRightCurlies = 0;\n            while (((ersTok & errorRecoverySet) == ErrorRecoverySet.None) ||\n                   (this.currentToken.tokenId == TokenID.CloseBrace) && (pendingRightCurlies > 0)) {\n                if (this.currentToken.tokenId == TokenID.OpenBrace) {\n                    pendingRightCurlies++;\n                }\n                else if (this.currentToken.tokenId == TokenID.CloseBrace) {\n                    pendingRightCurlies--;\n                }\n                this.currentToken = this.scanner.scan();\n                ersTok = ErrorRecoverySet.None;\n                tokenInfo = lookupToken(this.currentToken.tokenId);\n                if (tokenInfo != undefined) {\n                    ersTok = tokenInfo.ers;\n                }\n                // TODO: regex rescan \n            }\n        }\n\n        private checkCurrentToken(tokenId: TokenID, errorRecoverySet: ErrorRecoverySet, errorText: string = null): void {\n            if (this.currentToken.tokenId != tokenId) {\n                errorText = errorText == null ? ("Expected \'" + tokenTable[tokenId].text + "\'") : errorText;\n                this.reportParseError(errorText);\n                if (this.errorRecove',
v27621=v27622+'ry) {\n                    this.skip(errorRecoverySet);\n                }\n            }\n            else {\n                this.currentToken = this.scanner.scan();\n            }\n        }\n\n        private pushDeclLists() {\n            this.staticsLists.push(new ASTList());\n            this.varLists.push(new ASTList());\n            this.scopeLists.push(new ASTList());\n        }\n\n        private popDeclLists() {\n            this.staticsLists.pop();\n            this.varLists.pop();\n            this.scopeLists.pop();\n        }\n\n        private topVarList() {\n            return this.varLists[this.varLists.length - 1];\n        }\n\n        private topScopeList() {\n            return this.scopeLists[this.scopeLists.length - 1];\n        }\n\n        private topStaticsList() {\n            return this.staticsLists[this.staticsLists.length - 1];\n        }\n\n        private parseComment(comment: CommentToken) {\n            if (comment) {\n                var c: Comment = new Comment(comment.value, comment.isBlock, comment.endsLine);\n                c.minChar = comment.startPos;\n                c.limChar = comment.startPos + comment.value.length;\n                var lineCol = { line: -1, col: -1 };\n                this.getSourceLineCol(lineCol, c.minChar);\n                c.minLine = lineCol.line;\n                this.getSourceLineCol(lineCol, c.limChar);\n                c.limLine = lineCol.line;\n\n                if (!comment.isBlock && comment.value.length > 3 && comment.value.substring(0, 3) == "///") {\n                    var dependencyPath = getAdditionalDependencyPath(comment.value);\n\n                    if (dependencyPath) {\n                        this.amdDependencies.push(dependencyPath);\n                    }\n\n                    if (getImplicitImport(comment.value)) {\n                        this.hasTopLevelImportOrExport = true;\n                    }\n                }\n\n                return c;\n            }\n            else {\n                return null;\n            }\n        }\n\n        private parseCommentsInner(comments: CommentToken[]) {\n            if (comments) {\n                var commentASTs: Comment[] = new Comment[];\n                for (var i = 0; i < comments.length; i++) {\n                    commentASTs.push(this.parseComment(comments[i]));\n                }\n                return commentASTs;\n            } else {\n                return null;\n            }\n        }\n\n        private parseComments() {\n            var comments = this.scanner.getComments();\n            return this.parseCommentsInner(comments);\n        }\n\n        private parseCommentsForLine(line: number) {\n            var comments = this.scanner.getCommentsForLine(line);\n\n            return this.parseCommentsInner(comments);\n        }\n\n        private combineComments(comment1: Comment[], comment2: Comment[]) {\n            if (comment1 == null) {\n                return comment2;\n            }\n            else if (comment2 == null) {\n                return comment1;\n            }\n            else {\n                return comment1.concat(comment2);\n            }\n        }\n\n        private parseEnumDecl(errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers): ModuleDeclaration {\n            var leftCurlyCount = this.scanner.leftCurlyCount;\n            var rightCurlyCount = this.scanner.rightCurlyCount;\n\n            var name: Identifier = null;\n            if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                name = Identifier.fromToken(this.currentToken);\n                name.minChar = this.scanner.startPos;\n                name.limChar = this.scanner.pos;\n                this.currentToken = this.scanner.scan();\n            }\n            else {\n                this.reportParseError("Enum declaration requires identifier");\n                if (this.errorRecovery) {\n                    name = new MissingIdentifier();\n                    name.minChar = this.scanner.startPos;\n                    name.limChar = this.scanner.startPos;\n                    name.flags |= ASTFlags.Error;\n                }\n            }\n\n            var membersMinChar = this.scanner.startPos;\n            this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet | ErrorRecoverySet.ID);\n            this.pushDeclLists();\n            var members = new ASTList();\n            members.minChar = membersMinChar;\n            var mapDecl = new VarDecl(new Identifier("_map"), 0);\n            mapDecl.varFlags |= VarFlags.Exported;\n            mapDecl.varFlags |= VarFlags.Private;\n\n            // REVIEW: Is this still necessary?\n            mapDecl.varFlags |= (VarFlags.Property | VarFlags.Public);\n            mapDecl.init = new UnaryExpression(NodeType.ArrayLit, null);\n            members.append(mapDecl);\n            var lastValue: NumberLiteral = null;\n            for (; ;) {\n                var minChar = this.scanner.startPos;\n                var limChar;\n                var memberName: Identifier = null;\n',
v27620=v27621+'                var memberValue: AST = null;\n                var preComments = null;\n                var postComments = null;\n\n                if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToIDName(this.currentToken)) {\n                    memberName = Identifier.fromToken(this.currentToken);\n                    memberName.minChar = this.scanner.startPos;\n                    memberName.limChar = this.scanner.pos;\n                }\n                else if (this.currentToken.tokenId == TokenID.CloseBrace) {\n                    break;\n                }\n                else {\n                    this.reportParseError("Expected identifer of enum member");\n                    if (this.errorRecovery) {\n                        memberName = new MissingIdentifier();\n                        memberName.minChar = this.scanner.startPos;\n                        memberName.limChar = this.scanner.startPos;\n                        memberName.flags |= ASTFlags.Error;\n                    }\n                }\n\n                limChar = this.scanner.pos;\n                preComments = this.parseComments();\n                this.currentToken = this.scanner.scan();\n                postComments = this.parseComments();\n\n                if (this.currentToken.tokenId == TokenID.Equals) {\n                    this.currentToken = this.scanner.scan();\n                    memberValue = this.parseExpr(errorRecoverySet, OperatorPrecedence.Comma, true,\n                                          TypeContext.NoTypes);\n                    lastValue = <NumberLiteral>memberValue;\n                    limChar = memberValue.limChar;\n                }\n                else {\n                    if (lastValue == null) {\n                        memberValue = new NumberLiteral(0);\n                        lastValue = <NumberLiteral>memberValue;\n                    }\n                    else {\n                        memberValue = new NumberLiteral(lastValue.value + 1);\n                        lastValue = <NumberLiteral>memberValue;\n                    }\n                    var map: BinaryExpression =\n                        new BinaryExpression(NodeType.Asg,\n                                             new BinaryExpression(NodeType.Index,\n                                                                  new Identifier("_map"),\n                                                                  memberValue),\n                                             new StringLiteral(\'"\' + memberName.actualText + \'"\'));\n                    members.append(map);\n                }\n                var member = new VarDecl(memberName, this.nestingLevel);\n                member.minChar = minChar;\n                member.limChar = limChar;\n                member.init = memberValue;\n                // Note: Leave minChar, limChar as "-1" on typeExpr as this is a parsing artifact.\n                member.typeExpr = new TypeReference(this.createRef(name.actualText, name.hasEscapeSequence, -1), 0);\n                member.varFlags |= (VarFlags.Readonly | VarFlags.Property);\n                if (memberValue.nodeType == NodeType.NumberLit) {\n                    member.varFlags |= VarFlags.Constant;\n                }\n                member.preComments = preComments;\n                members.append(member);\n                member.postComments = postComments;\n                // all enum members are exported\n                member.varFlags |= VarFlags.Exported;\n\n                if (this.currentToken.tokenId == TokenID.Comma) {\n                    this.currentToken = this.scanner.scan();\n                    member.postComments = this.combineComments(member.postComments, this.parseCommentsForLine(this.scanner.prevLine));\n                    if ((this.currentToken.tokenId == TokenID.Identifier) || (convertTokToIDName(this.currentToken))) {\n                        continue;\n                    }\n                }\n                break;\n            }\n            var endingToken = new ASTSpan();\n            endingToken.minChar = this.scanner.startPos;\n            endingToken.limChar = this.scanner.pos;\n\n            this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n            members.limChar = this.scanner.lastTokenLimChar();\n            var modDecl = new ModuleDeclaration(name, members, this.topVarList(), this.topScopeList(), endingToken);\n            modDecl.modFlags |= ModuleFlags.IsEnum;\n            this.popDeclLists();\n\n            modDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n            modDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n            return modDecl;\n        }\n\n        private parseDottedName(enclosedList: AST[]): void {\n            this.currentToken = this.scanner.scan();\n            if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                var id = Identifier.fromToken(this.currentToken);\n                id.preComments = this.parseCom',
v27619=v27620+"ments();\n                enclosedList[enclosedList.length] = id;\n                id.minChar = this.scanner.startPos;\n                id.limChar = this.scanner.pos;\n                this.currentToken = this.scanner.scan();\n                if (this.currentToken.tokenId == TokenID.Dot) {\n                    this.parseDottedName(enclosedList);\n                }\n            }\n            else {\n                this.reportParseError(\"need identifier after '.'\");\n            }\n        }\n\n        // REVIEW: This is much more lenient than the spec - we're basically just checking to see if the\n        // path is rooted or contains an extension, not if it could potentially be a bogus file path\n        private isValidImportPath(importPath: string) {\n            importPath = stripQuotes(importPath);\n\n            if (!importPath ||\n                importPath.indexOf(':') != -1 || \n                importPath.indexOf('\\\\') != -1 ||\n                //(importPath.indexOf('.') != -1 && importPath.charAt(0) != '.') ||\n                importPath.charAt(0) == '/') {\n                return false;\n            }\n            return true;\n        }\n\n        private parseImportDeclaration(errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers): ImportDeclaration {\n\n            var name: Identifier = null;\n            var alias: AST = null;\n            var importDecl: ImportDeclaration = null;\n            var minChar = this.scanner.startPos;\n            var isDynamicImport = false;\n\n            this.currentToken = this.scanner.scan();\n\n            if (this.currentToken.tokenId == TokenID.Identifier || convertTokToID(this.currentToken, this.strictMode)) {\n                name = Identifier.fromToken(this.currentToken);\n            }\n            else {\n                this.reportParseError(\"Expected identifer after 'import'\");\n                name = new MissingIdentifier();\n            }\n\n            name.minChar = this.scanner.startPos;\n            name.limChar = this.scanner.pos;\n\n            this.currentToken = this.scanner.scan();\n\n            this.checkCurrentToken(TokenID.Equals, errorRecoverySet | ErrorRecoverySet.ID);\n\n            var aliasPreComments = this.parseComments();\n\n            var limChar;\n            if (this.currentToken.tokenId == TokenID.Identifier || convertTokToID(this.currentToken, this.strictMode)) {\n\n                if (this.currentToken.tokenId == TokenID.Module) {\n                    limChar = this.scanner.pos;\n                    this.currentToken = this.scanner.scan();\n                    if (this.currentToken.tokenId == TokenID.OpenParen) {\n                        this.currentToken = this.scanner.scan();\n\n                        if (this.currentToken.tokenId == TokenID.StringLiteral || this.currentToken.tokenId == TokenID.Identifier || convertTokToID(this.currentToken, this.strictMode)) {\n\n                            if (this.currentToken.tokenId == TokenID.StringLiteral) {\n\n                                if (this.topLevel) {\n                                    this.hasTopLevelImportOrExport = true;\n                                } else if (!this.allowImportDeclaration) {\n                                    this.reportParseError(\"Import declaration of external module is permitted only in global or top level dynamic modules\");\n                                }\n\n                                var aliasText = this.currentToken.getText();\n                                alias = Identifier.fromToken(this.currentToken);\n                                alias.minChar = this.scanner.startPos;\n                                alias.limChar = this.scanner.pos;\n\n                                if (!this.isValidImportPath((<Identifier>alias).text)) {\n                                    this.reportParseError(\"Invalid import path\");\n                                }\n\n                                isDynamicImport = true;\n                                this.currentToken = this.scanner.scan();\n                                    \n                                alias.preComments = aliasPreComments;\n                            }\n                            else {\n                                alias = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon,\n                                            OperatorPrecedence.Assignment, true,\n                                            TypeContext.NoTypes);\n                                    \n                                alias.preComments = aliasPreComments;\n                            }\n                        }\n\n                        limChar = this.scanner.pos;\n                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.ID);\n\n                        if (alias) {\n                            alias.postComments = this.parseComments();\n                        }\n                    }\n                }\n                else {\n                    alias = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon,\n                 ",
v27618=v27619+'                           OperatorPrecedence.Assignment, true,\n                                            TypeContext.NoTypes);\n                    limChar = this.scanner.pos; // Include semicolon if needed\n                }\n            }\n            else {\n                this.reportParseError("Expected module name");\n                alias = new MissingIdentifier();\n                alias.minChar = this.scanner.startPos;\n                if (this.currentToken.tokenId == TokenID.Semicolon) {\n                    alias.limChar = this.scanner.startPos;\n                } else {\n                    alias.limChar = this.scanner.pos;\n                    this.currentToken = this.scanner.scan();\n                }\n                alias.flags |= ASTFlags.Error;\n                limChar = alias.limChar;\n            }\n\n            importDecl = new ImportDeclaration(name, alias);\n            importDecl.isDynamicImport = isDynamicImport;\n\n            importDecl.minChar = minChar;\n            importDecl.limChar = limChar;\n\n            return importDecl;\n        }\n\n        private parseModuleDecl(errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers, preComments: Comment[]): ModuleDeclaration {\n            var leftCurlyCount = this.scanner.leftCurlyCount;\n            var rightCurlyCount = this.scanner.rightCurlyCount;\n\n            var svAmbient = this.ambientModule;\n            var svTopLevel = this.topLevel;\n            this.topLevel = false;\n            if (this.parsingDeclareFile || svAmbient || hasFlag(modifiers, Modifiers.Ambient)) {\n                this.ambientModule = true;\n            }\n\n            this.currentToken = this.scanner.scan();\n            var name: AST = null;\n            var enclosedList: AST[] = null;\n            this.pushDeclLists();\n            var minChar = this.scanner.startPos;\n            var isDynamicMod = false;\n\n            if ((this.currentToken.tokenId == TokenID.Identifier) || (this.currentToken.tokenId == TokenID.StringLiteral) || (!isPrimitiveTypeToken(this.currentToken) && convertTokToID(this.currentToken, this.strictMode))) {\n                var nameText = this.currentToken.getText();\n\n                if (this.currentToken.tokenId == TokenID.StringLiteral) {\n                    isDynamicMod = true;\n                    if (!this.ambientModule) {\n                        this.reportParseError("Only ambient dynamic modules may have string literal names");\n                    }\n\n                    if (!svTopLevel) {\n                        this.reportParseError("Dynamic modules may not be nested within other modules");\n                    }\n                }\n\n                name = Identifier.fromToken(this.currentToken);\n                name.minChar = this.scanner.startPos;\n                name.limChar = this.scanner.pos;\n\n                this.currentToken = this.scanner.scan();\n            }\n            else if (this.currentToken.tokenId == TokenID.OpenBrace) {\n                this.reportParseError("Module name missing");\n                name = new Identifier("");\n                // "fake" position of where the ID would be\n                name.minChar = minChar;\n                name.limChar = minChar;\n            }\n\n            if (this.currentToken.tokenId == TokenID.Dot) {\n                enclosedList = new AST[];\n                this.parseDottedName(enclosedList);\n            }\n\n            if (name == null) {\n                name = new MissingIdentifier();\n            }\n\n            var moduleBody = new ASTList();\n            var bodyMinChar = this.scanner.startPos;\n            this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet | ErrorRecoverySet.ID);\n\n            if (svTopLevel && isDynamicMod) {\n                this.allowImportDeclaration = true;\n            } else {\n                this.allowImportDeclaration = false;\n            }\n            this.parseStatementList(\n                errorRecoverySet | ErrorRecoverySet.RCurly, moduleBody,\n                /*sourceElements:*/ true, /*noLeadingCase:*/ true, AllowedElements.Global, modifiers);\n            moduleBody.minChar = bodyMinChar;\n            moduleBody.limChar = this.scanner.pos;\n\n            var endingToken = new ASTSpan();\n            endingToken.minChar = this.scanner.startPos;\n            endingToken.limChar = this.scanner.pos;\n            this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n\n            var limChar = this.scanner.lastTokenLimChar();\n            var moduleDecl: ModuleDeclaration;\n\n            this.allowImportDeclaration = svTopLevel;\n\n            if (enclosedList && (enclosedList.length > 0)) {\n                var len = enclosedList.length;\n                var innerName = <Identifier>enclosedList[len - 1];\n                var innerDecl = new ModuleDeclaration(innerName, moduleBody, this.topVarList(),\n                                                this.topScopeList(), endingToken);\n                innerDecl.preComments = preComments;\n\n                if (this.parsingDeclareFile || hasFl',
v27617=v27618+'ag(modifiers, Modifiers.Ambient)) {\n                    innerDecl.modFlags |= ModuleFlags.Ambient;\n                }\n\n                innerDecl.modFlags |= ModuleFlags.Exported;\n\n                // REVIEW: will also possibly need to re-parent comments as well\n                innerDecl.minChar = minChar;\n                innerDecl.limChar = limChar;\n\n                this.popDeclLists();\n                var outerModBod: ASTList;\n                for (var i = len - 2; i >= 0; i--) {\n                    outerModBod = new ASTList();\n                    outerModBod.append(innerDecl);\n                    innerName = <Identifier>enclosedList[i];\n                    innerDecl = new ModuleDeclaration(innerName, outerModBod, new ASTList(),\n                                                new ASTList(), endingToken);\n                    outerModBod.minChar = innerDecl.minChar = minChar;\n                    outerModBod.limChar = innerDecl.limChar = limChar;\n\n                    if (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)) {\n                        innerDecl.modFlags |= ModuleFlags.Ambient;\n                    }\n\n                    innerDecl.modFlags |= ModuleFlags.Exported;\n                }\n                outerModBod = new ASTList();\n                outerModBod.append(innerDecl);\n                outerModBod.minChar = minChar;\n                outerModBod.limChar = limChar;\n                moduleDecl = new ModuleDeclaration(<Identifier>name, outerModBod, new ASTList(),\n                                            new ASTList(), endingToken);\n            }\n            else {\n                moduleDecl = new ModuleDeclaration(<Identifier>name, moduleBody, this.topVarList(), this.topScopeList(), endingToken);\n                moduleDecl.preComments = preComments;\n                this.popDeclLists();\n            }\n\n            if (this.parsingDeclareFile || svAmbient || hasFlag(modifiers, Modifiers.Ambient)) {\n                moduleDecl.modFlags |= ModuleFlags.Ambient;\n            }\n            if (svAmbient || hasFlag(modifiers, Modifiers.Exported)) {\n                moduleDecl.modFlags |= ModuleFlags.Exported;\n            }\n            if (isDynamicMod) {\n                moduleDecl.modFlags |= ModuleFlags.IsDynamic;\n            }\n\n            this.ambientModule = svAmbient;\n\n            this.topLevel = svTopLevel;\n            moduleDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n            moduleDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n            moduleDecl.limChar = moduleBody.limChar;\n            return moduleDecl;\n        }\n\n        private parseTypeReferenceTail(errorRecoverySet: ErrorRecoverySet, minChar: number, term: AST): TypeReference {\n            var result = new TypeReference(term, 0);\n            result.minChar = minChar;\n            while (this.currentToken.tokenId == TokenID.OpenBracket) {\n                this.currentToken = this.scanner.scan();\n                result.arrayCount++;\n                this.checkCurrentToken(TokenID.CloseBracket, errorRecoverySet | ErrorRecoverySet.LBrack);\n            }\n            result.limChar = this.scanner.lastTokenLimChar();\n            return result;\n        }\n\n        // REVIEW: Consider renaming to parseTypeName.\n        private parseNamedType(errorRecoverySet: ErrorRecoverySet, minChar: number, term: AST, tail: bool): AST {\n            this.currentToken = this.scanner.scan();\n            if (this.currentToken.tokenId == TokenID.Dot) {\n                var curpos = this.scanner.pos;\n                this.currentToken = this.scanner.scan();\n                // Don\'t allow reserved words if immediately after a new line and error recovery is enabled\n                if ((this.currentToken.tokenId == TokenID.Identifier) || ((!this.errorRecovery || !this.scanner.lastTokenHadNewline()) && convertTokToID(this.currentToken, this.strictMode))) {\n                    var op2 = Identifier.fromToken(this.currentToken);\n                    op2.minChar = this.scanner.startPos;\n                    op2.limChar = this.scanner.pos;\n                    var dotNode = new BinaryExpression(NodeType.Dot, term, op2);\n                    dotNode.minChar = term.minChar;\n                    dotNode.limChar = op2.limChar;\n                    return this.parseNamedType(errorRecoverySet, minChar,\n                                            dotNode, tail);\n                }\n                else {\n                    this.reportParseError("need identifier after \'.\'");\n                    if (this.errorRecovery) {\n                        term.flags |= ASTFlags.DotLHS;\n                        // We set "limChar" to be slightly innacurate for completion list behavior\n                        // (last AST node from "quickParse" will match DotLHS and be at end of file position)\n                        // This is to match the behavior of TokenId.Dot processing in parsePostfixOperators.\n                        term.limChar = this.scanner.las',
v27616=v27617+'tTokenLimChar();\n                        return term;\n                    }\n                    else {\n                        var eop2 = new MissingIdentifier();\n                        eop2.minChar = this.scanner.pos;\n                        eop2.limChar = this.scanner.pos;\n                        var edotNode = new BinaryExpression(NodeType.Dot, term, eop2);\n                        edotNode.flags |= ASTFlags.Error;\n                        edotNode.minChar = term.minChar;\n                        edotNode.limChar = eop2.limChar;\n                        return this.parseNamedType(errorRecoverySet, minChar,\n                                                edotNode, tail);\n                    }\n                }\n            }\n            else {\n                if (tail) {\n                    return this.parseTypeReferenceTail(errorRecoverySet, minChar, term);\n                }\n                else {\n                    return term;\n                }\n            }\n        }\n\n        // REVIEW: Reconsider renaming this to parseType to match the grammar.\n        private parseTypeReference(errorRecoverySet: ErrorRecoverySet, allowVoid: bool): AST {\n            var minChar = this.scanner.startPos;\n            var isConstructorMember = false;\n\n            switch (this.currentToken.tokenId) {\n                case TokenID.Void:\n                    if (!allowVoid) {\n                        this.reportParseError("void not a valid type in this context");\n                    }\n                // Intentional fall-through\n                case TokenID.Any:\n                case TokenID.Number:\n                case TokenID.Bool:\n                case TokenID.String: {\n                    var text = tokenTable[this.currentToken.tokenId].text;\n                    var predefinedIdentifier = new Identifier(text);\n                    predefinedIdentifier.minChar = minChar;\n                    predefinedIdentifier.limChar = this.scanner.pos;\n                    this.currentToken = this.scanner.scan();\n                    return this.parseTypeReferenceTail(errorRecoverySet, minChar, predefinedIdentifier);\n                }\n\n                case TokenID.Identifier:\n                    var ident = this.createRef(this.currentToken.getText(), (<IdentifierToken>this.currentToken).hasEscapeSequence, minChar);\n                    ident.limChar = this.scanner.pos;\n                    return this.parseNamedType(errorRecoverySet, minChar, ident, true);\n\n                case TokenID.OpenBrace:\n                    return this.parseObjectType(minChar, errorRecoverySet);\n\n                case TokenID.New:\n                    this.currentToken = this.scanner.scan();\n                    // can\'t use chkCurrentTok, since we don\'t want to advance the token\n                    if (this.currentToken.tokenId != TokenID.OpenParen) {\n                        this.reportParseError("Expected \'(\'");\n                    }\n                    else {\n                        isConstructorMember = true;\n                        // fall through...\n                    }\n\n                case TokenID.OpenParen: {\n                    // ( formals ) => type\n                    var formals = new ASTList();\n                    var variableArgList =\n                        this.parseFormalParameterList(errorRecoverySet | ErrorRecoverySet.RParen,\n                                            formals, false, true, false, false, false, false, null, true);\n                    this.checkCurrentToken(TokenID.EqualsGreaterThan, errorRecoverySet);\n                    var returnType = this.parseTypeReference(errorRecoverySet, true);\n                    var funcDecl = new FuncDecl(null, null, false, formals, null, null, null,\n                                                NodeType.FuncDecl);\n                    funcDecl.returnTypeAnnotation = returnType;\n                    funcDecl.variableArgList = variableArgList;\n                    funcDecl.fncFlags |= FncFlags.Signature;\n\n                    if (isConstructorMember) {\n                        funcDecl.fncFlags |= FncFlags.ConstructMember;\n                        funcDecl.hint = "_construct";\n                        funcDecl.classDecl = null;\n                    }\n                    funcDecl.minChar = minChar;\n                    return this.parseTypeReferenceTail(errorRecoverySet, minChar, funcDecl);\n                }\n\n                default:\n                    this.reportParseError("Expected type name");\n                    var etr = new TypeReference(null, 0);\n                    etr.flags |= ASTFlags.Error;\n                    etr.minChar = this.scanner.pos;\n                    etr.limChar = this.scanner.pos;\n                    return etr;\n            }\n        }\n\n        private parseObjectType(minChar: number, errorRecoverySet: ErrorRecoverySet): TypeReference {\n            this.currentToken = this.scanner.scan();\n\n            var members = new ASTList();\n            members.minChar = minChar;\n\n            var prevInInter',
v27615=v27616+'faceDecl = this.inInterfaceDecl;\n            this.inInterfaceDecl = true;\n            this.parseTypeMemberList(errorRecoverySet | ErrorRecoverySet.RCurly, members);\n            this.inInterfaceDecl = prevInInterfaceDecl;\n\n            this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n\n            // REVIEW: We\'re parsing an ObjectType, but we give a NodeType of Interface here.\n            var interfaceDecl = new InterfaceDeclaration(\n                this.anonId, members, /*extends:*/ null, /*implementsL*/ null);\n\n            interfaceDecl.minChar = minChar;\n            interfaceDecl.limChar = members.limChar;    // "}"\n\n            return this.parseTypeReferenceTail(errorRecoverySet, minChar, interfaceDecl);\n        }\n\n        private parseFunctionBlock(errorRecoverySet: ErrorRecoverySet,\n                                   allowedElements: AllowedElements,\n                                   parentModifiers: Modifiers,\n                                   bod: ASTList,\n                                   bodMinChar: number): void {\n            this.state = ParseState.StartStatementList;\n            this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet | ErrorRecoverySet.StmtStart);\n            var savedInFunction = this.inFunction;\n            this.inFunction = true;\n            this.parseStatementList(\n                errorRecoverySet | ErrorRecoverySet.RCurly | ErrorRecoverySet.StmtStart,\n                bod, /*sourceElements:*/ true, /*noLeadingCase:*/ false, allowedElements, parentModifiers);\n            bod.minChar = bodMinChar;\n            bod.limChar = this.scanner.pos;\n            this.inFunction = savedInFunction;\n            var ec = new EndCode();\n            ec.minChar = bod.limChar;\n            ec.limChar = ec.minChar;\n            bod.append(ec);\n        }\n\n        private parseFunctionStatements(errorRecoverySet: ErrorRecoverySet,\n                                        name: Identifier,\n                                        isConstructor: bool,\n                                        isMethod: bool,\n                                        args: ASTList,\n                                        allowedElements: AllowedElements,\n                                        minChar: number,\n                                        requiresSignature: bool,\n                                        parentModifiers: Modifiers) {\n\n            this.pushDeclLists();\n            // start new statement stack\n            var svStmtStack = this.statementInfoStack;\n            this.resetStmtStack();\n\n            var bod: ASTList = null;\n            var wasShorthand = false;\n            var isAnonLambda = false;\n            var limChar: number;\n\n            if (requiresSignature) {\n                // If we require a signature, but they provided a block, then give an error, but\n                // still consume the block.\n                limChar = this.scanner.pos;\n                if (this.currentToken.tokenId === TokenID.OpenBrace) {\n                    this.reportParseError("Function declarations are not permitted within interfaces, ambient modules or classes")\n                    bod = new ASTList();\n                    var bodMinChar = this.scanner.startPos;\n\n                    this.parseFunctionBlock(errorRecoverySet, allowedElements, parentModifiers, bod, bodMinChar);\n                    this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n\n                    // If there\'s also a semicolon, then just skip over it.  We don\'t want to report an \n                    // additional error here.\n                    if (this.currentToken.tokenId === TokenID.Semicolon) {\n                        this.currentToken = this.scanner.scan();\n                    }\n                }\n                else {\n                    this.checkCurrentToken(TokenID.Semicolon, errorRecoverySet, "Expected \';\'");\n                }\n            }\n            else {\n                bod = new ASTList();\n                var bodMinChar = this.scanner.startPos;\n                if (this.currentToken.tokenId == TokenID.EqualsGreaterThan) {\n                    if (isMethod) {\n                        this.reportParseError("\'=>\' may not be used for class methods");\n                    }\n                    wasShorthand = true;\n                    this.currentToken = this.scanner.scan();\n                }\n\n                if (wasShorthand && this.currentToken.tokenId != TokenID.OpenBrace) {\n                    var retExpr = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon,\n                                            OperatorPrecedence.Assignment, true,\n                                            TypeContext.NoTypes);\n                    var retStmt = new ReturnStatement();\n                    retStmt.returnExpression = retExpr;\n                    retStmt.minChar = retExpr.minChar;\n                    retStmt.limChar = retExpr.limChar;\n                    bod.minChar = bodMinChar;\n                    bod.append(retStmt);\n ',
v27614=v27615+'               }\n                else {\n                    isAnonLambda = wasShorthand;\n                    this.parseFunctionBlock(errorRecoverySet, allowedElements, parentModifiers, bod, bodMinChar);\n                }\n\n                limChar = this.scanner.pos;\n            }\n\n            var funcDecl = new FuncDecl(name, bod, isConstructor, args, this.topVarList(),\n                                        this.topScopeList(), this.topStaticsList(), NodeType.FuncDecl);\n            this.popDeclLists();\n            var scopeList = this.topScopeList();\n            scopeList.append(funcDecl);\n            var staticFuncDecl = false;\n\n            if (!requiresSignature) {\n                if (!wasShorthand || isAnonLambda) {\n                    funcDecl.endingToken = new ASTSpan();\n                    funcDecl.endingToken.minChar = this.scanner.startPos;\n                    funcDecl.endingToken.limChar = this.scanner.pos;\n                    this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n\n                    if (isAnonLambda) {\n                        funcDecl.fncFlags |= FncFlags.IsFatArrowFunction;\n                    }\n                }\n                else {\n                    funcDecl.fncFlags |= FncFlags.IsFatArrowFunction;\n                    funcDecl.endingToken = new ASTSpan();\n\n                    funcDecl.endingToken.minChar = bod.members[0].minChar;\n                    funcDecl.endingToken.limChar = bod.members[0].limChar;\n                }\n            }\n            funcDecl.minChar = minChar;\n            funcDecl.limChar = limChar;\n\n            if (!requiresSignature) {\n                funcDecl.fncFlags |= FncFlags.Definition;\n            }\n\n            this.statementInfoStack = svStmtStack;\n            return funcDecl;\n        }\n\n        private transformAnonymousArgsIntoFormals(formals: ASTList, argList: AST) : bool {\n\n            var translateBinExOperand = (operand: AST) : bool => {\n                if (operand.nodeType == NodeType.Comma) {\n                    return this.transformAnonymousArgsIntoFormals(formals, operand);\n                }\n                else if (operand.nodeType == NodeType.Name || operand.nodeType == NodeType.Asg) {\n                    var opArg = operand.nodeType == NodeType.Asg ? (<BinaryExpression>operand).operand1 : operand;\n\n                    var arg = new ArgDecl(<Identifier>opArg);\n                    arg.preComments = opArg.preComments;\n                    arg.postComments = opArg.postComments;\n                    arg.minChar = operand.minChar;\n                    arg.limChar = operand.limChar;\n\n                    if (hasFlag(opArg.flags, ASTFlags.PossibleOptionalParameter)) {\n                        arg.isOptional = true;\n                    }\n\n                    if (operand.nodeType == NodeType.Asg) {\n                        arg.init = (<BinaryExpression>operand).operand2;\n                    }\n\n                    formals.append(arg);\n\n                    return arg.isOptional || arg.init;\n                }\n                else {\n                    this.reportParseError("Invalid lambda argument");\n                }\n                return false;\n            }\n\n            if (argList) {\n                if (argList.nodeType == NodeType.Comma) {\n                    var commaList = <BinaryExpression> argList;\n                    if (commaList.operand1.isParenthesized) { \n                        this.reportParseError("Invalid lambda argument", commaList.operand1.minChar, commaList.operand1.limChar);\n                    }\n                    if (commaList.operand2.isParenthesized) { \n                        this.reportParseError("Invalid lambda argument", commaList.operand2.minChar, commaList.operand2.limChar);\n                    }\n                    var isOptional = translateBinExOperand(commaList.operand1);\n                    isOptional = translateBinExOperand(commaList.operand2) || isOptional;\n                    return isOptional;\n                }\n                else {\n                    return translateBinExOperand(argList);\n                }\n            }\n        }\n\n        private parseFormalParameterList(errorRecoverySet: ErrorRecoverySet,\n                                            formals: ASTList,\n                                            isClassConstr: bool,\n                                            isSig: bool,\n                                            isIndexer: bool,\n                                            isGetter: bool,\n                                            isSetter: bool,\n                                            isLambda: bool,\n                                            preProcessedLambdaArgs: AST,\n                                            expectClosingRParen: bool): bool \n        {\n\n            formals.minChar = this.scanner.startPos; // \'(\' or \'[\'\n            if (isIndexer) {\n                this.currentToken = this.scanner.scan();\n            }\n            else if (!isLambda) {\n                this.ch',
v27613=v27614+'eckCurrentToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.RParen);\n            }\n            var sawEllipsis = false;\n            var firstArg = true;\n            var hasOptional = false;\n            var haveFirstArgID = false;\n\n            // if preProcessedLambdaArgs is "true", we either have a typeless argument list, or we have\n            // a single identifier node and the current token is the \':\' before a typereference\n            if (isLambda && preProcessedLambdaArgs && preProcessedLambdaArgs.nodeType != NodeType.EmptyExpr) {\n                hasOptional = this.transformAnonymousArgsIntoFormals(formals, preProcessedLambdaArgs);\n                haveFirstArgID = true;\n            }\n\n            while (true) {\n                var munchedArg = false;\n                var argFlags = VarFlags.None;\n                var argMinChar = this.scanner.startPos;\n\n                if (this.inferPropertiesFromThisAssignment && this.currentToken.tokenId == TokenID.This) {\n                    if (!isClassConstr) {\n                        this.reportParseError("Instance property declarations using \'this\' may only be used in class constructors");\n                    }\n                    this.currentToken = this.scanner.scan(); // consume the \'.\'\n\n                    argFlags |= (VarFlags.Public | VarFlags.Property);\n                    if (this.currentClassDefinition) {\n                        this.currentClassDefinition.varFlags |= VarFlags.ClassSuperMustBeFirstCallInConstructor;\n                    }\n                }\n                if (this.currentToken.tokenId == TokenID.Public) {\n                    argFlags |= (VarFlags.Public | VarFlags.Property);\n\n                    if (this.currentClassDefinition) {\n                        this.currentClassDefinition.varFlags |= VarFlags.ClassSuperMustBeFirstCallInConstructor;\n                    }\n                }\n                else if (this.currentToken.tokenId == TokenID.Private) {\n                    argFlags |= (VarFlags.Private | VarFlags.Property);\n\n                    if (this.currentClassDefinition) {\n                        this.currentClassDefinition.varFlags |= VarFlags.ClassSuperMustBeFirstCallInConstructor;\n                    }\n                }\n                else if (this.currentToken.tokenId == TokenID.Static && isClassConstr) {\n                    this.reportParseError("Static properties can not be declared as parameter properties");\n                    this.currentToken = this.scanner.scan();\n                }\n\n                if (argFlags != VarFlags.None) {\n                    if (!isClassConstr) {\n                        this.reportParseError("only constructor parameters can be properties");\n                    }\n                    this.currentToken = this.scanner.scan();\n\n                    if (isModifier(this.currentToken)) { \n                        this.reportParseError("Multiple modifiers may not be applied to parameters");\n                        this.currentToken = this.scanner.scan();\n                    }\n\n                    if (this.inferPropertiesFromThisAssignment && this.currentToken.tokenId == TokenID.This) {\n                        if (!isClassConstr) {\n                            this.reportParseError("Instance property declarations using \'this\' may only be used in class constructors");\n                        }\n                        this.currentToken = this.scanner.scan(); // consume the \'.\'\n                        this.currentToken = this.scanner.scan();\n                    }\n                }\n                else if (this.currentToken.tokenId == TokenID.DotDotDot) {\n                    sawEllipsis = true;\n                    this.currentToken = this.scanner.scan();\n\n                    if (!(this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                        this.reportParseError("\'...\' parameters require both a parameter name and an array type annotation to be specified");\n                        sawEllipsis = false; // Do not treat this parameter as vararg\n                    }\n                }\n\n                var argId: Identifier = null;\n\n                if (!haveFirstArgID && (this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                    argId = Identifier.fromToken(this.currentToken);\n                    argId.minChar = this.scanner.startPos;\n                    argId.limChar = this.scanner.pos;\n                }\n\n                if (haveFirstArgID || argId) {\n                    munchedArg = true;\n                    var type: AST = null;\n                    var arg: ArgDecl = null;\n\n                    if (haveFirstArgID && formals.members.length) {\n                        arg = <ArgDecl>formals.members[formals.members.length - 1];\n\n                        if (arg.isOptional) {\n                            hasOptional = true;\n                        }\n                    }\n         ',
v27612=v27613+'           else {\n                        arg = new ArgDecl(argId);\n\n                        if (isGetter) {\n                            this.reportParseError("Property getters may not take any arguments");\n                        }\n\n                        if (isSetter && !firstArg) {\n                            this.reportParseError("Property setters may only take one argument");\n                        }\n\n                        arg.minChar = argMinChar;\n                        arg.preComments = this.parseComments();\n                        this.currentToken = this.scanner.scan();\n                    }\n\n                    if (this.currentToken.tokenId == TokenID.Question) {\n                        arg.isOptional = true;\n                        hasOptional = true;\n                        this.currentToken = this.scanner.scan();\n                    }\n\n                    if (this.currentToken.tokenId == TokenID.Colon) {\n                        this.currentToken = this.scanner.scan();\n                        type = this.parseTypeReference(errorRecoverySet, false);\n                    }\n\n                    // check for default parameter\n                    // REVIEW: In the case of a typed reference, assume that parseTypeReference or one\n                    // of its children in the call graph advanced tok\n                    if (this.currentToken.tokenId == TokenID.Equals) {\n                        if (isSig) {\n                            this.reportParseError("Arguments in signatures may not have default values");\n                        }\n\n                        hasOptional = true;\n                        this.currentToken = this.scanner.scan();\n                        arg.init = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                            OperatorPrecedence.Comma, false,\n                                            TypeContext.NoTypes);\n\n                    }\n\n                    if (hasOptional && !arg.isOptionalArg() && !sawEllipsis) {\n                        this.reportParseError("Optional parameters may only be followed by other optional parameters");\n                    }\n\n                    if (sawEllipsis && arg.isOptionalArg()) {\n                        this.reportParseError("Varargs may not be optional or have default parameters");\n                    }\n\n                    if (sawEllipsis && !type) {\n                        // Ellipsis is missing a type definition\n                        this.reportParseError("\'...\' parameters require both a parameter name and an array type annotation to be specified");\n                    }\n\n                    // REVIEW: Ok for lambdas?\n                    arg.postComments = this.parseComments();\n                    arg.typeExpr = type;\n                    arg.limChar = this.scanner.lastTokenLimChar();\n                    arg.varFlags |= argFlags;\n                    if (!haveFirstArgID) {\n                        formals.append(arg);\n                    }\n                    else {\n                        haveFirstArgID = false;\n                    }\n                }\n                firstArg = false;\n                if (this.currentToken.tokenId == TokenID.Comma) {\n                    if ((munchedArg) && (!sawEllipsis)) {\n                        this.currentToken = this.scanner.scan();\n                        continue;\n                    }\n                    else {\n                        this.reportParseError("Unexpected \',\' in argument list");\n                        if (this.errorRecovery) {\n                            this.currentToken = this.scanner.scan();\n                            continue;\n                        }\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n\n            if (isIndexer) {\n                this.checkCurrentToken(TokenID.CloseBracket, errorRecoverySet | ErrorRecoverySet.LCurly | ErrorRecoverySet.SColon);\n            }\n            else if (expectClosingRParen) {\n                this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.LCurly | ErrorRecoverySet.SColon);\n            }\n            formals.limChar = this.scanner.lastTokenLimChar(); // \')\' or \']\'\n            return sawEllipsis;\n        }\n\n        private parseFncDecl(errorRecoverySet: ErrorRecoverySet,\n                             isDecl: bool,\n                             requiresSignature: bool,\n                             isMethod: bool,\n                             methodName: Identifier,\n                             indexer: bool,\n                             isStatic: bool,\n                             markedAsAmbient: bool,\n                             modifiers: Modifiers,\n                             lambdaArgContext: ILambdaArgumentContext,\n                             expectClosingRParen: bool): AST {\n\n            var leftCurlyCount = this.scanner.leftCurlyCount;\n            var rightCurlyCount = this.scanner.rightCurlyC',
v27611=v27612+'ount;\n\n            var prevInConstr = this.parsingClassConstructorDefinition;\n            this.parsingClassConstructorDefinition = false;\n\n            var name: Identifier = null;\n            var fnMin = this.scanner.startPos;\n            var minChar = this.scanner.pos;\n            var prevNestingLevel = this.nestingLevel;\n            var preComments = this.parseComments();\n            var isLambda = !!lambdaArgContext;\n            this.nestingLevel = 0;\n            if ((!this.style_funcInLoop) && this.inLoop()) {\n                this.reportParseStyleError("function declaration in loop");\n            }\n            if (!isMethod && !isStatic && !indexer && !lambdaArgContext) {\n                // past function keyword\n                this.currentToken = this.scanner.scan();\n                this.state = ParseState.StartFncDecl;\n                if ((this.currentToken.tokenId != TokenID.Identifier) && (!convertTokToID(this.currentToken, this.strictMode))) {\n                    if (isDecl) {\n                        this.reportParseError("Function declaration must include identifier");\n\n                        this.nestingLevel = prevNestingLevel;\n                        return new IncompleteAST(fnMin, this.scanner.pos);\n                    }\n                }\n                else {\n                    name = Identifier.fromToken(this.currentToken);\n                    name.minChar = this.scanner.startPos;\n                    name.limChar = this.scanner.pos;\n                    this.currentToken = this.scanner.scan();\n                }\n            }\n            else {\n                if (methodName) {\n                    name = methodName;\n                }\n            }\n\n            this.state = ParseState.FncDeclName;\n            var args: ASTList = new ASTList();\n            var variableArgList = false;\n            var isOverload = false;\n            var isGetter = hasFlag(modifiers, Modifiers.Getter);\n            var isSetter = hasFlag(modifiers, Modifiers.Setter);\n            if ((this.currentToken.tokenId == TokenID.OpenParen) || (indexer && (this.currentToken.tokenId == TokenID.OpenBracket)) || (lambdaArgContext && (lambdaArgContext.preProcessedLambdaArgs || this.currentToken.tokenId == TokenID.DotDotDot))) {\n                // arg list\n                variableArgList = this.parseFormalParameterList(errorRecoverySet, args, false, requiresSignature, indexer, isGetter, isSetter, isLambda, lambdaArgContext ? lambdaArgContext.preProcessedLambdaArgs : null, expectClosingRParen);\n            }\n            this.state = ParseState.FncDeclArgs;\n            var returnType: AST = null;\n            if (this.currentToken.tokenId == TokenID.Colon) {\n                this.currentToken = this.scanner.scan();\n                if (hasFlag(modifiers, Modifiers.Setter)) {\n                    this.reportParseError("Property setters may not declare a return type");\n                }\n                returnType = this.parseTypeReference(errorRecoverySet, true);\n            }\n\n            if (indexer && args.members.length == 0) {\n                this.reportParseError("Index signatures require a parameter type to be specified");\n            }\n            this.state = ParseState.FncDeclReturnType;\n\n            if (isLambda && this.currentToken.tokenId != TokenID.EqualsGreaterThan) {\n                this.reportParseError("Expected \'=>\'");\n            }\n\n            // REVIEW:\n            // Currently, it\'s imperative that ambient functions *not* be marked as overloads.  At some point, we may\n            // want to unify the two concepts internally\n            if (isDecl && !(this.parsingDeclareFile || markedAsAmbient) && (!isMethod || !(this.ambientModule || this.ambientClass || this.inInterfaceDecl)) && this.currentToken.tokenId == TokenID.Semicolon) {\n                isOverload = true;\n                isDecl = false;\n                requiresSignature = true;\n            }\n            var svInFncDecl = this.inFncDecl;\n            this.inFncDecl = true;\n            var funcDecl: FuncDecl =\n                this.parseFunctionStatements(\n                errorRecoverySet | ErrorRecoverySet.RCurly,\n                name, /*isConstructor:*/ false, isMethod, args, AllowedElements.None,\n                minChar, requiresSignature, Modifiers.None);\n\n            this.inFncDecl = svInFncDecl;\n            funcDecl.variableArgList = variableArgList;\n            funcDecl.isOverload = isOverload;\n\n            if (!requiresSignature) { // REVIEW: What\'s the point of this?  Why not just use \'Signature\' instead of \'Definition\'?\n                funcDecl.fncFlags |= FncFlags.Definition;\n            }\n\n            if (isStatic) {\n                funcDecl.fncFlags |= FncFlags.Static;\n            }\n\n            if (requiresSignature) {\n                funcDecl.fncFlags |= FncFlags.Signature;\n            }\n            if (indexer) {\n                funcDecl.fncFlags |= FncFlags.IndexerMember;\n            }\n            funcDecl.returnTypeAnnotation = returnType;',
v27610=v27611+'\n            if (isMethod) {\n                funcDecl.fncFlags |= FncFlags.Method;\n                // all class property methods are currently exported\n                funcDecl.fncFlags |= FncFlags.ClassPropertyMethodExported;\n            }\n            funcDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n            funcDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n\n            this.nestingLevel = prevNestingLevel;\n            this.parsingClassConstructorDefinition = prevInConstr;\n            funcDecl.preComments = preComments;\n            return funcDecl;\n        }\n\n        private convertToTypeReference(ast: AST): TypeReference {\n            var result: TypeReference;\n            switch (ast.nodeType) {\n                case NodeType.TypeRef:\n                    return <TypeReference>ast;\n                case NodeType.Name:\n                    result = new TypeReference(ast, 0);\n                    result.minChar = ast.minChar;\n                    result.limChar = ast.limChar;\n                    return result;\n                case NodeType.Index: {\n                    var expr = <BinaryExpression>ast;\n                    result = this.convertToTypeReference(expr.operand1);\n                    if (result) {\n                        result.arrayCount++;\n                        result.minChar = expr.minChar;\n                        result.limChar = expr.limChar;\n                        return result;\n                    }\n                    else {\n                        var etr = <TypeReference>new AST(NodeType.Error);\n                        return etr;\n                    }\n                }\n            }\n            return null;\n        }\n\n        private parseArgList(errorRecoverySet: ErrorRecoverySet): ASTList {\n            var args: ASTList = new ASTList();\n            args.minChar = this.scanner.startPos;\n\n            // skip left paren\n            this.currentToken = this.scanner.scan();\n\n            if (this.currentToken.tokenId !== TokenID.CloseParen) {\n                while (true) {\n                    if (args.members.length > 0xffff) {\n                        this.reportParseError("max number of args exceeded");\n                        break;\n                    }\n\n                    var arg = this.parseExpr(\n                        ErrorRecoverySet.Comma | errorRecoverySet,\n                        OperatorPrecedence.Comma, \n                        /*allowIn:*/ true,\n                        TypeContext.NoTypes);\n\n                    args.append(arg);\n                    if (this.currentToken.tokenId != TokenID.Comma) {\n                        break;\n                    }\n\n                    this.currentToken = this.scanner.scan();\n                }\n            }\n\n            args.limChar = this.scanner.pos;\n            return args;\n        }\n\n        private parseBaseList(extendsList: ASTList,\n                              implementsList: ASTList,\n                              errorRecoverySet: ErrorRecoverySet,\n                              isClass: bool): void {\n            var keyword = true;\n            var currentList = extendsList;\n            for (; ;) {\n                if (keyword) {\n                    if (this.currentToken.tokenId === TokenID.Implements) {\n                        currentList = implementsList;\n                    }\n                    else if (this.currentToken.tokenId == TokenID.Extends && !this.requiresExtendsBlock) {\n                        this.requiresExtendsBlock = isClass;\n                    }\n                    this.currentToken = this.scanner.scan();\n                    keyword = false;\n                }\n                var baseName: Identifier = null;\n                if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                    var minChar = this.scanner.startPos;\n                    baseName = Identifier.fromToken(this.currentToken);\n                    baseName.minChar = minChar;\n                    baseName.limChar = this.scanner.pos;\n                    baseName = <Identifier>this.parseNamedType(errorRecoverySet | ErrorRecoverySet.LCurly,\n                                            minChar, baseName, false);\n                }\n                else {\n                    this.reportParseError("Expected base name");\n                    if (this.errorRecovery) {\n                        baseName = new MissingIdentifier();\n                        baseName.minChar = this.scanner.pos;\n                        baseName.limChar = this.scanner.pos;\n                        baseName.flags |= ASTFlags.Error;\n                    }\n                }\n                if (this.currentToken.tokenId == TokenID.OpenParen) {\n                    if (isClass) {\n                        this.reportParseError("Base classes may only be initialized via a \'super\' call within the constructor body");\n                    }\n                    else {\n                        th',
v27609=v27610+'is.reportParseError("Interfaces may not be extended with a call expression");\n                    }\n                }\n                else {\n                    currentList.append(baseName);\n                }\n\n                if (isClass && currentList == extendsList && extendsList.members.length > 1) {\n                    this.reportParseError("A class may only extend one other class");\n                }\n\n                if (this.currentToken.tokenId == TokenID.Comma) {\n                    this.currentToken = this.scanner.scan();\n                    continue;\n                }\n\n                else if ((this.currentToken.tokenId == TokenID.Extends) ||\n                         (this.currentToken.tokenId == TokenID.Implements)) {\n\n                    if (this.currentToken.tokenId == TokenID.Extends && !this.requiresExtendsBlock) {\n                        this.requiresExtendsBlock = isClass;\n                    }\n\n                    currentList = extendsList;\n                    keyword = true;\n                    continue;\n                }\n\n                break;\n            }\n        }\n\n        private parseClassDecl(errorRecoverySet: ErrorRecoverySet, minChar: number, modifiers: Modifiers): ClassDeclaration {\n            var leftCurlyCount = this.scanner.leftCurlyCount;\n            var rightCurlyCount = this.scanner.rightCurlyCount;\n\n            if ((modifiers & Modifiers.Readonly) != Modifiers.None) {\n                this.reportParseError("const modifier is implicit for class");\n            }\n\n            // mark the class as ambient, as necessary\n            if (this.parsingDeclareFile || this.ambientModule) {\n                modifiers |= Modifiers.Ambient;\n                modifiers |= Modifiers.Exported;\n            }\n            var classIsMarkedAsAmbient = this.parsingDeclareFile || (modifiers & Modifiers.Ambient) != Modifiers.None;\n            var svAmbientClass = this.ambientClass;\n            this.ambientClass = classIsMarkedAsAmbient;\n\n            // grab the class\'s name\n            this.currentToken = this.scanner.scan();\n            var name: Identifier = null;\n            if ((this.currentToken.tokenId == TokenID.Identifier) || (!isPrimitiveTypeToken(this.currentToken) && convertTokToID(this.currentToken, this.strictMode)) ) {\n                name = Identifier.fromToken(this.currentToken);\n                name.minChar = this.scanner.startPos;\n                name.limChar = this.scanner.pos;\n                this.currentToken = this.scanner.scan();\n            }\n            else {\n                this.reportParseError("class missing name");\n                if (this.errorRecovery) {\n                    name = new MissingIdentifier();\n                    name.minChar = this.scanner.pos;\n                    name.limChar = this.scanner.pos;\n                    name.flags |= ASTFlags.Error;\n                }\n            }\n\n            var extendsList: ASTList = null;\n            var implementsList: ASTList = null;\n            var requiresSignature = false;\n\n            if ((this.currentToken.tokenId == TokenID.Extends) ||\n                (this.currentToken.tokenId == TokenID.Implements)) {\n                extendsList = new ASTList();\n                implementsList = new ASTList();\n                this.parseBaseList(extendsList, implementsList, errorRecoverySet, /*isClass:*/ true);\n            }\n\n            // REVIEW: Note that we don\'t set this as the current class decl\n            var classDecl = new ClassDeclaration(name, new ASTList(), extendsList, implementsList);\n\n            this.currentClassDefinition = classDecl;\n\n            // parse the classes members\n            this.parseClassElements(classDecl, errorRecoverySet, modifiers);\n\n            if (this.ambientModule || this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Exported)) {\n                classDecl.varFlags |= VarFlags.Exported;\n            }\n\n            if (this.ambientModule || hasFlag(modifiers, Modifiers.Ambient)) {\n                classDecl.varFlags |= VarFlags.Ambient;\n            }\n\n            classDecl.varFlags |= VarFlags.Class;\n\n            this.ambientClass = svAmbientClass;\n            classDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n            classDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n            return classDecl;\n        }\n\n        private parseClassElements(classDecl: ClassDeclaration, errorRecoverySet: ErrorRecoverySet, parentModifiers: Modifiers) {\n            var modifiers = parentModifiers;\n            var resetModifiers = false;\n\n            var membersMinChar = this.scanner.startPos;\n            this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet);\n\n            this.nestingLevel++;\n\n            var currentMemberMinChar = this.scanner.startPos;\n            var wasGetOrSetId = false;\n\n            while (!(this.currentToken.tokenId == TokenID.CloseBrace || this.currentToken.tokenId == TokenID.EndOfFile)) {\n                var scanNext = true;',
v27608=v27609+'\n                var publicOrPrivateFlags = Modifiers.Public | Modifiers.Private;\n\n                // modifiers\n                if (this.currentToken.tokenId == TokenID.Get) {\n                    if (modifiers & Modifiers.Getter) {\n                        this.reportParseError("Duplicate \'get\' declaration in class body");\n                    }\n                    if (modifiers & Modifiers.Setter) {\n                        this.reportParseError("Getter already marked as a setter");\n                    }\n                    modifiers |= Modifiers.Getter;\n                }\n                else if (this.currentToken.tokenId == TokenID.Set) {\n                    if (modifiers & Modifiers.Setter) {\n                        this.reportParseError("Duplicate \'set\' declaration in class body");\n                    }\n                    if (modifiers & Modifiers.Getter) {\n                        this.reportParseError("Setter already marked as a getter");\n                    }\n                    modifiers |= Modifiers.Setter;\n\n                }\n                else if (this.currentToken.tokenId == TokenID.Private) {\n                    if (modifiers & publicOrPrivateFlags) {\n                        this.reportParseError("Multiple modifiers may not be applied to class members");\n                    }\n                    modifiers |= Modifiers.Private;\n                }\n                else if (this.currentToken.tokenId == TokenID.Public) {\n                    if (modifiers & publicOrPrivateFlags) {\n                        this.reportParseError("Multiple modifiers may not be applied to class members");\n                    }\n                    modifiers |= Modifiers.Public;\n                }\n                else if (this.currentToken.tokenId == TokenID.Static) {\n                    if (modifiers & Modifiers.Static) { // only check for double instances of static\n                        this.reportParseError("Multiple modifiers may not be applied to class members");\n                    }\n                    modifiers |= Modifiers.Static;\n                }  // constructors\n                else if (this.currentToken.tokenId == TokenID.Constructor) {\n\n                    if (modifiers != parentModifiers) {\n                        this.reportParseError("Constructors may not have modifiers");\n                    }\n\n                    this.parseClassConstructorDeclaration(currentMemberMinChar, errorRecoverySet, modifiers);\n                    scanNext = false; // parsing functions advances the token for us\n                    resetModifiers = true;\n                }  // member declarations\n                else if (wasGetOrSetId || this.currentToken.tokenId == TokenID.Identifier || convertTokToIDName(this.currentToken)) {\n\n                    var idText = wasGetOrSetId ? ((modifiers & Modifiers.Getter) ? "get" : "set") : this.currentToken.getText();\n                    var id = wasGetOrSetId ? new Identifier(idText) : Identifier.fromToken(this.currentToken);\n                    id.minChar = this.scanner.startPos;\n                    id.limChar = this.scanner.pos;\n\n                    // unset the get/set bit, if we\'re using it for an id\n                    if (wasGetOrSetId) {\n                        modifiers = modifiers ^ ((modifiers & Modifiers.Getter) ? Modifiers.Getter : Modifiers.Setter);\n                        wasGetOrSetId = false;\n                    }\n                    else {\n                        this.currentToken = this.scanner.scan();\n                    }\n\n                    if (this.currentToken.tokenId == TokenID.OpenParen) {\n                        this.parseClassMemberFunctionDeclaration(id, currentMemberMinChar, errorRecoverySet, modifiers);\n                        scanNext = false; // parsing functions advances the token for us\n                    }\n                    else {\n                        if (modifiers & Modifiers.Getter || modifiers & Modifiers.Setter) {\n                            this.reportParseError("Property accessors must be functions");\n                        }\n\n                        var varDecl = this.parseClassMemberVariableDeclaration(id, currentMemberMinChar, false, errorRecoverySet, modifiers);\n\n                        if (varDecl.init && varDecl.init.nodeType == NodeType.FuncDecl) {\n                            if (this.currentToken.tokenId == TokenID.CloseBrace) {\n                                scanNext = false;\n                            }\n                        }\n                        else if (varDecl.init && varDecl.init.nodeType == NodeType.ObjectLit && this.currentToken.tokenId != TokenID.Semicolon) {\n                            scanNext = false;\n                            varDecl.init.flags |= ASTFlags.AutomaticSemicolon;\n                        }\n                        else if (this.currentToken.tokenId != TokenID.Semicolon) {\n                            this.reportParseError("Expected \';\'");\n                            scanNext = false;\n                        }',
v27607=v27608+"\n                    }\n\n                    resetModifiers = true;\n                } // catch errant uses of 'super'\n                else if (this.currentToken.tokenId == TokenID.Super) {\n                    this.reportParseError(\"Base class initializers must be the first statement in a class definition\");\n                }\n                else if (!wasGetOrSetId && ((modifiers & Modifiers.Getter) || (modifiers & Modifiers.Setter)) &&\n                         ((this.currentToken.tokenId == TokenID.OpenParen) || (this.currentToken.tokenId == TokenID.Equals) ||\n                          (this.currentToken.tokenId == TokenID.Colon) || (this.currentToken.tokenId == TokenID.Semicolon))) {\n                             // catch a 'get' or 'set' used as an identifier\n                    wasGetOrSetId = true;\n                    scanNext = false;\n\n                }  // mark anything else as an error\n                else if (this.currentToken.tokenId != TokenID.Semicolon) { // jettison semicolons\n                    this.reportParseError(\"Unexpected '\" + this.currentToken.getText() + \"' in class definition\");\n                    resetModifiers = true;\n                }\n\n                if (scanNext) {\n                    this.currentToken = this.scanner.scan();\n                }\n\n                if (resetModifiers) {\n                    modifiers = parentModifiers;\n                    currentMemberMinChar = this.scanner.startPos;\n                    resetModifiers = false;\n                }\n            }\n\n            var membersLimChar = this.scanner.pos;\n            if (this.currentToken.tokenId == TokenID.CloseBrace) {\n                classDecl.endingToken = new ASTSpan();\n                classDecl.endingToken.minChar = this.scanner.startPos;\n                classDecl.endingToken.limChar = this.scanner.pos;\n\n                // for a class with an empty body, consume any 'dangling' inner comments\n                if (!this.currentClassDefinition.members.members.length) {\n                    this.currentClassDefinition.preComments = this.parseComments();\n                }\n\n                this.currentToken = this.scanner.scan();\n            }\n\n            this.nestingLevel--;\n\n            this.currentClassDefinition.members.minChar = membersMinChar;\n            this.currentClassDefinition.members.limChar = membersLimChar;\n            this.currentClassDefinition.limChar = membersLimChar;\n            this.currentClassDefinition = null;\n        }\n\n        private parseClassConstructorDeclaration(minChar: number, errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers) {\n            this.parsingClassConstructorDefinition = true;\n\n            var isAmbient = this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient);\n\n            var args: ASTList = new ASTList();\n            var variableArgList = false;\n            var preComments = this.parseComments();\n\n            this.currentToken = this.scanner.scan(); // scan past the 'constructor' token\n\n            if (this.currentToken.tokenId == TokenID.OpenParen) {\n                variableArgList = this.parseFormalParameterList(errorRecoverySet, args, true, isAmbient, false, false, false, false, null, true);\n                if (args.members.length > 0) {\n                    var lastArg = args.members[args.members.length - 1];\n                }\n            }\n\n            var requiresSignature = isAmbient || this.currentToken.tokenId == TokenID.Semicolon;\n\n\n            if (requiresSignature) {\n                for (var i = 0; i < args.members.length; i++) {\n                    var arg = <ArgDecl> args.members[i];\n                    if (hasFlag(arg.varFlags, VarFlags.Property)) {\n                        this.reportParseError(\"Overload or ambient signatures may not specify parameter properties\", arg.minChar, arg.limChar);\n                    }\n                }\n            }\n\n            if (!requiresSignature) {\n                this.currentClassDefinition.constructorNestingLevel = this.nestingLevel + 1;\n            }\n\n            var constructorFuncDecl = this.parseFunctionStatements(\n                errorRecoverySet | ErrorRecoverySet.RCurly, this.currentClassDefinition.name, \n                /*isConstructor:*/ true, /*isMethod:*/ false, args, AllowedElements.Properties, \n                minChar, requiresSignature, modifiers);\n\n            constructorFuncDecl.preComments = preComments;\n\n            if (requiresSignature && !isAmbient) {\n                constructorFuncDecl.isOverload = true;\n            }\n\n            constructorFuncDecl.variableArgList = variableArgList;\n            this.currentClassDecl = null;\n            constructorFuncDecl.returnTypeAnnotation = this.convertToTypeReference(this.currentClassDefinition.name);\n            constructorFuncDecl.classDecl = this.currentClassDefinition;\n\n            if (isAmbient) {\n                constructorFuncDecl.fncFlags |= FncFlags.Ambient;\n            }\n\n            if (requiresSignature) {\n                constructorF",
v27606=v27607+'uncDecl.fncFlags |= FncFlags.Signature;\n            }\n\n            if (this.ambientModule || hasFlag(modifiers, Modifiers.Exported)) {\n                constructorFuncDecl.fncFlags |= FncFlags.Exported;\n            }\n\n\n            if (this.currentClassDefinition.constructorDecl) {\n                if (!isAmbient && !this.currentClassDefinition.constructorDecl.isSignature() && !constructorFuncDecl.isSignature()) {\n                    this.reportParseError("Duplicate constructor definition");\n                }\n            }\n\n            if (isAmbient || !constructorFuncDecl.isSignature()) {\n                this.currentClassDefinition.constructorDecl = constructorFuncDecl;\n            }\n\n            // REVIEW: Should we have a separate flag for class constructors?  (Constructors are not methods)\n            constructorFuncDecl.fncFlags |= FncFlags.ClassMethod;\n\n            this.currentClassDefinition.members.members[this.currentClassDefinition.members.members.length] = constructorFuncDecl;\n\n            this.parsingClassConstructorDefinition = false;\n\n            return constructorFuncDecl;\n        }\n\n        private parseClassMemberVariableDeclaration(text: Identifier, minChar: number, isDeclaredInConstructor: bool, errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers) {\n\n            var varDecl = new VarDecl(text, this.nestingLevel);\n            varDecl.minChar = minChar;\n            var isStatic = false;\n            varDecl.preComments = this.parseComments();\n\n            if (this.currentToken.tokenId == TokenID.Colon) {\n                this.currentToken = this.scanner.scan();\n                varDecl.typeExpr =\n                    this.parseTypeReference(errorRecoverySet | ErrorRecoverySet.Asg | ErrorRecoverySet.Comma, false);\n                if (varDecl.typeExpr && varDecl.typeExpr.nodeType == NodeType.TypeRef) {\n                    var typeExpr = (<TypeReference>varDecl.typeExpr);\n                    if (typeExpr.term && typeExpr.term.nodeType == NodeType.FuncDecl) {\n                        typeExpr.term.preComments = varDecl.preComments;\n                    }\n                }\n            }\n\n            if (this.currentToken.tokenId == TokenID.Equals) {\n                if (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)) {\n                    this.reportParseError("context does not permit variable initializer");\n                    if (this.errorRecovery) {\n                        this.skip(errorRecoverySet);\n                        varDecl.flags |= ASTFlags.Error;\n                        varDecl.limChar = this.scanner.lastTokenLimChar();\n                        return varDecl;\n                    }\n                }\n\n                // TODO: note assignment for language service\n                this.currentToken = this.scanner.scan();\n\n                varDecl.init = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                        OperatorPrecedence.Comma, true, TypeContext.NoTypes);\n\n                varDecl.limChar = varDecl.init.limChar;\n\n                // member initializers on instance properties require that super be invoked as the first call within the constructor\n                if (!(modifiers & Modifiers.Static)) {\n                    this.currentClassDefinition.varFlags |= VarFlags.ClassSuperMustBeFirstCallInConstructor;\n                }\n            }\n            else {\n                varDecl.limChar = this.scanner.pos;\n            }\n\n            if (modifiers & Modifiers.Static) {\n                varDecl.varFlags |= VarFlags.Static;\n                isStatic = true;\n            }\n\n            if ((modifiers & Modifiers.Private) != Modifiers.None) {\n                varDecl.varFlags |= VarFlags.Private;\n            }\n            else {\n                varDecl.varFlags |= VarFlags.Public;\n            }\n\n            varDecl.varFlags |= VarFlags.Property;\n\n            if (isDeclaredInConstructor) {\n                varDecl.varFlags |= VarFlags.ClassConstructorProperty;\n            }\n\n            if (!isDeclaredInConstructor && !isStatic) {\n                varDecl.varFlags |= VarFlags.ClassBodyProperty;\n            }\n\n            this.currentClassDefinition.knownMemberNames[text.actualText] = true;\n\n            if (!isDeclaredInConstructor) {\n                this.currentClassDefinition.members.members[this.currentClassDefinition.members.members.length] = varDecl;\n            }\n\n            varDecl.postComments = this.parseComments();\n            return varDecl;\n        }\n\n        private parseClassMemberFunctionDeclaration(methodName: Identifier, minChar: number, errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers) {\n            var wasAccessorID = this.prevIDTok != null;\n            var isAccessor = hasFlag(modifiers, Modifiers.Getter) || hasFlag(modifiers, Modifiers.Setter);\n            var isStatic = hasFlag(modifiers, Modifiers.Static);\n\n            var isAmbient = this.ambientModule || hasFlag(modifiers, Modifiers.Ambient);\n\n            er',
v27605=v27606+'rorRecoverySet |= ErrorRecoverySet.RParen;\n\n            if (isAccessor && (modifiers & Modifiers.Ambient)) {\n                this.reportParseError("Property accessors may not be declared in ambient classes");\n            }\n\n            // REVIEW: Why bother passing in isAmbient for both requiresSignature and isAmbient?  Shouldn\'t just saying its ambient suffice?\n            var ast: AST = this.parseFncDecl(errorRecoverySet, true, isAmbient, true, methodName, false, isStatic, isAmbient, modifiers, null, true);\n            if (ast.nodeType == NodeType.Error) {\n                return ast;\n            }\n\n            var funcDecl = <FuncDecl>ast;\n\n            funcDecl.minChar = minChar;\n            if (funcDecl.bod !== null)\n                funcDecl.limChar = funcDecl.bod.limChar;\n\n            if (modifiers & Modifiers.Private) {\n                funcDecl.fncFlags |= FncFlags.Private;\n            }\n            else {\n                funcDecl.fncFlags |= FncFlags.Public;\n            }\n\n            if (isStatic) {\n                funcDecl.fncFlags |= FncFlags.Static;\n            }\n\n            if (isAccessor) {\n                // REVIEW: verify return-type annotations and arguments\n                if (hasFlag(modifiers, Modifiers.Getter)) {\n                    funcDecl.fncFlags |= FncFlags.GetAccessor;\n                    funcDecl.hint = "get" + funcDecl.name.actualText;\n                }\n                else {\n                    funcDecl.fncFlags |= FncFlags.SetAccessor;\n                    funcDecl.hint = "set" + funcDecl.name.actualText;\n                }\n                funcDecl.fncFlags |= FncFlags.IsFunctionExpression;\n                if (codeGenTarget < CodeGenTarget.ES5) {\n                    this.reportParseError("Property accessors are only available when targeting ES5 or greater", funcDecl.minChar, funcDecl.limChar);\n                }\n            }\n\n            funcDecl.fncFlags |= FncFlags.ClassMethod;\n\n            this.currentClassDefinition.knownMemberNames[methodName.actualText] = true;\n\n            this.currentClassDefinition.members.members[this.currentClassDefinition.members.members.length] = funcDecl;\n\n            return funcDecl;\n        }\n\n        private parseTypeMember(errorRecoverySet: ErrorRecoverySet): AST {\n            var minChar = this.scanner.startPos;\n\n            var propertyDecl = this.parsePropertyDeclaration(\n                errorRecoverySet, Modifiers.Public, /*requireSignature:*/ true, /*isStatic:*/ false);\n\n            if (propertyDecl) {\n                propertyDecl.minChar = minChar;\n\n                if (propertyDecl.nodeType == NodeType.VarDecl) {\n                     this.checkCurrentToken(TokenID.Semicolon, errorRecoverySet);\n                }\n            }\n\n            return propertyDecl;\n        }\n\n        private parseTypeMemberList(errorRecoverySet: ErrorRecoverySet, members: ASTList) {\n            errorRecoverySet |= ErrorRecoverySet.TypeScriptS;\n            while (true) {\n                switch (this.currentToken.tokenId) {\n                    case TokenID.CloseBrace:\n                    case TokenID.EndOfFile:\n                        members.limChar = this.scanner.pos;\n                        return;\n                }\n\n                // REVIEW: This code looks suspect.  If parseTypeMember returns null, then \n                // won\'t we just infinite loop?\n                var element = this.parseTypeMember(errorRecoverySet);\n                if (element) {\n                    members.append(element);\n                }\n            }\n        }\n\n        private parseInterfaceDecl(errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers): InterfaceDeclaration {\n            var leftCurlyCount = this.scanner.leftCurlyCount;\n            var rightCurlyCount = this.scanner.rightCurlyCount;\n\n            this.currentToken = this.scanner.scan();\n            var minChar = this.scanner.pos;\n            var name: Identifier = null;\n            if ((this.currentToken.tokenId == TokenID.Identifier) || (!isPrimitiveTypeToken(this.currentToken) && convertTokToID(this.currentToken, this.strictMode))) {\n                name = Identifier.fromToken(this.currentToken);\n                name.minChar = this.scanner.startPos;\n                name.limChar = this.scanner.pos;\n                this.currentToken = this.scanner.scan();\n            }\n            else {\n                this.reportParseError("interface missing name");\n                if (this.errorRecovery) {\n                    name = new MissingIdentifier();\n                    name.minChar = this.scanner.pos;\n                    name.limChar = this.scanner.pos;\n                    name.flags |= ASTFlags.Error;\n                }\n            }\n\n            var extendsList: ASTList = null;\n            var implementsList: ASTList = null;\n            if (this.currentToken.tokenId === TokenID.Extends || this.currentToken.tokenId === TokenID.Implements) {\n                if (this.currentToken.tokenId === TokenID.Implements) {\n            ',
v27604=v27605+'        this.reportParseError("Expected \'extends\'");\n                }\n\n                extendsList = new ASTList();\n                implementsList = new ASTList();\n                extendsList.minChar = this.scanner.startPos;\n                this.parseBaseList(extendsList, implementsList, errorRecoverySet, /*isClass:*/ false);\n            }\n\n            var membersMinChar = this.scanner.startPos;\n            this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet | ErrorRecoverySet.TypeScriptS);\n            var members = new ASTList();\n            members.minChar = membersMinChar;\n            var prevInInterfaceDecl = this.inInterfaceDecl;\n            this.inInterfaceDecl = true;\n            this.parseTypeMemberList(errorRecoverySet | ErrorRecoverySet.RCurly, members);\n            this.inInterfaceDecl = prevInInterfaceDecl;\n            this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n\n            // REVIEW: According to the grammar, an interface declaration should actually just\n            // have an \'ObjectType\' and not a list of members.  We may want to consider making that\n            // change.  Note: it would mean breaking aparat TypeDecl into InterfaceDeclaration and \n            // ClassDeclaration.\n            var interfaceDecl = new InterfaceDeclaration(name, members, extendsList, null);\n            if (hasFlag(modifiers, Modifiers.Private)) {\n                interfaceDecl.varFlags |= VarFlags.Private;\n            }\n            if (hasFlag(modifiers, Modifiers.Public)) {\n                interfaceDecl.varFlags |= VarFlags.Public;\n            }\n            if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Exported)) {\n                interfaceDecl.varFlags |= VarFlags.Exported;\n            }\n\n            interfaceDecl.limChar = members.limChar;\n            interfaceDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n            interfaceDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n            return interfaceDecl;\n        }\n\n        private makeVarDecl(id: Identifier, nest: number): VarDecl {\n            var varDecl = new VarDecl(id, nest);\n            var currentVarList = this.topVarList();\n            if (currentVarList) {\n                currentVarList.append(varDecl);\n            }\n            return varDecl;\n        }\n\n        private parsePropertyDeclaration(\n            errorRecoverySet: ErrorRecoverySet,\n            modifiers: Modifiers,\n            requireSignature: bool,\n            isStatic: bool): AST {\n\n            var text: Identifier = null;\n            var minChar = this.scanner.startPos;\n            var nameLimChar = minChar;\n            var isNew = false;\n            var isIndexer = false;\n            var wasAccessorID = this.prevIDTok != null;\n            var isAccessor = hasFlag(modifiers, Modifiers.Getter) || hasFlag(modifiers, Modifiers.Setter);\n\n            if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Ambient)) {\n                requireSignature = true;\n            }\n\n            if (this.currentToken.tokenId == TokenID.OpenParen && !wasAccessorID) {\n                if (!requireSignature && !isStatic) {\n                    this.reportParseError("Expected identifier in property declaration");\n                    if (this.errorRecovery) {\n                        this.skip(errorRecoverySet);\n                        //REVIEW: Use something else than "Identifier"?\n                        text = new MissingIdentifier();\n                    }\n                }\n            }\n            else if (this.currentToken.tokenId == TokenID.New) {\n                if (requireSignature) {\n                    this.currentToken = this.scanner.scan();\n                    if (this.currentToken.tokenId == TokenID.OpenParen) {\n                        isNew = true;\n                    }\n                }\n\n                if (!isNew) {\n                    // is identifier\n                    if (!requireSignature) {\n                        this.currentToken = this.scanner.scan();\n                    }\n                    text = new Identifier("new");\n                    text.minChar = this.scanner.pos - 3;\n                    text.limChar = this.scanner.pos;\n                    nameLimChar = this.scanner.pos;\n                }\n            }\n            else if ((this.currentToken.tokenId == TokenID.OpenBracket) && requireSignature) {\n                // indexer signature\n                isIndexer = true;\n                //REVIEW: Should we use a special "compiler reserved" identifier node?\n                text = new Identifier("__item");\n            }\n            else if ((this.currentToken.tokenId != TokenID.Identifier) && (!convertTokToIDName(this.currentToken)) && !wasAccessorID) {\n                this.reportParseError("Expected identifier in property declaration");\n                if (this.errorRecovery) {\n                    var eminChar = this.scanner.startPos;\n             ',
v27603=v27604+'       var curpos = this.scanner.pos;\n                    this.skip(errorRecoverySet & (~ErrorRecoverySet.Comma));\n                    if (this.scanner.pos == curpos) {\n                        // ensure progress\n                        this.currentToken = this.scanner.scan();\n                    }\n\n                    var epd = new VarDecl(new MissingIdentifier(), this.nestingLevel);\n                    epd.flags |= ASTFlags.Error;\n                    epd.minChar = eminChar;\n                    epd.limChar = this.scanner.lastTokenLimChar();\n                    return epd;\n                }\n            }\n            else {\n                if (wasAccessorID) {\n                    text = Identifier.fromToken(this.prevIDTok);\n                    text.minChar = this.scanner.lastTokenLimChar() - 3;\n                    text.limChar = this.scanner.lastTokenLimChar();\n                    nameLimChar = text.limChar;\n\n                    if (codeGenTarget < CodeGenTarget.ES5) {\n                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                    }\n\n                    // this block guards against \'get\' and \'set\' tokens that\n                    // were coerced into identifiers\n                    if (this.currentToken.getText() == text.actualText && this.currentToken != this.prevIDTok) {\n                        this.currentToken = this.scanner.scan();\n                    } // Otherwise, don\'t update the token - we\'re already at \'(\'\n\n                    // reset the previous ID Token\n                    this.prevIDTok = null;\n                }\n                else {\n                    text = Identifier.fromToken(this.currentToken);\n                    text.minChar = this.scanner.startPos;\n                    text.limChar = this.scanner.pos;\n                    nameLimChar = this.scanner.pos;\n                    this.currentToken = this.scanner.scan();\n                }\n            }\n\n            if (this.currentToken.tokenId == TokenID.Question) {\n                if (this.inInterfaceDecl && text) {\n                    text.flags |= ASTFlags.OptionalName;\n                }\n                else {\n                    this.reportParseError("Optional properties may only be declared on interface or object types");\n                }\n                this.currentToken = this.scanner.scan();\n            }\n\n            if ((this.currentToken.tokenId == TokenID.OpenParen) ||\n                (isIndexer && (this.currentToken.tokenId == TokenID.OpenBracket))) {\n                var ers = errorRecoverySet | ErrorRecoverySet.RParen;\n                if (isIndexer) {\n                    ers = errorRecoverySet | ErrorRecoverySet.RBrack;\n                }\n                var ast = this.parseFncDecl(ers, true, requireSignature,\n                                       !this.inFncDecl, text, isIndexer, isStatic, (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)), modifiers, null, true);\n                var funcDecl: FuncDecl;\n                if (ast.nodeType == NodeType.Error) {\n                    return ast;\n                }\n                else {\n                    funcDecl = <FuncDecl>ast;\n                }\n                if (funcDecl.name) {\n                    funcDecl.name.minChar = minChar;\n                    funcDecl.name.limChar = nameLimChar;\n                }\n                if ((modifiers & Modifiers.Public) != Modifiers.None) {\n                    funcDecl.fncFlags |= FncFlags.Public;\n                }\n                if ((modifiers & Modifiers.Private) != Modifiers.None) {\n                    funcDecl.fncFlags |= FncFlags.Private;\n                }\n                if (isStatic) {\n                    funcDecl.fncFlags |= FncFlags.Static;\n                }\n                if (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)) {\n                    funcDecl.fncFlags |= FncFlags.Ambient;\n                }\n                if (isAccessor) {\n                    // REVIEW: verify return-type annotations and arguments\n                    if (hasFlag(modifiers, Modifiers.Getter)) {\n                        funcDecl.fncFlags |= FncFlags.GetAccessor;\n                        funcDecl.hint = "get" + funcDecl.name.actualText;\n                    }\n                    else {\n                        funcDecl.fncFlags |= FncFlags.SetAccessor;\n                        funcDecl.hint = "set" + funcDecl.name.actualText;\n                    }\n                    funcDecl.fncFlags |= FncFlags.IsFunctionExpression;\n\n                    if (modifiers & Modifiers.Ambient) {\n                        this.reportParseError("Property accessors may not be declared in ambient types");\n                    }\n                }\n\n                if (text == null) {\n                    if (isNew) {\n                        funcDecl.fncFlags |= FncFlags.ConstructMember;\n                        funcDecl.hint = "_construct";\n                        funcDecl.classDecl = thi',
v27602=v27603+'s.currentClassDecl;\n                    }\n                    else {\n                        funcDecl.hint = "_call";\n                        funcDecl.fncFlags |= FncFlags.CallMember;\n                    }\n                }\n                return funcDecl;\n            }\n            else {\n                var varDecl = new VarDecl(text, this.nestingLevel);\n                varDecl.preComments = this.parseComments();\n                varDecl.minChar = minChar;\n                if (this.currentToken.tokenId == TokenID.Colon) {\n                    this.currentToken = this.scanner.scan();\n                    varDecl.typeExpr =\n                        this.parseTypeReference(errorRecoverySet | ErrorRecoverySet.Asg |\n                                           ErrorRecoverySet.Comma, false);\n                    if (varDecl.typeExpr && varDecl.typeExpr.nodeType == NodeType.TypeRef) {\n                        var typeExpr = (<TypeReference>varDecl.typeExpr);\n                        if (typeExpr.term && typeExpr.term.nodeType == NodeType.FuncDecl) {\n                            typeExpr.term.preComments = varDecl.preComments;\n                        }\n                    }\n                }\n                if (this.currentToken.tokenId == TokenID.Equals) {\n                    if (requireSignature) {\n                        this.reportParseError("context does not permit variable initializer");\n                        if (this.errorRecovery) {\n                            this.skip(errorRecoverySet);\n                            varDecl.flags |= ASTFlags.Error;\n                            varDecl.limChar = this.scanner.lastTokenLimChar();\n                            return varDecl;\n                        }\n                    }\n                    // TODO: note assignment for language service\n                    this.currentToken = this.scanner.scan();\n                    varDecl.init = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                           OperatorPrecedence.Comma, true, TypeContext.NoTypes);\n                    varDecl.limChar = varDecl.init.limChar;\n                    if (varDecl.init.nodeType == NodeType.FuncDecl) {\n                        var funcDecl = <FuncDecl>varDecl.init;\n                        funcDecl.hint = varDecl.id.text;\n                        funcDecl.boundToProperty = varDecl;\n                    }\n                    else if (isAccessor) {\n                        this.reportParseError("Accessors may only be functions");\n                    }\n                }\n                else {\n                    varDecl.limChar = this.scanner.pos;\n                }\n                if ((modifiers & Modifiers.Readonly) != Modifiers.None) {\n                    varDecl.varFlags |= VarFlags.Readonly;\n                }\n                if (isStatic) {\n                    varDecl.varFlags |= VarFlags.Static;\n                }\n                if ((modifiers & Modifiers.Public) != Modifiers.None) {\n                    varDecl.varFlags |= VarFlags.Public;\n                }\n                if ((modifiers & Modifiers.Private) != Modifiers.None) {\n                    varDecl.varFlags |= VarFlags.Private;\n                }\n                varDecl.varFlags |= VarFlags.Property;\n                return varDecl;\n            }\n        }\n\n        private parseVariableDeclaration(\n            errorRecoverySet: ErrorRecoverySet,\n            modifiers: Modifiers,\n            allowIn: bool,\n            isStatic: bool): AST {\n\n            var isConst = hasFlag(modifiers, Modifiers.Readonly);\n            var minChar = this.scanner.startPos;\n            var varDecl: VarDecl = null;\n            var declList: ASTList = null;\n            var multivar = false;\n\n            this.currentToken = this.scanner.scan();\n            var varDeclPreComments = this.parseComments();\n\n            while (true) {\n                if ((this.currentToken.tokenId != TokenID.Identifier) && (!convertTokToID(this.currentToken, this.strictMode))) {\n                    this.reportParseError("Expected identifier in variable declaration");\n\n                    if (this.errorRecovery) {\n                        varDecl = new VarDecl(new MissingIdentifier(), this.nestingLevel);\n                        varDecl.minChar = minChar;\n                        this.skip(errorRecoverySet);\n                        varDecl.flags |= ASTFlags.Error;\n                        varDecl.limChar = this.scanner.lastTokenLimChar();\n                        return varDecl;\n                    }\n                }\n\n                var varDeclName = Identifier.fromToken(this.currentToken)\n                if (this.strictMode && (varDeclName.text == "eval")) {\n                    this.reportParseError("\'eval\' may not name a variable in strict mode");\n                }\n\n                varDecl = this.makeVarDecl(varDeclName, this.nestingLevel);\n                varDecl.id.minChar = this.scanner.startPos;\n                varDecl.id.limChar = this.scanner.pos;\n  ',
v27601=v27602+'              varDecl.preComments = varDeclPreComments;\n\n                if (isStatic) {\n                    varDecl.varFlags |= VarFlags.Static;\n                }\n                if (hasFlag(modifiers, Modifiers.Readonly)) {\n                    varDecl.varFlags |= VarFlags.Readonly;\n                }\n                if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Ambient)) {\n                    varDecl.varFlags |= VarFlags.Ambient;\n                }\n                if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Exported)) {\n                    varDecl.varFlags |= VarFlags.Exported;\n                }\n                varDecl.minChar = minChar;\n                if (declList) {\n                    declList.append(varDecl);\n                }\n\n                // move past ID; with error recovery need a test \n                this.currentToken = this.scanner.scan();\n                if (this.currentToken.tokenId == TokenID.Colon) {\n                    this.currentToken = this.scanner.scan();\n                    var prevInFncDecl = this.inFncDecl;\n                    this.inFncDecl = false;\n                    varDecl.typeExpr = this.parseTypeReference(\n                        errorRecoverySet | ErrorRecoverySet.Asg | ErrorRecoverySet.Comma, /*allowVoid:*/ false);\n                    this.inFncDecl = prevInFncDecl;\n                }\n\n                if (this.currentToken.tokenId == TokenID.Equals) {\n                    if (hasFlag(varDecl.varFlags, VarFlags.Ambient)) {\n                        this.reportParseError("Ambient variable can not have an initializer");\n                    }\n                    // TODO: note assignment for language service\n                    this.currentToken = this.scanner.scan();\n                    varDecl.init = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                           OperatorPrecedence.Comma, allowIn,\n                                           TypeContext.NoTypes);\n                    varDecl.limChar = varDecl.init.limChar;\n                    if (varDecl.init.nodeType == NodeType.FuncDecl) {\n                        // TODO: use \'as\' operator when can bootstrap\n                        var funcDecl = <FuncDecl>varDecl.init;\n                        funcDecl.hint = varDecl.id.actualText;\n                    }\n                }\n                else {\n                    if (isConst) {\n                        this.reportParseError("const declaration requires initializer");\n                    }\n                    varDecl.limChar = this.scanner.pos;\n                }\n                varDecl.postComments = this.parseCommentsForLine(this.scanner.line);\n\n                if (this.currentToken.tokenId != TokenID.Comma) {\n                    if (declList) {\n                        declList.limChar = varDecl.limChar;\n                        return declList;\n                    }\n                    else {\n                        return varDecl;\n                    }\n                }\n\n                if (!multivar) {\n                    declList = new ASTList();\n                    declList.minChar = varDecl.minChar;\n                    declList.append(varDecl);\n                    multivar = true;\n                }\n\n                this.currentToken = this.scanner.scan();\n                minChar = this.scanner.startPos;\n            }\n        }\n\n        private parseMemberList(errorRecoverySet: ErrorRecoverySet): ASTList {\n            var elements = new ASTList();\n            if (this.currentToken.tokenId == TokenID.CloseBrace) {\n                return elements;\n            }\n\n            var idHint: string = null;\n            var memberName: AST = null;\n            var memberExpr: AST = null;\n            var member: BinaryExpression = null;\n            var minChar = this.scanner.startPos;\n            var isSet = false;\n            var skippedTokenForGetSetId = false;\n            var getSetTok: Token = null;\n            var getSetStartPos = 0;\n            var getSetPos = 0;\n\n            for (; ;) {\n                var accessorPattern = false;\n                if (this.currentToken.tokenId == TokenID.Get || this.currentToken.tokenId == TokenID.Set) {\n                    isSet = this.currentToken.tokenId == TokenID.Set;\n                    getSetTok = this.currentToken;\n                    getSetStartPos = this.scanner.startPos;\n                    getSetPos = this.scanner.pos;\n\n                    this.currentToken = this.scanner.scan();\n\n                    if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToIDName(this.currentToken)) {\n                        idHint = isSet ? "set" : "get";\n                        idHint = idHint + this.currentToken.getText();\n                        memberName = Identifier.fromToken(this.currentToken);\n                        memberName.minChar = this.scanner.startPos;\n                        accessorPattern = true;\n                   ',
v27600=v27601+'     if (codeGenTarget < CodeGenTarget.ES5) {\n                            this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                        }\n                    }\n                    else if (this.currentToken.tokenId != TokenID.Colon) {\n                        this.reportParseError("Expected identifier, string or number as accessor name");\n                    }\n                    else {\n                        skippedTokenForGetSetId = true;\n                        memberName = Identifier.fromToken(getSetTok);\n                        memberName.minChar = getSetStartPos;\n                        memberName.limChar = getSetPos;\n                    }\n                }\n                else if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToIDName(this.currentToken)) {\n                    idHint = this.currentToken.getText();\n                    memberName = Identifier.fromToken(this.currentToken);\n                    memberName.minChar = this.scanner.startPos;\n                    memberName.limChar = this.scanner.pos;\n                }\n                else if (this.currentToken.tokenId == TokenID.StringLiteral) {\n                    idHint = this.currentToken.getText();\n                    memberName = new StringLiteral(idHint);\n                    memberName.minChar = this.scanner.startPos;\n                    memberName.limChar = this.scanner.pos;\n                }\n                    // TODO: allow reserved words\n                else if (this.currentToken.tokenId == TokenID.NumberLiteral) {\n                    var ntok = <NumberLiteralToken>this.currentToken;\n                    idHint = ntok.value.toString();\n                    memberName = new StringLiteral(idHint);\n                    memberName.minChar = this.scanner.startPos;\n                    memberName.limChar = this.scanner.pos;\n                }\n                else {\n                    this.reportParseError("Expected identifier, string or number as member name");\n                    if (this.errorRecovery) {\n                        memberName = new MissingIdentifier();\n                        memberName.minChar = this.scanner.startPos;\n                        memberName.flags |= ASTFlags.Error;\n                        this.skip(errorRecoverySet | ErrorRecoverySet.Comma);\n                        memberName.limChar = this.scanner.lastTokenLimChar();\n                    }\n                }\n\n                if (!skippedTokenForGetSetId) {\n                    this.currentToken = this.scanner.scan();\n                }\n                else {\n                    skippedTokenForGetSetId = false;\n                }\n\n                if (this.currentToken.tokenId == TokenID.Question) {\n                    memberName.flags |= ASTFlags.OptionalName;\n                    this.currentToken = this.scanner.scan();\n                }\n\n                if (accessorPattern) {\n                    var args = new ASTList();\n                    this.parseFormalParameterList(errorRecoverySet | ErrorRecoverySet.RParen,\n                                      args, false, true, false, !isSet, isSet, false, null, true);\n\n                    var funcDecl: FuncDecl =\n                        this.parseFunctionStatements(errorRecoverySet | ErrorRecoverySet.RCurly,\n                                                <Identifier>memberName, false, true, args,\n                                                AllowedElements.None,\n                                                this.scanner.startPos, false, Modifiers.None);\n\n                    if (isSet && funcDecl.returnTypeAnnotation) {\n                        this.reportParseError("Property setters may not declare a return type");\n                    }\n\n                    funcDecl.fncFlags |= isSet ? FncFlags.SetAccessor : FncFlags.GetAccessor;\n                    funcDecl.fncFlags |= FncFlags.IsFunctionExpression;\n                    funcDecl.hint = idHint;\n                    memberExpr = funcDecl;\n                    member = new BinaryExpression(NodeType.Member, memberName, memberExpr);\n                    member.minChar = memberName.minChar;\n                    if (memberExpr.nodeType == NodeType.FuncDecl) {\n                        var funcDecl = <FuncDecl>memberExpr;\n                        funcDecl.hint = idHint;\n                    }\n                }\n                else if (this.currentToken.tokenId == TokenID.Colon) {\n                    this.currentToken = this.scanner.scan();\n                    memberExpr = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                         OperatorPrecedence.Comma, true, TypeContext.NoTypes);\n                    // If the memberExpr is a type reference, we can be certain that it was an\n                    // array type declaraion that lacked a "new".  We can realistically only\n                    // expect call and name ASTs to be the result of this call to parseExpr.\n                   ',
v27599=v27600+" // If it's a constructor without a \"new\", we'll flag it as an invalid\n                    // call site later on.\n                    if (memberExpr.nodeType == NodeType.TypeRef) {\n                        this.reportParseError(\"Expected 'new' on array declaration in member definition\")\n                    }\n                    member = new BinaryExpression(NodeType.Member, memberName, memberExpr);\n                    member.minChar = memberName.minChar;\n                    if (memberExpr.nodeType == NodeType.FuncDecl) {\n                        var funcDecl = <FuncDecl>memberExpr;\n                        funcDecl.hint = idHint;\n                    }\n                }\n                else {\n                    this.reportParseError(\"Expected ':' in member definition\");\n                    if (this.errorRecovery) {\n                        this.skip(errorRecoverySet);\n                        elements.flags |= ASTFlags.Error;\n                        elements.minChar = minChar;\n                        elements.limChar = this.scanner.lastTokenLimChar();\n                        return elements;\n                    }\n                }\n                idHint = null;\n                elements.append(member);\n                member.limChar = this.scanner.lastTokenLimChar();\n                if (this.currentToken.tokenId != TokenID.Comma) {\n                    break;\n                }\n                else {\n                    // munch comma\n                    this.currentToken = this.scanner.scan();\n                }\n\n                // trailing comma allowed\n                if (this.currentToken.tokenId == TokenID.CloseBrace) {\n                    break;\n                }\n            }\n\n            if (member) {\n                elements.limChar = member.limChar;\n            }\n            elements.minChar = minChar;\n            return elements;\n        }\n\n        private parseArrayList(errorRecoverySet: ErrorRecoverySet): ASTList {\n            var elements: ASTList = null;\n            if (this.currentToken.tokenId == TokenID.CloseBracket) {\n                return elements;\n            }\n            else {\n                elements = new ASTList();\n                elements.minChar = this.scanner.startPos;\n            }\n\n            var arg: AST;\n\n            for (; ;) {\n                if ((this.currentToken.tokenId == TokenID.Comma) ||\n                    (this.currentToken.tokenId == TokenID.CloseBracket)) {\n                    arg = new AST(NodeType.EmptyExpr);\n                }\n                else {\n                    arg = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                  OperatorPrecedence.Comma, true, TypeContext.NoTypes);\n                }\n                elements.append(arg);\n                if (this.currentToken.tokenId != TokenID.Comma) {\n                    break;\n                }\n                this.currentToken = this.scanner.scan();\n            }\n            elements.limChar = this.scanner.lastTokenLimChar();\n            return elements;\n        }\n\n        private parseArrayLiteral(errorRecoverySet: ErrorRecoverySet): UnaryExpression {\n            var arrayLiteral: UnaryExpression = null;\n            arrayLiteral = new UnaryExpression(NodeType.ArrayLit,\n                                             this.parseArrayList(errorRecoverySet));\n            return arrayLiteral;\n        }\n\n        private parseTerm(errorRecoverySet: ErrorRecoverySet, allowCall: bool, typeContext: TypeContext, inCast: bool): AST {\n            var ast: AST = null;\n            var sawId = false;\n            var inNew = false;\n            var minChar = this.scanner.startPos;\n            var limChar = this.scanner.pos;\n            var parseAsLambda = false;\n            var expectlambdaRParen = false;\n\n            // keywords first\n            switch (this.currentToken.tokenId) {\n                case TokenID.Number:\n                case TokenID.Bool:\n                case TokenID.Any:\n                case TokenID.String:\n                    var tid = new Identifier(tokenTable[this.currentToken.tokenId].text);\n                    if (hasFlag(typeContext, TypeContext.Primitive)) {\n                        ast = new TypeReference(tid, 0);\n                        sawId = true;\n                    }\n                    else {\n                        ast = tid;\n                        sawId = true;\n                    }\n                    ast.minChar = minChar;\n                    this.currentToken = this.scanner.scan();\n                    limChar = this.scanner.lastTokenLimChar();\n                    break;\n                case TokenID.This:\n                    ast = new AST(NodeType.This);\n                    ast.minChar = minChar;\n                    this.currentToken = this.scanner.scan();\n                    limChar = this.scanner.lastTokenLimChar();\n                    break;\n                case TokenID.Super:\n                    ast = new AST(NodeType.Super);\n                    ast.minChar =",
v27598=v27599+" minChar;\n                    this.currentToken = this.scanner.scan();\n                    limChar = this.scanner.lastTokenLimChar();\n                    break;\n                case TokenID.True:\n                    ast = new AST(NodeType.True);\n                    this.currentToken = this.scanner.scan();\n                    ast.minChar = minChar;\n                    break;\n                case TokenID.False:\n                    ast = new AST(NodeType.False);\n                    this.currentToken = this.scanner.scan();\n                    ast.minChar = minChar;\n                    break;\n                case TokenID.Null:\n                    ast = new AST(NodeType.Null);\n                    this.currentToken = this.scanner.scan();\n                    ast.minChar = minChar;\n                    break;\n                case TokenID.New:\n                    minChar = this.scanner.pos;\n                    this.currentToken = this.scanner.scan();\n                    var target = this.parseTerm(errorRecoverySet, false, TypeContext.AllSimpleTypes, inCast);\n\n                    if (target.nodeType == NodeType.Error || (target.nodeType == NodeType.Index && (<BinaryExpression>target).operand1.nodeType == NodeType.TypeRef)) {\n                        this.reportParseError(\"Cannot invoke 'new' on this expression\");\n                    } else {\n                        ast = new CallExpression(NodeType.New, target, null);\n                        ast.minChar = minChar;\n                        limChar = this.scanner.lastTokenLimChar();\n                        inNew = true;\n                    }\n                    break;\n                case TokenID.Function:\n                    minChar = this.scanner.pos;\n                    ast = this.parseFncDecl(errorRecoverySet, false, false, false, null, false, false, false, Modifiers.None, null, true);\n                    (<FuncDecl>ast).fncFlags |= FncFlags.IsFunctionExpression;\n                    ast.minChar = minChar;\n                    limChar = this.scanner.lastTokenLimChar();\n                    ast.limChar = limChar;\n                    break;\n            }\n\n            if (ast == null) {\n                if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n\n                    var idText = this.currentToken.getText();\n                    ast = this.createRef(idText, (<IdentifierToken>this.currentToken).hasEscapeSequence, minChar);\n                    sawId = true;\n \n                    ast.minChar = minChar;\n                    this.currentToken = this.scanner.scan();\n\n                    if (this.currentToken.tokenId == TokenID.Question) {\n                        ast.flags |= ASTFlags.PossibleOptionalParameter;\n                    }\n\n                    limChar = this.scanner.lastTokenLimChar();\n                }\n            }\n\n            if (inCast) {\n                this.checkCurrentToken(TokenID.GreaterThan, errorRecoverySet);\n            }\n\n            if (ast == null) {\n                switch (this.currentToken.tokenId) {\n                    case TokenID.OpenParen:\n                        minChar = this.scanner.pos;\n                        var prevTokId = this.scanner.previousToken().tokenId;\n                        this.currentToken = this.scanner.scan();\n\n                        var couldBeLambda = prevTokId == TokenID.OpenParen || // foo(()=>{});\n                                            prevTokId == TokenID.Comma || // foo(x,()=>{});\n                                            prevTokId == TokenID.EqualsEquals || // var foo = ()=>{};\n                                            prevTokId == TokenID.Colon;    // var x = { foo: ()=> {} };\n\n\n                        if (couldBeLambda && this.currentToken.tokenId == TokenID.CloseParen) {\n                            parseAsLambda = true;\n                            expectlambdaRParen = false;\n                            this.currentToken = this.scanner.scan();\n                        }\n                        else if (couldBeLambda && this.currentToken.tokenId == TokenID.DotDotDot) {\n                            parseAsLambda = true;\n                            expectlambdaRParen = true;\n                        }\n                        else {\n                            ast = this.parseExpr(errorRecoverySet | ErrorRecoverySet.RParen,\n                                          OperatorPrecedence.None, true, TypeContext.NoTypes, couldBeLambda);\n                            limChar = this.scanner.lastTokenLimChar();\n                            parseAsLambda = couldBeLambda && (ast.nodeType == NodeType.Name || ast.nodeType == NodeType.Comma) &&\n                                            (this.currentToken.tokenId == TokenID.Colon || this.currentToken.tokenId == TokenID.Question);\n                            expectlambdaRParen = true;\n                        }\n\n                        // Check for the RParen if it's not an anonymous '=>' function\n                       ",
v27597=v27598+" if ((ast && !parseAsLambda)) {\n                            if (hasFlag(ast.flags, ASTFlags.SkipNextRParen)) {\n                                // REVIEW: parseExpr resulted in a lambda node, the LParen scanned earlier, is the beginning of that node, and not of a parenthesized expression;\n                                //         do not look for a matching RParen for this node, but make sure to remove the flag, so that any enclosing parenthesis are matched correctly.\n                                ast.flags = ast.flags & (~(ASTFlags.SkipNextRParen)); \n                                break;\n                            }\n                            this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet);\n                            ast.isParenthesized = true;\n                        }\n\n                        break;\n                    case TokenID.NumberLiteral: {\n                        var numTok = <NumberLiteralToken>this.currentToken;\n                        this.currentToken = this.scanner.scan();\n                        ast = new NumberLiteral(numTok.value, numTok.hasEmptyFraction);\n                        ast.minChar = minChar;\n                        limChar = this.scanner.lastTokenLimChar();\n                        break;\n                    }\n                    case TokenID.StringLiteral:\n                        ast = new StringLiteral(this.currentToken.getText());\n                        this.currentToken = this.scanner.scan();\n                        ast.minChar = minChar;\n                        limChar = this.scanner.lastTokenLimChar();\n                        break;\n                    case TokenID.RegularExpressionLiteral: {\n                        var rtok = <RegularExpressionLiteralToken>this.currentToken;\n                        ast = new RegexLiteral(rtok.regex);\n                        this.currentToken = this.scanner.scan();\n                        ast.minChar = minChar;\n                        limChar = this.scanner.lastTokenLimChar();\n                        break;\n                    }\n                    case TokenID.OpenBracket:\n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        ast = this.parseArrayLiteral(ErrorRecoverySet.RBrack | errorRecoverySet);\n                        ast.minChar = minChar;\n                        limChar = this.scanner.pos; // ']'\n                        this.checkCurrentToken(TokenID.CloseBracket, errorRecoverySet);\n                        break;\n                    // TODO: rescan regex for TokenID.Div and AsgDiv\n                        case TokenID.OpenBrace:\n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        var members = this.parseMemberList(ErrorRecoverySet.RCurly | errorRecoverySet)\n                        this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n                        ast = new UnaryExpression(NodeType.ObjectLit, members);\n                        ast.minChar = minChar;\n                        limChar = this.scanner.lastTokenLimChar();\n                        members.minChar = minChar;\n                        members.limChar = limChar;\n                        break;\n\n                    case TokenID.LessThan:\n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        var term: AST = this.parseTypeReference(ErrorRecoverySet.BinOp, false);\n                        this.checkCurrentToken(TokenID.GreaterThan, errorRecoverySet);\n                        ast = new UnaryExpression(NodeType.TypeAssertion, this.parseExpr(errorRecoverySet, OperatorPrecedence.Unary, false, TypeContext.NoTypes));\n                        (<UnaryExpression>ast).castTerm = term;\n                        break;\n\n                    default:\n                        if (this.prevExpr && hasFlag(this.prevExpr.flags, ASTFlags.PossibleOptionalParameter)) {\n                            parseAsLambda = true;\n                            ast = this.prevExpr;\n                        }\n                        else {\n                            this.reportParseError(\"Check format of expression term\");\n                            if (this.errorRecovery) {\n                                var ident = new MissingIdentifier();\n                                ident.minChar = minChar;\n                                ident.flags |= ASTFlags.Error;\n                                this.skip(errorRecoverySet | ErrorRecoverySet.Postfix);\n                                if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                                    ident.setText(this.currentToken.getText(), (<IdentifierToken>this.currentToken).hasEscapeSequence);\n                                    this.currentToken = this.scanner.scan();\n                       ",
v27596=v27597+'             limChar = this.scanner.lastTokenLimChar();\n                                }\n                                else {\n                                    limChar = this.scanner.lastTokenLimChar();\n                                    //tok=scanner.scan();\n                                }\n\n                                // REVIEW: set sawId\n                                ast = ident;\n                            }\n                        }\n                }\n            }\n\n            if (parseAsLambda) {\n                // If the next token is an fat arrow or a colon, we either have a parameter list, or can rightly assume\n                // that we have a typed formal, so we proceed with the lambda parse\n                if (\n                    this.currentToken.tokenId == TokenID.Colon ||\n                    this.currentToken.tokenId == TokenID.Comma ||\n                    this.currentToken.tokenId == TokenID.CloseParen ||\n                    this.currentToken.tokenId == TokenID.DotDotDot) {\n\n                        // We won\'t scan in the \':\' case, since keeping the \':\' simplifies argument handling in parseFormalParameterList\n                        // Note that we don\'t set the minchar in this case\n                    ast = this.parseLambdaExpr(errorRecoverySet, ast, true /* skipNextRParen */, expectlambdaRParen);\n                    ast.minChar = minChar;\n                    limChar = this.scanner.lastTokenLimChar();\n                    ast.limChar = limChar;\n                }\n                else if (ast) {\n                    ast.isParenthesized = true;\n                }\n            }\n\n            if (sawId && (typeContext != TypeContext.NoTypes)) {\n                typeContext |= TypeContext.ArraySuffix;\n            }\n\n            var postFix = this.parsePostfixOperators(errorRecoverySet, ast, allowCall, inNew, typeContext, minChar, limChar);\n\n            // Defensive error check...\n            if (postFix) {\n                if (sawId && (postFix.nodeType == NodeType.Index)) {\n                    var binExpr = <BinaryExpression>postFix;\n                    if (binExpr.operand2 == null) {\n                        postFix = this.convertToTypeReference(postFix);\n                    }\n                }\n\n                ///////////////////////////////////////////////////////////\n                //TODO: Eventually, we want to remove "minChar" and "limChar" assignments here,\n                //      as they are sometimes not specific enough for each expression kind.\n                postFix.minChar = minChar;\n                // Only update "limChar" if it is not better than "lastTokenLimChar()"\n                postFix.limChar = max(postFix.limChar, this.scanner.lastTokenLimChar());\n                //\n                ///////////////////////////////////////////////////////////\n                return postFix;\n            }\n            else {\n                return new AST(NodeType.Error);\n            }\n\n        }\n\n        private parseLambdaExpr(errorRecoverySet: ErrorRecoverySet, lambdaArgs: AST, skipNextRParen: bool, expectClosingRParen: bool): AST {\n            // REVIEW: Parse the remainder of a lambda expression. The opening paren has been read already, if it existed. \n            //         skipNextRParen sets a flag on the resulting lambda node to tell the calling parseTerm that the LParen it scanned has been matched as part of parsing the formal parameter list\n            //         expectClosingRParen indicates that a closing RParen is expected, in the cases with optional parameter or more than one parameter.\n            var ast = this.parseFncDecl(errorRecoverySet, false, false, false, null, false, false, false, Modifiers.None, { preProcessedLambdaArgs: lambdaArgs }, expectClosingRParen);\n            (<FuncDecl>ast).fncFlags |= FncFlags.IsFunctionExpression;\n            (<FuncDecl>ast).fncFlags |= FncFlags.IsFatArrowFunction;\n            if (!skipNextRParen) {\n                ast.flags |= ASTFlags.SkipNextRParen;\n            }\n            ast.limChar = this.scanner.lastTokenLimChar();;\n            return ast;\n        }\n\n        private parseExpr(errorRecoverySet: ErrorRecoverySet, minPrecedence: number, allowIn: bool,\n            typeContext: TypeContext, possiblyInLambda: bool = false): AST {\n            var ast: AST = null;\n            var tokenInfo = lookupToken(this.currentToken.tokenId);\n            var canAssign: bool = true;\n            var idHint: string = null;\n            var minChar = this.scanner.startPos;\n            var preComments = this.parseComments();\n            var exprIsAnonLambda = false;\n\n            if ((tokenInfo != undefined) && (tokenInfo.unopNodeType != NodeType.None)) {\n                canAssign = false;\n                this.currentToken = this.scanner.scan();\n                var tempExpr = this.parseExpr(ErrorRecoverySet.BinOp | errorRecoverySet,\n                                       tokenInfo.unopPrecedence, allowIn,\n                                       TypeCo',
v27595=v27596+'ntext.NoTypes);\n\n                // fold unary +- into constants\n                if ((tokenInfo.unopNodeType == NodeType.Pos) &&\n                    (tempExpr.nodeType == NodeType.NumberLit)) {\n                    ast = tempExpr;\n                }\n                else if ((tokenInfo.unopNodeType == NodeType.Neg) &&\n                         (tempExpr.nodeType == NodeType.NumberLit)) {\n                    var numLit = <NumberLiteral>tempExpr;\n                    numLit.value = (-numLit.value);\n                    if (numLit.value == 0) {\n                        numLit.isNegativeZero = true;\n                    }\n                    ast = tempExpr;\n                }\n                else {\n                    ast = new UnaryExpression(tokenInfo.unopNodeType, tempExpr);\n                    ast.limChar = tempExpr.limChar;\n                }\n                ast.minChar = minChar;\n            }\n            else {\n                ast = this.parseTerm(ErrorRecoverySet.BinOp | ErrorRecoverySet.AddOp |\n                              errorRecoverySet, true, typeContext, false);\n                var id: Identifier;\n                var temp: AST;\n                if (ast.nodeType == NodeType.Name) {\n                    id = <Identifier>ast;\n                    idHint = id.actualText;\n                }\n                else if (ast.nodeType == NodeType.Dot) {\n\n                    // If this is within a class declaration, and the circumstances are right, we need to\n                    // transform the dotted expression into a member declaration\n                    var subsumedExpr = false;\n\n                    if (this.inferPropertiesFromThisAssignment && \n                        (this.currentToken.tokenId == TokenID.Colon || this.currentToken.tokenId == TokenID.Equals) &&\n                         this.parsingClassConstructorDefinition &&\n                         this.nestingLevel == this.currentClassDefinition.constructorNestingLevel && // this nesting level means we\'re at the top-level in the constructor\n                         (<BinaryExpression>ast).operand1.nodeType == NodeType.This) {\n\n                        if ((<BinaryExpression>ast).operand2.nodeType == NodeType.Name) {\n                            var op2ID: Identifier = (<Identifier>(<BinaryExpression>ast).operand2);\n\n                            if (!this.currentClassDefinition.knownMemberNames[op2ID.actualText]) {\n                                ast = this.parseClassMemberVariableDeclaration(op2ID, ast.minChar, true, errorRecoverySet, Modifiers.Public);\n                                subsumedExpr = true;\n                            }\n                        }\n                    }\n\n                    if (!subsumedExpr) {\n                        temp = ast;\n                        while (temp.nodeType == NodeType.Dot) {\n                            var binExpr = <BinaryExpression>temp;\n                            temp = binExpr.operand2;\n                        }\n                        if (temp.nodeType == NodeType.Name) {\n                             id = <Identifier>temp;\n                            idHint = id.actualText;\n                        }\n                    }\n                }\n                if ((!this.scanner.lastTokenHadNewline()) &&\n                    ((this.currentToken.tokenId == TokenID.PlusPlus) || (this.currentToken.tokenId == TokenID.MinusMinus))) {\n                    canAssign = false;\n                    var operand = ast;\n                    ast = new UnaryExpression((this.currentToken.tokenId == TokenID.PlusPlus) ? NodeType.IncPost : NodeType.DecPost, operand);\n                    ast.limChar = this.scanner.pos;\n                    ast.minChar = operand.minChar;\n                    this.currentToken = this.scanner.scan();\n                }\n            }\n            for (; ;) {\n                tokenInfo = lookupToken(this.currentToken.tokenId);\n                if ((tokenInfo == undefined) || (tokenInfo.binopNodeType == NodeType.None)) {\n                    break;\n                }\n                if ((!allowIn) && (tokenInfo.binopNodeType == NodeType.In)) {\n                    break;\n                }\n                if (tokenInfo.binopPrecedence == OperatorPrecedence.Assignment) {\n                    if (tokenInfo.binopPrecedence < minPrecedence) {\n                        break;\n                    }\n                    if (!canAssign) {\n                        this.reportParseError("illegal assignment");\n                    }\n                }\n                else if (tokenInfo.binopPrecedence <= minPrecedence) {\n                    break;\n                }\n\n                if (possiblyInLambda && this.currentToken.tokenId == TokenID.Comma && this.scanner.getLookAheadToken().tokenId == TokenID.DotDotDot) {\n                    // The ellipsis can only exist in the formal list of a lambda expression, so do not attempt to parse the comma token as the comma binary operator\n                    // instead parse it as a lambda\n               ',
v27594=v27595+'     exprIsAnonLambda = true;\n                    canAssign = false;\n                    ast = this.parseLambdaExpr(errorRecoverySet, ast, false, true);\n                    break;\n                }\n\n                // Precedence is high enough. Consume the operator token.\n                this.currentToken = this.scanner.scan();\n                canAssign = false;\n                if (tokenInfo.binopNodeType == NodeType.ConditionalExpression) {\n                    if (possiblyInLambda && \n                        ( this.currentToken.tokenId == TokenID.Equals || this.currentToken.tokenId == TokenID.Colon || this.currentToken.tokenId == TokenID.CloseParen || this.currentToken.tokenId == TokenID.Comma)) {\n                        // The QMark is not a ternary expression, it is a marker for optional parameter in a lambda expression.\n                        exprIsAnonLambda = true;\n                        canAssign = true;\n                    }\n                    else {\n                        this.prevExpr = ast;\n                        var whenTrue = this.parseExpr(\n                            errorRecoverySet | ErrorRecoverySet.Colon, OperatorPrecedence.Assignment, allowIn, TypeContext.NoTypes);\n\n                        // Do not hold onto the prevExpr handle\n                        this.prevExpr = null;\n                        this.checkCurrentToken(TokenID.Colon, errorRecoverySet | ErrorRecoverySet.ExprStart);\n\n                        var whenFalse = this.parseExpr(\n                            errorRecoverySet | ErrorRecoverySet.BinOp, OperatorPrecedence.Assignment, allowIn, TypeContext.NoTypes)\n                        ast = new ConditionalExpression(ast, whenTrue, whenFalse);\n                    }\n                }\n                else {\n                    var tc = TypeContext.NoTypes;\n                    var binExpr2: BinaryExpression;\n\n                    binExpr2 = new BinaryExpression(tokenInfo.binopNodeType, ast,\n                                                    this.parseExpr(errorRecoverySet |\n                                                            ErrorRecoverySet.BinOp,\n                                                            tokenInfo.binopPrecedence,\n                                                            allowIn, TypeContext.NoTypes, possiblyInLambda));\n                    if (binExpr2.operand2.nodeType == NodeType.FuncDecl) {\n                        var funcDecl = <FuncDecl>binExpr2.operand2;\n                        funcDecl.hint = idHint;\n                    }\n\n                    binExpr2.minChar = ast.minChar;\n                    binExpr2.limChar = this.scanner.lastTokenLimChar();\n                    idHint = null;\n                    ast = binExpr2;\n                }\n            }\n            if (canAssign) {\n                ast.flags |= ASTFlags.Writeable;\n            }\n            if (!exprIsAnonLambda) {\n                ///////////////////////////////////////////////////////////\n                //TODO: Eventually, we want to remove "minChar" and "limChar" assignments here,\n                //      as they are sometimes not specific enough for each statement kind.\n                ast.minChar = minChar;\n                // Only update "limChar" if it is not better than "lastTokenLimChar()"\n                ast.limChar = max(ast.limChar, this.scanner.lastTokenLimChar());\n                //\n                ///////////////////////////////////////////////////////////\n                ast.preComments = preComments;\n                ast.postComments = this.parseCommentsForLine(this.scanner.line);\n            }\n            return ast;\n        }\n\n        private parsePostfixOperators(errorRecoverySet: ErrorRecoverySet, ast: AST, allowCall: bool, inNew: bool,\n            typeContext: TypeContext, lhsMinChar: number, lhsLimChar: number): AST {\n            var count = 0;\n\n            if (!ast) {\n                ast = new AST(NodeType.EmptyExpr);\n                ast.isParenthesized = true;\n            }\n\n            ast.minChar = lhsMinChar;\n            ast.limChar = lhsLimChar;\n\n            for (; ;) {\n                switch (this.currentToken.tokenId) {\n                    case TokenID.OpenParen:\n                        if (inNew) {\n                            var callExpr = <CallExpression>ast;\n                            callExpr.arguments = this.parseArgList(errorRecoverySet);\n                            inNew = false;\n                        }\n                        else {\n                            if (!allowCall) {\n                                return ast;\n                            }\n                            ast = new CallExpression(NodeType.Call, ast,\n                                                   this.parseArgList(errorRecoverySet));\n                            ast.minChar = lhsMinChar;\n                        }\n                        ast.limChar = this.scanner.pos; // \')\'\n                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet);\n              ',
v27593=v27594+"          break;\n                    case TokenID.OpenBracket:\n                        this.currentToken = this.scanner.scan();\n                        if (this.currentToken.tokenId == TokenID.CloseBracket) {\n                            if (hasFlag(typeContext, TypeContext.ArraySuffix)) {\n                                this.currentToken = this.scanner.scan();\n                                if (ast.nodeType == NodeType.TypeRef) {\n                                    var typeRef = <TypeReference>ast;\n                                    typeRef.arrayCount++;\n                                }\n                                else {\n                                    ast = new BinaryExpression(NodeType.Index, ast, null);\n                                }\n                                ast.limChar = this.scanner.pos;\n                                break; // note early exit from case\n                            }\n                        }\n\n                        ast = new BinaryExpression(NodeType.Index, ast,\n                                                 this.parseExpr(errorRecoverySet | ErrorRecoverySet.RBrack,\n                                                           OperatorPrecedence.None, true,\n                                                           TypeContext.NoTypes));\n                        ast.minChar = lhsMinChar;\n                        ast.limChar = this.scanner.pos; // ']'\n                        this.checkCurrentToken(TokenID.CloseBracket, errorRecoverySet);\n                        break;\n                    case TokenID.Dot: {\n                        var name: Identifier = null;\n                        var curpos = this.scanner.pos;\n                        this.currentToken = this.scanner.scan();\n                        // Don't allow reserved words if immediately after a new line and error recovery is enabled\n                        if ((this.currentToken.tokenId == TokenID.Identifier) || ((!this.errorRecovery || !this.scanner.lastTokenHadNewline()) && convertTokToIDName(this.currentToken))) {\n                            ast.flags |= ASTFlags.DotLHS;\n                            name = this.createRef(this.currentToken.getText(), (<IdentifierToken>this.currentToken).hasEscapeSequence, this.scanner.startPos);\n                            name.limChar = this.scanner.pos;\n                            this.currentToken = this.scanner.scan();\n                        }\n                        else {\n                            this.reportParseError(\"Expected identifier following dot\");\n                            if (this.errorRecovery) {\n                                this.skip(errorRecoverySet);\n                                ast.flags |= (ASTFlags.Error | ASTFlags.DotLHS);\n                                return ast;\n                            }\n                            else {\n                                name = new MissingIdentifier();\n                            }\n                        }\n                        ast = new BinaryExpression(NodeType.Dot, ast, name);\n                        ast.minChar = lhsMinChar;\n                        ast.limChar = this.scanner.lastTokenLimChar();\n                        break;\n                    }\n                    case TokenID.EqualsGreaterThan:\n                        ast = this.parseFncDecl(errorRecoverySet, false, false, false, null, false, false, false, Modifiers.None, { preProcessedLambdaArgs: ast }, false);\n                        (<FuncDecl>ast).fncFlags |= FncFlags.IsFunctionExpression;\n                        ast.minChar = lhsMinChar;\n                        ast.limChar = this.scanner.lastTokenLimChar();\n                        break;\n                    default:\n                        return ast;\n\n                }\n            }\n        }\n\n        private parseTry(tryNode: Try, errorRecoverySet: ErrorRecoverySet, parentModifiers: Modifiers): Try {\n            var minChar = this.scanner.startPos;\n            var preComments = this.parseComments();\n            this.currentToken = this.scanner.scan();\n            if (this.currentToken.tokenId != TokenID.OpenBrace) {\n                this.reportParseError(\"Expected '{'\");\n                if (this.errorRecovery) {\n                    var etryNode = tryNode;\n                    etryNode.minChar = minChar;\n                    etryNode.limChar = this.scanner.lastTokenLimChar();\n                    etryNode.flags |= ASTFlags.Error;\n                    return etryNode;\n                }\n            }\n            tryNode.body = this.parseStatement(errorRecoverySet, AllowedElements.None, parentModifiers);\n            tryNode.minChar = minChar;\n            tryNode.limChar = tryNode.body.limChar;\n            tryNode.preComments = preComments;\n            tryNode.postComments = this.parseComments();\n            return tryNode;\n        }\n\n        private parseCatch(errorRecoverySet: ErrorRecoverySet, parentModifiers: Modifiers): Catch {\n            var catchMinChar = this.scanner.startPos;\n       ",
v27592=v27593+'     var preComments = this.parseComments();\n            this.currentToken = this.scanner.scan();\n            this.checkCurrentToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart);\n            if ((this.currentToken.tokenId != TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                this.reportParseError("Expected identifier in catch header");\n                if (this.errorRecovery) {\n                    this.skip(errorRecoverySet);\n\n                    var ecatch = new Catch(new VarDecl(new MissingIdentifier(), this.nestingLevel),\n                                            new Statement(NodeType.Empty));\n                    ecatch.statement.minChar = catchMinChar;\n                    ecatch.statement.limChar = this.scanner.pos;\n                    ecatch.minChar = this.scanner.startPos;\n                    ecatch.limChar = this.scanner.pos;\n                    ecatch.flags |= ASTFlags.Error;\n                    return ecatch;\n                }\n            }\n            var param = new VarDecl(Identifier.fromToken(this.currentToken), this.nestingLevel);\n            param.id.minChar = this.scanner.startPos;\n            param.id.limChar = this.scanner.pos;\n            param.minChar = param.id.minChar;\n            param.limChar = param.id.limChar;\n            this.currentToken = this.scanner.scan();\n            var statementPos = this.scanner.pos;\n            this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.StmtStart);\n            if (this.currentToken.tokenId != TokenID.OpenBrace) {\n                this.reportParseError("Expected \'{\' to start catch body");\n                if (this.errorRecovery) {\n                    this.skip(errorRecoverySet);\n\n                    var ecatch = new Catch(new VarDecl(new MissingIdentifier(), this.nestingLevel),\n                                            new Statement(NodeType.Empty));\n                    ecatch.statement.minChar = catchMinChar;\n                    ecatch.statement.limChar = statementPos;\n                    ecatch.minChar = this.scanner.startPos;\n                    ecatch.limChar = this.scanner.pos;\n                    ecatch.flags |= ASTFlags.Error;\n                    return ecatch;\n                }\n            }\n\n            var catchStmt = this.parseStatement(errorRecoverySet, AllowedElements.None, parentModifiers);\n            var catchNode = new Catch(param, catchStmt);\n            catchNode.statement.minChar = catchMinChar;\n            catchNode.statement.limChar = statementPos;\n            catchNode.minChar = catchMinChar;\n            catchNode.limChar = catchStmt.limChar;\n            catchNode.preComments = preComments;\n            catchNode.postComments = this.parseComments();\n            return catchNode;\n        }\n\n        private parseFinally(errorRecoverySet: ErrorRecoverySet, parentModifiers: Modifiers): Finally {\n            var finMinChar = this.scanner.startPos;\n            var preComments = this.parseComments();\n            this.currentToken = this.scanner.scan();\n            if (this.currentToken.tokenId != TokenID.OpenBrace) {\n                this.reportParseError("Expected \'{\' to start body of finally statement");\n                if (this.errorRecovery) {\n                    this.skip(errorRecoverySet);\n                    var efin = new Finally(new Statement(NodeType.Empty));\n                    efin.flags |= ASTFlags.Error;\n                    efin.minChar = this.scanner.startPos;\n                    efin.limChar = this.scanner.pos;\n                    return efin;\n                }\n            }\n\n            var finBody = this.parseStatement(errorRecoverySet, AllowedElements.None, parentModifiers)\n            var fin = new Finally(finBody);\n            fin.minChar = finMinChar;\n            fin.limChar = fin.body.limChar;\n            fin.preComments = preComments;\n            fin.postComments = this.parseComments();\n            return fin;\n        }\n\n        private parseTryCatchFinally(errorRecoverySet: ErrorRecoverySet, parentModifiers: Modifiers, labelList: ASTList): AST {\n            var tryPart: AST = new Try(null);\n            var tryMinChar = this.scanner.startPos;\n            this.pushStmt(<Statement>tryPart, labelList);\n            this.parseTry(<Try>tryPart, errorRecoverySet | ErrorRecoverySet.Catch, parentModifiers);\n            this.popStmt();\n            var tc: TryCatch = null;\n            var tf: TryFinally = null;\n\n            if (this.currentToken.tokenId == TokenID.Catch) {\n                var catchPart = this.parseCatch(errorRecoverySet | ErrorRecoverySet.Catch, parentModifiers);\n                tc = new TryCatch(<Try>tryPart, catchPart);\n                tc.minChar = tryPart.minChar;\n                tc.limChar = catchPart.limChar;\n            }\n\n            if (this.currentToken.tokenId != TokenID.Finally) {\n                if (tc == null) {\n                    this.reportParseError("try with neither catch nor finally");\n        ',
v27591=v27592+'            if (this.errorRecovery) {\n                        var etf = new TryFinally(tryPart, new Finally(new AST(NodeType.Empty)));\n                        etf.flags |= ASTFlags.Error;\n                        etf.minChar = this.scanner.startPos;\n                        etf.limChar = this.scanner.pos;\n                        return etf;\n                    }\n                    return new TryFinally(tryPart, new Finally(new AST(NodeType.Empty)));\n                }\n                else {\n                    return tc;\n                }\n            }\n            else {\n                if (tc) {\n                    tryPart = tc;\n                }\n                var finallyPart = this.parseFinally(errorRecoverySet, parentModifiers)\n                tf = new TryFinally(tryPart, finallyPart);\n                tf.minChar = tryMinChar;\n                tf.limChar = finallyPart.limChar;\n                return tf;\n            }\n        }\n\n        private parseStatement(errorRecoverySet: ErrorRecoverySet, allowedElements: AllowedElements, parentModifiers: Modifiers): AST {\n            var ast: AST = null;\n            var labelList: ASTList = null;\n            var astList: ASTList = null;\n            var temp: AST;\n            var modifiers = Modifiers.None;\n            var minChar = this.scanner.startPos;\n            var forInOk = false;\n            var needTerminator = false;\n            var fnOrVar: AST = null;\n            var preComments = this.parseComments();\n            this.state = ParseState.StartStatement;\n\n            function isAmbient() {\n                return hasFlag(modifiers, Modifiers.Ambient) || hasFlag(parentModifiers, Modifiers.Ambient);\n            }\n\n            function mayNotBeExported() {\n                if (hasFlag(modifiers, Modifiers.Exported)) {\n                    this.reportError("Statement may not be exported");\n                }\n            }\n\n            for (; ;) {\n                switch (this.currentToken.tokenId) {\n                    case TokenID.EndOfFile:\n                        ast = new AST(NodeType.Error);\n                        ast.minChar = minChar;\n                        ast.limChar = this.scanner.pos;\n                        break;\n                    case TokenID.Function:\n                        if (this.parsingDeclareFile || isAmbient() || this.ambientModule) {\n                            this.currentToken = this.scanner.scan();\n                            fnOrVar = this.parsePropertyDeclaration(errorRecoverySet | ErrorRecoverySet.SColon,\n                                                      modifiers, true, false);\n                            if (fnOrVar.nodeType == NodeType.VarDecl) {\n                                this.reportParseError("function keyword can only introduce function declaration");\n                            }\n                            else if ((fnOrVar.nodeType == NodeType.FuncDecl) && ((<FuncDecl>fnOrVar).fncFlags, FncFlags.IsFatArrowFunction)) {\n                                needTerminator = true;\n                            }\n                            ast = fnOrVar;\n                            if (this.parsingDeclareFile || this.ambientModule && ast.nodeType == NodeType.FuncDecl) {\n                                (<FuncDecl>ast).fncFlags |= FncFlags.Exported;\n                            }\n                        }\n                        else {\n                            ast = this.parseFncDecl(errorRecoverySet, true, false, false, null, false, false, isAmbient(), modifiers, null, true);\n                            if (hasFlag((<FuncDecl>ast).fncFlags, FncFlags.IsFatArrowFunction)) {\n                                needTerminator = true;\n                            }\n                            if (this.ambientModule) {\n                                this.reportParseError("function declaration not permitted within ambient module");\n                            }\n                            if (hasFlag(modifiers, Modifiers.Exported)) {\n                                (<FuncDecl>ast).fncFlags |= FncFlags.Exported;\n                            }\n                        }\n                        break;\n                    case TokenID.Module:\n                        if ((allowedElements & AllowedElements.ModuleDeclarations) == AllowedElements.None) {\n                            this.reportParseError("module not allowed in this context");\n                            this.currentToken = this.scanner.scan();\n                            ast = new AST(NodeType.Error);\n                            ast.minChar = minChar;\n                            ast.limChar = this.scanner.lastTokenLimChar();\n                        }\n                        else {\n                            ast = this.parseModuleDecl(errorRecoverySet, modifiers, preComments);\n                            preComments = null;\n                        }\n                        break;\n                    case TokenID.Import:\n                        if ((allowedElements & AllowedElement',
v27590=v27591+'s.ModuleDeclarations) == AllowedElements.None) {\n                            this.reportParseError("module not allowed in this context");\n                            this.currentToken = this.scanner.scan();\n                            ast = new AST(NodeType.Error);\n                            ast.minChar = minChar;\n                            ast.limChar = this.scanner.lastTokenLimChar();\n                        }\n                        else {\n                            if (hasFlag(modifiers, Modifiers.Exported)) {\n                                this.reportParseError("export keyword not permitted on import declaration");\n                            }\n                            ast = this.parseImportDeclaration(errorRecoverySet, modifiers);\n                            needTerminator = true;\n                        }\n                        break;\n                    case TokenID.Export:\n                        if ((allowedElements & AllowedElements.ModuleDeclarations) == AllowedElements.None) {\n                            this.reportParseError("\'export\' statements are only allowed at the global and module levels");\n                            this.currentToken = this.scanner.scan();\n                            ast = new AST(NodeType.Error);\n                            ast.minChar = minChar;\n                            ast.limChar = this.scanner.lastTokenLimChar();\n                        }\n                        if (this.topLevel) {\n                            this.hasTopLevelImportOrExport = true;\n                        }\n                        modifiers |= Modifiers.Exported;\n                        this.currentToken = this.scanner.scan();\n                        break;\n                    case TokenID.Private:\n                        modifiers |= Modifiers.Private;\n\n                        this.currentToken = this.scanner.scan();\n\n                        if (this.parsingClassConstructorDefinition) {\n\n                            if (!this.inferPropertiesFromThisAssignment) {\n                                this.reportParseError("Property declarations are not permitted within constructor bodies");\n                            }\n\n                            minChar = this.scanner.pos;\n                            if (this.inferPropertiesFromThisAssignment && (this.currentToken.tokenId != TokenID.This || (this.currentToken = this.scanner.scan()).tokenId != TokenID.Dot)) {\n                                this.reportParseError("Expected \'this.\' for property declaration");\n                                this.currentToken = this.scanner.scan();\n                                ast = new AST(NodeType.Error);\n                                ast.minChar = minChar;\n                                ast.limChar = this.scanner.lastTokenLimChar();\n                            }\n                            else {\n                                this.currentToken = this.scanner.scan();\n\n                                var id = Identifier.fromToken(this.currentToken);\n                                id.minChar = this.scanner.startPos;\n                                id.limChar = this.scanner.pos;\n\n                                this.currentToken = this.scanner.scan();\n                                ast = this.parseClassMemberVariableDeclaration(id, minChar, this.parsingClassConstructorDefinition, errorRecoverySet, modifiers);\n                            }\n                        }\n                        else {\n                            if (this.currentToken.tokenId != TokenID.Interface) {\n                                if (this.currentToken.tokenId == TokenID.Get) {\n                                    this.prevIDTok = this.currentToken;\n                                    this.currentToken = this.scanner.scan();\n                                    if (codeGenTarget < CodeGenTarget.ES5) {\n                                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                                    }\n                                    if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                                        modifiers |= Modifiers.Getter;\n                                        this.prevIDTok = null;\n                                    }\n                                }\n                                else if (this.currentToken.tokenId == TokenID.Set) {\n                                    this.prevIDTok = this.currentToken;\n                                    this.currentToken = this.scanner.scan();\n                                    if (codeGenTarget < CodeGenTarget.ES5) {\n                                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                                    }\n                                    if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMod',
v27589=v27590+'e)) {\n                                        modifiers |= Modifiers.Setter;\n                                        this.prevIDTok = null;\n                                    }\n                                }\n                                fnOrVar = this.parsePropertyDeclaration(errorRecoverySet | ErrorRecoverySet.SColon,\n                                                          modifiers, isAmbient(), false);\n                                if ((fnOrVar.nodeType == NodeType.VarDecl) ||\n                                    ((fnOrVar.nodeType == NodeType.FuncDecl) && (hasFlag((<FuncDecl>fnOrVar).fncFlags, FncFlags.IsFatArrowFunction)))) {\n                                    needTerminator = true;\n                                }\n                                ast = fnOrVar;\n                            }\n                        }\n                        break;\n                    case TokenID.Public:\n                        if (this.parsingClassConstructorDefinition) {\n\n                            if (!this.inferPropertiesFromThisAssignment) {\n                                this.reportParseError("Property declarations are not permitted within constructor bodies");\n                            }\n\n                            this.currentToken = this.scanner.scan(); \n                            minChar = this.scanner.pos;\n                            modifiers |= Modifiers.Public;\n                            if (this.inferPropertiesFromThisAssignment && (this.currentToken.tokenId != TokenID.This || (this.currentToken = this.scanner.scan()).tokenId != TokenID.Dot)) {\n                                this.reportParseError("Expected \'this.\' for property declaration");\n                                this.currentToken = this.scanner.scan();\n                                ast = new AST(NodeType.Error);\n                                ast.minChar = minChar;\n                                ast.limChar = this.scanner.lastTokenLimChar();\n                            }\n                            else {\n                                this.currentToken = this.scanner.scan();\n\n                                var id = Identifier.fromToken(this.currentToken);\n                                id.minChar = this.scanner.startPos;\n                                id.limChar = this.scanner.pos;\n\n                                this.currentToken = this.scanner.scan();\n                                ast = this.parseClassMemberVariableDeclaration(id, minChar, this.parsingClassConstructorDefinition, errorRecoverySet, modifiers);\n                            }\n                        }\n                        else {\n                            if ((allowedElements & AllowedElements.Properties) == AllowedElements.None) {\n                                this.reportParseError("\'property\' statements are only allowed within classes");\n                                this.currentToken = this.scanner.scan();\n                                ast = new AST(NodeType.Error);\n                                ast.minChar = minChar;\n                                ast.limChar = this.scanner.lastTokenLimChar();\n                            }\n                            else {\n                                modifiers |= Modifiers.Public;\n                                this.currentToken = this.scanner.scan();\n                                if (this.currentToken.tokenId == TokenID.Get) {\n                                    this.prevIDTok = this.currentToken;\n                                    this.currentToken = this.scanner.scan();\n                                    if (codeGenTarget < CodeGenTarget.ES5) {\n                                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                                    }\n                                    if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                                        modifiers |= Modifiers.Getter;\n                                        this.prevIDTok = null;\n                                    }\n                                }\n                                else if (this.currentToken.tokenId == TokenID.Set) {\n                                    this.prevIDTok = this.currentToken;\n                                    this.currentToken = this.scanner.scan();\n                                    if (codeGenTarget < CodeGenTarget.ES5) {\n                                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                                    }\n                                    if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                                        modifiers |= Modifiers.Setter;\n                                        this.prevIDTok = null;\n                                    }\n                                }\n       ',
v27588=v27589+'                         fnOrVar = this.parsePropertyDeclaration(errorRecoverySet | ErrorRecoverySet.SColon,\n                                                            modifiers, isAmbient(), false);\n                                if ((fnOrVar.nodeType == NodeType.VarDecl) ||\n                                    ((fnOrVar.nodeType == NodeType.FuncDecl) && hasFlag((<FuncDecl>fnOrVar).fncFlags, FncFlags.IsFatArrowFunction))) {\n                                    needTerminator = true;\n                                }\n                                ast = fnOrVar;\n                            }\n                        }\n                        break;\n                    case TokenID.Declare:\n                        if (!(allowedElements & AllowedElements.AmbientDeclarations)) {\n                            this.reportParseError("Ambient declarations are only allowed at the top-level or module scopes")\n                        }\n                        if (!this.parsingDeclareFile && hasFlag(parentModifiers, Modifiers.Ambient)) {\n                            this.reportParseError("Duplicate ambient declaration in this context. (Is the enclosing module or class already ambient?)")\n                        }\n                        modifiers |= Modifiers.Ambient;\n                        this.currentToken = this.scanner.scan();\n                        break;\n                    case TokenID.Class:\n                        if ((allowedElements & AllowedElements.ClassDeclarations) == AllowedElements.None) {\n                            this.reportParseError("class not allowed in this context");\n                            this.currentToken = this.scanner.scan();\n                            ast = new AST(NodeType.Error);\n                            ast.minChar = minChar;\n                            ast.limChar = this.scanner.lastTokenLimChar();\n                        }\n                        else {\n                            ast = this.parseClassDecl(errorRecoverySet, minChar, modifiers);\n                        }\n                        break;\n                    case TokenID.Interface:\n                        if ((allowedElements & AllowedElements.InterfaceDeclarations) == AllowedElements.None) {\n                            this.reportParseError("interface not allowed in this context");\n                            this.currentToken = this.scanner.scan();\n                            ast = new AST(NodeType.Error);\n                            ast.minChar = minChar;\n                            ast.limChar = this.scanner.lastTokenLimChar();\n                        }\n                        else {\n                            ast = this.parseInterfaceDecl(errorRecoverySet, modifiers);\n                        }\n                        break;\n                    case TokenID.Var:\n                        var declAst: AST = this.parseVariableDeclaration(errorRecoverySet | ErrorRecoverySet.StmtStart, modifiers,\n                                                     true, false);\n                        if (declAst.nodeType == NodeType.VarDecl) {\n                            ast = declAst;\n                        }\n                        else {\n                            ast = new Block(<ASTList>declAst, false);\n                        }\n                        needTerminator = true;\n                        break;\n                    case TokenID.Static:\n\n                        if (this.currentClassDecl == null) {\n                            this.reportParseError("Statics may only be class members");\n                        }\n\n                        mayNotBeExported();\n                        modifiers |= Modifiers.Public;\n                        this.currentToken = this.scanner.scan();\n                        if (this.currentToken.tokenId == TokenID.Get) {\n                            this.prevIDTok = this.currentToken;\n                            this.currentToken = this.scanner.scan();\n                            if (codeGenTarget < CodeGenTarget.ES5) {\n                                this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                            }\n                            if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                                modifiers |= Modifiers.Getter;\n                                this.prevIDTok = null;\n                            }\n                        }\n                        else if (this.currentToken.tokenId == TokenID.Set) {\n                            this.currentToken = this.scanner.scan();\n                            if (codeGenTarget < CodeGenTarget.ES5) {\n                                this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                            }\n                            if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n             ',
v27587=v27588+'                   modifiers |= Modifiers.Setter;\n                            }\n                        }\n                        if (isAmbient()) {\n                            modifiers |= Modifiers.Ambient;\n                        }\n                        fnOrVar = this.parsePropertyDeclaration(errorRecoverySet | ErrorRecoverySet.SColon,\n                                                  modifiers, this.parsingDeclareFile || (modifiers & Modifiers.Ambient) != Modifiers.None, true);\n\n                        var staticsList = this.topStaticsList();\n                        if (staticsList && fnOrVar.nodeType == NodeType.VarDecl) {\n                            staticsList.append(fnOrVar);\n                        }\n\n                        if (fnOrVar.nodeType == NodeType.VarDecl || ((fnOrVar.nodeType == NodeType.FuncDecl) && hasFlag((<FuncDecl>fnOrVar).fncFlags, FncFlags.IsFatArrowFunction))) {\n                            needTerminator = true;\n                        }\n\n                        ast = fnOrVar;\n                        break;\n                    case TokenID.For:\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("syntax error: for statement does not take modifiers");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.checkNextToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart | ErrorRecoverySet.Var);\n                        this.state = ParseState.ForInit;\n                        forInOk = true;\n                        switch (this.currentToken.tokenId) {\n                            case TokenID.Var:\n                                temp = this.parseVariableDeclaration(errorRecoverySet | ErrorRecoverySet.SColon |\n                                                  ErrorRecoverySet.In, Modifiers.None, false, false);\n                                break;\n                            case TokenID.Semicolon:\n                                temp = null;\n                                this.state = ParseState.ForCondStart;\n                                break;\n                            default:\n                                temp = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon |\n                                               ErrorRecoverySet.In, OperatorPrecedence.None, false,\n                                               TypeContext.NoTypes);\n                                break;\n                        }\n                        this.state = ParseState.ForInitAfterVar;\n                        if (this.currentToken.tokenId == TokenID.In) {\n                            if ((temp == null) || (!forInOk)) {\n                                this.reportParseError("malformed for statement");\n                                if (this.errorRecovery) {\n                                    this.skip(errorRecoverySet | ErrorRecoverySet.StmtStart);\n                                    ast = new AST(NodeType.Empty);\n                                    ast.flags |= ASTFlags.Error;\n                                }\n                            }\n                            else {\n                                this.currentToken = this.scanner.scan();\n                                var forInStmt = new ForInStatement(temp,\n                                                                 this.parseExpr(ErrorRecoverySet.RParen |\n                                                                           errorRecoverySet,\n                                                                           OperatorPrecedence.Comma,\n                                                                           false,\n                                                                           TypeContext.NoTypes));\n\n                                forInStmt.limChar = this.scanner.pos;\n                                forInStmt.statement.minChar = minChar;\n                                forInStmt.statement.limChar = this.scanner.pos;\n                                this.checkCurrentToken(TokenID.CloseParen, ErrorRecoverySet.StmtStart | errorRecoverySet);\n                                this.pushStmt(forInStmt, labelList);\n                                forInStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\n                                this.popStmt();\n                                forInStmt.minChar = minChar;\n                                ast = forInStmt;\n                            }\n                        }\n                        else {\n                            var forStmt: ForStatement = new ForStatement(temp);\n                            forStmt.minChar = minChar;\n                            this.checkCurrentToken(TokenID.Semicolon, errorRecoverySet);\n                            if (this.currentToken.tokenId == TokenID.Semicolon) {\n                                forStmt.cond = null;\n                 ',
v27586=v27587+"           }\n                            else {\n                                forStmt.cond = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon |\n                                                       ErrorRecoverySet.RParen,\n                                                       OperatorPrecedence.None, true,\n                                                       TypeContext.NoTypes);\n                                if (this.currentToken.tokenId != TokenID.Semicolon) {\n                                    this.skip(errorRecoverySet | ErrorRecoverySet.StmtStart);\n                                    ast = forStmt;\n                                    ast.flags |= ASTFlags.Error;\n                                }\n                            }\n                            this.currentToken = this.scanner.scan();\n                            if (this.currentToken.tokenId == TokenID.CloseParen) {\n                                forStmt.incr = null;\n                            }\n                            else {\n                                forStmt.incr = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon |\n                                                       ErrorRecoverySet.RParen,\n                                                       OperatorPrecedence.None, true,\n                                                       TypeContext.NoTypes);\n                            }\n                            this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.LCurly);\n                            this.pushStmt(forStmt, labelList);\n                            forStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\n                            this.popStmt();\n                            forStmt.limChar = forStmt.body.limChar;\n                            ast = forStmt;\n                        }\n                        break;\n                    case TokenID.With: {\n                        if (codeGenTarget < CodeGenTarget.ES5) {\n                            this.reportParseError(\"'with' statements are only available in ES5 codegen mode or better\");\n                        }\n\n                        if (this.strictMode) {\n                            this.reportParseError(\"'with' statements are not available in strict mode\");\n                        }\n\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError(\"'with' statement does not take modifiers\");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.checkNextToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart | ErrorRecoverySet.Var);\n\n                        var expr = this.parseExpr(errorRecoverySet | ErrorRecoverySet.Colon,\n                                                            OperatorPrecedence.None, true,\n                                                            TypeContext.NoTypes);\n                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.LCurly);\n\n                        var withStmt = new WithStatement(expr);\n                        withStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\n                        withStmt.minChar = minChar;\n                        withStmt.limChar = withStmt.body.limChar;\n                        ast = withStmt;\n                    }\n                        break;\n                    case TokenID.Switch: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError(\"'switch' statement does not take modifiers\");\n                        }\n                        this.checkNextToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart);\n\n                        var switchStmt = new SwitchStatement(this.parseExpr(errorRecoverySet |\n                                                                     ErrorRecoverySet.RParen,\n                                                                     OperatorPrecedence.None,\n                                                                     true,\n                                                                     TypeContext.NoTypes));\n                        switchStmt.statement.minChar = minChar;\n                        switchStmt.statement.limChar = this.scanner.pos;\n                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.LCurly);\n                        var caseListMinChar = this.scanner.startPos;\n                         this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet | ErrorRecoverySet.SCase);\n                        switchStmt.defaultCase = null;\n                        switchStmt.caseList = new ASTList();\n                        var caseStmt: CaseStatement = null;\n                        this.push",
v27585=v27586+'Stmt(switchStmt, labelList);\n                        for (; ;) {\n                            if ((this.currentToken.tokenId == TokenID.Case) ||\n                                (this.currentToken.tokenId == TokenID.Default)) {\n                                var isDefault = (this.currentToken.tokenId == TokenID.Default);\n                                caseStmt = new CaseStatement();\n                                caseStmt.minChar = this.scanner.startPos;\n                                this.currentToken = this.scanner.scan();\n                                if (isDefault) {\n                                    switchStmt.defaultCase = caseStmt;\n                                }\n                                else {\n                                    caseStmt.expr = this.parseExpr(errorRecoverySet | ErrorRecoverySet.Colon,\n                                                            OperatorPrecedence.None, true,\n                                                            TypeContext.NoTypes);\n                                }\n                                this.checkCurrentToken(TokenID.Colon, errorRecoverySet | ErrorRecoverySet.StmtStart);\n                                caseStmt.body = new ASTList();\n                                this.parseStatementList(errorRecoverySet | ErrorRecoverySet.RCurly,\n                                              caseStmt.body, false, true, allowedElements, modifiers);\n                                caseStmt.limChar = caseStmt.body.limChar;\n                                switchStmt.caseList.append(caseStmt);\n                            }\n                            else {\n                                break;\n                            }\n                        }\n                        // end of switch statement\n                        switchStmt.caseList.minChar = caseListMinChar;\n                        switchStmt.caseList.limChar = this.scanner.pos;\n                        switchStmt.limChar = switchStmt.caseList.limChar;\n                        this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n                        this.popStmt();\n                        ast = switchStmt;\n                        break;\n                    }\n                    case TokenID.While: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("\'while\' statement does not take modifiers");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.checkNextToken(TokenID.OpenParen, ErrorRecoverySet.ExprStart |\n                                  errorRecoverySet);\n                        var whileStmt = new WhileStatement(this.parseExpr(errorRecoverySet |\n                                                                   ErrorRecoverySet.RParen,\n                                                                   OperatorPrecedence.None,\n                                                                   true, TypeContext.NoTypes));\n                        whileStmt.minChar = minChar;\n                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet |\n                                  ErrorRecoverySet.StmtStart);\n                        this.pushStmt(whileStmt, labelList);\n                        whileStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\n                        whileStmt.limChar = whileStmt.body.limChar;\n                        this.popStmt();\n                        ast = whileStmt;\n                        break;\n                    }\n                    case TokenID.Do: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("\'do\' statement does not take modifiers");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        var doStmt = new DoWhileStatement();\n                        doStmt.minChar = minChar;\n                        this.pushStmt(doStmt, labelList);\n                        doStmt.body = this.parseStatement(errorRecoverySet | ErrorRecoverySet.While,\n                                                   allowedElements, parentModifiers);\n                        this.popStmt();\n                        doStmt.whileAST = new Identifier("while");\n                        doStmt.whileAST.minChar = this.scanner.startPos;\n                        this.checkCurrentToken(TokenID.While, errorRecoverySet | ErrorRecoverySet.LParen);\n                        doStmt.whileAST.limChar = doStmt.whileAST.minChar + 5;\n                        this.checkCurrentToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart);\n                        doStmt.cond = this.parseExpr(errorRecoverySet | ErrorRecoverySet.RParen,\n                                           ',
v27584=v27585+'   OperatorPrecedence.None, true, TypeContext.NoTypes);\n                        doStmt.limChar = this.scanner.pos;\n                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet);\n                        ast = doStmt;\n                        // compatibility; more strict would be to require the \';\'\n                        if (this.currentToken.tokenId == TokenID.Semicolon) {\n                            this.currentToken = this.scanner.scan();\n                        }\n                        break;\n                    }\n                    case TokenID.If: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("if statement does not take modifiers");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.checkNextToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart);\n                        var ifStmt = new IfStatement(this.parseExpr(errorRecoverySet |\n                                                             ErrorRecoverySet.LParen,\n                                                             OperatorPrecedence.None, true,\n                                                             TypeContext.NoTypes));\n                        ifStmt.minChar = minChar;\n                        ifStmt.statement.minChar = minChar;\n                        ifStmt.statement.limChar = this.scanner.pos;\n                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.StmtStart);\n                        this.pushStmt(ifStmt, labelList);\n                        ifStmt.thenBod = this.parseStatement(ErrorRecoverySet.Else | errorRecoverySet,\n                                                      allowedElements, parentModifiers);\n                        ifStmt.limChar = ifStmt.thenBod.limChar;\n                        if (this.currentToken.tokenId == TokenID.Else) {\n                            this.currentToken = this.scanner.scan();\n                            ifStmt.elseBod = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\n                            ifStmt.limChar = ifStmt.elseBod.limChar;\n                        }\n                        this.popStmt();\n                        ast = ifStmt;\n                        break;\n                    }\n                    case TokenID.Try: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("try statement does not take modifiers");\n                        }\n                        minChar = this.scanner.startPos;\n                        ast = this.parseTryCatchFinally(errorRecoverySet, parentModifiers, labelList);\n                        break;\n                    }\n                    case TokenID.OpenBrace: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("block does not take modifiers");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        var block = new Block(new ASTList(), true);\n                        this.pushStmt(block, labelList);\n                        this.parseStatementList(\n                            errorRecoverySet | ErrorRecoverySet.RCurly, block.statements,\n                            /*sourceElements:*/ false, /*noLeadingCase:*/ false, AllowedElements.None, modifiers);\n                        this.popStmt();\n                        block.statements.minChar = minChar;\n                        block.statements.limChar = this.scanner.pos;\n                        block.minChar = block.statements.minChar;\n                        block.limChar = block.statements.limChar;\n                        this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n                        ast = block;\n                        break;\n                    }\n                    case TokenID.Semicolon:\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("modifier can not appear here");\n                        }\n                        ast = new AST(NodeType.Empty);\n                        this.currentToken = this.scanner.scan();\n                        break;\n                    case TokenID.Break:\n                    case TokenID.Continue: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("modifiers can not appear before jump statement");\n                        }\n                        var jump =\n                            new Jump((this.currentToken.tokenId == TokenID.Break) ? NodeType.Break : NodeType.Cont',
v27583=v27584+'inue);\n                        this.currentToken = this.scanner.scan();\n                        if ((this.currentToken.tokenId == TokenID.Identifier) && (!this.scanner.lastTokenHadNewline())) {\n                            // Labeled break or continue.\n                            jump.target = this.currentToken.getText();\n                            this.currentToken = this.scanner.scan();\n                        }\n                        this.resolveJumpTarget(jump);\n                        ast = jump;\n                        needTerminator = true;\n                        break;\n                    }\n                    case TokenID.Return: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("modifiers can not appear before return statement");\n                        }\n                        if (!this.inFunction) {\n                            this.reportParseError("return statement outside of function body");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        var retStmt = new ReturnStatement();\n                        retStmt.minChar = minChar;\n                        if ((this.currentToken.tokenId != TokenID.Semicolon) &&\n                            (this.currentToken.tokenId != TokenID.CloseBrace) &&\n                            (!(this.scanner.lastTokenHadNewline()))) {\n                            retStmt.returnExpression = this.parseExpr(errorRecoverySet |\n                                                               ErrorRecoverySet.SColon,\n                                                               OperatorPrecedence.None,\n                                                               true, TypeContext.NoTypes);\n                        }\n                        needTerminator = true;\n                        retStmt.limChar = this.scanner.lastTokenLimChar();\n                        ast = retStmt;\n                        break;\n                    }\n                    case TokenID.Throw:\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("modifiers can not appear before a throw statement");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        if ((this.currentToken.tokenId != TokenID.Semicolon) &&\n                            (this.currentToken.tokenId != TokenID.CloseBrace) &&\n                            (!(this.scanner.lastTokenHadNewline()))) {\n                            temp = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon,\n                                           OperatorPrecedence.None, true, TypeContext.NoTypes);\n                        }\n                        else {\n                            this.reportParseError("throw with no target");\n                            temp = null;\n                        }\n                        ast = new UnaryExpression(NodeType.Throw, temp);\n                        ast.limChar = this.scanner.lastTokenLimChar();\n                        needTerminator = true;\n                        break;\n                    case TokenID.Enum:\n                        // TODO: check module allowed here\n                        //minChar=scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        ast = this.parseEnumDecl(errorRecoverySet, modifiers);\n                        ast.minChar = minChar;\n                        ast.limChar = this.scanner.lastTokenLimChar();\n                        if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Ambient)) {\n                            (<ModuleDeclaration>ast).modFlags |= ModuleFlags.Ambient;\n                        }\n                        if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Exported)) {\n                            (<ModuleDeclaration>ast).modFlags |= ModuleFlags.Exported;\n                        }\n                        break;\n                    case TokenID.Debugger:\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("modifiers can not appear before debugger statement");\n                        }\n                        \n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        var debuggerStmt = new DebuggerStatement();\n                        debuggerStmt.minChar = minChar;\n                        needTerminator = true;\n                        debuggerStmt.limChar = this.scanner.lastTokenLimChar();\n                        ast = debuggerStmt;\n                       ',
v27582=v27583+' break;\n                    default:\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("modifiers can not appear before an expression statement or label");\n                        }\n                        minChar = this.scanner.startPos;\n                        var svPos = this.scanner.pos;\n                        temp = this.parseExpr(ErrorRecoverySet.Colon | ErrorRecoverySet.StmtStart |\n                                       errorRecoverySet, OperatorPrecedence.None, true,\n                                       TypeContext.NoTypes);\n                        if (this.scanner.pos == svPos) {\n                            // no progress\n                            this.currentToken = this.scanner.scan();\n                            ast = temp;\n                        }\n                        else if ((this.currentToken.tokenId == TokenID.Colon) && (!this.scanner.lastTokenHadNewline()) &&\n                                        temp && (temp.nodeType == NodeType.Name)) {\n                                            // It\'s a label\n                            if (labelList == null) {\n                                labelList = new ASTList();\n                            }\n                            labelList.append(new Label(<Identifier>temp));\n                            this.currentToken = this.scanner.scan();\n                        }\n                        else {\n                            // expression statement\n                            ast = temp;\n                            needTerminator = true;\n                        }\n                }\n                if (ast) {\n                    break;\n                }\n            }\n            if (needTerminator) {\n                switch (this.currentToken.tokenId) {\n                    case TokenID.Semicolon:\n                        this.currentToken = this.scanner.scan();\n                        ast.flags |= ASTFlags.ExplicitSemicolon;\n                        break;\n                    case TokenID.EndOfFile:\n                        // Extend any incomplete statements to include EOF token. This makes sure that this node is in the path \n                        // when completion or parameter help is requested.\n                        ast.limChar = this.scanner.pos;\n                        // IntentionaCloseBracethrough\n                    case TokenID.CloseBrace:\n                        ast.flags |= ASTFlags.AutomaticSemicolon;\n                        if (this.style_requireSemi) {\n                            this.reportParseStyleError("no automatic semicolon");\n                        }\n                        break;\n                    default:\n                        if (!this.scanner.lastTokenHadNewline()) {\n                            this.reportParseError("Expected \';\'");\n                        }\n                        else {\n                            ast.flags |= ASTFlags.AutomaticSemicolon;\n                            if (this.style_requireSemi) {\n                                this.reportParseStyleError("no automatic semicolon");\n                            }\n                        }\n                        break;\n                }\n            }\n            if (labelList) {\n                ast = new LabeledStatement(labelList, ast);\n            }\n\n            ///////////////////////////////////////////////////////////\n            //TODO: Eventually, we want to remove "minChar" and "limChar" assignments here,\n            //      as they are sometimes not specific enough for each statement kind.\n            ast.minChar = minChar;\n            // Only update "limChar" if it is not better than "lastTokenLimChar()"\n            ast.limChar = max(ast.limChar, this.scanner.lastTokenLimChar());\n            //\n            ///////////////////////////////////////////////////////////\n\n            if (preComments) {\n                ast.preComments = preComments;\n            }\n            if (this.ambientModule && (!this.okAmbientModuleMember(ast))) {\n                this.reportParseError("statement not permitted within ambient module");\n            }\n            ast.flags |= ASTFlags.IsStatement;\n            return ast;\n        }\n\n        private okAmbientModuleMember(ast: AST) {\n            var nt = ast.nodeType;\n            return (nt == NodeType.ClassDeclaration) || (nt == NodeType.ImportDeclaration) || (nt == NodeType.InterfaceDeclaration) || (nt == NodeType.ModuleDeclaration) ||\n                (nt == NodeType.Empty) || (nt == NodeType.VarDecl) || \n                ((nt == NodeType.Block) && !(<Block>ast).isStatementBlock) ||\n                ((nt == NodeType.FuncDecl) && ((<FuncDecl>ast).isMethod()));\n        }\n\n        private parseStatementList(errorRecoverySet: ErrorRecoverySet,\n                                   statements: ASTList,\n                                   sourceElms: bool,\n                                   noLeadingCase: bool,\n                                   allowedElements: A',
v27581=v27582+'llowedElements,\n                                   parentModifiers: Modifiers): void {\n            var directivePrologue = sourceElms;\n            statements.minChar = this.scanner.startPos;\n            var limChar = this.scanner.pos;\n            var innerStmts = (allowedElements & AllowedElements.ModuleDeclarations) == AllowedElements.None;\n            var classNope = (allowedElements & AllowedElements.ClassDeclarations) == AllowedElements.None;\n\n            errorRecoverySet |= ErrorRecoverySet.TypeScriptS | ErrorRecoverySet.RCurly;\n\n            this.state = ParseState.StartStatementList;\n            var oldStrictMode = this.strictMode;\n            this.nestingLevel++;\n            for (; ;) {\n                if ((this.currentToken.tokenId == TokenID.CloseBrace) ||\n                    (noLeadingCase && ((this.currentToken.tokenId == TokenID.Case) || (this.currentToken.tokenId == TokenID.Default))) ||\n                    (innerStmts && (this.currentToken.tokenId == TokenID.Export)) ||\n                    (classNope && (this.currentToken.tokenId == TokenID.Class)) ||\n                    (this.currentToken.tokenId == TokenID.EndOfFile)) {\n                    this.state = ParseState.EndStmtList;\n                    statements.limChar = limChar;\n                    if (statements.members.length == 0) {\n                        statements.preComments = this.parseComments();\n                    }\n                    else {\n                        statements.postComments = this.parseComments();\n                    }\n                    this.strictMode = oldStrictMode;\n                    this.nestingLevel--;\n                    return;\n                }\n\n                var stmt = this.parseStatement(errorRecoverySet &\n                                        (~(ErrorRecoverySet.Else | ErrorRecoverySet.RParen |\n                                           ErrorRecoverySet.Catch | ErrorRecoverySet.Colon)),\n                                        allowedElements, parentModifiers);\n\n\n                if (stmt) {\n                    stmt.postComments = this.combineComments(stmt.postComments, this.parseCommentsForLine(this.scanner.prevLine));\n                    statements.append(stmt);\n                    limChar = stmt.limChar;\n                    if (directivePrologue) {\n                        if (stmt.nodeType == NodeType.QString) {\n                            var qstring = <StringLiteral>stmt;\n                            if (qstring.text == "\\"use strict\\"") {\n                                statements.flags |= ASTFlags.StrictMode;\n                                this.strictMode = true;\n                            }\n                            else {\n                                directivePrologue = false;\n                            }\n                        }\n                        else {\n                            directivePrologue = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        private fname = "";\n\n        public quickParse(sourceText: ISourceText, filename: string, unitIndex: number): QuickParseResult {\n            //TODO: REVIEW: We set this to avoid adding a "module" decl in the resulting script (see parse() method)\n            var svGenTarget = TypeScript.moduleGenTarget;\n            try {\n                TypeScript.moduleGenTarget = TypeScript.ModuleGenTarget.Local;\n                var script = this.parse(sourceText, filename, unitIndex, AllowedElements.QuickParse);\n                return new QuickParseResult(script, this.scanner.lexState);\n            }\n            finally {\n                TypeScript.moduleGenTarget = svGenTarget;\n            }\n        }\n\n        public parse(sourceText: ISourceText, filename: string, unitIndex: number, allowedElements = AllowedElements.Global): Script {\n            // Reset all parser state here.  This allows us to be resilient to reentrancy if an \n            // exception is thrown.\n            this.fname = filename;\n            this.currentUnitIndex = unitIndex;\n\n            this.currentToken = null;\n            this.needTerminator = false;\n            this.inFunction = false;\n            this.inInterfaceDecl = false;\n            this.inFncDecl = false;\n            this.state = ParseState.StartStatementList;\n            this.ambientModule = false;\n            this.ambientClass = false;\n            this.topLevel = true;\n            this.allowImportDeclaration = true;\n            this.prevIDTok = null;\n            this.statementInfoStack = new IStatementInfo[];\n            this.hasTopLevelImportOrExport = false;\n            this.strictMode = false;\n            this.nestingLevel = 0;\n            this.prevExpr = null;\n            this.currentClassDefinition = null;\n            this.parsingClassConstructorDefinition = false;\n            this.parsingDeclareFile = false;\n            this.amdDependencies = [];\n            this.inferPropertiesFromThisAssignment = false;\n            this.requiresExtendsBlock = false;\n\n',
v27580=v27581+'            this.scanner.resetComments();\n            this.scanner.setErrorHandler((message) =>this.reportParseError(message));\n            this.scanner.setSourceText(sourceText, LexMode.File);\n\n            var leftCurlyCount = this.scanner.leftCurlyCount;\n            var rightCurlyCount = this.scanner.rightCurlyCount;\n\n            var minChar = this.scanner.pos;\n            this.currentToken = this.scanner.scan();\n            this.pushDeclLists();\n            var bod = new ASTList();\n            bod.minChar = minChar;\n\n            this.state = ParseState.StartScript;\n            this.parsingDeclareFile = isDSTRFile(filename) || isDTSFile(filename);\n\n            while (true) {\n                this.parseStatementList(\n                    ErrorRecoverySet.EOF | ErrorRecoverySet.Func,\n                    bod, /*sourceElements:*/ true, /*noLeadingCase:*/ false,\n                    allowedElements, Modifiers.None);\n\n                if (this.currentToken.tokenId === TokenID.EndOfFile) {\n                    break;\n                }\n\n                // Still have remaining tokens in the file.  Report error for this unexpected token,\n                // skip it, and continue trying to parse statements until we\'re done. \n                var badToken = tokenTable[this.currentToken.tokenId];\n                this.reportParseError("Unexpected statement block terminator \'" + badToken.text + "\'");\n\n                this.currentToken = this.scanner.scan();\n            }\n\n            this.state = ParseState.EndScript;\n\n            bod.limChar = this.scanner.pos;\n\n            var topLevelMod: ModuleDeclaration = null;\n            if (moduleGenTarget != ModuleGenTarget.Local && this.hasTopLevelImportOrExport) {\n                var correctedFileName = switchToForwardSlashes(filename);\n                var id: Identifier = new Identifier(correctedFileName);\n                topLevelMod = new ModuleDeclaration(id, bod, this.topVarList(), this.topScopeList(), null);\n\n                topLevelMod.modFlags |= ModuleFlags.IsDynamic;\n                topLevelMod.modFlags |= ModuleFlags.IsWholeFile;\n                topLevelMod.modFlags |= ModuleFlags.Exported;\n\n                if (this.parsingDeclareFile) {\n                    topLevelMod.modFlags |= ModuleFlags.Ambient;\n                }\n\n                topLevelMod.minChar = minChar;\n                topLevelMod.limChar = this.scanner.pos;\n                topLevelMod.prettyName = getPrettyName(correctedFileName);\n                topLevelMod.containsUnicodeChar = this.scanner.seenUnicodeChar;\n                topLevelMod.containsUnicodeCharInComment = this.scanner.seenUnicodeCharInComment;\n\n                topLevelMod.amdDependencies = this.amdDependencies;\n\n                bod = new ASTList();\n                bod.minChar = topLevelMod.minChar;\n                bod.limChar = topLevelMod.limChar;\n                bod.append(topLevelMod);\n            }\n\n            var script = new Script(this.topVarList(), this.topScopeList());\n            script.bod = bod;\n            this.popDeclLists();\n            script.minChar = minChar;\n            script.limChar = this.scanner.pos;\n            script.locationInfo = new LocationInfo(filename, this.scanner.lineMap, unitIndex);\n            script.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n            script.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n            script.isDeclareFile = this.parsingDeclareFile;\n            script.topLevelMod = topLevelMod;\n            script.containsUnicodeChar = this.scanner.seenUnicodeChar;\n            script.containsUnicodeCharInComment = this.scanner.seenUnicodeCharInComment;\n            script.requiresExtendsBlock = this.requiresExtendsBlock;\n            return script;\n        }\n    }\n\n    export function quickParse(logger: TypeScript.ILogger, scopeStartAST: AST, sourceText: ISourceText, minChar: number, limChar: number,\n        errorCapture: (minChar: number, charLen: number, message: string, unitIndex: number) => void ): QuickParseResult {\n\n        var fragment = sourceText.getText(minChar, limChar);\n        logger.log("Quick parse range (" + minChar + "," + limChar + "): \\"" + TypeScript.stringToLiteral(fragment, 100) + "\\"");\n\n        var quickParser = new Parser();\n        quickParser.setErrorRecovery(null);\n        quickParser.errorCallback = errorCapture;\n\n        // REVIEW: use enclosing scope to determine this\n        // REVIEW: Why even use class here?\n        var quickClassDecl = new ClassDeclaration(null, null, null, null);\n        quickParser.currentClassDecl = quickClassDecl;\n\n        var result = quickParser.quickParse(new StringSourceText(fragment), "", 0);\n        return result;\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/license',
v27579=v27580+'s/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    // We need to catch both left and right quotes\n    // (depending on your editor\'s font, this may not be clear...)    \n    export function stripQuotes(str: string) {\n        return str.replace("\\"", "").replace("\'", "").replace("\'", "").replace("\\"", "")\n    }\n\n    export function isQuoted(str: string) {\n        return str.indexOf("\\"") != -1 || str.indexOf("\'") != -1 || str.indexOf("\'") != -1 || str.indexOf("\\"") != -1;\n    }\n\n    export function quoteStr(str: string) {\n        return "\\"" + str + "\\"";\n    }\n\n    export function swapQuotes(str: string) {\n\n        if (str.indexOf("\\"") != -1) {\n            str = str.replace("\\"", "\'");\n            str = str.replace("\\"", "\'");\n        }\n        else {\n            str = str.replace("\'", "\\"");\n            str = str.replace("\'", "\\"");\n        }\n\n        return str;\n    }\n\n    export function switchToForwardSlashes(path: string) {\n        return path.replace(/\\\\/g, "/");\n    }\n\n    export function trimModName(modName: string) {\n        // in case\'s it\'s a declare file...\n        if (modName.length > 6 && modName.substring(modName.length - 6, modName.length) == ".d.str") {\n            return modName.substring(0, modName.length - 6);\n        }\n        if (modName.length > 4 && modName.substring(modName.length - 4, modName.length) == ".str") {\n            return modName.substring(0, modName.length - 4);\n        }\n        if (modName.length > 5 && modName.substring(modName.length - 5, modName.length) == ".d.ts") {\n            return modName.substring(0, modName.length - 5);\n        }\n        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) == ".ts") {\n            return modName.substring(0, modName.length - 3);\n        }\n        // in case\'s it\'s a .js file\n        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) == ".js") {\n            return modName.substring(0, modName.length - 3);\n        }\n\n        return modName;\n    }\n\n    export function getDeclareFilePath(fname: string) {\n        return isSTRFile(fname) ? changePathToDSTR(fname) : isTSFile(fname) ? changePathToDTS(fname) : changePathToDTS(fname);\n    }\n\n    function isFileOfExtension(fname: string, ext: string) {\n        var invariantFname = fname.toLocaleUpperCase();\n        var invariantExt = ext.toLocaleUpperCase();\n        var extLength = invariantExt.length;\n        return invariantFname.length > extLength && invariantFname.substring(invariantFname.length - extLength, invariantFname.length) == invariantExt;\n    }\n\n    export function isJSFile(fname: string) {\n        return isFileOfExtension(fname, ".js");\n    }\n\n    export function isSTRFile(fname: string) {\n        return isFileOfExtension(fname, ".str");\n    }\n\n    export function isTSFile(fname: string) {\n        return isFileOfExtension(fname, ".ts");\n    }\n\n    export function isDSTRFile(fname: string) {\n        return isFileOfExtension(fname, ".d.str");\n    }\n\n    export function isDTSFile(fname: string) {\n        return isFileOfExtension(fname, ".d.ts");\n    }\n\n    export function getPrettyName(modPath: string, quote?=true, treatAsFileName?=false) { \n        var modName = treatAsFileName ? switchToForwardSlashes(modPath) : trimModName(stripQuotes(modPath));\n        var components = this.getPathComponents(modName);\n        return components.length ? (quote ? quoteStr(components[components.length - 1]) : components[components.length - 1]) : modPath;\n    }\n\n    export function getPathComponents(path: string) {\n        return path.split("/");\n    }\n\n    export function getRelativePathToFixedPath(fixedModFilePath: string, absoluteModPath: string) {\n        absoluteModPath = switchToForwardSlashes(absoluteModPath);\n\n        var modComponents = this.getPathComponents(absoluteModPath);\n        var fixedModComponents = this.getPathComponents(fixedModFilePath);\n\n        // Find the component that differs\n        var joinStartIndex = 0;\n        for (; joinStartIndex < modComponents.length && joinStartIndex < fixedModComponents.length ; joinStartIndex++) {\n            if (fixedModComponents[joinStartIndex] != modComponents[joinStartIndex]) {\n                break;\n            }\n        }\n\n        // Get the relative path\n        if (joinStartIndex != 0) {\n            var relativePath = "";\n            var relativePathComponents = modComponents.slice(joinStartIndex, modComponents.length);\n            for (; joinStartIndex < fixedModComponents.length; joinStartIndex++) {\n                if (fixedModComponents[joinStartIndex] != "") {\n                    relativePath = relativePath + "../";\n      ',
v27578=v27579+'          }\n            }\n\n            return relativePath + relativePathComponents.join("/");\n        }\n\n        return absoluteModPath;\n    }\n\n    export function quoteBaseName(modPath: string) {\n        var modName = trimModName(stripQuotes(modPath));\n        var path = getRootFilePath(modName);\n        if (path == "") {\n            return modPath;\n        }\n        else {\n            var components = modName.split(path);\n            var fileIndex = components.length > 1 ? 1 : 0;\n            return quoteStr(components[fileIndex]);\n        }\n    }\n\n    export function changePathToSTR(modPath: string) {\n        return trimModName(stripQuotes(modPath)) + ".str";\n    }\n\n    export function changePathToDSTR(modPath: string) {\n        return trimModName(stripQuotes(modPath)) + ".d.str";\n    }\n\n    export function changePathToTS(modPath: string) {\n        return trimModName(stripQuotes(modPath)) + ".ts";\n    }\n\n    export function changePathToDTS(modPath: string) {\n        return trimModName(stripQuotes(modPath)) + ".d.ts";\n    }\n\n    export function isRelative(path: string) {\n        return path.charAt(0) == ".";\n    }\n    export function isRooted(path: string) {\n        return path.charAt(0) == "\\\\" || path.charAt(0) == "/" || (path.indexOf(":\\\\") != -1) || (path.indexOf(":/") != -1);\n    }\n\n    export function getRootFilePath(outFname: string) {\n        if (outFname == "") {\n            return outFname;\n        }\n        else {\n            var isPath = outFname.indexOf("/") != -1;\n            return isPath ? filePath(outFname) : "";\n        }\n    }\n\n    export function filePathComponents(fullPath: string) {\n        fullPath = switchToForwardSlashes(fullPath);\n        var components = getPathComponents(fullPath);\n        return components.slice(0, components.length - 1);\n    }\n\n    export function filePath(fullPath: string) {\n        var path = filePathComponents(fullPath);\n        return path.join("/") + "/";\n    }\n\n    export function normalizeURL(url: string): string {\n        var hostDomainAndPortRegex = /^(https?:\\/\\/[\\-\\w\\.]+(:\\d+)?\\/)(.*)$/i;\n        var matches = hostDomainAndPortRegex.exec(url);\n        if (matches) {\n            var hostDomainAndPort = matches[1];\n            var actualPath = matches[3];\n            return hostDomainAndPort + normalizePath(actualPath);\n        }\n        return normalizePath(url);\n    }\n\n    export var pathNormalizeRegExp = /\\//g;\n\n    export function normalizePath(path: string): string {\n        path = switchToForwardSlashes(path);\n        var startedWithSep = path.charAt(0) === "/";\n        var parts = this.getPathComponents(path);\n        for (var i = 0; i < parts.length; i++) {\n            if (parts[i] === "." || parts[i] === "") {\n                parts.splice(i, 1);\n                i--;\n            }\n            if (i > 0 && parts[i] === ".." && parts[i - 1] !== "..") {\n                parts.splice(i - 1, 2);\n                i -= 2;\n            }\n        }\n        return (startedWithSep ? "/" : "") + parts.join("/");\n    }\n\n    export function normalizeImportPath(path: string): string {\n        return normalizePath(path);\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    /// Compiler settings\n\n    export class StyleSettings {\n        // bitwise operations not permitted\n        public bitwise = false;  \n        // disallow non-block statements as bodies of compound statements\n        public blockInCompoundStmt = false;\n        // disallow == and !=\n        public eqeqeq = false;\n        // require body of for in loop to start with a filter\n        public forin = false;\n        // empty blocks permitted\n        public emptyBlocks = true;\n        // require result of new expression to be used (no new just for side-effects)\n        public newMustBeUsed = false;\n        // require semicolons to terminate statements\n        public requireSemi = false;\n        // no top-level assignment in conditionals if (a=b) { ...\n        public assignmentInCond = false;\n        // no == null or != null\n        public eqnull = false;\n        // permit eval\n        public evalOK = true;\n        // permit var use if decl in inner scope as in if (c) { var v=10; } v=11;\n        public innerScopeDeclEscape = true;\n        // permit functions in loops\n        public funcInLoop = true;\n        // permit re-declaration of local variable \n        public reDecl',
v27577=v27578+'areLocal = true;\n        // permit obj[\'x\'] in addition to obj.x\n        public literalSubscript = true;\n        // flag implicit \'any\'\n        public implicitAny = false;\n\n        public setOption(opt: string, val: bool): bool {\n            var optExists = this[opt];\n            if (optExists !== undefined) {\n                this[opt] = val;\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n        \n        public parseOptions(str: string) {\n            var opts=str.split(";");\n            for (var i = 0, len = opts.length; i < len; i++) {\n                var opt = opts[i];\n                var val = true;\n                var colonIndex=opt.lastIndexOf(":");\n                if (colonIndex >= 0) {\n                    var valStr = opt.substring(colonIndex+1);\n                    opt = opt.substring(0, colonIndex);\n                    if (valStr == "off") {\n                        val = false;\n                    }\n                }\n                if (!this.setOption(opt, val)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    \n    export class CompilationSettings {\n        public styleSettings = new StyleSettings();\n        public propagateConstants = false;\n        public minWhitespace = false;\n        public parseOnly = false;\n        public errorRecovery = false;\n        public emitComments = false;\n        public watch = false;\n        public exec = false;\n        public resolve = true;\n        public controlFlow = false;\n        public printControlFlow = false;\n        public controlFlowUseDef = false;\n        public errorOnWith = true;\n        public preprocess = true;\n        public canCallDefinitionSignature = false;\n\n        public inferPropertiesFromThisAssignment = false;\n        public useDefaultLib = true;\n\n        public codeGenTarget = CodeGenTarget.ES3;\n        public moduleGenTarget = ModuleGenTarget.Synchronous;\n        // --out option passed. \n        // Default is the "" which leads to multiple files generated next to the.ts files\n        public outputOption: string = "";\n        public mapSourceFiles = false;\n        public generateDeclarationFiles = false;\n\n        public useCaseSensitiveFileResolution = false;\n\n        public setStyleOptions(str: string) {\n            this.styleSettings.parseOptions(str);\n        }\n    }\n\n    ///\n    /// Preprocessing\n    ///\n    export interface IPreProcessedFileInfo {\n        settings: CompilationSettings;\n        referencedFiles: IFileReference[];\n        importedFiles: IFileReference[];\n        isLibFile: bool;\n    }\n\n    function getFileReferenceFromReferencePath(comment: string): IFileReference {\n        var referencesRegEx = /^(\\/\\/\\/\\s*<reference\\s+path=)(\'|")(.+?)\\2\\s*(static=(\'|")(.+?)\\2\\s*)*\\/>/gim;\n        var match = referencesRegEx.exec(comment);\n\n        if (match) {\n            var path: string = normalizePath(match[3]);\n            var adjustedPath = normalizePath(path);\n    \n            var isResident = match.length >= 7 && match[6] == "true";\n            if (isResident) {\n                CompilerDiagnostics.debugPrint(path + " is resident");\n            }\n            return { minChar: 0, limChar: 0, path: switchToForwardSlashes(adjustedPath), isResident: isResident };\n        }\n        else {\n            return null;\n        }\n    }\n\n    // used in the parser, but kept here in case we want to reintegrate it with preprocessing\n    export function getAdditionalDependencyPath(comment: string): string {\n        var amdDependencyRegEx = /^(\\/\\/\\/\\s*<amd-dependency\\s+path=)(\'|")(.+?)\\2\\s*(static=(\'|")(.+?)\\2\\s*)*\\/>/gim;\n        var match = amdDependencyRegEx.exec(comment);\n\n        if (match) {\n            var path: string = match[3];\n            return path;\n        }\n        else {\n            return null;\n        }\n    }\n\n    export function getImplicitImport(comment: string): bool {\n        var implicitImportRegEx = /^(\\/\\/\\/\\s*<implicit-import\\s*)*\\/>/gim;\n        var match = implicitImportRegEx.exec(comment);\n\n        if (match) {\n            return true;\n        }\n        \n        return false;\n    }\n\n    export function getStyleSettings(comment: string, styleSettings: StyleSettings) {\n        var styleRegEx = /^(\\/\\/\\/\\s*<style\\s+)(([a-zA-Z])+=(\'|").+(\'|"))\\s*\\/>/gim;\n\n        var settings = styleRegEx.exec(comment);\n\n        if (settings) {\n            var settingsRegEx = /^([a-zA-Z]+=[\'"]on[\'|"])/gim;\n            settings = settingsRegEx.exec(settings[2]);\n                \n            if (settings) {\n                for (var i = 0; i < settings.length; i++) {\n                    var setting = (<string>settings[i]).split("=");\n                    var on = "\\"on\\"";\n\n                    switch (setting[0]) {\n                        case "blockInCompoundStmt": styleSettings.blockInCompoundStmt = setting[1] == on; break;\n                        case "eqeqeq": styleSettings.eqeqeq = setting[1] == on; break;',
v27576=v27577+'\n                        case "forin": styleSettings.forin = setting[1] == on; break;\n                        case "emptyBlocks": styleSettings.emptyBlocks = setting[1] == on; break;\n                        case "newMustBeUsed": styleSettings.newMustBeUsed = setting[1] == on; break;\n                        case "requireSemi": styleSettings.requireSemi = setting[1] == on; break;\n                        case "assignmentInCond": styleSettings.assignmentInCond = setting[1] == on; break;\n                        case "eqnull": styleSettings.eqnull = setting[1] == on; break;\n                        case "evalOK": styleSettings.evalOK = setting[1] == on; break;\n                        case "innerScopeDeclEscape": styleSettings.innerScopeDeclEscape = setting[1] == on; break;\n                        case "funcInLoop": styleSettings.funcInLoop = setting[1] == on; break;\n                        case "reDeclareLocal": styleSettings.reDeclareLocal = setting[1] == on; break;\n                        case "literalSubscript": styleSettings.literalSubscript = setting[1] == on; break;\n                        case "implicitAny": styleSettings.implicitAny = setting[1] == on; break;                               \n                    }\n                }\n            }\n        }\n    }\n\n    export function getReferencedFiles(sourceText: ISourceText): IFileReference[] {\n        var preProcessInfo = preProcessFile(sourceText, null, false);\n        return preProcessInfo.referencedFiles;\n    }\n\n    export function preProcessFile(sourceText: ISourceText, options=new CompilationSettings(), readImportFiles? = true): IPreProcessedFileInfo {\n        var scanner = new Scanner();\n        scanner.resetComments();\n        scanner.setSourceText(sourceText, LexMode.File);\n\n        var tok: Token = scanner.scan();\n        var comments: CommentToken[] = [];\n        var comment: CommentToken = null;\n        var leftCurlies: Token[] = [];\n\n        var settings: CompilationSettings = options;\n        var referencedFiles: IFileReference[] = [];\n        var importedFiles: IFileReference[] = [];\n        var isLibFile: bool = false;\n\n        // only search out dynamic mods\n        // if you find a dynamic mod, ignore every other mod inside, until you balance rcurlies\n\n        while (tok.tokenId != TokenID.EndOfFile) {\n\n            if (readImportFiles && tok.tokenId == TokenID.Import) {\n\n                tok = scanner.scan();\n\n                if (tok.tokenId == TokenID.Identifier || convertTokToID(tok, false)) {\n                    tok = scanner.scan();\n\n                    if (tok.tokenId == TokenID.Equals) {\n                        tok = scanner.scan();\n\n                        if (tok.tokenId == TokenID.Module) {\n                            tok = scanner.scan();\n                            if (tok.tokenId == TokenID.OpenParen) {\n                                tok = scanner.scan();\n\n                                // import foo = module("foo")\n                                if (tok.tokenId == TokenID.StringLiteral) {\n                                    var ref = { minChar: scanner.startPos, limChar: scanner.pos, path: stripQuotes(switchToForwardSlashes(tok.getText())), isResident: false };\n                                    importedFiles.push(ref);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (tok.tokenId == TokenID.OpenBrace) {\n                leftCurlies.push(tok);\n            }\n\n            if (tok.tokenId == TokenID.CloseBrace) {\n                leftCurlies.pop();\n            }\n\n            tok = scanner.scan();\n        }\n\n        // deal with comment references, amd dependencies and style settings\n        // REVIEW: We could potentially do this inline with the above, if we\n        // set Scanner::scanComments to \'true\'\n        comments = scanner.getComments();\n\n        for (var iComment = 0; iComment < comments.length; iComment++) {\n            comment = comments[iComment];\n            \n            if (!comment.isBlock) {\n                var referencedCode = getFileReferenceFromReferencePath(comment.getText());\n                if (referencedCode) {\n                    referencedCode.minChar = comment.startPos;\n                    referencedCode.limChar = referencedCode.minChar + comment.value.length;\n                    referencedFiles.push(referencedCode);\n                }\n\n                if (settings) {\n                    getStyleSettings(comment.getText(), settings.styleSettings);\n\n                    // is it a lib file?\n                    var isNoLibRegex = /^(\\/\\/\\/\\s*<reference\\s+no-default-lib=)(\'|")(.+?)\\2\\s*\\/>/gim;\n                    var isNoLibMatch: any = isNoLibRegex.exec(comment.getText());\n                    if (isNoLibMatch) {\n                        isLibFile = (isNoLibMatch[3] == "true");\n                    }\n                }\n            }\n        }\n\n        return { settings: settings, referencedFiles: refere',
v27575=v27576+'ncedFiles, importedFiles: importedFiles, isLibFile: isLibFile };\n    }\n\n} // Tools//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    // TODO: refactor indent logic for use in emit\n    export class PrintContext {\n        public builder = "";\n        public indent1 = "  ";\n        public indentStrings: string[] = [];\n        public indentAmt = 0;\n\n        constructor (public outfile: ITextWriter, public parser: Parser) {\n        }\n\n        public increaseIndent() {\n            this.indentAmt++;\n        }\n\n        public decreaseIndent() {\n            this.indentAmt--;\n        }\n\n        public startLine() {\n            if (this.builder.length > 0) {\n                CompilerDiagnostics.Alert(this.builder);\n            }\n            var indentString = this.indentStrings[this.indentAmt];\n            if (indentString === undefined) {\n                indentString = "";\n                for (var i = 0; i < this.indentAmt; i++) {\n                    indentString += this.indent1;\n                }\n                this.indentStrings[this.indentAmt] = indentString;\n            }\n            this.builder += indentString;\n        }\n\n        public write(s) {\n            this.builder += s;\n        }\n\n        public writeLine(s) {\n            this.builder += s;\n            this.outfile.WriteLine(this.builder);\n            this.builder = "";\n        }\n\n    }\n\n    export function prePrintAST(ast: AST, parent: AST, walker: IAstWalker) {\n        var pc: PrintContext = <PrintContext>walker.state;\n\n        ast.print(pc);\n        pc.increaseIndent();\n        return ast;\n    }\n\n\n    export function postPrintAST(ast: AST, parent: AST, walker: IAstWalker) {\n        var pc: PrintContext = <PrintContext>walker.state;\n        pc.decreaseIndent();\n        return ast;\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export interface IResolvedFile {\n        content: string;\n        path: string;\n    }\n\n    /// This class acts as a convenience class to store path and content information in places\n    /// where we need an ISourceText object\n    export class SourceUnit implements ISourceText, IResolvedFile {\n        public referencedFiles: IFileReference[] = null;\n        constructor(public path: string, public content: string) {\n        }\n\n        public getText(start: number, end: number): string { return this.content.substring(start, end); }\n        public getLength(): number { return this.content.length; }\n    }\n\n    export interface IFileReference {\n        minChar: number;\n        limChar: number;\n        path: string;\n        isResident: bool;\n    }\n\n    /// Limited API for file system manipulation\n    export interface IFileSystemObject {\n        resolvePath(path: string): string;\n        readFile(path: string): string;\n        findFile(rootPath: string, partialFilePath: string): IResolvedFile;\n        dirName(path: string): string;\n    }\n\n    export class CompilationEnvironment {\n        constructor (public compilationSettings: CompilationSettings, public ioHost: IFileSystemObject) { }\n        public residentCode: SourceUnit[] = [];\n        public code: SourceUnit[] = [];\n    }\n\n    export interface IResolutionDispatcher {\n        postResolutionError(errorFile: string, errorMessage: string, errorObject: any): void;\n        postResolution(path: string, source: ISourceText): void;\n    }\n\n    export interface ICodeResolver {\n        resolveCode(referencePath: string, rootPath: string, performSearch:bool, state: IResolutionDispatcher): void;\n    }\n\n    export interface IResolverHost {\n        resolveCompilationEnvironment(preEnvironment: CompilationEnvironment, resolver: ICodeResolver, traceDependencies: bool): CompilationEnvironment;\n    }\n\n    export class CodeResolver implements T',
v27574=v27575+'ypeScript.ICodeResolver {\n        public visited: any = { };\n\n        constructor (public environment: CompilationEnvironment) { }\n\n        public resolveCode(referencePath: string, parentPath: string, performSearch: bool, resolutionDispatcher: TypeScript.IResolutionDispatcher): void {\n            \n            var resolvedFile: IResolvedFile = { content: null, path: referencePath };\n            \n            var ioHost = this.environment.ioHost;\n            \n            // If the path is relative, normalize it, based on the root\n            var isRelativePath = TypeScript.isRelative(referencePath);\n            var isRootedPath = isRelativePath ? false : isRooted(referencePath);\n            var normalizedPath: string = \n                isRelativePath ? ioHost.resolvePath(parentPath + "/" + referencePath) : \n                // we only follow the second clause if the path is a non-rooted triple-slash reference path\n                (isRootedPath || !parentPath || performSearch ? referencePath : parentPath + "/" + referencePath);\n\n            // We use +=.ts to make sure we don\'t accidentally pick up ".js" files or the like\n            if (!isSTRFile(normalizedPath) && !isTSFile(normalizedPath)) {\n                normalizedPath += ".ts";  //changePathToSTR(normalizedPath);\n            }\n\n            normalizedPath = switchToForwardSlashes(stripQuotes(normalizedPath));\n            var absoluteModuleID = this.environment.compilationSettings.useCaseSensitiveFileResolution ? normalizedPath : normalizedPath.toLocaleUpperCase();\n            // read the file contents - if it doesn\'t exist, trigger a resolution error\n            if (!this.visited[absoluteModuleID]) {\n\n                // if the path is relative, or came from a reference tag, we don\'t perform a search\n                if (isRelativePath || isRootedPath || !performSearch) {\n                    try {\n                        CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);\n                            \n                        // Look for the .ts file first - if not present, use the .ts, the .d.str and the .d.ts\n                        try {\n                            resolvedFile.content = ioHost.readFile(normalizedPath);\n                        }\n                        catch (err) {\n                            try {\n                                if (isSTRFile(normalizedPath)) {\n                                    normalizedPath = changePathToTS(normalizedPath);\n                                }\n                                else if (isTSFile(normalizedPath)) {\n                                    normalizedPath = changePathToSTR(normalizedPath);\n                                }\n                                CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);\n                                resolvedFile.content = ioHost.readFile(normalizedPath);\n                            }\n                            catch (err) {\n                                normalizedPath = changePathToDSTR(normalizedPath);\n                                CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);\n\n                                try {\n                                    resolvedFile.content = ioHost.readFile(normalizedPath);\n                                }\n                                catch (err) {\n                                    normalizedPath = changePathToDTS(normalizedPath);\n                                    CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);\n                                    resolvedFile.content = ioHost.readFile(normalizedPath);\n                                }\n                            }\n                        }\n                        CompilerDiagnostics.debugPrint("   Found code at " + normalizedPath);\n\n                        resolvedFile.path = normalizedPath;\n                        this.visited[absoluteModuleID] = true;\n                    }\n                    catch (err) {\n                        CompilerDiagnostics.debugPrint("   Did not find code for " + referencePath);\n                    }\n                }\n                else {\n\n                    // if the path is non-relative, we should attempt to search on the relative path\n                    resolvedFile = ioHost.findFile(parentPath, normalizedPath);\n\n                    if (!resolvedFile) {\n                        if (isSTRFile(normalizedPath)) {\n                            normalizedPath = changePathToTS(normalizedPath);\n                        }\n                        else if (isTSFile(normalizedPath)) {\n                            normalizedPath = changePathToSTR(normalizedPath);\n                        }\n                        resolvedFile = ioHost.findFile(parentPath, normalizedPath);\n                    }\n\n                    if (!resolvedFile) {\n                        normalizedPath = changePathToDTS(normalizedPath);\n                        resolvedFile = ioHo',
v27573=v27574+"st.findFile(parentPath, normalizedPath);\n                        if (!resolvedFile) {\n                            normalizedPath = changePathToDSTR(normalizedPath);\n                            resolvedFile = ioHost.findFile(parentPath, normalizedPath);\n                        }\n                    }\n\n                    if (resolvedFile) {\n                        resolvedFile.path = switchToForwardSlashes(TypeScript.stripQuotes(resolvedFile.path));\n                        CompilerDiagnostics.debugPrint(referencePath + \" resolved to: \" + resolvedFile.path);\n                        resolvedFile.content = resolvedFile.content;\n                        this.visited[absoluteModuleID] = true;\n                    }\n                    else {\n                        CompilerDiagnostics.debugPrint(\"Could not find \" + referencePath);\n                    }\n                }\n\n                if (resolvedFile && resolvedFile.content != null) {\n                    // preprocess the file, to gather dependencies\n                    var rootDir = ioHost.dirName(resolvedFile.path);\n                    var sourceUnit = new SourceUnit(resolvedFile.path, resolvedFile.content);\n                    var preProcessedFileInfo = preProcessFile(sourceUnit, this.environment.compilationSettings);\n                    sourceUnit.referencedFiles = preProcessedFileInfo.referencedFiles;\n\n                    // resolve explicit references\n                    for (var i = 0; i < preProcessedFileInfo.referencedFiles.length; i++) {\n                        var referencedFile = preProcessedFileInfo.referencedFiles[i];\n                        var normalizedPath = isRooted(referencedFile.path) ? referencedFile.path : rootDir + \"/\" + referencedFile.path;\n                        normalizedPath = ioHost.resolvePath(normalizedPath);\n                        if (referencePath == normalizedPath) {\n                            resolutionDispatcher.postResolutionError(normalizedPath, \"File contains reference to itself\", null);\n                            continue;\n                        }\n                        this.resolveCode(referencedFile.path, rootDir, false, resolutionDispatcher);\n                    }\n                    \n                    // resolve imports\n                    for (var i = 0; i < preProcessedFileInfo.importedFiles.length; i++) {\n                        this.resolveCode(preProcessedFileInfo.importedFiles[i].path, rootDir, true, resolutionDispatcher);\n                    }\n\n                    // add the file to the appropriate code list\n                    resolutionDispatcher.postResolution(sourceUnit.path, sourceUnit);\n                }\n            }\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path='typescript.ts' />\n\nmodule TypeScript {\n\n    export var LexEOF = (-1);\n\n    export var LexCodeNWL = 0x0A;\n    export var LexCodeRET = 0x0D;\n    export var LexCodeLS =  0x2028;\n    export var LexCodePS =  0x2029;\n    export var LexCodeTAB = 0x09;\n    export var LexCodeVTAB = 0x0B;\n    export var LexCode_e = 'e'.charCodeAt(0);\n    export var LexCode_E = 'E'.charCodeAt(0);\n    export var LexCode_x = 'x'.charCodeAt(0);\n    export var LexCode_X = 'X'.charCodeAt(0);\n    export var LexCode_a = 'a'.charCodeAt(0);\n    export var LexCode_A = 'A'.charCodeAt(0);\n    export var LexCode_f = 'f'.charCodeAt(0);\n    export var LexCode_F = 'F'.charCodeAt(0);\n\n    export var LexCode_g = 'g'.charCodeAt(0);\n    export var LexCode_m = 'm'.charCodeAt(0);\n    export var LexCode_i = 'i'.charCodeAt(0);\n\n    export var LexCode_u = 'u'.charCodeAt(0);\n\n    export var LexCode_0 = '0'.charCodeAt(0);\n    export var LexCode_9 = '9'.charCodeAt(0);\n    export var LexCode_8 = '8'.charCodeAt(0);\n    export var LexCode_7 = '7'.charCodeAt(0);\n\n    export var LexCodeBSL = '\\\\'.charCodeAt(0);\n    export var LexCodeSHP = '#'.charCodeAt(0);\n    export var LexCodeBNG = '!'.charCodeAt(0);\n    export var LexCodeQUO = '\"'.charCodeAt(0);\n    export var LexCodeAPO = '\\''.charCodeAt(0);\n    export var LexCodePCT = '%'.charCodeAt(0);\n    export var LexCodeAMP = '&'.charCodeAt(0);\n    export var LexCodeLPR = '('.charCodeAt(0);\n    export var LexCodeRPR = ')'.charCodeAt(0);\n    export var LexCodePLS = '+'.charCodeAt(0);\n    export var LexCodeMIN = '-'.charCodeAt(0);\n    export var LexCodeMUL = '*'.charCodeAt(0);\n    export var LexCodeSLH = '/'.charCodeAt(0);\n    export var LexCodeXOR = '^'.",
v27572=v27573+"charCodeAt(0);\n    export var LexCodeCMA = ','.charCodeAt(0);\n    export var LexCodeDOT = '.'.charCodeAt(0);\n    export var LexCodeLT = '<'.charCodeAt(0);\n    export var LexCodeEQ = '='.charCodeAt(0);\n    export var LexCodeGT = '>'.charCodeAt(0);\n    export var LexCodeQUE = '?'.charCodeAt(0);\n    export var LexCodeLBR = '['.charCodeAt(0);\n    export var LexCodeRBR = ']'.charCodeAt(0);\n    export var LexCodeUSC = '_'.charCodeAt(0);\n    export var LexCodeLC = '{'.charCodeAt(0);\n    export var LexCodeRC = '}'.charCodeAt(0);\n    export var LexCodeBAR = '|'.charCodeAt(0);\n    export var LexCodeTIL = '~'.charCodeAt(0);\n    export var LexCodeCOL = ':'.charCodeAt(0);\n    export var LexCodeSMC = ';'.charCodeAt(0);\n    export var LexCodeUnderscore = '_'.charCodeAt(0);\n    export var LexCodeDollar = '$'.charCodeAt(0);\n    export var LexCodeSpace = 32;\n    export var LexCodeAtSign = '@'.charCodeAt(0);\n    export var LexCodeASCIIChars = 128;\n\n    export var LexKeywordTable = undefined;\n    // TODO: use new Token[128];\n    var autoToken: Token[] = new Array(LexCodeASCIIChars);\n    var lexIdStartTable: bool[] = new Array(LexCodeASCIIChars);\n\n    // Unicode range maps\n    // REVIEW: These range maps have been extracted from the Unicode specifications, they might be missing values, and/or include \n    //         incorrect ranges. but for the most they seem to be correct. A more accurate and thorough review is needed.\n\n    /*\n        As per ECMAScript Language Specification 3th Edition, Section 7.6: Identifiers\n        IdentifierStart :: Can contain Unicode 3.0.0  categories Uppercase letter (Lu), Lowercase letter (Ll), Titlecase letter (Lt), Modifier letter (Lm), Other letter (Lo), or Letter number (Nl).\n        IdentifierPart :: Can contain IdentifierStart + Unicode 3.0.0  categories Non-spacing mark (Mn), Combining spacing mark (Mc), Decimal number (Nd), or Connector punctuation (Pc).\n                    \n        Codepoint ranges for ES3 Identifiers are extracted from the Unicode 3.0.0 specification at:\n        http://www.unicode.org/Public/3.0-Update/UnicodeData-3.0.0.txt\n    */\n    var unicodeES3IdStart = [\n\t\t170, 170,181, 181,186, 186,192, 214,216, 246,248, 543,546, 563,592, 685,688, 696,699, 705,720, 721,736, 740,750, 750,890, 890,902, 902,904, 906,908, 908,910, 929,931, 974,976, 983,986, 1011,1024, 1153,1164, 1220,1223, 1224,1227, 1228,1232, 1269,1272, 1273,1329, 1366,1369, 1369,1377, 1415,1488, 1514,\n\t\t1520, 1522,1569, 1594,1600, 1610,1649, 1747,1749, 1749,1765, 1766,1786, 1788,1808, 1808,1810, 1836,1920, 1957,2309, 2361,2365, 2365,2384, 2384,2392, 2401,2437, 2444,2447, 2448,2451, 2472,2474, 2480,2482, 2482,2486, 2489,2524, 2525,2527, 2529,2544, 2545,2565, 2570,2575, 2576,2579, 2600,2602, 2608,2610, 2611,\n\t\t2613, 2614,2616, 2617,2649, 2652,2654, 2654,2674, 2676,2693, 2699,2701, 2701,2703, 2705,2707, 2728,2730, 2736,2738, 2739,2741, 2745,2749, 2749,2768, 2768,2784, 2784,2821, 2828,2831, 2832,2835, 2856,2858, 2864,2866, 2867,2870, 2873,2877, 2877,2908, 2909,2911, 2913,2949, 2954,2958, 2960,2962, 2965,2969, 2970,\n\t\t2972, 2972,2974, 2975,2979, 2980,2984, 2986,2990, 2997,2999, 3001,3077, 3084,3086, 3088,3090, 3112,3114, 3123,3125, 3129,3168, 3169,3205, 3212,3214, 3216,3218, 3240,3242, 3251,3253, 3257,3294, 3294,3296, 3297,3333, 3340,3342, 3344,3346, 3368,3370, 3385,3424, 3425,3461, 3478,3482, 3505,3507, 3515,3517, 3517,\n\t\t3520, 3526,3585, 3632,3634, 3635,3648, 3654,3713, 3714,3716, 3716,3719, 3720,3722, 3722,3725, 3725,3732, 3735,3737, 3743,3745, 3747,3749, 3749,3751, 3751,3754, 3755,3757, 3760,3762, 3763,3773, 3773,3776, 3780,3782, 3782,3804, 3805,3840, 3840,3904, 3911,3913, 3946,3976, 3979,4096, 4129,4131, 4135,4137, 4138,\n\t\t4176, 4181,4256, 4293,4304, 4342,4352, 4441,4447, 4514,4520, 4601,4608, 4614,4616, 4678,4680, 4680,4682, 4685,4688, 4694,4696, 4696,4698, 4701,4704, 4742,4744, 4744,4746, 4749,4752, 4782,4784, 4784,4786, 4789,4792, 4798,4800, 4800,4802, 4805,4808, 4814,4816, 4822,4824, 4846,4848, 4878,4880, 4880,4882, 4885,\n\t\t4888, 4894,4896, 4934,4936, 4954,5024, 5108,5121, 5740,5743, 5750,5761, 5786,5792, 5866,6016, 6067,6176, 6263,6272, 6312,7680, 7835,7840, 7929,7936, 7957,7960, 7965,7968, 8005,8008, 8013,8016, 8023,8025, 8025,8027, 8027,8029, 8029,8031, 8061,8064, 8116,8118, 8124,8126, 8126,8130, 8132,8134, 8140,8144, 8147,\n\t\t8150, 8155,8160, 8172,8178, 8180,8182, 8188,8319, 8319,8450, 8450,8455, 8455,8458, 8467,8469, 8469,8473, 8477,8484, 8484,8486, 8486,8488, 8488,8490, 8493,8495, 8497,8499, 8505,8544, 8579,12293, 12295,12321, 12329,12337, 12341,12344, 12346,12353, 12436,12445, 12446,12449, 12538,12540, 12542,12549, 12588,\n\t\t12593, 12686,12704, 12727,13312, 13312,19893, 19893,19968, 19968,40869, 40869,40960, 42124,44032, 44032,55203, 55203,63744, 64045,64256, 64262,64275, 64279,64285, 64285,64287, 64296,64298, 64310,64312, 64316,64318, 64318,64320, 64321,64323, 64324,64326, 64433,64467, 64829,64848, 64911,64914, 64967,\n\t\t65008, 65019,65136, 65138,65140, 65140,65142, 65276,65313, 65338,65345, 65370,65382, 654",
v27571=v27572+"70,65474, 65479,65482, 65487,65490, 65495,65498, 65500\n\t];\n\n\tvar unicodeES3IdCont = [\n\t\t768, 846,864, 866,1155, 1158,1425, 1441,1443, 1465,1467, 1469,1471, 1471,1473, 1474,1476, 1476,1611, 1621,1632, 1641,1648, 1648,1750, 1756,1759, 1764,1767, 1768,1770, 1773,1776, 1785,1809, 1809,1840, 1866,1958, 1968,2305, 2307,2364, 2364,2366, 2381,2385, 2388,2402, 2403,2406, 2415,2433, 2435,2492, 2492,\n\t\t2494, 2500,2503, 2504,2507, 2509,2519, 2519,2530, 2531,2534, 2543,2562, 2562,2620, 2620,2622, 2626,2631, 2632,2635, 2637,2662, 2673,2689, 2691,2748, 2748,2750, 2757,2759, 2761,2763, 2765,2790, 2799,2817, 2819,2876, 2876,2878, 2883,2887, 2888,2891, 2893,2902, 2903,2918, 2927,2946, 2947,3006, 3010,3014, 3016,\n\t\t3018, 3021,3031, 3031,3047, 3055,3073, 3075,3134, 3140,3142, 3144,3146, 3149,3157, 3158,3174, 3183,3202, 3203,3262, 3268,3270, 3272,3274, 3277,3285, 3286,3302, 3311,3330, 3331,3390, 3395,3398, 3400,3402, 3405,3415, 3415,3430, 3439,3458, 3459,3530, 3530,3535, 3540,3542, 3542,3544, 3551,3570, 3571,3633, 3633,\n\t\t3636, 3642,3655, 3662,3664, 3673,3761, 3761,3764, 3769,3771, 3772,3784, 3789,3792, 3801,3864, 3865,3872, 3881,3893, 3893,3895, 3895,3897, 3897,3902, 3903,3953, 3972,3974, 3975,3984, 3991,3993, 4028,4038, 4038,4140, 4146,4150, 4153,4160, 4169,4182, 4185,4969, 4977,6068, 6099,6112, 6121,6160, 6169,6313, 6313,\n\t\t8255, 8256,8400, 8412,8417, 8417,12330, 12335,12441, 12442,12539, 12539,64286, 64286,65056, 65059,65075, 65076,65101, 65103,65296, 65305,65343, 65343,65381, 65381\n\t];\n\n\n    /*\n        As per ECMAScript Language Specification 5th Edition, Section 7.6: Identifier Names and Identifiers\n        IdentifierStart :: Can contain Unicode 6.2  categories Uppercase letter (Lu), Lowercase letter (Ll), Titlecase letter (Lt), Modifier letter (Lm), Other letter (Lo), or Letter number (Nl).\n        IdentifierPart :: Can contain IdentifierStart + Unicode 6.2  categories Non-spacing mark (Mn), Combining spacing mark (Mc), Decimal number (Nd), Connector punctuation (Pc), <ZWNJ>, or <ZWJ>.\n                    \n        Codepoint ranges for ES5 Identifiers are extracted from the Unicode 6.2 specification at:\n        http://www.unicode.org/Public/6.2.0/ucd/UnicodeData.txt\n    */\n\tvar unicodeES5IdStart = [\n\t\t170, 170,181, 181,186, 186,192, 214,216, 246,248, 705,710, 721,736, 740,748, 748,750, 750,880, 884,886, 887,890, 893,902, 902,904, 906,908, 908,910, 929,931, 1013,1015, 1153,1162, 1319,1329, 1366,1369, 1369,1377, 1415,1488, 1514,1520, 1522,1568, 1610,1646, 1647,1649, 1747,1749, 1749,1765, 1766,1774, 1775,\n\t\t1786, 1788,1791, 1791,1808, 1808,1810, 1839,1869, 1957,1969, 1969,1994, 2026,2036, 2037,2042, 2042,2048, 2069,2074, 2074,2084, 2084,2088, 2088,2112, 2136,2208, 2208,2210, 2220,2308, 2361,2365, 2365,2384, 2384,2392, 2401,2417, 2423,2425, 2431,2437, 2444,2447, 2448,2451, 2472,2474, 2480,2482, 2482,2486, 2489,\n\t\t2493, 2493,2510, 2510,2524, 2525,2527, 2529,2544, 2545,2565, 2570,2575, 2576,2579, 2600,2602, 2608,2610, 2611,2613, 2614,2616, 2617,2649, 2652,2654, 2654,2674, 2676,2693, 2701,2703, 2705,2707, 2728,2730, 2736,2738, 2739,2741, 2745,2749, 2749,2768, 2768,2784, 2785,2821, 2828,2831, 2832,2835, 2856,2858, 2864,\n\t\t2866, 2867,2869, 2873,2877, 2877,2908, 2909,2911, 2913,2929, 2929,2947, 2947,2949, 2954,2958, 2960,2962, 2965,2969, 2970,2972, 2972,2974, 2975,2979, 2980,2984, 2986,2990, 3001,3024, 3024,3077, 3084,3086, 3088,3090, 3112,3114, 3123,3125, 3129,3133, 3133,3160, 3161,3168, 3169,3205, 3212,3214, 3216,3218, 3240,\n\t\t3242, 3251,3253, 3257,3261, 3261,3294, 3294,3296, 3297,3313, 3314,3333, 3340,3342, 3344,3346, 3386,3389, 3389,3406, 3406,3424, 3425,3450, 3455,3461, 3478,3482, 3505,3507, 3515,3517, 3517,3520, 3526,3585, 3632,3634, 3635,3648, 3654,3713, 3714,3716, 3716,3719, 3720,3722, 3722,3725, 3725,3732, 3735,3737, 3743,\n\t\t3745, 3747,3749, 3749,3751, 3751,3754, 3755,3757, 3760,3762, 3763,3773, 3773,3776, 3780,3782, 3782,3804, 3807,3840, 3840,3904, 3911,3913, 3948,3976, 3980,4096, 4138,4159, 4159,4176, 4181,4186, 4189,4193, 4193,4197, 4198,4206, 4208,4213, 4225,4238, 4238,4256, 4293,4295, 4295,4301, 4301,4304, 4346,4348, 4680,\n\t\t4682, 4685,4688, 4694,4696, 4696,4698, 4701,4704, 4744,4746, 4749,4752, 4784,4786, 4789,4792, 4798,4800, 4800,4802, 4805,4808, 4822,4824, 4880,4882, 4885,4888, 4954,4992, 5007,5024, 5108,5121, 5740,5743, 5759,5761, 5786,5792, 5866,5870, 5872,5888, 5900,5902, 5905,5920, 5937,5952, 5969,5984, 5996,5998, 6000,\n\t\t6016, 6067,6103, 6103,6108, 6108,6176, 6263,6272, 6312,6314, 6314,6320, 6389,6400, 6428,6480, 6509,6512, 6516,6528, 6571,6593, 6599,6656, 6678,6688, 6740,6823, 6823,6917, 6963,6981, 6987,7043, 7072,7086, 7087,7098, 7141,7168, 7203,7245, 7247,7258, 7293,7401, 7404,7406, 7409,7413, 7414,7424, 7615,7680, 7957,\n\t\t7960, 7965,7968, 8005,8008, 8013,8016, 8023,8025, 8025,8027, 8027,8029, 8029,8031, 8061,8064, 8116,8118, 8124,8126, 8126,8130, 8132,8134, 8140,8144, 8147,8150, 8155,8160, 8172,8178, 8180,8182, 8188,8305, 8305,8319, 8319,8336, 8348,8450, 8450,8455, 8455,8458, 8467,8469, 8469,8473, 8477,84",
v27570=v27571+"84, 8484,8486, 8486,\n\t\t8488, 8488,8490, 8493,8495, 8505,8508, 8511,8517, 8521,8526, 8526,8544, 8584,11264, 11310,11312, 11358,11360, 11492,11499, 11502,11506, 11507,11520, 11557,11559, 11559,11565, 11565,11568, 11623,11631, 11631,11648, 11670,11680, 11686,11688, 11694,11696, 11702,11704, 11710,11712, 11718,11720, 11726,\n\t\t11728, 11734,11736, 11742,11823, 11823,12293, 12295,12321, 12329,12337, 12341,12344, 12348,12353, 12438,12445, 12447,12449, 12538,12540, 12543,12549, 12589,12593, 12686,12704, 12730,12784, 12799,13312, 13312,19893, 19893,19968, 19968,40908, 40908,40960, 42124,42192, 42237,42240, 42508,42512, 42527,\n\t\t42538, 42539,42560, 42606,42623, 42647,42656, 42735,42775, 42783,42786, 42888,42891, 42894,42896, 42899,42912, 42922,43000, 43009,43011, 43013,43015, 43018,43020, 43042,43072, 43123,43138, 43187,43250, 43255,43259, 43259,43274, 43301,43312, 43334,43360, 43388,43396, 43442,43471, 43471,43520, 43560,\n\t\t43584, 43586,43588, 43595,43616, 43638,43642, 43642,43648, 43695,43697, 43697,43701, 43702,43705, 43709,43712, 43712,43714, 43714,43739, 43741,43744, 43754,43762, 43764,43777, 43782,43785, 43790,43793, 43798,43808, 43814,43816, 43822,43968, 44002,44032, 44032,55203, 55203,55216, 55238,55243, 55291,\n\t\t63744, 64109,64112, 64217,64256, 64262,64275, 64279,64285, 64285,64287, 64296,64298, 64310,64312, 64316,64318, 64318,64320, 64321,64323, 64324,64326, 64433,64467, 64829,64848, 64911,64914, 64967,65008, 65019,65136, 65140,65142, 65276,65313, 65338,65345, 65370,65382, 65470,65474, 65479,65482, 65487,\n\t\t65490, 65495,65498, 65500\n\t];\n\n\tvar unicodeES5IdCont = [\n\t\t768, 879,1155, 1159,1425, 1469,1471, 1471,1473, 1474,1476, 1477,1479, 1479,1552, 1562,1611, 1641,1648, 1648,1750, 1756,1759, 1764,1767, 1768,1770, 1773,1776, 1785,1809, 1809,1840, 1866,1958, 1968,1984, 1993,2027, 2035,2070, 2073,2075, 2083,2085, 2087,2089, 2093,2137, 2139,2276, 2302,2304, 2307,2362, 2364,\n\t\t2366, 2383,2385, 2391,2402, 2403,2406, 2415,2433, 2435,2492, 2492,2494, 2500,2503, 2504,2507, 2509,2519, 2519,2530, 2531,2534, 2543,2561, 2563,2620, 2620,2622, 2626,2631, 2632,2635, 2637,2641, 2641,2662, 2673,2677, 2677,2689, 2691,2748, 2748,2750, 2757,2759, 2761,2763, 2765,2786, 2787,2790, 2799,2817, 2819,\n\t\t2876, 2876,2878, 2884,2887, 2888,2891, 2893,2902, 2903,2914, 2915,2918, 2927,2946, 2946,3006, 3010,3014, 3016,3018, 3021,3031, 3031,3046, 3055,3073, 3075,3134, 3140,3142, 3144,3146, 3149,3157, 3158,3170, 3171,3174, 3183,3202, 3203,3260, 3260,3262, 3268,3270, 3272,3274, 3277,3285, 3286,3298, 3299,3302, 3311,\n\t\t3330, 3331,3390, 3396,3398, 3400,3402, 3405,3415, 3415,3426, 3427,3430, 3439,3458, 3459,3530, 3530,3535, 3540,3542, 3542,3544, 3551,3570, 3571,3633, 3633,3636, 3642,3655, 3662,3664, 3673,3761, 3761,3764, 3769,3771, 3772,3784, 3789,3792, 3801,3864, 3865,3872, 3881,3893, 3893,3895, 3895,3897, 3897,3902, 3903,\n\t\t3953, 3972,3974, 3975,3981, 3991,3993, 4028,4038, 4038,4139, 4158,4160, 4169,4182, 4185,4190, 4192,4194, 4196,4199, 4205,4209, 4212,4226, 4237,4239, 4253,4957, 4959,5906, 5908,5938, 5940,5970, 5971,6002, 6003,6068, 6099,6109, 6109,6112, 6121,6155, 6157,6160, 6169,6313, 6313,6432, 6443,6448, 6459,6470, 6479,\n\t\t6576, 6592,6600, 6601,6608, 6617,6679, 6683,6741, 6750,6752, 6780,6783, 6793,6800, 6809,6912, 6916,6964, 6980,6992, 7001,7019, 7027,7040, 7042,7073, 7085,7088, 7097,7142, 7155,7204, 7223,7232, 7241,7248, 7257,7376, 7378,7380, 7400,7405, 7405,7410, 7412,7616, 7654,7676, 7679,8204, 8205,8255, 8256,8276, 8276,\n\t\t8400, 8412,8417, 8417,8421, 8432,11503, 11505,11647, 11647,11744, 11775,12330, 12335,12441, 12442,42528, 42537,42607, 42607,42612, 42621,42655, 42655,42736, 42737,43010, 43010,43014, 43014,43019, 43019,43043, 43047,43136, 43137,43188, 43204,43216, 43225,43232, 43249,43264, 43273,43302, 43309,43335, 43347,\n\t\t43392, 43395,43443, 43456,43472, 43481,43561, 43574,43587, 43587,43596, 43597,43600, 43609,43643, 43643,43696, 43696,43698, 43700,43703, 43704,43710, 43711,43713, 43713,43755, 43759,43765, 43766,44003, 44010,44012, 44013,44016, 44025,64286, 64286,65024, 65039,65056, 65062,65075, 65076,65101, 65103,\n\t\t65296, 65305,65343, 65343\n\t];\n\n    export function LexLookUpUnicodeMap(code: number, map: number[]) : bool {\n        // Perform binary search in one of the unicode range maps\n        var lo: number = 0;\n        var hi: number = map.length;\n        var mid: number;\n\n        while (lo + 1 < hi)\n        {\n            mid = lo + (hi - lo) / 2;\n            // mid has to be even to catch a range's beginning\n            mid -= mid % 2;\n            if (map[mid] <= code && code <= map[mid + 1])\n                return true;\n            if (code < map[mid])\n                hi = mid;\n            else\n                lo = mid + 2;\n        }\n        return false;\n    }\n\n    export function LexIsUnicodeDigit(code: number): bool {\n        if (codeGenTarget == CodeGenTarget.ES3) {\n            return LexLookUpUnicodeMap(code, unicodeES3IdCont);\n        } else {\n            return LexLookUpUnicodeMap(code, unicodeES5IdCont);\n        }\n    ",
v27569=v27570+"}\n\n    export function LexIsUnicodeIdStart(code: number): bool {\n        if (codeGenTarget == CodeGenTarget.ES3) {\n            return LexLookUpUnicodeMap(code, unicodeES3IdStart);\n        } else {\n            return LexLookUpUnicodeMap(code, unicodeES5IdStart);\n        }\n    }\n    export function LexInitialize() {\n        initializeStaticTokens();\n        autoToken[LexCodeLPR] = staticTokens[TokenID.OpenParen];\n        autoToken[LexCodeRPR] = staticTokens[TokenID.CloseParen];\n        autoToken[LexCodeCMA] = staticTokens[TokenID.Comma];\n        autoToken[LexCodeSMC] = staticTokens[TokenID.Semicolon];\n        autoToken[LexCodeLBR] = staticTokens[TokenID.OpenBracket];\n        autoToken[LexCodeRBR] = staticTokens[TokenID.CloseBracket];\n        autoToken[LexCodeTIL] = staticTokens[TokenID.Tilde];\n        autoToken[LexCodeQUE] = staticTokens[TokenID.Question];\n        autoToken[LexCodeLC] = staticTokens[TokenID.OpenBrace];\n        autoToken[LexCodeRC] = staticTokens[TokenID.CloseBrace];\n        autoToken[LexCodeCOL] = staticTokens[TokenID.Colon];\n        LexKeywordTable = new StringHashTable();\n        for (var i in (<any>TokenID)._map) {\n            if ((<number><any>i) <= TokenID.LimKeyword) {\n                LexKeywordTable.add((<any>TokenID)._map[i].toLowerCase(), i);\n            }\n        }\n        for (var j = 0; j < LexCodeASCIIChars; j++) {\n            if (LexIsIdentifierStartChar(j)) {\n                lexIdStartTable[j] = true;\n            }\n            else {\n                lexIdStartTable[j] = false;\n            }\n        }\n    }\n\n    export function LexAdjustIndent(code, indentAmt) {\n        if ((code == LexCodeLBR) || (code == LexCodeLC) || (code == LexCodeLPR)) {\n            return indentAmt + 1;\n        }\n        else if ((code == LexCodeRBR) || (code == LexCodeRC) || (code == LexCodeRPR)) {\n            return indentAmt - 1;\n        }\n        else return indentAmt;\n    }\n\n    export function LexIsIdentifierStartChar(code): bool {\n        return (((code >= 97) && (code <= 122)) ||\n                ((code >= 65) && (code <= 90)) ||\n                (code == LexCodeDollar) ||\n                (code == LexCodeUnderscore));\n    }\n\n    export function LexIsDigit(code): bool {\n        return ((code >= 48) && (code <= 57));\n    }\n\n    export function LexIsIdentifierChar(code:number) {\n        return lexIdStartTable[code] || LexIsDigit(code);\n    }\n\n    export function LexMatchingOpen(code) {\n        if (code == LexCodeRBR)\n            return LexCodeLBR;\n        else if (code == LexCodeRC)\n            return LexCodeLC;\n        else if (code == LexCodeRPR)\n            return LexCodeLPR;\n        else return 0;\n    }\n\n    export enum NumberScanState {\n        Start,\n        InFraction,\n        InEmptyFraction,\n        InExponent\n    }\n\n    export enum LexState {\n        Start,\n        InMultilineComment,\n        InMultilineSingleQuoteString,\n        InMultilineDoubleQuoteString,\n    }\n\n    export enum LexMode {\n        Line,\n        File,\n    }\n\n    export enum CommentStyle {\n        Line,\n        Block\n    }\n\n    // Represent a piece of source code which can be read in multiple segments\n    export interface ISourceText {\n        getText(start: number, end: number): string;\n        getLength(): number;\n    }\n\n    // Implementation on top of a contiguous string\n    export class StringSourceText implements ISourceText {\n        constructor (public text: string) {\n        }\n\n        public getText(start: number, end: number): string {\n            return this.text.substring(start, end);\n        }\n\n        public getLength(): number {\n            return this.text.length;\n        }\n    }\n\n    export class SourceTextSegment implements ISourceTextSegment {\n        constructor (public segmentStart: number,\n                    public segmentEnd: number,\n                    public segment: string) {\n        }\n\n        charCodeAt(index: number): number {\n            return this.segment.charCodeAt(index - this.segmentStart);\n        }\n\n        substring(start: number, end: number): string {\n            return this.segment.substring(start - this.segmentStart, end - this.segmentStart);\n        }\n    }\n\n    export class AggerateSourceTextSegment implements ISourceTextSegment {\n\n        constructor (public seg1: SourceTextSegment, public seg2: SourceTextSegment) { }\n\n        public charCodeAt(index: number): number {\n            if (this.seg1.segmentStart <= index && index < this.seg1.segmentEnd)\n                return this.seg1.segment.charCodeAt(index - this.seg1.segmentStart);\n\n            return this.seg2.segment.charCodeAt(index - this.seg2.segmentStart);\n        }\n\n        public substring(start: number, end: number): string {\n            if (this.seg1.segmentStart <= start && end <= this.seg1.segmentEnd)\n                return this.seg1.segment.substring(start - this.seg1.segmentStart, end - this.seg1.segmentStart);\n\n            return this.seg2.segment.substring(start - this.seg2.segmentStart) + this.seg1.segment.substri",
v27568=v27569+'ng(0, end - this.seg1.segmentStart);\n        }\n    }\n\n    export interface ISourceTextSegment {\n        charCodeAt(index: number): number;\n        substring(start: number, end: number): string;\n    }\n\n    export class ScannerTextStream {\n        static emptySegment = new SourceTextSegment(0, 0, "");\n        public agg: AggerateSourceTextSegment;\n        public len: number;\n\n        constructor (public sourceText: ISourceText) {\n            this.agg = new AggerateSourceTextSegment(ScannerTextStream.emptySegment, ScannerTextStream.emptySegment);\n            this.len = this.sourceText.getLength();\n        }\n\n        public max(a: number, b: number): number {\n            return a >= b ? a : b;\n        }\n\n        public min(a: number, b: number): number {\n            return a <= b ? a : b;\n        }\n\n        public fetchSegment(start: number, end: number): ISourceTextSegment {\n            // Common case\n            if (this.agg.seg1.segmentStart <= start && end <= this.agg.seg1.segmentEnd)\n                return this.agg.seg1;\n\n            // Common overlap case\n            if (this.agg.seg2.segmentStart <= start && end <= this.agg.seg1.segmentEnd)\n                return this.agg;\n\n            // if overlapping outside of fetched segment(s), fetch a new segment\n            var prev = this.agg.seg1;\n\n            var s = prev.segmentEnd;\n            var e = max(s + 512, end); // ensure we move forward at least 512 characters or "end"\n            e = min(e, this.len);    // but don\'t go past the end of the source text\n\n            var src = this.sourceText.getText(s, e);\n            var newSeg = new SourceTextSegment(s, e, src);\n            this.agg.seg2 = prev;\n            this.agg.seg1 = newSeg;\n            return this.agg;\n        }\n\n        public charCodeAt(index: number): number {\n            return this.fetchSegment(index, index + 1).charCodeAt(index);\n        }\n\n        public substring(start: number, end: number) {\n            return this.fetchSegment(start, end).substring(start, end);\n        }\n    }\n\n    export interface IScanner {\n        startPos: number;\n        pos: number;\n        scan(): Token;\n        previousToken(): Token;\n        prevLine: number;\n        line: number;\n        col: number;\n        leftCurlyCount: number;\n        rightCurlyCount: number;\n        lastTokenLimChar(): number;\n        lastTokenHadNewline(): bool;\n        lexState: number;\n        getComments(): CommentToken[];\n        getCommentsForLine(line: number): CommentToken[];\n        resetComments(): void;\n        lineMap: number[];\n        setSourceText(newSrc: ISourceText, textMode: number): void;\n        setErrorHandler(reportError: (message: string) => void): void;\n        seenUnicodeChar: bool;\n        seenUnicodeCharInComment: bool;\n        getLookAheadToken(): Token;\n    }\n\n    export class SavedTokens implements IScanner {\n        public prevToken: Token = null;\n        public curSavedToken: SavedToken = null;\n        public prevSavedToken: SavedToken = null;\n        public currentTokenIndex: number;\n        public currentTokens: SavedToken[];\n        public tokensByLine: SavedToken[][];\n        public lexStateByLine: LexState[];\n        private prevToken: SavedToken = null;\n        public previousToken(): Token { return this.prevToken; }\n        public currentToken = 0;\n        public tokens = new SavedToken[];\n        public startPos: number;\n        public pos: number;\n        public seenUnicodeChar: bool = false;\n        seenUnicodeCharInComment: bool = false;\n\n        public close() {\n            this.currentToken = 0;\n        }\n\n        public addToken(tok: Token, scanner: IScanner) {\n            this.tokens[this.currentToken++] = new SavedToken(tok, scanner.startPos, scanner.pos);\n        }\n\n        public scan(): Token {\n            // TODO: curly count\n            this.startLine = this.line;\n            this.startPos = this.col;\n            if (this.currentTokenIndex == this.currentTokens.length) {\n                if (this.line < this.lineMap.length) {\n                    this.line++;\n                    this.col = 0;\n                    this.currentTokenIndex = 0;\n                    this.currentTokens = this.tokensByLine[this.line];\n                }\n                else {\n                    return staticTokens[TokenID.EndOfFile];\n                }\n            }\n            if (this.currentTokenIndex < this.currentTokens.length) {\n                this.prevToken = this.curSavedToken.tok;\n                this.prevSavedToken = this.curSavedToken;\n                this.curSavedToken = this.currentTokens[this.currentTokenIndex++];\n                var curToken = this.curSavedToken.tok;\n                this.pos = this.curSavedToken.limChar;\n                this.col += (this.curSavedToken.limChar - this.curSavedToken.minChar);\n                this.startPos = this.curSavedToken.minChar;\n                this.prevLine = this.line;\n                return curToken;\n            }\n            else {\n                retur',
v27567=v27568+'n staticTokens[TokenID.EndOfFile];\n            }\n        }\n        public startLine: number;\n        public prevLine = 1;\n        public line = 1;\n        public col = 0;\n        public leftCurlyCount: number;\n        public rightCurlyCount: number;\n\n        public syncToTok(offset: number): number {\n            this.line = getLineNumberFromPosition(this.lineMap, offset);\n            this.currentTokenIndex = 0;\n            var tmpCol = offset - this.lineMap[this.line];\n            while ((this.lexStateByLine[this.line] == LexState.InMultilineComment) && (this.line > 0)) {\n                this.line--;\n                tmpCol = 0;\n            }\n            var lenMin1 = this.lineMap.length - 1;\n            this.currentTokens = this.tokensByLine[this.line];\n            while ((this.currentTokens.length == 0) && (this.line < lenMin1)) {\n                this.line++;\n                this.currentTokens = this.tokensByLine[this.line];\n                tmpCol = 0;\n            }\n            if (this.line <= lenMin1) {\n                while ((this.currentTokenIndex < this.currentTokens.length) &&\n                       (tmpCol > this.currentTokens[this.currentTokenIndex].limChar)) {\n                    this.currentTokenIndex++;\n                }\n                if (this.currentTokenIndex < this.currentTokens.length) {\n                    this.col = this.currentTokens[this.currentTokenIndex].minChar;\n                    return this.col + this.lineMap[this.line];\n                }\n            }\n            return -1;\n        }\n\n        public lastTokenLimChar(): number {\n            if (this.prevSavedToken !== null) {\n                return this.prevSavedToken.limChar;\n            }\n            else {\n                return 0;\n            }\n        }\n\n        public lastTokenHadNewline(): bool {\n            return this.prevLine != this.startLine;\n        }\n\n        public lexState = LexState.Start;\n\n        public commentStack: CommentToken[] = new CommentToken[];\n\n        public pushComment(comment: CommentToken) {\n            this.commentStack.push(comment);\n        }\n\n        public getComments() {\n            var stack = this.commentStack;\n            this.commentStack = [];\n            return stack;\n        }\n\n        public getCommentsForLine(line: number) {\n            var comments: CommentToken[] = null;\n            while ((this.commentStack.length > 0) && (this.commentStack[0].line == line)) {\n                if (comments == null) {\n                    comments = [this.commentStack.shift()];\n                }\n                else {\n                    comments = comments.concat([this.commentStack.shift()]);\n                }\n\n            }\n            return comments;\n        }\n\n        public resetComments() {\n            this.commentStack = [];\n        }\n\n        public lineMap: number[] = [];\n        public setSourceText(newSrc: ISourceText, textMode: number) {\n        }\n        public setErrorHandler(reportError: (message: string) => void ) { \n        }\n        public getLookAheadToken(): Token {\n            throw new Error("Invalid operation.");\n        }\n    }\n\n    export class Scanner implements IScanner {\n        // REVIEW: When adding new variables make sure to handle storing them in getLookAheadToken. \n        //         The method works by storing the state before scanning and restoring it later on, missing a member variable \n        //         could result in an inconsistent state.\n        public prevLine = 1;\n        public line = 1;\n        public col = 0;\n        public pos = 0;\n        public startPos = 0;\n        public startCol: number;\n        public startLine: number;\n        public src: string;\n        public len = 0;\n        public lineMap: number[] = [];\n        \n        public ch = LexEOF;\n        public lexState = LexState.Start;\n        public mode = LexMode.File;\n        public scanComments: bool = true;\n        public interveningWhitespace = false; // Was there a whitespace token between the last token and the current one?\n        private interveningWhitespacePos = 0; //  If yes, this contains the start position of the whitespace\n        public leftCurlyCount = 0;\n        public rightCurlyCount = 0;\n        public commentStack: CommentToken[] = new CommentToken[];\n        public saveScan: SavedTokens = null;\n        public seenUnicodeChar: bool = false;\n        seenUnicodeCharInComment: bool = false;\n\n        private reportError: (message: string) =>void;\n\n        constructor () {\n            this.startCol = this.col;\n            this.startLine = this.line;            \n            this.lineMap[1] = 0;\n            \n            if (!LexKeywordTable) {\n                LexInitialize();\n            }            \n        }\n\n        private prevTok = staticTokens[TokenID.EndOfFile];\n        public previousToken() { return this.prevTok; }\n\n        public setSourceText(newSrc: ISourceText, textMode: number) {\n            this.mode = textMode;\n            this.scanComments = (this.mode === LexMo',
v27566=v27567+"de.Line);\n            this.pos = 0;\n            this.interveningWhitespacePos = 0;\n            this.startPos = 0;\n            this.line = 1;\n            this.col = 0;\n            this.startCol = this.col;\n            this.startLine = this.line;\n            this.len = 0;\n            this.src = newSrc.getText(0, newSrc.getLength());\n            this.len = this.src.length;\n            this.lineMap = [];\n            this.lineMap[1] = 0;\n            this.commentStack = [];\n            this.leftCurlyCount = 0;\n            this.rightCurlyCount = 0;\n            this.seenUnicodeChar = false;\n            this.seenUnicodeCharInComment = false;\n        }\n\n        public setErrorHandler(reportError: (message: string) => void ) { \n            this.reportError = reportError;\n        }\n\n        public setSaveScan(savedTokens: SavedTokens) {\n            this.saveScan = savedTokens;\n        }\n\n        public setText(newSrc: string, textMode: number) {\n            this.setSourceText(new StringSourceText(newSrc), textMode);\n        }\n\n        public setScanComments(value: bool) {\n            this.scanComments = value;\n        }\n\n        public getLexState(): number {\n            return this.lexState;\n        }\n\n        public tokenStart() {\n            this.startPos = this.pos;\n            this.startLine = this.line;\n            this.startCol = this.col;\n            this.interveningWhitespace = false;\n        }\n\n        public peekChar(): number {\n            if (this.pos < this.len) {\n                return this.src.charCodeAt(this.pos);\n            }\n            else {\n                return LexEOF;\n            }\n        }\n\n        public peekCharAt(index: number): number {\n            if (index < this.len) {\n                return this.src.charCodeAt(index);\n            }\n            else {\n                return LexEOF;\n            }\n        }\n\n        public IsHexDigit(c: number) {\n            return ((c >= LexCode_0) && (c <= LexCode_9)) || ((c >= LexCode_A) && (c <= LexCode_F)) ||\n                ((c >= LexCode_a) && (c <= LexCode_f));\n        }\n\n        public IsOctalDigit(c: number) {\n            return ((c >= LexCode_0) && (c <= LexCode_7)) ||\n                ((c >= LexCode_a) && (c <= LexCode_f));\n        }\n\n        public scanHexDigits(): Token {\n            var atLeastOneDigit = false;\n            for (; ;) {\n                if (this.IsHexDigit(this.ch)) {\n                    this.nextChar();\n                    atLeastOneDigit = true;\n                }\n                else {\n                    if (atLeastOneDigit) {\n                        return new NumberLiteralToken(parseInt(this.src.substring(this.startPos, this.pos)));\n                    }\n                    else {\n                        return null;\n                    }\n                }\n            }\n\n        }\n\n        public scanOctalDigits(): Token {\n            var atLeastOneDigit = false;\n            for (; ;) {\n                if (this.IsOctalDigit(this.ch)) {\n                    this.nextChar();\n                    atLeastOneDigit = true;\n                }\n                else {\n                    if (atLeastOneDigit) {\n                        return new NumberLiteralToken(parseInt(this.src.substring(this.startPos, this.pos)));\n                    }\n                    else {\n                        return null;\n                    }\n                }\n            }\n\n        }\n\n        public scanDecimalNumber(state: number): Token {\n            var atLeastOneDigit = false;\n            var svPos = this.pos;\n            var svCol = this.col;\n            for (; ;) {\n                if (LexIsDigit(this.ch)) {\n                    atLeastOneDigit = true;\n                    if (this.ch != LexCode_0 && state == NumberScanState.InEmptyFraction) {\n                        state = NumberScanState.InFraction;\n                    }\n                    this.nextChar();\n                }\n                else if (this.ch == LexCodeDOT) {\n                    if (state == NumberScanState.Start) {\n                        // DecimalDigit* .\n                        this.nextChar();\n                        state = NumberScanState.InEmptyFraction;\n                    }\n                    else {\n                        // dot not part of number\n                        if (atLeastOneDigit) {\n                            // DecimalDigit* . DecimalDigit+\n                            return new NumberLiteralToken(parseFloat(this.src.substring(this.startPos, this.pos)), state == NumberScanState.InEmptyFraction);\n                        }\n                        else {\n                            this.pos = svPos;\n                            this.col = svCol;\n                            return null;\n                        }\n                    }\n                } else if ((this.ch == LexCode_e) || (this.ch == LexCode_E)) {\n                    if (state == NumberScanState.Start) {\n                        if (atLeastOneDigit) {\n                            // DecimalDigit+ (.",
v27565=v27566+" DecimalDigit*) [eE] [+-]DecimalDigit+\n                            atLeastOneDigit = false;\n                            this.nextChar();\n                            state = NumberScanState.InExponent;\n                        }\n                        else {\n                            this.pos = svPos;\n                            this.col = svCol;\n                            return null;\n                        }\n                    }\n                    else if (state == NumberScanState.InFraction || state == NumberScanState.InEmptyFraction) {\n                        // DecimalDigit+ . DecimalDigit* [eE]\n                        this.nextChar();\n                        state = NumberScanState.InExponent;\n                        atLeastOneDigit = false;\n                    }\n                    else {\n                        // DecimalDigit+ . DecimalDigit* [eE] DecimalDigit+\n                        if (atLeastOneDigit) {\n                            return new NumberLiteralToken(parseFloat(this.src.substring(this.startPos, this.pos)));\n                        }\n                        else {\n                            this.pos = svPos;\n                            this.col = svCol;\n                            return null;\n                        }\n                    }\n                }\n                else if ((this.ch == LexCodePLS) || (this.ch == LexCodeMIN)) {\n                    if (state == NumberScanState.InExponent) {\n                        if (!atLeastOneDigit) {\n                            this.nextChar();\n                        }\n                        else {\n                            this.pos = svPos;\n                            this.col = svCol;\n                            return null;\n                        }\n                    }\n                    else if (state == NumberScanState.InEmptyFraction || state == NumberScanState.InFraction) {\n                        // This case will not generate bad javascript if we miss the fractional part, but we just want to be consistent with the dot case\n                        return new NumberLiteralToken(parseFloat(this.src.substring(this.startPos, this.pos)), state == NumberScanState.InEmptyFraction);\n                    }\n                    else {\n                        if (!atLeastOneDigit) {\n                            this.pos = svPos;\n                            this.col = svCol;\n                            return null;\n                        }\n                        else {\n                            return new NumberLiteralToken(parseFloat(this.src.substring(this.startPos, this.pos)));\n                        }\n                    }\n                }\n                else {\n                    if (!atLeastOneDigit) {\n                        this.pos = svPos;\n                        this.col = svCol;\n                        return null;\n                    }\n                    else {\n                        return new NumberLiteralToken(parseFloat(this.src.substring(this.startPos, this.pos)), state == NumberScanState.InEmptyFraction);\n                    }\n                }\n            }\n        }\n\n        // 0 [xX] hexDigits\n        // 0 octalDigits\n        // 0 [89] decimalDigits\n        // decimalDigits? fraction? exponent?\n\n        public scanNumber(): Token {\n            if (this.peekChar() == LexCode_0) {\n                switch (this.peekCharAt(this.pos + 1)) {\n                    case LexCode_x:\n                    case LexCode_X:\n                        // Hex\n                        this.advanceChar(2);\n                        return this.scanHexDigits();\n                    case LexCode_8:\n                    case LexCode_9:\n                    case LexCodeDOT:\n                        return this.scanDecimalNumber(NumberScanState.Start);\n                    default:\n                        // Octal\n                        return this.scanOctalDigits();\n                }\n            }\n            else {\n                return this.scanDecimalNumber(NumberScanState.Start);\n            }\n        }\n\n        public scanFraction(): Token {\n            return this.scanDecimalNumber(NumberScanState.InFraction);\n        }\n\n        public newLine() {\n            this.col = 0;\n            if (this.mode == LexMode.File) {\n                this.line++;\n                this.lineMap[this.line] = this.pos + 1;\n            }\n        }\n\n        public finishMultilineComment(): bool {\n            var ch2: number;\n            this.lexState = LexState.InMultilineComment;\n            while (this.pos < this.len) {\n                if (this.ch == LexCodeMUL) {\n                    ch2 = this.peekCharAt(this.pos + 1);\n                    if (ch2 == LexCodeSLH) {\n                        this.advanceChar(2);\n                        if (this.mode == LexMode.File) {\n                            this.tokenStart();\n                        }\n                        this.lexState = LexState.Start;\n                        return true;\n                    }\n        ",
v27564=v27565+"        }\n                else if (this.ch == LexCodeNWL) {\n                    this.newLine();\n                    if (this.mode == LexMode.Line) {\n                        this.nextChar();\n                        return false;\n                    }\n                } \n                else if (this.ch >= LexCodeASCIIChars) { \n                    this.seenUnicodeCharInComment = true;\n                }\n                this.nextChar();\n            }\n            return false;\n        }\n\n        public pushComment(comment: CommentToken) {\n            this.commentStack.push(comment);\n        }\n\n        public getComments() {\n            var stack = this.commentStack;\n            this.commentStack = [];\n            return stack;\n        }\n\n        public getCommentsForLine(line: number) {\n            var comments: CommentToken[] = null;\n            while ((this.commentStack.length > 0) && (this.commentStack[0].line == line)) {\n                if (comments == null) {\n                    comments = [this.commentStack.shift()];\n                }\n                else {\n                    comments = comments.concat([this.commentStack.shift()]);\n                }\n\n            }\n            return comments;\n        }\n\n        public resetComments() {\n            this.commentStack = [];\n        }\n\n        public endsLine(c: number) {\n            return (c == LexCodeNWL) || (c == LexCodeRET) || (c == LexCodeLS) || (c == LexCodePS);\n        }\n\n        public finishSinglelineComment() {\n            while (this.pos < this.len) {\n                if (this.endsLine(this.ch))\n                    break;\n                if (this.ch >= LexCodeASCIIChars) { \n                    this.seenUnicodeCharInComment = true;\n                }\n                this.nextChar();\n            }\n\n            if (this.mode == LexMode.File) {\n                this.tokenStart();\n            }\n        }\n\n        public tokenText(): string {\n            return this.src.substring(this.startPos, this.pos);\n        }\n\n        public findClosingSLH() {\n            var index = this.pos;\n            var ch2 = this.src.charCodeAt(index);\n            var prevCh = 0;\n            var liveEsc = false;\n            while (!this.endsLine(ch2) && (index < this.len)) {\n                if ((ch2 == LexCodeSLH) && (!liveEsc)) {\n                    return index;\n                }\n                prevCh = ch2;\n                index++;\n                if (liveEsc) {\n                    liveEsc = false;\n                }\n                else {\n                    liveEsc = (prevCh == LexCodeBSL);\n                }\n\n                ch2 = this.src.charCodeAt(index);\n            }\n            return -1;\n        }\n\n        public speculateRegex(): Token {\n            if (noRegexTable[this.prevTok.tokenId] != undefined) {\n                return null;\n            }\n            var svPos = this.pos;\n            var svCol = this.col;\n            // first char is '/' and has been skipped\n            var index = this.findClosingSLH();\n            if (index > 0) {\n                // found closing /\n                var pattern = this.src.substring(svPos, index);\n                var flags = \"\";\n                this.pos = index + 1;\n                this.ch = this.peekChar();\n                var flagsStart = this.pos;\n                // TODO: check for duplicate flags\n                while ((this.ch == LexCode_i) || (this.ch == LexCode_g) || (this.ch == LexCode_m)) {\n                    this.nextChar();\n                }\n                if ((this.pos - flagsStart) > 3) {\n                    return null;\n                }\n                else {\n                    flags = this.src.substring(flagsStart, this.pos);\n                }\n                var regex = undefined;\n                try {\n                    regex = new RegExp(pattern, flags);\n                }\n                catch (regexException) {\n                }\n                if (regex) {\n                    // no line boundary in regex string\n                    this.col = svCol + (this.pos - this.startPos);\n                    return new RegularExpressionLiteralToken(regex);\n                }\n            }\n            this.pos = svPos;\n            this.col = svCol;\n            return null;\n        }\n\n        public lastTokenHadNewline() {\n            return this.prevLine != this.startLine;\n        }\n\n        public lastTokenLimChar() {\n            return this.interveningWhitespace ? this.interveningWhitespacePos : this.startPos;\n        }\n\n        // use only when known not to skip line terminators\n        public advanceChar(amt: number) {\n            this.pos += amt;\n            this.col += amt;\n            this.ch = this.peekChar();\n        }\n\n        public nextChar() {\n            this.pos++;\n            this.col++;\n            this.ch = this.peekChar();\n        }\n\n        public getLookAheadToken(): Token {\n            // REVIEW: This method is only used for parsing varargs in lambda expressions. If this functionality is neede",
v27563=v27564+'d for more common cases, \n            //         it needs to be designed. \n            //         Look-ahead token needs to be integrated in the scanner design to allow for an efficient lookup.\n\n            // Store the scanner state\n            var prevLine = this.prevLine;\n            var line = this.line;\n            var col = this.col;\n            var pos = this.pos;\n            var startPos = this.startPos;\n            var startCol = this.startCol;\n            var startLine = this.startLine;\n            var ch = this.ch;\n            var prevTok = this.prevTok;\n            var lexState = this.lexState;\n            var interveningWhitespace = this.interveningWhitespace;\n            var interveningWhitespacePos = this.interveningWhitespacePos;\n            var leftCurlyCount = this.leftCurlyCount;\n            var rightCurlyCount = this.rightCurlyCount;\n            var seenUnicodeChar = this.seenUnicodeChar;\n            var seenUnicodeCharInComment = this.seenUnicodeCharInComment;\n            var commentStackLength = this.commentStack.length;\n\n            var lookAheadToken = this.scan();\n\n            // Restore state\n            this.prevLine = prevLine;\n            this.line = line;\n            this.col = col;\n            this.pos = pos;\n            this.startPos = startPos;\n            this.startCol = startCol;\n            this.startLine = startLine;\n            this.ch = ch;\n            this.prevTok = prevTok;\n            this.lexState = lexState;\n            this.interveningWhitespace = interveningWhitespace;\n            this.interveningWhitespacePos = interveningWhitespacePos;\n            this.leftCurlyCount = leftCurlyCount;\n            this.rightCurlyCount = rightCurlyCount;\n            this.seenUnicodeChar = seenUnicodeChar;\n            this.seenUnicodeCharInComment = seenUnicodeCharInComment;\n            this.commentStack.length = commentStackLength;\n\n            return lookAheadToken;\n        }\n\n        public scanInLine(): Token {\n            if ((this.lexState == LexState.InMultilineComment) && (this.scanComments)) {\n                this.ch = this.peekChar();\n                var commentLine = this.line;\n                this.finishMultilineComment();\n                if (this.startPos < this.pos) {\n                    var commentText = this.src.substring(this.startPos, this.pos);\n                    this.tokenStart();\n                    return new CommentToken(TokenID.Comment, commentText,/*isBlock*/true, this.startPos, commentLine,/*endsLine*/true);\n                }\n                else {\n                    return staticTokens[TokenID.EndOfFile];\n                }\n            } \n            else if (this.lexState == LexState.InMultilineSingleQuoteString && this.pos < this.len) { \n                this.ch = LexCodeAPO;\n                this.lexState = LexState.Start;\n                return this.scanStringConstant();\n            }\n            else if (this.lexState == LexState.InMultilineDoubleQuoteString && this.pos < this.len) { \n                this.ch = LexCodeQUO;\n                this.lexState = LexState.Start;\n                return this.scanStringConstant();\n            }\n            this.prevLine = this.line;\n            var prevTok = this.innerScan();\n\n            // Ingore white spaces\n            if (prevTok.tokenId != TokenID.Whitespace) {\n                this.prevTok = prevTok;\n            }\n            return prevTok;\n        }\n\n        public scan(): Token {\n            this.prevLine = this.line;\n            this.prevTok = this.innerScan();\n            if (this.saveScan) {\n                this.saveScan.addToken(this.prevTok, this);\n            }\n            return this.prevTok;\n        }\n\n        private isValidUnicodeIdentifierChar(): bool {\n            var valid = LexIsUnicodeIdStart(this.ch) || LexIsUnicodeDigit(this.ch);\n            this.seenUnicodeChar = this.seenUnicodeChar || valid;\n            return valid;\n        }\n\n        private scanStringConstant(): Token {\n            var endCode = this.ch;\n            \n            // Skip the first quote\n            this.nextChar();\n            \n            // Accumulate with escape characters\n            scanStringConstantLoop:\n            for (;;) {\n                switch (this.ch) {\n                    case LexEOF:\n                        // Unexpected end of file\n                        this.reportScannerError("Unterminated string constant");\n                        break scanStringConstantLoop;\n\n                    case LexCodeLS:\n                    case LexCodePS:\n                        this.seenUnicodeChar = true;\n                    // Intentional fall through\n                    case LexCodeRET:\n                    case LexCodeNWL:\n                        this.reportScannerError("Unterminated string constant");\n                        break scanStringConstantLoop;\n\n                    case LexCodeAPO:\n                    case LexCodeQUO:\n                        if (this.ch == endCode) {\n                            // Foun',
v27562=v27563+'d string terminator. Skip past end code.\n                            this.nextChar();\n                            break scanStringConstantLoop;\n                        }\n                        break;\n\n                    case LexCodeBSL:\n                        // Consume the current slash\n                        this.nextChar();\n\n                        switch (this.ch) {\n                            case LexCodeAPO:\n                            case LexCodeQUO:\n                            case LexCodeBSL:\n                                // Valid escape sequences\n                                this.nextChar();\n                                continue scanStringConstantLoop;\n\n                            case LexCodeLS:\n                            case LexCodePS:\n                                this.seenUnicodeChar = true;\n                            // Intentional fall through\n                            case LexCodeRET:\n                            case LexCodeNWL:\n                                // Skip /r in a /r/n sequence\n                                if (this.ch == LexCodeRET && this.peekCharAt(this.pos + 1) == LexCodeNWL) {\n                                    this.nextChar();\n                                }\n\n                                // Consume the new line char\n                                this.nextChar();\n\n                                // Record new line\n                                this.newLine();\n\n                                if (this.mode == LexMode.Line) {\n                                    this.lexState = endCode == LexCodeAPO ? LexState.InMultilineSingleQuoteString : LexState.InMultilineDoubleQuoteString;\n                                    break scanStringConstantLoop;\n                                }\n                                break;\n\n                            case LexCode_x:\n                            case LexCode_u:\n                                var expectedHexDigits = this.ch == LexCode_x ? 2 : 4;\n                                this.nextChar();\n                                for (var i = 0; i < expectedHexDigits; i++) {\n                                    if (this.IsHexDigit(this.ch)) {\n                                        this.nextChar();\n                                    }\n                                    else {\n                                        this.reportScannerError("Invalid Unicode escape sequence");\n                                        break;\n                                    }\n                                }\n                                continue scanStringConstantLoop;\n                        }\n                        break;\n                }\n\n                // Record seeing a Unicode char\n                if (this.ch >= LexCodeASCIIChars) {\n                    this.seenUnicodeChar = true;\n                }\n\n                this.nextChar();\n            }\n\n            return new StringLiteralToken(this.src.substring(this.startPos, this.pos));\n        }\n\n        private scanIdentifier(): Token {\n            var hasEscape = false;\n            var isFirstChar = (this.ch == LexCodeBSL);\n            var hasUnicode: any = false;\n\n            for (; ;) {\n                while (lexIdStartTable[this.ch] || LexIsDigit(this.ch) || \n                      (this.ch >= LexCodeASCIIChars && this.isValidUnicodeIdentifierChar())) {\n                    this.nextChar();\n                }\n                if (this.ch == LexCodeBSL) {\n                    this.nextChar();\n                    if (this.ch == LexCode_u) {\n                        // 4 hex digits\n                        this.nextChar();\n                        for (var h = 0; h < 4 ; h++) {\n                            if (this.IsHexDigit(this.ch)) {\n                                this.nextChar();\n                            }\n                            else {\n                                this.reportScannerError("Invalid Unicode escape sequence");\n                                return staticTokens[TokenID.Error];\n                            }\n                        }\n                        var hexChar = parseInt(this.src.substring(this.pos - 4, this.pos), 16);\n\n                        // Verify is valid ID char \n                        if (lexIdStartTable[hexChar] || (!isFirstChar && LexIsDigit(hexChar)) ||\n                            (hexChar >= LexCodeASCIIChars && (LexIsUnicodeIdStart(hexChar) || (!isFirstChar && LexIsUnicodeDigit(hexChar))))) {\n                        }\n                        else { \n                            this.reportScannerError("Invalid identifier character");\n                            return staticTokens[TokenID.Error];\n                        }\n\n                        hasEscape = true;\n                        isFirstChar = false;\n                        continue;\n                    }\n\n                    this.reportScannerError("Invalid Unicode escape sequence");\n                    return staticTokens[TokenID.Error];\n                }\n        ',
v27561=v27562+'        break;\n            }\n\n            var id: number;\n            var text = this.src.substring(this.startPos, this.pos);\n            if (!hasEscape && (id = LexKeywordTable.lookup(text)) != null) {\n                return staticTokens[id];\n            }\n            else {\n                return new IdentifierToken(text, hasEscape);\n            }\n        }\n\n        public innerScan(): Token {\n            var rtok;\n            this.tokenStart();\n            this.ch = this.peekChar();\n\n            start: while (this.pos < this.len) {\n                 if (lexIdStartTable[this.ch] || this.ch == LexCodeBSL || (this.ch >= LexCodeASCIIChars && LexIsUnicodeIdStart(this.ch))) {\n                    // identifier or keyword\n                    return this.scanIdentifier();\n                }\n                else if (this.ch == LexCodeSpace) {\n                    if (!this.interveningWhitespace) {\n                        this.interveningWhitespacePos = this.pos;\n                    }\n                    do {\n                        this.nextChar();\n                    } while (this.ch == LexCodeSpace);\n                    if (this.mode == LexMode.Line) {\n                        var whitespaceText = this.src.substring(this.startPos, this.pos);\n                        return new WhitespaceToken(TokenID.Whitespace, whitespaceText);\n                    }\n                    else {\n                        this.tokenStart();\n                        this.interveningWhitespace = true;\n                    }\n                }\n                else if (this.ch == LexCodeSLH) {\n                    this.nextChar();\n                    var commentText;\n                    if (this.ch == LexCodeSLH) {\n                        if (!this.interveningWhitespace) {\n                            this.interveningWhitespacePos = this.pos - 1;\n                        }\n                        var commentStartPos = this.pos - 1;\n                        var commentStartLine = this.line;\n                        this.finishSinglelineComment();\n                        var commentText = this.src.substring(commentStartPos, this.pos);\n                        var commentToken = new CommentToken(TokenID.Comment, commentText,/*isBlock*/false, commentStartPos, commentStartLine,/*endsLine*/false);\n                        if (this.scanComments) {\n                            // respect scanner contract: when returning a token, startPos is the start position of the token\n                            this.startPos = commentStartPos;\n                            return commentToken;\n                        }\n                        else {\n                            this.pushComment(commentToken);\n                        }\n\n                        this.interveningWhitespace = true;\n                    }\n                    else if (this.ch == LexCodeMUL) {\n                        if (!this.interveningWhitespace) {\n                            this.interveningWhitespacePos = this.pos - 1;\n                        }\n                        var commentStartPos = this.pos - 1;\n                        var commentStartLine = this.line;\n                        this.nextChar();  // Skip the "*"\n                        this.finishMultilineComment();\n                        var commentText = this.src.substring(commentStartPos, this.pos);\n                        var endsLine = this.endsLine(this.peekChar());\n                        var commentToken = new CommentToken(TokenID.Comment, commentText,/*isBlock*/true, commentStartPos, commentStartLine, endsLine);\n                        if (this.scanComments) {\n                            // respect scanner contract: when returning a token, startPos is the start position of the token\n                            this.startPos = commentStartPos;\n                            return commentToken;\n                        }\n                        else {\n                            this.pushComment(commentToken);\n                        }\n                        this.interveningWhitespace = true;\n                    }\n                    else {\n                        var regexTok = this.speculateRegex();\n                        if (regexTok) {\n                            return regexTok;\n                        }\n                        else {\n                            if (this.peekCharAt(this.pos) == LexCodeEQ) {\n                                this.nextChar();\n                                return staticTokens[TokenID.SlashEquals];\n                            }\n                            else {\n                                return staticTokens[TokenID.Slash];\n                            }\n                        }\n                    }\n                }\n                else if (this.ch == LexCodeSMC) {\n                    this.nextChar();\n                    return staticTokens[TokenID.Semicolon];\n                }\n                else if ((this.ch == LexCodeAPO) || (this.ch == LexCodeQUO)) {\n                    return this.scanSt',
v27560=v27561+"ringConstant();\n                }\n                else if (autoToken[this.ch]) {\n                    var atok = autoToken[this.ch];\n                    if (atok.tokenId == TokenID.OpenBrace) {\n                        this.leftCurlyCount++;\n                    }\n                    else if (atok.tokenId == TokenID.CloseBrace) {\n                        this.rightCurlyCount++;\n                    }\n                    this.nextChar();\n                    return atok;\n                }\n                else if ((this.ch >= LexCode_0) && (this.ch <= LexCode_9)) {\n                    rtok = this.scanNumber();\n                    if (rtok) {\n                        return rtok;\n                    }\n                    else {\n                        this.nextChar();\n                        return staticTokens[TokenID.Error];\n                    }\n                }\n                else switch (this.ch) {\n                    // TAB\n                    case LexCodeTAB:\n                    case LexCodeVTAB:\n                        if (!this.interveningWhitespace) {\n                            this.interveningWhitespacePos = this.pos;\n                        }\n                        if (this.mode == LexMode.Line) {\n                            do {\n                                this.nextChar();\n                            } while ((this.ch == LexCodeSpace) || (this.ch == 9));\n                            var wsText = this.src.substring(this.startPos, this.pos);\n                            return new WhitespaceToken(TokenID.Whitespace, wsText);\n                        }\n                        else {\n                            this.interveningWhitespace = true;\n                        }\n                     // Newlines and BOM\n                    case 0xFF: // UTF16 SEQUENCE\n                    case 0xFE:\n                    case 0xEF:    // UTF8 SEQUENCE\n                    case 0xBB:\n                    case 0xBF:\n                    case LexCodeLS:\n                    case LexCodePS:\n                    case LexCodeNWL:\n                    case LexCodeRET:\n                        if (this.ch == LexCodeNWL) {\n                            this.newLine();\n                            if (this.mode == LexMode.Line) {\n                                return staticTokens[TokenID.EndOfFile];\n                            }\n                        }\n                        if (!this.interveningWhitespace) {\n                            this.interveningWhitespacePos = this.pos;\n                        }\n                        this.nextChar();\n                        this.tokenStart();\n                        this.interveningWhitespace = true;\n                        break;\n                    case LexCodeDOT: {\n                        if (this.peekCharAt(this.pos + 1) == LexCodeDOT) {\n                            if (this.peekCharAt(this.pos + 2) == LexCodeDOT) {\n                                this.advanceChar(3);\n                                return staticTokens[TokenID.DotDotDot];\n                            }\n                            else {\n                                this.nextChar();\n                                return staticTokens[TokenID.Dot];\n                            }\n                        }\n                        else {\n                            this.nextChar();\n                            rtok = this.scanFraction();\n                            if (rtok) {\n                                return rtok;\n                            }\n                            else {\n                                return staticTokens[TokenID.Dot];\n                            }\n                        }\n                        // break;\n                    }\n                    case LexCodeEQ:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            if (this.peekCharAt(this.pos + 2) == LexCodeEQ) {\n                                this.advanceChar(3);\n                                return staticTokens[TokenID.EqualsEqualsEquals];\n                            }\n                            else {\n                                this.advanceChar(2);\n                                return staticTokens[TokenID.EqualsEquals];\n                            }\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodeGT) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.EqualsGreaterThan];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Equals];\n                        }\n                    // break;\n                    case LexCodeBNG:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            if (this.peekCharAt(this.pos + 2) == LexCodeEQ) {\n                                this.advanceChar(3);\n                                return staticTo",
v27559=v27560+"kens[TokenID.ExclamationEqualsEquals];\n                            }\n                            else {\n                                this.advanceChar(2);\n                                return staticTokens[TokenID.ExclamationEquals];\n                            }\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Exclamation];\n                        }\n                    // break;\n                    case LexCodePLS:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.PlusEquals];\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodePLS) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.PlusPlus];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Plus];\n                        }\n                    // break;\n                    case LexCodeMIN:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.MinusEquals];\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodeMIN) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.MinusMinus];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Minus];\n                        }\n                    // break;\n                    case LexCodeMUL:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.AsteriskEquals];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Asterisk];\n                        }\n                    // break;\n                    case LexCodePCT:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.PercentEquals];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Percent];\n                        }\n                    // break;\n                    case LexCodeLT:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeLT) {\n                            if (this.peekCharAt(this.pos + 2) == LexCodeEQ) {\n                                this.advanceChar(3);\n                                return staticTokens[TokenID.LessThanLessThanEquals];\n                            }\n                            else {\n                                this.advanceChar(2);\n                                return staticTokens[TokenID.LessThanLessThan];\n                            }\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.LessThanEquals];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.LessThan];\n                        }\n                    //  break;\n                    case LexCodeGT:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeGT) {\n                            if (this.peekCharAt(this.pos + 2) == LexCodeEQ) {\n                                this.advanceChar(3);\n                                return staticTokens[TokenID.GreaterThanGreaterThanEquals];\n                            }\n                            else if (this.peekCharAt(this.pos + 2) == LexCodeGT) {\n                                if (this.peekCharAt(this.pos + 3) == LexCodeEQ) {\n                                    this.advanceChar(4);\n                                    return staticTokens[TokenID.GreaterThanGreaterThanGreaterThanEquals];\n                                }\n                                else {\n                                    this.advanceChar(3);\n                                    return staticTokens[TokenID.GreaterThanGreaterThanGreaterThan];\n                                }\n                            }\n                            else {\n                                this.advanceChar(2);\n                                return staticTokens[TokenID.GreaterThanGreaterThan];\n                            }\n                        }\n                        ",
v27558=v27559+'else if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.GreaterThanEquals];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.GreaterThan];\n                        }\n                    // break;\n                    case LexCodeXOR:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.CaretEquals];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Caret];\n                        }\n                    //  break;\n                    case LexCodeBAR:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.BarEquals];\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodeBAR) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.BarBar];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Bar];\n                        }\n                    //  break;\n                    case LexCodeAMP:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.AmpersandEquals];\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodeAMP) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.AmpersandAmpersand];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.And];\n                        }\n                    //  break;\n                    default:\n                        // Report error\n                        this.reportScannerError("Invalid character");\n                        this.nextChar();\n\n                        continue start;\n                }\n            }\n            return staticTokens[TokenID.EndOfFile];\n        }\n\n        private reportScannerError(message: string) { \n            if (this.reportError) { \n                this.reportError(message);\n            }\n        }\n    }\n\n    // Reseverved words only apply to Identifiers, not IdentifierNames\n    export function convertTokToIDName(tok: Token): bool {\n        return convertTokToIDBase(tok, true, false);\n    }\n\n    export function convertTokToID(tok: Token, strictMode: bool): bool {\n        return convertTokToIDBase(tok, false, strictMode);\n    }\n\n    function convertTokToIDBase(tok: Token, identifierName: bool, strictMode: bool): bool {\n        if (tok.tokenId <= TokenID.LimKeyword) {\n            var tokInfo = lookupToken(tok.tokenId);\n            if (tokInfo != undefined) {\n                var resFlags = Reservation.Javascript | Reservation.JavascriptFuture;\n                if (strictMode) {\n                    resFlags |= Reservation.JavascriptFutureStrict;\n                }\n                if (identifierName || !hasFlag(tokInfo.reservation, resFlags)) {\n                    return true;\n                }\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n\n    // Return the (1-based) line number from a character offset using the provided linemap.\n    export function getLineNumberFromPosition(lineMap: number[], position: number): number {\n        if (position === -1)\n            return 0;\n\n        // Binary search\n        var min = 0;\n        var max = lineMap.length - 1;\n        while (min < max) {\n            var med = (min + max) >> 1;\n            if (position < lineMap[med]) {\n                max = med - 1;\n            }\n            else if (position < lineMap[med + 1]) {\n                min = max = med; // found it\n            }\n            else {\n                min = med + 1;\n            }\n        }\n\n        return min;\n    }\n\n    /// Return the [line, column] data for a given offset and a lineMap.\n    /// Note that the returned line is 1-based, while the column is 0-based.\n    export function getSourceLineColFromMap(lineCol: ILineCol, minChar: number, lineMap: number[]): void {\n        var line = getLineNumberFromPosition(lineMap, minChar);\n\n        if (line > 0) {\n            lineCol.line = line;\n            lineCol.col = (minChar - lineMap[line]);\n        }\n    }\n\n    // Return the [line, column] (both 1 based) corresponding to a given position in a given script.\n    export funct',
v27557=v27558+'ion getLineColumnFromPosition(script: TypeScript.Script, position: number): ILineCol {\n        var result = { line: -1, col: -1 };\n        getSourceLineColFromMap(result, position, script.locationInfo.lineMap);\n        if (result.col >= 0) {\n            result.col++;   // Make it 1-based\n        }\n        return result;\n    }\n\n    //\n    // Return the position (offset) corresponding to a given [line, column] (both 1-based) in a given script.\n    //\n    export function getPositionFromLineColumn(script: TypeScript.Script, line: number, column: number): number {\n        return script.locationInfo.lineMap[line] + (column - 1);\n    }\n    \n    // Return true if the token is a primitive type\n    export function isPrimitiveTypeToken(token: Token) {\n        switch (token.tokenId) {\n            case TokenID.Any:\n            case TokenID.Bool:\n            case TokenID.Number:\n            case TokenID.String:\n                return true;\n        }\n        return false;\n    }\n\n    // Return true if the token is a primitive type\n    export function isModifier(token: Token) {\n        switch (token.tokenId) {\n            case TokenID.Public:\n            case TokenID.Private:\n            case TokenID.Static:\n                return true;\n        }\n        return false;\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export class AssignScopeContext {\n        constructor (public scopeChain: ScopeChain,\n                     public typeFlow: TypeFlow,\n                     public modDeclChain: ModuleDeclaration[]) {\n        }\n    }\n\n    export function pushAssignScope(scope: SymbolScope,\n        context: AssignScopeContext,\n        type: Type,\n        classType: Type,\n        fnc: FuncDecl) {\n\n        var chain = new ScopeChain(null, context.scopeChain, scope);\n        chain.thisType = type;\n        chain.classType = classType;\n        chain.fnc = fnc;\n        context.scopeChain = chain;\n    }\n\n    export function popAssignScope(context: AssignScopeContext) {\n        context.scopeChain = context.scopeChain.previous;\n    }\n\n    export function instanceCompare(a: Symbol, b: Symbol) {\n        if (((a == null) || (!a.isInstanceProperty()))) {\n            return b;\n        }\n        else {\n            return a;\n        }\n    }\n\n    export function instanceFilterStop(s: Symbol) {\n        return s.isInstanceProperty();\n    }\n\n    export class ScopeSearchFilter {\n\n        constructor (public select: (a: Symbol, b: Symbol) =>Symbol,\n                            public stop: (s: Symbol) =>bool) { }\n\n        public result: Symbol = null;\n\n        public reset() {\n            this.result = null;\n        }\n\n        public update(b: Symbol): bool {\n            this.result = this.select(this.result, b);\n            if (this.result) {\n                return this.stop(this.result);\n            }\n            else {\n                return false;\n            }\n        }\n    }\n\n    export var instanceFilter = new ScopeSearchFilter(instanceCompare, instanceFilterStop);\n\n    export function preAssignModuleScopes(ast: AST, context: AssignScopeContext) {\n        var moduleDecl = <ModuleDeclaration>ast;\n        var memberScope: SymbolTableScope = null;\n        var aggScope: SymbolAggregateScope = null;\n\n        if (moduleDecl.name && moduleDecl.mod) {\n            moduleDecl.name.sym = moduleDecl.mod.symbol;\n        }\n\n        var mod = moduleDecl.mod;\n\n        // We\'re likely here because of error recovery\n        if (!mod) {\n            return;\n        }\n\n        memberScope = new SymbolTableScope(mod.members, mod.ambientMembers, mod.enclosedTypes, mod.ambientEnclosedTypes, mod.symbol);\n        mod.memberScope = memberScope;\n        context.modDeclChain.push(moduleDecl);\n        context.typeFlow.checker.currentModDecl = moduleDecl;\n        aggScope = new SymbolAggregateScope(mod.symbol);\n        aggScope.addParentScope(memberScope);\n        aggScope.addParentScope(context.scopeChain.scope);\n        pushAssignScope(aggScope, context, null, null, null);\n        mod.containedScope = aggScope;\n        if (mod.symbol) {\n            context.typeFlow.addLocalsFromScope(mod.containedScope, mod.symbol, moduleDecl.vars, mod.members.privateMembers, true);\n        }\n    }\n\n    export function preAssignClassScopes(ast: AST, context: AssignScopeContext) {\n        var classDecl = <InterfaceDeclaration>ast;\n        var memberScope: Symb',
v27556=v27557+"olTableScope = null;\n        var aggScope: SymbolAggregateScope = null;\n\n        if (classDecl.name && classDecl.type) {\n            classDecl.name.sym = classDecl.type.symbol;\n        }\n\n        var classType = ast.type;\n\n        if (classType) {\n            var classSym = classType.symbol;\n            memberScope = <SymbolTableScope>context.typeFlow.checker.scopeOf(classType);\n\n            aggScope = new SymbolAggregateScope(classType.symbol);\n            aggScope.addParentScope(memberScope);\n            aggScope.addParentScope(context.scopeChain.scope);\n\n            classType.containedScope = aggScope;\n            classType.memberScope = memberScope;\n\n            var instanceType = classType.instanceType;\n            memberScope = <SymbolTableScope>context.typeFlow.checker.scopeOf(instanceType);\n            instanceType.memberScope = memberScope;\n\n            aggScope = new SymbolAggregateScope(instanceType.symbol);\n            aggScope.addParentScope(context.scopeChain.scope);\n\n            pushAssignScope(aggScope, context, instanceType, classType, null);\n            instanceType.containedScope = aggScope;\n        }\n        else {\n            ast.type = context.typeFlow.anyType;\n        }\n    }\n\n    export function preAssignInterfaceScopes(ast: AST, context: AssignScopeContext) {\n        var interfaceDecl = <InterfaceDeclaration>ast;\n        var memberScope: SymbolTableScope = null;\n        var aggScope: SymbolAggregateScope = null;\n\n        if (interfaceDecl.name && interfaceDecl.type) {\n            interfaceDecl.name.sym = interfaceDecl.type.symbol;\n        }\n\n        var interfaceType = ast.type;\n        memberScope = <SymbolTableScope>context.typeFlow.checker.scopeOf(interfaceType);\n        interfaceType.memberScope = memberScope;\n        aggScope = new SymbolAggregateScope(interfaceType.symbol);\n        aggScope.addParentScope(memberScope);\n        aggScope.addParentScope(context.scopeChain.scope);\n        pushAssignScope(aggScope, context, null, null, null);\n        interfaceType.containedScope = aggScope;\n    }\n\n    export function preAssignWithScopes(ast: AST, context: AssignScopeContext) {\n        var withStmt = <WithStatement>ast;\n        var withType = withStmt.type;\n\n        var members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n        var ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n\n        var withType = new Type();\n        var withSymbol = new WithSymbol(withStmt.minChar, context.typeFlow.checker.locationInfo.unitIndex, withType);\n        withType.members = members;\n        withType.ambientMembers = ambientMembers;\n        withType.symbol = withSymbol;\n        withType.setHasImplementation();\n        withStmt.type = withType;\n\n        var withScope = new TypeScript.SymbolScopeBuilder(withType.members, withType.ambientMembers, null, null, context.scopeChain.scope, withType.symbol);\n\n        pushAssignScope(withScope, context, null, null, null);\n        withType.containedScope = withScope;\n    }\n\n    export function preAssignFuncDeclScopes(ast: AST, context: AssignScopeContext) {\n        var funcDecl = <FuncDecl>ast;\n\n        var container: Symbol = null;\n        var localContainer: Symbol = null;\n        if (funcDecl.type) {\n            localContainer = ast.type.symbol;\n        }\n\n        var isStatic = hasFlag(funcDecl.fncFlags, FncFlags.Static);\n        var isInnerStatic = isStatic && context.scopeChain.fnc != null;\n        // for inner static functions, use the parent's member scope, so local vars cannot be captured\n        var parentScope = isInnerStatic ? context.scopeChain.fnc.type.memberScope : context.scopeChain.scope;\n\n        // if this is not a method, but enclosed by class, use constructor as\n        // the enclosing scope\n        // REVIEW: Some twisted logic here - this needs to be cleaned up once old classes are removed\n        //  - if it's a new class, always use the contained scope, since we initialize the constructor scope below\n        if (context.scopeChain.thisType &&\n            (!funcDecl.isConstructor || hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod))) {\n            var instType = context.scopeChain.thisType;\n\n            if (!(instType.typeFlags & TypeFlags.IsClass) && !hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {\n                if (!funcDecl.isMethod() || isStatic) {\n                    parentScope = instType.constructorScope;\n                }\n                else {\n                    // use constructor scope if a method as well\n                    parentScope = instType.containedScope;\n                }\n            }\n            else {\n                if (context.scopeChain.previous.scope.container &&\n                    context.scopeChain.previous.scope.container.declAST &&\n                    context.scopeChain.previous.scope.container.declAST.nodeType == NodeType.FuncDecl &&\n                    (<FuncDecl>context.scopeChain.previous.sco",
v27555=v27556+"pe.container.declAST).isConstructor) {\n\n                        // if the parent is the class constructor, use the constructor scope\n                    parentScope = instType.constructorScope;\n                }\n                else if (isStatic && context.scopeChain.classType) {\n                    parentScope = context.scopeChain.classType.containedScope;\n                }\n                else {\n                    // else, use the contained scope\n                    parentScope = instType.containedScope;\n                }\n            }\n            container = instType.symbol;\n        }\n        else if (funcDecl.isConstructor && context.scopeChain.thisType) {\n            // sets the container to the class type's symbol (which is shared by the instance type)\n            container = context.scopeChain.thisType.symbol;\n        }\n\n        if (funcDecl.type == null || hasFlag(funcDecl.type.symbol.flags, SymbolFlags.TypeSetDuringScopeAssignment)) {\n            if (context.scopeChain.fnc && context.scopeChain.fnc.type) {\n                container = context.scopeChain.fnc.type.symbol;\n            }\n\n            var funcScope = null;\n            var outerFnc: FuncDecl = context.scopeChain.fnc;\n            var nameText = funcDecl.name ? funcDecl.name.actualText : null;\n            var fgSym: TypeSymbol = null;\n\n            if (isStatic) {\n                // In the case of function-nested statics, no member list will have bee initialized for the function, so we need\n                // to copy it over.  We don't set this by default because having a non-null member list will throw off assignment\n                // compatibility tests\n                if (outerFnc.type.members == null && container.getType().memberScope) {\n                    outerFnc.type.members = (<SymbolScopeBuilder>(<TypeSymbol>container).type.memberScope).valueMembers;\n                }\n                funcScope = context.scopeChain.fnc.type.memberScope;\n                outerFnc.innerStaticFuncs[outerFnc.innerStaticFuncs.length] = funcDecl;\n            }\n            else {\n                funcScope = context.scopeChain.scope;\n            }\n\n            // REVIEW: We don't search for another sym for accessors to prevent us from\n            // accidentally coalescing function signatures with the same name (E.g., a function\n            // 'f' the outer scope and a setter 'f' in an object literal within that scope)\n            if (nameText && nameText != \"__missing\" && !funcDecl.isAccessor()) {\n                if (isStatic) {\n                    fgSym = funcScope.findLocal(nameText, false, false);\n                }\n                else {\n                    // REVIEW: This logic should be symmetric with preCollectClassTypes\n                    fgSym = funcScope.findLocal(nameText, false, false);\n                }\n            }\n\n            context.typeFlow.checker.createFunctionSignature(funcDecl, container,\n                                                            funcScope, fgSym, fgSym == null);\n\n            // it's a getter or setter for a class property                     \n            if (!funcDecl.accessorSymbol && \n                (funcDecl.fncFlags & FncFlags.ClassMethod) &&\n                container && \n                ((!fgSym || fgSym.declAST.nodeType != NodeType.FuncDecl) && funcDecl.isAccessor()) || \n                    (fgSym && fgSym.isAccessor())) \n            {\n                funcDecl.accessorSymbol = context.typeFlow.checker.createAccessorSymbol(funcDecl, fgSym, container.getType(), (funcDecl.isMethod() && isStatic), true, funcScope, container);\n            }\n\n            funcDecl.type.symbol.flags |= SymbolFlags.TypeSetDuringScopeAssignment;\n        }\n\n        // Set the symbol for functions and their overloads\n        if (funcDecl.name && funcDecl.type) {\n            funcDecl.name.sym = funcDecl.type.symbol;\n        }\n\n        // Keep track of the original scope type, because target typing might override\n        // the \"type\" member. We need the original \"Scope type\" for completion list, etc.\n        funcDecl.scopeType = funcDecl.type;\n\n        // Overloads have no scope, so bail here\n        if (funcDecl.isOverload) {\n            return;\n        }\n\n        var funcTable = new StringHashTable();\n        var funcMembers = new ScopedMembers(new DualStringHashTable(funcTable, new StringHashTable()));\n        var ambientFuncTable = new StringHashTable();\n        var ambientFuncMembers = new ScopedMembers(new DualStringHashTable(ambientFuncTable, new StringHashTable()));\n        var funcStaticTable = new StringHashTable();\n        var funcStaticMembers = new ScopedMembers(new DualStringHashTable(funcStaticTable, new StringHashTable()));\n        var ambientFuncStaticTable = new StringHashTable();\n        var ambientFuncStaticMembers = new ScopedMembers(new DualStringHashTable(ambientFuncStaticTable, new StringHashTable()));\n\n        // REVIEW: Is it a problem that this is being set twice for properties and constructors?\n        funcDe",
v27554=v27555+"cl.unitIndex = context.typeFlow.checker.locationInfo.unitIndex;\n\n        var locals = new SymbolScopeBuilder(funcMembers, ambientFuncMembers, null, null, parentScope, localContainer);\n        var statics = new SymbolScopeBuilder(funcStaticMembers, ambientFuncStaticMembers, null, null, parentScope, null);\n\n        if (funcDecl.isConstructor && context.scopeChain.thisType) {\n            context.scopeChain.thisType.constructorScope = locals;\n        }\n\n        // basically, there are two problems\n        // - Above, for new classes, we were overwriting the constructor scope with the containing scope.  This caused constructor params to be\n        // in scope everywhere\n        // - Below, we're setting the contained scope table to the same table we were overwriting the constructor scope with, which we need to\n        // fish lambda params, etc, out (see funcTable below)\n        //\n        // A good first approach to solving this would be to change addLocalsFromScope to take a scope instead of a table, and add to the\n        // constructor scope as appropriate\n\n        funcDecl.symbols = funcTable;\n\n        if (!funcDecl.isSpecialFn()) {\n            var group = funcDecl.type;\n            var signature = funcDecl.signature;\n\n            if (!funcDecl.isConstructor) {\n                group.containedScope = locals;\n                locals.container = group.symbol;\n\n                group.memberScope = statics;\n                statics.container = group.symbol;\n            }\n            funcDecl.enclosingFnc = context.scopeChain.fnc;\n            group.enclosingType = isStatic ? context.scopeChain.classType : context.scopeChain.thisType;\n            // for mapping when type checking\n            var fgSym = <TypeSymbol>ast.type.symbol;\n            if (((funcDecl.fncFlags & FncFlags.Signature) == FncFlags.None) && funcDecl.vars) {\n                context.typeFlow.addLocalsFromScope(locals, fgSym, funcDecl.vars,\n                                                    funcTable, false);\n                context.typeFlow.addLocalsFromScope(statics, fgSym, funcDecl.statics,\n                                                    funcStaticTable, false);\n            }\n            if (signature.parameters) {\n                var len = signature.parameters.length;\n                for (var i = 0; i < len; i++) {\n                    var paramSym: ParameterSymbol = signature.parameters[i];\n                    context.typeFlow.checker.resolveTypeLink(locals,\n                                                                paramSym.parameter.typeLink, true);\n                }\n            }\n            context.typeFlow.checker.resolveTypeLink(locals, signature.returnType,\n                                                        funcDecl.isSignature());\n        }\n\n        if (!funcDecl.isConstructor || hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {\n            var thisType = (funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) ? context.scopeChain.thisType : null;\n            pushAssignScope(locals, context, thisType, null, funcDecl);\n        }\n\n        if (funcDecl.name && hasFlag(funcDecl.fncFlags, FncFlags.IsFunctionExpression)) {\n            // If the function is an expression, the name will not be visible in the enclosing scope.\n            // Add the function symbol under its name to the local scope to allow for recursive calls.\n            if (funcDecl.name.sym) {\n                funcTable.add(funcDecl.name.actualText, funcDecl.name.sym);\n            }\n        }\n    }\n\n    export function preAssignCatchScopes(ast: AST, context: AssignScopeContext) {\n        var catchBlock = <Catch>ast;\n        if (catchBlock.param) {\n            var catchTable = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable())); // REVIEW: Should we be allocating a public table instead of a private one?\n            var catchLocals = new SymbolScopeBuilder(catchTable, null, null, null, context.scopeChain.scope,\n                                                   context.scopeChain.scope.container);\n            catchBlock.containedScope = catchLocals;\n            pushAssignScope(catchLocals, context, context.scopeChain.thisType, context.scopeChain.classType, context.scopeChain.fnc);\n        }\n    }\n\n    export function preAssignScopes(ast: AST, parent: AST, walker: IAstWalker) {\n        var context:AssignScopeContext = walker.state;\n        var go = true;\n\n        if (ast) {\n            if (ast.nodeType == NodeType.List) {\n                var list = <ASTList>ast;\n                list.enclosingScope = context.scopeChain.scope;\n            }\n            else if (ast.nodeType == NodeType.ModuleDeclaration) {\n                preAssignModuleScopes(ast, context);\n            }\n            else if (ast.nodeType == NodeType.ClassDeclaration) {\n                preAssignClassScopes(ast, context);\n            }\n            else if (ast.nodeType == NodeType.InterfaceDeclaration) {\n                preAssignInterfaceScopes(",
v27553=v27554+'ast, context);\n            }\n            else if (ast.nodeType == NodeType.With) {\n                preAssignWithScopes(ast, context);\n            }\n            else if (ast.nodeType == NodeType.FuncDecl) {\n                preAssignFuncDeclScopes(ast, context);\n            }\n            else if (ast.nodeType == NodeType.Catch) {\n                preAssignCatchScopes(ast, context);\n            }\n            else if (ast.nodeType == NodeType.TypeRef) {\n                go = false;\n            }\n        }\n        walker.options.goChildren = go;\n        return ast;\n    }\n\n    export function postAssignScopes(ast: AST, parent: AST, walker: IAstWalker) {\n        var context:AssignScopeContext = walker.state;\n        var go = true;\n        if (ast) {\n            if (ast.nodeType == NodeType.ModuleDeclaration) {\n                var prevModDecl = <ModuleDeclaration>ast;\n\n                popAssignScope(context);\n\n                context.modDeclChain.pop();\n                if (context.modDeclChain.length >= 1) {\n                    context.typeFlow.checker.currentModDecl = context.modDeclChain[context.modDeclChain.length - 1];\n                }\n            }\n            else if (ast.nodeType == NodeType.ClassDeclaration) {\n                popAssignScope(context);\n            }\n            else if (ast.nodeType == NodeType.InterfaceDeclaration) {\n                popAssignScope(context);\n            }\n            else if (ast.nodeType == NodeType.With) {\n                popAssignScope(context);\n            }\n            else if (ast.nodeType == NodeType.FuncDecl) {\n                var funcDecl = <FuncDecl>ast;\n                if ((!funcDecl.isConstructor || hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) && !funcDecl.isOverload) {\n                    popAssignScope(context);\n                }\n            }\n            else if (ast.nodeType == NodeType.Catch) {\n                var catchBlock = <Catch>ast;\n                if (catchBlock.param) {\n                    popAssignScope(context);\n                }\n            }\n            else {\n                go = false;\n            }\n        }\n        walker.options.goChildren = go;\n        return ast;\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class TypeCollectionContext {\n        public script: Script = null;\n\n        constructor (public scopeChain: ScopeChain, public checker: TypeChecker) {\n        }\n    }\n\n    export class MemberScopeContext {\n        public type: Type = null;\n        public ast: AST = null;\n        public scope: SymbolScope;\n        public options = new AstWalkOptions();\n\n        constructor (public flow: TypeFlow, public pos: number, public matchFlag: ASTFlags) {\n        }\n    }\n\n    export class EnclosingScopeContext {\n\n        public scopeGetter: () => SymbolScope = null;\n        public objectLiteralScopeGetter: () => SymbolScope = null;\n        public scopeStartAST: AST = null;\n        public skipNextFuncDeclForClass = false;\n        public deepestModuleDecl: ModuleDeclaration = null;\n        public enclosingClassDecl: TypeDeclaration = null;\n        public enclosingObjectLit: UnaryExpression = null;\n        public publicsOnly = true;\n        public useFullAst = false;\n        private scriptFragment: Script;\n\n        constructor (public logger: ILogger,\n                    public script: Script,\n                    public text: ISourceText,\n                    public pos: number,\n                    public isMemberCompletion: bool) {\n        }\n\n        public getScope(): SymbolScope {\n            return this.scopeGetter();\n        }\n\n        public getObjectLiteralScope(): SymbolScope {\n            return this.objectLiteralScopeGetter();\n        }\n\n        public getScopeAST() {\n            return this.scopeStartAST;\n        }\n\n        public getScopePosition() {\n            return this.scopeStartAST.minChar;\n        }\n\n        public getScriptFragmentStartAST(): AST {\n            return this.scopeStartAST;\n        }\n\n        public getScriptFragmentPosition(): number {\n            return this.getScriptFragmentStartAST().minChar;\n        }\n\n        public getScriptFragment(): Script {\n            if (this.scriptFragment == null) {\n                var ast = this.getScriptFragmentStartAST();\n                var minChar = ast.minChar;\n                var limChar = (this.isMemberCompletion ? this.pos : this.po',
v27552=v27553+"s + 1);\n                this.scriptFragment = TypeScript.quickParse(this.logger, ast, this.text, minChar, limChar, null/*errorCapture*/).Script;\n            }\n            return this.scriptFragment;\n        }\n    }\n\n    export function preFindMemberScope(ast: AST, parent: AST, walker: IAstWalker) {\n        var memScope: MemberScopeContext = walker.state;\n        if (hasFlag(ast.flags, memScope.matchFlag) && ((memScope.pos < 0) || (memScope.pos == ast.limChar))) {\n            memScope.ast = ast;\n            if ((ast.type == null) && (memScope.pos >= 0)) {\n                memScope.flow.inScopeTypeCheck(ast, memScope.scope);\n            }\n            memScope.type = ast.type;\n            memScope.options.stopWalk();\n        }\n        return ast;\n    }\n\n    export function pushTypeCollectionScope(container: Symbol,\n        valueMembers: ScopedMembers,\n        ambientValueMembers: ScopedMembers,\n        enclosedTypes: ScopedMembers,\n        ambientEnclosedTypes: ScopedMembers,\n        context: TypeCollectionContext,\n        thisType: Type,\n        classType: Type,\n        moduleDecl: ModuleDeclaration) {\n        var builder = new SymbolScopeBuilder(valueMembers, ambientValueMembers, enclosedTypes, ambientEnclosedTypes, null, container);\n        var chain: ScopeChain = new ScopeChain(container, context.scopeChain, builder);\n        chain.thisType = thisType;\n        chain.classType = classType;\n        chain.moduleDecl = moduleDecl;\n        context.scopeChain = chain;\n    }\n\n    export function popTypeCollectionScope(context: TypeCollectionContext) {\n        context.scopeChain = context.scopeChain.previous;\n    }\n\n    export function preFindEnclosingScope(ast: AST, parent: AST, walker: IAstWalker) {\n        var context: EnclosingScopeContext = walker.state;\n        var minChar = ast.minChar;\n        var limChar = ast.limChar;\n\n        // Account for the fact completion list may be called at the end of a file which\n        // is has not been fully re-parsed yet.\n        if (ast.nodeType == NodeType.Script && context.pos > limChar)\n            limChar = context.pos;\n\n        if ((minChar <= context.pos) &&\n            (limChar >= context.pos)) {\n            switch (ast.nodeType) {\n                case NodeType.Script:\n                    var script = <Script>ast;\n                    context.scopeGetter = function () {\n                        return script.bod === null ? null : script.bod.enclosingScope;\n                    };\n                    context.scopeStartAST = script;\n                    break;\n\n                case NodeType.ClassDeclaration:\n                    context.scopeGetter = function () {\n                        return (ast.type === null || ast.type.instanceType.containedScope === null) ? null : ast.type.instanceType.containedScope;\n                    };\n                    context.scopeStartAST = ast;\n                    context.enclosingClassDecl = <TypeDeclaration>ast;\n                    break;\n\n                case NodeType.ObjectLit:\n                    var objectLit = <UnaryExpression>ast;\n                    // Only consider target-typed object literals\n                    if (objectLit.targetType) {\n                        context.scopeGetter = function () {\n                            return objectLit.targetType.containedScope;\n                        };\n                        context.objectLiteralScopeGetter = function () {\n                            return objectLit.targetType.memberScope;\n                        }\n                        context.enclosingObjectLit = objectLit;\n                    }\n                    break;\n\n                case NodeType.ModuleDeclaration:\n                    context.deepestModuleDecl = <ModuleDeclaration>ast;\n                    context.scopeGetter = function () {\n                        return ast.type === null ? null : ast.type.containedScope;\n                    };\n                    context.scopeStartAST = ast;\n                    break;\n\n                case NodeType.InterfaceDeclaration:\n                    context.scopeGetter = function () {\n                        return (ast.type === null) ? null : ast.type.containedScope;\n                    };\n                    context.scopeStartAST = ast;\n                    break;\n\n                case NodeType.FuncDecl: {\n                    var funcDecl = <FuncDecl>ast;\n                    if (context.skipNextFuncDeclForClass) {\n                        context.skipNextFuncDeclForClass = false;\n                    }\n                    else {\n                        context.scopeGetter = function () {\n                            // The scope of a class constructor is hidden somewhere we don't expect :-S\n                            if (funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {\n                                if (ast.type && ast.type.enclosingType) {\n                                    return ast.type.enclosingType.constructorScope;\n                              ",
v27551=v27552+'  }\n                            }\n\n                            if (funcDecl.scopeType) {\n                                return funcDecl.scopeType.containedScope;\n                            }\n\n                            if (funcDecl.type) {\n                                return funcDecl.type.containedScope;\n                            }\n                            return null;\n                        };\n                        context.scopeStartAST = ast;\n                    }\n                }\n                    break;\n            }\n            walker.options.goChildren = true;\n        }\n        else {\n            walker.options.goChildren = false;\n        }\n        return ast;\n    }\n\n    //\n    // Find the enclosing scope context from a position inside a script AST.\n    // The "scopeStartAST" of the returned scope is always valid.\n    // Return "null" if the enclosing scope can\'t be found.\n    //\n    export function findEnclosingScopeAt(logger: ILogger, script: Script, text: ISourceText, pos: number, isMemberCompletion: bool): EnclosingScopeContext {\n        var context = new EnclosingScopeContext(logger, script, text, pos, isMemberCompletion);\n\n        TypeScript.getAstWalkerFactory().walk(script, preFindEnclosingScope, null, null, context);\n\n        if (context.scopeStartAST === null)\n            return null;\n        return context;\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class Signature {\n        public hasVariableArgList = false;\n        public returnType: TypeLink;\n        public parameters: ParameterSymbol[] = null;\n        public declAST: FuncDecl = null;\n        public typeCheckStatus = TypeCheckStatus.NotStarted;\n        public nonOptionalParameterCount = 0;\n\n        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Signature {\n            var result = new Signature();\n            if (this.hasVariableArgList) {\n                result.hasVariableArgList = true;\n            }\n            result.returnType = new TypeLink();\n            if (this.returnType.type) {\n                result.returnType.type =\n                    this.returnType.type.specializeType(pattern, replacement, checker, false);\n            }\n            else {\n                result.returnType.type = checker.anyType;\n            }\n\n            if (this.parameters) {\n                result.parameters = [];\n                for (var i = 0, len = this.parameters.length; i < len; i++) {\n                    var oldSym:ParameterSymbol = this.parameters[i];\n                    var paramDef = new ValueLocation();\n                    var paramSym = new ParameterSymbol(oldSym.name, oldSym.location,\n                                                     checker.locationInfo.unitIndex,\n                                                     paramDef);\n\n                    paramSym.declAST = this.declAST;\n                    paramDef.symbol = paramSym;\n                    paramDef.typeLink = new TypeLink();\n                    result.parameters[i] = paramSym;\n                    var oldType = oldSym.getType();\n                    if (oldType) {\n                        paramDef.typeLink.type = oldType.specializeType(pattern, replacement, checker, false);\n                        paramSym.declAST.type = paramDef.typeLink.type;\n                    }\n                    else {\n                        paramDef.typeLink.type = checker.anyType;\n                    }\n                }\n            }\n            result.nonOptionalParameterCount = this.nonOptionalParameterCount;\n            result.declAST = this.declAST;\n\n            return result;\n        }\n\n        public toString() {\n            return this.toStringHelper(false, false, null);\n        }\n\n        public toStringHelper(shortform: bool, brackets: bool, scope: SymbolScope) {\n            return this.toStringHelperEx(shortform, brackets, scope).toString();\n        }\n\n        public toStringHelperEx(shortform: bool, brackets: bool, scope: SymbolScope, prefix? : string = "") : MemberName {\n            var builder = new MemberNameArray();\n            if (brackets) {\n                builder.prefix =  prefix + "[";\n            }\n            else {\n                builder.prefix = prefix + "(";\n            }\n\n            var paramLen = this.parameters.length;\n            var len = this.hasVariableArgList ? paramLen - 1 : par',
v27550=v27551+'amLen;\n            for (var i = 0; i < len; i++) {\n                builder.add(MemberName.create(this.parameters[i].name + (this.parameters[i].isOptional() ? "?" : "") + ": "));\n                builder.add(this.parameters[i].getType().getScopedTypeNameEx(scope));\n                if (i < paramLen - 1) {\n                    builder.add(MemberName.create(", "));\n                }\n            }\n\n            if (this.hasVariableArgList) {\n                builder.add(MemberName.create("..." + this.parameters[i].name + ": "));\n                builder.add(this.parameters[i].getType().getScopedTypeNameEx(scope));\n            }\n\n            if (shortform) {\n                if (brackets) {\n                    builder.add(MemberName.create("] => "));\n                }\n                else {\n                    builder.add(MemberName.create(") => "));\n                }\n            }\n            else {\n                if (brackets) {\n                    builder.add(MemberName.create("]: "));\n                }\n                else {\n                    builder.add(MemberName.create("): "));\n                }\n            }\n\n            if (this.returnType.type) {\n                 builder.add(this.returnType.type.getScopedTypeNameEx(scope));\n            }\n            else {\n                builder.add(MemberName.create("any"));\n            }\n            return builder;\n        }\n    }\n\n    export class SignatureGroup {\n        public signatures: Signature[] = [];\n        public hasImplementation = true;\n        public definitionSignature: Signature = null;\n        public hasBeenTypechecked = false;\n        public flags: SignatureFlags = SignatureFlags.None;\n        public addSignature(signature: Signature) {\n            if (this.signatures == null) {\n                this.signatures = new Signature[];\n            }\n            this.signatures[this.signatures.length] = signature;\n            \n            // REVIEW: duplicates should be found within createFunctionSignature,\n            // so we won\'t check for them here\n            if (signature.declAST &&\n                !signature.declAST.isOverload &&\n                !signature.declAST.isSignature() && \n                !hasFlag(signature.declAST.fncFlags, FncFlags.Ambient) &&\n                hasFlag(signature.declAST.fncFlags, FncFlags.Definition)) {\n                this.definitionSignature = signature;\n            }\n        }\n\n        public toString() { return this.signatures.toString(); }\n        public toStrings(prefix: string, shortform: bool, scope: SymbolScope) {\n            var result : MemberName[] = [];  \n            var len = this.signatures.length;\n            if (len > 1) {\n                shortform = false;\n            }\n            for (var i = 0; i < len; i++) {\n                // the definition signature shouldn\'t be printed if there are overloads\n                if (len > 1 && this.signatures[i] == this.definitionSignature) {\n                    continue;\n                }\n                if (this.flags & SignatureFlags.IsIndexer) {\n                    result.push(this.signatures[i].toStringHelperEx(shortform, true, scope));\n                }\n                else {\n                    result.push(this.signatures[i].toStringHelperEx(shortform, false, scope, prefix));\n                }\n            }\n            \n            return result;\n        }\n\n        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): SignatureGroup {\n            var result = new SignatureGroup();\n            if (this.signatures) {\n                for (var i = 0, len = this.signatures.length; i < len; i++) {\n                    result.addSignature(this.signatures[i].specializeType(pattern, replacement, checker));\n                }\n            }\n            return result;\n        }\n\n        // verifies that signatures are\n        //  - unique within a given group\n        //  - compatible with the declaration signature\n        public verifySignatures(checker: TypeChecker) {\n\n            var len = 0;\n            \n            // TODO: verify no signature pair with identical parameters\n            if (this.signatures && ((len = this.signatures.length) > 0)) {\n                \n                for (var i = 0; i < len; i++) {\n                    \n                    for (var j = i + 1; j < len; j++) {\n                        // next check for equivalence between overloads - no two can be exactly the same                     \n                        if (this.signatures[i].declAST && this.signatures[j].declAST &&\n                            (!hasFlag(this.signatures[i].declAST.fncFlags, FncFlags.Definition) && !hasFlag(this.signatures[j].declAST.fncFlags, FncFlags.Definition)) &&\n                            checker.signaturesAreIdentical(this.signatures[i], this.signatures[j])) {\n                            checker.errorReporter.simpleError(this.signatures[i].declAST, (this.signatures[i].declAST && this.signatures[i].declAST.name) ? "Signature for \'" + this.signatures',
v27549=v27550+'[i].declAST.name.actualText + "\' is duplicated" :"Signature is duplicated");\n                        }\n                    }\n                    \n                    // finally, ensure that the definition is assignable to each signature\n                    if (this.definitionSignature) {\n                        if (!checker.signatureIsAssignableToTarget(this.definitionSignature, this.signatures[i])) {\n                            checker.errorReporter.simpleError(this.signatures[i].declAST, "Overload signature is not compatible with function definition");\n                        }\n                    }\n                }\n            }\n        }\n\n        public typeCheck(checker: TypeChecker, ast: AST, hasConstruct:bool) {\n            \n            if (this.hasBeenTypechecked) {\n                return;\n            }\n            \n            // set here to prevent us from recursively invoking typeCheck again\n            this.hasBeenTypechecked = true;\n            \n            var len = 0;\n            \n            if (this.signatures && ((len = this.signatures.length) > 0)) {\n                \n                // first, typecheck each signature\n                for (var i = 0; i < len; i++) {\n\n                    if (!hasConstruct && !this.definitionSignature && this.signatures[i].declAST && this.signatures[i].declAST.isOverload && !hasFlag(this.signatures[i].declAST.fncFlags, FncFlags.Ambient)) {\n                        checker.errorReporter.simpleError(this.signatures[i].declAST, "Overload declaration lacks definition");\n                    }\n\n                    // If we\'re typechecking a constructor via one of its overloads, ensure that the outer class is typechecked, since we need to validate its inheritance properties\n                    // to properly check that \'super\' is being used correctly\n                    if (this.signatures[i].declAST && this.signatures[i].declAST.isConstructor && this.signatures[i].declAST.classDecl && this.signatures[i].declAST.classDecl.type.symbol.typeCheckStatus == TypeCheckStatus.NotStarted) {\n                        checker.typeFlow.typeCheck(this.signatures[i].declAST.classDecl);\n                    }\n\n                    checker.typeFlow.typeCheck(this.signatures[i].declAST);\n                }\n\n                this.verifySignatures(checker);\n            }\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n///<reference path=\'..\\harness\\external\\json2.ts\' />\n\nmodule TypeScript {\n    export class SourceMapPosition {\n        public sourceLine: number;\n        public sourceColumn: number;\n        public emittedLine: number;\n        public emittedColumn: number;\n    }\n\n    export class SourceMapping {\n        public start = new SourceMapPosition();\n        public end = new SourceMapPosition();\n        public nameIndex: number = -1;\n        public childMappings: SourceMapping[] = [];\n    }\n\n    export class SourceMapper {\n        static MapFileExtension = ".map";\n        \n        public sourceMappings: SourceMapping[] = [];\n        public currentMappings: SourceMapping[][] = [];\n\n        public names: string[] = [];\n        public currentNameIndex: number[] = [];\n\n        public jsFileName: string;\n        public tsFileName: string;\n\n        constructor(tsFileName: string, jsFileName: string, public jsFile: ITextWriter, public sourceMapOut: ITextWriter, public errorReporter: ErrorReporter) {\n            this.currentMappings.push(this.sourceMappings);\n\n            jsFileName = switchToForwardSlashes(jsFileName);\n            this.jsFileName = TypeScript.getPrettyName(jsFileName, false, true);\n\n            var removalIndex = jsFileName.lastIndexOf(this.jsFileName);\n            var fixedPath = jsFileName.substring(0, removalIndex);\n\n            this.tsFileName = TypeScript.getRelativePathToFixedPath(fixedPath, tsFileName);\n        }\n        \n        // Generate source mapping\n        static EmitSourceMapping(allSourceMappers: SourceMapper[]) {\n            // At this point we know that there is at least one source mapper present.\n            // If there are multiple source mappers, all will correspond to same map file but different sources\n\n            // Output map file name into the js file\n            var sourceMapper = allSourceMappers[0];\n            sourceMapper.jsFile.WriteLine("//@ sourceMappingURL=" + sourceMapper.jsFileName + SourceMapper.MapFileExtension);\n\n  ',
v27548=v27549+'          // Now output map file\n            var sourceMapOut = sourceMapper.sourceMapOut;\n            var mappingsString = "";\n            var tsFiles: string[] = [];\n\n            var prevEmittedColumn = 0;\n            var prevEmittedLine = 0;\n            var prevSourceColumn = 0;\n            var prevSourceLine = 0;\n            var prevSourceIndex = 0;\n            var prevNameIndex = 0;\n            var namesList: string[] = [];\n            var namesCount = 0;\n            var emitComma = false;\n\n            var recordedPosition: SourceMapPosition = null;\n            for (var sourceMapperIndex = 0; sourceMapperIndex < allSourceMappers.length; sourceMapperIndex++) {\n                sourceMapper = allSourceMappers[sourceMapperIndex];\n\n                // If there are any mappings generated\n                var currentSourceIndex = tsFiles.length;\n                tsFiles.push(sourceMapper.tsFileName);\n\n                // Join namelist\n                if (sourceMapper.names.length > 0) {\n                    namesList.push.apply(namesList, sourceMapper.names);\n                }\n\n                var recordSourceMapping = (mappedPosition: SourceMapPosition, nameIndex: number) => {\n                    if (recordedPosition != null &&\n                        recordedPosition.emittedColumn == mappedPosition.emittedColumn &&\n                        recordedPosition.emittedLine == mappedPosition.emittedLine) {\n                        // This position is already recorded\n                        return;\n                    }\n\n                    // Record this position\n                    if (prevEmittedLine !== mappedPosition.emittedLine) {\n                        while (prevEmittedLine < mappedPosition.emittedLine) {\n                            prevEmittedColumn = 0;\n                            mappingsString = mappingsString + ";";\n                            prevEmittedLine++;\n                        }\n                        emitComma = false;\n                    }\n                    else if (emitComma) {\n                        mappingsString = mappingsString + ",";\n                    }\n\n                    // 1. Relative Column\n                    mappingsString = mappingsString + Base64VLQFormat.encode(mappedPosition.emittedColumn - prevEmittedColumn);\n                    prevEmittedColumn = mappedPosition.emittedColumn;\n\n                    // 2. Relative sourceIndex \n                    mappingsString = mappingsString + Base64VLQFormat.encode(currentSourceIndex - prevSourceIndex);\n                    prevSourceIndex = currentSourceIndex;\n\n                    // 3. Relative sourceLine 0 based\n                    mappingsString = mappingsString + Base64VLQFormat.encode(mappedPosition.sourceLine - 1 - prevSourceLine);\n                    prevSourceLine = mappedPosition.sourceLine - 1;\n\n                    // 4. Relative sourceColumn 0 based \n                    mappingsString = mappingsString + Base64VLQFormat.encode(mappedPosition.sourceColumn - prevSourceColumn);\n                    prevSourceColumn = mappedPosition.sourceColumn;\n\n                    // 5. Relative namePosition 0 based\n                    if (nameIndex >= 0) {\n                        mappingsString = mappingsString + Base64VLQFormat.encode(namesCount + nameIndex - prevNameIndex);\n                        prevNameIndex = namesCount + nameIndex;\n                    }\n\n                    emitComma = true;\n                    recordedPosition = mappedPosition;\n                }\n\n                // Record starting spans\n                var recordSourceMappingSiblings = (sourceMappings: SourceMapping[]) => {\n                    for (var i = 0; i < sourceMappings.length; i++) {\n                        var sourceMapping = sourceMappings[i];\n                        recordSourceMapping(sourceMapping.start, sourceMapping.nameIndex);\n                        recordSourceMappingSiblings(sourceMapping.childMappings);\n                        recordSourceMapping(sourceMapping.end, sourceMapping.nameIndex);\n                    }\n                }\n\n                recordSourceMappingSiblings(sourceMapper.sourceMappings, -1);\n                namesCount = namesCount + sourceMapper.names.length;\n            }\n\n            // Write the actual map file\n            if (mappingsString != "") {\n                sourceMapOut.Write(JSON2.stringify({\n                    version: 3,\n                    file: sourceMapper.jsFileName,\n                    sources: tsFiles,\n                    names: namesList,\n                    mappings: mappingsString\n                }));\n            }\n\n            // Done, close the file\n            try {\n                // Closing files could result in exceptions, report them if they occur\n                sourceMapOut.Close();\n            } catch (ex) {\n                sourceMapper.errorReporter.emitterError(null, ex.message);\n            }\n        }\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under',
v27547=v27548+' the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    // private members are private to the scope\n    // public members are public to the scope\n    export class ScopedMembers {\n\n        public allMembers: IHashTable;\n        public publicMembers: IHashTable;\n        public privateMembers: IHashTable;\n\n        constructor (public dualMembers: DualStringHashTable) { \n            this.allMembers = this.dualMembers;\n            this.publicMembers = this.dualMembers.primaryTable;\n            this.privateMembers = this.dualMembers.secondaryTable;\n        }\n\n        // add a public member\n        public addPublicMember(key: string, data) { return this.dualMembers.primaryTable.add(key, data); }\n\n        // add a private member \n        public addPrivateMember(key: string, data) { return this.dualMembers.secondaryTable.add(key, data); }\n    }\n\n    export enum SymbolKind {\n        None,\n        Type,\n        Field,\n        Parameter,\n        Variable,\n    }\n\n    export class SymbolScope {\n        constructor (public container: Symbol) { }\n        public printLabel() { return "base"; }\n        public getAllSymbolNames(members: bool): string[]{\n            return ["please", "implement", "in", "derived", "classes"];\n        }\n        public getAllTypeSymbolNames(members: bool): string[]{\n            return ["please", "implement", "in", "derived", "classes"];\n        }\n        public getAllValueSymbolNames(members: bool): string[]{\n            return ["please", "implement", "in", "derived", "classes"];\n        }\n        // advanced search using a filter\n        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool): Symbol { return null; }\n        // find in this immediate scope\n        public findLocal(name: string, publicOnly: bool, typespace: bool): Symbol { return null; }\n        // find in value namespace \n        public find(name: string, publicOnly: bool, typespace: bool): Symbol { return null; }\n        // find symbol that supplies an implementation\n        public findImplementation(name: string, publicOnly: bool, typespace: bool): Symbol { return null; }\n        // restrict the search to ambient values\n        public findAmbient(name: string, publicOnly: bool, typespace: bool): Symbol { return null; }\n        public print(outfile: ITextWriter) {\n            if (this.container) {\n                outfile.WriteLine(this.printLabel() + " scope with container: " + this.container.name + "...");\n            }\n            else {\n                outfile.WriteLine(this.printLabel() + " scope...");\n            }\n        }\n\n        public enter(container: Symbol, ast: AST, symbol: Symbol, errorReporter: ErrorReporter, publicOnly: bool,\n            typespace: bool, ambient: bool): void {\n            throw new Error("please implement in derived class");\n        }\n\n        public getTable(): IHashTable {\n            throw new Error("please implement in derived class");\n        }\n    }\n\n    function symbolCanBeUsed(sym: Symbol, publicOnly) {\n        return publicOnly ? !(hasFlag(sym.flags, SymbolFlags.Private) ||\n                            (sym.declAST && sym.declAST.nodeType == NodeType.FuncDecl && hasFlag((<FuncDecl>sym.declAST).fncFlags, FncFlags.Private)))\n                          : true;\n    }\n\n    export class SymbolAggregateScope extends SymbolScope {\n        public printLabel() { return "agg"; }\n        public valueCache: IHashTable = null;\n        public valueImplCache: IHashTable = null;\n        public valueAmbientCache: IHashTable = null;\n        public typeCache: IHashTable = null;\n        public typeImplCache: IHashTable = null;\n        public typeAmbientCache: IHashTable = null;\n        public parents: SymbolScope[] = null;\n        public container: Symbol;\n\n        constructor (container: Symbol) {\n            super(container);\n            this.container = container;\n        }\n\n        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool) {\n            if (this.parents) {\n                for (var i = 0; i < this.parents.length; i++) {\n                    var sym = this.parents[i].search(filter, name, publicOnly, typespace);\n                    if (sym) {\n                        if (filter.update(sym)) {\n                            return sym;\n                        }\n                    }\n                }\n            }\n            return filter.result;\n        }\n\n        public getAllSymbolNames(members',
v27546=v27547+": bool): string[]{\n            var result: string[] = [];\n            if (this.parents) {\n                for (var i = 0; i < this.parents.length; i++) {\n                    var parentResult = this.parents[i].getAllSymbolNames(members);\n                    if (parentResult) {\n                        result = result.concat(parentResult);\n                    }\n                }\n            }\n            return result;\n        }\n\n        public getAllTypeSymbolNames(members: bool): string[]{\n            var result: string[] = [];\n            if (this.parents) {\n                for (var i = 0; i < this.parents.length; i++) {\n                    var parentResult = this.parents[i].getAllTypeSymbolNames(members);\n                    if (parentResult) {\n                        result = result.concat(parentResult);\n                    }\n                }\n            }\n            return result;\n        }\n\n        public getAllValueSymbolNames(members: bool): string[]{\n            var result: string[] = [];\n            if (this.parents) {\n                for (var i = 0; i < this.parents.length; i++) {\n                    var parentResult = this.parents[i].getAllValueSymbolNames(members);\n                    if (parentResult) {\n                        result = result.concat(parentResult);\n                    }\n                }\n            }\n            return result;\n        }\n\n        public print(outfile: ITextWriter) {\n            super.print(outfile);\n            if (this.parents) {\n                for (var i = 0; i < this.parents.length; i++) {\n                    this.parents[i].print(outfile);\n                }\n            }\n        }\n\n        public findImplementation(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var i = 0;\n            var implCache = this.valueImplCache;\n\n            if (typespace) {\n                implCache = this.typeImplCache;\n            }\n            if (implCache &&\n                ((sym = implCache.lookup(name)) != null) &&\n                (publicOnly ? !(hasFlag(sym.flags, SymbolFlags.Private) ||\n                                        (sym.declAST && sym.declAST.nodeType == NodeType.FuncDecl && hasFlag((<FuncDecl>sym.declAST).fncFlags, FncFlags.Private)))\n                                        : true)) {\n                return sym;\n            }\n            if (this.parents) {\n                for (i = 0; i < this.parents.length; i++) {\n                    sym = this.parents[i].findImplementation(name, publicOnly, typespace);\n                    if (sym) {\n                        break;\n                    }\n                }\n            }\n            if (implCache) {\n                if (typespace) {\n                    this.typeImplCache = new StringHashTable();\n                    implCache = this.typeImplCache;\n                }\n                else {\n                    this.valueImplCache = new StringHashTable();\n                    implCache = this.valueImplCache;\n                }\n            }\n            implCache.add(name, sym);\n            return sym;\n        }\n\n        public find(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var i = 0;\n            var cache = this.valueCache;\n\n            if (typespace) {\n                cache = this.typeCache;\n            }\n            if (cache &&\n                ((sym = cache.lookup(name)) != null) &&\n                (publicOnly ? !(hasFlag(sym.flags, SymbolFlags.Private) ||\n                                        (sym.declAST && sym.declAST.nodeType == NodeType.FuncDecl && hasFlag((<FuncDecl>sym.declAST).fncFlags, FncFlags.Private)))\n                                        : true)) {\n                return sym;\n            }\n            if (this.parents) {\n                for (i = 0; i < this.parents.length; i++) {\n                    sym = this.parents[i].find(name, publicOnly, typespace);\n                    if (sym) {\n                        break;\n                    }\n                }\n            }\n            if (cache == null) {\n                if (typespace) {\n                    this.typeCache = new StringHashTable();\n                    cache = this.typeCache;\n                }\n                else {\n                    this.valueCache = new StringHashTable();\n                    cache = this.valueCache;\n                }\n            }\n            cache.add(name, sym);\n            return sym;\n        }\n\n        public findAmbient(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var i = 0;\n            var cache = this.valueAmbientCache;\n            if (typespace) {\n                cache = this.typeAmbientCache;\n            }\n            if (cache && ((sym = cache.lookup(name)) != null)) {\n                return sym;\n            }\n            if (this.parents) {\n                for (i = 0; i < this.parents.length; i++) {\n                    sym =",
v27545=v27546+' this.parents[i].findAmbient(name, publicOnly, typespace);\n                    if (sym) {\n                        break;\n                    }\n                }\n            }\n            if (cache == null) {\n                if (typespace) {\n                    this.typeAmbientCache = new StringHashTable();\n                    cache = this.typeAmbientCache;\n                }\n                else {\n                    this.valueAmbientCache = new StringHashTable();\n                    cache = this.valueAmbientCache;\n                }\n            }\n            cache.add(name, sym);\n            return sym;\n        }\n\n        public addParentScope(parent: SymbolScope): void {\n            if (this.parents == null) {\n                this.parents = new SymbolScope[];\n            }\n            this.parents[this.parents.length] = parent;\n        }\n    }\n\n    export class SymbolTableScope extends SymbolScope {\n        public container: Symbol;\n\n        constructor(public valueMembers: ScopedMembers,\n                            public ambientValueMembers: ScopedMembers,\n                            public enclosedTypes: ScopedMembers,\n                            public ambientEnclosedTypes: ScopedMembers,\n                            container: Symbol)\n        {\n            super(container);\n            this.container = container;\n        }\n\n        public printLabel() { return "table"; }\n\n        public getAllSymbolNames(members: bool): string[]{\n            var result = this.getAllTypeSymbolNames(members);\n\n            return result.concat(this.getAllValueSymbolNames(members));\n        }\n\n        public getAllTypeSymbolNames(members: bool): string[]{\n            var result = [];\n            if (this.ambientEnclosedTypes) {\n                result = result.concat(this.ambientEnclosedTypes.allMembers.getAllKeys());\n            }\n            if (this.enclosedTypes) {\n                result = result.concat(this.enclosedTypes.allMembers.getAllKeys());\n            }\n            return result;\n        }\n\n        public getAllValueSymbolNames(members: bool): string[]{\n            var result = [];\n            if (this.ambientValueMembers) {\n                result = result.concat(this.ambientValueMembers.allMembers.getAllKeys());\n            }\n            if (this.valueMembers) {\n                result = result.concat(this.valueMembers.allMembers.getAllKeys());\n            }\n            return result;\n        }\n\n        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool) {\n            var sym = this.find(name, publicOnly, typespace);\n            filter.update(sym);\n            return filter.result;\n        }\n\n        public find(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var table: IHashTable = null;\n            var ambientTable: IHashTable = null;\n\n            if (typespace) {\n                table = (this.enclosedTypes == null) ? null :\n                            publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            else {\n                table = (this.valueMembers == null) ? null :\n                                publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;\n                ambientTable = (this.ambientValueMembers == null) ? null :\n                                    publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            }\n            if (ambientTable) {\n                var s = ambientTable.lookup(name);\n                if (s) { return s; }\n            }\n            if (table) {\n                var s = table.lookup(name);\n                if (s) { return s; }\n            }\n\n            return null;\n        }\n\n        public findAmbient(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var ambientTable = (this.ambientValueMembers == null) ? null :\n                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            if (typespace) {\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            if (ambientTable) {\n                var s = ambientTable.lookup(name);\n                if (s) { return s; }\n            }\n\n            return null;\n        }\n\n        public print(outfile: ITextWriter) {\n            super.print(outfile);\n            if (this.ambientValueMembers) {\n                this.ambientValueMembers.allMembers.map(function (key, sym, context) {\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n            if (this.valueMembers) {\n   ',
v27544=v27545+'             this.valueMembers.allMembers.map(function (key, sym, context) {\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n            if (this.ambientEnclosedTypes) {\n                this.ambientEnclosedTypes.allMembers.map(function (key, sym, context) {\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n            if (this.enclosedTypes) {\n                this.enclosedTypes.allMembers.map(function (key, sym, context) {\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n        }\n\n        public findImplementation(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym = this.find(name, publicOnly, typespace);\n            if (sym) {\n                if (sym.kind() == SymbolKind.Type) {\n                    var typeSym = <TypeSymbol>sym;\n                    if (!typeSym.type.hasImplementation()) {\n                        sym = null;\n                    }\n                }\n                else if (sym.container) {\n                    if (sym.container.kind() == SymbolKind.Type) {\n                        var ctypeSym = <TypeSymbol>sym.container;\n                        if (!ctypeSym.type.hasImplementation()) {\n                            sym = null;\n                        }\n                    }\n                }\n            }\n            return sym;\n        }\n\n        public getTable() {\n            return this.valueMembers.publicMembers;\n        }\n    }\n\n    export class SymbolScopeBuilder extends SymbolScope {\n        public container: Symbol;\n        \n        constructor (public valueMembers: ScopedMembers,\n                    public ambientValueMembers: ScopedMembers,\n                    public enclosedTypes: ScopedMembers,\n                    public ambientEnclosedTypes: ScopedMembers,\n                    public parent: SymbolScope,\n                    container: Symbol)\n        {\n            super(container);\n            this.container = container;\n        }\n\n        public printLabel() { return "builder"; }\n        public getAllSymbolNames(members: bool): string[]{\n            var result: string[] = this.getAllTypeSymbolNames(members);\n            return result.concat(this.getAllValueSymbolNames(members));\n        }\n\n        public getAllTypeSymbolNames(members: bool): string[]{\n            var result: string[] = [];\n            if (this.ambientEnclosedTypes) {\n                result = result.concat(this.ambientEnclosedTypes.allMembers.getAllKeys());\n            }\n            if (this.enclosedTypes) {\n                result = result.concat(this.enclosedTypes.allMembers.getAllKeys());\n            }\n            if (!members && this.parent) {\n                var parentResult = this.parent.getAllTypeSymbolNames(members);\n                if (parentResult) {\n                    result = result.concat(parentResult);\n                }\n            }\n            return result;\n        }\n\n        public getAllValueSymbolNames(members: bool): string[]{\n            var result: string[] = [];\n            if (this.ambientValueMembers) {\n                result = result.concat(this.ambientValueMembers.allMembers.getAllKeys());\n            }\n            if (this.valueMembers) {\n                result = result.concat(this.valueMembers.allMembers.getAllKeys());\n            }\n            if (!members && this.parent) {\n                var parentResult = this.parent.getAllValueSymbolNames(members);\n                if (parentResult) {\n                    result = result.concat(parentResult);\n                }\n            }\n            return result;\n        }\n\n        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool) {\n            var sym: Symbol = null;\n            var table = (this.valueMembers == null) ? null :\n                            publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;\n            var ambientTable = (this.ambientValueMembers == null) ? null :\n                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            if (typespace) {\n                table = (this.enclosedTypes == null) ? null :\n                            publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            if (ambientTable) {\n                if ((sym = ambientTable.lookup(name)) != null) {\n                    if (filter.update(sym)) {\n                        return sym;\n                    }\n                }\n            }\n            if (table) {\n                if ((sym = table.lookup(name)) != null) {\n                    if (filter.update(sym)) {\n                        return sym;\n                    }\n        ',
v27543=v27544+'        }\n            }\n            if (this.parent) {\n                sym = this.parent.search(filter, name, publicOnly, typespace);\n                if (sym) {\n                    if (filter.update(sym)) {\n                        return sym;\n                    }\n                }\n            }\n            return filter.result;\n        }\n\n        public print(outfile: ITextWriter) {\n            super.print(outfile);\n            if (this.ambientValueMembers) {\n                this.ambientValueMembers.allMembers.map(function (key, s, context) {\n                    var sym = <Symbol>s;\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n            if (this.valueMembers) {\n                this.valueMembers.allMembers.map(function (key, s, context) {\n                    var sym = <Symbol>s;\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n            if (this.ambientEnclosedTypes) {\n                this.ambientEnclosedTypes.allMembers.map(function (key, s, context) {\n                    var sym = <Symbol>s;\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n            if (this.enclosedTypes) {\n                this.enclosedTypes.allMembers.map(function (key, s, context) {\n                    var sym = <Symbol>s;\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n            if (this.parent) {\n                this.parent.print(outfile);\n            }\n        }\n\n        public find(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var table = (this.valueMembers == null) ? null :\n                            publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;\n            var ambientTable = (this.ambientValueMembers == null) ? null :\n                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            if (typespace) {\n                table = (this.enclosedTypes == null) ? null :\n                            publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            if (ambientTable && ((sym = ambientTable.lookup(name)) != null)) {\n                return sym;\n            }\n            if (table && ((sym = table.lookup(name)) != null)) {\n                return sym;\n            }\n            if (this.parent) {\n                return this.parent.find(name, publicOnly, typespace);\n            }\n            return null;\n        }\n\n        public findAmbient(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var ambientTable = (this.ambientValueMembers == null) ? null :\n                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            if (typespace) {\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            if (ambientTable && ((sym = ambientTable.lookup(name)) != null)) {\n                return sym;\n            }\n            if (this.parent) {\n                return this.parent.findAmbient(name, publicOnly, typespace);\n            }\n            return null;\n        }\n\n        public findLocal(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var table = (this.valueMembers == null) ? null :\n                            publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;\n            var ambientTable = (this.ambientValueMembers == null) ? null :\n                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            if (typespace) {\n                table = (this.enclosedTypes == null) ? null :\n                            publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            if (table) {\n                if ((sym = table.lookup(name)) != null) {\n                    if (sym) { return sym; }\n                }\n            }\n            if (ambientTable) {\n                if ((sym = ambientTable.lookup(name)) != null) {\n                    if (sym) { return sym; }\n                }\n            }\n            return null;\n        }\n\n        public enter(container: Symbol, ast: AST, symbol: Symbol, ',
v27542=v27543+'errorReporter: ErrorReporter, insertAsPublic: bool, typespace: bool, ambient: bool): void {\n            var table = null;\n\n            if (ambient) {\n                if (typespace) {\n                    table = (this.ambientEnclosedTypes == null) ? null :\n                                    insertAsPublic ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.privateMembers;\n                }\n                else {\n                    table = (this.ambientValueMembers == null) ? null :\n                                insertAsPublic ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.privateMembers;\n                }\n            }\n            else {\n                if (typespace) {\n                    table = (this.enclosedTypes == null) ? null :\n                                insertAsPublic ? this.enclosedTypes.publicMembers : this.enclosedTypes.privateMembers;\n                }\n                else {\n                    table = (this.valueMembers == null) ? null :\n                                insertAsPublic ? this.valueMembers.publicMembers : this.valueMembers.privateMembers;\n                }\n            }\n\n            if (table) {\n                if (!table.add(symbol.name, symbol)) {\n                    errorReporter.duplicateIdentifier(ast, symbol.name);\n                }\n            }\n            else {\n                CompilerDiagnostics.Alert("YYYYY");  // REVIEW: Surely we can do better than this...\n            }\n            symbol.container = container;\n        }\n\n        public getTable() { return this.valueMembers.allMembers; }\n    }\n\n    export class FilteredSymbolScope extends SymbolScope {\n        constructor (public scope: SymbolScope, container: Symbol, public filter: ScopeSearchFilter) {\n            super(container);\n        }\n        public print(outfile: ITextWriter) {\n            this.scope.print(outfile);\n        }\n\n        public find(name: string, publicOnly: bool, typespace: bool) {\n            this.filter.reset();\n            return this.scope.search(this.filter, name, publicOnly, typespace);\n        }\n        public findLocal(name: string, publicOnly: bool, typespace: bool) { return this.scope.findLocal(name, publicOnly, typespace); }\n    }\n\n    export class FilteredSymbolScopeBuilder extends SymbolScopeBuilder {\n        constructor (valueMembers: ScopedMembers, parent: SymbolScope, container: Symbol, public filter: (sym: Symbol) =>bool) {\n            super(valueMembers, null, null, null, parent, container);\n        }\n        public findLocal(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym = super.findLocal(name, publicOnly, typespace);\n            if (sym) {\n                if (!this.filter(sym)) {\n                    return null;\n                }\n            }\n            return sym;\n        }\n\n        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool):Symbol {\n            throw new Error("please implement");\n        }\n\n        public find(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym = super.findLocal(name, publicOnly, typespace);\n            if (sym) {\n                if (!this.filter(sym)) {\n                    return null;\n                }\n            }\n            return super.find(name, publicOnly, typespace);\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export enum TypeCheckStatus {\n        NotStarted,\n        Started,\n        Finished,\n    }\n\n    // For lexically-scoped constructs\n    export function aLexicallyEnclosesB(a: Symbol, b: Symbol) {\n        if (a.declAST && b && b.declAST && a.declAST.nodeType == NodeType.FuncDecl) {\n            return a.declAST.minChar <= b.declAST.minChar && a.declAST.limChar >= b.declAST.limChar;\n        }\n        else {\n            return false;\n        }\n    }\n\n    export function aEnclosesB(a: Symbol, b: Symbol) {\n        while (a.container) {\n            if (a == b || aLexicallyEnclosesB(a.container, b)) {\n                return true;\n            }\n            a = a.container;\n        }\n        return false;\n    }\n\n    export interface PhasedTypecheckObject {\n        typeCheckStatus: TypeCheckStatus;\n    }\n\n    export class Symbol {\n        public bound = false;\n        public container: Symbol;\n        public instanceScope(): SymbolScope { return null;',
v27541=v27542+' }\n        public isVariable() { return false; }\n        public isMember() { return false; }\n        public isInferenceSymbol() { return false; }\n        public isWith() { return false; }\n        public writeable() { return false; }\n        public isType(): bool { return false; }\n        public getType(): Type { return null; }\n        public flags: SymbolFlags = SymbolFlags.None;\n        public refs: Identifier[];\n        public isAccessor() { return false; }\n        public isObjectLitField = false;\n\n        public declAST: AST = null;\n        public declModule: ModuleDeclaration = null;  // if child of module, this is the module that declared it\n\n        public passSymbolCreated: number = CompilerDiagnostics.analysisPass;\n\n        constructor(public name: string, public location: number, public length: number,\n                 public unitIndex: number) { }\n\n        public isInstanceProperty() {\n            return hasFlag(this.flags, SymbolFlags.Property) && (!hasFlag(this.flags, SymbolFlags.ModuleMember));\n        }\n\n        public getTypeName(scope: SymbolScope): string {\n            return this.getTypeNameEx(scope).toString();\n        }\n        \n        public getTypeNameEx(scope: SymbolScope): MemberName {\n            return MemberName.create(this.toString());\n        }\n\n        public getOptionalNameString() {\n            return hasFlag(this.flags, SymbolFlags.Optional) ? "?" : "";\n        }\n\n        public pathToRoot() {\n            var path = new Symbol[];\n            var node = this;\n            while (node && (node.name != globalId)) {\n                path[path.length] = node;\n                node = node.container;\n            }\n            return path;\n        }\n\n        public findCommonAncestorPath(b: Symbol) {\n            if (this.container == null) {\n                return new Symbol[];\n            }\n            var aPath = this.container.pathToRoot();\n            var bPath: Symbol[];\n            if (b) {\n                bPath = b.pathToRoot();\n            }\n            else {\n                bPath = new Symbol[];\n            }\n            var commonNodeIndex = -1;\n            for (var i = 0, aLen = aPath.length; i < aLen; i++) {\n                var aNode = aPath[i];\n                for (var j = 0, bLen = bPath.length; j < bLen; j++) {\n                    var bNode = bPath[j];\n                    if (aNode == bNode) {\n                        commonNodeIndex = i;\n                        break;\n                    }\n                }\n                if (commonNodeIndex >= 0) {\n                    break;\n                }\n            }\n            if (commonNodeIndex >= 0) {\n                return aPath.slice(0, commonNodeIndex);\n            }\n            else {\n                return aPath;\n            }\n        }\n\n        // Gets the pretty Name for the symbol withing the scope\n        public getPrettyName(scopeSymbol: Symbol) {\n            return this.name;\n        }\n\n        public scopeRelativeName(scope: SymbolScope): string {\n            if (scope == null) {\n                return this.getPrettyName(null) + this.getOptionalNameString();\n            }\n            var lca = this.findCommonAncestorPath(scope.container);\n            var builder = "";\n            for (var i = 0, len = lca.length; i < len; i++) {\n                var prettyName = lca[i].getPrettyName(i == len - 1 ? scope.container : lca[i + 1]);\n                builder = prettyName + "." + builder;\n            }\n            builder += this.getPrettyName(len == 0 ? scope.container : lca[0]) + this.getOptionalNameString();\n            return builder;\n        }\n\n        public fullName(): string {\n            var builder = this.name;\n            var ancestor = this.container;\n            while (ancestor && (ancestor.name != globalId)) {\n                builder = ancestor.name + "." + builder;\n                ancestor = ancestor.container;\n            }\n            return builder;\n        }\n\n        public isExternallyVisible(checker: TypeChecker) {\n            // Global module is not hidden\n            if (this == checker.gloMod) {\n                return true;\n            }\n\n            // private symbol\n            if (hasFlag(this.flags, SymbolFlags.Private)) {\n                return false;\n            }\n\n            // If the current container is not exported\n            // If its in global - it is visible, otherwise it isn\'t\n            if (!hasFlag(this.flags, SymbolFlags.Exported)) {\n                return this.container == checker.gloMod;\n            }\n\n            // It is visible if its container is visible too\n            return this.container.isExternallyVisible(checker);\n        }\n\n        public visible(scope: SymbolScope, checker: TypeChecker) {\n            if (checker == null || this.container == checker.gloMod) {\n                return true;\n            }\n\n            if (hasFlag(this.flags, SymbolFlags.ModuleMember)) {\n\n                if (hasFlag(this.flags, SymbolFlags.Exported)) {\n                    if (!hasFlag',
v27540=v27541+'(this.flags, SymbolFlags.Private)) {\n                        return true;\n                    }\n                    else {\n                        return aEnclosesB(this, scope.container);\n                    }\n                }\n                else {\n                    // REVIEW:\n                    // Note that in the scope-assignment and binding phases,\n                    // currentModDecl will point to the "master" module decl,\n                    // and not necessarily the one that the symbol in question\n                    // was declared in.\n                    // That\'s ok - there\'s no harm done in attributing the symbol\n                    // to the master mod decl in either of those phases, so long\n                    // as we reference the actual module fragment of declaration\n                    // during typecheck.  Doing this also prevents us from printing\n                    // multiple error messages if the symbol is not visible.\n                    return checker && (checker.currentModDecl == this.declModule) ||\n                                                (checker.currentModDecl &&\n                                                    checker.currentModDecl.mod &&\n                                                    checker.currentModDecl.mod.symbol &&\n                                                    this.declModule &&\n                                                    this.declModule.mod &&\n                                                    this.declModule.mod.symbol &&\n                                                    aEnclosesB(checker.currentModDecl.mod.symbol, this.declModule.mod.symbol));\n                }\n            }\n            else {\n                // field or method\n                var isFunction = this.declAST && this.declAST.nodeType == NodeType.FuncDecl;\n                var isMethod = isFunction && (<FuncDecl>this.declAST).isMethod();\n                var isStaticFunction = isFunction && hasFlag((<FuncDecl>this.declAST).fncFlags, FncFlags.Static)\n                var isPrivateMethod = isMethod && hasFlag((<FuncDecl>this.declAST).fncFlags, FncFlags.Private);\n                var isAlias = this.isType() && (<TypeSymbol>this).aliasLink;\n\n                if (this.isMember() || isMethod || isStaticFunction || isAlias) {\n                    if (hasFlag(this.flags, SymbolFlags.Private) || isPrivateMethod) {\n                        if (scope.container == null && this.container != scope.container) {\n                            return false; // it\'s an inner member being accessed by the global scope\n                        }\n                        else {\n                            return this.container == null ? true : aEnclosesB(scope.container, this.container);\n                        }\n                    }\n                    else {\n                        return true;\n                    }\n                }\n                else if (this.container) {\n                    return aEnclosesB(this, scope.container);\n                }\n                else {\n                    return true;\n                }\n            }\n        }\n\n        public addRef(identifier: Identifier) {\n            if (!this.refs) {\n                this.refs = [];\n            }\n            this.refs[this.refs.length] = identifier;\n        }\n\n        public toString() {\n            if (this.name) {\n                return this.name;\n            }\n            else {\n                return "_anonymous";\n            }\n        }\n\n        public print(outfile) {\n            outfile.Write(this.toString());\n        }\n\n        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Symbol {\n            throw new Error("please implement in derived class");\n        }\n\n        public setType(type: Type) {\n            throw new Error("please implement in derived class");\n        }\n\n        public kind(): SymbolKind {\n            throw new Error("please implement in derived class");\n        }\n\n        public getInterfaceDeclFromSymbol(checker: TypeChecker) {\n            if (this.declAST != null) {\n                if (this.declAST.nodeType == NodeType.InterfaceDeclaration) {\n                    return <InterfaceDeclaration>this.declAST;\n                } else if (this.container != null && this.container != checker.gloMod && this.container.declAST.nodeType == NodeType.InterfaceDeclaration) {\n                    return <InterfaceDeclaration>this.container.declAST;\n                }\n            }\n\n            return null;\n        }\n\n        public getVarDeclFromSymbol() {\n            if (this.declAST != null && this.declAST.nodeType == NodeType.VarDecl) {\n                return <VarDecl>this.declAST;\n            }\n\n            return null;\n        }\n\n        public getDocComments() : Comment[] {\n            if (this.declAST != null) {\n                return this.declAST.getDocComments();\n            }\n\n            return [];\n        }\n\n        public isStatic() {\n            return hasFlag(this.fla',
v27539=v27540+'gs, SymbolFlags.Static);\n        }\n    }\n\n    export class ValueLocation {\n        public symbol: Symbol;\n        public typeLink: TypeLink;\n    }\n\n    export class InferenceSymbol extends Symbol {\n        constructor (name: string, location: number, length: number, unitIndex: number) {\n            super(name, location, length, unitIndex);\n        }\n\n        public typeCheckStatus = TypeCheckStatus.NotStarted;\n        public isInferenceSymbol() { return true; }\n        public transferVarFlags(varFlags: VarFlags) {\n            if (hasFlag(varFlags, VarFlags.Ambient)) {\n                this.flags |= SymbolFlags.Ambient;\n            }\n            if (hasFlag(varFlags, VarFlags.Constant)) {\n                this.flags |= SymbolFlags.Constant;\n            }\n            if (hasFlag(varFlags, VarFlags.Static)) {\n                this.flags |= SymbolFlags.Static;\n            }\n            if (hasFlag(varFlags, VarFlags.Property)) {\n                this.flags |= SymbolFlags.Property;\n            }\n            if (hasFlag(varFlags, VarFlags.Private)) {\n                this.flags |= SymbolFlags.Private;\n            }\n            if (hasFlag(varFlags, VarFlags.Public)) {\n                this.flags |= SymbolFlags.Public;\n            }\n            if (hasFlag(varFlags, VarFlags.Readonly)) {\n                this.flags |= SymbolFlags.Readonly;\n            }\n            if (hasFlag(varFlags, VarFlags.Exported)) {\n                this.flags |= SymbolFlags.Exported;\n            }\n        }\n    }\n\n    export class TypeSymbol extends InferenceSymbol {\n        public additionalLocations: number[];\n        public expansions: Type[] = []; // For types that may be "split", keep track of the subsequent definitions\n        public expansionsDeclAST: AST[] = [];\n        public isDynamic = false;\n\n        constructor (locName: string, location: number, length: number, unitIndex: number, public type: Type) {\n            super(locName, location, length, unitIndex);\n            this.prettyName = this.name;\n        }\n\n        public addLocation(loc: number) {\n            if (this.additionalLocations == null) {\n                this.additionalLocations = [];\n            }\n            this.additionalLocations[this.additionalLocations.length] = loc;\n        }\n        public isMethod = false;\n        public aliasLink:ImportDeclaration = null;\n        public kind() { return SymbolKind.Type; }\n        public isType(): bool { return true; }\n        public getType() { return this.type; }\n        public prettyName: string;\n        public onlyReferencedAsTypeRef = optimizeModuleCodeGen;\n\n        public getTypeNameEx(scope: SymbolScope) {\n            return this.type.getMemberTypeNameEx(this.name ? this.name + this.getOptionalNameString() : "", false, false, scope);\n        }\n\n        public instanceScope(): SymbolScope {\n            // Don\'t use the constructor scope for a class body or methods - use the contained scope\n            if (!(this.type.typeFlags & TypeFlags.IsClass) && this.type.isClass()) {\n                return this.type.instanceType.constructorScope;\n            }\n            else {\n                return this.type.containedScope;\n            }\n        }\n        // corresponding instance type if this is a class\n        public instanceType: Type;\n\n        public toString() {\n            var result = this.type.getTypeName();\n            if (this.name) {\n                result = this.name + ":" + result;\n            }\n            return result;\n        }\n\n        public isClass() { return this.instanceType != null; }\n        public isFunction() { return this.declAST != null && this.declAST.nodeType == NodeType.FuncDecl; }\n\n        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Symbol {\n            if (this.type == pattern) {\n                return replacement.symbol;\n            }\n            else {\n                var replType = this.type.specializeType(pattern, replacement, checker, false);\n                if (replType != this.type) {\n                    var result = new TypeSymbol(this.name, -1, 0, -1, replType);\n                    return result;\n                }\n                else {\n                    return this;\n                }\n            }\n        }\n\n        // Gets the pretty name of the symbol with respect to symbol of the scope (scopeSymbol)\n        // searchTillRoot specifies if the name need to searched in the root path of the scope\n        public getPrettyName(scopeSymbol: Symbol) {\n            if (!!scopeSymbol && isQuoted(this.prettyName) && this.type.isModuleType()) {\n                // Its a dynamic module - and need to be specialized with the scope\n                // Check in exported module members in each scope\n                var symbolPath = scopeSymbol.pathToRoot();\n                var prettyName = this.getPrettyNameOfDynamicModule(symbolPath);\n                if (prettyName != null) {\n                    return prettyName.name;\n                }\n            }\n\n            retur',
v27538=v27539+'n this.prettyName;\n        }\n\n        public getPrettyNameOfDynamicModule(scopeSymbolPath: Symbol[]) {\n            var scopeSymbolPathLength = scopeSymbolPath.length;\n            var externalSymbol: { name: string; symbol: Symbol; } = null;\n            if (scopeSymbolPath.length > 0 &&\n                scopeSymbolPath[scopeSymbolPathLength - 1].getType().isModuleType() &&\n                (<TypeSymbol>scopeSymbolPath[scopeSymbolPathLength - 1]).isDynamic) {\n\n                // Check if submodule is dynamic\n                if (scopeSymbolPathLength > 1 &&\n                    scopeSymbolPath[scopeSymbolPathLength - 2].getType().isModuleType() &&\n                    (<TypeSymbol>scopeSymbolPath[scopeSymbolPathLength - 2]).isDynamic) {\n                    var moduleType = <ModuleType>scopeSymbolPath[scopeSymbolPathLength - 2].getType();\n                    externalSymbol = moduleType.findDynamicModuleName(this.type);\n\n                }\n\n                if (externalSymbol == null) {\n                    // Check in this module\n                    var moduleType = <ModuleType>scopeSymbolPath[scopeSymbolPathLength - 1].getType();\n                    externalSymbol = moduleType.findDynamicModuleName(this.type);\n                }\n            }\n\n            return externalSymbol;\n        }\n\n        public getDocComments(): Comment[]{\n            var comments : Comment[] = [];\n            if (this.declAST != null) {\n                comments = comments.concat(this.declAST.getDocComments());\n            }\n\n            for (var i = 0; i < this.expansionsDeclAST.length; i++) {\n                comments = comments.concat(this.expansionsDeclAST[i].getDocComments());\n            }\n\n            return comments;\n        }\n    }\n\n    export class WithSymbol extends TypeSymbol {\n        constructor (location: number, unitIndex: number, withType: Type) {\n            super("with", location, 4, unitIndex, withType);\n        }\n        public isWith() { return true; }\n    }\n\n    export class FieldSymbol extends InferenceSymbol {\n        public name: string;\n        public location: number;\n\n        constructor (name: string, location: number, unitIndex: number, public canWrite: bool,\n                      public field: ValueLocation) {\n\n            super(name, location, name.length, unitIndex);\n            this.name = name;\n            this.location = location;\n        }\n        public kind() { return SymbolKind.Field; }\n        public writeable() { return this.isAccessor() ? this.setter != null : this.canWrite; }\n        public getType() { return this.field.typeLink.type; }\n        public getTypeNameEx(scope: SymbolScope) {\n            return MemberName.create(this.field.typeLink.type.getScopedTypeNameEx(scope), this.name + this.getOptionalNameString() + ": ", "");\n        }\n\n        public isMember() { return true; }\n        public setType(type: Type) {\n            this.field.typeLink.type = type;\n        }\n\n        public getter: TypeSymbol = null;\n        public setter: TypeSymbol = null;\n        public hasBeenEmitted = false; // since getters and setters are emitted together, need to track if one has been emitted\n\n        public isAccessor() { return this.getter != null || this.setter != null; }\n\n        public isVariable() { return true; }\n        public toString() { return this.getTypeNameEx(null).toString(); }\n        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Symbol {\n            var rType = this.field.typeLink.type.specializeType(pattern, replacement, checker, false);\n            if (rType != this.field.typeLink.type) {\n                var fieldDef = new ValueLocation();\n                var result = new FieldSymbol(this.name, 0, checker.locationInfo.unitIndex,\n                                           this.canWrite, fieldDef);\n                result.flags = this.flags;\n                fieldDef.symbol = result;\n                fieldDef.typeLink = new TypeLink();\n                result.setType(rType);\n                result.typeCheckStatus = TypeCheckStatus.Finished;\n                return result;\n            }\n            else {\n                return this;\n            }\n        }\n\n        public getDocComments(): Comment[] {\n            if (this.getter != null || this.setter != null) {\n                var comments : Comment[] = [];\n                if (this.getter != null) {\n                    comments = comments.concat(this.getter.getDocComments());\n                }\n                if (this.setter != null) {\n                    comments = comments.concat(this.setter.getDocComments());\n                }\n                return comments;\n            }\n            else if (this.declAST != null) {\n                return this.declAST.getDocComments();\n            }\n\n            return [];\n        }\n\n    }\n\n    export class ParameterSymbol extends InferenceSymbol {\n        public name: string;\n        public location: number;\n        private paramDocComment: string = null;\n        public funcDecl',
v27537=v27538+': AST = null;\n        \n        constructor (name: string, location: number, unitIndex: number,\n                          public parameter: ValueLocation) {\n            super(name, location, name.length, unitIndex);\n\n            this.name = name;\n            this.location = location;\n        }\n        public kind() { return SymbolKind.Parameter; }\n        public writeable() { return true; }\n        public getType() { return this.parameter.typeLink.type; }\n        public setType(type: Type) {\n            this.parameter.typeLink.type = type;\n        }\n        public isVariable() { return true; }\n        public argsOffset = (-1);\n        public isOptional() {\n            if (this.parameter && this.parameter.symbol && this.parameter.symbol.declAST) {\n                return (<ArgDecl>this.parameter.symbol.declAST).isOptional;\n            }\n            else {\n                return false;\n            }\n        }\n\n        public getTypeNameEx(scope: SymbolScope) {\n            return MemberName.create(this.getType().getScopedTypeNameEx(scope), this.name + (this.isOptional() ? "?" : "") + ": ", "");\n        }\n\n        public toString() { return this.getTypeNameEx(null).toString(); }\n\n        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Symbol {\n            var rType = this.parameter.typeLink.type.specializeType(pattern, replacement, checker, false);\n            if (this.parameter.typeLink.type != rType) {\n                var paramDef = new ValueLocation();\n                var result = new ParameterSymbol(this.name, 0, checker.locationInfo.unitIndex,\n                                               paramDef);\n                paramDef.symbol = result;\n                result.setType(rType);\n                return result;\n            }\n            else {\n                return this;\n            }\n        }\n\n        public getParameterDocComments() {\n            if (!this.paramDocComment) {\n                var parameterComments: string[] = [];\n                if (this.funcDecl) {\n                    var fncDocComments = this.funcDecl.getDocComments();\n                    var paramComment = Comment.getParameterDocCommentText(this.name, fncDocComments);\n                    if (paramComment != "") {\n                        parameterComments.push(paramComment);\n                    }\n                }\n                var docComments = TypeScript.Comment.getDocCommentText(this.getDocComments());\n                if (docComments != "") {\n                    parameterComments.push(docComments);\n                }\n                \n                this.paramDocComment = parameterComments.join("\\n");\n            }\n\n            return this.paramDocComment;\n        }\n    }\n\n    export class VariableSymbol extends InferenceSymbol {\n\n        constructor (name: string, location: number, unitIndex: number, public variable: ValueLocation) {\n            super(name, location, name.length, unitIndex);\n        }\n        public kind() { return SymbolKind.Variable; }\n        public writeable() { return true; }\n        public getType() { return this.variable.typeLink.type; }\n        public getTypeNameEx(scope: SymbolScope) {\n            return MemberName.create(this.getType().getScopedTypeNameEx(scope), this.name + ": ", "");\n        }\n\n        public setType(type: Type) {\n            this.variable.typeLink.type = type;\n        }\n        public isVariable() { return true; }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export enum TokenID {\n        // Keywords\n        Any,\n        Bool,\n        Break,\n        Case,\n        Catch,\n        Class,\n        Const,\n        Continue,\n        Debugger,\n        Default,\n        Delete,\n        Do,\n        Else,\n        Enum,\n        Export,\n        Extends,\n        Declare,\n        False,\n        Finally,\n        For,\n        Function,\n        Constructor,\n        Get,\n        If,\n        Implements,\n        Import,\n        In,\n        InstanceOf,\n        Interface,\n        Let,\n        Module,\n        New,\n        Number,\n        Null,\n        Package,\n        Private,\n        Protected,\n        Public,\n        Return,\n        Set,\n        Static,\n        String,\n        Super,\n        Switch,\n        This,\n        Throw,\n        True,\n        Try,\n        TypeOf,\n        Var,\n        Void,\n        With,\n        While,\n        Yield,\n      ',
v27536=v27537+'  // Punctuation\n        Semicolon,\n        OpenParen,\n        CloseParen,\n        OpenBracket,\n        CloseBracket,\n        OpenBrace,\n        CloseBrace,\n        Comma,\n        Equals,\n        PlusEquals,\n        MinusEquals,\n        AsteriskEquals,\n        SlashEquals,\n        PercentEquals,\n        AmpersandEquals,\n        CaretEquals,\n        BarEquals,\n        LessThanLessThanEquals,\n        GreaterThanGreaterThanEquals,\n        GreaterThanGreaterThanGreaterThanEquals,\n        Question,\n        Colon,\n        BarBar,\n        AmpersandAmpersand,\n        Bar,\n        Caret,\n        And,\n        EqualsEquals,\n        ExclamationEquals,\n        EqualsEqualsEquals,\n        ExclamationEqualsEquals,\n        LessThan,\n        LessThanEquals,\n        GreaterThan,\n        GreaterThanEquals,\n        LessThanLessThan,\n        GreaterThanGreaterThan,\n        GreaterThanGreaterThanGreaterThan,\n        Plus,\n        Minus,\n        Asterisk,\n        Slash,\n        Percent,\n        Tilde,\n        Exclamation,\n        PlusPlus,\n        MinusMinus,\n        Dot,\n        DotDotDot,\n        Error,\n        EndOfFile,\n        EqualsGreaterThan,\n        Identifier,\n        StringLiteral,\n        RegularExpressionLiteral,\n        NumberLiteral,\n        Whitespace,\n        Comment,\n        Lim,\n        LimFixed = EqualsGreaterThan,\n        LimKeyword = Yield,\n    }\n\n    export var tokenTable = new TokenInfo[];\n    export var nodeTypeTable = new string[];\n    export var nodeTypeToTokTable = new number[];\n    export var noRegexTable = new bool[];\n\n    noRegexTable[TokenID.Identifier] = true;\n    noRegexTable[TokenID.StringLiteral] = true;\n    noRegexTable[TokenID.NumberLiteral] = true;\n    noRegexTable[TokenID.RegularExpressionLiteral] = true;\n    noRegexTable[TokenID.This] = true;\n    noRegexTable[TokenID.PlusPlus] = true;\n    noRegexTable[TokenID.MinusMinus] = true;\n    noRegexTable[TokenID.CloseParen] = true;\n    noRegexTable[TokenID.CloseBracket] = true;\n    noRegexTable[TokenID.CloseBrace] = true;\n    noRegexTable[TokenID.True] = true;\n    noRegexTable[TokenID.False] = true;\n\n    export enum OperatorPrecedence {\n        None,\n        Comma,\n        Assignment,\n        Conditional,\n        LogicalOr,\n        LogicalAnd,\n        BitwiseOr,\n        BitwiseExclusiveOr,\n        BitwiseAnd,\n        Equality,\n        Relational,\n        Shift,\n        Additive,\n        Multiplicative,\n        Unary,\n        Lim\n    }\n\n    export enum Reservation {\n        None = 0,\n        Javascript = 1,\n        JavascriptFuture = 2,\n        TypeScript = 4,\n        JavascriptFutureStrict = 8,\n        TypeScriptAndJS = Javascript | TypeScript,\n        TypeScriptAndJSFuture = JavascriptFuture | TypeScript,\n        TypeScriptAndJSFutureStrict = JavascriptFutureStrict | TypeScript,\n    }\n\n    export class TokenInfo {\n        constructor (public tokenId: TokenID, public reservation: Reservation,\n                    public binopPrecedence: number, public binopNodeType: number,\n                    public unopPrecedence: number, public unopNodeType: number,\n                    public text: string, public ers: ErrorRecoverySet) { }\n    }\n\n    function setTokenInfo(tokenId: TokenID, reservation: number, binopPrecedence: number,\n        binopNodeType: number, unopPrecedence: number, unopNodeType: number,\n        text: string, ers: ErrorRecoverySet) {\n        if (tokenId !== undefined) {\n            tokenTable[tokenId] = new TokenInfo(tokenId, reservation, binopPrecedence,\n                                              binopNodeType, unopPrecedence, unopNodeType, text, ers);\n            if (binopNodeType != NodeType.None) {\n                nodeTypeTable[binopNodeType] = text;\n                nodeTypeToTokTable[binopNodeType] = tokenId;\n            }\n            if (unopNodeType != NodeType.None) {\n                nodeTypeTable[unopNodeType] = text;\n            }\n        }\n    }\n\n    setTokenInfo(TokenID.Any, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "any", ErrorRecoverySet.PrimType);\n    setTokenInfo(TokenID.Bool, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "bool", ErrorRecoverySet.PrimType);\n    setTokenInfo(TokenID.Break, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "break", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.Case, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "case", ErrorRecoverySet.SCase);\n    setTokenInfo(TokenID.Catch, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "catch", ErrorRecoverySet.Catch);\n    setTokenInfo(TokenID.Class, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "class", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.Const, Reservation.TypeScri',
v27535=v27536+'ptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "const", ErrorRecoverySet.Var);\n    setTokenInfo(TokenID.Continue, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "continue", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.Debugger, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.Debugger, "debugger", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.Default, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "default", ErrorRecoverySet.SCase);\n    setTokenInfo(TokenID.Delete, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.Delete, "delete", ErrorRecoverySet.Prefix);\n    setTokenInfo(TokenID.Do, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "do", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.Else, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "else", ErrorRecoverySet.Else);\n    setTokenInfo(TokenID.Enum, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "enum", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.Export, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "export", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.Extends, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "extends", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.Declare, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "declare", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.False, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "false", ErrorRecoverySet.RLit);\n    setTokenInfo(TokenID.Finally, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "finally", ErrorRecoverySet.Catch);\n    setTokenInfo(TokenID.For, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "for", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.Function, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "function", ErrorRecoverySet.Func);\n    setTokenInfo(TokenID.Constructor, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "constructor", ErrorRecoverySet.Func);\n    setTokenInfo(TokenID.Get, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "get", ErrorRecoverySet.Func);\n    setTokenInfo(TokenID.Set, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "set", ErrorRecoverySet.Func);\n    setTokenInfo(TokenID.If, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "if", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.Implements, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "implements", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.Import, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "import", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.In, Reservation.TypeScriptAndJS, OperatorPrecedence.Relational, NodeType.In, OperatorPrecedence.None, NodeType.None, "in", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.InstanceOf, Reservation.TypeScriptAndJS, OperatorPrecedence.Relational, NodeType.InstOf, OperatorPrecedence.None, NodeType.None, "instanceof", ErrorRecoverySet.BinOp);\n    setTokenInfo(TokenID.Interface, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "interface", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.Let, Reservation.JavascriptFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "let", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.Module, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "module", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.New, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "new", ErrorRecoverySet.PreOp);\n    setTokenInfo(TokenID.Number, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "number", ErrorRecoverySet.PrimType);\n    setTokenInfo(TokenID.Nu',
v27534=v27535+'ll, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "null", ErrorRecoverySet.RLit);\n    setTokenInfo(TokenID.Package, Reservation.JavascriptFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "package", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.Private, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "private", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.Protected, Reservation.JavascriptFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "protected", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.Public, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "public", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.Return, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "return", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.Static, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "static", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.String, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "string", ErrorRecoverySet.PrimType);\n    setTokenInfo(TokenID.Super, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "super", ErrorRecoverySet.RLit);\n    setTokenInfo(TokenID.Switch, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "switch", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.This, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "this", ErrorRecoverySet.RLit);\n    setTokenInfo(TokenID.Throw, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "throw", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.True, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "true", ErrorRecoverySet.RLit);\n    setTokenInfo(TokenID.Try, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "try", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.TypeOf, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.Typeof, "typeof", ErrorRecoverySet.Prefix);\n    setTokenInfo(TokenID.Var, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "var", ErrorRecoverySet.Var);\n    setTokenInfo(TokenID.Void, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.Void, "void", ErrorRecoverySet.Prefix);\n    setTokenInfo(TokenID.With, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.With, "with", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.While, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "while", ErrorRecoverySet.While);\n    setTokenInfo(TokenID.Yield, Reservation.JavascriptFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "yield", ErrorRecoverySet.None);\n\n    setTokenInfo(TokenID.Identifier, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "identifier", ErrorRecoverySet.ID);\n    setTokenInfo(TokenID.NumberLiteral, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "numberLiteral", ErrorRecoverySet.Literal);\n    setTokenInfo(TokenID.RegularExpressionLiteral, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "regex", ErrorRecoverySet.RegExp);\n    setTokenInfo(TokenID.StringLiteral, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "qstring", ErrorRecoverySet.Literal);\n\n    // Non-operator non-identifier tokens\n    setTokenInfo(TokenID.Semicolon, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, ";", ErrorRecoverySet.SColon); // ;\n    setTokenInfo(TokenID.CloseParen, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, ")", ErrorRecoverySet.RParen); // )\n    setTokenInfo(TokenID.CloseBracket, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "]", ErrorRecoverySet.RBrack); // ]\n    setTokenInfo(TokenID.OpenBrace, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "{", ErrorRecoverySet.LCurly); // {\n    setToken',
v27533=v27534+'Info(TokenID.CloseBrace, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "}", ErrorRecoverySet.RCurly); // }\n    setTokenInfo(TokenID.DotDotDot, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "...", ErrorRecoverySet.None); // ...\n\n    // Operator non-identifier tokens\n    setTokenInfo(TokenID.Comma, Reservation.None, OperatorPrecedence.Comma, NodeType.Comma, OperatorPrecedence.None, NodeType.None, ",", ErrorRecoverySet.Comma); // ,\n    setTokenInfo(TokenID.Equals, Reservation.None, OperatorPrecedence.Assignment, NodeType.Asg, OperatorPrecedence.None, NodeType.None, "=", ErrorRecoverySet.Asg); // =\n    setTokenInfo(TokenID.PlusEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgAdd, OperatorPrecedence.None, NodeType.None, "+=", ErrorRecoverySet.BinOp); // +=\n    setTokenInfo(TokenID.MinusEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgSub, OperatorPrecedence.None, NodeType.None, "-=", ErrorRecoverySet.BinOp); // -=\n    setTokenInfo(TokenID.AsteriskEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgMul, OperatorPrecedence.None, NodeType.None, "*=", ErrorRecoverySet.BinOp); // *=\n\n    setTokenInfo(TokenID.SlashEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgDiv, OperatorPrecedence.None, NodeType.None, "/=", ErrorRecoverySet.BinOp); // /=\n    setTokenInfo(TokenID.PercentEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgMod, OperatorPrecedence.None, NodeType.None, "%=", ErrorRecoverySet.BinOp); // %=\n    setTokenInfo(TokenID.AmpersandEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgAnd, OperatorPrecedence.None, NodeType.None, "&=", ErrorRecoverySet.BinOp); // &=\n    setTokenInfo(TokenID.CaretEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgXor, OperatorPrecedence.None, NodeType.None, "^=", ErrorRecoverySet.BinOp); // ^=\n    setTokenInfo(TokenID.BarEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgOr, OperatorPrecedence.None, NodeType.None, "|=", ErrorRecoverySet.BinOp); // |=\n    setTokenInfo(TokenID.LessThanLessThanEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgLsh, OperatorPrecedence.None, NodeType.None, "<<=", ErrorRecoverySet.BinOp); // <<=\n    setTokenInfo(TokenID.GreaterThanGreaterThanEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgRsh, OperatorPrecedence.None, NodeType.None, ">>=", ErrorRecoverySet.BinOp); // >>=\n    setTokenInfo(TokenID.GreaterThanGreaterThanGreaterThanEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgRs2, OperatorPrecedence.None, NodeType.None, ">>>=", ErrorRecoverySet.BinOp); // >>>=\n    setTokenInfo(TokenID.Question, Reservation.None, OperatorPrecedence.Conditional, NodeType.ConditionalExpression, OperatorPrecedence.None, NodeType.None, "?", ErrorRecoverySet.BinOp); // ?\n    setTokenInfo(TokenID.Colon, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, ":", ErrorRecoverySet.Colon); // :\n    setTokenInfo(TokenID.BarBar, Reservation.None, OperatorPrecedence.LogicalOr, NodeType.LogOr, OperatorPrecedence.None, NodeType.None, "||", ErrorRecoverySet.BinOp); // ||\n    setTokenInfo(TokenID.AmpersandAmpersand, Reservation.None, OperatorPrecedence.LogicalAnd, NodeType.LogAnd, OperatorPrecedence.None, NodeType.None, "&&", ErrorRecoverySet.BinOp); // &&\n    setTokenInfo(TokenID.Bar, Reservation.None, OperatorPrecedence.BitwiseOr, NodeType.Or, OperatorPrecedence.None, NodeType.None, "|", ErrorRecoverySet.BinOp); // |\n    setTokenInfo(TokenID.Caret, Reservation.None, OperatorPrecedence.BitwiseExclusiveOr, NodeType.Xor, OperatorPrecedence.None, NodeType.None, "^", ErrorRecoverySet.BinOp); // ^\n    setTokenInfo(TokenID.And, Reservation.None, OperatorPrecedence.BitwiseAnd, NodeType.And, OperatorPrecedence.None, NodeType.None, "&", ErrorRecoverySet.BinOp); // &\n    setTokenInfo(TokenID.EqualsEquals, Reservation.None, OperatorPrecedence.Equality, NodeType.Eq, OperatorPrecedence.None, NodeType.None, "==", ErrorRecoverySet.BinOp); // ==\n    setTokenInfo(TokenID.ExclamationEquals, Reservation.None, OperatorPrecedence.Equality, NodeType.Ne, OperatorPrecedence.None, NodeType.None, "!=", ErrorRecoverySet.BinOp); // !=\n    setTokenInfo(TokenID.EqualsEqualsEquals, Reservation.None, OperatorPrecedence.Equality, NodeType.Eqv, OperatorPrecedence.None, NodeType.None, "===", ErrorRecoverySet.BinOp); // ===\n    setTokenInfo(TokenID.ExclamationEqualsEquals, Reservation.None, OperatorPrecedence.Equality, NodeType.NEqv, OperatorPrecedence.None, NodeType.None, "!==", ErrorRecoverySet.BinOp); // !==\n    setTokenInfo(TokenID.LessThan, Reservation.None, OperatorPrecedence.Relational, NodeType.Lt, OperatorPrecedence.None, NodeType.None, "<", ErrorRecoverySet.BinOp); // <\n    setTokenInfo(TokenID.LessThanEquals, Reservation.None, OperatorPrecedence.Relational, NodeTyp',
v27532=v27533+'e.Le, OperatorPrecedence.None, NodeType.None, "<=", ErrorRecoverySet.BinOp); // <=\n    setTokenInfo(TokenID.GreaterThan, Reservation.None, OperatorPrecedence.Relational, NodeType.Gt, OperatorPrecedence.None, NodeType.None, ">", ErrorRecoverySet.BinOp); // >\n    setTokenInfo(TokenID.GreaterThanEquals, Reservation.None, OperatorPrecedence.Relational, NodeType.Ge, OperatorPrecedence.None, NodeType.None, ">=", ErrorRecoverySet.BinOp); // >=\n    setTokenInfo(TokenID.LessThanLessThan, Reservation.None, OperatorPrecedence.Shift, NodeType.Lsh, OperatorPrecedence.None, NodeType.None, "<<", ErrorRecoverySet.BinOp); // <<\n    setTokenInfo(TokenID.GreaterThanGreaterThan, Reservation.None, OperatorPrecedence.Shift, NodeType.Rsh, OperatorPrecedence.None, NodeType.None, ">>", ErrorRecoverySet.BinOp); // >>\n    setTokenInfo(TokenID.GreaterThanGreaterThanGreaterThan, Reservation.None, OperatorPrecedence.Shift, NodeType.Rs2, OperatorPrecedence.None, NodeType.None, ">>>", ErrorRecoverySet.BinOp); // >>>\n    setTokenInfo(TokenID.Plus, Reservation.None, OperatorPrecedence.Additive, NodeType.Add, OperatorPrecedence.Unary, NodeType.Pos, "+", ErrorRecoverySet.AddOp); // +\n    setTokenInfo(TokenID.Minus, Reservation.None, OperatorPrecedence.Additive, NodeType.Sub, OperatorPrecedence.Unary, NodeType.Neg, "-", ErrorRecoverySet.AddOp); // -\n    setTokenInfo(TokenID.Asterisk, Reservation.None, OperatorPrecedence.Multiplicative, NodeType.Mul, OperatorPrecedence.None, NodeType.None, "*", ErrorRecoverySet.BinOp); // *\n    setTokenInfo(TokenID.Slash, Reservation.None, OperatorPrecedence.Multiplicative, NodeType.Div, OperatorPrecedence.None, NodeType.None, "/", ErrorRecoverySet.BinOp); // /\n    setTokenInfo(TokenID.Percent, Reservation.None, OperatorPrecedence.Multiplicative, NodeType.Mod, OperatorPrecedence.None, NodeType.None, "%", ErrorRecoverySet.BinOp); // %\n    setTokenInfo(TokenID.Tilde, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.Not, "~", ErrorRecoverySet.PreOp); // ~\n    setTokenInfo(TokenID.Exclamation, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.LogNot, "!", ErrorRecoverySet.PreOp); // !\n    setTokenInfo(TokenID.PlusPlus, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.IncPre, "++", ErrorRecoverySet.PreOp); // ++\n    setTokenInfo(TokenID.MinusMinus, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.DecPre, "--", ErrorRecoverySet.PreOp); // --\n    setTokenInfo(TokenID.OpenParen, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "(", ErrorRecoverySet.LParen); // (\n    setTokenInfo(TokenID.OpenBracket, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "[", ErrorRecoverySet.LBrack); // [\n    setTokenInfo(TokenID.Dot, Reservation.None, OperatorPrecedence.Unary, NodeType.None, OperatorPrecedence.None, NodeType.None, ".", ErrorRecoverySet.Dot); // .\n    setTokenInfo(TokenID.EndOfFile, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "<EOF>", ErrorRecoverySet.EOF); // EOF\n    setTokenInfo(TokenID.EqualsGreaterThan, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "=>", ErrorRecoverySet.None); // =>\n\n    export function lookupToken(tokenId: TokenID): TokenInfo {\n        return tokenTable[tokenId];\n    }\n\n    export enum TokenClass {\n        Punctuation,\n        Keyword,\n        Operator,\n        Comment,\n        Whitespace,\n        Identifier,\n        NumberLiteral,\n        StringLiteral,\n        RegExpLiteral,\n    }\n\n    export class SavedToken {\n        constructor (public tok: Token, public minChar: number, public limChar: number) { }\n    }\n\n    export class Token {\n        constructor (public tokenId: TokenID) {\n        }\n\n        public toString() {\n            return "token: " + this.tokenId + " " + this.getText() + " (" + (<any>TokenID)._map[this.tokenId] + ")";\n        }\n\n        public print(line: number, outfile) {\n            outfile.WriteLine(this.toString() + ",on line" + line);\n        }\n\n        public getText(): string {\n            return tokenTable[this.tokenId].text;\n        }\n\n        public classification(): TokenClass {\n            if (this.tokenId <= TokenID.LimKeyword) {\n                return TokenClass.Keyword;\n            }\n            else {\n                var tokenInfo = lookupToken(this.tokenId);\n                if (tokenInfo != undefined) {\n                    if ((tokenInfo.unopNodeType != NodeType.None) ||\n                        (tokenInfo.binopNodeType != NodeType.None)) {\n                        return TokenClass.Operator;\n                    }\n                }\n            }\n\n            return TokenClass.Punctuation;\n        }\n    }\n\n    export class NumberLiteralToken extends Token {\n        constructor (public value: number,',
v27531=v27532+' public hasEmptyFraction?: bool) {\n            super(TokenID.NumberLiteral);\n        }\n\n        public getText(): string {\n            return this.hasEmptyFraction ? this.value.toString() + ".0" : this.value.toString();\n        }\n\n        public classification(): TokenClass {\n            return TokenClass.NumberLiteral;\n        }\n    }\n\n    export class StringLiteralToken extends Token {\n        constructor (public value: string) {\n            super(TokenID.StringLiteral);\n        }\n\n        public getText(): string {\n            return this.value;\n        }\n\n        public classification(): TokenClass {\n            return TokenClass.StringLiteral;\n        }\n    }\n\n    export class IdentifierToken extends Token {\n        constructor (public value: string, public hasEscapeSequence : bool) {\n            super(TokenID.Identifier);\n        }\n        public getText(): string {\n            return this.value;\n        }\n        public classification(): TokenClass {\n            return TokenClass.Identifier;\n        }\n    }\n\n    export class WhitespaceToken extends Token {\n        constructor (tokenId: TokenID, public value: string) {\n            super(tokenId);\n        }\n\n        public getText(): string {\n            return this.value;\n        }\n\n        public classification(): TokenClass {\n            return TokenClass.Whitespace;\n        }\n    }\n\n    export class CommentToken extends Token {\n        constructor (tokenID: TokenID, public value: string, public isBlock: bool, public startPos: number, public line: number, public endsLine: bool) {\n            super(tokenID);\n        }\n\n        public getText(): string {\n            return this.value;\n        }\n\n        public classification(): TokenClass {\n            return TokenClass.Comment;\n        }\n    }\n\n    export class RegularExpressionLiteralToken extends Token {\n        constructor(public regex) {\n            super(TokenID.RegularExpressionLiteral);\n        }\n\n        public getText(): string {\n            return this.regex.toString();\n        }\n\n        public classification(): TokenClass {\n            return TokenClass.RegExpLiteral;\n        }\n    }\n\n    // TODO: new with length TokenID.LimFixed\n    export var staticTokens = new Token[];\n    export function initializeStaticTokens() {\n        for (var i = 0; i <= TokenID.LimFixed; i++) {\n            staticTokens[i] = new Token(i);\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\'/>\n///<reference path=\'io.ts\'/>\n///<reference path=\'optionsParser.ts\'/>\n\nclass CommandLineHost implements TypeScript.IResolverHost {\n\n    public pathMap: any = {};\n    public resolvedPaths: any = {};\n\n    constructor(public compilationSettings: TypeScript.CompilationSettings) { \n    }\n\n    public getPathIdentifier(path: string) { \n        return this.compilationSettings.useCaseSensitiveFileResolution ? path : path.toLocaleUpperCase();\n    }\n\n    public isResolved(path: string) {\n        return this.resolvedPaths[this.getPathIdentifier(this.pathMap[path])] != undefined;\n    }\n\n    public resolveCompilationEnvironment(preEnv: TypeScript.CompilationEnvironment,\n        resolver: TypeScript.ICodeResolver,\n        traceDependencies: bool): TypeScript.CompilationEnvironment {\n        var resolvedEnv = new TypeScript.CompilationEnvironment(preEnv.compilationSettings, preEnv.ioHost);\n\n        var nCode = preEnv.code.length;\n        var path = "";\n\n        var postResolutionError = \n            (errorFile: string, errorMessage: string) => {\n                TypeScript.CompilerDiagnostics.debugPrint("Could not resolve file \'" + errorFile + "\'" + (errorMessage == "" ? "" : ": " + errorMessage));\n            }\n\n        var resolutionDispatcher: TypeScript.IResolutionDispatcher = {\n            postResolutionError: postResolutionError,\n            postResolution: (path: string, code: TypeScript.ISourceText) => {\n                var pathId = this.getPathIdentifier(path);\n                if (!this.resolvedPaths[pathId]) {\n                    resolvedEnv.code.push(<TypeScript.SourceUnit>code);\n                    this.resolvedPaths[pathId] = true;\n                }\n            }\n        };\n\n        for (var i = 0; i < nCode; i++) {\n            path = TypeScript.switchToForwardSlashes(preEnv.ioHost.resolvePath(preEnv.code[i].path));\n            this.pathMap[preEnv.code[i].path] = path;\n            resolver.resolveCode(path, "", false, r',
v27530=v27531+'esolutionDispatcher);\n        }\n\n        return resolvedEnv;\n    }\n}\nclass BatchCompiler {\n    public compilationSettings: TypeScript.CompilationSettings;\n    public compilationEnvironment: TypeScript.CompilationEnvironment;\n    public resolvedEnvironment: TypeScript.CompilationEnvironment = null;\n    public hasResolveErrors: bool = false;\n    public compilerVersion = "0.8.2.0";\n    public printedVersion = false;\n\n    constructor (public ioHost: IIO) { \n        this.compilationSettings = new TypeScript.CompilationSettings();\n        this.compilationEnvironment = new TypeScript.CompilationEnvironment(this.compilationSettings, this.ioHost);\n    }\n\n    public resolve() {\n        var resolver = new TypeScript.CodeResolver(this.compilationEnvironment);\n        var commandLineHost = new CommandLineHost(this.compilationSettings);\n        var ret = commandLineHost.resolveCompilationEnvironment(this.compilationEnvironment, resolver, true);\n\n        // Reset resolve error status\n        this.hasResolveErrors = false;\n\n        for (var i = 0; i < this.compilationEnvironment.code.length; i++) {\n            if (!commandLineHost.isResolved(this.compilationEnvironment.code[i].path)) {\n                this.hasResolveErrors = true;\n                var path = this.compilationEnvironment.code[i].path;\n                if (!TypeScript.isSTRFile(path) && !TypeScript.isDSTRFile(path) && !TypeScript.isTSFile(path) && !TypeScript.isDTSFile(path)) {\n                    this.ioHost.stderr.WriteLine("Unknown extension for file: \\""+path+"\\". Only .ts and .d.ts extensions are allowed.");\n                }\n                else {\n                    this.ioHost.stderr.WriteLine("Error reading file \\"" + path + "\\": File not found");\n                }\n            }\n        }\n\n        return ret;\n    }\n    \n    /// Do the actual compilation reading from input files and\n    /// writing to output file(s).\n    public compile(): bool {\n        var compiler: TypeScript.TypeScriptCompiler;\n\n        compiler = new TypeScript.TypeScriptCompiler(this.ioHost.stderr, new TypeScript.NullLogger(), this.compilationSettings);\n        compiler.setErrorOutput(this.ioHost.stderr);\n        compiler.setErrorCallback(\n            (minChar, charLen, message, unitIndex) => {\n                compiler.errorReporter.hasErrors = true;\n                var fname = this.resolvedEnvironment.code[unitIndex].path;\n                var lineCol = { line: -1, col: -1 };\n                compiler.parser.getSourceLineCol(lineCol, minChar);\n                // line is 1-base, col, however, is 0-base. add 1 to the col before printing the message\n                var msg = fname + " (" + lineCol.line + "," + (lineCol.col + 1) + "): " + message;\n                if (this.compilationSettings.errorRecovery) {\n                    this.ioHost.stderr.WriteLine(msg);\n                } else {\n                    throw new SyntaxError(msg);\n                }\n            });\n\n        if (this.compilationSettings.emitComments) {\n            compiler.emitCommentsToOutput();\n        }\n\n        var consumeUnit = (code: TypeScript.SourceUnit, addAsResident: bool) => {\n            try {\n                // if file resolving is disabled, the file\'s content will not yet be loaded\n\n                if (!this.compilationSettings.resolve) {\n                    code.content = this.ioHost.readFile(code.path);\n                    // If declaration files are going to be emitted, \n                    // preprocess the file contents and add in referenced files as well\n                    if (this.compilationSettings.generateDeclarationFiles) {\n                        TypeScript.CompilerDiagnostics.assert(code.referencedFiles == null, "With no resolve option, referenced files need to null");\n                        code.referencedFiles = TypeScript.getReferencedFiles(code);\n                    }\n                }\n\n                if (code.content != null) {\n                    if (this.compilationSettings.parseOnly) {\n                        compiler.parseUnit(code.content, code.path);\n                    }\n                    else {\n                        if (this.compilationSettings.errorRecovery) {\n                            compiler.parser.setErrorRecovery(this.ioHost.stderr);\n                        }\n                        compiler.addUnit(code.content, code.path, addAsResident, code.referencedFiles);\n                    }\n                }\n            }\n            catch (err) {\n                compiler.errorReporter.hasErrors = true;\n                // This includes syntax errors thrown from error callback if not in recovery mode\n                this.ioHost.stderr.WriteLine(err.message);\n            }\n\n        }\n\n        for (var iCode = 0 ; iCode < this.resolvedEnvironment.code.length; iCode++) {\n            if (!this.compilationSettings.parseOnly || (iCode > 0)) {\n                consumeUnit(this.resolvedEnvironment.code[iCode], false);\n            }\n        }\n\n        var emitterIOHost = {\n          ',
v27529=v27530+"  createFile: (fileName: string, useUTF8?: bool) => IOUtils.createFileAndFolderStructure(this.ioHost, fileName, useUTF8),\n            directoryExists: this.ioHost.directoryExists,\n            fileExists: this.ioHost.fileExists,\n            resolvePath: this.ioHost.resolvePath\n        };\n\n        try {\n            if (!this.compilationSettings.parseOnly) {\n                compiler.typeCheck();\n                compiler.emit(emitterIOHost);\n                compiler.emitDeclarations();\n            }\n            else {\n                compiler.emitAST(emitterIOHost);\n            }\n        } catch (err) {\n            compiler.errorReporter.hasErrors = true;\n            // Catch emitter exceptions\n            if (err.message != \"EmitError\") {\n                throw err;\n            }\n        }\n\n        return compiler.errorReporter.hasErrors;\n    }\n\n    // Execute the provided inputs\n    public run() {\n        for (var i = 0; i < this.compilationEnvironment.code.length; i++) {\n            var unit = this.compilationEnvironment.code[i];\n            \n            var outputFileName: string = unit.path;\n            if (TypeScript.isTSFile(outputFileName)) {\n                outputFileName = outputFileName.replace(/\\.ts$/, \".js\");\n            } else if (TypeScript.isSTRFile(outputFileName)) {\n                outputFileName = outputFileName.replace(/\\.str$/, \".js\");\n            }\n            if (this.ioHost.fileExists(outputFileName)) {\n                var unitRes = this.ioHost.readFile(outputFileName)\n                this.ioHost.run(unitRes, outputFileName);\n            }\n        }\n    }\n\n    /// Begin batch compilation\n    public batchCompile() {\n        TypeScript.CompilerDiagnostics.diagnosticWriter = { Alert: (s: string) => { this.ioHost.printLine(s); } }\n\n        var code: TypeScript.SourceUnit;\n\n        var opts = new OptionsParser(this.ioHost);\n\n        opts.option('out', {\n            usage: 'Concatenate and emit output to single file | Redirect output structure to the directory',\n            type: 'file|directory',\n            set: (str) => {\n                this.compilationSettings.outputOption = str;\n            }\n        });\n\n        opts.option('style', {\n            usage: 'Select style checking options (examples --style requireSemi:off or --style \"eqeqeq;bitwise:off\")',\n            experimental: true,\n            set: (str) => {\n                this.compilationSettings.setStyleOptions(str);\n            }\n        });\n\n        opts.flag('sourcemap', {\n            usage: 'Generates corresponding .map file',\n            set: () => {\n                this.compilationSettings.mapSourceFiles = true;\n            }\n        });\n\n        opts.flag('declaration', {\n            usage: 'Generates corresponding .d.ts file',\n            set: () => {\n                this.compilationSettings.generateDeclarationFiles = true;\n            }\n        });\n\n        if (this.ioHost.watchFile) {\n            opts.flag('watch', {\n                usage: 'Watch output files',\n                set: () => {\n                    this.compilationSettings.watch = true;\n                }\n            }, 'w');\n        }\n\n        opts.flag('exec', {\n            usage: 'Execute the script after compilation',\n            set: () => {\n                this.compilationSettings.exec = true;\n            }\n        }, 'e');\n\n        opts.flag('parse', {\n            usage: 'Parse only',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.parseOnly = true;\n            }\n        });\n\n        opts.flag('minw', {\n            usage: 'Minimize whitespace',\n            experimental: true,\n            set: () => { this.compilationSettings.minWhitespace = true; }\n        }, 'mw');\n\n        opts.flag('const', {\n            usage: 'Propagate constants to emitted code',\n            experimental: true,\n            set: () => { this.compilationSettings.propagateConstants = true; }\n        });\n\n        opts.flag('errorrecovery', {\n            usage: 'Enable error recovery',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.errorRecovery = true;\n            }\n        }, 'er');\n\n        opts.flag('comments', {\n            usage: 'Emit comments to output',\n            set: () => {\n                this.compilationSettings.emitComments = true;\n            }\n        }, 'c');\n\n        opts.flag('cflow', {\n            usage: 'Control flow',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.controlFlow = true;\n            }\n        });\n\n        opts.flag('cflowp', {\n            usage: 'Print control flow',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.controlFlow = true;\n                this.compilationSettings.printControlFlow = true;\n            }\n        });\n\n        opts.flag('cflowu', {\n            usage: 'Print Use Def control flow',\n            experimental: true,\n            set: () ",
v27528=v27529+"=> {\n                this.compilationSettings.controlFlow = true;\n                this.compilationSettings.controlFlowUseDef = true;\n            }\n        });\n\n        opts.flag('noerroronwith', {\n            usage: 'Allow with statements',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.errorOnWith = false;\n            }\n        });\n\n        opts.flag('noresolve', {\n            usage: 'Skip resolution and preprocessing',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.resolve = false;\n                this.compilationSettings.preprocess = false;\n            }\n        });\n\n        opts.flag('debug', {\n            usage: 'Print debug output',\n            experimental: true,\n            set: () => {\n                TypeScript.CompilerDiagnostics.debug = true;\n            }\n        });\n\n        opts.flag('canCallDefinitionSignature', {\n            usage: 'Allows you to call the definition signature of an overload group',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.canCallDefinitionSignature = true;\n            }\n        });\n\n        opts.flag('nooptimizemodules', {\n            usage: 'Do not optimize module codegen',\n            experimental: true,\n            set: () => {\n                TypeScript.optimizeModuleCodeGen = false;\n            }\n        });\n\n        opts.flag('nolib', {\n            usage: 'Do not include a default lib.d.ts with global declarations',\n            set: () => {\n                this.compilationSettings.useDefaultLib = false;\n            }\n        });\n\n\n        opts.flag('inferProperties', {\n            usage: 'Infer class properties from top-level assignments to \\'this\\'',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.inferPropertiesFromThisAssignment = true;\n            }\n        });\n\n        opts.option('target', {\n            usage: 'Specify ECMAScript target version: \"ES3\" (default), or \"ES5\"',\n            type: 'VER',\n            set: (type) => {\n                type = type.toLowerCase();\n\n                if (type === 'es3') {\n                    this.compilationSettings.codeGenTarget = TypeScript.CodeGenTarget.ES3;\n                } else if (type === 'es5') {\n                    this.compilationSettings.codeGenTarget = TypeScript.CodeGenTarget.ES5;\n                }\n                else {\n                    this.ioHost.printLine(\"ECMAScript target version '\" + type + \"' not supported.  Using default 'ES3' code generation\");\n                }\n            }\n        });\n\n        opts.option('module', {\n            usage: 'Specify module code generation: \"commonjs\" (default) or \"amd\"',\n            type: 'kind',\n            set: (type) => {\n                type = type.toLowerCase();\n\n                if (type === 'commonjs' || type === 'node') {\n                    TypeScript.moduleGenTarget = TypeScript.ModuleGenTarget.Synchronous;\n                } else if (type === 'amd') {\n                    TypeScript.moduleGenTarget = TypeScript.ModuleGenTarget.Asynchronous;\n                } else {\n                    this.ioHost.printLine(\"Module code generation '\" + type + \"' not supported.  Using default 'commonjs' code generation\");\n                }\n            }\n        });\n\n        var printedUsage = false;\n\n        opts.flag('help', {\n            usage: 'Print this message',\n            set: () => {\n                this.printVersion();\n                opts.printUsage();\n                printedUsage = true;\n            }\n        }, 'h');\n\n        opts.flag('useCaseSensitiveFileResolution', {\n            usage: 'Force file resolution to be case sensitive',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.useCaseSensitiveFileResolution = true;\n            }\n        });\n\n        opts.flag('version', {\n            usage: 'Print the compiler\\'s version: ' + this.compilerVersion,\n            set: () => {\n                this.printVersion();\n            }\n        }, 'v');\n\n        opts.parse(this.ioHost.arguments);\n        \n        if (this.compilationSettings.useDefaultLib) {\n            var compilerFilePath = this.ioHost.getExecutingFilePath()\n            var binDirPath = this.ioHost.dirName(compilerFilePath);\n            var libStrPath = this.ioHost.resolvePath(binDirPath + \"/lib.d.ts\");\n            code = new TypeScript.SourceUnit(libStrPath, null);\n            this.compilationEnvironment.code.push(code);\n        }\n\n        for (var i = 0; i < opts.unnamed.length; i++) {\n            code = new TypeScript.SourceUnit(opts.unnamed[i], null);\n            this.compilationEnvironment.code.push(code);\n        }\n\n        // If no source files provided to compiler - print usage information\n        if (this.compilationEnvironment.code.length == (this.compilationSettings.useDefaultLib ? 1 : 0)) {\n            if (!printedUsage && !this.printedVersion",
v27527=v27528+') {\n                this.printVersion();\n                opts.printUsage();\n                this.ioHost.quit(1);\n            }\n            return;\n        }\n\n        var sourceFiles: TypeScript.SourceUnit[] = [];\n        if (this.compilationSettings.watch) {\n            // Capture the state before calling resolve\n            sourceFiles = this.compilationEnvironment.code.slice(0);\n        }\n\n        // Resolve file dependencies, if requested\n        this.resolvedEnvironment = this.compilationSettings.resolve ? this.resolve() : this.compilationEnvironment;\n\n        var hasCompileErrors = this.compile();\n\n        var hasErrors = hasCompileErrors || this.hasResolveErrors;\n        if (!hasErrors) {\n            if (this.compilationSettings.exec) {\n                this.run();\n            }\n        }\n\n        if (this.compilationSettings.watch) {\n            // Watch will cause the program to stick around as long as the files exist\n            this.watchFiles(sourceFiles);\n        }\n        else {  \n            // Exit with the appropriate error code\n            this.ioHost.quit(hasErrors ? 1 : 0);\n        }\n    }\n\n    public printVersion() {\n        if (!this.printedVersion) {\n            this.ioHost.printLine("Version " + this.compilerVersion);\n            this.printedVersion = true;\n        }\n    }\n\n    public watchFiles(soruceFiles: TypeScript.SourceUnit[]) {\n        if (!this.ioHost.watchFile) {\n            this.ioHost.printLine("Error: Current host does not support -w[atch] option");\n            return;\n        }\n\n        var resolvedFiles: string[] = []\n        var watchers: { [x: string]: IFileWatcher; } = {};\n\n        var addWatcher = (filename: string) => {\n            if (!watchers[filename]) {\n                var watcher = this.ioHost.watchFile(filename, onWatchedFileChange);\n                watchers[filename] = watcher;\n            }\n            else {\n                throw new Error("Cannot watch file, it is already watched.");\n            }\n        };\n\n        var removeWatcher = (filename: string) => {\n            if (watchers[filename]) {\n                watchers[filename].close();\n                delete watchers[filename];\n            }\n            else {\n                throw new Error("Cannot stop watching file, it is not being watched.");\n            }\n        };\n\n        var onWatchedFileChange = () => {\n            // Reset the state\n            this.compilationEnvironment.code = soruceFiles;\n\n            // Resolve file dependencies, if requested\n            this.resolvedEnvironment = this.compilationSettings.resolve ? this.resolve() : this.compilationEnvironment;\n\n            // Check if any new files were added to the environment as a result of the file change\n            var oldFiles = resolvedFiles;\n            var newFiles: string[] = [];\n            this.resolvedEnvironment.code.forEach((sf) => newFiles.push(sf.path));\n            newFiles = newFiles.sort();\n\n            var i = 0, j = 0;\n            while (i < oldFiles.length && j < newFiles.length) {\n\n                var compareResult = oldFiles[i].localeCompare(newFiles[j]);\n                if (compareResult == 0) {\n                    // No change here\n                    i++;\n                    j++;\n                }\n                else if (compareResult < 0) {\n                    // Entry in old list does not exist in the new one, it was removed\n                    removeWatcher(oldFiles[i]);\n                    i++;\n                }\n                else {\n                    // Entry in new list does exist in the new one, it was added\n                    addWatcher(newFiles[j]);\n                    j++;\n                }\n            }\n\n            // All remaining unmatched items in the old list have been removed\n            for (var k = i; k < oldFiles.length; k++) {\n                removeWatcher(oldFiles[k]);\n            }\n\n            // All remaing unmatched items in the new list have been added\n            for (var k = j; k < newFiles.length; k++) {\n                addWatcher(newFiles[k]);\n            }\n\n            // Update the state\n            resolvedFiles = newFiles;;\n\n            // Print header\n            this.ioHost.printLine("");\n            this.ioHost.printLine("Recompiling (" + new Date() + "): ");\n            resolvedFiles.forEach((f) => this.ioHost.printLine("    " + f));\n\n            // Trigger a new compilation\n            var hasCompileErrors = this.compile();\n\n            var hasErrors = hasCompileErrors || this.hasResolveErrors;\n            if (!hasErrors) {\n                if (this.compilationSettings.exec) {\n                    this.run();\n                }\n            }\n        };\n\n        // Switch to using stdout for all error messages\n        this.ioHost.stderr = this.ioHost.stdout;\n\n        // Initialize the initial list of resolved files, and add watches to them\n        this.resolvedEnvironment.code.forEach((sf) => {\n            resolvedFiles.push(sf.path);\n            addWatcher(sf.path);\n ',
v27526=v27527+'       });\n        resolvedFiles.sort();\n    }\n}\n\n// Start the batch compilation using the current hosts IO\nvar batch = new BatchCompiler(IO);\nbatch.batchCompile();\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class ArrayCache {\n        public arrayType: Type;\n        public arrayBase: Type = null;\n\n        public specialize(arrInstType: Type, checker: TypeChecker): Type {\n            if (this.arrayBase == null) {\n                this.arrayBase = arrInstType.specializeType(checker.wildElm.type, this.arrayType.elementType,\n                                                   checker, true);\n            }\n            return this.arrayBase;\n        }\n    }\n\n    export class TypeComparisonInfo {\n        public onlyCaptureFirstError = false;\n        public flags: TypeRelationshipFlags = TypeRelationshipFlags.SuccessfulComparison;\n        public message = "";\n\n        public addMessageToFront(message) {\n            if (!this.onlyCaptureFirstError) {\n                this.message = this.message ? message + ":\\n\\t" + this.message : message;\n            }\n            else {\n                this.setMessage(message);\n            }\n        }\n\n        public setMessage(message) {\n            this.message = message;\n        }\n    }\n\n    export interface SignatureData {\n        parameters: ParameterSymbol[];\n        nonOptionalParameterCount: number;\n    }\n\n    export interface ApplicableSignature {\n        signature: Signature;\n        hadProvisionalErrors: bool;\n    }\n\n    export enum TypeCheckCollectionMode {\n        Resident,\n        Transient\n    }\n\n    export class PersistentGlobalTypeState {\n        public importedGlobalsTable = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n        public importedGlobalsTypeTable = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n\n        public importedGlobals: SymbolScopeBuilder;\n\n        // transient state\n        public globals: IHashTable = null;\n        public globalTypes: IHashTable = null;\n        public ambientGlobals: IHashTable = null;\n        public ambientGlobalTypes: IHashTable = null;\n\n        // resident state\n        public residentGlobalValues = new StringHashTable();\n        public residentGlobalTypes = new StringHashTable();\n        public residentGlobalAmbientValues = new StringHashTable();\n        public residentGlobalAmbientTypes = new StringHashTable();\n\n        // dual resident/transient state\n\n        // REVIEW: We shouldn\'t need to allocate private hash tables for these, since there\'s no private global scope\n        // REVIEW: In general, we should audit each instance of DualStringHashTable to ensure that both the primary\n        // and secondary tables are necessary.  If it\'s not necessary, we should sub in a constant sentinel value.\n        public dualGlobalValues: DualStringHashTable;\n        public dualGlobalTypes: DualStringHashTable;\n        public dualAmbientGlobalValues: DualStringHashTable;\n        public dualAmbientGlobalTypes: DualStringHashTable;\n\n        public globalScope: SymbolScope;\n\n        public voidType: Type;\n        public booleanType: Type;\n        public doubleType: Type;\n\n        public stringType: Type;\n        public anyType: Type;\n        public nullType: Type;\n        public undefinedType: Type;\n\n        // Use this flag to turn resident checking on and off\n        public residentTypeCheck: bool = true;\n\n        public mod: ModuleType = null;\n        public gloMod: TypeSymbol = null;\n\n        public wildElm: TypeSymbol = null;\n\n        constructor (public errorReporter: ErrorReporter) {\n            this.importedGlobals = new SymbolScopeBuilder(null, this.importedGlobalsTable, null, this.importedGlobalsTypeTable, null, null);\n\n            this.dualGlobalValues = new DualStringHashTable(this.residentGlobalValues, new StringHashTable());\n            this.dualGlobalTypes = new DualStringHashTable(this.residentGlobalTypes, new StringHashTable());\n            this.dualAmbientGlobalValues = new DualStringHashTable(this.residentGlobalAmbientValues, new StringHashTable());\n            this.dualAmbientGlobalTypes = new DualStringHashTable(this.residentGlobalAmbientTypes, new StringHashTable());\n\n            var dualGlobalScopedMembers = new ScopedMembers(new DualStringHashTable(this.dualGlobalValues, new StringHashTable',
v27525=v27526+'()));\n            var dualGlobalScopedAmbientMembers = new ScopedMembers(new DualStringHashTable(this.dualAmbientGlobalValues, new StringHashTable()));\n            var dualGlobalScopedEnclosedTypes = new ScopedMembers(new DualStringHashTable(this.dualGlobalTypes, new StringHashTable()));\n            var dualGlobalScopedAmbientEnclosedTypes = new ScopedMembers(new DualStringHashTable(this.dualAmbientGlobalTypes, new StringHashTable()));\n\n            this.globalScope = new SymbolScopeBuilder(dualGlobalScopedMembers, dualGlobalScopedAmbientMembers, dualGlobalScopedEnclosedTypes, dualGlobalScopedAmbientEnclosedTypes, this.importedGlobals, null);\n\n            this.voidType = this.enterPrimitive(Primitive.Void, "void");\n            this.booleanType = this.enterPrimitive(Primitive.Boolean, "bool");\n            this.doubleType = this.enterPrimitive(Primitive.Double, "number");\n            this.importedGlobals.ambientEnclosedTypes.addPublicMember("number", this.doubleType.symbol);\n\n            this.stringType = this.enterPrimitive(Primitive.String, "string");\n            this.anyType = this.enterPrimitive(Primitive.Any, "any");\n            this.nullType = this.enterPrimitive(Primitive.Null, "null");\n            this.undefinedType = this.enterPrimitive(Primitive.Undefined, "undefined");\n\n            // shared global state is resident\n            this.setCollectionMode(TypeCheckCollectionMode.Resident);\n\n            this.wildElm = new TypeSymbol("_element", -1, 0, -1, new Type());\n            this.importedGlobalsTypeTable.addPublicMember(this.wildElm.name, this.wildElm);\n\n            this.mod = new ModuleType(dualGlobalScopedEnclosedTypes, dualGlobalScopedAmbientEnclosedTypes);\n            this.mod.members = dualGlobalScopedMembers;\n            this.mod.ambientMembers = dualGlobalScopedAmbientMembers;\n            this.mod.containedScope = this.globalScope;\n\n            this.gloMod = new TypeSymbol(globalId, -1, 0, -1, this.mod);\n            this.mod.members.addPublicMember(this.gloMod.name, this.gloMod);\n\n            this.defineGlobalValue("undefined", this.undefinedType);\n        }\n\n\n        public enterPrimitive(flags: number, name: string) {\n            var primitive = new Type();\n            primitive.primitiveTypeClass = flags;\n            var symbol = new TypeSymbol(name, -1, name.length, -1, primitive);\n            symbol.typeCheckStatus = TypeCheckStatus.Finished;\n            primitive.symbol = symbol;\n            this.importedGlobals.enter(null, null, symbol, this.errorReporter, true, true, true);\n            return primitive;\n        }\n\n        public setCollectionMode(mode: TypeCheckCollectionMode) {\n            this.residentTypeCheck =\n                this.dualGlobalValues.insertPrimary =\n                    this.dualGlobalTypes.insertPrimary =\n                        this.dualAmbientGlobalValues.insertPrimary =\n                            this.dualAmbientGlobalTypes.insertPrimary = mode == TypeCheckCollectionMode.Resident;\n        }\n\n        public refreshPersistentState() {\n            this.globals = new StringHashTable();\n            this.globalTypes = new StringHashTable();\n            this.ambientGlobals = new StringHashTable();\n            this.ambientGlobalTypes = new StringHashTable();\n\n            // add global types to the global scope\n            this.globalTypes.add(this.voidType.symbol.name, this.voidType.symbol);\n            this.globalTypes.add(this.booleanType.symbol.name, this.booleanType.symbol);\n            this.globalTypes.add(this.doubleType.symbol.name, this.doubleType.symbol);\n            this.globalTypes.add("number", this.doubleType.symbol);\n            this.globalTypes.add(this.stringType.symbol.name, this.stringType.symbol);\n            this.globalTypes.add(this.anyType.symbol.name, this.anyType.symbol);\n            this.globalTypes.add(this.nullType.symbol.name, this.nullType.symbol);\n            this.globalTypes.add(this.undefinedType.symbol.name, this.undefinedType.symbol);\n\n            this.dualGlobalValues.secondaryTable = this.globals;\n            this.dualGlobalTypes.secondaryTable = this.globalTypes;\n            this.dualAmbientGlobalValues.secondaryTable = this.ambientGlobals;\n            this.dualAmbientGlobalTypes.secondaryTable = this.ambientGlobalTypes;\n        }\n\n        public defineGlobalValue(name: string, type: Type) {\n            var valueLocation = new ValueLocation();\n            valueLocation.typeLink = new TypeLink();\n            var sym = new VariableSymbol(name, 0, -1, valueLocation);\n            sym.setType(type);\n            sym.typeCheckStatus = TypeCheckStatus.Finished;\n            sym.container = this.gloMod;\n            this.importedGlobalsTable.addPublicMember(name, sym);\n        }\n    }\n\n    export class ContextualTypeContext {\n        public targetSig: Signature = null;\n        public targetThis: Type = null;\n        public targetAccessorType: Type = null;\n\n        constructor (public contextualType: Type,\n            public provisional: bool, pu',
v27524=v27525+'blic contextID: number) { }\n    }\n\n    export class ContextualTypingContextStack {\n        private contextStack: ContextualTypeContext[] = [];\n        static contextID = TypeCheckStatus.Finished + 1;\n        public pushContextualType(type: Type, provisional: bool) { this.contextStack.push(new ContextualTypeContext(type, provisional, ContextualTypingContextStack.contextID++)); this.checker.errorReporter.pushToErrorSink = provisional; }\n        public hadProvisionalErrors = false; // somewhere in the chain a provisional typecheck error was thrown\n        public popContextualType() {\n            var tc = this.contextStack.pop();\n            this.checker.errorReporter.pushToErrorSink = this.isProvisional();\n            this.hadProvisionalErrors = this.hadProvisionalErrors || (tc.provisional && (this.checker.errorReporter.getCapturedErrors().length));\n            this.checker.errorReporter.freeCapturedErrors();\n            return tc;\n        }\n        public getContextualType(): ContextualTypeContext { return (!this.contextStack.length ? null : this.contextStack[this.contextStack.length - 1]); }\n        public getContextID() { return (!this.contextStack.length ? TypeCheckStatus.Finished : this.contextStack[this.contextStack.length - 1].contextID); }\n        public isProvisional() { return (!this.contextStack.length ? false : this.contextStack[this.contextStack.length - 1].provisional); }\n\n        constructor (public checker: TypeChecker) { }\n    }\n\n    export class TypeChecker {\n        public errorReporter: ErrorReporter = null;\n        public globalScope: SymbolScope;\n\n        public checkControlFlow = false;\n        public printControlFlowGraph = false;\n        public checkControlFlowUseDef = false;\n        public styleSettings: StyleSettings = null;\n\n        public units: LocationInfo[] = null;\n\n        public voidType: Type;\n        public booleanType: Type;\n        public numberType: Type;\n        public stringType: Type;\n        public anyType: Type;\n        public nullType: Type;\n        public undefinedType: Type;\n\n        public anon = "_anonymous";\n\n        public globals: DualStringHashTable;\n        public globalTypes: DualStringHashTable;\n        public ambientGlobals: DualStringHashTable;\n        public ambientGlobalTypes: DualStringHashTable;\n        public gloModType: ModuleType;\n        public gloMod: TypeSymbol;\n        public wildElm: TypeSymbol;\n\n        public locationInfo: LocationInfo = null;\n        public typeFlow: TypeFlow = null;\n\n        public currentCompareA: Symbol = null;\n        public currentCompareB: Symbol = null;\n\n        public currentModDecl: ModuleDeclaration = null;\n\n        public inBind = false;\n        public inWith = false;\n        public errorsOnWith = true;\n\n        public typingContextStack: ContextualTypingContextStack;\n        public currentContextualTypeContext: ContextualTypeContext = null;\n\n        public resolvingBases = false;\n\n        public canCallDefinitionSignature = false;\n\n        public assignableCache: any[] = <any>{};\n        public subtypeCache: any[] = <any>{};\n        public identicalCache: any[] = <any>{};\n\n        public provisionalStartedTypecheckObjects: PhasedTypecheckObject[] = [];\n\n        public mustCaptureGlobalThis = false;\n\n        constructor (public persistentState: PersistentGlobalTypeState) {\n            this.voidType = this.persistentState.voidType;\n            this.booleanType = this.persistentState.booleanType;\n            this.numberType = this.persistentState.doubleType;\n            this.stringType = this.persistentState.stringType;\n            this.anyType = this.persistentState.anyType;\n            this.nullType = this.persistentState.nullType;\n            this.undefinedType = this.persistentState.undefinedType;\n\n            this.globals = this.persistentState.dualGlobalValues;\n            this.globalTypes = this.persistentState.dualGlobalTypes;\n            this.ambientGlobals = this.persistentState.dualAmbientGlobalValues;\n            this.ambientGlobalTypes = this.persistentState.dualAmbientGlobalTypes;\n            this.gloModType = this.persistentState.mod;\n            this.gloMod = this.persistentState.gloMod;\n            this.wildElm = this.persistentState.wildElm;\n\n            this.globalScope = this.persistentState.globalScope;\n\n            this.typingContextStack = new ContextualTypingContextStack(this);\n        }\n\n        public setStyleOptions(style: StyleSettings) {\n            this.styleSettings = style;\n        }\n\n        // Contextual typing\n        public setContextualType(type: Type, provisional: bool) {\n            this.typingContextStack.pushContextualType(type, provisional);\n            this.currentContextualTypeContext = this.typingContextStack.getContextualType();\n        }\n\n        public unsetContextualType() {\n            var lastTC = this.typingContextStack.popContextualType();\n            this.currentContextualTypeContext = this.typingContextStack.getContextualType();\n            return lastTC;\n   ',
v27523=v27524+'     }\n\n        public hadProvisionalErrors() {\n            return this.typingContextStack.hadProvisionalErrors;\n        }\n        public resetProvisionalErrors() {\n            if (!this.typingContextStack.getContextualType()) {\n                this.typingContextStack.hadProvisionalErrors = false;\n            }\n        }\n\n        public typeCheckWithContextualType(contextType: Type, provisional: bool, condition: bool, ast: AST) {\n            if (condition) {\n                this.setContextualType(contextType, this.typingContextStack.isProvisional() || provisional);\n            }\n            this.typeFlow.typeCheck(ast);\n            if (condition) {\n                this.unsetContextualType();\n            }\n        }\n\n        public resetTargetType() {\n            this.currentContextualTypeContext = this.typingContextStack.getContextualType();\n        }\n\n        // Unset the current contextual type without disturbing the stack, effectively "killing" the contextual typing process\n        public killCurrentContextualType() { this.currentContextualTypeContext = null; this.errorReporter.pushToErrorSink = false; }\n        public hasTargetType() { return this.currentContextualTypeContext && this.currentContextualTypeContext.contextualType; }\n        public getTargetTypeContext() { return this.currentContextualTypeContext; }\n\n        public inProvisionalTypecheckMode() {\n            return this.typingContextStack.isProvisional();\n        }\n\n        public getTypeCheckFinishedStatus() {\n            if (this.inProvisionalTypecheckMode()) {\n                return this.typingContextStack.getContextID();\n            }\n            return TypeCheckStatus.Finished;\n        }\n\n        public typeStatusIsFinished(status: TypeCheckStatus) {\n\n            return status == TypeCheckStatus.Finished ||\n                   (this.inProvisionalTypecheckMode() && status == this.typingContextStack.getContextID());\n        }\n\n        public addStartedPTO(pto: PhasedTypecheckObject) {\n            if (this.inProvisionalTypecheckMode()) {\n                this.provisionalStartedTypecheckObjects[this.provisionalStartedTypecheckObjects.length] = pto;\n            }\n        }\n\n        public cleanStartedPTO() {\n            for (var i = 0; i < this.provisionalStartedTypecheckObjects.length; i++) {\n                if (this.provisionalStartedTypecheckObjects[i].typeCheckStatus >= this.typingContextStack.getContextID()) {\n                    this.provisionalStartedTypecheckObjects[i].typeCheckStatus = TypeCheckStatus.NotStarted;\n                }\n            }\n            this.provisionalStartedTypecheckObjects = [];\n        }\n\n        // type collection      \n        public collectTypes(ast: AST): void {\n            if (ast.nodeType == NodeType.Script) {\n                var script = <Script>ast;\n                this.locationInfo = script.locationInfo;\n            }\n            var globalChain = new ScopeChain(this.gloMod, null, this.globalScope);\n            var context = new TypeCollectionContext(globalChain, this);\n            getAstWalkerFactory().walk(ast, preCollectTypes, postCollectTypes, null, context);\n        }\n\n        public makeArrayType(type: Type): Type {\n            if (type.arrayCache == null) {\n                type.arrayCache = new ArrayCache();\n                type.arrayCache.arrayType = new Type();\n                type.arrayCache.arrayType.elementType = type;\n                type.arrayCache.arrayType.symbol = type.symbol;\n            }\n            return type.arrayCache.arrayType;\n        }\n\n        public getParameterList(funcDecl: FuncDecl, container: Symbol): SignatureData {\n            var args = funcDecl.arguments;\n            var parameterTable = null;\n            var parameterBuilder = null;\n            var len = args.members.length;\n            var nonOptionalParams = 0;\n            var result: ParameterSymbol[] = [];\n\n            if (len > 0) {\n                parameterTable = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                parameterBuilder = new SymbolScopeBuilder(parameterTable, null, null, null, null, container);\n\n                for (var i = 0; i < len; i++) {\n                    var parameter = <ArgDecl>args.members[i];\n                    var paramDef = new ValueLocation();\n                    var parameterSymbol = new ParameterSymbol(parameter.id.text, parameter.minChar,\n                                                            this.locationInfo.unitIndex, paramDef);\n                    parameterSymbol.declAST = parameter;\n                    parameterSymbol.funcDecl = funcDecl;\n                    parameter.id.sym = parameterSymbol;\n                    parameter.sym = parameterSymbol;\n                    paramDef.symbol = parameterSymbol;\n                    paramDef.typeLink = getTypeLink(parameter.typeExpr, this, false);\n                    parameterBuilder.enter(null, parameter, parameterSymbol, this.errorReporter, true, false, false); // REVIEW: Shoul',
v27522=v27523+"d this be entered into the private scope?\n                    result[result.length] = parameterSymbol;\n                    if (!parameter.isOptionalArg()) {\n                        nonOptionalParams++;\n                    }\n                }\n            }\n            return { parameters: result, nonOptionalParameterCount: nonOptionalParams };\n        }\n\n        // Create a signature for a function definition\n        //  (E.g., has a function body - function declarations, property declarations, lambdas)\n        public createFunctionSignature(funcDecl: FuncDecl, container: Symbol, scope: SymbolScope, overloadGroupSym: Symbol, addToScope: bool): Signature {\n\n            var isExported = hasFlag(funcDecl.fncFlags, FncFlags.Exported | FncFlags.ClassPropertyMethodExported) || container == this.gloMod;\n            var isStatic = hasFlag(funcDecl.fncFlags, FncFlags.Static);\n            var isPrivate = hasFlag(funcDecl.fncFlags, FncFlags.Private);\n            var isDefinition = hasFlag(funcDecl.fncFlags, FncFlags.Definition);\n            var isAmbient = hasFlag(funcDecl.fncFlags, FncFlags.Ambient);\n            var isConstructor = funcDecl.isConstructMember() || funcDecl.isConstructor;\n            var isGlobal = container == this.gloMod;\n\n            var signature: Signature = new Signature();\n            var isLambda = funcDecl.fncFlags & FncFlags.IsFunctionExpression;\n\n            // If a return type has been declared for the signature, set the type link.\n            // Otherwise:\n            //  if it's a signature, its type will be 'any'\n            //  if it's a definition, the return type will be inferred  \n            if (funcDecl.returnTypeAnnotation || isDefinition) {\n                signature.returnType = getTypeLink(funcDecl.returnTypeAnnotation, this, false);\n            }\n            else {\n                signature.returnType = new TypeLink();\n                signature.returnType.type = this.anyType;\n            }\n\n            signature.hasVariableArgList = funcDecl.variableArgList;\n\n            var sigData = this.getParameterList(funcDecl, container);\n\n            signature.parameters = sigData.parameters;\n            signature.nonOptionalParameterCount = sigData.nonOptionalParameterCount;\n\n            funcDecl.signature = signature;\n            signature.declAST = funcDecl;\n\n            var useOverloadGroupSym =\n                overloadGroupSym &&\n                overloadGroupSym.getType() &&\n                !overloadGroupSym.isAccessor() &&\n                (funcDecl.isSignature() || (isAmbient == hasFlag(overloadGroupSym.flags, SymbolFlags.Ambient)));\n\n            if (useOverloadGroupSym && isPrivate != hasFlag(overloadGroupSym.flags, SymbolFlags.Private)) {\n                this.errorReporter.simpleError(funcDecl, \"Public/Private visibility of overloads does not agree\");\n            }\n\n            var groupType = useOverloadGroupSym ? overloadGroupSym.getType() : new Type();\n\n            if (isConstructor) {\n                if (groupType.construct == null) {\n                    groupType.construct = new SignatureGroup();\n                }\n                groupType.construct.addSignature(signature);\n                groupType.construct.hasImplementation = !(funcDecl.isSignature());\n                if (groupType.construct.hasImplementation) {\n                    groupType.setHasImplementation();\n                }\n            }\n            else if (funcDecl.isIndexerMember()) {\n                if (groupType.index == null) {\n                    groupType.index = new SignatureGroup();\n                    groupType.index.flags |= SignatureFlags.IsIndexer;\n                }\n\n                groupType.index.addSignature(signature);\n                groupType.index.hasImplementation = !(funcDecl.isSignature());\n                if (groupType.index.hasImplementation) {\n                    groupType.setHasImplementation();\n                }\n            }\n            else {\n                if (groupType.call == null) {\n                    groupType.call = new SignatureGroup();\n                }\n                groupType.call.addSignature(signature);\n\n                groupType.call.hasImplementation = !(funcDecl.isSignature());\n                if (groupType.call.hasImplementation) {\n                    groupType.setHasImplementation();\n                }\n            }\n\n            var instanceType = groupType.instanceType;\n\n            // Ensure that the function's symbol is properly configured\n            // (If there were overloads, we'll already have a symbol, otherwise we need to create one)\n            var funcName: string = null;\n\n            // Set the function's name:\n            //  In the case of anonymous or functions resulting from error\n            //  correction in the parser (isMissing() == true), we do not\n            //  want to set a function name, since they shouldn't be inserted\n            //  into the enclosing scope\n\n            // usedHint prevents functions bound to object literal fields from",
v27521=v27522+" being added to the\n            // enclosing scope\n            var usedHint = false;\n            if (funcDecl.name && !funcDecl.name.isMissing()) {\n                funcName = funcDecl.name.text;\n            }\n            else if (funcDecl.hint) {\n                funcName = funcDecl.hint;\n                usedHint = true;\n            }\n\n            if (groupType.symbol == null) {\n                groupType.symbol =\n                    new TypeSymbol(funcName ? funcName : this.anon,\n                                    funcDecl.minChar, funcDecl.limChar - funcDecl.minChar,\n                                    this.locationInfo.unitIndex,\n                                    groupType);\n                if (!useOverloadGroupSym) {\n                    groupType.symbol.declAST = funcDecl;\n                }\n            }\n\n            // REVIEW: Are we missing any other flags?\n            if (isStatic) {\n                groupType.symbol.flags |= SymbolFlags.Static;\n            }\n\n            if (isAmbient) {\n                groupType.symbol.flags |= SymbolFlags.Ambient;\n            }\n\n            if (isPrivate) {\n                groupType.symbol.flags |= SymbolFlags.Private;\n            }\n\n            groupType.symbol.isMethod = funcDecl.isMethod();\n            if (groupType.symbol.isMethod) {\n                groupType.symbol.flags |= SymbolFlags.Property;\n            }\n\n            funcDecl.type = groupType;\n\n            // Add the function symbol to the appropriate scope\n            // if the funcDecl is a constructor, it will be added to the enclosing scope as a class\n            if (!isConstructor) {\n                // Add the function's symbol to its enclosing scope\n                if (funcName && !isLambda && !funcDecl.isAccessor() && !usedHint) {\n\n                    // REVIEW: We're not setting the isDecl flags for fuctions bound to object literal properties\n                    // so removing the isDefiniton clause would break object literals\n                    if (addToScope) {  // REVIEW: If we combine this with createFunctionDeclarationSignature, we'll need to broaden this for both decls and defs                      \n                        // if it's a static method, enter directly into the container's scope\n                        if (funcDecl.isMethod() && isStatic) {\n\n                            // REVIEW: What about private statics?\n                            if (!(<TypeSymbol>container).type.members.publicMembers.add(funcName, groupType.symbol)) {\n                                this.errorReporter.duplicateIdentifier(funcDecl, funcName);\n                            }\n\n                            groupType.symbol.container = container;\n                        } // REVIEW: Another check for overloads...\n                        else if (overloadGroupSym == null || (overloadGroupSym.declAST && !(<FuncDecl>overloadGroupSym.declAST).isOverload && (container.isType()))) {\n                            scope.enter(container, funcDecl, groupType.symbol, this.errorReporter, !isPrivate && (isExported || isStatic || isGlobal), false, isAmbient);\n                        }\n                    }\n                    else if (!funcDecl.isSpecialFn()) {\n                        groupType.symbol.container = container; // REVIEW: Set container for overloads or anonymous?\n                    }\n                }\n                else if (!funcDecl.isSpecialFn()) {\n                    groupType.symbol.container = container; // REVIEW: Set container for lambdas and accessors?\n                }\n            }\n\n            // If, say, a call signature overload was declared before the class type was, we want to reuse\n            // the type that's already been instantiated for the class type, rather than allocate a new one\n            if (useOverloadGroupSym) {\n                var overloadGroupType = overloadGroupSym ? overloadGroupSym.getType() : null;\n                var classType = groupType;\n\n                if (classType != overloadGroupType) {\n                    if (classType.construct == null) {\n                        if (overloadGroupType && overloadGroupType.construct) {\n                            classType.construct = overloadGroupType.construct;\n                        }\n                        else {\n                            classType.construct = new SignatureGroup();\n                        }\n                    }\n                    else if (overloadGroupType) {\n                        if (overloadGroupType.construct) {\n                            classType.construct.signatures.concat(overloadGroupType.construct.signatures);\n                        }\n                    }\n\n                    // sync call and index signatures as well, but don't allocate should they not\n                    // already exist\n                    if (overloadGroupType) {\n                        if (classType.call == null) {\n                            classType.call = overloadGroupType.call;\n                        }\n                ",
v27520=v27521+'        else if (overloadGroupType.call) {\n                            classType.call.signatures.concat(overloadGroupType.call.signatures);\n                        }\n\n                        // if the function is not static, we need to add any call overloads onto the\n                        // instance type\'s call signature list\n                        if (!isStatic) {\n\n                            if (classType.instanceType == null) {\n                                classType.instanceType = overloadGroupType.instanceType;\n                            }\n\n                            var instanceType = classType.instanceType;\n\n                            if (instanceType) {\n                                if (instanceType.call == null) {\n                                    instanceType.call = overloadGroupType.call;\n                                }\n                                else if (overloadGroupType.call) {\n                                    instanceType.call.signatures.concat(overloadGroupType.call.signatures);\n                                }\n                            }\n                        }\n\n                        if (classType.index == null) {\n                            classType.index = overloadGroupType.index;\n                        }\n                        else if (overloadGroupType.index) {\n                            classType.index.signatures.concat(overloadGroupType.index.signatures);\n                        }\n                    }\n                }\n            }\n\n            return signature;\n        }\n\n        // Creates a new symbol for an accessor property\n        // Note that funcDecl.type.symbol and fgSym may not be the same (E.g., in the case of type collection)\n        public createAccessorSymbol(funcDecl: FuncDecl, fgSym: Symbol, enclosingClass: Type, addToMembers: bool, isClassProperty: bool, scope: SymbolScope, container: Symbol) {\n            var accessorSym: FieldSymbol = null\n            var sig = funcDecl.signature;\n            var nameText = funcDecl.name.text;\n            var isStatic = hasFlag(funcDecl.fncFlags, FncFlags.Static);\n            var isPrivate = hasFlag(funcDecl.fncFlags, FncFlags.Private);\n\n            if (fgSym == null) {\n                var field = new ValueLocation();\n                accessorSym = new FieldSymbol(nameText, funcDecl.minChar, this.locationInfo.unitIndex, false, field);\n                field.symbol = accessorSym;\n                accessorSym.declAST = funcDecl; // REVIEW: need to reset for getters and setters\n\n                if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {\n                    if (accessorSym.getter) {\n                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property getter");\n                    }\n                    accessorSym.getter = <TypeSymbol>sig.declAST.type.symbol;\n                }\n                else {\n                    if (accessorSym.setter) {\n                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property setter");\n                    }\n                    accessorSym.setter = <TypeSymbol>sig.declAST.type.symbol;\n                }\n\n                field.typeLink = getTypeLink(null, this, false);\n\n                // if it\'s static, enter it into the class\'s member list directly\n                if (addToMembers) {\n                    if (enclosingClass) {\n                        if (!enclosingClass.members.publicMembers.add(nameText, accessorSym)) {\n                            this.errorReporter.duplicateIdentifier(funcDecl, accessorSym.name);\n                        }\n                        accessorSym.container = enclosingClass.symbol;\n                    }\n                    else {\n                        this.errorReporter.simpleError(funcDecl, "Accessor property may not be added in this context");\n                    }\n                }\n                else {\n                    scope.enter(container, funcDecl, accessorSym, this.errorReporter, !isPrivate || isStatic, false, false);\n                }\n\n                // We set the flags here, instead of below, because the accessor symbol does not yet have a type\n                if (isClassProperty) {\n                    accessorSym.flags |= SymbolFlags.Property;\n                }\n                if (isStatic) {\n                    accessorSym.flags |= SymbolFlags.Static;\n                }\n\n                if (isPrivate) {\n                    accessorSym.flags |= SymbolFlags.Private;\n                }\n                else {\n                    accessorSym.flags |= SymbolFlags.Public;\n                }\n            }\n            else {\n                accessorSym = <FieldSymbol>(<any>fgSym);\n\n                if (isPrivate != hasFlag(accessorSym.flags, SymbolFlags.Private)) {\n                    this.errorReporter.simpleError(funcDecl, "Getter and setter accessors do not agree in visibility");\n                }\n\n                if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {\n       ',
v27519=v27520+'             if (accessorSym.getter) {\n                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property getter");\n                    }\n                    accessorSym.getter = <TypeSymbol>funcDecl.type.symbol;\n                }\n                else {\n                    if (accessorSym.setter) {\n                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property setter");\n                    }\n                    accessorSym.setter = <TypeSymbol>funcDecl.type.symbol;\n                }\n            }\n\n            return accessorSym;\n        }\n\n        public addBases(resultScope: SymbolAggregateScope, type: Type, baseContext: { base: string; baseId: number; }): void {\n            resultScope.addParentScope(new SymbolTableScope(type.members, type.ambientMembers, type.getAllEnclosedTypes(), type.getAllAmbientEnclosedTypes(), type.symbol));\n            var i = 0;\n            var parent: Type;\n            if (type.extendsList) {\n                for (var len = type.extendsList.length; i < len; i++) {\n                    parent = type.extendsList[i];\n                    if (baseContext.baseId == parent.typeID) {\n                        this.errorReporter.reportErrorFromSym(parent.symbol, "Type \'" + baseContext.base + "\' is recursively referenced as a base class of itself");\n                        parent.symbol.flags |= SymbolFlags.RecursivelyReferenced;\n                        break;\n                    }\n                    this.addBases(resultScope, parent, baseContext);\n                }\n            }\n        }\n\n        public scopeOf(type: Type): SymbolScope {\n            var resultScope = new SymbolAggregateScope(type.symbol);\n            var baseContext = { base: type.symbol && type.symbol.name ? type.symbol.name : "{}", baseId: type.typeID };\n            this.addBases(resultScope, type, baseContext);\n            return resultScope;\n        }\n\n        public lookupMemberTypeSymbol(containingType: Type, name: string): Symbol {\n            var symbol: Symbol = null;\n            if (containingType.containedScope) {\n                symbol = containingType.containedScope.find(name, false, true);\n            }\n            else if (containingType.members) {\n                symbol = containingType.members.allMembers.lookup(name);\n\n                if (symbol == null && containingType.ambientMembers) {\n                    symbol = containingType.ambientMembers.allMembers.lookup(name);\n                }\n            }\n            if (symbol == null) {\n                var typeMembers = containingType.getAllEnclosedTypes();\n                var ambientTypeMembers = containingType.getAllAmbientEnclosedTypes();\n                if (typeMembers) {\n                    symbol = typeMembers.allMembers.lookup(name);\n\n                    if (symbol == null && ambientTypeMembers) {\n                        symbol = ambientTypeMembers.allMembers.lookup(name);\n                    }\n\n                }\n            }\n            if (symbol && symbol.isType()) {\n                return symbol;\n            }\n            else {\n                return null;\n            }\n        }\n\n        public findSymbolForDynamicModule(idText: string, currentFileName: string, search: (id: string) =>Symbol): Symbol {\n            var originalIdText = idText;\n            var symbol = search(idText);\n           \n            if (symbol == null) {\n                // perhaps it\'s a dynamic module?\n                if (!symbol) {\n                    idText = swapQuotes(originalIdText);\n                    symbol = search(idText);\n                }\n\n                // Check the literal path first\n                if (!symbol) {\n                    idText = stripQuotes(originalIdText) + ".ts";\n                    symbol = search(idText);\n                }\n\n                if (!symbol) {\n                    idText = stripQuotes(originalIdText) + ".str";\n                    symbol = search(idText);\n                }\n\n                // Check check for .d.str\n                if (!symbol) {\n                    idText = stripQuotes(originalIdText) + ".d.ts";\n                    symbol = search(idText);\n                }\n\n                if (!symbol) {\n                    idText = stripQuotes(originalIdText) + ".d.str";\n                    symbol = search(idText);\n                }\n\n                // If the literal path doesn\'t work, begin the search\n                if (!symbol && !isRelative(originalIdText)) {\n                    // check the full path first, as this is the most likely scenario\n                    idText = originalIdText;\n\n                    var strippedIdText = stripQuotes(idText);\n\n                    // REVIEW: Technically, we shouldn\'t have to normalize here - we should normalize in addUnit.\n                    // Still, normalizing here alows any language services to be free of assumptions\n                    var path = getRootFilePath(switchToForwardSlashes(currentFileName));\n\n                    ',
v27518=v27519+'while (symbol == null && path != "") {\n                        idText = normalizePath(path + strippedIdText + ".ts");\n                        symbol = search(idText);\n\n                        // check for .str\n                        if (symbol == null) {\n                            idText = changePathToSTR(idText);\n                            symbol = search(idText);\n                        }\n\n                        // check for .d.ts\n                        if (symbol == null) {\n                            idText = changePathToDTS(idText);\n                            symbol = search(idText);\n                        }\n\n                        // check for .d.str\n                        if (symbol == null) {\n                            idText = changePathToDSTR(idText);\n                            symbol = search(idText);\n                        }\n\n                        if (symbol == null) {\n\t\t\t\t\t\t\tif(path === \'/\') {\n\t\t\t\t\t\t\t\tpath = \'\';\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpath = normalizePath(path + "..");\n\t\t\t\t\t\t\t\tpath = path && path != \'/\' ? path + \'/\' : path;\n\t\t\t\t\t\t\t}\n                        }\n                    }\n                }\n            }\n\n            return symbol;\n        }\n\n        public resolveTypeMember(scope: SymbolScope, dotNode: BinaryExpression): Type {\n            var lhs = dotNode.operand1;\n            var rhs = dotNode.operand2;\n            var resultType = this.anyType;\n            var lhsType = this.anyType;\n\n            if (lhs && rhs && (rhs.nodeType == NodeType.Name)) {\n                if (lhs.nodeType == NodeType.Dot) {\n                    lhsType = this.resolveTypeMember(scope, <BinaryExpression>lhs);\n                }\n                else if (lhs.nodeType == NodeType.Name) {\n                    var identifier = <Identifier>lhs;\n                    var symbol = scope.find(identifier.text, false, true);\n                    if (symbol == null) {\n                        this.errorReporter.unresolvedSymbol(identifier, identifier.actualText);\n                    }\n                    else if (symbol.isType()) {\n\n                        var typeSymbol = <TypeSymbol> symbol;\n\n                        if (typeSymbol.aliasLink && !typeSymbol.type && typeSymbol.aliasLink.alias.nodeType == NodeType.Name) {\n                            var modPath = (<Identifier>typeSymbol.aliasLink.alias).text;\n                            var modSym = this.findSymbolForDynamicModule(modPath, this.locationInfo.filename, (id) => scope.find(id, false, true));\n                            if (modSym) {\n                                typeSymbol.type = modSym.getType();\n                            }\n                        }\n\n                        if (optimizeModuleCodeGen && symbol) {\n                            var symType = symbol.getType();\n                            // Once the type has been referenced outside of a type ref position, there\'s\n                            // no going back                        \n                            if (symType && typeSymbol.aliasLink && typeSymbol.onlyReferencedAsTypeRef) {\n\n                                var modDecl = <ModuleDeclaration>symType.symbol.declAST;\n                                if (modDecl && hasFlag(modDecl.modFlags, ModuleFlags.IsDynamic)) {\n                                    typeSymbol.onlyReferencedAsTypeRef = !this.resolvingBases;\n                                }\n                            }\n                        }\n                        if (!symbol.visible(scope, this)) {\n                            this.errorReporter.simpleError(lhs, "The symbol \'" + identifier.actualText + "\' is not visible at this point");\n                        }\n                        lhsType = symbol.getType();\n\n                        identifier.sym = symbol;\n                    }\n                    else {\n                        this.errorReporter.simpleError(lhs, "Expected type");\n                    }\n\n                }\n\n                // if the LHS type is a module alias, we won\'t be able to resolve it until\n                // typecheck type.  If this is called during binding, lhsType will be null\n                if (!lhsType) {\n                    lhsType = this.anyType;\n                }\n\n                if (lhsType != this.anyType) {\n                    var rhsIdentifier = <Identifier>rhs;\n                    var resultSymbol = this.lookupMemberTypeSymbol(lhsType, rhsIdentifier.text);\n                    if (resultSymbol == null) {\n                        resultType = this.anyType;\n                        this.errorReporter.simpleError(dotNode, "Expected type");\n                    }\n                    else {\n                        resultType = resultSymbol.getType();\n                        if (!resultSymbol.visible(scope, this)) {\n                            this.errorReporter.simpleError(lhs, "The symbol \'" + (<Identifier>rhs).actualText + "\' is not visible at this point");\n                        }\n                    }\n                    rhsIdentifier.sym =',
v27517=v27518+' resultType.symbol;\n                }\n            }\n            if (resultType.isClass()) {\n                resultType = resultType.instanceType;\n            }\n            return resultType;\n        }\n\n        public resolveFuncDecl(funcDecl: FuncDecl, scope: SymbolScope,\n            fgSym: TypeSymbol): Symbol {\n            var functionGroupSymbol = this.createFunctionSignature(funcDecl, scope.container, scope, fgSym, false).declAST.type.symbol;\n            var signatures: Signature[];\n            if (funcDecl.isConstructMember()) {\n                signatures = functionGroupSymbol.type.construct.signatures;\n            }\n            else if (funcDecl.isIndexerMember()) {\n                signatures = functionGroupSymbol.type.getInstanceType().index.signatures;\n            }\n            else {\n                signatures = functionGroupSymbol.type.call.signatures;\n            }\n\n            var signature = signatures[signatures.length - 1];\n            var len = signature.parameters.length;\n            for (var i = 0; i < len; i++) {\n                var paramSym: ParameterSymbol = signature.parameters[i];\n                this.resolveTypeLink(scope, paramSym.parameter.typeLink, true);\n            }\n\n            // If a vararg list is present, check that the type is an array type\n            if (len && funcDecl.variableArgList) {\n                if (!signature.parameters[len - 1].parameter.typeLink.type.elementType) {\n                    this.errorReporter.simpleErrorFromSym(signature.parameters[len - 1].parameter.symbol, "... parameter must have array type");\n                    signature.parameters[len - 1].parameter.typeLink.type = this.makeArrayType(signature.parameters[len - 1].parameter.typeLink.type);\n                }\n            }\n            this.resolveTypeLink(scope, signature.returnType,\n                            funcDecl.isSignature());\n            return functionGroupSymbol;\n        }\n\n        public resolveVarDecl(varDecl: VarDecl, scope: SymbolScope): Symbol {\n            var field = new ValueLocation();\n            var fieldSymbol =\n                new FieldSymbol(varDecl.id.text, varDecl.minChar, this.locationInfo.unitIndex,\n                                (varDecl.varFlags & VarFlags.Readonly) == VarFlags.None,\n                                field);\n            fieldSymbol.transferVarFlags(varDecl.varFlags);\n            field.symbol = fieldSymbol;\n            fieldSymbol.declAST = varDecl;\n            field.typeLink = getTypeLink(varDecl.typeExpr, this, varDecl.init == null);\n            this.resolveTypeLink(scope, field.typeLink, true);\n            varDecl.sym = fieldSymbol;\n            varDecl.type = field.typeLink.type;\n            return fieldSymbol;\n        }\n\n        public resolveTypeLink(scope: SymbolScope, typeLink: TypeLink, supplyVar: bool): void {\n            var arrayCount = 0;\n            if (typeLink.type == null) {\n                var ast: AST = typeLink.ast;\n                if (ast) {\n                    while (typeLink.type == null) {\n                        switch (ast.nodeType) {\n                            case NodeType.Name:\n                                var identifier = <Identifier>ast;\n                                var symbol = scope.find(identifier.text, false, true);\n                                if (symbol == null) {\n                                    typeLink.type = this.anyType;\n                                    this.errorReporter.unresolvedSymbol(identifier, identifier.actualText);\n                                }\n                                else if (symbol.isType()) {\n                                    if (!symbol.visible(scope, this)) {\n                                        this.errorReporter.simpleError(ast, "The symbol \'" + identifier.actualText + "\' is not visible at this point");\n                                    }\n                                    identifier.sym = symbol;\n                                    typeLink.type = symbol.getType();\n                                    if (typeLink.type) {\n                                        if (typeLink.type.isClass()) {\n                                            typeLink.type = typeLink.type.instanceType;\n                                        }\n                                    }\n                                    else {\n                                        typeLink.type = this.anyType;\n                                    }\n                                }\n                                else {\n                                    typeLink.type = this.anyType;\n                                    this.errorReporter.simpleError(ast, "Expected type");\n                                }\n                                break;\n                            case NodeType.Dot:\n                                typeLink.type = this.resolveTypeMember(scope, <BinaryExpression>ast);\n                                break;\n                            case NodeType.TypeRef:\n                       ',
v27516=v27517+'         var typeRef = <TypeReference>ast;\n                                arrayCount = typeRef.arrayCount;\n                                ast = typeRef.term;\n                                if (ast == null) {\n                                    typeLink.type = this.anyType;\n                                }\n                                break;\n                            case NodeType.InterfaceDeclaration:\n                                var interfaceDecl = <InterfaceDeclaration>ast;\n                                var interfaceType = new Type();\n                                var interfaceSymbol = new TypeSymbol((<Identifier>interfaceDecl.name).text,\n                                                                   ast.minChar,\n                                                                   ast.limChar - ast.minChar,\n                                                                   this.locationInfo.unitIndex,\n                                                                   interfaceType);\n                                interfaceType.symbol = interfaceSymbol;\n                                interfaceType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n\n                                interfaceType.containedScope =\n                                    new SymbolTableScope(interfaceType.members, null, null, null,\n                                                         interfaceSymbol);\n\n                                interfaceType.containedScope.container = interfaceSymbol;\n                                interfaceType.memberScope = interfaceType.containedScope;\n\n                                var memberList = <ASTList>interfaceDecl.members;\n                                var props: AST[] = memberList.members;\n                                var propsLen = props.length;\n\n                                for (var j = 0; j < propsLen; j++) {\n                                    var propDecl = props[j];\n                                    var propSym: Symbol = null;\n                                    var addMember = true;\n                                    var id: Identifier = null;\n                                    if (propDecl.nodeType == NodeType.FuncDecl) {\n                                        var funcDecl = <FuncDecl>propDecl;\n                                        id = funcDecl.name;\n                                        propSym = interfaceType.members.allMembers.lookup(funcDecl.getNameText());\n                                        addMember = (propSym == null);\n                                        if (funcDecl.isSpecialFn()) {\n                                            addMember = false;\n                                            propSym = this.resolveFuncDecl(funcDecl, scope, interfaceSymbol);\n                                        }\n                                        else {\n                                            propSym = this.resolveFuncDecl(funcDecl, scope, <TypeSymbol>propSym);\n                                        }\n                                        funcDecl.type = (<TypeSymbol>propSym).type;\n                                    }\n                                    else {\n                                        id = (<VarDecl>propDecl).id;\n                                        propSym = this.resolveVarDecl(<VarDecl>propDecl, scope);\n\n                                        // Don\'t add the member if it was missing a name.  This \n                                        // generally just leads to cascading errors that make things\n                                        // more confusing for the user.\n                                        addMember = !id.isMissing();\n                                    }\n\n                                    if (addMember) {\n                                        if (id && hasFlag(id.flags, ASTFlags.OptionalName)) {\n                                            propSym.flags |= SymbolFlags.Optional;\n                                        }\n                                        if (!interfaceType.members.allMembers.add(propSym.name, propSym)) {\n                                            this.errorReporter.duplicateIdentifier(ast, propSym.name);\n                                        }\n                                    }\n                                }\n\n                                ast.type = interfaceType;\n                                typeLink.type = interfaceType;\n\n                                break;\n                            case NodeType.FuncDecl:\n                                var tsym = <TypeSymbol>this.resolveFuncDecl(<FuncDecl>ast, scope, null);\n                                typeLink.type = tsym.type;\n                                break;\n                            default:\n                                typeLink.type = this.anyType;\n                                this.errorReporter.simpleError(ast, "Expected type");\n                ',
v27515=v27516+'                break;\n                        }\n                    }\n                }\n                for (var count = arrayCount; count > 0; count--) {\n                    typeLink.type = this.makeArrayType(typeLink.type);\n                }\n                if (supplyVar && (typeLink.type == null)) {\n                    typeLink.type = this.anyType;\n                }\n                if (typeLink.ast) {\n                    typeLink.ast.type = typeLink.type;\n                }\n            }\n            // else wait for type inference\n        }\n\n        public resolveBaseTypeLink(typeLink: TypeLink, scope: SymbolScope) {\n            this.resolvingBases = true;\n            this.resolveTypeLink(scope, typeLink, true);\n            this.resolvingBases = false;\n            var extendsType: Type = null;\n            if (typeLink.type.isClass()) {\n                extendsType = typeLink.type.instanceType;\n            }\n            else {\n                extendsType = typeLink.type;\n            }\n\n            return extendsType;\n        }\n\n        public findMostApplicableSignature(signatures: ApplicableSignature[], args: ASTList): { sig: Signature; ambiguous: bool; } {\n\n            if (signatures.length == 1) {\n                return { sig: signatures[0].signature, ambiguous: false };\n            }\n\n            var best: ApplicableSignature = signatures[0];\n            var Q: ApplicableSignature = null;\n            var AType: Type = null;\n            var PType: Type = null;\n            var QType: Type = null;\n            var ambiguous = false;\n\n            for (var qSig = 1; qSig < signatures.length; qSig++) {\n                Q = signatures[qSig];\n                var i = 0;\n                // find the better conversion\n                for (i = 0; args && i < args.members.length; i++) {\n                    AType = args.members[i].type;\n                    PType = i < best.signature.parameters.length ? best.signature.parameters[i].getType() : best.signature.parameters[best.signature.parameters.length - 1].getType().elementType;\n                    QType = i < Q.signature.parameters.length ? Q.signature.parameters[i].getType() : Q.signature.parameters[Q.signature.parameters.length - 1].getType().elementType;\n\n                    if (this.typesAreIdentical(PType, QType)) {\n                        continue;\n                    }\n                    else if (this.typesAreIdentical(AType, PType)) {\n                        break;\n                    }\n                    else if (this.typesAreIdentical(AType, QType)) {\n                        best = Q;\n                        break;\n                    }\n                    else if (this.sourceIsSubtypeOfTarget(PType, QType)) {\n                        break;\n                    }\n                    else if (this.sourceIsSubtypeOfTarget(QType, PType)) {\n                        best = Q;\n                        break;\n                    }\n                    else if (Q.hadProvisionalErrors) {\n                        break;\n                    }\n                    else if (best.hadProvisionalErrors) {\n                        best = Q;\n                        break;\n                    }\n                }\n\n                if (!args || i == args.members.length) {\n                    var collection: ITypeCollection = {\n                        getLength: () => { return 2; },\n                        setTypeAtIndex: (index: number, type: Type) => { }, // no contextual typing here, so no need to do anything\n                        getTypeAtIndex: (index: number) => { return index ? Q.signature.returnType.type : best.signature.returnType.type; } // we only want the "second" type - the "first" is skipped\n                    }\n                    var bct = this.findBestCommonType(best.signature.returnType.type, null, collection, true);\n                    ambiguous = !bct;\n                }\n                else {\n                    ambiguous = false;\n                }\n            }\n\n            return { sig: best.signature, ambiguous: ambiguous };\n        }\n\n        public getApplicableSignatures(signatures: Signature[], args: ASTList, comparisonInfo: TypeComparisonInfo): ApplicableSignature[] {\n\n            var applicableSigs: ApplicableSignature[] = [];\n            var memberType: Type = null;\n            var miss = false;\n            var cxt: ContextualTypeContext = null;\n            var hadProvisionalErrors = false;\n\n            for (var i = 0; i < signatures.length; i++) {\n                miss = false;\n\n                for (var j = 0; j < args.members.length; j++) {\n\n                    if (j >= signatures[i].parameters.length) {\n                        continue;\n                    }\n                    memberType = signatures[i].parameters[j].getType();\n\n                    // account for varargs\n                    if (signatures[i].declAST.variableArgList && (j >= signatures[i].nonOptionalParameterCount - 1) && memberType.isArray()) {\n                        memberType = mem',
v27514=v27515+'berType.elementType;\n                    }\n\n                    if (memberType == this.anyType) {\n                        continue;\n                    }\n                    else if (args.members[j].nodeType == NodeType.FuncDecl) {\n                        if (this.typeFlow.functionInterfaceType && memberType == this.typeFlow.functionInterfaceType) {\n                            continue;\n                        }\n                        if (!this.canContextuallyTypeFunction(memberType, <FuncDecl>args.members[j], true)) {\n                            // if it\'s just annotations that are blocking us, typecheck the function and add it to the list\n                            if (this.canContextuallyTypeFunction(memberType, <FuncDecl>args.members[j], false)) {\n                                this.typeFlow.typeCheck(args.members[j]);\n                                if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {\n                                    break;\n                                }\n                            }\n                            else {\n                                break;\n                            }\n                        }\n                        else { // if it can be contextually typed, try it out...\n\n                            this.typeCheckWithContextualType(memberType, true, true, args.members[j]);\n                            this.cleanStartedPTO();\n                            hadProvisionalErrors = this.hadProvisionalErrors();\n\n                            if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {\n                                if (comparisonInfo) {\n                                    comparisonInfo.setMessage("Could not apply type \'" + memberType.getTypeName() + "\' to argument " + (j + 1) + ", which is of type \'" + args.members[j].type.getTypeName() + "\'");\n                                }\n                                miss = true;\n                            }\n\n                            // clean the type\n                            //if (hadProvisionalErrors) {\n                            //    cxt = this.currentContextualTypeContext;\n                            //    this.typeCheckWithContextualType(null, true, true, args.members[j]);\n                            //    if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType)) {\n                            //        miss = true;\n                            //    }\n                            //    this.cleanStartedPTO();\n                            //}\n\n                            this.resetProvisionalErrors();\n                            if (miss) {\n                                break;\n                            }\n                        }\n                    }\n                    else if (args.members[j].nodeType == NodeType.ObjectLit) {\n                        // now actually attempt to typecheck as the contextual type\n                        if (this.typeFlow.objectInterfaceType && memberType == this.typeFlow.objectInterfaceType) {\n                            continue;\n                        }\n\n                        this.typeCheckWithContextualType(memberType, true, true, args.members[j]);\n                        this.cleanStartedPTO();\n                        hadProvisionalErrors = this.hadProvisionalErrors(); \n\n                        if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {\n                            if (comparisonInfo) {\n                                comparisonInfo.setMessage("Could not apply type \'" + memberType.getTypeName() + "\' to argument " + (j + 1) + ", which is of type \'" + args.members[j].type.getTypeName() + "\'");\n                            }\n                            miss = true;\n                        }\n\n                        // clean the type\n                        //if (hadProvisionalErrors) {\n                        //    this.typeCheckWithContextualType(null, true, true, args.members[j]);\n\n                        //    // is the "cleaned" type even assignable?\n                        //    if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType)) {\n                        //        miss = true;\n                        //    }\n\n                        //    this.cleanStartedPTO();\n                        //}\n\n                        this.resetProvisionalErrors();\n                        if (miss) {\n                            break;\n                        }\n                    }\n                    else if (args.members[j].nodeType == NodeType.ArrayLit) {\n                        // attempt to contextually type the array literal\n                        if (this.typeFlow.arrayInterfaceType && memberType == this.typeFlow.arrayInterfaceType) {\n                            continue;\n                        }\n\n                        this.typeCheckWithContextualType(memberType, true, true, args.members[j]);\n                        thi',
v27513=v27514+'s.cleanStartedPTO();\n                        hadProvisionalErrors = this.hadProvisionalErrors(); \n\n                        if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {\n                            if (comparisonInfo) {\n                                comparisonInfo.setMessage("Could not apply type \'" + memberType.getTypeName() + "\' to argument " + (j + 1) + ", which is of type \'" + args.members[j].type.getTypeName() + "\'");\n                            }\n                            break;\n                        }\n\n                        // clean the type\n                        //if (hadProvisionalErrors) {\n                        //    this.typeCheckWithContextualType(null, true, true, args.members[j]);\n                        //    if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType)) {\n                        //        miss = true;\n                        //    }\n\n                        //    this.cleanStartedPTO();\n                        //}\n\n                        this.resetProvisionalErrors();\n                        if (miss) {\n                            break;\n                        }\n                    }\n                }\n\n                if (j == args.members.length) {\n                    applicableSigs[applicableSigs.length] = { signature: signatures[i], hadProvisionalErrors: hadProvisionalErrors };\n                }\n                hadProvisionalErrors = false;\n            }\n\n            return applicableSigs;\n        }\n\n        public canContextuallyTypeFunction(candidateType: Type, funcDecl: FuncDecl, beStringent: bool): bool {\n\n            // in these cases, we do not attempt to apply a contextual type\n            //  RE: isInlineCallLiteral - if the call target is a function literal, we don\'t want to apply the target type\n            //  to its body - instead, it should be applied to its return type\n            if (funcDecl.isParenthesized ||\n                funcDecl.isMethod() ||\n                beStringent && funcDecl.returnTypeAnnotation ||\n                funcDecl.isInlineCallLiteral) {\n                return false;\n            }\n\n            beStringent = beStringent || (this.typeFlow.functionInterfaceType == candidateType);\n\n            // At this point, if we\'re not being stringent, there\'s no need to check for multiple call sigs\n            // or count parameters - we just want to unblock typecheck\n            if (!beStringent) {\n                return true;\n            }\n\n            // If we\'re coming from an in-scope typecheck, lambdas may not have had function signatures created for them\n            // REVIEW: Should we search out the overload group here?\n            if (!funcDecl.signature) {\n                this.createFunctionSignature(funcDecl, this.typeFlow.scope.container, this.typeFlow.scope, null, null);\n                this.typeFlow.typeCheck(funcDecl);\n            }\n\n            var signature = funcDecl.signature;\n            var paramLen = signature.parameters.length;\n\n            // Check that the argument declarations have no type annotations\n            for (var i = 0; i < paramLen; i++) {\n                var param = signature.parameters[i];\n                var symbol = <ParameterSymbol>param;\n                var argDecl = <ArgDecl>symbol.declAST;\n\n                // REVIEW: a valid typeExpr is a requirement for varargs,\n                // so we may want to revise our invariant\n                if (beStringent && argDecl.typeExpr) {\n                    return false;\n                }\n            }\n\n            if (candidateType.construct && candidateType.call) {\n                return false;\n            }\n\n            var candidateSigs = candidateType.construct ? candidateType.construct : candidateType.call;\n\n            if (!candidateSigs || candidateSigs.signatures.length > 1) {\n                return false;\n            }\n\n            // if we\'re here, the contextual type can be applied to the function\n            return true;\n        }\n\n        public canContextuallyTypeObjectLiteral(targetType: Type, objectLit: UnaryExpression): bool {\n\n            if (targetType == this.typeFlow.objectInterfaceType) {\n                return true;\n            }\n\n            var memberDecls = <ASTList>objectLit.operand;\n\n            if (!(memberDecls && targetType.memberScope)) {\n                return false;\n            }\n\n            var id: AST = null;\n            var targetMember: Symbol = null;\n            var text = "";\n            var foundSyms = {};\n\n            // Check that each property in the object literal is present in the target\n            // type\n            for (var i = 0; i < memberDecls.members.length; i++) {\n                id = (<BinaryExpression>memberDecls.members[i]).operand1;\n\n                if (id.nodeType == NodeType.Name) {\n                    text = (<Identifier>id).text;\n                }\n                else if (id.nodeType == NodeType.QString) {\n                    // TODO: set te',
v27512=v27513+"xt to unescaped string\n                    var idText = (<StringLiteral>id).text;\n                    text = idText.substring(1, idText.length - 1);\n                }\n                else {\n                    return false;\n                }\n\n                targetMember = targetType.memberScope.find(text, true, false);\n\n                if (!targetMember) {\n                    return false;\n                }\n\n                foundSyms[text] = true;\n            }\n\n            // Check that all members in the target type are present in the object literal\n            var targetMembers = targetType.memberScope.getAllValueSymbolNames(true);\n\n            for (var i = 0; i < targetMembers.length; i++) {\n                var memberName = targetMembers[i];\n                var memberSym = targetType.memberScope.find(memberName, true, false);\n\n                if (!foundSyms[targetMembers[i]] &&\n                    !hasFlag(memberSym.flags, SymbolFlags.Optional)) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        public widenType(t: Type) {\n            if (t == this.undefinedType || t == this.nullType) { // REVIEW: not isNullOrUndefinedType for perf reasons\n                return this.anyType;\n            }\n\n            return t;\n        }\n\n        public isNullOrUndefinedType(t: Type) {\n            return t == this.undefinedType || t == this.nullType;\n        }\n\n        public findBestCommonType(initialType: Type, targetType: Type, collection: ITypeCollection, acceptVoid:bool, comparisonInfo?: TypeComparisonInfo) {\n            var i = 0;\n            var len = collection.getLength();\n            var nlastChecked = 0;\n            var bestCommonType = initialType;\n\n            if (targetType) {\n                bestCommonType = bestCommonType ? bestCommonType.mergeOrdered(targetType, this, acceptVoid) : targetType;\n            }\n\n            // it's important that we set the convergence type here, and not in the loop,\n            // since the first element considered may be the contextual type\n            var convergenceType: Type = bestCommonType;\n\n            while (nlastChecked < len) {\n\n                for (i = 0; i < len; i++) {\n\n                    // no use in comparing a type against itself\n                    if (i == nlastChecked) {\n                        continue;\n                    }\n\n                    if (convergenceType && (bestCommonType = convergenceType.mergeOrdered(collection.getTypeAtIndex(i), this, acceptVoid, comparisonInfo))) {\n                        convergenceType = bestCommonType;\n                    }\n\n                    if (bestCommonType == this.anyType || bestCommonType == null) {\n                        break;\n                    }\n                    else if (targetType) { // set the element type to the target type\n                        collection.setTypeAtIndex(i, targetType);\n                    }\n                }\n\n                // use the type if we've agreed upon it\n                if (convergenceType && bestCommonType) {\n                    break;\n                }\n\n                nlastChecked++;\n                if (nlastChecked < len) {\n                    convergenceType = collection.getTypeAtIndex(nlastChecked);\n                }\n            }\n\n            return acceptVoid ? bestCommonType : (bestCommonType == this.voidType ? null : bestCommonType);\n        }\n\n        // Type Identity\n\n        public typesAreIdentical(t1: Type, t2: Type) {\n\n            // This clause will cover both primitive types (since the type objects are shared),\n            // as well as shared brands\n            if (t1 == t2) {\n                return true;\n            }\n\n            if (!t1 || !t2) {\n                return false;\n            }\n\n            if (t1.isClass() || t1.isClassInstance()) {\n                return false;\n            }\n\n            var comboId = (t2.typeID << 16) | t1.typeID;\n\n            if (this.identicalCache[comboId]) {\n                return true;\n            }\n\n            // If one is an enum, and they're not the same type, they're not identical\n            if ((t1.typeFlags & TypeFlags.IsEnum) || (t2.typeFlags & TypeFlags.IsEnum)) {\n                return false;\n            }\n\n            if (t1.isArray() || t2.isArray()) {\n                if (!(t1.isArray() && t2.isArray())) {\n                    return false;\n                }\n                this.identicalCache[comboId] = false;\n                var ret = this.typesAreIdentical(t1.elementType, t2.elementType);\n                if (ret) {\n                    this.subtypeCache[comboId] = true;\n                }\n                else {\n                    this.subtypeCache[comboId] = undefined;\n                }\n\n                return ret;\n            }\n\n            if (t1.primitiveTypeClass != t2.primitiveTypeClass) {\n                return false;\n            }\n\n            this.identicalCache[comboId] = false;\n\n            // properties are identical in na",
v27511=v27512+"me, optionality, and type\n            // REVIEW: TypeChanges - The compiler does not currently check against the members of parent types!\n            // REVIEW: TypeChanges - What about ambientMembers?\n            if (t1.memberScope && t2.memberScope) {\n                var t1MemberKeys = t1.memberScope.getAllValueSymbolNames(true).sort();\n                var t2MemberKeys = t2.memberScope.getAllValueSymbolNames(true).sort();\n\n                if (t1MemberKeys.length != t2MemberKeys.length) {\n                    this.identicalCache[comboId] = undefined;\n                    return false;\n                }\n\n                var t1MemberSymbol: Symbol = null;\n                var t2MemberSymbol: Symbol = null;\n\n                var t1MemberType: Type = null;\n                var t2MemberType: Type = null;\n\n                for (var iMember = 0; iMember < t1MemberKeys.length; iMember++) {\n                    if (t1MemberKeys[iMember] != t2MemberKeys[iMember]) {\n                        this.identicalCache[comboId] = undefined;\n                        return false;\n                    }\n\n                    t1MemberSymbol = <Symbol>t1.memberScope.find(t1MemberKeys[iMember], false, false);\n                    t2MemberSymbol = <Symbol>t2.memberScope.find(t2MemberKeys[iMember], false, false);\n\n                    if ((t1MemberSymbol.flags & SymbolFlags.Optional) != (t2MemberSymbol.flags & SymbolFlags.Optional)) {\n                        this.identicalCache[comboId] = undefined;\n                        return false;\n                    }\n\n                    t1MemberType = t1MemberSymbol.getType();\n                    t2MemberType = t2MemberSymbol.getType();\n\n                    // catch the mutually recursive or cached cases\n                    if (t1MemberType && t2MemberType && (this.identicalCache[(t2MemberType.typeID << 16) | t1MemberType.typeID] != undefined)) {\n                        continue;\n                    }\n\n                    if (!this.typesAreIdentical(t1MemberType, t2MemberType)) {\n                        this.identicalCache[comboId] = undefined;\n                        return false;\n                    }\n                }\n            }\n            else if (t1.memberScope || t2.memberScope) {\n                this.identicalCache[comboId] = undefined;\n                return false;\n            }\n\n            if (!this.signatureGroupsAreIdentical(t1.call, t2.call)) {\n                this.identicalCache[comboId] = undefined;\n                return false;\n            }\n\n            if (!this.signatureGroupsAreIdentical(t1.construct, t2.construct)) {\n                this.identicalCache[comboId] = undefined;\n                return false;\n            }\n\n            if (!this.signatureGroupsAreIdentical(t1.index, t2.index)) {\n                this.identicalCache[comboId] = undefined;\n                return false;\n            }\n\n            this.identicalCache[comboId] = true;\n            return true;\n        }\n\n        public signatureGroupsAreIdentical(sg1: SignatureGroup, sg2: SignatureGroup) {\n\n            // covers the null case\n            if (sg1 == sg2) {\n                return true;\n            }\n\n            // covers the mixed-null case\n            if (!sg1 || !sg2) {\n                return false;\n            }\n\n            if (sg1.signatures.length != sg2.signatures.length) {\n                return false;\n            }\n\n            var sig1: Signature = null;\n            var sig2: Signature = null;\n            var sigsMatch = false;\n\n            // The signatures in the signature group may not be ordered...\n            // REVIEW: Should definition signatures be required to be identical as well?\n            for (var iSig1 = 0; iSig1 < sg1.signatures.length; iSig1++) {\n                sig1 = sg1.signatures[iSig1];\n\n                for (var iSig2 = 0; iSig2 < sg2.signatures.length; iSig2++) {\n                    sig2 = sg2.signatures[iSig2];\n\n                    if (this.signaturesAreIdentical(sig1, sig2)) {\n                        sigsMatch = true;\n                        break;\n                    }\n                }\n\n                if (sigsMatch) {\n                    sigsMatch = false;\n                    continue;\n                }\n\n                // no match found for a specific signature\n                return false;\n            }\n\n            return true;\n        }\n\n        public signaturesAreIdentical(s1: Signature, s2: Signature) {\n\n            if (s1.hasVariableArgList != s2.hasVariableArgList) {\n                return false;\n            }\n\n            if (s1.nonOptionalParameterCount != s2.nonOptionalParameterCount) {\n                return false;\n            }\n\n            if (s1.parameters.length != s2.parameters.length) {\n                return false;\n            }\n\n            if (!this.typesAreIdentical(s1.returnType.type, s2.returnType.type)) {\n                return false;\n            }\n\n            for (var iParam = 0; iParam < s1.parameters.length; iParam++) {\n                if (!thi",
v27510=v27511+"s.typesAreIdentical(s1.parameters[iParam].parameter.typeLink.type, s2.parameters[iParam].parameter.typeLink.type)) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        // Subtyping and Assignment compatibility\n\n        public sourceIsSubtypeOfTarget(source: Type, target: Type, comparisonInfo?: TypeComparisonInfo) { return this.sourceIsRelatableToTarget(source, target, false, this.subtypeCache, comparisonInfo); }\n        public signatureGroupIsSubtypeOfTarget(sg1: SignatureGroup, sg2: SignatureGroup, comparisonInfo?: TypeComparisonInfo) { return this.signatureGroupIsRelatableToTarget(sg1, sg2, false, this.subtypeCache, comparisonInfo); }\n        public signatureIsSubtypeOfTarget(s1: Signature, s2: Signature, comparisonInfo?: TypeComparisonInfo) { return this.signatureIsRelatableToTarget(s1, s2, false, this.subtypeCache, comparisonInfo); }\n\n        public sourceIsAssignableToTarget(source: Type, target: Type, comparisonInfo?: TypeComparisonInfo) { return this.sourceIsRelatableToTarget(source, target, true, this.assignableCache, comparisonInfo); }\n        public signatureGroupIsAssignableToTarget(sg1: SignatureGroup, sg2: SignatureGroup, comparisonInfo?: TypeComparisonInfo) { return this.signatureGroupIsRelatableToTarget(sg1, sg2, true, this.assignableCache, comparisonInfo); }\n        public signatureIsAssignableToTarget(s1: Signature, s2: Signature, comparisonInfo?: TypeComparisonInfo) { return this.signatureIsRelatableToTarget(s1, s2, true, this.assignableCache, comparisonInfo); }\n\n        public sourceIsRelatableToTarget(source: Type, target: Type, assignableTo: bool, comparisonCache: any, comparisonInfo: TypeComparisonInfo) {\n\n            // REVIEW: Does this check even matter?\n            //if (this.typesAreIdentical(source, target)) {\n            //    return true;\n            //}\n            if (source == target) {\n                return true;\n            }\n\n            // An error has already been reported in this case\n            if (!(source && target)) {\n                return true;\n            }\n\n            var comboId = (source.typeID << 16) | target.typeID;\n\n            // In the case of a 'false', we want to short-circuit a recursive typecheck\n            if (comparisonCache[comboId] != undefined) {\n                return true;\n            }\n\n            // this is one difference between subtyping and assignment compatibility\n            if (assignableTo) {\n                if (source == this.anyType || target == this.anyType) {\n                    return true;\n                }\n            }\n            else {\n                // This is one difference between assignment compatibility and subtyping\n                if (target == this.anyType) {\n                    return true;\n                }\n            }\n\n            if (source == this.undefinedType) {\n                return true;\n            }\n\n            if ((source == this.nullType) && (target != this.undefinedType && target != this.voidType)) {\n                return true;\n            }\n\n            // REVIEW: enum types aren't explicitly covered in the spec\n            if (target == this.numberType && (source.typeFlags & TypeFlags.IsEnum)) {\n                return true;\n            }\n            if (source == this.numberType && (target.typeFlags & TypeFlags.IsEnum)) {\n                return true;\n            }\n            if ((source.typeFlags & TypeFlags.IsEnum) || (target.typeFlags & TypeFlags.IsEnum)) {\n                return false;\n            }\n\n            if (source.isArray() || target.isArray()) {\n                if (!(source.isArray() && target.isArray())) {\n                    return false;\n                }\n                comparisonCache[comboId] = false;\n                var ret = this.sourceIsRelatableToTarget(source.elementType, target.elementType, assignableTo, comparisonCache, comparisonInfo);\n                if (ret) {\n                    comparisonCache[comboId] = true;\n                }\n                else {\n                    comparisonCache[comboId] = undefined;\n                }\n\n                return ret;\n            }\n\n            // this check ensures that we only operate on object types from this point forward,\n            // since the checks involving primitives occurred above\n            if (source.primitiveTypeClass != target.primitiveTypeClass) {\n\n                if (target.primitiveTypeClass == Primitive.None) {\n                    if (source == this.numberType && this.typeFlow.numberInterfaceType) {\n                        source = this.typeFlow.numberInterfaceType;\n                    }\n                    else if (source == this.stringType && this.typeFlow.stringInterfaceType) {\n                        source = this.typeFlow.stringInterfaceType;\n                    }\n                    else if (source == this.booleanType && this.typeFlow.booleanInterfaceType) {\n                        source = this.typeFlow.booleanInterfaceType;\n           ",
v27509=v27510+'         }\n                    else {\n                        return false;\n                    }\n                }\n                else {\n                    return false;\n                }\n            }\n\n            comparisonCache[comboId] = false;\n\n            if (source.hasBase(target)) {\n                comparisonCache[comboId] = true;\n                return true;\n            }\n\n            if (this.typeFlow.objectInterfaceType && target == this.typeFlow.objectInterfaceType) {\n                return true;\n            }\n\n            if (this.typeFlow.functionInterfaceType && (source.call || source.construct) && target == this.typeFlow.functionInterfaceType) {\n                return true;\n            }\n\n            // REVIEW: We should perhaps do this, though it wouldn\'t be quite right without generics support\n            //if (this.typeFlow.arrayInterfaceType && (source.index) && target == this.typeFlow.arrayInterfaceType) {\n            //    return true;\n            //}\n\n            // At this point, if the target is a class, but not the source or a parent of the source, bail\n            if (target.isClass() || target.isClassInstance()) {\n                comparisonCache[comboId] = undefined;\n                return false;\n            }\n\n            if (target.memberScope && source.memberScope) {\n                var mPropKeys = target.memberScope.getAllValueSymbolNames(true);\n                var mProp: Symbol = null;\n                var nProp: Symbol = null;\n                var mPropType: Type = null;\n                var nPropType: Type = null;\n                var inferenceSymbol: InferenceSymbol = null;\n\n                for (var iMProp = 0; iMProp < mPropKeys.length; iMProp++) {\n                    mProp = target.memberScope.find(mPropKeys[iMProp], false, false);\n                    nProp = source.memberScope.find(mPropKeys[iMProp], false, false);\n\n                    // methods do not have the "arguments" field\n                    if (mProp.name == "arguments" &&\n                        this.typeFlow.iargumentsInterfaceType &&\n                        (this.typeFlow.iargumentsInterfaceType.symbol.flags & SymbolFlags.CompilerGenerated) &&\n                        mProp.kind() == SymbolKind.Variable &&\n                        (<VariableSymbol>mProp).variable.typeLink.type == this.typeFlow.iargumentsInterfaceType) {\n                        continue;\n                    }\n\n                    if (mProp.isInferenceSymbol()) {\n                        inferenceSymbol = <InferenceSymbol>mProp;\n                        if (inferenceSymbol.typeCheckStatus == TypeCheckStatus.NotStarted) {\n                            // REVIEW: TypeChanges: Does this ever really happen?  Maybe for out-of-order typecheck?\n                            this.typeFlow.typeCheck(mProp.declAST);\n                        }\n                    }\n                    mPropType = mProp.getType();\n\n                    if (!nProp) {\n                        // If it\'s not present on the type in question, look for the property on \'Object\'\n                        if (this.typeFlow.objectInterfaceType) {\n                            nProp = this.typeFlow.objectInterfaceType.memberScope.find(mPropKeys[iMProp], false, false);\n                        }\n\n                        if (!nProp) {\n                            // Now, the property was not found on Object, but the type in question is a function, look\n                            // for it on function\n                            if (this.typeFlow.functionInterfaceType && (mPropType.call || mPropType.construct)) {\n                                nProp = this.typeFlow.functionInterfaceType.memberScope.find(mPropKeys[iMProp], false, false);\n                            }\n\n                            // finally, check to see if the property is optional\n                            if (!nProp) {\n                                if (!(mProp.flags & SymbolFlags.Optional)) {\n                                    comparisonCache[comboId] = undefined;\n                                    if (comparisonInfo) { // only surface the first error\n                                        comparisonInfo.flags |= TypeRelationshipFlags.RequiredPropertyIsMissing;\n                                        comparisonInfo.addMessageToFront("Type \'" + source.getTypeName() + "\' is missing property \'" + mPropKeys[iMProp] + "\' from type \'" + target.getTypeName() + "\'");\n                                    }\n                                    return false;\n                                }\n                                else {\n                                    continue;\n                                }\n                            }\n                        }\n                    }\n\n                    if (nProp.isInferenceSymbol()) {\n                        inferenceSymbol = <InferenceSymbol>nProp;\n                        if (inferenceSymbol.typeCheckStatus == TypeCheckStatus.NotStarted) {\n                            this.typeFlow.type',
v27508=v27509+'Check(nProp.declAST);\n                        }\n                    }\n\n\n                    nPropType = nProp.getType();\n\n                    // catch the mutually recursive or cached cases\n                    if (mPropType && nPropType && (comparisonCache[(nPropType.typeID << 16) | mPropType.typeID] != undefined)) {\n                        continue;\n                    }\n\n                    if (!this.sourceIsRelatableToTarget(nPropType, mPropType, assignableTo, comparisonCache, comparisonInfo)) {\n                        comparisonCache[comboId] = undefined;\n                        if (comparisonInfo) { // only surface the first error\n                            comparisonInfo.flags |= TypeRelationshipFlags.IncompatiblePropertyTypes;\n                            comparisonInfo.addMessageToFront("Types of property \'" + mProp.name + "\' of types \'" + source.getTypeName() + "\' and \'" + target.getTypeName() + "\' are incompatible");\n                        }\n                        return false;\n                    }\n                }\n            }\n\n            // check signature groups\n            if (source.call || target.call) {\n                if (!this.signatureGroupIsRelatableToTarget(source.call, target.call, assignableTo, comparisonCache, comparisonInfo)) {\n                    if (comparisonInfo) {\n                        if (source.call && target.call) {\n                            comparisonInfo.addMessageToFront("Call signatures of types \'" + source.getTypeName() + "\' and \'" + target.getTypeName() + "\' are incompatible");\n                        }\n                        else {\n                            var hasSig = target.call ? target.getTypeName() : source.getTypeName();\n                            var lacksSig = !target.call ? target.getTypeName() : source.getTypeName();\n                            comparisonInfo.setMessage("Type \'" + hasSig + "\' requires a call signature, but Type \'" + lacksSig + "\' lacks one");\n                        }\n                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleSignatures;\n                    }\n                    comparisonCache[comboId] = undefined;\n                    return false;\n                }\n            }\n\n            if (source.construct || target.construct) {\n                if (!this.signatureGroupIsRelatableToTarget(source.construct, target.construct, assignableTo, comparisonCache, comparisonInfo)) {\n                    if (comparisonInfo) {\n                        if (source.construct && target.construct) {\n                            comparisonInfo.addMessageToFront("Construct signatures of types \'" + source.getTypeName() + "\' and \'" + target.getTypeName() + "\' are incompatible");\n                        }\n                        else {\n                            var hasSig = target.construct ? target.getTypeName() : source.getTypeName();\n                            var lacksSig = !target.construct ? target.getTypeName() : source.getTypeName();\n                            comparisonInfo.setMessage("Type \'" + hasSig + "\' requires a construct signature, but Type \'" + lacksSig + "\' lacks one");\n                        }\n                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleSignatures;\n                    }\n                    comparisonCache[comboId] = undefined;\n                    return false;\n                }\n            }\n\n            if (target.index) {\n                var targetIndex = !target.index && this.typeFlow.objectInterfaceType ? this.typeFlow.objectInterfaceType.index : target.index;\n                var sourceIndex = !source.index && this.typeFlow.objectInterfaceType ? this.typeFlow.objectInterfaceType.index : source.index;\n\n                if (!this.signatureGroupIsRelatableToTarget(sourceIndex, targetIndex, assignableTo, comparisonCache, comparisonInfo)) {\n                    if (comparisonInfo) {\n                        comparisonInfo.addMessageToFront("Index signatures of types \'" + source.getTypeName() + "\' and \'" + target.getTypeName() + "\' are incompatible");\n                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleSignatures;\n                    }\n                    comparisonCache[comboId] = undefined;\n                    return false;\n                }\n            }\n\n            comparisonCache[comboId] = true;\n            return true;\n        }\n\n        // REVIEW: TypeChanges: Return an error context object so the user can get better diagnostic info\n        public signatureGroupIsRelatableToTarget(sourceSG: SignatureGroup, targetSG: SignatureGroup, assignableTo: bool, comparisonCache: any, comparisonInfo?: TypeComparisonInfo) {\n            if (sourceSG == targetSG) {\n                return true;\n            }\n\n            if (!(sourceSG && targetSG)) {\n                return false;\n            }\n\n            var mSig: Signature = null;\n            var nSig: Signature = null;\n            var foundMatch = false;\n\n            for (var iMSig = 0; ',
v27507=v27508+'iMSig < targetSG.signatures.length; iMSig++) {\n                mSig = targetSG.signatures[iMSig];\n\n                for (var iNSig = 0; iNSig < sourceSG.signatures.length; iNSig++) {\n                    nSig = sourceSG.signatures[iNSig];\n                    if (this.signatureIsRelatableToTarget(nSig, mSig, assignableTo, comparisonCache, comparisonInfo)) {\n                        foundMatch = true;\n                        break;\n                    }\n                }\n\n                if (foundMatch) {\n                    foundMatch = false;\n                    continue;\n                }\n                return false;\n            }\n\n            return true;\n        }\n\n        public signatureIsRelatableToTarget(sourceSig: Signature, targetSig: Signature, assignableTo: bool, comparisonCache: any, comparisonInfo?: TypeComparisonInfo) {\n\n            if (!sourceSig.parameters || !targetSig.parameters) {\n                return false;\n            }\n\n            var targetVarArgCount = targetSig.hasVariableArgList ? targetSig.nonOptionalParameterCount - 1 : targetSig.nonOptionalParameterCount;\n            var sourceVarArgCount = sourceSig.hasVariableArgList ? sourceSig.nonOptionalParameterCount - 1 : sourceSig.nonOptionalParameterCount;\n\n            if (sourceVarArgCount > targetVarArgCount && !targetSig.hasVariableArgList) {\n                if (comparisonInfo) {\n                    comparisonInfo.flags |= TypeRelationshipFlags.SourceSignatureHasTooManyParameters;\n                    comparisonInfo.addMessageToFront("Call signature expects " + targetVarArgCount + " or fewer parameters");\n                }\n                return false;\n            }\n\n            var sourceReturnType = sourceSig.returnType.type;\n            var targetReturnType = targetSig.returnType.type;\n\n            if (targetReturnType != this.voidType) {\n                if (!this.sourceIsRelatableToTarget(sourceReturnType, targetReturnType, assignableTo, comparisonCache, comparisonInfo)) {\n                    if (comparisonInfo) {\n                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleReturnTypes;\n                        // No need to print this one here - it\'s printed as part of the signature error in sourceIsRelatableToTarget\n                        //comparisonInfo.addMessageToFront("Incompatible return types: \'" + sourceReturnType.getTypeName() + "\' and \'" + targetReturnType.getTypeName() + "\'");\n                    }\n                    return false;\n                }\n            }\n\n            var len = (sourceVarArgCount < targetVarArgCount && sourceSig.hasVariableArgList) ? targetVarArgCount : sourceVarArgCount;\n            var sourceParamType: Type = null;\n            var targetParamType: Type = null;\n            var sourceParamName = "";\n            var targetParamName = "";\n\n            for (var iSource = 0, iTarget = 0; iSource < len; iSource++, iTarget++) {\n\n                if (!sourceSig.hasVariableArgList || iSource < sourceVarArgCount) {\n                    sourceParamType = (<ParameterSymbol>sourceSig.parameters[iSource]).parameter.typeLink.type;\n                    sourceParamName = (<ParameterSymbol>sourceSig.parameters[iSource]).parameter.symbol.name;\n                }\n                else if (iSource == sourceVarArgCount) {\n                    sourceParamType = (<ParameterSymbol>sourceSig.parameters[iSource]).parameter.typeLink.type;\n                    if (sourceParamType.elementType) {\n                        sourceParamType = sourceParamType.elementType;\n                    }\n                    sourceParamName = (<ParameterSymbol>sourceSig.parameters[iSource]).parameter.symbol.name;\n                }\n\n                if (iTarget < targetSig.parameters.length && iTarget < targetVarArgCount) {\n                    targetParamType = (<ParameterSymbol>targetSig.parameters[iTarget]).parameter.typeLink.type;\n                    targetParamName = (<ParameterSymbol>targetSig.parameters[iTarget]).parameter.symbol.name;\n                }\n                else if (targetSig.hasVariableArgList && iTarget == targetVarArgCount) {\n                    targetParamType = (<ParameterSymbol>targetSig.parameters[iTarget]).parameter.typeLink.type;\n                    if (targetParamType.elementType) {\n                        targetParamType = targetParamType.elementType;\n                    }\n                    targetParamName = (<ParameterSymbol>targetSig.parameters[iTarget]).parameter.symbol.name;\n                }\n\n                if (!(this.sourceIsRelatableToTarget(sourceParamType, targetParamType, assignableTo, comparisonCache, comparisonInfo) ||\n                        this.sourceIsRelatableToTarget(targetParamType, sourceParamType, assignableTo, comparisonCache, comparisonInfo))) {\n\n                    if (comparisonInfo) {\n                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleParameterTypes;\n                    }\n                    return false;\n                }\n            }\n   ',
v27506=v27507+'         return true;\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class Continuation {\n        public exceptionBlock = -1;\n        constructor (public normalBlock: number) { }\n    }\n\n    function getBaseTypeLinks(bases: ASTList, baseTypeLinks: TypeLink[]) {\n        if (bases) {\n            var len = bases.members.length;\n            if (baseTypeLinks == null) {\n                baseTypeLinks = new TypeLink[];\n            }\n            for (var i = 0; i < len; i++) {\n                var baseExpr = bases.members[i];\n                var name = baseExpr;\n                var typeLink = new TypeLink();\n                typeLink.ast = name;\n                baseTypeLinks[baseTypeLinks.length] = typeLink;\n            }\n        }\n        return baseTypeLinks;\n    }\n\n    function getBases(type: Type, typeDecl: TypeDeclaration) {\n        type.extendsTypeLinks = getBaseTypeLinks(typeDecl.extendsList, type.extendsTypeLinks);\n        type.implementsTypeLinks = getBaseTypeLinks(typeDecl.implementsList, type.implementsTypeLinks);\n    }\n\n    function addPrototypeField(classType: Type, ast: AST, context: TypeCollectionContext) {\n        var field = new ValueLocation();\n        field.typeLink = new TypeLink();\n        field.typeLink.ast = ast;\n        field.typeLink.type = classType.instanceType;\n\n        var fieldSymbol =\n            new FieldSymbol("prototype", ast.minChar,\n                            context.checker.locationInfo.unitIndex, true, field);\n        fieldSymbol.flags |= (SymbolFlags.Property | SymbolFlags.BuiltIn);\n        field.symbol = fieldSymbol;\n        fieldSymbol.declAST = ast;\n        classType.members.addPublicMember("prototype", fieldSymbol);\n    }\n\n    export function createNewConstructGroupForType(type: Type) {\n        var signature = new Signature();\n        signature.returnType = new TypeLink();\n        signature.returnType.type = type.instanceType;\n        signature.parameters = [];\n\n        type.construct = new SignatureGroup();\n        type.construct.addSignature(signature);     \n    }\n\n    export function cloneParentConstructGroupForChildType(child: Type, parent: Type) {\n        child.construct = new SignatureGroup();\n        var sig: Signature = null;\n\n        if (!parent.construct) {\n            createNewConstructGroupForType(parent);\n        }\n\n        for (var i = 0; i < parent.construct.signatures.length; i++) { \n            sig = new Signature();\n            sig.parameters = parent.construct.signatures[i].parameters;\n            sig.nonOptionalParameterCount = parent.construct.signatures[i].nonOptionalParameterCount;\n            sig.typeCheckStatus = parent.construct.signatures[i].typeCheckStatus;\n            sig.declAST = parent.construct.signatures[i].declAST;\n            sig.returnType = new TypeLink();\n            sig.returnType.type = child.instanceType;\n            child.construct.addSignature(sig);\n        }\n\n    }\n\n    export var globalId = "__GLO";\n\n    export interface IAliasScopeContext {\n        topLevelScope: ScopeChain;\n        members: IHashTable;\n        tcContext: TypeCollectionContext;\n    }\n\n    function findTypeSymbolInScopeChain(name: string, scopeChain: ScopeChain): Symbol {\n        var symbol = scopeChain.scope.find(name, false, true);\n\n        if (symbol == null && scopeChain.previous) {\n            symbol = findTypeSymbolInScopeChain(name, scopeChain.previous);\n        }\n\n        return symbol;\n    }\n\n    function findSymbolFromAlias(alias: AST, context: IAliasScopeContext): Symbol {\n        var symbol: Symbol = null;\n        switch (alias.nodeType) {\n            case NodeType.Name:\n                var name = (<Identifier>alias).text;\n                var isDynamic = isQuoted(name);\n\n                var findSym = (id: string) => {\n                    if (context.members) {\n                        return context.members.lookup(name);\n                    }\n                    else {\n                        return findTypeSymbolInScopeChain(name, context.topLevelScope);\n                    }\n                }\n\n                if (isDynamic) {\n                    symbol = context.tcContext.checker.findSymbolForDynamicModule(name, context.tcContext.script.locationInfo.filename, findSym);\n                }\n                else {\n                    symbol = findSym(name);\n                }\n\n                break;\n\n     ',
v27505=v27506+"       case NodeType.Dot:\n                var dottedExpr = <BinaryExpression>alias;\n                var op1Sym = findSymbolFromAlias(dottedExpr.operand1, context);\n\n                if (op1Sym && op1Sym.getType()) {\n                    symbol = findSymbolFromAlias(dottedExpr.operand2, context);\n                }\n\n                break;\n\n            default:\n                break;\n        }\n\n        if (symbol) {\n            var symType = symbol.getType();\n            if (symType) {\n                var members = symType.members;\n                if (members) {\n                    context.members = members.publicMembers;\n                }\n            }\n        }\n\n        return symbol;\n    }\n\n    export function preCollectImportTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n        var typeSymbol: TypeSymbol = null;\n        var modType: ModuleType = null;\n        var importDecl = <ImportDeclaration>ast;\n\n        // REVIEW: technically, this call isn't strictly necessary, since we'll find the type during the call to resolveTypeMembers\n        var aliasedModSymbol = findSymbolFromAlias(importDecl.alias, { topLevelScope: scopeChain, members: null, tcContext: context });\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\n\n        if (aliasedModSymbol) {\n            var aliasedModType = aliasedModSymbol.getType();\n\n            if (aliasedModType) {\n                modType = <ModuleType>aliasedModType;\n            }\n        }\n\n        typeSymbol = new TypeSymbol(importDecl.id.text, importDecl.id.minChar, importDecl.limChar - importDecl.minChar,\n                                    context.checker.locationInfo.unitIndex, modType);\n\n        typeSymbol.aliasLink = importDecl;\n\n        if (context.scopeChain.moduleDecl) {\n            typeSymbol.flags |= SymbolFlags.ModuleMember;\n            typeSymbol.declModule = context.scopeChain.moduleDecl;\n        }\n\n        typeSymbol.declAST = importDecl;\n        importDecl.id.sym = typeSymbol;\n        scopeChain.scope.enter(scopeChain.container, ast, typeSymbol,\n                                context.checker.errorReporter, isGlobal, true, false);\n        scopeChain.scope.enter(scopeChain.container, ast, typeSymbol,\n                                context.checker.errorReporter, isGlobal, false, false);\n        return true;\n    }\n\n    export function preCollectModuleTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n\n        var moduleDecl: ModuleDeclaration = <ModuleDeclaration>ast;\n\n        var isAmbient = hasFlag(moduleDecl.modFlags, ModuleFlags.Ambient);\n        var isEnum = hasFlag(moduleDecl.modFlags, ModuleFlags.IsEnum);\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\n        var isExported = hasFlag(moduleDecl.modFlags, ModuleFlags.Exported);\n        var modName = (<Identifier>moduleDecl.name).text;\n\n        var isDynamic = isQuoted(modName);\n\n        var symbol = scopeChain.scope.findLocal(modName, false, false);\n        var typeSymbol: TypeSymbol = null;\n        var modType: ModuleType = null;\n        if ((symbol == null) || (symbol.kind() != SymbolKind.Type)) {\n\n            if (modType == null) {\n                var enclosedTypes = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                var ambientEnclosedTypes = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                modType = new ModuleType(enclosedTypes, ambientEnclosedTypes);\n                if (isEnum) {\n                    modType.typeFlags |= TypeFlags.IsEnum;\n                }\n                modType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                modType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                modType.setHasImplementation();\n            }\n\n            typeSymbol = new TypeSymbol(modName, moduleDecl.name.minChar, modName.length,\n                                        context.checker.locationInfo.unitIndex, modType);\n            typeSymbol.isDynamic = isQuoted(moduleDecl.prettyName);\n\n            if (context.scopeChain.moduleDecl) {\n                typeSymbol.declModule = context.scopeChain.moduleDecl;\n            }\n            typeSymbol.declAST = moduleDecl;\n            typeSymbol.prettyName = moduleDecl.prettyName;\n            scopeChain.scope.enter(scopeChain.container, ast, typeSymbol,\n                                    context.checker.errorReporter, isExported || isGlobal, true, isAmbient);\n            scopeChain.scope.enter(scopeChain.container, ast, typeSymbol,\n                                    context.checker.errorReporter, isExported || isGlobal, false, isAmbient);\n            modType.symbol = typeSymbol;\n        }\n        else {\n            if (symbol && symbol.declAST && symbol.",
v27504=v27505+"declAST.nodeType != NodeType.ModuleDeclaration) {\n                context.checker.errorReporter.simpleError(moduleDecl, \"Conflicting symbol name for module '\" + modName + \"'\");\n            }\n            typeSymbol = <TypeSymbol>symbol;\n\n            // initialize new private scope for the type\n            var publicEnclosedTypes = typeSymbol.type.getAllEnclosedTypes().publicMembers;\n            var publicEnclosedTypesTable = (publicEnclosedTypes == null) ? new StringHashTable() : publicEnclosedTypes;\n            var enclosedTypes = new ScopedMembers(new DualStringHashTable(publicEnclosedTypesTable, new StringHashTable()));\n\n            var publicEnclosedAmbientTypes = typeSymbol.type.getAllAmbientEnclosedTypes().publicMembers;\n            var publicAmbientEnclosedTypesTable = (publicEnclosedAmbientTypes == null) ? new StringHashTable() : publicEnclosedAmbientTypes;\n            var ambientEnclosedTypes = new ScopedMembers(new DualStringHashTable(publicAmbientEnclosedTypesTable, new StringHashTable()));\n\n            var publicMembers = typeSymbol.type.members.publicMembers;\n            var publicMembersTable = (publicMembers == null) ? new StringHashTable() : publicMembers;\n            var members = new ScopedMembers(new DualStringHashTable(publicMembersTable, new StringHashTable()));\n\n            var publicAmbientMembers = typeSymbol.type.ambientMembers.publicMembers;\n            var publicAmbientMembersTable = (publicAmbientMembers == null) ? new StringHashTable() : publicAmbientMembers;\n            var ambientMembers = new ScopedMembers(new DualStringHashTable(publicAmbientMembersTable, new StringHashTable()));\n\n            modType = new ModuleType(enclosedTypes, ambientEnclosedTypes);\n            if (isEnum) {\n                modType.typeFlags |= TypeFlags.IsEnum;\n            }\n            modType.members = members;\n            modType.ambientMembers = ambientMembers;\n            modType.setHasImplementation();\n            modType.symbol = typeSymbol;\n\n            typeSymbol.addLocation(moduleDecl.minChar);\n            typeSymbol.expansions.push(modType);\n            typeSymbol.expansionsDeclAST.push(moduleDecl);\n\n        }\n        if (context.scopeChain.moduleDecl) {\n            context.scopeChain.moduleDecl.recordNonInterface();\n        }\n        // REVIEW: If multiple disparate module decls for the same module don't agree\n        // in export privileges, how should we handle it?\n        if (isExported) {\n            typeSymbol.flags |= SymbolFlags.Exported;\n        }\n        if ((context.scopeChain.moduleDecl) ||\n            (context.scopeChain.container == context.checker.gloMod)) {\n            typeSymbol.flags |= SymbolFlags.ModuleMember;\n        }\n\n        moduleDecl.mod = modType;\n        pushTypeCollectionScope(typeSymbol, modType.members,\n                                modType.ambientMembers,\n                                modType.enclosedTypes,\n                                modType.ambientEnclosedTypes,\n                                context, null, null, moduleDecl);\n\n        return true;\n    }\n\n    export function preCollectClassTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n        var classDecl = <ClassDeclaration>ast;\n\n        var classType: Type;\n        var instanceType: Type;\n        var typeSymbol: TypeSymbol = null;\n        var className = (<Identifier>classDecl.name).text;\n        var alreadyInScope = false;\n        var isAmbient = hasFlag(classDecl.varFlags, VarFlags.Ambient);\n        var isExported = hasFlag(classDecl.varFlags, VarFlags.Exported);\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\n        var containerMod = <TypeSymbol>scopeChain.container;\n        var foundValSymbol = false;\n\n        typeSymbol = <TypeSymbol>scopeChain.scope.findLocal(className, false, true);\n        \n        // check the value space, since an override may have been declared with the type's name\n        // REVIEW-CLASSES\n        if (!typeSymbol) {\n            var valTypeSymbol = scopeChain.scope.findLocal(className, false, false);\n            \n            if (valTypeSymbol &&\n                valTypeSymbol.isType() &&\n                valTypeSymbol.declAST &&\n                valTypeSymbol.declAST.nodeType == NodeType.FuncDecl &&\n                (<FuncDecl>valTypeSymbol.declAST).isSignature()) {\n                \n                typeSymbol = <TypeSymbol>valTypeSymbol;\n                foundValSymbol = true;\n                \n                if (isExported) {\n                    typeSymbol.flags |= SymbolFlags.Exported;\n                }\n            \n                if (isAmbient) {\n                    typeSymbol.flags |= SymbolFlags.Ambient;\n                }                \n                \n                // the class was never entered into type space, so add it\n                context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol,\n                                            context.checke",
v27503=v27504+"r.errorReporter, isExported || isGlobal, true, isAmbient);                \n            }\n        }\n        \n        if (typeSymbol && !foundValSymbol && (typeSymbol.declAST != classDecl)) {\n            typeSymbol = null;\n        }\n\n        if (typeSymbol == null) {\n            var valueSymbol = scopeChain.scope.findLocal(className, false, false);\n            classType = new Type();\n            classType.setHasImplementation();\n            instanceType = new Type();\n            instanceType.setHasImplementation();\n            classType.instanceType = instanceType;\n            classType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            classType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            addPrototypeField(classType, classDecl, context);\n            instanceType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            instanceType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            typeSymbol = new TypeSymbol(className, classDecl.name.minChar, className.length,\n                                        context.checker.locationInfo.unitIndex, classType);\n            typeSymbol.declAST = classDecl;\n            typeSymbol.instanceType = instanceType;\n            classType.symbol = typeSymbol;\n            instanceType.symbol = typeSymbol;\n\n            if (context.scopeChain.moduleDecl) {\n                context.scopeChain.moduleDecl.recordNonInterface();\n                typeSymbol.declModule = context.scopeChain.moduleDecl;\n                typeSymbol.flags |= SymbolFlags.ModuleMember;\n            }\n\n            if (isExported) {\n                typeSymbol.flags |= SymbolFlags.Exported;\n            }\n            \n            if (isAmbient) {\n                typeSymbol.flags |= SymbolFlags.Ambient;\n            }\n\n            ast.type = classType;\n\n            // class in both name spaces (type for instance type; constructor representative in value space)\n            context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol,\n                                            context.checker.errorReporter, isExported || isGlobal, true, isAmbient);\n\n            if (valueSymbol == null) {\n                context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol,\n                                            context.checker.errorReporter, isExported || isGlobal, false, isAmbient);\n            }\n        }\n        else {                            \n            classType = typeSymbol.type;\n            \n            // If the instance type is null, a call overload was likely declared before the class constructor\n            if (classType.instanceType == null) {\n                classType.instanceType = new Type();\n                classType.instanceType.setHasImplementation();\n                classType.instanceType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                classType.instanceType.symbol = classType.symbol;\n                classType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                classType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            }\n            \n            instanceType = classType.instanceType;\n            ast.type = classType;\n        }\n        \n        // if the class has no declared constructor, either create a default signature or adapt \n        // it's base class's signature group\n        if (!classDecl.constructorDecl) {\n\n            if (typeSymbol && typeSymbol.declAST && typeSymbol.declAST.type && typeSymbol.declAST.type.call && !(<FuncDecl>typeSymbol.declAST).isOverload) {\n                context.checker.errorReporter.duplicateIdentifier(typeSymbol.declAST, typeSymbol.name);\n            }\n\n            createNewConstructGroupForType(classDecl.type);\n        }\n\n        classType.typeFlags |= TypeFlags.IsClass;\n        instanceType.typeFlags |= TypeFlags.IsClass;\n\n        getBases(instanceType, classDecl);\n        pushTypeCollectionScope(typeSymbol, instanceType.members, instanceType.ambientMembers, null, null,\n                                context, instanceType, classType, null);\n        return true;\n    }\n\n    export function preCollectInterfaceTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n        var interfaceDecl = <InterfaceDeclaration>ast;\n        var interfaceSymbol: TypeSymbol = null;\n        var interfaceType: Type = null;\n        var isExported = hasFlag(interfaceDecl.varFlags, VarFlags.Exported);\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\n        var alreadyInScope = true;\n\n        alreadyInScope = false;\n        var ",
v27502=v27503+'interfaceName = (<Identifier>interfaceDecl.name).text;\n        interfaceSymbol = <TypeSymbol>scopeChain.scope.findLocal(interfaceName, false, true);\n        if (interfaceSymbol == null) {\n            interfaceType = new Type();\n            interfaceSymbol = new TypeSymbol(interfaceName,\n                                        interfaceDecl.name.minChar,\n                                        interfaceName.length,\n                                        context.checker.locationInfo.unitIndex,\n                                        interfaceType);\n            interfaceType.symbol = interfaceSymbol;\n            // REVIEW: Shouldn\'t allocate another table for interface privates\n            interfaceType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            interfaceType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            interfaceSymbol.declAST = interfaceDecl;\n            interfaceSymbol.declModule = context.scopeChain.moduleDecl;\n        }\n        else {\n            alreadyInScope = true;\n            interfaceType = interfaceSymbol.type;\n        }\n\n        if (!interfaceType) {\n            interfaceType = context.checker.anyType;\n        }\n\n        ast.type = interfaceType;\n        getBases(interfaceType, interfaceDecl);\n\n        if (isExported) {\n            interfaceSymbol.flags |= SymbolFlags.Exported;\n        }\n\n        if (context.scopeChain.moduleDecl) {\n            interfaceSymbol.flags |= SymbolFlags.ModuleMember;\n        }\n\n        if (!alreadyInScope) {\n            context.scopeChain.scope.enter(context.scopeChain.container, ast,\n                                            interfaceSymbol, context.checker.errorReporter, isGlobal || isExported, true, false); // REVIEW: Technically, interfaces should be ambient\n        }\n        pushTypeCollectionScope(interfaceSymbol, interfaceType.members, interfaceType.ambientMembers, null, null,\n                                context, interfaceType, null, null);\n        return true;\n    }\n\n    export function preCollectArgDeclTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n        var argDecl = <ArgDecl>ast;\n        if (hasFlag(argDecl.varFlags, VarFlags.Public | VarFlags.Private)) {\n            var field = new ValueLocation();\n            var isPrivate = hasFlag(argDecl.varFlags, VarFlags.Private);\n            var fieldSymbol =\n                new FieldSymbol(argDecl.id.text, argDecl.id.minChar,\n                                context.checker.locationInfo.unitIndex,\n                                !hasFlag(argDecl.varFlags, VarFlags.Readonly),\n                                field);\n            fieldSymbol.transferVarFlags(argDecl.varFlags);\n            field.symbol = fieldSymbol;\n            fieldSymbol.declAST = ast;\n            argDecl.parameterPropertySym = fieldSymbol;\n\n            context.scopeChain.scope.enter(context.scopeChain.container, ast,\n                                            fieldSymbol, context.checker.errorReporter, !isPrivate, false, false);\n\n            field.typeLink = getTypeLink(argDecl.typeExpr, context.checker, argDecl.init == null);\n            argDecl.sym = fieldSymbol;\n        }\n        return false;\n    }\n\n    export function preCollectVarDeclTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n        var varDecl = <VarDecl>ast;\n        var isAmbient = hasFlag(varDecl.varFlags, VarFlags.Ambient);\n        var isExported = hasFlag(varDecl.varFlags, VarFlags.Exported);\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\n        var isProperty = hasFlag(varDecl.varFlags, VarFlags.Property);\n        var isStatic = hasFlag(varDecl.varFlags, VarFlags.Static);\n        var isPrivate = hasFlag(varDecl.varFlags, VarFlags.Private);\n        var isOptional = hasFlag(varDecl.id.flags, ASTFlags.OptionalName);\n\n        if (context.scopeChain.moduleDecl) {\n            context.scopeChain.moduleDecl.recordNonInterface();\n        }\n        if (isProperty ||\n            isExported ||\n            (context.scopeChain.container == context.checker.gloMod) ||\n            context.scopeChain.moduleDecl) {\n            if (isAmbient) {\n                var existingSym =\n                    <FieldSymbol>scopeChain.scope.findLocal(varDecl.id.text, false, false);\n                if (existingSym) {\n                    varDecl.sym = existingSym;\n                    return false;\n                }\n            }\n\n            // Defensive error detection...\n            if (varDecl.id == null) {\n                context.checker.errorReporter.simpleError(varDecl, "Expected variable identifier at this location");\n                return false;\n            }\n\n            var field = new ValueLocation();\n            var fieldSymbol =\n                new FieldSymbol(varDecl.id.text, varDecl.id.minChar,\n         ',
v27501=v27502+'                       context.checker.locationInfo.unitIndex,\n                                (varDecl.varFlags & VarFlags.Readonly) == VarFlags.None,\n                                field);\n            fieldSymbol.transferVarFlags(varDecl.varFlags);\n            if (isOptional) {\n                fieldSymbol.flags |= SymbolFlags.Optional;\n            }\n            field.symbol = fieldSymbol;\n            fieldSymbol.declAST = ast;\n            if ((context.scopeChain.moduleDecl) ||\n                (context.scopeChain.container == context.checker.gloMod)) {\n                fieldSymbol.flags |= SymbolFlags.ModuleMember;\n                fieldSymbol.declModule = context.scopeChain.moduleDecl;\n            }\n\n            // if it\'s static, enter it into the class\'s member list directly\n            if (hasFlag(varDecl.varFlags, VarFlags.Property) && isStatic && context.scopeChain.classType) {\n                if (!context.scopeChain.classType.members.publicMembers.add(varDecl.id.text, fieldSymbol)) {\n                    context.checker.errorReporter.duplicateIdentifier(ast, fieldSymbol.name);\n                }\n                fieldSymbol.container = context.scopeChain.classType.symbol;\n            }\n            else {\n                context.scopeChain.scope.enter(context.scopeChain.container,\n                                                ast,\n                                                fieldSymbol,\n                                                context.checker.errorReporter,\n                                                !isPrivate && (isProperty || isExported || isGlobal || isStatic),\n                                                false,\n                                                isAmbient);\n            }\n\n            if (hasFlag(varDecl.varFlags, VarFlags.Exported)) {\n                fieldSymbol.flags |= SymbolFlags.Exported;\n            }\n\n            field.typeLink = getTypeLink(varDecl.typeExpr, context.checker,\n                                        varDecl.init == null);\n            varDecl.sym = fieldSymbol;\n        }\n        return false;\n    }\n\n    export function preCollectFuncDeclTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n\n        // REVIEW: This will have to change when we move to "export"\n        if (context.scopeChain.moduleDecl) {\n            context.scopeChain.moduleDecl.recordNonInterface();\n        }\n\n        var funcDecl = <FuncDecl>ast;\n        var fgSym: TypeSymbol = null;\n        var nameText = funcDecl.getNameText();\n        var isExported = hasFlag(funcDecl.fncFlags, FncFlags.Exported | FncFlags.ClassPropertyMethodExported);\n        var isStatic = hasFlag(funcDecl.fncFlags, FncFlags.Static);\n        var isPrivate = hasFlag(funcDecl.fncFlags, FncFlags.Private);\n        var isConstructor = funcDecl.isConstructMember() || funcDecl.isConstructor;\n        var containerSym:TypeSymbol = <TypeSymbol> (((funcDecl.isMethod() && isStatic) || funcDecl.isAccessor()) && context.scopeChain.classType ? context.scopeChain.classType.symbol : context.scopeChain.container);\n        var containerScope: SymbolScope = context.scopeChain.scope;\n        var isGlobal = containerSym == context.checker.gloMod;\n        var isOptional = funcDecl.name && hasFlag(funcDecl.name.flags, ASTFlags.OptionalName);\n        var go = false;\n        var foundSymbol = false; \n\n        // If this is a class constructor, the "container" is actually the class declaration\n        if (isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {\n            containerSym = <TypeSymbol>containerSym.container;\n            containerScope = scopeChain.previous.scope;\n        }\n\n        funcDecl.unitIndex = context.checker.locationInfo.unitIndex;\n        \n        // If the parent is the constructor, and this isn\'t an instance method, skip it.\n        // That way, we\'ll set the type during scope assignment, and can be sure that the\n        // function will be placed in the constructor-local scope\n        if (!funcDecl.isConstructor &&\n            containerSym &&\n            containerSym.declAST &&\n            containerSym.declAST.nodeType == NodeType.FuncDecl &&\n            (<FuncDecl>containerSym.declAST).isConstructor &&\n            !funcDecl.isMethod()) {\n            return go;\n        }        \n\n        // Interfaces and overloads\n        if (hasFlag(funcDecl.fncFlags, FncFlags.Signature)) {\n            var instType = context.scopeChain.thisType;                       \n\n            // If the function is static, search in the class type\'s\n            if (nameText && nameText != "__missing") {\n                if (isStatic) {\n                    fgSym = containerSym.type.members.allMembers.lookup(nameText);\n                }\n                else {\n                    // REVIEW: This logic should be symmetric with preCollectClassTypes\n                    fgSym = <TypeSymbol>containerScope.findLocal(nameText, false, false);\n                    \n                 ',
v27500=v27501+"   // If we could not find the function symbol in the value context, look\n                    // in the type context.\n                    // This would be the case, for example, if a class constructor override\n                    // were declared before a call override for a given class\n                    if (fgSym == null) {\n                        fgSym = <TypeSymbol>containerScope.findLocal(nameText, false, true);\n                    }\n                }\n                \n                if (fgSym) {\n                    foundSymbol = true;\n                    \n                    // We'll combine ambient and non-ambient funcdecls during typecheck (for contextual typing).,\n                    // So, if they don't agree, don't use the symbol we've found                    \n                    if (!funcDecl.isSignature() && (hasFlag(funcDecl.fncFlags, FncFlags.Ambient) != hasFlag(fgSym.flags, SymbolFlags.Ambient))) {\n                       fgSym = null;\n                    }\n                }                \n            }\n            \n            // a function with this symbol has not yet been declared in this scope\n            // REVIEW: In the code below, we need to ensure that only function overloads are considered\n            //  (E.g., if a vardecl has the same id as a function or class, we may use the vardecl symbol\n            //  as the overload.)  Defensively, however, the vardecl won't have a type yet, so it should\n            //  suffice to just check for a null type when considering the overload symbol in\n            //  createFunctionSignature\n            if (fgSym == null) {\n                if (!(funcDecl.isSpecialFn())) {                    \n                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, null, !foundSymbol).declAST.type.symbol;\n                }\n                else {\n                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, containerSym, false).declAST.type.symbol;                                                                         \n                }\n                \n                // set the symbol's declAST, which will point back to the first declaration (symbol or otherwise)\n                // related to this symbol\n                if (fgSym.declAST == null || !funcDecl.isSpecialFn()) {\n                    fgSym.declAST = ast;\n                }\n            }\n            else { // there exists a symbol with this name\n                \n                if ((fgSym.kind() == SymbolKind.Type)) {\n\n                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, fgSym, false).declAST.type.symbol;\n                }\n                else {\n                    context.checker.errorReporter.simpleError(funcDecl, \"Function or method '\" + funcDecl.name.actualText + \"' already declared as a property\");\n                }\n            }\n         \n            if (funcDecl.isSpecialFn() && !isStatic) {\n                funcDecl.type = instType ? instType : fgSym.type; \n            }\n            else {\n                funcDecl.type = fgSym.type;\n            }            \n        }\n        else {\n            // declarations\n            \n            if (nameText) {\n                if (isStatic) {\n                    fgSym = containerSym.type.members.allMembers.lookup(nameText);\n                }\n                else {\n                    // in the constructor case, we want to check the parent scope for overloads\n                    if (funcDecl.isConstructor && context.scopeChain.previous) {\n                        fgSym = <TypeSymbol>context.scopeChain.previous.scope.findLocal(nameText, false, false);\n                    }\n                    \n                    if (fgSym == null) {\n                        fgSym = <TypeSymbol>containerScope.findLocal(nameText, false, false);\n                    }\n                }\n                if (fgSym) {\n                    foundSymbol = true;\n                    \n                    if (!isConstructor && fgSym.declAST.nodeType == NodeType.FuncDecl && !(<FuncDecl>fgSym.declAST).isAccessor() && !(<FuncDecl>fgSym.declAST).isSignature()) {\n                        fgSym = null;\n                        foundSymbol = false;\n                    }\n                }                \n            }\n\n            // REVIEW: Move this check into the typecheck phase?  It's only being run over properties...\n            if (fgSym &&\n                !fgSym.isAccessor() &&\n                fgSym.type &&\n                fgSym.type.construct &&\n                fgSym.type.construct.signatures != [] &&\n                (fgSym.type.construct.signatures[0].declAST == null ||\n                    !hasFlag(fgSym.type.construct.signatures[0].declAST.fncFlags, FncFlags.Ambient)) &&\n                !funcDecl.isConstructor) {\n                context.checker.errorReporter.simpleError(funcDecl, \"Functions may not have class overloads\");\n            }\n\n   ",
v27499=v27500+'         if (fgSym && !(fgSym.kind() == SymbolKind.Type) && funcDecl.isMethod() && !funcDecl.isAccessor() && !funcDecl.isConstructor) {\n                context.checker.errorReporter.simpleError(funcDecl, "Function or method \'" + funcDecl.name.actualText + "\' already declared as a property");\n                fgSym.type = context.checker.anyType;\n            }\n            var sig = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, fgSym, !foundSymbol);\n\n            // it\'s a getter or setter function                                   \n            if (((!fgSym || fgSym.declAST.nodeType != NodeType.FuncDecl) && funcDecl.isAccessor()) || (fgSym && fgSym.isAccessor())) {\n                funcDecl.accessorSymbol = context.checker.createAccessorSymbol(funcDecl, fgSym, containerSym.type, (funcDecl.isMethod() && isStatic), true, containerScope, containerSym);\n            }\n\n            funcDecl.type.symbol.declAST = ast;\n            if (funcDecl.isConstructor) { // REVIEW: Remove when classes completely replace oldclass\n                go = true;\n            };\n        }\n        if (isExported) {\n            if (funcDecl.type.call) {\n                funcDecl.type.symbol.flags |= SymbolFlags.Exported;\n            }\n            \n            // Accessors are set to \'exported\' above\n            if (fgSym && !fgSym.isAccessor() && fgSym.kind() == SymbolKind.Type && fgSym.type.call) {\n                fgSym.flags |= SymbolFlags.Exported;\n            }\n        }\n        if (context.scopeChain.moduleDecl && !funcDecl.isSpecialFn()) {\n            funcDecl.type.symbol.flags |= SymbolFlags.ModuleMember;\n            funcDecl.type.symbol.declModule = context.scopeChain.moduleDecl;\n        }\n\n        if (fgSym && isOptional) {\n            fgSym.flags |= SymbolFlags.Optional;\n        }\n\n        return go;\n    }\n\n    export function preCollectTypes(ast: AST, parent: AST, walker: IAstWalker) {\n        var context: TypeCollectionContext = walker.state;\n        var go = false;\n        var scopeChain = context.scopeChain;\n\n        if (ast.nodeType == NodeType.Script) {\n            var script: Script = <Script>ast;\n            context.script = script;\n            go = true;\n        }\n        else if (ast.nodeType == NodeType.List) {\n            go = true;\n        }\n        else if (ast.nodeType == NodeType.ImportDeclaration) {\n            go = preCollectImportTypes(ast, parent, context);\n        }\n        else if (ast.nodeType == NodeType.With) {\n            go = false;\n        }\n        else if (ast.nodeType == NodeType.ModuleDeclaration) {\n            go = preCollectModuleTypes(ast, parent, context);\n        }\n        else if (ast.nodeType == NodeType.ClassDeclaration) {\n            go = preCollectClassTypes(ast, parent, context);\n        }\n        else if (ast.nodeType == NodeType.Block) {\n            go = true;\n        }\n        else if (ast.nodeType == NodeType.InterfaceDeclaration) {\n            go = preCollectInterfaceTypes(ast, parent, context);\n        }\n        // This will be a constructor arg because this pass only traverses\n        // constructor arg lists\n        else if (ast.nodeType == NodeType.ArgDecl) {\n            go = preCollectArgDeclTypes(ast, parent, context);\n        }\n        else if (ast.nodeType == NodeType.VarDecl) {\n            go = preCollectVarDeclTypes(ast, parent, context);\n        }\n        else if (ast.nodeType == NodeType.FuncDecl) {\n            go = preCollectFuncDeclTypes(ast, parent, context);\n        }\n        else {\n            if (ast.isStatementOrExpression() && context.scopeChain.moduleDecl) {\n                context.scopeChain.moduleDecl.recordNonInterface();\n            }\n        }\n        walker.options.goChildren = go;\n        return ast;\n    }\n\n    export function postCollectTypes(ast: AST, parent: AST, walker: IAstWalker) {\n        var context: TypeCollectionContext = walker.state;\n\n        if (ast.nodeType == NodeType.ModuleDeclaration) {\n            popTypeCollectionScope(context);\n        }\n        else if (ast.nodeType == NodeType.ClassDeclaration) {\n            popTypeCollectionScope(context);\n        }\n        else if (ast.nodeType == NodeType.InterfaceDeclaration) {\n            popTypeCollectionScope(context);\n        }\n        return ast;\n    }\n\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class ScopeChain {\n        ',
v27498=v27499+"public thisType: Type;\n        public classType: Type;\n        public fnc: FuncDecl;\n        public moduleDecl: ModuleDeclaration;\n\n        constructor (public container: Symbol, public previous: ScopeChain,\n                     public scope: SymbolScope) { }\n    }\n\n    export class BBUseDefInfo {\n        public defsBySymbol = new bool[];\n        public gen: BitVector;\n        public kill: BitVector;\n        public top: BitVector;\n        // use lists by symbol \n        public useIndexBySymbol = new number[][];\n\n        constructor (public bb: BasicBlock) { }\n\n        public updateTop() {\n            var temp = new BitVector(this.top.bitCount);\n            for (var i = 0, succLen = this.bb.successors.length; i < succLen; i++) {\n                var succ = this.bb.successors[i];\n                if (succ.useDef) {\n                    temp.union(succ.useDef.top);\n                }\n            }\n            temp.difference(this.kill);\n            temp.union(this.gen);\n            var changed = temp.notEq(this.top);\n            this.top = temp;\n            return changed;\n        }\n\n\n        public initialize(useDefContext: UseDefContext) {\n            var defSym = (sym: Symbol, context: UseDefContext) => {\n                if (context.isLocalSym(sym)) {\n                    var index = context.getSymbolIndex(sym);\n                    // clear pending uses\n                    this.useIndexBySymbol[index] = new number[];\n                    this.defsBySymbol[index] = true;\n                }\n            }\n\n            var useSym = (sym: Symbol, context: UseDefContext, ast: AST) => {\n                if (context.isLocalSym(sym)) {\n                    var symIndex = context.getSymbolIndex(sym);\n                    if (this.useIndexBySymbol[symIndex] == undefined) {\n                        this.useIndexBySymbol[symIndex] = new number[];\n                    }\n                    var symUses = this.useIndexBySymbol[symIndex];\n                    var astIndex = context.getUseIndex(ast);\n                    context.addUse(symIndex, astIndex);\n                    symUses.push(astIndex);\n                }\n            }\n\n            function initUseDefPre(cur: AST, parent: AST, walker: IAstWalker) {\n                var context: UseDefContext = walker.state;\n                if (cur == null) {\n                    cur = null;\n                }\n                if (cur.nodeType == NodeType.VarDecl) {\n                    var varDecl = <BoundDecl>cur;\n                    if (varDecl.init || hasFlag(varDecl.varFlags, VarFlags.AutoInit)) {\n                        defSym(varDecl.sym, context);\n                    }\n                }\n                else if (cur.nodeType == NodeType.Name) {\n                    // use\n                    if (parent) {\n                        if (parent.nodeType == NodeType.Asg) {\n                            var asg = <BinaryExpression>parent;\n                            if (asg.operand1 == cur) {\n                                return cur;\n                            }\n                        }\n                        else if (parent.nodeType == NodeType.VarDecl) {\n                            var parentDecl = <BoundDecl>parent;\n                            if (parentDecl.id == cur) {\n                                return cur;\n                            }\n                        }\n                    }\n                    var id = <Identifier>cur;\n                    useSym(id.sym, context, cur);\n                }\n                else if ((cur.nodeType >= NodeType.Asg) && (cur.nodeType <= NodeType.LastAsg)) {\n                    // def\n                    var asg = <BinaryExpression>cur;\n                    if (asg.operand1 && (asg.operand1.nodeType == NodeType.Name)) {\n                        var id = <Identifier>asg.operand1;\n                        defSym(id.sym, context);\n                    }\n                }\n                else if (cur.nodeType == NodeType.FuncDecl) {\n                    walker.options.goChildren = false;\n                }\n\n                return cur;\n            }\n\n            var options = new AstWalkOptions();\n            // traverse ASTs in reverse order of execution (to match uses with preceding defs)\n            options.reverseSiblings = true;\n\n            getAstWalkerFactory().walk(this.bb.content, initUseDefPre, null, options, useDefContext);\n        }\n\n        public initializeGen(useDefContext: UseDefContext) {\n            var symbolLen = this.useIndexBySymbol.length;\n            var bitCount = useDefContext.uses.length;\n            this.gen = new BitVector(bitCount);\n            for (var s = 0; s < symbolLen; s++) {\n                var symUses = this.useIndexBySymbol[s];\n                if ((symUses != undefined) && (symUses.length > 0)) {\n                    for (var u = 0, uLen = symUses.length; u < uLen; u++) {\n                        this.gen.set(symUses[u], true);\n                    }\n                }\n            }\n            this.top = this.gen;\n        }\n\n     ",
v27497=v27498+"   public initializeKill(useDefContext: UseDefContext) {\n            this.kill = new BitVector(this.gen.bitCount);\n            for (var s = 0, symbolLen = this.defsBySymbol.length; s < symbolLen; s++) {\n                if (this.defsBySymbol[s]) {\n                    var globalSymUses = useDefContext.useIndexBySymbol[s];\n                    if (globalSymUses) {\n                        for (var u = 0, useLen = globalSymUses.length; u < useLen; u++) {\n                            this.kill.set(globalSymUses[u], true);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    export class UseDefContext {\n        // global use lists by symbol\n        public useIndexBySymbol = new number[][];\n        // global list of uses (flat)\n        public uses = new AST[];\n        public symbols = new VariableSymbol[];\n        public symbolMap = new StringHashTable();\n        public symbolCount = 0;\n        public func: Symbol;\n\n        constructor () {\n        }\n\n        public getSymbolIndex(sym: Symbol) {\n            var name = sym.name;\n            var index = <number>(this.symbolMap.lookup(name));\n            if (index == null) {\n                index = this.symbolCount++;\n                this.symbols[index] = <VariableSymbol>sym;\n                this.symbolMap.add(name, index);\n            }\n            return index;\n        }\n\n        public addUse(symIndex: number, astIndex: number) {\n            var useBySym = this.useIndexBySymbol[symIndex];\n            if (useBySym == undefined) {\n                useBySym = new number[];\n                this.useIndexBySymbol[symIndex] = useBySym;\n            }\n            useBySym[useBySym.length] = astIndex;\n        }\n\n        public getUseIndex(ast: AST) {\n            this.uses[this.uses.length] = ast;\n            return this.uses.length - 1;\n        }\n\n        public isLocalSym(sym: Symbol) { return (sym && (sym.container == this.func) && (sym.kind() == SymbolKind.Variable)); }\n\n        public killSymbol(sym: VariableSymbol, bbUses: BitVector) {\n            var index: number = this.symbolMap.lookup(sym.name);\n            var usesOfSym = this.useIndexBySymbol[index];\n            for (var k = 0, len = usesOfSym.length; k < len; k++) {\n                bbUses.set(usesOfSym[k], true);\n            }\n        }\n    }\n\n    export class BitVector {\n        static packBits = 30;\n        public firstBits = 0;\n        public restOfBits: number[] = null;\n\n        constructor (public bitCount: number) {\n            if (this.bitCount > BitVector.packBits) {\n                this.restOfBits = new number[];\n                var len = Math.floor(this.bitCount / BitVector.packBits);\n                for (var i = 0; i < len; i++) {\n                    this.restOfBits[i] = 0;\n                }\n            }\n        }\n\n        public set(bitIndex: number, value: bool) {\n            if (bitIndex < BitVector.packBits) {\n                if (value) {\n                    this.firstBits |= (1 << bitIndex);\n                }\n                else {\n                    this.firstBits &= (~(1 << bitIndex));\n                }\n            }\n            else {\n                var offset = Math.floor(bitIndex / BitVector.packBits) - 1;\n                var localIndex = bitIndex % BitVector.packBits;\n                if (value) {\n                    this.restOfBits[offset] |= (1 << localIndex);\n                }\n                else {\n                    this.restOfBits[offset] &= (~(1 << localIndex));\n                }\n            }\n        }\n\n        public map(fn: (index: number) =>any) {\n            var k: number;\n            for (k = 0; k < BitVector.packBits; k++) {\n                if (k == this.bitCount) {\n                    return;\n                }\n                if (((1 << k) & this.firstBits) != 0) {\n                    fn(k);\n                }\n            }\n            if (this.restOfBits) {\n                var len: number;\n                var cumu = BitVector.packBits;\n                for (k = 0, len = this.restOfBits.length; k < len; k++) {\n                    var myBits = this.restOfBits[k];\n                    for (var j = 0; j < BitVector.packBits; j++) {\n                        if (((1 << j) & myBits) != 0) {\n                            fn(cumu);\n                        }\n                        cumu++;\n                        if (cumu == this.bitCount) {\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n\n        // assume conforming sizes\n        public union(b: BitVector) {\n            this.firstBits |= b.firstBits;\n            if (this.restOfBits) {\n                for (var k = 0, len = this.restOfBits.length; k < len; k++) {\n                    var myBits = this.restOfBits[k];\n                    var bBits = b.restOfBits[k];\n                    this.restOfBits[k] = myBits | bBits;\n                }\n            }\n        }\n\n        // assume conforming sizes\n        public interse",
v27496=v27497+'ction(b: BitVector) {\n            this.firstBits &= b.firstBits;\n            if (this.restOfBits) {\n                for (var k = 0, len = this.restOfBits.length; k < len; k++) {\n                    var myBits = this.restOfBits[k];\n                    var bBits = b.restOfBits[k];\n                    this.restOfBits[k] = myBits & bBits;\n                }\n            }\n        }\n\n        // assume conforming sizes\n        public notEq(b: BitVector) {\n            if (this.firstBits != b.firstBits) {\n                return true;\n            }\n            if (this.restOfBits) {\n                for (var k = 0, len = this.restOfBits.length; k < len; k++) {\n                    var myBits = this.restOfBits[k];\n                    var bBits = b.restOfBits[k];\n                    if (myBits != bBits) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        public difference(b: BitVector) {\n            var oldFirstBits = this.firstBits;\n            this.firstBits &= (~b.firstBits);\n            if (this.restOfBits) {\n                for (var k = 0, len = this.restOfBits.length; k < len; k++) {\n                    var myBits = this.restOfBits[k];\n                    var bBits = b.restOfBits[k];\n                    this.restOfBits[k] &= (~bBits);\n                }\n            }\n        }\n    }\n\n    export class BasicBlock {\n        // blocks that branch to the block after this one\n        public predecessors = new BasicBlock[];\n        public index = -1;\n        public markValue = 0;\n        public marked(markBase: number) { return this.markValue > markBase; }\n        public mark() {\n            this.markValue++;\n        }\n        public successors = new BasicBlock[];\n        public useDef: BBUseDefInfo = null;\n        public content = new ASTList();\n        public addSuccessor(successor: BasicBlock): void {\n            this.successors[this.successors.length] = successor;\n            successor.predecessors[successor.predecessors.length] = this;\n        }\n    }\n\n    export interface ITargetInfo {\n        stmt: AST;\n        continueBB: BasicBlock;\n        breakBB: BasicBlock;\n    }\n\n    export class ControlFlowContext {\n        public entry = null;\n        // first unreachable ast for each unreachable code segment\n        public unreachable: AST[] = null;\n        public noContinuation = false;\n        // statements enclosing the current statement\n        public statementStack = new ITargetInfo[];\n        public currentSwitch = new BasicBlock[];\n        public walker: IAstWalker;\n\n        constructor (public current: BasicBlock,\n                     public exit: BasicBlock) {\n            this.entry = this.current;\n        }\n\n        public walk(ast: AST, parent: AST) {\n            return this.walker.walk(ast, parent);\n        }\n\n        public pushSwitch(bb: BasicBlock) {\n            this.currentSwitch.push(bb);\n        }\n\n        public popSwitch() {\n            return this.currentSwitch.pop();\n        }\n\n        public reportUnreachable(er: ErrorReporter) {\n            if (this.unreachable && (this.unreachable.length > 0)) {\n                var len = this.unreachable.length;\n                for (var i = 0; i < len; i++) {\n                    var unreachableAST = this.unreachable[i];\n                    if (unreachableAST.nodeType != NodeType.EndCode) {\n                        er.simpleError(unreachableAST, "unreachable code");\n                    }\n                }\n            }\n        }\n\n        private printAST(ast: AST, outfile: ITextWriter) {\n            var printContext = new PrintContext(outfile, null);\n\n            printContext.increaseIndent();\n            //ast.walk(prePrintAST, postPrintAST, null, printContext);\n            getAstWalkerFactory().walk(ast, prePrintAST, postPrintAST, null, printContext);\n\n            printContext.decreaseIndent();\n        }\n\n        private printBlockContent(bb: BasicBlock, outfile: ITextWriter) {\n            var content = bb.content;\n            for (var i = 0, len = content.members.length; i < len; i++) {\n                var ast = content.members[i];\n                this.printAST(ast, outfile);\n            }\n        }\n\n        public markBase = 0;\n\n        public bfs(nodeFunc: (bb: BasicBlock) =>void , edgeFunc: (node1: BasicBlock, node2: BasicBlock) =>void ,\n            preEdges: () =>void , postEdges: () =>void ) {\n            var markValue = this.markBase++;\n            var q = new BasicBlock[];\n            q[q.length] = this.entry;\n\n            while (q.length > 0) {\n                var bb = q.pop();\n                if (!(bb.marked(markValue))) {\n                    bb.mark();\n                    if (nodeFunc) {\n                        nodeFunc(bb);\n                    }\n                    var succLen = bb.successors.length;\n                    if (succLen > 0) {\n                        if (preEdges) {\n                            preEdges();\n                        }\n                        for',
v27495=v27496+' (var j = succLen - 1; j >= 0; j--) {\n                            var successor = bb.successors[j];\n                            if (!(successor.marked(this.markBase))) {\n                                if (edgeFunc) {\n                                    edgeFunc(bb, successor);\n                                }\n                                q[q.length] = successor;\n                            }\n                        }\n                        if (postEdges) {\n                            postEdges();\n                        }\n                    }\n                }\n            }\n        }\n\n        public linearBBs = new BasicBlock[];\n\n        public useDef(er: ErrorReporter, funcSym: Symbol) {\n            var useDefContext = new UseDefContext();\n            useDefContext.func = funcSym;\n            var useDefInit = (bb: BasicBlock) => {\n                bb.useDef = new BBUseDefInfo(bb);\n                bb.useDef.initialize(useDefContext);\n                this.linearBBs[this.linearBBs.length] = bb;\n            }\n            this.bfs(useDefInit, null, null, null);\n            var i: number, bbLen: number;\n            for (i = 0, bbLen = this.linearBBs.length; i < bbLen; i++) {\n                this.linearBBs[i].useDef.initializeGen(useDefContext);\n                this.linearBBs[i].useDef.initializeKill(useDefContext);\n            }\n            var changed = true;\n\n            while (changed) {\n                changed = false;\n                for (i = 0; i < bbLen; i++) {\n                    changed = this.linearBBs[i].useDef.updateTop() || changed;\n                }\n            }\n\n            var top = this.entry.useDef.top;\n            top.map((index) => {\n                var ast = <Identifier>useDefContext.uses[<number>index];\n                er.simpleError(ast, "use of variable \'" + ast.actualText + "\' that is not definitely assigned");\n            });\n        }\n\n        public print(outfile: ITextWriter) {\n            var index = 0;\n            var node = (bb: BasicBlock) => {\n                if (bb.index < 0) {\n                    bb.index = index++;\n                }\n                if (bb == this.exit) {\n                    outfile.WriteLine("Exit block with index " + bb.index);\n                }\n                else {\n                    outfile.WriteLine("Basic block with index " + bb.index);\n                    this.printBlockContent(bb, outfile);\n                }\n            }\n\n            function preEdges() {\n                outfile.Write("  Branches to ");\n            }\n\n            function postEdges() {\n                outfile.WriteLine("");\n            }\n\n            function edge(node1: BasicBlock, node2: BasicBlock) {\n                if (node2.index < 0) {\n                    node2.index = index++;\n                }\n                outfile.Write(node2.index + " ");\n            }\n\n            this.bfs(node, edge, preEdges, postEdges);\n            if (this.unreachable != null) {\n                for (var i = 0, len = this.unreachable.length; i < len; i++) {\n                    outfile.WriteLine("Unreachable basic block ...");\n                    this.printAST(this.unreachable[i], outfile);\n                }\n            }\n        }\n\n        public pushStatement(stmt: Statement, continueBB: BasicBlock, breakBB: BasicBlock) {\n            this.statementStack.push({ stmt: stmt, continueBB: continueBB, breakBB: breakBB });\n        }\n\n        public popStatement() { return this.statementStack.pop(); }\n\n        public returnStmt() {\n            // TODO: make successor finally block if return stmt inside of try/finally \n            this.current.addSuccessor(this.exit);\n            this.setUnreachable();\n        }\n\n        public setUnreachable() {\n            this.current = null;\n            this.noContinuation = true;\n        }\n\n        public addUnreachable(ast: AST) {\n            if (this.unreachable === null) {\n                this.unreachable = new AST[];\n            }\n            this.unreachable[this.unreachable.length] = ast;\n        }\n\n        public unconditionalBranch(target: AST, isContinue: bool) {\n            var targetBB = null;\n            for (var i = 0, len = this.statementStack.length; i < len; i++) {\n                var targetInfo = this.statementStack[i];\n                if (targetInfo.stmt == target) {\n                    if (isContinue) {\n                        targetBB = targetInfo.continueBB;\n                    }\n                    else {\n                        targetBB = targetInfo.breakBB;\n                    }\n                    break;\n                }\n            }\n            if (targetBB) {\n                this.current.addSuccessor(targetBB);\n            }\n            this.setUnreachable();\n        }\n\n        public addContent(ast: AST): void {\n            if (this.current) {\n                this.current.content.append(ast);\n            }\n        }\n    }\n\n    export interface IResolutionData {\n        actuals: Type[];\n        exactCandidates: Signature[];\n        c',
v27494=v27495+'onversionCandidates: Signature[];\n        id: number;\n    }\n\n    export class ResolutionDataCache {\n        public cacheSize = 16;\n        public rdCache: IResolutionData[] = [];\n        public nextUp: number = 0;\n\n        constructor () {\n            for (var i = 0; i < this.cacheSize; i++) {\n                this.rdCache[i] = {\n                    actuals: new Type[],\n                    exactCandidates: new Signature[],\n                    conversionCandidates: new Signature[],\n                    id: i\n                };\n            }\n        }\n\n        public getResolutionData(): IResolutionData {\n            var rd: IResolutionData = null;\n\n            if (this.nextUp < this.cacheSize) {\n                rd = this.rdCache[this.nextUp];\n            }\n\n            if (rd == null) {\n                this.cacheSize++;\n                rd = {\n                    actuals: new Type[],\n                    exactCandidates: new Signature[],\n                    conversionCandidates: new Signature[],\n                    id: this.cacheSize\n                };\n                this.rdCache[this.cacheSize] = rd;\n            }\n\n            // cache operates as a stack - RD is always served up in-order\n            this.nextUp++;\n\n            return rd;\n        }\n\n        public returnResolutionData(rd: IResolutionData) {\n            // Pop to save on array allocations, which are a bottleneck\n            // REVIEW: On some VMs, Array.pop doesn\'t always pop the last value in the array\n            rd.actuals.length = 0;\n            rd.exactCandidates.length = 0;\n            rd.conversionCandidates.length = 0;\n\n            this.nextUp = rd.id;\n        }\n    }\n\n    export class TypeFlow {\n        public scope: SymbolScope;\n        public globalScope: SymbolScope;\n\n        public thisType: Type;\n        public thisFnc: FuncDecl = null;\n        public thisClassNode: TypeDeclaration = null;\n        public enclosingFncIsMethod = false;\n\n        // REVIEW: Prune in favor of typechecker fields\n        public doubleType: Type;\n        public booleanType: Type;\n        public stringType: Type;\n        public anyType: Type;\n        public regexType: Type;\n        public nullType: Type;\n        public voidType: Type;\n        public arrayAnyType: Type;\n\n        public arrayInterfaceType: Type = null;\n        public stringInterfaceType: Type = null;\n        public objectInterfaceType: Type = null;\n        public functionInterfaceType: Type = null;\n        public numberInterfaceType: Type = null;\n        public booleanInterfaceType: Type = null;\n        public iargumentsInterfaceType: Type = null;\n\n        public currentScript: Script = null;\n\n        public inImportTypeCheck = false;\n        public inTypeRefTypeCheck = false;\n        public inArrayElementTypeCheck = false;\n        public resolutionDataCache = new ResolutionDataCache();\n        public nestingLevel = 0;\n        public inSuperCall = false;\n\n        constructor (public logger: ILogger, public initScope: SymbolScope, public parser: Parser,\n                   public checker: TypeChecker) {\n            this.checker.typeFlow = this;\n            this.scope = this.initScope;\n            this.globalScope = this.initScope;\n            this.doubleType = this.checker.numberType;\n            this.booleanType = this.checker.booleanType;\n            this.stringType = this.checker.stringType;\n            this.anyType = this.checker.anyType;\n            this.regexType = this.anyType;\n            this.nullType = this.checker.nullType;\n            this.voidType = this.checker.voidType;\n            this.arrayAnyType = this.checker.makeArrayType(this.anyType);\n        }\n\n        public initLibs() {\n            var arraySym = this.globalScope.find("Array", false, true);\n            if (arraySym && (arraySym.kind() == SymbolKind.Type)) {\n                this.arrayInterfaceType = (<TypeSymbol>arraySym).type;\n            }\n            var stringSym = this.globalScope.find("String", false, true);\n            if (stringSym && (stringSym.kind() == SymbolKind.Type)) {\n                this.stringInterfaceType = (<TypeSymbol>stringSym).type;\n            }\n            var objectSym = this.globalScope.find("Object", false, true);\n            if (objectSym && (objectSym.kind() == SymbolKind.Type)) {\n                this.objectInterfaceType = (<TypeSymbol>objectSym).type;\n            }\n            var fnSym = this.globalScope.find("Function", false, true);\n            if (fnSym && (fnSym.kind() == SymbolKind.Type)) {\n                this.functionInterfaceType = (<TypeSymbol>fnSym).type;\n            }\n            var numberSym = this.globalScope.find("Number", false, true);\n            if (numberSym && (numberSym.kind() == SymbolKind.Type)) {\n                this.numberInterfaceType = (<TypeSymbol>numberSym).type;\n            }\n            var booleanSym = this.globalScope.find("Boolean", false, true);\n            if (booleanSym && (booleanSym.kind() == SymbolKind.Type)) {\n                this.booleanInterfaceT',
v27493=v27494+'ype = (<TypeSymbol>booleanSym).type;\n            }\n            var regexSym = this.globalScope.find("RegExp", false, true);\n            if (regexSym && (regexSym.kind() == SymbolKind.Type)) {\n                this.regexType = (<TypeSymbol>regexSym).type;\n            }\n        }\n\n        public cast(ast: AST, type: Type): AST {\n            return this.castWithCoercion(ast, type, true, false);\n        }\n\n        public castWithCoercion(ast: AST, type: Type, applyCoercion: bool, typeAssertion: bool): AST {\n            var comparisonInfo = new TypeComparisonInfo();\n            if (this.checker.sourceIsAssignableToTarget(ast.type, type, comparisonInfo) || (typeAssertion && this.checker.sourceIsAssignableToTarget(type, ast.type, comparisonInfo))) {\n                if (applyCoercion) {\n                    if (type == null) {\n                        ast.type = this.anyType;\n                    }\n                    else if (type.isClass()) {\n                        ast.type = type.instanceType;\n                    }\n                    else {\n                        ast.type = type;\n                    }\n                }\n                return ast;\n            }\n            else {\n                this.checker.errorReporter.incompatibleTypes(ast, ast.type, type, null, this.scope, comparisonInfo);\n                return ast;\n            }\n        }\n\n        public inScopeTypeCheck(ast: AST, enclosingScope: SymbolScope): AST {\n            var prevScope = this.scope;\n            this.scope = enclosingScope;\n            var svThisFnc = this.thisFnc;\n            var svThisType = this.thisType;\n            var svThisClassNode = this.thisClassNode;\n            var svCurrentModDecl = this.checker.currentModDecl;\n            var prevMethodStatus = this.enclosingFncIsMethod;\n            var container = this.scope.container;\n            var fnc: FuncDecl = null;\n            while (container) {\n                if (container.kind() == SymbolKind.Type) {\n                    var typeSym = <TypeSymbol>container;\n                    var type = typeSym.type;\n                    if (type.call) {\n                        if (fnc == null) {\n                            // use innermost function\n                            this.enclosingFncIsMethod = typeSym.isMethod;\n                            fnc = <FuncDecl>container.declAST;\n                        }\n                    }\n                    if (type.isClass()) {\n                        this.thisType = type.instanceType;\n                        if (typeSym.declAST &&\n                            (typeSym.declAST.nodeType == NodeType.ClassDeclaration)) {\n                            this.thisClassNode = <TypeDeclaration>typeSym.declAST;\n                        }\n                        // use innermost class\n                        break;\n                    }\n                    if (type.isModuleType()) {\n                        this.checker.currentModDecl = <ModuleDeclaration>typeSym.declAST;\n                        // use innermost module\n                        break;\n                    }\n                }\n                container = container.container;\n            }\n            this.thisFnc = fnc;\n\n            var updated = this.typeCheck(ast);\n\n            this.thisFnc = svThisFnc;\n            this.thisType = svThisType;\n            this.thisClassNode = svThisClassNode;\n            this.checker.currentModDecl = svCurrentModDecl;\n            this.enclosingFncIsMethod = prevMethodStatus;\n            this.scope = prevScope;\n            return updated;\n        }\n\n        public typeCheck(ast: AST): AST {\n            if (ast) {\n                return ast.typeCheck(this);\n            }\n            else {\n                return null;\n            }\n        }\n\n        public inScopeTypeCheckDecl(ast: AST) {\n            if (ast.nodeType == NodeType.VarDecl || ast.nodeType == NodeType.ArgDecl) {\n                this.inScopeTypeCheckBoundDecl(<BoundDecl>ast);\n            }\n            else if (ast.nodeType == NodeType.FuncDecl) {\n\n                var funcDecl = <FuncDecl>ast;\n\n                if (funcDecl.isAccessor()) {\n                    this.typeCheckFunction(funcDecl);\n                }\n            }\n        }\n\n        public inScopeTypeCheckBoundDecl(varDecl: BoundDecl) {\n            var sym = varDecl.sym;\n            var svThisFnc = this.thisFnc;\n            var svThisType = this.thisType;\n            var prevMethodStatus = this.enclosingFncIsMethod;\n            var prevLocationInfo = this.checker.locationInfo;\n            if (sym && sym.container) {\n                var instanceScope = hasFlag(varDecl.varFlags, VarFlags.ClassConstructorProperty) ? sym.container.getType().constructorScope : sym.container.instanceScope();\n                if (hasFlag(varDecl.varFlags, VarFlags.Property) && sym.container.declAST.nodeType == NodeType.FuncDecl) {\n                    this.thisFnc = <FuncDecl>sym.container.declAST;\n                }\n                if (instanceScope) {\n                    var',
v27492=v27493+" prevScope = this.scope;\n                    this.scope = instanceScope;\n                    var container = sym.container;\n                    var svCurrentModDecl = this.checker.currentModDecl;\n                    if (this.checker.units &&\n                        (sym.unitIndex >= 0) &&\n                        (sym.unitIndex < this.checker.units.length)) {\n                        this.checker.locationInfo = this.checker.units[sym.unitIndex];\n                    }\n                    else {\n                        this.checker.locationInfo = unknownLocationInfo;\n                    }\n                    // REVIEW: container linkage for function expressions\n                    while (container) {\n                        if (container.kind() == SymbolKind.Type) {\n                            var typeSym = <TypeSymbol>container;\n                            var type = typeSym.type;\n                            if (type.call) {\n                                this.enclosingFncIsMethod = typeSym.isMethod;\n                            }\n                            if (type.isClass()) {\n                                this.thisType = type.instanceType;\n                            }\n                            if (type.isModuleType()) {\n                                this.checker.currentModDecl = <ModuleDeclaration>container.declAST;\n                                break;\n                            }\n                        }\n                        container = container.container;\n                    }\n\n                    this.typeCheckBoundDecl(varDecl);\n                    this.checker.currentModDecl = svCurrentModDecl;\n                    this.scope = prevScope;\n                }\n            }\n            this.thisFnc = svThisFnc;\n            this.thisType = svThisType;\n            this.checker.locationInfo = prevLocationInfo;\n            this.enclosingFncIsMethod = prevMethodStatus;\n        }\n\n        public resolveBoundDecl(varDecl: BoundDecl) {\n            if (varDecl.typeExpr) {\n                if (varDecl.typeExpr.type == null ||\n                    (varDecl.typeExpr.type && varDecl.typeExpr.type == this.anyType && this.scope) ||\n                    varDecl.typeExpr.type.symbol == null ||\n                    !this.checker.typeStatusIsFinished(varDecl.typeExpr.type.symbol.typeCheckStatus)) {\n                    this.typeCheck(varDecl.typeExpr);\n                }\n                varDecl.type = varDecl.typeExpr.type;\n                if (varDecl.sym) {\n                    varDecl.sym.setType(varDecl.type);\n                }\n            }\n            else if (varDecl.init == null) {\n                if (this.checker.styleSettings.implicitAny) {\n                    this.checker.errorReporter.styleError(varDecl, \"type implicitly set to 'any'\");\n                }\n                varDecl.type = this.anyType;\n                if (varDecl.sym) {\n                    if (varDecl.sym.isType()) {\n                        var tsym = <TypeSymbol>varDecl.sym;\n                        if (tsym.isMethod) {\n                            this.checker.errorReporter.simpleError(varDecl, \"Cannot bind method group to variable.  (Did you mean to use 'declare function' instead of 'declare var'?)\");\n                            return;\n                        }\n                        else {\n                            this.checker.errorReporter.simpleError(varDecl, \"Cannot bind type to variable\");\n                            return;\n                        }\n                    }\n                    varDecl.sym.setType(varDecl.type);\n                }\n            }\n        }\n\n        public typeCheckBoundDecl(varDecl: BoundDecl): VarDecl {\n            // symbol has already been added to the scope\n            var infSym = <InferenceSymbol>varDecl.sym;\n            if (infSym == null) {\n                if (varDecl.init) {\n                    varDecl.init = this.typeCheck(varDecl.init);\n                    varDecl.type = this.checker.widenType(varDecl.init.type);\n                }\n                else {\n                    if (this.checker.styleSettings.implicitAny) {\n                        this.checker.errorReporter.styleError(varDecl, \"type implicitly set to 'any'\");\n                    }\n                    varDecl.type = this.anyType;\n                }\n            }\n            else {\n                if (infSym.typeCheckStatus == TypeCheckStatus.Started) {\n                    if (this.checker.styleSettings.implicitAny) {\n                        this.checker.errorReporter.styleError(varDecl, \"type implicitly set to 'any'\");\n                    }\n                    varDecl.type = this.anyType;\n                    infSym.setType(this.anyType);\n                }\n                else if (infSym.typeCheckStatus == TypeCheckStatus.NotStarted) {\n                    infSym.typeCheckStatus = TypeCheckStatus.Started;\n                    this.checker.addStartedPTO(infSym);\n                    var resolved = false;\n                    if (varDecl.type",
v27491=v27492+" == null) {\n                        // propagate declared type\n                        if (varDecl.typeExpr) {\n                            this.resolveBoundDecl(varDecl);\n                            resolved = true;\n                            varDecl.type = varDecl.typeExpr.type;\n                            infSym.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();\n                        }\n                    }\n\n                    if (varDecl.init) {\n                        // if the bound decl is a function-local static, we need to set the\n                        // encapsulating scope to the function's member scope\n                        var isLocalStatic = hasFlag(varDecl.varFlags, VarFlags.LocalStatic);\n                        var prevScope = this.scope;\n                        var applyTargetType = !varDecl.init.isParenthesized;\n                        if (isLocalStatic) {\n                            this.scope = varDecl.sym.container.getType().memberScope;\n                        }\n\n                        // Mark Lambda expressions with IsPropertyBound flag\n                        if (hasFlag(varDecl.varFlags, VarFlags.Property) && this.thisClassNode) {\n                            getAstWalkerFactory().walk(varDecl.init, (ast: AST, parent: AST, walker: IAstWalker) => {\n                                if (ast && ast.nodeType == NodeType.FuncDecl) {\n                                    if (hasFlag((<FuncDecl>ast).fncFlags, FncFlags.IsFatArrowFunction)) {\n                                        // Found a Lambda, mark it\n                                        (<FuncDecl>ast).fncFlags |= FncFlags.IsPropertyBound;\n                                    }\n                                    // Only mark the top level functions\n                                    walker.options.goChildren = false;\n                                }\n                                return ast;\n                            });\n                        }\n\n                        this.checker.typeCheckWithContextualType(varDecl.type, this.checker.inProvisionalTypecheckMode(), applyTargetType, varDecl.init);\n\n                        this.scope = prevScope;\n                        if (varDecl.type) {\n                            // If the cast is to a target type, in the case of a funcdecl,\n                            // we may overwrite the init's type with one generated from a signature.\n                            // In that case, we need to preserve the contained scope of the actual decl\n                            var preserveScope = false;\n                            var preservedContainedScope = null;\n\n                            if (varDecl.init.type) {\n                                preservedContainedScope = varDecl.init.type.containedScope;\n                                preserveScope = true;\n                                if (varDecl.init.type == this.voidType) {\n                                    this.checker.errorReporter.simpleError(varDecl, \"Cannot assign type 'void' to variable '\" + varDecl.id.actualText + \"'\");\n                                }\n                            }\n\n                            varDecl.init = this.castWithCoercion(varDecl.init, varDecl.type, applyTargetType && !this.checker.inProvisionalTypecheckMode(), false);\n\n                            if (preserveScope && varDecl.init.type.containedScope == null) {\n                                varDecl.init.type.containedScope = preservedContainedScope;\n                            }\n                        }\n                        else {\n                            varDecl.type = this.checker.widenType(varDecl.init.type);\n                            if (varDecl.type == this.voidType) {\n                                this.checker.errorReporter.simpleError(varDecl, \"Cannot assign type 'void' to variable '\" + varDecl.id.actualText + \"'\");\n                                varDecl.type = this.anyType;\n                            }\n                        }\n                        infSym.setType(varDecl.type);\n                    }\n                    else {\n                        if (!resolved) {\n                            this.resolveBoundDecl(varDecl);\n                        }\n                    }\n                    infSym.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();\n                }\n                else if (this.checker.typeStatusIsFinished(infSym.typeCheckStatus) &&\n                         (infSym.declAST != varDecl)) {\n                    if (varDecl.init) {\n                        varDecl.init = this.typeCheck(varDecl.init);\n                        varDecl.type = infSym.getType();\n                        varDecl.init = this.cast(varDecl.init, varDecl.type);\n                    }\n                }\n            }\n            if (varDecl.id && varDecl.sym) {\n                varDecl.id.sym = varDecl.sym;\n            }\n\n            // Check if variable satisfies type privacy\n            if (varDecl.sym && varDecl.sym.con",
v27490=v27491+'tainer) {\n                this.checkTypePrivacy(varDecl.sym.getType(), varDecl.sym, (typeName: string, isModuleName: bool) => this.varPrivacyErrorReporter(varDecl, typeName, isModuleName));\n            }\n            return <VarDecl>varDecl;\n        }\n\n        private varPrivacyErrorReporter(varDecl: BoundDecl, typeName: string, isModuleName: bool) {\n            var typestring = "";\n            if (isModuleName) {\n                var quotestring = "";\n                if (!isQuoted(typeName)) {\n                    quotestring = "\'";\n                }\n                typestring = " is using inaccessible module " + quotestring + typeName + quotestring;\n            } else {\n                typestring = " has or is using private type \'" + typeName + "\'";\n            }\n\n            if (hasFlag(varDecl.varFlags, VarFlags.Public)) {\n                if (varDecl.sym.container.declAST.nodeType == NodeType.InterfaceDeclaration) {\n                    this.checker.errorReporter.simpleError(varDecl, "property \'" + varDecl.sym.name + "\' of exported interface" + typestring);\n                } else {\n                    this.checker.errorReporter.simpleError(varDecl, "public member \'" + varDecl.sym.name + "\' of exported class" + typestring);\n                }\n            } else {\n                this.checker.errorReporter.simpleError(varDecl, "exported variable \'" + varDecl.sym.name + "\'" + typestring);\n            }\n        }\n\n        public typeCheckSuper(ast: AST): AST {\n            if (this.thisType && (this.enclosingFncIsMethod && !this.thisFnc.isStatic()) && this.thisType.baseClass()) {\n                ast.type = this.thisType.baseClass();\n            }\n            else {\n                // redirect \'super\' used within lambdas\n                if (!this.enclosingFncIsMethod &&\n                    this.thisType && this.thisType.baseClass() &&\n                    this.thisFnc && hasFlag(this.thisFnc.fncFlags, FncFlags.IsFatArrowFunction)) {\n                    // Find the closest non lambda function\n                    var enclosingFnc = this.thisFnc.enclosingFnc;\n                    while (hasFlag(enclosingFnc.fncFlags, FncFlags.IsFatArrowFunction)) {\n                        enclosingFnc = enclosingFnc.enclosingFnc;\n                    }\n\n                    // If the lambda is enclosed is a valid member, use the base type\n                    if (enclosingFnc && (enclosingFnc.isMethod() || enclosingFnc.isConstructor) && !enclosingFnc.isStatic()) {\n                        ast.type = this.thisType.baseClass();\n                        enclosingFnc.setHasSuperReferenceInFatArrowFunction();\n                        return ast;\n                    }\n                }\n\n                ast.type = this.anyType;\n                this.checker.errorReporter.invalidSuperReference(ast);\n            }\n            return ast;\n        }\n\n        public typeCheckThis(ast: AST): AST {\n           ast.type = this.anyType;\n            var illegalThisRef = false;\n            if (this.thisFnc == null) {\n                // \'this\' in class bodies should bind to \'any\'\n                if (this.thisType) {\n                    if (this.thisClassNode && this.thisClassNode.nodeType == NodeType.ClassDeclaration) {\n                        illegalThisRef = true;\n                    }\n                    else {\n                        ast.type = this.thisType;\n                    }\n                }\n                else if (this.checker.currentModDecl) {\n                    this.checker.errorReporter.simpleError(ast, "\'this\' may not be referenced within module bodies");\n                }\n            }\n            else {\n                if (this.thisClassNode && (hasFlag(this.thisFnc.fncFlags, FncFlags.IsPropertyBound) || (this.inSuperCall && hasFlag((<ClassDeclaration>this.thisClassNode).varFlags, VarFlags.ClassSuperMustBeFirstCallInConstructor)))) {\n                    illegalThisRef = true;\n                }\n                if (this.thisFnc.isMethod() || this.thisFnc.isConstructor || this.thisFnc.isTargetTypedAsMethod) {\n                    if (this.thisType && !(this.thisFnc.fncFlags & FncFlags.Static)) {\n                        ast.type = this.thisType;\n                    }\n                }\n            }\n\n            // redirect \'this\' used within lambdas\n            if (!this.enclosingFncIsMethod &&\n                this.thisFnc &&\n                hasFlag(this.thisFnc.fncFlags, FncFlags.IsFatArrowFunction)) {\n\n                    // if the enclosing function was bound to a property,\n                    // checkInitSelf would not have been able to mark the \n                    // function for a self init\n                if (this.thisFnc.boundToProperty) {\n                    var container = this.thisFnc.boundToProperty.sym.container;\n                    if (container.declAST.nodeType == NodeType.FuncDecl) {\n                        (<FuncDecl>container.declAST).setHasSelfReference();\n                    }\n                }\n                else {\n         ',
v27489=v27490+'           var encFnc = this.thisFnc.enclosingFnc;\n                    var firstEncFnc = encFnc;\n\n                    while (encFnc) {\n                        if (this.thisClassNode && hasFlag(encFnc.fncFlags, FncFlags.IsPropertyBound)) {\n                            illegalThisRef = true;\n                        }\n\n                        if (!hasFlag(encFnc.fncFlags, FncFlags.IsFatArrowFunction) || encFnc.hasSelfReference()) {\n                            encFnc.setHasSelfReference();\n                            break;\n                        }\n\n                        encFnc = encFnc.enclosingFnc;\n                    }\n\n                    if (!encFnc && firstEncFnc) {\n                        encFnc = firstEncFnc;\n                        encFnc.setHasSelfReference();\n                    }\n                    else if (!encFnc) { // the lambda is bound at the top-level...\n                        if (this.thisClassNode) {\n                            (<ClassDeclaration>this.thisClassNode).varFlags |= VarFlags.MustCaptureThis;\n                        }\n                        else if (this.checker.currentModDecl) {\n                            this.checker.currentModDecl.modFlags |= ModuleFlags.MustCaptureThis;\n                        }\n                        else {\n                            this.checker.mustCaptureGlobalThis = true;\n                        }\n                    }\n\n                    if (encFnc && (encFnc.isMethod() || encFnc.isConstructor) && this.thisType && !hasFlag(encFnc.fncFlags, FncFlags.Static)) {\n                        ast.type = this.thisType;\n                    }\n                }\n            }\n\n            if (illegalThisRef) {\n                this.checker.errorReporter.simpleError(ast, "Keyword \'this\' cannot be referenced in initializers in a class body, or in super constructor calls");\n            }\n            return ast;\n        }\n\n        public setTypeFromSymbol(ast: AST, symbol: Symbol): void {\n            if (symbol.isVariable()) {\n                if (symbol.isInferenceSymbol()) {\n                    var infSym = <InferenceSymbol>symbol;\n                    if (infSym.declAST &&\n                        !this.checker.typeStatusIsFinished(infSym.typeCheckStatus)) {\n                        this.inScopeTypeCheckDecl(infSym.declAST);\n                    }\n                    if (!this.checker.styleSettings.innerScopeDeclEscape) {\n                        if (infSym.declAST && (infSym.declAST.nodeType == NodeType.VarDecl)) {\n                            if (this.nestingLevel < (<VarDecl>infSym.declAST).nestingLevel) {\n                                this.checker.errorReporter.styleError(ast, "Illegal reference to a variable defined in more nested scope");\n                            }\n                        }\n                    }\n                }\n                ast.type = symbol.getType();\n                if (!symbol.writeable()) {\n                    ast.flags = ast.flags & (~(ASTFlags.Writeable));\n                }\n            }\n            else if (symbol.isType()) {\n                ast.type = symbol.getType();\n                ast.flags = ast.flags & (~(ASTFlags.Writeable));\n            }\n            else {\n                ast.type = this.anyType;\n                this.checker.errorReporter.symbolDoesNotReferToAValue(ast, symbol.name);\n            }\n        }\n\n        public typeCheckName(ast: AST): AST {\n            var identifier = <Identifier>ast;\n\n            if (this.checker.inWith) {\n                identifier.type = this.anyType;\n            }\n            else {\n                var typespace = this.inTypeRefTypeCheck;\n                var idText = identifier.text;\n                var originalIdText = idText;\n                var isDynamicModuleName = isQuoted(identifier.text);\n\n                var symbol = this.scope.find(idText, false, typespace);\n\n                if (symbol == null && isDynamicModuleName) {\n                    symbol = this.checker.findSymbolForDynamicModule(idText, this.currentScript.locationInfo.filename, (id) => this.scope.find(id, false, typespace));\n                }\n\n                if (!symbol) {\n                    if (!identifier.isMissing()) {\n                        this.checker.errorReporter.unresolvedSymbol(identifier, identifier.text);\n                    }\n                    identifier.type = this.anyType;\n                }\n                else {\n                    if (optimizeModuleCodeGen && symbol && symbol.isType()) {\n                        var symType = symbol.getType();\n                        // Once the type has been referenced outside of a type ref position, there\'s\n                        // no going back                        \n                        if (symType && (<TypeSymbol>symbol).aliasLink && (<TypeSymbol>symbol).onlyReferencedAsTypeRef) {\n\n                            var modDecl = <ModuleDeclaration>symType.symbol.declAST;\n                            if (modDecl && hasFlag(modDecl.modFlags, ModuleFlags.IsDynamic',
v27488=v27489+")) {\n                                (<TypeSymbol>symbol).onlyReferencedAsTypeRef = this.inTypeRefTypeCheck;\n                            }\n                        }\n                    }\n\n                    if (symbol.declAST &&\n                        symbol.declAST.nodeType == NodeType.FuncDecl &&\n                        !(<FuncDecl>symbol.declAST).returnTypeAnnotation &&\n                        (<FuncDecl>symbol.declAST).signature.typeCheckStatus == TypeCheckStatus.Started) {\n                        (<FuncDecl>symbol.declAST).type.symbol.flags |= SymbolFlags.RecursivelyReferenced;\n                        (<FuncDecl>symbol.declAST).signature.returnType.type = this.anyType;\n                    }\n\n                    this.setTypeFromSymbol(ast, symbol);\n                    identifier.sym = symbol;\n                    if (this.thisFnc) {\n                        if (this.thisFnc.type && symbol.container != this.thisFnc.type.symbol) {\n                            this.thisFnc.freeVariables[this.thisFnc.freeVariables.length] = symbol;\n                        }\n                    }\n                }\n            }\n            return ast;\n        }\n\n        public typeCheckScript(script: Script): Script {\n            this.checker.locationInfo = script.locationInfo;\n            this.scope = this.checker.globalScope;\n\n            // if it's a top-level module, the globals have already been added to the implicit\n            // module decl\n            if (!script.topLevelMod) {\n                this.addLocalsFromScope(this.scope, this.checker.gloMod,\n                                   script.vars, this.checker.globals, true);\n            }\n\n            this.currentScript = script;\n            script.bod = <ASTList>this.typeCheck(script.bod);\n            this.currentScript = null;\n            return script;\n        }\n\n        public typeCheckBitNot(ast: AST): AST {\n            var unex = <UnaryExpression>ast;\n            unex.operand = this.typeCheck(unex.operand);\n            unex.type = this.doubleType;\n            return unex;\n        }\n\n        public typeCheckUnaryNumberOperator(ast: AST): AST {\n            var unex = <UnaryExpression>ast;\n            unex.operand = this.typeCheck(unex.operand);\n            unex.type = this.doubleType;\n            return ast;\n        }\n\n        public typeCheckLogNot(ast: AST): AST {\n            var unex = <UnaryExpression>ast;\n            unex.operand = this.typeCheck(unex.operand);\n            unex.type = this.booleanType;\n            return unex;\n        }\n\n        public astIsWriteable(ast: AST): bool {\n            return hasFlag(ast.flags, ASTFlags.Writeable);\n        }\n\n        public typeCheckIncOrDec(ast: AST): AST {\n            var unex = <UnaryExpression>ast;\n            var lval = unex.operand;\n            if (!this.astIsWriteable(unex)) {\n                this.checker.errorReporter.valueCannotBeModified(unex);\n                unex.type = this.doubleType;\n            }\n            else {\n                unex = <UnaryExpression> this.typeCheckUnaryNumberOperator(ast);\n                if (unex.operand.type != this.checker.numberType && unex.operand.type != this.checker.anyType && !(unex.operand.type.typeFlags & TypeFlags.IsEnum)) {\n                    this.checker.errorReporter.simpleError(ast, \"'++' and '--' may only be applied to operands of type 'number' or 'any'\");\n                }\n            }\n            return unex;\n        }\n\n        public typeCheckBitwiseOperator(ast: AST, assignment: bool): AST {\n            var binex = <BinaryExpression>ast;\n            var resultType: Type = null;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            var leftType = binex.operand1.type;\n            var rightType = binex.operand2.type;\n\n            if (assignment && (!this.astIsWriteable(binex))) {\n                this.checker.errorReporter.valueCannotBeModified(binex);\n            }\n\n            if (this.checker.styleSettings.bitwise) {\n                this.checker.errorReporter.styleError(ast, \"use of \" + nodeTypeTable[binex.nodeType]);\n            }\n\n            if (this.checker.sourceIsSubtypeOfTarget(leftType, this.doubleType) && (this.checker.sourceIsSubtypeOfTarget(rightType, this.doubleType))) {\n                resultType = this.doubleType;\n            }\n            else if ((leftType == this.booleanType) &&\n                     (rightType == this.booleanType)) {\n                resultType = this.booleanType;\n            }\n            else if (leftType == this.anyType) {\n                if ((rightType == this.anyType) ||\n                    (rightType == this.doubleType) ||\n                    (rightType == this.booleanType)) {\n                    resultType = this.anyType;\n                }\n            }\n            else if (rightType == this.anyType) {\n                if ((leftType == this.anyType) ||\n                    (leftType == this.doubleType) ||\n                    (leftType == th",
v27487=v27488+'is.booleanType)) {\n                    resultType = this.anyType;\n                }\n            }\n            if (resultType == null) {\n                resultType = this.anyType;\n                this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType,\n                                                        binex.printLabel(), this.scope);\n            }\n            binex.type = resultType;\n            return binex;\n        }\n\n        public typeCheckArithmeticOperator(ast: AST, assignment: bool): AST {\n            var binex = <BinaryExpression>ast;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            var leftType = binex.operand1.type;\n            var rightType = binex.operand2.type;\n\n            if (assignment && (!this.astIsWriteable(binex.operand1))) {\n                this.checker.errorReporter.valueCannotBeModified(binex);\n            }\n\n            if (this.checker.styleSettings.bitwise &&\n                ((binex.nodeType == NodeType.And) ||\n                (binex.nodeType == NodeType.Or) ||\n                (binex.nodeType == NodeType.AsgAnd) ||\n                (binex.nodeType == NodeType.AsgOr))) {\n                this.checker.errorReporter.styleError(ast, "use of " + nodeTypeTable[binex.nodeType]);\n            }\n\n            if (leftType == null || rightType == null) {\n                this.checker.errorReporter.simpleError(binex, "Could not typecheck arithmetic operation.  Possible recursive typecheck error?");\n                binex.type = this.anyType;\n                return binex;\n            }\n            var nodeType = binex.nodeType;\n\n            if (this.checker.isNullOrUndefinedType(leftType)) {\n                leftType = rightType;\n            }\n            if (this.checker.isNullOrUndefinedType(rightType)) {\n                rightType = leftType;\n            }\n            leftType = this.checker.widenType(leftType);\n            rightType = this.checker.widenType(rightType);\n\n            if (nodeType == NodeType.Add || nodeType == NodeType.AsgAdd) {\n\n                if (leftType == this.checker.stringType || rightType == this.checker.stringType) {\n                    binex.type = this.checker.stringType;\n                }\n                else if (leftType == this.checker.numberType && rightType == this.checker.numberType) {\n                    binex.type = this.checker.numberType;\n                }\n                else if (this.checker.sourceIsSubtypeOfTarget(leftType, this.checker.numberType) && this.checker.sourceIsSubtypeOfTarget(rightType, this.checker.numberType)) {\n                    binex.type = this.checker.numberType;\n                }\n                else if (leftType == this.checker.anyType || rightType == this.checker.anyType) {\n                    binex.type = this.checker.anyType;\n                }\n                else {\n                    binex.type = this.anyType;\n                    this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType,\n                                                            binex.printLabel(), this.scope);\n                }\n            }\n            else {\n                if (leftType == this.checker.numberType && rightType == this.checker.numberType) {\n                    binex.type = this.checker.numberType;\n                }\n                else if (this.checker.sourceIsSubtypeOfTarget(leftType, this.checker.numberType) && this.checker.sourceIsSubtypeOfTarget(rightType, this.checker.numberType)) {\n                    binex.type = this.checker.numberType;\n                }\n                else if (leftType == this.checker.anyType || rightType == this.checker.anyType) {\n                    binex.type = this.checker.numberType;\n                }\n                else {\n                    binex.type = this.anyType;\n                    this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType,\n                                                            binex.printLabel(), this.scope);\n                }\n            }\n\n            return binex;\n        }\n\n        public typeCheckDotOperator(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            var leftIsFnc = false;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            var leftType = binex.operand1.type;\n            var leftScope: SymbolScope = null;\n            // REVIEW: replace with get member scope\n            if (leftType) {\n                if (leftType == this.anyType) {\n                    binex.type = this.anyType;\n                    return binex;\n                }\n                else if (leftType == this.stringType) {\n                    if (this.stringInterfaceType) {\n                        leftScope = this.stringInterfaceType.memberScope;\n                    }\n                    else {\n                        binex.type = this.anyType;\n                        return binex;\n                    }\n                }\n              ',
v27486=v27487+"  else if (leftType == this.doubleType) {\n                    if (this.numberInterfaceType) {\n                        leftScope = this.numberInterfaceType.memberScope;\n                    }\n                    else {\n                        binex.type = this.anyType;\n                        return binex;\n                    }\n                }\n                else if (leftType == this.booleanType) {\n                    if (this.booleanInterfaceType) {\n                        leftScope = this.booleanInterfaceType.memberScope;\n                    }\n                    else {\n                        binex.type = this.anyType;\n                        return binex;\n                    }\n                }\n                else if ((leftType.call || leftType.construct) && leftType.members == null) {\n                    if (this.functionInterfaceType) {\n                        leftScope = this.functionInterfaceType.memberScope;\n                    }\n                    else {\n                        binex.type = this.anyType;\n                        return binex;\n                    }\n                }\n                else if (leftType.elementType) {\n                    if (this.arrayInterfaceType) {\n                        var arrInstType = leftType.elementType.getArrayBase(this.arrayInterfaceType, this.checker);\n                        leftScope = arrInstType.memberScope;\n                    }\n                    else {\n                        binex.type = this.anyType;\n                        return binex;\n                    }\n                }\n                else {\n                    leftScope = leftType.memberScope;\n                }\n            }\n            if (leftScope == null) {\n                this.checker.errorReporter.expectedClassOrInterface(binex);\n                binex.type = this.anyType;\n            }\n            else {\n                var propertyName = <Identifier>binex.operand2;\n                var lhsIsEnclosingType = (this.thisClassNode && binex.operand1.type == this.thisClassNode.type.instanceType) || this.inTypeRefTypeCheck;\n                var symbol = leftScope.find(propertyName.text, !lhsIsEnclosingType, this.inTypeRefTypeCheck); // only search the public members, unless the rhs is a 'this' pointer\n\n                // If the symbol wasn't found, delegate to the appropriate 'virtual' parent type\n                if (!symbol) {\n                    if (this.objectInterfaceType && leftType) {\n                        // check 'Object' for the symbol\n                        if (leftType.isReferenceType()) {\n                            symbol = this.objectInterfaceType.memberScope.find(propertyName.text, false, this.inTypeRefTypeCheck);\n                        }\n                        if (!symbol) {\n                            // check 'Function', if appropriate\n                            if (this.functionInterfaceType && (leftType.call || leftType.construct)) {\n                                symbol = this.functionInterfaceType.memberScope.find(propertyName.text, false, this.inTypeRefTypeCheck);\n                            }\n                        }\n                    }\n                }\n\n                if (!symbol || (!symbol.visible(leftScope, this.checker))) {\n                    binex.type = this.anyType;\n\n                    if (symbol == null) {\n                        this.checker.errorReporter.simpleError(propertyName, \"The property '\" + propertyName.actualText + \"' does not exist on value of type '\" + leftType.getScopedTypeName(this.scope) + \"'\");\n                    }\n                    else if (!this.inTypeRefTypeCheck) {  // if it's a dotted type reference, we'll catch the visibility error during binding\n                        this.checker.errorReporter.simpleError(binex, \"The property '\" + propertyName.actualText + \" on type '\" + leftType.getScopedTypeName(this.scope) + \"' is not visible\");\n                    }\n                }\n                else {\n                    if (symbol.isVariable()) {\n                        if (symbol.isInferenceSymbol()) {\n                            var infSym = <InferenceSymbol>symbol;\n                            if (infSym.declAST && !this.checker.typeStatusIsFinished(infSym.typeCheckStatus)) {\n                                this.inScopeTypeCheckDecl(infSym.declAST);\n                            }\n                        }\n                    }\n                    propertyName.sym = symbol;\n                    binex.type = symbol.getType();\n                }\n            }\n            if (binex.type == null) {\n                binex.type = this.anyType;\n            }\n\n            return binex;\n        }\n\n        public typeCheckBooleanOperator(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            var leftType = binex.operand1.type;\n            var rightType = binex.operand2.type;\n            if ((!",
v27485=v27486+'(this.checker.sourceIsAssignableToTarget(leftType, rightType))) &&\n                (!(this.checker.sourceIsAssignableToTarget(rightType, leftType)))) {\n                this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType, binex.printLabel(), this.scope);\n            }\n            binex.type = this.booleanType;\n            return binex;\n        }\n\n        public typeCheckAsgOperator(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            var applyTargetType = !binex.operand2.isParenthesized;\n            binex.operand1 = this.typeCheck(binex.operand1);\n\n            this.checker.typeCheckWithContextualType(binex.operand1.type, this.checker.inProvisionalTypecheckMode(), applyTargetType, binex.operand2);\n\n            var leftType = binex.operand1.type;\n            var rightType = binex.operand2.type;\n\n            if (!(this.astIsWriteable(binex.operand1))) {\n                this.checker.errorReporter.valueCannotBeModified(binex);\n            }\n            if (binex.operand1.nodeType == NodeType.Call) {\n                var callEx = <CallExpression>binex.operand1;\n            }\n            var preserveScope = false;\n            var preservedContainedScope = null;\n            if (binex.operand2.type) {\n                preservedContainedScope = binex.operand2.type.containedScope;\n                preserveScope = true;\n            }\n            // Do not re-write the AST in provisional typecheck mode\n            binex.operand2 = this.castWithCoercion(binex.operand2, leftType, applyTargetType && !this.checker.inProvisionalTypecheckMode(), false);\n            if (preserveScope && binex.operand2.type.containedScope == null) {\n                binex.operand2.type.containedScope = preservedContainedScope;\n            }\n            binex.type = rightType;\n            return binex;\n        }\n\n        public typeCheckIndex(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            binex.operand1 = this.typeCheck(binex.operand1); // ObjExpr\n            binex.operand2 = this.typeCheck(binex.operand2); // IndexExpr\n\n            if (!this.checker.styleSettings.literalSubscript) {\n                if (binex.operand2.nodeType == NodeType.QString) {\n                    this.checker.errorReporter.styleError(ast, "use literal subscript (\'.\') notation instead)");\n                }\n            }\n\n            var objExprType = binex.operand1.type;\n            var indexExprType = binex.operand2.type;\n\n            if (objExprType.elementType) { // arrays\n                if (indexExprType == this.checker.anyType || indexExprType == this.checker.numberType || hasFlag(indexExprType.typeFlags, TypeFlags.IsEnum)) {\n                    binex.type = objExprType.elementType;\n                }\n                else if (indexExprType == this.checker.stringType) {\n                    binex.type = this.checker.anyType;\n                }\n                else {\n                    this.checker.errorReporter.simpleError(binex, "Illegal property access");\n                    binex.type = this.checker.anyType;\n                }\n            }\n            else if (objExprType.index) { // types with index sigs\n\n                if (indexExprType == this.checker.anyType ||\n                    !((objExprType.index.flags & SignatureFlags.IsStringIndexer) || (objExprType.index.flags & SignatureFlags.IsNumberIndexer)) || // REVIEW: unvalidated type expression\n                    ((objExprType.index.flags & SignatureFlags.IsStringIndexer) && indexExprType == this.checker.stringType) ||\n                    ((objExprType.index.flags & SignatureFlags.IsNumberIndexer) && (indexExprType == this.checker.numberType || hasFlag(indexExprType.typeFlags, TypeFlags.IsEnum)))) {\n                    var sig = this.resolveOverload(ast, objExprType.index);\n                    if (sig) {\n                        binex.type = sig.returnType.type;//objExprType.index.signatures[0].returnType.type;\n                    }\n                    else {\n                        binex.type = this.checker.anyType;\n                    }\n                }\n                else if (indexExprType == this.checker.stringType) {\n                    binex.type = this.checker.anyType;\n                }\n                else {\n                    this.checker.errorReporter.simpleError(binex, "Illegal property access");\n                    binex.type = this.checker.anyType;\n                }\n            }\n            else if ((objExprType == this.checker.anyType ||\n                     objExprType == this.checker.stringType ||\n                     objExprType == this.checker.numberType ||\n                     objExprType == this.checker.booleanType ||\n                     objExprType.isReferenceType()) &&\n                     (indexExprType == this.checker.anyType ||\n                      indexExprType == this.checker.stringType ||\n                      (indexExprType == this.checker.numberType || hasFlag(indexExprType.typeFlags, TypeFlags.IsEnum)))) { // RE',
v27484=v27485+'VIEW: Do we want to allow indexes of type \'number\'?\n                binex.type = this.checker.anyType;\n            }\n            else {\n                this.checker.errorReporter.simpleError(binex, "Illegal property access");\n                binex.type = this.checker.anyType;\n            }\n\n            return binex;\n        }\n\n        public typeCheckInOperator(binex: BinaryExpression): BinaryExpression {\n            binex.operand1 = this.cast(this.typeCheck(binex.operand1), this.stringType);\n            binex.operand2 = this.typeCheck(binex.operand2);\n\n            if (!((binex.operand1.type == this.checker.anyType || binex.operand1.type == this.checker.stringType) &&\n                    (binex.operand2.type == this.anyType || this.checker.sourceIsSubtypeOfTarget(binex.operand2.type, this.objectInterfaceType)))) {\n                this.checker.errorReporter.simpleError(binex, "The in operator requires the left operand to be of type Any or the String primitive type, and the right operand to be of type Any or an object type");\n            }\n\n            binex.type = this.booleanType;\n            return binex;\n        }\n\n        public typeCheckShift(binex: BinaryExpression, assignment: bool): BinaryExpression {\n            binex.operand1 = this.cast(this.typeCheck(binex.operand1), this.doubleType);\n            binex.operand2 = this.cast(this.typeCheck(binex.operand2), this.doubleType);\n            if (assignment && (!(this.astIsWriteable(binex.operand1)))) {\n                this.checker.errorReporter.valueCannotBeModified(binex);\n            }\n            binex.type = this.doubleType;\n            return binex;\n        }\n\n        public typeCheckQMark(trinex: ConditionalExpression): ConditionalExpression {\n            trinex.operand1 = this.typeCheck(trinex.operand1);\n            trinex.operand2 = this.typeCheck(trinex.operand2);\n            trinex.operand3 = this.typeCheck(trinex.operand3);\n            var leftType = trinex.operand2.type;\n            var rightType = trinex.operand3.type;\n\n            if (leftType == rightType) {\n                trinex.type = leftType;\n            }\n            else {\n                if (this.checker.sourceIsSubtypeOfTarget(leftType, rightType)) {\n                    trinex.type = rightType;\n                }\n                else if (this.checker.sourceIsSubtypeOfTarget(rightType, leftType)) {\n                    trinex.type = leftType;\n                }\n                else {\n                    trinex.type = this.anyType;\n                    this.checker.errorReporter.incompatibleTypes(trinex, leftType, rightType, trinex.printLabel(), this.scope);\n                }\n            }\n\n            return trinex;\n        }\n\n        public addFormals(container: Symbol, signature: Signature,\n            table: IHashTable) {\n            var len = signature.parameters.length;\n            for (var i = 0; i < len; i++) {\n                var symbol = <ParameterSymbol>signature.parameters[i];\n                symbol.container = container;\n                table.add(symbol.name, symbol);\n            }\n        }\n\n        // REVIEW: We use isModContainer instead of container.getType().isModuleType because container.type may be null at this\n        // juncture\n        public addLocalsFromScope(scope: SymbolScope, container: Symbol, vars: ASTList, table: IHashTable, isModContainer: bool) {\n            var len = vars.members.length;\n            var hasArgsDef = false;\n            for (var i = 0; i < len; i++) {\n                var local = <VarDecl>vars.members[i];\n                if (((local.sym == null) || (local.sym.kind() != SymbolKind.Field))) {\n                    var result: Symbol = null;\n                    if ((result = table.lookup(local.id.text)) == null) {\n                        var localVar: ValueLocation = new ValueLocation();\n                        localVar.typeLink = new TypeLink();\n                        var varSym = null;\n\n                        if (hasFlag(local.varFlags, VarFlags.Static)) {\n                            local.varFlags |= VarFlags.LocalStatic;\n                            varSym = new FieldSymbol(local.id.text, local.minChar,\n                                                      this.checker.locationInfo.unitIndex,\n                                                      true, localVar);\n                        }\n                        else {\n                            varSym = new VariableSymbol(local.id.text, local.minChar,\n                                                      this.checker.locationInfo.unitIndex,\n                                                      localVar);\n                        }\n                        varSym.transferVarFlags(local.varFlags);\n                        localVar.symbol = varSym;\n                        varSym.declAST = local;\n                        localVar.typeLink.ast = local.typeExpr;\n                        this.checker.resolveTypeLink(scope, localVar.typeLink, false);\n                        if ((local.type == null) &&',
v27483=v27484+' (local.init == null)) {\n                            local.type = this.anyType;\n                        }\n                        localVar.typeLink.type = local.type;\n                        localVar.symbol.container = container;\n                        local.sym = localVar.symbol;\n                        table.add(local.id.text, varSym);\n                        if (local.id.text == "arguments") {\n                            hasArgsDef = true;\n                        }\n                    }\n                    else {\n                        local.type = result.getType();\n                        local.sym = result;\n                    }\n                }\n            }\n            if (!isModContainer) {\n                if (!hasArgsDef) {\n                    var argLoc = new ValueLocation();\n                    argLoc.typeLink = new TypeLink();\n                    var theArgSym = new VariableSymbol("arguments", vars.minChar,\n                                                     this.checker.locationInfo.unitIndex,\n                                                     argLoc);\n\n                    // if the user is using a custom lib.d.ts where IArguments has not been defined\n                    // (or they\'re compiling with the --nolib option), use \'any\' as the argument type\n                    if (!this.iargumentsInterfaceType) {\n                        var argumentsSym = scope.find("IArguments", false, true);\n\n                        if (argumentsSym) {\n                            argumentsSym.flags |= SymbolFlags.CompilerGenerated;\n                            this.iargumentsInterfaceType = argumentsSym.getType();\n                        }\n                        else {\n                            this.iargumentsInterfaceType = this.anyType;\n                        }\n                    }\n                    argLoc.typeLink.type = this.iargumentsInterfaceType;\n                    table.add("arguments", theArgSym);\n                }\n            }\n        }\n\n        // REVIEW: isClass param may now be redundant\n        public addConstructorLocalArgs(container: Symbol, args: ASTList, table: IHashTable, isClass: bool): void {\n            if (args) {\n                var len = args.members.length;\n                for (var i = 0; i < len; i++) {\n                    var local = <ArgDecl>args.members[i];\n                    if ((local.sym == null) ||\n                        (isClass || (local.sym.kind() != SymbolKind.Field))) {\n                        var result: Symbol = null;\n                        if ((result = table.lookup(local.id.text)) == null) {\n                            this.resolveBoundDecl(local);\n                            var localVar: ValueLocation = new ValueLocation();\n                            localVar.typeLink = new TypeLink();\n                            var varSym = new ParameterSymbol(local.id.text, local.minChar,\n                                                                   this.checker.locationInfo.unitIndex,\n                                                                   localVar);\n                            varSym.declAST = local;\n                            localVar.symbol = varSym;\n                            localVar.typeLink.type = local.type;\n                            localVar.symbol.container = container;\n                            local.sym = localVar.symbol;\n                            table.add(local.id.text, varSym);\n                        }\n                        else {\n                            local.type = result.getType();\n                            local.sym = result;\n                        }\n                    }\n                }\n            }\n        }\n\n        public checkInitSelf(funcDecl: FuncDecl): bool {\n            if (!funcDecl.isMethod()) {\n                var freeVars = funcDecl.freeVariables;\n                for (var k = 0, len = freeVars.length; k < len; k++) {\n                    var sym = freeVars[k];\n                    if (sym.isInstanceProperty()) {\n                        return true;\n                    }\n                }\n            }\n            var fns = funcDecl.scopes;\n            var fnsLen = fns.members.length;\n\n            for (var j = 0; j < fnsLen; j++) {\n                var fn = <FuncDecl>fns.members[j];\n                if (this.checkInitSelf(fn)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        public checkPromoteFreeVars(funcDecl: FuncDecl, constructorSym: Symbol): void {\n            var freeVars = funcDecl.freeVariables;\n            for (var k = 0, len = freeVars.length; k < len; k++) {\n                var sym = freeVars[k];\n                if ((!sym.isInstanceProperty()) && (sym.container == constructorSym)) {\n                    instanceFilter.reset();\n                    if (this.scope.search(instanceFilter, sym.name, false, false)) {\n                        this.checker.errorReporter.simpleError(funcDecl, "Constructor-local variable shadows class property',
v27482=v27483+' \'" + sym.name + "\'. To access the class property, use \'self." + sym.name + "\'");\n                    }\n\n                    this.checker.errorReporter.simpleError(funcDecl, "Constructor-local variables may not be accessed from instance method bodies. Consider changing local variable \'" + sym.name + "\' to a class property")\n                }\n            }\n        }\n\n        public allReturnsAreVoid(funcDecl: FuncDecl) {\n            // in the case of a function or method with no declared return type, walk the body to \n            // pre-emptively determine if the function has a return type of void\n            //\n            // REVIEW: Eventually, we\'ll want to perform exit graph analysis to determine\n            // if the function ever "escapes" without a return expression\n            // This would require moving some of this logic into the function\'s typecheck-proper,\n            // which would slow things down a fair bit, but would open up more analysis opportunities\n            var allReturnsAreVoid = true;\n\n            if (funcDecl.signature.returnType.type == null) {\n                var preFindReturnExpressionTypes = function (ast: AST, parent: AST, walker: IAstWalker) {\n                    var go = true;\n                    switch (ast.nodeType) {\n                        case NodeType.FuncDecl:\n                            // don\'t recurse into a function decl - we don\'t want to confuse a nested\n                            // return type with the top-level function\'s return type\n                            go = false;\n                            break;\n                        case NodeType.Return:\n                            var returnStmt: ReturnStatement = <ReturnStatement>ast;\n\n                            if (returnStmt.returnExpression) {\n                                allReturnsAreVoid = false;\n                                go = false;\n                            }\n\n                        default:\n                            break;\n                    }\n                    walker.options.goChildren = go;\n                    walker.options.goNextSibling = go;\n                    return ast;\n                }\n\n                getAstWalkerFactory().walk(funcDecl.bod, preFindReturnExpressionTypes);\n            }\n\n            return allReturnsAreVoid;\n        }\n\n        public classConstructorHasSuperCall(funcDecl: FuncDecl) {\n            var foundSuper = false;\n\n            var preFindSuperCall = function (ast: AST, parent: AST, walker: IAstWalker) {\n\n                var go = true;\n\n                switch (ast.nodeType) {\n                    case NodeType.FuncDecl:\n                        go = false;\n                        break;\n                    case NodeType.Call:\n                        var call = <CallExpression>ast;\n\n                        if (call.target.nodeType == NodeType.Super) {\n                            go = false;\n                            foundSuper = true;\n                            break;\n                        }\n                        break;\n                    default:\n                        break;\n                }\n                walker.options.goChildren = go;\n                return ast;\n            }\n\n            getAstWalkerFactory().walk(funcDecl.bod, preFindSuperCall);\n\n            return foundSuper;\n        }\n\n        private baseListPrivacyErrorReporter(bases: ASTList, i: number, declSymbol: Symbol, extendsList: bool, typeName: string, isModuleName: bool) {\n            var baseSymbol = bases.members[i].type.symbol;\n            var declTypeString = (declSymbol.declAST.nodeType == NodeType.InterfaceDeclaration) ? "interface" : "class";\n            var baseListTypeString = extendsList ? "extends" : "implements";\n            var baseTypeString = (baseSymbol.declAST.nodeType == NodeType.InterfaceDeclaration) ? "interface" : "class";\n            var typestring = "";\n            if (isModuleName) {\n                var quotestring = "";\n                if (!isQuoted(typeName)) {\n                    quotestring = "\'";\n                }\n                typestring = " is using inaccessible module ";\n                baseTypeString = " " + baseTypeString + " from private module " + quotestring + typeName + quotestring;\n            } else {\n                baseTypeString = " private " + baseTypeString + " \'" + typeName + "\'";\n            }\n            this.checker.errorReporter.simpleError(bases.members[i], "exported " + declTypeString + " \'" + declSymbol.name + "\' " + baseListTypeString + baseTypeString);\n        }\n\n        // Check if declSymbol can satisfy baselist privacy\n        private typeCheckBaseListPrivacy(bases: ASTList, declSymbol: Symbol, extendsList: bool) {\n            if (bases) {\n                var basesLen = bases.members.length;\n                for (var i = 0; i < basesLen; i++) {\n                    if (!bases.members[i].type || bases.members[i].type == this.checker.anyType) {\n                        // This type is coming from external module so it ha',
v27481=v27482+"s to be exported, or we're recovering from an\n                        // error condition\n                        continue;\n                    }\n\n                    this.checkSymbolPrivacy(bases.members[i].type.symbol, declSymbol, (typeName: string, isModuleName: bool) => this.baseListPrivacyErrorReporter(bases, i, declSymbol, extendsList, typeName, isModuleName));\n                }\n            }\n        }\n\n        // Checks if the privacy is satisfied by typeSymbol that is used in the declaration inside container\n        private checkSymbolPrivacy(typeSymbol: TypeSymbol, declSymbol: Symbol, errorCallback: (typeName: string, isModuleName: bool) => void ) {\n            var externalModuleSymbol: TypeSymbol = null;\n            var declSymbolPath: Symbol[] = null;\n\n            // Type is visible type, so this can be used by anyone.\n            if (typeSymbol.isExternallyVisible(this.checker)) {\n                // Symbol could be from external module, go ahead and find the external module\n                var typeSymbolPath = typeSymbol.pathToRoot();\n                declSymbolPath = declSymbol.pathToRoot();\n                var typeSymbolLength = typeSymbolPath.length;\n                var declSymbolPathLength = declSymbolPath.length;\n\n                if (typeSymbolLength > 0) {\n                    if (typeSymbolPath[typeSymbolLength - 1].getType().isModuleType() &&\n                        (<TypeSymbol>typeSymbolPath[typeSymbolLength - 1]).isDynamic &&\n                        typeSymbolPath[typeSymbolLength - 1] != declSymbolPath[declSymbolPathLength - 1]) {\n                        // Symbol from external module that was imported using one of the import statement\n                        externalModuleSymbol = <TypeSymbol>typeSymbolPath[typeSymbolLength - 1];\n                    } else if (typeSymbolLength > 1) {\n                        // Is symbol from declared quoted module\n                        if (typeSymbolPath[typeSymbolLength - 2].getType().isModuleType() &&\n                            (<TypeSymbol>typeSymbolPath[typeSymbolLength - 2]).isDynamic &&\n                            (declSymbolPathLength == 1 || typeSymbolPath[typeSymbolLength - 2] != declSymbolPath[declSymbolPathLength - 2])) {\n                            // From quoted module name\n                            externalModuleSymbol = <TypeSymbol>typeSymbolPath[typeSymbolLength - 2];\n                        }\n                    }\n                }\n\n                if (externalModuleSymbol == null) {\n                    return;\n                }\n            }\n\n            // Interface symbol doesn't reflect correct Exported state so use AST instead\n            var interfaceDecl: InterfaceDeclaration = declSymbol.getInterfaceDeclFromSymbol(this.checker);\n            if (interfaceDecl && !hasFlag(interfaceDecl.varFlags, VarFlags.Exported)) {\n                return;\n            }\n\n            var checkVisibilitySymbol = declSymbol;\n            // Var decl symbol doesnt reflect correct exported state so use AST instead\n            var varDecl = declSymbol.getVarDeclFromSymbol();\n            if (varDecl) {\n                if (hasFlag(varDecl.varFlags, VarFlags.Private)) {\n                    return;\n                } else if (hasFlag(varDecl.varFlags, VarFlags.Public)) {\n                    // Its a member from class so check visibility of its container\n                    checkVisibilitySymbol = declSymbol.container;\n                }\n            }\n\n            // If the container is visible from global scrope it is error\n            if (checkVisibilitySymbol.isExternallyVisible(this.checker)) {\n                var privateSymbolName = typeSymbol.name;\n\n                // If imported typeSymbol mark it as visible externally and verify that the symbol it imports is visible externally\n                if (externalModuleSymbol != null) {\n                    var prettyName = externalModuleSymbol.getPrettyNameOfDynamicModule(declSymbolPath);\n                    if (prettyName != null) {\n                        this.currentScript.AddExternallyVisibleImportedSymbol(prettyName.symbol, this.checker);\n                        return;\n                    } else {\n                        privateSymbolName = externalModuleSymbol.prettyName;\n                    }\n                }\n\n                // Visible declaration using non visible type.\n                errorCallback(privateSymbolName, typeSymbol.name != privateSymbolName);\n            }\n        }\n\n        // Checks if the privacy is satisfied by type that is used in the declaration inside container\n        private checkTypePrivacy(type: Type, declSymbol: Symbol, errorCallback: (typeName: string, isModuleName : bool) =>void ) {\n            // Primitive types\n            if (!(type && type.primitiveTypeClass == Primitive.None)) {\n                return;\n            }\n\n\n            // If type is array, check element type\n            if (type.isArray()) {\n                return this.checkTypePrivacy(type.elementTyp",
v27480=v27481+'e, declSymbol, errorCallback);\n            }\n\n            // Going to be printing symbol name, verify if symbol can be emitted\n            if (type.symbol && type.symbol.name && type.symbol.name != "_anonymous" &&\n                        (((type.call == null) && (type.construct == null) && (type.index == null)) ||\n                        (type.members && (!type.isClass())))) {\n                return this.checkSymbolPrivacy(<TypeSymbol>type.symbol, declSymbol, errorCallback);\n            }\n\n            if (type.members) {\n                // Verify symbols for members\n                type.members.allMembers.map((key, s, unused) => {\n                    var sym = <Symbol>s;\n                    if (!hasFlag(sym.flags, SymbolFlags.BuiltIn)) {\n                        this.checkTypePrivacy(sym.getType(), declSymbol, errorCallback);\n                    }\n                }, null);\n            }\n\n            this.checkSignatureGroupPrivacy(type.call, declSymbol, errorCallback);\n            this.checkSignatureGroupPrivacy(type.construct, declSymbol, errorCallback);\n            this.checkSignatureGroupPrivacy(type.index, declSymbol, errorCallback);\n        }\n\n        // Checks if the privacy is satisfied by typeSymbol that is used in the declaration inside container\n        private checkSignatureGroupPrivacy(sgroup: SignatureGroup, declSymbol: Symbol, errorCallback: (typeName: string, isModuleName : bool) =>void ) {\n            if (sgroup) {\n                var len = sgroup.signatures.length;\n                for (var i = 0; i < sgroup.signatures.length; i++) {\n                    var signature = sgroup.signatures[i];\n                    if (len > 1 && signature == sgroup.definitionSignature) {\n                        // In case of overloads don\'t look up for overload defintion types.\n                        continue;\n                    }\n\n                    if (signature.returnType) {\n                        this.checkTypePrivacy(signature.returnType.type, declSymbol, errorCallback);\n                    }\n\n                    var paramLen = signature.parameters.length;\n                    for (var j = 0; j < paramLen; j++) {\n                        var param = signature.parameters[j];\n                        this.checkTypePrivacy(param.getType(), declSymbol, errorCallback);\n                    }\n                }\n            }\n        }\n\n        private functionArgumentPrivacyErrorReporter(funcDecl: FuncDecl, p: number, paramSymbol: Symbol, typeName: string, isModuleName: bool) {\n            var isGetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor);\n            var isSetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.SetAccessor);\n            var isPublicFunc = hasFlag(funcDecl.fncFlags, FncFlags.Public);\n            var isContainerInterface = funcDecl.type.symbol.getInterfaceDeclFromSymbol(this.checker) != null;\n            var typestring = "";\n            if (isModuleName) {\n                var quotestring = "";\n                if (!isQuoted(typeName)) {\n                    quotestring = "\'";\n                }\n                typestring = " is using inaccessible module " + quotestring + typeName + quotestring;\n            } else {\n                typestring = " has or is using private type \'" + typeName + "\'";\n            }\n\n            if (!isContainerInterface) {\n                if (funcDecl.isConstructor) {\n                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported class\'s constructor parameter \'" + paramSymbol.name + "\'" + typestring);\n                } else if (isSetter) {\n                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], (isPublicFunc ? "public" : "exported") + " setter parameter \'" + paramSymbol.name + "\'" + typestring);\n                } else if (!isGetter) {\n                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], (isPublicFunc ? "public" : "exported") + " function parameter \'" + paramSymbol.name + "\'" + typestring);\n                }\n            } else {\n                if (funcDecl.isConstructMember()) {\n                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported interface\'s constructor parameter \'" + paramSymbol.name + "\'" + typestring);\n                } else if (funcDecl.isCallMember()) {\n                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported interface\'s call parameter \'" + paramSymbol.name + "\'" + typestring);\n                } else if (!funcDecl.isIndexerMember()) {\n                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported interface\'s function parameter \'" + paramSymbol.name + "\'" + typestring);\n                }\n            }\n        }\n\n        private returnTypePrivacyError(astError: AST, funcDecl: FuncDecl, typeName: string, isModuleName: bool) {\n            var isGetter = funcDecl.isAccessor() && hasFlag(funcD',
v27479=v27480+'ecl.fncFlags, FncFlags.GetAccessor);\n            var isSetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.SetAccessor);\n            var isPublicFunc = hasFlag(funcDecl.fncFlags, FncFlags.Public);\n            var isContainerInterface = funcDecl.type.symbol.getInterfaceDeclFromSymbol(this.checker) != null;\n            var typestring = "";\n            if (isModuleName) {\n                var quotestring = "";\n                if (!isQuoted(typeName)) {\n                    quotestring = "\'";\n                }\n                typestring = " is using inaccessible module " + quotestring + typeName + quotestring;\n            } else {\n                typestring = " has or is using private type \'" + typeName + "\'";\n            }\n            if (!isContainerInterface) {\n                if (isGetter) {\n                    this.checker.errorReporter.simpleError(astError, (isPublicFunc ? "public" : "exported") + " getter return type" + typestring);\n                } else if (!isSetter) {\n                    this.checker.errorReporter.simpleError(astError, (isPublicFunc ? "public" : "exported") + " function return type" + typestring);\n                }\n            } else {\n                if (funcDecl.isConstructMember()) {\n                    this.checker.errorReporter.simpleError(astError, "exported interface\'s constructor return type" + typestring);\n                } else if (funcDecl.isCallMember()) {\n                    this.checker.errorReporter.simpleError(astError, "exported interface\'s call return type" + typestring);\n                } else if (funcDecl.isIndexerMember()) {\n                    this.checker.errorReporter.simpleError(astError, "exported interface\'s indexer return type" + typestring);\n                } else {\n                    this.checker.errorReporter.simpleError(astError, "exported interface\'s function return type" + typestring);\n                }\n            }\n        }\n\n        private functionReturnTypePrivacyErrorReporter(funcDecl: FuncDecl, signature: Signature, typeName: string, isModuleName: bool) {\n            var reportOnFuncDecl = false;\n\n            // Error coming from return annotation\n            if (funcDecl.returnTypeAnnotation != null &&\n                funcDecl.returnTypeAnnotation.type == signature.returnType.type) {\n                this.returnTypePrivacyError(funcDecl.returnTypeAnnotation, funcDecl, typeName, isModuleName);\n            }\n\n            // Check if return statement\'s type matches the one that we concluded\n            for (var i = 0; i < funcDecl.returnStatementsWithExpressions.length; i++) {\n                if (funcDecl.returnStatementsWithExpressions[i].type == signature.returnType.type) {\n                    this.returnTypePrivacyError(funcDecl.returnStatementsWithExpressions[i], funcDecl, typeName, isModuleName);\n                } else {\n                    reportOnFuncDecl = true;\n                }\n            }\n\n            if (reportOnFuncDecl) {\n                // Show on function decl\n                this.returnTypePrivacyError(funcDecl, funcDecl, typeName, isModuleName);\n            }\n        }\n\n        public typeCheckFunction(funcDecl: FuncDecl): FuncDecl {\n            this.nestingLevel = 0;\n            var fnType = funcDecl.type;\n\n            var fgSym = fnType.symbol;\n            var signature = funcDecl.signature;\n\n            if (this.checker.typeStatusIsFinished(signature.typeCheckStatus)) {\n                return funcDecl;\n            }\n            else if (signature.typeCheckStatus == TypeCheckStatus.Started) {\n                if (!funcDecl.returnTypeAnnotation &&\n                    funcDecl.bod &&\n                       !funcDecl.isSignature() &&\n                       !(funcDecl.isConstructor) &&\n                       this.allReturnsAreVoid(funcDecl)) {\n\n                    signature.returnType.type = this.voidType;\n                    return funcDecl;\n                }\n                else {\n                    if (funcDecl.returnTypeAnnotation == null) {\n                        if (this.checker.styleSettings.implicitAny) {\n                            this.checker.errorReporter.styleError(funcDecl, "type implicitly set to \'any\'");\n                        }\n                        signature.returnType.type = this.anyType;\n                        fgSym.flags |= SymbolFlags.RecursivelyReferenced;\n                    }\n                    return funcDecl;\n                }\n            }\n\n            signature.typeCheckStatus = TypeCheckStatus.Started;\n            this.checker.addStartedPTO(signature);\n            var prevScope = this.scope;\n            var prevFnc = this.thisFnc;\n            var prevMethodStatus = this.enclosingFncIsMethod;\n            var prevClassNode = this.thisClassNode;\n            this.enclosingFncIsMethod = funcDecl.isMethod() || funcDecl.isConstructor;\n            this.thisFnc = funcDecl;\n            var container = funcDecl.type.symbol;\n            var prevThisType = this.thisType;\n            var pr',
v27478=v27479+"evLocationInfo = this.checker.locationInfo;\n            var funcTable: IHashTable = null;\n            var acceptedContextualType = false;\n            var targetParams: ParameterSymbol[] = null;\n            var targetReturnType: Type = null;\n            var isGetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor);\n            var isSetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.SetAccessor);\n            var accessorType: Type = (isGetter || isSetter) && funcDecl.accessorSymbol ? funcDecl.accessorSymbol.getType() : null;\n            var prevModDecl = this.checker.currentModDecl;\n\n            if (funcDecl.isConstructor && !funcDecl.isOverload) {\n                if (fnType.instanceType == null) {\n                    this.checker.errorReporter.simpleError(funcDecl, \"Malformed function body (is this a class named the same as an existing interface?)\");\n                    return funcDecl;\n                }\n\n                this.scope = fnType.instanceType.constructorScope;\n                var ssb = <SymbolScopeBuilder>this.scope;\n                funcTable = ssb.valueMembers.allMembers;\n            }\n            else if ((funcDecl.isSpecialFn() && !(funcDecl.fncFlags & FncFlags.Signature)) || funcDecl.isOverload) {\n                funcTable = funcDecl.symbols;\n                // if the function is static, we just want to use the \n                // current scope\n                if (!hasFlag(funcDecl.fncFlags, FncFlags.Static) && fnType.containedScope) {\n                    this.scope = fnType.containedScope;\n                }\n            }\n            else {\n                if (funcDecl.bod) {\n                    this.scope = fnType.containedScope;\n                }\n                var ssb = <SymbolScopeBuilder>this.scope;\n\n                // If it is null, it's an ambient declaration with no body, so it doesn't strictly matter\n                // if funcTable is not set\n                if (ssb && ssb.valueMembers) {\n                    funcTable = ssb.valueMembers.allMembers;\n                }\n            }\n\n            // If it's a class constructor, we need to check for the presence (or absense) of calls\n            // to the 'super' constructor\n            //\n            // A super constructor call must exist if:\n            //  - the class has a base class\n            //\n            // A super constructor call must be the first statement in the function body if:\n            //  - the constructor has parameter properties or\n            //  - the class body has initialized property decls\n            //\n            // A super constructor call may not exist if:\n            //  - The class has no base type, or inherits directly from 'Object'\n            if (funcDecl.isConstructor && funcDecl.bod && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {\n\n                var hasBaseType = hasFlag(funcDecl.classDecl.type.instanceType.typeFlags, TypeFlags.HasBaseType);\n                var noSuperCallAllowed = !hasBaseType || hasFlag(funcDecl.classDecl.type.instanceType.typeFlags, TypeFlags.HasBaseTypeOfObject);\n                var superCallMustBeFirst = hasFlag((<ClassDeclaration>funcDecl.classDecl).varFlags, VarFlags.ClassSuperMustBeFirstCallInConstructor);\n\n                if (noSuperCallAllowed && this.classConstructorHasSuperCall(funcDecl)) {\n                    this.checker.errorReporter.simpleError(funcDecl, \"Calls to 'super' constructor are not allowed in classes that either inherit directly from 'Object' or have no base class\");\n                }\n                else if (hasBaseType) {\n                    if (superCallMustBeFirst) {\n                        if (!funcDecl.bod ||\n                            !funcDecl.bod.members.length ||\n                            !((funcDecl.bod.members[0].nodeType == NodeType.Call && (<CallExpression>funcDecl.bod.members[0]).target.nodeType == NodeType.Super) ||\n                            (hasFlag(funcDecl.bod.flags, ASTFlags.StrictMode) && funcDecl.bod.members.length > 1 &&\n                             funcDecl.bod.members[1].nodeType == NodeType.Call && (<CallExpression>funcDecl.bod.members[1]).target.nodeType == NodeType.Super))) {\n                            this.checker.errorReporter.simpleError(funcDecl, \"If a derived class contains initialized properties or constructor parameter properties, the first statement in the constructor body must be a call to the super constructor\");\n                        }\n                    }\n                    else if (!this.classConstructorHasSuperCall(funcDecl)) {\n                        this.checker.errorReporter.simpleError(funcDecl, \"Constructors for derived classes must contain a call to the class's 'super' constructor\");\n                    }\n                }\n            }\n\n            // If we've typechecked this method \"out of order\" (not by walking the class, but through a method call somewhere else),\n            // we need to reset the current class node in question, so that vis",
v27477=v27478+"ibility checks on class members don't fail\n            if (funcDecl.isMethod() && funcDecl.type.enclosingType) {\n\n                var enclosingClassNode: TypeDeclaration = null;\n\n                if (funcDecl.type.enclosingType.symbol.declAST.nodeType == NodeType.FuncDecl) {\n                    enclosingClassNode = <TypeDeclaration>(<FuncDecl>funcDecl.type.enclosingType.symbol.declAST).classDecl;\n                }\n                else if (funcDecl.type.enclosingType.symbol.declAST.nodeType == NodeType.ClassDeclaration) {\n                    enclosingClassNode = <TypeDeclaration>funcDecl.type.enclosingType.symbol.declAST;\n                }\n\n                if (enclosingClassNode) {\n                    this.thisClassNode = enclosingClassNode;\n                }\n            }\n\n            // if this function is contained in a module, we may be in the midst of a recursive typecheck operation\n            // should that be the case, we need to properly set the current module (for visibility tests)\n            if (fnType.enclosingType) {;\n                var enclosingSym = fnType.symbol.container;\n\n                // if the enclosing type is a class, grab the parent module\n                if (enclosingSym && enclosingSym.isType() && enclosingSym.getType().isClass()) {\n                    enclosingSym = enclosingSym.container;\n                }\n\n                if (enclosingSym && enclosingSym.declAST && enclosingSym.declAST.nodeType == NodeType.ModuleDeclaration) {\n                    this.checker.currentModDecl = <ModuleDeclaration>enclosingSym.declAST;\n                }\n            }\n\n            if (funcDecl.unitIndex > 0) {\n                if (this.checker.units &&\n                    (funcDecl.unitIndex < this.checker.units.length)) {\n                    this.checker.locationInfo = this.checker.units[funcDecl.unitIndex];\n                }\n                else {\n                    this.checker.locationInfo = unknownLocationInfo;\n                }\n            }\n\n            if (fnType.enclosingType) {\n                this.thisType = fnType.enclosingType;\n            }\n            else {\n                this.thisType = prevThisType;\n            }\n\n            var paramLen = signature.parameters.length;\n\n            if (!funcDecl.isConstructor && funcDecl.bod && !funcDecl.isSignature()) {\n                var tmpParamScope = this.scope;\n                var ssb = <SymbolScopeBuilder>this.scope;\n\n                // Attempt to contextually type the function declaration             \n                if (!funcDecl.isMethod() && funcDecl.returnTypeAnnotation == null) {\n\n                    // the funcDecl may be a candidate for contextual typing                 \n                    // REVIEW: prevScope will only be null in the case of an upstream error\n                    if (prevScope && funcDecl.name && !funcDecl.name.isMissing()) {\n                        // Go ahead and check for an ambient symbol\n                        var considerSym: Symbol = prevScope.findAmbient(funcDecl.name.text, false, false);\n\n                        if (considerSym && considerSym.declAST && considerSym.declAST.type) {\n                            // REVIEW: Ambients beget signatures, and signatures don't need to be typechecked\n                            //typeCheck(considerSym.declAST);\n                            this.checker.setContextualType(considerSym.declAST.type, false);\n                        }\n                    }\n\n                    if (this.checker.hasTargetType()) {\n                        var candidateTypeContext = this.checker.getTargetTypeContext();\n                        var candidateType = candidateTypeContext.contextualType;\n\n                        if (this.checker.canContextuallyTypeFunction(candidateType, funcDecl, true)) {\n\n                            // Safe to do this, since the indices and fields are guaranteed to be\n                            // non-null and valid by the above call to canContextuallyTypeFunction\n                            var candidateSigs = candidateType.construct ? candidateType.construct : candidateType.call;\n                            candidateTypeContext.targetSig = candidateSigs.signatures[0];\n                            var candidateParams = candidateTypeContext.targetSig.parameters;\n\n                            // the target type has been accepted\n                            targetParams = candidateParams;\n                            targetReturnType = candidateTypeContext.targetSig.returnType.type;\n\n                            // Set \"this\" if applicable\n                            if (candidateTypeContext.targetSig.declAST) {\n                                if (candidateTypeContext.targetSig.declAST.isConstructor) {\n                                    //candidateTypeContext.targetThis=candidateType.instanceType;\n                                    //this.thisType = candidateType.instanceType;\n                                    funcDecl.isTargetTypedAsMethod = true;\n               ",
v27476=v27477+"                 }\n                                else if (candidateTypeContext.targetSig.declAST.isMethod()) {\n                                    //candidateTypeContext.targetThis=candidateTypeContext.targetSig.declAST.type.enclosingType;\n                                    //this.thisType = candidateTypeContext.targetSig.declAST.type.enclosingType;\n                                    funcDecl.isTargetTypedAsMethod = true;\n                                }\n                            }\n                            fgSym.type = candidateTypeContext.contextualType;\n                            acceptedContextualType = true;\n                        }\n                        else if (candidateType && funcDecl.isAccessor()) {\n                            accessorType = candidateType;\n                            candidateTypeContext.targetAccessorType = accessorType;\n                        }\n                        else {\n                            this.checker.killCurrentContextualType();\n                        }\n                    }\n                }\n\n                // typecheck parameters\n                // Add parameter symbols to current scope for typechecking (in case default params reference each other)\n                // Order matters here - default parameters can reference previously defined parameters\n                var paramTable = ssb.valueMembers;\n                this.scope = new SymbolScopeBuilder(paramTable, null, null, null, prevScope, container);\n\n                for (var p = 0; p < paramLen; p++) {\n                    var symbol = signature.parameters[p];\n                    var ast = <ArgDecl>symbol.declAST\n\n                    if (this.checker.hasTargetType() && (targetParams && (this.checker.getTargetTypeContext().targetSig.hasVariableArgList || p < targetParams.length))) {\n                        var candidateTypeContext = this.checker.getTargetTypeContext();\n                        var hasVarArgList = candidateTypeContext.targetSig.hasVariableArgList;\n                        ast.type = hasVarArgList && p >= targetParams.length - 1 ? targetParams[targetParams.length - 1].getType().elementType : targetParams[p].getType();\n                        ast.sym.setType(ast.type);\n                        (<InferenceSymbol>ast.sym).typeCheckStatus = this.checker.getTypeCheckFinishedStatus();\n                    }\n                    else {\n                        this.typeCheck(ast);\n                    }\n\n                    // infer the setter type, if necessary\n                    if (isSetter && accessorType) {\n                        ast = <ArgDecl>this.cast(ast, accessorType);\n                    }\n\n                    symbol.container = container;\n                    // Verify the parameter for the privacy\n                    this.checkTypePrivacy(symbol.getType(), container, (typeName: string, isModuleName: bool) => this.functionArgumentPrivacyErrorReporter(funcDecl, p, symbol, typeName, isModuleName));\n                    paramTable.publicMembers.add(symbol.name, symbol);\n                }\n                this.scope = tmpParamScope;\n            }\n            else {\n                this.typeCheck(funcDecl.arguments)\n\n                // Because some terms were not yet type-checkable during binding, ensure that\n                // param symbols are updated with the proper argument types\n                for (var p = 0; p < paramLen; p++) {\n                    signature.parameters[p].parameter.typeLink.type = funcDecl.arguments.members[p].type;\n                    // Verify the parameter for the privacy\n                    this.checkTypePrivacy(signature.parameters[p].getType(), container, (typeName: string, isModuleName: bool) => this.functionArgumentPrivacyErrorReporter(funcDecl, p, signature.parameters[p], typeName, isModuleName));\n                    if ((<ArgDecl>funcDecl.arguments.members[p]).parameterPropertySym) {\n                        (<ArgDecl>funcDecl.arguments.members[p]).parameterPropertySym.setType(funcDecl.arguments.members[p].type);\n                    }\n                }\n\n                if ((funcDecl.fncFlags & FncFlags.IndexerMember)) {\n                    if (!paramLen || paramLen > 1) {\n                        this.checker.errorReporter.simpleError(funcDecl, \"Index signatures may take one and only one parameter\");\n                    }\n                    else if (funcDecl.arguments.members[0].type == this.checker.numberType) {\n                        fnType.index.flags |= SignatureFlags.IsNumberIndexer;\n                    }\n                    else if (funcDecl.arguments.members[0].type == this.checker.stringType) {\n                        fnType.index.flags |= SignatureFlags.IsStringIndexer;\n                    }\n                    else {\n                        this.checker.errorReporter.simpleError(funcDecl.arguments.members[0], \"Index signatures may only take 'string' or 'number' as their parameter\");\n                    }\n\n                }\n            }\n\n       ",
v27475=v27476+"     // typecheck body\n            if (funcDecl.bod && (!funcDecl.isSignature())) {\n                if (!(funcDecl.isConstructor)) {\n                    this.addFormals(container, signature, funcTable);\n                }\n                else {\n                    this.addConstructorLocalArgs(funcDecl.type.symbol, funcDecl.arguments, funcTable, hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod));\n\n                    if (this.thisClassNode && this.thisClassNode.extendsList) {\n                        var tmpScope = this.scope;\n                        var funcMembers = new ScopedMembers(<DualStringHashTable>funcTable);\n                        this.scope = new FilteredSymbolScopeBuilder(funcMembers, prevScope, funcDecl.type.symbol,\n                                                             function (sym) {\n                                                                 return sym.kind() == SymbolKind.Parameter;\n                                                             });\n                        this.typeCheckBaseCalls(this.thisClassNode.extendsList);\n                        this.scope = tmpScope;\n                    }\n                }\n\n                // Because this function may have been typechecked in a different visiblity context as its caller (e.g., this\n                // function is being typechecked as a result of a call, before the declaration could be typechecked), we need\n                // to set the enclosing module\n                var prevMod = this.checker.currentModDecl;\n                if (funcDecl.type &&\n                    funcDecl.type.symbol &&\n                    !funcDecl.isMethod() &&\n                    funcDecl.type.symbol.declModule) {\n                    this.checker.currentModDecl = funcDecl.type.symbol.declModule;\n                }\n\n\n                // unset the contextual type before typechecking the function body\n                if (acceptedContextualType) {\n                    this.checker.setContextualType(null, this.checker.inProvisionalTypecheckMode());\n                }\n\n                this.typeCheck(funcDecl.bod);\n\n                if (acceptedContextualType) {\n                    this.checker.unsetContextualType();\n                }\n\n                this.checker.currentModDecl = prevMod;\n\n                if (this.checker.checkControlFlow) {\n                    var cfg = funcDecl.buildControlFlow();\n                    if (this.checker.printControlFlowGraph) {\n                        cfg.print(this.checker.errorReporter.outfile);\n                    }\n                    cfg.reportUnreachable(this.checker.errorReporter);\n                    if (this.checker.checkControlFlowUseDef) {\n                        cfg.useDef(this.checker.errorReporter, funcDecl.type.symbol);\n                    }\n                }\n\n                if (funcDecl.isConstructor) {\n                    var fns: ASTList = funcDecl.scopes;\n                    var fnsLen = fns.members.length;\n                    var freeVars: Symbol[];\n                    var sym: Symbol;\n                    var j = 0;\n                    for (; j < fnsLen; j++) {\n                        var fn = <FuncDecl>fns.members[j];\n                        if (!fn.isSignature()) {\n                            if (hasFlag(fn.fncFlags, FncFlags.Method) && (!hasFlag(fn.fncFlags, FncFlags.Static))) {\n                                this.checkPromoteFreeVars(fn, funcDecl.type.symbol);\n                            }\n                        }\n                    }\n                }\n            }\n\n            this.scope = prevScope;\n            this.thisFnc = prevFnc;\n            this.thisClassNode = prevClassNode;\n            this.enclosingFncIsMethod = prevMethodStatus;\n            this.thisType = prevThisType;\n            this.checker.locationInfo = prevLocationInfo;\n            this.checker.currentModDecl = prevModDecl;\n\n            signature.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();\n\n            // set the return type\n            if (funcDecl.returnTypeAnnotation) {\n                this.checkForVoidConstructor(funcDecl.returnTypeAnnotation.type, funcDecl.returnTypeAnnotation);\n\n                if (signature.returnType.type == null) {\n                    this.checker.resolveTypeLink(this.scope, signature.returnType, false);\n                }\n            }\n            else if (targetReturnType) {\n                signature.returnType.type = targetReturnType;\n            }\n\n            // If no return type annotation has been applied to the function declaration\n            // unify the return types from the given return statements\n\n            if (!(fgSym.flags & SymbolFlags.RecursivelyReferenced) && funcDecl.returnStatementsWithExpressions.length > 0) {\n                var collection: ITypeCollection = {\n                    getLength: () => { return funcDecl.returnStatementsWithExpressions.length; },\n                    setTypeAtIndex: (index: number, type: Type) => { funcDecl.returnStatementsWithExpressions[index].t",
v27474=v27475+'ype = type; },\n                    getTypeAtIndex: (index: number) => { return funcDecl.returnStatementsWithExpressions[index].type; }\n                }\n\n                var bestCommonReturnType = funcDecl.returnStatementsWithExpressions[0].type;\n                bestCommonReturnType = this.checker.findBestCommonType(bestCommonReturnType, null, collection, true);\n\n                if (bestCommonReturnType) {\n                    signature.returnType.type = this.checker.widenType(bestCommonReturnType);\n                }\n                else {\n                    for (var i = 0; i < funcDecl.returnStatementsWithExpressions.length; i++) {\n                        this.checker.errorReporter.simpleError(funcDecl.returnStatementsWithExpressions[i], "Incompatible return type");\n                    }\n                    signature.returnType.type = this.anyType;\n                }\n            }\n\n            var onlyHasThrow = false;\n\n            if (signature.returnType.type == null) {\n                if (hasFlag(funcDecl.fncFlags, FncFlags.HasReturnExpression)) {\n                    if (this.checker.styleSettings.implicitAny) {\n                        this.checker.errorReporter.styleError(funcDecl, "type implicitly set to \'any\'");\n                    }\n                    signature.returnType.type = this.anyType;\n                }\n                else {\n                    signature.returnType.type = this.voidType;\n                }\n            }\n            else if (signature.returnType.type == this.nullType || signature.returnType.type == this.checker.undefinedType) {\n                signature.returnType.type = this.anyType;\n            }\n            else if ((signature.returnType.type != this.voidType && signature.returnType.type != this.checker.undefinedType && signature.returnType.type != this.anyType)) {\n                // the signature declared a non-void type, but there\'s no return statement\n                if (!funcDecl.isSignature() &&\n                    !funcDecl.isConstructor &&\n                    !hasFlag(funcDecl.fncFlags, FncFlags.HasReturnExpression) &&\n                    !hasFlag(funcDecl.fncFlags, FncFlags.IsFatArrowFunction)) {\n                        // relax the restriction if the method only contains a single "throw" statement\n                    onlyHasThrow = (funcDecl.bod.members.length > 0) && (funcDecl.bod.members[0].nodeType == NodeType.Throw)\n\n                    if (!onlyHasThrow) {\n                        this.checker.errorReporter.simpleError(funcDecl.returnTypeAnnotation || funcDecl,\n                             "Function declared a non-void return type, but has no return expression");\n                    }\n                }\n\n                // Type check for return type Privacy\n                this.checkTypePrivacy(signature.returnType.type, container, (typeName: string, isModuleName: bool) => this.functionReturnTypePrivacyErrorReporter(funcDecl, signature, typeName, isModuleName));\n            }\n\n            // if the function declaration is a getter or a setter, set the type of the associated getter/setter symbol\n            if (funcDecl.accessorSymbol) {\n                var accessorType = funcDecl.accessorSymbol.getType();\n                if (!onlyHasThrow && hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor) && !hasFlag(funcDecl.fncFlags, FncFlags.HasReturnExpression)) {\n                    this.checker.errorReporter.simpleError(funcDecl, "Getters must return a value");\n                }\n                if (accessorType) {\n                    if ((hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor) && accessorType != signature.returnType.type) ||\n                        (funcDecl.arguments.members.length > 0 && accessorType != funcDecl.arguments.members[0].type)) {\n                        this.checker.errorReporter.simpleError(funcDecl, "Getter and setter types do not agree");\n                    }\n                }\n                else {\n                    if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {\n                        funcDecl.accessorSymbol.setType(signature.returnType.type);\n                    }\n                    else {\n                        if (funcDecl.arguments.members.length != 1) {\n                            this.checker.errorReporter.simpleError(funcDecl, "Setters may have one and only one argument");\n                        }\n                        else {\n                            funcDecl.accessorSymbol.setType(funcDecl.arguments.members[0].type);\n                        }\n                    }\n                }\n            }\n\n            this.typeCheckOverloadSignatures(fnType, funcDecl);\n            return funcDecl;\n        }\n\n        public typeCheckBases(type: Type) {\n            var seenInterface = false;\n            var bases = type.extendsList;\n            var baseLinks = type.extendsTypeLinks;\n            if (bases) {\n                var len = bases.length;\n\n                if (len > 0) {\n                    type.typeFlags |= TypeFlags.Has',
v27473=v27474+'BaseType;\n                }\n\n                for (var i = 0; i < len; i++) {\n                    if (bases[i] == this.checker.anyType) {\n                        // This may be the type from imported module and hence the type was not really resolved to the correct one.\n                        // Try resolving it again\n                        baseLinks[i].type = null;\n                        // There are no contextual errors when trying to verify the base class\n                        var oldErrors = this.checker.errorReporter.getCapturedErrors();\n                        CompilerDiagnostics.assert(oldErrors.length == 0, "There shouldnt be any contextual errors when typechecking base type names");\n                        this.checker.errorReporter.pushToErrorSink = true;\n                        bases[i] = this.checker.resolveBaseTypeLink(baseLinks[i], type.containedScope);\n                        this.checker.errorReporter.pushToErrorSink = false;\n                        this.checker.errorReporter.freeCapturedErrors();\n                    }\n\n                    var base = bases[i];\n                    var baseRef = baseLinks[i].ast;\n\n                    // make sure it\'s the global \'Object\' and not some alias\n                    var baseTypeOfObject = base.symbol && base.symbol.name == "Object" && base.symbol.container == this.checker.gloMod;\n\n                    if (baseTypeOfObject) {\n                        type.typeFlags |= TypeFlags.HasBaseTypeOfObject;\n                    }\n\n                    if (base.isClassInstance()) {\n                        if (!(type.isClassInstance())) {\n                            this.checker.errorReporter.simpleError(baseRef, "Interface base type must be interface");\n                        }\n                        else {\n                            if (seenInterface) {\n                                this.checker.errorReporter.simpleError(baseRef, "Class may not follow interface as base type");\n                            }\n                        }\n                    }\n                    else if (base.isModuleType()) {\n                        this.checker.errorReporter.simpleError(baseRef, "Types may not be derived from module types");\n                    }\n                    else if (base.members) {\n                        if (!seenInterface) {\n                            seenInterface = true;\n                        }\n                    }\n                    else {\n                        if (!(type.isClassInstance())) {\n                            this.checker.errorReporter.simpleError(baseRef,\n                                                                     "Interface base type must be interface");\n                        }\n                        else {\n                            this.checker.errorReporter.simpleError(baseRef,\n                                                                     "Base type must be interface or class");\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n\n        public checkMembersImplementInterfaces(implementingType: Type) {\n            var instanceType = implementingType.getInstanceType();\n            if (instanceType.implementsList) {\n                var len = instanceType.implementsList.length;\n\n                for (var i = 0; i < len; i++) {\n                    var interfaceType = instanceType.implementsList[i];\n                    var comparisonInfo = new TypeComparisonInfo();\n                    if (!this.checker.sourceIsSubtypeOfTarget(instanceType, interfaceType, comparisonInfo)) {\n                        var emsg = "Class \'" + instanceType.getTypeName() +\n                              "\' declares interface \'" + interfaceType.getTypeName() +\n                              "\' but does not implement it";\n                        if (!comparisonInfo.message) {\n                            this.checker.errorReporter.simpleErrorFromSym(instanceType.symbol, emsg);\n                        }\n                        else {\n                            this.checker.errorReporter.simpleErrorFromSym(instanceType.symbol, emsg + ": " + comparisonInfo.message);\n                        }\n                    }\n                }\n            }\n        }\n\n        public typeCheckBaseCalls(bases: ASTList) {\n            if (bases == null) {\n                return;\n            }\n            var basesLen = bases.members.length;\n            for (var i = 0; i < basesLen; i++) {\n                var baseExpr = bases.members[i];\n                var baseSymbol: Symbol = null;\n                if (baseExpr.nodeType == NodeType.Call) {\n                    this.typeCheckNew(baseExpr);\n                }\n            }\n        }\n\n        public assertUniqueNamesInBaseTypes(names: IHashTable, type: Type, classDecl: InterfaceDeclaration, checkUnique: bool): void {\n            if (type) {\n                if (type.members) {\n                    type.members.publicMembers.map((key, s, c) => {\n  ',
v27472=v27473+'                      var sym = <Symbol>s;\n                        var dup = names.lookup(sym.name);\n                        if (dup) {\n                            if (checkUnique) {\n                                this.checker.errorReporter.simpleError(classDecl,\n                                                                  "duplicate member name in bases for " + classDecl.name.actualText + ": " + type.symbol.name + " and " + dup.container.name + " both contain member with name " + sym.name);\n                            }\n                        }\n                        else {\n                            names.add(sym.name, sym);\n                        }\n                    }, null);\n                }\n                if (type.extendsList) {\n                    var len = type.extendsList.length;\n                    for (var i = 0; i < len; i++) {\n                        if (!(type.extendsList[i].symbol.flags & SymbolFlags.RecursivelyReferenced)) {\n                            this.assertUniqueNamesInBaseTypes(names, type.extendsList[i], classDecl, checkUnique);\n                        }\n                    }\n                }\n            }\n        }\n\n        public checkBaseTypeMemberInheritance(derivedType: Type, derivedTypeDecl: AST): void {\n            var instanceType = derivedType.getInstanceType();\n            if (instanceType.extendsList == null) {\n                return;\n            }\n\n            var len = instanceType.extendsList.length;\n            if (len > 0) {\n                var names = new StringHashTable();\n                if (instanceType.isClassInstance()) {\n                    for (var i = 0; i < len; i++) {\n                        this.assertUniqueNamesInBaseTypes(names, instanceType.extendsList[i], <InterfaceDeclaration>derivedTypeDecl, i > 0);\n                    }\n                }\n\n                if (instanceType.members) {\n                    instanceType.members.publicMembers.map((key, s, c) => {\n                        var sym = <Symbol>s;\n                        for (var j = 0; j < len; j++) {\n                            var base = instanceType.extendsList[j];\n                            if (base.memberScope == null) {\n                                this.checker.errorReporter.simpleError(derivedTypeDecl, "Base type \'" + base.symbol.name + "\' lacks an implementation.")\n                            }\n                            else {\n                                var bSym = base.memberScope.find(sym.name, false, false);\n                                if (bSym) {\n                                    var aType = sym.getType();\n                                    var bType = bSym.getType();\n                                    if (!(this.checker.sourceIsSubtypeOfTarget(aType, bType))) {\n                                        this.checker.errorReporter.simpleErrorFromSym(sym,\n                                                                          "Type of overridden member \'" + sym.name + "\' is not subtype of original member defined by type \'" + bSym.container.name + "\'");\n                                    }\n                                    else if ((sym.kind() == SymbolKind.Type) &&\n                                             (bSym.kind() == SymbolKind.Field)) {\n                                        this.checker.errorReporter.simpleErrorFromSym(sym,\n                                                                          "Cannot override field \'" + sym.name + "\' with method");\n                                    }\n                                }\n                            }\n                        }\n                    }, null);\n                }\n            }\n        }\n\n        public typeCheckClass(classDecl: ClassDeclaration): ClassDeclaration {\n            var typeSymbol = <TypeSymbol>classDecl.type.symbol;\n\n            if (typeSymbol.typeCheckStatus == TypeCheckStatus.Finished) {\n                return classDecl;\n            }\n            else if (typeSymbol.typeCheckStatus == TypeCheckStatus.Started) {\n                // REVIEW: report this recursion\n                //checker.errorReporter.recursionRequiresTypeAnnotation(classDecl);\n                return classDecl;\n            }\n            else {\n                typeSymbol.typeCheckStatus = TypeCheckStatus.Started;\n                this.checker.addStartedPTO(typeSymbol);\n            }\n\n            var prevScope = this.scope;\n            var svClassNode = this.thisClassNode;\n            this.thisClassNode = classDecl;\n            var classType = classDecl.type;\n            this.typeCheckBases(classType.instanceType);\n\n            this.typeCheckBaseListPrivacy(classDecl.extendsList, typeSymbol, true);\n            this.typeCheckBaseListPrivacy(classDecl.implementsList, typeSymbol, false);\n\n            var prevThisType = this.thisType;\n            this.thisType = classType.instanceType;\n            this.scope = classType.instanceType.containedScope;\n\n            // Add the constructor locals, if necessary\n  ',
v27471=v27472+'          if (classDecl.constructorDecl) {\n                this.scope = classType.instanceType.constructorScope;\n                var ssb = <SymbolScopeBuilder>this.scope;\n                var funcTable = ssb.valueMembers.allMembers;\n\n                this.addConstructorLocalArgs(classDecl.constructorDecl.type.symbol, classDecl.constructorDecl.arguments, funcTable, true);\n            }\n\n            this.typeCheck(classDecl.members);\n            typeSymbol.typeCheckStatus = TypeCheckStatus.Finished;\n            this.checkBaseTypeMemberInheritance(classType, classDecl);\n            this.checkMembersImplementInterfaces(classType);\n\n            this.typeCheckOverloadSignatures(classType, classDecl);\n            this.typeCheckOverloadSignatures(classType.instanceType, classDecl);\n\n            // if the class has no declared constructor, adapt its base class\'s signature group, if necessary\n            if (!classDecl.constructorDecl) {\n                if (classDecl.extendsList &&\n                    classDecl.extendsList.members.length &&\n                    classDecl.extendsList.members[0].type &&\n                    classDecl.extendsList.members[0].type.symbol.type.isClass()) {\n                    cloneParentConstructGroupForChildType(classDecl.type, classDecl.extendsList.members[0].type.symbol.type);\n                }\n            }\n\n            this.thisType = prevThisType;\n            this.thisClassNode = svClassNode;\n            this.scope = prevScope;\n            return classDecl;\n        }\n\n        public typeCheckOverloadSignatures(type: Type, ast: AST) {\n            if (type.call) {\n                type.call.typeCheck(this.checker, ast, type.construct != null);\n            }\n            if (type.construct) {\n                type.construct.typeCheck(this.checker, ast, false);\n            }\n            if (type.index) {\n                type.index.typeCheck(this.checker, ast, false);\n            }\n        }\n\n        public typeCheckInterface(interfaceDecl: InterfaceDeclaration): InterfaceDeclaration {\n            // overloads will be typechecked inline by the members\n            //this.typeCheckOverloadSignatures(interfaceDecl.type, interfaceDecl);\n            this.typeCheckBases(interfaceDecl.type);\n            this.typeCheckBaseListPrivacy(interfaceDecl.extendsList, interfaceDecl.type.symbol, true);\n            this.typeCheck(interfaceDecl.members);\n            this.checkBaseTypeMemberInheritance(interfaceDecl.type, interfaceDecl);\n\n            // propagate base type signatures\n            if (interfaceDecl.extendsList) {\n                for (var i = 0; i < interfaceDecl.extendsList.members.length; i++) {\n                    if (interfaceDecl.extendsList.members[i].type.call) {\n                        if (interfaceDecl.type.call) {\n                            interfaceDecl.type.call.signatures = interfaceDecl.type.call.signatures.concat(interfaceDecl.extendsList.members[i].type.call.signatures);\n                        }\n                        else {\n                            interfaceDecl.type.call = interfaceDecl.extendsList.members[i].type.call;\n                        }\n                    }\n                    if (interfaceDecl.extendsList.members[i].type.construct) {\n                        if (interfaceDecl.type.construct) {\n                            interfaceDecl.type.construct.signatures = interfaceDecl.type.construct.signatures.concat(interfaceDecl.extendsList.members[i].type.construct.signatures);\n                        }\n                        else {\n                            interfaceDecl.type.construct = interfaceDecl.extendsList.members[i].type.construct;\n                        }\n                    }\n                    if (interfaceDecl.extendsList.members[i].type.index) {\n                        if (interfaceDecl.type.index) {\n                            interfaceDecl.type.index.signatures = interfaceDecl.type.index.signatures.concat(interfaceDecl.extendsList.members[i].type.index.signatures);\n                        }\n                        else {\n                            interfaceDecl.type.index = interfaceDecl.extendsList.members[i].type.index;\n                        }\n                    }\n                }\n            }\n\n            return interfaceDecl;\n        }\n\n        public typeCheckImportDecl(importDecl: ImportDeclaration) {\n            var mod: ModuleType = <ModuleType>importDecl.alias.type;\n            var sym: TypeSymbol = null;\n            var prevInImportTC = this.inImportTypeCheck;\n            this.inImportTypeCheck = true;\n\n            this.typeCheck(importDecl.alias);\n            mod = <ModuleType>importDecl.alias.type;\n\n            if (mod == null) {\n                this.checker.errorReporter.simpleError(importDecl.alias, "Could not resolve module alias \'" + importDecl.id.actualText + "\'");\n                mod = <ModuleType>this.checker.anyType;\n                (<TypeSymbol>importDecl.id.sym).type = mod;\n            }\n\n            importDecl.id.type = mod;',
v27470=v27471+'\n            sym = mod.symbol;\n\n            if (!mod.isModuleType()) {\n                this.checker.errorReporter.simpleError(importDecl.alias, "A module cannot be aliased to a non-module type");\n            }\n            else {\n                sym.type = mod;\n                \n                // Add the imported module to the AMD dependency list\n                if (this.checker.typeFlow.currentScript && \n                    this.checker.typeFlow.currentScript.topLevelMod && \n                    this.checker.typeFlow.currentScript.topLevelMod.mod) \n                {\n                    this.checker.typeFlow.currentScript.topLevelMod.mod.importedModules.push(importDecl);\n                }\n\n                (<TypeSymbol>importDecl.id.sym).type = mod;\n\n                if (mod.symbol && mod.symbol.declAST) {\n                    (<ModuleDeclaration>mod.symbol.declAST).modFlags &= ~ModuleFlags.ShouldEmitModuleDecl;\n                }\n\n                //importDecl.id.sym = sym;\n                // REVIEW: Uncomment when you can toggle module codegen targets from the language service\n                //else if (typeFlow.checker.currentModDecl == null && \n                //            hasFlag((<ModuleDecl>sym.declAST).modFlags,ModuleFlags.IsDynamic) &&\n                //            moduleGenTarget == ModuleGenTarget.Asynchronous) \n                //{\n                //    typeFlow.checker.errorReporter.simpleError(alias, "In AMD codegen mode, dynamic modules may not be referenced from global scope.  (Wrap the file in a module declaration.)");\n                //}\n            }\n            this.inImportTypeCheck = prevInImportTC;\n            return importDecl;\n        }\n\n        public typeCheckModule(moduleDecl: ModuleDeclaration): ModuleDeclaration {\n\n            // In some really nasty cases of error recovery, we may not have a type\n            if (!moduleDecl.mod) {\n                return moduleDecl;\n            }\n\n            if (this.currentScript) {\n                this.currentScript.requiresGlobal = true;\n            }\n            var mod = moduleDecl.mod;\n            var sym: TypeSymbol = null;\n\n            var prevScope = this.scope;\n            var prevThisType = this.thisType;\n            var prevCurrentModDecl = this.checker.currentModDecl;\n            this.checker.currentModDecl = moduleDecl;\n\n            this.thisType = null;\n            this.scope = mod.containedScope;\n            this.typeCheck(moduleDecl.members);\n            sym = mod.symbol;\n\n            this.checker.currentModDecl = prevCurrentModDecl;\n            this.thisType = prevThisType;\n            this.scope = prevScope;\n\n            moduleDecl.type = mod;\n\n            if (sym) {\n                sym.typeCheckStatus = TypeCheckStatus.Finished;\n            }\n            return moduleDecl;\n        }\n\n        public typeCheckFor(forStmt: ForStatement): ForStatement {\n            forStmt.init = this.typeCheck(forStmt.init);\n            this.nestingLevel++;\n            forStmt.cond = this.typeCheck(forStmt.cond);\n            this.typeCheckCondExpr(forStmt.cond);\n            forStmt.incr = this.typeCheck(forStmt.incr);\n            this.nestingLevel--;\n            forStmt.body = this.typeCheck(forStmt.body);\n            this.typeCheckCompoundStmtBlock(forStmt.body, "for statement");\n            forStmt.type = this.voidType;\n            return forStmt;\n        }\n\n        public typeCheckWith(withStmt: WithStatement): WithStatement {\n            if (this.checker.errorsOnWith) {\n                this.checker.errorReporter.simpleError(withStmt.expr, "All symbols within a \'with\' block will be typed as \'any\'");\n            }\n            withStmt.expr = this.typeCheck(withStmt.expr);\n            this.checker.inWith = true;\n            withStmt.body = this.typeCheck(withStmt.body);\n            this.typeCheckCompoundStmtBlock(withStmt.body, "with statement");\n            this.checker.inWith = false;\n            return withStmt;\n        }\n\n        public typeCheckForIn(forInStmt: ForInStatement): ForInStatement {\n            forInStmt.obj = this.typeCheck(forInStmt.obj);\n            forInStmt.lval = this.cast(this.typeCheck(forInStmt.lval), this.checker.stringType);\n            if (forInStmt.lval.nodeType == NodeType.VarDecl) {\n\n                var varDecl = <VarDecl>forInStmt.lval;\n                if (varDecl.typeExpr) {\n                    this.checker.errorReporter.simpleError(varDecl, "Variable declarations for for/in expressions may not contain a type annotation");\n                }\n\n                if (varDecl.sym) {\n                    varDecl.sym.setType(this.checker.stringType);\n                }\n            }\n            forInStmt.body = this.typeCheck(forInStmt.body);\n            this.typeCheckCompoundStmtBlock(forInStmt.body, "for in statement");\n            return forInStmt;\n        }\n\n        public typeCheckWhile(whileStmt: WhileStatement): WhileStatement {\n            whileStmt.cond = this.typeCheck(whileStmt.cond);\n            this.typeCheckCondE',
v27469=v27470+'xpr(whileStmt.cond);\n            whileStmt.body = this.typeCheck(whileStmt.body);\n            this.typeCheckCompoundStmtBlock(whileStmt.body, "while statement");\n            whileStmt.type = this.voidType;\n            return whileStmt;\n        }\n\n        public typeCheckDoWhile(doWhileStmt: DoWhileStatement): DoWhileStatement {\n            doWhileStmt.cond = this.typeCheck(doWhileStmt.cond);\n            this.typeCheckCondExpr(doWhileStmt.cond);\n            doWhileStmt.body = this.typeCheck(doWhileStmt.body);\n            this.typeCheckCompoundStmtBlock(doWhileStmt.body, "do while statement");\n            doWhileStmt.type = this.voidType;\n            return doWhileStmt;\n        }\n\n        public typeCheckCondExpr(cond: AST) {\n            if (this.checker.styleSettings.assignmentInCond) {\n                if ((cond !== null) &&\n                    (cond.nodeType >= NodeType.Asg) &&\n                    (cond.nodeType <= NodeType.LastAsg)) {\n                    this.checker.errorReporter.simpleError(cond, "top-level assignment statement in conditional expression");\n                }\n            }\n        }\n\n        public typeCheckCompoundStmtBlock(stmts: AST, stmtType: string) {\n            if (this.checker.styleSettings.blockInCompoundStmt && stmts) {\n                if (stmts.nodeType != NodeType.Block) {\n                    this.checker.errorReporter.styleError(stmts, stmtType + " requires a block");\n                }\n            }\n        }\n        public typeCheckIf(ifStmt: IfStatement): IfStatement {\n            ifStmt.cond = this.typeCheck(ifStmt.cond);\n            this.typeCheckCondExpr(ifStmt.cond);\n            ifStmt.thenBod = this.typeCheck(ifStmt.thenBod);\n            ifStmt.elseBod = this.typeCheck(ifStmt.elseBod);\n            this.typeCheckCompoundStmtBlock(ifStmt.thenBod, "if statement");\n            this.typeCheckCompoundStmtBlock(ifStmt.elseBod, "if statement");\n            ifStmt.type = this.voidType;\n            return ifStmt;\n        }\n\n        public typeFromAccessorFuncDecl(funcDecl: FuncDecl) {\n            if (!funcDecl.isAccessor()) {\n                return null;\n            }\n\n            if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {\n                return funcDecl.type.call.signatures[0].returnType.type;\n            }\n            else {\n                return funcDecl.type.call.signatures[0].parameters[0].getType();\n            }\n        }\n\n        public typeCheckObjectLit(objectLit: UnaryExpression): void {\n\n            var resultType = new Type();\n            resultType.symbol = new TypeSymbol(this.checker.anon, objectLit.minChar,\n                                             objectLit.limChar - objectLit.minChar,\n                                             this.checker.locationInfo.unitIndex,\n                                             resultType);\n\n            resultType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            resultType.memberScope = new SymbolTableScope(resultType.members, null, null, null, null);\n\n            var aggScope = new SymbolAggregateScope(resultType.symbol);\n            aggScope.addParentScope(resultType.memberScope);\n            aggScope.addParentScope(this.scope);\n            resultType.containedScope = aggScope;\n            var memberDecls = <ASTList>objectLit.operand;\n            var prevThisType = this.thisType;\n            var acceptTargetType = false;\n            var targetType: Type = null;\n\n            if (this.checker.hasTargetType()) {\n                targetType = this.checker.getTargetTypeContext().contextualType;\n\n                if (targetType && targetType.symbol && !this.checker.typeStatusIsFinished(targetType.symbol.typeCheckStatus)) {\n                    if (targetType.symbol.declAST) {\n                        this.typeCheck(targetType.symbol.declAST);\n                    }\n                }\n                acceptTargetType = true;\n            }\n\n            if (memberDecls) {\n                for (var i = 0, len = memberDecls.members.length; i < len; i++) {\n\n                    var binex = <BinaryExpression>memberDecls.members[i];\n\n                    var id = binex.operand1;\n                    var text: string;\n                    var targetMember: Symbol = null;\n                    var fieldSymbol: FieldSymbol = null;\n\n                    if (id.nodeType == NodeType.Name) {\n                        text = (<Identifier>id).text;\n                    }\n                    else if (id.nodeType == NodeType.QString) {\n                        // TODO: set text to unescaped string\n                        var idText = (<StringLiteral>id).text;\n                        text = idText.substring(1, idText.length - 1);\n                    }\n                    else {\n                        this.checker.errorReporter.simpleError(objectLit,\n                                                          "malformed object literal");\n                        resultType = this.anyType;\n       ',
v27468=v27469+"                 break;\n                    }\n\n                    if (acceptTargetType && targetType.memberScope) {\n                        targetMember = targetType.memberScope.find(text, false, false);\n                    }\n\n                    // before typechecking an accessor function member, we need to initialize its accessor symbol\n                    if (binex.operand2.nodeType == NodeType.FuncDecl && (<FuncDecl>binex.operand2).isAccessor()) {\n\n                        var funcDecl = <FuncDecl>binex.operand2;\n                        var accessorSym: FieldSymbol = resultType.members.publicMembers.lookup(text);\n\n                        accessorSym = this.checker.createAccessorSymbol(funcDecl, accessorSym, resultType, true, false, resultType.memberScope, null);\n                        funcDecl.accessorSymbol = accessorSym;\n                        fieldSymbol = accessorSym;\n                        if (id.nodeType == NodeType.Name) {\n                            (<Identifier>id).sym = accessorSym;\n                        }\n                    }\n\n                    this.checker.typeCheckWithContextualType(acceptTargetType && targetMember ? targetMember.getType() : null, false, acceptTargetType, binex.operand2);\n\n                    if (acceptTargetType && targetMember) {\n                        // Note that we accept 'any' in place of a valid subtype                     \n                        if ((binex.operand2.type == this.anyType || this.checker.sourceIsAssignableToTarget(binex.operand2.type, targetMember.getType())) ||\n                            (binex.operand2.nodeType == NodeType.FuncDecl &&\n                            (<FuncDecl>binex.operand2).isAccessor() &&\n                                this.typeFromAccessorFuncDecl(<FuncDecl>binex.operand2) == targetMember.getType())) {\n                                    // set the field type to the proper contextual type\n                                    // this is especially important in the 'any' case, so that\n                                    // fields typed to 'any' aren't accepted for contextual typing,\n                                    // but never properly set to the target type\n                            binex.operand1.type = targetMember.getType();\n                        }\n                    }\n                    else {\n                        // here we sub in 'any' for 'undefined' to account for field initialization to\n                        // 'undefined'  \n                        binex.operand2.type = binex.operand2.type == this.checker.undefinedType ? this.anyType : binex.operand2.type;\n                    }\n\n                    // the field symbol hasn't been set by a getter or setter\n                    if (fieldSymbol == null) {\n                        var memberType = binex.operand2.type;\n                        var field = new ValueLocation();\n                        fieldSymbol =\n                            new FieldSymbol(text, id.minChar,\n                                            this.checker.locationInfo.unitIndex,\n                                            true, field);\n                        fieldSymbol.flags |= SymbolFlags.Property;\n                        field.symbol = fieldSymbol;\n                        fieldSymbol.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();\n                        field.typeLink = new TypeLink();\n                        field.typeLink.type = memberType;\n                        resultType.members.publicMembers.add(text, fieldSymbol);\n                    }\n                    fieldSymbol.isObjectLitField = true;\n                }\n            }\n\n            this.thisType = prevThisType;\n            objectLit.type = resultType;\n            if (targetType) {\n                objectLit.targetType = targetType;\n            }\n        }\n\n        public typeCheckArrayLit(arrayLit: UnaryExpression): void {\n            var elements = <ASTList>arrayLit.operand;\n            var elementType = this.anyType;\n            var targetElementType: Type = null;\n            var comparisonInfo = new TypeComparisonInfo();\n            comparisonInfo.onlyCaptureFirstError = true;\n\n            // if the target type is an array type, extract the element type\n            if (this.checker.hasTargetType()) {\n                var targetType = this.checker.getTargetTypeContext().contextualType;\n                if (targetType.elementType) {\n                    targetElementType = targetType.elementType;\n                }\n            }\n\n            if (elements) {\n\n                var prevInArrayElemTypeCheck = this.inArrayElementTypeCheck;\n\n                this.inArrayElementTypeCheck = true;\n                this.checker.typeCheckWithContextualType(targetElementType, this.checker.inProvisionalTypecheckMode(), targetElementType != null, elements);\n                this.inArrayElementTypeCheck = prevInArrayElemTypeCheck;\n\n                elementType = elements.members[0].type;\n\n                var collection: ITypeCo",
v27467=v27468+'llection = {\n                    getLength: () => { return elements.members.length; },\n                    setTypeAtIndex: (index: number, type: Type) => { elements.members[index].type = type; },\n                    getTypeAtIndex: (index: number) => { return elements.members[index].type; }\n                }\n\n                elementType = this.checker.findBestCommonType(elementType, targetElementType, collection, false, comparisonInfo);\n\n                // if the array type is the undefined type, we should widen it to any\n                // if it\'s of the null type, only widen it if it\'s not in a nested array element, so as not to \n                // short-circuit any checks for the best common type\n                if (elementType == this.checker.undefinedType || (!prevInArrayElemTypeCheck && elementType == this.nullType)) {\n                    elementType = this.anyType;\n                }\n            }\n            if (!elementType) {\n                var emsg = "Incompatible types in array literal expression";\n                if (!comparisonInfo.message) {\n                    this.checker.errorReporter.simpleError(arrayLit, emsg);\n                }\n                else {\n                    this.checker.errorReporter.simpleError(arrayLit, emsg + ": " + comparisonInfo.message);\n                }\n                elementType = this.anyType;\n            }\n            else if (targetElementType) {\n                // for the case of zero-length \'any\' arrays, we still want to set the contextual type, if\n                // need be\n                if (this.checker.sourceIsAssignableToTarget(elementType, targetElementType)) {\n                    elementType = targetElementType;\n                }\n            }\n\n            arrayLit.type = this.checker.makeArrayType(elementType);\n\n        }\n\n        public checkForVoidConstructor(type: Type, ast: AST) {\n            if (type &&\n                type.construct &&\n                type.construct.signatures.length > 0) {\n\n                for (var i = 0; i < type.construct.signatures.length; i++) {\n                    if (type.construct.signatures[i].returnType.type == this.checker.voidType) {\n                        this.checker.errorReporter.simpleError(ast, "Constructors may not have a return type of \'void\'");\n                        break;\n                    }\n                }\n            }\n        }\n\n        // REVIEW: the code below could set the signature type of the function to the current return\n        // type, which would have a benefit of reducing the risk of a recursive typecheck scenario, but is\n        // is technically wrong - mergeOrdered will only work properly if the best common supertype\n        // comes before any sibling types.  This would mean that if a function, "color()", returned\n        // three types (in order) - "Red", "Blue", and "IColor", an "Incompatible return type" error \n        // would be triggered.  However, if "color()" returned (in order) "Red", "IColor" and "Blue"\n        // no error would be triggered, and the return type of the function would be "IColor"\n        public typeCheckReturn(returnStmt: ReturnStatement): ReturnStatement {\n\n            if (this.thisFnc) {\n                var targetType: Type = null;\n\n                // determine the target type\n                if (this.checker.hasTargetType()) {\n                    var tcContext = this.checker.getTargetTypeContext();\n                    var accessorType = tcContext.targetAccessorType;\n\n                    if (accessorType) {\n                        targetType = accessorType;\n                    }\n                    else {\n                        var targetSig = this.checker.getTargetTypeContext().targetSig;\n                        if (targetSig && targetSig.returnType.type != this.voidType) {\n                            targetType = targetSig.returnType.type;\n                        }\n                    }\n                }\n\n                if (returnStmt.returnExpression) {\n                    this.thisFnc.fncFlags |= FncFlags.HasReturnExpression;\n\n                    if (targetType == null && this.thisFnc.returnTypeAnnotation && this.thisFnc.returnTypeAnnotation.type && this.thisFnc.returnTypeAnnotation.type != this.voidType) {\n                        targetType = this.thisFnc.returnTypeAnnotation.type;\n                    }\n\n                    this.checker.typeCheckWithContextualType(targetType, this.checker.inProvisionalTypecheckMode(), targetType != null, returnStmt.returnExpression);\n\n                    var expectedReturnType: Type =\n                        (this.thisFnc.returnTypeAnnotation && this.thisFnc.returnTypeAnnotation.type) ?\n                            this.thisFnc.returnTypeAnnotation.type :\n                            targetType;\n                    if (expectedReturnType) {\n                        if (expectedReturnType == this.voidType && returnStmt.returnExpression.type != this.voidType) {\n                            this.checker.errorReporter.simp',
v27466=v27467+'leError(returnStmt,\n                                                              "Return with value expression in void function");\n\n                            // even though we\'ve raised an error, use the more specific type\n                            returnStmt.type = returnStmt.returnExpression.type;\n                        }\n                        else {\n                            returnStmt.returnExpression = this.cast(returnStmt.returnExpression, expectedReturnType);\n                            returnStmt.type = expectedReturnType;\n                        }\n                    }\n                    else {\n                        if (targetType) {\n                            if (returnStmt.returnExpression.type != this.voidType) {\n                                returnStmt.returnExpression = this.cast(returnStmt.returnExpression, targetType);\n                            }\n                            else {\n                                returnStmt.returnExpression.type = targetType;\n                            }\n                        }\n                        returnStmt.type = returnStmt.returnExpression.type;\n                    }\n                    this.thisFnc.returnStatementsWithExpressions[this.thisFnc.returnStatementsWithExpressions.length] = returnStmt;\n                }\n                else {\n                    returnStmt.type = targetType == null ? this.checker.voidType : targetType; //((this.thisFnc.returnTypeAnnotation && this.thisFnc.returnTypeAnnotation.type) ? this.thisFnc.returnTypeAnnotation.type : this.checker.voidType) : targetType;\n                }\n            }\n\n            return returnStmt;\n        }\n\n        public typeCheckInstOf(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n\n            if (!((binex.operand1.type == this.checker.anyType || this.checker.sourceIsSubtypeOfTarget(binex.operand1.type, this.objectInterfaceType)) &&\n                    (binex.operand2.type == this.anyType || this.checker.sourceIsSubtypeOfTarget(binex.operand2.type, this.functionInterfaceType)))) {\n                this.checker.errorReporter.simpleError(ast, "The instanceof operator requires the left operand to be of type Any or an object type, and the right operand to be of type Any or a subtype of the Function interface type");\n            }\n            binex.type = this.booleanType;\n            return binex;\n        }\n\n        public typeCheckCommaOperator(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            binex.type = binex.operand2.type;\n            return binex;\n        }\n\n        public typeCheckLogOr(binex: BinaryExpression): BinaryExpression {\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            var leftType = binex.operand1.type;\n            var rightType = binex.operand2.type;\n\n            if (leftType == this.checker.anyType || rightType == this.checker.anyType) {\n                binex.type = this.checker.anyType;\n            }\n            else if (leftType == this.checker.booleanType) {\n                if (rightType == this.checker.booleanType) {\n                    binex.type = this.checker.booleanType;\n                }\n                else {\n                    binex.type = this.checker.anyType;\n                }\n            }\n            else if (leftType == this.checker.numberType) {\n                if (rightType == this.checker.numberType) {\n                    binex.type = this.checker.numberType;\n                }\n                else {\n                    binex.type = this.checker.anyType;\n                }\n            }\n            else if (leftType == this.checker.stringType) {\n                if (rightType == this.checker.stringType) {\n                    binex.type = this.checker.stringType;\n                }\n                else {\n                    binex.type = this.checker.anyType;\n                }\n            }\n            else {\n                if (this.checker.sourceIsSubtypeOfTarget(leftType, rightType)) {\n                    binex.type = rightType;\n                }\n                else if (this.checker.sourceIsSubtypeOfTarget(rightType, leftType)) {\n                    binex.type = leftType;\n                }\n                else {\n                    binex.type = this.checker.anyType;\n                }\n            }\n            return binex;\n        }\n\n        public typeCheckLogAnd(binex: BinaryExpression): BinaryExpression {\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            binex.type = binex.operand2.type;\n            return binex;\n        }\n\n        public tryAddCandidates(signature: Signature, actuals: Type[]',
v27465=v27466+", exactCandidates: Signature[], conversionCandidates: Signature[], comparisonInfo: TypeComparisonInfo): void {\n            var lowerBound = signature.nonOptionalParameterCount; // required parameters\n            var upperBound = signature.parameters.length; // required and optional parameters\n            var formalLen = lowerBound;\n            var acceptable = false;\n\n            if ((actuals.length >= lowerBound) && (signature.hasVariableArgList || actuals.length <= upperBound)) {\n                formalLen = (signature.hasVariableArgList ? signature.parameters.length : actuals.length);\n                acceptable = true;\n            }\n\n            var repeatType: Type = null;\n\n            if (acceptable || signature.hasVariableArgList) {\n                // assumed structure here is checked when signature is formed\n                if (signature.hasVariableArgList) {\n                    formalLen -= 1;\n                    repeatType = (<ParameterSymbol>signature.parameters[formalLen]).parameter.typeLink.type;\n                    repeatType = repeatType.elementType;\n                    acceptable = actuals.length >= formalLen;\n                }\n                var len = actuals.length;\n\n                var exact = acceptable;\n                var convert = acceptable;\n                for (var i = 0; i < len; i++) {\n                    var typeA: Type;\n                    if (i < formalLen) {\n                        typeA =\n                            (<ParameterSymbol>signature.parameters[i]).parameter.typeLink.type;\n                    }\n                    else {\n                        typeA = repeatType;\n                    }\n\n                    var typeB = actuals[i];\n                    if (!typeA || !typeB || !(this.checker.typesAreIdentical(typeA, typeB))) {\n                        exact = false;\n                    }\n                    // is the argument assignable to the parameter?\n                    if (!this.checker.sourceIsAssignableToTarget(typeB, typeA, comparisonInfo)) {\n                        convert = false;\n                    }\n                    if (!(exact || convert)) {\n                        break;\n                    }\n                }\n                if (exact) {\n                    exactCandidates[exactCandidates.length] = signature;\n                }\n                else if (convert && (exactCandidates.length == 0)) {\n                    conversionCandidates[conversionCandidates.length] = signature;\n                }\n\n            }\n        }\n\n        public resolveOverload(application: AST, group: SignatureGroup): Signature {\n            var rd = this.resolutionDataCache.getResolutionData();\n            var actuals = rd.actuals;\n            var exactCandidates = rd.exactCandidates;\n            var conversionCandidates = rd.conversionCandidates;\n            var candidate: Signature = null;\n            var hasOverloads = group.signatures.length > 1;\n            var comparisonInfo = new TypeComparisonInfo();\n            var args: ASTList = null;\n            var target: AST = null;\n\n            if (application.nodeType == NodeType.Call || application.nodeType == NodeType.New) {\n                var callEx = <CallExpression>application;\n                args = callEx.arguments;\n                target = callEx.target;\n                if (callEx.arguments) {\n                    var len = callEx.arguments.members.length;\n                    for (var i = 0; i < len; i++) {\n                        actuals[i] = callEx.arguments.members[i].type;\n                    }\n                }\n            }\n            else if (application.nodeType == NodeType.Index) {\n                var binExp = <BinaryExpression>application;\n                target = binExp.operand1;\n                args = new ASTList();\n                args.members[0] = binExp.operand2;\n                actuals[0] = binExp.operand2.type;\n            }\n\n            for (var j = 0, groupLen = group.signatures.length; j < groupLen; j++) {\n                var signature = group.signatures[j];\n                if (hasOverloads && signature == group.definitionSignature && !this.checker.canCallDefinitionSignature) {\n                    continue;\n                }\n                if (!signature.returnType.type && signature.declAST &&\n                    (signature.typeCheckStatus != TypeCheckStatus.Finished)) {\n                    this.typeCheckFunction(signature.declAST);\n                }\n                this.tryAddCandidates(signature, actuals, exactCandidates, conversionCandidates, comparisonInfo);\n            }\n            if (exactCandidates.length == 0) {\n\n                var applicableCandidates = this.checker.getApplicableSignatures(conversionCandidates, args, comparisonInfo);\n                if (applicableCandidates.length > 0) {\n                    var candidateInfo = this.checker.findMostApplicableSignature(applicableCandidates, args);\n                    if (candidateInfo.ambiguous) {\n                        this.checker.errorR",
v27464=v27465+'eporter.simpleError(target, "Ambiguous call expression - could not choose overload");\n                    }\n                    candidate = candidateInfo.sig;\n                }\n                else {\n                    var emsg = "Supplied parameters do not match any signature of call target";\n                    if (comparisonInfo.message) {\n                        this.checker.errorReporter.simpleError(target, emsg + ":\\n\\t" + comparisonInfo.message);\n                    }\n                    else {\n                        this.checker.errorReporter.simpleError(target, emsg);\n                    }\n                }\n            }\n            else {\n                if (exactCandidates.length > 1) {\n                    var applicableSigs: ApplicableSignature[] = [];\n                    for (var i = 0; i < exactCandidates.length; i++) {\n                        applicableSigs[i] = { signature: exactCandidates[i], hadProvisionalErrors: false };\n                    }\n                    var candidateInfo = this.checker.findMostApplicableSignature(applicableSigs, args);\n                    if (candidateInfo.ambiguous) {\n                        this.checker.errorReporter.simpleError(target, "Ambiguous call expression - could not choose overload");\n                    }\n                    candidate = candidateInfo.sig;\n                }\n                else {\n                    candidate = exactCandidates[0];\n                }\n            }\n\n            this.resolutionDataCache.returnResolutionData(rd);\n            return candidate;\n        }\n\n        public typeCheckNew(ast: AST): AST {\n            var callEx = <CallExpression>ast;\n\n            callEx.target = this.typeCheck(callEx.target);\n            var target = callEx.target;\n            if (target.type.construct || target.type.call) {\n                this.preTypeCheckCallArgs(callEx.arguments);\n            }\n            else {\n                callEx.arguments = <ASTList>this.typeCheck(callEx.arguments);\n            }\n\n            if (target.type == this.anyType) {\n                callEx.type = this.anyType;\n                callEx.arguments = <ASTList>this.typeCheck(callEx.arguments);\n            }\n            else {\n                if (target.type.construct) {\n                    var signature = this.resolveOverload(callEx, target.type.construct);\n                    if (signature == null) {\n                        callEx.type = this.anyType;\n                    }\n                    else if (signature.returnType.type == this.voidType) {\n                        callEx.type = this.anyType;\n                        callEx.signature = signature;\n                    }\n                    else {\n                        callEx.type = signature.returnType.type;\n                        callEx.signature = signature;\n                    }\n                }\n                else if (target.type.call) {\n                    var signature = this.resolveOverload(callEx, target.type.call);\n                    if (signature == null) {\n                        callEx.type = this.anyType;\n                    }\n                    else if ((signature.returnType.type == this.voidType) || (signature.returnType.type == this.anyType)) {\n                        callEx.type = this.anyType;\n                        callEx.signature = signature;\n                    }\n                    else {\n                        this.checker.errorReporter.simpleError(callEx.target,\n                           "new expression only valid on constructors");\n                    }\n                }\n                else if (target.type.elementType) {\n                    callEx.type = target.type;\n                }\n                else {\n                    this.checker.errorReporter.invalidCall(callEx, callEx.nodeType, this.scope);\n                    callEx.type = this.anyType;\n                }\n            }\n\n            this.postTypeCheckCallArgs(callEx);\n\n            return callEx;\n        }\n\n        // Typecheck all args that cannot be affected by contextual typing of overloads\n        public preTypeCheckCallArgs(args: ASTList) {\n\n            if (!args) {\n                return;\n            }\n\n            for (var i = 0; i < args.members.length; i++) {\n                switch (args.members[i].nodeType) {\n                    case NodeType.FuncDecl:\n                    case NodeType.ObjectLit:\n                    case NodeType.ArrayLit:\n                        continue;\n                    default:\n                        this.typeCheck(args.members[i]);\n                        break;\n                }\n            }\n        }\n\n        public postTypeCheckCallArgs(callEx: CallExpression) {\n\n            var acceptedTargetType = false;\n            var i = 0;\n\n            if (callEx.target &&\n                callEx.target.type &&\n                callEx.signature &&\n                callEx.arguments) {\n                var sig = callEx.signature;\n\n                if (sig && callEx.arguments.members.length >= si',
v27463=v27464+'g.nonOptionalParameterCount) {\n                    acceptedTargetType = true;\n                    var targetType: Type = null;\n                    var nonVarArgFormalParamLength = sig.hasVariableArgList ? sig.parameters.length - 1 : sig.parameters.length;\n                    var nonVarArgActualParamLength = callEx.arguments.members.length < nonVarArgFormalParamLength ? callEx.arguments.members.length : nonVarArgFormalParamLength\n\n                    for (i = 0; i < nonVarArgActualParamLength; i++) {\n                        targetType = sig.parameters[i].getType();\n                        switch (callEx.arguments.members[i].nodeType) {\n                            case NodeType.FuncDecl:\n                            case NodeType.ObjectLit:\n                            case NodeType.ArrayLit:\n                                this.checker.typeCheckWithContextualType(targetType, this.checker.inProvisionalTypecheckMode(), !sig.parameters[i].declAST.isParenthesized, callEx.arguments.members[i]);\n                                break;\n                        }\n                    }\n\n                    if (sig.hasVariableArgList) {\n                        var varArgParamIndex = sig.nonOptionalParameterCount - 1;\n                        targetType = sig.parameters[varArgParamIndex].getType();\n                        if (targetType) {\n                            targetType = targetType.elementType;\n                        }\n                        var isParenthesized = !sig.parameters[varArgParamIndex].declAST.isParenthesized;\n                        for (i = nonVarArgActualParamLength; i < callEx.arguments.members.length; i++) {\n                            switch (callEx.arguments.members[i].nodeType) {\n                                case NodeType.FuncDecl:\n                                case NodeType.ObjectLit:\n                                case NodeType.ArrayLit:\n                                    this.checker.typeCheckWithContextualType(targetType, this.checker.inProvisionalTypecheckMode(), isParenthesized, callEx.arguments.members[i]);\n                                    break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (!acceptedTargetType && callEx.arguments) {\n                this.checker.killCurrentContextualType();\n\n                for (i = 0; i < callEx.arguments.members.length; i++) {\n                    switch (callEx.arguments.members[i].nodeType) {\n                        case NodeType.FuncDecl:\n                        case NodeType.ObjectLit:\n                        case NodeType.ArrayLit:\n                            this.typeCheck(callEx.arguments.members[i]);\n                            break;\n                        default:\n                            continue;\n                    }\n                }\n            }\n        }\n\n        public typeCheckCall(ast: AST): AST {\n            var callEx = <CallExpression>ast;\n            if (this.checker.styleSettings.newMustBeUsed && (ast.nodeType == NodeType.New)) {\n                if (hasFlag(ast.flags, ASTFlags.IsStatement)) {\n                    this.checker.errorReporter.styleError(ast, "use of new expression as a statement");\n                }\n            }\n            else if ((!this.checker.styleSettings.evalOK) && (ast.nodeType == NodeType.Call)) {\n                if ((callEx.target.nodeType == NodeType.Name) && ((<Identifier>callEx.target).text == "eval")) {\n                    this.checker.errorReporter.styleError(callEx, "eval not permitted");\n                }\n            }\n\n            if (callEx.target.nodeType == NodeType.FuncDecl) {\n                (<FuncDecl>callEx.target).isInlineCallLiteral = true;\n            }\n\n            var prevInSuperCall = this.inSuperCall;\n\n            if (callEx.target.nodeType == NodeType.Super) {\n                this.inSuperCall = true;\n            }\n\n            callEx.target = this.typeCheck(callEx.target);\n            this.preTypeCheckCallArgs(callEx.arguments);\n\n            var target = callEx.target;\n\n            if ((target.type == null) || (target.type == this.anyType) || (this.functionInterfaceType && target.type == this.functionInterfaceType)) {\n                callEx.type = this.anyType;\n            }\n            else {\n                var fnType = target.type;\n                if (fnType.call) {\n                    var signature = this.resolveOverload(callEx, fnType.call);\n                    if (signature == null) {\n                        callEx.type = this.anyType;\n                    }\n                    else {\n                        callEx.type = signature.returnType.type;\n                        callEx.signature = signature;\n                    }\n                }\n                else {\n                    // track calls to class base class\n                    if (callEx.target.nodeType == NodeType.Super &&\n                        this.thisFnc &&\n                        this.thisFnc.isConstructor &&\n        ',
v27462=v27463+'                hasFlag(this.thisFnc.fncFlags, FncFlags.ClassMethod)) {\n\n                            // Need to use the class type for the construct signature, not the instance type\n                        var signature = fnType.symbol.type.construct ? this.resolveOverload(callEx, fnType.symbol.type.construct) : null;\n\n                        if (signature == null) {\n                            callEx.type = this.anyType;\n                        }\n                        else {\n                            callEx.flags |= ASTFlags.ClassBaseConstructorCall;\n                            callEx.type = signature.returnType.type;\n                            callEx.signature = signature;\n                        }\n                    }\n                    else {\n                        callEx.type = this.anyType;\n                        this.checker.errorReporter.invalidCall(callEx, callEx.nodeType, this.scope);\n                    }\n                }\n            }\n            this.postTypeCheckCallArgs(callEx);\n\n            this.inSuperCall = prevInSuperCall;\n\n            return callEx;\n        }\n\n        public assignScopes(ast: AST) {\n            var script = <Script>ast;\n            this.checker.locationInfo = script.locationInfo;\n            var globalChain = new ScopeChain(this.checker.gloMod, null, this.globalScope);\n            var context = new AssignScopeContext(globalChain, this, [this.checker.currentModDecl]);\n            getAstWalkerFactory().walk(ast, preAssignScopes, postAssignScopes, null, context);\n        }\n\n        public findMemberScope(enclosingScopeContext: EnclosingScopeContext, matchFlag: ASTFlags) {\n            var enclosingScope = enclosingScopeContext.getScope();\n            var pos = enclosingScopeContext.pos - enclosingScopeContext.getScriptFragmentPosition();\n            var scriptFragment = enclosingScopeContext.getScriptFragment();\n\n            var memContext = new MemberScopeContext(this, pos, matchFlag);\n            memContext.scope = enclosingScope;\n            if (scriptFragment.nodeType == NodeType.Name) {\n                return scriptFragment.type.getMemberScope(this);\n            }\n            else {\n                getAstWalkerFactory().walk(scriptFragment, preFindMemberScope, null, null, memContext);\n                if (memContext.ast && enclosingScopeContext.enclosingClassDecl && memContext.ast.type == enclosingScopeContext.enclosingClassDecl.type.instanceType) {\n                    enclosingScopeContext.publicsOnly = false;\n                }\n                if (memContext.type) {\n                    return memContext.type.getMemberScope(this);\n                }\n                else {\n                    return null;\n                }\n            }\n        }\n\n        public findMemberScopeAt(enclosingScopeContext: EnclosingScopeContext) {\n            return this.findMemberScope(enclosingScopeContext, ASTFlags.DotLHS);\n        }\n\n        public findMemberScopeAtFullAst(enclosingScopeContext: EnclosingScopeContext) {\n            var matchFlag = ASTFlags.DotLHS;\n            var pos = enclosingScopeContext.pos;\n            var astResult: AST = null;\n\n            var preFindMemberScopeFullAst = function (ast: AST, parent: AST, walker: IAstWalker) {\n                if (isValidAstNode(ast)) {\n                    // Note: pos == ast.limChar       in case of incomplete code (e.g. "foo.")\n                    // Note: (pos - 1) == ast.limChar in case of complete code (e.g. "foo.bar")\n                    if (hasFlag(ast.flags, matchFlag) && (pos == ast.limChar || (pos - 1) == ast.limChar)) {\n                        astResult = ast;\n                        walker.options.stopWalk();\n                    }\n\n                    // Stop traversal if range does not contain position\n                    walker.options.goChildren = (ast.minChar <= pos) && (pos <= ast.limChar);\n                }\n                return ast;\n            }\n\n            var preFindMemberScopeFullAstFuzy = function (ast: AST, parent: AST, walker: IAstWalker) {\n                if (isValidAstNode(ast)) {\n                    if (hasFlag(ast.flags, matchFlag) && ((ast.minChar < pos) && (pos <= ast.limChar))) {\n                        astResult = ast;\n                    }\n\n                    // Stop traversal if range does not contain position\n                    walker.options.goChildren = (ast.minChar <= pos) && (pos <= ast.limChar);\n                }\n                return ast;\n            }\n\n            getAstWalkerFactory().walk(enclosingScopeContext.script, preFindMemberScopeFullAst);\n\n            if (astResult == null) {\n                // Perform a more "fusy" match. This is because the limChar of AST nodes is sometimes\n                // not what we expect, for example:\n                //   foo./*comment*/;\n                // In this case, limChar points to ";" instead of "." (because of the trailing comment).\n                getAstWalkerFactory().walk(enclosingScopeContext.script, preFindMemberScopeFullAstFuzy)',
v27461=v27462+";\n            }\n\n            if (astResult &&\n                enclosingScopeContext.enclosingClassDecl &&\n                astResult.type == enclosingScopeContext.enclosingClassDecl.type.instanceType) {\n                enclosingScopeContext.publicsOnly = false;\n            }\n\n            if (astResult && astResult.type) {\n                return astResult.type.getMemberScope(this);\n            }\n            else {\n                return null;\n            }\n        }\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path='diagnostics.ts' />\n///<reference path='flags.ts' />\n///<reference path='nodeTypes.ts' />\n///<reference path='hashTable.ts' />\n///<reference path='ast.ts' />\n///<reference path='astWalker.ts' />\n///<reference path='astWalkerCallback.ts' />\n///<reference path='astPath.ts' />\n///<reference path='astLogger.ts' />\n///<reference path='binder.ts' />\n///<reference path='base64.ts' />\n///<reference path='sourceMapping.ts' />\n///<reference path='emitter.ts' />\n///<reference path='errorReporter.ts' />\n///<reference path='parser.ts' />\n///<reference path='printContext.ts' />\n///<reference path='scanner.ts' />\n///<reference path='scopeAssignment.ts' />\n///<reference path='scopeWalk.ts' />\n///<reference path='signatures.ts' />\n///<reference path='symbols.ts' />\n///<reference path='symbolScope.ts' />\n///<reference path='tokens.ts' />\n///<reference path='typeChecker.ts' />\n///<reference path='typeCollection.ts' />\n///<reference path='typeFlow.ts' />\n///<reference path='types.ts' />\n///<reference path='pathUtils.ts' />\n///<reference path='referenceResolution.ts' />\n///<reference path='precompile.ts' />\n///<reference path='incrementalParser.ts' />\n///<reference path='declarationEmitter.ts' />\n\nmodule TypeScript {\n\n    export enum UpdateUnitKind {\n        Unknown,\n        NoEdits,\n        EditsInsideSingleScope,\n    }\n\n    export class ScriptEditRange {\n        constructor (public minChar: number,\n                     public limChar: number,\n                     public delta: number) { }\n\n        static unknown(): ScriptEditRange {\n            return new ScriptEditRange(-1, -1, -1);\n        }\n\n        public isUnknown() {\n            return this.minChar === -1 && this.limChar === -1 && this.delta === -1;\n        }\n\n        public containsPosition(pos: number) {\n            return (this.minChar <= pos && pos < this.limChar)\n                || (this.minChar <= pos && pos < this.limChar + this.delta);\n        }\n\n        public toString(): string {\n            return \"editRange(minChar=\" + this.minChar + \", limChar=\" + this.limChar + \", delta=\" + this.delta + \")\";\n        }\n    }\n\n    export class UpdateUnitResult {\n\n        constructor (public kind: UpdateUnitKind, public unitIndex: number, public script1: Script, public script2: Script) { }\n\n        public scope1: AST = null;\n        public scope2: AST = null;\n        public editRange: ScriptEditRange = null;\n        public parseErrors: ErrorEntry[] = [];\n\n        static noEdits(unitIndex: number) {\n            return new UpdateUnitResult(UpdateUnitKind.NoEdits, unitIndex, null, null);\n        }\n\n        static unknownEdits(script1: Script, script2: Script, parseErrors: ErrorEntry[]) {\n            var result = new UpdateUnitResult(UpdateUnitKind.Unknown, script1.locationInfo.unitIndex, script1, script2);\n            result.parseErrors = parseErrors;\n            return result;\n        }\n\n        static singleScopeEdits(script1: Script, script2: Script, scope1: AST, scope2: AST, editRange: ScriptEditRange, parseErrors: ErrorEntry[]) {\n            var result = new UpdateUnitResult(UpdateUnitKind.EditsInsideSingleScope, script1.locationInfo.unitIndex, script1, script2);\n            result.scope1 = scope1;\n            result.scope2 = scope2;\n            result.editRange = editRange;\n            result.parseErrors = parseErrors;\n            return result;\n        }\n    }\n\n    export class ErrorEntry {\n        constructor (public unitIndex: number,\n                    public minChar: number,\n                    public limChar: number,\n                    public message: string) { }\n    }\n\n    export var defaultSettings = new CompilationSettings();\n\n    export interface EmitterIOHost {\n        // function that can even create a folder structure if needed\n        createFile(path: string, useUTF8?: bool): ITextWriter;\n\n        // function to check if file exists on the disk\n        fileExi",
v27460=v27461+'sts(path: string): bool;\n\n        // Function to check if the directory exists on the disk\n        directoryExists(path: string): bool;\n\n        // Resolves the path\n        resolvePath(path: string): string;\n    }\n\n    export class TypeScriptCompiler {\n        public parser = new Parser();\n        public typeChecker: TypeChecker;\n        public typeFlow: TypeFlow = null;\n        public scripts = new ASTList();\n        public units: LocationInfo[] = new LocationInfo[];\n        public errorReporter: ErrorReporter;\n\n        public persistentTypeState: PersistentGlobalTypeState;\n\n\n        public emitSettings: EmitOptions;\n\n        constructor (public errorOutput: ITextWriter, public logger: ILogger = new NullLogger(), public settings: CompilationSettings = defaultSettings) {\n            this.errorReporter = new ErrorReporter(this.errorOutput);\n            this.persistentTypeState = new PersistentGlobalTypeState(this.errorReporter);\n            this.errorReporter.parser = this.parser;\n            this.initTypeChecker(this.errorOutput);\n\n            this.parser.style_requireSemi = this.settings.styleSettings.requireSemi;\n            this.parser.style_funcInLoop = this.settings.styleSettings.funcInLoop;\n            this.parser.inferPropertiesFromThisAssignment = this.settings.inferPropertiesFromThisAssignment;\n            this.emitSettings = new EmitOptions(this.settings);\n            codeGenTarget = settings.codeGenTarget;\n        }\n\n        public timeFunction(funcDescription: string, func: () => any): any {\n            return TypeScript.timeFunction(this.logger, funcDescription, func);\n        }\n\n        public initTypeChecker(errorOutput: ITextWriter) {\n            // The initial "refresh" initializes the persistent type state\n            this.persistentTypeState.refreshPersistentState();\n            this.typeChecker = new TypeChecker(this.persistentTypeState);\n            this.typeChecker.errorReporter = this.errorReporter;\n\n            // REVIEW: These properties should be moved out of the typeCheck object\n            // ideally, CF should be a separate pass, independent of control flow\n            this.typeChecker.checkControlFlow = this.settings.controlFlow;\n            this.typeChecker.checkControlFlowUseDef = this.settings.controlFlowUseDef;\n            this.typeChecker.printControlFlowGraph = this.settings.printControlFlow;\n\n            this.typeChecker.errorsOnWith = this.settings.errorOnWith;\n            this.typeChecker.styleSettings = this.settings.styleSettings;\n            this.typeChecker.canCallDefinitionSignature = this.settings.canCallDefinitionSignature;\n\n            this.errorReporter.checker = this.typeChecker;\n            this.setErrorOutput(this.errorOutput);\n        }\n\n        public setErrorOutput(outerr) {\n            this.errorOutput = outerr;\n            this.errorReporter.setErrOut(outerr);\n            this.parser.outfile = outerr;\n        }\n\n        public emitCommentsToOutput() {\n            this.emitSettings = new EmitOptions(this.settings);\n        }\n\n        public setErrorCallback(fn: (minChar: number, charLen: number, message: string,\n            unitIndex: number) =>void ) {\n            this.parser.errorCallback = fn;\n        }\n\n        public updateUnit(prog: string, filename: string, setRecovery: bool) {\n            return this.updateSourceUnit(new StringSourceText(prog), filename, setRecovery);\n        }\n\n        public updateSourceUnit(sourceText: ISourceText, filename: string, setRecovery: bool): bool {\n            return this.timeFunction("updateSourceUnit(" + filename + ")", () => {\n                var updateResult = this.partialUpdateUnit(sourceText, filename, setRecovery);\n                return this.applyUpdateResult(updateResult);\n            });\n        }\n\n        // Apply changes to compiler state.\n        // Return "false" if the change is empty and nothing was updated.\n        public applyUpdateResult(updateResult: UpdateUnitResult): bool {\n            switch (updateResult.kind) {\n                case UpdateUnitKind.NoEdits:\n                    return false;\n\n                case UpdateUnitKind.Unknown:\n                    this.scripts.members[updateResult.unitIndex] = updateResult.script2;\n                    this.units[updateResult.unitIndex] = updateResult.script2.locationInfo;\n                    for (var i = 0, len = updateResult.parseErrors.length; i < len; i++) {\n                        var e = updateResult.parseErrors[i];\n                        if (this.parser.errorCallback) {\n                            this.parser.errorCallback(e.minChar, e.limChar - e.minChar, e.message, e.unitIndex);\n                        }\n                    }\n                    return true;\n\n                case UpdateUnitKind.EditsInsideSingleScope:\n                    new IncrementalParser(this.logger).mergeTrees(updateResult);\n                    return true;\n            }\n        }\n\n        public partialUpdateUnit(sourceText: ISourceText, filename: string, setRecovery:',
v27459=v27460+' bool): UpdateUnitResult {\n            return this.timeFunction("partialUpdateUnit(" + filename + ")", () => {\n                for (var i = 0, len = this.units.length; i < len; i++) {\n                    if (this.units[i].filename == filename) {\n                        if ((<Script>this.scripts.members[i]).isResident) {\n                            return UpdateUnitResult.noEdits(i);\n                        }\n\n                        if (setRecovery) {\n                            this.parser.setErrorRecovery(null);\n                        }\n\n                        var updateResult: UpdateUnitResult;\n\n                        // Capture parsing errors so that they are part of "updateResult"\n                        var parseErrors: ErrorEntry[] = [];\n                        var errorCapture = (minChar: number, charLen: number, message: string, unitIndex: number): void => {\n                            parseErrors.push(new ErrorEntry(unitIndex, minChar, minChar + charLen, message));\n                        };\n                        var svErrorCallback = this.parser.errorCallback;\n                        if (svErrorCallback)\n                            this.parser.errorCallback = errorCapture;\n\n                        var oldScript = <Script>this.scripts.members[i];\n                        var newScript = this.parser.parse(sourceText, filename, i);\n\n                        if (svErrorCallback)\n                            this.parser.errorCallback = svErrorCallback;\n\n                        updateResult = UpdateUnitResult.unknownEdits(oldScript, newScript, parseErrors);\n\n                        return updateResult;\n                    }\n                }\n                throw new Error("Unknown file \\"" + filename + "\\"");\n            });\n        }\n\n        public addUnit(prog: string, filename: string, keepResident? = false, referencedFiles?: IFileReference[] = []): Script {\n            return this.addSourceUnit(new StringSourceText(prog), filename, keepResident, referencedFiles);\n        }\n\n        public addSourceUnit(sourceText: ISourceText, filename: string, keepResident:bool, referencedFiles?: IFileReference[] = []): Script {\n            return this.timeFunction("addSourceUnit(" + filename + ", " + keepResident + ")", () => {\n                var script: Script = this.parser.parse(sourceText, filename, this.units.length, AllowedElements.Global);\n                script.referencedFiles = referencedFiles;\n                script.isResident = keepResident;\n                this.persistentTypeState.setCollectionMode(keepResident ? TypeCheckCollectionMode.Resident : TypeCheckCollectionMode.Transient);\n                var index = this.units.length;\n                this.units[index] = script.locationInfo;\n                this.typeChecker.collectTypes(script);\n                this.scripts.append(script);\n                return script\n            });\n        }\n\n        public parseUnit(prog: string, filename: string) {\n            return this.parseSourceUnit(new StringSourceText(prog), filename);\n        }\n\n        public parseSourceUnit(sourceText: ISourceText, filename: string) {\n            this.parser.setErrorRecovery(this.errorOutput);\n            var script: Script = this.parser.parse(sourceText, filename, 0);\n\n            var index = this.units.length;\n            this.units[index] = script.locationInfo;\n            this.typeChecker.collectTypes(script);\n            this.scripts.append(script);\n        }\n\n        public typeCheck() {\n            return this.timeFunction("typeCheck()", () => {\n                var binder = new Binder(this.typeChecker);\n                this.typeChecker.units = this.units;\n                binder.bind(this.typeChecker.globalScope, this.typeChecker.globals);\n                binder.bind(this.typeChecker.globalScope, this.typeChecker.ambientGlobals);\n                binder.bind(this.typeChecker.globalScope, this.typeChecker.globalTypes);\n                binder.bind(this.typeChecker.globalScope, this.typeChecker.ambientGlobalTypes);\n                this.typeFlow = new TypeFlow(this.logger, this.typeChecker.globalScope, this.parser, this.typeChecker);\n                var i = 0;\n                var script: Script = null;\n                var len = this.scripts.members.length;\n\n\n                this.persistentTypeState.setCollectionMode(TypeCheckCollectionMode.Resident);\n                // first, typecheck resident "lib" scripts, if necessary\n                for (i = 0; i < len; i++) {\n                    script = <Script>this.scripts.members[i];\n                    if (!script.isResident || script.hasBeenTypeChecked) { continue; }\n\n                    this.typeFlow.assignScopes(script);\n                    this.typeFlow.initLibs();\n                }\n                for (i = 0; i < len; i++) {\n                    script = <Script>this.scripts.members[i];\n                    if (!script.isResident || script.hasBeenTypeChecked) { continue; }\n\n                    this.typeFlow.typeCheck(script);',
v27458=v27459+'\n                    script.hasBeenTypeChecked = true;\n                }\n\n                // next typecheck scripts that may change\n                this.persistentTypeState.setCollectionMode(TypeCheckCollectionMode.Transient);\n                len = this.scripts.members.length;\n                for (i = 0; i < len; i++) {\n                    script = <Script>this.scripts.members[i];\n                    if (script.isResident) { continue; }\n                    this.typeFlow.assignScopes(script);\n                    this.typeFlow.initLibs();\n                }\n                for (i = 0; i < len; i++) {\n                    script = <Script>this.scripts.members[i];\n                    if (script.isResident) { continue; }\n                    this.typeFlow.typeCheck(script);\n                }\n\n                return null;\n            });\n        }\n\n        public cleanASTTypesForReTypeCheck(ast: AST) {\n            function cleanASTType(ast: AST, parent: AST): AST {\n                ast.type = null;\n                if (ast.nodeType == NodeType.VarDecl) {\n                    var vardecl = <VarDecl>ast;\n                    vardecl.sym = null;\n                }\n                else if (ast.nodeType == NodeType.ArgDecl) {\n                    var argdecl = <ArgDecl>ast;\n                    argdecl.sym = null;\n                }\n                else if (ast.nodeType == NodeType.Name) {\n                    var name = <Identifier>ast;\n                    name.sym = null;\n                }\n                else if (ast.nodeType == NodeType.FuncDecl) {\n                    var funcdecl = <FuncDecl>ast;\n                    funcdecl.signature = null;\n                    funcdecl.freeVariables = new Symbol[]\n                    funcdecl.symbols = null;\n                    funcdecl.accessorSymbol = null;\n                    funcdecl.scopeType = null;\n                }\n                else if (ast.nodeType == NodeType.ModuleDeclaration) {\n                    var modDecl = <ModuleDeclaration>ast;\n                    modDecl.mod = null;\n                }\n                else if (ast.nodeType == NodeType.With) {\n                    (<WithStatement>ast).withSym = null;\n                }\n                else if (ast.nodeType == NodeType.Catch) {\n                    (<Catch>ast).containedScope = null;\n                }\n                return ast;\n            }\n            TypeScript.getAstWalkerFactory().walk(ast, cleanASTType);\n        }\n\n        public cleanTypesForReTypeCheck() {\n            return this.timeFunction("cleanTypesForReTypeCheck()", () => {\n                for (var i = 0, len = this.scripts.members.length; i < len; i++) {\n                    var script = this.scripts.members[i];\n                    if ((<Script>script).isResident) {\n                        continue;\n                    }\n                    this.cleanASTTypesForReTypeCheck(script);\n                    this.typeChecker.collectTypes(script);\n                }\n\n                return null;\n            });\n        }\n\n        // Return "true" if the incremental typecheck was successful\n        // Return "false" if incremental typecheck failed, requiring a full typecheck\n        public attemptIncrementalTypeCheck(updateResult: TypeScript.UpdateUnitResult): bool {\n            return this.timeFunction("attemptIncrementalTypeCheck()", () => {\n                // updateResult.kind == editsInsideFunction\n                // updateResult.scope1 == old function\n                // updateResult.scope2 == new function\n                //REVIEW: What about typecheck errors? How do we replace the old ones with the new ones?\n                return false;\n            });\n        }\n\n        public reTypeCheck() {\n            return this.timeFunction("reTypeCheck()", () => {\n                CompilerDiagnostics.analysisPass++;\n                this.initTypeChecker(this.errorOutput);\n                this.persistentTypeState.setCollectionMode(TypeCheckCollectionMode.Transient);\n                this.cleanTypesForReTypeCheck();\n                return this.typeCheck();\n            });\n        }\n\n        private isDynamicModuleCompilation() {\n            for (var i = 0, len = this.scripts.members.length; i < len; i++) {\n                var script = <Script>this.scripts.members[i];\n                if (!script.isDeclareFile && script.topLevelMod != null) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private updateCommonDirectoryPath() {\n            var commonComponents: string[] = [];\n            var commonComponentsLength = -1;\n            for (var i = 0, len = this.scripts.members.length; i < len; i++) {\n                var script = <Script>this.scripts.members[i];\n                if (script.emitRequired(this.emitSettings)) {\n                    var fileName = script.locationInfo.filename;\n                    var fileComponents = filePathComponents(fileName);\n                    if (commonComponentsLength == -1) {\n            ',
v27457=v27458+'            // First time at finding common path\n                        // So common path = directory of file\n                        commonComponents = fileComponents;\n                        commonComponentsLength = commonComponents.length;\n                    } else {\n                        var updatedPath = false;\n                        for (var j = 0; j < commonComponentsLength && j < fileComponents.length; j++) {\n                            if (commonComponents[j] != fileComponents[j]) {\n                                // The new components = 0 ... j -1\n                                commonComponentsLength = j;\n                                updatedPath = true;\n\n                                if (j == 0) {\n                                    // Its error to not have common path\n                                    this.errorReporter.emitterError(null, "Cannot find the common subdirectory path for the input files");\n                                    return;\n                                }\n\n                                break;\n                            }\n                        }\n\n                        // If the fileComponent path completely matched and less than already found update the length\n                        if (!updatedPath && fileComponents.length < commonComponentsLength) {\n                            commonComponentsLength = fileComponents.length;\n                        }\n                    }\n                }\n            }\n\n            this.emitSettings.commonDirectoryPath = commonComponents.slice(0, commonComponentsLength).join("/") + "/";\n            if (this.emitSettings.outputOption.charAt(this.emitSettings.outputOption.length - 1) != "/") {\n                this.emitSettings.outputOption += "/";\n            }\n        }\n\n        public parseEmitOption(ioHost: EmitterIOHost) {\n            this.emitSettings.ioHost = ioHost;\n            if (this.emitSettings.outputOption == "") {\n                this.emitSettings.outputMany = true;\n                this.emitSettings.commonDirectoryPath = "";\n                return;\n            }\n\n            this.emitSettings.outputOption = switchToForwardSlashes(this.emitSettings.ioHost.resolvePath(this.emitSettings.outputOption));\n\n            // Determine if output options is directory or file\n            if (this.emitSettings.ioHost.directoryExists(this.emitSettings.outputOption)) {\n                // Existing directory\n                this.emitSettings.outputMany = true;\n            } else if (this.emitSettings.ioHost.fileExists(this.emitSettings.outputOption)) {\n                // Existing file\n                this.emitSettings.outputMany = false;\n            }\n            else {\n                // New File/directory\n                this.emitSettings.outputMany = !isJSFile(this.emitSettings.outputOption);\n            }\n\n            // Verify if options are correct\n            if (this.isDynamicModuleCompilation() && !this.emitSettings.outputMany) {\n                this.errorReporter.emitterError(null, "Cannot compile dynamic modules when emitting into single file");\n            }\n\n            // Parse the directory structure\n            if (this.emitSettings.outputMany) {\n                this.updateCommonDirectoryPath();\n            }\n        }\n\n        public useUTF8ForFile(script: Script) {\n            if (this.emitSettings.outputMany) {\n                return this.outputScriptToUTF8(script);\n            } else {\n                return this.outputScriptsToUTF8(<Script[]>(this.scripts.members));\n            }\n        }\n\n        static mapToDTSFileName(fileName: string, wholeFileNameReplaced: bool) {\n            return getDeclareFilePath(fileName);\n        }\n\n        private canEmitDeclarations(script?: Script) {\n            if (!this.settings.generateDeclarationFiles) {\n                return false;\n            }\n\n            // If its already a declare file or is resident or does not contain body \n            if (!!script && (script.isDeclareFile || script.isResident || script.bod == null)) {\n                return false;\n            }\n\n            return true;\n        }\n\n        public emitDeclarationsUnit(script: Script, reuseEmitter?: bool, declarationEmitter?: DeclarationEmitter) {\n            if (!this.canEmitDeclarations(script)) {\n                return null;\n            }\n\n            if (!declarationEmitter) {\n                var declareFileName = this.emitSettings.mapOutputFileName(script.locationInfo.filename, TypeScriptCompiler.mapToDTSFileName);\n                var declareFile = this.createFile(declareFileName, this.useUTF8ForFile(script));\n                declarationEmitter = new DeclarationEmitter(this.typeChecker, this.emitSettings, this.errorReporter);\n                declarationEmitter.setDeclarationFile(declareFile);\n            }\n\n            declarationEmitter.emitDeclarations(script);\n\n            if (!reuseEmitter) {\n                declarationEmitter.Close();\n                return null;\n            } else {',
v27456=v27457+'\n                return declarationEmitter;\n            }\n        }\n\n        public emitDeclarations() {\n            if (!this.canEmitDeclarations()) {\n                return;\n            }\n\n            if (this.errorReporter.hasErrors) {\n                // There were errors reported, do not generate declaration file\n                return;\n            }\n\n            if (this.scripts.members.length == 0) {\n                return;\n            }\n\n            var declarationEmitter: DeclarationEmitter = null;\n            for (var i = 0, len = this.scripts.members.length; i < len; i++) {\n                var script = <Script>this.scripts.members[i];\n                if (this.emitSettings.outputMany || declarationEmitter == null) {\n                    // Create or reuse file\n                    declarationEmitter = this.emitDeclarationsUnit(script, !this.emitSettings.outputMany);\n                } else {\n                    // Emit in existing emitter\n                    this.emitDeclarationsUnit(script, true, declarationEmitter);\n                }\n            }\n\n            if (declarationEmitter) {\n                declarationEmitter.Close();\n            }\n        }\n\n        static mapToFileNameExtension(extension: string, fileName: string, wholeFileNameReplaced: bool) {\n            if (wholeFileNameReplaced) {\n                // The complete output is redirected in this file so do not change extension\n                return fileName;\n            } else {\n                // Change the extension of the file\n                var splitFname = fileName.split(".");\n                splitFname.pop();\n                return splitFname.join(".") + extension;\n            }\n        }\n\n        static mapToJSFileName(fileName: string, wholeFileNameReplaced: bool) {\n            return TypeScriptCompiler.mapToFileNameExtension(".js", fileName, wholeFileNameReplaced);\n        }\n\n        public emitUnit(script: Script, reuseEmitter?: bool, emitter?: Emitter) {\n            if (!script.emitRequired(this.emitSettings)) {\n                return null;\n            }\n\n            var fname = script.locationInfo.filename;\n            if (!emitter) {\n                var outFname = this.emitSettings.mapOutputFileName(fname, TypeScriptCompiler.mapToJSFileName);\n                var outFile = this.createFile(outFname, this.useUTF8ForFile(script));\n                emitter = new Emitter(this.typeChecker, outFname, outFile, this.emitSettings, this.errorReporter);\n                if (this.settings.mapSourceFiles) {\n                    emitter.setSourceMappings(new TypeScript.SourceMapper(fname, outFname, outFile, this.createFile(outFname + SourceMapper.MapFileExtension, false), this.errorReporter));\n                }\n            } else if (this.settings.mapSourceFiles) {\n                emitter.setSourceMappings(new TypeScript.SourceMapper(fname, emitter.emittingFileName, emitter.outfile, emitter.sourceMapper.sourceMapOut, this.errorReporter));\n            }\n\n            this.typeChecker.locationInfo = script.locationInfo;\n            emitter.emitJavascript(script, TokenID.Comma, false);\n            if (!reuseEmitter) {\n                emitter.Close();\n                return null;\n            } else {\n                return emitter;\n            }\n        }\n\n        public emit(ioHost: EmitterIOHost) {\n            this.parseEmitOption(ioHost);\n\n            var emitter: Emitter = null;\n            for (var i = 0, len = this.scripts.members.length; i < len; i++) {\n                var script = <Script>this.scripts.members[i];\n                if (this.emitSettings.outputMany || emitter == null) {\n                    emitter = this.emitUnit(script, !this.emitSettings.outputMany);\n                } else {\n                    this.emitUnit(script, true, emitter);\n                }\n            }\n\n            if (emitter) {\n                emitter.Close();\n            }\n        }\n\n        public emitToOutfile(outputFile: ITextWriter) {\n            if (this.settings.mapSourceFiles) {\n                throw Error("Cannot generate source map");\n            }\n\n            if (this.settings.generateDeclarationFiles) {\n                throw Error("Cannot generate declaration files");\n            }\n\n            if (this.settings.outputOption != "") {\n                throw Error("Cannot parse output option");\n            }\n\n            var emitter: Emitter = emitter = new Emitter(this.typeChecker, "stdout", outputFile, this.emitSettings, this.errorReporter);;\n            for (var i = 0, len = this.scripts.members.length; i < len; i++) {\n                var script = <Script>this.scripts.members[i];\n                this.typeChecker.locationInfo = script.locationInfo;\n                emitter.emitJavascript(script, TokenID.Comma, false);\n            }\n        }\n\n        public emitAST(ioHost: EmitterIOHost) {\n            this.parseEmitOption(ioHost);\n\n            var outFile: ITextWriter = null;\n            var context: PrintContext = null;\n\n            for (var i = 0, ',
v27455=v27456+'len = this.scripts.members.length; i < len; i++) {\n                var script = <Script>this.scripts.members[i];\n                if (this.emitSettings.outputMany || context == null) {\n                    var fname = this.units[i].filename;\n                    var mapToTxtFileName = (fileName: string, wholeFileNameReplaced: bool) => {\n                        return TypeScriptCompiler.mapToFileNameExtension(".txt", fileName, wholeFileNameReplaced);\n                    };\n                    var outFname = this.emitSettings.mapOutputFileName(fname, mapToTxtFileName);\n                    outFile = this.createFile(outFname, this.useUTF8ForFile(script));\n                    context = new PrintContext(outFile, this.parser);\n                }\n                getAstWalkerFactory().walk(script, prePrintAST, postPrintAST, null, context);\n                if (this.emitSettings.outputMany) {\n                    try {\n                        outFile.Close();\n                    } catch (e) {\n                        this.errorReporter.emitterError(null, e.message);\n                    }\n                }\n            }\n\n            if (!this.emitSettings.outputMany) {\n                try {\n                    outFile.Close();\n                } catch (e) {\n                    this.errorReporter.emitterError(null, e.message);\n                }\n            }\n        }\n\n        private outputScriptToUTF8(script: Script): bool {\n            return script.containsUnicodeChar || (this.emitSettings.emitComments && script.containsUnicodeCharInComment);\n        }\n\n        private outputScriptsToUTF8(scripts: Script[]): bool {\n            for (var i = 0, len = scripts.length; i < len; i++) {\n                var script = scripts[i];\n                if (this.outputScriptToUTF8(script)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private createFile(fileName: string, useUTF8: bool): ITextWriter {\n            try {\n                // Creating files can cause exceptions, report them.   \n                return this.emitSettings.ioHost.createFile(fileName, useUTF8);\n            } catch (ex) {\n                this.errorReporter.emitterError(null, ex.message);\n            }\n        }\n    }\n\n    export class ScopeEntry {\n        constructor (\n            public name: string,\n            public type: string,\n            public sym: Symbol) {\n        }\n    }\n\n    export class ScopeTraversal {\n        constructor (private compiler: TypeScriptCompiler) {\n        }\n\n        public getScope(enclosingScopeContext: EnclosingScopeContext): SymbolScope {\n            if (enclosingScopeContext.enclosingObjectLit && enclosingScopeContext.isMemberCompletion) {\n                return enclosingScopeContext.getObjectLiteralScope();\n            }\n            else if (enclosingScopeContext.isMemberCompletion) {\n                if (enclosingScopeContext.useFullAst) {\n                    return this.compiler.typeFlow.findMemberScopeAtFullAst(enclosingScopeContext)\n                }\n                else {\n                    return this.compiler.typeFlow.findMemberScopeAt(enclosingScopeContext)\n                }\n            }\n            else {\n                return enclosingScopeContext.getScope();\n            }\n        }\n\n        public getScopeEntries(enclosingScopeContext: EnclosingScopeContext): ScopeEntry[] {\n            var scope = this.getScope(enclosingScopeContext);\n            if (scope == null) {\n                return [];\n            }\n\n            var inScopeNames: IHashTable = new StringHashTable();\n            var allSymbolNames: string[] = scope.getAllSymbolNames(enclosingScopeContext.isMemberCompletion);\n\n            // there may be duplicates between the type and value tables, so batch the symbols\n            // getTypeNamesForNames will prefer the entry in the value table\n            for (var i = 0; i < allSymbolNames.length; i++) {\n                var name = allSymbolNames[i];\n\n                // Skip global/internal symbols that won\'t compile in user code\n                if (name == globalId || name == "_Core" || name == "_element") {\n                    continue;\n                }\n\n                inScopeNames.add(name, "");\n            }\n\n            var svModuleDecl = this.compiler.typeChecker.currentModDecl;\n            this.compiler.typeChecker.currentModDecl = enclosingScopeContext.deepestModuleDecl;\n\n            var result = this.getTypeNamesForNames(enclosingScopeContext, inScopeNames.getAllKeys(), scope);\n\n            this.compiler.typeChecker.currentModDecl = svModuleDecl;\n            return result;\n        }\n\n        private getTypeNamesForNames(enclosingScopeContext: EnclosingScopeContext, allNames: string[], scope: SymbolScope): ScopeEntry[] {\n            var result: ScopeEntry[] = [];\n\n            var enclosingScope = enclosingScopeContext.getScope();\n            for (var i = 0; i < allNames.length; i++) {\n                var name = allNames[i];\n                //',
v27454=v27455+' Search for the id in the value space first\n                // if we don\'t find it, search in the type space.\n                // We don\'t want to search twice, because the first\n                // search may insert the name in the symbol value table\n                // if the scope is aggregate\n                var publicsOnly = enclosingScopeContext.publicsOnly && enclosingScopeContext.isMemberCompletion;\n                var symbol = scope.find(name, publicsOnly, false/*typespace*/);  // REVIEW: Should search public members only?\n                if (symbol == null) {\n                    symbol = scope.find(name, publicsOnly, true/*typespace*/);\n                }\n\n                var displayThisMember = symbol && symbol.flags & SymbolFlags.Private ? symbol.container == scope.container : true;\n\n                if (symbol) {\n                    // Do not add dynamic module names to the list, since they\'re not legal as identifiers\n                    if (displayThisMember && !isQuoted(symbol.name) && !isRelative(symbol.name)) {\n                        var typeName = symbol.getType().getScopedTypeName(enclosingScope);\n                        result.push(new ScopeEntry(name, typeName, symbol));\n                    }\n                }\n                else {\n                    // Special case for "true" and "false"\n                    // REVIEW: This may no longer be necessary?\n                    if (name == "true" || name == "false") {\n                        result.push(new ScopeEntry(name, "bool", this.compiler.typeChecker.booleanType.symbol));\n                    }\n                }\n            }\n\n            return result;\n        }\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export enum Primitive {\n        None = 0,\n        Void = 1,\n        Double = 2,\n        String = 4,\n        Boolean = 8,\n        Any = 16,\n        Null = 32,\n        Undefined = 64,\n    }\n\n    export class MemberName {\n        public prefix: string = "";\n        public suffix: string = "";\n\n        public isString() { return false; }\n        public isArray() { return false; }\n\n        public toString(): string {\n            return MemberName.memberNameToString(this);\n        }\n\n        static memberNameToString(memberName: MemberName): string {\n            var result = memberName.prefix;\n\n            if (memberName.isString()) {\n                result += (<MemberNameString>memberName).text;\n            }\n            else {\n                var ar = <MemberNameArray>memberName;\n                for (var index = 0; index < ar.entries.length; index++) {\n                    result += memberNameToString(ar.entries[index]);\n                    result += ar.delim;\n                }\n            }\n\n            result += memberName.suffix;\n            return result;\n        }\n\n        static create(text: string): MemberName;\n        static create(entry: MemberName, prefix: string, suffix: string): MemberName;\n        static create(arg1: any, arg2?: any, arg3?: any): MemberName {\n            if (typeof arg1 == "string") {\n                return new MemberNameString(arg1);\n            }\n            else {\n                var result = new MemberNameArray();\n                if (arg2)\n                    result.prefix = arg2;\n                if (arg3)\n                    result.suffix = arg3;\n                result.entries.push(arg1);\n                return result;\n            }\n        }\n    }\n\n    export class MemberNameString extends MemberName {\n        constructor (public text: string) {\n            super()\n        }\n\n        public isString() { return true; }\n    }\n\n    export class MemberNameArray extends MemberName {\n        public delim: string = "";\n        public entries: MemberName[] = [];\n\n        public isArray() { return true; }\n\n        public add(entry: MemberName) {\n            this.entries.push(entry);\n        }\n\n        public addAll(entries: MemberName[]) {\n            for (var i = 0 ; i < entries.length; i++) {\n                this.entries.push(entries[i]);\n            }\n        }\n    }\n\n    var currentTypeID = -1;\n\n    export class Type {\n        public typeID = currentTypeID++;\n\n        public members: ScopedMembers;\n        public ambientMembers: ScopedMembers;\n\n        public construct: SignatureGroup = null;\n        public call: SignatureGroup = null;\n        public index: SignatureGroup =',
v27453=v27454+' null;\n\n        // REVIEW: for either of the below, why do we have lists of types and lists of type links?\n        // interface can only extend\n        public extendsList: Type[];\n        public extendsTypeLinks: TypeLink[];\n\n        // class can also implement\n        public implementsList: Type[];\n        public implementsTypeLinks: TypeLink[];\n\n        public passTypeCreated: number = CompilerDiagnostics.analysisPass;\n\n        public baseClass(): Type {\n            if (this.extendsList && (this.extendsList.length > 0)) {\n                return this.extendsList[0];\n            }\n            else {\n                return null;\n            }\n        }\n\n        public elementType: Type;\n\n        public getArrayBase(arrInstType: Type, checker: TypeChecker): Type {\n            return this.arrayCache.specialize(arrInstType, checker);\n        }\n\n        public primitiveTypeClass: number = Primitive.None;\n\n        // REVIEW: Prune constructorScope\n        public constructorScope: SymbolScope;\n        public containedScope: SymbolScope;\n        public memberScope: SymbolScope;\n\n        public arrayCache: ArrayCache;\n\n        public typeFlags = TypeFlags.None;\n\n        public symbol: TypeSymbol;\n\n        public enclosingType: Type;\n        public instanceType: Type;\n\n        // REVIEW: Prune\n        public isClass() { return this.instanceType != null; }\n        public isArray() { return this.elementType != null; }\n        public isClassInstance() {\n            return this.symbol && !this.elementType && (<TypeSymbol>this.symbol).type.isClass();\n        }\n\n        public getInstanceType() {\n            if (this.isClass()) {\n                return this.instanceType;\n            }\n            else {\n                return this;\n            }\n        }\n\n        public hasImplementation() { return hasFlag(this.typeFlags, TypeFlags.HasImplementation); }\n        public setHasImplementation() { this.typeFlags |= TypeFlags.HasImplementation; }\n\n        public isDouble() { return hasFlag(this.primitiveTypeClass, Primitive.Double); }\n        public isString() { return hasFlag(this.primitiveTypeClass, Primitive.String); }\n        public isBoolean() { return hasFlag(this.primitiveTypeClass, Primitive.Boolean); }\n        public isNull() { return hasFlag(this.primitiveTypeClass, Primitive.Null); }\n\n        // REVIEW: No need for this to be a method\n        public getTypeName(): string {\n            return this.getMemberTypeName("", true, false, null);\n        }\n\n        public getScopedTypeName(scope: SymbolScope) {\n            return this.getMemberTypeName("", true, false, scope);\n        }\n\n        public getScopedTypeNameEx(scope: SymbolScope) {\n            return this.getMemberTypeNameEx("", true, false, scope);\n        }\n\n        // REVIEW: No need for this to be a method\n        public callCount() {\n            var total = 0;\n            if (this.call) {\n                total += this.call.signatures.length;\n            }\n            if (this.construct) {\n                total += this.construct.signatures.length;\n            }\n            if (this.index) {\n                total += this.index.signatures.length;\n            }\n            return total;\n        }\n\n        // REVIEW: No need for this to be a method\n        public getMemberTypeName(prefix: string, topLevel: bool, isElementType: bool, scope: SymbolScope): string {\n            var memberName = this.getMemberTypeNameEx(prefix, topLevel, isElementType, scope);\n            return memberName.toString();\n        }\n\n        // REVIEW: No need for this to be a method\n        public getMemberTypeNameEx(prefix: string, topLevel: bool, isElementType: bool, scope: SymbolScope): MemberName {\n            if (this.elementType) {\n                return MemberName.create(this.elementType.getMemberTypeNameEx(prefix, false, true, scope), "", "[]");\n            }\n            else if (this.symbol && this.symbol.name && this.symbol.name != "_anonymous" &&\n                     (((this.call == null) && (this.construct == null) && (this.index == null)) ||\n                      (hasFlag(this.typeFlags, TypeFlags.BuildingName)) ||\n                      (this.members && (!this.isClass())))) {\n                var tn = this.symbol.scopeRelativeName(scope);\n                return MemberName.create(tn == "null" ? "any" : tn); // REVIEW: GROSS!!!\n            }\n            else {\n                if (this.members || this.call || this.construct) {\n                    if (hasFlag(this.typeFlags, TypeFlags.BuildingName)) {\n                        return MemberName.create("this");\n                    }\n                    this.typeFlags |= TypeFlags.BuildingName;\n                    var builder = "";\n                    var allMemberNames = new MemberNameArray();\n                    var curlies = isElementType || this.index != null;\n                    var memCount = 0;\n                    var delim = "; ";\n                    if (this.members) {\n                        this.members.allMembers.map((key, ',
v27452=v27453+'s, unused) => {\n                            var sym = <Symbol>s;\n                            if (!hasFlag(sym.flags, SymbolFlags.BuiltIn)) {\n                                // Remove the delimiter character from the generated type name, since\n                                // our "allMemberNames" array takes care of storing delimiters\n                                var typeNameMember = sym.getTypeNameEx(scope);\n                                if (typeNameMember.isArray() && (<MemberNameArray>typeNameMember).delim == delim) {\n                                    allMemberNames.addAll((<MemberNameArray>typeNameMember).entries);\n                                } else {\n                                    allMemberNames.add(typeNameMember);\n                                }\n                                memCount++;\n                                curlies = true;\n                            }\n                        }, null);\n                    }\n\n                    var signatureCount = this.callCount();\n                    var j: number;\n                    var len = 0;\n                    var shortform = !curlies && signatureCount == 1 && topLevel;\n                    if (this.call) {\n                        allMemberNames.addAll(this.call.toStrings(prefix, shortform, scope));\n                    }\n\n                    if (this.construct) {\n                        allMemberNames.addAll(this.construct.toStrings("new", shortform, scope));\n                    }\n\n                    if (this.index) {\n                        allMemberNames.addAll(this.index.toStrings("", shortform, scope));\n                    }\n\n                    if ((curlies) || ((signatureCount > 1) && topLevel)) {\n                        allMemberNames.prefix = "{ ";\n                        allMemberNames.suffix = "}";\n                        allMemberNames.delim = delim;\n                    } else if (allMemberNames.entries.length > 1) {\n                        allMemberNames.delim = delim;\n                    }\n\n                    this.typeFlags &= (~TypeFlags.BuildingName);\n                    if ((signatureCount == 0) && (memCount == 0)) {\n                        return MemberName.create("{}");\n                    }\n                    else {\n                        return allMemberNames;\n                    }\n                }\n                else {\n                    return MemberName.create("{}");\n                }\n            }\n        }\n\n        public checkDecl(checker: TypeChecker) {\n            if (this.isClassInstance() || this.isClass()) {\n                if (this.symbol.declAST) {\n                    checker.typeFlow.inScopeTypeCheckDecl(this.symbol.declAST);\n                }\n            }\n        }\n\n        public getMemberScope(flow: TypeFlow) {\n            if (this == flow.anyType) {\n                return null;\n            }\n            else if (this.isDouble()) {\n                if (flow.numberInterfaceType) {\n                    return flow.numberInterfaceType.memberScope;\n                }\n                else {\n                    return null;\n                }\n            }\n            else if (this.isBoolean()) {\n                if (flow.booleanInterfaceType) {\n                    return flow.booleanInterfaceType.memberScope;\n                }\n                else {\n                    return null;\n                }\n            }\n            else if (this == flow.stringType) {\n                if (flow.stringInterfaceType) {\n                    return flow.stringInterfaceType.memberScope;\n                }\n                else {\n                    return null;\n                }\n            }\n            else if (this.elementType) {\n                if (flow.arrayInterfaceType) {\n                    var arrInstType = this.elementType.getArrayBase(flow.arrayInterfaceType, flow.checker);\n                    return arrInstType.memberScope;\n                }\n                else {\n                    return null;\n                }\n            }\n            else {\n                return this.memberScope;\n            }\n        }\n\n        public isReferenceType() {\n            return this.members || this.extendsList ||\n                this.construct || this.call || this.index ||\n                this.elementType;\n        }\n\n        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker, membersOnly: bool): Type {\n            if (pattern == this) {\n                return replacement;\n            }\n            var result = this;\n            if (membersOnly) {\n                // assume interface type without bases\n                if (this.isReferenceType()) {\n                    result = new Type();\n                    if (this.members) {\n                        result.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n\n                        this.members.publicMembers.map((key, s, unused) => {\n                            var sym = <Symbol>s;\n         ',
v27451=v27452+"                   var bSym = sym.specializeType(pattern, replacement, checker);\n                            result.members.addPublicMember(bSym.name, bSym);\n                        }, null);\n\n                        this.members.privateMembers.map((key, s, unused) => {\n                            var sym = <Symbol>s;\n                            var bSym = sym.specializeType(pattern, replacement, checker);\n                            result.members.addPrivateMember(bSym.name, bSym);\n                        }, null);\n                    }\n                    if (this.ambientMembers) {\n                        result.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                        this.ambientMembers.publicMembers.map((key, s, unused) => {\n                            var sym = <Symbol>s;\n                            var bSym = sym.specializeType(pattern, replacement, checker);\n                            result.ambientMembers.addPublicMember(bSym.name, bSym);\n                        }, null);\n\n                        this.ambientMembers.privateMembers.map((key, s, unused) => {\n                            var sym = <Symbol>s;\n                            var bSym = sym.specializeType(pattern, replacement, checker);\n                            result.ambientMembers.addPrivateMember(bSym.name, bSym);\n                        }, null);\n                    }\n                    result.containedScope = checker.scopeOf(result);\n                    result.memberScope = result.containedScope;\n                }\n            }\n            else {\n                if (this.elementType) {\n                    if (this.elementType == pattern) {\n                        result = checker.makeArrayType(replacement);\n                    }\n                    else {\n                        if (this.elementType.elementType == pattern) {\n                            result = checker.makeArrayType(checker.makeArrayType(replacement));\n                        }\n                    }\n                }\n                else if (this.call) {\n                    result = new Type();\n                    result.call = this.call.specializeType(pattern, replacement, checker);\n                }\n            }\n            return result;\n        }\n\n        public hasBase(baseType: Type): bool {\n            if (baseType == this) {\n                return true;\n            }\n            else {\n                if (this.extendsList) {\n                    for (var i = 0, len = this.extendsList.length; i < len; i++) {\n                        if (this.extendsList[i].hasBase(baseType)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n\n        public mergeOrdered(b: Type, checker: TypeChecker, acceptVoid: bool, comparisonInfo?: TypeComparisonInfo): Type {\n            if ((this == checker.anyType) || (b == checker.anyType)) {\n                return checker.anyType;\n            }\n            else if (this == b) {\n                return this;\n            }\n            else if ((b == checker.nullType) && this != checker.nullType) {\n                return this;\n            }\n            else if ((this == checker.nullType) && (b != checker.nullType)) {\n                return b;\n            }\n            else if (acceptVoid && (b == checker.voidType) && this != checker.voidType) {\n                return this;\n            }\n            else if (acceptVoid && (this == checker.voidType) && (b != checker.voidType)) {\n                return b;\n            }\n            else if ((b == checker.undefinedType) && this != checker.undefinedType) {\n                return this;\n            }\n            else if ((this == checker.undefinedType) && (b != checker.undefinedType)) {\n                return b;\n            }\n            else if (this.elementType && b.elementType) {\n                if (this.elementType == b.elementType) {\n                    return this;\n                }\n                else {\n                    var mergedET = this.elementType.mergeOrdered(b.elementType, checker, acceptVoid, comparisonInfo);\n                    if (mergedET == null) {\n                        return checker.makeArrayType(checker.anyType);\n                    }\n                    else {\n                        return checker.makeArrayType(mergedET);\n                    }\n                }\n            }\n            else if (checker.sourceIsSubtypeOfTarget(this, b, comparisonInfo)) {\n                return b;\n            }\n            else if (checker.sourceIsSubtypeOfTarget(b, this, comparisonInfo)) {\n                return this;\n            }\n            else {\n                return null;\n            }\n        }\n\n        public isModuleType() { return false; }\n        public hasMembers() { return this.members != null; }\n        public getAllEnclosedTypes(): ScopedMembers { return null; }\n        public getAllAmbientEnc",
v27450=v27451+'losedTypes(): ScopedMembers { return null; }\n        public getPublicEnclosedTypes(): ScopedMembers { return null; }\n        public getpublicAmbientEnclosedTypes(): ScopedMembers { return null; }\n\n        public getDocComments(): Comment[]{\n            if (this.elementType || !this.symbol) {\n                return [];\n            }\n\n            if (this.isClassInstance() || this.isClass()) {\n                if (this.symbol.declAST.nodeType == NodeType.FuncDecl) {\n                    // Its a constructor - use the class declaration instead\n                    return (<FuncDecl>this.symbol.declAST).classDecl.getDocComments();\n                } else {\n                    // Its a class without constructor\n                    return this.symbol.getDocComments();\n                }\n            }\n\n            if (this.symbol.name && this.symbol.name != "_anonymous" &&\n                (((this.call == null) && (this.construct == null) && (this.index == null))\n                  || this.members)) {\n                return this.symbol.getDocComments();\n            }\n\n            return [];\n        }\n    }\n\n    export interface ITypeCollection {\n        // returns null when types are exhausted\n        getLength(): number;\n        setTypeAtIndex(index: number, type: Type): void;\n        getTypeAtIndex(index: number): Type;\n    }\n\n    export class ModuleType extends Type {\n\n        constructor (public enclosedTypes: ScopedMembers, public ambientEnclosedTypes: ScopedMembers) {\n            super();\n        }\n\n        public isModuleType() { return true; }\n        public hasMembers() { return this.members != null || this.enclosedTypes != null; }\n        public getAllEnclosedTypes() { return this.enclosedTypes; }\n        public getAllAmbientEnclosedTypes() { return this.ambientEnclosedTypes; }\n        public getPublicEnclosedTypes(): ScopedMembers { return null; }\n        public getpublicAmbientEnclosedTypes(): ScopedMembers { return null; }\n        public importedModules: ImportDeclaration[] = [];\n\n        // Finds the dynamic module name of moduleType in the members\n        // ignoreSymbols define list of symbols already visited - to avoid recursion\n        static findDynamicModuleNameInHashTable(moduleType: Type, members: IHashTable) {\n            var moduleName: { name: string; symbol: Symbol; } = null;\n            members.map((key, s, c) => {\n                if (moduleName == null && !isQuoted(key)) {\n                    var symbol = <Symbol>s;\n                    var type = symbol.getType();\n                    if (type == moduleType) {\n                        // If this is the module type we were looking for\n                        moduleName = { name: key, symbol: symbol };\n                    }\n                }\n            }, null);\n\n            return moduleName;\n        }\n\n        // Finds the Dynamic module name of the moduleType in this moduleType\n        // onlyPublic tells if we are looking for module name in public members only\n        public findDynamicModuleName(moduleType: Type): { name: string; symbol: Symbol; } {\n            var moduleName: { name: string; symbol: Symbol; } = null;\n            // Not cached, so seach and add to the cache\n            moduleName = ModuleType.findDynamicModuleNameInHashTable(moduleType, this.members.allMembers);\n            if (moduleName == null) {\n                moduleName = ModuleType.findDynamicModuleNameInHashTable(moduleType, this.ambientMembers.allMembers);\n            }\n            return moduleName;\n        }\n    }\n\n    export class TypeLink {\n        public type: Type = null;\n        public ast: AST = null;\n    }\n\n    export function getTypeLink(ast: AST, checker: TypeChecker, autoVar: bool): TypeLink {\n        var result = new TypeLink();\n\n        result.ast = ast;\n\n        if ((ast == null) && (autoVar)) {\n            result.type = checker.anyType;\n        }\n        else {\n            result.type = null;\n        }\n\n        return result;\n    }\n\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule Tools {\n    export interface IWalkContext {\n        goChildren: bool;\n        goNextSibling: bool;\n        // visit siblings in reverse execution order\n        reverseSiblings: bool;\n    }\n\n    export class BaseWalkContext implements IWalkContext {\n        public goChildren = true;\n        public goNextSibling = true;\n        public reverseSiblings = false;\n    }\n}',
compiler_input=v27450,TypeScript,v18791=TypeScript,v22792=!v18791;v22792&&(v18791=TypeScript={});var v12340=v18791;v48();var v18792=TypeScript,v22793=!v18792;v22793&&(v18792=TypeScript={});var v12341=v18792;v49();var v18793=TypeScript,v22794=!v18793;v22794&&(v18793=TypeScript={});var v12342=v18793;v78();var v12343=this.__extends,v18794=!v12343;v18794&&(v12343=v79);var __extends=v12343,v18795=TypeScript,v22795=!v18795;v22795&&(v18795=TypeScript={});var v12344=v18795;v322();
var v18796=TypeScript,v22796=!v18796;v22796&&(v18796=TypeScript={});var v12345=v18796;v333();var v18797=TypeScript,v22797=!v18797;v22797&&(v18797=TypeScript={});var v12346=v18797;v335();var v18798=TypeScript,v22798=!v18798;v22798&&(v18798=TypeScript={});var v12347=v18798;v399();var v18799=TypeScript,v22799=!v18799;v22799&&(v18799=TypeScript={});var v12348=v18799;v407();var v18800=TypeScript,v22800=!v18800;v22800&&(v18800=TypeScript={});var v12349=v18800;v417();var v18801=TypeScript,v22801=!v18801;
v22801&&(v18801=TypeScript={});var v12350=v18801;v420();var JSON2={};v427();var v18802=TypeScript,v22802=!v18802;v22802&&(v18802=TypeScript={});var v12351=v18802;v433();var v18803=TypeScript,v22803=!v18803;v22803&&(v18803=TypeScript={});var v12352=v18803;v492();var v18804=TypeScript,v22804=!v18804;v22804&&(v18804=TypeScript={});var v12353=v18804;v519();var v18805=TypeScript,v22805=!v18805;v22805&&(v18805=TypeScript={});var v12354=v18805;v592();var v18806=TypeScript,v22806=!v18806;
v22806&&(v18806=TypeScript={});var v12355=v18806;v599();var v18807=TypeScript,v22807=!v18807;v22807&&(v18807=TypeScript={});var v12356=v18807;v675();var v18808=TypeScript,v22808=!v18808;v22808&&(v18808=TypeScript={});var v12357=v18808;v680();var v18809=TypeScript,v22809=!v18809;v22809&&(v18809=TypeScript={});var v12358=v18809;v698();var v18810=TypeScript,v22810=!v18810;v22810&&(v18810=TypeScript={});var v12359=v18810;v711();var v18811=TypeScript,v22811=!v18811;v22811&&(v18811=TypeScript={});
var v12360=v18811;v794();var v18812=TypeScript,v22812=!v18812;v22812&&(v18812=TypeScript={});var v12361=v18812;v862();var v18813=TypeScript,v22813=!v18813;v22813&&(v18813=TypeScript={});var v12362=v18813;v892();var v18814=TypeScript,v22814=!v18814;v22814&&(v18814=TypeScript={});var v12363=v18814;v964();var v18815=TypeScript,v22815=!v18815;v22815&&(v18815=TypeScript={});var v12364=v18815;v967();var v18816=TypeScript,v22816=!v18816;v22816&&(v18816=TypeScript={});var v12365=v18816;v1113();
var v18817=TypeScript,v22817=!v18817;v22817&&(v18817=TypeScript={});var v12366=v18817;v1172();var v18818=TypeScript,v22818=!v18818;v22818&&(v18818=TypeScript={});var v12367=v18818;v1173();var v18819=TypeScript,v22819=!v18819;v22819&&(v18819=TypeScript={});var v12368=v18819;v1180();var v18820=TypeScript,v22820=!v18820;v22820&&(v18820=TypeScript={});var v12369=v18820;v1186();var v18821=TypeScript,v22821=!v18821;v22821&&(v18821=TypeScript={});var v12370=v18821;v1195();var v18822=TypeScript,v22822=!v18822;
v22822&&(v18822=TypeScript={});var v12371=v18822;v1233();var v18823=TypeScript,v22823=!v18823;v22823&&(v18823=TypeScript={});var v12372=v18823;v1288();var v18824=TypeScript,v22824=!v18824;v22824&&(v18824=TypeScript={});var v12373=v18824;v1311();var IOUtils,v18825=IOUtils,v22825=!v18825;v22825&&(v18825=IOUtils={});var v12374=v18825;v1312();
var IO=v1357(),OptionsParser=v1365(),CommandLineHost=v1370(),BatchCompiler=v1409(),completed=0,benchmarks=JAMScript.call(BenchmarkSuite.CountBenchmarks,BenchmarkSuite,[]),success=!0,latencyBenchmarks=["Splay","Mandreel"],v12375,v22826=typeof skipBenchmarks,v18826="undefined"===v22826,skipBenchmarks=v12375=v18826?[]:skipBenchmarks;

JAM.stopProfile('load');
