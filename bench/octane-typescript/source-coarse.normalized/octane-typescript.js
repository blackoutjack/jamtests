introspect(JAM.policy.pFull) {
function v1409() {
  function v1408(soruceFiles) {
    function v1407(sf$$1) {
      var v1410 = sf$$1.path;
      resolvedFiles.push(v1410);
      var v1411 = sf$$1.path;
      addWatcher(v1411);
      return;
    }
    function onWatchedFileChange() {
      function v1406(f$$1) {
        var v1412 = _this$$24.ioHost;
        var v1413 = "    " + f$$1;
        return v1412.printLine(v1413);
      }
      function v1405(sf) {
        var v1414 = sf.path;
        return newFiles.push(v1414);
      }
      var v1415 = _this$$24.compilationEnvironment;
      v1415.code = soruceFiles;
      var v1416 = _this$$24;
      var v12376;
      var v23072 = _this$$24.compilationSettings;
      var v18872 = v23072.resolve;
      if (v18872) {
        v12376 = _this$$24.resolve();
      } else {
        v12376 = _this$$24.compilationEnvironment;
      }
      v1416.resolvedEnvironment = v12376;
      var oldFiles = resolvedFiles;
      var newFiles = [];
      var v12377 = _this$$24.resolvedEnvironment;
      var v1417 = v12377.code;
      v1417.forEach(v1405);
      newFiles = newFiles.sort();
      var i$$149 = 0;
      var j$$21 = 0;
      var v18873 = oldFiles.length;
      var v12378 = i$$149 < v18873;
      if (v12378) {
        var v18874 = newFiles.length;
        v12378 = j$$21 < v18874;
      }
      var v1424 = v12378;
      for (;v1424;) {
        var v1418 = oldFiles[i$$149];
        var v1419 = newFiles[j$$21];
        var compareResult = v1418.localeCompare(v1419);
        var v1423 = compareResult == 0;
        if (v1423) {
          i$$149 = i$$149 + 1;
          j$$21 = j$$21 + 1;
        } else {
          var v1422 = compareResult < 0;
          if (v1422) {
            var v1420 = oldFiles[i$$149];
            removeWatcher(v1420);
            i$$149 = i$$149 + 1;
          } else {
            var v1421 = newFiles[j$$21];
            addWatcher(v1421);
            j$$21 = j$$21 + 1;
          }
        }
        var v18875 = oldFiles.length;
        var v12379 = i$$149 < v18875;
        if (v12379) {
          var v18876 = newFiles.length;
          v12379 = j$$21 < v18876;
        }
        v1424 = v12379;
      }
      var k$$15 = i$$149;
      var v12380 = oldFiles.length;
      var v1426 = k$$15 < v12380;
      for (;v1426;) {
        var v1425 = oldFiles[k$$15];
        removeWatcher(v1425);
        k$$15 = k$$15 + 1;
        var v12381 = oldFiles.length;
        v1426 = k$$15 < v12381;
      }
      k$$15 = j$$21;
      var v12382 = newFiles.length;
      var v1428 = k$$15 < v12382;
      for (;v1428;) {
        var v1427 = newFiles[k$$15];
        addWatcher(v1427);
        k$$15 = k$$15 + 1;
        var v12383 = newFiles.length;
        v1428 = k$$15 < v12383;
      }
      resolvedFiles = newFiles;
      var v1429 = _this$$24.ioHost;
      v1429.printLine("");
      var v1430 = _this$$24.ioHost;
      var v18877 = new Date;
      var v12384 = "Recompiling (" + v18877;
      var v1431 = v12384 + "): ";
      v1430.printLine(v1431);
      resolvedFiles.forEach(v1406);
      var hasCompileErrors$$1 = _this$$24.compile();
      var v1432 = hasCompileErrors$$1;
      var v12385 = !v1432;
      if (v12385) {
        v1432 = _this$$24.hasResolveErrors;
      }
      var hasErrors$$1 = v1432;
      var v1434 = !hasErrors$$1;
      if (v1434) {
        var v12386 = _this$$24.compilationSettings;
        var v1433 = v12386.exec;
        if (v1433) {
          _this$$24.run();
        }
      }
      return;
    }
    function removeWatcher(filename$$14) {
      var v1436 = watchers[filename$$14];
      if (v1436) {
        var v1435 = watchers[filename$$14];
        v1435.close();
        delete watchers[filename$$14];
      } else {
        throw new Error("Cannot stop watching file, it is not being watched.");
      }
      return;
    }
    function addWatcher(filename$$13) {
      var v12387 = watchers[filename$$13];
      var v1438 = !v12387;
      if (v1438) {
        var v1437 = _this$$24.ioHost;
        var watcher = v1437.watchFile(filename$$13, onWatchedFileChange);
        watchers[filename$$13] = watcher;
      } else {
        throw new Error("Cannot watch file, it is already watched.");
      }
      return;
    }
    var _this$$24 = this;
    var v18878 = this.ioHost;
    var v12388 = v18878.watchFile;
    var v1440 = !v12388;
    if (v1440) {
      var v1439 = this.ioHost;
      v1439.printLine("Error: Current host does not support -w[atch] option");
      return;
    }
    var resolvedFiles = [];
    var watchers = {};
    var v1441 = this.ioHost;
    var v12389 = this.ioHost;
    v1441.stderr = v12389.stdout;
    var v12390 = this.resolvedEnvironment;
    var v1442 = v12390.code;
    v1442.forEach(v1407);
    resolvedFiles.sort();
    return;
  }
  function v1404() {
    var v12391 = this.printedVersion;
    var v1445 = !v12391;
    if (v1445) {
      var v1443 = this.ioHost;
      var v12392 = this.compilerVersion;
      var v1444 = "Version " + v12392;
      v1443.printLine(v1444);
      this.printedVersion = true;
    }
    return;
  }
  function v1403() {
    function v1402() {
      _this$$23.printVersion();
      return;
    }
    function v1401() {
      var v1446 = _this$$23.compilationSettings;
      v1446.useCaseSensitiveFileResolution = true;
      return;
    }
    function v1400() {
      _this$$23.printVersion();
      opts$$1.printUsage();
      printedUsage = true;
      return;
    }
    function v1399(type$$63) {
      type$$63 = type$$63.toLowerCase();
      var v12393 = type$$63 === "commonjs";
      var v18879 = !v12393;
      if (v18879) {
        v12393 = type$$63 === "node";
      }
      var v1452 = v12393;
      if (v1452) {
        var v1447 = TypeScript.ModuleGenTarget;
        TypeScript.moduleGenTarget = v1447.Synchronous;
      } else {
        var v1451 = type$$63 === "amd";
        if (v1451) {
          var v1448 = TypeScript.ModuleGenTarget;
          TypeScript.moduleGenTarget = v1448.Asynchronous;
        } else {
          var v1449 = _this$$23.ioHost;
          var v12394 = "Module code generation '" + type$$63;
          var v1450 = v12394 + "' not supported.  Using default 'commonjs' code generation";
          v1449.printLine(v1450);
        }
      }
      return;
    }
    function v1398(type$$62) {
      type$$62 = type$$62.toLowerCase();
      var v1458 = type$$62 === "es3";
      if (v1458) {
        var v1453 = _this$$23.compilationSettings;
        var v12395 = TypeScript.CodeGenTarget;
        v1453.codeGenTarget = v12395.ES3;
      } else {
        var v1457 = type$$62 === "es5";
        if (v1457) {
          var v1454 = _this$$23.compilationSettings;
          var v12396 = TypeScript.CodeGenTarget;
          v1454.codeGenTarget = v12396.ES5;
        } else {
          var v1455 = _this$$23.ioHost;
          var v12397 = "ECMAScript target version '" + type$$62;
          var v1456 = v12397 + "' not supported.  Using default 'ES3' code generation";
          v1455.printLine(v1456);
        }
      }
      return;
    }
    function v1397() {
      var v1459 = _this$$23.compilationSettings;
      v1459.inferPropertiesFromThisAssignment = true;
      return;
    }
    function v1396() {
      var v1460 = _this$$23.compilationSettings;
      v1460.useDefaultLib = false;
      return;
    }
    function v1395() {
      TypeScript.optimizeModuleCodeGen = false;
      return;
    }
    function v1394() {
      var v1461 = _this$$23.compilationSettings;
      v1461.canCallDefinitionSignature = true;
      return;
    }
    function v1393() {
      var v1462 = TypeScript.CompilerDiagnostics;
      v1462.debug = true;
      return;
    }
    function v1392() {
      var v1463 = _this$$23.compilationSettings;
      v1463.resolve = false;
      var v1464 = _this$$23.compilationSettings;
      v1464.preprocess = false;
      return;
    }
    function v1391() {
      var v1465 = _this$$23.compilationSettings;
      v1465.errorOnWith = false;
      return;
    }
    function v1390() {
      var v1466 = _this$$23.compilationSettings;
      v1466.controlFlow = true;
      var v1467 = _this$$23.compilationSettings;
      v1467.controlFlowUseDef = true;
      return;
    }
    function v1389() {
      var v1468 = _this$$23.compilationSettings;
      v1468.controlFlow = true;
      var v1469 = _this$$23.compilationSettings;
      v1469.printControlFlow = true;
      return;
    }
    function v1388() {
      var v1470 = _this$$23.compilationSettings;
      v1470.controlFlow = true;
      return;
    }
    function v1387() {
      var v1471 = _this$$23.compilationSettings;
      v1471.emitComments = true;
      return;
    }
    function v1386() {
      var v1472 = _this$$23.compilationSettings;
      v1472.errorRecovery = true;
      return;
    }
    function v1385() {
      var v1473 = _this$$23.compilationSettings;
      v1473.propagateConstants = true;
      return;
    }
    function v1384() {
      var v1474 = _this$$23.compilationSettings;
      v1474.minWhitespace = true;
      return;
    }
    function v1383() {
      var v1475 = _this$$23.compilationSettings;
      v1475.parseOnly = true;
      return;
    }
    function v1382() {
      var v1476 = _this$$23.compilationSettings;
      v1476.exec = true;
      return;
    }
    function v1381() {
      var v1477 = _this$$23.compilationSettings;
      v1477.watch = true;
      return;
    }
    function v1380() {
      var v1478 = _this$$23.compilationSettings;
      v1478.generateDeclarationFiles = true;
      return;
    }
    function v1379() {
      var v1479 = _this$$23.compilationSettings;
      v1479.mapSourceFiles = true;
      return;
    }
    function v1378(str$$27) {
      var v1480 = _this$$23.compilationSettings;
      v1480.setStyleOptions(str$$27);
      return;
    }
    function v1377(str$$26) {
      var v1481 = _this$$23.compilationSettings;
      v1481.outputOption = str$$26;
      return;
    }
    function v1376(s$$42) {
      var v1482 = _this$$23.ioHost;
      v1482.printLine(s$$42);
      return;
    }
    var _this$$23 = this;
    var v1483 = TypeScript.CompilerDiagnostics;
    v1483.diagnosticWriter = {Alert:v1376};
    var code$$12;
    var v1484 = this.ioHost;
    var opts$$1 = new OptionsParser(v1484);
    var v1485 = {usage:"Concatenate and emit output to single file | Redirect output structure to the directory", type:"file|directory", set:v1377};
    opts$$1.option("out", v1485);
    var v1486 = {usage:'Select style checking options (examples --style requireSemi:off or --style "eqeqeq;bitwise:off")', experimental:true, set:v1378};
    opts$$1.option("style", v1486);
    var v1487 = {usage:"Generates corresponding .map file", set:v1379};
    opts$$1.flag("sourcemap", v1487);
    var v1488 = {usage:"Generates corresponding .d.ts file", set:v1380};
    opts$$1.flag("declaration", v1488);
    var v12398 = this.ioHost;
    var v1490 = v12398.watchFile;
    if (v1490) {
      var v1489 = {usage:"Watch output files", set:v1381};
      opts$$1.flag("watch", v1489, "w");
    }
    var v1491 = {usage:"Execute the script after compilation", set:v1382};
    opts$$1.flag("exec", v1491, "e");
    var v1492 = {usage:"Parse only", experimental:true, set:v1383};
    opts$$1.flag("parse", v1492);
    var v1493 = {usage:"Minimize whitespace", experimental:true, set:v1384};
    opts$$1.flag("minw", v1493, "mw");
    var v1494 = {usage:"Propagate constants to emitted code", experimental:true, set:v1385};
    opts$$1.flag("const", v1494);
    var v1495 = {usage:"Enable error recovery", experimental:true, set:v1386};
    opts$$1.flag("errorrecovery", v1495, "er");
    var v1496 = {usage:"Emit comments to output", set:v1387};
    opts$$1.flag("comments", v1496, "c");
    var v1497 = {usage:"Control flow", experimental:true, set:v1388};
    opts$$1.flag("cflow", v1497);
    var v1498 = {usage:"Print control flow", experimental:true, set:v1389};
    opts$$1.flag("cflowp", v1498);
    var v1499 = {usage:"Print Use Def control flow", experimental:true, set:v1390};
    opts$$1.flag("cflowu", v1499);
    var v1500 = {usage:"Allow with statements", experimental:true, set:v1391};
    opts$$1.flag("noerroronwith", v1500);
    var v1501 = {usage:"Skip resolution and preprocessing", experimental:true, set:v1392};
    opts$$1.flag("noresolve", v1501);
    var v1502 = {usage:"Print debug output", experimental:true, set:v1393};
    opts$$1.flag("debug", v1502);
    var v1503 = {usage:"Allows you to call the definition signature of an overload group", experimental:true, set:v1394};
    opts$$1.flag("canCallDefinitionSignature", v1503);
    var v1504 = {usage:"Do not optimize module codegen", experimental:true, set:v1395};
    opts$$1.flag("nooptimizemodules", v1504);
    var v1505 = {usage:"Do not include a default lib.d.ts with global declarations", set:v1396};
    opts$$1.flag("nolib", v1505);
    var v1506 = {usage:"Infer class properties from top-level assignments to 'this'", experimental:true, set:v1397};
    opts$$1.flag("inferProperties", v1506);
    var v1507 = {usage:'Specify ECMAScript target version: "ES3" (default), or "ES5"', type:"VER", set:v1398};
    opts$$1.option("target", v1507);
    var v1508 = {usage:'Specify module code generation: "commonjs" (default) or "amd"', type:"kind", set:v1399};
    opts$$1.option("module", v1508);
    var printedUsage = false;
    var v1509 = {usage:"Print this message", set:v1400};
    opts$$1.flag("help", v1509, "h");
    var v1510 = {usage:"Force file resolution to be case sensitive", experimental:true, set:v1401};
    opts$$1.flag("useCaseSensitiveFileResolution", v1510);
    var v18880 = this.compilerVersion;
    var v12399 = "Print the compiler's version: " + v18880;
    var v1511 = {usage:v12399, set:v1402};
    opts$$1.flag("version", v1511, "v");
    var v12400 = this.ioHost;
    var v1512 = v12400.arguments;
    opts$$1.parse(v1512);
    var v12401 = this.compilationSettings;
    var v1519 = v12401.useDefaultLib;
    if (v1519) {
      var v1513 = this.ioHost;
      var compilerFilePath = v1513.getExecutingFilePath();
      var v1514 = this.ioHost;
      var binDirPath = v1514.dirName(compilerFilePath);
      var v1515 = this.ioHost;
      var v1516 = binDirPath + "/lib.d.ts";
      var libStrPath = v1515.resolvePath(v1516);
      var v1517 = TypeScript.SourceUnit;
      code$$12 = new v1517(libStrPath, null);
      var v12402 = this.compilationEnvironment;
      var v1518 = v12402.code;
      v1518.push(code$$12);
    }
    var i$$148 = 0;
    var v18881 = opts$$1.unnamed;
    var v12403 = v18881.length;
    var v1523 = i$$148 < v12403;
    for (;v1523;) {
      var v1520 = TypeScript.SourceUnit;
      var v12404 = opts$$1.unnamed;
      var v1521 = v12404[i$$148];
      code$$12 = new v1520(v1521, null);
      var v12405 = this.compilationEnvironment;
      var v1522 = v12405.code;
      v1522.push(code$$12);
      i$$148 = i$$148 + 1;
      var v18882 = opts$$1.unnamed;
      var v12406 = v18882.length;
      v1523 = i$$148 < v12406;
    }
    var v23073 = this.compilationEnvironment;
    var v18883 = v23073.code;
    var v12407 = v18883.length;
    var v18884;
    var v25136 = this.compilationSettings;
    var v23074 = v25136.useDefaultLib;
    if (v23074) {
      v18884 = 1;
    } else {
      v18884 = 0;
    }
    var v12408 = v18884;
    var v1526 = v12407 == v12408;
    if (v1526) {
      var v12409 = !printedUsage;
      if (v12409) {
        var v18885 = this.printedVersion;
        v12409 = !v18885;
      }
      var v1525 = v12409;
      if (v1525) {
        this.printVersion();
        opts$$1.printUsage();
        var v1524 = this.ioHost;
        v1524.quit(1);
      }
      return;
    }
    var sourceFiles = [];
    var v12410 = this.compilationSettings;
    var v1528 = v12410.watch;
    if (v1528) {
      var v12411 = this.compilationEnvironment;
      var v1527 = v12411.code;
      sourceFiles = v1527.slice(0);
    }
    var v1529;
    var v18886 = this.compilationSettings;
    var v12412 = v18886.resolve;
    if (v12412) {
      v1529 = this.resolve();
    } else {
      v1529 = this.compilationEnvironment;
    }
    this.resolvedEnvironment = v1529;
    var hasCompileErrors = this.compile();
    var v1530 = hasCompileErrors;
    var v12413 = !v1530;
    if (v12413) {
      v1530 = this.hasResolveErrors;
    }
    var hasErrors = v1530;
    var v1532 = !hasErrors;
    if (v1532) {
      var v12414 = this.compilationSettings;
      var v1531 = v12414.exec;
      if (v1531) {
        this.run();
      }
    }
    var v12415 = this.compilationSettings;
    var v1535 = v12415.watch;
    if (v1535) {
      this.watchFiles(sourceFiles);
    } else {
      var v1533 = this.ioHost;
      var v12416;
      if (hasErrors) {
        v12416 = 1;
      } else {
        v12416 = 0;
      }
      var v1534 = v12416;
      v1533.quit(v1534);
    }
    return;
  }
  function v1375() {
    var i$$147 = 0;
    var v23075 = this.compilationEnvironment;
    var v18887 = v23075.code;
    var v12417 = v18887.length;
    var v1542 = i$$147 < v12417;
    for (;v1542;) {
      var v12418 = this.compilationEnvironment;
      var v1536 = v12418.code;
      var unit = v1536[i$$147];
      var outputFileName = unit.path;
      var v1538 = TypeScript.isTSFile(outputFileName);
      if (v1538) {
        outputFileName = outputFileName.replace(/\.ts$/, ".js");
      } else {
        var v1537 = TypeScript.isSTRFile(outputFileName);
        if (v1537) {
          outputFileName = outputFileName.replace(/\.str$/, ".js");
        }
      }
      var v12419 = this.ioHost;
      var v1541 = v12419.fileExists(outputFileName);
      if (v1541) {
        var v1539 = this.ioHost;
        var unitRes = v1539.readFile(outputFileName);
        var v1540 = this.ioHost;
        v1540.run(unitRes, outputFileName);
      }
      i$$147 = i$$147 + 1;
      var v23076 = this.compilationEnvironment;
      var v18888 = v23076.code;
      var v12420 = v18888.length;
      v1542 = i$$147 < v12420;
    }
    return;
  }
  function v1374() {
    function v1373(fileName$$10, useUTF8$$5) {
      var v1543 = _this$$22.ioHost;
      return IOUtils.createFileAndFolderStructure(v1543, fileName$$10, useUTF8$$5);
    }
    function v1372(minChar$$37, charLen$$2, message$$23, unitIndex$$15) {
      var v1544 = compiler$$3.errorReporter;
      v1544.hasErrors = true;
      var v18889 = _this$$22.resolvedEnvironment;
      var v12421 = v18889.code;
      var v1545 = v12421[unitIndex$$15];
      var fname$$9 = v1545.path;
      var lineCol$$6 = {line:-1, col:-1};
      var v1546 = compiler$$3.parser;
      v1546.getSourceLineCol(lineCol$$6, minChar$$37);
      var v25137 = fname$$9 + " (";
      var v25138 = lineCol$$6.line;
      var v23077 = v25137 + v25138;
      var v18890 = v23077 + ",";
      var v23078 = lineCol$$6.col;
      var v18891 = v23078 + 1;
      var v12422 = v18890 + v18891;
      var v1547 = v12422 + "): ";
      var msg$$4 = v1547 + message$$23;
      var v12423 = _this$$22.compilationSettings;
      var v1549 = v12423.errorRecovery;
      if (v1549) {
        var v12424 = _this$$22.ioHost;
        var v1548 = v12424.stderr;
        v1548.WriteLine(msg$$4);
      } else {
        throw new SyntaxError(msg$$4);
      }
      return;
    }
    function consumeUnit(code$$11, addAsResident) {
      try {
        var v18892 = _this$$22.compilationSettings;
        var v12425 = v18892.resolve;
        var v1555 = !v12425;
        if (v1555) {
          var v1550 = code$$11;
          var v12426 = _this$$22.ioHost;
          var v12427 = code$$11.path;
          var v26764 = v12426.readFile(v12427);
          v1550.content = v26764;
          var v12428 = _this$$22.compilationSettings;
          var v1554 = v12428.generateDeclarationFiles;
          if (v1554) {
            var v1551 = TypeScript.CompilerDiagnostics;
            var v12429 = code$$11.referencedFiles;
            var v1552 = v12429 == null;
            v1551.assert(v1552, "With no resolve option, referenced files need to null");
            var v1553 = code$$11;
            var v26765 = TypeScript.getReferencedFiles(code$$11);
            v1553.referencedFiles = v26765;
          }
        }
        var v1565 = code$$11.content;
        if (v1565) {
          var v12430 = _this$$22.compilationSettings;
          var v1564 = v12430.parseOnly;
          if (v1564) {
            var v1556 = code$$11.content;
            var v1557 = code$$11.path;
            compiler$$3.parseUnit(v1556, v1557);
          } else {
            var v12431 = _this$$22.compilationSettings;
            var v1560 = v12431.errorRecovery;
            if (v1560) {
              var v1558 = compiler$$3.parser;
              var v12432 = _this$$22.ioHost;
              var v1559 = v12432.stderr;
              v1558.setErrorRecovery(v1559);
            }
            var v1561 = code$$11.content;
            var v1562 = code$$11.path;
            var v1563 = code$$11.referencedFiles;
            compiler$$3.addUnit(v1561, v1562, addAsResident, v1563);
          }
        }
      } catch (err$$7) {
        var v1566 = compiler$$3.errorReporter;
        v1566.hasErrors = true;
        var v12433 = _this$$22.ioHost;
        var v1567 = v12433.stderr;
        var v1568 = err$$7.message;
        v1567.WriteLine(v1568);
      }
      return;
    }
    var _this$$22 = this;
    var compiler$$3;
    var v1569 = TypeScript.TypeScriptCompiler;
    var v12434 = this.ioHost;
    var v1570 = v12434.stderr;
    var v12435 = TypeScript.NullLogger;
    var v1571 = new v12435;
    var v1572 = this.compilationSettings;
    compiler$$3 = new v1569(v1570, v1571, v1572);
    var v12436 = this.ioHost;
    var v1573 = v12436.stderr;
    compiler$$3.setErrorOutput(v1573);
    compiler$$3.setErrorCallback(v1372);
    var v12437 = this.compilationSettings;
    var v1574 = v12437.emitComments;
    if (v1574) {
      compiler$$3.emitCommentsToOutput();
    }
    var iCode = 0;
    var v23079 = this.resolvedEnvironment;
    var v18893 = v23079.code;
    var v12438 = v18893.length;
    var v1577 = iCode < v12438;
    for (;v1577;) {
      var v23080 = this.compilationSettings;
      var v18894 = v23080.parseOnly;
      var v12439 = !v18894;
      var v18895 = !v12439;
      if (v18895) {
        v12439 = iCode > 0;
      }
      var v1576 = v12439;
      if (v1576) {
        var v18896 = this.resolvedEnvironment;
        var v12440 = v18896.code;
        var v1575 = v12440[iCode];
        consumeUnit(v1575, false);
      }
      iCode = iCode + 1;
      var v23081 = this.resolvedEnvironment;
      var v18897 = v23081.code;
      var v12441 = v18897.length;
      v1577 = iCode < v12441;
    }
    var v12442 = this.ioHost;
    var v1578 = v12442.directoryExists;
    var v12443 = this.ioHost;
    var v1579 = v12443.fileExists;
    var v12444 = this.ioHost;
    var v1580 = v12444.resolvePath;
    var emitterIOHost = {createFile:v1373, directoryExists:v1578, fileExists:v1579, resolvePath:v1580};
    try {
      var v18898 = this.compilationSettings;
      var v12445 = v18898.parseOnly;
      var v1581 = !v12445;
      if (v1581) {
        compiler$$3.typeCheck();
        compiler$$3.emit(emitterIOHost);
        compiler$$3.emitDeclarations();
      } else {
        compiler$$3.emitAST(emitterIOHost);
      }
    } catch (err$$8) {
      var v1582 = compiler$$3.errorReporter;
      v1582.hasErrors = true;
      var v12446 = err$$8.message;
      var v1583 = v12446 != "EmitError";
      if (v1583) {
        throw err$$8;
      }
    }
    var v1584 = compiler$$3.errorReporter;
    return v1584.hasErrors;
  }
  function v1371() {
    var v1585 = TypeScript.CodeResolver;
    var v1586 = this.compilationEnvironment;
    var resolver$$1 = new v1585(v1586);
    var v1587 = this.compilationSettings;
    var commandLineHost = new CommandLineHost(v1587);
    var v1588 = this.compilationEnvironment;
    var ret$$2 = commandLineHost.resolveCompilationEnvironment(v1588, resolver$$1, true);
    this.hasResolveErrors = false;
    var i$$146 = 0;
    var v23082 = this.compilationEnvironment;
    var v18899 = v23082.code;
    var v12447 = v18899.length;
    var v1596 = i$$146 < v12447;
    for (;v1596;) {
      var v26021 = this.compilationEnvironment;
      var v25139 = v26021.code;
      var v23083 = v25139[i$$146];
      var v18900 = v23083.path;
      var v12448 = commandLineHost.isResolved(v18900);
      var v1595 = !v12448;
      if (v1595) {
        this.hasResolveErrors = true;
        var v18901 = this.compilationEnvironment;
        var v12449 = v18901.code;
        var v1589 = v12449[i$$146];
        var path$$45 = v1589.path;
        var v25140 = TypeScript.isSTRFile(path$$45);
        var v23084 = !v25140;
        if (v23084) {
          var v25141 = TypeScript.isDSTRFile(path$$45);
          v23084 = !v25141;
        }
        var v18902 = v23084;
        if (v18902) {
          var v23085 = TypeScript.isTSFile(path$$45);
          v18902 = !v23085;
        }
        var v12450 = v18902;
        if (v12450) {
          var v18903 = TypeScript.isDTSFile(path$$45);
          v12450 = !v18903;
        }
        var v1594 = v12450;
        if (v1594) {
          var v12451 = this.ioHost;
          var v1590 = v12451.stderr;
          var v12452 = 'Unknown extension for file: "' + path$$45;
          var v1591 = v12452 + '". Only .ts and .d.ts extensions are allowed.';
          v1590.WriteLine(v1591);
        } else {
          var v12453 = this.ioHost;
          var v1592 = v12453.stderr;
          var v12454 = 'Error reading file "' + path$$45;
          var v1593 = v12454 + '": File not found';
          v1592.WriteLine(v1593);
        }
      }
      i$$146 = i$$146 + 1;
      var v23086 = this.compilationEnvironment;
      var v18904 = v23086.code;
      var v12455 = v18904.length;
      v1596 = i$$146 < v12455;
    }
    return ret$$2;
  }
  function BatchCompiler$$1(ioHost$$7) {
    this.ioHost = ioHost$$7;
    this.resolvedEnvironment = null;
    this.hasResolveErrors = false;
    this.compilerVersion = "0.8.2.0";
    this.printedVersion = false;
    var v1597 = TypeScript.CompilationSettings;
    var v26766 = new v1597;
    this.compilationSettings = v26766;
    var v1598 = TypeScript.CompilationEnvironment;
    var v1599 = this.compilationSettings;
    var v1600 = this.ioHost;
    var v26767 = new v1598(v1599, v1600);
    this.compilationEnvironment = v26767;
    return;
  }
  var v1601 = BatchCompiler$$1.prototype;
  v1601.resolve = v1371;
  var v1602 = BatchCompiler$$1.prototype;
  v1602.compile = v1374;
  var v1603 = BatchCompiler$$1.prototype;
  v1603.run = v1375;
  var v1604 = BatchCompiler$$1.prototype;
  v1604.batchCompile = v1403;
  var v1605 = BatchCompiler$$1.prototype;
  v1605.printVersion = v1404;
  var v1606 = BatchCompiler$$1.prototype;
  v1606.watchFiles = v1408;
  return BatchCompiler$$1;
}
function v1370() {
  function v1369(preEnv, resolver, traceDependencies) {
    function v1368(path$$44, code$$10) {
      var pathId = _this$$21.getPathIdentifier(path$$44);
      var v18905 = _this$$21.resolvedPaths;
      var v12456 = v18905[pathId];
      var v1609 = !v12456;
      if (v1609) {
        var v1607 = resolvedEnv.code;
        v1607.push(code$$10);
        var v1608 = _this$$21.resolvedPaths;
        v1608[pathId] = true;
      }
      return;
    }
    function postResolutionError(errorFile, errorMessage$$1) {
      var v1610 = TypeScript.CompilerDiagnostics;
      var v18906 = "Could not resolve file '" + errorFile;
      var v12457 = v18906 + "'";
      var v18907;
      var v23087 = errorMessage$$1 == "";
      if (v23087) {
        v18907 = "";
      } else {
        v18907 = ": " + errorMessage$$1;
      }
      var v12458 = v18907;
      var v1611 = v12457 + v12458;
      v1610.debugPrint(v1611);
      return;
    }
    var _this$$21 = this;
    var v1612 = TypeScript.CompilationEnvironment;
    var v1613 = preEnv.compilationSettings;
    var v1614 = preEnv.ioHost;
    var resolvedEnv = new v1612(v1613, v1614);
    var v1615 = preEnv.code;
    var nCode = v1615.length;
    var path$$43 = "";
    var resolutionDispatcher$$1 = {postResolutionError:postResolutionError, postResolution:v1368};
    var i$$145 = 0;
    var v1619 = i$$145 < nCode;
    for (;v1619;) {
      var v12459 = preEnv.ioHost;
      var v23088 = preEnv.code;
      var v18908 = v23088[i$$145];
      var v12460 = v18908.path;
      var v1616 = v12459.resolvePath(v12460);
      path$$43 = TypeScript.switchToForwardSlashes(v1616);
      var v1617 = this.pathMap;
      var v18909 = preEnv.code;
      var v12461 = v18909[i$$145];
      var v1618 = v12461.path;
      v1617[v1618] = path$$43;
      resolver.resolveCode(path$$43, "", false, resolutionDispatcher$$1);
      i$$145 = i$$145 + 1;
      v1619 = i$$145 < nCode;
    }
    return resolvedEnv;
  }
  function v1367(path$$42) {
    var v12462 = this.resolvedPaths;
    var v23089 = this.pathMap;
    var v18910 = v23089[path$$42];
    var v12463 = this.getPathIdentifier(v18910);
    var v1620 = v12462[v12463];
    return v1620 != undefined;
  }
  function v1366(path$$41) {
    var v1621;
    var v18911 = this.compilationSettings;
    var v12464 = v18911.useCaseSensitiveFileResolution;
    if (v12464) {
      v1621 = path$$41;
    } else {
      v1621 = path$$41.toLocaleUpperCase();
    }
    return v1621;
  }
  function CommandLineHost$$1(compilationSettings$$1) {
    this.compilationSettings = compilationSettings$$1;
    this.pathMap = {};
    this.resolvedPaths = {};
    return;
  }
  var v1622 = CommandLineHost$$1.prototype;
  v1622.getPathIdentifier = v1366;
  var v1623 = CommandLineHost$$1.prototype;
  v1623.isResolved = v1367;
  var v1624 = CommandLineHost$$1.prototype;
  v1624.resolveCompilationEnvironment = v1369;
  return CommandLineHost$$1;
}
function v1365() {
  function v1364(args$$19) {
    var position$$5 = 0;
    var v12465 = args$$19.length;
    var v1635 = position$$5 < v12465;
    for (;v1635;) {
      var v1625 = position$$5;
      position$$5 = position$$5 + 1;
      var current$$4 = args$$19[v1625];
      var match$$3 = current$$4.match(/^(--?|@)(.*)/);
      var value$$43 = null;
      if (match$$3) {
        var v12466 = match$$3[1];
        var v1633 = v12466 === "@";
        if (v1633) {
          var v12467 = this.host;
          var v12468 = match$$3[2];
          var v1626 = v12467.readFile(v12468);
          this.parseString(v1626);
        } else {
          var arg$$11 = match$$3[2];
          var option$$1 = this.findOption(arg$$11);
          var v1632 = option$$1 === null;
          if (v1632) {
            var v1627 = this.host;
            var v12469 = "Unknown option '" + arg$$11;
            var v1628 = v12469 + "'";
            v1627.printLine(v1628);
            var v1629 = this.host;
            v1629.printLine("Use the '--help' flag to see options");
          } else {
            var v12470 = option$$1.flag;
            var v1631 = !v12470;
            if (v1631) {
              var v1630 = position$$5;
              position$$5 = position$$5 + 1;
              value$$43 = args$$19[v1630];
            }
            option$$1.set(value$$43);
          }
        }
      } else {
        var v1634 = this.unnamed;
        v1634.push(current$$4);
      }
      var v12471 = args$$19.length;
      v1635 = position$$5 < v12471;
    }
    return;
  }
  function v1363(argString) {
    var position$$4 = 0;
    var tokens = argString.match(/\s+|"|[^\s"]+/g);
    var args$$18 = [];
    var currentArg = "";
    var v12472 = tokens.length;
    var v1645 = position$$4 < v12472;
    for (;v1645;) {
      var token$$7 = tokens[position$$4];
      var v1644 = token$$7 === '"';
      if (v1644) {
        var JSCompiler_temp_const$$34 = currentArg;
        var JSCompiler_inline_result$$35;
        var value$$inline_36 = "";
        var v1636 = position$$4;
        position$$4 = position$$4 + 1;
        tokens[v1636];
        var token$$inline_37 = tokens[position$$4];
        var v12473 = token$$inline_37;
        if (v12473) {
          v12473 = token$$inline_37 !== '"';
        }
        var v1638 = v12473;
        for (;v1638;) {
          var v1637 = position$$4;
          position$$4 = position$$4 + 1;
          tokens[v1637];
          value$$inline_36 = value$$inline_36 + token$$inline_37;
          token$$inline_37 = tokens[position$$4];
          var v12474 = token$$inline_37;
          if (v12474) {
            v12474 = token$$inline_37 !== '"';
          }
          v1638 = v12474;
        }
        var v1639 = position$$4;
        position$$4 = position$$4 + 1;
        tokens[v1639];
        JSCompiler_inline_result$$35 = value$$inline_36;
        currentArg = JSCompiler_temp_const$$34 + JSCompiler_inline_result$$35;
      } else {
        var v1643 = token$$7.match(/\s/);
        if (v1643) {
          var v12475 = currentArg.length;
          var v1640 = v12475 > 0;
          if (v1640) {
            args$$18.push(currentArg);
            currentArg = "";
          }
          var v1641 = position$$4;
          position$$4 = position$$4 + 1;
          tokens[v1641];
        } else {
          var v1642 = position$$4;
          position$$4 = position$$4 + 1;
          tokens[v1642];
          currentArg = currentArg + token$$7;
        }
      }
      var v12476 = tokens.length;
      v1645 = position$$4 < v12476;
    }
    var v12477 = currentArg.length;
    var v1646 = v12477 > 0;
    if (v1646) {
      args$$18.push(currentArg);
    }
    this.parse(args$$18);
    return;
  }
  function v1362(name$$91, config$$2, short$$1) {
    var v1647 = !config$$2;
    if (v1647) {
      config$$2 = short$$1;
      short$$1 = null;
    }
    config$$2.name = name$$91;
    config$$2.short = short$$1;
    config$$2.flag = true;
    var v1648 = this.options;
    v1648.push(config$$2);
    return;
  }
  function v1361(name$$90, config$$1, short) {
    var v1649 = !config$$1;
    if (v1649) {
      config$$1 = short;
      short = null;
    }
    config$$1.name = name$$90;
    config$$1.short = short;
    config$$1.flag = false;
    var v1650 = this.options;
    v1650.push(config$$1);
    return;
  }
  function v1360() {
    function v1359(a$$9, b$$15) {
      var v1651 = a$$9.name;
      var aName = v1651.toLowerCase();
      var v1652 = b$$15.name;
      var bName = v1652.toLowerCase();
      var v1654 = aName > bName;
      if (v1654) {
        return 1;
      } else {
        var v1653 = aName < bName;
        if (v1653) {
          return-1;
        } else {
          return 0;
        }
      }
      return;
    }
    var v1655 = this.host;
    v1655.printLine("Syntax:   tsc [options] [file ..]");
    var v1656 = this.host;
    v1656.printLine("");
    var v1657 = this.host;
    v1657.printLine("Examples: tsc hello.ts");
    var v1658 = this.host;
    v1658.printLine("          tsc --out foo.js foo.ts");
    var v1659 = this.host;
    v1659.printLine("          tsc @args.txt");
    var v1660 = this.host;
    v1660.printLine("");
    var v1661 = this.host;
    v1661.printLine("Options:");
    var output$$1 = [];
    var maxLength = 0;
    var v1662 = this.options;
    var v26768 = v1662.sort(v1359);
    this.options = v26768;
    var i$$144 = 0;
    var v18912 = this.options;
    var v12478 = v18912.length;
    var v1670 = i$$144 < v12478;
    for (;v1670;) {
      var v1663 = this.options;
      var option = v1663[i$$144];
      var v1664 = option.experimental;
      if (v1664) {
        i$$144 = i$$144 + 1;
        var v18913 = this.options;
        var v12479 = v18913.length;
        v1670 = i$$144 < v12479;
        continue;
      }
      var v12480 = option.usage;
      var v1665 = !v12480;
      if (v1665) {
        break;
      }
      var usageString = "  ";
      var v1666;
      var v12482 = option.type;
      if (v12482) {
        var v18914 = option.type;
        var v12481 = v18914.toUpperCase();
        v1666 = " " + v12481;
      } else {
        v1666 = "";
      }
      var type$$61 = v1666;
      var v1667 = option.short;
      if (v1667) {
        var v25142 = this.DEFAULT_SHORT_FLAG;
        var v25143 = option.short;
        var v23090 = v25142 + v25143;
        var v18915 = v23090 + type$$61;
        var v12483 = v18915 + ", ";
        usageString = usageString + v12483;
      }
      var v23091 = this.DEFAULT_LONG_FLAG;
      var v23092 = option.name;
      var v18916 = v23091 + v23092;
      var v12484 = v18916 + type$$61;
      usageString = usageString + v12484;
      var v12485 = option.usage;
      var v1668 = [usageString, v12485];
      output$$1.push(v1668);
      var v12486 = usageString.length;
      var v1669 = v12486 > maxLength;
      if (v1669) {
        maxLength = usageString.length;
      }
      i$$144 = i$$144 + 1;
      var v18917 = this.options;
      var v12487 = v18917.length;
      v1670 = i$$144 < v12487;
    }
    var v1671 = ["  @<file>", "Insert command line options and files from a file."];
    output$$1.push(v1671);
    i$$144 = 0;
    var v12488 = output$$1.length;
    var v1674 = i$$144 < v12488;
    for (;v1674;) {
      var v1672 = this.host;
      var v23093 = output$$1[i$$144];
      var v18918 = v23093[0];
      var v26680 = output$$1[i$$144];
      var v26590 = v26680[0];
      var v26411 = v26590.length;
      var v26022 = maxLength - v26411;
      var v25144 = v26022 + 3;
      var v23094 = new Array(v25144);
      var v18919 = v23094.join(" ");
      var v12489 = v18918 + v18919;
      var v18920 = output$$1[i$$144];
      var v12490 = v18920[1];
      var v1673 = v12489 + v12490;
      v1672.printLine(v1673);
      i$$144 = i$$144 + 1;
      var v12491 = output$$1.length;
      v1674 = i$$144 < v12491;
    }
    return;
  }
  function v1358(arg$$10) {
    var i$$143 = 0;
    var v18921 = this.options;
    var v12492 = v18921.length;
    var v1677 = i$$143 < v12492;
    for (;v1677;) {
      var v25145 = this.options;
      var v23095 = v25145[i$$143];
      var v18922 = v23095.short;
      var v12493 = arg$$10 === v18922;
      var v18924 = !v12493;
      if (v18924) {
        var v25146 = this.options;
        var v23096 = v25146[i$$143];
        var v18923 = v23096.name;
        v12493 = arg$$10 === v18923;
      }
      var v1676 = v12493;
      if (v1676) {
        var v1675 = this.options;
        return v1675[i$$143];
      }
      i$$143 = i$$143 + 1;
      var v18925 = this.options;
      var v12494 = v18925.length;
      v1677 = i$$143 < v12494;
    }
    return null;
  }
  function OptionsParser$$1(host) {
    this.host = host;
    this.DEFAULT_SHORT_FLAG = "-";
    this.DEFAULT_LONG_FLAG = "--";
    this.unnamed = [];
    this.options = [];
    return;
  }
  var v1678 = OptionsParser$$1.prototype;
  v1678.findOption = v1358;
  var v1679 = OptionsParser$$1.prototype;
  v1679.printUsage = v1360;
  var v1680 = OptionsParser$$1.prototype;
  v1680.option = v1361;
  var v1681 = OptionsParser$$1.prototype;
  v1681.flag = v1362;
  var v1682 = OptionsParser$$1.prototype;
  v1682.parseString = v1363;
  var v1683 = OptionsParser$$1.prototype;
  v1683.parse = v1364;
  return OptionsParser$$1;
}
function v1357() {
  function getWindowsScriptHostIO() {
    function v1331(exitCode) {
      var v12495 = typeof exitCode;
      var v1684 = v12495 === "undefined";
      if (v1684) {
        exitCode = 0;
      }
      try {
        WScript.Quit(exitCode);
      } catch (e$$16) {
      }
      return;
    }
    function v1330() {
      return WScript.ScriptFullName;
    }
    function v1329(source$$4, filename$$10) {
      try {
        eval(source$$4);
      } catch (e$$15) {
        var v12496 = "Error while executing file '" + filename$$10;
        var v1685 = v12496 + "'.";
        IOUtils.throwIOError(v1685, e$$15);
      }
      return;
    }
    function v1328(str$$17) {
      WScript.Echo(str$$17);
      return;
    }
    function v1327(str$$16) {
      var v1686 = WScript.StdOut;
      v1686.Write(str$$16);
      return;
    }
    function v1326(path$$30, spec, options$$8) {
      function filesInFolder(folder$$1, root) {
        var paths$$1 = [];
        var fc;
        var v1690 = options$$8.recursive;
        if (v1690) {
          var v1687 = folder$$1.subfolders;
          fc = new Enumerator(v1687);
          var v12497 = fc.atEnd();
          var v1689 = !v12497;
          for (;v1689;) {
            var v12498 = fc.item();
            var v18926 = root + "/";
            var v23097 = fc.item();
            var v18927 = v23097.Name;
            var v12499 = v18926 + v18927;
            var v1688 = filesInFolder(v12498, v12499);
            paths$$1 = paths$$1.concat(v1688);
            fc.moveNext();
            var v12500 = fc.atEnd();
            v1689 = !v12500;
          }
        }
        var v1691 = folder$$1.files;
        fc = new Enumerator(v1691);
        var v12501 = fc.atEnd();
        var v1694 = !v12501;
        for (;v1694;) {
          var v12502 = !spec;
          var v18929 = !v12502;
          if (v18929) {
            var v23098 = fc.item();
            var v18928 = v23098.Name;
            v12502 = v18928.match(spec);
          }
          var v1693 = v12502;
          if (v1693) {
            var v12503 = root + "/";
            var v18930 = fc.item();
            var v12504 = v18930.Name;
            var v1692 = v12503 + v12504;
            paths$$1.push(v1692);
          }
          fc.moveNext();
          var v12505 = fc.atEnd();
          v1694 = !v12505;
        }
        return paths$$1;
      }
      options$$8 = options$$8 || {};
      var folder = fso.GetFolder(path$$30);
      var paths = [];
      return filesInFolder(folder, path$$30);
    }
    function v1325(path$$29) {
      try {
        var v12506 = this.directoryExists(path$$29);
        var v1695 = !v12506;
        if (v1695) {
          fso.CreateFolder(path$$29);
        }
      } catch (e$$14) {
        var v12507 = "Couldn't create directory '" + path$$29;
        var v1696 = v12507 + "'.";
        IOUtils.throwIOError(v1696, e$$14);
      }
      return;
    }
    function v1324(path$$28) {
      return fso.FolderExists(path$$28);
    }
    function v1323(path$$27, useUTF8$$3) {
      function v1322() {
        try {
          streamObj$$1.SaveToFile(path$$27, 2);
        } catch (saveError) {
          var v12508 = "Couldn't write to file '" + path$$27;
          var v1697 = v12508 + "'.";
          IOUtils.throwIOError(v1697, saveError);
        } finally {
          var v12509 = streamObj$$1.State;
          var v1698 = v12509 != 0;
          if (v1698) {
            streamObj$$1.Close();
          }
          streamObjectPool.push(streamObj$$1);
        }
        return;
      }
      function v1321(str$$15) {
        streamObj$$1.WriteText(str$$15, 1);
        return;
      }
      function v1320(str$$14) {
        streamObj$$1.WriteText(str$$14, 0);
        return;
      }
      try {
        var streamObj$$1 = getStreamObject();
        var v1699;
        if (useUTF8$$3) {
          v1699 = "utf-8";
        } else {
          v1699 = "x-ansi";
        }
        streamObj$$1.Charset = v1699;
        streamObj$$1.Open();
        return{Write:v1320, WriteLine:v1321, Close:v1322};
      } catch (creationError) {
        var v12510 = "Couldn't write to file '" + path$$27;
        var v1700 = v12510 + "'.";
        IOUtils.throwIOError(v1700, creationError);
      }
      return;
    }
    function v1319(path$$26) {
      try {
        var v1701 = fso.FileExists(path$$26);
        if (v1701) {
          fso.DeleteFile(path$$26, true);
        }
      } catch (e$$13) {
        var v12511 = "Couldn't delete file '" + path$$26;
        var v1702 = v12511 + "'.";
        IOUtils.throwIOError(v1702, e$$13);
      }
      return;
    }
    function v1318(rootPath, partialFilePath) {
      var v12512 = fso.GetAbsolutePathName(rootPath);
      var v1703 = v12512 + "/";
      var path$$25 = v1703 + partialFilePath;
      for (;true;) {
        var v1706 = fso.FileExists(path$$25);
        if (v1706) {
          try {
            var content$$6 = this.readFile(path$$25);
            return{content:content$$6, path:path$$25};
          } catch (err$$5) {
          }
        } else {
          var v1704 = fso.GetAbsolutePathName(rootPath);
          rootPath = fso.GetParentFolderName(v1704);
          var v1705 = rootPath == "";
          if (v1705) {
            return null;
          } else {
            path$$25 = fso.BuildPath(rootPath, partialFilePath);
          }
        }
      }
      return;
    }
    function v1317(path$$24) {
      return fso.GetParentFolderName(path$$24);
    }
    function v1316(path$$23) {
      return fso.GetAbsolutePathName(path$$23);
    }
    function v1315(path$$22) {
      return fso.FileExists(path$$22);
    }
    function v1314(path$$21, contents) {
      var file$$1 = this.createFile(path$$21);
      file$$1.Write(contents);
      file$$1.Close();
      return;
    }
    function v1313(path$$20) {
      try {
        var streamObj = getStreamObject();
        streamObj.Open();
        streamObj.Type = 2;
        streamObj.Charset = "x-ansi";
        streamObj.LoadFromFile(path$$20);
        var bomChar = streamObj.ReadText(2);
        streamObj.Position = 0;
        var v23099 = bomChar.charCodeAt(0);
        var v18931 = v23099 == 254;
        if (v18931) {
          var v23100 = bomChar.charCodeAt(1);
          v18931 = v23100 == 255;
        }
        var v12513 = v18931;
        var v18933 = !v12513;
        if (v18933) {
          var v23101 = bomChar.charCodeAt(0);
          var v18932 = v23101 == 255;
          if (v18932) {
            var v23102 = bomChar.charCodeAt(1);
            v18932 = v23102 == 254;
          }
          v12513 = v18932;
        }
        var v1708 = v12513;
        if (v1708) {
          streamObj.Charset = "unicode";
        } else {
          var v18934 = bomChar.charCodeAt(0);
          var v12514 = v18934 == 239;
          if (v12514) {
            var v18935 = bomChar.charCodeAt(1);
            v12514 = v18935 == 187;
          }
          var v1707 = v12514;
          if (v1707) {
            streamObj.Charset = "utf-8";
          }
        }
        var str$$13 = streamObj.ReadText(-1);
        streamObj.Close();
        streamObjectPool.push(streamObj);
        return str$$13;
      } catch (err$$4) {
        var v12515 = 'Error reading file "' + path$$20;
        var v1709 = v12515 + '".';
        IOUtils.throwIOError(v1709, err$$4);
      }
      return;
    }
    function getStreamObject() {
      var v12516 = streamObjectPool.length;
      var v1710 = v12516 > 0;
      if (v1710) {
        return streamObjectPool.pop();
      } else {
        return new ActiveXObject("ADODB.Stream");
      }
      return;
    }
    var fso = new ActiveXObject("Scripting.FileSystemObject");
    var streamObjectPool = [];
    var args$$17 = [];
    var i$$140 = 0;
    var v18936 = WScript.Arguments;
    var v12517 = v18936.length;
    var v1713 = i$$140 < v12517;
    for (;v1713;) {
      var v1711 = args$$17;
      var v1712 = i$$140;
      var v12518 = WScript.Arguments;
      var v26769 = v12518.Item(i$$140);
      v1711[v1712] = v26769;
      i$$140 = i$$140 + 1;
      var v18937 = WScript.Arguments;
      var v12519 = v18937.length;
      v1713 = i$$140 < v12519;
    }
    var v1714 = WScript.StdErr;
    var v1715 = WScript.StdOut;
    return{readFile:v1313, writeFile:v1314, fileExists:v1315, resolvePath:v1316, dirName:v1317, findFile:v1318, deleteFile:v1319, createFile:v1323, directoryExists:v1324, createDirectory:v1325, dir:v1326, print:v1327, printLine:v1328, arguments:args$$17, stderr:v1714, stdout:v1715, watchFile:null, run:v1329, getExecutingFilePath:v1330, quit:v1331};
  }
  function getNodeIO() {
    function v1356() {
      var v1716 = process.mainModule;
      return v1716.filename;
    }
    function v1355(source$$5, filename$$12) {
      var v1717 = require.main;
      v1717.filename = filename$$12;
      var v1718 = require.main;
      var v18938 = _fs.realpathSync(filename$$12);
      var v12520 = _path.dirname(v18938);
      var v26770 = _module._nodeModulePaths(v12520);
      v1718.paths = v26770;
      var v1719 = require.main;
      v1719._compile(source$$5, filename$$12);
      return;
    }
    function v1354(filename$$11, callback$$28) {
      function v1353() {
        _fs.unwatchFile(filename$$11, fileChanged);
        return;
      }
      function fileChanged(curr, prev$$1) {
        function v1352() {
          processingChange = false;
          return;
        }
        var v1722 = !firstRun;
        if (v1722) {
          var v12521 = curr.mtime;
          var v12522 = prev$$1.mtime;
          var v1720 = v12521 < v12522;
          if (v1720) {
            return;
          }
          _fs.unwatchFile(filename$$11, fileChanged);
          var v1721 = !processingChange;
          if (v1721) {
            processingChange = true;
            callback$$28(filename$$11);
            setTimeout(v1352, 100);
          }
        }
        firstRun = false;
        var v1723 = {persistent:true, interval:500};
        _fs.watchFile(filename$$11, v1723, fileChanged);
        return;
      }
      var firstRun = true;
      var processingChange = false;
      fileChanged();
      return{filename:filename$$11, close:v1353};
    }
    function v1351() {
      return;
    }
    function v1350(str$$25) {
      var v1724 = process.stdout;
      var v1725 = str$$25 + "\n";
      v1724.write(v1725);
      return;
    }
    function v1349(str$$24) {
      var v1726 = process.stdout;
      v1726.write(str$$24);
      return;
    }
    function v1348() {
      return;
    }
    function v1347(str$$23) {
      var v1727 = process.stderr;
      var v1728 = str$$23 + "\n";
      v1727.write(v1728);
      return;
    }
    function v1346(str$$22) {
      var v1729 = process.stderr;
      v1729.write(str$$22);
      return;
    }
    function v1345(str$$21) {
      var v1730 = process.stdout;
      var v1731 = str$$21 + "\n";
      v1730.write(v1731);
      return;
    }
    function v1344(str$$20) {
      var v1732 = process.stdout;
      v1732.write(str$$20);
      return;
    }
    function v1343(rootPath$$1, partialFilePath$$1) {
      var v1733 = rootPath$$1 + "/";
      var path$$40 = v1733 + partialFilePath$$1;
      for (;true;) {
        var v1735 = _fs.existsSync(path$$40);
        if (v1735) {
          try {
            var content$$7 = this.readFile(path$$40);
            return{content:content$$7, path:path$$40};
          } catch (err$$6) {
          }
        } else {
          var parentPath$$1 = _path.resolve(rootPath$$1, "..");
          var v1734 = rootPath$$1 === parentPath$$1;
          if (v1734) {
            return null;
          } else {
            rootPath$$1 = parentPath$$1;
            path$$40 = _path.resolve(rootPath$$1, partialFilePath$$1);
          }
        }
      }
      return;
    }
    function v1342(path$$39) {
      return _path.dirname(path$$39);
    }
    function v1341(path$$38) {
      return _path.resolve(path$$38);
    }
    function v1340(path$$37) {
      var v1736 = _fs.existsSync(path$$37);
      if (v1736) {
        var v12523 = _fs.lstatSync(path$$37);
        v1736 = v12523.isDirectory();
      }
      return v1736;
    }
    function v1339(path$$36) {
      try {
        var v12524 = this.directoryExists(path$$36);
        var v1737 = !v12524;
        if (v1737) {
          _fs.mkdirSync(path$$36);
        }
      } catch (e$$20) {
        var v12525 = "Couldn't create directory '" + path$$36;
        var v1738 = v12525 + "'.";
        IOUtils.throwIOError(v1738, e$$20);
      }
      return;
    }
    function dir(path$$35, spec$$1, options$$9) {
      function filesInFolder$$1(folder$$2) {
        var paths$$2 = [];
        var files = _fs.readdirSync(folder$$2);
        var i$$142 = 0;
        var v12526 = files.length;
        var v1744 = i$$142 < v12526;
        for (;v1744;) {
          var v12527 = folder$$2 + "/";
          var v12528 = files[i$$142];
          var v1739 = v12527 + v12528;
          var stat = _fs.statSync(v1739);
          var v12529 = options$$9.recursive;
          if (v12529) {
            v12529 = stat.isDirectory();
          }
          var v1743 = v12529;
          if (v1743) {
            var v18939 = folder$$2 + "/";
            var v18940 = files[i$$142];
            var v12530 = v18939 + v18940;
            var v1740 = filesInFolder$$1(v12530);
            paths$$2 = paths$$2.concat(v1740);
          } else {
            var v12531 = stat.isFile();
            if (v12531) {
              var v18941 = !spec$$1;
              var v23104 = !v18941;
              if (v23104) {
                var v23103 = files[i$$142];
                v18941 = v23103.match(spec$$1);
              }
              v12531 = v18941;
            }
            var v1742 = v12531;
            if (v1742) {
              var v12532 = folder$$2 + "/";
              var v12533 = files[i$$142];
              var v1741 = v12532 + v12533;
              paths$$2.push(v1741);
            }
          }
          i$$142 = i$$142 + 1;
          var v12534 = files.length;
          v1744 = i$$142 < v12534;
        }
        return paths$$2;
      }
      options$$9 = options$$9 || {};
      return filesInFolder$$1(path$$35);
    }
    function v1338(path$$33, useUTF8$$4) {
      function v1337() {
        _fs.closeSync(fd);
        fd = null;
        return;
      }
      function v1336(str$$19) {
        var v1745 = str$$19 + "\r\n";
        _fs.writeSync(fd, v1745);
        return;
      }
      function v1335(str$$18) {
        _fs.writeSync(fd, str$$18);
        return;
      }
      function mkdirRecursiveSync(path$$34) {
        var stats = _fs.statSync(path$$34);
        var v1749 = stats.isFile();
        if (v1749) {
          var v12535 = '"' + path$$34;
          var v1746 = v12535 + "\" exists but isn't a directory.";
          IOUtils.throwIOError(v1746, null);
        } else {
          var v1748 = stats.isDirectory();
          if (v1748) {
          } else {
            var v1747 = _path.dirname(path$$34);
            mkdirRecursiveSync(v1747);
            _fs.mkdirSync(path$$34, 509);
          }
        }
        return;
      }
      var v1750 = _path.dirname(path$$33);
      mkdirRecursiveSync(v1750);
      try {
        var fd = _fs.openSync(path$$33, "w");
      } catch (e$$19) {
        var v12536 = "Couldn't write to file '" + path$$33;
        var v1751 = v12536 + "'.";
        IOUtils.throwIOError(v1751, e$$19);
      }
      return{Write:v1335, WriteLine:v1336, Close:v1337};
    }
    function v1334(path$$32) {
      return _fs.existsSync(path$$32);
    }
    function v1333(path$$31) {
      try {
        _fs.unlinkSync(path$$31);
      } catch (e$$18) {
        var v12537 = "Couldn't delete file '" + path$$31;
        var v1752 = v12537 + "'.";
        IOUtils.throwIOError(v1752, e$$18);
      }
      return;
    }
    function v1332(file$$2) {
      try {
        var buffer$$8 = _fs.readFileSync(file$$2);
        var v1759 = buffer$$8[0];
        switch(v1759) {
          case 254:
            var v12538 = buffer$$8[1];
            var v1756 = v12538 == 255;
            if (v1756) {
              var i$$141 = 0;
              var v12539 = i$$141 + 1;
              var v12540 = buffer$$8.length;
              var v1755 = v12539 < v12540;
              for (;v1755;) {
                var temp$$17 = buffer$$8[i$$141];
                var v1753 = i$$141 + 1;
                buffer$$8[i$$141] = buffer$$8[v1753];
                var v1754 = i$$141 + 1;
                buffer$$8[v1754] = temp$$17;
                i$$141 = i$$141 + 2;
                var v12541 = i$$141 + 1;
                var v12542 = buffer$$8.length;
                v1755 = v12541 < v12542;
              }
              return buffer$$8.toString("ucs2", 2);
            }
            break;
          case 255:
            var v12543 = buffer$$8[1];
            var v1757 = v12543 == 254;
            if (v1757) {
              return buffer$$8.toString("ucs2", 2);
            }
            break;
          case 239:
            var v12544 = buffer$$8[1];
            var v1758 = v12544 == 187;
            if (v1758) {
              return buffer$$8.toString("utf8", 3);
            }
          ;
        }
        return buffer$$8.toString();
      } catch (e$$17) {
        var v12545 = 'Error reading file "' + file$$2;
        var v1760 = v12545 + '".';
        IOUtils.throwIOError(v1760, e$$17);
      }
      return;
    }
    var _fs = require("fs");
    var _path = require("path");
    var _module = require("module");
    var v1761 = _fs.writeFileSync;
    var v12546 = process.argv;
    var v1762 = v12546.slice(2);
    var v1763 = {Write:v1346, WriteLine:v1347, Close:v1348};
    var v1764 = {Write:v1349, WriteLine:v1350, Close:v1351};
    var v1765 = process.exit;
    return{readFile:v1332, writeFile:v1761, deleteFile:v1333, fileExists:v1334, createFile:v1338, dir:dir, createDirectory:v1339, directoryExists:v1340, resolvePath:v1341, dirName:v1342, findFile:v1343, print:v1344, printLine:v1345, arguments:v1762, stderr:v1763, stdout:v1764, watchFile:v1354, run:v1355, getExecutingFilePath:v1356, quit:v1765};
  }
  var v12547 = typeof ActiveXObject;
  var v1767 = v12547 === "function";
  if (v1767) {
    return getWindowsScriptHostIO();
  } else {
    var v12548 = typeof require;
    var v1766 = v12548 === "function";
    if (v1766) {
      return getNodeIO();
    } else {
      return null;
    }
  }
  return;
}
function v1312(IOUtils$$1) {
  function createDirectoryStructure(ioHost$$5, dirName) {
    var v1768 = ioHost$$5.directoryExists(dirName);
    if (v1768) {
      return;
    }
    var parentDirectory = ioHost$$5.dirName(dirName);
    var v1769 = parentDirectory != "";
    if (v1769) {
      createDirectoryStructure(ioHost$$5, parentDirectory);
    }
    ioHost$$5.createDirectory(dirName);
    return;
  }
  function createFileAndFolderStructure(ioHost$$6, fileName$$9, useUTF8$$2) {
    var path$$19 = ioHost$$6.resolvePath(fileName$$9);
    var dirName$$1 = ioHost$$6.dirName(path$$19);
    createDirectoryStructure(ioHost$$6, dirName$$1);
    return ioHost$$6.createFile(path$$19, useUTF8$$2);
  }
  function throwIOError(message$$22, error$$2) {
    var errorMessage = message$$22;
    var v12549 = error$$2;
    if (v12549) {
      v12549 = error$$2.message;
    }
    var v1770 = v12549;
    if (v1770) {
      var v18942 = error$$2.message;
      var v12550 = " " + v18942;
      errorMessage = errorMessage + v12550;
    }
    throw new Error(errorMessage);
  }
  IOUtils$$1.createFileAndFolderStructure = createFileAndFolderStructure;
  IOUtils$$1.throwIOError = throwIOError;
  return;
}
function v1311(TypeScript$$33) {
  function v1310() {
    function v1309(s$$41) {
      var v1771 = this.logContents;
      v1771.push(s$$41);
      return;
    }
    function v1308() {
      return false;
    }
    function v1307() {
      return false;
    }
    function v1306() {
      return false;
    }
    function v1305() {
      return false;
    }
    function v1304() {
      return false;
    }
    function BufferedLogger$$1() {
      this.logContents = [];
      return;
    }
    var v1772 = BufferedLogger$$1.prototype;
    v1772.information = v1304;
    var v1773 = BufferedLogger$$1.prototype;
    v1773.debug = v1305;
    var v1774 = BufferedLogger$$1.prototype;
    v1774.warning = v1306;
    var v1775 = BufferedLogger$$1.prototype;
    v1775.error = v1307;
    var v1776 = BufferedLogger$$1.prototype;
    v1776.fatal = v1308;
    var v1777 = BufferedLogger$$1.prototype;
    v1777.log = v1309;
    return BufferedLogger$$1;
  }
  function v1303() {
    function v1302(s$$40) {
      var v1778 = this.logger;
      v1778.log(s$$40);
      return;
    }
    function v1301() {
      return this._fatal;
    }
    function v1300() {
      return this._error;
    }
    function v1299() {
      return this._warning;
    }
    function v1298() {
      return this._debug;
    }
    function v1297() {
      return this._information;
    }
    function LoggerAdapter$$1(logger$$8) {
      this.logger = logger$$8;
      var v1779 = this.logger;
      var v26771 = v1779.information();
      this._information = v26771;
      var v1780 = this.logger;
      var v26772 = v1780.debug();
      this._debug = v26772;
      var v1781 = this.logger;
      var v26773 = v1781.warning();
      this._warning = v26773;
      var v1782 = this.logger;
      var v26774 = v1782.error();
      this._error = v26774;
      var v1783 = this.logger;
      var v26775 = v1783.fatal();
      this._fatal = v26775;
      return;
    }
    var v1784 = LoggerAdapter$$1.prototype;
    v1784.information = v1297;
    var v1785 = LoggerAdapter$$1.prototype;
    v1785.debug = v1298;
    var v1786 = LoggerAdapter$$1.prototype;
    v1786.warning = v1299;
    var v1787 = LoggerAdapter$$1.prototype;
    v1787.error = v1300;
    var v1788 = LoggerAdapter$$1.prototype;
    v1788.fatal = v1301;
    var v1789 = LoggerAdapter$$1.prototype;
    v1789.log = v1302;
    return LoggerAdapter$$1;
  }
  function v1296() {
    function v1295(s$$39) {
      return;
    }
    function v1294() {
      return false;
    }
    function v1293() {
      return false;
    }
    function v1292() {
      return false;
    }
    function v1291() {
      return false;
    }
    function v1290() {
      return false;
    }
    function NullLogger$$1() {
      return;
    }
    var v1790 = NullLogger$$1.prototype;
    v1790.information = v1290;
    var v1791 = NullLogger$$1.prototype;
    v1791.debug = v1291;
    var v1792 = NullLogger$$1.prototype;
    v1792.warning = v1292;
    var v1793 = NullLogger$$1.prototype;
    v1793.error = v1293;
    var v1794 = NullLogger$$1.prototype;
    v1794.fatal = v1294;
    var v1795 = NullLogger$$1.prototype;
    v1795.log = v1295;
    return NullLogger$$1;
  }
  function v1289(CompilerDiagnostics$$1) {
    function Alert(output) {
      var v1797 = CompilerDiagnostics$$1.diagnosticWriter;
      if (v1797) {
        var v1796 = CompilerDiagnostics$$1.diagnosticWriter;
        v1796.Alert(output);
      }
      return;
    }
    function debugPrint(s$$37) {
      var v1798 = CompilerDiagnostics$$1.debug;
      if (v1798) {
        Alert(s$$37);
      }
      return;
    }
    function assert(condition$$1, s$$38) {
      var v1800 = CompilerDiagnostics$$1.debug;
      if (v1800) {
        var v1799 = !condition$$1;
        if (v1799) {
          Alert(s$$38);
        }
      }
      return;
    }
    CompilerDiagnostics$$1.debug = false;
    CompilerDiagnostics$$1.diagnosticWriter = null;
    CompilerDiagnostics$$1.analysisPass = 0;
    CompilerDiagnostics$$1.Alert = Alert;
    CompilerDiagnostics$$1.debugPrint = debugPrint;
    CompilerDiagnostics$$1.assert = assert;
    return;
  }
  function timeFunction(logger$$7, funcDescription$$1, func$$5) {
    var v1801 = new Date;
    var start$$14 = +v1801;
    var result$$39 = func$$5();
    var v1802 = new Date;
    var end$$7 = +v1802;
    var v18943 = funcDescription$$1 + " completed in ";
    var v18944 = end$$7 - start$$14;
    var v12551 = v18943 + v18944;
    var v1803 = v12551 + " msec";
    logger$$7.log(v1803);
    return result$$39;
  }
  function stringToLiteral(value$$41, length$$18) {
    function addChar(index$$65) {
      var ch$$1 = value$$41.charCodeAt(index$$65);
      switch(ch$$1) {
        case 9:
          result$$40 = result$$40 + "\\t";
          break;
        case 10:
          result$$40 = result$$40 + "\\n";
          break;
        case 11:
          result$$40 = result$$40 + "\\v";
          break;
        case 12:
          result$$40 = result$$40 + "\\f";
          break;
        case 13:
          result$$40 = result$$40 + "\\r";
          break;
        case 34:
          result$$40 = result$$40 + '\\"';
          break;
        case 39:
          result$$40 = result$$40 + "\\'";
          break;
        case 92:
          result$$40 = result$$40 + "\\";
          break;
        default:
          var v12552 = result$$40;
          var v12553 = value$$41.charAt(index$$65);
          result$$40 = v12552 + v12553;
      }
      return;
    }
    var result$$40 = "";
    var v1804 = value$$41.length;
    var tooLong = v1804 > length$$18;
    if (tooLong) {
      var mid$$1 = length$$18 >> 1;
      var i$$139 = 0;
      var v1805 = i$$139 < mid$$1;
      for (;v1805;) {
        addChar(i$$139);
        i$$139 = i$$139 + 1;
        v1805 = i$$139 < mid$$1;
      }
      result$$40 = result$$40 + "(...)";
      var v1806 = value$$41.length;
      i$$139 = v1806 - mid$$1;
      var v12554 = value$$41.length;
      var v1807 = i$$139 < v12554;
      for (;v1807;) {
        addChar(i$$139);
        i$$139 = i$$139 + 1;
        var v12555 = value$$41.length;
        v1807 = i$$139 < v12555;
      }
    } else {
      length$$18 = value$$41.length;
      i$$139 = 0;
      var v1808 = i$$139 < length$$18;
      for (;v1808;) {
        addChar(i$$139);
        i$$139 = i$$139 + 1;
        v1808 = i$$139 < length$$18;
      }
    }
    return result$$40;
  }
  var v12556 = TypeScript$$33.CompilerDiagnostics;
  var v18945 = !v12556;
  if (v18945) {
    v12556 = TypeScript$$33.CompilerDiagnostics = {};
  }
  var v1809 = v12556;
  v1289(v1809);
  var CompilerDiagnostics = TypeScript$$33.CompilerDiagnostics;
  var NullLogger = v1296();
  TypeScript$$33.NullLogger = NullLogger;
  var LoggerAdapter = v1303();
  TypeScript$$33.LoggerAdapter = LoggerAdapter;
  var BufferedLogger = v1310();
  TypeScript$$33.BufferedLogger = BufferedLogger;
  TypeScript$$33.timeFunction = timeFunction;
  TypeScript$$33.stringToLiteral = stringToLiteral;
  return;
}
function v1288(TypeScript$$32) {
  function v1287() {
    function v1286(enclosingScopeContext$$5, allNames, scope$$36) {
      var result$$38 = [];
      var enclosingScope$$2 = enclosingScopeContext$$5.getScope();
      var i$$138 = 0;
      var v12557 = allNames.length;
      var v1818 = i$$138 < v12557;
      for (;v1818;) {
        var name$$89 = allNames[i$$138];
        var v1810 = enclosingScopeContext$$5.publicsOnly;
        if (v1810) {
          v1810 = enclosingScopeContext$$5.isMemberCompletion;
        }
        var publicsOnly = v1810;
        var symbol$$23 = scope$$36.find(name$$89, publicsOnly, false);
        var v1811 = symbol$$23 == null;
        if (v1811) {
          symbol$$23 = scope$$36.find(name$$89, publicsOnly, true);
        }
        var v1812;
        var v18946 = symbol$$23;
        if (v18946) {
          var v23105 = symbol$$23.flags;
          var v25147 = TypeScript$$32.SymbolFlags;
          var v23106 = v25147.Private;
          v18946 = v23105 & v23106;
        }
        var v12560 = v18946;
        if (v12560) {
          var v12558 = symbol$$23.container;
          var v12559 = scope$$36.container;
          v1812 = v12558 == v12559;
        } else {
          v1812 = true;
        }
        var displayThisMember = v1812;
        if (symbol$$23) {
          var v18947 = displayThisMember;
          if (v18947) {
            var v25148 = symbol$$23.name;
            var v23107 = TypeScript$$32.isQuoted(v25148);
            v18947 = !v23107;
          }
          var v12561 = v18947;
          if (v12561) {
            var v23108 = symbol$$23.name;
            var v18948 = TypeScript$$32.isRelative(v23108);
            v12561 = !v18948;
          }
          var v1815 = v12561;
          if (v1815) {
            var v1813 = symbol$$23.getType();
            var typeName$$11 = v1813.getScopedTypeName(enclosingScope$$2);
            var v1814 = new ScopeEntry(name$$89, typeName$$11, symbol$$23);
            result$$38.push(v1814);
          }
        } else {
          var v12562 = name$$89 == "true";
          var v18949 = !v12562;
          if (v18949) {
            v12562 = name$$89 == "false";
          }
          var v1817 = v12562;
          if (v1817) {
            var v25149 = this.compiler;
            var v23109 = v25149.typeChecker;
            var v18950 = v23109.booleanType;
            var v12563 = v18950.symbol;
            var v1816 = new ScopeEntry(name$$89, "bool", v12563);
            result$$38.push(v1816);
          }
        }
        i$$138 = i$$138 + 1;
        var v12564 = allNames.length;
        v1818 = i$$138 < v12564;
      }
      return result$$38;
    }
    function v1285(enclosingScopeContext$$4) {
      var scope$$35 = this.getScope(enclosingScopeContext$$4);
      var v1819 = scope$$35 == null;
      if (v1819) {
        return[];
      }
      var v1820 = TypeScript$$32.StringHashTable;
      var inScopeNames = new v1820;
      var v1821 = enclosingScopeContext$$4.isMemberCompletion;
      var allSymbolNames = scope$$35.getAllSymbolNames(v1821);
      var i$$137 = 0;
      var v12565 = allSymbolNames.length;
      var v1823 = i$$137 < v12565;
      for (;v1823;) {
        var name$$88 = allSymbolNames[i$$137];
        var v23110 = TypeScript$$32.globalId;
        var v18951 = name$$88 == v23110;
        var v23111 = !v18951;
        if (v23111) {
          v18951 = name$$88 == "_Core";
        }
        var v12566 = v18951;
        var v18952 = !v12566;
        if (v18952) {
          v12566 = name$$88 == "_element";
        }
        var v1822 = v12566;
        if (v1822) {
          i$$137 = i$$137 + 1;
          var v12567 = allSymbolNames.length;
          v1823 = i$$137 < v12567;
          continue;
        }
        inScopeNames.add(name$$88, "");
        i$$137 = i$$137 + 1;
        var v12568 = allSymbolNames.length;
        v1823 = i$$137 < v12568;
      }
      var v12569 = this.compiler;
      var v1824 = v12569.typeChecker;
      var svModuleDecl = v1824.currentModDecl;
      var v12570 = this.compiler;
      var v1825 = v12570.typeChecker;
      v1825.currentModDecl = enclosingScopeContext$$4.deepestModuleDecl;
      var v1826 = inScopeNames.getAllKeys();
      var result$$37 = this.getTypeNamesForNames(enclosingScopeContext$$4, v1826, scope$$35);
      var v12571 = this.compiler;
      var v1827 = v12571.typeChecker;
      v1827.currentModDecl = svModuleDecl;
      return result$$37;
    }
    function v1284(enclosingScopeContext$$3) {
      var v12572 = enclosingScopeContext$$3.enclosingObjectLit;
      if (v12572) {
        v12572 = enclosingScopeContext$$3.isMemberCompletion;
      }
      var v1832 = v12572;
      if (v1832) {
        return enclosingScopeContext$$3.getObjectLiteralScope();
      } else {
        var v1831 = enclosingScopeContext$$3.isMemberCompletion;
        if (v1831) {
          var v1830 = enclosingScopeContext$$3.useFullAst;
          if (v1830) {
            var v12573 = this.compiler;
            var v1828 = v12573.typeFlow;
            return v1828.findMemberScopeAtFullAst(enclosingScopeContext$$3);
          } else {
            var v12574 = this.compiler;
            var v1829 = v12574.typeFlow;
            return v1829.findMemberScopeAt(enclosingScopeContext$$3);
          }
        } else {
          return enclosingScopeContext$$3.getScope();
        }
      }
      return;
    }
    function ScopeTraversal$$1(compiler$$2) {
      this.compiler = compiler$$2;
      return;
    }
    var v1833 = ScopeTraversal$$1.prototype;
    v1833.getScope = v1284;
    var v1834 = ScopeTraversal$$1.prototype;
    v1834.getScopeEntries = v1285;
    var v1835 = ScopeTraversal$$1.prototype;
    v1835.getTypeNamesForNames = v1286;
    return ScopeTraversal$$1;
  }
  function v1283() {
    function ScopeEntry$$1(name$$87, type$$60, sym$$49) {
      this.name = name$$87;
      this.type = type$$60;
      this.sym = sym$$49;
      return;
    }
    return ScopeEntry$$1;
  }
  function v1282() {
    function v1281(fileName$$8, useUTF8$$1) {
      try {
        var v12575 = this.emitSettings;
        var v1836 = v12575.ioHost;
        return v1836.createFile(fileName$$8, useUTF8$$1);
      } catch (ex$$6) {
        var v1837 = this.errorReporter;
        var v1838 = ex$$6.message;
        v1837.emitterError(null, v1838);
      }
      return;
    }
    function v1280(scripts) {
      var i$$136 = 0;
      var len$$68 = scripts.length;
      var v1840 = i$$136 < len$$68;
      for (;v1840;) {
        var script$$38 = scripts[i$$136];
        var v1839 = this.outputScriptToUTF8(script$$38);
        if (v1839) {
          return true;
        }
        i$$136 = i$$136 + 1;
        v1840 = i$$136 < len$$68;
      }
      return false;
    }
    function v1279(script$$37) {
      var v1841 = script$$37.containsUnicodeChar;
      var v12577 = !v1841;
      if (v12577) {
        var v18953 = this.emitSettings;
        var v12576 = v18953.emitComments;
        if (v12576) {
          v12576 = script$$37.containsUnicodeCharInComment;
        }
        v1841 = v12576;
      }
      return v1841;
    }
    function v1278(ioHost$$4) {
      function v1277(fileName$$7, wholeFileNameReplaced$$3) {
        return TypeScriptCompiler$$1.mapToFileNameExtension(".txt", fileName$$7, wholeFileNameReplaced$$3);
      }
      this.parseEmitOption(ioHost$$4);
      var outFile$$1 = null;
      var context$$65 = null;
      var i$$135 = 0;
      var v12578 = this.scripts;
      var v1842 = v12578.members;
      var len$$67 = v1842.length;
      var v1856 = i$$135 < len$$67;
      for (;v1856;) {
        var v12579 = this.scripts;
        var v1843 = v12579.members;
        var script$$36 = v1843[i$$135];
        var v18954 = this.emitSettings;
        var v12580 = v18954.outputMany;
        var v18955 = !v12580;
        if (v18955) {
          v12580 = context$$65 == null;
        }
        var v1849 = v12580;
        if (v1849) {
          var v12581 = this.units;
          var v1844 = v12581[i$$135];
          var fname$$8 = v1844.filename;
          var mapToTxtFileName = v1277;
          var v1845 = this.emitSettings;
          var outFname$$2 = v1845.mapOutputFileName(fname$$8, mapToTxtFileName);
          var v1846 = this.useUTF8ForFile(script$$36);
          outFile$$1 = this.createFile(outFname$$2, v1846);
          var v1847 = TypeScript$$32.PrintContext;
          var v1848 = this.parser;
          context$$65 = new v1847(outFile$$1, v1848);
        }
        var v1850 = TypeScript$$32.getAstWalkerFactory();
        var v1851 = TypeScript$$32.prePrintAST;
        var v1852 = TypeScript$$32.postPrintAST;
        v1850.walk(script$$36, v1851, v1852, null, context$$65);
        var v12582 = this.emitSettings;
        var v1855 = v12582.outputMany;
        if (v1855) {
          try {
            outFile$$1.Close();
          } catch (e$$11) {
            var v1853 = this.errorReporter;
            var v1854 = e$$11.message;
            v1853.emitterError(null, v1854);
          }
        }
        i$$135 = i$$135 + 1;
        v1856 = i$$135 < len$$67;
      }
      var v18956 = this.emitSettings;
      var v12583 = v18956.outputMany;
      var v1859 = !v12583;
      if (v1859) {
        try {
          outFile$$1.Close();
        } catch (e$$12) {
          var v1857 = this.errorReporter;
          var v1858 = e$$12.message;
          v1857.emitterError(null, v1858);
        }
      }
      return;
    }
    function v1276(outputFile) {
      var v12584 = this.settings;
      var v1860 = v12584.mapSourceFiles;
      if (v1860) {
        throw Error("Cannot generate source map");
      }
      var v12585 = this.settings;
      var v1861 = v12585.generateDeclarationFiles;
      if (v1861) {
        throw Error("Cannot generate declaration files");
      }
      var v18957 = this.settings;
      var v12586 = v18957.outputOption;
      var v1862 = v12586 != "";
      if (v1862) {
        throw Error("Cannot parse output option");
      }
      var v1863 = TypeScript$$32.Emitter;
      var v1864 = this.typeChecker;
      var v1865 = this.emitSettings;
      var v1866 = this.errorReporter;
      var emitter$$41 = emitter$$41 = new v1863(v1864, "stdout", outputFile, v1865, v1866);
      var i$$134 = 0;
      var v12587 = this.scripts;
      var v1867 = v12587.members;
      var len$$66 = v1867.length;
      var v1871 = i$$134 < len$$66;
      for (;v1871;) {
        var v12588 = this.scripts;
        var v1868 = v12588.members;
        var script$$35 = v1868[i$$134];
        var v1869 = this.typeChecker;
        v1869.locationInfo = script$$35.locationInfo;
        var v12589 = TypeScript$$32.TokenID;
        var v1870 = v12589.Comma;
        emitter$$41.emitJavascript(script$$35, v1870, false);
        i$$134 = i$$134 + 1;
        v1871 = i$$134 < len$$66;
      }
      return;
    }
    function v1275(ioHost$$3) {
      this.parseEmitOption(ioHost$$3);
      var emitter$$40 = null;
      var i$$133 = 0;
      var v12590 = this.scripts;
      var v1872 = v12590.members;
      var len$$65 = v1872.length;
      var v1876 = i$$133 < len$$65;
      for (;v1876;) {
        var v12591 = this.scripts;
        var v1873 = v12591.members;
        var script$$34 = v1873[i$$133];
        var v18958 = this.emitSettings;
        var v12592 = v18958.outputMany;
        var v18959 = !v12592;
        if (v18959) {
          v12592 = emitter$$40 == null;
        }
        var v1875 = v12592;
        if (v1875) {
          var v18960 = this.emitSettings;
          var v12593 = v18960.outputMany;
          var v1874 = !v12593;
          emitter$$40 = this.emitUnit(script$$34, v1874);
        } else {
          this.emitUnit(script$$34, true, emitter$$40);
        }
        i$$133 = i$$133 + 1;
        v1876 = i$$133 < len$$65;
      }
      if (emitter$$40) {
        emitter$$40.Close();
      }
      return;
    }
    function v1274(script$$33, reuseEmitter$$1, emitter$$39) {
      var v18961 = this.emitSettings;
      var v12594 = script$$33.emitRequired(v18961);
      var v1877 = !v12594;
      if (v1877) {
        return null;
      }
      var v1878 = script$$33.locationInfo;
      var fname$$7 = v1878.filename;
      var v1890 = !emitter$$39;
      if (v1890) {
        var v1879 = this.emitSettings;
        var v1880 = TypeScriptCompiler$$1.mapToJSFileName;
        var outFname$$1 = v1879.mapOutputFileName(fname$$7, v1880);
        var v1881 = this.useUTF8ForFile(script$$33);
        var outFile = this.createFile(outFname$$1, v1881);
        var v1882 = TypeScript$$32.Emitter;
        var v1883 = this.typeChecker;
        var v1884 = this.emitSettings;
        var v1885 = this.errorReporter;
        emitter$$39 = new v1882(v1883, outFname$$1, outFile, v1884, v1885);
        var v12595 = this.settings;
        var v1887 = v12595.mapSourceFiles;
        if (v1887) {
          var v12596 = TypeScript$$32.SourceMapper;
          var v25150 = TypeScript$$32.SourceMapper;
          var v23112 = v25150.MapFileExtension;
          var v18962 = outFname$$1 + v23112;
          var v12597 = this.createFile(v18962, false);
          var v12598 = this.errorReporter;
          var v1886 = new v12596(fname$$7, outFname$$1, outFile, v12597, v12598);
          emitter$$39.setSourceMappings(v1886);
        }
      } else {
        var v12599 = this.settings;
        var v1889 = v12599.mapSourceFiles;
        if (v1889) {
          var v12600 = TypeScript$$32.SourceMapper;
          var v12601 = emitter$$39.emittingFileName;
          var v12602 = emitter$$39.outfile;
          var v18963 = emitter$$39.sourceMapper;
          var v12603 = v18963.sourceMapOut;
          var v12604 = this.errorReporter;
          var v1888 = new v12600(fname$$7, v12601, v12602, v12603, v12604);
          emitter$$39.setSourceMappings(v1888);
        }
      }
      var v1891 = this.typeChecker;
      v1891.locationInfo = script$$33.locationInfo;
      var v12605 = TypeScript$$32.TokenID;
      var v1892 = v12605.Comma;
      emitter$$39.emitJavascript(script$$33, v1892, false);
      var v1893 = !reuseEmitter$$1;
      if (v1893) {
        emitter$$39.Close();
        return null;
      } else {
        return emitter$$39;
      }
      return;
    }
    function mapToJSFileName(fileName$$6, wholeFileNameReplaced$$2) {
      return TypeScriptCompiler$$1.mapToFileNameExtension(".js", fileName$$6, wholeFileNameReplaced$$2);
    }
    function mapToFileNameExtension(extension, fileName$$5, wholeFileNameReplaced$$1) {
      if (wholeFileNameReplaced$$1) {
        return fileName$$5;
      } else {
        var splitFname = fileName$$5.split(".");
        splitFname.pop();
        var v1894 = splitFname.join(".");
        return v1894 + extension;
      }
      return;
    }
    function v1273() {
      var v12606 = this.canEmitDeclarations();
      var v1895 = !v12606;
      if (v1895) {
        return;
      }
      var v12607 = this.errorReporter;
      var v1896 = v12607.hasErrors;
      if (v1896) {
        return;
      }
      var v23113 = this.scripts;
      var v18964 = v23113.members;
      var v12608 = v18964.length;
      var v1897 = v12608 == 0;
      if (v1897) {
        return;
      }
      var declarationEmitter$$1 = null;
      var i$$132 = 0;
      var v12609 = this.scripts;
      var v1898 = v12609.members;
      var len$$64 = v1898.length;
      var v1902 = i$$132 < len$$64;
      for (;v1902;) {
        var v12610 = this.scripts;
        var v1899 = v12610.members;
        var script$$32 = v1899[i$$132];
        var v18965 = this.emitSettings;
        var v12611 = v18965.outputMany;
        var v18966 = !v12611;
        if (v18966) {
          v12611 = declarationEmitter$$1 == null;
        }
        var v1901 = v12611;
        if (v1901) {
          var v18967 = this.emitSettings;
          var v12612 = v18967.outputMany;
          var v1900 = !v12612;
          declarationEmitter$$1 = this.emitDeclarationsUnit(script$$32, v1900);
        } else {
          this.emitDeclarationsUnit(script$$32, true, declarationEmitter$$1);
        }
        i$$132 = i$$132 + 1;
        v1902 = i$$132 < len$$64;
      }
      if (declarationEmitter$$1) {
        declarationEmitter$$1.Close();
      }
      return;
    }
    function v1272(script$$31, reuseEmitter, declarationEmitter) {
      var v12613 = this.canEmitDeclarations(script$$31);
      var v1903 = !v12613;
      if (v1903) {
        return null;
      }
      var v1912 = !declarationEmitter;
      if (v1912) {
        var v1904 = this.emitSettings;
        var v12614 = script$$31.locationInfo;
        var v1905 = v12614.filename;
        var v1906 = TypeScriptCompiler$$1.mapToDTSFileName;
        var declareFileName$$2 = v1904.mapOutputFileName(v1905, v1906);
        var v1907 = this.useUTF8ForFile(script$$31);
        var declareFile = this.createFile(declareFileName$$2, v1907);
        var v1908 = TypeScript$$32.DeclarationEmitter;
        var v1909 = this.typeChecker;
        var v1910 = this.emitSettings;
        var v1911 = this.errorReporter;
        declarationEmitter = new v1908(v1909, v1910, v1911);
        declarationEmitter.setDeclarationFile(declareFile);
      }
      declarationEmitter.emitDeclarations(script$$31);
      var v1913 = !reuseEmitter;
      if (v1913) {
        declarationEmitter.Close();
        return null;
      } else {
        return declarationEmitter;
      }
      return;
    }
    function v1271(script$$30) {
      var v18968 = this.settings;
      var v12615 = v18968.generateDeclarationFiles;
      var v1914 = !v12615;
      if (v1914) {
        return false;
      }
      var v18969 = !script$$30;
      var v12616 = !v18969;
      if (v12616) {
        var v23114 = script$$30.isDeclareFile;
        var v25151 = !v23114;
        if (v25151) {
          v23114 = script$$30.isResident;
        }
        var v18970 = v23114;
        var v23116 = !v18970;
        if (v23116) {
          var v23115 = script$$30.bod;
          v18970 = v23115 == null;
        }
        v12616 = v18970;
      }
      var v1915 = v12616;
      if (v1915) {
        return false;
      }
      return true;
    }
    function mapToDTSFileName(fileName$$4, wholeFileNameReplaced) {
      return TypeScript$$32.getDeclareFilePath(fileName$$4);
    }
    function v1270(script$$29) {
      var v12617 = this.emitSettings;
      var v1917 = v12617.outputMany;
      if (v1917) {
        return this.outputScriptToUTF8(script$$29);
      } else {
        var v12618 = this.scripts;
        var v1916 = v12618.members;
        return this.outputScriptsToUTF8(v1916);
      }
      return;
    }
    function v1269(ioHost$$2) {
      var v1918 = this.emitSettings;
      v1918.ioHost = ioHost$$2;
      var v18971 = this.emitSettings;
      var v12619 = v18971.outputOption;
      var v1921 = v12619 == "";
      if (v1921) {
        var v1919 = this.emitSettings;
        v1919.outputMany = true;
        var v1920 = this.emitSettings;
        v1920.commonDirectoryPath = "";
        return;
      }
      var v1922 = this.emitSettings;
      var v23117 = this.emitSettings;
      var v18972 = v23117.ioHost;
      var v23118 = this.emitSettings;
      var v18973 = v23118.outputOption;
      var v12620 = v18972.resolvePath(v18973);
      var v26776 = TypeScript$$32.switchToForwardSlashes(v12620);
      v1922.outputOption = v26776;
      var v18974 = this.emitSettings;
      var v12621 = v18974.ioHost;
      var v18975 = this.emitSettings;
      var v12622 = v18975.outputOption;
      var v1927 = v12621.directoryExists(v12622);
      if (v1927) {
        var v1923 = this.emitSettings;
        v1923.outputMany = true;
      } else {
        var v18976 = this.emitSettings;
        var v12623 = v18976.ioHost;
        var v18977 = this.emitSettings;
        var v12624 = v18977.outputOption;
        var v1926 = v12623.fileExists(v12624);
        if (v1926) {
          var v1924 = this.emitSettings;
          v1924.outputMany = false;
        } else {
          var v1925 = this.emitSettings;
          var v23119 = this.emitSettings;
          var v18978 = v23119.outputOption;
          var v12625 = TypeScript$$32.isJSFile(v18978);
          v1925.outputMany = !v12625;
        }
      }
      var v12626 = this.isDynamicModuleCompilation();
      if (v12626) {
        var v23120 = this.emitSettings;
        var v18979 = v23120.outputMany;
        v12626 = !v18979;
      }
      var v1929 = v12626;
      if (v1929) {
        var v1928 = this.errorReporter;
        v1928.emitterError(null, "Cannot compile dynamic modules when emitting into single file");
      }
      var v12627 = this.emitSettings;
      var v1930 = v12627.outputMany;
      if (v1930) {
        this.updateCommonDirectoryPath();
      }
      return;
    }
    function v1268() {
      var commonComponents = [];
      var commonComponentsLength = -1;
      var i$$131 = 0;
      var v12628 = this.scripts;
      var v1931 = v12628.members;
      var len$$63 = v1931.length;
      var v1941 = i$$131 < len$$63;
      for (;v1941;) {
        var v12629 = this.scripts;
        var v1932 = v12629.members;
        var script$$28 = v1932[i$$131];
        var v12630 = this.emitSettings;
        var v1940 = script$$28.emitRequired(v12630);
        if (v1940) {
          var v1933 = script$$28.locationInfo;
          var fileName$$3 = v1933.filename;
          var fileComponents = TypeScript$$32.filePathComponents(fileName$$3);
          var v1939 = commonComponentsLength == -1;
          if (v1939) {
            commonComponents = fileComponents;
            commonComponentsLength = commonComponents.length;
          } else {
            var updatedPath = false;
            var j$$20 = 0;
            var v12631 = j$$20 < commonComponentsLength;
            if (v12631) {
              var v18980 = fileComponents.length;
              v12631 = j$$20 < v18980;
            }
            var v1937 = v12631;
            for (;v1937;) {
              var v12632 = commonComponents[j$$20];
              var v12633 = fileComponents[j$$20];
              var v1936 = v12632 != v12633;
              if (v1936) {
                commonComponentsLength = j$$20;
                updatedPath = true;
                var v1935 = j$$20 == 0;
                if (v1935) {
                  var v1934 = this.errorReporter;
                  v1934.emitterError(null, "Cannot find the common subdirectory path for the input files");
                  return;
                }
                break;
              }
              j$$20 = j$$20 + 1;
              var v12634 = j$$20 < commonComponentsLength;
              if (v12634) {
                var v18981 = fileComponents.length;
                v12634 = j$$20 < v18981;
              }
              v1937 = v12634;
            }
            var v12635 = !updatedPath;
            if (v12635) {
              var v18982 = fileComponents.length;
              v12635 = v18982 < commonComponentsLength;
            }
            var v1938 = v12635;
            if (v1938) {
              commonComponentsLength = fileComponents.length;
            }
          }
        }
        i$$131 = i$$131 + 1;
        v1941 = i$$131 < len$$63;
      }
      var v1942 = this.emitSettings;
      var v18983 = commonComponents.slice(0, commonComponentsLength);
      var v12636 = v18983.join("/");
      v1942.commonDirectoryPath = v12636 + "/";
      var v23121 = this.emitSettings;
      var v18984 = v23121.outputOption;
      var v26023 = this.emitSettings;
      var v25152 = v26023.outputOption;
      var v23122 = v25152.length;
      var v18985 = v23122 - 1;
      var v12637 = v18984.charAt(v18985);
      var v1944 = v12637 != "/";
      if (v1944) {
        var v1943 = this.emitSettings;
        var v18986 = v1943.outputOption;
        v1943.outputOption = v18986 + "/";
      }
      return;
    }
    function v1267() {
      var i$$130 = 0;
      var v12638 = this.scripts;
      var v1945 = v12638.members;
      var len$$62 = v1945.length;
      var v1948 = i$$130 < len$$62;
      for (;v1948;) {
        var v12639 = this.scripts;
        var v1946 = v12639.members;
        var script$$27 = v1946[i$$130];
        var v18987 = script$$27.isDeclareFile;
        var v12640 = !v18987;
        if (v12640) {
          var v18988 = script$$27.topLevelMod;
          v12640 = v18988 != null;
        }
        var v1947 = v12640;
        if (v1947) {
          return true;
        }
        i$$130 = i$$130 + 1;
        v1948 = i$$130 < len$$62;
      }
      return false;
    }
    function v1266() {
      function v1265() {
        var v12641 = TypeScript$$32.CompilerDiagnostics;
        var v23123 = TypeScript$$32.CompilerDiagnostics;
        var v18989 = v23123.analysisPass;
        v12641.analysisPass = v18989 + 1;
        var v1949 = _this$$20.errorOutput;
        _this$$20.initTypeChecker(v1949);
        var v1950 = _this$$20.persistentTypeState;
        var v12642 = TypeScript$$32.TypeCheckCollectionMode;
        var v1951 = v12642.Transient;
        v1950.setCollectionMode(v1951);
        _this$$20.cleanTypesForReTypeCheck();
        return _this$$20.typeCheck();
      }
      var _this$$20 = this;
      return this.timeFunction("reTypeCheck()", v1265);
    }
    function v1264(updateResult$$4) {
      function v1263() {
        return false;
      }
      return this.timeFunction("attemptIncrementalTypeCheck()", v1263);
    }
    function v1262() {
      function v1261() {
        var i$$129 = 0;
        var v12643 = _this$$19.scripts;
        var v1952 = v12643.members;
        var len$$61 = v1952.length;
        var v1956 = i$$129 < len$$61;
        for (;v1956;) {
          var v12644 = _this$$19.scripts;
          var v1953 = v12644.members;
          var script$$26 = v1953[i$$129];
          var v1954 = script$$26.isResident;
          if (v1954) {
            i$$129 = i$$129 + 1;
            v1956 = i$$129 < len$$61;
            continue;
          }
          _this$$19.cleanASTTypesForReTypeCheck(script$$26);
          var v1955 = _this$$19.typeChecker;
          v1955.collectTypes(script$$26);
          i$$129 = i$$129 + 1;
          v1956 = i$$129 < len$$61;
        }
        return null;
      }
      var _this$$19 = this;
      return this.timeFunction("cleanTypesForReTypeCheck()", v1261);
    }
    function v1260(ast$$122) {
      function cleanASTType(ast$$123, parent$$72) {
        ast$$123.type = null;
        var v12645 = ast$$123.nodeType;
        var v18990 = TypeScript$$32.NodeType;
        var v12646 = v18990.VarDecl;
        var v1964 = v12645 == v12646;
        if (v1964) {
          var vardecl = ast$$123;
          vardecl.sym = null;
        } else {
          var v12647 = ast$$123.nodeType;
          var v18991 = TypeScript$$32.NodeType;
          var v12648 = v18991.ArgDecl;
          var v1963 = v12647 == v12648;
          if (v1963) {
            var argdecl = ast$$123;
            argdecl.sym = null;
          } else {
            var v12649 = ast$$123.nodeType;
            var v18992 = TypeScript$$32.NodeType;
            var v12650 = v18992.Name;
            var v1962 = v12649 == v12650;
            if (v1962) {
              var name$$86 = ast$$123;
              name$$86.sym = null;
            } else {
              var v12651 = ast$$123.nodeType;
              var v18993 = TypeScript$$32.NodeType;
              var v12652 = v18993.FuncDecl;
              var v1961 = v12651 == v12652;
              if (v1961) {
                var funcdecl = ast$$123;
                funcdecl.signature = null;
                var v1957 = funcdecl;
                var v26777 = new Array;
                v1957.freeVariables = v26777;
                funcdecl.symbols = null;
                funcdecl.accessorSymbol = null;
                funcdecl.scopeType = null;
              } else {
                var v12653 = ast$$123.nodeType;
                var v18994 = TypeScript$$32.NodeType;
                var v12654 = v18994.ModuleDeclaration;
                var v1960 = v12653 == v12654;
                if (v1960) {
                  var modDecl$$3 = ast$$123;
                  modDecl$$3.mod = null;
                } else {
                  var v12655 = ast$$123.nodeType;
                  var v18995 = TypeScript$$32.NodeType;
                  var v12656 = v18995.With;
                  var v1959 = v12655 == v12656;
                  if (v1959) {
                    ast$$123.withSym = null;
                  } else {
                    var v12657 = ast$$123.nodeType;
                    var v18996 = TypeScript$$32.NodeType;
                    var v12658 = v18996.Catch;
                    var v1958 = v12657 == v12658;
                    if (v1958) {
                      ast$$123.containedScope = null;
                    }
                  }
                }
              }
            }
          }
        }
        return ast$$123;
      }
      var v1965 = TypeScript$$32.getAstWalkerFactory();
      v1965.walk(ast$$122, cleanASTType);
      return;
    }
    function v1259() {
      function v1258() {
        var v1966 = TypeScript$$32.Binder;
        var v1967 = _this$$18.typeChecker;
        var binder$$1 = new v1966(v1967);
        var v1968 = _this$$18.typeChecker;
        v1968.units = _this$$18.units;
        var v12659 = _this$$18.typeChecker;
        var v1969 = v12659.globalScope;
        var v12660 = _this$$18.typeChecker;
        var v1970 = v12660.globals;
        binder$$1.bind(v1969, v1970);
        var v12661 = _this$$18.typeChecker;
        var v1971 = v12661.globalScope;
        var v12662 = _this$$18.typeChecker;
        var v1972 = v12662.ambientGlobals;
        binder$$1.bind(v1971, v1972);
        var v12663 = _this$$18.typeChecker;
        var v1973 = v12663.globalScope;
        var v12664 = _this$$18.typeChecker;
        var v1974 = v12664.globalTypes;
        binder$$1.bind(v1973, v1974);
        var v12665 = _this$$18.typeChecker;
        var v1975 = v12665.globalScope;
        var v12666 = _this$$18.typeChecker;
        var v1976 = v12666.ambientGlobalTypes;
        binder$$1.bind(v1975, v1976);
        var v1977 = _this$$18;
        var v12667 = TypeScript$$32.TypeFlow;
        var v12668 = _this$$18.logger;
        var v18997 = _this$$18.typeChecker;
        var v12669 = v18997.globalScope;
        var v12670 = _this$$18.parser;
        var v12671 = _this$$18.typeChecker;
        var v26778 = new v12667(v12668, v12669, v12670, v12671);
        v1977.typeFlow = v26778;
        var i$$128 = 0;
        var script$$25 = null;
        var v12672 = _this$$18.scripts;
        var v1978 = v12672.members;
        var len$$60 = v1978.length;
        var v1979 = _this$$18.persistentTypeState;
        var v12673 = TypeScript$$32.TypeCheckCollectionMode;
        var v1980 = v12673.Resident;
        v1979.setCollectionMode(v1980);
        i$$128 = 0;
        var v1985 = i$$128 < len$$60;
        for (;v1985;) {
          var v12674 = _this$$18.scripts;
          var v1981 = v12674.members;
          script$$25 = v1981[i$$128];
          var v18998 = script$$25.isResident;
          var v12675 = !v18998;
          var v18999 = !v12675;
          if (v18999) {
            v12675 = script$$25.hasBeenTypeChecked;
          }
          var v1982 = v12675;
          if (v1982) {
            i$$128 = i$$128 + 1;
            v1985 = i$$128 < len$$60;
            continue;
          }
          var v1983 = _this$$18.typeFlow;
          v1983.assignScopes(script$$25);
          var v1984 = _this$$18.typeFlow;
          v1984.initLibs();
          i$$128 = i$$128 + 1;
          v1985 = i$$128 < len$$60;
        }
        i$$128 = 0;
        var v1989 = i$$128 < len$$60;
        for (;v1989;) {
          var v12676 = _this$$18.scripts;
          var v1986 = v12676.members;
          script$$25 = v1986[i$$128];
          var v19000 = script$$25.isResident;
          var v12677 = !v19000;
          var v19001 = !v12677;
          if (v19001) {
            v12677 = script$$25.hasBeenTypeChecked;
          }
          var v1987 = v12677;
          if (v1987) {
            i$$128 = i$$128 + 1;
            v1989 = i$$128 < len$$60;
            continue;
          }
          var v1988 = _this$$18.typeFlow;
          v1988.typeCheck(script$$25);
          script$$25.hasBeenTypeChecked = true;
          i$$128 = i$$128 + 1;
          v1989 = i$$128 < len$$60;
        }
        var v1990 = _this$$18.persistentTypeState;
        var v12678 = TypeScript$$32.TypeCheckCollectionMode;
        var v1991 = v12678.Transient;
        v1990.setCollectionMode(v1991);
        var v12679 = _this$$18.scripts;
        var v1992 = v12679.members;
        len$$60 = v1992.length;
        i$$128 = 0;
        var v1997 = i$$128 < len$$60;
        for (;v1997;) {
          var v12680 = _this$$18.scripts;
          var v1993 = v12680.members;
          script$$25 = v1993[i$$128];
          var v1994 = script$$25.isResident;
          if (v1994) {
            i$$128 = i$$128 + 1;
            v1997 = i$$128 < len$$60;
            continue;
          }
          var v1995 = _this$$18.typeFlow;
          v1995.assignScopes(script$$25);
          var v1996 = _this$$18.typeFlow;
          v1996.initLibs();
          i$$128 = i$$128 + 1;
          v1997 = i$$128 < len$$60;
        }
        i$$128 = 0;
        var v2001 = i$$128 < len$$60;
        for (;v2001;) {
          var v12681 = _this$$18.scripts;
          var v1998 = v12681.members;
          script$$25 = v1998[i$$128];
          var v1999 = script$$25.isResident;
          if (v1999) {
            i$$128 = i$$128 + 1;
            v2001 = i$$128 < len$$60;
            continue;
          }
          var v2000 = _this$$18.typeFlow;
          v2000.typeCheck(script$$25);
          i$$128 = i$$128 + 1;
          v2001 = i$$128 < len$$60;
        }
        return null;
      }
      var _this$$18 = this;
      return this.timeFunction("typeCheck()", v1258);
    }
    function v1257(sourceText$$9, filename$$9) {
      var v2002 = this.parser;
      var v2003 = this.errorOutput;
      v2002.setErrorRecovery(v2003);
      var v2004 = this.parser;
      var script$$24 = v2004.parse(sourceText$$9, filename$$9, 0);
      var v2005 = this.units;
      var index$$64 = v2005.length;
      var v2006 = this.units;
      v2006[index$$64] = script$$24.locationInfo;
      var v2007 = this.typeChecker;
      v2007.collectTypes(script$$24);
      var v2008 = this.scripts;
      v2008.append(script$$24);
      return;
    }
    function v1256(prog$$2, filename$$8) {
      var v12682 = TypeScript$$32.StringSourceText;
      var v2009 = new v12682(prog$$2);
      return this.parseSourceUnit(v2009, filename$$8);
    }
    function v1255(sourceText$$8, filename$$7, keepResident$$1, referencedFiles$$2) {
      function v1254() {
        var v2010 = _this$$17.parser;
        var v12683 = _this$$17.units;
        var v2011 = v12683.length;
        var v12684 = TypeScript$$32.AllowedElements;
        var v2012 = v12684.Global;
        var script$$23 = v2010.parse(sourceText$$8, filename$$7, v2011, v2012);
        script$$23.referencedFiles = referencedFiles$$2;
        script$$23.isResident = keepResident$$1;
        var v2013 = _this$$17.persistentTypeState;
        var v12685;
        if (keepResident$$1) {
          var v19002 = TypeScript$$32.TypeCheckCollectionMode;
          v12685 = v19002.Resident;
        } else {
          var v19003 = TypeScript$$32.TypeCheckCollectionMode;
          v12685 = v19003.Transient;
        }
        var v2014 = v12685;
        v2013.setCollectionMode(v2014);
        var v2015 = _this$$17.units;
        var index$$63 = v2015.length;
        var v2016 = _this$$17.units;
        v2016[index$$63] = script$$23.locationInfo;
        var v2017 = _this$$17.typeChecker;
        v2017.collectTypes(script$$23);
        var v2018 = _this$$17.scripts;
        v2018.append(script$$23);
        return script$$23;
      }
      var v12686 = typeof referencedFiles$$2;
      var v2019 = v12686 === "undefined";
      if (v2019) {
        referencedFiles$$2 = [];
      }
      var _this$$17 = this;
      var v23124 = "addSourceUnit(" + filename$$7;
      var v19004 = v23124 + ", ";
      var v12687 = v19004 + keepResident$$1;
      var v2020 = v12687 + ")";
      return this.timeFunction(v2020, v1254);
    }
    function v1253(prog$$1, filename$$6, keepResident, referencedFiles$$1) {
      var v12688 = typeof keepResident;
      var v2021 = v12688 === "undefined";
      if (v2021) {
        keepResident = false;
      }
      var v12689 = typeof referencedFiles$$1;
      var v2022 = v12689 === "undefined";
      if (v2022) {
        referencedFiles$$1 = [];
      }
      var v12690 = TypeScript$$32.StringSourceText;
      var v2023 = new v12690(prog$$1);
      return this.addSourceUnit(v2023, filename$$6, keepResident, referencedFiles$$1);
    }
    function v1252(sourceText$$7, filename$$5, setRecovery$$2) {
      function v1251() {
        function v1250(minChar$$36, charLen$$1, message$$21, unitIndex$$14) {
          var v12691 = minChar$$36 + charLen$$1;
          var v2024 = new ErrorEntry(unitIndex$$14, minChar$$36, v12691, message$$21);
          parseErrors$$4.push(v2024);
          return;
        }
        var i$$127 = 0;
        var v2025 = _this$$16.units;
        var len$$59 = v2025.length;
        var v2034 = i$$127 < len$$59;
        for (;v2034;) {
          var v23125 = _this$$16.units;
          var v19005 = v23125[i$$127];
          var v12692 = v19005.filename;
          var v2033 = v12692 == filename$$5;
          if (v2033) {
            var v23126 = _this$$16.scripts;
            var v19006 = v23126.members;
            var v12693 = v19006[i$$127];
            var v2026 = v12693.isResident;
            if (v2026) {
              return UpdateUnitResult.noEdits(i$$127);
            }
            if (setRecovery$$2) {
              var v2027 = _this$$16.parser;
              v2027.setErrorRecovery(null);
            }
            var updateResult$$3;
            var parseErrors$$4 = [];
            var errorCapture$$2 = v1250;
            var v2028 = _this$$16.parser;
            var svErrorCallback = v2028.errorCallback;
            if (svErrorCallback) {
              var v2029 = _this$$16.parser;
              v2029.errorCallback = errorCapture$$2;
            }
            var v12694 = _this$$16.scripts;
            var v2030 = v12694.members;
            var oldScript = v2030[i$$127];
            var v2031 = _this$$16.parser;
            var newScript = v2031.parse(sourceText$$7, filename$$5, i$$127);
            if (svErrorCallback) {
              var v2032 = _this$$16.parser;
              v2032.errorCallback = svErrorCallback;
            }
            updateResult$$3 = UpdateUnitResult.unknownEdits(oldScript, newScript, parseErrors$$4);
            return updateResult$$3;
          }
          i$$127 = i$$127 + 1;
          v2034 = i$$127 < len$$59;
        }
        var v12695 = 'Unknown file "' + filename$$5;
        var v2035 = v12695 + '"';
        throw new Error(v2035);
      }
      var _this$$16 = this;
      var v12696 = "partialUpdateUnit(" + filename$$5;
      var v2036 = v12696 + ")";
      return this.timeFunction(v2036, v1251);
    }
    function v1249(updateResult$$2) {
      var v2051 = updateResult$$2.kind;
      switch(v2051) {
        case UpdateUnitKind.NoEdits:
          return false;
        case UpdateUnitKind.Unknown:
          var v12697 = this.scripts;
          var v2037 = v12697.members;
          var v2038 = updateResult$$2.unitIndex;
          v2037[v2038] = updateResult$$2.script2;
          var v2039 = this.units;
          var v2040 = updateResult$$2.unitIndex;
          var v12698 = updateResult$$2.script2;
          v2039[v2040] = v12698.locationInfo;
          var i$$126 = 0;
          var v2041 = updateResult$$2.parseErrors;
          var len$$58 = v2041.length;
          var v2049 = i$$126 < len$$58;
          for (;v2049;) {
            var v2042 = updateResult$$2.parseErrors;
            var e$$10 = v2042[i$$126];
            var v12699 = this.parser;
            var v2048 = v12699.errorCallback;
            if (v2048) {
              var v2043 = this.parser;
              var v2044 = e$$10.minChar;
              var v12700 = e$$10.limChar;
              var v12701 = e$$10.minChar;
              var v2045 = v12700 - v12701;
              var v2046 = e$$10.message;
              var v2047 = e$$10.unitIndex;
              v2043.errorCallback(v2044, v2045, v2046, v2047);
            }
            i$$126 = i$$126 + 1;
            v2049 = i$$126 < len$$58;
          }
          return true;
        case UpdateUnitKind.EditsInsideSingleScope:
          var v12702 = TypeScript$$32.IncrementalParser;
          var v12703 = this.logger;
          var v2050 = new v12702(v12703);
          v2050.mergeTrees(updateResult$$2);
          return true;
      }
      return;
    }
    function v1248(sourceText$$6, filename$$4, setRecovery$$1) {
      function v1247() {
        var updateResult$$1 = _this$$15.partialUpdateUnit(sourceText$$6, filename$$4, setRecovery$$1);
        return _this$$15.applyUpdateResult(updateResult$$1);
      }
      var _this$$15 = this;
      var v12704 = "updateSourceUnit(" + filename$$4;
      var v2052 = v12704 + ")";
      return this.timeFunction(v2052, v1247);
    }
    function v1246(prog, filename$$3, setRecovery) {
      var v12705 = TypeScript$$32.StringSourceText;
      var v2053 = new v12705(prog);
      return this.updateSourceUnit(v2053, filename$$3, setRecovery);
    }
    function v1245(fn$$10) {
      var v2054 = this.parser;
      v2054.errorCallback = fn$$10;
      return;
    }
    function v1244() {
      var v2055 = TypeScript$$32.EmitOptions;
      var v2056 = this.settings;
      var v26779 = new v2055(v2056);
      this.emitSettings = v26779;
      return;
    }
    function v1243(outerr$$2) {
      this.errorOutput = outerr$$2;
      var v2057 = this.errorReporter;
      v2057.setErrOut(outerr$$2);
      var v2058 = this.parser;
      v2058.outfile = outerr$$2;
      return;
    }
    function v1242(errorOutput$$1) {
      var v2059 = this.persistentTypeState;
      v2059.refreshPersistentState();
      var v2060 = TypeScript$$32.TypeChecker;
      var v2061 = this.persistentTypeState;
      var v26780 = new v2060(v2061);
      this.typeChecker = v26780;
      var v2062 = this.typeChecker;
      v2062.errorReporter = this.errorReporter;
      var v2063 = this.typeChecker;
      var v12706 = this.settings;
      v2063.checkControlFlow = v12706.controlFlow;
      var v2064 = this.typeChecker;
      var v12707 = this.settings;
      v2064.checkControlFlowUseDef = v12707.controlFlowUseDef;
      var v2065 = this.typeChecker;
      var v12708 = this.settings;
      v2065.printControlFlowGraph = v12708.printControlFlow;
      var v2066 = this.typeChecker;
      var v12709 = this.settings;
      v2066.errorsOnWith = v12709.errorOnWith;
      var v2067 = this.typeChecker;
      var v12710 = this.settings;
      v2067.styleSettings = v12710.styleSettings;
      var v2068 = this.typeChecker;
      var v12711 = this.settings;
      v2068.canCallDefinitionSignature = v12711.canCallDefinitionSignature;
      var v2069 = this.errorReporter;
      v2069.checker = this.typeChecker;
      var v2070 = this.errorOutput;
      this.setErrorOutput(v2070);
      return;
    }
    function v1241(funcDescription, func$$4) {
      var v2071 = this.logger;
      return TypeScript$$32.timeFunction(v2071, funcDescription, func$$4);
    }
    function TypeScriptCompiler$$1(errorOutput, logger$$6, settings$$4) {
      var v12712 = typeof logger$$6;
      var v2073 = v12712 === "undefined";
      if (v2073) {
        var v2072 = TypeScript$$32.NullLogger;
        logger$$6 = new v2072;
      }
      var v12713 = typeof settings$$4;
      var v2074 = v12713 === "undefined";
      if (v2074) {
        settings$$4 = TypeScript$$32.defaultSettings;
      }
      this.errorOutput = errorOutput;
      this.logger = logger$$6;
      this.settings = settings$$4;
      var v2075 = TypeScript$$32.Parser;
      var v26781 = new v2075;
      this.parser = v26781;
      this.typeFlow = null;
      var v2076 = TypeScript$$32.ASTList;
      var v26782 = new v2076;
      this.scripts = v26782;
      var v26783 = new Array;
      this.units = v26783;
      var v2077 = TypeScript$$32.ErrorReporter;
      var v2078 = this.errorOutput;
      var v26784 = new v2077(v2078);
      this.errorReporter = v26784;
      var v2079 = TypeScript$$32.PersistentGlobalTypeState;
      var v2080 = this.errorReporter;
      var v26785 = new v2079(v2080);
      this.persistentTypeState = v26785;
      var v2081 = this.errorReporter;
      v2081.parser = this.parser;
      var v2082 = this.errorOutput;
      this.initTypeChecker(v2082);
      var v2083 = this.parser;
      var v19007 = this.settings;
      var v12714 = v19007.styleSettings;
      v2083.style_requireSemi = v12714.requireSemi;
      var v2084 = this.parser;
      var v19008 = this.settings;
      var v12715 = v19008.styleSettings;
      v2084.style_funcInLoop = v12715.funcInLoop;
      var v2085 = this.parser;
      var v12716 = this.settings;
      v2085.inferPropertiesFromThisAssignment = v12716.inferPropertiesFromThisAssignment;
      var v2086 = TypeScript$$32.EmitOptions;
      var v2087 = this.settings;
      var v26786 = new v2086(v2087);
      this.emitSettings = v26786;
      TypeScript$$32.codeGenTarget = settings$$4.codeGenTarget;
      return;
    }
    var v2088 = TypeScriptCompiler$$1.prototype;
    v2088.timeFunction = v1241;
    var v2089 = TypeScriptCompiler$$1.prototype;
    v2089.initTypeChecker = v1242;
    var v2090 = TypeScriptCompiler$$1.prototype;
    v2090.setErrorOutput = v1243;
    var v2091 = TypeScriptCompiler$$1.prototype;
    v2091.emitCommentsToOutput = v1244;
    var v2092 = TypeScriptCompiler$$1.prototype;
    v2092.setErrorCallback = v1245;
    var v2093 = TypeScriptCompiler$$1.prototype;
    v2093.updateUnit = v1246;
    var v2094 = TypeScriptCompiler$$1.prototype;
    v2094.updateSourceUnit = v1248;
    var v2095 = TypeScriptCompiler$$1.prototype;
    v2095.applyUpdateResult = v1249;
    var v2096 = TypeScriptCompiler$$1.prototype;
    v2096.partialUpdateUnit = v1252;
    var v2097 = TypeScriptCompiler$$1.prototype;
    v2097.addUnit = v1253;
    var v2098 = TypeScriptCompiler$$1.prototype;
    v2098.addSourceUnit = v1255;
    var v2099 = TypeScriptCompiler$$1.prototype;
    v2099.parseUnit = v1256;
    var v2100 = TypeScriptCompiler$$1.prototype;
    v2100.parseSourceUnit = v1257;
    var v2101 = TypeScriptCompiler$$1.prototype;
    v2101.typeCheck = v1259;
    var v2102 = TypeScriptCompiler$$1.prototype;
    v2102.cleanASTTypesForReTypeCheck = v1260;
    var v2103 = TypeScriptCompiler$$1.prototype;
    v2103.cleanTypesForReTypeCheck = v1262;
    var v2104 = TypeScriptCompiler$$1.prototype;
    v2104.attemptIncrementalTypeCheck = v1264;
    var v2105 = TypeScriptCompiler$$1.prototype;
    v2105.reTypeCheck = v1266;
    var v2106 = TypeScriptCompiler$$1.prototype;
    v2106.isDynamicModuleCompilation = v1267;
    var v2107 = TypeScriptCompiler$$1.prototype;
    v2107.updateCommonDirectoryPath = v1268;
    var v2108 = TypeScriptCompiler$$1.prototype;
    v2108.parseEmitOption = v1269;
    var v2109 = TypeScriptCompiler$$1.prototype;
    v2109.useUTF8ForFile = v1270;
    TypeScriptCompiler$$1.mapToDTSFileName = mapToDTSFileName;
    var v2110 = TypeScriptCompiler$$1.prototype;
    v2110.canEmitDeclarations = v1271;
    var v2111 = TypeScriptCompiler$$1.prototype;
    v2111.emitDeclarationsUnit = v1272;
    var v2112 = TypeScriptCompiler$$1.prototype;
    v2112.emitDeclarations = v1273;
    TypeScriptCompiler$$1.mapToFileNameExtension = mapToFileNameExtension;
    TypeScriptCompiler$$1.mapToJSFileName = mapToJSFileName;
    var v2113 = TypeScriptCompiler$$1.prototype;
    v2113.emitUnit = v1274;
    var v2114 = TypeScriptCompiler$$1.prototype;
    v2114.emit = v1275;
    var v2115 = TypeScriptCompiler$$1.prototype;
    v2115.emitToOutfile = v1276;
    var v2116 = TypeScriptCompiler$$1.prototype;
    v2116.emitAST = v1278;
    var v2117 = TypeScriptCompiler$$1.prototype;
    v2117.outputScriptToUTF8 = v1279;
    var v2118 = TypeScriptCompiler$$1.prototype;
    v2118.outputScriptsToUTF8 = v1280;
    var v2119 = TypeScriptCompiler$$1.prototype;
    v2119.createFile = v1281;
    return TypeScriptCompiler$$1;
  }
  function v1240() {
    function ErrorEntry$$1(unitIndex$$13, minChar$$35, limChar$$13, message$$20) {
      this.unitIndex = unitIndex$$13;
      this.minChar = minChar$$35;
      this.limChar = limChar$$13;
      this.message = message$$20;
      return;
    }
    return ErrorEntry$$1;
  }
  function v1239() {
    function singleScopeEdits(script1$$2, script2$$2, scope1$$2, scope2$$1, editRange$$4, parseErrors$$3) {
      var v2120 = UpdateUnitKind.EditsInsideSingleScope;
      var v12717 = script1$$2.locationInfo;
      var v2121 = v12717.unitIndex;
      var result$$36 = new UpdateUnitResult$$1(v2120, v2121, script1$$2, script2$$2);
      result$$36.scope1 = scope1$$2;
      result$$36.scope2 = scope2$$1;
      result$$36.editRange = editRange$$4;
      result$$36.parseErrors = parseErrors$$3;
      return result$$36;
    }
    function unknownEdits(script1$$1, script2$$1, parseErrors$$2) {
      var v2122 = UpdateUnitKind.Unknown;
      var v12718 = script1$$1.locationInfo;
      var v2123 = v12718.unitIndex;
      var result$$35 = new UpdateUnitResult$$1(v2122, v2123, script1$$1, script2$$1);
      result$$35.parseErrors = parseErrors$$2;
      return result$$35;
    }
    function noEdits(unitIndex$$12) {
      var v2124 = UpdateUnitKind.NoEdits;
      return new UpdateUnitResult$$1(v2124, unitIndex$$12, null, null);
    }
    function UpdateUnitResult$$1(kind, unitIndex$$11, script1, script2) {
      this.kind = kind;
      this.unitIndex = unitIndex$$11;
      this.script1 = script1;
      this.script2 = script2;
      this.scope1 = null;
      this.scope2 = null;
      this.editRange = null;
      this.parseErrors = [];
      return;
    }
    UpdateUnitResult$$1.noEdits = noEdits;
    UpdateUnitResult$$1.unknownEdits = unknownEdits;
    UpdateUnitResult$$1.singleScopeEdits = singleScopeEdits;
    return UpdateUnitResult$$1;
  }
  function v1238() {
    function v1237() {
      var v26024 = this.minChar;
      var v25153 = "editRange(minChar=" + v26024;
      var v23127 = v25153 + ", limChar=";
      var v23128 = this.limChar;
      var v19009 = v23127 + v23128;
      var v12719 = v19009 + ", delta=";
      var v12720 = this.delta;
      var v2125 = v12719 + v12720;
      return v2125 + ")";
    }
    function v1236(pos$$8) {
      var v19010 = this.minChar;
      var v12721 = v19010 <= pos$$8;
      if (v12721) {
        var v19011 = this.limChar;
        v12721 = pos$$8 < v19011;
      }
      var v2126 = v12721;
      var v12723 = !v2126;
      if (v12723) {
        var v19012 = this.minChar;
        var v12722 = v19012 <= pos$$8;
        if (v12722) {
          var v23129 = this.limChar;
          var v23130 = this.delta;
          var v19013 = v23129 + v23130;
          v12722 = pos$$8 < v19013;
        }
        v2126 = v12722;
      }
      return v2126;
    }
    function v1235() {
      var v19014 = this.minChar;
      var v12724 = v19014 === -1;
      if (v12724) {
        var v19015 = this.limChar;
        v12724 = v19015 === -1;
      }
      var v2127 = v12724;
      if (v2127) {
        var v12725 = this.delta;
        v2127 = v12725 === -1;
      }
      return v2127;
    }
    function unknown() {
      return new ScriptEditRange$$1(-1, -1, -1);
    }
    function ScriptEditRange$$1(minChar$$34, limChar$$12, delta$$2) {
      this.minChar = minChar$$34;
      this.limChar = limChar$$12;
      this.delta = delta$$2;
      return;
    }
    ScriptEditRange$$1.unknown = unknown;
    var v2128 = ScriptEditRange$$1.prototype;
    v2128.isUnknown = v1235;
    var v2129 = ScriptEditRange$$1.prototype;
    v2129.containsPosition = v1236;
    var v2130 = ScriptEditRange$$1.prototype;
    v2130.toString = v1237;
    return ScriptEditRange$$1;
  }
  function v1234(UpdateUnitKind$$1) {
    UpdateUnitKind$$1._map = [];
    var v2131 = UpdateUnitKind$$1._map;
    v2131[0] = "Unknown";
    UpdateUnitKind$$1.Unknown = 0;
    var v2132 = UpdateUnitKind$$1._map;
    v2132[1] = "NoEdits";
    UpdateUnitKind$$1.NoEdits = 1;
    var v2133 = UpdateUnitKind$$1._map;
    v2133[2] = "EditsInsideSingleScope";
    UpdateUnitKind$$1.EditsInsideSingleScope = 2;
    return;
  }
  var v12726 = TypeScript$$32.UpdateUnitKind;
  var v19016 = !v12726;
  if (v19016) {
    v12726 = TypeScript$$32.UpdateUnitKind = {};
  }
  var v2134 = v12726;
  v1234(v2134);
  var UpdateUnitKind = TypeScript$$32.UpdateUnitKind;
  var ScriptEditRange = v1238();
  TypeScript$$32.ScriptEditRange = ScriptEditRange;
  var UpdateUnitResult = v1239();
  TypeScript$$32.UpdateUnitResult = UpdateUnitResult;
  var ErrorEntry = v1240();
  TypeScript$$32.ErrorEntry = ErrorEntry;
  var v2135 = TypeScript$$32;
  var v12727 = TypeScript$$32.CompilationSettings;
  var v26787 = new v12727;
  v2135.defaultSettings = v26787;
  var TypeScriptCompiler = v1282();
  TypeScript$$32.TypeScriptCompiler = TypeScriptCompiler;
  var ScopeEntry = v1283();
  TypeScript$$32.ScopeEntry = ScopeEntry;
  var ScopeTraversal = v1287();
  TypeScript$$32.ScopeTraversal = ScopeTraversal;
  return;
}
function v1233(TypeScript$$31) {
  function v1232() {
    function v1231(pre$$21, ast$$121) {
      var v12728 = ast$$121.flags;
      var v19017 = TypeScript$$31.ASTFlags;
      var v12729 = v19017.IsStatement;
      var v2136 = TypeScript$$31.hasFlag(v12728, v12729);
      return!v2136;
    }
    function v1230(pre$$20, script$$22) {
      if (pre$$20) {
        var v12730 = this.emitOptions;
        var v2145 = v12730.outputMany;
        if (v2145) {
          var i$$125 = 0;
          var v19018 = script$$22.referencedFiles;
          var v12731 = v19018.length;
          var v2144 = i$$125 < v12731;
          for (;v2144;) {
            var v12732 = script$$22.referencedFiles;
            var v2137 = v12732[i$$125];
            var referencePath$$1 = v2137.path;
            var declareFileName$$1;
            var v2141 = TypeScript$$31.isRooted(referencePath$$1);
            if (v2141) {
              var v2138 = this.emitOptions;
              var v12733 = TypeScript$$31.TypeScriptCompiler;
              var v2139 = v12733.mapToDTSFileName;
              declareFileName$$1 = v2138.mapOutputFileName(referencePath$$1, v2139);
            } else {
              var v19019 = script$$22.referencedFiles;
              var v12734 = v19019[i$$125];
              var v2140 = v12734.path;
              declareFileName$$1 = TypeScript$$31.getDeclareFilePath(v2140);
            }
            var v2142 = this.declFile;
            var v12735 = '/// <reference path="' + declareFileName$$1;
            var v2143 = v12735 + '" />';
            v2142.WriteLine(v2143);
            i$$125 = i$$125 + 1;
            var v19020 = script$$22.referencedFiles;
            var v12736 = v19020.length;
            v2144 = i$$125 < v12736;
          }
        }
        this.pushDeclarationContainer(script$$22);
      } else {
        this.popDeclarationContainer(script$$22);
      }
      return true;
    }
    function v1229(pre$$19, moduleDecl$$9) {
      var v12737 = moduleDecl$$9.modFlags;
      var v19021 = TypeScript$$31.ModuleFlags;
      var v12738 = v19021.IsWholeFile;
      var v2165 = TypeScript$$31.hasFlag(v12737, v12738);
      if (v2165) {
        var v12739 = moduleDecl$$9.modFlags;
        var v19022 = TypeScript$$31.ModuleFlags;
        var v12740 = v19022.IsDynamic;
        var v2164 = TypeScript$$31.hasFlag(v12739, v12740);
        if (v2164) {
          if (pre$$19) {
            var v19023 = this.emitOptions;
            var v12741 = v19023.outputMany;
            var v2155 = !v12741;
            if (v2155) {
              this.singleDeclFile = this.declFile;
              var v2146 = TypeScript$$31.CompilerDiagnostics;
              var v19024 = this.indenter;
              var v12742 = v19024.indentAmt;
              var v2147 = v12742 == 0;
              v2146.assert(v2147, "Indent has to be 0 when outputing new file");
              var v2148 = this.emitOptions;
              var v23131 = moduleDecl$$9.name;
              var v19025 = v23131.sym;
              var v12743 = v19025.name;
              var v2149 = TypeScript$$31.stripQuotes(v12743);
              var v12744 = TypeScript$$31.TypeScriptCompiler;
              var v2150 = v12744.mapToDTSFileName;
              var declareFileName = v2148.mapOutputFileName(v2149, v2150);
              var v2151 = moduleDecl$$9.containsUnicodeChar;
              var v12746 = !v2151;
              if (v12746) {
                var v19026 = this.emitOptions;
                var v12745 = v19026.emitComments;
                if (v12745) {
                  v12745 = moduleDecl$$9.containsUnicodeCharInComment;
                }
                v2151 = v12745;
              }
              var useUTF8InOutputfile$$1 = v2151;
              try {
                var v19027 = this.emitOptions;
                var v12747 = v19027.ioHost;
                var v2152 = v12747.createFile(declareFileName, useUTF8InOutputfile$$1);
                var v26788 = new DeclFileWriter(v2152);
                this.declFile = v26788;
              } catch (ex$$4) {
                var v2153 = this.errorReporter;
                var v2154 = ex$$4.message;
                v2153.emitterError(null, v2154);
              }
            }
            this.pushDeclarationContainer(moduleDecl$$9);
          } else {
            var v19028 = this.emitOptions;
            var v12748 = v19028.outputMany;
            var v2163 = !v12748;
            if (v2163) {
              var v2156 = TypeScript$$31.CompilerDiagnostics;
              var v12749 = this.singleDeclFile;
              var v12750 = this.declFile;
              var v2157 = v12749 != v12750;
              v2156.assert(v2157, "singleDeclFile cannot be null as we are going to revert back to it");
              var v2158 = TypeScript$$31.CompilerDiagnostics;
              var v19029 = this.indenter;
              var v12751 = v19029.indentAmt;
              var v2159 = v12751 == 0;
              v2158.assert(v2159, "Indent has to be 0 when outputing new file");
              try {
                var v2160 = this.declFile;
                v2160.Close();
              } catch (ex$$5) {
                var v2161 = this.errorReporter;
                var v2162 = ex$$5.message;
                v2161.emitterError(null, v2162);
              }
              this.declFile = this.singleDeclFile;
            }
            this.popDeclarationContainer(moduleDecl$$9);
          }
        }
        return true;
      }
      var v2166 = moduleDecl$$9.isEnum();
      if (v2166) {
        if (pre$$19) {
          this.emitEnumSignature(moduleDecl$$9);
        }
        return false;
      }
      var v23132 = moduleDecl$$9.modFlags;
      var v19030 = TypeScript$$31.ToDeclFlags(v23132);
      var v12752 = this.canEmitPrePostAstSignature(v19030, moduleDecl$$9, pre$$19);
      var v2167 = !v12752;
      if (v2167) {
        return false;
      }
      if (pre$$19) {
        var v2169 = this.emitDottedModuleName();
        if (v2169) {
          var v12753 = this.dottedModuleEmit;
          this.dottedModuleEmit = v12753 + ".";
        } else {
          var v12754 = moduleDecl$$9.modFlags;
          var v2168 = TypeScript$$31.ToDeclFlags(v12754);
          var v26789 = this.getDeclFlagsString(v2168, "module");
          this.dottedModuleEmit = v26789;
        }
        var v12755 = this.dottedModuleEmit;
        var v19031 = moduleDecl$$9.name;
        var v12756 = v19031.text;
        this.dottedModuleEmit = v12755 + v12756;
        var v26025 = moduleDecl$$9.members;
        var v25154 = v26025.members;
        var v23133 = v25154.length;
        var v19032 = v23133 == 1;
        if (v19032) {
          var v26412 = moduleDecl$$9.members;
          var v26026 = v26412.members;
          var v25155 = v26026[0];
          var v23134 = v25155.nodeType;
          var v25156 = TypeScript$$31.NodeType;
          var v23135 = v25156.ModuleDeclaration;
          v19032 = v23134 == v23135;
        }
        var v12757 = v19032;
        if (v12757) {
          var v26027 = moduleDecl$$9.members;
          var v25157 = v26027.members;
          var v23136 = v25157[0];
          var v19033 = v23136.isEnum();
          v12757 = !v19033;
        }
        var v2170 = v12757;
        if (v2170) {
          var v25158 = moduleDecl$$9.members;
          var v23137 = v25158.members;
          var v19034 = v23137[0];
          var v12758 = v19034.modFlags;
          var v19035 = TypeScript$$31.ModuleFlags;
          var v12759 = v19035.Exported;
          v2170 = TypeScript$$31.hasFlag(v12758, v12759);
        }
        var isCurrentModuleDotted = v2170;
        var moduleDeclComments = moduleDecl$$9.getDocComments();
        var v2171 = isCurrentModuleDotted;
        if (v2171) {
          var v12760 = moduleDeclComments == null;
          var v19037 = !v12760;
          if (v19037) {
            var v19036 = moduleDeclComments.length;
            v12760 = v19036 == 0;
          }
          v2171 = v12760;
        }
        isCurrentModuleDotted = v2171;
        var v2172 = this.isDottedModuleName;
        v2172.push(isCurrentModuleDotted);
        this.pushDeclarationContainer(moduleDecl$$9);
        var v2177 = !isCurrentModuleDotted;
        if (v2177) {
          this.emitDeclarationComments(moduleDecl$$9);
          var v2173 = this.declFile;
          var v2174 = this.dottedModuleEmit;
          v2173.Write(v2174);
          var v2175 = this.declFile;
          v2175.WriteLine(" {");
          var v2176 = this.indenter;
          v2176.increaseIndent();
        }
      } else {
        var v12761 = this.emitDottedModuleName();
        var v2180 = !v12761;
        if (v2180) {
          var v2178 = this.indenter;
          v2178.decreaseIndent();
          this.emitIndent();
          var v2179 = this.declFile;
          v2179.WriteLine("}");
        }
        this.popDeclarationContainer(moduleDecl$$9);
        var v2181 = this.isDottedModuleName;
        v2181.pop();
      }
      return true;
    }
    function v1228(moduleDecl$$8) {
      var v23138 = moduleDecl$$8.modFlags;
      var v19038 = TypeScript$$31.ToDeclFlags(v23138);
      var v12762 = this.canEmitSignature(v19038);
      var v2182 = !v12762;
      if (v2182) {
        return false;
      }
      this.emitDeclarationComments(moduleDecl$$8);
      var v12763 = moduleDecl$$8.modFlags;
      var v2183 = TypeScript$$31.ToDeclFlags(v12763);
      this.emitDeclFlags(v2183, "enum");
      var v2184 = this.declFile;
      var v19039 = moduleDecl$$8.name;
      var v12764 = v19039.text;
      var v2185 = v12764 + " {";
      v2184.WriteLine(v2185);
      var v2186 = this.indenter;
      v2186.increaseIndent();
      var v12765 = moduleDecl$$8.members;
      var v2187 = v12765.members;
      var membersLen$$1 = v2187.length;
      var j$$19 = 1;
      var v2194 = j$$19 < membersLen$$1;
      for (;v2194;) {
        var v12766 = moduleDecl$$8.members;
        var v2188 = v12766.members;
        var memberDecl$$1 = v2188[j$$19];
        var v12767 = memberDecl$$1.nodeType;
        var v19040 = TypeScript$$31.NodeType;
        var v12768 = v19040.VarDecl;
        var v2193 = v12767 == v12768;
        if (v2193) {
          this.emitDeclarationComments(memberDecl$$1);
          this.emitIndent();
          var v2189 = this.declFile;
          var v19041 = memberDecl$$1.id;
          var v12769 = v19041.text;
          var v2190 = v12769 + ",";
          v2189.WriteLine(v2190);
        } else {
          var v2191 = TypeScript$$31.CompilerDiagnostics;
          var v12770 = memberDecl$$1.nodeType;
          var v19042 = TypeScript$$31.NodeType;
          var v12771 = v19042.Asg;
          var v2192 = v12770 != v12771;
          v2191.assert(v2192, "We want to catch this");
        }
        j$$19 = j$$19 + 1;
        v2194 = j$$19 < membersLen$$1;
      }
      var v2195 = this.indenter;
      v2195.decreaseIndent();
      this.emitIndent();
      var v2196 = this.declFile;
      v2196.WriteLine("}");
      return false;
    }
    function v1227(pre$$18, importDecl$$3) {
      if (pre$$18) {
        var v19043 = this.declarationContainerStack;
        var v12772 = v19043[0];
        var v19044 = importDecl$$3.id;
        var v12773 = v19044.sym;
        var v2205 = v12772.isExternallyVisibleSymbol(v12773);
        if (v2205) {
          this.emitDeclarationComments(importDecl$$3);
          this.emitIndent();
          var v2197 = this.declFile;
          v2197.Write("import ");
          var v2198 = this.declFile;
          var v19045 = importDecl$$3.id;
          var v12774 = v19045.text;
          var v2199 = v12774 + " = ";
          v2198.Write(v2199);
          var v2204 = importDecl$$3.isDynamicImport;
          if (v2204) {
            var v2200 = this.declFile;
            var v19046 = importDecl$$3.getAliasName();
            var v12775 = "module (" + v19046;
            var v2201 = v12775 + ");";
            v2200.WriteLine(v2201);
          } else {
            var v2202 = this.declFile;
            var v12776 = importDecl$$3.getAliasName();
            var v2203 = v12776 + ";";
            v2202.WriteLine(v2203);
          }
        }
      }
      return false;
    }
    function v1226(pre$$17, interfaceDecl$$7) {
      var v23139 = interfaceDecl$$7.varFlags;
      var v19047 = TypeScript$$31.ToDeclFlags(v23139);
      var v12777 = this.canEmitPrePostAstSignature(v19047, interfaceDecl$$7, pre$$17);
      var v2206 = !v12777;
      if (v2206) {
        return false;
      }
      if (pre$$17) {
        var v2207 = interfaceDecl$$7.name;
        var interfaceName$$1 = v2207.text;
        this.emitDeclarationComments(interfaceDecl$$7);
        var v12778 = interfaceDecl$$7.varFlags;
        var v2208 = TypeScript$$31.ToDeclFlags(v12778);
        this.emitDeclFlags(v2208, "interface");
        var v2209 = this.declFile;
        v2209.Write(interfaceName$$1);
        var v2210 = interfaceDecl$$7.extendsList;
        this.emitBaseList(v2210, "extends");
        var v2211 = this.declFile;
        v2211.WriteLine(" {");
        var v2212 = this.indenter;
        v2212.increaseIndent();
        this.pushDeclarationContainer(interfaceDecl$$7);
      } else {
        var v2213 = this.indenter;
        v2213.decreaseIndent();
        this.popDeclarationContainer(interfaceDecl$$7);
        this.emitIndent();
        var v2214 = this.declFile;
        v2214.WriteLine("}");
      }
      return true;
    }
    function v1225(pre$$16, classDecl$$10) {
      var v23140 = classDecl$$10.varFlags;
      var v19048 = TypeScript$$31.ToDeclFlags(v23140);
      var v12779 = this.canEmitPrePostAstSignature(v19048, classDecl$$10, pre$$16);
      var v2215 = !v12779;
      if (v2215) {
        return false;
      }
      if (pre$$16) {
        var v2216 = classDecl$$10.name;
        var className$$5 = v2216.text;
        this.emitDeclarationComments(classDecl$$10);
        var v12780 = classDecl$$10.varFlags;
        var v2217 = TypeScript$$31.ToDeclFlags(v12780);
        this.emitDeclFlags(v2217, "class");
        var v2218 = this.declFile;
        v2218.Write(className$$5);
        var v2219 = classDecl$$10.extendsList;
        this.emitBaseList(v2219, "extends");
        var v2220 = classDecl$$10.implementsList;
        this.emitBaseList(v2220, "implements");
        var v2221 = this.declFile;
        v2221.WriteLine(" {");
        this.pushDeclarationContainer(classDecl$$10);
        var v2222 = this.indenter;
        v2222.increaseIndent();
        var v2224 = classDecl$$10.constructorDecl;
        if (v2224) {
          var v2223 = classDecl$$10.constructorDecl;
          this.emitClassMembersFromConstructorDefinition(v2223);
        }
      } else {
        var v2225 = this.indenter;
        v2225.decreaseIndent();
        this.popDeclarationContainer(classDecl$$10);
        this.emitIndent();
        var v2226 = this.declFile;
        v2226.WriteLine("}");
      }
      return true;
    }
    function v1224(funcDecl$$37) {
      var v2239 = funcDecl$$37.arguments;
      if (v2239) {
        var v12781 = funcDecl$$37.arguments;
        var v2227 = v12781.members;
        var argsLen$$3 = v2227.length;
        var v2228 = funcDecl$$37.variableArgList;
        if (v2228) {
          argsLen$$3 = argsLen$$3 - 1;
        }
        var i$$124 = 0;
        var v2238 = i$$124 < argsLen$$3;
        for (;v2238;) {
          var v12782 = funcDecl$$37.arguments;
          var v2229 = v12782.members;
          var argDecl$$4 = v2229[i$$124];
          var v12783 = argDecl$$4.varFlags;
          var v19049 = TypeScript$$31.VarFlags;
          var v12784 = v19049.Property;
          var v2237 = TypeScript$$31.hasFlag(v12783, v12784);
          if (v2237) {
            this.emitDeclarationComments(argDecl$$4);
            var v12785 = argDecl$$4.varFlags;
            var v2230 = TypeScript$$31.ToDeclFlags(v12785);
            this.emitDeclFlags(v2230, "var");
            var v2231 = this.declFile;
            var v12786 = argDecl$$4.id;
            var v2232 = v12786.text;
            v2231.Write(v2232);
            var v12787 = argDecl$$4.typeExpr;
            if (v12787) {
              var v23141 = argDecl$$4.varFlags;
              var v19050 = TypeScript$$31.ToDeclFlags(v23141);
              v12787 = this.canEmitTypeAnnotationSignature(v19050);
            }
            var v2235 = v12787;
            if (v2235) {
              var v2233 = this.declFile;
              v2233.Write(": ");
              var v2234 = argDecl$$4.type;
              this.emitTypeSignature(v2234);
            }
            var v2236 = this.declFile;
            v2236.WriteLine(";");
          }
          i$$124 = i$$124 + 1;
          v2238 = i$$124 < argsLen$$3;
        }
      }
      return;
    }
    function v1223(funcDecl$$36) {
      var accessorSymbol$$1 = funcDecl$$36.accessorSymbol;
      var v12788 = accessorSymbol$$1.getter;
      if (v12788) {
        var v23142 = accessorSymbol$$1.getter;
        var v19051 = v23142.declAST;
        v12788 = v19051 != funcDecl$$36;
      }
      var v2240 = v12788;
      if (v2240) {
        return false;
      }
      this.emitDeclarationComments(accessorSymbol$$1);
      var v12789 = accessorSymbol$$1.flags;
      var v2241 = TypeScript$$31.ToDeclFlags(v12789);
      this.emitDeclFlags(v2241, "var");
      var v2242 = this.declFile;
      var v12790 = funcDecl$$36.name;
      var v2243 = v12790.text;
      v2242.Write(v2243);
      var propertyType = accessorSymbol$$1.getType();
      var v19052 = accessorSymbol$$1.flags;
      var v12791 = TypeScript$$31.ToDeclFlags(v19052);
      var v2245 = this.canEmitTypeAnnotationSignature(v12791);
      if (v2245) {
        var v2244 = this.declFile;
        v2244.Write(" : ");
        this.emitTypeSignature(propertyType);
      }
      var v2246 = this.declFile;
      v2246.WriteLine(";");
      return false;
    }
    function v1222(bases$$8, qual) {
      var v12792 = bases$$8;
      if (v12792) {
        var v23143 = bases$$8.members;
        var v19053 = v23143.length;
        v12792 = v19053 > 0;
      }
      var v2255 = v12792;
      if (v2255) {
        var v2247 = this.declFile;
        var v12793 = " " + qual;
        var v2248 = v12793 + " ";
        v2247.Write(v2248);
        var v2249 = bases$$8.members;
        var basesLen$$3 = v2249.length;
        var i$$123 = 0;
        var v2254 = i$$123 < basesLen$$3;
        for (;v2254;) {
          var v2250 = bases$$8.members;
          var baseExpr$$3 = v2250[i$$123];
          var v2251 = baseExpr$$3.type;
          var baseSymbol$$4 = v2251.symbol;
          var baseType$$1 = baseExpr$$3.type;
          var v2253 = i$$123 > 0;
          if (v2253) {
            var v2252 = this.declFile;
            v2252.Write(", ");
          }
          this.emitTypeSignature(baseType$$1);
          i$$123 = i$$123 + 1;
          v2254 = i$$123 < basesLen$$3;
        }
      }
      return;
    }
    function v1221(pre$$15, funcDecl$$35) {
      var v2256 = !pre$$15;
      if (v2256) {
        return false;
      }
      var v2257 = funcDecl$$35.isAccessor();
      if (v2257) {
        return this.emitPropertyAccessorSignature(funcDecl$$35);
      }
      var v12794 = this.getAstDeclarationContainer();
      var v2258 = v12794.nodeType;
      var v12795 = TypeScript$$31.NodeType;
      var v2259 = v12795.InterfaceDeclaration;
      var isInterfaceMember = v2258 == v2259;
      var v2269 = funcDecl$$35.bod;
      if (v2269) {
        var v2262 = funcDecl$$35.isConstructor;
        if (v2262) {
          var v19054 = funcDecl$$35.type;
          var v12796 = v19054.construct;
          if (v12796) {
            var v26028 = funcDecl$$35.type;
            var v25159 = v26028.construct;
            var v23144 = v25159.signatures;
            var v19055 = v23144.length;
            v12796 = v19055 > 1;
          }
          var v2260 = v12796;
          if (v2260) {
            return false;
          }
        } else {
          var v19056 = funcDecl$$35.type;
          var v12797 = v19056.call;
          if (v12797) {
            var v26029 = funcDecl$$35.type;
            var v25160 = v26029.call;
            var v23145 = v25160.signatures;
            var v19057 = v23145.length;
            v12797 = v19057 > 1;
          }
          var v2261 = v12797;
          if (v2261) {
            return false;
          }
        }
      } else {
        var v23146 = !isInterfaceMember;
        if (v23146) {
          var v25161 = funcDecl$$35.fncFlags;
          var v26030 = TypeScript$$31.FncFlags;
          var v25162 = v26030.Private;
          v23146 = TypeScript$$31.hasFlag(v25161, v25162);
        }
        var v19058 = v23146;
        if (v19058) {
          var v23147 = funcDecl$$35.type;
          v19058 = v23147.call;
        }
        var v12798 = v19058;
        if (v12798) {
          var v26031 = funcDecl$$35.type;
          var v25163 = v26031.call;
          var v23148 = v25163.signatures;
          var v19059 = v23148.length;
          v12798 = v19059 > 1;
        }
        var v2268 = v12798;
        if (v2268) {
          var v12799 = funcDecl$$35.type;
          var v2263 = v12799.call;
          var signatures$$4 = v2263.signatures;
          var v2264 = signatures$$4[0];
          var firstSignature = v2264.declAST;
          var v2266 = firstSignature.bod;
          if (v2266) {
            var v2265 = signatures$$4[1];
            firstSignature = v2265.declAST;
          }
          var v2267 = firstSignature != funcDecl$$35;
          if (v2267) {
            return false;
          }
        }
      }
      var v23149 = funcDecl$$35.fncFlags;
      var v19060 = TypeScript$$31.ToDeclFlags(v23149);
      var v12800 = this.canEmitSignature(v19060, false);
      var v2270 = !v12800;
      if (v2270) {
        return false;
      }
      this.emitDeclarationComments(funcDecl$$35);
      var v2281 = funcDecl$$35.isConstructor;
      if (v2281) {
        this.emitIndent();
        var v2271 = this.declFile;
        v2271.Write("constructor");
      } else {
        var id$$24 = funcDecl$$35.getNameText();
        var v2280 = !isInterfaceMember;
        if (v2280) {
          var v12801 = funcDecl$$35.fncFlags;
          var v2272 = TypeScript$$31.ToDeclFlags(v12801);
          this.emitDeclFlags(v2272, "function");
          var v2273 = this.declFile;
          v2273.Write(id$$24);
        } else {
          this.emitIndent();
          var v2279 = funcDecl$$35.isConstructMember();
          if (v2279) {
            var v2274 = this.declFile;
            v2274.Write("new");
          } else {
            var v19061 = funcDecl$$35.isCallMember();
            var v12802 = !v19061;
            if (v12802) {
              var v19062 = funcDecl$$35.isIndexerMember();
              v12802 = !v19062;
            }
            var v2278 = v12802;
            if (v2278) {
              var v2275 = this.declFile;
              v2275.Write(id$$24);
              var v19063 = funcDecl$$35.name;
              var v12803 = v19063.flags;
              var v19064 = TypeScript$$31.ASTFlags;
              var v12804 = v19064.OptionalName;
              var v2277 = TypeScript$$31.hasFlag(v12803, v12804);
              if (v2277) {
                var v2276 = this.declFile;
                v2276.Write("? ");
              }
            }
          }
        }
      }
      var v12805 = funcDecl$$35.isIndexerMember();
      var v2284 = !v12805;
      if (v2284) {
        var v2282 = this.declFile;
        v2282.Write("(");
      } else {
        var v2283 = this.declFile;
        v2283.Write("[");
      }
      var v2285 = this.indenter;
      v2285.increaseIndent();
      var v2292 = funcDecl$$35.arguments;
      if (v2292) {
        var v12806 = funcDecl$$35.arguments;
        var v2286 = v12806.members;
        var argsLen$$2 = v2286.length;
        var v2287 = funcDecl$$35.variableArgList;
        if (v2287) {
          argsLen$$2 = argsLen$$2 - 1;
        }
        var i$$122 = 0;
        var v2291 = i$$122 < argsLen$$2;
        for (;v2291;) {
          var v12807 = funcDecl$$35.arguments;
          var v2288 = v12807.members;
          var argDecl$$3 = v2288[i$$122];
          this.emitArgDecl(argDecl$$3, funcDecl$$35);
          var v12808 = argsLen$$2 - 1;
          var v2290 = i$$122 < v12808;
          if (v2290) {
            var v2289 = this.declFile;
            v2289.Write(", ");
          }
          i$$122 = i$$122 + 1;
          v2291 = i$$122 < argsLen$$2;
        }
      }
      var v2298 = funcDecl$$35.variableArgList;
      if (v2298) {
        var v12809 = funcDecl$$35.arguments;
        var v2293 = v12809.members;
        var v23150 = funcDecl$$35.arguments;
        var v19065 = v23150.members;
        var v12810 = v19065.length;
        var v2294 = v12810 - 1;
        var lastArg$$2 = v2293[v2294];
        var v23151 = funcDecl$$35.arguments;
        var v19066 = v23151.members;
        var v12811 = v19066.length;
        var v2297 = v12811 > 1;
        if (v2297) {
          var v2295 = this.declFile;
          v2295.Write(", ...");
        } else {
          var v2296 = this.declFile;
          v2296.Write("...");
        }
        this.emitArgDecl(lastArg$$2, funcDecl$$35);
      }
      var v2299 = this.indenter;
      v2299.decreaseIndent();
      var v12812 = funcDecl$$35.isIndexerMember();
      var v2302 = !v12812;
      if (v2302) {
        var v2300 = this.declFile;
        v2300.Write(")");
      } else {
        var v2301 = this.declFile;
        v2301.Write("]");
      }
      var v23152 = funcDecl$$35.isConstructor;
      var v19067 = !v23152;
      if (v19067) {
        var v23153 = funcDecl$$35.returnTypeAnnotation;
        var v25166 = !v23153;
        if (v25166) {
          var v26413 = funcDecl$$35.signature;
          var v26032 = v26413.returnType;
          var v25164 = v26032.type;
          var v26033 = this.checker;
          var v25165 = v26033.anyType;
          v23153 = v25164 != v25165;
        }
        v19067 = v23153;
      }
      var v12813 = v19067;
      if (v12813) {
        var v23154 = funcDecl$$35.fncFlags;
        var v19068 = TypeScript$$31.ToDeclFlags(v23154);
        v12813 = this.canEmitTypeAnnotationSignature(v19068);
      }
      var v2305 = v12813;
      if (v2305) {
        var v2303 = this.declFile;
        v2303.Write(": ");
        var v19069 = funcDecl$$35.signature;
        var v12814 = v19069.returnType;
        var v2304 = v12814.type;
        this.emitTypeSignature(v2304);
      }
      var v2306 = this.declFile;
      v2306.WriteLine(";");
      return false;
    }
    function v1220(argDecl$$2, funcDecl$$34) {
      this.emitDeclarationComments(argDecl$$2, false);
      var v2307 = this.declFile;
      var v12815 = argDecl$$2.id;
      var v2308 = v12815.text;
      v2307.Write(v2308);
      var v2310 = argDecl$$2.isOptionalArg();
      if (v2310) {
        var v2309 = this.declFile;
        v2309.Write("?");
      }
      var v19070 = argDecl$$2.typeExpr;
      var v23157 = !v19070;
      if (v23157) {
        var v23155 = argDecl$$2.type;
        var v25167 = this.checker;
        var v23156 = v25167.anyType;
        v19070 = v23155 != v23156;
      }
      var v12816 = v19070;
      if (v12816) {
        var v23158 = funcDecl$$34.fncFlags;
        var v19071 = TypeScript$$31.ToDeclFlags(v23158);
        v12816 = this.canEmitTypeAnnotationSignature(v19071);
      }
      var v2313 = v12816;
      if (v2313) {
        var v2311 = this.declFile;
        v2311.Write(": ");
        var v2312 = argDecl$$2.type;
        this.emitTypeSignature(v2312);
      }
      return;
    }
    function v1219(pre$$14, block$$2) {
      var v12817 = block$$2.isStatementBlock;
      var v2315 = !v12817;
      if (v2315) {
        if (pre$$14) {
          var v12818 = block$$2.statements;
          var v2314 = v12818.members;
          this.varListCount = v2314.length;
        } else {
          this.varListCount = 0;
        }
        return true;
      }
      return false;
    }
    function v1218(pre$$13, varDecl$$20) {
      var v12819 = pre$$13;
      if (v12819) {
        var v23159 = varDecl$$20.varFlags;
        var v19072 = TypeScript$$31.ToDeclFlags(v23159);
        v12819 = this.canEmitSignature(v19072, false);
      }
      var v2340 = v12819;
      if (v2340) {
        var v12820 = this.getAstDeclarationContainer();
        var v2316 = v12820.nodeType;
        var v12821 = TypeScript$$31.NodeType;
        var v2317 = v12821.InterfaceDeclaration;
        var interfaceMember = v2316 == v2317;
        this.emitDeclarationComments(varDecl$$20);
        var v2327 = !interfaceMember;
        if (v2327) {
          var v12822 = this.varListCount;
          var v2320 = v12822 >= 0;
          if (v2320) {
            var v12823 = varDecl$$20.varFlags;
            var v2318 = TypeScript$$31.ToDeclFlags(v12823);
            this.emitDeclFlags(v2318, "var");
            var v2319 = this.varListCount;
            this.varListCount = -v2319;
          }
          var v2321 = this.declFile;
          var v12824 = varDecl$$20.id;
          var v2322 = v12824.text;
          v2321.Write(v2322);
        } else {
          this.emitIndent();
          var v2323 = this.declFile;
          var v12825 = varDecl$$20.id;
          var v2324 = v12825.text;
          v2323.Write(v2324);
          var v19073 = varDecl$$20.id;
          var v12826 = v19073.flags;
          var v19074 = TypeScript$$31.ASTFlags;
          var v12827 = v19074.OptionalName;
          var v2326 = TypeScript$$31.hasFlag(v12826, v12827);
          if (v2326) {
            var v2325 = this.declFile;
            v2325.Write("?");
          }
        }
        var type$$59 = null;
        var v12828 = varDecl$$20.typeExpr;
        if (v12828) {
          var v19075 = varDecl$$20.typeExpr;
          v12828 = v19075.type;
        }
        var v2332 = v12828;
        if (v2332) {
          var v2328 = varDecl$$20.typeExpr;
          type$$59 = v2328.type;
        } else {
          var v2331 = varDecl$$20.sym;
          if (v2331) {
            var v2329 = varDecl$$20.sym;
            type$$59 = v2329.getType();
            var v19076 = this.checker;
            var v12829 = v19076.anyType;
            var v2330 = type$$59 == v12829;
            if (v2330) {
              type$$59 = null;
            }
          }
        }
        var v12830 = type$$59;
        if (v12830) {
          var v23160 = varDecl$$20.varFlags;
          var v19077 = TypeScript$$31.ToDeclFlags(v23160);
          v12830 = this.canEmitTypeAnnotationSignature(v19077);
        }
        var v2334 = v12830;
        if (v2334) {
          var v2333 = this.declFile;
          v2333.Write(": ");
          this.emitTypeSignature(type$$59);
        }
        var v12831 = this.varListCount;
        var v2336 = v12831 > 0;
        if (v2336) {
          var v12832 = this.varListCount;
          this.varListCount = v12832 - 1;
        } else {
          var v12833 = this.varListCount;
          var v2335 = v12833 < 0;
          if (v2335) {
            var v12834 = this.varListCount;
            this.varListCount = v12834 + 1;
          }
        }
        var v12835 = this.varListCount;
        var v2339 = v12835 < 0;
        if (v2339) {
          var v2337 = this.declFile;
          v2337.Write(", ");
        } else {
          var v2338 = this.declFile;
          v2338.WriteLine(";");
        }
      }
      return false;
    }
    function v1217(astOrSymbol, endLine) {
      var v12836 = typeof endLine;
      var v2341 = v12836 === "undefined";
      if (v2341) {
        endLine = true;
      }
      var v19078 = this.emitOptions;
      var v12837 = v19078.emitComments;
      var v2342 = !v12837;
      if (v2342) {
        return;
      }
      var declComments = astOrSymbol.getDocComments();
      var v12838 = declComments.length;
      var v2348 = v12838 > 0;
      if (v2348) {
        var i$$121 = 0;
        var v12839 = declComments.length;
        var v2344 = i$$121 < v12839;
        for (;v2344;) {
          var v2343 = declComments[i$$121];
          this.emitComment(v2343);
          i$$121 = i$$121 + 1;
          var v12840 = declComments.length;
          v2344 = i$$121 < v12840;
        }
        if (endLine) {
          var v19079 = this.declFile;
          var v12841 = v19079.onNewLine;
          var v2346 = !v12841;
          if (v2346) {
            var v2345 = this.declFile;
            v2345.WriteLine("");
          }
        } else {
          var v12842 = this.declFile;
          var v2347 = v12842.onNewLine;
          if (v2347) {
            this.emitIndent();
          }
        }
      }
      return;
    }
    function v1216(comment$$10) {
      var text$$26 = comment$$10.getText();
      var v12843 = this.declFile;
      var v2351 = v12843.onNewLine;
      if (v2351) {
        this.emitIndent();
      } else {
        var v12844 = comment$$10.isBlockComment;
        var v2350 = !v12844;
        if (v2350) {
          var v2349 = this.declFile;
          v2349.WriteLine("");
          this.emitIndent();
        }
      }
      var v2352 = this.declFile;
      var v2353 = text$$26[0];
      v2352.Write(v2353);
      var i$$120 = 1;
      var v12845 = text$$26.length;
      var v2357 = i$$120 < v12845;
      for (;v2357;) {
        var v2354 = this.declFile;
        v2354.WriteLine("");
        this.emitIndent();
        var v2355 = this.declFile;
        var v2356 = text$$26[i$$120];
        v2355.Write(v2356);
        i$$120 = i$$120 + 1;
        var v12846 = text$$26.length;
        v2357 = i$$120 < v12846;
      }
      var v12847 = comment$$10.endsLine;
      var v19081 = !v12847;
      if (v19081) {
        var v19080 = comment$$10.isBlockComment;
        v12847 = !v19080;
      }
      var v2360 = v12847;
      if (v2360) {
        var v2358 = this.declFile;
        v2358.WriteLine("");
      } else {
        var v2359 = this.declFile;
        v2359.Write(" ");
      }
      return;
    }
    function v1215(type$$58) {
      var containingScope = null;
      var declarationContainerAst = this.getAstDeclarationContainer();
      var v2368 = declarationContainerAst.nodeType;
      switch(v2368) {
        case TypeScript$$31.NodeType.ModuleDeclaration:
        ;
        case TypeScript$$31.NodeType.InterfaceDeclaration:
        ;
        case TypeScript$$31.NodeType.FuncDecl:
          var v2362 = declarationContainerAst.type;
          if (v2362) {
            var v2361 = declarationContainerAst.type;
            containingScope = v2361.containedScope;
          }
          break;
        case TypeScript$$31.NodeType.Script:
          var script$$21 = declarationContainerAst;
          var v2364 = script$$21.bod;
          if (v2364) {
            var v2363 = script$$21.bod;
            containingScope = v2363.enclosingScope;
          }
          break;
        case TypeScript$$31.NodeType.ClassDeclaration:
          var v2366 = declarationContainerAst.type;
          if (v2366) {
            var v12848 = declarationContainerAst.type;
            var v2365 = v12848.instanceType;
            containingScope = v2365.containedScope;
          }
          break;
        default:
          var v2367 = TypeScript$$31.CompilerDiagnostics;
          v2367.debugPrint("Unknown containing scope");
      }
      var typeNameMembers = type$$58.getScopedTypeNameEx(containingScope);
      this.emitTypeNamesMember(typeNameMembers);
      return;
    }
    function v1214(memberName$$5, emitIndent) {
      var v12849 = typeof emitIndent;
      var v2369 = v12849 === "undefined";
      if (v2369) {
        emitIndent = false;
      }
      var v12850 = memberName$$5.prefix;
      var v2375 = v12850 == "{ ";
      if (v2375) {
        if (emitIndent) {
          this.emitIndent();
        }
        var v2370 = this.declFile;
        v2370.WriteLine("{");
        var v2371 = this.indenter;
        v2371.increaseIndent();
        emitIndent = true;
      } else {
        var v12851 = memberName$$5.prefix;
        var v2374 = v12851 != "";
        if (v2374) {
          if (emitIndent) {
            this.emitIndent();
          }
          var v2372 = this.declFile;
          var v2373 = memberName$$5.prefix;
          v2372.Write(v2373);
          emitIndent = false;
        }
      }
      var v2382 = memberName$$5.isString();
      if (v2382) {
        if (emitIndent) {
          this.emitIndent();
        }
        var v2376 = this.declFile;
        var v2377 = memberName$$5.text;
        v2376.Write(v2377);
      } else {
        var ar$$1 = memberName$$5;
        var index$$62 = 0;
        var v19082 = ar$$1.entries;
        var v12852 = v19082.length;
        var v2381 = index$$62 < v12852;
        for (;v2381;) {
          var v12853 = ar$$1.entries;
          var v2378 = v12853[index$$62];
          this.emitTypeNamesMember(v2378, emitIndent);
          var v12854 = ar$$1.delim;
          var v2380 = v12854 == "; ";
          if (v2380) {
            var v2379 = this.declFile;
            v2379.WriteLine(";");
          }
          index$$62 = index$$62 + 1;
          var v19083 = ar$$1.entries;
          var v12855 = v19083.length;
          v2381 = index$$62 < v12855;
        }
      }
      var v12856 = memberName$$5.suffix;
      var v2388 = v12856 == "}";
      if (v2388) {
        var v2383 = this.indenter;
        v2383.decreaseIndent();
        this.emitIndent();
        var v2384 = this.declFile;
        var v2385 = memberName$$5.suffix;
        v2384.Write(v2385);
      } else {
        var v2386 = this.declFile;
        var v2387 = memberName$$5.suffix;
        v2386.Write(v2387);
      }
      return;
    }
    function v1213(ast$$120) {
      var v2389 = TypeScript$$31.CompilerDiagnostics;
      var v12857 = ast$$120;
      var v12858 = this.getAstDeclarationContainer();
      var v2390 = v12857 != v12858;
      v2389.assert(v2390, "Declaration container mismatch");
      var v2391 = this.declarationContainerStack;
      v2391.pop();
      return;
    }
    function v1212(ast$$119) {
      var v2392 = this.declarationContainerStack;
      v2392.push(ast$$119);
      return;
    }
    function v1211(declFlag) {
      var v12859 = typeof declFlag;
      var v2394 = v12859 === "undefined";
      if (v2394) {
        var v2393 = TypeScript$$31.DeclFlags;
        declFlag = v2393.None;
      }
      var v19084 = TypeScript$$31.DeclFlags;
      var v12860 = v19084.Private;
      var v2395 = TypeScript$$31.hasFlag(declFlag, v12860);
      return!v2395;
    }
    function v1210(declFlags$$3, typeString$$1) {
      var v2396 = this.declFile;
      var v2397 = this.getDeclFlagsString(declFlags$$3, typeString$$1);
      v2396.Write(v2397);
      return;
    }
    function v1209(declFlags$$2, typeString) {
      var result$$34 = this.getIndentString();
      var accessorString = "";
      var v19085 = TypeScript$$31.DeclFlags;
      var v12861 = v19085.GetAccessor;
      var v2399 = TypeScript$$31.hasFlag(declFlags$$2, v12861);
      if (v2399) {
        accessorString = "get ";
      } else {
        var v19086 = TypeScript$$31.DeclFlags;
        var v12862 = v19086.SetAccessor;
        var v2398 = TypeScript$$31.hasFlag(declFlags$$2, v12862);
        if (v2398) {
          accessorString = "set ";
        }
      }
      var container$$23 = this.getAstDeclarationContainer();
      var v23161 = container$$23.nodeType;
      var v25168 = TypeScript$$31.NodeType;
      var v23162 = v25168.ModuleDeclaration;
      var v19087 = v23161 == v23162;
      if (v19087) {
        var v23163 = container$$23.modFlags;
        var v25169 = TypeScript$$31.ModuleFlags;
        var v23164 = v25169.IsWholeFile;
        v19087 = TypeScript$$31.hasFlag(v23163, v23164);
      }
      var v12863 = v19087;
      if (v12863) {
        var v23165 = TypeScript$$31.DeclFlags;
        var v19088 = v23165.Exported;
        v12863 = TypeScript$$31.hasFlag(declFlags$$2, v19088);
      }
      var v2400 = v12863;
      if (v2400) {
        result$$34 = result$$34 + "export ";
      }
      var v23166 = TypeScript$$31.DeclFlags;
      var v19089 = v23166.LocalStatic;
      var v12864 = TypeScript$$31.hasFlag(declFlags$$2, v19089);
      var v19091 = !v12864;
      if (v19091) {
        var v23167 = TypeScript$$31.DeclFlags;
        var v19090 = v23167.Static;
        v12864 = TypeScript$$31.hasFlag(declFlags$$2, v19090);
      }
      var v2404 = v12864;
      if (v2404) {
        var v12865 = "static " + accessorString;
        result$$34 = result$$34 + v12865;
      } else {
        var v19092 = TypeScript$$31.DeclFlags;
        var v12866 = v19092.Private;
        var v2403 = TypeScript$$31.hasFlag(declFlags$$2, v12866);
        if (v2403) {
          var v12867 = "private " + accessorString;
          result$$34 = result$$34 + v12867;
        } else {
          var v19093 = TypeScript$$31.DeclFlags;
          var v12868 = v19093.Public;
          var v2402 = TypeScript$$31.hasFlag(declFlags$$2, v12868);
          if (v2402) {
            var v12869 = "public " + accessorString;
            result$$34 = result$$34 + v12869;
          } else {
            var v2401 = accessorString == "";
            if (v2401) {
              var v12870 = typeString + " ";
              result$$34 = result$$34 + v12870;
            } else {
              result$$34 = result$$34 + accessorString;
            }
          }
        }
      }
      return result$$34;
    }
    function v1208(declFlags$$1, astWithPrePostCallback, preCallback) {
      var v2408 = this.ignoreCallbackAst;
      if (v2408) {
        var v2405 = TypeScript$$31.CompilerDiagnostics;
        var v12871 = this.ignoreCallbackAst;
        var v2406 = v12871 != astWithPrePostCallback;
        v2405.assert(v2406, "Ignore Callback AST mismatch");
        this.ignoreCallbackAst = null;
        return false;
      } else {
        var v12872 = preCallback;
        if (v12872) {
          var v19094 = this.canEmitSignature(declFlags$$1, true, preCallback);
          v12872 = !v19094;
        }
        var v2407 = v12872;
        if (v2407) {
          this.ignoreCallbackAst = astWithPrePostCallback;
          return false;
        }
      }
      return true;
    }
    function v1207(declFlags, canEmitGlobalAmbientDecl, useDeclarationContainerTop) {
      var v12873 = typeof canEmitGlobalAmbientDecl;
      var v2409 = v12873 === "undefined";
      if (v2409) {
        canEmitGlobalAmbientDecl = true;
      }
      var v12874 = typeof useDeclarationContainerTop;
      var v2410 = v12874 === "undefined";
      if (v2410) {
        useDeclarationContainerTop = true;
      }
      var container$$22;
      if (useDeclarationContainerTop) {
        container$$22 = this.getAstDeclarationContainer();
      } else {
        var v2411 = this.declarationContainerStack;
        var v19095 = this.declarationContainerStack;
        var v12875 = v19095.length;
        var v2412 = v12875 - 2;
        container$$22 = v2411[v2412];
      }
      var v19096 = container$$22.nodeType;
      var v23168 = TypeScript$$31.NodeType;
      var v19097 = v23168.ModuleDeclaration;
      var v12876 = v19096 == v19097;
      if (v12876) {
        var v25170 = TypeScript$$31.DeclFlags;
        var v23169 = v25170.Exported;
        var v19098 = TypeScript$$31.hasFlag(declFlags, v23169);
        v12876 = !v19098;
      }
      var v2413 = v12876;
      if (v2413) {
        return false;
      }
      var v19099 = !canEmitGlobalAmbientDecl;
      if (v19099) {
        var v23170 = container$$22.nodeType;
        var v25171 = TypeScript$$31.NodeType;
        var v23171 = v25171.Script;
        v19099 = v23170 == v23171;
      }
      var v12877 = v19099;
      if (v12877) {
        var v23172 = TypeScript$$31.DeclFlags;
        var v19100 = v23172.Ambient;
        v12877 = TypeScript$$31.hasFlag(declFlags, v19100);
      }
      var v2414 = v12877;
      if (v2414) {
        return false;
      }
      return true;
    }
    function v1206() {
      var v2415 = this.declFile;
      var v2416 = this.getIndentString();
      v2415.Write(v2416);
      return;
    }
    function v1205(declIndent) {
      var v12878 = typeof declIndent;
      var v2417 = v12878 === "undefined";
      if (v2417) {
        declIndent = false;
      }
      var v12879 = this.emitOptions;
      var v2419 = v12879.minWhitespace;
      if (v2419) {
        return "";
      } else {
        var v2418 = this.indenter;
        return v2418.getIndent();
      }
      return;
    }
    function v1204(script$$20) {
      var v2420 = TypeScript$$31.AstWalkerWithDetailCallback;
      v2420.walk(script$$20, this);
      return;
    }
    function v1203() {
      try {
        var v2421 = this.declFile;
        v2421.Close();
      } catch (ex$$3) {
        var v2422 = this.errorReporter;
        var v2423 = ex$$3.message;
        v2422.emitterError(null, v2423);
      }
      return;
    }
    function v1202(file) {
      var v26790 = new DeclFileWriter(file);
      this.declFile = v26790;
      return;
    }
    function v1201() {
      var v2424;
      var v23173 = this.isDottedModuleName;
      var v19101 = v23173.length;
      var v12882 = v19101 == 0;
      if (v12882) {
        v2424 = false;
      } else {
        var v12880 = this.isDottedModuleName;
        var v23174 = this.isDottedModuleName;
        var v19102 = v23174.length;
        var v12881 = v19102 - 1;
        v2424 = v12880[v12881];
      }
      return v2424;
    }
    function v1200() {
      var v2425 = this.declarationContainerStack;
      var v19103 = this.declarationContainerStack;
      var v12883 = v19103.length;
      var v2426 = v12883 - 1;
      return v2425[v2426];
    }
    function DeclarationEmitter$$1(checker$$23, emitOptions$$2, errorReporter$$5) {
      this.checker = checker$$23;
      this.emitOptions = emitOptions$$2;
      this.errorReporter = errorReporter$$5;
      this.declFile = null;
      var v2427 = TypeScript$$31.Indenter;
      var v26791 = new v2427;
      this.indenter = v26791;
      this.declarationContainerStack = [];
      this.isDottedModuleName = [];
      this.ignoreCallbackAst = null;
      this.singleDeclFile = null;
      this.varListCount = 0;
      return;
    }
    var v2428 = DeclarationEmitter$$1.prototype;
    v2428.getAstDeclarationContainer = v1200;
    var v2429 = DeclarationEmitter$$1.prototype;
    v2429.emitDottedModuleName = v1201;
    var v2430 = DeclarationEmitter$$1.prototype;
    v2430.setDeclarationFile = v1202;
    var v2431 = DeclarationEmitter$$1.prototype;
    v2431.Close = v1203;
    var v2432 = DeclarationEmitter$$1.prototype;
    v2432.emitDeclarations = v1204;
    var v2433 = DeclarationEmitter$$1.prototype;
    v2433.getIndentString = v1205;
    var v2434 = DeclarationEmitter$$1.prototype;
    v2434.emitIndent = v1206;
    var v2435 = DeclarationEmitter$$1.prototype;
    v2435.canEmitSignature = v1207;
    var v2436 = DeclarationEmitter$$1.prototype;
    v2436.canEmitPrePostAstSignature = v1208;
    var v2437 = DeclarationEmitter$$1.prototype;
    v2437.getDeclFlagsString = v1209;
    var v2438 = DeclarationEmitter$$1.prototype;
    v2438.emitDeclFlags = v1210;
    var v2439 = DeclarationEmitter$$1.prototype;
    v2439.canEmitTypeAnnotationSignature = v1211;
    var v2440 = DeclarationEmitter$$1.prototype;
    v2440.pushDeclarationContainer = v1212;
    var v2441 = DeclarationEmitter$$1.prototype;
    v2441.popDeclarationContainer = v1213;
    var v2442 = DeclarationEmitter$$1.prototype;
    v2442.emitTypeNamesMember = v1214;
    var v2443 = DeclarationEmitter$$1.prototype;
    v2443.emitTypeSignature = v1215;
    var v2444 = DeclarationEmitter$$1.prototype;
    v2444.emitComment = v1216;
    var v2445 = DeclarationEmitter$$1.prototype;
    v2445.emitDeclarationComments = v1217;
    var v2446 = DeclarationEmitter$$1.prototype;
    v2446.VarDeclCallback = v1218;
    var v2447 = DeclarationEmitter$$1.prototype;
    v2447.BlockCallback = v1219;
    var v2448 = DeclarationEmitter$$1.prototype;
    v2448.emitArgDecl = v1220;
    var v2449 = DeclarationEmitter$$1.prototype;
    v2449.FuncDeclCallback = v1221;
    var v2450 = DeclarationEmitter$$1.prototype;
    v2450.emitBaseList = v1222;
    var v2451 = DeclarationEmitter$$1.prototype;
    v2451.emitPropertyAccessorSignature = v1223;
    var v2452 = DeclarationEmitter$$1.prototype;
    v2452.emitClassMembersFromConstructorDefinition = v1224;
    var v2453 = DeclarationEmitter$$1.prototype;
    v2453.ClassDeclarationCallback = v1225;
    var v2454 = DeclarationEmitter$$1.prototype;
    v2454.InterfaceDeclarationCallback = v1226;
    var v2455 = DeclarationEmitter$$1.prototype;
    v2455.ImportDeclarationCallback = v1227;
    var v2456 = DeclarationEmitter$$1.prototype;
    v2456.emitEnumSignature = v1228;
    var v2457 = DeclarationEmitter$$1.prototype;
    v2457.ModuleDeclarationCallback = v1229;
    var v2458 = DeclarationEmitter$$1.prototype;
    v2458.ScriptCallback = v1230;
    var v2459 = DeclarationEmitter$$1.prototype;
    v2459.DefaultCallback = v1231;
    return DeclarationEmitter$$1;
  }
  function v1199() {
    function v1198() {
      var v2460 = this.declFile;
      v2460.Close();
      return;
    }
    function v1197(s$$36) {
      var v2461 = this.declFile;
      v2461.WriteLine(s$$36);
      this.onNewLine = true;
      return;
    }
    function v1196(s$$35) {
      var v2462 = this.declFile;
      v2462.Write(s$$35);
      this.onNewLine = false;
      return;
    }
    function DeclFileWriter$$1(declFile) {
      this.declFile = declFile;
      this.onNewLine = true;
      return;
    }
    var v2463 = DeclFileWriter$$1.prototype;
    v2463.Write = v1196;
    var v2464 = DeclFileWriter$$1.prototype;
    v2464.WriteLine = v1197;
    var v2465 = DeclFileWriter$$1.prototype;
    v2465.Close = v1198;
    return DeclFileWriter$$1;
  }
  var DeclFileWriter = v1199();
  TypeScript$$31.DeclFileWriter = DeclFileWriter;
  var DeclarationEmitter = v1232();
  TypeScript$$31.DeclarationEmitter = DeclarationEmitter;
  return;
}
function v1195(TypeScript$$30) {
  function v1194() {
    function v1193(ast$$117, start$$13, delta$$1) {
      function pre$$12(cur$$11, parent$$71, walker$$55) {
        var v19104 = cur$$11.limChar;
        var v12884 = v19104 !== -1;
        if (v12884) {
          var v19105 = cur$$11.limChar;
          v12884 = v19105 < start$$13;
        }
        var v2467 = v12884;
        if (v2467) {
          var v2466 = walker$$55.options;
          v2466.goChildren = false;
        }
        applyDelta(cur$$11);
        var v2468 = cur$$11.preComments;
        applyDeltaToComments(v2468);
        var v2469 = cur$$11.postComments;
        applyDeltaToComments(v2469);
        return cur$$11;
      }
      function applyDeltaToComments(comments$$13) {
        var v12885 = comments$$13;
        if (v12885) {
          var v19106 = comments$$13.length;
          v12885 = v19106 > 0;
        }
        var v2472 = v12885;
        if (v2472) {
          var i$$119 = 0;
          var v12886 = comments$$13.length;
          var v2471 = i$$119 < v12886;
          for (;v2471;) {
            var v2470 = comments$$13[i$$119];
            applyDelta(v2470);
            i$$119 = i$$119 + 1;
            var v12887 = comments$$13.length;
            v2471 = i$$119 < v12887;
          }
        }
        return;
      }
      function applyDelta(ast$$118) {
        var v19107 = ast$$118.minChar;
        var v12888 = v19107 !== -1;
        if (v12888) {
          var v19108 = ast$$118.minChar;
          v12888 = v19108 >= start$$13;
        }
        var v2473 = v12888;
        if (v2473) {
          var v12889 = ast$$118.minChar;
          ast$$118.minChar = v12889 + delta$$1;
        }
        var v19109 = ast$$118.limChar;
        var v12890 = v19109 !== -1;
        if (v12890) {
          var v19110 = ast$$118.limChar;
          v12890 = v19110 >= start$$13;
        }
        var v2474 = v12890;
        if (v2474) {
          var v12891 = ast$$118.limChar;
          ast$$118.limChar = v12891 + delta$$1;
        }
        return;
      }
      var v2475 = TypeScript$$30.getAstWalkerFactory();
      v2475.walk(ast$$117, pre$$12);
      return;
    }
    function v1192(script$$19, partial$$1, editRange$$3) {
      var v2476 = script$$19.locationInfo;
      var lineMap1 = v2476.lineMap;
      var v2477 = partial$$1.locationInfo;
      var lineMap2 = v2477.lineMap;
      var v12892 = this.logger;
      var v2484 = v12892.information();
      if (v2484) {
        var v2478 = this.logger;
        v2478.log("lineMap1 (before):");
        var v2479 = this.astLogger;
        v2479.logLinemap(lineMap1);
        var v2480 = this.logger;
        v2480.log("lineMap2 (quick parse):");
        var v2481 = this.astLogger;
        v2481.logLinemap(lineMap2);
        var v2482 = this.logger;
        var v2483 = "EditRange=" + editRange$$3;
        v2482.log(v2483);
      }
      var i1 = 2;
      var i2 = 2;
      var len1 = lineMap1.length;
      var len2 = lineMap2.length;
      var v2489 = i1 < len1;
      for (;v2489;) {
        var v12893 = lineMap1[i1];
        var v12894 = editRange$$3.minChar;
        var v2488 = v12893 <= v12894;
        if (v2488) {
          i1 = i1 + 1;
        } else {
          var v12895 = lineMap1[i1];
          var v12896 = editRange$$3.limChar;
          var v2487 = v12895 >= v12896;
          if (v2487) {
            var v12897 = lineMap1[i1];
            var v12898 = editRange$$3.delta;
            lineMap1[i1] = v12897 + v12898;
            i1 = i1 + 1;
          } else {
            var v2486 = i2 < len2;
            if (v2486) {
              var v12899 = lineMap2[i2];
              var v12900 = editRange$$3.minChar;
              var v2485 = v12899 + v12900;
              lineMap1.splice(i1, 0, v2485);
              i1 = i1 + 1;
              len1 = len1 + 1;
              i2 = i2 + 1;
            } else {
              lineMap1.splice(i1, 1);
              len1 = len1 - 1;
            }
          }
        }
        v2489 = i1 < len1;
      }
      var v2496 = i2 < len2;
      if (v2496) {
        var v19111 = len1 - 1;
        var v12901 = lineMap1[v19111];
        var v19112 = lineMap2[i2];
        var v19113 = editRange$$3.minChar;
        var v12902 = v19112 + v19113;
        var v2493 = v12901 >= v12902;
        if (v2493) {
          i1 = 2;
          var v12903 = i1 < len1;
          if (v12903) {
            v12903 = i2 < len2;
          }
          var v2492 = v12903;
          for (;v2492;) {
            var v12904 = lineMap1[i1];
            var v19114 = lineMap2[i2];
            var v19115 = editRange$$3.minChar;
            var v12905 = v19114 + v19115;
            var v2491 = v12904 < v12905;
            if (v2491) {
              i1 = i1 + 1;
            } else {
              var v12906 = lineMap2[i2];
              var v12907 = editRange$$3.minChar;
              var v2490 = v12906 + v12907;
              lineMap1.splice(i1, 0, v2490);
              i1 = i1 + 1;
              len1 = len1 + 1;
              i2 = i2 + 1;
            }
            var v12908 = i1 < len1;
            if (v12908) {
              v12908 = i2 < len2;
            }
            v2492 = v12908;
          }
        }
        var v2495 = i2 < len2;
        for (;v2495;) {
          var v12909 = lineMap2[i2];
          var v12910 = editRange$$3.minChar;
          var v2494 = v12909 + v12910;
          lineMap1.push(v2494);
          i2 = i2 + 1;
          v2495 = i2 < len2;
        }
      }
      var v12911 = this.logger;
      var v2499 = v12911.information();
      if (v2499) {
        var v2497 = this.logger;
        v2497.log("lineMap1 (after merge):");
        var v2498 = this.astLogger;
        v2498.logLinemap(lineMap1);
      }
      return;
    }
    function v1191(script$$18, oldAst, newAst) {
      function pre$$11(cur$$10, parent$$70, walker$$54) {
        var v2502 = cur$$10 === oldAst;
        if (v2502) {
          newAst.preComments = cur$$10.preComments;
          newAst.postComments = cur$$10.postComments;
          var v2500 = _this$$14.logger;
          v2500.log("replaced old AST node with new one in script AST");
          var v2501 = walker$$54.options;
          v2501.stopWalk();
          return newAst;
        }
        var v2505 = TypeScript$$30.isValidAstNode(cur$$10);
        if (v2505) {
          var v19116 = cur$$10.limChar;
          var v19117 = oldAst.minChar;
          var v12912 = v19116 < v19117;
          var v19120 = !v12912;
          if (v19120) {
            var v19118 = cur$$10.minChar;
            var v19119 = oldAst.limChar;
            v12912 = v19118 > v19119;
          }
          var v2504 = v12912;
          if (v2504) {
            var v2503 = walker$$54.options;
            v2503.goChildren = false;
          }
        }
        return cur$$10;
      }
      var _this$$14 = this;
      var v2506 = TypeScript$$30.getAstWalkerFactory();
      v2506.walk(script$$18, pre$$11);
      return;
    }
    function v1190(updateResult) {
      function v1189() {
        var v2507 = TypeScript$$30.ScriptEditRange;
        var v12913 = updateResult.scope1;
        var v2508 = v12913.minChar;
        var v12914 = updateResult.scope1;
        var v2509 = v12914.limChar;
        var v12915 = updateResult.editRange;
        var v2510 = v12915.delta;
        var editRange$$2 = new v2507(v2508, v2509, v2510);
        var v2511 = updateResult.script1;
        var v2512 = editRange$$2.limChar;
        var v2513 = editRange$$2.delta;
        _this$$13.applyDeltaPosition(v2511, v2512, v2513);
        var v2514 = updateResult.script2;
        var v2515 = editRange$$2.minChar;
        _this$$13.applyDeltaPosition(v2514, 0, v2515);
        var v2516 = updateResult.script1;
        var v2517 = updateResult.script2;
        _this$$13.mergeLocationInfo(v2516, v2517, editRange$$2);
        var v2518 = updateResult.script1;
        var v2519 = updateResult.scope1;
        var v2520 = updateResult.scope2;
        _this$$13.replaceAST(v2518, v2519, v2520);
        return;
      }
      var _this$$13 = this;
      var v2521 = this.logger;
      TypeScript$$30.timeFunction(v2521, "mergeTrees()", v1189);
      return;
    }
    function v1188(previousScript$$1, scriptId$$1, newSourceText$$1, editRange$$1) {
      function errorCapture$$1(minChar$$33, charLen, message$$19, unitIndex$$10) {
        var v12916 = TypeScript$$30.ErrorEntry;
        var v12917 = minChar$$33 + charLen;
        var v2522 = new v12916(unitIndex$$10, minChar$$33, v12917, message$$19);
        parseErrors$$1.push(v2522);
        return;
      }
      var v2523 = this.logger;
      var v12918 = 'attemptIncrementalUpdateUnit("' + scriptId$$1;
      var v2524 = v12918 + '")';
      v2523.log(v2524);
      var v2525 = editRange$$1 === null;
      if (v2525) {
        throw new Error("editRange should be valid");
      }
      var scope1$$1 = this.getEnclosingScopeContextIfSingleScopeEdit(previousScript$$1, scriptId$$1, newSourceText$$1, editRange$$1);
      var v2526 = scope1$$1 === null;
      if (v2526) {
        return null;
      }
      var v19121 = scope1$$1.scopeStartAST;
      var v12919 = v19121.limChar;
      var v19122 = scope1$$1.scopeStartAST;
      var v12920 = v19122.minChar;
      var v2527 = v12919 - v12920;
      var v2528 = editRange$$1.delta;
      var newScopeLength$$1 = v2527 + v2528;
      var v12921 = newScopeLength$$1;
      var v19123 = newSourceText$$1.getLength();
      var v12922 = v19123 / 2;
      var v2531 = v12921 >= v12922;
      if (v2531) {
        var v2529 = this.logger;
        var v12923 = "  Bailing out because range of scope to reparse (" + newScopeLength$$1;
        var v2530 = v12923 + " characters) is greater than half the size of the source text";
        v2529.log(v2530);
        return null;
      }
      var parseErrors$$1 = [];
      var v2532 = this.logger;
      var v2533 = scope1$$1.scopeStartAST;
      var v12924 = scope1$$1.scopeStartAST;
      var v2534 = v12924.minChar;
      var v19124 = scope1$$1.scopeStartAST;
      var v12925 = v19124.minChar;
      var v2535 = v12925 + newScopeLength$$1;
      var quickParseResult = TypeScript$$30.quickParse(v2532, v2533, newSourceText$$1, v2534, v2535, errorCapture$$1);
      var v12926 = quickParseResult.endLexState;
      var v19125 = TypeScript$$30.LexState;
      var v12927 = v19125.Start;
      var v2537 = v12926 != v12927;
      if (v2537) {
        var v2536 = this.logger;
        v2536.log("  Bailing out because scope contains unterminated comment");
        return null;
      }
      var scriptFragment$$1 = quickParseResult.Script;
      var v23175 = scriptFragment$$1.vars;
      var v19126 = v23175.members;
      var v12928 = v19126.length;
      var v2539 = v12928 !== 0;
      if (v2539) {
        var v2538 = this.logger;
        v2538.log("  Bailing out because new source text defines variables");
        return null;
      }
      var v23176 = scriptFragment$$1.bod;
      var v19127 = v23176.members;
      var v12929 = v19127.length;
      var v2541 = v12929 !== 1;
      if (v2541) {
        var v2540 = this.logger;
        v2540.log("  Bailing out because new source text defines more than one scope (or none)");
        return null;
      }
      var oldScope = scope1$$1.scopeStartAST;
      var v12930 = scriptFragment$$1.bod;
      var v2542 = v12930.members;
      var newScope = v2542[0];
      var v12931 = oldScope.nodeType;
      var v12932 = newScope.nodeType;
      var v2544 = v12931 != v12932;
      if (v2544) {
        var v2543 = this.logger;
        v2543.log("  Bailing out because new source text does not define the same scope type as the existing scope");
        return null;
      }
      var v19128 = oldScope.leftCurlyCount;
      var v12933 = !v19128;
      var v19130 = !v12933;
      if (v19130) {
        var v19129 = oldScope.rightCurlyCount;
        v12933 = !v19129;
      }
      var v2546 = v12933;
      if (v2546) {
        var v2545 = this.logger;
        v2545.log("  Bailing out because sopce doesn't have left/right curly count");
        return null;
      }
      var v12934 = oldScope.leftCurlyCount;
      var v12935 = newScope.leftCurlyCount;
      var v2548 = v12934 !== v12935;
      if (v2548) {
        var v2547 = this.logger;
        v2547.log("  Bailing out because new source text contains more (or fewer) left curly braces");
        return null;
      }
      var v12936 = oldScope.rightCurlyCount;
      var v12937 = newScope.rightCurlyCount;
      var v2550 = v12936 !== v12937;
      if (v2550) {
        var v2549 = this.logger;
        v2549.log("  Bailing out because new source text contains more (or fewer) right curly braces");
        return null;
      }
      var v12938 = newScope.minChar;
      var v2552 = v12938 !== 0;
      if (v2552) {
        var v2551 = this.logger;
        v2551.log("  Bailing out because new function declaration does not start at position 0");
        return null;
      }
      var v12939 = newScope.limChar;
      var v2554 = v12939 !== newScopeLength$$1;
      if (v2554) {
        var v2553 = this.logger;
        v2553.log("  Bailing out because new function declaration does not end at the new end position");
        return null;
      }
      var v2555 = TypeScript$$30.UpdateUnitResult;
      return v2555.singleScopeEdits(previousScript$$1, scriptFragment$$1, oldScope, newScope, editRange$$1, parseErrors$$1);
    }
    function v1187(previousScript, scriptId, newSourceText, editRange) {
      var v2556 = this.logger;
      var v12940 = 'checkEditsInsideSingleScope("' + scriptId;
      var v2557 = v12940 + '")';
      v2556.log(v2557);
      var v2558 = editRange === null;
      if (v2558) {
        throw new Error("editRange should be valid");
      }
      var v2560 = editRange.isUnknown();
      if (v2560) {
        var v2559 = this.logger;
        v2559.log("  Bailing out because edit range is unknown");
        return null;
      }
      var v2561 = this.logger;
      var v2562 = editRange.minChar;
      var scope1 = TypeScript$$30.findEnclosingScopeAt(v2561, previousScript, newSourceText, v2562, false);
      var v2563 = this.logger;
      var v2564 = editRange.limChar;
      var scope2 = TypeScript$$30.findEnclosingScopeAt(v2563, previousScript, newSourceText, v2564, false);
      var v12941 = scope1 == null;
      var v19131 = !v12941;
      if (v19131) {
        v12941 = scope2 == null;
      }
      var v2566 = v12941;
      if (v2566) {
        var v2565 = this.logger;
        v2565.log("  Bailing out because containing scopes cannot be determined");
        return null;
      }
      var v12942 = scope1.scopeStartAST;
      var v12943 = scope2.scopeStartAST;
      var v2568 = v12942 !== v12943;
      if (v2568) {
        var v2567 = this.logger;
        v2567.log("  Bailing out because edit overlaps 2 disctint scopes");
        return null;
      }
      var v19132 = scope1.scopeStartAST;
      var v12944 = v19132.limChar;
      var v19133 = scope1.scopeStartAST;
      var v12945 = v19133.minChar;
      var v2569 = v12944 - v12945;
      var v2570 = editRange.delta;
      var newScopeLength = v2569 + v2570;
      var v2572 = newScopeLength <= 0;
      if (v2572) {
        var v2571 = this.logger;
        v2571.log("  Bailing out because scope has been entirely removed from new source text");
        return null;
      }
      return scope1;
    }
    function IncrementalParser$$1(logger$$5) {
      this.logger = logger$$5;
      var v2573 = TypeScript$$30.AstLogger;
      var v2574 = this.logger;
      var v26792 = new v2573(v2574);
      this.astLogger = v26792;
      return;
    }
    var v2575 = IncrementalParser$$1.prototype;
    v2575.getEnclosingScopeContextIfSingleScopeEdit = v1187;
    var v2576 = IncrementalParser$$1.prototype;
    v2576.attemptIncrementalUpdateUnit = v1188;
    var v2577 = IncrementalParser$$1.prototype;
    v2577.mergeTrees = v1190;
    var v2578 = IncrementalParser$$1.prototype;
    v2578.replaceAST = v1191;
    var v2579 = IncrementalParser$$1.prototype;
    v2579.mergeLocationInfo = v1192;
    var v2580 = IncrementalParser$$1.prototype;
    v2580.applyDeltaPosition = v1193;
    return IncrementalParser$$1;
  }
  var IncrementalParser = v1194();
  TypeScript$$30.IncrementalParser = IncrementalParser;
  return;
}
function v1186(TypeScript$$29) {
  function v1185() {
    function v1184(str$$12) {
      var v2581 = this.styleSettings;
      v2581.parseOptions(str$$12);
      return;
    }
    function CompilationSettings$$1() {
      var v26793 = new StyleSettings;
      this.styleSettings = v26793;
      this.propagateConstants = false;
      this.minWhitespace = false;
      this.parseOnly = false;
      this.errorRecovery = false;
      this.emitComments = false;
      this.watch = false;
      this.exec = false;
      this.resolve = true;
      this.controlFlow = false;
      this.printControlFlow = false;
      this.controlFlowUseDef = false;
      this.errorOnWith = true;
      this.preprocess = true;
      this.canCallDefinitionSignature = false;
      this.inferPropertiesFromThisAssignment = false;
      this.useDefaultLib = true;
      var v2582 = TypeScript$$29.CodeGenTarget;
      this.codeGenTarget = v2582.ES3;
      var v2583 = TypeScript$$29.ModuleGenTarget;
      this.moduleGenTarget = v2583.Synchronous;
      this.outputOption = "";
      this.mapSourceFiles = false;
      this.generateDeclarationFiles = false;
      this.useCaseSensitiveFileResolution = false;
      return;
    }
    var v2584 = CompilationSettings$$1.prototype;
    v2584.setStyleOptions = v1184;
    return CompilationSettings$$1;
  }
  function v1183() {
    function v1182(str$$11) {
      var opts = str$$11.split(";");
      var i$$118 = 0;
      var len$$57 = opts.length;
      var v2589 = i$$118 < len$$57;
      for (;v2589;) {
        var opt$$1 = opts[i$$118];
        var val$$7 = true;
        var colonIndex = opt$$1.lastIndexOf(":");
        var v2587 = colonIndex >= 0;
        if (v2587) {
          var v2585 = colonIndex + 1;
          var valStr = opt$$1.substring(v2585);
          opt$$1 = opt$$1.substring(0, colonIndex);
          var v2586 = valStr == "off";
          if (v2586) {
            val$$7 = false;
          }
        }
        var v12946 = this.setOption(opt$$1, val$$7);
        var v2588 = !v12946;
        if (v2588) {
          return false;
        }
        i$$118 = i$$118 + 1;
        v2589 = i$$118 < len$$57;
      }
      return true;
    }
    function v1181(opt, val$$6) {
      var optExists = this[opt];
      var v2590 = optExists !== undefined;
      if (v2590) {
        this[opt] = val$$6;
        return true;
      } else {
        return false;
      }
      return;
    }
    function StyleSettings$$1() {
      this.bitwise = false;
      this.blockInCompoundStmt = false;
      this.eqeqeq = false;
      this.forin = false;
      this.emptyBlocks = true;
      this.newMustBeUsed = false;
      this.requireSemi = false;
      this.assignmentInCond = false;
      this.eqnull = false;
      this.evalOK = true;
      this.innerScopeDeclEscape = true;
      this.funcInLoop = true;
      this.reDeclareLocal = true;
      this.literalSubscript = true;
      this.implicitAny = false;
      return;
    }
    var v2591 = StyleSettings$$1.prototype;
    v2591.setOption = v1181;
    var v2592 = StyleSettings$$1.prototype;
    v2592.parseOptions = v1182;
    return StyleSettings$$1;
  }
  function getAdditionalDependencyPath(comment$$6) {
    var amdDependencyRegEx = /^(\/\/\/\s*<amd-dependency\s+path=)('|")(.+?)\2\s*(static=('|")(.+?)\2\s*)*\/>/igm;
    var match$$1 = amdDependencyRegEx.exec(comment$$6);
    if (match$$1) {
      var path$$18 = match$$1[3];
      return path$$18;
    } else {
      return null;
    }
    return;
  }
  function getImplicitImport(comment$$7) {
    var implicitImportRegEx = /^(\/\/\/\s*<implicit-import\s*)*\/>/igm;
    var match$$2 = implicitImportRegEx.exec(comment$$7);
    if (match$$2) {
      return true;
    }
    return false;
  }
  function getStyleSettings(comment$$8, styleSettings) {
    var styleRegEx = /^(\/\/\/\s*<style\s+)(([a-zA-Z])+=('|").+('|"))\s*\/>/igm;
    var settings$$2 = styleRegEx.exec(comment$$8);
    if (settings$$2) {
      var settingsRegEx = /^([a-zA-Z]+=['"]on['|"])/igm;
      var v2593 = settings$$2[2];
      settings$$2 = settingsRegEx.exec(v2593);
      if (settings$$2) {
        var i$$117 = 0;
        var v12947 = settings$$2.length;
        var v2610 = i$$117 < v12947;
        for (;v2610;) {
          var v2594 = settings$$2[i$$117];
          var setting = v2594.split("=");
          var on = '"on"';
          var v2609 = setting[0];
          switch(v2609) {
            case "blockInCompoundStmt":
              var v2595 = setting[1];
              styleSettings.blockInCompoundStmt = v2595 == on;
              break;
            case "eqeqeq":
              var v2596 = setting[1];
              styleSettings.eqeqeq = v2596 == on;
              break;
            case "forin":
              var v2597 = setting[1];
              styleSettings.forin = v2597 == on;
              break;
            case "emptyBlocks":
              var v2598 = setting[1];
              styleSettings.emptyBlocks = v2598 == on;
              break;
            case "newMustBeUsed":
              var v2599 = setting[1];
              styleSettings.newMustBeUsed = v2599 == on;
              break;
            case "requireSemi":
              var v2600 = setting[1];
              styleSettings.requireSemi = v2600 == on;
              break;
            case "assignmentInCond":
              var v2601 = setting[1];
              styleSettings.assignmentInCond = v2601 == on;
              break;
            case "eqnull":
              var v2602 = setting[1];
              styleSettings.eqnull = v2602 == on;
              break;
            case "evalOK":
              var v2603 = setting[1];
              styleSettings.evalOK = v2603 == on;
              break;
            case "innerScopeDeclEscape":
              var v2604 = setting[1];
              styleSettings.innerScopeDeclEscape = v2604 == on;
              break;
            case "funcInLoop":
              var v2605 = setting[1];
              styleSettings.funcInLoop = v2605 == on;
              break;
            case "reDeclareLocal":
              var v2606 = setting[1];
              styleSettings.reDeclareLocal = v2606 == on;
              break;
            case "literalSubscript":
              var v2607 = setting[1];
              styleSettings.literalSubscript = v2607 == on;
              break;
            case "implicitAny":
              var v2608 = setting[1];
              styleSettings.implicitAny = v2608 == on;
          }
          i$$117 = i$$117 + 1;
          var v12948 = settings$$2.length;
          v2610 = i$$117 < v12948;
        }
      }
    }
    return;
  }
  function getReferencedFiles(sourceText$$4) {
    var preProcessInfo = preProcessFile(sourceText$$4, null, false);
    return preProcessInfo.referencedFiles;
  }
  function preProcessFile(sourceText$$5, options$$7, readImportFiles) {
    var v12949 = typeof options$$7;
    var v2611 = v12949 === "undefined";
    if (v2611) {
      options$$7 = new CompilationSettings;
    }
    var v12950 = typeof readImportFiles;
    var v2612 = v12950 === "undefined";
    if (v2612) {
      readImportFiles = true;
    }
    var v2613 = TypeScript$$29.Scanner;
    var scanner$$1 = new v2613;
    scanner$$1.resetComments();
    var v12951 = TypeScript$$29.LexMode;
    var v2614 = v12951.File;
    scanner$$1.setSourceText(sourceText$$5, v2614);
    var tok$$5 = scanner$$1.scan();
    var comments$$12 = [];
    var comment$$9 = null;
    var leftCurlies = [];
    var settings$$3 = options$$7;
    var referencedFiles = [];
    var importedFiles = [];
    var isLibFile = false;
    var v12952 = tok$$5.tokenId;
    var v19134 = TypeScript$$29.TokenID;
    var v12953 = v19134.EndOfFile;
    var v2626 = v12952 != v12953;
    for (;v2626;) {
      var v12954 = readImportFiles;
      if (v12954) {
        var v19135 = tok$$5.tokenId;
        var v23177 = TypeScript$$29.TokenID;
        var v19136 = v23177.Import;
        v12954 = v19135 == v19136;
      }
      var v2623 = v12954;
      if (v2623) {
        tok$$5 = scanner$$1.scan();
        var v19137 = tok$$5.tokenId;
        var v23178 = TypeScript$$29.TokenID;
        var v19138 = v23178.Identifier;
        var v12955 = v19137 == v19138;
        var v19139 = !v12955;
        if (v19139) {
          v12955 = TypeScript$$29.convertTokToID(tok$$5, false);
        }
        var v2622 = v12955;
        if (v2622) {
          tok$$5 = scanner$$1.scan();
          var v12956 = tok$$5.tokenId;
          var v19140 = TypeScript$$29.TokenID;
          var v12957 = v19140.Equals;
          var v2621 = v12956 == v12957;
          if (v2621) {
            tok$$5 = scanner$$1.scan();
            var v12958 = tok$$5.tokenId;
            var v19141 = TypeScript$$29.TokenID;
            var v12959 = v19141.Module;
            var v2620 = v12958 == v12959;
            if (v2620) {
              tok$$5 = scanner$$1.scan();
              var v12960 = tok$$5.tokenId;
              var v19142 = TypeScript$$29.TokenID;
              var v12961 = v19142.OpenParen;
              var v2619 = v12960 == v12961;
              if (v2619) {
                tok$$5 = scanner$$1.scan();
                var v12962 = tok$$5.tokenId;
                var v19143 = TypeScript$$29.TokenID;
                var v12963 = v19143.StringLiteral;
                var v2618 = v12962 == v12963;
                if (v2618) {
                  var v2615 = scanner$$1.startPos;
                  var v2616 = scanner$$1.pos;
                  var v19144 = tok$$5.getText();
                  var v12964 = TypeScript$$29.switchToForwardSlashes(v19144);
                  var v2617 = TypeScript$$29.stripQuotes(v12964);
                  var ref$$2 = {minChar:v2615, limChar:v2616, path:v2617, isResident:false};
                  importedFiles.push(ref$$2);
                }
              }
            }
          }
        }
      }
      var v12965 = tok$$5.tokenId;
      var v19145 = TypeScript$$29.TokenID;
      var v12966 = v19145.OpenBrace;
      var v2624 = v12965 == v12966;
      if (v2624) {
        leftCurlies.push(tok$$5);
      }
      var v12967 = tok$$5.tokenId;
      var v19146 = TypeScript$$29.TokenID;
      var v12968 = v19146.CloseBrace;
      var v2625 = v12967 == v12968;
      if (v2625) {
        leftCurlies.pop();
      }
      tok$$5 = scanner$$1.scan();
      var v12969 = tok$$5.tokenId;
      var v19147 = TypeScript$$29.TokenID;
      var v12970 = v19147.EndOfFile;
      v2626 = v12969 != v12970;
    }
    comments$$12 = scanner$$1.getComments();
    var iComment = 0;
    var v12971 = comments$$12.length;
    var v2639 = iComment < v12971;
    for (;v2639;) {
      comment$$9 = comments$$12[iComment];
      var v12972 = comment$$9.isBlock;
      var v2638 = !v12972;
      if (v2638) {
        var referencedCode;
        JSCompiler_inline_label_getFileReferenceFromReferencePath_29: {
          var comment$$inline_23 = comment$$9.getText();
          var referencesRegEx$$inline_24 = /^(\/\/\/\s*<reference\s+path=)('|")(.+?)\2\s*(static=('|")(.+?)\2\s*)*\/>/igm;
          var match$$inline_25 = referencesRegEx$$inline_24.exec(comment$$inline_23);
          if (match$$inline_25) {
            var v2627 = match$$inline_25[3];
            var path$$inline_26 = TypeScript$$29.normalizePath(v2627);
            var adjustedPath$$inline_27 = TypeScript$$29.normalizePath(path$$inline_26);
            var v12973 = match$$inline_25.length;
            var v2628 = v12973 >= 7;
            if (v2628) {
              var v12974 = match$$inline_25[6];
              v2628 = v12974 == "true";
            }
            var isResident$$inline_28 = v2628;
            if (isResident$$inline_28) {
              var v2629 = TypeScript$$29.CompilerDiagnostics;
              var v2630 = path$$inline_26 + " is resident";
              v2629.debugPrint(v2630);
            }
            var v2631 = TypeScript$$29.switchToForwardSlashes(adjustedPath$$inline_27);
            referencedCode = {minChar:0, limChar:0, path:v2631, isResident:isResident$$inline_28};
          } else {
            referencedCode = null;
          }
        }
        if (referencedCode) {
          referencedCode.minChar = comment$$9.startPos;
          var v2632 = referencedCode.minChar;
          var v12975 = comment$$9.value;
          var v2633 = v12975.length;
          referencedCode.limChar = v2632 + v2633;
          referencedFiles.push(referencedCode);
        }
        if (settings$$3) {
          var v2634 = comment$$9.getText();
          var v2635 = settings$$3.styleSettings;
          getStyleSettings(v2634, v2635);
          var isNoLibRegex = /^(\/\/\/\s*<reference\s+no-default-lib=)('|")(.+?)\2\s*\/>/igm;
          var v2636 = comment$$9.getText();
          var isNoLibMatch = isNoLibRegex.exec(v2636);
          if (isNoLibMatch) {
            var v2637 = isNoLibMatch[3];
            isLibFile = v2637 == "true";
          }
        }
      }
      iComment = iComment + 1;
      var v12976 = comments$$12.length;
      v2639 = iComment < v12976;
    }
    return{settings:settings$$3, referencedFiles:referencedFiles, importedFiles:importedFiles, isLibFile:isLibFile};
  }
  var StyleSettings = v1183();
  TypeScript$$29.StyleSettings = StyleSettings;
  var CompilationSettings = v1185();
  TypeScript$$29.CompilationSettings = CompilationSettings;
  TypeScript$$29.getAdditionalDependencyPath = getAdditionalDependencyPath;
  TypeScript$$29.getImplicitImport = getImplicitImport;
  TypeScript$$29.getStyleSettings = getStyleSettings;
  TypeScript$$29.getReferencedFiles = getReferencedFiles;
  TypeScript$$29.preProcessFile = preProcessFile;
  return;
}
function v1180(TypeScript$$28) {
  function v1179() {
    function v1178(referencePath, parentPath, performSearch, resolutionDispatcher) {
      var resolvedFile = {content:"", path:referencePath};
      var v2640 = this.environment;
      var ioHost$$1 = v2640.ioHost;
      var isRelativePath = TypeScript$$28.isRelative(referencePath);
      var v2641;
      if (isRelativePath) {
        v2641 = false;
      } else {
        v2641 = TypeScript$$28.isRooted(referencePath);
      }
      var isRootedPath = v2641;
      var v2642;
      if (isRelativePath) {
        var v19148 = parentPath + "/";
        var v12977 = v19148 + referencePath;
        v2642 = ioHost$$1.resolvePath(v12977);
      } else {
        var v12978;
        var v25172 = isRootedPath;
        var v26034 = !v25172;
        if (v26034) {
          v25172 = !parentPath;
        }
        var v23179 = v25172;
        var v25173 = !v23179;
        if (v25173) {
          v23179 = performSearch;
        }
        var v19150 = v23179;
        if (v19150) {
          v12978 = referencePath;
        } else {
          var v19149 = parentPath + "/";
          v12978 = v19149 + referencePath;
        }
        v2642 = v12978;
      }
      var normalizedPath = v2642;
      var v19151 = TypeScript$$28.isSTRFile(normalizedPath);
      var v12979 = !v19151;
      if (v12979) {
        var v19152 = TypeScript$$28.isTSFile(normalizedPath);
        v12979 = !v19152;
      }
      var v2643 = v12979;
      if (v2643) {
        normalizedPath = normalizedPath + ".ts";
      }
      var v2644 = TypeScript$$28.stripQuotes(normalizedPath);
      normalizedPath = TypeScript$$28.switchToForwardSlashes(v2644);
      var v2645;
      var v23180 = this.environment;
      var v19153 = v23180.compilationSettings;
      var v12980 = v19153.useCaseSensitiveFileResolution;
      if (v12980) {
        v2645 = normalizedPath;
      } else {
        v2645 = normalizedPath.toLocaleUpperCase();
      }
      var absoluteModuleID = v2645;
      var v19154 = this.visited;
      var v12981 = v19154[absoluteModuleID];
      var v2690 = !v12981;
      if (v2690) {
        var v12982 = isRelativePath || isRootedPath;
        var v19155 = !v12982;
        if (v19155) {
          v12982 = !performSearch;
        }
        var v2676 = v12982;
        if (v2676) {
          try {
            var v2646 = TypeScript$$28.CompilerDiagnostics;
            var v2647 = "   Reading code from " + normalizedPath;
            v2646.debugPrint(v2647);
            try {
              var v2648 = resolvedFile;
              var v26794 = ioHost$$1.readFile(normalizedPath);
              v2648.content = v26794;
            } catch (err) {
              try {
                var v2650 = TypeScript$$28.isSTRFile(normalizedPath);
                if (v2650) {
                  normalizedPath = TypeScript$$28.changePathToTS(normalizedPath);
                } else {
                  var v2649 = TypeScript$$28.isTSFile(normalizedPath);
                  if (v2649) {
                    normalizedPath = TypeScript$$28.changePathToSTR(normalizedPath);
                  }
                }
                var v2651 = TypeScript$$28.CompilerDiagnostics;
                var v2652 = "   Reading code from " + normalizedPath;
                v2651.debugPrint(v2652);
                var v2653 = resolvedFile;
                var v26795 = ioHost$$1.readFile(normalizedPath);
                v2653.content = v26795;
              } catch (err$$1) {
                normalizedPath = TypeScript$$28.changePathToDSTR(normalizedPath);
                var v2654 = TypeScript$$28.CompilerDiagnostics;
                var v2655 = "   Reading code from " + normalizedPath;
                v2654.debugPrint(v2655);
                try {
                  var v2656 = resolvedFile;
                  var v26796 = ioHost$$1.readFile(normalizedPath);
                  v2656.content = v26796;
                } catch (err$$2) {
                  normalizedPath = TypeScript$$28.changePathToDTS(normalizedPath);
                  var v2657 = TypeScript$$28.CompilerDiagnostics;
                  var v2658 = "   Reading code from " + normalizedPath;
                  v2657.debugPrint(v2658);
                  var v2659 = resolvedFile;
                  var v26797 = ioHost$$1.readFile(normalizedPath);
                  v2659.content = v26797;
                }
              }
            }
            var v2660 = TypeScript$$28.CompilerDiagnostics;
            var v2661 = "   Found code at " + normalizedPath;
            v2660.debugPrint(v2661);
            resolvedFile.path = normalizedPath;
            var v2662 = this.visited;
            v2662[absoluteModuleID] = true;
          } catch (err$$3) {
            var v2663 = TypeScript$$28.CompilerDiagnostics;
            var v2664 = "   Did not find code for " + referencePath;
            v2663.debugPrint(v2664);
          }
        } else {
          resolvedFile = ioHost$$1.findFile(parentPath, normalizedPath);
          var v2667 = !resolvedFile;
          if (v2667) {
            var v2666 = TypeScript$$28.isSTRFile(normalizedPath);
            if (v2666) {
              normalizedPath = TypeScript$$28.changePathToTS(normalizedPath);
            } else {
              var v2665 = TypeScript$$28.isTSFile(normalizedPath);
              if (v2665) {
                normalizedPath = TypeScript$$28.changePathToSTR(normalizedPath);
              }
            }
            resolvedFile = ioHost$$1.findFile(parentPath, normalizedPath);
          }
          var v2669 = !resolvedFile;
          if (v2669) {
            normalizedPath = TypeScript$$28.changePathToDTS(normalizedPath);
            resolvedFile = ioHost$$1.findFile(parentPath, normalizedPath);
            var v2668 = !resolvedFile;
            if (v2668) {
              normalizedPath = TypeScript$$28.changePathToDSTR(normalizedPath);
              resolvedFile = ioHost$$1.findFile(parentPath, normalizedPath);
            }
          }
          if (resolvedFile) {
            var v2670 = resolvedFile;
            var v19156 = resolvedFile.path;
            var v12983 = TypeScript$$28.stripQuotes(v19156);
            var v26798 = TypeScript$$28.switchToForwardSlashes(v12983);
            v2670.path = v26798;
            var v2671 = TypeScript$$28.CompilerDiagnostics;
            var v12984 = referencePath + " resolved to: ";
            var v12985 = resolvedFile.path;
            var v2672 = v12984 + v12985;
            v2671.debugPrint(v2672);
            resolvedFile.content = resolvedFile.content;
            var v2673 = this.visited;
            v2673[absoluteModuleID] = true;
          } else {
            var v2674 = TypeScript$$28.CompilerDiagnostics;
            var v2675 = "Could not find " + referencePath;
            v2674.debugPrint(v2675);
          }
        }
        var v12986 = resolvedFile;
        if (v12986) {
          v12986 = resolvedFile.content;
        }
        var v2689 = v12986;
        if (v2689) {
          var v2677 = resolvedFile.path;
          var rootDir = ioHost$$1.dirName(v2677);
          var v2678 = resolvedFile.path;
          var v2679 = resolvedFile.content;
          var sourceUnit = new SourceUnit(v2678, v2679);
          var v12987 = this.environment;
          var v2680 = v12987.compilationSettings;
          var preProcessedFileInfo = TypeScript$$28.preProcessFile(sourceUnit, v2680);
          sourceUnit.referencedFiles = preProcessedFileInfo.referencedFiles;
          var i$$116 = 0;
          var v19157 = preProcessedFileInfo.referencedFiles;
          var v12988 = v19157.length;
          var v2685 = i$$116 < v12988;
          for (;v2685;) {
            var v2681 = preProcessedFileInfo.referencedFiles;
            var referencedFile = v2681[i$$116];
            var v2682;
            var v19158 = referencedFile.path;
            var v12991 = TypeScript$$28.isRooted(v19158);
            if (v12991) {
              v2682 = referencedFile.path;
            } else {
              var v12989 = rootDir + "/";
              var v12990 = referencedFile.path;
              v2682 = v12989 + v12990;
            }
            normalizedPath = v2682;
            normalizedPath = ioHost$$1.resolvePath(normalizedPath);
            var v2683 = referencePath == normalizedPath;
            if (v2683) {
              resolutionDispatcher.postResolutionError(normalizedPath, "File contains reference to itself", null);
              i$$116 = i$$116 + 1;
              var v19159 = preProcessedFileInfo.referencedFiles;
              var v12992 = v19159.length;
              v2685 = i$$116 < v12992;
              continue;
            }
            var v2684 = referencedFile.path;
            this.resolveCode(v2684, rootDir, false, resolutionDispatcher);
            i$$116 = i$$116 + 1;
            var v19160 = preProcessedFileInfo.referencedFiles;
            var v12993 = v19160.length;
            v2685 = i$$116 < v12993;
          }
          i$$116 = 0;
          var v19161 = preProcessedFileInfo.importedFiles;
          var v12994 = v19161.length;
          var v2687 = i$$116 < v12994;
          for (;v2687;) {
            var v19162 = preProcessedFileInfo.importedFiles;
            var v12995 = v19162[i$$116];
            var v2686 = v12995.path;
            this.resolveCode(v2686, rootDir, true, resolutionDispatcher);
            i$$116 = i$$116 + 1;
            var v19163 = preProcessedFileInfo.importedFiles;
            var v12996 = v19163.length;
            v2687 = i$$116 < v12996;
          }
          var v2688 = sourceUnit.path;
          resolutionDispatcher.postResolution(v2688, sourceUnit);
        }
      }
      return;
    }
    function CodeResolver$$1(environment) {
      this.environment = environment;
      this.visited = {};
      return;
    }
    var v2691 = CodeResolver$$1.prototype;
    v2691.resolveCode = v1178;
    return CodeResolver$$1;
  }
  function v1177() {
    function CompilationEnvironment$$1(compilationSettings, ioHost) {
      this.compilationSettings = compilationSettings;
      this.ioHost = ioHost;
      this.residentCode = [];
      this.code = [];
      return;
    }
    return CompilationEnvironment$$1;
  }
  function v1176() {
    function v1175() {
      var v2692 = this.content;
      return v2692.length;
    }
    function v1174(start$$12, end$$6) {
      var v2693 = this.content;
      return v2693.substring(start$$12, end$$6);
    }
    function SourceUnit$$1(path$$16, content$$5) {
      this.path = path$$16;
      this.content = content$$5;
      this.referencedFiles = null;
      return;
    }
    var v2694 = SourceUnit$$1.prototype;
    v2694.getText = v1174;
    var v2695 = SourceUnit$$1.prototype;
    v2695.getLength = v1175;
    return SourceUnit$$1;
  }
  var SourceUnit = v1176();
  TypeScript$$28.SourceUnit = SourceUnit;
  var CompilationEnvironment = v1177();
  TypeScript$$28.CompilationEnvironment = CompilationEnvironment;
  var CodeResolver = v1179();
  TypeScript$$28.CodeResolver = CodeResolver;
  return;
}
function v1173(TypeScript$$27) {
  function stripQuotes(str$$7) {
    var v19164 = str$$7.replace('"', "");
    var v12997 = v19164.replace("'", "");
    var v2696 = v12997.replace("'", "");
    return v2696.replace('"', "");
  }
  function isQuoted(str$$8) {
    var v23181 = str$$8.indexOf('"');
    var v19165 = v23181 != -1;
    var v23183 = !v19165;
    if (v23183) {
      var v23182 = str$$8.indexOf("'");
      v19165 = v23182 != -1;
    }
    var v12998 = v19165;
    var v19167 = !v12998;
    if (v19167) {
      var v19166 = str$$8.indexOf("'");
      v12998 = v19166 != -1;
    }
    var v2697 = v12998;
    var v13000 = !v2697;
    if (v13000) {
      var v12999 = str$$8.indexOf('"');
      v2697 = v12999 != -1;
    }
    return v2697;
  }
  function quoteStr(str$$9) {
    var v2698 = '"' + str$$9;
    return v2698 + '"';
  }
  function swapQuotes(str$$10) {
    var v13001 = str$$10.indexOf('"');
    var v2699 = v13001 != -1;
    if (v2699) {
      str$$10 = str$$10.replace('"', "'");
      str$$10 = str$$10.replace('"', "'");
    } else {
      str$$10 = str$$10.replace("'", '"');
      str$$10 = str$$10.replace("'", '"');
    }
    return str$$10;
  }
  function switchToForwardSlashes(path$$8) {
    return path$$8.replace(/\\/g, "/");
  }
  function trimModName(modName$$4) {
    var v19168 = modName$$4.length;
    var v13002 = v19168 > 6;
    if (v13002) {
      var v25174 = modName$$4.length;
      var v23184 = v25174 - 6;
      var v23185 = modName$$4.length;
      var v19169 = modName$$4.substring(v23184, v23185);
      v13002 = v19169 == ".d.str";
    }
    var v2701 = v13002;
    if (v2701) {
      var v13003 = modName$$4.length;
      var v2700 = v13003 - 6;
      return modName$$4.substring(0, v2700);
    }
    var v19170 = modName$$4.length;
    var v13004 = v19170 > 4;
    if (v13004) {
      var v25175 = modName$$4.length;
      var v23186 = v25175 - 4;
      var v23187 = modName$$4.length;
      var v19171 = modName$$4.substring(v23186, v23187);
      v13004 = v19171 == ".str";
    }
    var v2703 = v13004;
    if (v2703) {
      var v13005 = modName$$4.length;
      var v2702 = v13005 - 4;
      return modName$$4.substring(0, v2702);
    }
    var v19172 = modName$$4.length;
    var v13006 = v19172 > 5;
    if (v13006) {
      var v25176 = modName$$4.length;
      var v23188 = v25176 - 5;
      var v23189 = modName$$4.length;
      var v19173 = modName$$4.substring(v23188, v23189);
      v13006 = v19173 == ".d.ts";
    }
    var v2705 = v13006;
    if (v2705) {
      var v13007 = modName$$4.length;
      var v2704 = v13007 - 5;
      return modName$$4.substring(0, v2704);
    }
    var v19174 = modName$$4.length;
    var v13008 = v19174 > 3;
    if (v13008) {
      var v25177 = modName$$4.length;
      var v23190 = v25177 - 3;
      var v23191 = modName$$4.length;
      var v19175 = modName$$4.substring(v23190, v23191);
      v13008 = v19175 == ".ts";
    }
    var v2707 = v13008;
    if (v2707) {
      var v13009 = modName$$4.length;
      var v2706 = v13009 - 3;
      return modName$$4.substring(0, v2706);
    }
    var v19176 = modName$$4.length;
    var v13010 = v19176 > 3;
    if (v13010) {
      var v25178 = modName$$4.length;
      var v23192 = v25178 - 3;
      var v23193 = modName$$4.length;
      var v19177 = modName$$4.substring(v23192, v23193);
      v13010 = v19177 == ".js";
    }
    var v2709 = v13010;
    if (v2709) {
      var v13011 = modName$$4.length;
      var v2708 = v13011 - 3;
      return modName$$4.substring(0, v2708);
    }
    return modName$$4;
  }
  function getDeclareFilePath(fname) {
    var v2710;
    var v13013 = isSTRFile(fname);
    if (v13013) {
      v2710 = changePathToDSTR(fname);
    } else {
      var v13012;
      var v19178 = isTSFile(fname);
      if (v19178) {
        v13012 = changePathToDTS(fname);
      } else {
        v13012 = changePathToDTS(fname);
      }
      v2710 = v13012;
    }
    return v2710;
  }
  function isFileOfExtension(fname$$1, ext) {
    var invariantFname = fname$$1.toLocaleUpperCase();
    var invariantExt = ext.toLocaleUpperCase();
    var extLength = invariantExt.length;
    var v13014 = invariantFname.length;
    var v2711 = v13014 > extLength;
    if (v2711) {
      var v23194 = invariantFname.length;
      var v19179 = v23194 - extLength;
      var v19180 = invariantFname.length;
      var v13015 = invariantFname.substring(v19179, v19180);
      v2711 = v13015 == invariantExt;
    }
    return v2711;
  }
  function isJSFile(fname$$2) {
    return isFileOfExtension(fname$$2, ".js");
  }
  function isSTRFile(fname$$3) {
    return isFileOfExtension(fname$$3, ".str");
  }
  function isTSFile(fname$$4) {
    return isFileOfExtension(fname$$4, ".ts");
  }
  function isDSTRFile(fname$$5) {
    return isFileOfExtension(fname$$5, ".d.str");
  }
  function isDTSFile(fname$$6) {
    return isFileOfExtension(fname$$6, ".d.ts");
  }
  function getPrettyName(modPath$$3, quote$$1, treatAsFileName) {
    var v13016 = typeof quote$$1;
    var v2712 = v13016 === "undefined";
    if (v2712) {
      quote$$1 = true;
    }
    var v13017 = typeof treatAsFileName;
    var v2713 = v13017 === "undefined";
    if (v2713) {
      treatAsFileName = false;
    }
    var v2714;
    if (treatAsFileName) {
      v2714 = switchToForwardSlashes(modPath$$3);
    } else {
      var v13018 = stripQuotes(modPath$$3);
      v2714 = trimModName(v13018);
    }
    var modName$$5 = v2714;
    var components = this.getPathComponents(modName$$5);
    var v2715;
    var v13020 = components.length;
    if (v13020) {
      var v13019;
      if (quote$$1) {
        var v25179 = components.length;
        var v23195 = v25179 - 1;
        var v19181 = components[v23195];
        v13019 = quoteStr(v19181);
      } else {
        var v23196 = components.length;
        var v19182 = v23196 - 1;
        v13019 = components[v19182];
      }
      v2715 = v13019;
    } else {
      v2715 = modPath$$3;
    }
    return v2715;
  }
  function getPathComponents(path$$9) {
    return path$$9.split("/");
  }
  function getRelativePathToFixedPath(fixedModFilePath, absoluteModPath) {
    absoluteModPath = switchToForwardSlashes(absoluteModPath);
    var modComponents = this.getPathComponents(absoluteModPath);
    var fixedModComponents = this.getPathComponents(fixedModFilePath);
    var joinStartIndex = 0;
    var v19183 = modComponents.length;
    var v13021 = joinStartIndex < v19183;
    if (v13021) {
      var v19184 = fixedModComponents.length;
      v13021 = joinStartIndex < v19184;
    }
    var v2717 = v13021;
    for (;v2717;) {
      var v13022 = fixedModComponents[joinStartIndex];
      var v13023 = modComponents[joinStartIndex];
      var v2716 = v13022 != v13023;
      if (v2716) {
        break;
      }
      joinStartIndex = joinStartIndex + 1;
      var v19185 = modComponents.length;
      var v13024 = joinStartIndex < v19185;
      if (v13024) {
        var v19186 = fixedModComponents.length;
        v13024 = joinStartIndex < v19186;
      }
      v2717 = v13024;
    }
    var v2723 = joinStartIndex != 0;
    if (v2723) {
      var relativePath = "";
      var v2718 = modComponents.length;
      var relativePathComponents = modComponents.slice(joinStartIndex, v2718);
      var v13025 = fixedModComponents.length;
      var v2720 = joinStartIndex < v13025;
      for (;v2720;) {
        var v13026 = fixedModComponents[joinStartIndex];
        var v2719 = v13026 != "";
        if (v2719) {
          relativePath = relativePath + "../";
        }
        joinStartIndex = joinStartIndex + 1;
        var v13027 = fixedModComponents.length;
        v2720 = joinStartIndex < v13027;
      }
      var v2721 = relativePath;
      var v2722 = relativePathComponents.join("/");
      return v2721 + v2722;
    }
    return absoluteModPath;
  }
  function quoteBaseName(modPath$$4) {
    var v2724 = stripQuotes(modPath$$4);
    var modName$$6 = trimModName(v2724);
    var path$$10 = getRootFilePath(modName$$6);
    var v2727 = path$$10 == "";
    if (v2727) {
      return modPath$$4;
    } else {
      var components$$1 = modName$$6.split(path$$10);
      var v2725;
      var v19187 = components$$1.length;
      var v13028 = v19187 > 1;
      if (v13028) {
        v2725 = 1;
      } else {
        v2725 = 0;
      }
      var fileIndex = v2725;
      var v2726 = components$$1[fileIndex];
      return quoteStr(v2726);
    }
    return;
  }
  function changePathToSTR(modPath$$5) {
    var v13029 = stripQuotes(modPath$$5);
    var v2728 = trimModName(v13029);
    return v2728 + ".str";
  }
  function changePathToDSTR(modPath$$6) {
    var v13030 = stripQuotes(modPath$$6);
    var v2729 = trimModName(v13030);
    return v2729 + ".d.str";
  }
  function changePathToTS(modPath$$7) {
    var v13031 = stripQuotes(modPath$$7);
    var v2730 = trimModName(v13031);
    return v2730 + ".ts";
  }
  function changePathToDTS(modPath$$8) {
    var v13032 = stripQuotes(modPath$$8);
    var v2731 = trimModName(v13032);
    return v2731 + ".d.ts";
  }
  function isRelative(path$$11) {
    var v2732 = path$$11.charAt(0);
    return v2732 == ".";
  }
  function isRooted(path$$12) {
    var v23197 = path$$12.charAt(0);
    var v19188 = v23197 == "\\";
    var v23199 = !v19188;
    if (v23199) {
      var v23198 = path$$12.charAt(0);
      v19188 = v23198 == "/";
    }
    var v13033 = v19188;
    var v19190 = !v13033;
    if (v19190) {
      var v19189 = path$$12.indexOf(":\\");
      v13033 = v19189 != -1;
    }
    var v2733 = v13033;
    var v13035 = !v2733;
    if (v13035) {
      var v13034 = path$$12.indexOf(":/");
      v2733 = v13034 != -1;
    }
    return v2733;
  }
  function getRootFilePath(outFname) {
    var v2736 = outFname == "";
    if (v2736) {
      return outFname;
    } else {
      var v2734 = outFname.indexOf("/");
      var isPath = v2734 != -1;
      var v2735;
      if (isPath) {
        v2735 = filePath(outFname);
      } else {
        v2735 = "";
      }
      return v2735;
    }
    return;
  }
  function filePathComponents(fullPath) {
    fullPath = switchToForwardSlashes(fullPath);
    var components$$2 = getPathComponents(fullPath);
    var v13036 = components$$2.length;
    var v2737 = v13036 - 1;
    return components$$2.slice(0, v2737);
  }
  function filePath(fullPath$$1) {
    var path$$13 = filePathComponents(fullPath$$1);
    var v2738 = path$$13.join("/");
    return v2738 + "/";
  }
  function normalizeURL(url$$2) {
    var hostDomainAndPortRegex = /^(https?:\/\/[\-\w\.]+(:\d+)?\/)(.*)$/i;
    var matches = hostDomainAndPortRegex.exec(url$$2);
    if (matches) {
      var hostDomainAndPort = matches[1];
      var actualPath = matches[3];
      var v2739 = hostDomainAndPort;
      var v2740 = normalizePath(actualPath);
      return v2739 + v2740;
    }
    return normalizePath(url$$2);
  }
  function normalizePath(path$$14) {
    path$$14 = switchToForwardSlashes(path$$14);
    var v2741 = path$$14.charAt(0);
    var startedWithSep = v2741 === "/";
    var parts = this.getPathComponents(path$$14);
    var i$$115 = 0;
    var v13037 = parts.length;
    var v2745 = i$$115 < v13037;
    for (;v2745;) {
      var v19191 = parts[i$$115];
      var v13038 = v19191 === ".";
      var v19193 = !v13038;
      if (v19193) {
        var v19192 = parts[i$$115];
        v13038 = v19192 === "";
      }
      var v2742 = v13038;
      if (v2742) {
        parts.splice(i$$115, 1);
        i$$115 = i$$115 - 1;
      }
      var v19194 = i$$115 > 0;
      if (v19194) {
        var v23200 = parts[i$$115];
        v19194 = v23200 === "..";
      }
      var v13039 = v19194;
      if (v13039) {
        var v23201 = i$$115 - 1;
        var v19195 = parts[v23201];
        v13039 = v19195 !== "..";
      }
      var v2744 = v13039;
      if (v2744) {
        var v2743 = i$$115 - 1;
        parts.splice(v2743, 2);
        i$$115 = i$$115 - 2;
      }
      i$$115 = i$$115 + 1;
      var v13040 = parts.length;
      v2745 = i$$115 < v13040;
    }
    var v13041;
    if (startedWithSep) {
      v13041 = "/";
    } else {
      v13041 = "";
    }
    var v2746 = v13041;
    var v2747 = parts.join("/");
    return v2746 + v2747;
  }
  function normalizeImportPath(path$$15) {
    return normalizePath(path$$15);
  }
  TypeScript$$27.stripQuotes = stripQuotes;
  TypeScript$$27.isQuoted = isQuoted;
  TypeScript$$27.quoteStr = quoteStr;
  TypeScript$$27.swapQuotes = swapQuotes;
  TypeScript$$27.switchToForwardSlashes = switchToForwardSlashes;
  TypeScript$$27.trimModName = trimModName;
  TypeScript$$27.getDeclareFilePath = getDeclareFilePath;
  TypeScript$$27.isJSFile = isJSFile;
  TypeScript$$27.isSTRFile = isSTRFile;
  TypeScript$$27.isTSFile = isTSFile;
  TypeScript$$27.isDSTRFile = isDSTRFile;
  TypeScript$$27.isDTSFile = isDTSFile;
  TypeScript$$27.getPrettyName = getPrettyName;
  TypeScript$$27.getPathComponents = getPathComponents;
  TypeScript$$27.getRelativePathToFixedPath = getRelativePathToFixedPath;
  TypeScript$$27.quoteBaseName = quoteBaseName;
  TypeScript$$27.changePathToSTR = changePathToSTR;
  TypeScript$$27.changePathToDSTR = changePathToDSTR;
  TypeScript$$27.changePathToTS = changePathToTS;
  TypeScript$$27.changePathToDTS = changePathToDTS;
  TypeScript$$27.isRelative = isRelative;
  TypeScript$$27.isRooted = isRooted;
  TypeScript$$27.getRootFilePath = getRootFilePath;
  TypeScript$$27.filePathComponents = filePathComponents;
  TypeScript$$27.filePath = filePath;
  TypeScript$$27.normalizeURL = normalizeURL;
  TypeScript$$27.pathNormalizeRegExp = /\//g;
  TypeScript$$27.normalizePath = normalizePath;
  TypeScript$$27.normalizeImportPath = normalizeImportPath;
  return;
}
function v1172(TypeScript$$26) {
  function v1171() {
    function TypeLink$$1() {
      this.type = null;
      this.ast = null;
      return;
    }
    return TypeLink$$1;
  }
  function v1170(_super$$67) {
    function v1169(moduleType$$2) {
      var moduleName$$2 = null;
      var v13042 = this.members;
      var v2748 = v13042.allMembers;
      moduleName$$2 = ModuleType$$1.findDynamicModuleNameInHashTable(moduleType$$2, v2748);
      var v2750 = moduleName$$2 == null;
      if (v2750) {
        var v13043 = this.ambientMembers;
        var v2749 = v13043.allMembers;
        moduleName$$2 = ModuleType$$1.findDynamicModuleNameInHashTable(moduleType$$2, v2749);
      }
      return moduleName$$2;
    }
    function findDynamicModuleNameInHashTable(moduleType$$1, members$$27) {
      function v1168(key$$51, s$$34, c$$13) {
        var v13044 = moduleName$$1 == null;
        if (v13044) {
          var v19196 = TypeScript$$26.isQuoted(key$$51);
          v13044 = !v19196;
        }
        var v2752 = v13044;
        if (v2752) {
          var symbol$$22 = s$$34;
          var type$$57 = symbol$$22.getType();
          var v2751 = type$$57 == moduleType$$1;
          if (v2751) {
            moduleName$$1 = {name:key$$51, symbol:symbol$$22};
          }
        }
        return;
      }
      var moduleName$$1 = null;
      members$$27.map(v1168, null);
      return moduleName$$1;
    }
    function v1167() {
      return null;
    }
    function v1166() {
      return null;
    }
    function v1165() {
      return this.ambientEnclosedTypes;
    }
    function v1164() {
      return this.enclosedTypes;
    }
    function v1163() {
      var v13045 = this.members;
      var v2753 = v13045 != null;
      var v13047 = !v2753;
      if (v13047) {
        var v13046 = this.enclosedTypes;
        v2753 = v13046 != null;
      }
      return v2753;
    }
    function v1162() {
      return true;
    }
    function ModuleType$$1(enclosedTypes$$4, ambientEnclosedTypes$$4) {
      _super$$67.call(this);
      this.enclosedTypes = enclosedTypes$$4;
      this.ambientEnclosedTypes = ambientEnclosedTypes$$4;
      this.importedModules = [];
      return;
    }
    __extends(ModuleType$$1, _super$$67);
    var v2754 = ModuleType$$1.prototype;
    v2754.isModuleType = v1162;
    var v2755 = ModuleType$$1.prototype;
    v2755.hasMembers = v1163;
    var v2756 = ModuleType$$1.prototype;
    v2756.getAllEnclosedTypes = v1164;
    var v2757 = ModuleType$$1.prototype;
    v2757.getAllAmbientEnclosedTypes = v1165;
    var v2758 = ModuleType$$1.prototype;
    v2758.getPublicEnclosedTypes = v1166;
    var v2759 = ModuleType$$1.prototype;
    v2759.getpublicAmbientEnclosedTypes = v1167;
    ModuleType$$1.findDynamicModuleNameInHashTable = findDynamicModuleNameInHashTable;
    var v2760 = ModuleType$$1.prototype;
    v2760.findDynamicModuleName = v1169;
    return ModuleType$$1;
  }
  function v1161() {
    function v1160() {
      var v13048 = this.elementType;
      var v19198 = !v13048;
      if (v19198) {
        var v19197 = this.symbol;
        v13048 = !v19197;
      }
      var v2761 = v13048;
      if (v2761) {
        return[];
      }
      var v13049 = this.isClassInstance();
      var v19199 = !v13049;
      if (v19199) {
        v13049 = this.isClass();
      }
      var v2765 = v13049;
      if (v2765) {
        var v23202 = this.symbol;
        var v19200 = v23202.declAST;
        var v13050 = v19200.nodeType;
        var v19201 = TypeScript$$26.NodeType;
        var v13051 = v19201.FuncDecl;
        var v2764 = v13050 == v13051;
        if (v2764) {
          var v19202 = this.symbol;
          var v13052 = v19202.declAST;
          var v2762 = v13052.classDecl;
          return v2762.getDocComments();
        } else {
          var v2763 = this.symbol;
          return v2763.getDocComments();
        }
      }
      var v23203 = this.symbol;
      var v19203 = v23203.name;
      if (v19203) {
        var v25180 = this.symbol;
        var v23204 = v25180.name;
        v19203 = v23204 != "_anonymous";
      }
      var v13053 = v19203;
      if (v13053) {
        var v26035 = this.call;
        var v25181 = v26035 == null;
        if (v25181) {
          var v26036 = this.construct;
          v25181 = v26036 == null;
        }
        var v23205 = v25181;
        if (v23205) {
          var v25182 = this.index;
          v23205 = v25182 == null;
        }
        var v19204 = v23205;
        var v23206 = !v19204;
        if (v23206) {
          v19204 = this.members;
        }
        v13053 = v19204;
      }
      var v2767 = v13053;
      if (v2767) {
        var v2766 = this.symbol;
        return v2766.getDocComments();
      }
      return[];
    }
    function v1159() {
      return null;
    }
    function v1158() {
      return null;
    }
    function v1157() {
      return null;
    }
    function v1156() {
      return null;
    }
    function v1155() {
      var v2768 = this.members;
      return v2768 != null;
    }
    function v1154() {
      return false;
    }
    function v1153(b$$14, checker$$22, acceptVoid$$1, comparisonInfo$$17) {
      var v19205 = checker$$22.anyType;
      var v13054 = this == v19205;
      var v19207 = !v13054;
      if (v19207) {
        var v19206 = checker$$22.anyType;
        v13054 = b$$14 == v19206;
      }
      var v2784 = v13054;
      if (v2784) {
        return checker$$22.anyType;
      } else {
        var v2783 = this == b$$14;
        if (v2783) {
          return this;
        } else {
          var v19208 = checker$$22.nullType;
          var v13055 = b$$14 == v19208;
          if (v13055) {
            var v19209 = checker$$22.nullType;
            v13055 = this != v19209;
          }
          var v2782 = v13055;
          if (v2782) {
            return this;
          } else {
            var v19210 = checker$$22.nullType;
            var v13056 = this == v19210;
            if (v13056) {
              var v19211 = checker$$22.nullType;
              v13056 = b$$14 != v19211;
            }
            var v2781 = v13056;
            if (v2781) {
              return b$$14;
            } else {
              var v19212 = acceptVoid$$1;
              if (v19212) {
                var v23207 = checker$$22.voidType;
                v19212 = b$$14 == v23207;
              }
              var v13057 = v19212;
              if (v13057) {
                var v19213 = checker$$22.voidType;
                v13057 = this != v19213;
              }
              var v2780 = v13057;
              if (v2780) {
                return this;
              } else {
                var v19214 = acceptVoid$$1;
                if (v19214) {
                  var v23208 = checker$$22.voidType;
                  v19214 = this == v23208;
                }
                var v13058 = v19214;
                if (v13058) {
                  var v19215 = checker$$22.voidType;
                  v13058 = b$$14 != v19215;
                }
                var v2779 = v13058;
                if (v2779) {
                  return b$$14;
                } else {
                  var v19216 = checker$$22.undefinedType;
                  var v13059 = b$$14 == v19216;
                  if (v13059) {
                    var v19217 = checker$$22.undefinedType;
                    v13059 = this != v19217;
                  }
                  var v2778 = v13059;
                  if (v2778) {
                    return this;
                  } else {
                    var v19218 = checker$$22.undefinedType;
                    var v13060 = this == v19218;
                    if (v13060) {
                      var v19219 = checker$$22.undefinedType;
                      v13060 = b$$14 != v19219;
                    }
                    var v2777 = v13060;
                    if (v2777) {
                      return b$$14;
                    } else {
                      var v13061 = this.elementType;
                      if (v13061) {
                        v13061 = b$$14.elementType;
                      }
                      var v2776 = v13061;
                      if (v2776) {
                        var v13062 = this.elementType;
                        var v13063 = b$$14.elementType;
                        var v2773 = v13062 == v13063;
                        if (v2773) {
                          return this;
                        } else {
                          var v2769 = this.elementType;
                          var v2770 = b$$14.elementType;
                          var mergedET = v2769.mergeOrdered(v2770, checker$$22, acceptVoid$$1, comparisonInfo$$17);
                          var v2772 = mergedET == null;
                          if (v2772) {
                            var v2771 = checker$$22.anyType;
                            return checker$$22.makeArrayType(v2771);
                          } else {
                            return checker$$22.makeArrayType(mergedET);
                          }
                        }
                      } else {
                        var v2775 = checker$$22.sourceIsSubtypeOfTarget(this, b$$14, comparisonInfo$$17);
                        if (v2775) {
                          return b$$14;
                        } else {
                          var v2774 = checker$$22.sourceIsSubtypeOfTarget(b$$14, this, comparisonInfo$$17);
                          if (v2774) {
                            return this;
                          } else {
                            return null;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      return;
    }
    function v1152(baseType) {
      var v2789 = baseType == this;
      if (v2789) {
        return true;
      } else {
        var v2788 = this.extendsList;
        if (v2788) {
          var i$$114 = 0;
          var v2785 = this.extendsList;
          var len$$56 = v2785.length;
          var v2787 = i$$114 < len$$56;
          for (;v2787;) {
            var v19220 = this.extendsList;
            var v13064 = v19220[i$$114];
            var v2786 = v13064.hasBase(baseType);
            if (v2786) {
              return true;
            }
            i$$114 = i$$114 + 1;
            v2787 = i$$114 < len$$56;
          }
        }
      }
      return false;
    }
    function v1151(pattern$$8, replacement$$6, checker$$21, membersOnly) {
      function v1150(key$$50, s$$33, unused$$5) {
        var sym$$48 = s$$33;
        var bSym$$4 = sym$$48.specializeType(pattern$$8, replacement$$6, checker$$21);
        var v2790 = result$$33.ambientMembers;
        var v2791 = bSym$$4.name;
        v2790.addPrivateMember(v2791, bSym$$4);
        return;
      }
      function v1149(key$$49, s$$32, unused$$4) {
        var sym$$47 = s$$32;
        var bSym$$3 = sym$$47.specializeType(pattern$$8, replacement$$6, checker$$21);
        var v2792 = result$$33.ambientMembers;
        var v2793 = bSym$$3.name;
        v2792.addPublicMember(v2793, bSym$$3);
        return;
      }
      function v1148(key$$48, s$$31, unused$$3) {
        var sym$$46 = s$$31;
        var bSym$$2 = sym$$46.specializeType(pattern$$8, replacement$$6, checker$$21);
        var v2794 = result$$33.members;
        var v2795 = bSym$$2.name;
        v2794.addPrivateMember(v2795, bSym$$2);
        return;
      }
      function v1147(key$$47, s$$30, unused$$2) {
        var sym$$45 = s$$30;
        var bSym$$1 = sym$$45.specializeType(pattern$$8, replacement$$6, checker$$21);
        var v2796 = result$$33.members;
        var v2797 = bSym$$1.name;
        v2796.addPublicMember(v2797, bSym$$1);
        return;
      }
      var v2798 = pattern$$8 == this;
      if (v2798) {
        return replacement$$6;
      }
      var result$$33 = this;
      if (membersOnly) {
        var v2808 = this.isReferenceType();
        if (v2808) {
          result$$33 = new Type$$1;
          var v2802 = this.members;
          if (v2802) {
            var v2799 = result$$33;
            var v13065 = TypeScript$$26.ScopedMembers;
            var v19221 = TypeScript$$26.DualStringHashTable;
            var v23209 = TypeScript$$26.StringHashTable;
            var v19222 = new v23209;
            var v23210 = TypeScript$$26.StringHashTable;
            var v19223 = new v23210;
            var v13066 = new v19221(v19222, v19223);
            var v26799 = new v13065(v13066);
            v2799.members = v26799;
            var v13067 = this.members;
            var v2800 = v13067.publicMembers;
            v2800.map(v1147, null);
            var v13068 = this.members;
            var v2801 = v13068.privateMembers;
            v2801.map(v1148, null);
          }
          var v2806 = this.ambientMembers;
          if (v2806) {
            var v2803 = result$$33;
            var v13069 = TypeScript$$26.ScopedMembers;
            var v19224 = TypeScript$$26.DualStringHashTable;
            var v23211 = TypeScript$$26.StringHashTable;
            var v19225 = new v23211;
            var v23212 = TypeScript$$26.StringHashTable;
            var v19226 = new v23212;
            var v13070 = new v19224(v19225, v19226);
            var v26800 = new v13069(v13070);
            v2803.ambientMembers = v26800;
            var v13071 = this.ambientMembers;
            var v2804 = v13071.publicMembers;
            v2804.map(v1149, null);
            var v13072 = this.ambientMembers;
            var v2805 = v13072.privateMembers;
            v2805.map(v1150, null);
          }
          var v2807 = result$$33;
          var v26801 = checker$$21.scopeOf(result$$33);
          v2807.containedScope = v26801;
          result$$33.memberScope = result$$33.containedScope;
        }
      } else {
        var v2814 = this.elementType;
        if (v2814) {
          var v13073 = this.elementType;
          var v2811 = v13073 == pattern$$8;
          if (v2811) {
            result$$33 = checker$$21.makeArrayType(replacement$$6);
          } else {
            var v19227 = this.elementType;
            var v13074 = v19227.elementType;
            var v2810 = v13074 == pattern$$8;
            if (v2810) {
              var v2809 = checker$$21.makeArrayType(replacement$$6);
              result$$33 = checker$$21.makeArrayType(v2809);
            }
          }
        } else {
          var v2813 = this.call;
          if (v2813) {
            result$$33 = new Type$$1;
            var v2812 = result$$33;
            var v13075 = this.call;
            var v26802 = v13075.specializeType(pattern$$8, replacement$$6, checker$$21);
            v2812.call = v26802;
          }
        }
      }
      return result$$33;
    }
    function v1146() {
      var v25183 = this.members;
      var v26037 = !v25183;
      if (v26037) {
        v25183 = this.extendsList;
      }
      var v23213 = v25183;
      var v25184 = !v23213;
      if (v25184) {
        v23213 = this.construct;
      }
      var v19228 = v23213;
      var v23214 = !v19228;
      if (v23214) {
        v19228 = this.call;
      }
      var v13076 = v19228;
      var v19229 = !v13076;
      if (v19229) {
        v13076 = this.index;
      }
      var v2815 = v13076;
      var v13077 = !v2815;
      if (v13077) {
        v2815 = this.elementType;
      }
      return v2815;
    }
    function v1145(flow$$1) {
      var v13078 = flow$$1.anyType;
      var v2830 = this == v13078;
      if (v2830) {
        return null;
      } else {
        var v2829 = this.isDouble();
        if (v2829) {
          var v2817 = flow$$1.numberInterfaceType;
          if (v2817) {
            var v2816 = flow$$1.numberInterfaceType;
            return v2816.memberScope;
          } else {
            return null;
          }
        } else {
          var v2828 = this.isBoolean();
          if (v2828) {
            var v2819 = flow$$1.booleanInterfaceType;
            if (v2819) {
              var v2818 = flow$$1.booleanInterfaceType;
              return v2818.memberScope;
            } else {
              return null;
            }
          } else {
            var v13079 = flow$$1.stringType;
            var v2827 = this == v13079;
            if (v2827) {
              var v2821 = flow$$1.stringInterfaceType;
              if (v2821) {
                var v2820 = flow$$1.stringInterfaceType;
                return v2820.memberScope;
              } else {
                return null;
              }
            } else {
              var v2826 = this.elementType;
              if (v2826) {
                var v2825 = flow$$1.arrayInterfaceType;
                if (v2825) {
                  var v2822 = this.elementType;
                  var v2823 = flow$$1.arrayInterfaceType;
                  var v2824 = flow$$1.checker;
                  var arrInstType$$3 = v2822.getArrayBase(v2823, v2824);
                  return arrInstType$$3.memberScope;
                } else {
                  return null;
                }
              } else {
                return this.memberScope;
              }
            }
          }
        }
      }
      return;
    }
    function v1144(checker$$20) {
      var v13080 = this.isClassInstance();
      var v19230 = !v13080;
      if (v19230) {
        v13080 = this.isClass();
      }
      var v2834 = v13080;
      if (v2834) {
        var v13081 = this.symbol;
        var v2833 = v13081.declAST;
        if (v2833) {
          var v2831 = checker$$20.typeFlow;
          var v13082 = this.symbol;
          var v2832 = v13082.declAST;
          v2831.inScopeTypeCheckDecl(v2832);
        }
      }
      return;
    }
    function v1143(prefix$$5, topLevel$$1, isElementType$$1, scope$$34) {
      function v1142(key$$46, s$$29, unused$$1) {
        var sym$$44 = s$$29;
        var v19231 = sym$$44.flags;
        var v23215 = TypeScript$$26.SymbolFlags;
        var v19232 = v23215.BuiltIn;
        var v13083 = TypeScript$$26.hasFlag(v19231, v19232);
        var v2837 = !v13083;
        if (v2837) {
          var typeNameMember = sym$$44.getTypeNameEx(scope$$34);
          var v13084 = typeNameMember.isArray();
          if (v13084) {
            var v19233 = typeNameMember.delim;
            v13084 = v19233 == delim;
          }
          var v2836 = v13084;
          if (v2836) {
            var v2835 = typeNameMember.entries;
            allMemberNames.addAll(v2835);
          } else {
            allMemberNames.add(typeNameMember);
          }
          memCount = memCount + 1;
          curlies$$1 = true;
        }
        return;
      }
      var v2857 = this.elementType;
      if (v2857) {
        var v13085 = this.elementType;
        var v2838 = v13085.getMemberTypeNameEx(prefix$$5, false, true, scope$$34);
        return MemberName.create(v2838, "", "[]");
      } else {
        var v23216 = this.symbol;
        if (v23216) {
          var v25185 = this.symbol;
          v23216 = v25185.name;
        }
        var v19234 = v23216;
        if (v19234) {
          var v25186 = this.symbol;
          var v23217 = v25186.name;
          v19234 = v23217 != "_anonymous";
        }
        var v13086 = v19234;
        if (v13086) {
          var v26414 = this.call;
          var v26038 = v26414 == null;
          if (v26038) {
            var v26415 = this.construct;
            v26038 = v26415 == null;
          }
          var v25187 = v26038;
          if (v25187) {
            var v26039 = this.index;
            v25187 = v26039 == null;
          }
          var v23218 = v25187;
          var v25190 = !v23218;
          if (v25190) {
            var v25188 = this.typeFlags;
            var v26040 = TypeScript$$26.TypeFlags;
            var v25189 = v26040.BuildingName;
            v23218 = TypeScript$$26.hasFlag(v25188, v25189);
          }
          var v19235 = v23218;
          var v23220 = !v19235;
          if (v23220) {
            var v23219 = this.members;
            if (v23219) {
              var v25191 = this.isClass();
              v23219 = !v25191;
            }
            v19235 = v23219;
          }
          v13086 = v19235;
        }
        var v2856 = v13086;
        if (v2856) {
          var v2839 = this.symbol;
          var tn = v2839.scopeRelativeName(scope$$34);
          var v13087;
          var v19236 = tn == "null";
          if (v19236) {
            v13087 = "any";
          } else {
            v13087 = tn;
          }
          var v2840 = v13087;
          return MemberName.create(v2840);
        } else {
          var v19237 = this.members;
          var v23221 = !v19237;
          if (v23221) {
            v19237 = this.call;
          }
          var v13088 = v19237;
          var v19238 = !v13088;
          if (v19238) {
            v13088 = this.construct;
          }
          var v2855 = v13088;
          if (v2855) {
            var v13089 = this.typeFlags;
            var v19239 = TypeScript$$26.TypeFlags;
            var v13090 = v19239.BuildingName;
            var v2841 = TypeScript$$26.hasFlag(v13089, v13090);
            if (v2841) {
              return MemberName.create("this");
            }
            var v13091 = this.typeFlags;
            var v19240 = TypeScript$$26.TypeFlags;
            var v13092 = v19240.BuildingName;
            this.typeFlags = v13091 | v13092;
            var builder$$5 = "";
            var allMemberNames = new MemberNameArray;
            var v2842 = isElementType$$1;
            var v13094 = !v2842;
            if (v13094) {
              var v13093 = this.index;
              v2842 = v13093 != null;
            }
            var curlies$$1 = v2842;
            var memCount = 0;
            var delim = "; ";
            var v2844 = this.members;
            if (v2844) {
              var v13095 = this.members;
              var v2843 = v13095.allMembers;
              v2843.map(v1142, null);
            }
            var signatureCount = this.callCount();
            var j$$18;
            var len$$55 = 0;
            var v13096 = !curlies$$1;
            if (v13096) {
              v13096 = signatureCount == 1;
            }
            var v2845 = v13096;
            if (v2845) {
              v2845 = topLevel$$1;
            }
            var shortform$$3 = v2845;
            var v2847 = this.call;
            if (v2847) {
              var v13097 = this.call;
              var v2846 = v13097.toStrings(prefix$$5, shortform$$3, scope$$34);
              allMemberNames.addAll(v2846);
            }
            var v2849 = this.construct;
            if (v2849) {
              var v13098 = this.construct;
              var v2848 = v13098.toStrings("new", shortform$$3, scope$$34);
              allMemberNames.addAll(v2848);
            }
            var v2851 = this.index;
            if (v2851) {
              var v13099 = this.index;
              var v2850 = v13099.toStrings("", shortform$$3, scope$$34);
              allMemberNames.addAll(v2850);
            }
            var v13100 = curlies$$1;
            var v19242 = !v13100;
            if (v19242) {
              var v19241 = signatureCount > 1;
              if (v19241) {
                v19241 = topLevel$$1;
              }
              v13100 = v19241;
            }
            var v2853 = v13100;
            if (v2853) {
              allMemberNames.prefix = "{ ";
              allMemberNames.suffix = "}";
              allMemberNames.delim = delim;
            } else {
              var v19243 = allMemberNames.entries;
              var v13101 = v19243.length;
              var v2852 = v13101 > 1;
              if (v2852) {
                allMemberNames.delim = delim;
              }
            }
            var v13102 = this.typeFlags;
            var v23222 = TypeScript$$26.TypeFlags;
            var v19244 = v23222.BuildingName;
            var v13103 = ~v19244;
            this.typeFlags = v13102 & v13103;
            var v13104 = signatureCount == 0;
            if (v13104) {
              v13104 = memCount == 0;
            }
            var v2854 = v13104;
            if (v2854) {
              return MemberName.create("{}");
            } else {
              return allMemberNames;
            }
          } else {
            return MemberName.create("{}");
          }
        }
      }
      return;
    }
    function v1141(prefix$$4, topLevel, isElementType, scope$$33) {
      var memberName$$4 = this.getMemberTypeNameEx(prefix$$4, topLevel, isElementType, scope$$33);
      return memberName$$4.toString();
    }
    function v1140() {
      var total = 0;
      var v2858 = this.call;
      if (v2858) {
        var v23223 = this.call;
        var v19245 = v23223.signatures;
        var v13105 = v19245.length;
        total = total + v13105;
      }
      var v2859 = this.construct;
      if (v2859) {
        var v23224 = this.construct;
        var v19246 = v23224.signatures;
        var v13106 = v19246.length;
        total = total + v13106;
      }
      var v2860 = this.index;
      if (v2860) {
        var v23225 = this.index;
        var v19247 = v23225.signatures;
        var v13107 = v19247.length;
        total = total + v13107;
      }
      return total;
    }
    function v1139(scope$$32) {
      return this.getMemberTypeNameEx("", true, false, scope$$32);
    }
    function v1138(scope$$31) {
      return this.getMemberTypeName("", true, false, scope$$31);
    }
    function v1137() {
      return this.getMemberTypeName("", true, false, null);
    }
    function v1136() {
      var v2861 = this.primitiveTypeClass;
      var v2862 = Primitive.Null;
      return TypeScript$$26.hasFlag(v2861, v2862);
    }
    function v1135() {
      var v2863 = this.primitiveTypeClass;
      var v2864 = Primitive.Boolean;
      return TypeScript$$26.hasFlag(v2863, v2864);
    }
    function v1134() {
      var v2865 = this.primitiveTypeClass;
      var v2866 = Primitive.String;
      return TypeScript$$26.hasFlag(v2865, v2866);
    }
    function v1133() {
      var v2867 = this.primitiveTypeClass;
      var v2868 = Primitive.Double;
      return TypeScript$$26.hasFlag(v2867, v2868);
    }
    function v1132() {
      var v13108 = this.typeFlags;
      var v19248 = TypeScript$$26.TypeFlags;
      var v13109 = v19248.HasImplementation;
      this.typeFlags = v13108 | v13109;
      return;
    }
    function v1131() {
      var v2869 = this.typeFlags;
      var v13110 = TypeScript$$26.TypeFlags;
      var v2870 = v13110.HasImplementation;
      return TypeScript$$26.hasFlag(v2869, v2870);
    }
    function v1130() {
      var v2871 = this.isClass();
      if (v2871) {
        return this.instanceType;
      } else {
        return this;
      }
      return;
    }
    function v1129() {
      var v13111 = this.symbol;
      if (v13111) {
        var v19249 = this.elementType;
        v13111 = !v19249;
      }
      var v2872 = v13111;
      if (v2872) {
        var v19250 = this.symbol;
        var v13112 = v19250.type;
        v2872 = v13112.isClass();
      }
      return v2872;
    }
    function v1128() {
      var v2873 = this.elementType;
      return v2873 != null;
    }
    function v1127() {
      var v2874 = this.instanceType;
      return v2874 != null;
    }
    function v1126(arrInstType$$2, checker$$19) {
      var v2875 = this.arrayCache;
      return v2875.specialize(arrInstType$$2, checker$$19);
    }
    function v1125() {
      var v13113 = this.extendsList;
      if (v13113) {
        var v23226 = this.extendsList;
        var v19251 = v23226.length;
        v13113 = v19251 > 0;
      }
      var v2877 = v13113;
      if (v2877) {
        var v2876 = this.extendsList;
        return v2876[0];
      } else {
        return null;
      }
      return;
    }
    function Type$$1() {
      this.typeID = currentTypeID;
      currentTypeID = currentTypeID + 1;
      this.construct = null;
      this.call = null;
      this.index = null;
      var v2878 = TypeScript$$26.CompilerDiagnostics;
      this.passTypeCreated = v2878.analysisPass;
      this.primitiveTypeClass = Primitive.None;
      var v2879 = TypeScript$$26.TypeFlags;
      this.typeFlags = v2879.None;
      return;
    }
    var v2880 = Type$$1.prototype;
    v2880.baseClass = v1125;
    var v2881 = Type$$1.prototype;
    v2881.getArrayBase = v1126;
    var v2882 = Type$$1.prototype;
    v2882.isClass = v1127;
    var v2883 = Type$$1.prototype;
    v2883.isArray = v1128;
    var v2884 = Type$$1.prototype;
    v2884.isClassInstance = v1129;
    var v2885 = Type$$1.prototype;
    v2885.getInstanceType = v1130;
    var v2886 = Type$$1.prototype;
    v2886.hasImplementation = v1131;
    var v2887 = Type$$1.prototype;
    v2887.setHasImplementation = v1132;
    var v2888 = Type$$1.prototype;
    v2888.isDouble = v1133;
    var v2889 = Type$$1.prototype;
    v2889.isString = v1134;
    var v2890 = Type$$1.prototype;
    v2890.isBoolean = v1135;
    var v2891 = Type$$1.prototype;
    v2891.isNull = v1136;
    var v2892 = Type$$1.prototype;
    v2892.getTypeName = v1137;
    var v2893 = Type$$1.prototype;
    v2893.getScopedTypeName = v1138;
    var v2894 = Type$$1.prototype;
    v2894.getScopedTypeNameEx = v1139;
    var v2895 = Type$$1.prototype;
    v2895.callCount = v1140;
    var v2896 = Type$$1.prototype;
    v2896.getMemberTypeName = v1141;
    var v2897 = Type$$1.prototype;
    v2897.getMemberTypeNameEx = v1143;
    var v2898 = Type$$1.prototype;
    v2898.checkDecl = v1144;
    var v2899 = Type$$1.prototype;
    v2899.getMemberScope = v1145;
    var v2900 = Type$$1.prototype;
    v2900.isReferenceType = v1146;
    var v2901 = Type$$1.prototype;
    v2901.specializeType = v1151;
    var v2902 = Type$$1.prototype;
    v2902.hasBase = v1152;
    var v2903 = Type$$1.prototype;
    v2903.mergeOrdered = v1153;
    var v2904 = Type$$1.prototype;
    v2904.isModuleType = v1154;
    var v2905 = Type$$1.prototype;
    v2905.hasMembers = v1155;
    var v2906 = Type$$1.prototype;
    v2906.getAllEnclosedTypes = v1156;
    var v2907 = Type$$1.prototype;
    v2907.getAllAmbientEnclosedTypes = v1157;
    var v2908 = Type$$1.prototype;
    v2908.getPublicEnclosedTypes = v1158;
    var v2909 = Type$$1.prototype;
    v2909.getpublicAmbientEnclosedTypes = v1159;
    var v2910 = Type$$1.prototype;
    v2910.getDocComments = v1160;
    return Type$$1;
  }
  function v1124(_super$$66) {
    function v1123(entries) {
      var i$$113 = 0;
      var v13114 = entries.length;
      var v2913 = i$$113 < v13114;
      for (;v2913;) {
        var v2911 = this.entries;
        var v2912 = entries[i$$113];
        v2911.push(v2912);
        i$$113 = i$$113 + 1;
        var v13115 = entries.length;
        v2913 = i$$113 < v13115;
      }
      return;
    }
    function v1122(entry$$2) {
      var v2914 = this.entries;
      v2914.push(entry$$2);
      return;
    }
    function v1121() {
      return true;
    }
    function MemberNameArray$$1() {
      _super$$66.apply(this, arguments);
      this.delim = "";
      this.entries = [];
      return;
    }
    __extends(MemberNameArray$$1, _super$$66);
    var v2915 = MemberNameArray$$1.prototype;
    v2915.isArray = v1121;
    var v2916 = MemberNameArray$$1.prototype;
    v2916.add = v1122;
    var v2917 = MemberNameArray$$1.prototype;
    v2917.addAll = v1123;
    return MemberNameArray$$1;
  }
  function v1120(_super$$65) {
    function v1119() {
      return true;
    }
    function MemberNameString$$1(text$$25) {
      _super$$65.call(this);
      this.text = text$$25;
      return;
    }
    __extends(MemberNameString$$1, _super$$65);
    var v2918 = MemberNameString$$1.prototype;
    v2918.isString = v1119;
    return MemberNameString$$1;
  }
  function v1118() {
    function create(arg1, arg2, arg3) {
      var v13116 = typeof arg1;
      var v2920 = v13116 == "string";
      if (v2920) {
        return new MemberNameString(arg1);
      } else {
        var result$$32 = new MemberNameArray;
        if (arg2) {
          result$$32.prefix = arg2;
        }
        if (arg3) {
          result$$32.suffix = arg3;
        }
        var v2919 = result$$32.entries;
        v2919.push(arg1);
        return result$$32;
      }
      return;
    }
    function memberNameToString(memberName$$3) {
      var result$$31 = memberName$$3.prefix;
      var v2922 = memberName$$3.isString();
      if (v2922) {
        var v13117 = memberName$$3.text;
        result$$31 = result$$31 + v13117;
      } else {
        var ar = memberName$$3;
        var index$$61 = 0;
        var v19252 = ar.entries;
        var v13118 = v19252.length;
        var v2921 = index$$61 < v13118;
        for (;v2921;) {
          var v13119 = result$$31;
          var v23227 = ar.entries;
          var v19253 = v23227[index$$61];
          var v13120 = MemberName$$1.memberNameToString(v19253);
          result$$31 = v13119 + v13120;
          var v13121 = ar.delim;
          result$$31 = result$$31 + v13121;
          index$$61 = index$$61 + 1;
          var v19254 = ar.entries;
          var v13122 = v19254.length;
          v2921 = index$$61 < v13122;
        }
      }
      var v13123 = memberName$$3.suffix;
      result$$31 = result$$31 + v13123;
      return result$$31;
    }
    function v1117() {
      return MemberName$$1.memberNameToString(this);
    }
    function v1116() {
      return false;
    }
    function v1115() {
      return false;
    }
    function MemberName$$1() {
      this.prefix = "";
      this.suffix = "";
      return;
    }
    var v2923 = MemberName$$1.prototype;
    v2923.isString = v1115;
    var v2924 = MemberName$$1.prototype;
    v2924.isArray = v1116;
    var v2925 = MemberName$$1.prototype;
    v2925.toString = v1117;
    MemberName$$1.memberNameToString = memberNameToString;
    MemberName$$1.create = create;
    return MemberName$$1;
  }
  function v1114(Primitive$$1) {
    Primitive$$1._map = [];
    Primitive$$1.None = 0;
    Primitive$$1.Void = 1;
    Primitive$$1.Double = 2;
    Primitive$$1.String = 4;
    Primitive$$1.Boolean = 8;
    Primitive$$1.Any = 16;
    Primitive$$1.Null = 32;
    Primitive$$1.Undefined = 64;
    return;
  }
  function getTypeLink(ast$$116, checker$$18, autoVar) {
    var result$$30 = new TypeLink;
    result$$30.ast = ast$$116;
    var v13124 = ast$$116 == null;
    if (v13124) {
      v13124 = autoVar;
    }
    var v2926 = v13124;
    if (v2926) {
      result$$30.type = checker$$18.anyType;
    } else {
      result$$30.type = null;
    }
    return result$$30;
  }
  var v13125 = TypeScript$$26.Primitive;
  var v19255 = !v13125;
  if (v19255) {
    v13125 = TypeScript$$26.Primitive = {};
  }
  var v2927 = v13125;
  v1114(v2927);
  var Primitive = TypeScript$$26.Primitive;
  var MemberName = v1118();
  TypeScript$$26.MemberName = MemberName;
  var MemberNameString = v1120(MemberName);
  TypeScript$$26.MemberNameString = MemberNameString;
  var MemberNameArray = v1124(MemberName);
  TypeScript$$26.MemberNameArray = MemberNameArray;
  var currentTypeID = -1;
  var Type = v1161();
  TypeScript$$26.Type = Type;
  var ModuleType = v1170(Type);
  TypeScript$$26.ModuleType = ModuleType;
  var TypeLink = v1171();
  TypeScript$$26.TypeLink = TypeLink;
  TypeScript$$26.getTypeLink = getTypeLink;
  return;
}
function v1113(TypeScript$$25) {
  function v1112() {
    function v1111(enclosingScopeContext$$2) {
      function preFindMemberScopeFullAstFuzy(ast$$115, parent$$69, walker$$53) {
        var v2930 = TypeScript$$25.isValidAstNode(ast$$115);
        if (v2930) {
          var v19256 = ast$$115.flags;
          var v13126 = TypeScript$$25.hasFlag(v19256, matchFlag$$2);
          if (v13126) {
            var v23228 = ast$$115.minChar;
            var v19257 = v23228 < pos$$7;
            if (v19257) {
              var v23229 = ast$$115.limChar;
              v19257 = pos$$7 <= v23229;
            }
            v13126 = v19257;
          }
          var v2928 = v13126;
          if (v2928) {
            astResult = ast$$115;
          }
          var v2929 = walker$$53.options;
          var v19258 = ast$$115.minChar;
          var v13127 = v19258 <= pos$$7;
          if (v13127) {
            var v19259 = ast$$115.limChar;
            v13127 = pos$$7 <= v19259;
          }
          v2929.goChildren = v13127;
        }
        return ast$$115;
      }
      function preFindMemberScopeFullAst(ast$$114, parent$$68, walker$$52) {
        var v2934 = TypeScript$$25.isValidAstNode(ast$$114);
        if (v2934) {
          var v19260 = ast$$114.flags;
          var v13128 = TypeScript$$25.hasFlag(v19260, matchFlag$$2);
          if (v13128) {
            var v23230 = ast$$114.limChar;
            var v19261 = pos$$7 == v23230;
            var v23233 = !v19261;
            if (v23233) {
              var v23231 = pos$$7 - 1;
              var v23232 = ast$$114.limChar;
              v19261 = v23231 == v23232;
            }
            v13128 = v19261;
          }
          var v2932 = v13128;
          if (v2932) {
            astResult = ast$$114;
            var v2931 = walker$$52.options;
            v2931.stopWalk();
          }
          var v2933 = walker$$52.options;
          var v19262 = ast$$114.minChar;
          var v13129 = v19262 <= pos$$7;
          if (v13129) {
            var v19263 = ast$$114.limChar;
            v13129 = pos$$7 <= v19263;
          }
          v2933.goChildren = v13129;
        }
        return ast$$114;
      }
      var v2935 = TypeScript$$25.ASTFlags;
      var matchFlag$$2 = v2935.DotLHS;
      var pos$$7 = enclosingScopeContext$$2.pos;
      var astResult = null;
      var v2936 = TypeScript$$25.getAstWalkerFactory();
      var v2937 = enclosingScopeContext$$2.script;
      v2936.walk(v2937, preFindMemberScopeFullAst);
      var v2940 = astResult == null;
      if (v2940) {
        var v2938 = TypeScript$$25.getAstWalkerFactory();
        var v2939 = enclosingScopeContext$$2.script;
        v2938.walk(v2939, preFindMemberScopeFullAstFuzy);
      }
      var v19264 = astResult;
      if (v19264) {
        v19264 = enclosingScopeContext$$2.enclosingClassDecl;
      }
      var v13130 = v19264;
      if (v13130) {
        var v19265 = astResult.type;
        var v25192 = enclosingScopeContext$$2.enclosingClassDecl;
        var v23234 = v25192.type;
        var v19266 = v23234.instanceType;
        v13130 = v19265 == v19266;
      }
      var v2941 = v13130;
      if (v2941) {
        enclosingScopeContext$$2.publicsOnly = false;
      }
      var v13131 = astResult;
      if (v13131) {
        v13131 = astResult.type;
      }
      var v2943 = v13131;
      if (v2943) {
        var v2942 = astResult.type;
        return v2942.getMemberScope(this);
      } else {
        return null;
      }
      return;
    }
    function v1110(enclosingScopeContext$$1) {
      var v13132 = TypeScript$$25.ASTFlags;
      var v2944 = v13132.DotLHS;
      return this.findMemberScope(enclosingScopeContext$$1, v2944);
    }
    function v1109(enclosingScopeContext, matchFlag$$1) {
      var enclosingScope$$1 = enclosingScopeContext.getScope();
      var v2945 = enclosingScopeContext.pos;
      var v13133 = enclosingScopeContext.scopeStartAST;
      var v2946 = v13133.minChar;
      var pos$$6 = v2945 - v2946;
      var scriptFragment = enclosingScopeContext.getScriptFragment();
      var v2947 = TypeScript$$25.MemberScopeContext;
      var memContext = new v2947(this, pos$$6, matchFlag$$1);
      memContext.scope = enclosingScope$$1;
      var v13134 = scriptFragment.nodeType;
      var v19267 = TypeScript$$25.NodeType;
      var v13135 = v19267.Name;
      var v2954 = v13134 == v13135;
      if (v2954) {
        var v2948 = scriptFragment.type;
        return v2948.getMemberScope(this);
      } else {
        var v2949 = TypeScript$$25.getAstWalkerFactory();
        var v2950 = TypeScript$$25.preFindMemberScope;
        v2949.walk(scriptFragment, v2950, null, null, memContext);
        var v19268 = memContext.ast;
        if (v19268) {
          v19268 = enclosingScopeContext.enclosingClassDecl;
        }
        var v13136 = v19268;
        if (v13136) {
          var v23235 = memContext.ast;
          var v19269 = v23235.type;
          var v25193 = enclosingScopeContext.enclosingClassDecl;
          var v23236 = v25193.type;
          var v19270 = v23236.instanceType;
          v13136 = v19269 == v19270;
        }
        var v2951 = v13136;
        if (v2951) {
          enclosingScopeContext.publicsOnly = false;
        }
        var v2953 = memContext.type;
        if (v2953) {
          var v2952 = memContext.type;
          return v2952.getMemberScope(this);
        } else {
          return null;
        }
      }
      return;
    }
    function v1108(ast$$113) {
      var script$$17 = ast$$113;
      var v2955 = this.checker;
      v2955.locationInfo = script$$17.locationInfo;
      var v13137 = this.checker;
      var v2956 = v13137.gloMod;
      var v2957 = this.globalScope;
      var globalChain$$1 = new ScopeChain(v2956, null, v2957);
      var v2958 = TypeScript$$25.AssignScopeContext;
      var v19271 = this.checker;
      var v13138 = v19271.currentModDecl;
      var v2959 = [v13138];
      var context$$64 = new v2958(globalChain$$1, this, v2959);
      var v2960 = TypeScript$$25.getAstWalkerFactory();
      var v2961 = TypeScript$$25.preAssignScopes;
      var v2962 = TypeScript$$25.postAssignScopes;
      v2960.walk(ast$$113, v2961, v2962, null, context$$64);
      return;
    }
    function v1107(ast$$112) {
      var callEx$$5 = ast$$112;
      var v23237 = this.checker;
      var v19272 = v23237.styleSettings;
      var v13139 = v19272.newMustBeUsed;
      if (v13139) {
        var v19273 = ast$$112.nodeType;
        var v23238 = TypeScript$$25.NodeType;
        var v19274 = v23238.New;
        v13139 = v19273 == v19274;
      }
      var v2968 = v13139;
      if (v2968) {
        var v13140 = ast$$112.flags;
        var v19275 = TypeScript$$25.ASTFlags;
        var v13141 = v19275.IsStatement;
        var v2964 = TypeScript$$25.hasFlag(v13140, v13141);
        if (v2964) {
          var v13142 = this.checker;
          var v2963 = v13142.errorReporter;
          v2963.styleError(ast$$112, "use of new expression as a statement");
        }
      } else {
        var v25194 = this.checker;
        var v23239 = v25194.styleSettings;
        var v19276 = v23239.evalOK;
        var v13143 = !v19276;
        if (v13143) {
          var v19277 = ast$$112.nodeType;
          var v23240 = TypeScript$$25.NodeType;
          var v19278 = v23240.Call;
          v13143 = v19277 == v19278;
        }
        var v2967 = v13143;
        if (v2967) {
          var v23241 = callEx$$5.target;
          var v19279 = v23241.nodeType;
          var v23242 = TypeScript$$25.NodeType;
          var v19280 = v23242.Name;
          var v13144 = v19279 == v19280;
          if (v13144) {
            var v23243 = callEx$$5.target;
            var v19281 = v23243.text;
            v13144 = v19281 == "eval";
          }
          var v2966 = v13144;
          if (v2966) {
            var v13145 = this.checker;
            var v2965 = v13145.errorReporter;
            v2965.styleError(callEx$$5, "eval not permitted");
          }
        }
      }
      var v19282 = callEx$$5.target;
      var v13146 = v19282.nodeType;
      var v19283 = TypeScript$$25.NodeType;
      var v13147 = v19283.FuncDecl;
      var v2970 = v13146 == v13147;
      if (v2970) {
        var v2969 = callEx$$5.target;
        v2969.isInlineCallLiteral = true;
      }
      var prevInSuperCall = this.inSuperCall;
      var v19284 = callEx$$5.target;
      var v13148 = v19284.nodeType;
      var v19285 = TypeScript$$25.NodeType;
      var v13149 = v19285.Super;
      var v2971 = v13148 == v13149;
      if (v2971) {
        this.inSuperCall = true;
      }
      var v2972 = callEx$$5;
      var v13150 = callEx$$5.target;
      var v26803 = this.typeCheck(v13150);
      v2972.target = v26803;
      var v2973 = callEx$$5.arguments;
      this.preTypeCheckCallArgs(v2973);
      var target$$37 = callEx$$5.target;
      var v23244 = target$$37.type;
      var v19286 = v23244 == null;
      var v23247 = !v19286;
      if (v23247) {
        var v23245 = target$$37.type;
        var v23246 = this.anyType;
        v19286 = v23245 == v23246;
      }
      var v13151 = v19286;
      var v19288 = !v13151;
      if (v19288) {
        var v19287 = this.functionInterfaceType;
        if (v19287) {
          var v23248 = target$$37.type;
          var v23249 = this.functionInterfaceType;
          v19287 = v23248 == v23249;
        }
        v13151 = v19287;
      }
      var v2985 = v13151;
      if (v2985) {
        callEx$$5.type = this.anyType;
      } else {
        var fnType$$1 = target$$37.type;
        var v2984 = fnType$$1.call;
        if (v2984) {
          var v2974 = fnType$$1.call;
          var signature$$14 = this.resolveOverload(callEx$$5, v2974);
          var v2976 = signature$$14 == null;
          if (v2976) {
            callEx$$5.type = this.anyType;
          } else {
            var v2975 = signature$$14.returnType;
            callEx$$5.type = v2975.type;
            callEx$$5.signature = signature$$14;
          }
        } else {
          var v26041 = callEx$$5.target;
          var v25195 = v26041.nodeType;
          var v26042 = TypeScript$$25.NodeType;
          var v25196 = v26042.Super;
          var v23250 = v25195 == v25196;
          if (v23250) {
            v23250 = this.thisFnc;
          }
          var v19289 = v23250;
          if (v19289) {
            var v23251 = this.thisFnc;
            v19289 = v23251.isConstructor;
          }
          var v13152 = v19289;
          if (v13152) {
            var v23252 = this.thisFnc;
            var v19290 = v23252.fncFlags;
            var v23253 = TypeScript$$25.FncFlags;
            var v19291 = v23253.ClassMethod;
            v13152 = TypeScript$$25.hasFlag(v19290, v19291);
          }
          var v2983 = v13152;
          if (v2983) {
            var v2977;
            var v23254 = fnType$$1.symbol;
            var v19292 = v23254.type;
            var v13154 = v19292.construct;
            if (v13154) {
              var v23255 = fnType$$1.symbol;
              var v19293 = v23255.type;
              var v13153 = v19293.construct;
              v2977 = this.resolveOverload(callEx$$5, v13153);
            } else {
              v2977 = null;
            }
            signature$$14 = v2977;
            var v2979 = signature$$14 == null;
            if (v2979) {
              callEx$$5.type = this.anyType;
            } else {
              var v13155 = callEx$$5.flags;
              var v19294 = TypeScript$$25.ASTFlags;
              var v13156 = v19294.ClassBaseConstructorCall;
              callEx$$5.flags = v13155 | v13156;
              var v2978 = signature$$14.returnType;
              callEx$$5.type = v2978.type;
              callEx$$5.signature = signature$$14;
            }
          } else {
            callEx$$5.type = this.anyType;
            var v13157 = this.checker;
            var v2980 = v13157.errorReporter;
            var v2981 = callEx$$5.nodeType;
            var v2982 = this.scope;
            v2980.invalidCall(callEx$$5, v2981, v2982);
          }
        }
      }
      this.postTypeCheckCallArgs(callEx$$5);
      this.inSuperCall = prevInSuperCall;
      return callEx$$5;
    }
    function v1106(callEx$$4) {
      var acceptedTargetType = false;
      var i$$112 = 0;
      var v23256 = callEx$$4.target;
      if (v23256) {
        var v25197 = callEx$$4.target;
        v23256 = v25197.type;
      }
      var v19295 = v23256;
      if (v19295) {
        v19295 = callEx$$4.signature;
      }
      var v13158 = v19295;
      if (v13158) {
        v13158 = callEx$$4.arguments;
      }
      var v3005 = v13158;
      if (v3005) {
        var sig$$4 = callEx$$4.signature;
        var v13159 = sig$$4;
        if (v13159) {
          var v25198 = callEx$$4.arguments;
          var v23257 = v25198.members;
          var v19296 = v23257.length;
          var v19297 = sig$$4.nonOptionalParameterCount;
          v13159 = v19296 >= v19297;
        }
        var v3004 = v13159;
        if (v3004) {
          acceptedTargetType = true;
          var targetType$$8 = null;
          var v2986;
          var v13162 = sig$$4.hasVariableArgList;
          if (v13162) {
            var v19298 = sig$$4.parameters;
            var v13160 = v19298.length;
            v2986 = v13160 - 1;
          } else {
            var v13161 = sig$$4.parameters;
            v2986 = v13161.length;
          }
          var nonVarArgFormalParamLength = v2986;
          var v2987;
          var v25199 = callEx$$4.arguments;
          var v23258 = v25199.members;
          var v19299 = v23258.length;
          var v13164 = v19299 < nonVarArgFormalParamLength;
          if (v13164) {
            var v19300 = callEx$$4.arguments;
            var v13163 = v19300.members;
            v2987 = v13163.length;
          } else {
            v2987 = nonVarArgFormalParamLength;
          }
          var nonVarArgActualParamLength = v2987;
          i$$112 = 0;
          var v2994 = i$$112 < nonVarArgActualParamLength;
          for (;v2994;) {
            var v13165 = sig$$4.parameters;
            var v2988 = v13165[i$$112];
            targetType$$8 = v2988.getType();
            var v23259 = callEx$$4.arguments;
            var v19301 = v23259.members;
            var v13166 = v19301[i$$112];
            var v2993 = v13166.nodeType;
            switch(v2993) {
              case TypeScript$$25.NodeType.FuncDecl:
              ;
              case TypeScript$$25.NodeType.ObjectLit:
              ;
              case TypeScript$$25.NodeType.ArrayLit:
                var v2989 = this.checker;
                var v13167 = this.checker;
                var v2990 = v13167.inProvisionalTypecheckMode();
                var v25200 = sig$$4.parameters;
                var v23260 = v25200[i$$112];
                var v19302 = v23260.declAST;
                var v13168 = v19302.isParenthesized;
                var v2991 = !v13168;
                var v19303 = callEx$$4.arguments;
                var v13169 = v19303.members;
                var v2992 = v13169[i$$112];
                v2989.typeCheckWithContextualType(targetType$$8, v2990, v2991, v2992);
            }
            i$$112 = i$$112 + 1;
            v2994 = i$$112 < nonVarArgActualParamLength;
          }
          var v3003 = sig$$4.hasVariableArgList;
          if (v3003) {
            var v2995 = sig$$4.nonOptionalParameterCount;
            var varArgParamIndex = v2995 - 1;
            var v13170 = sig$$4.parameters;
            var v2996 = v13170[varArgParamIndex];
            targetType$$8 = v2996.getType();
            if (targetType$$8) {
              targetType$$8 = targetType$$8.elementType;
            }
            var v23261 = sig$$4.parameters;
            var v19304 = v23261[varArgParamIndex];
            var v13171 = v19304.declAST;
            var v2997 = v13171.isParenthesized;
            var isParenthesized = !v2997;
            i$$112 = nonVarArgActualParamLength;
            var v23262 = callEx$$4.arguments;
            var v19305 = v23262.members;
            var v13172 = v19305.length;
            var v3002 = i$$112 < v13172;
            for (;v3002;) {
              var v23263 = callEx$$4.arguments;
              var v19306 = v23263.members;
              var v13173 = v19306[i$$112];
              var v3001 = v13173.nodeType;
              switch(v3001) {
                case TypeScript$$25.NodeType.FuncDecl:
                ;
                case TypeScript$$25.NodeType.ObjectLit:
                ;
                case TypeScript$$25.NodeType.ArrayLit:
                  var v2998 = this.checker;
                  var v13174 = this.checker;
                  var v2999 = v13174.inProvisionalTypecheckMode();
                  var v19307 = callEx$$4.arguments;
                  var v13175 = v19307.members;
                  var v3000 = v13175[i$$112];
                  v2998.typeCheckWithContextualType(targetType$$8, v2999, isParenthesized, v3000);
              }
              i$$112 = i$$112 + 1;
              var v23264 = callEx$$4.arguments;
              var v19308 = v23264.members;
              var v13176 = v19308.length;
              v3002 = i$$112 < v13176;
            }
          }
        }
      }
      var v13177 = !acceptedTargetType;
      if (v13177) {
        v13177 = callEx$$4.arguments;
      }
      var v3010 = v13177;
      if (v3010) {
        var v3006 = this.checker;
        v3006.killCurrentContextualType();
        i$$112 = 0;
        var v23265 = callEx$$4.arguments;
        var v19309 = v23265.members;
        var v13178 = v19309.length;
        var v3009 = i$$112 < v13178;
        for (;v3009;) {
          var v23266 = callEx$$4.arguments;
          var v19310 = v23266.members;
          var v13179 = v19310[i$$112];
          var v3008 = v13179.nodeType;
          switch(v3008) {
            case TypeScript$$25.NodeType.FuncDecl:
            ;
            case TypeScript$$25.NodeType.ObjectLit:
            ;
            case TypeScript$$25.NodeType.ArrayLit:
              var v19311 = callEx$$4.arguments;
              var v13180 = v19311.members;
              var v3007 = v13180[i$$112];
              this.typeCheck(v3007);
            default:
            ;
          }
          i$$112 = i$$112 + 1;
          var v23267 = callEx$$4.arguments;
          var v19312 = v23267.members;
          var v13181 = v19312.length;
          v3009 = i$$112 < v13181;
        }
      }
      return;
    }
    function v1105(args$$16) {
      var v3011 = !args$$16;
      if (v3011) {
        return;
      }
      var i$$111 = 0;
      var v19313 = args$$16.members;
      var v13182 = v19313.length;
      var v3014 = i$$111 < v13182;
      for (;v3014;) {
        var v19314 = args$$16.members;
        var v13183 = v19314[i$$111];
        var v3013 = v13183.nodeType;
        switch(v3013) {
          case TypeScript$$25.NodeType.FuncDecl:
          ;
          case TypeScript$$25.NodeType.ObjectLit:
          ;
          case TypeScript$$25.NodeType.ArrayLit:
            i$$111 = i$$111 + 1;
            var v19315 = args$$16.members;
            var v13184 = v19315.length;
            v3014 = i$$111 < v13184;
            continue;
          default:
            var v13185 = args$$16.members;
            var v3012 = v13185[i$$111];
            this.typeCheck(v3012);
        }
        i$$111 = i$$111 + 1;
        var v19316 = args$$16.members;
        var v13186 = v19316.length;
        v3014 = i$$111 < v13186;
      }
      return;
    }
    function v1104(ast$$111) {
      var callEx$$3 = ast$$111;
      var v3015 = callEx$$3;
      var v13187 = callEx$$3.target;
      var v26804 = this.typeCheck(v13187);
      v3015.target = v26804;
      var target$$36 = callEx$$3.target;
      var v19317 = target$$36.type;
      var v13188 = v19317.construct;
      var v19319 = !v13188;
      if (v19319) {
        var v19318 = target$$36.type;
        v13188 = v19318.call;
      }
      var v3018 = v13188;
      if (v3018) {
        var v3016 = callEx$$3.arguments;
        this.preTypeCheckCallArgs(v3016);
      } else {
        var v3017 = callEx$$3;
        var v13189 = callEx$$3.arguments;
        var v26805 = this.typeCheck(v13189);
        v3017.arguments = v26805;
      }
      var v13190 = target$$36.type;
      var v13191 = this.anyType;
      var v3035 = v13190 == v13191;
      if (v3035) {
        callEx$$3.type = this.anyType;
        var v3019 = callEx$$3;
        var v13192 = callEx$$3.arguments;
        var v26806 = this.typeCheck(v13192);
        v3019.arguments = v26806;
      } else {
        var v13193 = target$$36.type;
        var v3034 = v13193.construct;
        if (v3034) {
          var v13194 = target$$36.type;
          var v3020 = v13194.construct;
          var signature$$13 = this.resolveOverload(callEx$$3, v3020);
          var v3023 = signature$$13 == null;
          if (v3023) {
            callEx$$3.type = this.anyType;
          } else {
            var v19320 = signature$$13.returnType;
            var v13195 = v19320.type;
            var v13196 = this.voidType;
            var v3022 = v13195 == v13196;
            if (v3022) {
              callEx$$3.type = this.anyType;
              callEx$$3.signature = signature$$13;
            } else {
              var v3021 = signature$$13.returnType;
              callEx$$3.type = v3021.type;
              callEx$$3.signature = signature$$13;
            }
          }
        } else {
          var v13197 = target$$36.type;
          var v3033 = v13197.call;
          if (v3033) {
            var v13198 = target$$36.type;
            var v3024 = v13198.call;
            signature$$13 = this.resolveOverload(callEx$$3, v3024);
            var v3028 = signature$$13 == null;
            if (v3028) {
              callEx$$3.type = this.anyType;
            } else {
              var v23268 = signature$$13.returnType;
              var v19321 = v23268.type;
              var v19322 = this.voidType;
              var v13199 = v19321 == v19322;
              var v19325 = !v13199;
              if (v19325) {
                var v23269 = signature$$13.returnType;
                var v19323 = v23269.type;
                var v19324 = this.anyType;
                v13199 = v19323 == v19324;
              }
              var v3027 = v13199;
              if (v3027) {
                callEx$$3.type = this.anyType;
                callEx$$3.signature = signature$$13;
              } else {
                var v13200 = this.checker;
                var v3025 = v13200.errorReporter;
                var v3026 = callEx$$3.target;
                v3025.simpleError(v3026, "new expression only valid on constructors");
              }
            }
          } else {
            var v13201 = target$$36.type;
            var v3032 = v13201.elementType;
            if (v3032) {
              callEx$$3.type = target$$36.type;
            } else {
              var v13202 = this.checker;
              var v3029 = v13202.errorReporter;
              var v3030 = callEx$$3.nodeType;
              var v3031 = this.scope;
              v3029.invalidCall(callEx$$3, v3030, v3031);
              callEx$$3.type = this.anyType;
            }
          }
        }
      }
      this.postTypeCheckCallArgs(callEx$$3);
      return callEx$$3;
    }
    function v1103(application, group$$1) {
      var v3036 = this.resolutionDataCache;
      var rd$$2 = v3036.getResolutionData();
      var actuals$$1 = rd$$2.actuals;
      var exactCandidates$$1 = rd$$2.exactCandidates;
      var conversionCandidates$$1 = rd$$2.conversionCandidates;
      var candidate = null;
      var v13203 = group$$1.signatures;
      var v3037 = v13203.length;
      var hasOverloads = v3037 > 1;
      var v3038 = TypeScript$$25.TypeComparisonInfo;
      var comparisonInfo$$16 = new v3038;
      var args$$15 = null;
      var target$$35 = null;
      var v19326 = application.nodeType;
      var v23270 = TypeScript$$25.NodeType;
      var v19327 = v23270.Call;
      var v13204 = v19326 == v19327;
      var v19330 = !v13204;
      if (v19330) {
        var v19328 = application.nodeType;
        var v23271 = TypeScript$$25.NodeType;
        var v19329 = v23271.New;
        v13204 = v19328 == v19329;
      }
      var v3047 = v13204;
      if (v3047) {
        var callEx$$2 = application;
        args$$15 = callEx$$2.arguments;
        target$$35 = callEx$$2.target;
        var v3042 = callEx$$2.arguments;
        if (v3042) {
          var v13205 = callEx$$2.arguments;
          var v3039 = v13205.members;
          var len$$54 = v3039.length;
          var i$$110 = 0;
          var v3041 = i$$110 < len$$54;
          for (;v3041;) {
            var v19331 = callEx$$2.arguments;
            var v13206 = v19331.members;
            var v3040 = v13206[i$$110];
            actuals$$1[i$$110] = v3040.type;
            i$$110 = i$$110 + 1;
            v3041 = i$$110 < len$$54;
          }
        }
      } else {
        var v13207 = application.nodeType;
        var v19332 = TypeScript$$25.NodeType;
        var v13208 = v19332.Index;
        var v3046 = v13207 == v13208;
        if (v3046) {
          var binExp = application;
          target$$35 = binExp.operand1;
          var v3043 = TypeScript$$25.ASTList;
          args$$15 = new v3043;
          var v3044 = args$$15.members;
          v3044[0] = binExp.operand2;
          var v3045 = binExp.operand2;
          actuals$$1[0] = v3045.type;
        }
      }
      var j$$17 = 0;
      var v3048 = group$$1.signatures;
      var groupLen = v3048.length;
      var v3053 = j$$17 < groupLen;
      for (;v3053;) {
        var v3049 = group$$1.signatures;
        var signature$$12 = v3049[j$$17];
        var v19333 = hasOverloads;
        if (v19333) {
          var v23272 = group$$1.definitionSignature;
          v19333 = signature$$12 == v23272;
        }
        var v13209 = v19333;
        if (v13209) {
          var v23273 = this.checker;
          var v19334 = v23273.canCallDefinitionSignature;
          v13209 = !v19334;
        }
        var v3050 = v13209;
        if (v3050) {
          j$$17 = j$$17 + 1;
          v3053 = j$$17 < groupLen;
          continue;
        }
        var v25201 = signature$$12.returnType;
        var v23274 = v25201.type;
        var v19335 = !v23274;
        if (v19335) {
          v19335 = signature$$12.declAST;
        }
        var v13210 = v19335;
        if (v13210) {
          var v19336 = signature$$12.typeCheckStatus;
          var v23275 = TypeScript$$25.TypeCheckStatus;
          var v19337 = v23275.Finished;
          v13210 = v19336 != v19337;
        }
        var v3052 = v13210;
        if (v3052) {
          var v3051 = signature$$12.declAST;
          this.typeCheckFunction(v3051);
        }
        this.tryAddCandidates(signature$$12, actuals$$1, exactCandidates$$1, conversionCandidates$$1, comparisonInfo$$16);
        j$$17 = j$$17 + 1;
        v3053 = j$$17 < groupLen;
      }
      var v13211 = exactCandidates$$1.length;
      var v3069 = v13211 == 0;
      if (v3069) {
        var v3054 = this.checker;
        var applicableCandidates = v3054.getApplicableSignatures(conversionCandidates$$1, args$$15, comparisonInfo$$16);
        var v13212 = applicableCandidates.length;
        var v3062 = v13212 > 0;
        if (v3062) {
          var v3055 = this.checker;
          var candidateInfo = v3055.findMostApplicableSignature(applicableCandidates, args$$15);
          var v3057 = candidateInfo.ambiguous;
          if (v3057) {
            var v13213 = this.checker;
            var v3056 = v13213.errorReporter;
            v3056.simpleError(target$$35, "Ambiguous call expression - could not choose overload");
          }
          candidate = candidateInfo.sig;
        } else {
          var emsg$$3 = "Supplied parameters do not match any signature of call target";
          var v3061 = comparisonInfo$$16.message;
          if (v3061) {
            var v13214 = this.checker;
            var v3058 = v13214.errorReporter;
            var v13215 = emsg$$3 + ":\n\t";
            var v13216 = comparisonInfo$$16.message;
            var v3059 = v13215 + v13216;
            v3058.simpleError(target$$35, v3059);
          } else {
            var v13217 = this.checker;
            var v3060 = v13217.errorReporter;
            v3060.simpleError(target$$35, emsg$$3);
          }
        }
      } else {
        var v13218 = exactCandidates$$1.length;
        var v3068 = v13218 > 1;
        if (v3068) {
          var applicableSigs$$1 = [];
          i$$110 = 0;
          var v13219 = exactCandidates$$1.length;
          var v3064 = i$$110 < v13219;
          for (;v3064;) {
            var v3063 = exactCandidates$$1[i$$110];
            applicableSigs$$1[i$$110] = {signature:v3063, hadProvisionalErrors:false};
            i$$110 = i$$110 + 1;
            var v13220 = exactCandidates$$1.length;
            v3064 = i$$110 < v13220;
          }
          var v3065 = this.checker;
          candidateInfo = v3065.findMostApplicableSignature(applicableSigs$$1, args$$15);
          var v3067 = candidateInfo.ambiguous;
          if (v3067) {
            var v13221 = this.checker;
            var v3066 = v13221.errorReporter;
            v3066.simpleError(target$$35, "Ambiguous call expression - could not choose overload");
          }
          candidate = candidateInfo.sig;
        } else {
          candidate = exactCandidates$$1[0];
        }
      }
      var v3070 = this.resolutionDataCache;
      v3070.returnResolutionData(rd$$2);
      return candidate;
    }
    function v1102(signature$$11, actuals, exactCandidates, conversionCandidates, comparisonInfo$$15) {
      var lowerBound = signature$$11.nonOptionalParameterCount;
      var v3071 = signature$$11.parameters;
      var upperBound = v3071.length;
      var formalLen = lowerBound;
      var acceptable = false;
      var v19338 = actuals.length;
      var v13222 = v19338 >= lowerBound;
      if (v13222) {
        var v19339 = signature$$11.hasVariableArgList;
        var v23277 = !v19339;
        if (v23277) {
          var v23276 = actuals.length;
          v19339 = v23276 <= upperBound;
        }
        v13222 = v19339;
      }
      var v3073 = v13222;
      if (v3073) {
        var v3072;
        var v13224 = signature$$11.hasVariableArgList;
        if (v13224) {
          var v13223 = signature$$11.parameters;
          v3072 = v13223.length;
        } else {
          v3072 = actuals.length;
        }
        formalLen = v3072;
        acceptable = true;
      }
      var repeatType = null;
      var v13225 = acceptable;
      var v19340 = !v13225;
      if (v19340) {
        v13225 = signature$$11.hasVariableArgList;
      }
      var v3086 = v13225;
      if (v3086) {
        var v3076 = signature$$11.hasVariableArgList;
        if (v3076) {
          formalLen = formalLen - 1;
          var v23278 = signature$$11.parameters;
          var v19341 = v23278[formalLen];
          var v13226 = v19341.parameter;
          var v3074 = v13226.typeLink;
          repeatType = v3074.type;
          repeatType = repeatType.elementType;
          var v3075 = actuals.length;
          acceptable = v3075 >= formalLen;
        }
        var len$$53 = actuals.length;
        var exact = acceptable;
        var convert = acceptable;
        var i$$109 = 0;
        var v3082 = i$$109 < len$$53;
        for (;v3082;) {
          var typeA;
          var v3078 = i$$109 < formalLen;
          if (v3078) {
            var v23279 = signature$$11.parameters;
            var v19342 = v23279[i$$109];
            var v13227 = v19342.parameter;
            var v3077 = v13227.typeLink;
            typeA = v3077.type;
          } else {
            typeA = repeatType;
          }
          var typeB = actuals[i$$109];
          var v19343 = !typeA;
          var v23280 = !v19343;
          if (v23280) {
            v19343 = !typeB;
          }
          var v13228 = v19343;
          var v19345 = !v13228;
          if (v19345) {
            var v23281 = this.checker;
            var v19344 = v23281.typesAreIdentical(typeA, typeB);
            v13228 = !v19344;
          }
          var v3079 = v13228;
          if (v3079) {
            exact = false;
          }
          var v19346 = this.checker;
          var v13229 = v19346.sourceIsAssignableToTarget(typeB, typeA, comparisonInfo$$15);
          var v3080 = !v13229;
          if (v3080) {
            convert = false;
          }
          var v13230 = exact || convert;
          var v3081 = !v13230;
          if (v3081) {
            break;
          }
          i$$109 = i$$109 + 1;
          v3082 = i$$109 < len$$53;
        }
        if (exact) {
          var v3083 = exactCandidates.length;
          exactCandidates[v3083] = signature$$11;
        } else {
          var v13231 = convert;
          if (v13231) {
            var v19347 = exactCandidates.length;
            v13231 = v19347 == 0;
          }
          var v3085 = v13231;
          if (v3085) {
            var v3084 = conversionCandidates.length;
            conversionCandidates[v3084] = signature$$11;
          }
        }
      }
      return;
    }
    function v1101(binex$$13) {
      var v3087 = binex$$13;
      var v13232 = binex$$13.operand1;
      var v26807 = this.typeCheck(v13232);
      v3087.operand1 = v26807;
      var v3088 = binex$$13;
      var v13233 = binex$$13.operand2;
      var v26808 = this.typeCheck(v13233);
      v3088.operand2 = v26808;
      var v3089 = binex$$13.operand2;
      binex$$13.type = v3089.type;
      return binex$$13;
    }
    function v1100(binex$$12) {
      var v3090 = binex$$12;
      var v13234 = binex$$12.operand1;
      var v26809 = this.typeCheck(v13234);
      v3090.operand1 = v26809;
      var v3091 = binex$$12;
      var v13235 = binex$$12.operand2;
      var v26810 = this.typeCheck(v13235);
      v3091.operand2 = v26810;
      var v3092 = binex$$12.operand1;
      var leftType$$6 = v3092.type;
      var v3093 = binex$$12.operand2;
      var rightType$$5 = v3093.type;
      var v23282 = this.checker;
      var v19348 = v23282.anyType;
      var v13236 = leftType$$6 == v19348;
      var v19350 = !v13236;
      if (v19350) {
        var v23283 = this.checker;
        var v19349 = v23283.anyType;
        v13236 = rightType$$5 == v19349;
      }
      var v3110 = v13236;
      if (v3110) {
        var v3094 = this.checker;
        binex$$12.type = v3094.anyType;
      } else {
        var v19351 = this.checker;
        var v13237 = v19351.booleanType;
        var v3109 = leftType$$6 == v13237;
        if (v3109) {
          var v19352 = this.checker;
          var v13238 = v19352.booleanType;
          var v3097 = rightType$$5 == v13238;
          if (v3097) {
            var v3095 = this.checker;
            binex$$12.type = v3095.booleanType;
          } else {
            var v3096 = this.checker;
            binex$$12.type = v3096.anyType;
          }
        } else {
          var v19353 = this.checker;
          var v13239 = v19353.numberType;
          var v3108 = leftType$$6 == v13239;
          if (v3108) {
            var v19354 = this.checker;
            var v13240 = v19354.numberType;
            var v3100 = rightType$$5 == v13240;
            if (v3100) {
              var v3098 = this.checker;
              binex$$12.type = v3098.numberType;
            } else {
              var v3099 = this.checker;
              binex$$12.type = v3099.anyType;
            }
          } else {
            var v19355 = this.checker;
            var v13241 = v19355.stringType;
            var v3107 = leftType$$6 == v13241;
            if (v3107) {
              var v19356 = this.checker;
              var v13242 = v19356.stringType;
              var v3103 = rightType$$5 == v13242;
              if (v3103) {
                var v3101 = this.checker;
                binex$$12.type = v3101.stringType;
              } else {
                var v3102 = this.checker;
                binex$$12.type = v3102.anyType;
              }
            } else {
              var v13243 = this.checker;
              var v3106 = v13243.sourceIsSubtypeOfTarget(leftType$$6, rightType$$5);
              if (v3106) {
                binex$$12.type = rightType$$5;
              } else {
                var v13244 = this.checker;
                var v3105 = v13244.sourceIsSubtypeOfTarget(rightType$$5, leftType$$6);
                if (v3105) {
                  binex$$12.type = leftType$$6;
                } else {
                  var v3104 = this.checker;
                  binex$$12.type = v3104.anyType;
                }
              }
            }
          }
        }
      }
      return binex$$12;
    }
    function v1099(ast$$110) {
      var binex$$11 = ast$$110;
      var v3111 = binex$$11;
      var v13245 = binex$$11.operand1;
      var v26811 = this.typeCheck(v13245);
      v3111.operand1 = v26811;
      var v3112 = binex$$11;
      var v13246 = binex$$11.operand2;
      var v26812 = this.typeCheck(v13246);
      v3112.operand2 = v26812;
      var v3113 = binex$$11.operand2;
      binex$$11.type = v3113.type;
      return binex$$11;
    }
    function v1098(ast$$109) {
      var binex$$10 = ast$$109;
      var v3114 = binex$$10;
      var v13247 = binex$$10.operand1;
      var v26813 = this.typeCheck(v13247);
      v3114.operand1 = v26813;
      var v3115 = binex$$10;
      var v13248 = binex$$10.operand2;
      var v26814 = this.typeCheck(v13248);
      v3115.operand2 = v26814;
      var v26043 = binex$$10.operand1;
      var v25202 = v26043.type;
      var v26044 = this.checker;
      var v25203 = v26044.anyType;
      var v23284 = v25202 == v25203;
      var v25207 = !v23284;
      if (v25207) {
        var v25204 = this.checker;
        var v26045 = binex$$10.operand1;
        var v25205 = v26045.type;
        var v25206 = this.objectInterfaceType;
        v23284 = v25204.sourceIsSubtypeOfTarget(v25205, v25206);
      }
      var v19357 = v23284;
      if (v19357) {
        var v26046 = binex$$10.operand2;
        var v25208 = v26046.type;
        var v25209 = this.anyType;
        var v23285 = v25208 == v25209;
        var v25213 = !v23285;
        if (v25213) {
          var v25210 = this.checker;
          var v26047 = binex$$10.operand2;
          var v25211 = v26047.type;
          var v25212 = this.functionInterfaceType;
          v23285 = v25210.sourceIsSubtypeOfTarget(v25211, v25212);
        }
        v19357 = v23285;
      }
      var v13249 = v19357;
      var v3117 = !v13249;
      if (v3117) {
        var v13250 = this.checker;
        var v3116 = v13250.errorReporter;
        v3116.simpleError(ast$$109, "The instanceof operator requires the left operand to be of type Any or an object type, and the right operand to be of type Any or a subtype of the Function interface type");
      }
      binex$$10.type = this.booleanType;
      return binex$$10;
    }
    function v1097(returnStmt$$1) {
      var v3143 = this.thisFnc;
      if (v3143) {
        var targetType$$7 = null;
        var v13251 = this.checker;
        var v3122 = v13251.hasTargetType();
        if (v3122) {
          var v3118 = this.checker;
          var tcContext = v3118.currentContextualTypeContext;
          var accessorType$$1 = tcContext.targetAccessorType;
          if (accessorType$$1) {
            targetType$$7 = accessorType$$1;
          } else {
            var v13252 = this.checker;
            var v3119 = v13252.currentContextualTypeContext;
            var targetSig$$1 = v3119.targetSig;
            var v13253 = targetSig$$1;
            if (v13253) {
              var v23286 = targetSig$$1.returnType;
              var v19358 = v23286.type;
              var v19359 = this.voidType;
              v13253 = v19358 != v19359;
            }
            var v3121 = v13253;
            if (v3121) {
              var v3120 = targetSig$$1.returnType;
              targetType$$7 = v3120.type;
            }
          }
        }
        var v3142 = returnStmt$$1.returnExpression;
        if (v3142) {
          var v3123 = this.thisFnc;
          var v19360 = v3123.fncFlags;
          var v23287 = TypeScript$$25.FncFlags;
          var v19361 = v23287.HasReturnExpression;
          v3123.fncFlags = v19360 | v19361;
          var v23288 = targetType$$7 == null;
          if (v23288) {
            var v25214 = this.thisFnc;
            v23288 = v25214.returnTypeAnnotation;
          }
          var v19362 = v23288;
          if (v19362) {
            var v25215 = this.thisFnc;
            var v23289 = v25215.returnTypeAnnotation;
            v19362 = v23289.type;
          }
          var v13254 = v19362;
          if (v13254) {
            var v25216 = this.thisFnc;
            var v23290 = v25216.returnTypeAnnotation;
            var v19363 = v23290.type;
            var v19364 = this.voidType;
            v13254 = v19363 != v19364;
          }
          var v3125 = v13254;
          if (v3125) {
            var v13255 = this.thisFnc;
            var v3124 = v13255.returnTypeAnnotation;
            targetType$$7 = v3124.type;
          }
          var v3126 = this.checker;
          var v13256 = this.checker;
          var v3127 = v13256.inProvisionalTypecheckMode();
          var v3128 = targetType$$7 != null;
          var v3129 = returnStmt$$1.returnExpression;
          v3126.typeCheckWithContextualType(targetType$$7, v3127, v3128, v3129);
          var v3130;
          var v23291 = this.thisFnc;
          var v19365 = v23291.returnTypeAnnotation;
          if (v19365) {
            var v25217 = this.thisFnc;
            var v23292 = v25217.returnTypeAnnotation;
            v19365 = v23292.type;
          }
          var v13258 = v19365;
          if (v13258) {
            var v19366 = this.thisFnc;
            var v13257 = v19366.returnTypeAnnotation;
            v3130 = v13257.type;
          } else {
            v3130 = targetType$$7;
          }
          var expectedReturnType = v3130;
          if (expectedReturnType) {
            var v19367 = this.voidType;
            var v13259 = expectedReturnType == v19367;
            if (v13259) {
              var v23293 = returnStmt$$1.returnExpression;
              var v19368 = v23293.type;
              var v19369 = this.voidType;
              v13259 = v19368 != v19369;
            }
            var v3134 = v13259;
            if (v3134) {
              var v13260 = this.checker;
              var v3131 = v13260.errorReporter;
              v3131.simpleError(returnStmt$$1, "Return with value expression in void function");
              var v3132 = returnStmt$$1.returnExpression;
              returnStmt$$1.type = v3132.type;
            } else {
              var v3133 = returnStmt$$1;
              var v13261 = returnStmt$$1.returnExpression;
              var v26815 = this.cast(v13261, expectedReturnType);
              v3133.returnExpression = v26815;
              returnStmt$$1.type = expectedReturnType;
            }
          } else {
            if (targetType$$7) {
              var v19370 = returnStmt$$1.returnExpression;
              var v13262 = v19370.type;
              var v13263 = this.voidType;
              var v3137 = v13262 != v13263;
              if (v3137) {
                var v3135 = returnStmt$$1;
                var v13264 = returnStmt$$1.returnExpression;
                var v26816 = this.cast(v13264, targetType$$7);
                v3135.returnExpression = v26816;
              } else {
                var v3136 = returnStmt$$1.returnExpression;
                v3136.type = targetType$$7;
              }
            }
            var v3138 = returnStmt$$1.returnExpression;
            returnStmt$$1.type = v3138.type;
          }
          var v13265 = this.thisFnc;
          var v3139 = v13265.returnStatementsWithExpressions;
          var v19371 = this.thisFnc;
          var v13266 = v19371.returnStatementsWithExpressions;
          var v3140 = v13266.length;
          v3139[v3140] = returnStmt$$1;
        } else {
          var v3141;
          var v13268 = targetType$$7 == null;
          if (v13268) {
            var v13267 = this.checker;
            v3141 = v13267.voidType;
          } else {
            v3141 = targetType$$7;
          }
          returnStmt$$1.type = v3141;
        }
      }
      return returnStmt$$1;
    }
    function v1096(type$$56, ast$$108) {
      var v19372 = type$$56;
      if (v19372) {
        v19372 = type$$56.construct;
      }
      var v13269 = v19372;
      if (v13269) {
        var v25218 = type$$56.construct;
        var v23294 = v25218.signatures;
        var v19373 = v23294.length;
        v13269 = v19373 > 0;
      }
      var v3147 = v13269;
      if (v3147) {
        var i$$108 = 0;
        var v23295 = type$$56.construct;
        var v19374 = v23295.signatures;
        var v13270 = v19374.length;
        var v3146 = i$$108 < v13270;
        for (;v3146;) {
          var v26048 = type$$56.construct;
          var v25219 = v26048.signatures;
          var v23296 = v25219[i$$108];
          var v19375 = v23296.returnType;
          var v13271 = v19375.type;
          var v19376 = this.checker;
          var v13272 = v19376.voidType;
          var v3145 = v13271 == v13272;
          if (v3145) {
            var v13273 = this.checker;
            var v3144 = v13273.errorReporter;
            v3144.simpleError(ast$$108, "Constructors may not have a return type of 'void'");
            break;
          }
          i$$108 = i$$108 + 1;
          var v23297 = type$$56.construct;
          var v19377 = v23297.signatures;
          var v13274 = v19377.length;
          v3146 = i$$108 < v13274;
        }
      }
      return;
    }
    function v1095(arrayLit) {
      function v1094(index$$60) {
        var v13275 = elements$$2.members;
        var v3148 = v13275[index$$60];
        return v3148.type;
      }
      function v1093(index$$59, type$$55) {
        var v13276 = elements$$2.members;
        var v3149 = v13276[index$$59];
        v3149.type = type$$55;
        return;
      }
      function v1092() {
        var v3150 = elements$$2.members;
        return v3150.length;
      }
      var elements$$2 = arrayLit.operand;
      var elementType = this.anyType;
      var targetElementType = null;
      var v3151 = TypeScript$$25.TypeComparisonInfo;
      var comparisonInfo$$14 = new v3151;
      comparisonInfo$$14.onlyCaptureFirstError = true;
      var v13277 = this.checker;
      var v3154 = v13277.hasTargetType();
      if (v3154) {
        var v13278 = this.checker;
        var v3152 = v13278.currentContextualTypeContext;
        var targetType$$6 = v3152.contextualType;
        var v3153 = targetType$$6.elementType;
        if (v3153) {
          targetElementType = targetType$$6.elementType;
        }
      }
      if (elements$$2) {
        var prevInArrayElemTypeCheck = this.inArrayElementTypeCheck;
        this.inArrayElementTypeCheck = true;
        var v3155 = this.checker;
        var v13279 = this.checker;
        var v3156 = v13279.inProvisionalTypecheckMode();
        var v3157 = targetElementType != null;
        v3155.typeCheckWithContextualType(targetElementType, v3156, v3157, elements$$2);
        this.inArrayElementTypeCheck = prevInArrayElemTypeCheck;
        var v13280 = elements$$2.members;
        var v3158 = v13280[0];
        elementType = v3158.type;
        var collection$$3 = {getLength:v1092, setTypeAtIndex:v1093, getTypeAtIndex:v1094};
        var v3159 = this.checker;
        elementType = v3159.findBestCommonType(elementType, targetElementType, collection$$3, false, comparisonInfo$$14);
        var v23298 = this.checker;
        var v19378 = v23298.undefinedType;
        var v13281 = elementType == v19378;
        var v19380 = !v13281;
        if (v19380) {
          var v19379 = !prevInArrayElemTypeCheck;
          if (v19379) {
            var v23299 = this.nullType;
            v19379 = elementType == v23299;
          }
          v13281 = v19379;
        }
        var v3160 = v13281;
        if (v3160) {
          elementType = this.anyType;
        }
      }
      var v3166 = !elementType;
      if (v3166) {
        var emsg$$2 = "Incompatible types in array literal expression";
        var v13282 = comparisonInfo$$14.message;
        var v3164 = !v13282;
        if (v3164) {
          var v13283 = this.checker;
          var v3161 = v13283.errorReporter;
          v3161.simpleError(arrayLit, emsg$$2);
        } else {
          var v13284 = this.checker;
          var v3162 = v13284.errorReporter;
          var v13285 = emsg$$2 + ": ";
          var v13286 = comparisonInfo$$14.message;
          var v3163 = v13285 + v13286;
          v3162.simpleError(arrayLit, v3163);
        }
        elementType = this.anyType;
      } else {
        if (targetElementType) {
          var v13287 = this.checker;
          var v3165 = v13287.sourceIsAssignableToTarget(elementType, targetElementType);
          if (v3165) {
            elementType = targetElementType;
          }
        }
      }
      var v3167 = arrayLit;
      var v13288 = this.checker;
      var v26817 = v13288.makeArrayType(elementType);
      v3167.type = v26817;
      return;
    }
    function v1091(objectLit$$2) {
      var v3168 = TypeScript$$25.Type;
      var resultType$$2 = new v3168;
      var v3169 = resultType$$2;
      var v13289 = TypeScript$$25.TypeSymbol;
      var v19381 = this.checker;
      var v13290 = v19381.anon;
      var v13291 = objectLit$$2.minChar;
      var v19382 = objectLit$$2.limChar;
      var v19383 = objectLit$$2.minChar;
      var v13292 = v19382 - v19383;
      var v23300 = this.checker;
      var v19384 = v23300.locationInfo;
      var v13293 = v19384.unitIndex;
      var v26818 = new v13289(v13290, v13291, v13292, v13293, resultType$$2);
      v3169.symbol = v26818;
      var v3170 = resultType$$2;
      var v13294 = TypeScript$$25.ScopedMembers;
      var v19385 = TypeScript$$25.DualStringHashTable;
      var v23301 = TypeScript$$25.StringHashTable;
      var v19386 = new v23301;
      var v23302 = TypeScript$$25.StringHashTable;
      var v19387 = new v23302;
      var v13295 = new v19385(v19386, v19387);
      var v26819 = new v13294(v13295);
      v3170.members = v26819;
      var v3171 = resultType$$2;
      var v13296 = TypeScript$$25.SymbolTableScope;
      var v13297 = resultType$$2.members;
      var v26820 = new v13296(v13297, null, null, null, null);
      v3171.memberScope = v26820;
      var v3172 = TypeScript$$25.SymbolAggregateScope;
      var v3173 = resultType$$2.symbol;
      var aggScope$$3 = new v3172(v3173);
      var v3174 = resultType$$2.memberScope;
      aggScope$$3.addParentScope(v3174);
      var v3175 = this.scope;
      aggScope$$3.addParentScope(v3175);
      resultType$$2.containedScope = aggScope$$3;
      var memberDecls$$1 = objectLit$$2.operand;
      var prevThisType$$3 = this.thisType;
      var acceptTargetType = false;
      var targetType$$5 = null;
      var v13298 = this.checker;
      var v3180 = v13298.hasTargetType();
      if (v3180) {
        var v13299 = this.checker;
        var v3176 = v13299.currentContextualTypeContext;
        targetType$$5 = v3176.contextualType;
        var v19388 = targetType$$5;
        if (v19388) {
          v19388 = targetType$$5.symbol;
        }
        var v13300 = v19388;
        if (v13300) {
          var v23303 = this.checker;
          var v25220 = targetType$$5.symbol;
          var v23304 = v25220.typeCheckStatus;
          var v19389 = v23303.typeStatusIsFinished(v23304);
          v13300 = !v19389;
        }
        var v3179 = v13300;
        if (v3179) {
          var v13301 = targetType$$5.symbol;
          var v3178 = v13301.declAST;
          if (v3178) {
            var v13302 = targetType$$5.symbol;
            var v3177 = v13302.declAST;
            this.typeCheck(v3177);
          }
        }
        acceptTargetType = true;
      }
      if (memberDecls$$1) {
        var i$$107 = 0;
        var v3181 = memberDecls$$1.members;
        var len$$52 = v3181.length;
        var v3211 = i$$107 < len$$52;
        for (;v3211;) {
          var v3182 = memberDecls$$1.members;
          var binex$$9 = v3182[i$$107];
          var id$$23 = binex$$9.operand1;
          var text$$24;
          var targetMember$$1 = null;
          var fieldSymbol$$4 = null;
          var v13303 = id$$23.nodeType;
          var v19390 = TypeScript$$25.NodeType;
          var v13304 = v19390.Name;
          var v3186 = v13303 == v13304;
          if (v3186) {
            text$$24 = id$$23.text;
          } else {
            var v13305 = id$$23.nodeType;
            var v19391 = TypeScript$$25.NodeType;
            var v13306 = v19391.QString;
            var v3185 = v13305 == v13306;
            if (v3185) {
              var idText$$5 = id$$23.text;
              var v13307 = idText$$5.length;
              var v3183 = v13307 - 1;
              text$$24 = idText$$5.substring(1, v3183);
            } else {
              var v13308 = this.checker;
              var v3184 = v13308.errorReporter;
              v3184.simpleError(objectLit$$2, "malformed object literal");
              resultType$$2 = this.anyType;
              break;
            }
          }
          var v13309 = acceptTargetType;
          if (v13309) {
            v13309 = targetType$$5.memberScope;
          }
          var v3188 = v13309;
          if (v3188) {
            var v3187 = targetType$$5.memberScope;
            targetMember$$1 = v3187.find(text$$24, false, false);
          }
          var v23305 = binex$$9.operand2;
          var v19392 = v23305.nodeType;
          var v23306 = TypeScript$$25.NodeType;
          var v19393 = v23306.FuncDecl;
          var v13310 = v19392 == v19393;
          if (v13310) {
            var v19394 = binex$$9.operand2;
            v13310 = v19394.isAccessor();
          }
          var v3193 = v13310;
          if (v3193) {
            var funcDecl$$33 = binex$$9.operand2;
            var v13311 = resultType$$2.members;
            var v3189 = v13311.publicMembers;
            var accessorSym$$1 = v3189.lookup(text$$24);
            var v3190 = this.checker;
            var v3191 = resultType$$2.memberScope;
            accessorSym$$1 = v3190.createAccessorSymbol(funcDecl$$33, accessorSym$$1, resultType$$2, true, false, v3191, null);
            funcDecl$$33.accessorSymbol = accessorSym$$1;
            fieldSymbol$$4 = accessorSym$$1;
            var v13312 = id$$23.nodeType;
            var v19395 = TypeScript$$25.NodeType;
            var v13313 = v19395.Name;
            var v3192 = v13312 == v13313;
            if (v3192) {
              id$$23.sym = accessorSym$$1;
            }
          }
          var v3194 = this.checker;
          var v13314;
          var v19396 = acceptTargetType && targetMember$$1;
          if (v19396) {
            v13314 = targetMember$$1.getType();
          } else {
            v13314 = null;
          }
          var v3195 = v13314;
          var v3196 = binex$$9.operand2;
          v3194.typeCheckWithContextualType(v3195, false, acceptTargetType, v3196);
          var v3200 = acceptTargetType && targetMember$$1;
          if (v3200) {
            var v25221 = binex$$9.operand2;
            var v23307 = v25221.type;
            var v23308 = this.anyType;
            var v19397 = v23307 == v23308;
            var v23312 = !v19397;
            if (v23312) {
              var v23309 = this.checker;
              var v25222 = binex$$9.operand2;
              var v23310 = v25222.type;
              var v23311 = targetMember$$1.getType();
              v19397 = v23309.sourceIsAssignableToTarget(v23310, v23311);
            }
            var v13315 = v19397;
            var v19399 = !v13315;
            if (v19399) {
              var v26049 = binex$$9.operand2;
              var v25223 = v26049.nodeType;
              var v26050 = TypeScript$$25.NodeType;
              var v25224 = v26050.FuncDecl;
              var v23313 = v25223 == v25224;
              if (v23313) {
                var v25225 = binex$$9.operand2;
                v23313 = v25225.isAccessor();
              }
              var v19398 = v23313;
              if (v19398) {
                var v25226 = binex$$9.operand2;
                var v23314 = this.typeFromAccessorFuncDecl(v25226);
                var v23315 = targetMember$$1.getType();
                v19398 = v23314 == v23315;
              }
              v13315 = v19398;
            }
            var v3198 = v13315;
            if (v3198) {
              var v3197 = binex$$9.operand1;
              var v26821 = targetMember$$1.getType();
              v3197.type = v26821;
            }
          } else {
            var v3199 = binex$$9.operand2;
            var v13316;
            var v25227 = binex$$9.operand2;
            var v23316 = v25227.type;
            var v25228 = this.checker;
            var v23317 = v25228.undefinedType;
            var v19401 = v23316 == v23317;
            if (v19401) {
              v13316 = this.anyType;
            } else {
              var v19400 = binex$$9.operand2;
              v13316 = v19400.type;
            }
            v3199.type = v13316;
          }
          var v3210 = fieldSymbol$$4 == null;
          if (v3210) {
            var v3201 = binex$$9.operand2;
            var memberType$$1 = v3201.type;
            var v3202 = TypeScript$$25.ValueLocation;
            var field$$6 = new v3202;
            var v3203 = TypeScript$$25.FieldSymbol;
            var v3204 = id$$23.minChar;
            var v19402 = this.checker;
            var v13317 = v19402.locationInfo;
            var v3205 = v13317.unitIndex;
            fieldSymbol$$4 = new v3203(text$$24, v3204, v3205, true, field$$6);
            var v13318 = fieldSymbol$$4.flags;
            var v19403 = TypeScript$$25.SymbolFlags;
            var v13319 = v19403.Property;
            fieldSymbol$$4.flags = v13318 | v13319;
            field$$6.symbol = fieldSymbol$$4;
            var v3206 = fieldSymbol$$4;
            var v13320 = this.checker;
            var v26822 = v13320.getTypeCheckFinishedStatus();
            v3206.typeCheckStatus = v26822;
            var v3207 = field$$6;
            var v13321 = TypeScript$$25.TypeLink;
            var v26823 = new v13321;
            v3207.typeLink = v26823;
            var v3208 = field$$6.typeLink;
            v3208.type = memberType$$1;
            var v13322 = resultType$$2.members;
            var v3209 = v13322.publicMembers;
            v3209.add(text$$24, fieldSymbol$$4);
          }
          fieldSymbol$$4.isObjectLitField = true;
          i$$107 = i$$107 + 1;
          v3211 = i$$107 < len$$52;
        }
      }
      this.thisType = prevThisType$$3;
      objectLit$$2.type = resultType$$2;
      if (targetType$$5) {
        objectLit$$2.targetType = targetType$$5;
      }
      return;
    }
    function v1090(funcDecl$$32) {
      var v13323 = funcDecl$$32.isAccessor();
      var v3212 = !v13323;
      if (v3212) {
        return null;
      }
      var v13324 = funcDecl$$32.fncFlags;
      var v19404 = TypeScript$$25.FncFlags;
      var v13325 = v19404.GetAccessor;
      var v3215 = TypeScript$$25.hasFlag(v13324, v13325);
      if (v3215) {
        var v25229 = funcDecl$$32.type;
        var v23318 = v25229.call;
        var v19405 = v23318.signatures;
        var v13326 = v19405[0];
        var v3213 = v13326.returnType;
        return v3213.type;
      } else {
        var v26051 = funcDecl$$32.type;
        var v25230 = v26051.call;
        var v23319 = v25230.signatures;
        var v19406 = v23319[0];
        var v13327 = v19406.parameters;
        var v3214 = v13327[0];
        return v3214.getType();
      }
      return;
    }
    function v1089(ifStmt$$1) {
      var v3216 = ifStmt$$1;
      var v13328 = ifStmt$$1.cond;
      var v26824 = this.typeCheck(v13328);
      v3216.cond = v26824;
      var v3217 = ifStmt$$1.cond;
      this.typeCheckCondExpr(v3217);
      var v3218 = ifStmt$$1;
      var v13329 = ifStmt$$1.thenBod;
      var v26825 = this.typeCheck(v13329);
      v3218.thenBod = v26825;
      var v3219 = ifStmt$$1;
      var v13330 = ifStmt$$1.elseBod;
      var v26826 = this.typeCheck(v13330);
      v3219.elseBod = v26826;
      var v3220 = ifStmt$$1.thenBod;
      this.typeCheckCompoundStmtBlock(v3220, "if statement");
      var v3221 = ifStmt$$1.elseBod;
      this.typeCheckCompoundStmtBlock(v3221, "if statement");
      ifStmt$$1.type = this.voidType;
      return ifStmt$$1;
    }
    function v1088(stmts$$3, stmtType) {
      var v23320 = this.checker;
      var v19407 = v23320.styleSettings;
      var v13331 = v19407.blockInCompoundStmt;
      if (v13331) {
        v13331 = stmts$$3;
      }
      var v3225 = v13331;
      if (v3225) {
        var v13332 = stmts$$3.nodeType;
        var v19408 = TypeScript$$25.NodeType;
        var v13333 = v19408.Block;
        var v3224 = v13332 != v13333;
        if (v3224) {
          var v13334 = this.checker;
          var v3222 = v13334.errorReporter;
          var v3223 = stmtType + " requires a block";
          v3222.styleError(stmts$$3, v3223);
        }
      }
      return;
    }
    function v1087(cond$$3) {
      var v19409 = this.checker;
      var v13335 = v19409.styleSettings;
      var v3228 = v13335.assignmentInCond;
      if (v3228) {
        var v19410 = cond$$3 !== null;
        if (v19410) {
          var v23321 = cond$$3.nodeType;
          var v25231 = TypeScript$$25.NodeType;
          var v23322 = v25231.Asg;
          v19410 = v23321 >= v23322;
        }
        var v13336 = v19410;
        if (v13336) {
          var v19411 = cond$$3.nodeType;
          var v23323 = TypeScript$$25.NodeType;
          var v19412 = v23323.LastAsg;
          v13336 = v19411 <= v19412;
        }
        var v3227 = v13336;
        if (v3227) {
          var v13337 = this.checker;
          var v3226 = v13337.errorReporter;
          v3226.simpleError(cond$$3, "top-level assignment statement in conditional expression");
        }
      }
      return;
    }
    function v1086(doWhileStmt) {
      var v3229 = doWhileStmt;
      var v13338 = doWhileStmt.cond;
      var v26827 = this.typeCheck(v13338);
      v3229.cond = v26827;
      var v3230 = doWhileStmt.cond;
      this.typeCheckCondExpr(v3230);
      var v3231 = doWhileStmt;
      var v13339 = doWhileStmt.body;
      var v26828 = this.typeCheck(v13339);
      v3231.body = v26828;
      var v3232 = doWhileStmt.body;
      this.typeCheckCompoundStmtBlock(v3232, "do while statement");
      doWhileStmt.type = this.voidType;
      return doWhileStmt;
    }
    function v1085(whileStmt$$1) {
      var v3233 = whileStmt$$1;
      var v13340 = whileStmt$$1.cond;
      var v26829 = this.typeCheck(v13340);
      v3233.cond = v26829;
      var v3234 = whileStmt$$1.cond;
      this.typeCheckCondExpr(v3234);
      var v3235 = whileStmt$$1;
      var v13341 = whileStmt$$1.body;
      var v26830 = this.typeCheck(v13341);
      v3235.body = v26830;
      var v3236 = whileStmt$$1.body;
      this.typeCheckCompoundStmtBlock(v3236, "while statement");
      whileStmt$$1.type = this.voidType;
      return whileStmt$$1;
    }
    function v1084(forInStmt$$1) {
      var v3237 = forInStmt$$1;
      var v13342 = forInStmt$$1.obj;
      var v26831 = this.typeCheck(v13342);
      v3237.obj = v26831;
      var v3238 = forInStmt$$1;
      var v19413 = forInStmt$$1.lval;
      var v13343 = this.typeCheck(v19413);
      var v19414 = this.checker;
      var v13344 = v19414.stringType;
      var v26832 = this.cast(v13343, v13344);
      v3238.lval = v26832;
      var v19415 = forInStmt$$1.lval;
      var v13345 = v19415.nodeType;
      var v19416 = TypeScript$$25.NodeType;
      var v13346 = v19416.VarDecl;
      var v3244 = v13345 == v13346;
      if (v3244) {
        var varDecl$$19 = forInStmt$$1.lval;
        var v3240 = varDecl$$19.typeExpr;
        if (v3240) {
          var v13347 = this.checker;
          var v3239 = v13347.errorReporter;
          v3239.simpleError(varDecl$$19, "Variable declarations for for/in expressions may not contain a type annotation");
        }
        var v3243 = varDecl$$19.sym;
        if (v3243) {
          var v3241 = varDecl$$19.sym;
          var v13348 = this.checker;
          var v3242 = v13348.stringType;
          v3241.setType(v3242);
        }
      }
      var v3245 = forInStmt$$1;
      var v13349 = forInStmt$$1.body;
      var v26833 = this.typeCheck(v13349);
      v3245.body = v26833;
      var v3246 = forInStmt$$1.body;
      this.typeCheckCompoundStmtBlock(v3246, "for in statement");
      return forInStmt$$1;
    }
    function v1083(withStmt$$2) {
      var v13350 = this.checker;
      var v3249 = v13350.errorsOnWith;
      if (v3249) {
        var v13351 = this.checker;
        var v3247 = v13351.errorReporter;
        var v3248 = withStmt$$2.expr;
        v3247.simpleError(v3248, "All symbols within a 'with' block will be typed as 'any'");
      }
      var v3250 = withStmt$$2;
      var v13352 = withStmt$$2.expr;
      var v26834 = this.typeCheck(v13352);
      v3250.expr = v26834;
      var v3251 = this.checker;
      v3251.inWith = true;
      var v3252 = withStmt$$2;
      var v13353 = withStmt$$2.body;
      var v26835 = this.typeCheck(v13353);
      v3252.body = v26835;
      var v3253 = withStmt$$2.body;
      this.typeCheckCompoundStmtBlock(v3253, "with statement");
      var v3254 = this.checker;
      v3254.inWith = false;
      return withStmt$$2;
    }
    function v1082(forStmt$$1) {
      var v3255 = forStmt$$1;
      var v13354 = forStmt$$1.init;
      var v26836 = this.typeCheck(v13354);
      v3255.init = v26836;
      var v13355 = this.nestingLevel;
      this.nestingLevel = v13355 + 1;
      var v3256 = forStmt$$1;
      var v13356 = forStmt$$1.cond;
      var v26837 = this.typeCheck(v13356);
      v3256.cond = v26837;
      var v3257 = forStmt$$1.cond;
      this.typeCheckCondExpr(v3257);
      var v3258 = forStmt$$1;
      var v13357 = forStmt$$1.incr;
      var v26838 = this.typeCheck(v13357);
      v3258.incr = v26838;
      var v13358 = this.nestingLevel;
      this.nestingLevel = v13358 - 1;
      var v3259 = forStmt$$1;
      var v13359 = forStmt$$1.body;
      var v26839 = this.typeCheck(v13359);
      v3259.body = v26839;
      var v3260 = forStmt$$1.body;
      this.typeCheckCompoundStmtBlock(v3260, "for statement");
      forStmt$$1.type = this.voidType;
      return forStmt$$1;
    }
    function v1081(moduleDecl$$7) {
      var v13360 = moduleDecl$$7.mod;
      var v3261 = !v13360;
      if (v3261) {
        return moduleDecl$$7;
      }
      var v3263 = this.currentScript;
      if (v3263) {
        var v3262 = this.currentScript;
        v3262.requiresGlobal = true;
      }
      var mod$$3 = moduleDecl$$7.mod;
      var sym$$43 = null;
      var prevScope$$6 = this.scope;
      var prevThisType$$2 = this.thisType;
      var v3264 = this.checker;
      var prevCurrentModDecl$$1 = v3264.currentModDecl;
      var v3265 = this.checker;
      v3265.currentModDecl = moduleDecl$$7;
      this.thisType = null;
      this.scope = mod$$3.containedScope;
      var v3266 = moduleDecl$$7.members;
      this.typeCheck(v3266);
      sym$$43 = mod$$3.symbol;
      var v3267 = this.checker;
      v3267.currentModDecl = prevCurrentModDecl$$1;
      this.thisType = prevThisType$$2;
      this.scope = prevScope$$6;
      moduleDecl$$7.type = mod$$3;
      if (sym$$43) {
        var v3268 = TypeScript$$25.TypeCheckStatus;
        sym$$43.typeCheckStatus = v3268.Finished;
      }
      return moduleDecl$$7;
    }
    function v1080(importDecl$$2) {
      var v3269 = importDecl$$2.alias;
      var mod$$2 = v3269.type;
      var sym$$42 = null;
      var prevInImportTC = this.inImportTypeCheck;
      this.inImportTypeCheck = true;
      var v3270 = importDecl$$2.alias;
      this.typeCheck(v3270);
      var v3271 = importDecl$$2.alias;
      mod$$2 = v3271.type;
      var v3277 = mod$$2 == null;
      if (v3277) {
        var v13361 = this.checker;
        var v3272 = v13361.errorReporter;
        var v3273 = importDecl$$2.alias;
        var v23324 = importDecl$$2.id;
        var v19417 = v23324.actualText;
        var v13362 = "Could not resolve module alias '" + v19417;
        var v3274 = v13362 + "'";
        v3272.simpleError(v3273, v3274);
        var v3275 = this.checker;
        mod$$2 = v3275.anyType;
        var v13363 = importDecl$$2.id;
        var v3276 = v13363.sym;
        v3276.type = mod$$2;
      }
      var v3278 = importDecl$$2.id;
      v3278.type = mod$$2;
      sym$$42 = mod$$2.symbol;
      var v13364 = mod$$2.isModuleType();
      var v3286 = !v13364;
      if (v3286) {
        var v13365 = this.checker;
        var v3279 = v13365.errorReporter;
        var v3280 = importDecl$$2.alias;
        v3279.simpleError(v3280, "A module cannot be aliased to a non-module type");
      } else {
        sym$$42.type = mod$$2;
        var v25232 = this.checker;
        var v23325 = v25232.typeFlow;
        var v19418 = v23325.currentScript;
        if (v19418) {
          var v26052 = this.checker;
          var v25233 = v26052.typeFlow;
          var v23326 = v25233.currentScript;
          v19418 = v23326.topLevelMod;
        }
        var v13366 = v19418;
        if (v13366) {
          var v26053 = this.checker;
          var v25234 = v26053.typeFlow;
          var v23327 = v25234.currentScript;
          var v19419 = v23327.topLevelMod;
          v13366 = v19419.mod;
        }
        var v3282 = v13366;
        if (v3282) {
          var v26054 = this.checker;
          var v25235 = v26054.typeFlow;
          var v23328 = v25235.currentScript;
          var v19420 = v23328.topLevelMod;
          var v13367 = v19420.mod;
          var v3281 = v13367.importedModules;
          v3281.push(importDecl$$2);
        }
        var v13368 = importDecl$$2.id;
        var v3283 = v13368.sym;
        v3283.type = mod$$2;
        var v13369 = mod$$2.symbol;
        if (v13369) {
          var v19421 = mod$$2.symbol;
          v13369 = v19421.declAST;
        }
        var v3285 = v13369;
        if (v3285) {
          var v13370 = mod$$2.symbol;
          var v3284 = v13370.declAST;
          var v19422 = v3284.modFlags;
          var v25236 = TypeScript$$25.ModuleFlags;
          var v23329 = v25236.ShouldEmitModuleDecl;
          var v19423 = ~v23329;
          v3284.modFlags = v19422 & v19423;
        }
      }
      this.inImportTypeCheck = prevInImportTC;
      return importDecl$$2;
    }
    function v1079(interfaceDecl$$6) {
      var v3287 = interfaceDecl$$6.type;
      this.typeCheckBases(v3287);
      var v3288 = interfaceDecl$$6.extendsList;
      var v13371 = interfaceDecl$$6.type;
      var v3289 = v13371.symbol;
      this.typeCheckBaseListPrivacy(v3288, v3289, true);
      var v3290 = interfaceDecl$$6.members;
      this.typeCheck(v3290);
      var v3291 = interfaceDecl$$6.type;
      this.checkBaseTypeMemberInheritance(v3291, interfaceDecl$$6);
      var v3305 = interfaceDecl$$6.extendsList;
      if (v3305) {
        var i$$106 = 0;
        var v23330 = interfaceDecl$$6.extendsList;
        var v19424 = v23330.members;
        var v13372 = v19424.length;
        var v3304 = i$$106 < v13372;
        for (;v3304;) {
          var v25237 = interfaceDecl$$6.extendsList;
          var v23331 = v25237.members;
          var v19425 = v23331[i$$106];
          var v13373 = v19425.type;
          var v3295 = v13373.call;
          if (v3295) {
            var v13374 = interfaceDecl$$6.type;
            var v3294 = v13374.call;
            if (v3294) {
              var v13375 = interfaceDecl$$6.type;
              var v3292 = v13375.call;
              var v23332 = interfaceDecl$$6.type;
              var v19426 = v23332.call;
              var v13376 = v19426.signatures;
              var v26416 = interfaceDecl$$6.extendsList;
              var v26055 = v26416.members;
              var v25238 = v26055[i$$106];
              var v23333 = v25238.type;
              var v19427 = v23333.call;
              var v13377 = v19427.signatures;
              var v26840 = v13376.concat(v13377);
              v3292.signatures = v26840;
            } else {
              var v3293 = interfaceDecl$$6.type;
              var v25239 = interfaceDecl$$6.extendsList;
              var v23334 = v25239.members;
              var v19428 = v23334[i$$106];
              var v13378 = v19428.type;
              v3293.call = v13378.call;
            }
          }
          var v25240 = interfaceDecl$$6.extendsList;
          var v23335 = v25240.members;
          var v19429 = v23335[i$$106];
          var v13379 = v19429.type;
          var v3299 = v13379.construct;
          if (v3299) {
            var v13380 = interfaceDecl$$6.type;
            var v3298 = v13380.construct;
            if (v3298) {
              var v13381 = interfaceDecl$$6.type;
              var v3296 = v13381.construct;
              var v23336 = interfaceDecl$$6.type;
              var v19430 = v23336.construct;
              var v13382 = v19430.signatures;
              var v26417 = interfaceDecl$$6.extendsList;
              var v26056 = v26417.members;
              var v25241 = v26056[i$$106];
              var v23337 = v25241.type;
              var v19431 = v23337.construct;
              var v13383 = v19431.signatures;
              var v26841 = v13382.concat(v13383);
              v3296.signatures = v26841;
            } else {
              var v3297 = interfaceDecl$$6.type;
              var v25242 = interfaceDecl$$6.extendsList;
              var v23338 = v25242.members;
              var v19432 = v23338[i$$106];
              var v13384 = v19432.type;
              v3297.construct = v13384.construct;
            }
          }
          var v25243 = interfaceDecl$$6.extendsList;
          var v23339 = v25243.members;
          var v19433 = v23339[i$$106];
          var v13385 = v19433.type;
          var v3303 = v13385.index;
          if (v3303) {
            var v13386 = interfaceDecl$$6.type;
            var v3302 = v13386.index;
            if (v3302) {
              var v13387 = interfaceDecl$$6.type;
              var v3300 = v13387.index;
              var v23340 = interfaceDecl$$6.type;
              var v19434 = v23340.index;
              var v13388 = v19434.signatures;
              var v26418 = interfaceDecl$$6.extendsList;
              var v26057 = v26418.members;
              var v25244 = v26057[i$$106];
              var v23341 = v25244.type;
              var v19435 = v23341.index;
              var v13389 = v19435.signatures;
              var v26842 = v13388.concat(v13389);
              v3300.signatures = v26842;
            } else {
              var v3301 = interfaceDecl$$6.type;
              var v25245 = interfaceDecl$$6.extendsList;
              var v23342 = v25245.members;
              var v19436 = v23342[i$$106];
              var v13390 = v19436.type;
              v3301.index = v13390.index;
            }
          }
          i$$106 = i$$106 + 1;
          var v23343 = interfaceDecl$$6.extendsList;
          var v19437 = v23343.members;
          var v13391 = v19437.length;
          v3304 = i$$106 < v13391;
        }
      }
      return interfaceDecl$$6;
    }
    function v1078(type$$54, ast$$107) {
      var v3309 = type$$54.call;
      if (v3309) {
        var v3306 = type$$54.call;
        var v3307 = this.checker;
        var v13392 = type$$54.construct;
        var v3308 = v13392 != null;
        v3306.typeCheck(v3307, ast$$107, v3308);
      }
      var v3312 = type$$54.construct;
      if (v3312) {
        var v3310 = type$$54.construct;
        var v3311 = this.checker;
        v3310.typeCheck(v3311, ast$$107, false);
      }
      var v3315 = type$$54.index;
      if (v3315) {
        var v3313 = type$$54.index;
        var v3314 = this.checker;
        v3313.typeCheck(v3314, ast$$107, false);
      }
      return;
    }
    function v1077(classDecl$$9) {
      var v3316 = classDecl$$9.type;
      var typeSymbol$$6 = v3316.symbol;
      var v13393 = typeSymbol$$6.typeCheckStatus;
      var v19438 = TypeScript$$25.TypeCheckStatus;
      var v13394 = v19438.Finished;
      var v3320 = v13393 == v13394;
      if (v3320) {
        return classDecl$$9;
      } else {
        var v13395 = typeSymbol$$6.typeCheckStatus;
        var v19439 = TypeScript$$25.TypeCheckStatus;
        var v13396 = v19439.Started;
        var v3319 = v13395 == v13396;
        if (v3319) {
          return classDecl$$9;
        } else {
          var v3317 = TypeScript$$25.TypeCheckStatus;
          typeSymbol$$6.typeCheckStatus = v3317.Started;
          var v3318 = this.checker;
          v3318.addStartedPTO(typeSymbol$$6);
        }
      }
      var prevScope$$5 = this.scope;
      var svClassNode$$1 = this.thisClassNode;
      this.thisClassNode = classDecl$$9;
      var classType$$6 = classDecl$$9.type;
      var v3321 = classType$$6.instanceType;
      this.typeCheckBases(v3321);
      var v3322 = classDecl$$9.extendsList;
      this.typeCheckBaseListPrivacy(v3322, typeSymbol$$6, true);
      var v3323 = classDecl$$9.implementsList;
      this.typeCheckBaseListPrivacy(v3323, typeSymbol$$6, false);
      var prevThisType$$1 = this.thisType;
      this.thisType = classType$$6.instanceType;
      var v3324 = classType$$6.instanceType;
      this.scope = v3324.containedScope;
      var v3329 = classDecl$$9.constructorDecl;
      if (v3329) {
        var v3325 = classType$$6.instanceType;
        this.scope = v3325.constructorScope;
        var ssb$$1 = this.scope;
        var v3326 = ssb$$1.valueMembers;
        var funcTable$$2 = v3326.allMembers;
        var v19440 = classDecl$$9.constructorDecl;
        var v13397 = v19440.type;
        var v3327 = v13397.symbol;
        var v13398 = classDecl$$9.constructorDecl;
        var v3328 = v13398.arguments;
        this.addConstructorLocalArgs(v3327, v3328, funcTable$$2, true);
      }
      var v3330 = classDecl$$9.members;
      this.typeCheck(v3330);
      var v3331 = TypeScript$$25.TypeCheckStatus;
      typeSymbol$$6.typeCheckStatus = v3331.Finished;
      this.checkBaseTypeMemberInheritance(classType$$6, classDecl$$9);
      this.checkMembersImplementInterfaces(classType$$6);
      this.typeCheckOverloadSignatures(classType$$6, classDecl$$9);
      var v3332 = classType$$6.instanceType;
      this.typeCheckOverloadSignatures(v3332, classDecl$$9);
      var v13399 = classDecl$$9.constructorDecl;
      var v3336 = !v13399;
      if (v3336) {
        var v23344 = classDecl$$9.extendsList;
        if (v23344) {
          var v26058 = classDecl$$9.extendsList;
          var v25246 = v26058.members;
          v23344 = v25246.length;
        }
        var v19441 = v23344;
        if (v19441) {
          var v26059 = classDecl$$9.extendsList;
          var v25247 = v26059.members;
          var v23345 = v25247[0];
          v19441 = v23345.type;
        }
        var v13400 = v19441;
        if (v13400) {
          var v26591 = classDecl$$9.extendsList;
          var v26419 = v26591.members;
          var v26060 = v26419[0];
          var v25248 = v26060.type;
          var v23346 = v25248.symbol;
          var v19442 = v23346.type;
          v13400 = v19442.isClass();
        }
        var v3335 = v13400;
        if (v3335) {
          var v3333 = classDecl$$9.type;
          var v26061 = classDecl$$9.extendsList;
          var v25249 = v26061.members;
          var v23347 = v25249[0];
          var v19443 = v23347.type;
          var v13401 = v19443.symbol;
          var v3334 = v13401.type;
          TypeScript$$25.cloneParentConstructGroupForChildType(v3333, v3334);
        }
      }
      this.thisType = prevThisType$$1;
      this.thisClassNode = svClassNode$$1;
      this.scope = prevScope$$5;
      return classDecl$$9;
    }
    function v1076(derivedType, derivedTypeDecl) {
      function v1075(key$$45, s$$28, c$$12) {
        var sym$$41 = s$$28;
        var j$$16 = 0;
        var v3349 = j$$16 < len$$51;
        for (;v3349;) {
          var v3337 = instanceType$$6.extendsList;
          var base$$3 = v3337[j$$16];
          var v13402 = base$$3.memberScope;
          var v3348 = v13402 == null;
          if (v3348) {
            var v13403 = _this$$12.checker;
            var v3338 = v13403.errorReporter;
            var v23348 = base$$3.symbol;
            var v19444 = v23348.name;
            var v13404 = "Base type '" + v19444;
            var v3339 = v13404 + "' lacks an implementation.";
            v3338.simpleError(derivedTypeDecl, v3339);
          } else {
            var v3340 = base$$3.memberScope;
            var v3341 = sym$$41.name;
            var bSym = v3340.find(v3341, false, false);
            if (bSym) {
              var aType = sym$$41.getType();
              var bType = bSym.getType();
              var v19445 = _this$$12.checker;
              var v13405 = v19445.sourceIsSubtypeOfTarget(aType, bType);
              var v3347 = !v13405;
              if (v3347) {
                var v13406 = _this$$12.checker;
                var v3342 = v13406.errorReporter;
                var v25250 = sym$$41.name;
                var v23349 = "Type of overridden member '" + v25250;
                var v19446 = v23349 + "' is not subtype of original member defined by type '";
                var v23350 = bSym.container;
                var v19447 = v23350.name;
                var v13407 = v19446 + v19447;
                var v3343 = v13407 + "'";
                v3342.simpleErrorFromSym(sym$$41, v3343);
              } else {
                var v19448 = sym$$41.kind();
                var v23351 = TypeScript$$25.SymbolKind;
                var v19449 = v23351.Type;
                var v13408 = v19448 == v19449;
                if (v13408) {
                  var v19450 = bSym.kind();
                  var v23352 = TypeScript$$25.SymbolKind;
                  var v19451 = v23352.Field;
                  v13408 = v19450 == v19451;
                }
                var v3346 = v13408;
                if (v3346) {
                  var v13409 = _this$$12.checker;
                  var v3344 = v13409.errorReporter;
                  var v19452 = sym$$41.name;
                  var v13410 = "Cannot override field '" + v19452;
                  var v3345 = v13410 + "' with method";
                  v3344.simpleErrorFromSym(sym$$41, v3345);
                }
              }
            }
          }
          j$$16 = j$$16 + 1;
          v3349 = j$$16 < len$$51;
        }
        return;
      }
      var _this$$12 = this;
      var instanceType$$6 = derivedType.getInstanceType();
      var v13411 = instanceType$$6.extendsList;
      var v3350 = v13411 == null;
      if (v3350) {
        return;
      }
      var v3351 = instanceType$$6.extendsList;
      var len$$51 = v3351.length;
      var v3359 = len$$51 > 0;
      if (v3359) {
        var v3352 = TypeScript$$25.StringHashTable;
        var names$$1 = new v3352;
        var v3356 = instanceType$$6.isClassInstance();
        if (v3356) {
          var i$$105 = 0;
          var v3355 = i$$105 < len$$51;
          for (;v3355;) {
            var v13412 = instanceType$$6.extendsList;
            var v3353 = v13412[i$$105];
            var v3354 = i$$105 > 0;
            this.assertUniqueNamesInBaseTypes(names$$1, v3353, derivedTypeDecl, v3354);
            i$$105 = i$$105 + 1;
            v3355 = i$$105 < len$$51;
          }
        }
        var v3358 = instanceType$$6.members;
        if (v3358) {
          var v13413 = instanceType$$6.members;
          var v3357 = v13413.publicMembers;
          v3357.map(v1075, null);
        }
      }
      return;
    }
    function v1074(names, type$$53, classDecl$$8, checkUnique) {
      function v1073(key$$44, s$$27, c$$11) {
        var sym$$40 = s$$27;
        var v3360 = sym$$40.name;
        var dup = names.lookup(v3360);
        if (dup) {
          if (checkUnique) {
            var v13414 = _this$$11.checker;
            var v3361 = v13414.errorReporter;
            var v26681 = classDecl$$8.name;
            var v26592 = v26681.actualText;
            var v26420 = "duplicate member name in bases for " + v26592;
            var v26062 = v26420 + ": ";
            var v26421 = type$$53.symbol;
            var v26063 = v26421.name;
            var v25251 = v26062 + v26063;
            var v23353 = v25251 + " and ";
            var v25252 = dup.container;
            var v23354 = v25252.name;
            var v19453 = v23353 + v23354;
            var v13415 = v19453 + " both contain member with name ";
            var v13416 = sym$$40.name;
            var v3362 = v13415 + v13416;
            v3361.simpleError(classDecl$$8, v3362);
          }
        } else {
          var v3363 = sym$$40.name;
          names.add(v3363, sym$$40);
        }
        return;
      }
      var _this$$11 = this;
      if (type$$53) {
        var v3365 = type$$53.members;
        if (v3365) {
          var v13417 = type$$53.members;
          var v3364 = v13417.publicMembers;
          v3364.map(v1073, null);
        }
        var v3370 = type$$53.extendsList;
        if (v3370) {
          var v3366 = type$$53.extendsList;
          var len$$50 = v3366.length;
          var i$$104 = 0;
          var v3369 = i$$104 < len$$50;
          for (;v3369;) {
            var v26064 = type$$53.extendsList;
            var v25253 = v26064[i$$104];
            var v23355 = v25253.symbol;
            var v19454 = v23355.flags;
            var v23356 = TypeScript$$25.SymbolFlags;
            var v19455 = v23356.RecursivelyReferenced;
            var v13418 = v19454 & v19455;
            var v3368 = !v13418;
            if (v3368) {
              var v13419 = type$$53.extendsList;
              var v3367 = v13419[i$$104];
              this.assertUniqueNamesInBaseTypes(names, v3367, classDecl$$8, checkUnique);
            }
            i$$104 = i$$104 + 1;
            v3369 = i$$104 < len$$50;
          }
        }
      }
      return;
    }
    function v1072(bases$$7) {
      var v3371 = bases$$7 == null;
      if (v3371) {
        return;
      }
      var v3372 = bases$$7.members;
      var basesLen$$2 = v3372.length;
      var i$$103 = 0;
      var v3375 = i$$103 < basesLen$$2;
      for (;v3375;) {
        var v3373 = bases$$7.members;
        var baseExpr$$2 = v3373[i$$103];
        var baseSymbol$$3 = null;
        var v13420 = baseExpr$$2.nodeType;
        var v19456 = TypeScript$$25.NodeType;
        var v13421 = v19456.Call;
        var v3374 = v13420 == v13421;
        if (v3374) {
          this.typeCheckNew(baseExpr$$2);
        }
        i$$103 = i$$103 + 1;
        v3375 = i$$103 < basesLen$$2;
      }
      return;
    }
    function v1071(implementingType) {
      var instanceType$$5 = implementingType.getInstanceType();
      var v3388 = instanceType$$5.implementsList;
      if (v3388) {
        var v3376 = instanceType$$5.implementsList;
        var len$$49 = v3376.length;
        var i$$102 = 0;
        var v3387 = i$$102 < len$$49;
        for (;v3387;) {
          var v3377 = instanceType$$5.implementsList;
          var interfaceType$$3 = v3377[i$$102];
          var v3378 = TypeScript$$25.TypeComparisonInfo;
          var comparisonInfo$$13 = new v3378;
          var v19457 = this.checker;
          var v13422 = v19457.sourceIsSubtypeOfTarget(instanceType$$5, interfaceType$$3, comparisonInfo$$13);
          var v3386 = !v13422;
          if (v3386) {
            var v23357 = instanceType$$5.getTypeName();
            var v19458 = "Class '" + v23357;
            var v13423 = v19458 + "' declares interface '";
            var v13424 = interfaceType$$3.getTypeName();
            var v3379 = v13423 + v13424;
            var emsg$$1 = v3379 + "' but does not implement it";
            var v13425 = comparisonInfo$$13.message;
            var v3385 = !v13425;
            if (v3385) {
              var v13426 = this.checker;
              var v3380 = v13426.errorReporter;
              var v3381 = instanceType$$5.symbol;
              v3380.simpleErrorFromSym(v3381, emsg$$1);
            } else {
              var v13427 = this.checker;
              var v3382 = v13427.errorReporter;
              var v3383 = instanceType$$5.symbol;
              var v13428 = emsg$$1 + ": ";
              var v13429 = comparisonInfo$$13.message;
              var v3384 = v13428 + v13429;
              v3382.simpleErrorFromSym(v3383, v3384);
            }
          }
          i$$102 = i$$102 + 1;
          v3387 = i$$102 < len$$49;
        }
      }
      return;
    }
    function v1070(type$$52) {
      var seenInterface = false;
      var bases$$6 = type$$52.extendsList;
      var baseLinks = type$$52.extendsTypeLinks;
      if (bases$$6) {
        var len$$48 = bases$$6.length;
        var v3389 = len$$48 > 0;
        if (v3389) {
          var v13430 = type$$52.typeFlags;
          var v19459 = TypeScript$$25.TypeFlags;
          var v13431 = v19459.HasBaseType;
          type$$52.typeFlags = v13430 | v13431;
        }
        var i$$101 = 0;
        var v3413 = i$$101 < len$$48;
        for (;v3413;) {
          var v13432 = bases$$6[i$$101];
          var v19460 = this.checker;
          var v13433 = v19460.anyType;
          var v3399 = v13432 == v13433;
          if (v3399) {
            var v3390 = baseLinks[i$$101];
            v3390.type = null;
            var v13434 = this.checker;
            var v3391 = v13434.errorReporter;
            var oldErrors = v3391.errorSink;
            var v3392 = TypeScript$$25.CompilerDiagnostics;
            var v13435 = oldErrors.length;
            var v3393 = v13435 == 0;
            v3392.assert(v3393, "There shouldnt be any contextual errors when typechecking base type names");
            var v13436 = this.checker;
            var v3394 = v13436.errorReporter;
            v3394.pushToErrorSink = true;
            var v3395 = bases$$6;
            var v3396 = i$$101;
            var v13437 = this.checker;
            var v13438 = baseLinks[i$$101];
            var v13439 = type$$52.containedScope;
            var v26843 = v13437.resolveBaseTypeLink(v13438, v13439);
            v3395[v3396] = v26843;
            var v13440 = this.checker;
            var v3397 = v13440.errorReporter;
            v3397.pushToErrorSink = false;
            var v13441 = this.checker;
            var v3398 = v13441.errorReporter;
            v3398.freeCapturedErrors();
          }
          var base$$2 = bases$$6[i$$101];
          var v3400 = baseLinks[i$$101];
          var baseRef$$1 = v3400.ast;
          var v13442 = base$$2.symbol;
          if (v13442) {
            var v23358 = base$$2.symbol;
            var v19461 = v23358.name;
            v13442 = v19461 == "Object";
          }
          var v3401 = v13442;
          if (v3401) {
            var v19462 = base$$2.symbol;
            var v13443 = v19462.container;
            var v19463 = this.checker;
            var v13444 = v19463.gloMod;
            v3401 = v13443 == v13444;
          }
          var baseTypeOfObject = v3401;
          if (baseTypeOfObject) {
            var v13445 = type$$52.typeFlags;
            var v19464 = TypeScript$$25.TypeFlags;
            var v13446 = v19464.HasBaseTypeOfObject;
            type$$52.typeFlags = v13445 | v13446;
          }
          var v3412 = base$$2.isClassInstance();
          if (v3412) {
            var v13447 = type$$52.isClassInstance();
            var v3404 = !v13447;
            if (v3404) {
              var v13448 = this.checker;
              var v3402 = v13448.errorReporter;
              v3402.simpleError(baseRef$$1, "Interface base type must be interface");
            } else {
              if (seenInterface) {
                var v13449 = this.checker;
                var v3403 = v13449.errorReporter;
                v3403.simpleError(baseRef$$1, "Class may not follow interface as base type");
              }
            }
          } else {
            var v3411 = base$$2.isModuleType();
            if (v3411) {
              var v13450 = this.checker;
              var v3405 = v13450.errorReporter;
              v3405.simpleError(baseRef$$1, "Types may not be derived from module types");
            } else {
              var v3410 = base$$2.members;
              if (v3410) {
                var v3406 = !seenInterface;
                if (v3406) {
                  seenInterface = true;
                }
              } else {
                var v13451 = type$$52.isClassInstance();
                var v3409 = !v13451;
                if (v3409) {
                  var v13452 = this.checker;
                  var v3407 = v13452.errorReporter;
                  v3407.simpleError(baseRef$$1, "Interface base type must be interface");
                } else {
                  var v13453 = this.checker;
                  var v3408 = v13453.errorReporter;
                  v3408.simpleError(baseRef$$1, "Base type must be interface or class");
                }
                break;
              }
            }
          }
          i$$101 = i$$101 + 1;
          v3413 = i$$101 < len$$48;
        }
      }
      return;
    }
    function v1069(funcDecl$$31) {
      function v1068(typeName$$10, isModuleName$$9) {
        return _this$$10.functionReturnTypePrivacyErrorReporter(funcDecl$$31, signature$$10, typeName$$10, isModuleName$$9);
      }
      function v1067(index$$58) {
        var v13454 = funcDecl$$31.returnStatementsWithExpressions;
        var v3414 = v13454[index$$58];
        return v3414.type;
      }
      function v1066(index$$57, type$$51) {
        var v13455 = funcDecl$$31.returnStatementsWithExpressions;
        var v3415 = v13455[index$$57];
        v3415.type = type$$51;
        return;
      }
      function v1065() {
        var v3416 = funcDecl$$31.returnStatementsWithExpressions;
        return v3416.length;
      }
      function v1064(sym$$39) {
        var v3417 = sym$$39.kind();
        var v13456 = TypeScript$$25.SymbolKind;
        var v3418 = v13456.Parameter;
        return v3417 == v3418;
      }
      function v1063(typeName$$9, isModuleName$$8) {
        var v13457 = signature$$10.parameters;
        var v3419 = v13457[p$$1];
        return _this$$10.functionArgumentPrivacyErrorReporter(funcDecl$$31, p$$1, v3419, typeName$$9, isModuleName$$8);
      }
      function v1062(typeName$$8, isModuleName$$7) {
        return _this$$10.functionArgumentPrivacyErrorReporter(funcDecl$$31, p$$1, symbol$$21, typeName$$8, isModuleName$$7);
      }
      var _this$$10 = this;
      this.nestingLevel = 0;
      var fnType = funcDecl$$31.type;
      var fgSym$$4 = fnType.symbol;
      var signature$$10 = funcDecl$$31.signature;
      var v13458 = this.checker;
      var v13459 = signature$$10.typeCheckStatus;
      var v3427 = v13458.typeStatusIsFinished(v13459);
      if (v3427) {
        return funcDecl$$31;
      } else {
        var v13460 = signature$$10.typeCheckStatus;
        var v19465 = TypeScript$$25.TypeCheckStatus;
        var v13461 = v19465.Started;
        var v3426 = v13460 == v13461;
        if (v3426) {
          var v26065 = funcDecl$$31.returnTypeAnnotation;
          var v25254 = !v26065;
          if (v25254) {
            v25254 = funcDecl$$31.bod;
          }
          var v23359 = v25254;
          if (v23359) {
            var v25255 = funcDecl$$31.isSignature();
            v23359 = !v25255;
          }
          var v19466 = v23359;
          if (v19466) {
            var v23360 = funcDecl$$31.isConstructor;
            v19466 = !v23360;
          }
          var v13462 = v19466;
          if (v13462) {
            v13462 = this.allReturnsAreVoid(funcDecl$$31);
          }
          var v3425 = v13462;
          if (v3425) {
            var v3420 = signature$$10.returnType;
            v3420.type = this.voidType;
            return funcDecl$$31;
          } else {
            var v13463 = funcDecl$$31.returnTypeAnnotation;
            var v3424 = v13463 == null;
            if (v3424) {
              var v19467 = this.checker;
              var v13464 = v19467.styleSettings;
              var v3422 = v13464.implicitAny;
              if (v3422) {
                var v13465 = this.checker;
                var v3421 = v13465.errorReporter;
                v3421.styleError(funcDecl$$31, "type implicitly set to 'any'");
              }
              var v3423 = signature$$10.returnType;
              v3423.type = this.anyType;
              var v13466 = fgSym$$4.flags;
              var v19468 = TypeScript$$25.SymbolFlags;
              var v13467 = v19468.RecursivelyReferenced;
              fgSym$$4.flags = v13466 | v13467;
            }
            return funcDecl$$31;
          }
        }
      }
      var v3428 = TypeScript$$25.TypeCheckStatus;
      signature$$10.typeCheckStatus = v3428.Started;
      var v3429 = this.checker;
      v3429.addStartedPTO(signature$$10);
      var prevScope$$4 = this.scope;
      var prevFnc = this.thisFnc;
      var prevMethodStatus$$2 = this.enclosingFncIsMethod;
      var prevClassNode = this.thisClassNode;
      var v3430 = funcDecl$$31.isMethod();
      var v13468 = !v3430;
      if (v13468) {
        v3430 = funcDecl$$31.isConstructor;
      }
      this.enclosingFncIsMethod = v3430;
      this.thisFnc = funcDecl$$31;
      var v3431 = funcDecl$$31.type;
      var container$$21 = v3431.symbol;
      var prevThisType = this.thisType;
      var v3432 = this.checker;
      var prevLocationInfo$$2 = v3432.locationInfo;
      var funcTable$$1 = null;
      var acceptedContextualType = false;
      var targetParams = null;
      var targetReturnType$$1 = null;
      var v3433 = funcDecl$$31.isAccessor();
      if (v3433) {
        var v13469 = funcDecl$$31.fncFlags;
        var v19469 = TypeScript$$25.FncFlags;
        var v13470 = v19469.GetAccessor;
        v3433 = TypeScript$$25.hasFlag(v13469, v13470);
      }
      var isGetter$$4 = v3433;
      var v3434 = funcDecl$$31.isAccessor();
      if (v3434) {
        var v13471 = funcDecl$$31.fncFlags;
        var v19470 = TypeScript$$25.FncFlags;
        var v13472 = v19470.SetAccessor;
        v3434 = TypeScript$$25.hasFlag(v13471, v13472);
      }
      var isSetter$$4 = v3434;
      var v3435;
      var v19471 = isGetter$$4 || isSetter$$4;
      if (v19471) {
        v19471 = funcDecl$$31.accessorSymbol;
      }
      var v13474 = v19471;
      if (v13474) {
        var v13473 = funcDecl$$31.accessorSymbol;
        v3435 = v13473.getType();
      } else {
        v3435 = null;
      }
      var accessorType = v3435;
      var v3436 = this.checker;
      var prevModDecl$$1 = v3436.currentModDecl;
      var v13475 = funcDecl$$31.isConstructor;
      if (v13475) {
        var v19472 = funcDecl$$31.isOverload;
        v13475 = !v19472;
      }
      var v3446 = v13475;
      if (v3446) {
        var v13476 = fnType.instanceType;
        var v3438 = v13476 == null;
        if (v3438) {
          var v13477 = this.checker;
          var v3437 = v13477.errorReporter;
          v3437.simpleError(funcDecl$$31, "Malformed function body (is this a class named the same as an existing interface?)");
          return funcDecl$$31;
        }
        var v3439 = fnType.instanceType;
        this.scope = v3439.constructorScope;
        var ssb = this.scope;
        var v3440 = ssb.valueMembers;
        funcTable$$1 = v3440.allMembers;
      } else {
        var v19473 = funcDecl$$31.isSpecialFn();
        if (v19473) {
          var v25256 = funcDecl$$31.fncFlags;
          var v26066 = TypeScript$$25.FncFlags;
          var v25257 = v26066.Signature;
          var v23361 = v25256 & v25257;
          v19473 = !v23361;
        }
        var v13478 = v19473;
        var v19474 = !v13478;
        if (v19474) {
          v13478 = funcDecl$$31.isOverload;
        }
        var v3445 = v13478;
        if (v3445) {
          funcTable$$1 = funcDecl$$31.symbols;
          var v23362 = funcDecl$$31.fncFlags;
          var v25258 = TypeScript$$25.FncFlags;
          var v23363 = v25258.Static;
          var v19475 = TypeScript$$25.hasFlag(v23362, v23363);
          var v13479 = !v19475;
          if (v13479) {
            v13479 = fnType.containedScope;
          }
          var v3441 = v13479;
          if (v3441) {
            this.scope = fnType.containedScope;
          }
        } else {
          var v3442 = funcDecl$$31.bod;
          if (v3442) {
            this.scope = fnType.containedScope;
          }
          ssb = this.scope;
          var v13480 = ssb;
          if (v13480) {
            v13480 = ssb.valueMembers;
          }
          var v3444 = v13480;
          if (v3444) {
            var v3443 = ssb.valueMembers;
            funcTable$$1 = v3443.allMembers;
          }
        }
      }
      var v19476 = funcDecl$$31.isConstructor;
      if (v19476) {
        v19476 = funcDecl$$31.bod;
      }
      var v13481 = v19476;
      if (v13481) {
        var v19477 = funcDecl$$31.fncFlags;
        var v23364 = TypeScript$$25.FncFlags;
        var v19478 = v23364.ClassMethod;
        v13481 = TypeScript$$25.hasFlag(v19477, v19478);
      }
      var v3458 = v13481;
      if (v3458) {
        var v23365 = funcDecl$$31.classDecl;
        var v19479 = v23365.type;
        var v13482 = v19479.instanceType;
        var v3447 = v13482.typeFlags;
        var v13483 = TypeScript$$25.TypeFlags;
        var v3448 = v13483.HasBaseType;
        var hasBaseType = TypeScript$$25.hasFlag(v3447, v3448);
        var v3449 = !hasBaseType;
        var v13486 = !v3449;
        if (v13486) {
          var v25259 = funcDecl$$31.classDecl;
          var v23366 = v25259.type;
          var v19480 = v23366.instanceType;
          var v13484 = v19480.typeFlags;
          var v19481 = TypeScript$$25.TypeFlags;
          var v13485 = v19481.HasBaseTypeOfObject;
          v3449 = TypeScript$$25.hasFlag(v13484, v13485);
        }
        var noSuperCallAllowed = v3449;
        var v13487 = funcDecl$$31.classDecl;
        var v3450 = v13487.varFlags;
        var v13488 = TypeScript$$25.VarFlags;
        var v3451 = v13488.ClassSuperMustBeFirstCallInConstructor;
        var superCallMustBeFirst = TypeScript$$25.hasFlag(v3450, v3451);
        var v13489 = noSuperCallAllowed;
        if (v13489) {
          v13489 = this.classConstructorHasSuperCall(funcDecl$$31);
        }
        var v3457 = v13489;
        if (v3457) {
          var v13490 = this.checker;
          var v3452 = v13490.errorReporter;
          v3452.simpleError(funcDecl$$31, "Calls to 'super' constructor are not allowed in classes that either inherit directly from 'Object' or have no base class");
        } else {
          if (hasBaseType) {
            if (superCallMustBeFirst) {
              var v23367 = funcDecl$$31.bod;
              var v19482 = !v23367;
              var v23369 = !v19482;
              if (v23369) {
                var v26067 = funcDecl$$31.bod;
                var v25260 = v26067.members;
                var v23368 = v25260.length;
                v19482 = !v23368;
              }
              var v13491 = v19482;
              var v19484 = !v13491;
              if (v19484) {
                var v26682 = funcDecl$$31.bod;
                var v26593 = v26682.members;
                var v26422 = v26593[0];
                var v26068 = v26422.nodeType;
                var v26423 = TypeScript$$25.NodeType;
                var v26069 = v26423.Call;
                var v25261 = v26068 == v26069;
                if (v25261) {
                  var v26726 = funcDecl$$31.bod;
                  var v26683 = v26726.members;
                  var v26594 = v26683[0];
                  var v26424 = v26594.target;
                  var v26070 = v26424.nodeType;
                  var v26425 = TypeScript$$25.NodeType;
                  var v26071 = v26425.Super;
                  v25261 = v26070 == v26071;
                }
                var v23370 = v25261;
                var v25263 = !v23370;
                if (v25263) {
                  var v26684 = funcDecl$$31.bod;
                  var v26595 = v26684.flags;
                  var v26685 = TypeScript$$25.ASTFlags;
                  var v26596 = v26685.StrictMode;
                  var v26426 = TypeScript$$25.hasFlag(v26595, v26596);
                  if (v26426) {
                    var v26727 = funcDecl$$31.bod;
                    var v26686 = v26727.members;
                    var v26597 = v26686.length;
                    v26426 = v26597 > 1;
                  }
                  var v26072 = v26426;
                  if (v26072) {
                    var v26728 = funcDecl$$31.bod;
                    var v26687 = v26728.members;
                    var v26598 = v26687[1];
                    var v26427 = v26598.nodeType;
                    var v26599 = TypeScript$$25.NodeType;
                    var v26428 = v26599.Call;
                    v26072 = v26427 == v26428;
                  }
                  var v25262 = v26072;
                  if (v25262) {
                    var v26729 = funcDecl$$31.bod;
                    var v26688 = v26729.members;
                    var v26600 = v26688[1];
                    var v26429 = v26600.target;
                    var v26073 = v26429.nodeType;
                    var v26430 = TypeScript$$25.NodeType;
                    var v26074 = v26430.Super;
                    v25262 = v26073 == v26074;
                  }
                  v23370 = v25262;
                }
                var v19483 = v23370;
                v13491 = !v19483;
              }
              var v3454 = v13491;
              if (v3454) {
                var v13492 = this.checker;
                var v3453 = v13492.errorReporter;
                v3453.simpleError(funcDecl$$31, "If a derived class contains initialized properties or constructor parameter properties, the first statement in the constructor body must be a call to the super constructor");
              }
            } else {
              var v13493 = this.classConstructorHasSuperCall(funcDecl$$31);
              var v3456 = !v13493;
              if (v3456) {
                var v13494 = this.checker;
                var v3455 = v13494.errorReporter;
                v3455.simpleError(funcDecl$$31, "Constructors for derived classes must contain a call to the class's 'super' constructor");
              }
            }
          }
        }
      }
      var v13495 = funcDecl$$31.isMethod();
      if (v13495) {
        var v19485 = funcDecl$$31.type;
        v13495 = v19485.enclosingType;
      }
      var v3463 = v13495;
      if (v3463) {
        var enclosingClassNode = null;
        var v26075 = funcDecl$$31.type;
        var v25264 = v26075.enclosingType;
        var v23371 = v25264.symbol;
        var v19486 = v23371.declAST;
        var v13496 = v19486.nodeType;
        var v19487 = TypeScript$$25.NodeType;
        var v13497 = v19487.FuncDecl;
        var v3462 = v13496 == v13497;
        if (v3462) {
          var v23372 = funcDecl$$31.type;
          var v19488 = v23372.enclosingType;
          var v13498 = v19488.symbol;
          var v3459 = v13498.declAST;
          enclosingClassNode = v3459.classDecl;
        } else {
          var v26076 = funcDecl$$31.type;
          var v25265 = v26076.enclosingType;
          var v23373 = v25265.symbol;
          var v19489 = v23373.declAST;
          var v13499 = v19489.nodeType;
          var v19490 = TypeScript$$25.NodeType;
          var v13500 = v19490.ClassDeclaration;
          var v3461 = v13499 == v13500;
          if (v3461) {
            var v19491 = funcDecl$$31.type;
            var v13501 = v19491.enclosingType;
            var v3460 = v13501.symbol;
            enclosingClassNode = v3460.declAST;
          }
        }
        if (enclosingClassNode) {
          this.thisClassNode = enclosingClassNode;
        }
      }
      var v3468 = fnType.enclosingType;
      if (v3468) {
        var v3464 = fnType.symbol;
        var enclosingSym = v3464.container;
        var v19492 = enclosingSym;
        if (v19492) {
          v19492 = enclosingSym.isType();
        }
        var v13502 = v19492;
        if (v13502) {
          var v19493 = enclosingSym.getType();
          v13502 = v19493.isClass();
        }
        var v3465 = v13502;
        if (v3465) {
          enclosingSym = enclosingSym.container;
        }
        var v19494 = enclosingSym;
        if (v19494) {
          v19494 = enclosingSym.declAST;
        }
        var v13503 = v19494;
        if (v13503) {
          var v23374 = enclosingSym.declAST;
          var v19495 = v23374.nodeType;
          var v23375 = TypeScript$$25.NodeType;
          var v19496 = v23375.ModuleDeclaration;
          v13503 = v19495 == v19496;
        }
        var v3467 = v13503;
        if (v3467) {
          var v3466 = this.checker;
          v3466.currentModDecl = enclosingSym.declAST;
        }
      }
      var v13504 = funcDecl$$31.unitIndex;
      var v3472 = v13504 > 0;
      if (v3472) {
        var v19497 = this.checker;
        var v13505 = v19497.units;
        if (v13505) {
          var v19498 = funcDecl$$31.unitIndex;
          var v25266 = this.checker;
          var v23376 = v25266.units;
          var v19499 = v23376.length;
          v13505 = v19498 < v19499;
        }
        var v3471 = v13505;
        if (v3471) {
          var v3469 = this.checker;
          var v19500 = this.checker;
          var v13506 = v19500.units;
          var v13507 = funcDecl$$31.unitIndex;
          v3469.locationInfo = v13506[v13507];
        } else {
          var v3470 = this.checker;
          v3470.locationInfo = TypeScript$$25.unknownLocationInfo;
        }
      }
      var v3473 = fnType.enclosingType;
      if (v3473) {
        this.thisType = fnType.enclosingType;
      } else {
        this.thisType = prevThisType;
      }
      var v3474 = signature$$10.parameters;
      var paramLen$$4 = v3474.length;
      var v23377 = funcDecl$$31.isConstructor;
      var v19501 = !v23377;
      if (v19501) {
        v19501 = funcDecl$$31.bod;
      }
      var v13508 = v19501;
      if (v13508) {
        var v19502 = funcDecl$$31.isSignature();
        v13508 = !v19502;
      }
      var v3523 = v13508;
      if (v3523) {
        var tmpParamScope = this.scope;
        ssb = this.scope;
        var v19503 = funcDecl$$31.isMethod();
        var v13509 = !v19503;
        if (v13509) {
          var v19504 = funcDecl$$31.returnTypeAnnotation;
          v13509 = v19504 == null;
        }
        var v3492 = v13509;
        if (v3492) {
          var v19505 = prevScope$$4;
          if (v19505) {
            v19505 = funcDecl$$31.name;
          }
          var v13510 = v19505;
          if (v13510) {
            var v23378 = funcDecl$$31.name;
            var v19506 = v23378.isMissing();
            v13510 = !v19506;
          }
          var v3479 = v13510;
          if (v3479) {
            var v13511 = funcDecl$$31.name;
            var v3475 = v13511.text;
            var considerSym = prevScope$$4.findAmbient(v3475, false, false);
            var v19507 = considerSym;
            if (v19507) {
              v19507 = considerSym.declAST;
            }
            var v13512 = v19507;
            if (v13512) {
              var v19508 = considerSym.declAST;
              v13512 = v19508.type;
            }
            var v3478 = v13512;
            if (v3478) {
              var v3476 = this.checker;
              var v13513 = considerSym.declAST;
              var v3477 = v13513.type;
              v3476.setContextualType(v3477, false);
            }
          }
          var v13514 = this.checker;
          var v3491 = v13514.hasTargetType();
          if (v3491) {
            var v3480 = this.checker;
            var candidateTypeContext = v3480.currentContextualTypeContext;
            var candidateType$$1 = candidateTypeContext.contextualType;
            var v13515 = this.checker;
            var v3490 = v13515.canContextuallyTypeFunction(candidateType$$1, funcDecl$$31, true);
            if (v3490) {
              var v3481;
              var v13516 = candidateType$$1.construct;
              if (v13516) {
                v3481 = candidateType$$1.construct;
              } else {
                v3481 = candidateType$$1.call;
              }
              var candidateSigs$$1 = v3481;
              var v3482 = candidateSigs$$1.signatures;
              candidateTypeContext.targetSig = v3482[0];
              var v3483 = candidateTypeContext.targetSig;
              var candidateParams = v3483.parameters;
              targetParams = candidateParams;
              var v13517 = candidateTypeContext.targetSig;
              var v3484 = v13517.returnType;
              targetReturnType$$1 = v3484.type;
              var v13518 = candidateTypeContext.targetSig;
              var v3487 = v13518.declAST;
              if (v3487) {
                var v19509 = candidateTypeContext.targetSig;
                var v13519 = v19509.declAST;
                var v3486 = v13519.isConstructor;
                if (v3486) {
                  funcDecl$$31.isTargetTypedAsMethod = true;
                } else {
                  var v19510 = candidateTypeContext.targetSig;
                  var v13520 = v19510.declAST;
                  var v3485 = v13520.isMethod();
                  if (v3485) {
                    funcDecl$$31.isTargetTypedAsMethod = true;
                  }
                }
              }
              fgSym$$4.type = candidateTypeContext.contextualType;
              acceptedContextualType = true;
            } else {
              var v13521 = candidateType$$1;
              if (v13521) {
                v13521 = funcDecl$$31.isAccessor();
              }
              var v3489 = v13521;
              if (v3489) {
                accessorType = candidateType$$1;
                candidateTypeContext.targetAccessorType = accessorType;
              } else {
                var v3488 = this.checker;
                v3488.killCurrentContextualType();
              }
            }
          }
        }
        var paramTable = ssb.valueMembers;
        var v3493 = TypeScript$$25.SymbolScopeBuilder;
        var v26844 = new v3493(paramTable, null, null, null, prevScope$$4, container$$21);
        this.scope = v26844;
        var p$$1 = 0;
        var v3506 = p$$1 < paramLen$$4;
        for (;v3506;) {
          var v3494 = signature$$10.parameters;
          var symbol$$21 = v3494[p$$1];
          var ast$$106 = symbol$$21.declAST;
          var v19511 = this.checker;
          var v13522 = v19511.hasTargetType();
          if (v13522) {
            var v19512 = targetParams;
            if (v19512) {
              var v26431 = this.checker;
              var v26077 = v26431.currentContextualTypeContext;
              var v25267 = v26077.targetSig;
              var v23379 = v25267.hasVariableArgList;
              var v25269 = !v23379;
              if (v25269) {
                var v25268 = targetParams.length;
                v23379 = p$$1 < v25268;
              }
              v19512 = v23379;
            }
            v13522 = v19512;
          }
          var v3501 = v13522;
          if (v3501) {
            var v3495 = this.checker;
            candidateTypeContext = v3495.currentContextualTypeContext;
            var v3496 = candidateTypeContext.targetSig;
            var hasVarArgList = v3496.hasVariableArgList;
            var v3497 = ast$$106;
            var v13523;
            var v23380 = hasVarArgList;
            if (v23380) {
              var v26078 = targetParams.length;
              var v25270 = v26078 - 1;
              v23380 = p$$1 >= v25270;
            }
            var v19515 = v23380;
            if (v19515) {
              var v26079 = targetParams.length;
              var v25271 = v26079 - 1;
              var v23381 = targetParams[v25271];
              var v19513 = v23381.getType();
              v13523 = v19513.elementType;
            } else {
              var v19514 = targetParams[p$$1];
              v13523 = v19514.getType();
            }
            v3497.type = v13523;
            var v3498 = ast$$106.sym;
            var v3499 = ast$$106.type;
            v3498.setType(v3499);
            var v3500 = ast$$106.sym;
            var v13524 = this.checker;
            var v26845 = v13524.getTypeCheckFinishedStatus();
            v3500.typeCheckStatus = v26845;
          } else {
            this.typeCheck(ast$$106);
          }
          var v3502 = isSetter$$4 && accessorType;
          if (v3502) {
            ast$$106 = this.cast(ast$$106, accessorType);
          }
          symbol$$21.container = container$$21;
          var v3503 = symbol$$21.getType();
          this.checkTypePrivacy(v3503, container$$21, v1062);
          var v3504 = paramTable.publicMembers;
          var v3505 = symbol$$21.name;
          v3504.add(v3505, symbol$$21);
          p$$1 = p$$1 + 1;
          v3506 = p$$1 < paramLen$$4;
        }
        this.scope = tmpParamScope;
      } else {
        var v3507 = funcDecl$$31.arguments;
        this.typeCheck(v3507);
        p$$1 = 0;
        var v3513 = p$$1 < paramLen$$4;
        for (;v3513;) {
          var v23382 = signature$$10.parameters;
          var v19516 = v23382[p$$1];
          var v13525 = v19516.parameter;
          var v3508 = v13525.typeLink;
          var v23383 = funcDecl$$31.arguments;
          var v19517 = v23383.members;
          var v13526 = v19517[p$$1];
          v3508.type = v13526.type;
          var v19518 = signature$$10.parameters;
          var v13527 = v19518[p$$1];
          var v3509 = v13527.getType();
          this.checkTypePrivacy(v3509, container$$21, v1063);
          var v23384 = funcDecl$$31.arguments;
          var v19519 = v23384.members;
          var v13528 = v19519[p$$1];
          var v3512 = v13528.parameterPropertySym;
          if (v3512) {
            var v23385 = funcDecl$$31.arguments;
            var v19520 = v23385.members;
            var v13529 = v19520[p$$1];
            var v3510 = v13529.parameterPropertySym;
            var v23386 = funcDecl$$31.arguments;
            var v19521 = v23386.members;
            var v13530 = v19521[p$$1];
            var v3511 = v13530.type;
            v3510.setType(v3511);
          }
          p$$1 = p$$1 + 1;
          v3513 = p$$1 < paramLen$$4;
        }
        var v13531 = funcDecl$$31.fncFlags;
        var v19522 = TypeScript$$25.FncFlags;
        var v13532 = v19522.IndexerMember;
        var v3522 = v13531 & v13532;
        if (v3522) {
          var v13533 = !paramLen$$4;
          var v19523 = !v13533;
          if (v19523) {
            v13533 = paramLen$$4 > 1;
          }
          var v3521 = v13533;
          if (v3521) {
            var v13534 = this.checker;
            var v3514 = v13534.errorReporter;
            v3514.simpleError(funcDecl$$31, "Index signatures may take one and only one parameter");
          } else {
            var v25272 = funcDecl$$31.arguments;
            var v23387 = v25272.members;
            var v19524 = v23387[0];
            var v13535 = v19524.type;
            var v19525 = this.checker;
            var v13536 = v19525.numberType;
            var v3520 = v13535 == v13536;
            if (v3520) {
              var v3515 = fnType.index;
              var v19526 = v3515.flags;
              var v23388 = TypeScript$$25.SignatureFlags;
              var v19527 = v23388.IsNumberIndexer;
              v3515.flags = v19526 | v19527;
            } else {
              var v25273 = funcDecl$$31.arguments;
              var v23389 = v25273.members;
              var v19528 = v23389[0];
              var v13537 = v19528.type;
              var v19529 = this.checker;
              var v13538 = v19529.stringType;
              var v3519 = v13537 == v13538;
              if (v3519) {
                var v3516 = fnType.index;
                var v19530 = v3516.flags;
                var v23390 = TypeScript$$25.SignatureFlags;
                var v19531 = v23390.IsStringIndexer;
                v3516.flags = v19530 | v19531;
              } else {
                var v13539 = this.checker;
                var v3517 = v13539.errorReporter;
                var v19532 = funcDecl$$31.arguments;
                var v13540 = v19532.members;
                var v3518 = v13540[0];
                v3517.simpleError(v3518, "Index signatures may only take 'string' or 'number' as their parameter");
              }
            }
          }
        }
      }
      var v13541 = funcDecl$$31.bod;
      if (v13541) {
        var v19533 = funcDecl$$31.isSignature();
        v13541 = !v19533;
      }
      var v3555 = v13541;
      if (v3555) {
        var v13542 = funcDecl$$31.isConstructor;
        var v3532 = !v13542;
        if (v3532) {
          this.addFormals(container$$21, signature$$10, funcTable$$1);
        } else {
          var v13543 = funcDecl$$31.type;
          var v3524 = v13543.symbol;
          var v3525 = funcDecl$$31.arguments;
          var v13544 = funcDecl$$31.fncFlags;
          var v19534 = TypeScript$$25.FncFlags;
          var v13545 = v19534.ClassMethod;
          var v3526 = TypeScript$$25.hasFlag(v13544, v13545);
          this.addConstructorLocalArgs(v3524, v3525, funcTable$$1, v3526);
          var v13546 = this.thisClassNode;
          if (v13546) {
            var v19535 = this.thisClassNode;
            v13546 = v19535.extendsList;
          }
          var v3531 = v13546;
          if (v3531) {
            var tmpScope = this.scope;
            var v3527 = TypeScript$$25.ScopedMembers;
            var funcMembers$$1 = new v3527(funcTable$$1);
            var v3528 = TypeScript$$25.FilteredSymbolScopeBuilder;
            var v13547 = funcDecl$$31.type;
            var v3529 = v13547.symbol;
            var v26846 = new v3528(funcMembers$$1, prevScope$$4, v3529, v1064);
            this.scope = v26846;
            var v13548 = this.thisClassNode;
            var v3530 = v13548.extendsList;
            this.typeCheckBaseCalls(v3530);
            this.scope = tmpScope;
          }
        }
        var v3533 = this.checker;
        var prevMod = v3533.currentModDecl;
        var v23391 = funcDecl$$31.type;
        if (v23391) {
          var v25274 = funcDecl$$31.type;
          v23391 = v25274.symbol;
        }
        var v19536 = v23391;
        if (v19536) {
          var v23392 = funcDecl$$31.isMethod();
          v19536 = !v23392;
        }
        var v13549 = v19536;
        if (v13549) {
          var v23393 = funcDecl$$31.type;
          var v19537 = v23393.symbol;
          v13549 = v19537.declModule;
        }
        var v3535 = v13549;
        if (v3535) {
          var v3534 = this.checker;
          var v19538 = funcDecl$$31.type;
          var v13550 = v19538.symbol;
          v3534.currentModDecl = v13550.declModule;
        }
        if (acceptedContextualType) {
          var v3536 = this.checker;
          var v13551 = this.checker;
          var v3537 = v13551.inProvisionalTypecheckMode();
          v3536.setContextualType(null, v3537);
        }
        var v3538 = funcDecl$$31.bod;
        this.typeCheck(v3538);
        if (acceptedContextualType) {
          var v3539 = this.checker;
          v3539.unsetContextualType();
        }
        var v3540 = this.checker;
        v3540.currentModDecl = prevMod;
        var v13552 = this.checker;
        var v3547 = v13552.checkControlFlow;
        if (v3547) {
          var cfg = funcDecl$$31.buildControlFlow();
          var v13553 = this.checker;
          var v3542 = v13553.printControlFlowGraph;
          if (v3542) {
            var v19539 = this.checker;
            var v13554 = v19539.errorReporter;
            var v3541 = v13554.outfile;
            cfg.print(v3541);
          }
          var v13555 = this.checker;
          var v3543 = v13555.errorReporter;
          cfg.reportUnreachable(v3543);
          var v13556 = this.checker;
          var v3546 = v13556.checkControlFlowUseDef;
          if (v3546) {
            var v13557 = this.checker;
            var v3544 = v13557.errorReporter;
            var v13558 = funcDecl$$31.type;
            var v3545 = v13558.symbol;
            cfg.useDef(v3544, v3545);
          }
        }
        var v3554 = funcDecl$$31.isConstructor;
        if (v3554) {
          var fns$$1 = funcDecl$$31.scopes;
          var v3548 = fns$$1.members;
          var fnsLen$$1 = v3548.length;
          var freeVars$$2;
          var sym$$38;
          var j$$15 = 0;
          var v3553 = j$$15 < fnsLen$$1;
          for (;v3553;) {
            var v3549 = fns$$1.members;
            var fn$$9 = v3549[j$$15];
            var v13559 = fn$$9.isSignature();
            var v3552 = !v13559;
            if (v3552) {
              var v19540 = fn$$9.fncFlags;
              var v23394 = TypeScript$$25.FncFlags;
              var v19541 = v23394.Method;
              var v13560 = TypeScript$$25.hasFlag(v19540, v19541);
              if (v13560) {
                var v23395 = fn$$9.fncFlags;
                var v25275 = TypeScript$$25.FncFlags;
                var v23396 = v25275.Static;
                var v19542 = TypeScript$$25.hasFlag(v23395, v23396);
                v13560 = !v19542;
              }
              var v3551 = v13560;
              if (v3551) {
                var v13561 = funcDecl$$31.type;
                var v3550 = v13561.symbol;
                this.checkPromoteFreeVars(fn$$9, v3550);
              }
            }
            j$$15 = j$$15 + 1;
            v3553 = j$$15 < fnsLen$$1;
          }
        }
      }
      this.scope = prevScope$$4;
      this.thisFnc = prevFnc;
      this.thisClassNode = prevClassNode;
      this.enclosingFncIsMethod = prevMethodStatus$$2;
      this.thisType = prevThisType;
      var v3556 = this.checker;
      v3556.locationInfo = prevLocationInfo$$2;
      var v3557 = this.checker;
      v3557.currentModDecl = prevModDecl$$1;
      var v3558 = signature$$10;
      var v13562 = this.checker;
      var v26847 = v13562.getTypeCheckFinishedStatus();
      v3558.typeCheckStatus = v26847;
      var v3566 = funcDecl$$31.returnTypeAnnotation;
      if (v3566) {
        var v13563 = funcDecl$$31.returnTypeAnnotation;
        var v3559 = v13563.type;
        var v3560 = funcDecl$$31.returnTypeAnnotation;
        this.checkForVoidConstructor(v3559, v3560);
        var v19543 = signature$$10.returnType;
        var v13564 = v19543.type;
        var v3564 = v13564 == null;
        if (v3564) {
          var v3561 = this.checker;
          var v3562 = this.scope;
          var v3563 = signature$$10.returnType;
          v3561.resolveTypeLink(v3562, v3563, false);
        }
      } else {
        if (targetReturnType$$1) {
          var v3565 = signature$$10.returnType;
          v3565.type = targetReturnType$$1;
        }
      }
      var v23397 = fgSym$$4.flags;
      var v25276 = TypeScript$$25.SymbolFlags;
      var v23398 = v25276.RecursivelyReferenced;
      var v19544 = v23397 & v23398;
      var v13565 = !v19544;
      if (v13565) {
        var v23399 = funcDecl$$31.returnStatementsWithExpressions;
        var v19545 = v23399.length;
        v13565 = v19545 > 0;
      }
      var v3574 = v13565;
      if (v3574) {
        var collection$$2 = {getLength:v1065, setTypeAtIndex:v1066, getTypeAtIndex:v1067};
        var v13566 = funcDecl$$31.returnStatementsWithExpressions;
        var v3567 = v13566[0];
        var bestCommonReturnType = v3567.type;
        var v3568 = this.checker;
        bestCommonReturnType = v3568.findBestCommonType(bestCommonReturnType, null, collection$$2, true);
        if (bestCommonReturnType) {
          var v3569 = signature$$10.returnType;
          var v13567 = this.checker;
          var v26848 = v13567.widenType(bestCommonReturnType);
          v3569.type = v26848;
        } else {
          var i$$100 = 0;
          var v19546 = funcDecl$$31.returnStatementsWithExpressions;
          var v13568 = v19546.length;
          var v3572 = i$$100 < v13568;
          for (;v3572;) {
            var v13569 = this.checker;
            var v3570 = v13569.errorReporter;
            var v13570 = funcDecl$$31.returnStatementsWithExpressions;
            var v3571 = v13570[i$$100];
            v3570.simpleError(v3571, "Incompatible return type");
            i$$100 = i$$100 + 1;
            var v19547 = funcDecl$$31.returnStatementsWithExpressions;
            var v13571 = v19547.length;
            v3572 = i$$100 < v13571;
          }
          var v3573 = signature$$10.returnType;
          v3573.type = this.anyType;
        }
      }
      var onlyHasThrow = false;
      var v19548 = signature$$10.returnType;
      var v13572 = v19548.type;
      var v3589 = v13572 == null;
      if (v3589) {
        var v13573 = funcDecl$$31.fncFlags;
        var v19549 = TypeScript$$25.FncFlags;
        var v13574 = v19549.HasReturnExpression;
        var v3579 = TypeScript$$25.hasFlag(v13573, v13574);
        if (v3579) {
          var v19550 = this.checker;
          var v13575 = v19550.styleSettings;
          var v3576 = v13575.implicitAny;
          if (v3576) {
            var v13576 = this.checker;
            var v3575 = v13576.errorReporter;
            v3575.styleError(funcDecl$$31, "type implicitly set to 'any'");
          }
          var v3577 = signature$$10.returnType;
          v3577.type = this.anyType;
        } else {
          var v3578 = signature$$10.returnType;
          v3578.type = this.voidType;
        }
      } else {
        var v23400 = signature$$10.returnType;
        var v19551 = v23400.type;
        var v19552 = this.nullType;
        var v13577 = v19551 == v19552;
        var v19555 = !v13577;
        if (v19555) {
          var v23401 = signature$$10.returnType;
          var v19553 = v23401.type;
          var v23402 = this.checker;
          var v19554 = v23402.undefinedType;
          v13577 = v19553 == v19554;
        }
        var v3588 = v13577;
        if (v3588) {
          var v3580 = signature$$10.returnType;
          v3580.type = this.anyType;
        } else {
          var v25277 = signature$$10.returnType;
          var v23403 = v25277.type;
          var v23404 = this.voidType;
          var v19556 = v23403 != v23404;
          if (v19556) {
            var v25278 = signature$$10.returnType;
            var v23405 = v25278.type;
            var v25279 = this.checker;
            var v23406 = v25279.undefinedType;
            v19556 = v23405 != v23406;
          }
          var v13578 = v19556;
          if (v13578) {
            var v23407 = signature$$10.returnType;
            var v19557 = v23407.type;
            var v19558 = this.anyType;
            v13578 = v19557 != v19558;
          }
          var v3587 = v13578;
          if (v3587) {
            var v25280 = funcDecl$$31.isSignature();
            var v23408 = !v25280;
            if (v23408) {
              var v25281 = funcDecl$$31.isConstructor;
              v23408 = !v25281;
            }
            var v19559 = v23408;
            if (v19559) {
              var v25282 = funcDecl$$31.fncFlags;
              var v26080 = TypeScript$$25.FncFlags;
              var v25283 = v26080.HasReturnExpression;
              var v23409 = TypeScript$$25.hasFlag(v25282, v25283);
              v19559 = !v23409;
            }
            var v13579 = v19559;
            if (v13579) {
              var v23410 = funcDecl$$31.fncFlags;
              var v25284 = TypeScript$$25.FncFlags;
              var v23411 = v25284.IsFatArrowFunction;
              var v19560 = TypeScript$$25.hasFlag(v23410, v23411);
              v13579 = !v19560;
            }
            var v3585 = v13579;
            if (v3585) {
              var v23412 = funcDecl$$31.bod;
              var v19561 = v23412.members;
              var v13580 = v19561.length;
              var v3581 = v13580 > 0;
              if (v3581) {
                var v25285 = funcDecl$$31.bod;
                var v23413 = v25285.members;
                var v19562 = v23413[0];
                var v13581 = v19562.nodeType;
                var v19563 = TypeScript$$25.NodeType;
                var v13582 = v19563.Throw;
                v3581 = v13581 == v13582;
              }
              onlyHasThrow = v3581;
              var v3584 = !onlyHasThrow;
              if (v3584) {
                var v13583 = this.checker;
                var v3582 = v13583.errorReporter;
                var v13584 = funcDecl$$31.returnTypeAnnotation;
                var v19564 = !v13584;
                if (v19564) {
                  v13584 = funcDecl$$31;
                }
                var v3583 = v13584;
                v3582.simpleError(v3583, "Function declared a non-void return type, but has no return expression");
              }
            }
            var v13585 = signature$$10.returnType;
            var v3586 = v13585.type;
            this.checkTypePrivacy(v3586, container$$21, v1068);
          }
        }
      }
      var v3602 = funcDecl$$31.accessorSymbol;
      if (v3602) {
        var v3590 = funcDecl$$31.accessorSymbol;
        accessorType = v3590.getType();
        var v19565 = !onlyHasThrow;
        if (v19565) {
          var v23414 = funcDecl$$31.fncFlags;
          var v25286 = TypeScript$$25.FncFlags;
          var v23415 = v25286.GetAccessor;
          v19565 = TypeScript$$25.hasFlag(v23414, v23415);
        }
        var v13586 = v19565;
        if (v13586) {
          var v23416 = funcDecl$$31.fncFlags;
          var v25287 = TypeScript$$25.FncFlags;
          var v23417 = v25287.HasReturnExpression;
          var v19566 = TypeScript$$25.hasFlag(v23416, v23417);
          v13586 = !v19566;
        }
        var v3592 = v13586;
        if (v3592) {
          var v13587 = this.checker;
          var v3591 = v13587.errorReporter;
          v3591.simpleError(funcDecl$$31, "Getters must return a value");
        }
        if (accessorType) {
          var v23418 = funcDecl$$31.fncFlags;
          var v25288 = TypeScript$$25.FncFlags;
          var v23419 = v25288.GetAccessor;
          var v19567 = TypeScript$$25.hasFlag(v23418, v23419);
          if (v19567) {
            var v25289 = signature$$10.returnType;
            var v23420 = v25289.type;
            v19567 = accessorType != v23420;
          }
          var v13588 = v19567;
          var v19569 = !v13588;
          if (v19569) {
            var v26081 = funcDecl$$31.arguments;
            var v25290 = v26081.members;
            var v23421 = v25290.length;
            var v19568 = v23421 > 0;
            if (v19568) {
              var v26432 = funcDecl$$31.arguments;
              var v26082 = v26432.members;
              var v25291 = v26082[0];
              var v23422 = v25291.type;
              v19568 = accessorType != v23422;
            }
            v13588 = v19568;
          }
          var v3594 = v13588;
          if (v3594) {
            var v13589 = this.checker;
            var v3593 = v13589.errorReporter;
            v3593.simpleError(funcDecl$$31, "Getter and setter types do not agree");
          }
        } else {
          var v13590 = funcDecl$$31.fncFlags;
          var v19570 = TypeScript$$25.FncFlags;
          var v13591 = v19570.GetAccessor;
          var v3601 = TypeScript$$25.hasFlag(v13590, v13591);
          if (v3601) {
            var v3595 = funcDecl$$31.accessorSymbol;
            var v13592 = signature$$10.returnType;
            var v3596 = v13592.type;
            v3595.setType(v3596);
          } else {
            var v23423 = funcDecl$$31.arguments;
            var v19571 = v23423.members;
            var v13593 = v19571.length;
            var v3600 = v13593 != 1;
            if (v3600) {
              var v13594 = this.checker;
              var v3597 = v13594.errorReporter;
              v3597.simpleError(funcDecl$$31, "Setters may have one and only one argument");
            } else {
              var v3598 = funcDecl$$31.accessorSymbol;
              var v23424 = funcDecl$$31.arguments;
              var v19572 = v23424.members;
              var v13595 = v19572[0];
              var v3599 = v13595.type;
              v3598.setType(v3599);
            }
          }
        }
      }
      this.typeCheckOverloadSignatures(fnType, funcDecl$$31);
      return funcDecl$$31;
    }
    function v1061(funcDecl$$30, signature$$9, typeName$$7, isModuleName$$6) {
      var reportOnFuncDecl = false;
      var v19573 = funcDecl$$30.returnTypeAnnotation;
      var v13596 = v19573 != null;
      if (v13596) {
        var v23425 = funcDecl$$30.returnTypeAnnotation;
        var v19574 = v23425.type;
        var v23426 = signature$$9.returnType;
        var v19575 = v23426.type;
        v13596 = v19574 == v19575;
      }
      var v3604 = v13596;
      if (v3604) {
        var v3603 = funcDecl$$30.returnTypeAnnotation;
        this.returnTypePrivacyError(v3603, funcDecl$$30, typeName$$7, isModuleName$$6);
      }
      var i$$99 = 0;
      var v19576 = funcDecl$$30.returnStatementsWithExpressions;
      var v13597 = v19576.length;
      var v3607 = i$$99 < v13597;
      for (;v3607;) {
        var v23427 = funcDecl$$30.returnStatementsWithExpressions;
        var v19577 = v23427[i$$99];
        var v13598 = v19577.type;
        var v19578 = signature$$9.returnType;
        var v13599 = v19578.type;
        var v3606 = v13598 == v13599;
        if (v3606) {
          var v13600 = funcDecl$$30.returnStatementsWithExpressions;
          var v3605 = v13600[i$$99];
          this.returnTypePrivacyError(v3605, funcDecl$$30, typeName$$7, isModuleName$$6);
        } else {
          reportOnFuncDecl = true;
        }
        i$$99 = i$$99 + 1;
        var v19579 = funcDecl$$30.returnStatementsWithExpressions;
        var v13601 = v19579.length;
        v3607 = i$$99 < v13601;
      }
      if (reportOnFuncDecl) {
        this.returnTypePrivacyError(funcDecl$$30, funcDecl$$30, typeName$$7, isModuleName$$6);
      }
      return;
    }
    function v1060(astError, funcDecl$$29, typeName$$6, isModuleName$$5) {
      var v3608 = funcDecl$$29.isAccessor();
      if (v3608) {
        var v13602 = funcDecl$$29.fncFlags;
        var v19580 = TypeScript$$25.FncFlags;
        var v13603 = v19580.GetAccessor;
        v3608 = TypeScript$$25.hasFlag(v13602, v13603);
      }
      var isGetter$$3 = v3608;
      var v3609 = funcDecl$$29.isAccessor();
      if (v3609) {
        var v13604 = funcDecl$$29.fncFlags;
        var v19581 = TypeScript$$25.FncFlags;
        var v13605 = v19581.SetAccessor;
        v3609 = TypeScript$$25.hasFlag(v13604, v13605);
      }
      var isSetter$$3 = v3609;
      var v3610 = funcDecl$$29.fncFlags;
      var v13606 = TypeScript$$25.FncFlags;
      var v3611 = v13606.Public;
      var isPublicFunc$$1 = TypeScript$$25.hasFlag(v3610, v3611);
      var v19582 = funcDecl$$29.type;
      var v13607 = v19582.symbol;
      var v13608 = this.checker;
      var v3612 = v13607.getInterfaceDeclFromSymbol(v13608);
      var isContainerInterface$$1 = v3612 != null;
      var typestring$$3 = "";
      if (isModuleName$$5) {
        var quotestring$$3 = "";
        var v13609 = TypeScript$$25.isQuoted(typeName$$6);
        var v3613 = !v13609;
        if (v3613) {
          quotestring$$3 = "'";
        }
        var v13610 = " is using inaccessible module " + quotestring$$3;
        var v3614 = v13610 + typeName$$6;
        typestring$$3 = v3614 + quotestring$$3;
      } else {
        var v3615 = " has or is using private type '" + typeName$$6;
        typestring$$3 = v3615 + "'";
      }
      var v3632 = !isContainerInterface$$1;
      if (v3632) {
        if (isGetter$$3) {
          var v13611 = this.checker;
          var v3616 = v13611.errorReporter;
          var v23428;
          if (isPublicFunc$$1) {
            v23428 = "public";
          } else {
            v23428 = "exported";
          }
          var v19583 = v23428;
          var v13612 = v19583 + " getter return type";
          var v3617 = v13612 + typestring$$3;
          v3616.simpleError(astError, v3617);
        } else {
          var v3620 = !isSetter$$3;
          if (v3620) {
            var v13613 = this.checker;
            var v3618 = v13613.errorReporter;
            var v23429;
            if (isPublicFunc$$1) {
              v23429 = "public";
            } else {
              v23429 = "exported";
            }
            var v19584 = v23429;
            var v13614 = v19584 + " function return type";
            var v3619 = v13614 + typestring$$3;
            v3618.simpleError(astError, v3619);
          }
        }
      } else {
        var v3631 = funcDecl$$29.isConstructMember();
        if (v3631) {
          var v13615 = this.checker;
          var v3621 = v13615.errorReporter;
          var v3622 = "exported interface's constructor return type" + typestring$$3;
          v3621.simpleError(astError, v3622);
        } else {
          var v3630 = funcDecl$$29.isCallMember();
          if (v3630) {
            var v13616 = this.checker;
            var v3623 = v13616.errorReporter;
            var v3624 = "exported interface's call return type" + typestring$$3;
            v3623.simpleError(astError, v3624);
          } else {
            var v3629 = funcDecl$$29.isIndexerMember();
            if (v3629) {
              var v13617 = this.checker;
              var v3625 = v13617.errorReporter;
              var v3626 = "exported interface's indexer return type" + typestring$$3;
              v3625.simpleError(astError, v3626);
            } else {
              var v13618 = this.checker;
              var v3627 = v13618.errorReporter;
              var v3628 = "exported interface's function return type" + typestring$$3;
              v3627.simpleError(astError, v3628);
            }
          }
        }
      }
      return;
    }
    function v1059(funcDecl$$28, p, paramSymbol, typeName$$5, isModuleName$$4) {
      var v3633 = funcDecl$$28.isAccessor();
      if (v3633) {
        var v13619 = funcDecl$$28.fncFlags;
        var v19585 = TypeScript$$25.FncFlags;
        var v13620 = v19585.GetAccessor;
        v3633 = TypeScript$$25.hasFlag(v13619, v13620);
      }
      var isGetter$$2 = v3633;
      var v3634 = funcDecl$$28.isAccessor();
      if (v3634) {
        var v13621 = funcDecl$$28.fncFlags;
        var v19586 = TypeScript$$25.FncFlags;
        var v13622 = v19586.SetAccessor;
        v3634 = TypeScript$$25.hasFlag(v13621, v13622);
      }
      var isSetter$$2 = v3634;
      var v3635 = funcDecl$$28.fncFlags;
      var v13623 = TypeScript$$25.FncFlags;
      var v3636 = v13623.Public;
      var isPublicFunc = TypeScript$$25.hasFlag(v3635, v3636);
      var v19587 = funcDecl$$28.type;
      var v13624 = v19587.symbol;
      var v13625 = this.checker;
      var v3637 = v13624.getInterfaceDeclFromSymbol(v13625);
      var isContainerInterface = v3637 != null;
      var typestring$$2 = "";
      if (isModuleName$$4) {
        var quotestring$$2 = "";
        var v13626 = TypeScript$$25.isQuoted(typeName$$5);
        var v3638 = !v13626;
        if (v3638) {
          quotestring$$2 = "'";
        }
        var v13627 = " is using inaccessible module " + quotestring$$2;
        var v3639 = v13627 + typeName$$5;
        typestring$$2 = v3639 + quotestring$$2;
      } else {
        var v3640 = " has or is using private type '" + typeName$$5;
        typestring$$2 = v3640 + "'";
      }
      var v3664 = !isContainerInterface;
      if (v3664) {
        var v3651 = funcDecl$$28.isConstructor;
        if (v3651) {
          var v13628 = this.checker;
          var v3641 = v13628.errorReporter;
          var v19588 = funcDecl$$28.arguments;
          var v13629 = v19588.members;
          var v3642 = v13629[p];
          var v23430 = paramSymbol.name;
          var v19589 = "exported class's constructor parameter '" + v23430;
          var v13630 = v19589 + "'";
          var v3643 = v13630 + typestring$$2;
          v3641.simpleError(v3642, v3643);
        } else {
          if (isSetter$$2) {
            var v13631 = this.checker;
            var v3644 = v13631.errorReporter;
            var v19590 = funcDecl$$28.arguments;
            var v13632 = v19590.members;
            var v3645 = v13632[p];
            var v26083;
            if (isPublicFunc) {
              v26083 = "public";
            } else {
              v26083 = "exported";
            }
            var v25292 = v26083;
            var v23431 = v25292 + " setter parameter '";
            var v23432 = paramSymbol.name;
            var v19591 = v23431 + v23432;
            var v13633 = v19591 + "'";
            var v3646 = v13633 + typestring$$2;
            v3644.simpleError(v3645, v3646);
          } else {
            var v3650 = !isGetter$$2;
            if (v3650) {
              var v13634 = this.checker;
              var v3647 = v13634.errorReporter;
              var v19592 = funcDecl$$28.arguments;
              var v13635 = v19592.members;
              var v3648 = v13635[p];
              var v26084;
              if (isPublicFunc) {
                v26084 = "public";
              } else {
                v26084 = "exported";
              }
              var v25293 = v26084;
              var v23433 = v25293 + " function parameter '";
              var v23434 = paramSymbol.name;
              var v19593 = v23433 + v23434;
              var v13636 = v19593 + "'";
              var v3649 = v13636 + typestring$$2;
              v3647.simpleError(v3648, v3649);
            }
          }
        }
      } else {
        var v3663 = funcDecl$$28.isConstructMember();
        if (v3663) {
          var v13637 = this.checker;
          var v3652 = v13637.errorReporter;
          var v19594 = funcDecl$$28.arguments;
          var v13638 = v19594.members;
          var v3653 = v13638[p];
          var v23435 = paramSymbol.name;
          var v19595 = "exported interface's constructor parameter '" + v23435;
          var v13639 = v19595 + "'";
          var v3654 = v13639 + typestring$$2;
          v3652.simpleError(v3653, v3654);
        } else {
          var v3662 = funcDecl$$28.isCallMember();
          if (v3662) {
            var v13640 = this.checker;
            var v3655 = v13640.errorReporter;
            var v19596 = funcDecl$$28.arguments;
            var v13641 = v19596.members;
            var v3656 = v13641[p];
            var v23436 = paramSymbol.name;
            var v19597 = "exported interface's call parameter '" + v23436;
            var v13642 = v19597 + "'";
            var v3657 = v13642 + typestring$$2;
            v3655.simpleError(v3656, v3657);
          } else {
            var v13643 = funcDecl$$28.isIndexerMember();
            var v3661 = !v13643;
            if (v3661) {
              var v13644 = this.checker;
              var v3658 = v13644.errorReporter;
              var v19598 = funcDecl$$28.arguments;
              var v13645 = v19598.members;
              var v3659 = v13645[p];
              var v23437 = paramSymbol.name;
              var v19599 = "exported interface's function parameter '" + v23437;
              var v13646 = v19599 + "'";
              var v3660 = v13646 + typestring$$2;
              v3658.simpleError(v3659, v3660);
            }
          }
        }
      }
      return;
    }
    function v1058(sgroup, declSymbol$$4, errorCallback$$6) {
      if (sgroup) {
        var v3665 = sgroup.signatures;
        var len$$47 = v3665.length;
        var i$$98 = 0;
        var v19600 = sgroup.signatures;
        var v13647 = v19600.length;
        var v3674 = i$$98 < v13647;
        for (;v3674;) {
          var v3666 = sgroup.signatures;
          var signature$$8 = v3666[i$$98];
          var v13648 = len$$47 > 1;
          if (v13648) {
            var v19601 = sgroup.definitionSignature;
            v13648 = signature$$8 == v19601;
          }
          var v3667 = v13648;
          if (v3667) {
            i$$98 = i$$98 + 1;
            var v19602 = sgroup.signatures;
            var v13649 = v19602.length;
            v3674 = i$$98 < v13649;
            continue;
          }
          var v3669 = signature$$8.returnType;
          if (v3669) {
            var v13650 = signature$$8.returnType;
            var v3668 = v13650.type;
            this.checkTypePrivacy(v3668, declSymbol$$4, errorCallback$$6);
          }
          var v3670 = signature$$8.parameters;
          var paramLen$$3 = v3670.length;
          var j$$14 = 0;
          var v3673 = j$$14 < paramLen$$3;
          for (;v3673;) {
            var v3671 = signature$$8.parameters;
            var param$$7 = v3671[j$$14];
            var v3672 = param$$7.getType();
            this.checkTypePrivacy(v3672, declSymbol$$4, errorCallback$$6);
            j$$14 = j$$14 + 1;
            v3673 = j$$14 < paramLen$$3;
          }
          i$$98 = i$$98 + 1;
          var v19603 = sgroup.signatures;
          var v13651 = v19603.length;
          v3674 = i$$98 < v13651;
        }
      }
      return;
    }
    function v1057(type$$50, declSymbol$$3, errorCallback$$5) {
      function v1056(key$$43, s$$26, unused) {
        var sym$$37 = s$$26;
        var v19604 = sym$$37.flags;
        var v23438 = TypeScript$$25.SymbolFlags;
        var v19605 = v23438.BuiltIn;
        var v13652 = TypeScript$$25.hasFlag(v19604, v19605);
        var v3676 = !v13652;
        if (v3676) {
          var v3675 = sym$$37.getType();
          _this$$9.checkTypePrivacy(v3675, declSymbol$$3, errorCallback$$5);
        }
        return;
      }
      var _this$$9 = this;
      var v19606 = type$$50;
      if (v19606) {
        var v23439 = type$$50.primitiveTypeClass;
        var v25294 = TypeScript$$25.Primitive;
        var v23440 = v25294.None;
        v19606 = v23439 == v23440;
      }
      var v13653 = v19606;
      var v3677 = !v13653;
      if (v3677) {
        return;
      }
      var v3679 = type$$50.isArray();
      if (v3679) {
        var v3678 = type$$50.elementType;
        return this.checkTypePrivacy(v3678, declSymbol$$3, errorCallback$$5);
      }
      var v23441 = type$$50.symbol;
      if (v23441) {
        var v25295 = type$$50.symbol;
        v23441 = v25295.name;
      }
      var v19607 = v23441;
      if (v19607) {
        var v25296 = type$$50.symbol;
        var v23442 = v25296.name;
        v19607 = v23442 != "_anonymous";
      }
      var v13654 = v19607;
      if (v13654) {
        var v26085 = type$$50.call;
        var v25297 = v26085 == null;
        if (v25297) {
          var v26086 = type$$50.construct;
          v25297 = v26086 == null;
        }
        var v23443 = v25297;
        if (v23443) {
          var v25298 = type$$50.index;
          v23443 = v25298 == null;
        }
        var v19608 = v23443;
        var v23445 = !v19608;
        if (v23445) {
          var v23444 = type$$50.members;
          if (v23444) {
            var v25299 = type$$50.isClass();
            v23444 = !v25299;
          }
          v19608 = v23444;
        }
        v13654 = v19608;
      }
      var v3681 = v13654;
      if (v3681) {
        var v3680 = type$$50.symbol;
        return this.checkSymbolPrivacy(v3680, declSymbol$$3, errorCallback$$5);
      }
      var v3683 = type$$50.members;
      if (v3683) {
        var v13655 = type$$50.members;
        var v3682 = v13655.allMembers;
        v3682.map(v1056, null);
      }
      var v3684 = type$$50.call;
      this.checkSignatureGroupPrivacy(v3684, declSymbol$$3, errorCallback$$5);
      var v3685 = type$$50.construct;
      this.checkSignatureGroupPrivacy(v3685, declSymbol$$3, errorCallback$$5);
      var v3686 = type$$50.index;
      this.checkSignatureGroupPrivacy(v3686, declSymbol$$3, errorCallback$$5);
      return;
    }
    function v1055(typeSymbol$$5, declSymbol$$2, errorCallback$$4) {
      var externalModuleSymbol = null;
      var declSymbolPath = null;
      var v13656 = this.checker;
      var v3694 = typeSymbol$$5.isExternallyVisible(v13656);
      if (v3694) {
        var typeSymbolPath = typeSymbol$$5.pathToRoot();
        declSymbolPath = declSymbol$$2.pathToRoot();
        var typeSymbolLength = typeSymbolPath.length;
        var declSymbolPathLength = declSymbolPath.length;
        var v3692 = typeSymbolLength > 0;
        if (v3692) {
          var v26087 = typeSymbolLength - 1;
          var v25300 = typeSymbolPath[v26087];
          var v23446 = v25300.getType();
          var v19609 = v23446.isModuleType();
          if (v19609) {
            var v25301 = typeSymbolLength - 1;
            var v23447 = typeSymbolPath[v25301];
            v19609 = v23447.isDynamic;
          }
          var v13657 = v19609;
          if (v13657) {
            var v23448 = typeSymbolLength - 1;
            var v19610 = typeSymbolPath[v23448];
            var v23449 = declSymbolPathLength - 1;
            var v19611 = declSymbolPath[v23449];
            v13657 = v19610 != v19611;
          }
          var v3691 = v13657;
          if (v3691) {
            var v3687 = typeSymbolLength - 1;
            externalModuleSymbol = typeSymbolPath[v3687];
          } else {
            var v3690 = typeSymbolLength > 1;
            if (v3690) {
              var v26088 = typeSymbolLength - 2;
              var v25302 = typeSymbolPath[v26088];
              var v23450 = v25302.getType();
              var v19612 = v23450.isModuleType();
              if (v19612) {
                var v25303 = typeSymbolLength - 2;
                var v23451 = typeSymbolPath[v25303];
                v19612 = v23451.isDynamic;
              }
              var v13658 = v19612;
              if (v13658) {
                var v19613 = declSymbolPathLength == 1;
                var v23454 = !v19613;
                if (v23454) {
                  var v25304 = typeSymbolLength - 2;
                  var v23452 = typeSymbolPath[v25304];
                  var v25305 = declSymbolPathLength - 2;
                  var v23453 = declSymbolPath[v25305];
                  v19613 = v23452 != v23453;
                }
                v13658 = v19613;
              }
              var v3689 = v13658;
              if (v3689) {
                var v3688 = typeSymbolLength - 2;
                externalModuleSymbol = typeSymbolPath[v3688];
              }
            }
          }
        }
        var v3693 = externalModuleSymbol == null;
        if (v3693) {
          return;
        }
      }
      var v3695 = this.checker;
      var interfaceDecl$$5 = declSymbol$$2.getInterfaceDeclFromSymbol(v3695);
      var v13659 = interfaceDecl$$5;
      if (v13659) {
        var v23455 = interfaceDecl$$5.varFlags;
        var v25306 = TypeScript$$25.VarFlags;
        var v23456 = v25306.Exported;
        var v19614 = TypeScript$$25.hasFlag(v23455, v23456);
        v13659 = !v19614;
      }
      var v3696 = v13659;
      if (v3696) {
        return;
      }
      var checkVisibilitySymbol = declSymbol$$2;
      var varDecl$$18 = declSymbol$$2.getVarDeclFromSymbol();
      if (varDecl$$18) {
        var v13660 = varDecl$$18.varFlags;
        var v19615 = TypeScript$$25.VarFlags;
        var v13661 = v19615.Private;
        var v3698 = TypeScript$$25.hasFlag(v13660, v13661);
        if (v3698) {
          return;
        } else {
          var v13662 = varDecl$$18.varFlags;
          var v19616 = TypeScript$$25.VarFlags;
          var v13663 = v19616.Public;
          var v3697 = TypeScript$$25.hasFlag(v13662, v13663);
          if (v3697) {
            checkVisibilitySymbol = declSymbol$$2.container;
          }
        }
      }
      var v13664 = this.checker;
      var v3705 = checkVisibilitySymbol.isExternallyVisible(v13664);
      if (v3705) {
        var privateSymbolName = typeSymbol$$5.name;
        var v3703 = externalModuleSymbol != null;
        if (v3703) {
          var prettyName$$2 = externalModuleSymbol.getPrettyNameOfDynamicModule(declSymbolPath);
          var v3702 = prettyName$$2 != null;
          if (v3702) {
            var v3699 = this.currentScript;
            var v3700 = prettyName$$2.symbol;
            var v3701 = this.checker;
            v3699.AddExternallyVisibleImportedSymbol(v3700, v3701);
            return;
          } else {
            privateSymbolName = externalModuleSymbol.prettyName;
          }
        }
        var v13665 = typeSymbol$$5.name;
        var v3704 = v13665 != privateSymbolName;
        errorCallback$$4(privateSymbolName, v3704);
      }
      return;
    }
    function v1054(bases$$5, declSymbol$$1, extendsList$$8) {
      function v1053(typeName$$4, isModuleName$$3) {
        return _this$$8.baseListPrivacyErrorReporter(bases$$5, i$$97, declSymbol$$1, extendsList$$8, typeName$$4, isModuleName$$3);
      }
      var _this$$8 = this;
      if (bases$$5) {
        var v3706 = bases$$5.members;
        var basesLen$$1 = v3706.length;
        var i$$97 = 0;
        var v3709 = i$$97 < basesLen$$1;
        for (;v3709;) {
          var v25307 = bases$$5.members;
          var v23457 = v25307[i$$97];
          var v19617 = v23457.type;
          var v13666 = !v19617;
          var v19620 = !v13666;
          if (v19620) {
            var v25308 = bases$$5.members;
            var v23458 = v25308[i$$97];
            var v19618 = v23458.type;
            var v23459 = this.checker;
            var v19619 = v23459.anyType;
            v13666 = v19618 == v19619;
          }
          var v3707 = v13666;
          if (v3707) {
            i$$97 = i$$97 + 1;
            v3709 = i$$97 < basesLen$$1;
            continue;
          }
          var v23460 = bases$$5.members;
          var v19621 = v23460[i$$97];
          var v13667 = v19621.type;
          var v3708 = v13667.symbol;
          this.checkSymbolPrivacy(v3708, declSymbol$$1, v1053);
          i$$97 = i$$97 + 1;
          v3709 = i$$97 < basesLen$$1;
        }
      }
      return;
    }
    function v1052(bases$$4, i$$96, declSymbol, extendsList$$7, typeName$$3, isModuleName$$2) {
      var v19622 = bases$$4.members;
      var v13668 = v19622[i$$96];
      var v3710 = v13668.type;
      var baseSymbol$$2 = v3710.symbol;
      var v3711;
      var v23461 = declSymbol.declAST;
      var v19623 = v23461.nodeType;
      var v23462 = TypeScript$$25.NodeType;
      var v19624 = v23462.InterfaceDeclaration;
      var v13669 = v19623 == v19624;
      if (v13669) {
        v3711 = "interface";
      } else {
        v3711 = "class";
      }
      var declTypeString = v3711;
      var v3712;
      if (extendsList$$7) {
        v3712 = "extends";
      } else {
        v3712 = "implements";
      }
      var baseListTypeString = v3712;
      var v3713;
      var v23463 = baseSymbol$$2.declAST;
      var v19625 = v23463.nodeType;
      var v23464 = TypeScript$$25.NodeType;
      var v19626 = v23464.InterfaceDeclaration;
      var v13670 = v19625 == v19626;
      if (v13670) {
        v3713 = "interface";
      } else {
        v3713 = "class";
      }
      var baseTypeString = v3713;
      var typestring$$1 = "";
      if (isModuleName$$2) {
        var quotestring$$1 = "";
        var v13671 = TypeScript$$25.isQuoted(typeName$$3);
        var v3714 = !v13671;
        if (v3714) {
          quotestring$$1 = "'";
        }
        typestring$$1 = " is using inaccessible module ";
        var v23465 = " " + baseTypeString;
        var v19627 = v23465 + " from private module ";
        var v13672 = v19627 + quotestring$$1;
        var v3715 = v13672 + typeName$$3;
        baseTypeString = v3715 + quotestring$$1;
      } else {
        var v19628 = " private " + baseTypeString;
        var v13673 = v19628 + " '";
        var v3716 = v13673 + typeName$$3;
        baseTypeString = v3716 + "'";
      }
      var v13674 = this.checker;
      var v3717 = v13674.errorReporter;
      var v13675 = bases$$4.members;
      var v3718 = v13675[i$$96];
      var v26089 = "exported " + declTypeString;
      var v25309 = v26089 + " '";
      var v25310 = declSymbol.name;
      var v23466 = v25309 + v25310;
      var v19629 = v23466 + "' ";
      var v13676 = v19629 + baseListTypeString;
      var v3719 = v13676 + baseTypeString;
      v3717.simpleError(v3718, v3719);
      return;
    }
    function v1051(funcDecl$$27) {
      function preFindSuperCall(ast$$105, parent$$67, walker$$51) {
        var go$$5 = true;
        var v3721 = ast$$105.nodeType;
        switch(v3721) {
          case TypeScript$$25.NodeType.FuncDecl:
            go$$5 = false;
            break;
          case TypeScript$$25.NodeType.Call:
            var call = ast$$105;
            var v19630 = call.target;
            var v13677 = v19630.nodeType;
            var v19631 = TypeScript$$25.NodeType;
            var v13678 = v19631.Super;
            var v3720 = v13677 == v13678;
            if (v3720) {
              go$$5 = false;
              foundSuper = true;
            }
          ;
          default:
          ;
        }
        var v3722 = walker$$51.options;
        v3722.goChildren = go$$5;
        return ast$$105;
      }
      var foundSuper = false;
      var v3723 = TypeScript$$25.getAstWalkerFactory();
      var v3724 = funcDecl$$27.bod;
      v3723.walk(v3724, preFindSuperCall);
      return foundSuper;
    }
    function v1050(funcDecl$$26) {
      function v1049(ast$$104, parent$$66, walker$$50) {
        var go$$4 = true;
        var v3726 = ast$$104.nodeType;
        switch(v3726) {
          case TypeScript$$25.NodeType.FuncDecl:
            go$$4 = false;
            break;
          case TypeScript$$25.NodeType.Return:
            var returnStmt = ast$$104;
            var v3725 = returnStmt.returnExpression;
            if (v3725) {
              allReturnsAreVoid = false;
              go$$4 = false;
            }
          ;
          default:
          ;
        }
        var v3727 = walker$$50.options;
        v3727.goChildren = go$$4;
        var v3728 = walker$$50.options;
        v3728.goNextSibling = go$$4;
        return ast$$104;
      }
      var allReturnsAreVoid = true;
      var v23467 = funcDecl$$26.signature;
      var v19632 = v23467.returnType;
      var v13679 = v19632.type;
      var v3731 = v13679 == null;
      if (v3731) {
        var preFindReturnExpressionTypes = v1049;
        var v3729 = TypeScript$$25.getAstWalkerFactory();
        var v3730 = funcDecl$$26.bod;
        v3729.walk(v3730, preFindReturnExpressionTypes);
      }
      return allReturnsAreVoid;
    }
    function v1048(funcDecl$$25, constructorSym) {
      var freeVars$$1 = funcDecl$$25.freeVariables;
      var k$$14 = 0;
      var len$$46 = freeVars$$1.length;
      var v3739 = k$$14 < len$$46;
      for (;v3739;) {
        var sym$$36 = freeVars$$1[k$$14];
        var v19633 = sym$$36.isInstanceProperty();
        var v13680 = !v19633;
        if (v13680) {
          var v19634 = sym$$36.container;
          v13680 = v19634 == constructorSym;
        }
        var v3738 = v13680;
        if (v3738) {
          var v3732 = TypeScript$$25.instanceFilter;
          v3732.reset();
          var v13681 = this.scope;
          var v13682 = TypeScript$$25.instanceFilter;
          var v13683 = sym$$36.name;
          var v3735 = v13681.search(v13682, v13683, false, false);
          if (v3735) {
            var v13684 = this.checker;
            var v3733 = v13684.errorReporter;
            var v25311 = sym$$36.name;
            var v23468 = "Constructor-local variable shadows class property '" + v25311;
            var v19635 = v23468 + "'. To access the class property, use 'self.";
            var v19636 = sym$$36.name;
            var v13685 = v19635 + v19636;
            var v3734 = v13685 + "'";
            v3733.simpleError(funcDecl$$25, v3734);
          }
          var v13686 = this.checker;
          var v3736 = v13686.errorReporter;
          var v19637 = sym$$36.name;
          var v13687 = "Constructor-local variables may not be accessed from instance method bodies. Consider changing local variable '" + v19637;
          var v3737 = v13687 + "' to a class property";
          v3736.simpleError(funcDecl$$25, v3737);
        }
        k$$14 = k$$14 + 1;
        v3739 = k$$14 < len$$46;
      }
      return;
    }
    function v1047(funcDecl$$24) {
      var v13688 = funcDecl$$24.isMethod();
      var v3742 = !v13688;
      if (v3742) {
        var freeVars = funcDecl$$24.freeVariables;
        var k$$13 = 0;
        var len$$45 = freeVars.length;
        var v3741 = k$$13 < len$$45;
        for (;v3741;) {
          var sym$$35 = freeVars[k$$13];
          var v3740 = sym$$35.isInstanceProperty();
          if (v3740) {
            return true;
          }
          k$$13 = k$$13 + 1;
          v3741 = k$$13 < len$$45;
        }
      }
      var fns = funcDecl$$24.scopes;
      var v3743 = fns.members;
      var fnsLen = v3743.length;
      var j$$13 = 0;
      var v3746 = j$$13 < fnsLen;
      for (;v3746;) {
        var v3744 = fns.members;
        var fn$$8 = v3744[j$$13];
        var v3745 = this.checkInitSelf(fn$$8);
        if (v3745) {
          return true;
        }
        j$$13 = j$$13 + 1;
        v3746 = j$$13 < fnsLen;
      }
      return false;
    }
    function v1046(container$$20, args$$14, table$$9, isClass$$1) {
      if (args$$14) {
        var v3747 = args$$14.members;
        var len$$44 = v3747.length;
        var i$$95 = 0;
        var v3761 = i$$95 < len$$44;
        for (;v3761;) {
          var v3748 = args$$14.members;
          var local$$1 = v3748[i$$95];
          var v19638 = local$$1.sym;
          var v13689 = v19638 == null;
          var v19640 = !v13689;
          if (v19640) {
            var v19639 = isClass$$1;
            var v23471 = !v19639;
            if (v23471) {
              var v25312 = local$$1.sym;
              var v23469 = v25312.kind();
              var v25313 = TypeScript$$25.SymbolKind;
              var v23470 = v25313.Field;
              v19639 = v23469 != v23470;
            }
            v13689 = v19639;
          }
          var v3760 = v13689;
          if (v3760) {
            var result$$29 = null;
            var v23472 = local$$1.id;
            var v19641 = v23472.text;
            var v13690 = result$$29 = table$$9.lookup(v19641);
            var v3759 = v13690 == null;
            if (v3759) {
              this.resolveBoundDecl(local$$1);
              var v3749 = TypeScript$$25.ValueLocation;
              var localVar$$1 = new v3749;
              var v3750 = localVar$$1;
              var v13691 = TypeScript$$25.TypeLink;
              var v26849 = new v13691;
              v3750.typeLink = v26849;
              var v3751 = TypeScript$$25.ParameterSymbol;
              var v13692 = local$$1.id;
              var v3752 = v13692.text;
              var v3753 = local$$1.minChar;
              var v19642 = this.checker;
              var v13693 = v19642.locationInfo;
              var v3754 = v13693.unitIndex;
              var varSym$$2 = new v3751(v3752, v3753, v3754, localVar$$1);
              varSym$$2.declAST = local$$1;
              localVar$$1.symbol = varSym$$2;
              var v3755 = localVar$$1.typeLink;
              v3755.type = local$$1.type;
              var v3756 = localVar$$1.symbol;
              v3756.container = container$$20;
              local$$1.sym = localVar$$1.symbol;
              var v13694 = local$$1.id;
              var v3757 = v13694.text;
              table$$9.add(v3757, varSym$$2);
            } else {
              var v3758 = local$$1;
              var v26850 = result$$29.getType();
              v3758.type = v26850;
              local$$1.sym = result$$29;
            }
          }
          i$$95 = i$$95 + 1;
          v3761 = i$$95 < len$$44;
        }
      }
      return;
    }
    function v1045(scope$$30, container$$19, vars$$3, table$$8, isModContainer) {
      var v3762 = vars$$3.members;
      var len$$43 = v3762.length;
      var hasArgsDef = false;
      var i$$94 = 0;
      var v3787 = i$$94 < len$$43;
      for (;v3787;) {
        var v3763 = vars$$3.members;
        var local = v3763[i$$94];
        var v19643 = local.sym;
        var v13695 = v19643 == null;
        var v19646 = !v13695;
        if (v19646) {
          var v23473 = local.sym;
          var v19644 = v23473.kind();
          var v23474 = TypeScript$$25.SymbolKind;
          var v19645 = v23474.Field;
          v13695 = v19644 != v19645;
        }
        var v3786 = v13695;
        if (v3786) {
          var result$$28 = null;
          var v23475 = local.id;
          var v19647 = v23475.text;
          var v13696 = result$$28 = table$$8.lookup(v19647);
          var v3785 = v13696 == null;
          if (v3785) {
            var v3764 = TypeScript$$25.ValueLocation;
            var localVar = new v3764;
            var v3765 = localVar;
            var v13697 = TypeScript$$25.TypeLink;
            var v26851 = new v13697;
            v3765.typeLink = v26851;
            var varSym$$1 = null;
            var v13698 = local.varFlags;
            var v19648 = TypeScript$$25.VarFlags;
            var v13699 = v19648.Static;
            var v3774 = TypeScript$$25.hasFlag(v13698, v13699);
            if (v3774) {
              var v13700 = local.varFlags;
              var v19649 = TypeScript$$25.VarFlags;
              var v13701 = v19649.LocalStatic;
              local.varFlags = v13700 | v13701;
              var v3766 = TypeScript$$25.FieldSymbol;
              var v13702 = local.id;
              var v3767 = v13702.text;
              var v3768 = local.minChar;
              var v19650 = this.checker;
              var v13703 = v19650.locationInfo;
              var v3769 = v13703.unitIndex;
              varSym$$1 = new v3766(v3767, v3768, v3769, true, localVar);
            } else {
              var v3770 = TypeScript$$25.VariableSymbol;
              var v13704 = local.id;
              var v3771 = v13704.text;
              var v3772 = local.minChar;
              var v19651 = this.checker;
              var v13705 = v19651.locationInfo;
              var v3773 = v13705.unitIndex;
              varSym$$1 = new v3770(v3771, v3772, v3773, localVar);
            }
            var v3775 = local.varFlags;
            varSym$$1.transferVarFlags(v3775);
            localVar.symbol = varSym$$1;
            varSym$$1.declAST = local;
            var v3776 = localVar.typeLink;
            v3776.ast = local.typeExpr;
            var v3777 = this.checker;
            var v3778 = localVar.typeLink;
            v3777.resolveTypeLink(scope$$30, v3778, false);
            var v19652 = local.type;
            var v13706 = v19652 == null;
            if (v13706) {
              var v19653 = local.init;
              v13706 = v19653 == null;
            }
            var v3779 = v13706;
            if (v3779) {
              local.type = this.anyType;
            }
            var v3780 = localVar.typeLink;
            v3780.type = local.type;
            var v3781 = localVar.symbol;
            v3781.container = container$$19;
            local.sym = localVar.symbol;
            var v13707 = local.id;
            var v3782 = v13707.text;
            table$$8.add(v3782, varSym$$1);
            var v19654 = local.id;
            var v13708 = v19654.text;
            var v3783 = v13708 == "arguments";
            if (v3783) {
              hasArgsDef = true;
            }
          } else {
            var v3784 = local;
            var v26852 = result$$28.getType();
            v3784.type = v26852;
            local.sym = result$$28;
          }
        }
        i$$94 = i$$94 + 1;
        v3787 = i$$94 < len$$43;
      }
      var v3796 = !isModContainer;
      if (v3796) {
        var v3795 = !hasArgsDef;
        if (v3795) {
          var v3788 = TypeScript$$25.ValueLocation;
          var argLoc = new v3788;
          var v3789 = argLoc;
          var v13709 = TypeScript$$25.TypeLink;
          var v26853 = new v13709;
          v3789.typeLink = v26853;
          var v3790 = TypeScript$$25.VariableSymbol;
          var v3791 = vars$$3.minChar;
          var v19655 = this.checker;
          var v13710 = v19655.locationInfo;
          var v3792 = v13710.unitIndex;
          var theArgSym = new v3790("arguments", v3791, v3792, argLoc);
          var v13711 = this.iargumentsInterfaceType;
          var v3793 = !v13711;
          if (v3793) {
            var argumentsSym = scope$$30.find("IArguments", false, true);
            if (argumentsSym) {
              var v13712 = argumentsSym.flags;
              var v19656 = TypeScript$$25.SymbolFlags;
              var v13713 = v19656.CompilerGenerated;
              argumentsSym.flags = v13712 | v13713;
              var v26854 = argumentsSym.getType();
              this.iargumentsInterfaceType = v26854;
            } else {
              this.iargumentsInterfaceType = this.anyType;
            }
          }
          var v3794 = argLoc.typeLink;
          v3794.type = this.iargumentsInterfaceType;
          table$$8.add("arguments", theArgSym);
        }
      }
      return;
    }
    function v1044(container$$18, signature$$7, table$$7) {
      var v3797 = signature$$7.parameters;
      var len$$42 = v3797.length;
      var i$$93 = 0;
      var v3800 = i$$93 < len$$42;
      for (;v3800;) {
        var v3798 = signature$$7.parameters;
        var symbol$$20 = v3798[i$$93];
        symbol$$20.container = container$$18;
        var v3799 = symbol$$20.name;
        table$$7.add(v3799, symbol$$20);
        i$$93 = i$$93 + 1;
        v3800 = i$$93 < len$$42;
      }
      return;
    }
    function v1043(trinex) {
      var v3801 = trinex;
      var v13714 = trinex.operand1;
      var v26855 = this.typeCheck(v13714);
      v3801.operand1 = v26855;
      var v3802 = trinex;
      var v13715 = trinex.operand2;
      var v26856 = this.typeCheck(v13715);
      v3802.operand2 = v26856;
      var v3803 = trinex;
      var v13716 = trinex.operand3;
      var v26857 = this.typeCheck(v13716);
      v3803.operand3 = v26857;
      var v3804 = trinex.operand2;
      var leftType$$5 = v3804.type;
      var v3805 = trinex.operand3;
      var rightType$$4 = v3805.type;
      var v3811 = leftType$$5 == rightType$$4;
      if (v3811) {
        trinex.type = leftType$$5;
      } else {
        var v13717 = this.checker;
        var v3810 = v13717.sourceIsSubtypeOfTarget(leftType$$5, rightType$$4);
        if (v3810) {
          trinex.type = rightType$$4;
        } else {
          var v13718 = this.checker;
          var v3809 = v13718.sourceIsSubtypeOfTarget(rightType$$4, leftType$$5);
          if (v3809) {
            trinex.type = leftType$$5;
          } else {
            trinex.type = this.anyType;
            var v13719 = this.checker;
            var v3806 = v13719.errorReporter;
            var v3807 = trinex.printLabel();
            var v3808 = this.scope;
            v3806.incompatibleTypes(trinex, leftType$$5, rightType$$4, v3807, v3808);
          }
        }
      }
      return trinex;
    }
    function v1042(binex$$8, assignment$$2) {
      var v3812 = binex$$8;
      var v19657 = binex$$8.operand1;
      var v13720 = this.typeCheck(v19657);
      var v13721 = this.doubleType;
      var v26858 = this.cast(v13720, v13721);
      v3812.operand1 = v26858;
      var v3813 = binex$$8;
      var v19658 = binex$$8.operand2;
      var v13722 = this.typeCheck(v19658);
      var v13723 = this.doubleType;
      var v26859 = this.cast(v13722, v13723);
      v3813.operand2 = v26859;
      var v13724 = assignment$$2;
      if (v13724) {
        var v23476 = binex$$8.operand1;
        var v19659 = this.astIsWriteable(v23476);
        v13724 = !v19659;
      }
      var v3815 = v13724;
      if (v3815) {
        var v13725 = this.checker;
        var v3814 = v13725.errorReporter;
        v3814.valueCannotBeModified(binex$$8);
      }
      binex$$8.type = this.doubleType;
      return binex$$8;
    }
    function v1041(binex$$7) {
      var v3816 = binex$$7;
      var v19660 = binex$$7.operand1;
      var v13726 = this.typeCheck(v19660);
      var v13727 = this.stringType;
      var v26860 = this.cast(v13726, v13727);
      v3816.operand1 = v26860;
      var v3817 = binex$$7;
      var v13728 = binex$$7.operand2;
      var v26861 = this.typeCheck(v13728);
      v3817.operand2 = v26861;
      var v26090 = binex$$7.operand1;
      var v25314 = v26090.type;
      var v26091 = this.checker;
      var v25315 = v26091.anyType;
      var v23477 = v25314 == v25315;
      var v25318 = !v23477;
      if (v25318) {
        var v26092 = binex$$7.operand1;
        var v25316 = v26092.type;
        var v26093 = this.checker;
        var v25317 = v26093.stringType;
        v23477 = v25316 == v25317;
      }
      var v19661 = v23477;
      if (v19661) {
        var v26094 = binex$$7.operand2;
        var v25319 = v26094.type;
        var v25320 = this.anyType;
        var v23478 = v25319 == v25320;
        var v25324 = !v23478;
        if (v25324) {
          var v25321 = this.checker;
          var v26095 = binex$$7.operand2;
          var v25322 = v26095.type;
          var v25323 = this.objectInterfaceType;
          v23478 = v25321.sourceIsSubtypeOfTarget(v25322, v25323);
        }
        v19661 = v23478;
      }
      var v13729 = v19661;
      var v3819 = !v13729;
      if (v3819) {
        var v13730 = this.checker;
        var v3818 = v13730.errorReporter;
        v3818.simpleError(binex$$7, "The in operator requires the left operand to be of type Any or the String primitive type, and the right operand to be of type Any or an object type");
      }
      binex$$7.type = this.booleanType;
      return binex$$7;
    }
    function v1040(ast$$103) {
      var binex$$6 = ast$$103;
      var v3820 = binex$$6;
      var v13731 = binex$$6.operand1;
      var v26862 = this.typeCheck(v13731);
      v3820.operand1 = v26862;
      var v3821 = binex$$6;
      var v13732 = binex$$6.operand2;
      var v26863 = this.typeCheck(v13732);
      v3821.operand2 = v26863;
      var v23479 = this.checker;
      var v19662 = v23479.styleSettings;
      var v13733 = v19662.literalSubscript;
      var v3824 = !v13733;
      if (v3824) {
        var v19663 = binex$$6.operand2;
        var v13734 = v19663.nodeType;
        var v19664 = TypeScript$$25.NodeType;
        var v13735 = v19664.QString;
        var v3823 = v13734 == v13735;
        if (v3823) {
          var v13736 = this.checker;
          var v3822 = v13736.errorReporter;
          v3822.styleError(ast$$103, "use literal subscript ('.') notation instead)");
        }
      }
      var v3825 = binex$$6.operand1;
      var objExprType = v3825.type;
      var v3826 = binex$$6.operand2;
      var indexExprType = v3826.type;
      var v3845 = objExprType.elementType;
      if (v3845) {
        var v25325 = this.checker;
        var v23480 = v25325.anyType;
        var v19665 = indexExprType == v23480;
        var v23482 = !v19665;
        if (v23482) {
          var v25326 = this.checker;
          var v23481 = v25326.numberType;
          v19665 = indexExprType == v23481;
        }
        var v13737 = v19665;
        var v19668 = !v13737;
        if (v19668) {
          var v19666 = indexExprType.typeFlags;
          var v23483 = TypeScript$$25.TypeFlags;
          var v19667 = v23483.IsEnum;
          v13737 = TypeScript$$25.hasFlag(v19666, v19667);
        }
        var v3831 = v13737;
        if (v3831) {
          binex$$6.type = objExprType.elementType;
        } else {
          var v19669 = this.checker;
          var v13738 = v19669.stringType;
          var v3830 = indexExprType == v13738;
          if (v3830) {
            var v3827 = this.checker;
            binex$$6.type = v3827.anyType;
          } else {
            var v13739 = this.checker;
            var v3828 = v13739.errorReporter;
            v3828.simpleError(binex$$6, "Illegal property access");
            var v3829 = this.checker;
            binex$$6.type = v3829.anyType;
          }
        }
      } else {
        var v3844 = objExprType.index;
        if (v3844) {
          var v26096 = this.checker;
          var v25327 = v26096.anyType;
          var v23484 = indexExprType == v25327;
          var v25329 = !v23484;
          if (v25329) {
            var v26601 = objExprType.index;
            var v26433 = v26601.flags;
            var v26602 = TypeScript$$25.SignatureFlags;
            var v26434 = v26602.IsStringIndexer;
            var v26097 = v26433 & v26434;
            var v26437 = !v26097;
            if (v26437) {
              var v26603 = objExprType.index;
              var v26435 = v26603.flags;
              var v26604 = TypeScript$$25.SignatureFlags;
              var v26436 = v26604.IsNumberIndexer;
              v26097 = v26435 & v26436;
            }
            var v25328 = v26097;
            v23484 = !v25328;
          }
          var v19670 = v23484;
          var v23486 = !v19670;
          if (v23486) {
            var v26098 = objExprType.index;
            var v25330 = v26098.flags;
            var v26099 = TypeScript$$25.SignatureFlags;
            var v25331 = v26099.IsStringIndexer;
            var v23485 = v25330 & v25331;
            if (v23485) {
              var v26100 = this.checker;
              var v25332 = v26100.stringType;
              v23485 = indexExprType == v25332;
            }
            v19670 = v23485;
          }
          var v13740 = v19670;
          var v19672 = !v13740;
          if (v19672) {
            var v25333 = objExprType.index;
            var v23487 = v25333.flags;
            var v25334 = TypeScript$$25.SignatureFlags;
            var v23488 = v25334.IsNumberIndexer;
            var v19671 = v23487 & v23488;
            if (v19671) {
              var v26101 = this.checker;
              var v25335 = v26101.numberType;
              var v23489 = indexExprType == v25335;
              var v25338 = !v23489;
              if (v25338) {
                var v25336 = indexExprType.typeFlags;
                var v26102 = TypeScript$$25.TypeFlags;
                var v25337 = v26102.IsEnum;
                v23489 = TypeScript$$25.hasFlag(v25336, v25337);
              }
              v19671 = v23489;
            }
            v13740 = v19671;
          }
          var v3839 = v13740;
          if (v3839) {
            var v3832 = objExprType.index;
            var sig$$3 = this.resolveOverload(ast$$103, v3832);
            if (sig$$3) {
              var v3833 = sig$$3.returnType;
              binex$$6.type = v3833.type;
            } else {
              var v3834 = this.checker;
              binex$$6.type = v3834.anyType;
            }
          } else {
            var v19673 = this.checker;
            var v13741 = v19673.stringType;
            var v3838 = indexExprType == v13741;
            if (v3838) {
              var v3835 = this.checker;
              binex$$6.type = v3835.anyType;
            } else {
              var v13742 = this.checker;
              var v3836 = v13742.errorReporter;
              v3836.simpleError(binex$$6, "Illegal property access");
              var v3837 = this.checker;
              binex$$6.type = v3837.anyType;
            }
          }
        } else {
          var v26605 = this.checker;
          var v26438 = v26605.anyType;
          var v26103 = objExprType == v26438;
          var v26440 = !v26103;
          if (v26440) {
            var v26606 = this.checker;
            var v26439 = v26606.stringType;
            v26103 = objExprType == v26439;
          }
          var v25339 = v26103;
          var v26105 = !v25339;
          if (v26105) {
            var v26441 = this.checker;
            var v26104 = v26441.numberType;
            v25339 = objExprType == v26104;
          }
          var v23490 = v25339;
          var v25341 = !v23490;
          if (v25341) {
            var v26106 = this.checker;
            var v25340 = v26106.booleanType;
            v23490 = objExprType == v25340;
          }
          var v19674 = v23490;
          var v23491 = !v19674;
          if (v23491) {
            v19674 = objExprType.isReferenceType();
          }
          var v13743 = v19674;
          if (v13743) {
            var v26107 = this.checker;
            var v25342 = v26107.anyType;
            var v23492 = indexExprType == v25342;
            var v25344 = !v23492;
            if (v25344) {
              var v26108 = this.checker;
              var v25343 = v26108.stringType;
              v23492 = indexExprType == v25343;
            }
            var v19675 = v23492;
            var v23494 = !v19675;
            if (v23494) {
              var v26109 = this.checker;
              var v25345 = v26109.numberType;
              var v23493 = indexExprType == v25345;
              var v25348 = !v23493;
              if (v25348) {
                var v25346 = indexExprType.typeFlags;
                var v26110 = TypeScript$$25.TypeFlags;
                var v25347 = v26110.IsEnum;
                v23493 = TypeScript$$25.hasFlag(v25346, v25347);
              }
              v19675 = v23493;
            }
            v13743 = v19675;
          }
          var v3843 = v13743;
          if (v3843) {
            var v3840 = this.checker;
            binex$$6.type = v3840.anyType;
          } else {
            var v13744 = this.checker;
            var v3841 = v13744.errorReporter;
            v3841.simpleError(binex$$6, "Illegal property access");
            var v3842 = this.checker;
            binex$$6.type = v3842.anyType;
          }
        }
      }
      return binex$$6;
    }
    function v1039(ast$$102) {
      var binex$$5 = ast$$102;
      var v13745 = binex$$5.operand2;
      var v3846 = v13745.isParenthesized;
      var applyTargetType$$2 = !v3846;
      var v3847 = binex$$5;
      var v13746 = binex$$5.operand1;
      var v26864 = this.typeCheck(v13746);
      v3847.operand1 = v26864;
      var v3848 = this.checker;
      var v13747 = binex$$5.operand1;
      var v3849 = v13747.type;
      var v13748 = this.checker;
      var v3850 = v13748.inProvisionalTypecheckMode();
      var v3851 = binex$$5.operand2;
      v3848.typeCheckWithContextualType(v3849, v3850, applyTargetType$$2, v3851);
      var v3852 = binex$$5.operand1;
      var leftType$$4 = v3852.type;
      var v3853 = binex$$5.operand2;
      var rightType$$3 = v3853.type;
      var v19676 = binex$$5.operand1;
      var v13749 = this.astIsWriteable(v19676);
      var v3855 = !v13749;
      if (v3855) {
        var v13750 = this.checker;
        var v3854 = v13750.errorReporter;
        v3854.valueCannotBeModified(binex$$5);
      }
      var v19677 = binex$$5.operand1;
      var v13751 = v19677.nodeType;
      var v19678 = TypeScript$$25.NodeType;
      var v13752 = v19678.Call;
      var v3856 = v13751 == v13752;
      if (v3856) {
        var callEx$$1 = binex$$5.operand1
      }
      var preserveScope$$1 = false;
      var preservedContainedScope$$1 = null;
      var v13753 = binex$$5.operand2;
      var v3858 = v13753.type;
      if (v3858) {
        var v13754 = binex$$5.operand2;
        var v3857 = v13754.type;
        preservedContainedScope$$1 = v3857.containedScope;
        preserveScope$$1 = true;
      }
      var v3859 = binex$$5;
      var v13755 = binex$$5.operand2;
      var v19679 = applyTargetType$$2;
      if (v19679) {
        var v25349 = this.checker;
        var v23495 = v25349.inProvisionalTypecheckMode();
        v19679 = !v23495;
      }
      var v13756 = v19679;
      var v26865 = this.castWithCoercion(v13755, leftType$$4, v13756, false);
      v3859.operand2 = v26865;
      var v13757 = preserveScope$$1;
      if (v13757) {
        var v25350 = binex$$5.operand2;
        var v23496 = v25350.type;
        var v19680 = v23496.containedScope;
        v13757 = v19680 == null;
      }
      var v3861 = v13757;
      if (v3861) {
        var v13758 = binex$$5.operand2;
        var v3860 = v13758.type;
        v3860.containedScope = preservedContainedScope$$1;
      }
      binex$$5.type = rightType$$3;
      return binex$$5;
    }
    function v1038(ast$$101) {
      var binex$$4 = ast$$101;
      var v3862 = binex$$4;
      var v13759 = binex$$4.operand1;
      var v26866 = this.typeCheck(v13759);
      v3862.operand1 = v26866;
      var v3863 = binex$$4;
      var v13760 = binex$$4.operand2;
      var v26867 = this.typeCheck(v13760);
      v3863.operand2 = v26867;
      var v3864 = binex$$4.operand1;
      var leftType$$3 = v3864.type;
      var v3865 = binex$$4.operand2;
      var rightType$$2 = v3865.type;
      var v23497 = this.checker;
      var v19681 = v23497.sourceIsAssignableToTarget(leftType$$3, rightType$$2);
      var v13761 = !v19681;
      if (v13761) {
        var v23498 = this.checker;
        var v19682 = v23498.sourceIsAssignableToTarget(rightType$$2, leftType$$3);
        v13761 = !v19682;
      }
      var v3869 = v13761;
      if (v3869) {
        var v13762 = this.checker;
        var v3866 = v13762.errorReporter;
        var v3867 = binex$$4.printLabel();
        var v3868 = this.scope;
        v3866.incompatibleTypes(binex$$4, leftType$$3, rightType$$2, v3867, v3868);
      }
      binex$$4.type = this.booleanType;
      return binex$$4;
    }
    function v1037(ast$$100) {
      var binex$$3 = ast$$100;
      var leftIsFnc = false;
      var v3870 = binex$$3;
      var v13763 = binex$$3.operand1;
      var v26868 = this.typeCheck(v13763);
      v3870.operand1 = v26868;
      var v3871 = binex$$3.operand1;
      var leftType$$2 = v3871.type;
      var leftScope = null;
      if (leftType$$2) {
        var v13764 = this.anyType;
        var v3889 = leftType$$2 == v13764;
        if (v3889) {
          binex$$3.type = this.anyType;
          return binex$$3;
        } else {
          var v13765 = this.stringType;
          var v3888 = leftType$$2 == v13765;
          if (v3888) {
            var v3873 = this.stringInterfaceType;
            if (v3873) {
              var v3872 = this.stringInterfaceType;
              leftScope = v3872.memberScope;
            } else {
              binex$$3.type = this.anyType;
              return binex$$3;
            }
          } else {
            var v13766 = this.doubleType;
            var v3887 = leftType$$2 == v13766;
            if (v3887) {
              var v3875 = this.numberInterfaceType;
              if (v3875) {
                var v3874 = this.numberInterfaceType;
                leftScope = v3874.memberScope;
              } else {
                binex$$3.type = this.anyType;
                return binex$$3;
              }
            } else {
              var v13767 = this.booleanType;
              var v3886 = leftType$$2 == v13767;
              if (v3886) {
                var v3877 = this.booleanInterfaceType;
                if (v3877) {
                  var v3876 = this.booleanInterfaceType;
                  leftScope = v3876.memberScope;
                } else {
                  binex$$3.type = this.anyType;
                  return binex$$3;
                }
              } else {
                var v19683 = leftType$$2.call;
                var v23499 = !v19683;
                if (v23499) {
                  v19683 = leftType$$2.construct;
                }
                var v13768 = v19683;
                if (v13768) {
                  var v19684 = leftType$$2.members;
                  v13768 = v19684 == null;
                }
                var v3885 = v13768;
                if (v3885) {
                  var v3879 = this.functionInterfaceType;
                  if (v3879) {
                    var v3878 = this.functionInterfaceType;
                    leftScope = v3878.memberScope;
                  } else {
                    binex$$3.type = this.anyType;
                    return binex$$3;
                  }
                } else {
                  var v3884 = leftType$$2.elementType;
                  if (v3884) {
                    var v3883 = this.arrayInterfaceType;
                    if (v3883) {
                      var v3880 = leftType$$2.elementType;
                      var v3881 = this.arrayInterfaceType;
                      var v3882 = this.checker;
                      var arrInstType$$1 = v3880.getArrayBase(v3881, v3882);
                      leftScope = arrInstType$$1.memberScope;
                    } else {
                      binex$$3.type = this.anyType;
                      return binex$$3;
                    }
                  } else {
                    leftScope = leftType$$2.memberScope;
                  }
                }
              }
            }
          }
        }
      }
      var v3918 = leftScope == null;
      if (v3918) {
        var v13769 = this.checker;
        var v3890 = v13769.errorReporter;
        v3890.expectedClassOrInterface(binex$$3);
        binex$$3.type = this.anyType;
      } else {
        var propertyName$$8 = binex$$3.operand2;
        var v13770 = this.thisClassNode;
        if (v13770) {
          var v23500 = binex$$3.operand1;
          var v19685 = v23500.type;
          var v25351 = this.thisClassNode;
          var v23501 = v25351.type;
          var v19686 = v23501.instanceType;
          v13770 = v19685 == v19686;
        }
        var v3891 = v13770;
        var v13771 = !v3891;
        if (v13771) {
          v3891 = this.inTypeRefTypeCheck;
        }
        var lhsIsEnclosingType = v3891;
        var v3892 = propertyName$$8.text;
        var v3893 = !lhsIsEnclosingType;
        var v3894 = this.inTypeRefTypeCheck;
        var symbol$$19 = leftScope.find(v3892, v3893, v3894);
        var v3905 = !symbol$$19;
        if (v3905) {
          var v13772 = this.objectInterfaceType;
          if (v13772) {
            v13772 = leftType$$2;
          }
          var v3904 = v13772;
          if (v3904) {
            var v3898 = leftType$$2.isReferenceType();
            if (v3898) {
              var v13773 = this.objectInterfaceType;
              var v3895 = v13773.memberScope;
              var v3896 = propertyName$$8.text;
              var v3897 = this.inTypeRefTypeCheck;
              symbol$$19 = v3895.find(v3896, false, v3897);
            }
            var v3903 = !symbol$$19;
            if (v3903) {
              var v13774 = this.functionInterfaceType;
              if (v13774) {
                var v19687 = leftType$$2.call;
                var v23502 = !v19687;
                if (v23502) {
                  v19687 = leftType$$2.construct;
                }
                v13774 = v19687;
              }
              var v3902 = v13774;
              if (v3902) {
                var v13775 = this.functionInterfaceType;
                var v3899 = v13775.memberScope;
                var v3900 = propertyName$$8.text;
                var v3901 = this.inTypeRefTypeCheck;
                symbol$$19 = v3899.find(v3900, false, v3901);
              }
            }
          }
        }
        var v13776 = !symbol$$19;
        var v19689 = !v13776;
        if (v19689) {
          var v23503 = this.checker;
          var v19688 = symbol$$19.visible(leftScope, v23503);
          v13776 = !v19688;
        }
        var v3917 = v13776;
        if (v3917) {
          binex$$3.type = this.anyType;
          var v3911 = symbol$$19 == null;
          if (v3911) {
            var v13777 = this.checker;
            var v3906 = v13777.errorReporter;
            var v25352 = propertyName$$8.actualText;
            var v23504 = "The property '" + v25352;
            var v19690 = v23504 + "' does not exist on value of type '";
            var v23505 = this.scope;
            var v19691 = leftType$$2.getScopedTypeName(v23505);
            var v13778 = v19690 + v19691;
            var v3907 = v13778 + "'";
            v3906.simpleError(propertyName$$8, v3907);
          } else {
            var v13779 = this.inTypeRefTypeCheck;
            var v3910 = !v13779;
            if (v3910) {
              var v13780 = this.checker;
              var v3908 = v13780.errorReporter;
              var v25353 = propertyName$$8.actualText;
              var v23506 = "The property '" + v25353;
              var v19692 = v23506 + " on type '";
              var v23507 = this.scope;
              var v19693 = leftType$$2.getScopedTypeName(v23507);
              var v13781 = v19692 + v19693;
              var v3909 = v13781 + "' is not visible";
              v3908.simpleError(binex$$3, v3909);
            }
          }
        } else {
          var v3915 = symbol$$19.isVariable();
          if (v3915) {
            var v3914 = symbol$$19.isInferenceSymbol();
            if (v3914) {
              var infSym$$2 = symbol$$19;
              var v13782 = infSym$$2.declAST;
              if (v13782) {
                var v23508 = this.checker;
                var v23509 = infSym$$2.typeCheckStatus;
                var v19694 = v23508.typeStatusIsFinished(v23509);
                v13782 = !v19694;
              }
              var v3913 = v13782;
              if (v3913) {
                var v3912 = infSym$$2.declAST;
                this.inScopeTypeCheckDecl(v3912);
              }
            }
          }
          propertyName$$8.sym = symbol$$19;
          var v3916 = binex$$3;
          var v26869 = symbol$$19.getType();
          v3916.type = v26869;
        }
      }
      var v13783 = binex$$3.type;
      var v3919 = v13783 == null;
      if (v3919) {
        binex$$3.type = this.anyType;
      }
      return binex$$3;
    }
    function v1036(ast$$99, assignment$$1) {
      var binex$$2 = ast$$99;
      var v3920 = binex$$2;
      var v13784 = binex$$2.operand1;
      var v26870 = this.typeCheck(v13784);
      v3920.operand1 = v26870;
      var v3921 = binex$$2;
      var v13785 = binex$$2.operand2;
      var v26871 = this.typeCheck(v13785);
      v3921.operand2 = v26871;
      var v3922 = binex$$2.operand1;
      var leftType$$1 = v3922.type;
      var v3923 = binex$$2.operand2;
      var rightType$$1 = v3923.type;
      var v13786 = assignment$$1;
      if (v13786) {
        var v23510 = binex$$2.operand1;
        var v19695 = this.astIsWriteable(v23510);
        v13786 = !v19695;
      }
      var v3925 = v13786;
      if (v3925) {
        var v13787 = this.checker;
        var v3924 = v13787.errorReporter;
        v3924.valueCannotBeModified(binex$$2);
      }
      var v23511 = this.checker;
      var v19696 = v23511.styleSettings;
      var v13788 = v19696.bitwise;
      if (v13788) {
        var v26111 = binex$$2.nodeType;
        var v26442 = TypeScript$$25.NodeType;
        var v26112 = v26442.And;
        var v25354 = v26111 == v26112;
        var v26115 = !v25354;
        if (v26115) {
          var v26113 = binex$$2.nodeType;
          var v26443 = TypeScript$$25.NodeType;
          var v26114 = v26443.Or;
          v25354 = v26113 == v26114;
        }
        var v23512 = v25354;
        var v25357 = !v23512;
        if (v25357) {
          var v25355 = binex$$2.nodeType;
          var v26116 = TypeScript$$25.NodeType;
          var v25356 = v26116.AsgAnd;
          v23512 = v25355 == v25356;
        }
        var v19697 = v23512;
        var v23515 = !v19697;
        if (v23515) {
          var v23513 = binex$$2.nodeType;
          var v25358 = TypeScript$$25.NodeType;
          var v23514 = v25358.AsgOr;
          v19697 = v23513 == v23514;
        }
        v13788 = v19697;
      }
      var v3928 = v13788;
      if (v3928) {
        var v13789 = this.checker;
        var v3926 = v13789.errorReporter;
        var v19698 = TypeScript$$25.nodeTypeTable;
        var v19699 = binex$$2.nodeType;
        var v13790 = v19698[v19699];
        var v3927 = "use of " + v13790;
        v3926.styleError(ast$$99, v3927);
      }
      var v13791 = leftType$$1 == null;
      var v19700 = !v13791;
      if (v19700) {
        v13791 = rightType$$1 == null;
      }
      var v3930 = v13791;
      if (v3930) {
        var v13792 = this.checker;
        var v3929 = v13792.errorReporter;
        v3929.simpleError(binex$$2, "Could not typecheck arithmetic operation.  Possible recursive typecheck error?");
        binex$$2.type = this.anyType;
        return binex$$2;
      }
      var nodeType$$14 = binex$$2.nodeType;
      var v13793 = this.checker;
      var v3931 = v13793.isNullOrUndefinedType(leftType$$1);
      if (v3931) {
        leftType$$1 = rightType$$1;
      }
      var v13794 = this.checker;
      var v3932 = v13794.isNullOrUndefinedType(rightType$$1);
      if (v3932) {
        rightType$$1 = leftType$$1;
      }
      var v3933 = this.checker;
      leftType$$1 = v3933.widenType(leftType$$1);
      var v3934 = this.checker;
      rightType$$1 = v3934.widenType(rightType$$1);
      var v23516 = TypeScript$$25.NodeType;
      var v19701 = v23516.Add;
      var v13795 = nodeType$$14 == v19701;
      var v19703 = !v13795;
      if (v19703) {
        var v23517 = TypeScript$$25.NodeType;
        var v19702 = v23517.AsgAdd;
        v13795 = nodeType$$14 == v19702;
      }
      var v3955 = v13795;
      if (v3955) {
        var v23518 = this.checker;
        var v19704 = v23518.stringType;
        var v13796 = leftType$$1 == v19704;
        var v19706 = !v13796;
        if (v19706) {
          var v23519 = this.checker;
          var v19705 = v23519.stringType;
          v13796 = rightType$$1 == v19705;
        }
        var v3945 = v13796;
        if (v3945) {
          var v3935 = this.checker;
          binex$$2.type = v3935.stringType;
        } else {
          var v23520 = this.checker;
          var v19707 = v23520.numberType;
          var v13797 = leftType$$1 == v19707;
          if (v13797) {
            var v23521 = this.checker;
            var v19708 = v23521.numberType;
            v13797 = rightType$$1 == v19708;
          }
          var v3944 = v13797;
          if (v3944) {
            var v3936 = this.checker;
            binex$$2.type = v3936.numberType;
          } else {
            var v19709 = this.checker;
            var v23522 = this.checker;
            var v19710 = v23522.numberType;
            var v13798 = v19709.sourceIsSubtypeOfTarget(leftType$$1, v19710);
            if (v13798) {
              var v19711 = this.checker;
              var v23523 = this.checker;
              var v19712 = v23523.numberType;
              v13798 = v19711.sourceIsSubtypeOfTarget(rightType$$1, v19712);
            }
            var v3943 = v13798;
            if (v3943) {
              var v3937 = this.checker;
              binex$$2.type = v3937.numberType;
            } else {
              var v23524 = this.checker;
              var v19713 = v23524.anyType;
              var v13799 = leftType$$1 == v19713;
              var v19715 = !v13799;
              if (v19715) {
                var v23525 = this.checker;
                var v19714 = v23525.anyType;
                v13799 = rightType$$1 == v19714;
              }
              var v3942 = v13799;
              if (v3942) {
                var v3938 = this.checker;
                binex$$2.type = v3938.anyType;
              } else {
                binex$$2.type = this.anyType;
                var v13800 = this.checker;
                var v3939 = v13800.errorReporter;
                var v3940 = binex$$2.printLabel();
                var v3941 = this.scope;
                v3939.incompatibleTypes(binex$$2, leftType$$1, rightType$$1, v3940, v3941);
              }
            }
          }
        }
      } else {
        var v23526 = this.checker;
        var v19716 = v23526.numberType;
        var v13801 = leftType$$1 == v19716;
        if (v13801) {
          var v23527 = this.checker;
          var v19717 = v23527.numberType;
          v13801 = rightType$$1 == v19717;
        }
        var v3954 = v13801;
        if (v3954) {
          var v3946 = this.checker;
          binex$$2.type = v3946.numberType;
        } else {
          var v19718 = this.checker;
          var v23528 = this.checker;
          var v19719 = v23528.numberType;
          var v13802 = v19718.sourceIsSubtypeOfTarget(leftType$$1, v19719);
          if (v13802) {
            var v19720 = this.checker;
            var v23529 = this.checker;
            var v19721 = v23529.numberType;
            v13802 = v19720.sourceIsSubtypeOfTarget(rightType$$1, v19721);
          }
          var v3953 = v13802;
          if (v3953) {
            var v3947 = this.checker;
            binex$$2.type = v3947.numberType;
          } else {
            var v23530 = this.checker;
            var v19722 = v23530.anyType;
            var v13803 = leftType$$1 == v19722;
            var v19724 = !v13803;
            if (v19724) {
              var v23531 = this.checker;
              var v19723 = v23531.anyType;
              v13803 = rightType$$1 == v19723;
            }
            var v3952 = v13803;
            if (v3952) {
              var v3948 = this.checker;
              binex$$2.type = v3948.numberType;
            } else {
              binex$$2.type = this.anyType;
              var v13804 = this.checker;
              var v3949 = v13804.errorReporter;
              var v3950 = binex$$2.printLabel();
              var v3951 = this.scope;
              v3949.incompatibleTypes(binex$$2, leftType$$1, rightType$$1, v3950, v3951);
            }
          }
        }
      }
      return binex$$2;
    }
    function v1035(ast$$98, assignment) {
      var binex$$1 = ast$$98;
      var resultType$$1 = null;
      var v3956 = binex$$1;
      var v13805 = binex$$1.operand1;
      var v26872 = this.typeCheck(v13805);
      v3956.operand1 = v26872;
      var v3957 = binex$$1;
      var v13806 = binex$$1.operand2;
      var v26873 = this.typeCheck(v13806);
      v3957.operand2 = v26873;
      var v3958 = binex$$1.operand1;
      var leftType = v3958.type;
      var v3959 = binex$$1.operand2;
      var rightType = v3959.type;
      var v13807 = assignment;
      if (v13807) {
        var v19725 = this.astIsWriteable(binex$$1);
        v13807 = !v19725;
      }
      var v3961 = v13807;
      if (v3961) {
        var v13808 = this.checker;
        var v3960 = v13808.errorReporter;
        v3960.valueCannotBeModified(binex$$1);
      }
      var v19726 = this.checker;
      var v13809 = v19726.styleSettings;
      var v3964 = v13809.bitwise;
      if (v3964) {
        var v13810 = this.checker;
        var v3962 = v13810.errorReporter;
        var v19727 = TypeScript$$25.nodeTypeTable;
        var v19728 = binex$$1.nodeType;
        var v13811 = v19727[v19728];
        var v3963 = "use of " + v13811;
        v3962.styleError(ast$$98, v3963);
      }
      var v19729 = this.checker;
      var v19730 = this.doubleType;
      var v13812 = v19729.sourceIsSubtypeOfTarget(leftType, v19730);
      if (v13812) {
        var v19731 = this.checker;
        var v19732 = this.doubleType;
        v13812 = v19731.sourceIsSubtypeOfTarget(rightType, v19732);
      }
      var v3970 = v13812;
      if (v3970) {
        resultType$$1 = this.doubleType;
      } else {
        var v19733 = this.booleanType;
        var v13813 = leftType == v19733;
        if (v13813) {
          var v19734 = this.booleanType;
          v13813 = rightType == v19734;
        }
        var v3969 = v13813;
        if (v3969) {
          resultType$$1 = this.booleanType;
        } else {
          var v13814 = this.anyType;
          var v3968 = leftType == v13814;
          if (v3968) {
            var v23532 = this.anyType;
            var v19735 = rightType == v23532;
            var v23534 = !v19735;
            if (v23534) {
              var v23533 = this.doubleType;
              v19735 = rightType == v23533;
            }
            var v13815 = v19735;
            var v19737 = !v13815;
            if (v19737) {
              var v19736 = this.booleanType;
              v13815 = rightType == v19736;
            }
            var v3965 = v13815;
            if (v3965) {
              resultType$$1 = this.anyType;
            }
          } else {
            var v13816 = this.anyType;
            var v3967 = rightType == v13816;
            if (v3967) {
              var v23535 = this.anyType;
              var v19738 = leftType == v23535;
              var v23537 = !v19738;
              if (v23537) {
                var v23536 = this.doubleType;
                v19738 = leftType == v23536;
              }
              var v13817 = v19738;
              var v19740 = !v13817;
              if (v19740) {
                var v19739 = this.booleanType;
                v13817 = leftType == v19739;
              }
              var v3966 = v13817;
              if (v3966) {
                resultType$$1 = this.anyType;
              }
            }
          }
        }
      }
      var v3974 = resultType$$1 == null;
      if (v3974) {
        resultType$$1 = this.anyType;
        var v13818 = this.checker;
        var v3971 = v13818.errorReporter;
        var v3972 = binex$$1.printLabel();
        var v3973 = this.scope;
        v3971.incompatibleTypes(binex$$1, leftType, rightType, v3972, v3973);
      }
      binex$$1.type = resultType$$1;
      return binex$$1;
    }
    function v1034(ast$$97) {
      var unex$$3 = ast$$97;
      var lval$$1 = unex$$3.operand;
      var v13819 = this.astIsWriteable(unex$$3);
      var v3978 = !v13819;
      if (v3978) {
        var v13820 = this.checker;
        var v3975 = v13820.errorReporter;
        v3975.valueCannotBeModified(unex$$3);
        unex$$3.type = this.doubleType;
      } else {
        unex$$3 = this.typeCheckUnaryNumberOperator(ast$$97);
        var v25359 = unex$$3.operand;
        var v23538 = v25359.type;
        var v25360 = this.checker;
        var v23539 = v25360.numberType;
        var v19741 = v23538 != v23539;
        if (v19741) {
          var v25361 = unex$$3.operand;
          var v23540 = v25361.type;
          var v25362 = this.checker;
          var v23541 = v25362.anyType;
          v19741 = v23540 != v23541;
        }
        var v13821 = v19741;
        if (v13821) {
          var v26117 = unex$$3.operand;
          var v25363 = v26117.type;
          var v23542 = v25363.typeFlags;
          var v25364 = TypeScript$$25.TypeFlags;
          var v23543 = v25364.IsEnum;
          var v19742 = v23542 & v23543;
          v13821 = !v19742;
        }
        var v3977 = v13821;
        if (v3977) {
          var v13822 = this.checker;
          var v3976 = v13822.errorReporter;
          v3976.simpleError(ast$$97, "'++' and '--' may only be applied to operands of type 'number' or 'any'");
        }
      }
      return unex$$3;
    }
    function v1033(ast$$96) {
      var v3979 = ast$$96.flags;
      var v13823 = TypeScript$$25.ASTFlags;
      var v3980 = v13823.Writeable;
      return TypeScript$$25.hasFlag(v3979, v3980);
    }
    function v1032(ast$$95) {
      var unex$$2 = ast$$95;
      var v3981 = unex$$2;
      var v13824 = unex$$2.operand;
      var v26874 = this.typeCheck(v13824);
      v3981.operand = v26874;
      unex$$2.type = this.booleanType;
      return unex$$2;
    }
    function v1031(ast$$94) {
      var unex$$1 = ast$$94;
      var v3982 = unex$$1;
      var v13825 = unex$$1.operand;
      var v26875 = this.typeCheck(v13825);
      v3982.operand = v26875;
      unex$$1.type = this.doubleType;
      return ast$$94;
    }
    function v1030(ast$$93) {
      var unex = ast$$93;
      var v3983 = unex;
      var v13826 = unex.operand;
      var v26876 = this.typeCheck(v13826);
      v3983.operand = v26876;
      unex.type = this.doubleType;
      return unex;
    }
    function v1029(script$$16) {
      var v3984 = this.checker;
      v3984.locationInfo = script$$16.locationInfo;
      var v3985 = this.checker;
      this.scope = v3985.globalScope;
      var v13827 = script$$16.topLevelMod;
      var v3990 = !v13827;
      if (v3990) {
        var v3986 = this.scope;
        var v13828 = this.checker;
        var v3987 = v13828.gloMod;
        var v3988 = script$$16.vars;
        var v13829 = this.checker;
        var v3989 = v13829.globals;
        this.addLocalsFromScope(v3986, v3987, v3988, v3989, true);
      }
      this.currentScript = script$$16;
      var v3991 = script$$16;
      var v13830 = script$$16.bod;
      var v26877 = this.typeCheck(v13830);
      v3991.bod = v26877;
      this.currentScript = null;
      return script$$16;
    }
    function v1028(ast$$92) {
      function v1027(id$$22) {
        var v3992 = _this$$7.scope;
        return v3992.find(id$$22, false, typespace$$24);
      }
      var _this$$7 = this;
      var identifier$$3 = ast$$92;
      var v13831 = this.checker;
      var v4013 = v13831.inWith;
      if (v4013) {
        identifier$$3.type = this.anyType;
      } else {
        var typespace$$24 = this.inTypeRefTypeCheck;
        var idText$$4 = identifier$$3.text;
        var originalIdText$$1 = idText$$4;
        var v3993 = identifier$$3.text;
        var isDynamicModuleName = TypeScript$$25.isQuoted(v3993);
        var v3994 = this.scope;
        var symbol$$18 = v3994.find(idText$$4, false, typespace$$24);
        var v13832 = symbol$$18 == null;
        if (v13832) {
          v13832 = isDynamicModuleName;
        }
        var v3997 = v13832;
        if (v3997) {
          var v3995 = this.checker;
          var v19743 = this.currentScript;
          var v13833 = v19743.locationInfo;
          var v3996 = v13833.filename;
          symbol$$18 = v3995.findSymbolForDynamicModule(idText$$4, v3996, v1027);
        }
        var v4012 = !symbol$$18;
        if (v4012) {
          var v13834 = identifier$$3.isMissing();
          var v4000 = !v13834;
          if (v4000) {
            var v13835 = this.checker;
            var v3998 = v13835.errorReporter;
            var v3999 = identifier$$3.text;
            v3998.unresolvedSymbol(identifier$$3, v3999);
          }
          identifier$$3.type = this.anyType;
        } else {
          var v19744 = TypeScript$$25.optimizeModuleCodeGen;
          if (v19744) {
            v19744 = symbol$$18;
          }
          var v13836 = v19744;
          if (v13836) {
            v13836 = symbol$$18.isType();
          }
          var v4004 = v13836;
          if (v4004) {
            var symType$$2 = symbol$$18.getType();
            var v19745 = symType$$2;
            if (v19745) {
              v19745 = symbol$$18.aliasLink;
            }
            var v13837 = v19745;
            if (v13837) {
              v13837 = symbol$$18.onlyReferencedAsTypeRef;
            }
            var v4003 = v13837;
            if (v4003) {
              var v4001 = symType$$2.symbol;
              var modDecl$$2 = v4001.declAST;
              var v13838 = modDecl$$2;
              if (v13838) {
                var v19746 = modDecl$$2.modFlags;
                var v23544 = TypeScript$$25.ModuleFlags;
                var v19747 = v23544.IsDynamic;
                v13838 = TypeScript$$25.hasFlag(v19746, v19747);
              }
              var v4002 = v13838;
              if (v4002) {
                symbol$$18.onlyReferencedAsTypeRef = this.inTypeRefTypeCheck;
              }
            }
          }
          var v23545 = symbol$$18.declAST;
          if (v23545) {
            var v26118 = symbol$$18.declAST;
            var v25365 = v26118.nodeType;
            var v26119 = TypeScript$$25.NodeType;
            var v25366 = v26119.FuncDecl;
            v23545 = v25365 == v25366;
          }
          var v19748 = v23545;
          if (v19748) {
            var v25367 = symbol$$18.declAST;
            var v23546 = v25367.returnTypeAnnotation;
            v19748 = !v23546;
          }
          var v13839 = v19748;
          if (v13839) {
            var v25368 = symbol$$18.declAST;
            var v23547 = v25368.signature;
            var v19749 = v23547.typeCheckStatus;
            var v23548 = TypeScript$$25.TypeCheckStatus;
            var v19750 = v23548.Started;
            v13839 = v19749 == v19750;
          }
          var v4007 = v13839;
          if (v4007) {
            var v19751 = symbol$$18.declAST;
            var v13840 = v19751.type;
            var v4005 = v13840.symbol;
            var v19752 = v4005.flags;
            var v23549 = TypeScript$$25.SymbolFlags;
            var v19753 = v23549.RecursivelyReferenced;
            v4005.flags = v19752 | v19753;
            var v19754 = symbol$$18.declAST;
            var v13841 = v19754.signature;
            var v4006 = v13841.returnType;
            v4006.type = this.anyType;
          }
          this.setTypeFromSymbol(ast$$92, symbol$$18);
          identifier$$3.sym = symbol$$18;
          var v4011 = this.thisFnc;
          if (v4011) {
            var v19755 = this.thisFnc;
            var v13842 = v19755.type;
            if (v13842) {
              var v19756 = symbol$$18.container;
              var v25369 = this.thisFnc;
              var v23550 = v25369.type;
              var v19757 = v23550.symbol;
              v13842 = v19756 != v19757;
            }
            var v4010 = v13842;
            if (v4010) {
              var v13843 = this.thisFnc;
              var v4008 = v13843.freeVariables;
              var v19758 = this.thisFnc;
              var v13844 = v19758.freeVariables;
              var v4009 = v13844.length;
              v4008[v4009] = symbol$$18;
            }
          }
        }
      }
      return ast$$92;
    }
    function v1026(ast$$91, symbol$$17) {
      var v4031 = symbol$$17.isVariable();
      if (v4031) {
        var v4020 = symbol$$17.isInferenceSymbol();
        if (v4020) {
          var infSym$$1 = symbol$$17;
          var v13845 = infSym$$1.declAST;
          if (v13845) {
            var v23551 = this.checker;
            var v23552 = infSym$$1.typeCheckStatus;
            var v19759 = v23551.typeStatusIsFinished(v23552);
            v13845 = !v19759;
          }
          var v4015 = v13845;
          if (v4015) {
            var v4014 = infSym$$1.declAST;
            this.inScopeTypeCheckDecl(v4014);
          }
          var v23553 = this.checker;
          var v19760 = v23553.styleSettings;
          var v13846 = v19760.innerScopeDeclEscape;
          var v4019 = !v13846;
          if (v4019) {
            var v13847 = infSym$$1.declAST;
            if (v13847) {
              var v23554 = infSym$$1.declAST;
              var v19761 = v23554.nodeType;
              var v23555 = TypeScript$$25.NodeType;
              var v19762 = v23555.VarDecl;
              v13847 = v19761 == v19762;
            }
            var v4018 = v13847;
            if (v4018) {
              var v13848 = this.nestingLevel;
              var v19763 = infSym$$1.declAST;
              var v13849 = v19763.nestingLevel;
              var v4017 = v13848 < v13849;
              if (v4017) {
                var v13850 = this.checker;
                var v4016 = v13850.errorReporter;
                v4016.styleError(ast$$91, "Illegal reference to a variable defined in more nested scope");
              }
            }
          }
        }
        var v4021 = ast$$91;
        var v26878 = symbol$$17.getType();
        v4021.type = v26878;
        var v13851 = symbol$$17.writeable();
        var v4024 = !v13851;
        if (v4024) {
          var v4022 = ast$$91.flags;
          var v19764 = TypeScript$$25.ASTFlags;
          var v13852 = v19764.Writeable;
          var v4023 = ~v13852;
          ast$$91.flags = v4022 & v4023;
        }
      } else {
        var v4030 = symbol$$17.isType();
        if (v4030) {
          var v4025 = ast$$91;
          var v26879 = symbol$$17.getType();
          v4025.type = v26879;
          var v4026 = ast$$91.flags;
          var v19765 = TypeScript$$25.ASTFlags;
          var v13853 = v19765.Writeable;
          var v4027 = ~v13853;
          ast$$91.flags = v4026 & v4027;
        } else {
          ast$$91.type = this.anyType;
          var v13854 = this.checker;
          var v4028 = v13854.errorReporter;
          var v4029 = symbol$$17.name;
          v4028.symbolDoesNotReferToAValue(ast$$91, v4029);
        }
      }
      return;
    }
    function v1025(ast$$90) {
      ast$$90.type = this.anyType;
      var illegalThisRef = false;
      var v13855 = this.thisFnc;
      var v4039 = v13855 == null;
      if (v4039) {
        var v4035 = this.thisType;
        if (v4035) {
          var v13856 = this.thisClassNode;
          if (v13856) {
            var v23556 = this.thisClassNode;
            var v19766 = v23556.nodeType;
            var v23557 = TypeScript$$25.NodeType;
            var v19767 = v23557.ClassDeclaration;
            v13856 = v19766 == v19767;
          }
          var v4032 = v13856;
          if (v4032) {
            illegalThisRef = true;
          } else {
            ast$$90.type = this.thisType;
          }
        } else {
          var v13857 = this.checker;
          var v4034 = v13857.currentModDecl;
          if (v4034) {
            var v13858 = this.checker;
            var v4033 = v13858.errorReporter;
            v4033.simpleError(ast$$90, "'this' may not be referenced within module bodies");
          }
        }
      } else {
        var v13859 = this.thisClassNode;
        if (v13859) {
          var v25370 = this.thisFnc;
          var v23558 = v25370.fncFlags;
          var v25371 = TypeScript$$25.FncFlags;
          var v23559 = v25371.IsPropertyBound;
          var v19768 = TypeScript$$25.hasFlag(v23558, v23559);
          var v23561 = !v19768;
          if (v23561) {
            var v23560 = this.inSuperCall;
            if (v23560) {
              var v26120 = this.thisClassNode;
              var v25372 = v26120.varFlags;
              var v26121 = TypeScript$$25.VarFlags;
              var v25373 = v26121.ClassSuperMustBeFirstCallInConstructor;
              v23560 = TypeScript$$25.hasFlag(v25372, v25373);
            }
            v19768 = v23560;
          }
          v13859 = v19768;
        }
        var v4036 = v13859;
        if (v4036) {
          illegalThisRef = true;
        }
        var v23562 = this.thisFnc;
        var v19769 = v23562.isMethod();
        var v23564 = !v19769;
        if (v23564) {
          var v23563 = this.thisFnc;
          v19769 = v23563.isConstructor;
        }
        var v13860 = v19769;
        var v19771 = !v13860;
        if (v19771) {
          var v19770 = this.thisFnc;
          v13860 = v19770.isTargetTypedAsMethod;
        }
        var v4038 = v13860;
        if (v4038) {
          var v13861 = this.thisType;
          if (v13861) {
            var v25374 = this.thisFnc;
            var v23565 = v25374.fncFlags;
            var v25375 = TypeScript$$25.FncFlags;
            var v23566 = v25375.Static;
            var v19772 = v23565 & v23566;
            v13861 = !v19772;
          }
          var v4037 = v13861;
          if (v4037) {
            ast$$90.type = this.thisType;
          }
        }
      }
      var v23567 = this.enclosingFncIsMethod;
      var v19773 = !v23567;
      if (v19773) {
        v19773 = this.thisFnc;
      }
      var v13862 = v19773;
      if (v13862) {
        var v23568 = this.thisFnc;
        var v19774 = v23568.fncFlags;
        var v23569 = TypeScript$$25.FncFlags;
        var v19775 = v23569.IsFatArrowFunction;
        v13862 = TypeScript$$25.hasFlag(v19774, v19775);
      }
      var v4055 = v13862;
      if (v4055) {
        var v13863 = this.thisFnc;
        var v4054 = v13863.boundToProperty;
        if (v4054) {
          var v19776 = this.thisFnc;
          var v13864 = v19776.boundToProperty;
          var v4040 = v13864.sym;
          var container$$17 = v4040.container;
          var v19777 = container$$17.declAST;
          var v13865 = v19777.nodeType;
          var v19778 = TypeScript$$25.NodeType;
          var v13866 = v19778.FuncDecl;
          var v4042 = v13865 == v13866;
          if (v4042) {
            var v4041 = container$$17.declAST;
            v4041.setHasSelfReference();
          }
        } else {
          var v4043 = this.thisFnc;
          var encFnc = v4043.enclosingFnc;
          var firstEncFnc = encFnc;
          for (;encFnc;) {
            var v13867 = this.thisClassNode;
            if (v13867) {
              var v19779 = encFnc.fncFlags;
              var v23570 = TypeScript$$25.FncFlags;
              var v19780 = v23570.IsPropertyBound;
              v13867 = TypeScript$$25.hasFlag(v19779, v19780);
            }
            var v4044 = v13867;
            if (v4044) {
              illegalThisRef = true;
            }
            var v23571 = encFnc.fncFlags;
            var v25376 = TypeScript$$25.FncFlags;
            var v23572 = v25376.IsFatArrowFunction;
            var v19781 = TypeScript$$25.hasFlag(v23571, v23572);
            var v13868 = !v19781;
            var v19782 = !v13868;
            if (v19782) {
              v13868 = encFnc.hasSelfReference();
            }
            var v4045 = v13868;
            if (v4045) {
              encFnc.setHasSelfReference();
              break;
            }
            encFnc = encFnc.enclosingFnc;
          }
          var v13869 = !encFnc;
          if (v13869) {
            v13869 = firstEncFnc;
          }
          var v4052 = v13869;
          if (v4052) {
            encFnc = firstEncFnc;
            encFnc.setHasSelfReference();
          } else {
            var v4051 = !encFnc;
            if (v4051) {
              var v4050 = this.thisClassNode;
              if (v4050) {
                var v4046 = this.thisClassNode;
                var v19783 = v4046.varFlags;
                var v23573 = TypeScript$$25.VarFlags;
                var v19784 = v23573.MustCaptureThis;
                v4046.varFlags = v19783 | v19784;
              } else {
                var v13870 = this.checker;
                var v4049 = v13870.currentModDecl;
                if (v4049) {
                  var v13871 = this.checker;
                  var v4047 = v13871.currentModDecl;
                  var v19785 = v4047.modFlags;
                  var v23574 = TypeScript$$25.ModuleFlags;
                  var v19786 = v23574.MustCaptureThis;
                  v4047.modFlags = v19785 | v19786;
                } else {
                  var v4048 = this.checker;
                  v4048.mustCaptureGlobalThis = true;
                }
              }
            }
          }
          var v23575 = encFnc;
          if (v23575) {
            var v25377 = encFnc.isMethod();
            var v26122 = !v25377;
            if (v26122) {
              v25377 = encFnc.isConstructor;
            }
            v23575 = v25377;
          }
          var v19787 = v23575;
          if (v19787) {
            v19787 = this.thisType;
          }
          var v13872 = v19787;
          if (v13872) {
            var v23576 = encFnc.fncFlags;
            var v25378 = TypeScript$$25.FncFlags;
            var v23577 = v25378.Static;
            var v19788 = TypeScript$$25.hasFlag(v23576, v23577);
            v13872 = !v19788;
          }
          var v4053 = v13872;
          if (v4053) {
            ast$$90.type = this.thisType;
          }
        }
      }
      if (illegalThisRef) {
        var v13873 = this.checker;
        var v4056 = v13873.errorReporter;
        v4056.simpleError(ast$$90, "Keyword 'this' cannot be referenced in initializers in a class body, or in super constructor calls");
      }
      return ast$$90;
    }
    function v1024(ast$$89) {
      var v19789 = this.thisType;
      if (v19789) {
        var v23578 = this.enclosingFncIsMethod;
        if (v23578) {
          var v26123 = this.thisFnc;
          var v25379 = v26123.isStatic();
          v23578 = !v25379;
        }
        v19789 = v23578;
      }
      var v13874 = v19789;
      if (v13874) {
        var v19790 = this.thisType;
        v13874 = v19790.baseClass();
      }
      var v4064 = v13874;
      if (v4064) {
        var v4057 = ast$$89;
        var v13875 = this.thisType;
        var v26880 = v13875.baseClass();
        v4057.type = v26880;
      } else {
        var v26124 = this.enclosingFncIsMethod;
        var v25380 = !v26124;
        if (v25380) {
          v25380 = this.thisType;
        }
        var v23579 = v25380;
        if (v23579) {
          var v25381 = this.thisType;
          v23579 = v25381.baseClass();
        }
        var v19791 = v23579;
        if (v19791) {
          v19791 = this.thisFnc;
        }
        var v13876 = v19791;
        if (v13876) {
          var v23580 = this.thisFnc;
          var v19792 = v23580.fncFlags;
          var v23581 = TypeScript$$25.FncFlags;
          var v19793 = v23581.IsFatArrowFunction;
          v13876 = TypeScript$$25.hasFlag(v19792, v19793);
        }
        var v4062 = v13876;
        if (v4062) {
          var v4058 = this.thisFnc;
          var enclosingFnc = v4058.enclosingFnc;
          var v13877 = enclosingFnc.fncFlags;
          var v19794 = TypeScript$$25.FncFlags;
          var v13878 = v19794.IsFatArrowFunction;
          var v4059 = TypeScript$$25.hasFlag(v13877, v13878);
          for (;v4059;) {
            enclosingFnc = enclosingFnc.enclosingFnc;
            var v13879 = enclosingFnc.fncFlags;
            var v19795 = TypeScript$$25.FncFlags;
            var v13880 = v19795.IsFatArrowFunction;
            v4059 = TypeScript$$25.hasFlag(v13879, v13880);
          }
          var v19796 = enclosingFnc;
          if (v19796) {
            var v23582 = enclosingFnc.isMethod();
            var v25382 = !v23582;
            if (v25382) {
              v23582 = enclosingFnc.isConstructor;
            }
            v19796 = v23582;
          }
          var v13881 = v19796;
          if (v13881) {
            var v19797 = enclosingFnc.isStatic();
            v13881 = !v19797;
          }
          var v4061 = v13881;
          if (v4061) {
            var v4060 = ast$$89;
            var v13882 = this.thisType;
            var v26881 = v13882.baseClass();
            v4060.type = v26881;
            enclosingFnc.setHasSuperReferenceInFatArrowFunction();
            return ast$$89;
          }
        }
        ast$$89.type = this.anyType;
        var v13883 = this.checker;
        var v4063 = v13883.errorReporter;
        v4063.invalidSuperReference(ast$$89);
      }
      return ast$$89;
    }
    function v1023(varDecl$$17, typeName$$2, isModuleName$$1) {
      var typestring = "";
      if (isModuleName$$1) {
        var quotestring = "";
        var v13884 = TypeScript$$25.isQuoted(typeName$$2);
        var v4065 = !v13884;
        if (v4065) {
          quotestring = "'";
        }
        var v13885 = " is using inaccessible module " + quotestring;
        var v4066 = v13885 + typeName$$2;
        typestring = v4066 + quotestring;
      } else {
        var v4067 = " has or is using private type '" + typeName$$2;
        typestring = v4067 + "'";
      }
      var v13886 = varDecl$$17.varFlags;
      var v19798 = TypeScript$$25.VarFlags;
      var v13887 = v19798.Public;
      var v4075 = TypeScript$$25.hasFlag(v13886, v13887);
      if (v4075) {
        var v25383 = varDecl$$17.sym;
        var v23583 = v25383.container;
        var v19799 = v23583.declAST;
        var v13888 = v19799.nodeType;
        var v19800 = TypeScript$$25.NodeType;
        var v13889 = v19800.InterfaceDeclaration;
        var v4072 = v13888 == v13889;
        if (v4072) {
          var v13890 = this.checker;
          var v4068 = v13890.errorReporter;
          var v25384 = varDecl$$17.sym;
          var v23584 = v25384.name;
          var v19801 = "property '" + v23584;
          var v13891 = v19801 + "' of exported interface";
          var v4069 = v13891 + typestring;
          v4068.simpleError(varDecl$$17, v4069);
        } else {
          var v13892 = this.checker;
          var v4070 = v13892.errorReporter;
          var v25385 = varDecl$$17.sym;
          var v23585 = v25385.name;
          var v19802 = "public member '" + v23585;
          var v13893 = v19802 + "' of exported class";
          var v4071 = v13893 + typestring;
          v4070.simpleError(varDecl$$17, v4071);
        }
      } else {
        var v13894 = this.checker;
        var v4073 = v13894.errorReporter;
        var v25386 = varDecl$$17.sym;
        var v23586 = v25386.name;
        var v19803 = "exported variable '" + v23586;
        var v13895 = v19803 + "'";
        var v4074 = v13895 + typestring;
        v4073.simpleError(varDecl$$17, v4074);
      }
      return;
    }
    function v1022(varDecl$$16) {
      function v1021(typeName$$1, isModuleName) {
        return _this$$6.varPrivacyErrorReporter(varDecl$$16, typeName$$1, isModuleName);
      }
      function v1020(ast$$88, parent$$65, walker$$49) {
        var v13896 = ast$$88;
        if (v13896) {
          var v19804 = ast$$88.nodeType;
          var v23587 = TypeScript$$25.NodeType;
          var v19805 = v23587.FuncDecl;
          v13896 = v19804 == v19805;
        }
        var v4078 = v13896;
        if (v4078) {
          var v13897 = ast$$88.fncFlags;
          var v19806 = TypeScript$$25.FncFlags;
          var v13898 = v19806.IsFatArrowFunction;
          var v4076 = TypeScript$$25.hasFlag(v13897, v13898);
          if (v4076) {
            var v13899 = ast$$88.fncFlags;
            var v19807 = TypeScript$$25.FncFlags;
            var v13900 = v19807.IsPropertyBound;
            ast$$88.fncFlags = v13899 | v13900;
          }
          var v4077 = walker$$49.options;
          v4077.goChildren = false;
        }
        return ast$$88;
      }
      var _this$$6 = this;
      var infSym = varDecl$$16.sym;
      var v4128 = infSym == null;
      if (v4128) {
        var v4083 = varDecl$$16.init;
        if (v4083) {
          var v4079 = varDecl$$16;
          var v13901 = varDecl$$16.init;
          var v26882 = this.typeCheck(v13901);
          v4079.init = v26882;
          var v4080 = varDecl$$16;
          var v13902 = this.checker;
          var v19808 = varDecl$$16.init;
          var v13903 = v19808.type;
          var v26883 = v13902.widenType(v13903);
          v4080.type = v26883;
        } else {
          var v19809 = this.checker;
          var v13904 = v19809.styleSettings;
          var v4082 = v13904.implicitAny;
          if (v4082) {
            var v13905 = this.checker;
            var v4081 = v13905.errorReporter;
            v4081.styleError(varDecl$$16, "type implicitly set to 'any'");
          }
          varDecl$$16.type = this.anyType;
        }
      } else {
        var v13906 = infSym.typeCheckStatus;
        var v19810 = TypeScript$$25.TypeCheckStatus;
        var v13907 = v19810.Started;
        var v4127 = v13906 == v13907;
        if (v4127) {
          var v19811 = this.checker;
          var v13908 = v19811.styleSettings;
          var v4085 = v13908.implicitAny;
          if (v4085) {
            var v13909 = this.checker;
            var v4084 = v13909.errorReporter;
            v4084.styleError(varDecl$$16, "type implicitly set to 'any'");
          }
          varDecl$$16.type = this.anyType;
          var v4086 = this.anyType;
          infSym.setType(v4086);
        } else {
          var v13910 = infSym.typeCheckStatus;
          var v19812 = TypeScript$$25.TypeCheckStatus;
          var v13911 = v19812.NotStarted;
          var v4126 = v13910 == v13911;
          if (v4126) {
            var v4087 = TypeScript$$25.TypeCheckStatus;
            infSym.typeCheckStatus = v4087.Started;
            var v4088 = this.checker;
            v4088.addStartedPTO(infSym);
            var resolved$$1 = false;
            var v13912 = varDecl$$16.type;
            var v4092 = v13912 == null;
            if (v4092) {
              var v4091 = varDecl$$16.typeExpr;
              if (v4091) {
                this.resolveBoundDecl(varDecl$$16);
                resolved$$1 = true;
                var v4089 = varDecl$$16.typeExpr;
                varDecl$$16.type = v4089.type;
                var v4090 = infSym;
                var v13913 = this.checker;
                var v26884 = v13913.getTypeCheckFinishedStatus();
                v4090.typeCheckStatus = v26884;
              }
            }
            var v4119 = varDecl$$16.init;
            if (v4119) {
              var v4093 = varDecl$$16.varFlags;
              var v13914 = TypeScript$$25.VarFlags;
              var v4094 = v13914.LocalStatic;
              var isLocalStatic = TypeScript$$25.hasFlag(v4093, v4094);
              var prevScope$$3 = this.scope;
              var v13915 = varDecl$$16.init;
              var v4095 = v13915.isParenthesized;
              var applyTargetType$$1 = !v4095;
              if (isLocalStatic) {
                var v19813 = varDecl$$16.sym;
                var v13916 = v19813.container;
                var v4096 = v13916.getType();
                this.scope = v4096.memberScope;
              }
              var v19814 = varDecl$$16.varFlags;
              var v23588 = TypeScript$$25.VarFlags;
              var v19815 = v23588.Property;
              var v13917 = TypeScript$$25.hasFlag(v19814, v19815);
              if (v13917) {
                v13917 = this.thisClassNode;
              }
              var v4099 = v13917;
              if (v4099) {
                var v4097 = TypeScript$$25.getAstWalkerFactory();
                var v4098 = varDecl$$16.init;
                v4097.walk(v4098, v1020);
              }
              var v4100 = this.checker;
              var v4101 = varDecl$$16.type;
              var v13918 = this.checker;
              var v4102 = v13918.inProvisionalTypecheckMode();
              var v4103 = varDecl$$16.init;
              v4100.typeCheckWithContextualType(v4101, v4102, applyTargetType$$1, v4103);
              this.scope = prevScope$$3;
              var v4116 = varDecl$$16.type;
              if (v4116) {
                var preserveScope = false;
                var preservedContainedScope = null;
                var v13919 = varDecl$$16.init;
                var v4108 = v13919.type;
                if (v4108) {
                  var v13920 = varDecl$$16.init;
                  var v4104 = v13920.type;
                  preservedContainedScope = v4104.containedScope;
                  preserveScope = true;
                  var v19816 = varDecl$$16.init;
                  var v13921 = v19816.type;
                  var v13922 = this.voidType;
                  var v4107 = v13921 == v13922;
                  if (v4107) {
                    var v13923 = this.checker;
                    var v4105 = v13923.errorReporter;
                    var v23589 = varDecl$$16.id;
                    var v19817 = v23589.actualText;
                    var v13924 = "Cannot assign type 'void' to variable '" + v19817;
                    var v4106 = v13924 + "'";
                    v4105.simpleError(varDecl$$16, v4106);
                  }
                }
                var v4109 = varDecl$$16;
                var v13925 = varDecl$$16.init;
                var v13926 = varDecl$$16.type;
                var v19818 = applyTargetType$$1;
                if (v19818) {
                  var v25387 = this.checker;
                  var v23590 = v25387.inProvisionalTypecheckMode();
                  v19818 = !v23590;
                }
                var v13927 = v19818;
                var v26885 = this.castWithCoercion(v13925, v13926, v13927, false);
                v4109.init = v26885;
                var v13928 = preserveScope;
                if (v13928) {
                  var v25388 = varDecl$$16.init;
                  var v23591 = v25388.type;
                  var v19819 = v23591.containedScope;
                  v13928 = v19819 == null;
                }
                var v4111 = v13928;
                if (v4111) {
                  var v13929 = varDecl$$16.init;
                  var v4110 = v13929.type;
                  v4110.containedScope = preservedContainedScope;
                }
              } else {
                var v4112 = varDecl$$16;
                var v13930 = this.checker;
                var v19820 = varDecl$$16.init;
                var v13931 = v19820.type;
                var v26886 = v13930.widenType(v13931);
                v4112.type = v26886;
                var v13932 = varDecl$$16.type;
                var v13933 = this.voidType;
                var v4115 = v13932 == v13933;
                if (v4115) {
                  var v13934 = this.checker;
                  var v4113 = v13934.errorReporter;
                  var v23592 = varDecl$$16.id;
                  var v19821 = v23592.actualText;
                  var v13935 = "Cannot assign type 'void' to variable '" + v19821;
                  var v4114 = v13935 + "'";
                  v4113.simpleError(varDecl$$16, v4114);
                  varDecl$$16.type = this.anyType;
                }
              }
              var v4117 = varDecl$$16.type;
              infSym.setType(v4117);
            } else {
              var v4118 = !resolved$$1;
              if (v4118) {
                this.resolveBoundDecl(varDecl$$16);
              }
            }
            var v4120 = infSym;
            var v13936 = this.checker;
            var v26887 = v13936.getTypeCheckFinishedStatus();
            v4120.typeCheckStatus = v26887;
          } else {
            var v19822 = this.checker;
            var v19823 = infSym.typeCheckStatus;
            var v13937 = v19822.typeStatusIsFinished(v19823);
            if (v13937) {
              var v19824 = infSym.declAST;
              v13937 = v19824 != varDecl$$16;
            }
            var v4125 = v13937;
            if (v4125) {
              var v4124 = varDecl$$16.init;
              if (v4124) {
                var v4121 = varDecl$$16;
                var v13938 = varDecl$$16.init;
                var v26888 = this.typeCheck(v13938);
                v4121.init = v26888;
                var v4122 = varDecl$$16;
                var v26889 = infSym.getType();
                v4122.type = v26889;
                var v4123 = varDecl$$16;
                var v13939 = varDecl$$16.init;
                var v13940 = varDecl$$16.type;
                var v26890 = this.cast(v13939, v13940);
                v4123.init = v26890;
              }
            }
          }
        }
      }
      var v13941 = varDecl$$16.id;
      if (v13941) {
        v13941 = varDecl$$16.sym;
      }
      var v4130 = v13941;
      if (v4130) {
        var v4129 = varDecl$$16.id;
        v4129.sym = varDecl$$16.sym;
      }
      var v13942 = varDecl$$16.sym;
      if (v13942) {
        var v19825 = varDecl$$16.sym;
        v13942 = v19825.container;
      }
      var v4133 = v13942;
      if (v4133) {
        var v13943 = varDecl$$16.sym;
        var v4131 = v13943.getType();
        var v4132 = varDecl$$16.sym;
        this.checkTypePrivacy(v4131, v4132, v1021);
      }
      return varDecl$$16;
    }
    function v1019(varDecl$$15) {
      var v4150 = varDecl$$15.typeExpr;
      if (v4150) {
        var v26125 = varDecl$$15.typeExpr;
        var v25389 = v26125.type;
        var v23593 = v25389 == null;
        var v25391 = !v23593;
        if (v25391) {
          var v26444 = varDecl$$15.typeExpr;
          var v26126 = v26444.type;
          if (v26126) {
            var v26607 = varDecl$$15.typeExpr;
            var v26445 = v26607.type;
            var v26446 = this.anyType;
            v26126 = v26445 == v26446;
          }
          var v25390 = v26126;
          if (v25390) {
            v25390 = this.scope;
          }
          v23593 = v25390;
        }
        var v19826 = v23593;
        var v23595 = !v19826;
        if (v23595) {
          var v26127 = varDecl$$15.typeExpr;
          var v25392 = v26127.type;
          var v23594 = v25392.symbol;
          v19826 = v23594 == null;
        }
        var v13944 = v19826;
        var v19828 = !v13944;
        if (v19828) {
          var v23596 = this.checker;
          var v26447 = varDecl$$15.typeExpr;
          var v26128 = v26447.type;
          var v25393 = v26128.symbol;
          var v23597 = v25393.typeCheckStatus;
          var v19827 = v23596.typeStatusIsFinished(v23597);
          v13944 = !v19827;
        }
        var v4135 = v13944;
        if (v4135) {
          var v4134 = varDecl$$15.typeExpr;
          this.typeCheck(v4134);
        }
        var v4136 = varDecl$$15.typeExpr;
        varDecl$$15.type = v4136.type;
        var v4139 = varDecl$$15.sym;
        if (v4139) {
          var v4137 = varDecl$$15.sym;
          var v4138 = varDecl$$15.type;
          v4137.setType(v4138);
        }
      } else {
        var v13945 = varDecl$$15.init;
        var v4149 = v13945 == null;
        if (v4149) {
          var v19829 = this.checker;
          var v13946 = v19829.styleSettings;
          var v4141 = v13946.implicitAny;
          if (v4141) {
            var v13947 = this.checker;
            var v4140 = v13947.errorReporter;
            v4140.styleError(varDecl$$15, "type implicitly set to 'any'");
          }
          varDecl$$15.type = this.anyType;
          var v4148 = varDecl$$15.sym;
          if (v4148) {
            var v13948 = varDecl$$15.sym;
            var v4145 = v13948.isType();
            if (v4145) {
              var tsym$$1 = varDecl$$15.sym;
              var v4144 = tsym$$1.isMethod;
              if (v4144) {
                var v13949 = this.checker;
                var v4142 = v13949.errorReporter;
                v4142.simpleError(varDecl$$15, "Cannot bind method group to variable.  (Did you mean to use 'declare function' instead of 'declare var'?)");
                return;
              } else {
                var v13950 = this.checker;
                var v4143 = v13950.errorReporter;
                v4143.simpleError(varDecl$$15, "Cannot bind type to variable");
                return;
              }
            }
            var v4146 = varDecl$$15.sym;
            var v4147 = varDecl$$15.type;
            v4146.setType(v4147);
          }
        }
      }
      return;
    }
    function v1018(varDecl$$14) {
      var sym$$34 = varDecl$$14.sym;
      var svThisFnc$$1 = this.thisFnc;
      var svThisType$$1 = this.thisType;
      var prevMethodStatus$$1 = this.enclosingFncIsMethod;
      var v4151 = this.checker;
      var prevLocationInfo$$1 = v4151.locationInfo;
      var v13951 = sym$$34;
      if (v13951) {
        v13951 = sym$$34.container;
      }
      var v4161 = v13951;
      if (v4161) {
        var v4152;
        var v19830 = varDecl$$14.varFlags;
        var v23598 = TypeScript$$25.VarFlags;
        var v19831 = v23598.ClassConstructorProperty;
        var v13954 = TypeScript$$25.hasFlag(v19830, v19831);
        if (v13954) {
          var v19832 = sym$$34.container;
          var v13952 = v19832.getType();
          v4152 = v13952.constructorScope;
        } else {
          var v13953 = sym$$34.container;
          v4152 = v13953.instanceScope();
        }
        var instanceScope = v4152;
        var v19833 = varDecl$$14.varFlags;
        var v23599 = TypeScript$$25.VarFlags;
        var v19834 = v23599.Property;
        var v13955 = TypeScript$$25.hasFlag(v19833, v19834);
        if (v13955) {
          var v25394 = sym$$34.container;
          var v23600 = v25394.declAST;
          var v19835 = v23600.nodeType;
          var v23601 = TypeScript$$25.NodeType;
          var v19836 = v23601.FuncDecl;
          v13955 = v19835 == v19836;
        }
        var v4154 = v13955;
        if (v4154) {
          var v4153 = sym$$34.container;
          this.thisFnc = v4153.declAST;
        }
        if (instanceScope) {
          var prevScope$$2 = this.scope;
          this.scope = instanceScope;
          var container$$16 = sym$$34.container;
          var v23602 = this.checker;
          var v19837 = v23602.units;
          if (v19837) {
            var v23603 = sym$$34.unitIndex;
            v19837 = v23603 >= 0;
          }
          var v13956 = v19837;
          if (v13956) {
            var v19838 = sym$$34.unitIndex;
            var v25395 = this.checker;
            var v23604 = v25395.units;
            var v19839 = v23604.length;
            v13956 = v19838 < v19839;
          }
          var v4157 = v13956;
          if (v4157) {
            var v4155 = this.checker;
            var v19840 = this.checker;
            var v13957 = v19840.units;
            var v13958 = sym$$34.unitIndex;
            v4155.locationInfo = v13957[v13958];
          } else {
            var v4156 = this.checker;
            v4156.locationInfo = TypeScript$$25.unknownLocationInfo;
          }
          for (;container$$16;) {
            var v13959 = container$$16.kind();
            var v19841 = TypeScript$$25.SymbolKind;
            var v13960 = v19841.Type;
            var v4160 = v13959 == v13960;
            if (v4160) {
              var typeSym$$3 = container$$16;
              var type$$49 = typeSym$$3.type;
              var v4158 = type$$49.call;
              if (v4158) {
                this.enclosingFncIsMethod = typeSym$$3.isMethod;
              }
              var v4159 = type$$49.isClass();
              if (v4159) {
                this.thisType = type$$49.instanceType;
                break;
              }
            }
            container$$16 = container$$16.container;
          }
          this.typeCheckBoundDecl(varDecl$$14);
          this.scope = prevScope$$2;
        }
      }
      this.thisFnc = svThisFnc$$1;
      this.thisType = svThisType$$1;
      var v4162 = this.checker;
      v4162.locationInfo = prevLocationInfo$$1;
      this.enclosingFncIsMethod = prevMethodStatus$$1;
      return;
    }
    function v1017(ast$$87) {
      var v19842 = ast$$87.nodeType;
      var v23605 = TypeScript$$25.NodeType;
      var v19843 = v23605.VarDecl;
      var v13961 = v19842 == v19843;
      var v19846 = !v13961;
      if (v19846) {
        var v19844 = ast$$87.nodeType;
        var v23606 = TypeScript$$25.NodeType;
        var v19845 = v23606.ArgDecl;
        v13961 = v19844 == v19845;
      }
      var v4165 = v13961;
      if (v4165) {
        this.inScopeTypeCheckBoundDecl(ast$$87);
      } else {
        var v13962 = ast$$87.nodeType;
        var v19847 = TypeScript$$25.NodeType;
        var v13963 = v19847.FuncDecl;
        var v4164 = v13962 == v13963;
        if (v4164) {
          var funcDecl$$23 = ast$$87;
          var v4163 = funcDecl$$23.isAccessor();
          if (v4163) {
            this.typeCheckFunction(funcDecl$$23);
          }
        }
      }
      return;
    }
    function v1016(ast$$86) {
      if (ast$$86) {
        return ast$$86.typeCheck(this);
      } else {
        return null;
      }
      return;
    }
    function v1015(ast$$85, enclosingScope) {
      var prevScope$$1 = this.scope;
      this.scope = enclosingScope;
      var svThisFnc = this.thisFnc;
      var svThisType = this.thisType;
      var svThisClassNode = this.thisClassNode;
      var v4166 = this.checker;
      var svCurrentModDecl = v4166.currentModDecl;
      var prevMethodStatus = this.enclosingFncIsMethod;
      var v4167 = this.scope;
      var container$$15 = v4167.container;
      var fnc$$1 = null;
      for (;container$$15;) {
        var v13964 = container$$15.kind();
        var v19848 = TypeScript$$25.SymbolKind;
        var v13965 = v19848.Type;
        var v4174 = v13964 == v13965;
        if (v4174) {
          var typeSym$$2 = container$$15;
          var type$$48 = typeSym$$2.type;
          var v4169 = type$$48.call;
          if (v4169) {
            var v4168 = fnc$$1 == null;
            if (v4168) {
              this.enclosingFncIsMethod = typeSym$$2.isMethod;
              fnc$$1 = container$$15.declAST;
            }
          }
          var v4171 = type$$48.isClass();
          if (v4171) {
            this.thisType = type$$48.instanceType;
            var v13966 = typeSym$$2.declAST;
            if (v13966) {
              var v23607 = typeSym$$2.declAST;
              var v19849 = v23607.nodeType;
              var v23608 = TypeScript$$25.NodeType;
              var v19850 = v23608.ClassDeclaration;
              v13966 = v19849 == v19850;
            }
            var v4170 = v13966;
            if (v4170) {
              this.thisClassNode = typeSym$$2.declAST;
            }
            break;
          }
          var v4173 = type$$48.isModuleType();
          if (v4173) {
            var v4172 = this.checker;
            v4172.currentModDecl = typeSym$$2.declAST;
            break;
          }
        }
        container$$15 = container$$15.container;
      }
      this.thisFnc = fnc$$1;
      var updated = this.typeCheck(ast$$85);
      this.thisFnc = svThisFnc;
      this.thisType = svThisType;
      this.thisClassNode = svThisClassNode;
      var v4175 = this.checker;
      v4175.currentModDecl = svCurrentModDecl;
      this.enclosingFncIsMethod = prevMethodStatus;
      this.scope = prevScope$$1;
      return updated;
    }
    function v1014(ast$$84, type$$47, applyCoercion, typeAssertion) {
      var v4176 = TypeScript$$25.TypeComparisonInfo;
      var comparisonInfo$$12 = new v4176;
      var v19851 = this.checker;
      var v19852 = ast$$84.type;
      var v13967 = v19851.sourceIsAssignableToTarget(v19852, type$$47, comparisonInfo$$12);
      var v19854 = !v13967;
      if (v19854) {
        var v19853 = typeAssertion;
        if (v19853) {
          var v23609 = this.checker;
          var v23610 = ast$$84.type;
          v19853 = v23609.sourceIsAssignableToTarget(type$$47, v23610, comparisonInfo$$12);
        }
        v13967 = v19853;
      }
      var v4182 = v13967;
      if (v4182) {
        if (applyCoercion) {
          var v4178 = type$$47 == null;
          if (v4178) {
            ast$$84.type = this.anyType;
          } else {
            var v4177 = type$$47.isClass();
            if (v4177) {
              ast$$84.type = type$$47.instanceType;
            } else {
              ast$$84.type = type$$47;
            }
          }
        }
        return ast$$84;
      } else {
        var v13968 = this.checker;
        var v4179 = v13968.errorReporter;
        var v4180 = ast$$84.type;
        var v4181 = this.scope;
        v4179.incompatibleTypes(ast$$84, v4180, type$$47, null, v4181, comparisonInfo$$12);
        return ast$$84;
      }
      return;
    }
    function v1013(ast$$83, type$$46) {
      return this.castWithCoercion(ast$$83, type$$46, true, false);
    }
    function v1012() {
      var v4183 = this.globalScope;
      var arraySym = v4183.find("Array", false, true);
      var v13969 = arraySym;
      if (v13969) {
        var v19855 = arraySym.kind();
        var v23611 = TypeScript$$25.SymbolKind;
        var v19856 = v23611.Type;
        v13969 = v19855 == v19856;
      }
      var v4184 = v13969;
      if (v4184) {
        this.arrayInterfaceType = arraySym.type;
      }
      var v4185 = this.globalScope;
      var stringSym = v4185.find("String", false, true);
      var v13970 = stringSym;
      if (v13970) {
        var v19857 = stringSym.kind();
        var v23612 = TypeScript$$25.SymbolKind;
        var v19858 = v23612.Type;
        v13970 = v19857 == v19858;
      }
      var v4186 = v13970;
      if (v4186) {
        this.stringInterfaceType = stringSym.type;
      }
      var v4187 = this.globalScope;
      var objectSym = v4187.find("Object", false, true);
      var v13971 = objectSym;
      if (v13971) {
        var v19859 = objectSym.kind();
        var v23613 = TypeScript$$25.SymbolKind;
        var v19860 = v23613.Type;
        v13971 = v19859 == v19860;
      }
      var v4188 = v13971;
      if (v4188) {
        this.objectInterfaceType = objectSym.type;
      }
      var v4189 = this.globalScope;
      var fnSym = v4189.find("Function", false, true);
      var v13972 = fnSym;
      if (v13972) {
        var v19861 = fnSym.kind();
        var v23614 = TypeScript$$25.SymbolKind;
        var v19862 = v23614.Type;
        v13972 = v19861 == v19862;
      }
      var v4190 = v13972;
      if (v4190) {
        this.functionInterfaceType = fnSym.type;
      }
      var v4191 = this.globalScope;
      var numberSym = v4191.find("Number", false, true);
      var v13973 = numberSym;
      if (v13973) {
        var v19863 = numberSym.kind();
        var v23615 = TypeScript$$25.SymbolKind;
        var v19864 = v23615.Type;
        v13973 = v19863 == v19864;
      }
      var v4192 = v13973;
      if (v4192) {
        this.numberInterfaceType = numberSym.type;
      }
      var v4193 = this.globalScope;
      var booleanSym = v4193.find("Boolean", false, true);
      var v13974 = booleanSym;
      if (v13974) {
        var v19865 = booleanSym.kind();
        var v23616 = TypeScript$$25.SymbolKind;
        var v19866 = v23616.Type;
        v13974 = v19865 == v19866;
      }
      var v4194 = v13974;
      if (v4194) {
        this.booleanInterfaceType = booleanSym.type;
      }
      var v4195 = this.globalScope;
      var regexSym = v4195.find("RegExp", false, true);
      var v13975 = regexSym;
      if (v13975) {
        var v19867 = regexSym.kind();
        var v23617 = TypeScript$$25.SymbolKind;
        var v19868 = v23617.Type;
        v13975 = v19867 == v19868;
      }
      var v4196 = v13975;
      if (v4196) {
        this.regexType = regexSym.type;
      }
      return;
    }
    function TypeFlow$$1(logger$$4, initScope, parser$$2, checker$$17) {
      this.logger = logger$$4;
      this.initScope = initScope;
      this.parser = parser$$2;
      this.checker = checker$$17;
      this.thisFnc = null;
      this.thisClassNode = null;
      this.enclosingFncIsMethod = false;
      this.arrayInterfaceType = null;
      this.stringInterfaceType = null;
      this.objectInterfaceType = null;
      this.functionInterfaceType = null;
      this.numberInterfaceType = null;
      this.booleanInterfaceType = null;
      this.iargumentsInterfaceType = null;
      this.currentScript = null;
      this.inImportTypeCheck = false;
      this.inTypeRefTypeCheck = false;
      this.inArrayElementTypeCheck = false;
      var v26891 = new ResolutionDataCache;
      this.resolutionDataCache = v26891;
      this.nestingLevel = 0;
      this.inSuperCall = false;
      var v4197 = this.checker;
      v4197.typeFlow = this;
      this.scope = this.initScope;
      this.globalScope = this.initScope;
      var v4198 = this.checker;
      this.doubleType = v4198.numberType;
      var v4199 = this.checker;
      this.booleanType = v4199.booleanType;
      var v4200 = this.checker;
      this.stringType = v4200.stringType;
      var v4201 = this.checker;
      this.anyType = v4201.anyType;
      this.regexType = this.anyType;
      var v4202 = this.checker;
      this.nullType = v4202.nullType;
      var v4203 = this.checker;
      this.voidType = v4203.voidType;
      var v4204 = this.checker;
      var v4205 = this.anyType;
      var v26892 = v4204.makeArrayType(v4205);
      this.arrayAnyType = v26892;
      return;
    }
    var v4206 = TypeFlow$$1.prototype;
    v4206.initLibs = v1012;
    var v4207 = TypeFlow$$1.prototype;
    v4207.cast = v1013;
    var v4208 = TypeFlow$$1.prototype;
    v4208.castWithCoercion = v1014;
    var v4209 = TypeFlow$$1.prototype;
    v4209.inScopeTypeCheck = v1015;
    var v4210 = TypeFlow$$1.prototype;
    v4210.typeCheck = v1016;
    var v4211 = TypeFlow$$1.prototype;
    v4211.inScopeTypeCheckDecl = v1017;
    var v4212 = TypeFlow$$1.prototype;
    v4212.inScopeTypeCheckBoundDecl = v1018;
    var v4213 = TypeFlow$$1.prototype;
    v4213.resolveBoundDecl = v1019;
    var v4214 = TypeFlow$$1.prototype;
    v4214.typeCheckBoundDecl = v1022;
    var v4215 = TypeFlow$$1.prototype;
    v4215.varPrivacyErrorReporter = v1023;
    var v4216 = TypeFlow$$1.prototype;
    v4216.typeCheckSuper = v1024;
    var v4217 = TypeFlow$$1.prototype;
    v4217.typeCheckThis = v1025;
    var v4218 = TypeFlow$$1.prototype;
    v4218.setTypeFromSymbol = v1026;
    var v4219 = TypeFlow$$1.prototype;
    v4219.typeCheckName = v1028;
    var v4220 = TypeFlow$$1.prototype;
    v4220.typeCheckScript = v1029;
    var v4221 = TypeFlow$$1.prototype;
    v4221.typeCheckBitNot = v1030;
    var v4222 = TypeFlow$$1.prototype;
    v4222.typeCheckUnaryNumberOperator = v1031;
    var v4223 = TypeFlow$$1.prototype;
    v4223.typeCheckLogNot = v1032;
    var v4224 = TypeFlow$$1.prototype;
    v4224.astIsWriteable = v1033;
    var v4225 = TypeFlow$$1.prototype;
    v4225.typeCheckIncOrDec = v1034;
    var v4226 = TypeFlow$$1.prototype;
    v4226.typeCheckBitwiseOperator = v1035;
    var v4227 = TypeFlow$$1.prototype;
    v4227.typeCheckArithmeticOperator = v1036;
    var v4228 = TypeFlow$$1.prototype;
    v4228.typeCheckDotOperator = v1037;
    var v4229 = TypeFlow$$1.prototype;
    v4229.typeCheckBooleanOperator = v1038;
    var v4230 = TypeFlow$$1.prototype;
    v4230.typeCheckAsgOperator = v1039;
    var v4231 = TypeFlow$$1.prototype;
    v4231.typeCheckIndex = v1040;
    var v4232 = TypeFlow$$1.prototype;
    v4232.typeCheckInOperator = v1041;
    var v4233 = TypeFlow$$1.prototype;
    v4233.typeCheckShift = v1042;
    var v4234 = TypeFlow$$1.prototype;
    v4234.typeCheckQMark = v1043;
    var v4235 = TypeFlow$$1.prototype;
    v4235.addFormals = v1044;
    var v4236 = TypeFlow$$1.prototype;
    v4236.addLocalsFromScope = v1045;
    var v4237 = TypeFlow$$1.prototype;
    v4237.addConstructorLocalArgs = v1046;
    var v4238 = TypeFlow$$1.prototype;
    v4238.checkInitSelf = v1047;
    var v4239 = TypeFlow$$1.prototype;
    v4239.checkPromoteFreeVars = v1048;
    var v4240 = TypeFlow$$1.prototype;
    v4240.allReturnsAreVoid = v1050;
    var v4241 = TypeFlow$$1.prototype;
    v4241.classConstructorHasSuperCall = v1051;
    var v4242 = TypeFlow$$1.prototype;
    v4242.baseListPrivacyErrorReporter = v1052;
    var v4243 = TypeFlow$$1.prototype;
    v4243.typeCheckBaseListPrivacy = v1054;
    var v4244 = TypeFlow$$1.prototype;
    v4244.checkSymbolPrivacy = v1055;
    var v4245 = TypeFlow$$1.prototype;
    v4245.checkTypePrivacy = v1057;
    var v4246 = TypeFlow$$1.prototype;
    v4246.checkSignatureGroupPrivacy = v1058;
    var v4247 = TypeFlow$$1.prototype;
    v4247.functionArgumentPrivacyErrorReporter = v1059;
    var v4248 = TypeFlow$$1.prototype;
    v4248.returnTypePrivacyError = v1060;
    var v4249 = TypeFlow$$1.prototype;
    v4249.functionReturnTypePrivacyErrorReporter = v1061;
    var v4250 = TypeFlow$$1.prototype;
    v4250.typeCheckFunction = v1069;
    var v4251 = TypeFlow$$1.prototype;
    v4251.typeCheckBases = v1070;
    var v4252 = TypeFlow$$1.prototype;
    v4252.checkMembersImplementInterfaces = v1071;
    var v4253 = TypeFlow$$1.prototype;
    v4253.typeCheckBaseCalls = v1072;
    var v4254 = TypeFlow$$1.prototype;
    v4254.assertUniqueNamesInBaseTypes = v1074;
    var v4255 = TypeFlow$$1.prototype;
    v4255.checkBaseTypeMemberInheritance = v1076;
    var v4256 = TypeFlow$$1.prototype;
    v4256.typeCheckClass = v1077;
    var v4257 = TypeFlow$$1.prototype;
    v4257.typeCheckOverloadSignatures = v1078;
    var v4258 = TypeFlow$$1.prototype;
    v4258.typeCheckInterface = v1079;
    var v4259 = TypeFlow$$1.prototype;
    v4259.typeCheckImportDecl = v1080;
    var v4260 = TypeFlow$$1.prototype;
    v4260.typeCheckModule = v1081;
    var v4261 = TypeFlow$$1.prototype;
    v4261.typeCheckFor = v1082;
    var v4262 = TypeFlow$$1.prototype;
    v4262.typeCheckWith = v1083;
    var v4263 = TypeFlow$$1.prototype;
    v4263.typeCheckForIn = v1084;
    var v4264 = TypeFlow$$1.prototype;
    v4264.typeCheckWhile = v1085;
    var v4265 = TypeFlow$$1.prototype;
    v4265.typeCheckDoWhile = v1086;
    var v4266 = TypeFlow$$1.prototype;
    v4266.typeCheckCondExpr = v1087;
    var v4267 = TypeFlow$$1.prototype;
    v4267.typeCheckCompoundStmtBlock = v1088;
    var v4268 = TypeFlow$$1.prototype;
    v4268.typeCheckIf = v1089;
    var v4269 = TypeFlow$$1.prototype;
    v4269.typeFromAccessorFuncDecl = v1090;
    var v4270 = TypeFlow$$1.prototype;
    v4270.typeCheckObjectLit = v1091;
    var v4271 = TypeFlow$$1.prototype;
    v4271.typeCheckArrayLit = v1095;
    var v4272 = TypeFlow$$1.prototype;
    v4272.checkForVoidConstructor = v1096;
    var v4273 = TypeFlow$$1.prototype;
    v4273.typeCheckReturn = v1097;
    var v4274 = TypeFlow$$1.prototype;
    v4274.typeCheckInstOf = v1098;
    var v4275 = TypeFlow$$1.prototype;
    v4275.typeCheckCommaOperator = v1099;
    var v4276 = TypeFlow$$1.prototype;
    v4276.typeCheckLogOr = v1100;
    var v4277 = TypeFlow$$1.prototype;
    v4277.typeCheckLogAnd = v1101;
    var v4278 = TypeFlow$$1.prototype;
    v4278.tryAddCandidates = v1102;
    var v4279 = TypeFlow$$1.prototype;
    v4279.resolveOverload = v1103;
    var v4280 = TypeFlow$$1.prototype;
    v4280.typeCheckNew = v1104;
    var v4281 = TypeFlow$$1.prototype;
    v4281.preTypeCheckCallArgs = v1105;
    var v4282 = TypeFlow$$1.prototype;
    v4282.postTypeCheckCallArgs = v1106;
    var v4283 = TypeFlow$$1.prototype;
    v4283.typeCheckCall = v1107;
    var v4284 = TypeFlow$$1.prototype;
    v4284.assignScopes = v1108;
    var v4285 = TypeFlow$$1.prototype;
    v4285.findMemberScope = v1109;
    var v4286 = TypeFlow$$1.prototype;
    v4286.findMemberScopeAt = v1110;
    var v4287 = TypeFlow$$1.prototype;
    v4287.findMemberScopeAtFullAst = v1111;
    return TypeFlow$$1;
  }
  function v1011() {
    function v1010(rd$$1) {
      var v4288 = rd$$1.actuals;
      v4288.length = 0;
      var v4289 = rd$$1.exactCandidates;
      v4289.length = 0;
      var v4290 = rd$$1.conversionCandidates;
      v4290.length = 0;
      this.nextUp = rd$$1.id;
      return;
    }
    function v1009() {
      var rd = null;
      var v13976 = this.nextUp;
      var v13977 = this.cacheSize;
      var v4293 = v13976 < v13977;
      if (v4293) {
        var v4291 = this.rdCache;
        var v4292 = this.nextUp;
        rd = v4291[v4292];
      }
      var v4300 = rd == null;
      if (v4300) {
        var v13978 = this.cacheSize;
        this.cacheSize = v13978 + 1;
        var v4294 = new Array;
        var v4295 = new Array;
        var v4296 = new Array;
        var v4297 = this.cacheSize;
        rd = {actuals:v4294, exactCandidates:v4295, conversionCandidates:v4296, id:v4297};
        var v4298 = this.rdCache;
        var v4299 = this.cacheSize;
        v4298[v4299] = rd;
      }
      var v13979 = this.nextUp;
      this.nextUp = v13979 + 1;
      return rd;
    }
    function ResolutionDataCache$$1() {
      this.cacheSize = 16;
      this.rdCache = [];
      this.nextUp = 0;
      var i$$92 = 0;
      var v13980 = this.cacheSize;
      var v4303 = i$$92 < v13980;
      for (;v4303;) {
        var v4301 = this.rdCache;
        var v4302 = i$$92;
        var v13981 = new Array;
        var v13982 = new Array;
        var v13983 = new Array;
        v4301[v4302] = {actuals:v13981, exactCandidates:v13982, conversionCandidates:v13983, id:i$$92};
        i$$92 = i$$92 + 1;
        var v13984 = this.cacheSize;
        v4303 = i$$92 < v13984;
      }
      return;
    }
    var v4304 = ResolutionDataCache$$1.prototype;
    v4304.getResolutionData = v1009;
    var v4305 = ResolutionDataCache$$1.prototype;
    v4305.returnResolutionData = v1010;
    return ResolutionDataCache$$1;
  }
  function v1008() {
    function v1007(ast$$82) {
      var v4307 = this.current;
      if (v4307) {
        var v13985 = this.current;
        var v4306 = v13985.content;
        v4306.append(ast$$82);
      }
      return;
    }
    function v1006(target$$34, isContinue) {
      var targetBB = null;
      var i$$91 = 0;
      var v4308 = this.statementStack;
      var len$$41 = v4308.length;
      var v4311 = i$$91 < len$$41;
      for (;v4311;) {
        var v4309 = this.statementStack;
        var targetInfo$$5 = v4309[i$$91];
        var v13986 = targetInfo$$5.stmt;
        var v4310 = v13986 == target$$34;
        if (v4310) {
          if (isContinue) {
            targetBB = targetInfo$$5.continueBB;
          } else {
            targetBB = targetInfo$$5.breakBB;
          }
          break;
        }
        i$$91 = i$$91 + 1;
        v4311 = i$$91 < len$$41;
      }
      if (targetBB) {
        var v4312 = this.current;
        v4312.addSuccessor(targetBB);
      }
      this.setUnreachable();
      return;
    }
    function v1005(ast$$81) {
      var v13987 = this.unreachable;
      var v4313 = v13987 === null;
      if (v4313) {
        var v26893 = new Array;
        this.unreachable = v26893;
      }
      var v4314 = this.unreachable;
      var v13988 = this.unreachable;
      var v4315 = v13988.length;
      v4314[v4315] = ast$$81;
      return;
    }
    function v1004() {
      this.current = null;
      this.noContinuation = true;
      return;
    }
    function v1003() {
      var v4316 = this.current;
      var v4317 = this.exit;
      v4316.addSuccessor(v4317);
      this.setUnreachable();
      return;
    }
    function v1002() {
      var v4318 = this.statementStack;
      return v4318.pop();
    }
    function v1001(stmt$$5, continueBB, breakBB) {
      var v4319 = this.statementStack;
      var v4320 = {stmt:stmt$$5, continueBB:continueBB, breakBB:breakBB};
      v4319.push(v4320);
      return;
    }
    function v1000(outfile$$14) {
      function node$$3(bb$$6) {
        var v13989 = bb$$6.index;
        var v4321 = v13989 < 0;
        if (v4321) {
          bb$$6.index = index$$56;
          index$$56 = index$$56 + 1;
        }
        var v13990 = _this$$5.exit;
        var v4324 = bb$$6 == v13990;
        if (v4324) {
          var v13991 = bb$$6.index;
          var v4322 = "Exit block with index " + v13991;
          outfile$$14.WriteLine(v4322);
        } else {
          var v13992 = bb$$6.index;
          var v4323 = "Basic block with index " + v13992;
          outfile$$14.WriteLine(v4323);
          _this$$5.printBlockContent(bb$$6, outfile$$14);
        }
        return;
      }
      function preEdges$$1() {
        outfile$$14.Write("  Branches to ");
        return;
      }
      function postEdges$$1() {
        outfile$$14.WriteLine("");
        return;
      }
      function edge(node1, node2) {
        var v13993 = node2.index;
        var v4325 = v13993 < 0;
        if (v4325) {
          node2.index = index$$56;
          index$$56 = index$$56 + 1;
        }
        var v13994 = node2.index;
        var v4326 = v13994 + " ";
        outfile$$14.Write(v4326);
        return;
      }
      var _this$$5 = this;
      var index$$56 = 0;
      this.bfs(node$$3, edge, preEdges$$1, postEdges$$1);
      var v13995 = this.unreachable;
      var v4330 = v13995 != null;
      if (v4330) {
        var i$$90 = 0;
        var v4327 = this.unreachable;
        var len$$40 = v4327.length;
        var v4329 = i$$90 < len$$40;
        for (;v4329;) {
          outfile$$14.WriteLine("Unreachable basic block ...");
          var v13996 = this.unreachable;
          var v4328 = v13996[i$$90];
          this.printAST(v4328, outfile$$14);
          i$$90 = i$$90 + 1;
          v4329 = i$$90 < len$$40;
        }
      }
      return;
    }
    function v999(er$$1, funcSym) {
      function v998(index$$55) {
        var v4331 = useDefContext$$3.uses;
        var ast$$80 = v4331[index$$55];
        var v19869 = ast$$80.actualText;
        var v13997 = "use of variable '" + v19869;
        var v4332 = v13997 + "' that is not definitely assigned";
        er$$1.simpleError(ast$$80, v4332);
        return;
      }
      function useDefInit(bb$$5) {
        var v4333 = bb$$5;
        var v26894 = new BBUseDefInfo(bb$$5);
        v4333.useDef = v26894;
        var v4334 = bb$$5.useDef;
        v4334.initialize(useDefContext$$3);
        var v4335 = _this$$4.linearBBs;
        var v13998 = _this$$4.linearBBs;
        var v4336 = v13998.length;
        v4335[v4336] = bb$$5;
        return;
      }
      var _this$$4 = this;
      var useDefContext$$3 = new UseDefContext;
      useDefContext$$3.func = funcSym;
      this.bfs(useDefInit, null, null, null);
      var i$$89;
      var bbLen;
      i$$89 = 0;
      var v13999 = this.linearBBs;
      bbLen = v13999.length;
      var v4339 = i$$89 < bbLen;
      for (;v4339;) {
        var v19870 = this.linearBBs;
        var v14000 = v19870[i$$89];
        var v4337 = v14000.useDef;
        v4337.initializeGen(useDefContext$$3);
        var v19871 = this.linearBBs;
        var v14001 = v19871[i$$89];
        var v4338 = v14001.useDef;
        v4338.initializeKill(useDefContext$$3);
        i$$89 = i$$89 + 1;
        v4339 = i$$89 < bbLen;
      }
      var changed$$1 = true;
      for (;changed$$1;) {
        changed$$1 = false;
        i$$89 = 0;
        var v4341 = i$$89 < bbLen;
        for (;v4341;) {
          var v23618 = this.linearBBs;
          var v19872 = v23618[i$$89];
          var v14002 = v19872.useDef;
          var v4340 = v14002.updateTop();
          var v14003 = !v4340;
          if (v14003) {
            v4340 = changed$$1;
          }
          changed$$1 = v4340;
          i$$89 = i$$89 + 1;
          v4341 = i$$89 < bbLen;
        }
      }
      var v14004 = this.entry;
      var v4342 = v14004.useDef;
      var top$$1 = v4342.top;
      top$$1.map(v998);
      return;
    }
    function v997(nodeFunc, edgeFunc, preEdges, postEdges) {
      var markValue = this.markBase;
      var v14005 = this.markBase;
      this.markBase = v14005 + 1;
      var q = new Array;
      var v4343 = q.length;
      q[v4343] = this.entry;
      var v14006 = q.length;
      var v4351 = v14006 > 0;
      for (;v4351;) {
        var bb$$4 = q.pop();
        var v14007 = bb$$4.marked(markValue);
        var v4350 = !v14007;
        if (v4350) {
          bb$$4.mark();
          if (nodeFunc) {
            nodeFunc(bb$$4);
          }
          var v4344 = bb$$4.successors;
          var succLen$$1 = v4344.length;
          var v4349 = succLen$$1 > 0;
          if (v4349) {
            if (preEdges) {
              preEdges();
            }
            var j$$12 = succLen$$1 - 1;
            var v4348 = j$$12 >= 0;
            for (;v4348;) {
              var v4345 = bb$$4.successors;
              var successor$$1 = v4345[j$$12];
              var v19873 = this.markBase;
              var v14008 = successor$$1.marked(v19873);
              var v4347 = !v14008;
              if (v4347) {
                if (edgeFunc) {
                  edgeFunc(bb$$4, successor$$1);
                }
                var v4346 = q.length;
                q[v4346] = successor$$1;
              }
              j$$12 = j$$12 - 1;
              v4348 = j$$12 >= 0;
            }
            if (postEdges) {
              postEdges();
            }
          }
        }
        var v14009 = q.length;
        v4351 = v14009 > 0;
      }
      return;
    }
    function v996(bb$$3, outfile$$13) {
      var content$$4 = bb$$3.content;
      var i$$88 = 0;
      var v4352 = content$$4.members;
      var len$$39 = v4352.length;
      var v4354 = i$$88 < len$$39;
      for (;v4354;) {
        var v4353 = content$$4.members;
        var ast$$79 = v4353[i$$88];
        this.printAST(ast$$79, outfile$$13);
        i$$88 = i$$88 + 1;
        v4354 = i$$88 < len$$39;
      }
      return;
    }
    function v995(ast$$78, outfile$$12) {
      var v4355 = TypeScript$$25.PrintContext;
      var printContext = new v4355(outfile$$12, null);
      printContext.increaseIndent();
      var v4356 = TypeScript$$25.getAstWalkerFactory();
      var v4357 = TypeScript$$25.prePrintAST;
      var v4358 = TypeScript$$25.postPrintAST;
      v4356.walk(ast$$78, v4357, v4358, null, printContext);
      printContext.decreaseIndent();
      return;
    }
    function v994(er) {
      var v14010 = this.unreachable;
      if (v14010) {
        var v23619 = this.unreachable;
        var v19874 = v23619.length;
        v14010 = v19874 > 0;
      }
      var v4363 = v14010;
      if (v4363) {
        var v4359 = this.unreachable;
        var len$$38 = v4359.length;
        var i$$87 = 0;
        var v4362 = i$$87 < len$$38;
        for (;v4362;) {
          var v4360 = this.unreachable;
          var unreachableAST = v4360[i$$87];
          var v14011 = unreachableAST.nodeType;
          var v19875 = TypeScript$$25.NodeType;
          var v14012 = v19875.EndCode;
          var v4361 = v14011 != v14012;
          if (v4361) {
            er.simpleError(unreachableAST, "unreachable code");
          }
          i$$87 = i$$87 + 1;
          v4362 = i$$87 < len$$38;
        }
      }
      return;
    }
    function v993() {
      var v4364 = this.currentSwitch;
      return v4364.pop();
    }
    function v992(bb$$2) {
      var v4365 = this.currentSwitch;
      v4365.push(bb$$2);
      return;
    }
    function v991(ast$$77, parent$$64) {
      var v4366 = this.walker;
      return v4366.walk(ast$$77, parent$$64);
    }
    function ControlFlowContext$$1(current$$3, exit$$1) {
      this.current = current$$3;
      this.exit = exit$$1;
      this.entry = null;
      this.unreachable = null;
      this.noContinuation = false;
      var v26895 = new Array;
      this.statementStack = v26895;
      var v26896 = new Array;
      this.currentSwitch = v26896;
      this.markBase = 0;
      var v26897 = new Array;
      this.linearBBs = v26897;
      this.entry = this.current;
      return;
    }
    var v4367 = ControlFlowContext$$1.prototype;
    v4367.walk = v991;
    var v4368 = ControlFlowContext$$1.prototype;
    v4368.pushSwitch = v992;
    var v4369 = ControlFlowContext$$1.prototype;
    v4369.popSwitch = v993;
    var v4370 = ControlFlowContext$$1.prototype;
    v4370.reportUnreachable = v994;
    var v4371 = ControlFlowContext$$1.prototype;
    v4371.printAST = v995;
    var v4372 = ControlFlowContext$$1.prototype;
    v4372.printBlockContent = v996;
    var v4373 = ControlFlowContext$$1.prototype;
    v4373.bfs = v997;
    var v4374 = ControlFlowContext$$1.prototype;
    v4374.useDef = v999;
    var v4375 = ControlFlowContext$$1.prototype;
    v4375.print = v1000;
    var v4376 = ControlFlowContext$$1.prototype;
    v4376.pushStatement = v1001;
    var v4377 = ControlFlowContext$$1.prototype;
    v4377.popStatement = v1002;
    var v4378 = ControlFlowContext$$1.prototype;
    v4378.returnStmt = v1003;
    var v4379 = ControlFlowContext$$1.prototype;
    v4379.setUnreachable = v1004;
    var v4380 = ControlFlowContext$$1.prototype;
    v4380.addUnreachable = v1005;
    var v4381 = ControlFlowContext$$1.prototype;
    v4381.unconditionalBranch = v1006;
    var v4382 = ControlFlowContext$$1.prototype;
    v4382.addContent = v1007;
    return ControlFlowContext$$1;
  }
  function v990() {
    function v989(successor) {
      var v4383 = this.successors;
      var v14013 = this.successors;
      var v4384 = v14013.length;
      v4383[v4384] = successor;
      var v4385 = successor.predecessors;
      var v14014 = successor.predecessors;
      var v4386 = v14014.length;
      v4385[v4386] = this;
      return;
    }
    function v988() {
      var v14015 = this.markValue;
      this.markValue = v14015 + 1;
      return;
    }
    function v987(markBase) {
      var v4387 = this.markValue;
      return v4387 > markBase;
    }
    function BasicBlock$$1() {
      var v26898 = new Array;
      this.predecessors = v26898;
      this.index = -1;
      this.markValue = 0;
      var v26899 = new Array;
      this.successors = v26899;
      this.useDef = null;
      var v4388 = TypeScript$$25.ASTList;
      var v26900 = new v4388;
      this.content = v26900;
      return;
    }
    var v4389 = BasicBlock$$1.prototype;
    v4389.marked = v987;
    var v4390 = BasicBlock$$1.prototype;
    v4390.mark = v988;
    var v4391 = BasicBlock$$1.prototype;
    v4391.addSuccessor = v989;
    return BasicBlock$$1;
  }
  function v986() {
    function v985(b$$13) {
      var oldFirstBits = this.firstBits;
      var v14016 = this.firstBits;
      var v19876 = b$$13.firstBits;
      var v14017 = ~v19876;
      this.firstBits = v14016 & v14017;
      var v4397 = this.restOfBits;
      if (v4397) {
        var k$$12 = 0;
        var v4392 = this.restOfBits;
        var len$$37 = v4392.length;
        var v4396 = k$$12 < len$$37;
        for (;v4396;) {
          var v4393 = this.restOfBits;
          var myBits$$4 = v4393[k$$12];
          var v4394 = b$$13.restOfBits;
          var bBits$$3 = v4394[k$$12];
          var v4395 = this.restOfBits;
          var v19877 = v4395[k$$12];
          var v19878 = ~bBits$$3;
          v4395[k$$12] = v19877 & v19878;
          k$$12 = k$$12 + 1;
          v4396 = k$$12 < len$$37;
        }
      }
      return;
    }
    function v984(b$$12) {
      var v14018 = this.firstBits;
      var v14019 = b$$12.firstBits;
      var v4398 = v14018 != v14019;
      if (v4398) {
        return true;
      }
      var v4404 = this.restOfBits;
      if (v4404) {
        var k$$11 = 0;
        var v4399 = this.restOfBits;
        var len$$36 = v4399.length;
        var v4403 = k$$11 < len$$36;
        for (;v4403;) {
          var v4400 = this.restOfBits;
          var myBits$$3 = v4400[k$$11];
          var v4401 = b$$12.restOfBits;
          var bBits$$2 = v4401[k$$11];
          var v4402 = myBits$$3 != bBits$$2;
          if (v4402) {
            return true;
          }
          k$$11 = k$$11 + 1;
          v4403 = k$$11 < len$$36;
        }
      }
      return false;
    }
    function v983(b$$11) {
      var v14020 = this.firstBits;
      var v14021 = b$$11.firstBits;
      this.firstBits = v14020 & v14021;
      var v4410 = this.restOfBits;
      if (v4410) {
        var k$$10 = 0;
        var v4405 = this.restOfBits;
        var len$$35 = v4405.length;
        var v4409 = k$$10 < len$$35;
        for (;v4409;) {
          var v4406 = this.restOfBits;
          var myBits$$2 = v4406[k$$10];
          var v4407 = b$$11.restOfBits;
          var bBits$$1 = v4407[k$$10];
          var v4408 = this.restOfBits;
          v4408[k$$10] = myBits$$2 & bBits$$1;
          k$$10 = k$$10 + 1;
          v4409 = k$$10 < len$$35;
        }
      }
      return;
    }
    function v982(b$$10) {
      var v14022 = this.firstBits;
      var v14023 = b$$10.firstBits;
      this.firstBits = v14022 | v14023;
      var v4416 = this.restOfBits;
      if (v4416) {
        var k$$9 = 0;
        var v4411 = this.restOfBits;
        var len$$34 = v4411.length;
        var v4415 = k$$9 < len$$34;
        for (;v4415;) {
          var v4412 = this.restOfBits;
          var myBits$$1 = v4412[k$$9];
          var v4413 = b$$10.restOfBits;
          var bBits = v4413[k$$9];
          var v4414 = this.restOfBits;
          v4414[k$$9] = myBits$$1 | bBits;
          k$$9 = k$$9 + 1;
          v4415 = k$$9 < len$$34;
        }
      }
      return;
    }
    function v981(fn$$7) {
      var k$$8;
      k$$8 = 0;
      var v14024 = BitVector$$1.packBits;
      var v4419 = k$$8 < v14024;
      for (;v4419;) {
        var v14025 = this.bitCount;
        var v4417 = k$$8 == v14025;
        if (v4417) {
          return;
        }
        var v19879 = 1 << k$$8;
        var v19880 = this.firstBits;
        var v14026 = v19879 & v19880;
        var v4418 = v14026 != 0;
        if (v4418) {
          fn$$7(k$$8);
        }
        k$$8 = k$$8 + 1;
        var v14027 = BitVector$$1.packBits;
        v4419 = k$$8 < v14027;
      }
      var v4425 = this.restOfBits;
      if (v4425) {
        var len$$33;
        var cumu = BitVector$$1.packBits;
        k$$8 = 0;
        var v14028 = this.restOfBits;
        len$$33 = v14028.length;
        var v4424 = k$$8 < len$$33;
        for (;v4424;) {
          var v4420 = this.restOfBits;
          var myBits = v4420[k$$8];
          var j$$11 = 0;
          var v14029 = BitVector$$1.packBits;
          var v4423 = j$$11 < v14029;
          for (;v4423;) {
            var v19881 = 1 << j$$11;
            var v14030 = v19881 & myBits;
            var v4421 = v14030 != 0;
            if (v4421) {
              fn$$7(cumu);
            }
            cumu = cumu + 1;
            var v14031 = this.bitCount;
            var v4422 = cumu == v14031;
            if (v4422) {
              return;
            }
            j$$11 = j$$11 + 1;
            var v14032 = BitVector$$1.packBits;
            v4423 = j$$11 < v14032;
          }
          k$$8 = k$$8 + 1;
          v4424 = k$$8 < len$$33;
        }
      }
      return;
    }
    function v980(bitIndex, value$$40) {
      var v14033 = BitVector$$1.packBits;
      var v4430 = bitIndex < v14033;
      if (v4430) {
        if (value$$40) {
          var v14034 = this.firstBits;
          var v14035 = 1 << bitIndex;
          this.firstBits = v14034 | v14035;
        } else {
          var v14036 = this.firstBits;
          var v19882 = 1 << bitIndex;
          var v14037 = ~v19882;
          this.firstBits = v14036 & v14037;
        }
      } else {
        var v19883 = BitVector$$1.packBits;
        var v14038 = bitIndex / v19883;
        var v4426 = Math.floor(v14038);
        var offset$$9 = v4426 - 1;
        var v4427 = BitVector$$1.packBits;
        var localIndex = bitIndex % v4427;
        if (value$$40) {
          var v4428 = this.restOfBits;
          var v19884 = v4428[offset$$9];
          var v19885 = 1 << localIndex;
          v4428[offset$$9] = v19884 | v19885;
        } else {
          var v4429 = this.restOfBits;
          var v19886 = v4429[offset$$9];
          var v23620 = 1 << localIndex;
          var v19887 = ~v23620;
          v4429[offset$$9] = v19886 & v19887;
        }
      }
      return;
    }
    function BitVector$$1(bitCount$$1) {
      this.bitCount = bitCount$$1;
      this.firstBits = 0;
      this.restOfBits = null;
      var v14039 = this.bitCount;
      var v14040 = BitVector$$1.packBits;
      var v4434 = v14039 > v14040;
      if (v4434) {
        var v26901 = new Array;
        this.restOfBits = v26901;
        var v14041 = this.bitCount;
        var v14042 = BitVector$$1.packBits;
        var v4431 = v14041 / v14042;
        var len$$32 = Math.floor(v4431);
        var i$$86 = 0;
        var v4433 = i$$86 < len$$32;
        for (;v4433;) {
          var v4432 = this.restOfBits;
          v4432[i$$86] = 0;
          i$$86 = i$$86 + 1;
          v4433 = i$$86 < len$$32;
        }
      }
      return;
    }
    BitVector$$1.packBits = 30;
    var v4435 = BitVector$$1.prototype;
    v4435.set = v980;
    var v4436 = BitVector$$1.prototype;
    v4436.map = v981;
    var v4437 = BitVector$$1.prototype;
    v4437.union = v982;
    var v4438 = BitVector$$1.prototype;
    v4438.intersection = v983;
    var v4439 = BitVector$$1.prototype;
    v4439.notEq = v984;
    var v4440 = BitVector$$1.prototype;
    v4440.difference = v985;
    return BitVector$$1;
  }
  function v979() {
    function v978(sym$$33, bbUses) {
      var v4441 = this.symbolMap;
      var v4442 = sym$$33.name;
      var index$$54 = v4441.lookup(v4442);
      var v4443 = this.useIndexBySymbol;
      var usesOfSym = v4443[index$$54];
      var k$$7 = 0;
      var len$$31 = usesOfSym.length;
      var v4445 = k$$7 < len$$31;
      for (;v4445;) {
        var v4444 = usesOfSym[k$$7];
        bbUses.set(v4444, true);
        k$$7 = k$$7 + 1;
        v4445 = k$$7 < len$$31;
      }
      return;
    }
    function v977(sym$$32) {
      var v14043 = sym$$32;
      if (v14043) {
        var v19888 = sym$$32.container;
        var v19889 = this.func;
        v14043 = v19888 == v19889;
      }
      var v4446 = v14043;
      if (v4446) {
        var v14044 = sym$$32.kind();
        var v19890 = TypeScript$$25.SymbolKind;
        var v14045 = v19890.Variable;
        v4446 = v14044 == v14045;
      }
      return v4446;
    }
    function v976(ast$$76) {
      var v4447 = this.uses;
      var v14046 = this.uses;
      var v4448 = v14046.length;
      v4447[v4448] = ast$$76;
      var v14047 = this.uses;
      var v4449 = v14047.length;
      return v4449 - 1;
    }
    function v975(symIndex$$1, astIndex$$1) {
      var v4450 = this.useIndexBySymbol;
      var useBySym = v4450[symIndex$$1];
      var v4452 = useBySym == undefined;
      if (v4452) {
        useBySym = new Array;
        var v4451 = this.useIndexBySymbol;
        v4451[symIndex$$1] = useBySym;
      }
      var v4453 = useBySym.length;
      useBySym[v4453] = astIndex$$1;
      return;
    }
    function v974(sym$$31) {
      var name$$85 = sym$$31.name;
      var v4454 = this.symbolMap;
      var index$$53 = v4454.lookup(name$$85);
      var v4457 = index$$53 == null;
      if (v4457) {
        index$$53 = this.symbolCount;
        var v14048 = this.symbolCount;
        this.symbolCount = v14048 + 1;
        var v4455 = this.symbols;
        v4455[index$$53] = sym$$31;
        var v4456 = this.symbolMap;
        v4456.add(name$$85, index$$53);
      }
      return index$$53;
    }
    function UseDefContext$$1() {
      var v26902 = new Array;
      this.useIndexBySymbol = v26902;
      var v26903 = new Array;
      this.uses = v26903;
      var v26904 = new Array;
      this.symbols = v26904;
      var v4458 = TypeScript$$25.StringHashTable;
      var v26905 = new v4458;
      this.symbolMap = v26905;
      this.symbolCount = 0;
      return;
    }
    var v4459 = UseDefContext$$1.prototype;
    v4459.getSymbolIndex = v974;
    var v4460 = UseDefContext$$1.prototype;
    v4460.addUse = v975;
    var v4461 = UseDefContext$$1.prototype;
    v4461.getUseIndex = v976;
    var v4462 = UseDefContext$$1.prototype;
    v4462.isLocalSym = v977;
    var v4463 = UseDefContext$$1.prototype;
    v4463.killSymbol = v978;
    return UseDefContext$$1;
  }
  function v973() {
    function v972(useDefContext$$2) {
      var v14049 = this.gen;
      var v4464 = v14049.bitCount;
      var v26906 = new BitVector(v4464);
      this.kill = v26906;
      var s$$25 = 0;
      var v4465 = this.defsBySymbol;
      var symbolLen$$1 = v4465.length;
      var v4471 = s$$25 < symbolLen$$1;
      for (;v4471;) {
        var v14050 = this.defsBySymbol;
        var v4470 = v14050[s$$25];
        if (v4470) {
          var v4466 = useDefContext$$2.useIndexBySymbol;
          var globalSymUses = v4466[s$$25];
          if (globalSymUses) {
            var u$$1 = 0;
            var useLen = globalSymUses.length;
            var v4469 = u$$1 < useLen;
            for (;v4469;) {
              var v4467 = this.kill;
              var v4468 = globalSymUses[u$$1];
              v4467.set(v4468, true);
              u$$1 = u$$1 + 1;
              v4469 = u$$1 < useLen;
            }
          }
        }
        s$$25 = s$$25 + 1;
        v4471 = s$$25 < symbolLen$$1;
      }
      return;
    }
    function v971(useDefContext$$1) {
      var v4472 = this.useIndexBySymbol;
      var symbolLen = v4472.length;
      var v4473 = useDefContext$$1.uses;
      var bitCount = v4473.length;
      var v26907 = new BitVector(bitCount);
      this.gen = v26907;
      var s$$24 = 0;
      var v4479 = s$$24 < symbolLen;
      for (;v4479;) {
        var v4474 = this.useIndexBySymbol;
        var symUses$$1 = v4474[s$$24];
        var v14051 = symUses$$1 != undefined;
        if (v14051) {
          var v19891 = symUses$$1.length;
          v14051 = v19891 > 0;
        }
        var v4478 = v14051;
        if (v4478) {
          var u = 0;
          var uLen = symUses$$1.length;
          var v4477 = u < uLen;
          for (;v4477;) {
            var v4475 = this.gen;
            var v4476 = symUses$$1[u];
            v4475.set(v4476, true);
            u = u + 1;
            v4477 = u < uLen;
          }
        }
        s$$24 = s$$24 + 1;
        v4479 = s$$24 < symbolLen;
      }
      this.top = this.gen;
      return;
    }
    function v970(useDefContext) {
      function defSym(sym$$29, context$$62) {
        var v4483 = context$$62.isLocalSym(sym$$29);
        if (v4483) {
          var index$$52 = context$$62.getSymbolIndex(sym$$29);
          var v4480 = _this$$3.useIndexBySymbol;
          var v4481 = index$$52;
          var v26908 = new Array;
          v4480[v4481] = v26908;
          var v4482 = _this$$3.defsBySymbol;
          v4482[index$$52] = true;
        }
        return;
      }
      function initUseDefPre(cur$$9, parent$$63, walker$$48) {
        var context$$61 = walker$$48.state;
        var v4484 = cur$$9 == null;
        if (v4484) {
          cur$$9 = null;
        }
        var v14052 = cur$$9.nodeType;
        var v19892 = TypeScript$$25.NodeType;
        var v14053 = v19892.VarDecl;
        var v4502 = v14052 == v14053;
        if (v4502) {
          var varDecl$$13 = cur$$9;
          var v14054 = varDecl$$13.init;
          var v19895 = !v14054;
          if (v19895) {
            var v19893 = varDecl$$13.varFlags;
            var v23621 = TypeScript$$25.VarFlags;
            var v19894 = v23621.AutoInit;
            v14054 = TypeScript$$25.hasFlag(v19893, v19894);
          }
          var v4486 = v14054;
          if (v4486) {
            var v4485 = varDecl$$13.sym;
            defSym(v4485, context$$61);
          }
        } else {
          var v14055 = cur$$9.nodeType;
          var v19896 = TypeScript$$25.NodeType;
          var v14056 = v19896.Name;
          var v4501 = v14055 == v14056;
          if (v4501) {
            if (parent$$63) {
              var v14057 = parent$$63.nodeType;
              var v19897 = TypeScript$$25.NodeType;
              var v14058 = v19897.Asg;
              var v4490 = v14057 == v14058;
              if (v4490) {
                var asg = parent$$63;
                var v14059 = asg.operand1;
                var v4487 = v14059 == cur$$9;
                if (v4487) {
                  return cur$$9;
                }
              } else {
                var v14060 = parent$$63.nodeType;
                var v19898 = TypeScript$$25.NodeType;
                var v14061 = v19898.VarDecl;
                var v4489 = v14060 == v14061;
                if (v4489) {
                  var parentDecl = parent$$63;
                  var v14062 = parentDecl.id;
                  var v4488 = v14062 == cur$$9;
                  if (v4488) {
                    return cur$$9;
                  }
                }
              }
            }
            var id$$21 = cur$$9;
            var sym$$inline_16 = id$$21.sym;
            var context$$inline_17 = context$$61;
            var ast$$inline_18 = cur$$9;
            var v4495 = context$$inline_17.isLocalSym(sym$$inline_16);
            if (v4495) {
              var symIndex$$inline_19 = context$$inline_17.getSymbolIndex(sym$$inline_16);
              var v19899 = _this$$3.useIndexBySymbol;
              var v14063 = v19899[symIndex$$inline_19];
              var v4493 = v14063 == undefined;
              if (v4493) {
                var v4491 = _this$$3.useIndexBySymbol;
                var v4492 = symIndex$$inline_19;
                var v26909 = new Array;
                v4491[v4492] = v26909;
              }
              var v4494 = _this$$3.useIndexBySymbol;
              var symUses$$inline_20 = v4494[symIndex$$inline_19];
              var astIndex$$inline_21 = context$$inline_17.getUseIndex(ast$$inline_18);
              context$$inline_17.addUse(symIndex$$inline_19, astIndex$$inline_21);
              symUses$$inline_20.push(astIndex$$inline_21);
            }
          } else {
            var v19900 = cur$$9.nodeType;
            var v23622 = TypeScript$$25.NodeType;
            var v19901 = v23622.Asg;
            var v14064 = v19900 >= v19901;
            if (v14064) {
              var v19902 = cur$$9.nodeType;
              var v23623 = TypeScript$$25.NodeType;
              var v19903 = v23623.LastAsg;
              v14064 = v19902 <= v19903;
            }
            var v4500 = v14064;
            if (v4500) {
              asg = cur$$9;
              var v14065 = asg.operand1;
              if (v14065) {
                var v23624 = asg.operand1;
                var v19904 = v23624.nodeType;
                var v23625 = TypeScript$$25.NodeType;
                var v19905 = v23625.Name;
                v14065 = v19904 == v19905;
              }
              var v4497 = v14065;
              if (v4497) {
                id$$21 = asg.operand1;
                var v4496 = id$$21.sym;
                defSym(v4496, context$$61);
              }
            } else {
              var v14066 = cur$$9.nodeType;
              var v19906 = TypeScript$$25.NodeType;
              var v14067 = v19906.FuncDecl;
              var v4499 = v14066 == v14067;
              if (v4499) {
                var v4498 = walker$$48.options;
                v4498.goChildren = false;
              }
            }
          }
        }
        return cur$$9;
      }
      var _this$$3 = this;
      var v4503 = TypeScript$$25.AstWalkOptions;
      var options$$6 = new v4503;
      options$$6.reverseSiblings = true;
      var v4504 = TypeScript$$25.getAstWalkerFactory();
      var v14068 = this.bb;
      var v4505 = v14068.content;
      v4504.walk(v4505, initUseDefPre, null, options$$6, useDefContext);
      return;
    }
    function v969() {
      var v14069 = this.top;
      var v4506 = v14069.bitCount;
      var temp$$16 = new BitVector(v4506);
      var i$$85 = 0;
      var v14070 = this.bb;
      var v4507 = v14070.successors;
      var succLen = v4507.length;
      var v4511 = i$$85 < succLen;
      for (;v4511;) {
        var v14071 = this.bb;
        var v4508 = v14071.successors;
        var succ = v4508[i$$85];
        var v4510 = succ.useDef;
        if (v4510) {
          var v14072 = succ.useDef;
          var v4509 = v14072.top;
          temp$$16.union(v4509);
        }
        i$$85 = i$$85 + 1;
        v4511 = i$$85 < succLen;
      }
      var v4512 = this.kill;
      temp$$16.difference(v4512);
      var v4513 = this.gen;
      temp$$16.union(v4513);
      var v4514 = this.top;
      var changed = temp$$16.notEq(v4514);
      this.top = temp$$16;
      return changed;
    }
    function BBUseDefInfo$$1(bb$$1) {
      this.bb = bb$$1;
      var v26910 = new Array;
      this.defsBySymbol = v26910;
      var v26911 = new Array;
      this.useIndexBySymbol = v26911;
      return;
    }
    var v4515 = BBUseDefInfo$$1.prototype;
    v4515.updateTop = v969;
    var v4516 = BBUseDefInfo$$1.prototype;
    v4516.initialize = v970;
    var v4517 = BBUseDefInfo$$1.prototype;
    v4517.initializeGen = v971;
    var v4518 = BBUseDefInfo$$1.prototype;
    v4518.initializeKill = v972;
    return BBUseDefInfo$$1;
  }
  function v968() {
    function ScopeChain$$1(container$$14, previous$$1, scope$$29) {
      this.container = container$$14;
      this.previous = previous$$1;
      this.scope = scope$$29;
      return;
    }
    return ScopeChain$$1;
  }
  var ScopeChain = v968();
  TypeScript$$25.ScopeChain = ScopeChain;
  var BBUseDefInfo = v973();
  TypeScript$$25.BBUseDefInfo = BBUseDefInfo;
  var UseDefContext = v979();
  TypeScript$$25.UseDefContext = UseDefContext;
  var BitVector = v986();
  TypeScript$$25.BitVector = BitVector;
  var BasicBlock = v990();
  TypeScript$$25.BasicBlock = BasicBlock;
  var ControlFlowContext = v1008();
  TypeScript$$25.ControlFlowContext = ControlFlowContext;
  var ResolutionDataCache = v1011();
  TypeScript$$25.ResolutionDataCache = ResolutionDataCache;
  var TypeFlow = v1112();
  TypeScript$$25.TypeFlow = TypeFlow;
  return;
}
function v967(TypeScript$$24) {
  function v966() {
    function Continuation$$1(normalBlock) {
      this.normalBlock = normalBlock;
      this.exceptionBlock = -1;
      return;
    }
    return Continuation$$1;
  }
  function getBaseTypeLinks(bases$$3, baseTypeLinks) {
    if (bases$$3) {
      var v4519 = bases$$3.members;
      var len$$30 = v4519.length;
      var v4520 = baseTypeLinks == null;
      if (v4520) {
        baseTypeLinks = new Array;
      }
      var i$$83 = 0;
      var v4524 = i$$83 < len$$30;
      for (;v4524;) {
        var v4521 = bases$$3.members;
        var baseExpr$$1 = v4521[i$$83];
        var name$$82 = baseExpr$$1;
        var v4522 = TypeScript$$24.TypeLink;
        var typeLink$$3 = new v4522;
        typeLink$$3.ast = name$$82;
        var v4523 = baseTypeLinks.length;
        baseTypeLinks[v4523] = typeLink$$3;
        i$$83 = i$$83 + 1;
        v4524 = i$$83 < len$$30;
      }
    }
    return baseTypeLinks;
  }
  function getBases(type$$44, typeDecl) {
    var v4525 = type$$44;
    var v14073 = typeDecl.extendsList;
    var v14074 = type$$44.extendsTypeLinks;
    var v26912 = getBaseTypeLinks(v14073, v14074);
    v4525.extendsTypeLinks = v26912;
    var v4526 = type$$44;
    var v14075 = typeDecl.implementsList;
    var v14076 = type$$44.implementsTypeLinks;
    var v26913 = getBaseTypeLinks(v14075, v14076);
    v4526.implementsTypeLinks = v26913;
    return;
  }
  function createNewConstructGroupForType(type$$45) {
    var v4527 = TypeScript$$24.Signature;
    var signature$$6 = new v4527;
    var v4528 = signature$$6;
    var v14077 = TypeScript$$24.TypeLink;
    var v26914 = new v14077;
    v4528.returnType = v26914;
    var v4529 = signature$$6.returnType;
    v4529.type = type$$45.instanceType;
    signature$$6.parameters = [];
    var v4530 = type$$45;
    var v14078 = TypeScript$$24.SignatureGroup;
    var v26915 = new v14078;
    v4530.construct = v26915;
    var v4531 = type$$45.construct;
    v4531.addSignature(signature$$6);
    return;
  }
  function cloneParentConstructGroupForChildType(child$$1, parent$$53) {
    var v4532 = child$$1;
    var v14079 = TypeScript$$24.SignatureGroup;
    var v26916 = new v14079;
    v4532.construct = v26916;
    var sig$$1 = null;
    var v14080 = parent$$53.construct;
    var v4533 = !v14080;
    if (v4533) {
      createNewConstructGroupForType(parent$$53);
    }
    var i$$84 = 0;
    var v23626 = parent$$53.construct;
    var v19907 = v23626.signatures;
    var v14081 = v19907.length;
    var v4542 = i$$84 < v14081;
    for (;v4542;) {
      var v4534 = TypeScript$$24.Signature;
      sig$$1 = new v4534;
      var v19908 = parent$$53.construct;
      var v14082 = v19908.signatures;
      var v4535 = v14082[i$$84];
      sig$$1.parameters = v4535.parameters;
      var v19909 = parent$$53.construct;
      var v14083 = v19909.signatures;
      var v4536 = v14083[i$$84];
      sig$$1.nonOptionalParameterCount = v4536.nonOptionalParameterCount;
      var v19910 = parent$$53.construct;
      var v14084 = v19910.signatures;
      var v4537 = v14084[i$$84];
      sig$$1.typeCheckStatus = v4537.typeCheckStatus;
      var v19911 = parent$$53.construct;
      var v14085 = v19911.signatures;
      var v4538 = v14085[i$$84];
      sig$$1.declAST = v4538.declAST;
      var v4539 = sig$$1;
      var v14086 = TypeScript$$24.TypeLink;
      var v26917 = new v14086;
      v4539.returnType = v26917;
      var v4540 = sig$$1.returnType;
      v4540.type = child$$1.instanceType;
      var v4541 = child$$1.construct;
      v4541.addSignature(sig$$1);
      i$$84 = i$$84 + 1;
      var v23627 = parent$$53.construct;
      var v19912 = v23627.signatures;
      var v14087 = v19912.length;
      v4542 = i$$84 < v14087;
    }
    return;
  }
  function findTypeSymbolInScopeChain(name$$83, scopeChain$$2) {
    var v4543 = scopeChain$$2.scope;
    var symbol$$14 = v4543.find(name$$83, false, true);
    var v14088 = symbol$$14 == null;
    if (v14088) {
      v14088 = scopeChain$$2.previous;
    }
    var v4545 = v14088;
    if (v4545) {
      var v4544 = scopeChain$$2.previous;
      symbol$$14 = findTypeSymbolInScopeChain(name$$83, v4544);
    }
    return symbol$$14;
  }
  function findSymbolFromAlias(alias$$2, context$$51) {
    function v965(id$$20) {
      var v4548 = context$$51.members;
      if (v4548) {
        var v4546 = context$$51.members;
        return v4546.lookup(name$$84);
      } else {
        var v4547 = context$$51.topLevelScope;
        return findTypeSymbolInScopeChain(name$$84, v4547);
      }
      return;
    }
    var symbol$$15 = null;
    var v4554 = alias$$2.nodeType;
    switch(v4554) {
      case TypeScript$$24.NodeType.Name:
        var name$$84 = alias$$2.text;
        var isDynamic = TypeScript$$24.isQuoted(name$$84);
        var findSym = v965;
        if (isDynamic) {
          var v14089 = context$$51.tcContext;
          var v4549 = v14089.checker;
          var v23628 = context$$51.tcContext;
          var v19913 = v23628.script;
          var v14090 = v19913.locationInfo;
          var v4550 = v14090.filename;
          symbol$$15 = v4549.findSymbolForDynamicModule(name$$84, v4550, findSym);
        } else {
          symbol$$15 = findSym(name$$84);
        }
        break;
      case TypeScript$$24.NodeType.Dot:
        var dottedExpr = alias$$2;
        var v4551 = dottedExpr.operand1;
        var op1Sym = findSymbolFromAlias(v4551, context$$51);
        var v14091 = op1Sym;
        if (v14091) {
          v14091 = op1Sym.getType();
        }
        var v4553 = v14091;
        if (v4553) {
          var v4552 = dottedExpr.operand2;
          symbol$$15 = findSymbolFromAlias(v4552, context$$51);
        }
      ;
      default:
      ;
    }
    if (symbol$$15) {
      var symType$$1 = symbol$$15.getType();
      if (symType$$1) {
        var members$$25 = symType$$1.members;
        if (members$$25) {
          context$$51.members = members$$25.publicMembers;
        }
      }
    }
    return symbol$$15;
  }
  function preCollectImportTypes(ast$$66, parent$$54, context$$52) {
    var scopeChain$$3 = context$$52.scopeChain;
    var typeSymbol$$2 = null;
    var modType = null;
    var importDecl$$1 = ast$$66;
    var v4555 = importDecl$$1.alias;
    var v4556 = {topLevelScope:scopeChain$$3, members:null, tcContext:context$$52};
    var aliasedModSymbol = findSymbolFromAlias(v4555, v4556);
    var v14092 = context$$52.scopeChain;
    var v4557 = v14092.container;
    var v14093 = context$$52.checker;
    var v4558 = v14093.gloMod;
    var isGlobal$$1 = v4557 == v4558;
    if (aliasedModSymbol) {
      var aliasedModType = aliasedModSymbol.getType();
      if (aliasedModType) {
        modType = aliasedModType;
      }
    }
    var v4559 = TypeScript$$24.TypeSymbol;
    var v14094 = importDecl$$1.id;
    var v4560 = v14094.text;
    var v14095 = importDecl$$1.id;
    var v4561 = v14095.minChar;
    var v14096 = importDecl$$1.limChar;
    var v14097 = importDecl$$1.minChar;
    var v4562 = v14096 - v14097;
    var v19914 = context$$52.checker;
    var v14098 = v19914.locationInfo;
    var v4563 = v14098.unitIndex;
    typeSymbol$$2 = new v4559(v4560, v4561, v4562, v4563, modType);
    typeSymbol$$2.aliasLink = importDecl$$1;
    var v14099 = context$$52.scopeChain;
    var v4565 = v14099.moduleDecl;
    if (v4565) {
      var v14100 = typeSymbol$$2.flags;
      var v19915 = TypeScript$$24.SymbolFlags;
      var v14101 = v19915.ModuleMember;
      typeSymbol$$2.flags = v14100 | v14101;
      var v4564 = context$$52.scopeChain;
      typeSymbol$$2.declModule = v4564.moduleDecl;
    }
    typeSymbol$$2.declAST = importDecl$$1;
    var v4566 = importDecl$$1.id;
    v4566.sym = typeSymbol$$2;
    var v4567 = scopeChain$$3.scope;
    var v4568 = scopeChain$$3.container;
    var v14102 = context$$52.checker;
    var v4569 = v14102.errorReporter;
    v4567.enter(v4568, ast$$66, typeSymbol$$2, v4569, isGlobal$$1, true, false);
    var v4570 = scopeChain$$3.scope;
    var v4571 = scopeChain$$3.container;
    var v14103 = context$$52.checker;
    var v4572 = v14103.errorReporter;
    v4570.enter(v4571, ast$$66, typeSymbol$$2, v4572, isGlobal$$1, false, false);
    return true;
  }
  function preCollectModuleTypes(ast$$67, parent$$55, context$$53) {
    var scopeChain$$4 = context$$53.scopeChain;
    var moduleDecl$$6 = ast$$67;
    var v4573 = moduleDecl$$6.modFlags;
    var v14104 = TypeScript$$24.ModuleFlags;
    var v4574 = v14104.Ambient;
    var isAmbient$$5 = TypeScript$$24.hasFlag(v4573, v4574);
    var v4575 = moduleDecl$$6.modFlags;
    var v14105 = TypeScript$$24.ModuleFlags;
    var v4576 = v14105.IsEnum;
    var isEnum = TypeScript$$24.hasFlag(v4575, v4576);
    var v14106 = context$$53.scopeChain;
    var v4577 = v14106.container;
    var v14107 = context$$53.checker;
    var v4578 = v14107.gloMod;
    var isGlobal$$2 = v4577 == v4578;
    var v4579 = moduleDecl$$6.modFlags;
    var v14108 = TypeScript$$24.ModuleFlags;
    var v4580 = v14108.Exported;
    var isExported$$2 = TypeScript$$24.hasFlag(v4579, v4580);
    var v4581 = moduleDecl$$6.name;
    var modName$$3 = v4581.text;
    var isDynamic$$1 = TypeScript$$24.isQuoted(modName$$3);
    var v4582 = scopeChain$$4.scope;
    var symbol$$16 = v4582.findLocal(modName$$3, false, false);
    var typeSymbol$$3 = null;
    var modType$$1 = null;
    var v14109 = symbol$$16 == null;
    var v19918 = !v14109;
    if (v19918) {
      var v19916 = symbol$$16.kind();
      var v23629 = TypeScript$$24.SymbolKind;
      var v19917 = v23629.Type;
      v14109 = v19916 != v19917;
    }
    var v4629 = v14109;
    if (v4629) {
      var v4590 = modType$$1 == null;
      if (v4590) {
        var v4583 = TypeScript$$24.ScopedMembers;
        var v14110 = TypeScript$$24.DualStringHashTable;
        var v19919 = TypeScript$$24.StringHashTable;
        var v14111 = new v19919;
        var v19920 = TypeScript$$24.StringHashTable;
        var v14112 = new v19920;
        var v4584 = new v14110(v14111, v14112);
        var enclosedTypes$$3 = new v4583(v4584);
        var v4585 = TypeScript$$24.ScopedMembers;
        var v14113 = TypeScript$$24.DualStringHashTable;
        var v19921 = TypeScript$$24.StringHashTable;
        var v14114 = new v19921;
        var v19922 = TypeScript$$24.StringHashTable;
        var v14115 = new v19922;
        var v4586 = new v14113(v14114, v14115);
        var ambientEnclosedTypes$$3 = new v4585(v4586);
        var v4587 = TypeScript$$24.ModuleType;
        modType$$1 = new v4587(enclosedTypes$$3, ambientEnclosedTypes$$3);
        if (isEnum) {
          var v14116 = modType$$1.typeFlags;
          var v19923 = TypeScript$$24.TypeFlags;
          var v14117 = v19923.IsEnum;
          modType$$1.typeFlags = v14116 | v14117;
        }
        var v4588 = modType$$1;
        var v14118 = TypeScript$$24.ScopedMembers;
        var v19924 = TypeScript$$24.DualStringHashTable;
        var v23630 = TypeScript$$24.StringHashTable;
        var v19925 = new v23630;
        var v23631 = TypeScript$$24.StringHashTable;
        var v19926 = new v23631;
        var v14119 = new v19924(v19925, v19926);
        var v26918 = new v14118(v14119);
        v4588.members = v26918;
        var v4589 = modType$$1;
        var v14120 = TypeScript$$24.ScopedMembers;
        var v19927 = TypeScript$$24.DualStringHashTable;
        var v23632 = TypeScript$$24.StringHashTable;
        var v19928 = new v23632;
        var v23633 = TypeScript$$24.StringHashTable;
        var v19929 = new v23633;
        var v14121 = new v19927(v19928, v19929);
        var v26919 = new v14120(v14121);
        v4589.ambientMembers = v26919;
        modType$$1.setHasImplementation();
      }
      var v4591 = TypeScript$$24.TypeSymbol;
      var v14122 = moduleDecl$$6.name;
      var v4592 = v14122.minChar;
      var v4593 = modName$$3.length;
      var v19930 = context$$53.checker;
      var v14123 = v19930.locationInfo;
      var v4594 = v14123.unitIndex;
      typeSymbol$$3 = new v4591(modName$$3, v4592, v4593, v4594, modType$$1);
      var v4595 = typeSymbol$$3;
      var v14124 = moduleDecl$$6.prettyName;
      var v26920 = TypeScript$$24.isQuoted(v14124);
      v4595.isDynamic = v26920;
      var v14125 = context$$53.scopeChain;
      var v4597 = v14125.moduleDecl;
      if (v4597) {
        var v4596 = context$$53.scopeChain;
        typeSymbol$$3.declModule = v4596.moduleDecl;
      }
      typeSymbol$$3.declAST = moduleDecl$$6;
      typeSymbol$$3.prettyName = moduleDecl$$6.prettyName;
      var v4598 = scopeChain$$4.scope;
      var v4599 = scopeChain$$4.container;
      var v14126 = context$$53.checker;
      var v4600 = v14126.errorReporter;
      var v4601 = isExported$$2 || isGlobal$$2;
      v4598.enter(v4599, ast$$67, typeSymbol$$3, v4600, v4601, true, isAmbient$$5);
      var v4602 = scopeChain$$4.scope;
      var v4603 = scopeChain$$4.container;
      var v14127 = context$$53.checker;
      var v4604 = v14127.errorReporter;
      var v4605 = isExported$$2 || isGlobal$$2;
      v4602.enter(v4603, ast$$67, typeSymbol$$3, v4604, v4605, false, isAmbient$$5);
      modType$$1.symbol = typeSymbol$$3;
    } else {
      var v19931 = symbol$$16;
      if (v19931) {
        v19931 = symbol$$16.declAST;
      }
      var v14128 = v19931;
      if (v14128) {
        var v23634 = symbol$$16.declAST;
        var v19932 = v23634.nodeType;
        var v23635 = TypeScript$$24.NodeType;
        var v19933 = v23635.ModuleDeclaration;
        v14128 = v19932 != v19933;
      }
      var v4608 = v14128;
      if (v4608) {
        var v14129 = context$$53.checker;
        var v4606 = v14129.errorReporter;
        var v14130 = "Conflicting symbol name for module '" + modName$$3;
        var v4607 = v14130 + "'";
        v4606.simpleError(moduleDecl$$6, v4607);
      }
      typeSymbol$$3 = symbol$$16;
      var v14131 = typeSymbol$$3.type;
      var v4609 = v14131.getAllEnclosedTypes();
      var publicEnclosedTypes = v4609.publicMembers;
      var v4610;
      var v14133 = publicEnclosedTypes == null;
      if (v14133) {
        var v14132 = TypeScript$$24.StringHashTable;
        v4610 = new v14132;
      } else {
        v4610 = publicEnclosedTypes;
      }
      var publicEnclosedTypesTable = v4610;
      var v4611 = TypeScript$$24.ScopedMembers;
      var v14134 = TypeScript$$24.DualStringHashTable;
      var v19934 = TypeScript$$24.StringHashTable;
      var v14135 = new v19934;
      var v4612 = new v14134(publicEnclosedTypesTable, v14135);
      enclosedTypes$$3 = new v4611(v4612);
      var v14136 = typeSymbol$$3.type;
      var v4613 = v14136.getAllAmbientEnclosedTypes();
      var publicEnclosedAmbientTypes = v4613.publicMembers;
      var v4614;
      var v14138 = publicEnclosedAmbientTypes == null;
      if (v14138) {
        var v14137 = TypeScript$$24.StringHashTable;
        v4614 = new v14137;
      } else {
        v4614 = publicEnclosedAmbientTypes;
      }
      var publicAmbientEnclosedTypesTable = v4614;
      var v4615 = TypeScript$$24.ScopedMembers;
      var v14139 = TypeScript$$24.DualStringHashTable;
      var v19935 = TypeScript$$24.StringHashTable;
      var v14140 = new v19935;
      var v4616 = new v14139(publicAmbientEnclosedTypesTable, v14140);
      ambientEnclosedTypes$$3 = new v4615(v4616);
      var v14141 = typeSymbol$$3.type;
      var v4617 = v14141.members;
      var publicMembers = v4617.publicMembers;
      var v4618;
      var v14143 = publicMembers == null;
      if (v14143) {
        var v14142 = TypeScript$$24.StringHashTable;
        v4618 = new v14142;
      } else {
        v4618 = publicMembers;
      }
      var publicMembersTable = v4618;
      var v4619 = TypeScript$$24.ScopedMembers;
      var v14144 = TypeScript$$24.DualStringHashTable;
      var v19936 = TypeScript$$24.StringHashTable;
      var v14145 = new v19936;
      var v4620 = new v14144(publicMembersTable, v14145);
      var members$$26 = new v4619(v4620);
      var v14146 = typeSymbol$$3.type;
      var v4621 = v14146.ambientMembers;
      var publicAmbientMembers = v4621.publicMembers;
      var v4622;
      var v14148 = publicAmbientMembers == null;
      if (v14148) {
        var v14147 = TypeScript$$24.StringHashTable;
        v4622 = new v14147;
      } else {
        v4622 = publicAmbientMembers;
      }
      var publicAmbientMembersTable = v4622;
      var v4623 = TypeScript$$24.ScopedMembers;
      var v14149 = TypeScript$$24.DualStringHashTable;
      var v19937 = TypeScript$$24.StringHashTable;
      var v14150 = new v19937;
      var v4624 = new v14149(publicAmbientMembersTable, v14150);
      var ambientMembers$$2 = new v4623(v4624);
      var v4625 = TypeScript$$24.ModuleType;
      modType$$1 = new v4625(enclosedTypes$$3, ambientEnclosedTypes$$3);
      if (isEnum) {
        var v14151 = modType$$1.typeFlags;
        var v19938 = TypeScript$$24.TypeFlags;
        var v14152 = v19938.IsEnum;
        modType$$1.typeFlags = v14151 | v14152;
      }
      modType$$1.members = members$$26;
      modType$$1.ambientMembers = ambientMembers$$2;
      modType$$1.setHasImplementation();
      modType$$1.symbol = typeSymbol$$3;
      var v4626 = moduleDecl$$6.minChar;
      typeSymbol$$3.addLocation(v4626);
      var v4627 = typeSymbol$$3.expansions;
      v4627.push(modType$$1);
      var v4628 = typeSymbol$$3.expansionsDeclAST;
      v4628.push(moduleDecl$$6);
    }
    var v14153 = context$$53.scopeChain;
    var v4631 = v14153.moduleDecl;
    if (v4631) {
      var v14154 = context$$53.scopeChain;
      var v4630 = v14154.moduleDecl;
      v4630.recordNonInterface();
    }
    if (isExported$$2) {
      var v14155 = typeSymbol$$3.flags;
      var v19939 = TypeScript$$24.SymbolFlags;
      var v14156 = v19939.Exported;
      typeSymbol$$3.flags = v14155 | v14156;
    }
    var v19940 = context$$53.scopeChain;
    var v14157 = v19940.moduleDecl;
    var v19943 = !v14157;
    if (v19943) {
      var v23636 = context$$53.scopeChain;
      var v19941 = v23636.container;
      var v23637 = context$$53.checker;
      var v19942 = v23637.gloMod;
      v14157 = v19941 == v19942;
    }
    var v4632 = v14157;
    if (v4632) {
      var v14158 = typeSymbol$$3.flags;
      var v19944 = TypeScript$$24.SymbolFlags;
      var v14159 = v19944.ModuleMember;
      typeSymbol$$3.flags = v14158 | v14159;
    }
    moduleDecl$$6.mod = modType$$1;
    var v4633 = modType$$1.members;
    var v4634 = modType$$1.ambientMembers;
    var v4635 = modType$$1.enclosedTypes;
    var v4636 = modType$$1.ambientEnclosedTypes;
    TypeScript$$24.pushTypeCollectionScope(typeSymbol$$3, v4633, v4634, v4635, v4636, context$$53, null, null, moduleDecl$$6);
    return true;
  }
  function preCollectClassTypes(ast$$68, parent$$56, context$$54) {
    var scopeChain$$5 = context$$54.scopeChain;
    var classDecl$$7 = ast$$68;
    var classType$$5;
    var instanceType$$4;
    var typeSymbol$$4 = null;
    var v4637 = classDecl$$7.name;
    var className$$4 = v4637.text;
    var alreadyInScope = false;
    var v4638 = classDecl$$7.varFlags;
    var v14160 = TypeScript$$24.VarFlags;
    var v4639 = v14160.Ambient;
    var isAmbient$$6 = TypeScript$$24.hasFlag(v4638, v4639);
    var v4640 = classDecl$$7.varFlags;
    var v14161 = TypeScript$$24.VarFlags;
    var v4641 = v14161.Exported;
    var isExported$$3 = TypeScript$$24.hasFlag(v4640, v4641);
    var v14162 = context$$54.scopeChain;
    var v4642 = v14162.container;
    var v14163 = context$$54.checker;
    var v4643 = v14163.gloMod;
    var isGlobal$$3 = v4642 == v4643;
    var containerMod = scopeChain$$5.container;
    var foundValSymbol = false;
    var v4644 = scopeChain$$5.scope;
    typeSymbol$$4 = v4644.findLocal(className$$4, false, true);
    var v4651 = !typeSymbol$$4;
    if (v4651) {
      var v4645 = scopeChain$$5.scope;
      var valTypeSymbol = v4645.findLocal(className$$4, false, false);
      var v25396 = valTypeSymbol;
      if (v25396) {
        v25396 = valTypeSymbol.isType();
      }
      var v23638 = v25396;
      if (v23638) {
        v23638 = valTypeSymbol.declAST;
      }
      var v19945 = v23638;
      if (v19945) {
        var v25397 = valTypeSymbol.declAST;
        var v23639 = v25397.nodeType;
        var v25398 = TypeScript$$24.NodeType;
        var v23640 = v25398.FuncDecl;
        v19945 = v23639 == v23640;
      }
      var v14164 = v19945;
      if (v14164) {
        var v19946 = valTypeSymbol.declAST;
        v14164 = v19946.isSignature();
      }
      var v4650 = v14164;
      if (v4650) {
        typeSymbol$$4 = valTypeSymbol;
        foundValSymbol = true;
        if (isExported$$3) {
          var v14165 = typeSymbol$$4.flags;
          var v19947 = TypeScript$$24.SymbolFlags;
          var v14166 = v19947.Exported;
          typeSymbol$$4.flags = v14165 | v14166;
        }
        if (isAmbient$$6) {
          var v14167 = typeSymbol$$4.flags;
          var v19948 = TypeScript$$24.SymbolFlags;
          var v14168 = v19948.Ambient;
          typeSymbol$$4.flags = v14167 | v14168;
        }
        var v14169 = context$$54.scopeChain;
        var v4646 = v14169.scope;
        var v14170 = context$$54.scopeChain;
        var v4647 = v14170.container;
        var v14171 = context$$54.checker;
        var v4648 = v14171.errorReporter;
        var v4649 = isExported$$3 || isGlobal$$3;
        v4646.enter(v4647, ast$$68, typeSymbol$$4, v4648, v4649, true, isAmbient$$6);
      }
    }
    var v19949 = typeSymbol$$4;
    if (v19949) {
      v19949 = !foundValSymbol;
    }
    var v14172 = v19949;
    if (v14172) {
      var v19950 = typeSymbol$$4.declAST;
      v14172 = v19950 != classDecl$$7;
    }
    var v4652 = v14172;
    if (v4652) {
      typeSymbol$$4 = null;
    }
    var v4691 = typeSymbol$$4 == null;
    if (v4691) {
      var v4653 = scopeChain$$5.scope;
      var valueSymbol = v4653.findLocal(className$$4, false, false);
      var v4654 = TypeScript$$24.Type;
      classType$$5 = new v4654;
      classType$$5.setHasImplementation();
      var v4655 = TypeScript$$24.Type;
      instanceType$$4 = new v4655;
      instanceType$$4.setHasImplementation();
      classType$$5.instanceType = instanceType$$4;
      var v4656 = classType$$5;
      var v14173 = TypeScript$$24.ScopedMembers;
      var v19951 = TypeScript$$24.DualStringHashTable;
      var v23641 = TypeScript$$24.StringHashTable;
      var v19952 = new v23641;
      var v23642 = TypeScript$$24.StringHashTable;
      var v19953 = new v23642;
      var v14174 = new v19951(v19952, v19953);
      var v26921 = new v14173(v14174);
      v4656.members = v26921;
      var v4657 = classType$$5;
      var v14175 = TypeScript$$24.ScopedMembers;
      var v19954 = TypeScript$$24.DualStringHashTable;
      var v23643 = TypeScript$$24.StringHashTable;
      var v19955 = new v23643;
      var v23644 = TypeScript$$24.StringHashTable;
      var v19956 = new v23644;
      var v14176 = new v19954(v19955, v19956);
      var v26922 = new v14175(v14176);
      v4657.ambientMembers = v26922;
      var classType$$inline_10 = classType$$5;
      var ast$$inline_11 = classDecl$$7;
      var context$$inline_12 = context$$54;
      var v4658 = TypeScript$$24.ValueLocation;
      var field$$inline_13 = new v4658;
      var v4659 = field$$inline_13;
      var v14177 = TypeScript$$24.TypeLink;
      var v26923 = new v14177;
      v4659.typeLink = v26923;
      var v4660 = field$$inline_13.typeLink;
      v4660.ast = ast$$inline_11;
      var v4661 = field$$inline_13.typeLink;
      v4661.type = classType$$inline_10.instanceType;
      var v4662 = TypeScript$$24.FieldSymbol;
      var v4663 = ast$$inline_11.minChar;
      var v19957 = context$$inline_12.checker;
      var v14178 = v19957.locationInfo;
      var v4664 = v14178.unitIndex;
      var fieldSymbol$$inline_14 = new v4662("prototype", v4663, v4664, true, field$$inline_13);
      var v14179 = fieldSymbol$$inline_14.flags;
      var v23645 = TypeScript$$24.SymbolFlags;
      var v19958 = v23645.Property;
      var v23646 = TypeScript$$24.SymbolFlags;
      var v19959 = v23646.BuiltIn;
      var v14180 = v19958 | v19959;
      fieldSymbol$$inline_14.flags = v14179 | v14180;
      field$$inline_13.symbol = fieldSymbol$$inline_14;
      fieldSymbol$$inline_14.declAST = ast$$inline_11;
      var v4665 = classType$$inline_10.members;
      v4665.addPublicMember("prototype", fieldSymbol$$inline_14);
      var v4666 = instanceType$$4;
      var v14181 = TypeScript$$24.ScopedMembers;
      var v19960 = TypeScript$$24.DualStringHashTable;
      var v23647 = TypeScript$$24.StringHashTable;
      var v19961 = new v23647;
      var v23648 = TypeScript$$24.StringHashTable;
      var v19962 = new v23648;
      var v14182 = new v19960(v19961, v19962);
      var v26924 = new v14181(v14182);
      v4666.members = v26924;
      var v4667 = instanceType$$4;
      var v14183 = TypeScript$$24.ScopedMembers;
      var v19963 = TypeScript$$24.DualStringHashTable;
      var v23649 = TypeScript$$24.StringHashTable;
      var v19964 = new v23649;
      var v23650 = TypeScript$$24.StringHashTable;
      var v19965 = new v23650;
      var v14184 = new v19963(v19964, v19965);
      var v26925 = new v14183(v14184);
      v4667.ambientMembers = v26925;
      var v4668 = TypeScript$$24.TypeSymbol;
      var v14185 = classDecl$$7.name;
      var v4669 = v14185.minChar;
      var v4670 = className$$4.length;
      var v19966 = context$$54.checker;
      var v14186 = v19966.locationInfo;
      var v4671 = v14186.unitIndex;
      typeSymbol$$4 = new v4668(className$$4, v4669, v4670, v4671, classType$$5);
      typeSymbol$$4.declAST = classDecl$$7;
      typeSymbol$$4.instanceType = instanceType$$4;
      classType$$5.symbol = typeSymbol$$4;
      instanceType$$4.symbol = typeSymbol$$4;
      var v14187 = context$$54.scopeChain;
      var v4674 = v14187.moduleDecl;
      if (v4674) {
        var v14188 = context$$54.scopeChain;
        var v4672 = v14188.moduleDecl;
        v4672.recordNonInterface();
        var v4673 = context$$54.scopeChain;
        typeSymbol$$4.declModule = v4673.moduleDecl;
        var v14189 = typeSymbol$$4.flags;
        var v19967 = TypeScript$$24.SymbolFlags;
        var v14190 = v19967.ModuleMember;
        typeSymbol$$4.flags = v14189 | v14190;
      }
      if (isExported$$3) {
        var v14191 = typeSymbol$$4.flags;
        var v19968 = TypeScript$$24.SymbolFlags;
        var v14192 = v19968.Exported;
        typeSymbol$$4.flags = v14191 | v14192;
      }
      if (isAmbient$$6) {
        var v14193 = typeSymbol$$4.flags;
        var v19969 = TypeScript$$24.SymbolFlags;
        var v14194 = v19969.Ambient;
        typeSymbol$$4.flags = v14193 | v14194;
      }
      ast$$68.type = classType$$5;
      var v14195 = context$$54.scopeChain;
      var v4675 = v14195.scope;
      var v14196 = context$$54.scopeChain;
      var v4676 = v14196.container;
      var v14197 = context$$54.checker;
      var v4677 = v14197.errorReporter;
      var v4678 = isExported$$3 || isGlobal$$3;
      v4675.enter(v4676, ast$$68, typeSymbol$$4, v4677, v4678, true, isAmbient$$6);
      var v4683 = valueSymbol == null;
      if (v4683) {
        var v14198 = context$$54.scopeChain;
        var v4679 = v14198.scope;
        var v14199 = context$$54.scopeChain;
        var v4680 = v14199.container;
        var v14200 = context$$54.checker;
        var v4681 = v14200.errorReporter;
        var v4682 = isExported$$3 || isGlobal$$3;
        v4679.enter(v4680, ast$$68, typeSymbol$$4, v4681, v4682, false, isAmbient$$6);
      }
    } else {
      classType$$5 = typeSymbol$$4.type;
      var v14201 = classType$$5.instanceType;
      var v4690 = v14201 == null;
      if (v4690) {
        var v4684 = classType$$5;
        var v14202 = TypeScript$$24.Type;
        var v26926 = new v14202;
        v4684.instanceType = v26926;
        var v4685 = classType$$5.instanceType;
        v4685.setHasImplementation();
        var v4686 = classType$$5.instanceType;
        var v14203 = TypeScript$$24.ScopedMembers;
        var v19970 = TypeScript$$24.DualStringHashTable;
        var v23651 = TypeScript$$24.StringHashTable;
        var v19971 = new v23651;
        var v23652 = TypeScript$$24.StringHashTable;
        var v19972 = new v23652;
        var v14204 = new v19970(v19971, v19972);
        var v26927 = new v14203(v14204);
        v4686.members = v26927;
        var v4687 = classType$$5.instanceType;
        v4687.symbol = classType$$5.symbol;
        var v4688 = classType$$5;
        var v14205 = TypeScript$$24.ScopedMembers;
        var v19973 = TypeScript$$24.DualStringHashTable;
        var v23653 = TypeScript$$24.StringHashTable;
        var v19974 = new v23653;
        var v23654 = TypeScript$$24.StringHashTable;
        var v19975 = new v23654;
        var v14206 = new v19973(v19974, v19975);
        var v26928 = new v14205(v14206);
        v4688.members = v26928;
        var v4689 = classType$$5;
        var v14207 = TypeScript$$24.ScopedMembers;
        var v19976 = TypeScript$$24.DualStringHashTable;
        var v23655 = TypeScript$$24.StringHashTable;
        var v19977 = new v23655;
        var v23656 = TypeScript$$24.StringHashTable;
        var v19978 = new v23656;
        var v14208 = new v19976(v19977, v19978);
        var v26929 = new v14207(v14208);
        v4689.ambientMembers = v26929;
      }
      instanceType$$4 = classType$$5.instanceType;
      ast$$68.type = classType$$5;
    }
    var v14209 = classDecl$$7.constructorDecl;
    var v4697 = !v14209;
    if (v4697) {
      var v25399 = typeSymbol$$4;
      if (v25399) {
        v25399 = typeSymbol$$4.declAST;
      }
      var v23657 = v25399;
      if (v23657) {
        var v25400 = typeSymbol$$4.declAST;
        v23657 = v25400.type;
      }
      var v19979 = v23657;
      if (v19979) {
        var v25401 = typeSymbol$$4.declAST;
        var v23658 = v25401.type;
        v19979 = v23658.call;
      }
      var v14210 = v19979;
      if (v14210) {
        var v23659 = typeSymbol$$4.declAST;
        var v19980 = v23659.isOverload;
        v14210 = !v19980;
      }
      var v4695 = v14210;
      if (v4695) {
        var v14211 = context$$54.checker;
        var v4692 = v14211.errorReporter;
        var v4693 = typeSymbol$$4.declAST;
        var v4694 = typeSymbol$$4.name;
        v4692.duplicateIdentifier(v4693, v4694);
      }
      var v4696 = classDecl$$7.type;
      createNewConstructGroupForType(v4696);
    }
    var v14212 = classType$$5.typeFlags;
    var v19981 = TypeScript$$24.TypeFlags;
    var v14213 = v19981.IsClass;
    classType$$5.typeFlags = v14212 | v14213;
    var v14214 = instanceType$$4.typeFlags;
    var v19982 = TypeScript$$24.TypeFlags;
    var v14215 = v19982.IsClass;
    instanceType$$4.typeFlags = v14214 | v14215;
    getBases(instanceType$$4, classDecl$$7);
    var v4698 = instanceType$$4.members;
    var v4699 = instanceType$$4.ambientMembers;
    TypeScript$$24.pushTypeCollectionScope(typeSymbol$$4, v4698, v4699, null, null, context$$54, instanceType$$4, classType$$5, null);
    return true;
  }
  function preCollectInterfaceTypes(ast$$69, parent$$57, context$$55) {
    var scopeChain$$6 = context$$55.scopeChain;
    var interfaceDecl$$4 = ast$$69;
    var interfaceSymbol$$1 = null;
    var interfaceType$$2 = null;
    var v4700 = interfaceDecl$$4.varFlags;
    var v14216 = TypeScript$$24.VarFlags;
    var v4701 = v14216.Exported;
    var isExported$$4 = TypeScript$$24.hasFlag(v4700, v4701);
    var v14217 = context$$55.scopeChain;
    var v4702 = v14217.container;
    var v14218 = context$$55.checker;
    var v4703 = v14218.gloMod;
    var isGlobal$$4 = v4702 == v4703;
    var alreadyInScope$$1 = true;
    alreadyInScope$$1 = false;
    var v4704 = interfaceDecl$$4.name;
    var interfaceName = v4704.text;
    var v4705 = scopeChain$$6.scope;
    interfaceSymbol$$1 = v4705.findLocal(interfaceName, false, true);
    var v4714 = interfaceSymbol$$1 == null;
    if (v4714) {
      var v4706 = TypeScript$$24.Type;
      interfaceType$$2 = new v4706;
      var v4707 = TypeScript$$24.TypeSymbol;
      var v14219 = interfaceDecl$$4.name;
      var v4708 = v14219.minChar;
      var v4709 = interfaceName.length;
      var v19983 = context$$55.checker;
      var v14220 = v19983.locationInfo;
      var v4710 = v14220.unitIndex;
      interfaceSymbol$$1 = new v4707(interfaceName, v4708, v4709, v4710, interfaceType$$2);
      interfaceType$$2.symbol = interfaceSymbol$$1;
      var v4711 = interfaceType$$2;
      var v14221 = TypeScript$$24.ScopedMembers;
      var v19984 = TypeScript$$24.DualStringHashTable;
      var v23660 = TypeScript$$24.StringHashTable;
      var v19985 = new v23660;
      var v23661 = TypeScript$$24.StringHashTable;
      var v19986 = new v23661;
      var v14222 = new v19984(v19985, v19986);
      var v26930 = new v14221(v14222);
      v4711.members = v26930;
      var v4712 = interfaceType$$2;
      var v14223 = TypeScript$$24.ScopedMembers;
      var v19987 = TypeScript$$24.DualStringHashTable;
      var v23662 = TypeScript$$24.StringHashTable;
      var v19988 = new v23662;
      var v23663 = TypeScript$$24.StringHashTable;
      var v19989 = new v23663;
      var v14224 = new v19987(v19988, v19989);
      var v26931 = new v14223(v14224);
      v4712.ambientMembers = v26931;
      interfaceSymbol$$1.declAST = interfaceDecl$$4;
      var v4713 = context$$55.scopeChain;
      interfaceSymbol$$1.declModule = v4713.moduleDecl;
    } else {
      alreadyInScope$$1 = true;
      interfaceType$$2 = interfaceSymbol$$1.type;
    }
    var v4716 = !interfaceType$$2;
    if (v4716) {
      var v4715 = context$$55.checker;
      interfaceType$$2 = v4715.anyType;
    }
    ast$$69.type = interfaceType$$2;
    getBases(interfaceType$$2, interfaceDecl$$4);
    if (isExported$$4) {
      var v14225 = interfaceSymbol$$1.flags;
      var v19990 = TypeScript$$24.SymbolFlags;
      var v14226 = v19990.Exported;
      interfaceSymbol$$1.flags = v14225 | v14226;
    }
    var v14227 = context$$55.scopeChain;
    var v4717 = v14227.moduleDecl;
    if (v4717) {
      var v14228 = interfaceSymbol$$1.flags;
      var v19991 = TypeScript$$24.SymbolFlags;
      var v14229 = v19991.ModuleMember;
      interfaceSymbol$$1.flags = v14228 | v14229;
    }
    var v4722 = !alreadyInScope$$1;
    if (v4722) {
      var v14230 = context$$55.scopeChain;
      var v4718 = v14230.scope;
      var v14231 = context$$55.scopeChain;
      var v4719 = v14231.container;
      var v14232 = context$$55.checker;
      var v4720 = v14232.errorReporter;
      var v4721 = isGlobal$$4 || isExported$$4;
      v4718.enter(v4719, ast$$69, interfaceSymbol$$1, v4720, v4721, true, false);
    }
    var v4723 = interfaceType$$2.members;
    var v4724 = interfaceType$$2.ambientMembers;
    TypeScript$$24.pushTypeCollectionScope(interfaceSymbol$$1, v4723, v4724, null, null, context$$55, interfaceType$$2, null, null);
    return true;
  }
  function preCollectArgDeclTypes(ast$$70, parent$$58, context$$56) {
    var scopeChain$$7 = context$$56.scopeChain;
    var argDecl$$1 = ast$$70;
    var v14233 = argDecl$$1.varFlags;
    var v23664 = TypeScript$$24.VarFlags;
    var v19992 = v23664.Public;
    var v23665 = TypeScript$$24.VarFlags;
    var v19993 = v23665.Private;
    var v14234 = v19992 | v19993;
    var v4739 = TypeScript$$24.hasFlag(v14233, v14234);
    if (v4739) {
      var v4725 = TypeScript$$24.ValueLocation;
      var field$$4 = new v4725;
      var v4726 = argDecl$$1.varFlags;
      var v14235 = TypeScript$$24.VarFlags;
      var v4727 = v14235.Private;
      var isPrivate$$2 = TypeScript$$24.hasFlag(v4726, v4727);
      var v4728 = TypeScript$$24.FieldSymbol;
      var v14236 = argDecl$$1.id;
      var v4729 = v14236.text;
      var v14237 = argDecl$$1.id;
      var v4730 = v14237.minChar;
      var v19994 = context$$56.checker;
      var v14238 = v19994.locationInfo;
      var v4731 = v14238.unitIndex;
      var v19995 = argDecl$$1.varFlags;
      var v23666 = TypeScript$$24.VarFlags;
      var v19996 = v23666.Readonly;
      var v14239 = TypeScript$$24.hasFlag(v19995, v19996);
      var v4732 = !v14239;
      var fieldSymbol$$2 = new v4728(v4729, v4730, v4731, v4732, field$$4);
      var v4733 = argDecl$$1.varFlags;
      fieldSymbol$$2.transferVarFlags(v4733);
      field$$4.symbol = fieldSymbol$$2;
      fieldSymbol$$2.declAST = ast$$70;
      argDecl$$1.parameterPropertySym = fieldSymbol$$2;
      var v14240 = context$$56.scopeChain;
      var v4734 = v14240.scope;
      var v14241 = context$$56.scopeChain;
      var v4735 = v14241.container;
      var v14242 = context$$56.checker;
      var v4736 = v14242.errorReporter;
      var v4737 = !isPrivate$$2;
      v4734.enter(v4735, ast$$70, fieldSymbol$$2, v4736, v4737, false, false);
      var v4738 = field$$4;
      var v14243 = argDecl$$1.typeExpr;
      var v14244 = context$$56.checker;
      var v19997 = argDecl$$1.init;
      var v14245 = v19997 == null;
      var v26932 = TypeScript$$24.getTypeLink(v14243, v14244, v14245);
      v4738.typeLink = v26932;
      argDecl$$1.sym = fieldSymbol$$2;
    }
    return false;
  }
  function preCollectVarDeclTypes(ast$$71, parent$$59, context$$57) {
    var scopeChain$$8 = context$$57.scopeChain;
    var varDecl$$12 = ast$$71;
    var v4740 = varDecl$$12.varFlags;
    var v14246 = TypeScript$$24.VarFlags;
    var v4741 = v14246.Ambient;
    var isAmbient$$7 = TypeScript$$24.hasFlag(v4740, v4741);
    var v4742 = varDecl$$12.varFlags;
    var v14247 = TypeScript$$24.VarFlags;
    var v4743 = v14247.Exported;
    var isExported$$5 = TypeScript$$24.hasFlag(v4742, v4743);
    var v14248 = context$$57.scopeChain;
    var v4744 = v14248.container;
    var v14249 = context$$57.checker;
    var v4745 = v14249.gloMod;
    var isGlobal$$5 = v4744 == v4745;
    var v4746 = varDecl$$12.varFlags;
    var v14250 = TypeScript$$24.VarFlags;
    var v4747 = v14250.Property;
    var isProperty = TypeScript$$24.hasFlag(v4746, v4747);
    var v4748 = varDecl$$12.varFlags;
    var v14251 = TypeScript$$24.VarFlags;
    var v4749 = v14251.Static;
    var isStatic$$8 = TypeScript$$24.hasFlag(v4748, v4749);
    var v4750 = varDecl$$12.varFlags;
    var v14252 = TypeScript$$24.VarFlags;
    var v4751 = v14252.Private;
    var isPrivate$$3 = TypeScript$$24.hasFlag(v4750, v4751);
    var v14253 = varDecl$$12.id;
    var v4752 = v14253.flags;
    var v14254 = TypeScript$$24.ASTFlags;
    var v4753 = v14254.OptionalName;
    var isOptional$$1 = TypeScript$$24.hasFlag(v4752, v4753);
    var v14255 = context$$57.scopeChain;
    var v4755 = v14255.moduleDecl;
    if (v4755) {
      var v14256 = context$$57.scopeChain;
      var v4754 = v14256.moduleDecl;
      v4754.recordNonInterface();
    }
    var v19998 = isProperty || isExported$$5;
    var v23669 = !v19998;
    if (v23669) {
      var v25402 = context$$57.scopeChain;
      var v23667 = v25402.container;
      var v25403 = context$$57.checker;
      var v23668 = v25403.gloMod;
      v19998 = v23667 == v23668;
    }
    var v14257 = v19998;
    var v20000 = !v14257;
    if (v20000) {
      var v19999 = context$$57.scopeChain;
      v14257 = v19999.moduleDecl;
    }
    var v4780 = v14257;
    if (v4780) {
      if (isAmbient$$7) {
        var v4756 = scopeChain$$8.scope;
        var v14258 = varDecl$$12.id;
        var v4757 = v14258.text;
        var existingSym = v4756.findLocal(v4757, false, false);
        if (existingSym) {
          varDecl$$12.sym = existingSym;
          return false;
        }
      }
      var v14259 = varDecl$$12.id;
      var v4759 = v14259 == null;
      if (v4759) {
        var v14260 = context$$57.checker;
        var v4758 = v14260.errorReporter;
        v4758.simpleError(varDecl$$12, "Expected variable identifier at this location");
        return false;
      }
      var v4760 = TypeScript$$24.ValueLocation;
      var field$$5 = new v4760;
      var v4761 = TypeScript$$24.FieldSymbol;
      var v14261 = varDecl$$12.id;
      var v4762 = v14261.text;
      var v14262 = varDecl$$12.id;
      var v4763 = v14262.minChar;
      var v20001 = context$$57.checker;
      var v14263 = v20001.locationInfo;
      var v4764 = v14263.unitIndex;
      var v20002 = varDecl$$12.varFlags;
      var v23670 = TypeScript$$24.VarFlags;
      var v20003 = v23670.Readonly;
      var v14264 = v20002 & v20003;
      var v20004 = TypeScript$$24.VarFlags;
      var v14265 = v20004.None;
      var v4765 = v14264 == v14265;
      var fieldSymbol$$3 = new v4761(v4762, v4763, v4764, v4765, field$$5);
      var v4766 = varDecl$$12.varFlags;
      fieldSymbol$$3.transferVarFlags(v4766);
      if (isOptional$$1) {
        var v14266 = fieldSymbol$$3.flags;
        var v20005 = TypeScript$$24.SymbolFlags;
        var v14267 = v20005.Optional;
        fieldSymbol$$3.flags = v14266 | v14267;
      }
      field$$5.symbol = fieldSymbol$$3;
      fieldSymbol$$3.declAST = ast$$71;
      var v20006 = context$$57.scopeChain;
      var v14268 = v20006.moduleDecl;
      var v20009 = !v14268;
      if (v20009) {
        var v23671 = context$$57.scopeChain;
        var v20007 = v23671.container;
        var v23672 = context$$57.checker;
        var v20008 = v23672.gloMod;
        v14268 = v20007 == v20008;
      }
      var v4768 = v14268;
      if (v4768) {
        var v14269 = fieldSymbol$$3.flags;
        var v20010 = TypeScript$$24.SymbolFlags;
        var v14270 = v20010.ModuleMember;
        fieldSymbol$$3.flags = v14269 | v14270;
        var v4767 = context$$57.scopeChain;
        fieldSymbol$$3.declModule = v4767.moduleDecl;
      }
      var v23673 = varDecl$$12.varFlags;
      var v25404 = TypeScript$$24.VarFlags;
      var v23674 = v25404.Property;
      var v20011 = TypeScript$$24.hasFlag(v23673, v23674);
      if (v20011) {
        v20011 = isStatic$$8;
      }
      var v14271 = v20011;
      if (v14271) {
        var v20012 = context$$57.scopeChain;
        v14271 = v20012.classType;
      }
      var v4777 = v14271;
      if (v4777) {
        var v26129 = context$$57.scopeChain;
        var v25405 = v26129.classType;
        var v23675 = v25405.members;
        var v20013 = v23675.publicMembers;
        var v23676 = varDecl$$12.id;
        var v20014 = v23676.text;
        var v14272 = v20013.add(v20014, fieldSymbol$$3);
        var v4771 = !v14272;
        if (v4771) {
          var v14273 = context$$57.checker;
          var v4769 = v14273.errorReporter;
          var v4770 = fieldSymbol$$3.name;
          v4769.duplicateIdentifier(ast$$71, v4770);
        }
        var v14274 = context$$57.scopeChain;
        var v4772 = v14274.classType;
        fieldSymbol$$3.container = v4772.symbol;
      } else {
        var v14275 = context$$57.scopeChain;
        var v4773 = v14275.scope;
        var v14276 = context$$57.scopeChain;
        var v4774 = v14276.container;
        var v14277 = context$$57.checker;
        var v4775 = v14277.errorReporter;
        var v14278 = !isPrivate$$3;
        if (v14278) {
          var v23677 = isProperty || isExported$$5;
          var v25406 = !v23677;
          if (v25406) {
            v23677 = isGlobal$$5;
          }
          var v20015 = v23677;
          var v23678 = !v20015;
          if (v23678) {
            v20015 = isStatic$$8;
          }
          v14278 = v20015;
        }
        var v4776 = v14278;
        v4773.enter(v4774, ast$$71, fieldSymbol$$3, v4775, v4776, false, isAmbient$$7);
      }
      var v14279 = varDecl$$12.varFlags;
      var v20016 = TypeScript$$24.VarFlags;
      var v14280 = v20016.Exported;
      var v4778 = TypeScript$$24.hasFlag(v14279, v14280);
      if (v4778) {
        var v14281 = fieldSymbol$$3.flags;
        var v20017 = TypeScript$$24.SymbolFlags;
        var v14282 = v20017.Exported;
        fieldSymbol$$3.flags = v14281 | v14282;
      }
      var v4779 = field$$5;
      var v14283 = varDecl$$12.typeExpr;
      var v14284 = context$$57.checker;
      var v20018 = varDecl$$12.init;
      var v14285 = v20018 == null;
      var v26933 = TypeScript$$24.getTypeLink(v14283, v14284, v14285);
      v4779.typeLink = v26933;
      varDecl$$12.sym = fieldSymbol$$3;
    }
    return false;
  }
  function preCollectFuncDeclTypes(ast$$72, parent$$60, context$$58) {
    var scopeChain$$9 = context$$58.scopeChain;
    var v14286 = context$$58.scopeChain;
    var v4782 = v14286.moduleDecl;
    if (v4782) {
      var v14287 = context$$58.scopeChain;
      var v4781 = v14287.moduleDecl;
      v4781.recordNonInterface();
    }
    var funcDecl$$22 = ast$$72;
    var fgSym$$3 = null;
    var nameText$$3 = funcDecl$$22.getNameText();
    var v4783 = funcDecl$$22.fncFlags;
    var v20019 = TypeScript$$24.FncFlags;
    var v14288 = v20019.Exported;
    var v20020 = TypeScript$$24.FncFlags;
    var v14289 = v20020.ClassPropertyMethodExported;
    var v4784 = v14288 | v14289;
    var isExported$$6 = TypeScript$$24.hasFlag(v4783, v4784);
    var v4785 = funcDecl$$22.fncFlags;
    var v14290 = TypeScript$$24.FncFlags;
    var v4786 = v14290.Static;
    var isStatic$$9 = TypeScript$$24.hasFlag(v4785, v4786);
    var v4787 = funcDecl$$22.fncFlags;
    var v14291 = TypeScript$$24.FncFlags;
    var v4788 = v14291.Private;
    var isPrivate$$4 = TypeScript$$24.hasFlag(v4787, v4788);
    var v4789 = funcDecl$$22.isConstructMember();
    var v14292 = !v4789;
    if (v14292) {
      v4789 = funcDecl$$22.isConstructor;
    }
    var isConstructor$$3 = v4789;
    var v4790;
    var v25407 = funcDecl$$22.isMethod();
    if (v25407) {
      v25407 = isStatic$$9;
    }
    var v23679 = v25407;
    var v25408 = !v23679;
    if (v25408) {
      v23679 = funcDecl$$22.isAccessor();
    }
    var v20021 = v23679;
    if (v20021) {
      var v23680 = context$$58.scopeChain;
      v20021 = v23680.classType;
    }
    var v14295 = v20021;
    if (v14295) {
      var v20022 = context$$58.scopeChain;
      var v14293 = v20022.classType;
      v4790 = v14293.symbol;
    } else {
      var v14294 = context$$58.scopeChain;
      v4790 = v14294.container;
    }
    var containerSym = v4790;
    var v4791 = context$$58.scopeChain;
    var containerScope = v4791.scope;
    var v14296 = context$$58.checker;
    var v4792 = v14296.gloMod;
    var isGlobal$$6 = containerSym == v4792;
    var v4793 = funcDecl$$22.name;
    if (v4793) {
      var v20023 = funcDecl$$22.name;
      var v14297 = v20023.flags;
      var v20024 = TypeScript$$24.ASTFlags;
      var v14298 = v20024.OptionalName;
      v4793 = TypeScript$$24.hasFlag(v14297, v14298);
    }
    var isOptional$$2 = v4793;
    var go$$2 = false;
    var foundSymbol = false;
    var v14299 = isConstructor$$3;
    if (v14299) {
      var v20025 = funcDecl$$22.fncFlags;
      var v23681 = TypeScript$$24.FncFlags;
      var v20026 = v23681.ClassMethod;
      v14299 = TypeScript$$24.hasFlag(v20025, v20026);
    }
    var v4795 = v14299;
    if (v4795) {
      containerSym = containerSym.container;
      var v4794 = scopeChain$$9.previous;
      containerScope = v4794.scope;
    }
    var v14300 = context$$58.checker;
    var v4796 = v14300.locationInfo;
    funcDecl$$22.unitIndex = v4796.unitIndex;
    var v26448 = funcDecl$$22.isConstructor;
    var v26130 = !v26448;
    if (v26130) {
      v26130 = containerSym;
    }
    var v25409 = v26130;
    if (v25409) {
      v25409 = containerSym.declAST;
    }
    var v23682 = v25409;
    if (v23682) {
      var v26131 = containerSym.declAST;
      var v25410 = v26131.nodeType;
      var v26132 = TypeScript$$24.NodeType;
      var v25411 = v26132.FuncDecl;
      v23682 = v25410 == v25411;
    }
    var v20027 = v23682;
    if (v20027) {
      var v23683 = containerSym.declAST;
      v20027 = v23683.isConstructor;
    }
    var v14301 = v20027;
    if (v14301) {
      var v20028 = funcDecl$$22.isMethod();
      v14301 = !v20028;
    }
    var v4797 = v14301;
    if (v4797) {
      return go$$2;
    }
    var v14302 = funcDecl$$22.fncFlags;
    var v20029 = TypeScript$$24.FncFlags;
    var v14303 = v20029.Signature;
    var v4831 = TypeScript$$24.hasFlag(v14302, v14303);
    if (v4831) {
      var v4798 = context$$58.scopeChain;
      var instType$$1 = v4798.thisType;
      var v14304 = nameText$$3;
      if (v14304) {
        v14304 = nameText$$3 != "__missing";
      }
      var v4802 = v14304;
      if (v4802) {
        if (isStatic$$9) {
          var v20030 = containerSym.type;
          var v14305 = v20030.members;
          var v4799 = v14305.allMembers;
          fgSym$$3 = v4799.lookup(nameText$$3);
        } else {
          fgSym$$3 = containerScope.findLocal(nameText$$3, false, false);
          var v4800 = fgSym$$3 == null;
          if (v4800) {
            fgSym$$3 = containerScope.findLocal(nameText$$3, false, true);
          }
        }
        if (fgSym$$3) {
          foundSymbol = true;
          var v20031 = funcDecl$$22.isSignature();
          var v14306 = !v20031;
          if (v14306) {
            var v23684 = funcDecl$$22.fncFlags;
            var v25412 = TypeScript$$24.FncFlags;
            var v23685 = v25412.Ambient;
            var v20032 = TypeScript$$24.hasFlag(v23684, v23685);
            var v23686 = fgSym$$3.flags;
            var v25413 = TypeScript$$24.SymbolFlags;
            var v23687 = v25413.Ambient;
            var v20033 = TypeScript$$24.hasFlag(v23686, v23687);
            v14306 = v20032 != v20033;
          }
          var v4801 = v14306;
          if (v4801) {
            fgSym$$3 = null;
          }
        }
      }
      var v4811 = fgSym$$3 == null;
      if (v4811) {
        var v14307 = funcDecl$$22.isSpecialFn();
        var v4805 = !v14307;
        if (v4805) {
          var v23688 = context$$58.checker;
          var v23689 = !foundSymbol;
          var v20034 = v23688.createFunctionSignature(funcDecl$$22, containerSym, containerScope, null, v23689);
          var v14308 = v20034.declAST;
          var v4803 = v14308.type;
          fgSym$$3 = v4803.symbol;
        } else {
          var v23690 = context$$58.checker;
          var v20035 = v23690.createFunctionSignature(funcDecl$$22, containerSym, containerScope, containerSym, false);
          var v14309 = v20035.declAST;
          var v4804 = v14309.type;
          fgSym$$3 = v4804.symbol;
        }
        var v20036 = fgSym$$3.declAST;
        var v14310 = v20036 == null;
        var v20038 = !v14310;
        if (v20038) {
          var v20037 = funcDecl$$22.isSpecialFn();
          v14310 = !v20037;
        }
        var v4806 = v14310;
        if (v4806) {
          fgSym$$3.declAST = ast$$72;
        }
      } else {
        var v14311 = fgSym$$3.kind();
        var v20039 = TypeScript$$24.SymbolKind;
        var v14312 = v20039.Type;
        var v4810 = v14311 == v14312;
        if (v4810) {
          var v23691 = context$$58.checker;
          var v20040 = v23691.createFunctionSignature(funcDecl$$22, containerSym, containerScope, fgSym$$3, false);
          var v14313 = v20040.declAST;
          var v4807 = v14313.type;
          fgSym$$3 = v4807.symbol;
        } else {
          var v14314 = context$$58.checker;
          var v4808 = v14314.errorReporter;
          var v23692 = funcDecl$$22.name;
          var v20041 = v23692.actualText;
          var v14315 = "Function or method '" + v20041;
          var v4809 = v14315 + "' already declared as a property";
          v4808.simpleError(funcDecl$$22, v4809);
        }
      }
      var v14316 = funcDecl$$22.isSpecialFn();
      if (v14316) {
        v14316 = !isStatic$$9;
      }
      var v4813 = v14316;
      if (v4813) {
        var v4812;
        if (instType$$1) {
          v4812 = instType$$1;
        } else {
          v4812 = fgSym$$3.type;
        }
        funcDecl$$22.type = v4812;
      } else {
        funcDecl$$22.type = fgSym$$3.type;
      }
    } else {
      if (nameText$$3) {
        if (isStatic$$9) {
          var v20042 = containerSym.type;
          var v14317 = v20042.members;
          var v4814 = v14317.allMembers;
          fgSym$$3 = v4814.lookup(nameText$$3);
        } else {
          var v14318 = funcDecl$$22.isConstructor;
          if (v14318) {
            var v20043 = context$$58.scopeChain;
            v14318 = v20043.previous;
          }
          var v4816 = v14318;
          if (v4816) {
            var v20044 = context$$58.scopeChain;
            var v14319 = v20044.previous;
            var v4815 = v14319.scope;
            fgSym$$3 = v4815.findLocal(nameText$$3, false, false);
          }
          var v4817 = fgSym$$3 == null;
          if (v4817) {
            fgSym$$3 = containerScope.findLocal(nameText$$3, false, false);
          }
        }
        if (fgSym$$3) {
          foundSymbol = true;
          var v23693 = !isConstructor$$3;
          if (v23693) {
            var v26133 = fgSym$$3.declAST;
            var v25414 = v26133.nodeType;
            var v26134 = TypeScript$$24.NodeType;
            var v25415 = v26134.FuncDecl;
            v23693 = v25414 == v25415;
          }
          var v20045 = v23693;
          if (v20045) {
            var v25416 = fgSym$$3.declAST;
            var v23694 = v25416.isAccessor();
            v20045 = !v23694;
          }
          var v14320 = v20045;
          if (v14320) {
            var v23695 = fgSym$$3.declAST;
            var v20046 = v23695.isSignature();
            v14320 = !v20046;
          }
          var v4818 = v14320;
          if (v4818) {
            fgSym$$3 = null;
            foundSymbol = false;
          }
        }
      }
      var v26449 = fgSym$$3;
      if (v26449) {
        var v26608 = fgSym$$3.isAccessor();
        v26449 = !v26608;
      }
      var v26135 = v26449;
      if (v26135) {
        v26135 = fgSym$$3.type;
      }
      var v25417 = v26135;
      if (v25417) {
        var v26136 = fgSym$$3.type;
        v25417 = v26136.construct;
      }
      var v23696 = v25417;
      if (v23696) {
        var v26450 = fgSym$$3.type;
        var v26137 = v26450.construct;
        var v25418 = v26137.signatures;
        v23696 = v25418 != [];
      }
      var v20047 = v23696;
      if (v20047) {
        var v26689 = fgSym$$3.type;
        var v26609 = v26689.construct;
        var v26451 = v26609.signatures;
        var v26138 = v26451[0];
        var v25419 = v26138.declAST;
        var v23697 = v25419 == null;
        var v25421 = !v23697;
        if (v25421) {
          var v26749 = fgSym$$3.type;
          var v26730 = v26749.construct;
          var v26690 = v26730.signatures;
          var v26610 = v26690[0];
          var v26452 = v26610.declAST;
          var v26139 = v26452.fncFlags;
          var v26453 = TypeScript$$24.FncFlags;
          var v26140 = v26453.Ambient;
          var v25420 = TypeScript$$24.hasFlag(v26139, v26140);
          v23697 = !v25420;
        }
        v20047 = v23697;
      }
      var v14321 = v20047;
      if (v14321) {
        var v20048 = funcDecl$$22.isConstructor;
        v14321 = !v20048;
      }
      var v4820 = v14321;
      if (v4820) {
        var v14322 = context$$58.checker;
        var v4819 = v14322.errorReporter;
        v4819.simpleError(funcDecl$$22, "Functions may not have class overloads");
      }
      var v25422 = fgSym$$3;
      if (v25422) {
        var v26454 = fgSym$$3.kind();
        var v26611 = TypeScript$$24.SymbolKind;
        var v26455 = v26611.Type;
        var v26141 = v26454 == v26455;
        v25422 = !v26141;
      }
      var v23698 = v25422;
      if (v23698) {
        v23698 = funcDecl$$22.isMethod();
      }
      var v20049 = v23698;
      if (v20049) {
        var v23699 = funcDecl$$22.isAccessor();
        v20049 = !v23699;
      }
      var v14323 = v20049;
      if (v14323) {
        var v20050 = funcDecl$$22.isConstructor;
        v14323 = !v20050;
      }
      var v4824 = v14323;
      if (v4824) {
        var v14324 = context$$58.checker;
        var v4821 = v14324.errorReporter;
        var v23700 = funcDecl$$22.name;
        var v20051 = v23700.actualText;
        var v14325 = "Function or method '" + v20051;
        var v4822 = v14325 + "' already declared as a property";
        v4821.simpleError(funcDecl$$22, v4822);
        var v4823 = context$$58.checker;
        fgSym$$3.type = v4823.anyType;
      }
      var v4825 = context$$58.checker;
      var v4826 = !foundSymbol;
      var sig$$2 = v4825.createFunctionSignature(funcDecl$$22, containerSym, containerScope, fgSym$$3, v4826);
      var v23701 = !fgSym$$3;
      var v25425 = !v23701;
      if (v25425) {
        var v26142 = fgSym$$3.declAST;
        var v25423 = v26142.nodeType;
        var v26143 = TypeScript$$24.NodeType;
        var v25424 = v26143.FuncDecl;
        v23701 = v25423 != v25424;
      }
      var v20052 = v23701;
      if (v20052) {
        v20052 = funcDecl$$22.isAccessor();
      }
      var v14326 = v20052;
      var v20054 = !v14326;
      if (v20054) {
        var v20053 = fgSym$$3;
        if (v20053) {
          v20053 = fgSym$$3.isAccessor();
        }
        v14326 = v20053;
      }
      var v4828 = v14326;
      if (v4828) {
        var v4827 = funcDecl$$22;
        var v14327 = context$$58.checker;
        var v14328 = containerSym.type;
        var v20055 = funcDecl$$22.isMethod();
        if (v20055) {
          v20055 = isStatic$$9;
        }
        var v14329 = v20055;
        var v26934 = v14327.createAccessorSymbol(funcDecl$$22, fgSym$$3, v14328, v14329, true, containerScope, containerSym);
        v4827.accessorSymbol = v26934;
      }
      var v14330 = funcDecl$$22.type;
      var v4829 = v14330.symbol;
      v4829.declAST = ast$$72;
      var v4830 = funcDecl$$22.isConstructor;
      if (v4830) {
        go$$2 = true;
      }
    }
    if (isExported$$6) {
      var v14331 = funcDecl$$22.type;
      var v4833 = v14331.call;
      if (v4833) {
        var v14332 = funcDecl$$22.type;
        var v4832 = v14332.symbol;
        var v20056 = v4832.flags;
        var v23702 = TypeScript$$24.SymbolFlags;
        var v20057 = v23702.Exported;
        v4832.flags = v20056 | v20057;
      }
      var v23703 = fgSym$$3;
      if (v23703) {
        var v25426 = fgSym$$3.isAccessor();
        v23703 = !v25426;
      }
      var v20058 = v23703;
      if (v20058) {
        var v23704 = fgSym$$3.kind();
        var v25427 = TypeScript$$24.SymbolKind;
        var v23705 = v25427.Type;
        v20058 = v23704 == v23705;
      }
      var v14333 = v20058;
      if (v14333) {
        var v20059 = fgSym$$3.type;
        v14333 = v20059.call;
      }
      var v4834 = v14333;
      if (v4834) {
        var v14334 = fgSym$$3.flags;
        var v20060 = TypeScript$$24.SymbolFlags;
        var v14335 = v20060.Exported;
        fgSym$$3.flags = v14334 | v14335;
      }
    }
    var v20061 = context$$58.scopeChain;
    var v14336 = v20061.moduleDecl;
    if (v14336) {
      var v20062 = funcDecl$$22.isSpecialFn();
      v14336 = !v20062;
    }
    var v4837 = v14336;
    if (v4837) {
      var v14337 = funcDecl$$22.type;
      var v4835 = v14337.symbol;
      var v20063 = v4835.flags;
      var v23706 = TypeScript$$24.SymbolFlags;
      var v20064 = v23706.ModuleMember;
      v4835.flags = v20063 | v20064;
      var v14338 = funcDecl$$22.type;
      var v4836 = v14338.symbol;
      var v14339 = context$$58.scopeChain;
      v4836.declModule = v14339.moduleDecl;
    }
    var v4838 = fgSym$$3 && isOptional$$2;
    if (v4838) {
      var v14340 = fgSym$$3.flags;
      var v20065 = TypeScript$$24.SymbolFlags;
      var v14341 = v20065.Optional;
      fgSym$$3.flags = v14340 | v14341;
    }
    return go$$2;
  }
  function preCollectTypes(ast$$73, parent$$61, walker$$46) {
    var context$$59 = walker$$46.state;
    var go$$3 = false;
    var scopeChain$$10 = context$$59.scopeChain;
    var v14342 = ast$$73.nodeType;
    var v20066 = TypeScript$$24.NodeType;
    var v14343 = v20066.Script;
    var v4851 = v14342 == v14343;
    if (v4851) {
      var script$$15 = ast$$73;
      context$$59.script = script$$15;
      go$$3 = true;
    } else {
      var v14344 = ast$$73.nodeType;
      var v20067 = TypeScript$$24.NodeType;
      var v14345 = v20067.List;
      var v4850 = v14344 == v14345;
      if (v4850) {
        go$$3 = true;
      } else {
        var v14346 = ast$$73.nodeType;
        var v20068 = TypeScript$$24.NodeType;
        var v14347 = v20068.ImportDeclaration;
        var v4849 = v14346 == v14347;
        if (v4849) {
          go$$3 = preCollectImportTypes(ast$$73, parent$$61, context$$59);
        } else {
          var v14348 = ast$$73.nodeType;
          var v20069 = TypeScript$$24.NodeType;
          var v14349 = v20069.With;
          var v4848 = v14348 == v14349;
          if (v4848) {
            go$$3 = false;
          } else {
            var v14350 = ast$$73.nodeType;
            var v20070 = TypeScript$$24.NodeType;
            var v14351 = v20070.ModuleDeclaration;
            var v4847 = v14350 == v14351;
            if (v4847) {
              go$$3 = preCollectModuleTypes(ast$$73, parent$$61, context$$59);
            } else {
              var v14352 = ast$$73.nodeType;
              var v20071 = TypeScript$$24.NodeType;
              var v14353 = v20071.ClassDeclaration;
              var v4846 = v14352 == v14353;
              if (v4846) {
                go$$3 = preCollectClassTypes(ast$$73, parent$$61, context$$59);
              } else {
                var v14354 = ast$$73.nodeType;
                var v20072 = TypeScript$$24.NodeType;
                var v14355 = v20072.Block;
                var v4845 = v14354 == v14355;
                if (v4845) {
                  go$$3 = true;
                } else {
                  var v14356 = ast$$73.nodeType;
                  var v20073 = TypeScript$$24.NodeType;
                  var v14357 = v20073.InterfaceDeclaration;
                  var v4844 = v14356 == v14357;
                  if (v4844) {
                    go$$3 = preCollectInterfaceTypes(ast$$73, parent$$61, context$$59);
                  } else {
                    var v14358 = ast$$73.nodeType;
                    var v20074 = TypeScript$$24.NodeType;
                    var v14359 = v20074.ArgDecl;
                    var v4843 = v14358 == v14359;
                    if (v4843) {
                      go$$3 = preCollectArgDeclTypes(ast$$73, parent$$61, context$$59);
                    } else {
                      var v14360 = ast$$73.nodeType;
                      var v20075 = TypeScript$$24.NodeType;
                      var v14361 = v20075.VarDecl;
                      var v4842 = v14360 == v14361;
                      if (v4842) {
                        go$$3 = preCollectVarDeclTypes(ast$$73, parent$$61, context$$59);
                      } else {
                        var v14362 = ast$$73.nodeType;
                        var v20076 = TypeScript$$24.NodeType;
                        var v14363 = v20076.FuncDecl;
                        var v4841 = v14362 == v14363;
                        if (v4841) {
                          go$$3 = preCollectFuncDeclTypes(ast$$73, parent$$61, context$$59);
                        } else {
                          var v14364 = ast$$73.isStatementOrExpression();
                          if (v14364) {
                            var v20077 = context$$59.scopeChain;
                            v14364 = v20077.moduleDecl;
                          }
                          var v4840 = v14364;
                          if (v4840) {
                            var v14365 = context$$59.scopeChain;
                            var v4839 = v14365.moduleDecl;
                            v4839.recordNonInterface();
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    var v4852 = walker$$46.options;
    v4852.goChildren = go$$3;
    return ast$$73;
  }
  function postCollectTypes(ast$$74, parent$$62, walker$$47) {
    var context$$60 = walker$$47.state;
    var v14366 = ast$$74.nodeType;
    var v20078 = TypeScript$$24.NodeType;
    var v14367 = v20078.ModuleDeclaration;
    var v4855 = v14366 == v14367;
    if (v4855) {
      TypeScript$$24.popTypeCollectionScope(context$$60);
    } else {
      var v14368 = ast$$74.nodeType;
      var v20079 = TypeScript$$24.NodeType;
      var v14369 = v20079.ClassDeclaration;
      var v4854 = v14368 == v14369;
      if (v4854) {
        TypeScript$$24.popTypeCollectionScope(context$$60);
      } else {
        var v14370 = ast$$74.nodeType;
        var v20080 = TypeScript$$24.NodeType;
        var v14371 = v20080.InterfaceDeclaration;
        var v4853 = v14370 == v14371;
        if (v4853) {
          TypeScript$$24.popTypeCollectionScope(context$$60);
        }
      }
    }
    return ast$$74;
  }
  var Continuation = v966();
  TypeScript$$24.Continuation = Continuation;
  TypeScript$$24.createNewConstructGroupForType = createNewConstructGroupForType;
  TypeScript$$24.cloneParentConstructGroupForChildType = cloneParentConstructGroupForChildType;
  TypeScript$$24.globalId = "__GLO";
  TypeScript$$24.preCollectImportTypes = preCollectImportTypes;
  TypeScript$$24.preCollectModuleTypes = preCollectModuleTypes;
  TypeScript$$24.preCollectClassTypes = preCollectClassTypes;
  TypeScript$$24.preCollectInterfaceTypes = preCollectInterfaceTypes;
  TypeScript$$24.preCollectArgDeclTypes = preCollectArgDeclTypes;
  TypeScript$$24.preCollectVarDeclTypes = preCollectVarDeclTypes;
  TypeScript$$24.preCollectFuncDeclTypes = preCollectFuncDeclTypes;
  TypeScript$$24.preCollectTypes = preCollectTypes;
  TypeScript$$24.postCollectTypes = postCollectTypes;
  return;
}
function v964(TypeScript$$23) {
  function v963() {
    function v962(sourceSig, targetSig, assignableTo$$2, comparisonCache$$2, comparisonInfo$$11) {
      var v20081 = sourceSig.parameters;
      var v14372 = !v20081;
      var v20083 = !v14372;
      if (v20083) {
        var v20082 = targetSig.parameters;
        v14372 = !v20082;
      }
      var v4856 = v14372;
      if (v4856) {
        return false;
      }
      var v4857;
      var v14374 = targetSig.hasVariableArgList;
      if (v14374) {
        var v14373 = targetSig.nonOptionalParameterCount;
        v4857 = v14373 - 1;
      } else {
        v4857 = targetSig.nonOptionalParameterCount;
      }
      var targetVarArgCount = v4857;
      var v4858;
      var v14376 = sourceSig.hasVariableArgList;
      if (v14376) {
        var v14375 = sourceSig.nonOptionalParameterCount;
        v4858 = v14375 - 1;
      } else {
        v4858 = sourceSig.nonOptionalParameterCount;
      }
      var sourceVarArgCount = v4858;
      var v14377 = sourceVarArgCount > targetVarArgCount;
      if (v14377) {
        var v20084 = targetSig.hasVariableArgList;
        v14377 = !v20084;
      }
      var v4860 = v14377;
      if (v4860) {
        if (comparisonInfo$$11) {
          var v14378 = comparisonInfo$$11.flags;
          var v20085 = TypeScript$$23.TypeRelationshipFlags;
          var v14379 = v20085.SourceSignatureHasTooManyParameters;
          comparisonInfo$$11.flags = v14378 | v14379;
          var v14380 = "Call signature expects " + targetVarArgCount;
          var v4859 = v14380 + " or fewer parameters";
          comparisonInfo$$11.addMessageToFront(v4859);
        }
        return false;
      }
      var v4861 = sourceSig.returnType;
      var sourceReturnType = v4861.type;
      var v4862 = targetSig.returnType;
      var targetReturnType = v4862.type;
      var v14381 = this.voidType;
      var v4864 = targetReturnType != v14381;
      if (v4864) {
        var v14382 = this.sourceIsRelatableToTarget(sourceReturnType, targetReturnType, assignableTo$$2, comparisonCache$$2, comparisonInfo$$11);
        var v4863 = !v14382;
        if (v4863) {
          if (comparisonInfo$$11) {
            var v14383 = comparisonInfo$$11.flags;
            var v20086 = TypeScript$$23.TypeRelationshipFlags;
            var v14384 = v20086.IncompatibleReturnTypes;
            comparisonInfo$$11.flags = v14383 | v14384;
          }
          return false;
        }
      }
      var v4865;
      var v20087 = sourceVarArgCount < targetVarArgCount;
      if (v20087) {
        v20087 = sourceSig.hasVariableArgList;
      }
      var v14385 = v20087;
      if (v14385) {
        v4865 = targetVarArgCount;
      } else {
        v4865 = sourceVarArgCount;
      }
      var len$$29 = v4865;
      var sourceParamType = null;
      var targetParamType = null;
      var sourceParamName = "";
      var targetParamName = "";
      var iSource = 0;
      var iTarget = 0;
      var v4881 = iSource < len$$29;
      for (;v4881;) {
        var v20088 = sourceSig.hasVariableArgList;
        var v14386 = !v20088;
        var v20089 = !v14386;
        if (v20089) {
          v14386 = iSource < sourceVarArgCount;
        }
        var v4872 = v14386;
        if (v4872) {
          var v23707 = sourceSig.parameters;
          var v20090 = v23707[iSource];
          var v14387 = v20090.parameter;
          var v4866 = v14387.typeLink;
          sourceParamType = v4866.type;
          var v23708 = sourceSig.parameters;
          var v20091 = v23708[iSource];
          var v14388 = v20091.parameter;
          var v4867 = v14388.symbol;
          sourceParamName = v4867.name;
        } else {
          var v4871 = iSource == sourceVarArgCount;
          if (v4871) {
            var v23709 = sourceSig.parameters;
            var v20092 = v23709[iSource];
            var v14389 = v20092.parameter;
            var v4868 = v14389.typeLink;
            sourceParamType = v4868.type;
            var v4869 = sourceParamType.elementType;
            if (v4869) {
              sourceParamType = sourceParamType.elementType;
            }
            var v23710 = sourceSig.parameters;
            var v20093 = v23710[iSource];
            var v14390 = v20093.parameter;
            var v4870 = v14390.symbol;
            sourceParamName = v4870.name;
          }
        }
        var v23711 = targetSig.parameters;
        var v20094 = v23711.length;
        var v14391 = iTarget < v20094;
        if (v14391) {
          v14391 = iTarget < targetVarArgCount;
        }
        var v4879 = v14391;
        if (v4879) {
          var v23712 = targetSig.parameters;
          var v20095 = v23712[iTarget];
          var v14392 = v20095.parameter;
          var v4873 = v14392.typeLink;
          targetParamType = v4873.type;
          var v23713 = targetSig.parameters;
          var v20096 = v23713[iTarget];
          var v14393 = v20096.parameter;
          var v4874 = v14393.symbol;
          targetParamName = v4874.name;
        } else {
          var v14394 = targetSig.hasVariableArgList;
          if (v14394) {
            v14394 = iTarget == targetVarArgCount;
          }
          var v4878 = v14394;
          if (v4878) {
            var v23714 = targetSig.parameters;
            var v20097 = v23714[iTarget];
            var v14395 = v20097.parameter;
            var v4875 = v14395.typeLink;
            targetParamType = v4875.type;
            var v4876 = targetParamType.elementType;
            if (v4876) {
              targetParamType = targetParamType.elementType;
            }
            var v23715 = targetSig.parameters;
            var v20098 = v23715[iTarget];
            var v14396 = v20098.parameter;
            var v4877 = v14396.symbol;
            targetParamName = v4877.name;
          }
        }
        var v20099 = this.sourceIsRelatableToTarget(sourceParamType, targetParamType, assignableTo$$2, comparisonCache$$2, comparisonInfo$$11);
        var v23716 = !v20099;
        if (v23716) {
          v20099 = this.sourceIsRelatableToTarget(targetParamType, sourceParamType, assignableTo$$2, comparisonCache$$2, comparisonInfo$$11);
        }
        var v14397 = v20099;
        var v4880 = !v14397;
        if (v4880) {
          if (comparisonInfo$$11) {
            var v14398 = comparisonInfo$$11.flags;
            var v20100 = TypeScript$$23.TypeRelationshipFlags;
            var v14399 = v20100.IncompatibleParameterTypes;
            comparisonInfo$$11.flags = v14398 | v14399;
          }
          return false;
        }
        iSource = iSource + 1;
        iTarget = iTarget + 1;
        v4881 = iSource < len$$29;
      }
      return true;
    }
    function v961(sourceSG, targetSG, assignableTo$$1, comparisonCache$$1, comparisonInfo$$10) {
      var v4882 = sourceSG == targetSG;
      if (v4882) {
        return true;
      }
      var v14400 = sourceSG && targetSG;
      var v4883 = !v14400;
      if (v4883) {
        return false;
      }
      var mSig = null;
      var nSig = null;
      var foundMatch = false;
      var iMSig = 0;
      var v20101 = targetSG.signatures;
      var v14401 = v20101.length;
      var v4888 = iMSig < v14401;
      for (;v4888;) {
        var v4884 = targetSG.signatures;
        mSig = v4884[iMSig];
        var iNSig = 0;
        var v20102 = sourceSG.signatures;
        var v14402 = v20102.length;
        var v4887 = iNSig < v14402;
        for (;v4887;) {
          var v4885 = sourceSG.signatures;
          nSig = v4885[iNSig];
          var v4886 = this.signatureIsRelatableToTarget(nSig, mSig, assignableTo$$1, comparisonCache$$1, comparisonInfo$$10);
          if (v4886) {
            foundMatch = true;
            break;
          }
          iNSig = iNSig + 1;
          var v20103 = sourceSG.signatures;
          var v14403 = v20103.length;
          v4887 = iNSig < v14403;
        }
        if (foundMatch) {
          foundMatch = false;
          iMSig = iMSig + 1;
          var v20104 = targetSG.signatures;
          var v14404 = v20104.length;
          v4888 = iMSig < v14404;
          continue;
        }
        return false;
      }
      return true;
    }
    function v960(source$$3, target$$33, assignableTo, comparisonCache, comparisonInfo$$9) {
      var v4889 = source$$3 == target$$33;
      if (v4889) {
        return true;
      }
      var v14405 = source$$3 && target$$33;
      var v4890 = !v14405;
      if (v4890) {
        return true;
      }
      var v14406 = source$$3.typeID;
      var v4891 = v14406 << 16;
      var v4892 = target$$33.typeID;
      var comboId$$1 = v4891 | v4892;
      var v14407 = comparisonCache[comboId$$1];
      var v4893 = v14407 != undefined;
      if (v4893) {
        return true;
      }
      if (assignableTo) {
        var v20105 = this.anyType;
        var v14408 = source$$3 == v20105;
        var v20107 = !v14408;
        if (v20107) {
          var v20106 = this.anyType;
          v14408 = target$$33 == v20106;
        }
        var v4894 = v14408;
        if (v4894) {
          return true;
        }
      } else {
        var v14409 = this.anyType;
        var v4895 = target$$33 == v14409;
        if (v4895) {
          return true;
        }
      }
      var v14410 = this.undefinedType;
      var v4896 = source$$3 == v14410;
      if (v4896) {
        return true;
      }
      var v20108 = this.nullType;
      var v14411 = source$$3 == v20108;
      if (v14411) {
        var v23717 = this.undefinedType;
        var v20109 = target$$33 != v23717;
        if (v20109) {
          var v23718 = this.voidType;
          v20109 = target$$33 != v23718;
        }
        v14411 = v20109;
      }
      var v4897 = v14411;
      if (v4897) {
        return true;
      }
      var v20110 = this.numberType;
      var v14412 = target$$33 == v20110;
      if (v14412) {
        var v20111 = source$$3.typeFlags;
        var v23719 = TypeScript$$23.TypeFlags;
        var v20112 = v23719.IsEnum;
        v14412 = v20111 & v20112;
      }
      var v4898 = v14412;
      if (v4898) {
        return true;
      }
      var v20113 = this.numberType;
      var v14413 = source$$3 == v20113;
      if (v14413) {
        var v20114 = target$$33.typeFlags;
        var v23720 = TypeScript$$23.TypeFlags;
        var v20115 = v23720.IsEnum;
        v14413 = v20114 & v20115;
      }
      var v4899 = v14413;
      if (v4899) {
        return true;
      }
      var v20116 = source$$3.typeFlags;
      var v23721 = TypeScript$$23.TypeFlags;
      var v20117 = v23721.IsEnum;
      var v14414 = v20116 & v20117;
      var v20120 = !v14414;
      if (v20120) {
        var v20118 = target$$33.typeFlags;
        var v23722 = TypeScript$$23.TypeFlags;
        var v20119 = v23722.IsEnum;
        v14414 = v20118 & v20119;
      }
      var v4900 = v14414;
      if (v4900) {
        return false;
      }
      var v14415 = source$$3.isArray();
      var v20121 = !v14415;
      if (v20121) {
        v14415 = target$$33.isArray();
      }
      var v4904 = v14415;
      if (v4904) {
        var v20122 = source$$3.isArray();
        if (v20122) {
          v20122 = target$$33.isArray();
        }
        var v14416 = v20122;
        var v4901 = !v14416;
        if (v4901) {
          return false;
        }
        comparisonCache[comboId$$1] = false;
        var v4902 = source$$3.elementType;
        var v4903 = target$$33.elementType;
        var ret$$1 = this.sourceIsRelatableToTarget(v4902, v4903, assignableTo, comparisonCache, comparisonInfo$$9);
        if (ret$$1) {
          comparisonCache[comboId$$1] = true;
        } else {
          comparisonCache[comboId$$1] = undefined;
        }
        return ret$$1;
      }
      var v14417 = source$$3.primitiveTypeClass;
      var v14418 = target$$33.primitiveTypeClass;
      var v4912 = v14417 != v14418;
      if (v4912) {
        var v14419 = target$$33.primitiveTypeClass;
        var v20123 = TypeScript$$23.Primitive;
        var v14420 = v20123.None;
        var v4911 = v14419 == v14420;
        if (v4911) {
          var v20124 = this.numberType;
          var v14421 = source$$3 == v20124;
          if (v14421) {
            var v20125 = this.typeFlow;
            v14421 = v20125.numberInterfaceType;
          }
          var v4910 = v14421;
          if (v4910) {
            var v4905 = this.typeFlow;
            source$$3 = v4905.numberInterfaceType;
          } else {
            var v20126 = this.stringType;
            var v14422 = source$$3 == v20126;
            if (v14422) {
              var v20127 = this.typeFlow;
              v14422 = v20127.stringInterfaceType;
            }
            var v4909 = v14422;
            if (v4909) {
              var v4906 = this.typeFlow;
              source$$3 = v4906.stringInterfaceType;
            } else {
              var v20128 = this.booleanType;
              var v14423 = source$$3 == v20128;
              if (v14423) {
                var v20129 = this.typeFlow;
                v14423 = v20129.booleanInterfaceType;
              }
              var v4908 = v14423;
              if (v4908) {
                var v4907 = this.typeFlow;
                source$$3 = v4907.booleanInterfaceType;
              } else {
                return false;
              }
            }
          }
        } else {
          return false;
        }
      }
      comparisonCache[comboId$$1] = false;
      var v4913 = source$$3.hasBase(target$$33);
      if (v4913) {
        comparisonCache[comboId$$1] = true;
        return true;
      }
      var v20130 = this.typeFlow;
      var v14424 = v20130.objectInterfaceType;
      if (v14424) {
        var v23723 = this.typeFlow;
        var v20131 = v23723.objectInterfaceType;
        v14424 = target$$33 == v20131;
      }
      var v4914 = v14424;
      if (v4914) {
        return true;
      }
      var v23724 = this.typeFlow;
      var v20132 = v23724.functionInterfaceType;
      if (v20132) {
        var v23725 = source$$3.call;
        var v25428 = !v23725;
        if (v25428) {
          v23725 = source$$3.construct;
        }
        v20132 = v23725;
      }
      var v14425 = v20132;
      if (v14425) {
        var v23726 = this.typeFlow;
        var v20133 = v23726.functionInterfaceType;
        v14425 = target$$33 == v20133;
      }
      var v4915 = v14425;
      if (v4915) {
        return true;
      }
      var v14426 = target$$33.isClass();
      var v20134 = !v14426;
      if (v20134) {
        v14426 = target$$33.isClassInstance();
      }
      var v4916 = v14426;
      if (v4916) {
        comparisonCache[comboId$$1] = undefined;
        return false;
      }
      var v14427 = target$$33.memberScope;
      if (v14427) {
        v14427 = source$$3.memberScope;
      }
      var v4946 = v14427;
      if (v4946) {
        var v4917 = target$$33.memberScope;
        var mPropKeys = v4917.getAllValueSymbolNames(true);
        var mProp = null;
        var nProp = null;
        var mPropType = null;
        var nPropType = null;
        var inferenceSymbol = null;
        var iMProp = 0;
        var v14428 = mPropKeys.length;
        var v4945 = iMProp < v14428;
        for (;v4945;) {
          var v4918 = target$$33.memberScope;
          var v4919 = mPropKeys[iMProp];
          mProp = v4918.find(v4919, false, false);
          var v4920 = source$$3.memberScope;
          var v4921 = mPropKeys[iMProp];
          nProp = v4920.find(v4921, false, false);
          var v26144 = mProp.name;
          var v25429 = v26144 == "arguments";
          if (v25429) {
            var v26145 = this.typeFlow;
            v25429 = v26145.iargumentsInterfaceType;
          }
          var v23727 = v25429;
          if (v23727) {
            var v26612 = this.typeFlow;
            var v26456 = v26612.iargumentsInterfaceType;
            var v26146 = v26456.symbol;
            var v25430 = v26146.flags;
            var v26147 = TypeScript$$23.SymbolFlags;
            var v25431 = v26147.CompilerGenerated;
            v23727 = v25430 & v25431;
          }
          var v20135 = v23727;
          if (v20135) {
            var v23728 = mProp.kind();
            var v25432 = TypeScript$$23.SymbolKind;
            var v23729 = v25432.Variable;
            v20135 = v23728 == v23729;
          }
          var v14429 = v20135;
          if (v14429) {
            var v25433 = mProp.variable;
            var v23730 = v25433.typeLink;
            var v20136 = v23730.type;
            var v23731 = this.typeFlow;
            var v20137 = v23731.iargumentsInterfaceType;
            v14429 = v20136 == v20137;
          }
          var v4922 = v14429;
          if (v4922) {
            iMProp = iMProp + 1;
            var v14430 = mPropKeys.length;
            v4945 = iMProp < v14430;
            continue;
          }
          var v4926 = mProp.isInferenceSymbol();
          if (v4926) {
            inferenceSymbol = mProp;
            var v14431 = inferenceSymbol.typeCheckStatus;
            var v20138 = TypeScript$$23.TypeCheckStatus;
            var v14432 = v20138.NotStarted;
            var v4925 = v14431 == v14432;
            if (v4925) {
              var v4923 = this.typeFlow;
              var v4924 = mProp.declAST;
              v4923.typeCheck(v4924);
            }
          }
          mPropType = mProp.getType();
          var v4937 = !nProp;
          if (v4937) {
            var v14433 = this.typeFlow;
            var v4929 = v14433.objectInterfaceType;
            if (v4929) {
              var v20139 = this.typeFlow;
              var v14434 = v20139.objectInterfaceType;
              var v4927 = v14434.memberScope;
              var v4928 = mPropKeys[iMProp];
              nProp = v4927.find(v4928, false, false);
            }
            var v4936 = !nProp;
            if (v4936) {
              var v20140 = this.typeFlow;
              var v14435 = v20140.functionInterfaceType;
              if (v14435) {
                var v20141 = mPropType.call;
                var v23732 = !v20141;
                if (v23732) {
                  v20141 = mPropType.construct;
                }
                v14435 = v20141;
              }
              var v4932 = v14435;
              if (v4932) {
                var v20142 = this.typeFlow;
                var v14436 = v20142.functionInterfaceType;
                var v4930 = v14436.memberScope;
                var v4931 = mPropKeys[iMProp];
                nProp = v4930.find(v4931, false, false);
              }
              var v4935 = !nProp;
              if (v4935) {
                var v20143 = mProp.flags;
                var v23733 = TypeScript$$23.SymbolFlags;
                var v20144 = v23733.Optional;
                var v14437 = v20143 & v20144;
                var v4934 = !v14437;
                if (v4934) {
                  comparisonCache[comboId$$1] = undefined;
                  if (comparisonInfo$$9) {
                    var v14438 = comparisonInfo$$9.flags;
                    var v20145 = TypeScript$$23.TypeRelationshipFlags;
                    var v14439 = v20145.RequiredPropertyIsMissing;
                    comparisonInfo$$9.flags = v14438 | v14439;
                    var v26457 = source$$3.getTypeName();
                    var v26148 = "Type '" + v26457;
                    var v25434 = v26148 + "' is missing property '";
                    var v25435 = mPropKeys[iMProp];
                    var v23734 = v25434 + v25435;
                    var v20146 = v23734 + "' from type '";
                    var v20147 = target$$33.getTypeName();
                    var v14440 = v20146 + v20147;
                    var v4933 = v14440 + "'";
                    comparisonInfo$$9.addMessageToFront(v4933);
                  }
                  return false;
                } else {
                  iMProp = iMProp + 1;
                  var v14441 = mPropKeys.length;
                  v4945 = iMProp < v14441;
                  continue;
                }
              }
            }
          }
          var v4941 = nProp.isInferenceSymbol();
          if (v4941) {
            inferenceSymbol = nProp;
            var v14442 = inferenceSymbol.typeCheckStatus;
            var v20148 = TypeScript$$23.TypeCheckStatus;
            var v14443 = v20148.NotStarted;
            var v4940 = v14442 == v14443;
            if (v4940) {
              var v4938 = this.typeFlow;
              var v4939 = nProp.declAST;
              v4938.typeCheck(v4939);
            }
          }
          nPropType = nProp.getType();
          var v14444 = mPropType && nPropType;
          if (v14444) {
            var v26149 = nPropType.typeID;
            var v25436 = v26149 << 16;
            var v25437 = mPropType.typeID;
            var v23735 = v25436 | v25437;
            var v20149 = comparisonCache[v23735];
            v14444 = v20149 != undefined;
          }
          var v4942 = v14444;
          if (v4942) {
            iMProp = iMProp + 1;
            var v14445 = mPropKeys.length;
            v4945 = iMProp < v14445;
            continue;
          }
          var v14446 = this.sourceIsRelatableToTarget(nPropType, mPropType, assignableTo, comparisonCache, comparisonInfo$$9);
          var v4944 = !v14446;
          if (v4944) {
            comparisonCache[comboId$$1] = undefined;
            if (comparisonInfo$$9) {
              var v14447 = comparisonInfo$$9.flags;
              var v20150 = TypeScript$$23.TypeRelationshipFlags;
              var v14448 = v20150.IncompatiblePropertyTypes;
              comparisonInfo$$9.flags = v14447 | v14448;
              var v26458 = mProp.name;
              var v26150 = "Types of property '" + v26458;
              var v25438 = v26150 + "' of types '";
              var v25439 = source$$3.getTypeName();
              var v23736 = v25438 + v25439;
              var v20151 = v23736 + "' and '";
              var v20152 = target$$33.getTypeName();
              var v14449 = v20151 + v20152;
              var v4943 = v14449 + "' are incompatible";
              comparisonInfo$$9.addMessageToFront(v4943);
            }
            return false;
          }
          iMProp = iMProp + 1;
          var v14450 = mPropKeys.length;
          v4945 = iMProp < v14450;
        }
      }
      var v14451 = source$$3.call;
      var v20153 = !v14451;
      if (v20153) {
        v14451 = target$$33.call;
      }
      var v4953 = v14451;
      if (v4953) {
        var v20154 = source$$3.call;
        var v20155 = target$$33.call;
        var v14452 = this.signatureGroupIsRelatableToTarget(v20154, v20155, assignableTo, comparisonCache, comparisonInfo$$9);
        var v4952 = !v14452;
        if (v4952) {
          if (comparisonInfo$$9) {
            var v14453 = source$$3.call;
            if (v14453) {
              v14453 = target$$33.call;
            }
            var v4951 = v14453;
            if (v4951) {
              var v25440 = source$$3.getTypeName();
              var v23737 = "Call signatures of types '" + v25440;
              var v20156 = v23737 + "' and '";
              var v20157 = target$$33.getTypeName();
              var v14454 = v20156 + v20157;
              var v4947 = v14454 + "' are incompatible";
              comparisonInfo$$9.addMessageToFront(v4947);
            } else {
              var v4948;
              var v14455 = target$$33.call;
              if (v14455) {
                v4948 = target$$33.getTypeName();
              } else {
                v4948 = source$$3.getTypeName();
              }
              var hasSig = v4948;
              var v4949;
              var v20158 = target$$33.call;
              var v14456 = !v20158;
              if (v14456) {
                v4949 = target$$33.getTypeName();
              } else {
                v4949 = source$$3.getTypeName();
              }
              var lacksSig = v4949;
              var v23738 = "Type '" + hasSig;
              var v20159 = v23738 + "' requires a call signature, but Type '";
              var v14457 = v20159 + lacksSig;
              var v4950 = v14457 + "' lacks one";
              comparisonInfo$$9.setMessage(v4950);
            }
            var v14458 = comparisonInfo$$9.flags;
            var v20160 = TypeScript$$23.TypeRelationshipFlags;
            var v14459 = v20160.IncompatibleSignatures;
            comparisonInfo$$9.flags = v14458 | v14459;
          }
          comparisonCache[comboId$$1] = undefined;
          return false;
        }
      }
      var v14460 = source$$3.construct;
      var v20161 = !v14460;
      if (v20161) {
        v14460 = target$$33.construct;
      }
      var v4960 = v14460;
      if (v4960) {
        var v20162 = source$$3.construct;
        var v20163 = target$$33.construct;
        var v14461 = this.signatureGroupIsRelatableToTarget(v20162, v20163, assignableTo, comparisonCache, comparisonInfo$$9);
        var v4959 = !v14461;
        if (v4959) {
          if (comparisonInfo$$9) {
            var v14462 = source$$3.construct;
            if (v14462) {
              v14462 = target$$33.construct;
            }
            var v4958 = v14462;
            if (v4958) {
              var v25441 = source$$3.getTypeName();
              var v23739 = "Construct signatures of types '" + v25441;
              var v20164 = v23739 + "' and '";
              var v20165 = target$$33.getTypeName();
              var v14463 = v20164 + v20165;
              var v4954 = v14463 + "' are incompatible";
              comparisonInfo$$9.addMessageToFront(v4954);
            } else {
              var v4955;
              var v14464 = target$$33.construct;
              if (v14464) {
                v4955 = target$$33.getTypeName();
              } else {
                v4955 = source$$3.getTypeName();
              }
              hasSig = v4955;
              var v4956;
              var v20166 = target$$33.construct;
              var v14465 = !v20166;
              if (v14465) {
                v4956 = target$$33.getTypeName();
              } else {
                v4956 = source$$3.getTypeName();
              }
              lacksSig = v4956;
              var v23740 = "Type '" + hasSig;
              var v20167 = v23740 + "' requires a construct signature, but Type '";
              var v14466 = v20167 + lacksSig;
              var v4957 = v14466 + "' lacks one";
              comparisonInfo$$9.setMessage(v4957);
            }
            var v14467 = comparisonInfo$$9.flags;
            var v20168 = TypeScript$$23.TypeRelationshipFlags;
            var v14468 = v20168.IncompatibleSignatures;
            comparisonInfo$$9.flags = v14467 | v14468;
          }
          comparisonCache[comboId$$1] = undefined;
          return false;
        }
      }
      var v4965 = target$$33.index;
      if (v4965) {
        var v4961;
        var v23741 = target$$33.index;
        var v20169 = !v23741;
        if (v20169) {
          var v23742 = this.typeFlow;
          v20169 = v23742.objectInterfaceType;
        }
        var v14470 = v20169;
        if (v14470) {
          var v20170 = this.typeFlow;
          var v14469 = v20170.objectInterfaceType;
          v4961 = v14469.index;
        } else {
          v4961 = target$$33.index;
        }
        var targetIndex = v4961;
        var v4962;
        var v23743 = source$$3.index;
        var v20171 = !v23743;
        if (v20171) {
          var v23744 = this.typeFlow;
          v20171 = v23744.objectInterfaceType;
        }
        var v14472 = v20171;
        if (v14472) {
          var v20172 = this.typeFlow;
          var v14471 = v20172.objectInterfaceType;
          v4962 = v14471.index;
        } else {
          v4962 = source$$3.index;
        }
        var sourceIndex = v4962;
        var v14473 = this.signatureGroupIsRelatableToTarget(sourceIndex, targetIndex, assignableTo, comparisonCache, comparisonInfo$$9);
        var v4964 = !v14473;
        if (v4964) {
          if (comparisonInfo$$9) {
            var v25442 = source$$3.getTypeName();
            var v23745 = "Index signatures of types '" + v25442;
            var v20173 = v23745 + "' and '";
            var v20174 = target$$33.getTypeName();
            var v14474 = v20173 + v20174;
            var v4963 = v14474 + "' are incompatible";
            comparisonInfo$$9.addMessageToFront(v4963);
            var v14475 = comparisonInfo$$9.flags;
            var v20175 = TypeScript$$23.TypeRelationshipFlags;
            var v14476 = v20175.IncompatibleSignatures;
            comparisonInfo$$9.flags = v14475 | v14476;
          }
          comparisonCache[comboId$$1] = undefined;
          return false;
        }
      }
      comparisonCache[comboId$$1] = true;
      return true;
    }
    function v959(s1$$2, s2$$2, comparisonInfo$$8) {
      var v4966 = this.assignableCache;
      return this.signatureIsRelatableToTarget(s1$$2, s2$$2, true, v4966, comparisonInfo$$8);
    }
    function v958(sg1$$2, sg2$$2, comparisonInfo$$7) {
      var v4967 = this.assignableCache;
      return this.signatureGroupIsRelatableToTarget(sg1$$2, sg2$$2, true, v4967, comparisonInfo$$7);
    }
    function v957(source$$2, target$$32, comparisonInfo$$6) {
      var v4968 = this.assignableCache;
      return this.sourceIsRelatableToTarget(source$$2, target$$32, true, v4968, comparisonInfo$$6);
    }
    function v956(s1$$1, s2$$1, comparisonInfo$$5) {
      var v4969 = this.subtypeCache;
      return this.signatureIsRelatableToTarget(s1$$1, s2$$1, false, v4969, comparisonInfo$$5);
    }
    function v955(sg1$$1, sg2$$1, comparisonInfo$$4) {
      var v4970 = this.subtypeCache;
      return this.signatureGroupIsRelatableToTarget(sg1$$1, sg2$$1, false, v4970, comparisonInfo$$4);
    }
    function v954(source$$1, target$$31, comparisonInfo$$3) {
      var v4971 = this.subtypeCache;
      return this.sourceIsRelatableToTarget(source$$1, target$$31, false, v4971, comparisonInfo$$3);
    }
    function v953(s1, s2) {
      var v14477 = s1.hasVariableArgList;
      var v14478 = s2.hasVariableArgList;
      var v4972 = v14477 != v14478;
      if (v4972) {
        return false;
      }
      var v14479 = s1.nonOptionalParameterCount;
      var v14480 = s2.nonOptionalParameterCount;
      var v4973 = v14479 != v14480;
      if (v4973) {
        return false;
      }
      var v20176 = s1.parameters;
      var v14481 = v20176.length;
      var v20177 = s2.parameters;
      var v14482 = v20177.length;
      var v4974 = v14481 != v14482;
      if (v4974) {
        return false;
      }
      var v23746 = s1.returnType;
      var v20178 = v23746.type;
      var v23747 = s2.returnType;
      var v20179 = v23747.type;
      var v14483 = this.typesAreIdentical(v20178, v20179);
      var v4975 = !v14483;
      if (v4975) {
        return false;
      }
      var iParam = 0;
      var v20180 = s1.parameters;
      var v14484 = v20180.length;
      var v4977 = iParam < v14484;
      for (;v4977;) {
        var v26459 = s1.parameters;
        var v26151 = v26459[iParam];
        var v25443 = v26151.parameter;
        var v23748 = v25443.typeLink;
        var v20181 = v23748.type;
        var v26460 = s2.parameters;
        var v26152 = v26460[iParam];
        var v25444 = v26152.parameter;
        var v23749 = v25444.typeLink;
        var v20182 = v23749.type;
        var v14485 = this.typesAreIdentical(v20181, v20182);
        var v4976 = !v14485;
        if (v4976) {
          return false;
        }
        iParam = iParam + 1;
        var v20183 = s1.parameters;
        var v14486 = v20183.length;
        v4977 = iParam < v14486;
      }
      return true;
    }
    function v952(sg1, sg2) {
      var v4978 = sg1 == sg2;
      if (v4978) {
        return true;
      }
      var v14487 = !sg1;
      var v20184 = !v14487;
      if (v20184) {
        v14487 = !sg2;
      }
      var v4979 = v14487;
      if (v4979) {
        return false;
      }
      var v20185 = sg1.signatures;
      var v14488 = v20185.length;
      var v20186 = sg2.signatures;
      var v14489 = v20186.length;
      var v4980 = v14488 != v14489;
      if (v4980) {
        return false;
      }
      var sig1 = null;
      var sig2 = null;
      var sigsMatch = false;
      var iSig1 = 0;
      var v20187 = sg1.signatures;
      var v14490 = v20187.length;
      var v4985 = iSig1 < v14490;
      for (;v4985;) {
        var v4981 = sg1.signatures;
        sig1 = v4981[iSig1];
        var iSig2 = 0;
        var v20188 = sg2.signatures;
        var v14491 = v20188.length;
        var v4984 = iSig2 < v14491;
        for (;v4984;) {
          var v4982 = sg2.signatures;
          sig2 = v4982[iSig2];
          var v4983 = this.signaturesAreIdentical(sig1, sig2);
          if (v4983) {
            sigsMatch = true;
            break;
          }
          iSig2 = iSig2 + 1;
          var v20189 = sg2.signatures;
          var v14492 = v20189.length;
          v4984 = iSig2 < v14492;
        }
        if (sigsMatch) {
          sigsMatch = false;
          iSig1 = iSig1 + 1;
          var v20190 = sg1.signatures;
          var v14493 = v20190.length;
          v4985 = iSig1 < v14493;
          continue;
        }
        return false;
      }
      return true;
    }
    function v951(t1$$1, t2$$1) {
      var v4986 = t1$$1 == t2$$1;
      if (v4986) {
        return true;
      }
      var v14494 = !t1$$1;
      var v20191 = !v14494;
      if (v20191) {
        v14494 = !t2$$1;
      }
      var v4987 = v14494;
      if (v4987) {
        return false;
      }
      var v14495 = t1$$1.isClass();
      var v20192 = !v14495;
      if (v20192) {
        v14495 = t1$$1.isClassInstance();
      }
      var v4988 = v14495;
      if (v4988) {
        return false;
      }
      var v14496 = t2$$1.typeID;
      var v4989 = v14496 << 16;
      var v4990 = t1$$1.typeID;
      var comboId = v4989 | v4990;
      var v14497 = this.identicalCache;
      var v4991 = v14497[comboId];
      if (v4991) {
        return true;
      }
      var v20193 = t1$$1.typeFlags;
      var v23750 = TypeScript$$23.TypeFlags;
      var v20194 = v23750.IsEnum;
      var v14498 = v20193 & v20194;
      var v20197 = !v14498;
      if (v20197) {
        var v20195 = t2$$1.typeFlags;
        var v23751 = TypeScript$$23.TypeFlags;
        var v20196 = v23751.IsEnum;
        v14498 = v20195 & v20196;
      }
      var v4992 = v14498;
      if (v4992) {
        return false;
      }
      var v14499 = t1$$1.isArray();
      var v20198 = !v14499;
      if (v20198) {
        v14499 = t2$$1.isArray();
      }
      var v4999 = v14499;
      if (v4999) {
        var v20199 = t1$$1.isArray();
        if (v20199) {
          v20199 = t2$$1.isArray();
        }
        var v14500 = v20199;
        var v4993 = !v14500;
        if (v4993) {
          return false;
        }
        var v4994 = this.identicalCache;
        v4994[comboId] = false;
        var v4995 = t1$$1.elementType;
        var v4996 = t2$$1.elementType;
        var ret = this.typesAreIdentical(v4995, v4996);
        if (ret) {
          var v4997 = this.subtypeCache;
          v4997[comboId] = true;
        } else {
          var v4998 = this.subtypeCache;
          v4998[comboId] = undefined;
        }
        return ret;
      }
      var v14501 = t1$$1.primitiveTypeClass;
      var v14502 = t2$$1.primitiveTypeClass;
      var v5000 = v14501 != v14502;
      if (v5000) {
        return false;
      }
      var v5001 = this.identicalCache;
      v5001[comboId] = false;
      var v14503 = t1$$1.memberScope;
      if (v14503) {
        v14503 = t2$$1.memberScope;
      }
      var v5020 = v14503;
      if (v5020) {
        var v14504 = t1$$1.memberScope;
        var v5002 = v14504.getAllValueSymbolNames(true);
        var t1MemberKeys = v5002.sort();
        var v14505 = t2$$1.memberScope;
        var v5003 = v14505.getAllValueSymbolNames(true);
        var t2MemberKeys = v5003.sort();
        var v14506 = t1MemberKeys.length;
        var v14507 = t2MemberKeys.length;
        var v5005 = v14506 != v14507;
        if (v5005) {
          var v5004 = this.identicalCache;
          v5004[comboId] = undefined;
          return false;
        }
        var t1MemberSymbol = null;
        var t2MemberSymbol = null;
        var t1MemberType = null;
        var t2MemberType = null;
        var iMember$$1 = 0;
        var v14508 = t1MemberKeys.length;
        var v5017 = iMember$$1 < v14508;
        for (;v5017;) {
          var v14509 = t1MemberKeys[iMember$$1];
          var v14510 = t2MemberKeys[iMember$$1];
          var v5007 = v14509 != v14510;
          if (v5007) {
            var v5006 = this.identicalCache;
            v5006[comboId] = undefined;
            return false;
          }
          var v5008 = t1$$1.memberScope;
          var v5009 = t1MemberKeys[iMember$$1];
          t1MemberSymbol = v5008.find(v5009, false, false);
          var v5010 = t2$$1.memberScope;
          var v5011 = t2MemberKeys[iMember$$1];
          t2MemberSymbol = v5010.find(v5011, false, false);
          var v20200 = t1MemberSymbol.flags;
          var v23752 = TypeScript$$23.SymbolFlags;
          var v20201 = v23752.Optional;
          var v14511 = v20200 & v20201;
          var v20202 = t2MemberSymbol.flags;
          var v23753 = TypeScript$$23.SymbolFlags;
          var v20203 = v23753.Optional;
          var v14512 = v20202 & v20203;
          var v5013 = v14511 != v14512;
          if (v5013) {
            var v5012 = this.identicalCache;
            v5012[comboId] = undefined;
            return false;
          }
          t1MemberType = t1MemberSymbol.getType();
          t2MemberType = t2MemberSymbol.getType();
          var v14513 = t1MemberType && t2MemberType;
          if (v14513) {
            var v23754 = this.identicalCache;
            var v26153 = t2MemberType.typeID;
            var v25445 = v26153 << 16;
            var v25446 = t1MemberType.typeID;
            var v23755 = v25445 | v25446;
            var v20204 = v23754[v23755];
            v14513 = v20204 != undefined;
          }
          var v5014 = v14513;
          if (v5014) {
            iMember$$1 = iMember$$1 + 1;
            var v14514 = t1MemberKeys.length;
            v5017 = iMember$$1 < v14514;
            continue;
          }
          var v14515 = this.typesAreIdentical(t1MemberType, t2MemberType);
          var v5016 = !v14515;
          if (v5016) {
            var v5015 = this.identicalCache;
            v5015[comboId] = undefined;
            return false;
          }
          iMember$$1 = iMember$$1 + 1;
          var v14516 = t1MemberKeys.length;
          v5017 = iMember$$1 < v14516;
        }
      } else {
        var v14517 = t1$$1.memberScope;
        var v20205 = !v14517;
        if (v20205) {
          v14517 = t2$$1.memberScope;
        }
        var v5019 = v14517;
        if (v5019) {
          var v5018 = this.identicalCache;
          v5018[comboId] = undefined;
          return false;
        }
      }
      var v20206 = t1$$1.call;
      var v20207 = t2$$1.call;
      var v14518 = this.signatureGroupsAreIdentical(v20206, v20207);
      var v5022 = !v14518;
      if (v5022) {
        var v5021 = this.identicalCache;
        v5021[comboId] = undefined;
        return false;
      }
      var v20208 = t1$$1.construct;
      var v20209 = t2$$1.construct;
      var v14519 = this.signatureGroupsAreIdentical(v20208, v20209);
      var v5024 = !v14519;
      if (v5024) {
        var v5023 = this.identicalCache;
        v5023[comboId] = undefined;
        return false;
      }
      var v20210 = t1$$1.index;
      var v20211 = t2$$1.index;
      var v14520 = this.signatureGroupsAreIdentical(v20210, v20211);
      var v5026 = !v14520;
      if (v5026) {
        var v5025 = this.identicalCache;
        v5025[comboId] = undefined;
        return false;
      }
      var v5027 = this.identicalCache;
      v5027[comboId] = true;
      return true;
    }
    function v950(initialType, targetType$$4, collection$$1, acceptVoid, comparisonInfo$$2) {
      var i$$82 = 0;
      var len$$28 = collection$$1.getLength();
      var nlastChecked = 0;
      var bestCommonType = initialType;
      if (targetType$$4) {
        var v5028;
        if (bestCommonType) {
          v5028 = bestCommonType.mergeOrdered(targetType$$4, this, acceptVoid);
        } else {
          v5028 = targetType$$4;
        }
        bestCommonType = v5028;
      }
      var convergenceType = bestCommonType;
      var v5035 = nlastChecked < len$$28;
      for (;v5035;) {
        i$$82 = 0;
        var v5032 = i$$82 < len$$28;
        for (;v5032;) {
          var v5029 = i$$82 == nlastChecked;
          if (v5029) {
            i$$82 = i$$82 + 1;
            v5032 = i$$82 < len$$28;
            continue;
          }
          var v14521 = convergenceType;
          if (v14521) {
            var v20212 = collection$$1.getTypeAtIndex(i$$82);
            v14521 = bestCommonType = convergenceType.mergeOrdered(v20212, this, acceptVoid, comparisonInfo$$2);
          }
          var v5030 = v14521;
          if (v5030) {
            convergenceType = bestCommonType;
          }
          var v20213 = this.anyType;
          var v14522 = bestCommonType == v20213;
          var v20214 = !v14522;
          if (v20214) {
            v14522 = bestCommonType == null;
          }
          var v5031 = v14522;
          if (v5031) {
            break;
          } else {
            if (targetType$$4) {
              collection$$1.setTypeAtIndex(i$$82, targetType$$4);
            }
          }
          i$$82 = i$$82 + 1;
          v5032 = i$$82 < len$$28;
        }
        var v5033 = convergenceType && bestCommonType;
        if (v5033) {
          break;
        }
        nlastChecked = nlastChecked + 1;
        var v5034 = nlastChecked < len$$28;
        if (v5034) {
          convergenceType = collection$$1.getTypeAtIndex(nlastChecked);
        }
        v5035 = nlastChecked < len$$28;
      }
      var v5036;
      if (acceptVoid) {
        v5036 = bestCommonType;
      } else {
        var v14523;
        var v23756 = this.voidType;
        var v20215 = bestCommonType == v23756;
        if (v20215) {
          v14523 = null;
        } else {
          v14523 = bestCommonType;
        }
        v5036 = v14523;
      }
      return v5036;
    }
    function v949(t$$1) {
      var v14524 = this.undefinedType;
      var v5037 = t$$1 == v14524;
      var v14526 = !v5037;
      if (v14526) {
        var v14525 = this.nullType;
        v5037 = t$$1 == v14525;
      }
      return v5037;
    }
    function v948(t) {
      var v20216 = this.undefinedType;
      var v14527 = t == v20216;
      var v20218 = !v14527;
      if (v20218) {
        var v20217 = this.nullType;
        v14527 = t == v20217;
      }
      var v5038 = v14527;
      if (v5038) {
        return this.anyType;
      }
      return t;
    }
    function v947(targetType$$3, objectLit$$1) {
      var v20219 = this.typeFlow;
      var v14528 = v20219.objectInterfaceType;
      var v5039 = targetType$$3 == v14528;
      if (v5039) {
        return true;
      }
      var memberDecls = objectLit$$1.operand;
      var v20220 = memberDecls;
      if (v20220) {
        v20220 = targetType$$3.memberScope;
      }
      var v14529 = v20220;
      var v5040 = !v14529;
      if (v5040) {
        return false;
      }
      var id$$19 = null;
      var targetMember = null;
      var text$$23 = "";
      var foundSyms = {};
      var i$$81 = 0;
      var v20221 = memberDecls.members;
      var v14530 = v20221.length;
      var v5047 = i$$81 < v14530;
      for (;v5047;) {
        var v14531 = memberDecls.members;
        var v5041 = v14531[i$$81];
        id$$19 = v5041.operand1;
        var v14532 = id$$19.nodeType;
        var v20222 = TypeScript$$23.NodeType;
        var v14533 = v20222.Name;
        var v5044 = v14532 == v14533;
        if (v5044) {
          text$$23 = id$$19.text;
        } else {
          var v14534 = id$$19.nodeType;
          var v20223 = TypeScript$$23.NodeType;
          var v14535 = v20223.QString;
          var v5043 = v14534 == v14535;
          if (v5043) {
            var idText$$3 = id$$19.text;
            var v14536 = idText$$3.length;
            var v5042 = v14536 - 1;
            text$$23 = idText$$3.substring(1, v5042);
          } else {
            return false;
          }
        }
        var v5045 = targetType$$3.memberScope;
        targetMember = v5045.find(text$$23, true, false);
        var v5046 = !targetMember;
        if (v5046) {
          return false;
        }
        foundSyms[text$$23] = true;
        i$$81 = i$$81 + 1;
        var v20224 = memberDecls.members;
        var v14537 = v20224.length;
        v5047 = i$$81 < v14537;
      }
      var v5048 = targetType$$3.memberScope;
      var targetMembers = v5048.getAllValueSymbolNames(true);
      i$$81 = 0;
      var v14538 = targetMembers.length;
      var v5051 = i$$81 < v14538;
      for (;v5051;) {
        var memberName$$2 = targetMembers[i$$81];
        var v5049 = targetType$$3.memberScope;
        var memberSym = v5049.find(memberName$$2, true, false);
        var v23757 = targetMembers[i$$81];
        var v20225 = foundSyms[v23757];
        var v14539 = !v20225;
        if (v14539) {
          var v23758 = memberSym.flags;
          var v25447 = TypeScript$$23.SymbolFlags;
          var v23759 = v25447.Optional;
          var v20226 = TypeScript$$23.hasFlag(v23758, v23759);
          v14539 = !v20226;
        }
        var v5050 = v14539;
        if (v5050) {
          return false;
        }
        i$$81 = i$$81 + 1;
        var v14540 = targetMembers.length;
        v5051 = i$$81 < v14540;
      }
      return true;
    }
    function v946(candidateType, funcDecl$$21, beStringent) {
      var v23760 = funcDecl$$21.isParenthesized;
      var v25448 = !v23760;
      if (v25448) {
        v23760 = funcDecl$$21.isMethod();
      }
      var v20227 = v23760;
      var v23762 = !v20227;
      if (v23762) {
        var v23761 = beStringent;
        if (v23761) {
          v23761 = funcDecl$$21.returnTypeAnnotation;
        }
        v20227 = v23761;
      }
      var v14541 = v20227;
      var v20228 = !v14541;
      if (v20228) {
        v14541 = funcDecl$$21.isInlineCallLiteral;
      }
      var v5052 = v14541;
      if (v5052) {
        return false;
      }
      var v5053 = beStringent;
      var v14543 = !v5053;
      if (v14543) {
        var v20229 = this.typeFlow;
        var v14542 = v20229.functionInterfaceType;
        v5053 = v14542 == candidateType;
      }
      beStringent = v5053;
      var v5054 = !beStringent;
      if (v5054) {
        return true;
      }
      var v14544 = funcDecl$$21.signature;
      var v5058 = !v14544;
      if (v5058) {
        var v20230 = this.typeFlow;
        var v14545 = v20230.scope;
        var v5055 = v14545.container;
        var v14546 = this.typeFlow;
        var v5056 = v14546.scope;
        this.createFunctionSignature(funcDecl$$21, v5055, v5056, null, null);
        var v5057 = this.typeFlow;
        v5057.typeCheck(funcDecl$$21);
      }
      var signature$$5 = funcDecl$$21.signature;
      var v5059 = signature$$5.parameters;
      var paramLen$$2 = v5059.length;
      var i$$80 = 0;
      var v5062 = i$$80 < paramLen$$2;
      for (;v5062;) {
        var v5060 = signature$$5.parameters;
        var param$$6 = v5060[i$$80];
        var symbol$$13 = param$$6;
        var argDecl = symbol$$13.declAST;
        var v14547 = beStringent;
        if (v14547) {
          v14547 = argDecl.typeExpr;
        }
        var v5061 = v14547;
        if (v5061) {
          return false;
        }
        i$$80 = i$$80 + 1;
        v5062 = i$$80 < paramLen$$2;
      }
      var v14548 = candidateType.construct;
      if (v14548) {
        v14548 = candidateType.call;
      }
      var v5063 = v14548;
      if (v5063) {
        return false;
      }
      var v5064;
      var v14549 = candidateType.construct;
      if (v14549) {
        v5064 = candidateType.construct;
      } else {
        v5064 = candidateType.call;
      }
      var candidateSigs = v5064;
      var v14550 = !candidateSigs;
      var v20232 = !v14550;
      if (v20232) {
        var v23763 = candidateSigs.signatures;
        var v20231 = v23763.length;
        v14550 = v20231 > 1;
      }
      var v5065 = v14550;
      if (v5065) {
        return false;
      }
      return true;
    }
    function v945(signatures$$3, args$$13, comparisonInfo$$1) {
      var applicableSigs = [];
      var memberType = null;
      var miss = false;
      var cxt = null;
      var hadProvisionalErrors = false;
      var i$$79 = 0;
      var v14551 = signatures$$3.length;
      var v5093 = i$$79 < v14551;
      for (;v5093;) {
        miss = false;
        var j$$10 = 0;
        var v20233 = args$$13.members;
        var v14552 = v20233.length;
        var v5090 = j$$10 < v14552;
        for (;v5090;) {
          var v23764 = signatures$$3[i$$79];
          var v20234 = v23764.parameters;
          var v14553 = v20234.length;
          var v5066 = j$$10 >= v14553;
          if (v5066) {
            j$$10 = j$$10 + 1;
            var v20235 = args$$13.members;
            var v14554 = v20235.length;
            v5090 = j$$10 < v14554;
            continue;
          }
          var v20236 = signatures$$3[i$$79];
          var v14555 = v20236.parameters;
          var v5067 = v14555[j$$10];
          memberType = v5067.getType();
          var v25449 = signatures$$3[i$$79];
          var v23765 = v25449.declAST;
          var v20237 = v23765.variableArgList;
          if (v20237) {
            var v26154 = signatures$$3[i$$79];
            var v25450 = v26154.nonOptionalParameterCount;
            var v23766 = v25450 - 1;
            v20237 = j$$10 >= v23766;
          }
          var v14556 = v20237;
          if (v14556) {
            v14556 = memberType.isArray();
          }
          var v5068 = v14556;
          if (v5068) {
            memberType = memberType.elementType;
          }
          var v14557 = this.anyType;
          var v5089 = memberType == v14557;
          if (v5089) {
          } else {
            var v23767 = args$$13.members;
            var v20238 = v23767[j$$10];
            var v14558 = v20238.nodeType;
            var v20239 = TypeScript$$23.NodeType;
            var v14559 = v20239.FuncDecl;
            var v5088 = v14558 == v14559;
            if (v5088) {
              var v20240 = this.typeFlow;
              var v14560 = v20240.functionInterfaceType;
              if (v14560) {
                var v23768 = this.typeFlow;
                var v20241 = v23768.functionInterfaceType;
                v14560 = memberType == v20241;
              }
              var v5069 = v14560;
              if (v5069) {
                j$$10 = j$$10 + 1;
                var v20242 = args$$13.members;
                var v14561 = v20242.length;
                v5090 = j$$10 < v14561;
                continue;
              }
              var v23769 = args$$13.members;
              var v20243 = v23769[j$$10];
              var v14562 = this.canContextuallyTypeFunction(memberType, v20243, true);
              var v5077 = !v14562;
              if (v5077) {
                var v20244 = args$$13.members;
                var v14563 = v20244[j$$10];
                var v5073 = this.canContextuallyTypeFunction(memberType, v14563, false);
                if (v5073) {
                  var v5070 = this.typeFlow;
                  var v14564 = args$$13.members;
                  var v5071 = v14564[j$$10];
                  v5070.typeCheck(v5071);
                  var v25451 = args$$13.members;
                  var v23770 = v25451[j$$10];
                  var v20245 = v23770.type;
                  var v14565 = this.sourceIsAssignableToTarget(v20245, memberType, comparisonInfo$$1);
                  var v5072 = !v14565;
                  if (v5072) {
                    break;
                  }
                } else {
                  break;
                }
              } else {
                var v14566 = args$$13.members;
                var v5074 = v14566[j$$10];
                this.typeCheckWithContextualType(memberType, true, true, v5074);
                this.cleanStartedPTO();
                hadProvisionalErrors = this.hadProvisionalErrors();
                var v25452 = args$$13.members;
                var v23771 = v25452[j$$10];
                var v20246 = v23771.type;
                var v14567 = this.sourceIsAssignableToTarget(v20246, memberType, comparisonInfo$$1);
                var v5076 = !v14567;
                if (v5076) {
                  if (comparisonInfo$$1) {
                    var v26461 = memberType.getTypeName();
                    var v26155 = "Could not apply type '" + v26461;
                    var v25453 = v26155 + "' to argument ";
                    var v25454 = j$$10 + 1;
                    var v23772 = v25453 + v25454;
                    var v20247 = v23772 + ", which is of type '";
                    var v26156 = args$$13.members;
                    var v25455 = v26156[j$$10];
                    var v23773 = v25455.type;
                    var v20248 = v23773.getTypeName();
                    var v14568 = v20247 + v20248;
                    var v5075 = v14568 + "'";
                    comparisonInfo$$1.setMessage(v5075);
                  }
                  miss = true;
                }
                this.resetProvisionalErrors();
                if (miss) {
                  break;
                }
              }
            } else {
              var v23774 = args$$13.members;
              var v20249 = v23774[j$$10];
              var v14569 = v20249.nodeType;
              var v20250 = TypeScript$$23.NodeType;
              var v14570 = v20250.ObjectLit;
              var v5087 = v14569 == v14570;
              if (v5087) {
                var v20251 = this.typeFlow;
                var v14571 = v20251.objectInterfaceType;
                if (v14571) {
                  var v23775 = this.typeFlow;
                  var v20252 = v23775.objectInterfaceType;
                  v14571 = memberType == v20252;
                }
                var v5078 = v14571;
                if (v5078) {
                  j$$10 = j$$10 + 1;
                  var v20253 = args$$13.members;
                  var v14572 = v20253.length;
                  v5090 = j$$10 < v14572;
                  continue;
                }
                var v14573 = args$$13.members;
                var v5079 = v14573[j$$10];
                this.typeCheckWithContextualType(memberType, true, true, v5079);
                this.cleanStartedPTO();
                hadProvisionalErrors = this.hadProvisionalErrors();
                var v25456 = args$$13.members;
                var v23776 = v25456[j$$10];
                var v20254 = v23776.type;
                var v14574 = this.sourceIsAssignableToTarget(v20254, memberType, comparisonInfo$$1);
                var v5081 = !v14574;
                if (v5081) {
                  if (comparisonInfo$$1) {
                    var v26462 = memberType.getTypeName();
                    var v26157 = "Could not apply type '" + v26462;
                    var v25457 = v26157 + "' to argument ";
                    var v25458 = j$$10 + 1;
                    var v23777 = v25457 + v25458;
                    var v20255 = v23777 + ", which is of type '";
                    var v26158 = args$$13.members;
                    var v25459 = v26158[j$$10];
                    var v23778 = v25459.type;
                    var v20256 = v23778.getTypeName();
                    var v14575 = v20255 + v20256;
                    var v5080 = v14575 + "'";
                    comparisonInfo$$1.setMessage(v5080);
                  }
                  miss = true;
                }
                this.resetProvisionalErrors();
                if (miss) {
                  break;
                }
              } else {
                var v23779 = args$$13.members;
                var v20257 = v23779[j$$10];
                var v14576 = v20257.nodeType;
                var v20258 = TypeScript$$23.NodeType;
                var v14577 = v20258.ArrayLit;
                var v5086 = v14576 == v14577;
                if (v5086) {
                  var v20259 = this.typeFlow;
                  var v14578 = v20259.arrayInterfaceType;
                  if (v14578) {
                    var v23780 = this.typeFlow;
                    var v20260 = v23780.arrayInterfaceType;
                    v14578 = memberType == v20260;
                  }
                  var v5082 = v14578;
                  if (v5082) {
                    j$$10 = j$$10 + 1;
                    var v20261 = args$$13.members;
                    var v14579 = v20261.length;
                    v5090 = j$$10 < v14579;
                    continue;
                  }
                  var v14580 = args$$13.members;
                  var v5083 = v14580[j$$10];
                  this.typeCheckWithContextualType(memberType, true, true, v5083);
                  this.cleanStartedPTO();
                  hadProvisionalErrors = this.hadProvisionalErrors();
                  var v25460 = args$$13.members;
                  var v23781 = v25460[j$$10];
                  var v20262 = v23781.type;
                  var v14581 = this.sourceIsAssignableToTarget(v20262, memberType, comparisonInfo$$1);
                  var v5085 = !v14581;
                  if (v5085) {
                    if (comparisonInfo$$1) {
                      var v26463 = memberType.getTypeName();
                      var v26159 = "Could not apply type '" + v26463;
                      var v25461 = v26159 + "' to argument ";
                      var v25462 = j$$10 + 1;
                      var v23782 = v25461 + v25462;
                      var v20263 = v23782 + ", which is of type '";
                      var v26160 = args$$13.members;
                      var v25463 = v26160[j$$10];
                      var v23783 = v25463.type;
                      var v20264 = v23783.getTypeName();
                      var v14582 = v20263 + v20264;
                      var v5084 = v14582 + "'";
                      comparisonInfo$$1.setMessage(v5084);
                    }
                    break;
                  }
                  this.resetProvisionalErrors();
                  if (miss) {
                    break;
                  }
                }
              }
            }
          }
          j$$10 = j$$10 + 1;
          var v20265 = args$$13.members;
          var v14583 = v20265.length;
          v5090 = j$$10 < v14583;
        }
        var v20266 = args$$13.members;
        var v14584 = v20266.length;
        var v5092 = j$$10 == v14584;
        if (v5092) {
          var v5091 = applicableSigs.length;
          var v14585 = signatures$$3[i$$79];
          applicableSigs[v5091] = {signature:v14585, hadProvisionalErrors:hadProvisionalErrors};
        }
        hadProvisionalErrors = false;
        i$$79 = i$$79 + 1;
        var v14586 = signatures$$3.length;
        v5093 = i$$79 < v14586;
      }
      return applicableSigs;
    }
    function v944(signatures$$2, args$$12) {
      function v943(index$$51) {
        var v5094;
        if (index$$51) {
          var v20267 = Q.signature;
          var v14587 = v20267.returnType;
          v5094 = v14587.type;
        } else {
          var v20268 = best.signature;
          var v14588 = v20268.returnType;
          v5094 = v14588.type;
        }
        return v5094;
      }
      function v942(index$$50, type$$43) {
        return;
      }
      function v941() {
        return 2;
      }
      var v14589 = signatures$$2.length;
      var v5096 = v14589 == 1;
      if (v5096) {
        var v14590 = signatures$$2[0];
        var v5095 = v14590.signature;
        return{sig:v5095, ambiguous:false};
      }
      var best = signatures$$2[0];
      var Q = null;
      var AType = null;
      var PType = null;
      var QType = null;
      var ambiguous = false;
      var qSig = 1;
      var v14591 = signatures$$2.length;
      var v5110 = qSig < v14591;
      for (;v5110;) {
        Q = signatures$$2[qSig];
        var i$$78 = 0;
        i$$78 = 0;
        var v14592 = args$$12;
        if (v14592) {
          var v23784 = args$$12.members;
          var v20269 = v23784.length;
          v14592 = i$$78 < v20269;
        }
        var v5107 = v14592;
        for (;v5107;) {
          var v14593 = args$$12.members;
          var v5097 = v14593[i$$78];
          AType = v5097.type;
          var v5098;
          var v25464 = best.signature;
          var v23785 = v25464.parameters;
          var v20270 = v23785.length;
          var v14596 = i$$78 < v20270;
          if (v14596) {
            var v23786 = best.signature;
            var v20271 = v23786.parameters;
            var v14594 = v20271[i$$78];
            v5098 = v14594.getType();
          } else {
            var v25465 = best.signature;
            var v23787 = v25465.parameters;
            var v26464 = best.signature;
            var v26161 = v26464.parameters;
            var v25466 = v26161.length;
            var v23788 = v25466 - 1;
            var v20272 = v23787[v23788];
            var v14595 = v20272.getType();
            v5098 = v14595.elementType;
          }
          PType = v5098;
          var v5099;
          var v25467 = Q.signature;
          var v23789 = v25467.parameters;
          var v20273 = v23789.length;
          var v14599 = i$$78 < v20273;
          if (v14599) {
            var v23790 = Q.signature;
            var v20274 = v23790.parameters;
            var v14597 = v20274[i$$78];
            v5099 = v14597.getType();
          } else {
            var v25468 = Q.signature;
            var v23791 = v25468.parameters;
            var v26465 = Q.signature;
            var v26162 = v26465.parameters;
            var v25469 = v26162.length;
            var v23792 = v25469 - 1;
            var v20275 = v23791[v23792];
            var v14598 = v20275.getType();
            v5099 = v14598.elementType;
          }
          QType = v5099;
          var v5106 = this.typesAreIdentical(PType, QType);
          if (v5106) {
          } else {
            var v5105 = this.typesAreIdentical(AType, PType);
            if (v5105) {
              break;
            } else {
              var v5104 = this.typesAreIdentical(AType, QType);
              if (v5104) {
                best = Q;
                break;
              } else {
                var v5103 = this.sourceIsSubtypeOfTarget(PType, QType);
                if (v5103) {
                  break;
                } else {
                  var v5102 = this.sourceIsSubtypeOfTarget(QType, PType);
                  if (v5102) {
                    best = Q;
                    break;
                  } else {
                    var v5101 = Q.hadProvisionalErrors;
                    if (v5101) {
                      break;
                    } else {
                      var v5100 = best.hadProvisionalErrors;
                      if (v5100) {
                        best = Q;
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
          i$$78 = i$$78 + 1;
          var v14600 = args$$12;
          if (v14600) {
            var v23793 = args$$12.members;
            var v20276 = v23793.length;
            v14600 = i$$78 < v20276;
          }
          v5107 = v14600;
        }
        var v14601 = !args$$12;
        var v20278 = !v14601;
        if (v20278) {
          var v23794 = args$$12.members;
          var v20277 = v23794.length;
          v14601 = i$$78 == v20277;
        }
        var v5109 = v14601;
        if (v5109) {
          var collection = {getLength:v941, setTypeAtIndex:v942, getTypeAtIndex:v943};
          var v20279 = best.signature;
          var v14602 = v20279.returnType;
          var v5108 = v14602.type;
          var bct = this.findBestCommonType(v5108, null, collection, true);
          ambiguous = !bct;
        } else {
          ambiguous = false;
        }
        qSig = qSig + 1;
        var v14603 = signatures$$2.length;
        v5110 = qSig < v14603;
      }
      var v5111 = best.signature;
      return{sig:v5111, ambiguous:ambiguous};
    }
    function v940(typeLink$$2, scope$$28) {
      this.resolvingBases = true;
      this.resolveTypeLink(scope$$28, typeLink$$2, true);
      this.resolvingBases = false;
      var extendsType = null;
      var v14604 = typeLink$$2.type;
      var v5113 = v14604.isClass();
      if (v5113) {
        var v5112 = typeLink$$2.type;
        extendsType = v5112.instanceType;
      } else {
        extendsType = typeLink$$2.type;
      }
      return extendsType;
    }
    function v939(scope$$27, typeLink$$1, supplyVar$$1) {
      var arrayCount$$1 = 0;
      var v14605 = typeLink$$1.type;
      var v5156 = v14605 == null;
      if (v5156) {
        var ast$$64 = typeLink$$1.ast;
        if (ast$$64) {
          var v14606 = typeLink$$1.type;
          var v5150 = v14606 == null;
          for (;v5150;) {
            var v5149 = ast$$64.nodeType;
            switch(v5149) {
              case TypeScript$$23.NodeType.Name:
                var identifier$$2 = ast$$64;
                var v5114 = identifier$$2.text;
                var symbol$$12 = scope$$27.find(v5114, false, true);
                var v5126 = symbol$$12 == null;
                if (v5126) {
                  typeLink$$1.type = this.anyType;
                  var v5115 = this.errorReporter;
                  var v5116 = identifier$$2.actualText;
                  v5115.unresolvedSymbol(identifier$$2, v5116);
                } else {
                  var v5125 = symbol$$12.isType();
                  if (v5125) {
                    var v14607 = symbol$$12.visible(scope$$27, this);
                    var v5119 = !v14607;
                    if (v5119) {
                      var v5117 = this.errorReporter;
                      var v20280 = identifier$$2.actualText;
                      var v14608 = "The symbol '" + v20280;
                      var v5118 = v14608 + "' is not visible at this point";
                      v5117.simpleError(ast$$64, v5118);
                    }
                    identifier$$2.sym = symbol$$12;
                    var v5120 = typeLink$$1;
                    var v26935 = symbol$$12.getType();
                    v5120.type = v26935;
                    var v5123 = typeLink$$1.type;
                    if (v5123) {
                      var v14609 = typeLink$$1.type;
                      var v5122 = v14609.isClass();
                      if (v5122) {
                        var v5121 = typeLink$$1.type;
                        typeLink$$1.type = v5121.instanceType;
                      }
                    } else {
                      typeLink$$1.type = this.anyType;
                    }
                  } else {
                    typeLink$$1.type = this.anyType;
                    var v5124 = this.errorReporter;
                    v5124.simpleError(ast$$64, "Expected type");
                  }
                }
                break;
              case TypeScript$$23.NodeType.Dot:
                var v5127 = typeLink$$1;
                var v26936 = this.resolveTypeMember(scope$$27, ast$$64);
                v5127.type = v26936;
                break;
              case TypeScript$$23.NodeType.TypeRef:
                var typeRef$$2 = ast$$64;
                arrayCount$$1 = typeRef$$2.arrayCount;
                ast$$64 = typeRef$$2.term;
                var v5128 = ast$$64 == null;
                if (v5128) {
                  typeLink$$1.type = this.anyType;
                }
                break;
              case TypeScript$$23.NodeType.InterfaceDeclaration:
                var interfaceDecl$$3 = ast$$64;
                var v5129 = TypeScript$$23.Type;
                var interfaceType$$1 = new v5129;
                var v5130 = TypeScript$$23.TypeSymbol;
                var v14610 = interfaceDecl$$3.name;
                var v5131 = v14610.text;
                var v5132 = ast$$64.minChar;
                var v14611 = ast$$64.limChar;
                var v14612 = ast$$64.minChar;
                var v5133 = v14611 - v14612;
                var v14613 = this.locationInfo;
                var v5134 = v14613.unitIndex;
                var interfaceSymbol = new v5130(v5131, v5132, v5133, v5134, interfaceType$$1);
                interfaceType$$1.symbol = interfaceSymbol;
                var v5135 = interfaceType$$1;
                var v14614 = TypeScript$$23.ScopedMembers;
                var v20281 = TypeScript$$23.DualStringHashTable;
                var v23795 = TypeScript$$23.StringHashTable;
                var v20282 = new v23795;
                var v23796 = TypeScript$$23.StringHashTable;
                var v20283 = new v23796;
                var v14615 = new v20281(v20282, v20283);
                var v26937 = new v14614(v14615);
                v5135.members = v26937;
                var v5136 = interfaceType$$1;
                var v14616 = TypeScript$$23.SymbolTableScope;
                var v14617 = interfaceType$$1.members;
                var v26938 = new v14616(v14617, null, null, null, interfaceSymbol);
                v5136.containedScope = v26938;
                var v5137 = interfaceType$$1.containedScope;
                v5137.container = interfaceSymbol;
                interfaceType$$1.memberScope = interfaceType$$1.containedScope;
                var memberList = interfaceDecl$$3.members;
                var props$$1 = memberList.members;
                var propsLen = props$$1.length;
                var j$$9 = 0;
                var v5147 = j$$9 < propsLen;
                for (;v5147;) {
                  var propDecl = props$$1[j$$9];
                  var propSym = null;
                  var addMember = true;
                  var id$$18 = null;
                  var v14618 = propDecl.nodeType;
                  var v20284 = TypeScript$$23.NodeType;
                  var v14619 = v20284.FuncDecl;
                  var v5142 = v14618 == v14619;
                  if (v5142) {
                    var funcDecl$$20 = propDecl;
                    id$$18 = funcDecl$$20.name;
                    var v14620 = interfaceType$$1.members;
                    var v5138 = v14620.allMembers;
                    var v5139 = funcDecl$$20.getNameText();
                    propSym = v5138.lookup(v5139);
                    addMember = propSym == null;
                    var v5140 = funcDecl$$20.isSpecialFn();
                    if (v5140) {
                      addMember = false;
                      propSym = this.resolveFuncDecl(funcDecl$$20, scope$$27, interfaceSymbol);
                    } else {
                      propSym = this.resolveFuncDecl(funcDecl$$20, scope$$27, propSym);
                    }
                    funcDecl$$20.type = propSym.type;
                  } else {
                    id$$18 = propDecl.id;
                    propSym = this.resolveVarDecl(propDecl, scope$$27);
                    var v5141 = id$$18.isMissing();
                    addMember = !v5141;
                  }
                  if (addMember) {
                    var v14621 = id$$18;
                    if (v14621) {
                      var v20285 = id$$18.flags;
                      var v23797 = TypeScript$$23.ASTFlags;
                      var v20286 = v23797.OptionalName;
                      v14621 = TypeScript$$23.hasFlag(v20285, v20286);
                    }
                    var v5143 = v14621;
                    if (v5143) {
                      var v14622 = propSym.flags;
                      var v20287 = TypeScript$$23.SymbolFlags;
                      var v14623 = v20287.Optional;
                      propSym.flags = v14622 | v14623;
                    }
                    var v23798 = interfaceType$$1.members;
                    var v20288 = v23798.allMembers;
                    var v20289 = propSym.name;
                    var v14624 = v20288.add(v20289, propSym);
                    var v5146 = !v14624;
                    if (v5146) {
                      var v5144 = this.errorReporter;
                      var v5145 = propSym.name;
                      v5144.duplicateIdentifier(ast$$64, v5145);
                    }
                  }
                  j$$9 = j$$9 + 1;
                  v5147 = j$$9 < propsLen;
                }
                ast$$64.type = interfaceType$$1;
                typeLink$$1.type = interfaceType$$1;
                break;
              case TypeScript$$23.NodeType.FuncDecl:
                var tsym = this.resolveFuncDecl(ast$$64, scope$$27, null);
                typeLink$$1.type = tsym.type;
                break;
              default:
                typeLink$$1.type = this.anyType;
                var v5148 = this.errorReporter;
                v5148.simpleError(ast$$64, "Expected type");
            }
            var v14625 = typeLink$$1.type;
            v5150 = v14625 == null;
          }
        }
        var count$$5 = arrayCount$$1;
        var v5152 = count$$5 > 0;
        for (;v5152;) {
          var v5151 = typeLink$$1;
          var v14626 = typeLink$$1.type;
          var v26939 = this.makeArrayType(v14626);
          v5151.type = v26939;
          count$$5 = count$$5 - 1;
          v5152 = count$$5 > 0;
        }
        var v14627 = supplyVar$$1;
        if (v14627) {
          var v20290 = typeLink$$1.type;
          v14627 = v20290 == null;
        }
        var v5153 = v14627;
        if (v5153) {
          typeLink$$1.type = this.anyType;
        }
        var v5155 = typeLink$$1.ast;
        if (v5155) {
          var v5154 = typeLink$$1.ast;
          v5154.type = typeLink$$1.type;
        }
      }
      return;
    }
    function v938(varDecl$$11, scope$$26) {
      var v5157 = TypeScript$$23.ValueLocation;
      var field$$2 = new v5157;
      var v5158 = TypeScript$$23.FieldSymbol;
      var v14628 = varDecl$$11.id;
      var v5159 = v14628.text;
      var v5160 = varDecl$$11.minChar;
      var v14629 = this.locationInfo;
      var v5161 = v14629.unitIndex;
      var v20291 = varDecl$$11.varFlags;
      var v23799 = TypeScript$$23.VarFlags;
      var v20292 = v23799.Readonly;
      var v14630 = v20291 & v20292;
      var v20293 = TypeScript$$23.VarFlags;
      var v14631 = v20293.None;
      var v5162 = v14630 == v14631;
      var fieldSymbol = new v5158(v5159, v5160, v5161, v5162, field$$2);
      var v5163 = varDecl$$11.varFlags;
      fieldSymbol.transferVarFlags(v5163);
      field$$2.symbol = fieldSymbol;
      fieldSymbol.declAST = varDecl$$11;
      var v5164 = field$$2;
      var v14632 = varDecl$$11.typeExpr;
      var v20294 = varDecl$$11.init;
      var v14633 = v20294 == null;
      var v26940 = TypeScript$$23.getTypeLink(v14632, this, v14633);
      v5164.typeLink = v26940;
      var v5165 = field$$2.typeLink;
      this.resolveTypeLink(scope$$26, v5165, true);
      varDecl$$11.sym = fieldSymbol;
      var v5166 = field$$2.typeLink;
      varDecl$$11.type = v5166.type;
      return fieldSymbol;
    }
    function v937(funcDecl$$19, scope$$25, fgSym$$2) {
      var v23800 = scope$$25.container;
      var v20295 = this.createFunctionSignature(funcDecl$$19, v23800, scope$$25, fgSym$$2, false);
      var v14634 = v20295.declAST;
      var v5167 = v14634.type;
      var functionGroupSymbol = v5167.symbol;
      var signatures$$1;
      var v5172 = funcDecl$$19.isConstructMember();
      if (v5172) {
        var v14635 = functionGroupSymbol.type;
        var v5168 = v14635.construct;
        signatures$$1 = v5168.signatures;
      } else {
        var v5171 = funcDecl$$19.isIndexerMember();
        if (v5171) {
          var v20296 = functionGroupSymbol.type;
          var v14636 = v20296.getInstanceType();
          var v5169 = v14636.index;
          signatures$$1 = v5169.signatures;
        } else {
          var v14637 = functionGroupSymbol.type;
          var v5170 = v14637.call;
          signatures$$1 = v5170.signatures;
        }
      }
      var v14638 = signatures$$1.length;
      var v5173 = v14638 - 1;
      var signature$$4 = signatures$$1[v5173];
      var v5174 = signature$$4.parameters;
      var len$$27 = v5174.length;
      var i$$77 = 0;
      var v5177 = i$$77 < len$$27;
      for (;v5177;) {
        var v5175 = signature$$4.parameters;
        var paramSym$$2 = v5175[i$$77];
        var v14639 = paramSym$$2.parameter;
        var v5176 = v14639.typeLink;
        this.resolveTypeLink(scope$$25, v5176, true);
        i$$77 = i$$77 + 1;
        v5177 = i$$77 < len$$27;
      }
      var v14640 = len$$27;
      if (v14640) {
        v14640 = funcDecl$$19.variableArgList;
      }
      var v5182 = v14640;
      if (v5182) {
        var v26466 = signature$$4.parameters;
        var v26467 = len$$27 - 1;
        var v26163 = v26466[v26467];
        var v25470 = v26163.parameter;
        var v23801 = v25470.typeLink;
        var v20297 = v23801.type;
        var v14641 = v20297.elementType;
        var v5181 = !v14641;
        if (v5181) {
          var v5178 = this.errorReporter;
          var v23802 = signature$$4.parameters;
          var v23803 = len$$27 - 1;
          var v20298 = v23802[v23803];
          var v14642 = v20298.parameter;
          var v5179 = v14642.symbol;
          v5178.simpleErrorFromSym(v5179, "... parameter must have array type");
          var v23804 = signature$$4.parameters;
          var v23805 = len$$27 - 1;
          var v20299 = v23804[v23805];
          var v14643 = v20299.parameter;
          var v5180 = v14643.typeLink;
          var v26164 = signature$$4.parameters;
          var v26165 = len$$27 - 1;
          var v25471 = v26164[v26165];
          var v23806 = v25471.parameter;
          var v20300 = v23806.typeLink;
          var v14644 = v20300.type;
          var v26941 = this.makeArrayType(v14644);
          v5180.type = v26941;
        }
      }
      var v5183 = signature$$4.returnType;
      var v5184 = funcDecl$$19.isSignature();
      this.resolveTypeLink(scope$$25, v5183, v5184);
      return functionGroupSymbol;
    }
    function v936(scope$$24, dotNode$$2) {
      function v935(id$$17) {
        return scope$$24.find(id$$17, false, true);
      }
      var lhs = dotNode$$2.operand1;
      var rhs = dotNode$$2.operand2;
      var resultType = this.anyType;
      var lhsType = this.anyType;
      var v14645 = lhs && rhs;
      if (v14645) {
        var v20301 = rhs.nodeType;
        var v23807 = TypeScript$$23.NodeType;
        var v20302 = v23807.Name;
        v14645 = v20301 == v20302;
      }
      var v5213 = v14645;
      if (v5213) {
        var v14646 = lhs.nodeType;
        var v20303 = TypeScript$$23.NodeType;
        var v14647 = v20303.Dot;
        var v5204 = v14646 == v14647;
        if (v5204) {
          lhsType = this.resolveTypeMember(scope$$24, lhs);
        } else {
          var v14648 = lhs.nodeType;
          var v20304 = TypeScript$$23.NodeType;
          var v14649 = v20304.Name;
          var v5203 = v14648 == v14649;
          if (v5203) {
            var identifier$$1 = lhs;
            var v5185 = identifier$$1.text;
            var symbol$$11 = scope$$24.find(v5185, false, true);
            var v5202 = symbol$$11 == null;
            if (v5202) {
              var v5186 = this.errorReporter;
              var v5187 = identifier$$1.actualText;
              v5186.unresolvedSymbol(identifier$$1, v5187);
            } else {
              var v5201 = symbol$$11.isType();
              if (v5201) {
                var typeSymbol$$1 = symbol$$11;
                var v20305 = typeSymbol$$1.aliasLink;
                if (v20305) {
                  var v23808 = typeSymbol$$1.type;
                  v20305 = !v23808;
                }
                var v14650 = v20305;
                if (v14650) {
                  var v25472 = typeSymbol$$1.aliasLink;
                  var v23809 = v25472.alias;
                  var v20306 = v23809.nodeType;
                  var v23810 = TypeScript$$23.NodeType;
                  var v20307 = v23810.Name;
                  v14650 = v20306 == v20307;
                }
                var v5191 = v14650;
                if (v5191) {
                  var v14651 = typeSymbol$$1.aliasLink;
                  var v5188 = v14651.alias;
                  var modPath$$2 = v5188.text;
                  var v14652 = this.locationInfo;
                  var v5189 = v14652.filename;
                  var modSym$$1 = this.findSymbolForDynamicModule(modPath$$2, v5189, v935);
                  if (modSym$$1) {
                    var v5190 = typeSymbol$$1;
                    var v26942 = modSym$$1.getType();
                    v5190.type = v26942;
                  }
                }
                var v14653 = TypeScript$$23.optimizeModuleCodeGen;
                if (v14653) {
                  v14653 = symbol$$11;
                }
                var v5196 = v14653;
                if (v5196) {
                  var symType = symbol$$11.getType();
                  var v20308 = symType;
                  if (v20308) {
                    v20308 = typeSymbol$$1.aliasLink;
                  }
                  var v14654 = v20308;
                  if (v14654) {
                    v14654 = typeSymbol$$1.onlyReferencedAsTypeRef;
                  }
                  var v5195 = v14654;
                  if (v5195) {
                    var v5192 = symType.symbol;
                    var modDecl$$1 = v5192.declAST;
                    var v14655 = modDecl$$1;
                    if (v14655) {
                      var v20309 = modDecl$$1.modFlags;
                      var v23811 = TypeScript$$23.ModuleFlags;
                      var v20310 = v23811.IsDynamic;
                      v14655 = TypeScript$$23.hasFlag(v20309, v20310);
                    }
                    var v5194 = v14655;
                    if (v5194) {
                      var v5193 = this.resolvingBases;
                      typeSymbol$$1.onlyReferencedAsTypeRef = !v5193;
                    }
                  }
                }
                var v14656 = symbol$$11.visible(scope$$24, this);
                var v5199 = !v14656;
                if (v5199) {
                  var v5197 = this.errorReporter;
                  var v20311 = identifier$$1.actualText;
                  var v14657 = "The symbol '" + v20311;
                  var v5198 = v14657 + "' is not visible at this point";
                  v5197.simpleError(lhs, v5198);
                }
                lhsType = symbol$$11.getType();
                identifier$$1.sym = symbol$$11;
              } else {
                var v5200 = this.errorReporter;
                v5200.simpleError(lhs, "Expected type");
              }
            }
          }
        }
        var v5205 = !lhsType;
        if (v5205) {
          lhsType = this.anyType;
        }
        var v14658 = this.anyType;
        var v5212 = lhsType != v14658;
        if (v5212) {
          var rhsIdentifier = rhs;
          var v5206 = rhsIdentifier.text;
          var resultSymbol = this.lookupMemberTypeSymbol(lhsType, v5206);
          var v5211 = resultSymbol == null;
          if (v5211) {
            resultType = this.anyType;
            var v5207 = this.errorReporter;
            v5207.simpleError(dotNode$$2, "Expected type");
          } else {
            resultType = resultSymbol.getType();
            var v14659 = resultSymbol.visible(scope$$24, this);
            var v5210 = !v14659;
            if (v5210) {
              var v5208 = this.errorReporter;
              var v20312 = rhs.actualText;
              var v14660 = "The symbol '" + v20312;
              var v5209 = v14660 + "' is not visible at this point";
              v5208.simpleError(lhs, v5209);
            }
          }
          rhsIdentifier.sym = resultType.symbol;
        }
      }
      var v5214 = resultType.isClass();
      if (v5214) {
        resultType = resultType.instanceType;
      }
      return resultType;
    }
    function v934(idText$$2, currentFileName, search) {
      var originalIdText = idText$$2;
      var symbol$$10 = search(idText$$2);
      var v5235 = symbol$$10 == null;
      if (v5235) {
        var v5215 = !symbol$$10;
        if (v5215) {
          idText$$2 = TypeScript$$23.swapQuotes(originalIdText);
          symbol$$10 = search(idText$$2);
        }
        var v5217 = !symbol$$10;
        if (v5217) {
          var v5216 = TypeScript$$23.stripQuotes(originalIdText);
          idText$$2 = v5216 + ".ts";
          symbol$$10 = search(idText$$2);
        }
        var v5219 = !symbol$$10;
        if (v5219) {
          var v5218 = TypeScript$$23.stripQuotes(originalIdText);
          idText$$2 = v5218 + ".str";
          symbol$$10 = search(idText$$2);
        }
        var v5221 = !symbol$$10;
        if (v5221) {
          var v5220 = TypeScript$$23.stripQuotes(originalIdText);
          idText$$2 = v5220 + ".d.ts";
          symbol$$10 = search(idText$$2);
        }
        var v5223 = !symbol$$10;
        if (v5223) {
          var v5222 = TypeScript$$23.stripQuotes(originalIdText);
          idText$$2 = v5222 + ".d.str";
          symbol$$10 = search(idText$$2);
        }
        var v14661 = !symbol$$10;
        if (v14661) {
          var v20313 = TypeScript$$23.isRelative(originalIdText);
          v14661 = !v20313;
        }
        var v5234 = v14661;
        if (v5234) {
          idText$$2 = originalIdText;
          var strippedIdText = TypeScript$$23.stripQuotes(idText$$2);
          var v5224 = TypeScript$$23.switchToForwardSlashes(currentFileName);
          var path$$7 = TypeScript$$23.getRootFilePath(v5224);
          var v14662 = symbol$$10 == null;
          if (v14662) {
            v14662 = path$$7 != "";
          }
          var v5233 = v14662;
          for (;v5233;) {
            var v14663 = path$$7 + strippedIdText;
            var v5225 = v14663 + ".ts";
            idText$$2 = TypeScript$$23.normalizePath(v5225);
            symbol$$10 = search(idText$$2);
            var v5226 = symbol$$10 == null;
            if (v5226) {
              idText$$2 = TypeScript$$23.changePathToSTR(idText$$2);
              symbol$$10 = search(idText$$2);
            }
            var v5227 = symbol$$10 == null;
            if (v5227) {
              idText$$2 = TypeScript$$23.changePathToDTS(idText$$2);
              symbol$$10 = search(idText$$2);
            }
            var v5228 = symbol$$10 == null;
            if (v5228) {
              idText$$2 = TypeScript$$23.changePathToDSTR(idText$$2);
              symbol$$10 = search(idText$$2);
            }
            var v5232 = symbol$$10 == null;
            if (v5232) {
              var v5231 = path$$7 === "/";
              if (v5231) {
                path$$7 = "";
              } else {
                var v5229 = path$$7 + "..";
                path$$7 = TypeScript$$23.normalizePath(v5229);
                var v5230;
                var v20314 = path$$7;
                if (v20314) {
                  v20314 = path$$7 != "/";
                }
                var v14664 = v20314;
                if (v14664) {
                  v5230 = path$$7 + "/";
                } else {
                  v5230 = path$$7;
                }
                path$$7 = v5230;
              }
            }
            var v14665 = symbol$$10 == null;
            if (v14665) {
              v14665 = path$$7 != "";
            }
            v5233 = v14665;
          }
        }
      }
      return symbol$$10;
    }
    function v933(containingType, name$$81) {
      var symbol$$9 = null;
      var v5241 = containingType.containedScope;
      if (v5241) {
        var v5236 = containingType.containedScope;
        symbol$$9 = v5236.find(name$$81, false, true);
      } else {
        var v5240 = containingType.members;
        if (v5240) {
          var v14666 = containingType.members;
          var v5237 = v14666.allMembers;
          symbol$$9 = v5237.lookup(name$$81);
          var v14667 = symbol$$9 == null;
          if (v14667) {
            v14667 = containingType.ambientMembers;
          }
          var v5239 = v14667;
          if (v5239) {
            var v14668 = containingType.ambientMembers;
            var v5238 = v14668.allMembers;
            symbol$$9 = v5238.lookup(name$$81);
          }
        }
      }
      var v5245 = symbol$$9 == null;
      if (v5245) {
        var typeMembers$$1 = containingType.getAllEnclosedTypes();
        var ambientTypeMembers$$1 = containingType.getAllAmbientEnclosedTypes();
        if (typeMembers$$1) {
          var v5242 = typeMembers$$1.allMembers;
          symbol$$9 = v5242.lookup(name$$81);
          var v14669 = symbol$$9 == null;
          if (v14669) {
            v14669 = ambientTypeMembers$$1;
          }
          var v5244 = v14669;
          if (v5244) {
            var v5243 = ambientTypeMembers$$1.allMembers;
            symbol$$9 = v5243.lookup(name$$81);
          }
        }
      }
      var v14670 = symbol$$9;
      if (v14670) {
        v14670 = symbol$$9.isType();
      }
      var v5246 = v14670;
      if (v5246) {
        return symbol$$9;
      } else {
        return null;
      }
      return;
    }
    function v932(type$$42) {
      var v5247 = TypeScript$$23.SymbolAggregateScope;
      var v5248 = type$$42.symbol;
      var resultScope$$1 = new v5247(v5248);
      var v14671;
      var v23812 = type$$42.symbol;
      if (v23812) {
        var v25473 = type$$42.symbol;
        v23812 = v25473.name;
      }
      var v20316 = v23812;
      if (v20316) {
        var v20315 = type$$42.symbol;
        v14671 = v20315.name;
      } else {
        v14671 = "{}";
      }
      var v5249 = v14671;
      var v5250 = type$$42.typeID;
      var baseContext$$1 = {base:v5249, baseId:v5250};
      this.addBases(resultScope$$1, type$$42, baseContext$$1);
      return resultScope$$1;
    }
    function v931(resultScope, type$$41, baseContext) {
      var v14672 = TypeScript$$23.SymbolTableScope;
      var v14673 = type$$41.members;
      var v14674 = type$$41.ambientMembers;
      var v14675 = type$$41.getAllEnclosedTypes();
      var v14676 = type$$41.getAllAmbientEnclosedTypes();
      var v14677 = type$$41.symbol;
      var v5251 = new v14672(v14673, v14674, v14675, v14676, v14677);
      resultScope.addParentScope(v5251);
      var i$$76 = 0;
      var parent$$52;
      var v5260 = type$$41.extendsList;
      if (v5260) {
        var v5252 = type$$41.extendsList;
        var len$$26 = v5252.length;
        var v5259 = i$$76 < len$$26;
        for (;v5259;) {
          var v5253 = type$$41.extendsList;
          parent$$52 = v5253[i$$76];
          var v14678 = baseContext.baseId;
          var v14679 = parent$$52.typeID;
          var v5258 = v14678 == v14679;
          if (v5258) {
            var v5254 = this.errorReporter;
            var v5255 = parent$$52.symbol;
            var v20317 = baseContext.base;
            var v14680 = "Type '" + v20317;
            var v5256 = v14680 + "' is recursively referenced as a base class of itself";
            v5254.reportErrorFromSym(v5255, v5256);
            var v5257 = parent$$52.symbol;
            var v20318 = v5257.flags;
            var v23813 = TypeScript$$23.SymbolFlags;
            var v20319 = v23813.RecursivelyReferenced;
            v5257.flags = v20318 | v20319;
            break;
          }
          this.addBases(resultScope, parent$$52, baseContext);
          i$$76 = i$$76 + 1;
          v5259 = i$$76 < len$$26;
        }
      }
      return;
    }
    function v930(funcDecl$$18, fgSym$$1, enclosingClass, addToMembers, isClassProperty, scope$$23, container$$13) {
      var accessorSym = null;
      var sig = funcDecl$$18.signature;
      var v5261 = funcDecl$$18.name;
      var nameText$$2 = v5261.text;
      var v5262 = funcDecl$$18.fncFlags;
      var v14681 = TypeScript$$23.FncFlags;
      var v5263 = v14681.Static;
      var isStatic$$7 = TypeScript$$23.hasFlag(v5262, v5263);
      var v5264 = funcDecl$$18.fncFlags;
      var v14682 = TypeScript$$23.FncFlags;
      var v5265 = v14682.Private;
      var isPrivate$$1 = TypeScript$$23.hasFlag(v5264, v5265);
      var v5293 = fgSym$$1 == null;
      if (v5293) {
        var v5266 = TypeScript$$23.ValueLocation;
        var field$$1 = new v5266;
        var v5267 = TypeScript$$23.FieldSymbol;
        var v5268 = funcDecl$$18.minChar;
        var v14683 = this.locationInfo;
        var v5269 = v14683.unitIndex;
        accessorSym = new v5267(nameText$$2, v5268, v5269, false, field$$1);
        field$$1.symbol = accessorSym;
        accessorSym.declAST = funcDecl$$18;
        var v14684 = funcDecl$$18.fncFlags;
        var v20320 = TypeScript$$23.FncFlags;
        var v14685 = v20320.GetAccessor;
        var v5276 = TypeScript$$23.hasFlag(v14684, v14685);
        if (v5276) {
          var v5271 = accessorSym.getter;
          if (v5271) {
            var v5270 = this.errorReporter;
            v5270.simpleError(funcDecl$$18, "Redeclaration of property getter");
          }
          var v14686 = sig.declAST;
          var v5272 = v14686.type;
          accessorSym.getter = v5272.symbol;
        } else {
          var v5274 = accessorSym.setter;
          if (v5274) {
            var v5273 = this.errorReporter;
            v5273.simpleError(funcDecl$$18, "Redeclaration of property setter");
          }
          var v14687 = sig.declAST;
          var v5275 = v14687.type;
          accessorSym.setter = v5275.symbol;
        }
        var v5277 = field$$1;
        var v26943 = TypeScript$$23.getTypeLink(null, this, false);
        v5277.typeLink = v26943;
        if (addToMembers) {
          if (enclosingClass) {
            var v23814 = enclosingClass.members;
            var v20321 = v23814.publicMembers;
            var v14688 = v20321.add(nameText$$2, accessorSym);
            var v5280 = !v14688;
            if (v5280) {
              var v5278 = this.errorReporter;
              var v5279 = accessorSym.name;
              v5278.duplicateIdentifier(funcDecl$$18, v5279);
            }
            accessorSym.container = enclosingClass.symbol;
          } else {
            var v5281 = this.errorReporter;
            v5281.simpleError(funcDecl$$18, "Accessor property may not be added in this context");
          }
        } else {
          var v5282 = this.errorReporter;
          var v14689 = !isPrivate$$1;
          var v20322 = !v14689;
          if (v20322) {
            v14689 = isStatic$$7;
          }
          var v5283 = v14689;
          scope$$23.enter(container$$13, funcDecl$$18, accessorSym, v5282, v5283, false, false);
        }
        if (isClassProperty) {
          var v14690 = accessorSym.flags;
          var v20323 = TypeScript$$23.SymbolFlags;
          var v14691 = v20323.Property;
          accessorSym.flags = v14690 | v14691;
        }
        if (isStatic$$7) {
          var v14692 = accessorSym.flags;
          var v20324 = TypeScript$$23.SymbolFlags;
          var v14693 = v20324.Static;
          accessorSym.flags = v14692 | v14693;
        }
        if (isPrivate$$1) {
          var v14694 = accessorSym.flags;
          var v20325 = TypeScript$$23.SymbolFlags;
          var v14695 = v20325.Private;
          accessorSym.flags = v14694 | v14695;
        } else {
          var v14696 = accessorSym.flags;
          var v20326 = TypeScript$$23.SymbolFlags;
          var v14697 = v20326.Public;
          accessorSym.flags = v14696 | v14697;
        }
      } else {
        accessorSym = fgSym$$1;
        var v14698 = isPrivate$$1;
        var v20327 = accessorSym.flags;
        var v23815 = TypeScript$$23.SymbolFlags;
        var v20328 = v23815.Private;
        var v14699 = TypeScript$$23.hasFlag(v20327, v20328);
        var v5285 = v14698 != v14699;
        if (v5285) {
          var v5284 = this.errorReporter;
          v5284.simpleError(funcDecl$$18, "Getter and setter accessors do not agree in visibility");
        }
        var v14700 = funcDecl$$18.fncFlags;
        var v20329 = TypeScript$$23.FncFlags;
        var v14701 = v20329.GetAccessor;
        var v5292 = TypeScript$$23.hasFlag(v14700, v14701);
        if (v5292) {
          var v5287 = accessorSym.getter;
          if (v5287) {
            var v5286 = this.errorReporter;
            v5286.simpleError(funcDecl$$18, "Redeclaration of property getter");
          }
          var v5288 = funcDecl$$18.type;
          accessorSym.getter = v5288.symbol;
        } else {
          var v5290 = accessorSym.setter;
          if (v5290) {
            var v5289 = this.errorReporter;
            v5289.simpleError(funcDecl$$18, "Redeclaration of property setter");
          }
          var v5291 = funcDecl$$18.type;
          accessorSym.setter = v5291.symbol;
        }
      }
      return accessorSym;
    }
    function v929(funcDecl$$17, container$$12, scope$$22, overloadGroupSym, addToScope) {
      var v14702 = funcDecl$$17.fncFlags;
      var v23816 = TypeScript$$23.FncFlags;
      var v20330 = v23816.Exported;
      var v23817 = TypeScript$$23.FncFlags;
      var v20331 = v23817.ClassPropertyMethodExported;
      var v14703 = v20330 | v20331;
      var v5294 = TypeScript$$23.hasFlag(v14702, v14703);
      var v14705 = !v5294;
      if (v14705) {
        var v14704 = this.gloMod;
        v5294 = container$$12 == v14704;
      }
      var isExported$$1 = v5294;
      var v5295 = funcDecl$$17.fncFlags;
      var v14706 = TypeScript$$23.FncFlags;
      var v5296 = v14706.Static;
      var isStatic$$6 = TypeScript$$23.hasFlag(v5295, v5296);
      var v5297 = funcDecl$$17.fncFlags;
      var v14707 = TypeScript$$23.FncFlags;
      var v5298 = v14707.Private;
      var isPrivate = TypeScript$$23.hasFlag(v5297, v5298);
      var v5299 = funcDecl$$17.fncFlags;
      var v14708 = TypeScript$$23.FncFlags;
      var v5300 = v14708.Definition;
      var isDefinition = TypeScript$$23.hasFlag(v5299, v5300);
      var v5301 = funcDecl$$17.fncFlags;
      var v14709 = TypeScript$$23.FncFlags;
      var v5302 = v14709.Ambient;
      var isAmbient$$4 = TypeScript$$23.hasFlag(v5301, v5302);
      var v5303 = funcDecl$$17.isConstructMember();
      var v14710 = !v5303;
      if (v14710) {
        v5303 = funcDecl$$17.isConstructor;
      }
      var isConstructor$$2 = v5303;
      var v5304 = this.gloMod;
      var isGlobal = container$$12 == v5304;
      var v5305 = TypeScript$$23.Signature;
      var signature$$3 = new v5305;
      var v5306 = funcDecl$$17.fncFlags;
      var v14711 = TypeScript$$23.FncFlags;
      var v5307 = v14711.IsFunctionExpression;
      var isLambda$$2 = v5306 & v5307;
      var v14712 = funcDecl$$17.returnTypeAnnotation;
      var v20332 = !v14712;
      if (v20332) {
        v14712 = isDefinition;
      }
      var v5311 = v14712;
      if (v5311) {
        var v5308 = signature$$3;
        var v14713 = funcDecl$$17.returnTypeAnnotation;
        var v26944 = TypeScript$$23.getTypeLink(v14713, this, false);
        v5308.returnType = v26944;
      } else {
        var v5309 = signature$$3;
        var v14714 = TypeScript$$23.TypeLink;
        var v26945 = new v14714;
        v5309.returnType = v26945;
        var v5310 = signature$$3.returnType;
        v5310.type = this.anyType;
      }
      signature$$3.hasVariableArgList = funcDecl$$17.variableArgList;
      var sigData = this.getParameterList(funcDecl$$17, container$$12);
      signature$$3.parameters = sigData.parameters;
      signature$$3.nonOptionalParameterCount = sigData.nonOptionalParameterCount;
      funcDecl$$17.signature = signature$$3;
      signature$$3.declAST = funcDecl$$17;
      var v20333 = overloadGroupSym;
      if (v20333) {
        v20333 = overloadGroupSym.getType();
      }
      var v14715 = v20333;
      if (v14715) {
        var v20334 = overloadGroupSym.isAccessor();
        v14715 = !v20334;
      }
      var v5312 = v14715;
      if (v5312) {
        var v14716 = funcDecl$$17.isSignature();
        var v20337 = !v14716;
        if (v20337) {
          var v20335 = isAmbient$$4;
          var v23818 = overloadGroupSym.flags;
          var v25474 = TypeScript$$23.SymbolFlags;
          var v23819 = v25474.Ambient;
          var v20336 = TypeScript$$23.hasFlag(v23818, v23819);
          v14716 = v20335 == v20336;
        }
        v5312 = v14716;
      }
      var useOverloadGroupSym = v5312;
      var v14717 = useOverloadGroupSym;
      if (v14717) {
        var v20338 = isPrivate;
        var v23820 = overloadGroupSym.flags;
        var v25475 = TypeScript$$23.SymbolFlags;
        var v23821 = v25475.Private;
        var v20339 = TypeScript$$23.hasFlag(v23820, v23821);
        v14717 = v20338 != v20339;
      }
      var v5314 = v14717;
      if (v5314) {
        var v5313 = this.errorReporter;
        v5313.simpleError(funcDecl$$17, "Public/Private visibility of overloads does not agree");
      }
      var v5315;
      if (useOverloadGroupSym) {
        v5315 = overloadGroupSym.getType();
      } else {
        var v14718 = TypeScript$$23.Type;
        v5315 = new v14718;
      }
      var groupType = v5315;
      if (isConstructor$$2) {
        var v14719 = groupType.construct;
        var v5317 = v14719 == null;
        if (v5317) {
          var v5316 = groupType;
          var v14720 = TypeScript$$23.SignatureGroup;
          var v26946 = new v14720;
          v5316.construct = v26946;
        }
        var v5318 = groupType.construct;
        v5318.addSignature(signature$$3);
        var v5319 = groupType.construct;
        var v14721 = funcDecl$$17.isSignature();
        v5319.hasImplementation = !v14721;
        var v14722 = groupType.construct;
        var v5320 = v14722.hasImplementation;
        if (v5320) {
          groupType.setHasImplementation();
        }
      } else {
        var v5332 = funcDecl$$17.isIndexerMember();
        if (v5332) {
          var v14723 = groupType.index;
          var v5323 = v14723 == null;
          if (v5323) {
            var v5321 = groupType;
            var v14724 = TypeScript$$23.SignatureGroup;
            var v26947 = new v14724;
            v5321.index = v26947;
            var v5322 = groupType.index;
            var v20340 = v5322.flags;
            var v23822 = TypeScript$$23.SignatureFlags;
            var v20341 = v23822.IsIndexer;
            v5322.flags = v20340 | v20341;
          }
          var v5324 = groupType.index;
          v5324.addSignature(signature$$3);
          var v5325 = groupType.index;
          var v14725 = funcDecl$$17.isSignature();
          v5325.hasImplementation = !v14725;
          var v14726 = groupType.index;
          var v5326 = v14726.hasImplementation;
          if (v5326) {
            groupType.setHasImplementation();
          }
        } else {
          var v14727 = groupType.call;
          var v5328 = v14727 == null;
          if (v5328) {
            var v5327 = groupType;
            var v14728 = TypeScript$$23.SignatureGroup;
            var v26948 = new v14728;
            v5327.call = v26948;
          }
          var v5329 = groupType.call;
          v5329.addSignature(signature$$3);
          var v5330 = groupType.call;
          var v14729 = funcDecl$$17.isSignature();
          v5330.hasImplementation = !v14729;
          var v14730 = groupType.call;
          var v5331 = v14730.hasImplementation;
          if (v5331) {
            groupType.setHasImplementation();
          }
        }
      }
      var instanceType$$3 = groupType.instanceType;
      var funcName$$1 = null;
      var usedHint = false;
      var v14731 = funcDecl$$17.name;
      if (v14731) {
        var v23823 = funcDecl$$17.name;
        var v20342 = v23823.isMissing();
        v14731 = !v20342;
      }
      var v5335 = v14731;
      if (v5335) {
        var v5333 = funcDecl$$17.name;
        funcName$$1 = v5333.text;
      } else {
        var v5334 = funcDecl$$17.hint;
        if (v5334) {
          funcName$$1 = funcDecl$$17.hint;
          usedHint = true;
        }
      }
      var v14732 = groupType.symbol;
      var v5339 = v14732 == null;
      if (v5339) {
        var v5336 = groupType;
        var v14733 = TypeScript$$23.TypeSymbol;
        var v20343;
        if (funcName$$1) {
          v20343 = funcName$$1;
        } else {
          v20343 = this.anon;
        }
        var v14734 = v20343;
        var v14735 = funcDecl$$17.minChar;
        var v20344 = funcDecl$$17.limChar;
        var v20345 = funcDecl$$17.minChar;
        var v14736 = v20344 - v20345;
        var v20346 = this.locationInfo;
        var v14737 = v20346.unitIndex;
        var v26949 = new v14733(v14734, v14735, v14736, v14737, groupType);
        v5336.symbol = v26949;
        var v5338 = !useOverloadGroupSym;
        if (v5338) {
          var v5337 = groupType.symbol;
          v5337.declAST = funcDecl$$17;
        }
      }
      if (isStatic$$6) {
        var v5340 = groupType.symbol;
        var v20347 = v5340.flags;
        var v23824 = TypeScript$$23.SymbolFlags;
        var v20348 = v23824.Static;
        v5340.flags = v20347 | v20348;
      }
      if (isAmbient$$4) {
        var v5341 = groupType.symbol;
        var v20349 = v5341.flags;
        var v23825 = TypeScript$$23.SymbolFlags;
        var v20350 = v23825.Ambient;
        v5341.flags = v20349 | v20350;
      }
      if (isPrivate) {
        var v5342 = groupType.symbol;
        var v20351 = v5342.flags;
        var v23826 = TypeScript$$23.SymbolFlags;
        var v20352 = v23826.Private;
        v5342.flags = v20351 | v20352;
      }
      var v5343 = groupType.symbol;
      var v26950 = funcDecl$$17.isMethod();
      v5343.isMethod = v26950;
      var v14738 = groupType.symbol;
      var v5345 = v14738.isMethod;
      if (v5345) {
        var v5344 = groupType.symbol;
        var v20353 = v5344.flags;
        var v23827 = TypeScript$$23.SymbolFlags;
        var v20354 = v23827.Property;
        v5344.flags = v20353 | v20354;
      }
      funcDecl$$17.type = groupType;
      var v5359 = !isConstructor$$2;
      if (v5359) {
        var v23828 = funcName$$1;
        if (v23828) {
          v23828 = !isLambda$$2;
        }
        var v20355 = v23828;
        if (v20355) {
          var v23829 = funcDecl$$17.isAccessor();
          v20355 = !v23829;
        }
        var v14739 = v20355;
        if (v14739) {
          v14739 = !usedHint;
        }
        var v5358 = v14739;
        if (v5358) {
          if (addToScope) {
            var v14740 = funcDecl$$17.isMethod();
            if (v14740) {
              v14740 = isStatic$$6;
            }
            var v5353 = v14740;
            if (v5353) {
              var v25476 = container$$12.type;
              var v23830 = v25476.members;
              var v20356 = v23830.publicMembers;
              var v20357 = groupType.symbol;
              var v14741 = v20356.add(funcName$$1, v20357);
              var v5347 = !v14741;
              if (v5347) {
                var v5346 = this.errorReporter;
                v5346.duplicateIdentifier(funcDecl$$17, funcName$$1);
              }
              var v5348 = groupType.symbol;
              v5348.container = container$$12;
            } else {
              var v14742 = overloadGroupSym == null;
              var v20359 = !v14742;
              if (v20359) {
                var v23831 = overloadGroupSym.declAST;
                if (v23831) {
                  var v26166 = overloadGroupSym.declAST;
                  var v25477 = v26166.isOverload;
                  v23831 = !v25477;
                }
                var v20358 = v23831;
                if (v20358) {
                  v20358 = container$$12.isType();
                }
                v14742 = v20358;
              }
              var v5352 = v14742;
              if (v5352) {
                var v5349 = groupType.symbol;
                var v5350 = this.errorReporter;
                var v14743 = !isPrivate;
                if (v14743) {
                  var v20360 = isExported$$1 || isStatic$$6;
                  var v23832 = !v20360;
                  if (v23832) {
                    v20360 = isGlobal;
                  }
                  v14743 = v20360;
                }
                var v5351 = v14743;
                scope$$22.enter(container$$12, funcDecl$$17, v5349, v5350, v5351, false, isAmbient$$4);
              }
            }
          } else {
            var v14744 = funcDecl$$17.isSpecialFn();
            var v5355 = !v14744;
            if (v5355) {
              var v5354 = groupType.symbol;
              v5354.container = container$$12;
            }
          }
        } else {
          var v14745 = funcDecl$$17.isSpecialFn();
          var v5357 = !v14745;
          if (v5357) {
            var v5356 = groupType.symbol;
            v5356.container = container$$12;
          }
        }
      }
      if (useOverloadGroupSym) {
        var v5360;
        if (overloadGroupSym) {
          v5360 = overloadGroupSym.getType();
        } else {
          v5360 = null;
        }
        var overloadGroupType = v5360;
        var classType$$3 = groupType;
        var v5381 = classType$$3 != overloadGroupType;
        if (v5381) {
          var v14746 = classType$$3.construct;
          var v5366 = v14746 == null;
          if (v5366) {
            var v14747 = overloadGroupType;
            if (v14747) {
              v14747 = overloadGroupType.construct;
            }
            var v5362 = v14747;
            if (v5362) {
              classType$$3.construct = overloadGroupType.construct;
            } else {
              var v5361 = classType$$3;
              var v14748 = TypeScript$$23.SignatureGroup;
              var v26951 = new v14748;
              v5361.construct = v26951;
            }
          } else {
            if (overloadGroupType) {
              var v5365 = overloadGroupType.construct;
              if (v5365) {
                var v14749 = classType$$3.construct;
                var v5363 = v14749.signatures;
                var v14750 = overloadGroupType.construct;
                var v5364 = v14750.signatures;
                v5363.concat(v5364);
              }
            }
          }
          if (overloadGroupType) {
            var v14751 = classType$$3.call;
            var v5370 = v14751 == null;
            if (v5370) {
              classType$$3.call = overloadGroupType.call;
            } else {
              var v5369 = overloadGroupType.call;
              if (v5369) {
                var v14752 = classType$$3.call;
                var v5367 = v14752.signatures;
                var v14753 = overloadGroupType.call;
                var v5368 = v14753.signatures;
                v5367.concat(v5368);
              }
            }
            var v5376 = !isStatic$$6;
            if (v5376) {
              var v14754 = classType$$3.instanceType;
              var v5371 = v14754 == null;
              if (v5371) {
                classType$$3.instanceType = overloadGroupType.instanceType;
              }
              instanceType$$3 = classType$$3.instanceType;
              if (instanceType$$3) {
                var v14755 = instanceType$$3.call;
                var v5375 = v14755 == null;
                if (v5375) {
                  instanceType$$3.call = overloadGroupType.call;
                } else {
                  var v5374 = overloadGroupType.call;
                  if (v5374) {
                    var v14756 = instanceType$$3.call;
                    var v5372 = v14756.signatures;
                    var v14757 = overloadGroupType.call;
                    var v5373 = v14757.signatures;
                    v5372.concat(v5373);
                  }
                }
              }
            }
            var v14758 = classType$$3.index;
            var v5380 = v14758 == null;
            if (v5380) {
              classType$$3.index = overloadGroupType.index;
            } else {
              var v5379 = overloadGroupType.index;
              if (v5379) {
                var v14759 = classType$$3.index;
                var v5377 = v14759.signatures;
                var v14760 = overloadGroupType.index;
                var v5378 = v14760.signatures;
                v5377.concat(v5378);
              }
            }
          }
        }
      }
      return signature$$3;
    }
    function v928(funcDecl$$16, container$$11) {
      var args$$11 = funcDecl$$16.arguments;
      var parameterTable = null;
      var parameterBuilder = null;
      var v5382 = args$$11.members;
      var len$$25 = v5382.length;
      var nonOptionalParams = 0;
      var result$$27 = [];
      var v5398 = len$$25 > 0;
      if (v5398) {
        var v5383 = TypeScript$$23.ScopedMembers;
        var v14761 = TypeScript$$23.DualStringHashTable;
        var v20361 = TypeScript$$23.StringHashTable;
        var v14762 = new v20361;
        var v20362 = TypeScript$$23.StringHashTable;
        var v14763 = new v20362;
        var v5384 = new v14761(v14762, v14763);
        parameterTable = new v5383(v5384);
        var v5385 = TypeScript$$23.SymbolScopeBuilder;
        parameterBuilder = new v5385(parameterTable, null, null, null, null, container$$11);
        var i$$75 = 0;
        var v5397 = i$$75 < len$$25;
        for (;v5397;) {
          var v5386 = args$$11.members;
          var parameter$$1 = v5386[i$$75];
          var v5387 = TypeScript$$23.ValueLocation;
          var paramDef$$2 = new v5387;
          var v5388 = TypeScript$$23.ParameterSymbol;
          var v14764 = parameter$$1.id;
          var v5389 = v14764.text;
          var v5390 = parameter$$1.minChar;
          var v14765 = this.locationInfo;
          var v5391 = v14765.unitIndex;
          var parameterSymbol = new v5388(v5389, v5390, v5391, paramDef$$2);
          parameterSymbol.declAST = parameter$$1;
          parameterSymbol.funcDecl = funcDecl$$16;
          var v5392 = parameter$$1.id;
          v5392.sym = parameterSymbol;
          parameter$$1.sym = parameterSymbol;
          paramDef$$2.symbol = parameterSymbol;
          var v5393 = paramDef$$2;
          var v14766 = parameter$$1.typeExpr;
          var v26952 = TypeScript$$23.getTypeLink(v14766, this, false);
          v5393.typeLink = v26952;
          var v5394 = this.errorReporter;
          parameterBuilder.enter(null, parameter$$1, parameterSymbol, v5394, true, false, false);
          var v5395 = result$$27.length;
          result$$27[v5395] = parameterSymbol;
          var v14767 = parameter$$1.isOptionalArg();
          var v5396 = !v14767;
          if (v5396) {
            nonOptionalParams = nonOptionalParams + 1;
          }
          i$$75 = i$$75 + 1;
          v5397 = i$$75 < len$$25;
        }
      }
      return{parameters:result$$27, nonOptionalParameterCount:nonOptionalParams};
    }
    function v927(type$$40) {
      var v14768 = type$$40.arrayCache;
      var v5403 = v14768 == null;
      if (v5403) {
        var v5399 = type$$40;
        var v26953 = new ArrayCache;
        v5399.arrayCache = v26953;
        var v5400 = type$$40.arrayCache;
        var v14769 = TypeScript$$23.Type;
        var v26954 = new v14769;
        v5400.arrayType = v26954;
        var v14770 = type$$40.arrayCache;
        var v5401 = v14770.arrayType;
        v5401.elementType = type$$40;
        var v14771 = type$$40.arrayCache;
        var v5402 = v14771.arrayType;
        v5402.symbol = type$$40.symbol;
      }
      var v5404 = type$$40.arrayCache;
      return v5404.arrayType;
    }
    function v926(ast$$63) {
      var v14772 = ast$$63.nodeType;
      var v20363 = TypeScript$$23.NodeType;
      var v14773 = v20363.Script;
      var v5405 = v14772 == v14773;
      if (v5405) {
        var script$$14 = ast$$63;
        this.locationInfo = script$$14.locationInfo;
      }
      var v5406 = TypeScript$$23.ScopeChain;
      var v5407 = this.gloMod;
      var v5408 = this.globalScope;
      var globalChain = new v5406(v5407, null, v5408);
      var v5409 = TypeScript$$23.TypeCollectionContext;
      var context$$49 = new v5409(globalChain, this);
      var v5410 = TypeScript$$23.getAstWalkerFactory();
      var v5411 = TypeScript$$23.preCollectTypes;
      var v5412 = TypeScript$$23.postCollectTypes;
      v5410.walk(ast$$63, v5411, v5412, null, context$$49);
      return;
    }
    function v925() {
      var i$$74 = 0;
      var v20364 = this.provisionalStartedTypecheckObjects;
      var v14774 = v20364.length;
      var v5415 = i$$74 < v14774;
      for (;v5415;) {
        var v23833 = this.provisionalStartedTypecheckObjects;
        var v20365 = v23833[i$$74];
        var v14775 = v20365.typeCheckStatus;
        var v20366 = this.typingContextStack;
        var v14776 = v20366.getContextID();
        var v5414 = v14775 >= v14776;
        if (v5414) {
          var v14777 = this.provisionalStartedTypecheckObjects;
          var v5413 = v14777[i$$74];
          var v14778 = TypeScript$$23.TypeCheckStatus;
          v5413.typeCheckStatus = v14778.NotStarted;
        }
        i$$74 = i$$74 + 1;
        var v20367 = this.provisionalStartedTypecheckObjects;
        var v14779 = v20367.length;
        v5415 = i$$74 < v14779;
      }
      this.provisionalStartedTypecheckObjects = [];
      return;
    }
    function v924(pto) {
      var v5418 = this.inProvisionalTypecheckMode();
      if (v5418) {
        var v5416 = this.provisionalStartedTypecheckObjects;
        var v14780 = this.provisionalStartedTypecheckObjects;
        var v5417 = v14780.length;
        v5416[v5417] = pto;
      }
      return;
    }
    function v923(status) {
      var v20368 = TypeScript$$23.TypeCheckStatus;
      var v14781 = v20368.Finished;
      var v5419 = status == v14781;
      var v14783 = !v5419;
      if (v14783) {
        var v14782 = this.inProvisionalTypecheckMode();
        if (v14782) {
          var v20369 = status;
          var v23834 = this.typingContextStack;
          var v20370 = v23834.getContextID();
          v14782 = v20369 == v20370;
        }
        v5419 = v14782;
      }
      return v5419;
    }
    function v922() {
      var v5421 = this.inProvisionalTypecheckMode();
      if (v5421) {
        var v5420 = this.typingContextStack;
        return v5420.getContextID();
      }
      var v5422 = TypeScript$$23.TypeCheckStatus;
      return v5422.Finished;
    }
    function v921() {
      var v5423 = this.typingContextStack;
      return v5423.isProvisional();
    }
    function v920() {
      return this.currentContextualTypeContext;
    }
    function v919() {
      var v5424 = this.currentContextualTypeContext;
      if (v5424) {
        var v14784 = this.currentContextualTypeContext;
        v5424 = v14784.contextualType;
      }
      return v5424;
    }
    function v918() {
      this.currentContextualTypeContext = null;
      var v5425 = this.errorReporter;
      v5425.pushToErrorSink = false;
      return;
    }
    function v917() {
      var v5426 = this.typingContextStack;
      var v26955 = v5426.getContextualType();
      this.currentContextualTypeContext = v26955;
      return;
    }
    function v916(contextType, provisional$$3, condition, ast$$62) {
      if (condition) {
        var v20371 = this.typingContextStack;
        var v14785 = v20371.isProvisional();
        var v20372 = !v14785;
        if (v20372) {
          v14785 = provisional$$3;
        }
        var v5427 = v14785;
        this.setContextualType(contextType, v5427);
      }
      var v5428 = this.typeFlow;
      v5428.typeCheck(ast$$62);
      if (condition) {
        this.unsetContextualType();
      }
      return;
    }
    function v915() {
      var v20373 = this.typingContextStack;
      var v14786 = v20373.getContextualType();
      var v5430 = !v14786;
      if (v5430) {
        var v5429 = this.typingContextStack;
        v5429.hadProvisionalErrors = false;
      }
      return;
    }
    function v914() {
      var v5431 = this.typingContextStack;
      return v5431.hadProvisionalErrors;
    }
    function v913() {
      var v5432 = this.typingContextStack;
      var lastTC = v5432.popContextualType();
      var v5433 = this.typingContextStack;
      var v26956 = v5433.getContextualType();
      this.currentContextualTypeContext = v26956;
      return lastTC;
    }
    function v912(type$$39, provisional$$2) {
      var v5434 = this.typingContextStack;
      v5434.pushContextualType(type$$39, provisional$$2);
      var v5435 = this.typingContextStack;
      var v26957 = v5435.getContextualType();
      this.currentContextualTypeContext = v26957;
      return;
    }
    function v911(style) {
      this.styleSettings = style;
      return;
    }
    function TypeChecker$$1(persistentState) {
      this.persistentState = persistentState;
      this.errorReporter = null;
      this.checkControlFlow = false;
      this.printControlFlowGraph = false;
      this.checkControlFlowUseDef = false;
      this.styleSettings = null;
      this.units = null;
      this.anon = "_anonymous";
      this.locationInfo = null;
      this.typeFlow = null;
      this.currentCompareA = null;
      this.currentCompareB = null;
      this.currentModDecl = null;
      this.inBind = false;
      this.inWith = false;
      this.errorsOnWith = true;
      this.currentContextualTypeContext = null;
      this.resolvingBases = false;
      this.canCallDefinitionSignature = false;
      this.assignableCache = {};
      this.subtypeCache = {};
      this.identicalCache = {};
      this.provisionalStartedTypecheckObjects = [];
      this.mustCaptureGlobalThis = false;
      var v5436 = this.persistentState;
      this.voidType = v5436.voidType;
      var v5437 = this.persistentState;
      this.booleanType = v5437.booleanType;
      var v5438 = this.persistentState;
      this.numberType = v5438.doubleType;
      var v5439 = this.persistentState;
      this.stringType = v5439.stringType;
      var v5440 = this.persistentState;
      this.anyType = v5440.anyType;
      var v5441 = this.persistentState;
      this.nullType = v5441.nullType;
      var v5442 = this.persistentState;
      this.undefinedType = v5442.undefinedType;
      var v5443 = this.persistentState;
      this.globals = v5443.dualGlobalValues;
      var v5444 = this.persistentState;
      this.globalTypes = v5444.dualGlobalTypes;
      var v5445 = this.persistentState;
      this.ambientGlobals = v5445.dualAmbientGlobalValues;
      var v5446 = this.persistentState;
      this.ambientGlobalTypes = v5446.dualAmbientGlobalTypes;
      var v5447 = this.persistentState;
      this.gloModType = v5447.mod;
      var v5448 = this.persistentState;
      this.gloMod = v5448.gloMod;
      var v5449 = this.persistentState;
      this.wildElm = v5449.wildElm;
      var v5450 = this.persistentState;
      this.globalScope = v5450.globalScope;
      var v26958 = new ContextualTypingContextStack(this);
      this.typingContextStack = v26958;
      return;
    }
    var v5451 = TypeChecker$$1.prototype;
    v5451.setStyleOptions = v911;
    var v5452 = TypeChecker$$1.prototype;
    v5452.setContextualType = v912;
    var v5453 = TypeChecker$$1.prototype;
    v5453.unsetContextualType = v913;
    var v5454 = TypeChecker$$1.prototype;
    v5454.hadProvisionalErrors = v914;
    var v5455 = TypeChecker$$1.prototype;
    v5455.resetProvisionalErrors = v915;
    var v5456 = TypeChecker$$1.prototype;
    v5456.typeCheckWithContextualType = v916;
    var v5457 = TypeChecker$$1.prototype;
    v5457.resetTargetType = v917;
    var v5458 = TypeChecker$$1.prototype;
    v5458.killCurrentContextualType = v918;
    var v5459 = TypeChecker$$1.prototype;
    v5459.hasTargetType = v919;
    var v5460 = TypeChecker$$1.prototype;
    v5460.getTargetTypeContext = v920;
    var v5461 = TypeChecker$$1.prototype;
    v5461.inProvisionalTypecheckMode = v921;
    var v5462 = TypeChecker$$1.prototype;
    v5462.getTypeCheckFinishedStatus = v922;
    var v5463 = TypeChecker$$1.prototype;
    v5463.typeStatusIsFinished = v923;
    var v5464 = TypeChecker$$1.prototype;
    v5464.addStartedPTO = v924;
    var v5465 = TypeChecker$$1.prototype;
    v5465.cleanStartedPTO = v925;
    var v5466 = TypeChecker$$1.prototype;
    v5466.collectTypes = v926;
    var v5467 = TypeChecker$$1.prototype;
    v5467.makeArrayType = v927;
    var v5468 = TypeChecker$$1.prototype;
    v5468.getParameterList = v928;
    var v5469 = TypeChecker$$1.prototype;
    v5469.createFunctionSignature = v929;
    var v5470 = TypeChecker$$1.prototype;
    v5470.createAccessorSymbol = v930;
    var v5471 = TypeChecker$$1.prototype;
    v5471.addBases = v931;
    var v5472 = TypeChecker$$1.prototype;
    v5472.scopeOf = v932;
    var v5473 = TypeChecker$$1.prototype;
    v5473.lookupMemberTypeSymbol = v933;
    var v5474 = TypeChecker$$1.prototype;
    v5474.findSymbolForDynamicModule = v934;
    var v5475 = TypeChecker$$1.prototype;
    v5475.resolveTypeMember = v936;
    var v5476 = TypeChecker$$1.prototype;
    v5476.resolveFuncDecl = v937;
    var v5477 = TypeChecker$$1.prototype;
    v5477.resolveVarDecl = v938;
    var v5478 = TypeChecker$$1.prototype;
    v5478.resolveTypeLink = v939;
    var v5479 = TypeChecker$$1.prototype;
    v5479.resolveBaseTypeLink = v940;
    var v5480 = TypeChecker$$1.prototype;
    v5480.findMostApplicableSignature = v944;
    var v5481 = TypeChecker$$1.prototype;
    v5481.getApplicableSignatures = v945;
    var v5482 = TypeChecker$$1.prototype;
    v5482.canContextuallyTypeFunction = v946;
    var v5483 = TypeChecker$$1.prototype;
    v5483.canContextuallyTypeObjectLiteral = v947;
    var v5484 = TypeChecker$$1.prototype;
    v5484.widenType = v948;
    var v5485 = TypeChecker$$1.prototype;
    v5485.isNullOrUndefinedType = v949;
    var v5486 = TypeChecker$$1.prototype;
    v5486.findBestCommonType = v950;
    var v5487 = TypeChecker$$1.prototype;
    v5487.typesAreIdentical = v951;
    var v5488 = TypeChecker$$1.prototype;
    v5488.signatureGroupsAreIdentical = v952;
    var v5489 = TypeChecker$$1.prototype;
    v5489.signaturesAreIdentical = v953;
    var v5490 = TypeChecker$$1.prototype;
    v5490.sourceIsSubtypeOfTarget = v954;
    var v5491 = TypeChecker$$1.prototype;
    v5491.signatureGroupIsSubtypeOfTarget = v955;
    var v5492 = TypeChecker$$1.prototype;
    v5492.signatureIsSubtypeOfTarget = v956;
    var v5493 = TypeChecker$$1.prototype;
    v5493.sourceIsAssignableToTarget = v957;
    var v5494 = TypeChecker$$1.prototype;
    v5494.signatureGroupIsAssignableToTarget = v958;
    var v5495 = TypeChecker$$1.prototype;
    v5495.signatureIsAssignableToTarget = v959;
    var v5496 = TypeChecker$$1.prototype;
    v5496.sourceIsRelatableToTarget = v960;
    var v5497 = TypeChecker$$1.prototype;
    v5497.signatureGroupIsRelatableToTarget = v961;
    var v5498 = TypeChecker$$1.prototype;
    v5498.signatureIsRelatableToTarget = v962;
    return TypeChecker$$1;
  }
  function v910() {
    function v909() {
      var v5499;
      var v23835 = this.contextStack;
      var v20374 = v23835.length;
      var v14788 = !v20374;
      if (v14788) {
        v5499 = false;
      } else {
        var v20375 = this.contextStack;
        var v25478 = this.contextStack;
        var v23836 = v25478.length;
        var v20376 = v23836 - 1;
        var v14787 = v20375[v20376];
        v5499 = v14787.provisional;
      }
      return v5499;
    }
    function v908() {
      var v5500;
      var v23837 = this.contextStack;
      var v20377 = v23837.length;
      var v14791 = !v20377;
      if (v14791) {
        var v14789 = TypeScript$$23.TypeCheckStatus;
        v5500 = v14789.Finished;
      } else {
        var v20378 = this.contextStack;
        var v25479 = this.contextStack;
        var v23838 = v25479.length;
        var v20379 = v23838 - 1;
        var v14790 = v20378[v20379];
        v5500 = v14790.contextID;
      }
      return v5500;
    }
    function v907() {
      var v5501;
      var v23839 = this.contextStack;
      var v20380 = v23839.length;
      var v14794 = !v20380;
      if (v14794) {
        v5501 = null;
      } else {
        var v14792 = this.contextStack;
        var v23840 = this.contextStack;
        var v20381 = v23840.length;
        var v14793 = v20381 - 1;
        v5501 = v14792[v14793];
      }
      return v5501;
    }
    function v906() {
      var v5502 = this.contextStack;
      var tc$$2 = v5502.pop();
      var v14795 = this.checker;
      var v5503 = v14795.errorReporter;
      var v26959 = this.isProvisional();
      v5503.pushToErrorSink = v26959;
      var v5504 = this.hadProvisionalErrors;
      var v14797 = !v5504;
      if (v14797) {
        var v14796 = tc$$2.provisional;
        if (v14796) {
          var v25480 = this.checker;
          var v23841 = v25480.errorReporter;
          var v20382 = v23841.errorSink;
          v14796 = v20382.length;
        }
        v5504 = v14796;
      }
      this.hadProvisionalErrors = v5504;
      var v14798 = this.checker;
      var v5505 = v14798.errorReporter;
      v5505.freeCapturedErrors();
      return tc$$2;
    }
    function v905(type$$38, provisional$$1) {
      var v5506 = this.contextStack;
      var v14799 = ContextualTypingContextStack$$1.contextID;
      var v23842 = ContextualTypingContextStack$$1.contextID;
      ContextualTypingContextStack$$1.contextID = v23842 + 1;
      var v5507 = new ContextualTypeContext(type$$38, provisional$$1, v14799);
      v5506.push(v5507);
      var v14800 = this.checker;
      var v5508 = v14800.errorReporter;
      v5508.pushToErrorSink = provisional$$1;
      return;
    }
    function ContextualTypingContextStack$$1(checker$$16) {
      this.checker = checker$$16;
      this.contextStack = [];
      this.hadProvisionalErrors = false;
      return;
    }
    var v14801 = TypeScript$$23.TypeCheckStatus;
    var v5509 = v14801.Finished;
    ContextualTypingContextStack$$1.contextID = v5509 + 1;
    var v5510 = ContextualTypingContextStack$$1.prototype;
    v5510.pushContextualType = v905;
    var v5511 = ContextualTypingContextStack$$1.prototype;
    v5511.popContextualType = v906;
    var v5512 = ContextualTypingContextStack$$1.prototype;
    v5512.getContextualType = v907;
    var v5513 = ContextualTypingContextStack$$1.prototype;
    v5513.getContextID = v908;
    var v5514 = ContextualTypingContextStack$$1.prototype;
    v5514.isProvisional = v909;
    return ContextualTypingContextStack$$1;
  }
  function v904() {
    function ContextualTypeContext$$1(contextualType, provisional, contextID) {
      this.contextualType = contextualType;
      this.provisional = provisional;
      this.contextID = contextID;
      this.targetSig = null;
      this.targetThis = null;
      this.targetAccessorType = null;
      return;
    }
    return ContextualTypeContext$$1;
  }
  function v903() {
    function v902(name$$80, type$$37) {
      var v5515 = TypeScript$$23.ValueLocation;
      var valueLocation = new v5515;
      var v5516 = valueLocation;
      var v14802 = TypeScript$$23.TypeLink;
      var v26960 = new v14802;
      v5516.typeLink = v26960;
      var v5517 = TypeScript$$23.VariableSymbol;
      var sym$$28 = new v5517(name$$80, 0, -1, valueLocation);
      sym$$28.setType(type$$37);
      var v5518 = TypeScript$$23.TypeCheckStatus;
      sym$$28.typeCheckStatus = v5518.Finished;
      sym$$28.container = this.gloMod;
      var v5519 = this.importedGlobalsTable;
      v5519.addPublicMember(name$$80, sym$$28);
      return;
    }
    function v901() {
      var v5520 = TypeScript$$23.StringHashTable;
      var v26961 = new v5520;
      this.globals = v26961;
      var v5521 = TypeScript$$23.StringHashTable;
      var v26962 = new v5521;
      this.globalTypes = v26962;
      var v5522 = TypeScript$$23.StringHashTable;
      var v26963 = new v5522;
      this.ambientGlobals = v26963;
      var v5523 = TypeScript$$23.StringHashTable;
      var v26964 = new v5523;
      this.ambientGlobalTypes = v26964;
      var v5524 = this.globalTypes;
      var v20383 = this.voidType;
      var v14803 = v20383.symbol;
      var v5525 = v14803.name;
      var v14804 = this.voidType;
      var v5526 = v14804.symbol;
      v5524.add(v5525, v5526);
      var v5527 = this.globalTypes;
      var v20384 = this.booleanType;
      var v14805 = v20384.symbol;
      var v5528 = v14805.name;
      var v14806 = this.booleanType;
      var v5529 = v14806.symbol;
      v5527.add(v5528, v5529);
      var v5530 = this.globalTypes;
      var v20385 = this.doubleType;
      var v14807 = v20385.symbol;
      var v5531 = v14807.name;
      var v14808 = this.doubleType;
      var v5532 = v14808.symbol;
      v5530.add(v5531, v5532);
      var v5533 = this.globalTypes;
      var v14809 = this.doubleType;
      var v5534 = v14809.symbol;
      v5533.add("number", v5534);
      var v5535 = this.globalTypes;
      var v20386 = this.stringType;
      var v14810 = v20386.symbol;
      var v5536 = v14810.name;
      var v14811 = this.stringType;
      var v5537 = v14811.symbol;
      v5535.add(v5536, v5537);
      var v5538 = this.globalTypes;
      var v20387 = this.anyType;
      var v14812 = v20387.symbol;
      var v5539 = v14812.name;
      var v14813 = this.anyType;
      var v5540 = v14813.symbol;
      v5538.add(v5539, v5540);
      var v5541 = this.globalTypes;
      var v20388 = this.nullType;
      var v14814 = v20388.symbol;
      var v5542 = v14814.name;
      var v14815 = this.nullType;
      var v5543 = v14815.symbol;
      v5541.add(v5542, v5543);
      var v5544 = this.globalTypes;
      var v20389 = this.undefinedType;
      var v14816 = v20389.symbol;
      var v5545 = v14816.name;
      var v14817 = this.undefinedType;
      var v5546 = v14817.symbol;
      v5544.add(v5545, v5546);
      var v5547 = this.dualGlobalValues;
      v5547.secondaryTable = this.globals;
      var v5548 = this.dualGlobalTypes;
      v5548.secondaryTable = this.globalTypes;
      var v5549 = this.dualAmbientGlobalValues;
      v5549.secondaryTable = this.ambientGlobals;
      var v5550 = this.dualAmbientGlobalTypes;
      v5550.secondaryTable = this.ambientGlobalTypes;
      return;
    }
    function v900(mode$$7) {
      var v5551 = this.dualGlobalValues;
      var v14818 = this.dualGlobalTypes;
      var v20390 = this.dualAmbientGlobalValues;
      var v23843 = this.dualAmbientGlobalTypes;
      var v25481 = TypeCheckCollectionMode.Resident;
      this.residentTypeCheck = v5551.insertPrimary = v14818.insertPrimary = v20390.insertPrimary = v23843.insertPrimary = mode$$7 == v25481;
      return;
    }
    function v899(flags$$3, name$$79) {
      var v5552 = TypeScript$$23.Type;
      var primitive = new v5552;
      primitive.primitiveTypeClass = flags$$3;
      var v5553 = TypeScript$$23.TypeSymbol;
      var v5554 = name$$79.length;
      var symbol$$8 = new v5553(name$$79, -1, v5554, -1, primitive);
      var v5555 = TypeScript$$23.TypeCheckStatus;
      symbol$$8.typeCheckStatus = v5555.Finished;
      primitive.symbol = symbol$$8;
      var v5556 = this.importedGlobals;
      var v5557 = this.errorReporter;
      v5556.enter(null, null, symbol$$8, v5557, true, true, true);
      return primitive;
    }
    function PersistentGlobalTypeState$$1(errorReporter$$4) {
      this.errorReporter = errorReporter$$4;
      var v5558 = TypeScript$$23.ScopedMembers;
      var v14819 = TypeScript$$23.DualStringHashTable;
      var v20391 = TypeScript$$23.StringHashTable;
      var v14820 = new v20391;
      var v20392 = TypeScript$$23.StringHashTable;
      var v14821 = new v20392;
      var v5559 = new v14819(v14820, v14821);
      var v26965 = new v5558(v5559);
      this.importedGlobalsTable = v26965;
      var v5560 = TypeScript$$23.ScopedMembers;
      var v14822 = TypeScript$$23.DualStringHashTable;
      var v20393 = TypeScript$$23.StringHashTable;
      var v14823 = new v20393;
      var v20394 = TypeScript$$23.StringHashTable;
      var v14824 = new v20394;
      var v5561 = new v14822(v14823, v14824);
      var v26966 = new v5560(v5561);
      this.importedGlobalsTypeTable = v26966;
      this.globals = null;
      this.globalTypes = null;
      this.ambientGlobals = null;
      this.ambientGlobalTypes = null;
      var v5562 = TypeScript$$23.StringHashTable;
      var v26967 = new v5562;
      this.residentGlobalValues = v26967;
      var v5563 = TypeScript$$23.StringHashTable;
      var v26968 = new v5563;
      this.residentGlobalTypes = v26968;
      var v5564 = TypeScript$$23.StringHashTable;
      var v26969 = new v5564;
      this.residentGlobalAmbientValues = v26969;
      var v5565 = TypeScript$$23.StringHashTable;
      var v26970 = new v5565;
      this.residentGlobalAmbientTypes = v26970;
      this.residentTypeCheck = true;
      this.mod = null;
      this.gloMod = null;
      this.wildElm = null;
      var v5566 = TypeScript$$23.SymbolScopeBuilder;
      var v5567 = this.importedGlobalsTable;
      var v5568 = this.importedGlobalsTypeTable;
      var v26971 = new v5566(null, v5567, null, v5568, null, null);
      this.importedGlobals = v26971;
      var v5569 = TypeScript$$23.DualStringHashTable;
      var v5570 = this.residentGlobalValues;
      var v14825 = TypeScript$$23.StringHashTable;
      var v5571 = new v14825;
      var v26972 = new v5569(v5570, v5571);
      this.dualGlobalValues = v26972;
      var v5572 = TypeScript$$23.DualStringHashTable;
      var v5573 = this.residentGlobalTypes;
      var v14826 = TypeScript$$23.StringHashTable;
      var v5574 = new v14826;
      var v26973 = new v5572(v5573, v5574);
      this.dualGlobalTypes = v26973;
      var v5575 = TypeScript$$23.DualStringHashTable;
      var v5576 = this.residentGlobalAmbientValues;
      var v14827 = TypeScript$$23.StringHashTable;
      var v5577 = new v14827;
      var v26974 = new v5575(v5576, v5577);
      this.dualAmbientGlobalValues = v26974;
      var v5578 = TypeScript$$23.DualStringHashTable;
      var v5579 = this.residentGlobalAmbientTypes;
      var v14828 = TypeScript$$23.StringHashTable;
      var v5580 = new v14828;
      var v26975 = new v5578(v5579, v5580);
      this.dualAmbientGlobalTypes = v26975;
      var v5581 = TypeScript$$23.ScopedMembers;
      var v14829 = TypeScript$$23.DualStringHashTable;
      var v14830 = this.dualGlobalValues;
      var v20395 = TypeScript$$23.StringHashTable;
      var v14831 = new v20395;
      var v5582 = new v14829(v14830, v14831);
      var dualGlobalScopedMembers = new v5581(v5582);
      var v5583 = TypeScript$$23.ScopedMembers;
      var v14832 = TypeScript$$23.DualStringHashTable;
      var v14833 = this.dualAmbientGlobalValues;
      var v20396 = TypeScript$$23.StringHashTable;
      var v14834 = new v20396;
      var v5584 = new v14832(v14833, v14834);
      var dualGlobalScopedAmbientMembers = new v5583(v5584);
      var v5585 = TypeScript$$23.ScopedMembers;
      var v14835 = TypeScript$$23.DualStringHashTable;
      var v14836 = this.dualGlobalTypes;
      var v20397 = TypeScript$$23.StringHashTable;
      var v14837 = new v20397;
      var v5586 = new v14835(v14836, v14837);
      var dualGlobalScopedEnclosedTypes = new v5585(v5586);
      var v5587 = TypeScript$$23.ScopedMembers;
      var v14838 = TypeScript$$23.DualStringHashTable;
      var v14839 = this.dualAmbientGlobalTypes;
      var v20398 = TypeScript$$23.StringHashTable;
      var v14840 = new v20398;
      var v5588 = new v14838(v14839, v14840);
      var dualGlobalScopedAmbientEnclosedTypes = new v5587(v5588);
      var v5589 = TypeScript$$23.SymbolScopeBuilder;
      var v5590 = this.importedGlobals;
      var v26976 = new v5589(dualGlobalScopedMembers, dualGlobalScopedAmbientMembers, dualGlobalScopedEnclosedTypes, dualGlobalScopedAmbientEnclosedTypes, v5590, null);
      this.globalScope = v26976;
      var v14841 = TypeScript$$23.Primitive;
      var v5591 = v14841.Void;
      var v26977 = this.enterPrimitive(v5591, "void");
      this.voidType = v26977;
      var v14842 = TypeScript$$23.Primitive;
      var v5592 = v14842.Boolean;
      var v26978 = this.enterPrimitive(v5592, "bool");
      this.booleanType = v26978;
      var v14843 = TypeScript$$23.Primitive;
      var v5593 = v14843.Double;
      var v26979 = this.enterPrimitive(v5593, "number");
      this.doubleType = v26979;
      var v14844 = this.importedGlobals;
      var v5594 = v14844.ambientEnclosedTypes;
      var v14845 = this.doubleType;
      var v5595 = v14845.symbol;
      v5594.addPublicMember("number", v5595);
      var v14846 = TypeScript$$23.Primitive;
      var v5596 = v14846.String;
      var v26980 = this.enterPrimitive(v5596, "string");
      this.stringType = v26980;
      var v14847 = TypeScript$$23.Primitive;
      var v5597 = v14847.Any;
      var v26981 = this.enterPrimitive(v5597, "any");
      this.anyType = v26981;
      var v14848 = TypeScript$$23.Primitive;
      var v5598 = v14848.Null;
      var v26982 = this.enterPrimitive(v5598, "null");
      this.nullType = v26982;
      var v14849 = TypeScript$$23.Primitive;
      var v5599 = v14849.Undefined;
      var v26983 = this.enterPrimitive(v5599, "undefined");
      this.undefinedType = v26983;
      var v5600 = TypeCheckCollectionMode.Resident;
      this.setCollectionMode(v5600);
      var v5601 = TypeScript$$23.TypeSymbol;
      var v14850 = TypeScript$$23.Type;
      var v5602 = new v14850;
      var v26984 = new v5601("_element", -1, 0, -1, v5602);
      this.wildElm = v26984;
      var v5603 = this.importedGlobalsTypeTable;
      var v14851 = this.wildElm;
      var v5604 = v14851.name;
      var v5605 = this.wildElm;
      v5603.addPublicMember(v5604, v5605);
      var v5606 = TypeScript$$23.ModuleType;
      var v26985 = new v5606(dualGlobalScopedEnclosedTypes, dualGlobalScopedAmbientEnclosedTypes);
      this.mod = v26985;
      var v5607 = this.mod;
      v5607.members = dualGlobalScopedMembers;
      var v5608 = this.mod;
      v5608.ambientMembers = dualGlobalScopedAmbientMembers;
      var v5609 = this.mod;
      v5609.containedScope = this.globalScope;
      var v5610 = TypeScript$$23.TypeSymbol;
      var v5611 = TypeScript$$23.globalId;
      var v5612 = this.mod;
      var v26986 = new v5610(v5611, -1, 0, -1, v5612);
      this.gloMod = v26986;
      var v14852 = this.mod;
      var v5613 = v14852.members;
      var v14853 = this.gloMod;
      var v5614 = v14853.name;
      var v5615 = this.gloMod;
      v5613.addPublicMember(v5614, v5615);
      var v5616 = this.undefinedType;
      this.defineGlobalValue("undefined", v5616);
      return;
    }
    var v5617 = PersistentGlobalTypeState$$1.prototype;
    v5617.enterPrimitive = v899;
    var v5618 = PersistentGlobalTypeState$$1.prototype;
    v5618.setCollectionMode = v900;
    var v5619 = PersistentGlobalTypeState$$1.prototype;
    v5619.refreshPersistentState = v901;
    var v5620 = PersistentGlobalTypeState$$1.prototype;
    v5620.defineGlobalValue = v902;
    return PersistentGlobalTypeState$$1;
  }
  function v898(TypeCheckCollectionMode$$1) {
    TypeCheckCollectionMode$$1._map = [];
    var v5621 = TypeCheckCollectionMode$$1._map;
    v5621[0] = "Resident";
    TypeCheckCollectionMode$$1.Resident = 0;
    var v5622 = TypeCheckCollectionMode$$1._map;
    v5622[1] = "Transient";
    TypeCheckCollectionMode$$1.Transient = 1;
    return;
  }
  function v897() {
    function v896(message$$18) {
      this.message = message$$18;
      return;
    }
    function v895(message$$17) {
      var v14854 = this.onlyCaptureFirstError;
      var v5624 = !v14854;
      if (v5624) {
        var v5623;
        var v14857 = this.message;
        if (v14857) {
          var v14855 = message$$17 + ":\n\t";
          var v14856 = this.message;
          v5623 = v14855 + v14856;
        } else {
          v5623 = message$$17;
        }
        this.message = v5623;
      } else {
        this.setMessage(message$$17);
      }
      return;
    }
    function TypeComparisonInfo$$1() {
      this.onlyCaptureFirstError = false;
      var v5625 = TypeScript$$23.TypeRelationshipFlags;
      this.flags = v5625.SuccessfulComparison;
      this.message = "";
      return;
    }
    var v5626 = TypeComparisonInfo$$1.prototype;
    v5626.addMessageToFront = v895;
    var v5627 = TypeComparisonInfo$$1.prototype;
    v5627.setMessage = v896;
    return TypeComparisonInfo$$1;
  }
  function v894() {
    function v893(arrInstType, checker$$15) {
      var v14858 = this.arrayBase;
      var v5630 = v14858 == null;
      if (v5630) {
        var v14859 = checker$$15.wildElm;
        var v5628 = v14859.type;
        var v14860 = this.arrayType;
        var v5629 = v14860.elementType;
        var v26987 = arrInstType.specializeType(v5628, v5629, checker$$15, true);
        this.arrayBase = v26987;
      }
      return this.arrayBase;
    }
    function ArrayCache$$1() {
      this.arrayBase = null;
      return;
    }
    var v5631 = ArrayCache$$1.prototype;
    v5631.specialize = v893;
    return ArrayCache$$1;
  }
  var ArrayCache = v894();
  TypeScript$$23.ArrayCache = ArrayCache;
  var TypeComparisonInfo = v897();
  TypeScript$$23.TypeComparisonInfo = TypeComparisonInfo;
  var v14861 = TypeScript$$23.TypeCheckCollectionMode;
  var v20399 = !v14861;
  if (v20399) {
    v14861 = TypeScript$$23.TypeCheckCollectionMode = {};
  }
  var v5632 = v14861;
  v898(v5632);
  var TypeCheckCollectionMode = TypeScript$$23.TypeCheckCollectionMode;
  var PersistentGlobalTypeState = v903();
  TypeScript$$23.PersistentGlobalTypeState = PersistentGlobalTypeState;
  var ContextualTypeContext = v904();
  TypeScript$$23.ContextualTypeContext = ContextualTypeContext;
  var ContextualTypingContextStack = v910();
  TypeScript$$23.ContextualTypingContextStack = ContextualTypingContextStack;
  var TypeChecker = v963();
  TypeScript$$23.TypeChecker = TypeChecker;
  return;
}
function v892(TypeScript$$22) {
  function v891(_super$$64) {
    function v890() {
      return TokenClass.RegExpLiteral;
    }
    function v889() {
      var v5633 = this.regex;
      return v5633.toString();
    }
    function RegularExpressionLiteralToken$$1(regex$$3) {
      var v5634 = TokenID.RegularExpressionLiteral;
      _super$$64.call(this, v5634);
      this.regex = regex$$3;
      return;
    }
    __extends(RegularExpressionLiteralToken$$1, _super$$64);
    var v5635 = RegularExpressionLiteralToken$$1.prototype;
    v5635.getText = v889;
    var v5636 = RegularExpressionLiteralToken$$1.prototype;
    v5636.classification = v890;
    return RegularExpressionLiteralToken$$1;
  }
  function v888(_super$$63) {
    function v887() {
      return TokenClass.Comment;
    }
    function v886() {
      return this.value;
    }
    function CommentToken$$1(tokenID, value$$39, isBlock, startPos$$2, line$$11, endsLine$$2) {
      _super$$63.call(this, tokenID);
      this.value = value$$39;
      this.isBlock = isBlock;
      this.startPos = startPos$$2;
      this.line = line$$11;
      this.endsLine = endsLine$$2;
      return;
    }
    __extends(CommentToken$$1, _super$$63);
    var v5637 = CommentToken$$1.prototype;
    v5637.getText = v886;
    var v5638 = CommentToken$$1.prototype;
    v5638.classification = v887;
    return CommentToken$$1;
  }
  function v885(_super$$62) {
    function v884() {
      return TokenClass.Whitespace;
    }
    function v883() {
      return this.value;
    }
    function WhitespaceToken$$1(tokenId$$48, value$$38) {
      _super$$62.call(this, tokenId$$48);
      this.value = value$$38;
      return;
    }
    __extends(WhitespaceToken$$1, _super$$62);
    var v5639 = WhitespaceToken$$1.prototype;
    v5639.getText = v883;
    var v5640 = WhitespaceToken$$1.prototype;
    v5640.classification = v884;
    return WhitespaceToken$$1;
  }
  function v882(_super$$61) {
    function v881() {
      return TokenClass.Identifier;
    }
    function v880() {
      return this.value;
    }
    function IdentifierToken$$1(value$$37, hasEscapeSequence$$3) {
      var v5641 = TokenID.Identifier;
      _super$$61.call(this, v5641);
      this.value = value$$37;
      this.hasEscapeSequence = hasEscapeSequence$$3;
      return;
    }
    __extends(IdentifierToken$$1, _super$$61);
    var v5642 = IdentifierToken$$1.prototype;
    v5642.getText = v880;
    var v5643 = IdentifierToken$$1.prototype;
    v5643.classification = v881;
    return IdentifierToken$$1;
  }
  function v879(_super$$60) {
    function v878() {
      return TokenClass.StringLiteral;
    }
    function v877() {
      return this.value;
    }
    function StringLiteralToken$$1(value$$36) {
      var v5644 = TokenID.StringLiteral;
      _super$$60.call(this, v5644);
      this.value = value$$36;
      return;
    }
    __extends(StringLiteralToken$$1, _super$$60);
    var v5645 = StringLiteralToken$$1.prototype;
    v5645.getText = v877;
    var v5646 = StringLiteralToken$$1.prototype;
    v5646.classification = v878;
    return StringLiteralToken$$1;
  }
  function v876(_super$$59) {
    function v875() {
      return TokenClass.NumberLiteral;
    }
    function v874() {
      var v5647;
      var v14864 = this.hasEmptyFraction;
      if (v14864) {
        var v20400 = this.value;
        var v14862 = v20400.toString();
        v5647 = v14862 + ".0";
      } else {
        var v14863 = this.value;
        v5647 = v14863.toString();
      }
      return v5647;
    }
    function NumberLiteralToken$$1(value$$35, hasEmptyFraction$$1) {
      var v5648 = TokenID.NumberLiteral;
      _super$$59.call(this, v5648);
      this.value = value$$35;
      this.hasEmptyFraction = hasEmptyFraction$$1;
      return;
    }
    __extends(NumberLiteralToken$$1, _super$$59);
    var v5649 = NumberLiteralToken$$1.prototype;
    v5649.getText = v874;
    var v5650 = NumberLiteralToken$$1.prototype;
    v5650.classification = v875;
    return NumberLiteralToken$$1;
  }
  function v873() {
    function v872() {
      var v14865 = this.tokenId;
      var v14866 = TokenID.LimKeyword;
      var v5654 = v14865 <= v14866;
      if (v5654) {
        return TokenClass.Keyword;
      } else {
        var v5651 = this.tokenId;
        var tokenInfo$$2 = lookupToken(v5651);
        var v5653 = tokenInfo$$2 != undefined;
        if (v5653) {
          var v20401 = tokenInfo$$2.unopNodeType;
          var v23844 = TypeScript$$22.NodeType;
          var v20402 = v23844.None;
          var v14867 = v20401 != v20402;
          var v20405 = !v14867;
          if (v20405) {
            var v20403 = tokenInfo$$2.binopNodeType;
            var v23845 = TypeScript$$22.NodeType;
            var v20404 = v23845.None;
            v14867 = v20403 != v20404;
          }
          var v5652 = v14867;
          if (v5652) {
            return TokenClass.Operator;
          }
        }
      }
      return TokenClass.Punctuation;
    }
    function v871() {
      var v14868 = TypeScript$$22.tokenTable;
      var v14869 = this.tokenId;
      var v5655 = v14868[v14869];
      return v5655.text;
    }
    function v870(line$$10, outfile$$11) {
      var v20406 = this.toString();
      var v14870 = v20406 + ",on line";
      var v5656 = v14870 + line$$10;
      outfile$$11.WriteLine(v5656);
      return;
    }
    function v869() {
      var v26167 = this.tokenId;
      var v25482 = "token: " + v26167;
      var v23846 = v25482 + " ";
      var v23847 = this.getText();
      var v20407 = v23846 + v23847;
      var v14871 = v20407 + " (";
      var v20408 = TokenID._map;
      var v20409 = this.tokenId;
      var v14872 = v20408[v20409];
      var v5657 = v14871 + v14872;
      return v5657 + ")";
    }
    function Token$$1(tokenId$$47) {
      this.tokenId = tokenId$$47;
      return;
    }
    var v5658 = Token$$1.prototype;
    v5658.toString = v869;
    var v5659 = Token$$1.prototype;
    v5659.print = v870;
    var v5660 = Token$$1.prototype;
    v5660.getText = v871;
    var v5661 = Token$$1.prototype;
    v5661.classification = v872;
    return Token$$1;
  }
  function v868() {
    function SavedToken$$1(tok$$4, minChar$$32, limChar$$11) {
      this.tok = tok$$4;
      this.minChar = minChar$$32;
      this.limChar = limChar$$11;
      return;
    }
    return SavedToken$$1;
  }
  function v867(TokenClass$$1) {
    TokenClass$$1._map = [];
    var v5662 = TokenClass$$1._map;
    v5662[0] = "Punctuation";
    TokenClass$$1.Punctuation = 0;
    var v5663 = TokenClass$$1._map;
    v5663[1] = "Keyword";
    TokenClass$$1.Keyword = 1;
    var v5664 = TokenClass$$1._map;
    v5664[2] = "Operator";
    TokenClass$$1.Operator = 2;
    var v5665 = TokenClass$$1._map;
    v5665[3] = "Comment";
    TokenClass$$1.Comment = 3;
    var v5666 = TokenClass$$1._map;
    v5666[4] = "Whitespace";
    TokenClass$$1.Whitespace = 4;
    var v5667 = TokenClass$$1._map;
    v5667[5] = "Identifier";
    TokenClass$$1.Identifier = 5;
    var v5668 = TokenClass$$1._map;
    v5668[6] = "NumberLiteral";
    TokenClass$$1.NumberLiteral = 6;
    var v5669 = TokenClass$$1._map;
    v5669[7] = "StringLiteral";
    TokenClass$$1.StringLiteral = 7;
    var v5670 = TokenClass$$1._map;
    v5670[8] = "RegExpLiteral";
    TokenClass$$1.RegExpLiteral = 8;
    return;
  }
  function v866() {
    function TokenInfo$$1(tokenId$$46, reservation$$1, binopPrecedence$$1, binopNodeType$$1, unopPrecedence$$1, unopNodeType$$1, text$$22, ers$$2) {
      this.tokenId = tokenId$$46;
      this.reservation = reservation$$1;
      this.binopPrecedence = binopPrecedence$$1;
      this.binopNodeType = binopNodeType$$1;
      this.unopPrecedence = unopPrecedence$$1;
      this.unopNodeType = unopNodeType$$1;
      this.text = text$$22;
      this.ers = ers$$2;
      return;
    }
    return TokenInfo$$1;
  }
  function v865(Reservation$$1) {
    Reservation$$1._map = [];
    Reservation$$1.None = 0;
    Reservation$$1.Javascript = 1;
    Reservation$$1.JavascriptFuture = 2;
    Reservation$$1.TypeScript = 4;
    Reservation$$1.JavascriptFutureStrict = 8;
    var v5671 = Reservation$$1.Javascript;
    var v5672 = Reservation$$1.TypeScript;
    Reservation$$1.TypeScriptAndJS = v5671 | v5672;
    var v5673 = Reservation$$1.JavascriptFuture;
    var v5674 = Reservation$$1.TypeScript;
    Reservation$$1.TypeScriptAndJSFuture = v5673 | v5674;
    var v5675 = Reservation$$1.JavascriptFutureStrict;
    var v5676 = Reservation$$1.TypeScript;
    Reservation$$1.TypeScriptAndJSFutureStrict = v5675 | v5676;
    return;
  }
  function v864(OperatorPrecedence$$1) {
    OperatorPrecedence$$1._map = [];
    var v5677 = OperatorPrecedence$$1._map;
    v5677[0] = "None";
    OperatorPrecedence$$1.None = 0;
    var v5678 = OperatorPrecedence$$1._map;
    v5678[1] = "Comma";
    OperatorPrecedence$$1.Comma = 1;
    var v5679 = OperatorPrecedence$$1._map;
    v5679[2] = "Assignment";
    OperatorPrecedence$$1.Assignment = 2;
    var v5680 = OperatorPrecedence$$1._map;
    v5680[3] = "Conditional";
    OperatorPrecedence$$1.Conditional = 3;
    var v5681 = OperatorPrecedence$$1._map;
    v5681[4] = "LogicalOr";
    OperatorPrecedence$$1.LogicalOr = 4;
    var v5682 = OperatorPrecedence$$1._map;
    v5682[5] = "LogicalAnd";
    OperatorPrecedence$$1.LogicalAnd = 5;
    var v5683 = OperatorPrecedence$$1._map;
    v5683[6] = "BitwiseOr";
    OperatorPrecedence$$1.BitwiseOr = 6;
    var v5684 = OperatorPrecedence$$1._map;
    v5684[7] = "BitwiseExclusiveOr";
    OperatorPrecedence$$1.BitwiseExclusiveOr = 7;
    var v5685 = OperatorPrecedence$$1._map;
    v5685[8] = "BitwiseAnd";
    OperatorPrecedence$$1.BitwiseAnd = 8;
    var v5686 = OperatorPrecedence$$1._map;
    v5686[9] = "Equality";
    OperatorPrecedence$$1.Equality = 9;
    var v5687 = OperatorPrecedence$$1._map;
    v5687[10] = "Relational";
    OperatorPrecedence$$1.Relational = 10;
    var v5688 = OperatorPrecedence$$1._map;
    v5688[11] = "Shift";
    OperatorPrecedence$$1.Shift = 11;
    var v5689 = OperatorPrecedence$$1._map;
    v5689[12] = "Additive";
    OperatorPrecedence$$1.Additive = 12;
    var v5690 = OperatorPrecedence$$1._map;
    v5690[13] = "Multiplicative";
    OperatorPrecedence$$1.Multiplicative = 13;
    var v5691 = OperatorPrecedence$$1._map;
    v5691[14] = "Unary";
    OperatorPrecedence$$1.Unary = 14;
    var v5692 = OperatorPrecedence$$1._map;
    v5692[15] = "Lim";
    OperatorPrecedence$$1.Lim = 15;
    return;
  }
  function v863(TokenID$$1) {
    TokenID$$1._map = [];
    var v5693 = TokenID$$1._map;
    v5693[0] = "Any";
    TokenID$$1.Any = 0;
    var v5694 = TokenID$$1._map;
    v5694[1] = "Bool";
    TokenID$$1.Bool = 1;
    var v5695 = TokenID$$1._map;
    v5695[2] = "Break";
    TokenID$$1.Break = 2;
    var v5696 = TokenID$$1._map;
    v5696[3] = "Case";
    TokenID$$1.Case = 3;
    var v5697 = TokenID$$1._map;
    v5697[4] = "Catch";
    TokenID$$1.Catch = 4;
    var v5698 = TokenID$$1._map;
    v5698[5] = "Class";
    TokenID$$1.Class = 5;
    var v5699 = TokenID$$1._map;
    v5699[6] = "Const";
    TokenID$$1.Const = 6;
    var v5700 = TokenID$$1._map;
    v5700[7] = "Continue";
    TokenID$$1.Continue = 7;
    var v5701 = TokenID$$1._map;
    v5701[8] = "Debugger";
    TokenID$$1.Debugger = 8;
    var v5702 = TokenID$$1._map;
    v5702[9] = "Default";
    TokenID$$1.Default = 9;
    var v5703 = TokenID$$1._map;
    v5703[10] = "Delete";
    TokenID$$1.Delete = 10;
    var v5704 = TokenID$$1._map;
    v5704[11] = "Do";
    TokenID$$1.Do = 11;
    var v5705 = TokenID$$1._map;
    v5705[12] = "Else";
    TokenID$$1.Else = 12;
    var v5706 = TokenID$$1._map;
    v5706[13] = "Enum";
    TokenID$$1.Enum = 13;
    var v5707 = TokenID$$1._map;
    v5707[14] = "Export";
    TokenID$$1.Export = 14;
    var v5708 = TokenID$$1._map;
    v5708[15] = "Extends";
    TokenID$$1.Extends = 15;
    var v5709 = TokenID$$1._map;
    v5709[16] = "Declare";
    TokenID$$1.Declare = 16;
    var v5710 = TokenID$$1._map;
    v5710[17] = "False";
    TokenID$$1.False = 17;
    var v5711 = TokenID$$1._map;
    v5711[18] = "Finally";
    TokenID$$1.Finally = 18;
    var v5712 = TokenID$$1._map;
    v5712[19] = "For";
    TokenID$$1.For = 19;
    var v5713 = TokenID$$1._map;
    v5713[20] = "Function";
    TokenID$$1.Function = 20;
    var v5714 = TokenID$$1._map;
    v5714[21] = "Constructor";
    TokenID$$1.Constructor = 21;
    var v5715 = TokenID$$1._map;
    v5715[22] = "Get";
    TokenID$$1.Get = 22;
    var v5716 = TokenID$$1._map;
    v5716[23] = "If";
    TokenID$$1.If = 23;
    var v5717 = TokenID$$1._map;
    v5717[24] = "Implements";
    TokenID$$1.Implements = 24;
    var v5718 = TokenID$$1._map;
    v5718[25] = "Import";
    TokenID$$1.Import = 25;
    var v5719 = TokenID$$1._map;
    v5719[26] = "In";
    TokenID$$1.In = 26;
    var v5720 = TokenID$$1._map;
    v5720[27] = "InstanceOf";
    TokenID$$1.InstanceOf = 27;
    var v5721 = TokenID$$1._map;
    v5721[28] = "Interface";
    TokenID$$1.Interface = 28;
    var v5722 = TokenID$$1._map;
    v5722[29] = "Let";
    TokenID$$1.Let = 29;
    var v5723 = TokenID$$1._map;
    v5723[30] = "Module";
    TokenID$$1.Module = 30;
    var v5724 = TokenID$$1._map;
    v5724[31] = "New";
    TokenID$$1.New = 31;
    var v5725 = TokenID$$1._map;
    v5725[32] = "Number";
    TokenID$$1.Number = 32;
    var v5726 = TokenID$$1._map;
    v5726[33] = "Null";
    TokenID$$1.Null = 33;
    var v5727 = TokenID$$1._map;
    v5727[34] = "Package";
    TokenID$$1.Package = 34;
    var v5728 = TokenID$$1._map;
    v5728[35] = "Private";
    TokenID$$1.Private = 35;
    var v5729 = TokenID$$1._map;
    v5729[36] = "Protected";
    TokenID$$1.Protected = 36;
    var v5730 = TokenID$$1._map;
    v5730[37] = "Public";
    TokenID$$1.Public = 37;
    var v5731 = TokenID$$1._map;
    v5731[38] = "Return";
    TokenID$$1.Return = 38;
    var v5732 = TokenID$$1._map;
    v5732[39] = "Set";
    TokenID$$1.Set = 39;
    var v5733 = TokenID$$1._map;
    v5733[40] = "Static";
    TokenID$$1.Static = 40;
    var v5734 = TokenID$$1._map;
    v5734[41] = "String";
    TokenID$$1.String = 41;
    var v5735 = TokenID$$1._map;
    v5735[42] = "Super";
    TokenID$$1.Super = 42;
    var v5736 = TokenID$$1._map;
    v5736[43] = "Switch";
    TokenID$$1.Switch = 43;
    var v5737 = TokenID$$1._map;
    v5737[44] = "This";
    TokenID$$1.This = 44;
    var v5738 = TokenID$$1._map;
    v5738[45] = "Throw";
    TokenID$$1.Throw = 45;
    var v5739 = TokenID$$1._map;
    v5739[46] = "True";
    TokenID$$1.True = 46;
    var v5740 = TokenID$$1._map;
    v5740[47] = "Try";
    TokenID$$1.Try = 47;
    var v5741 = TokenID$$1._map;
    v5741[48] = "TypeOf";
    TokenID$$1.TypeOf = 48;
    var v5742 = TokenID$$1._map;
    v5742[49] = "Var";
    TokenID$$1.Var = 49;
    var v5743 = TokenID$$1._map;
    v5743[50] = "Void";
    TokenID$$1.Void = 50;
    var v5744 = TokenID$$1._map;
    v5744[51] = "With";
    TokenID$$1.With = 51;
    var v5745 = TokenID$$1._map;
    v5745[52] = "While";
    TokenID$$1.While = 52;
    var v5746 = TokenID$$1._map;
    v5746[53] = "Yield";
    TokenID$$1.Yield = 53;
    var v5747 = TokenID$$1._map;
    v5747[54] = "Semicolon";
    TokenID$$1.Semicolon = 54;
    var v5748 = TokenID$$1._map;
    v5748[55] = "OpenParen";
    TokenID$$1.OpenParen = 55;
    var v5749 = TokenID$$1._map;
    v5749[56] = "CloseParen";
    TokenID$$1.CloseParen = 56;
    var v5750 = TokenID$$1._map;
    v5750[57] = "OpenBracket";
    TokenID$$1.OpenBracket = 57;
    var v5751 = TokenID$$1._map;
    v5751[58] = "CloseBracket";
    TokenID$$1.CloseBracket = 58;
    var v5752 = TokenID$$1._map;
    v5752[59] = "OpenBrace";
    TokenID$$1.OpenBrace = 59;
    var v5753 = TokenID$$1._map;
    v5753[60] = "CloseBrace";
    TokenID$$1.CloseBrace = 60;
    var v5754 = TokenID$$1._map;
    v5754[61] = "Comma";
    TokenID$$1.Comma = 61;
    var v5755 = TokenID$$1._map;
    v5755[62] = "Equals";
    TokenID$$1.Equals = 62;
    var v5756 = TokenID$$1._map;
    v5756[63] = "PlusEquals";
    TokenID$$1.PlusEquals = 63;
    var v5757 = TokenID$$1._map;
    v5757[64] = "MinusEquals";
    TokenID$$1.MinusEquals = 64;
    var v5758 = TokenID$$1._map;
    v5758[65] = "AsteriskEquals";
    TokenID$$1.AsteriskEquals = 65;
    var v5759 = TokenID$$1._map;
    v5759[66] = "SlashEquals";
    TokenID$$1.SlashEquals = 66;
    var v5760 = TokenID$$1._map;
    v5760[67] = "PercentEquals";
    TokenID$$1.PercentEquals = 67;
    var v5761 = TokenID$$1._map;
    v5761[68] = "AmpersandEquals";
    TokenID$$1.AmpersandEquals = 68;
    var v5762 = TokenID$$1._map;
    v5762[69] = "CaretEquals";
    TokenID$$1.CaretEquals = 69;
    var v5763 = TokenID$$1._map;
    v5763[70] = "BarEquals";
    TokenID$$1.BarEquals = 70;
    var v5764 = TokenID$$1._map;
    v5764[71] = "LessThanLessThanEquals";
    TokenID$$1.LessThanLessThanEquals = 71;
    var v5765 = TokenID$$1._map;
    v5765[72] = "GreaterThanGreaterThanEquals";
    TokenID$$1.GreaterThanGreaterThanEquals = 72;
    var v5766 = TokenID$$1._map;
    v5766[73] = "GreaterThanGreaterThanGreaterThanEquals";
    TokenID$$1.GreaterThanGreaterThanGreaterThanEquals = 73;
    var v5767 = TokenID$$1._map;
    v5767[74] = "Question";
    TokenID$$1.Question = 74;
    var v5768 = TokenID$$1._map;
    v5768[75] = "Colon";
    TokenID$$1.Colon = 75;
    var v5769 = TokenID$$1._map;
    v5769[76] = "BarBar";
    TokenID$$1.BarBar = 76;
    var v5770 = TokenID$$1._map;
    v5770[77] = "AmpersandAmpersand";
    TokenID$$1.AmpersandAmpersand = 77;
    var v5771 = TokenID$$1._map;
    v5771[78] = "Bar";
    TokenID$$1.Bar = 78;
    var v5772 = TokenID$$1._map;
    v5772[79] = "Caret";
    TokenID$$1.Caret = 79;
    var v5773 = TokenID$$1._map;
    v5773[80] = "And";
    TokenID$$1.And = 80;
    var v5774 = TokenID$$1._map;
    v5774[81] = "EqualsEquals";
    TokenID$$1.EqualsEquals = 81;
    var v5775 = TokenID$$1._map;
    v5775[82] = "ExclamationEquals";
    TokenID$$1.ExclamationEquals = 82;
    var v5776 = TokenID$$1._map;
    v5776[83] = "EqualsEqualsEquals";
    TokenID$$1.EqualsEqualsEquals = 83;
    var v5777 = TokenID$$1._map;
    v5777[84] = "ExclamationEqualsEquals";
    TokenID$$1.ExclamationEqualsEquals = 84;
    var v5778 = TokenID$$1._map;
    v5778[85] = "LessThan";
    TokenID$$1.LessThan = 85;
    var v5779 = TokenID$$1._map;
    v5779[86] = "LessThanEquals";
    TokenID$$1.LessThanEquals = 86;
    var v5780 = TokenID$$1._map;
    v5780[87] = "GreaterThan";
    TokenID$$1.GreaterThan = 87;
    var v5781 = TokenID$$1._map;
    v5781[88] = "GreaterThanEquals";
    TokenID$$1.GreaterThanEquals = 88;
    var v5782 = TokenID$$1._map;
    v5782[89] = "LessThanLessThan";
    TokenID$$1.LessThanLessThan = 89;
    var v5783 = TokenID$$1._map;
    v5783[90] = "GreaterThanGreaterThan";
    TokenID$$1.GreaterThanGreaterThan = 90;
    var v5784 = TokenID$$1._map;
    v5784[91] = "GreaterThanGreaterThanGreaterThan";
    TokenID$$1.GreaterThanGreaterThanGreaterThan = 91;
    var v5785 = TokenID$$1._map;
    v5785[92] = "Plus";
    TokenID$$1.Plus = 92;
    var v5786 = TokenID$$1._map;
    v5786[93] = "Minus";
    TokenID$$1.Minus = 93;
    var v5787 = TokenID$$1._map;
    v5787[94] = "Asterisk";
    TokenID$$1.Asterisk = 94;
    var v5788 = TokenID$$1._map;
    v5788[95] = "Slash";
    TokenID$$1.Slash = 95;
    var v5789 = TokenID$$1._map;
    v5789[96] = "Percent";
    TokenID$$1.Percent = 96;
    var v5790 = TokenID$$1._map;
    v5790[97] = "Tilde";
    TokenID$$1.Tilde = 97;
    var v5791 = TokenID$$1._map;
    v5791[98] = "Exclamation";
    TokenID$$1.Exclamation = 98;
    var v5792 = TokenID$$1._map;
    v5792[99] = "PlusPlus";
    TokenID$$1.PlusPlus = 99;
    var v5793 = TokenID$$1._map;
    v5793[100] = "MinusMinus";
    TokenID$$1.MinusMinus = 100;
    var v5794 = TokenID$$1._map;
    v5794[101] = "Dot";
    TokenID$$1.Dot = 101;
    var v5795 = TokenID$$1._map;
    v5795[102] = "DotDotDot";
    TokenID$$1.DotDotDot = 102;
    var v5796 = TokenID$$1._map;
    v5796[103] = "Error";
    TokenID$$1.Error = 103;
    var v5797 = TokenID$$1._map;
    v5797[104] = "EndOfFile";
    TokenID$$1.EndOfFile = 104;
    var v5798 = TokenID$$1._map;
    v5798[105] = "EqualsGreaterThan";
    TokenID$$1.EqualsGreaterThan = 105;
    var v5799 = TokenID$$1._map;
    v5799[106] = "Identifier";
    TokenID$$1.Identifier = 106;
    var v5800 = TokenID$$1._map;
    v5800[107] = "StringLiteral";
    TokenID$$1.StringLiteral = 107;
    var v5801 = TokenID$$1._map;
    v5801[108] = "RegularExpressionLiteral";
    TokenID$$1.RegularExpressionLiteral = 108;
    var v5802 = TokenID$$1._map;
    v5802[109] = "NumberLiteral";
    TokenID$$1.NumberLiteral = 109;
    var v5803 = TokenID$$1._map;
    v5803[110] = "Whitespace";
    TokenID$$1.Whitespace = 110;
    var v5804 = TokenID$$1._map;
    v5804[111] = "Comment";
    TokenID$$1.Comment = 111;
    var v5805 = TokenID$$1._map;
    v5805[112] = "Lim";
    TokenID$$1.Lim = 112;
    TokenID$$1.LimFixed = TokenID$$1.EqualsGreaterThan;
    TokenID$$1.LimKeyword = TokenID$$1.Yield;
    return;
  }
  function setTokenInfo(tokenId$$44, reservation, binopPrecedence, binopNodeType, unopPrecedence, unopNodeType, text$$21, ers$$1) {
    var v5813 = tokenId$$44 !== undefined;
    if (v5813) {
      var v5806 = TypeScript$$22.tokenTable;
      var v5807 = tokenId$$44;
      var v26988 = new TokenInfo(tokenId$$44, reservation, binopPrecedence, binopNodeType, unopPrecedence, unopNodeType, text$$21, ers$$1);
      v5806[v5807] = v26988;
      var v20410 = TypeScript$$22.NodeType;
      var v14873 = v20410.None;
      var v5810 = binopNodeType != v14873;
      if (v5810) {
        var v5808 = TypeScript$$22.nodeTypeTable;
        v5808[binopNodeType] = text$$21;
        var v5809 = TypeScript$$22.nodeTypeToTokTable;
        v5809[binopNodeType] = tokenId$$44;
      }
      var v20411 = TypeScript$$22.NodeType;
      var v14874 = v20411.None;
      var v5812 = unopNodeType != v14874;
      if (v5812) {
        var v5811 = TypeScript$$22.nodeTypeTable;
        v5811[unopNodeType] = text$$21;
      }
    }
    return;
  }
  function lookupToken(tokenId$$45) {
    var v5814 = TypeScript$$22.tokenTable;
    return v5814[tokenId$$45];
  }
  function initializeStaticTokens() {
    var i$$73 = 0;
    var v14875 = TokenID.LimFixed;
    var v5817 = i$$73 <= v14875;
    for (;v5817;) {
      var v5815 = TypeScript$$22.staticTokens;
      var v5816 = i$$73;
      var v26989 = new Token(i$$73);
      v5815[v5816] = v26989;
      i$$73 = i$$73 + 1;
      var v14876 = TokenID.LimFixed;
      v5817 = i$$73 <= v14876;
    }
    return;
  }
  var v14877 = TypeScript$$22.TokenID;
  var v20412 = !v14877;
  if (v20412) {
    v14877 = TypeScript$$22.TokenID = {};
  }
  var v5818 = v14877;
  v863(v5818);
  var TokenID = TypeScript$$22.TokenID;
  var v5819 = TypeScript$$22;
  var v26990 = new Array;
  v5819.tokenTable = v26990;
  var v5820 = TypeScript$$22;
  var v26991 = new Array;
  v5820.nodeTypeTable = v26991;
  var v5821 = TypeScript$$22;
  var v26992 = new Array;
  v5821.nodeTypeToTokTable = v26992;
  var v5822 = TypeScript$$22;
  var v26993 = new Array;
  v5822.noRegexTable = v26993;
  var v5823 = TypeScript$$22.noRegexTable;
  var v5824 = TokenID.Identifier;
  v5823[v5824] = true;
  var v5825 = TypeScript$$22.noRegexTable;
  var v5826 = TokenID.StringLiteral;
  v5825[v5826] = true;
  var v5827 = TypeScript$$22.noRegexTable;
  var v5828 = TokenID.NumberLiteral;
  v5827[v5828] = true;
  var v5829 = TypeScript$$22.noRegexTable;
  var v5830 = TokenID.RegularExpressionLiteral;
  v5829[v5830] = true;
  var v5831 = TypeScript$$22.noRegexTable;
  var v5832 = TokenID.This;
  v5831[v5832] = true;
  var v5833 = TypeScript$$22.noRegexTable;
  var v5834 = TokenID.PlusPlus;
  v5833[v5834] = true;
  var v5835 = TypeScript$$22.noRegexTable;
  var v5836 = TokenID.MinusMinus;
  v5835[v5836] = true;
  var v5837 = TypeScript$$22.noRegexTable;
  var v5838 = TokenID.CloseParen;
  v5837[v5838] = true;
  var v5839 = TypeScript$$22.noRegexTable;
  var v5840 = TokenID.CloseBracket;
  v5839[v5840] = true;
  var v5841 = TypeScript$$22.noRegexTable;
  var v5842 = TokenID.CloseBrace;
  v5841[v5842] = true;
  var v5843 = TypeScript$$22.noRegexTable;
  var v5844 = TokenID.True;
  v5843[v5844] = true;
  var v5845 = TypeScript$$22.noRegexTable;
  var v5846 = TokenID.False;
  v5845[v5846] = true;
  var v14878 = TypeScript$$22.OperatorPrecedence;
  var v20413 = !v14878;
  if (v20413) {
    v14878 = TypeScript$$22.OperatorPrecedence = {};
  }
  var v5847 = v14878;
  v864(v5847);
  var OperatorPrecedence = TypeScript$$22.OperatorPrecedence;
  var v14879 = TypeScript$$22.Reservation;
  var v20414 = !v14879;
  if (v20414) {
    v14879 = TypeScript$$22.Reservation = {};
  }
  var v5848 = v14879;
  v865(v5848);
  var Reservation = TypeScript$$22.Reservation;
  var TokenInfo = v866();
  TypeScript$$22.TokenInfo = TokenInfo;
  var v5849 = TokenID.Any;
  var v5850 = Reservation.TypeScript;
  var v5851 = OperatorPrecedence.None;
  var v14880 = TypeScript$$22.NodeType;
  var v5852 = v14880.None;
  var v5853 = OperatorPrecedence.None;
  var v14881 = TypeScript$$22.NodeType;
  var v5854 = v14881.None;
  var v14882 = TypeScript$$22.ErrorRecoverySet;
  var v5855 = v14882.PrimType;
  setTokenInfo(v5849, v5850, v5851, v5852, v5853, v5854, "any", v5855);
  var v5856 = TokenID.Bool;
  var v5857 = Reservation.TypeScript;
  var v5858 = OperatorPrecedence.None;
  var v14883 = TypeScript$$22.NodeType;
  var v5859 = v14883.None;
  var v5860 = OperatorPrecedence.None;
  var v14884 = TypeScript$$22.NodeType;
  var v5861 = v14884.None;
  var v14885 = TypeScript$$22.ErrorRecoverySet;
  var v5862 = v14885.PrimType;
  setTokenInfo(v5856, v5857, v5858, v5859, v5860, v5861, "bool", v5862);
  var v5863 = TokenID.Break;
  var v5864 = Reservation.TypeScriptAndJS;
  var v5865 = OperatorPrecedence.None;
  var v14886 = TypeScript$$22.NodeType;
  var v5866 = v14886.None;
  var v5867 = OperatorPrecedence.None;
  var v14887 = TypeScript$$22.NodeType;
  var v5868 = v14887.None;
  var v14888 = TypeScript$$22.ErrorRecoverySet;
  var v5869 = v14888.Stmt;
  setTokenInfo(v5863, v5864, v5865, v5866, v5867, v5868, "break", v5869);
  var v5870 = TokenID.Case;
  var v5871 = Reservation.TypeScriptAndJS;
  var v5872 = OperatorPrecedence.None;
  var v14889 = TypeScript$$22.NodeType;
  var v5873 = v14889.None;
  var v5874 = OperatorPrecedence.None;
  var v14890 = TypeScript$$22.NodeType;
  var v5875 = v14890.None;
  var v14891 = TypeScript$$22.ErrorRecoverySet;
  var v5876 = v14891.SCase;
  setTokenInfo(v5870, v5871, v5872, v5873, v5874, v5875, "case", v5876);
  var v5877 = TokenID.Catch;
  var v5878 = Reservation.TypeScriptAndJS;
  var v5879 = OperatorPrecedence.None;
  var v14892 = TypeScript$$22.NodeType;
  var v5880 = v14892.None;
  var v5881 = OperatorPrecedence.None;
  var v14893 = TypeScript$$22.NodeType;
  var v5882 = v14893.None;
  var v14894 = TypeScript$$22.ErrorRecoverySet;
  var v5883 = v14894.Catch;
  setTokenInfo(v5877, v5878, v5879, v5880, v5881, v5882, "catch", v5883);
  var v5884 = TokenID.Class;
  var v5885 = Reservation.TypeScriptAndJSFuture;
  var v5886 = OperatorPrecedence.None;
  var v14895 = TypeScript$$22.NodeType;
  var v5887 = v14895.None;
  var v5888 = OperatorPrecedence.None;
  var v14896 = TypeScript$$22.NodeType;
  var v5889 = v14896.None;
  var v14897 = TypeScript$$22.ErrorRecoverySet;
  var v5890 = v14897.TypeScriptS;
  setTokenInfo(v5884, v5885, v5886, v5887, v5888, v5889, "class", v5890);
  var v5891 = TokenID.Const;
  var v5892 = Reservation.TypeScriptAndJSFuture;
  var v5893 = OperatorPrecedence.None;
  var v14898 = TypeScript$$22.NodeType;
  var v5894 = v14898.None;
  var v5895 = OperatorPrecedence.None;
  var v14899 = TypeScript$$22.NodeType;
  var v5896 = v14899.None;
  var v14900 = TypeScript$$22.ErrorRecoverySet;
  var v5897 = v14900.Var;
  setTokenInfo(v5891, v5892, v5893, v5894, v5895, v5896, "const", v5897);
  var v5898 = TokenID.Continue;
  var v5899 = Reservation.TypeScriptAndJS;
  var v5900 = OperatorPrecedence.None;
  var v14901 = TypeScript$$22.NodeType;
  var v5901 = v14901.None;
  var v5902 = OperatorPrecedence.None;
  var v14902 = TypeScript$$22.NodeType;
  var v5903 = v14902.None;
  var v14903 = TypeScript$$22.ErrorRecoverySet;
  var v5904 = v14903.Stmt;
  setTokenInfo(v5898, v5899, v5900, v5901, v5902, v5903, "continue", v5904);
  var v5905 = TokenID.Debugger;
  var v5906 = Reservation.TypeScriptAndJS;
  var v5907 = OperatorPrecedence.None;
  var v14904 = TypeScript$$22.NodeType;
  var v5908 = v14904.None;
  var v5909 = OperatorPrecedence.None;
  var v14905 = TypeScript$$22.NodeType;
  var v5910 = v14905.Debugger;
  var v14906 = TypeScript$$22.ErrorRecoverySet;
  var v5911 = v14906.Stmt;
  setTokenInfo(v5905, v5906, v5907, v5908, v5909, v5910, "debugger", v5911);
  var v5912 = TokenID.Default;
  var v5913 = Reservation.TypeScriptAndJS;
  var v5914 = OperatorPrecedence.None;
  var v14907 = TypeScript$$22.NodeType;
  var v5915 = v14907.None;
  var v5916 = OperatorPrecedence.None;
  var v14908 = TypeScript$$22.NodeType;
  var v5917 = v14908.None;
  var v14909 = TypeScript$$22.ErrorRecoverySet;
  var v5918 = v14909.SCase;
  setTokenInfo(v5912, v5913, v5914, v5915, v5916, v5917, "default", v5918);
  var v5919 = TokenID.Delete;
  var v5920 = Reservation.TypeScriptAndJS;
  var v5921 = OperatorPrecedence.None;
  var v14910 = TypeScript$$22.NodeType;
  var v5922 = v14910.None;
  var v5923 = OperatorPrecedence.Unary;
  var v14911 = TypeScript$$22.NodeType;
  var v5924 = v14911.Delete;
  var v14912 = TypeScript$$22.ErrorRecoverySet;
  var v5925 = v14912.Prefix;
  setTokenInfo(v5919, v5920, v5921, v5922, v5923, v5924, "delete", v5925);
  var v5926 = TokenID.Do;
  var v5927 = Reservation.TypeScriptAndJS;
  var v5928 = OperatorPrecedence.None;
  var v14913 = TypeScript$$22.NodeType;
  var v5929 = v14913.None;
  var v5930 = OperatorPrecedence.None;
  var v14914 = TypeScript$$22.NodeType;
  var v5931 = v14914.None;
  var v14915 = TypeScript$$22.ErrorRecoverySet;
  var v5932 = v14915.Stmt;
  setTokenInfo(v5926, v5927, v5928, v5929, v5930, v5931, "do", v5932);
  var v5933 = TokenID.Else;
  var v5934 = Reservation.TypeScriptAndJS;
  var v5935 = OperatorPrecedence.None;
  var v14916 = TypeScript$$22.NodeType;
  var v5936 = v14916.None;
  var v5937 = OperatorPrecedence.None;
  var v14917 = TypeScript$$22.NodeType;
  var v5938 = v14917.None;
  var v14918 = TypeScript$$22.ErrorRecoverySet;
  var v5939 = v14918.Else;
  setTokenInfo(v5933, v5934, v5935, v5936, v5937, v5938, "else", v5939);
  var v5940 = TokenID.Enum;
  var v5941 = Reservation.TypeScriptAndJSFuture;
  var v5942 = OperatorPrecedence.None;
  var v14919 = TypeScript$$22.NodeType;
  var v5943 = v14919.None;
  var v5944 = OperatorPrecedence.None;
  var v14920 = TypeScript$$22.NodeType;
  var v5945 = v14920.None;
  var v14921 = TypeScript$$22.ErrorRecoverySet;
  var v5946 = v14921.TypeScriptS;
  setTokenInfo(v5940, v5941, v5942, v5943, v5944, v5945, "enum", v5946);
  var v5947 = TokenID.Export;
  var v5948 = Reservation.TypeScriptAndJSFuture;
  var v5949 = OperatorPrecedence.None;
  var v14922 = TypeScript$$22.NodeType;
  var v5950 = v14922.None;
  var v5951 = OperatorPrecedence.None;
  var v14923 = TypeScript$$22.NodeType;
  var v5952 = v14923.None;
  var v14924 = TypeScript$$22.ErrorRecoverySet;
  var v5953 = v14924.TypeScriptS;
  setTokenInfo(v5947, v5948, v5949, v5950, v5951, v5952, "export", v5953);
  var v5954 = TokenID.Extends;
  var v5955 = Reservation.TypeScriptAndJSFuture;
  var v5956 = OperatorPrecedence.None;
  var v14925 = TypeScript$$22.NodeType;
  var v5957 = v14925.None;
  var v5958 = OperatorPrecedence.None;
  var v14926 = TypeScript$$22.NodeType;
  var v5959 = v14926.None;
  var v14927 = TypeScript$$22.ErrorRecoverySet;
  var v5960 = v14927.None;
  setTokenInfo(v5954, v5955, v5956, v5957, v5958, v5959, "extends", v5960);
  var v5961 = TokenID.Declare;
  var v5962 = Reservation.TypeScript;
  var v5963 = OperatorPrecedence.None;
  var v14928 = TypeScript$$22.NodeType;
  var v5964 = v14928.None;
  var v5965 = OperatorPrecedence.None;
  var v14929 = TypeScript$$22.NodeType;
  var v5966 = v14929.None;
  var v14930 = TypeScript$$22.ErrorRecoverySet;
  var v5967 = v14930.Stmt;
  setTokenInfo(v5961, v5962, v5963, v5964, v5965, v5966, "declare", v5967);
  var v5968 = TokenID.False;
  var v5969 = Reservation.TypeScriptAndJS;
  var v5970 = OperatorPrecedence.None;
  var v14931 = TypeScript$$22.NodeType;
  var v5971 = v14931.None;
  var v5972 = OperatorPrecedence.None;
  var v14932 = TypeScript$$22.NodeType;
  var v5973 = v14932.None;
  var v14933 = TypeScript$$22.ErrorRecoverySet;
  var v5974 = v14933.RLit;
  setTokenInfo(v5968, v5969, v5970, v5971, v5972, v5973, "false", v5974);
  var v5975 = TokenID.Finally;
  var v5976 = Reservation.TypeScriptAndJS;
  var v5977 = OperatorPrecedence.None;
  var v14934 = TypeScript$$22.NodeType;
  var v5978 = v14934.None;
  var v5979 = OperatorPrecedence.None;
  var v14935 = TypeScript$$22.NodeType;
  var v5980 = v14935.None;
  var v14936 = TypeScript$$22.ErrorRecoverySet;
  var v5981 = v14936.Catch;
  setTokenInfo(v5975, v5976, v5977, v5978, v5979, v5980, "finally", v5981);
  var v5982 = TokenID.For;
  var v5983 = Reservation.TypeScriptAndJS;
  var v5984 = OperatorPrecedence.None;
  var v14937 = TypeScript$$22.NodeType;
  var v5985 = v14937.None;
  var v5986 = OperatorPrecedence.None;
  var v14938 = TypeScript$$22.NodeType;
  var v5987 = v14938.None;
  var v14939 = TypeScript$$22.ErrorRecoverySet;
  var v5988 = v14939.Stmt;
  setTokenInfo(v5982, v5983, v5984, v5985, v5986, v5987, "for", v5988);
  var v5989 = TokenID.Function;
  var v5990 = Reservation.TypeScriptAndJS;
  var v5991 = OperatorPrecedence.None;
  var v14940 = TypeScript$$22.NodeType;
  var v5992 = v14940.None;
  var v5993 = OperatorPrecedence.None;
  var v14941 = TypeScript$$22.NodeType;
  var v5994 = v14941.None;
  var v14942 = TypeScript$$22.ErrorRecoverySet;
  var v5995 = v14942.Func;
  setTokenInfo(v5989, v5990, v5991, v5992, v5993, v5994, "function", v5995);
  var v5996 = TokenID.Constructor;
  var v5997 = Reservation.TypeScriptAndJSFutureStrict;
  var v5998 = OperatorPrecedence.None;
  var v14943 = TypeScript$$22.NodeType;
  var v5999 = v14943.None;
  var v6000 = OperatorPrecedence.None;
  var v14944 = TypeScript$$22.NodeType;
  var v6001 = v14944.None;
  var v14945 = TypeScript$$22.ErrorRecoverySet;
  var v6002 = v14945.Func;
  setTokenInfo(v5996, v5997, v5998, v5999, v6000, v6001, "constructor", v6002);
  var v6003 = TokenID.Get;
  var v6004 = Reservation.TypeScript;
  var v6005 = OperatorPrecedence.None;
  var v14946 = TypeScript$$22.NodeType;
  var v6006 = v14946.None;
  var v6007 = OperatorPrecedence.None;
  var v14947 = TypeScript$$22.NodeType;
  var v6008 = v14947.None;
  var v14948 = TypeScript$$22.ErrorRecoverySet;
  var v6009 = v14948.Func;
  setTokenInfo(v6003, v6004, v6005, v6006, v6007, v6008, "get", v6009);
  var v6010 = TokenID.Set;
  var v6011 = Reservation.TypeScript;
  var v6012 = OperatorPrecedence.None;
  var v14949 = TypeScript$$22.NodeType;
  var v6013 = v14949.None;
  var v6014 = OperatorPrecedence.None;
  var v14950 = TypeScript$$22.NodeType;
  var v6015 = v14950.None;
  var v14951 = TypeScript$$22.ErrorRecoverySet;
  var v6016 = v14951.Func;
  setTokenInfo(v6010, v6011, v6012, v6013, v6014, v6015, "set", v6016);
  var v6017 = TokenID.If;
  var v6018 = Reservation.TypeScriptAndJS;
  var v6019 = OperatorPrecedence.None;
  var v14952 = TypeScript$$22.NodeType;
  var v6020 = v14952.None;
  var v6021 = OperatorPrecedence.None;
  var v14953 = TypeScript$$22.NodeType;
  var v6022 = v14953.None;
  var v14954 = TypeScript$$22.ErrorRecoverySet;
  var v6023 = v14954.Stmt;
  setTokenInfo(v6017, v6018, v6019, v6020, v6021, v6022, "if", v6023);
  var v6024 = TokenID.Implements;
  var v6025 = Reservation.TypeScriptAndJSFutureStrict;
  var v6026 = OperatorPrecedence.None;
  var v14955 = TypeScript$$22.NodeType;
  var v6027 = v14955.None;
  var v6028 = OperatorPrecedence.None;
  var v14956 = TypeScript$$22.NodeType;
  var v6029 = v14956.None;
  var v14957 = TypeScript$$22.ErrorRecoverySet;
  var v6030 = v14957.None;
  setTokenInfo(v6024, v6025, v6026, v6027, v6028, v6029, "implements", v6030);
  var v6031 = TokenID.Import;
  var v6032 = Reservation.TypeScriptAndJSFuture;
  var v6033 = OperatorPrecedence.None;
  var v14958 = TypeScript$$22.NodeType;
  var v6034 = v14958.None;
  var v6035 = OperatorPrecedence.None;
  var v14959 = TypeScript$$22.NodeType;
  var v6036 = v14959.None;
  var v14960 = TypeScript$$22.ErrorRecoverySet;
  var v6037 = v14960.TypeScriptS;
  setTokenInfo(v6031, v6032, v6033, v6034, v6035, v6036, "import", v6037);
  var v6038 = TokenID.In;
  var v6039 = Reservation.TypeScriptAndJS;
  var v6040 = OperatorPrecedence.Relational;
  var v14961 = TypeScript$$22.NodeType;
  var v6041 = v14961.In;
  var v6042 = OperatorPrecedence.None;
  var v14962 = TypeScript$$22.NodeType;
  var v6043 = v14962.None;
  var v14963 = TypeScript$$22.ErrorRecoverySet;
  var v6044 = v14963.None;
  setTokenInfo(v6038, v6039, v6040, v6041, v6042, v6043, "in", v6044);
  var v6045 = TokenID.InstanceOf;
  var v6046 = Reservation.TypeScriptAndJS;
  var v6047 = OperatorPrecedence.Relational;
  var v14964 = TypeScript$$22.NodeType;
  var v6048 = v14964.InstOf;
  var v6049 = OperatorPrecedence.None;
  var v14965 = TypeScript$$22.NodeType;
  var v6050 = v14965.None;
  var v14966 = TypeScript$$22.ErrorRecoverySet;
  var v6051 = v14966.BinOp;
  setTokenInfo(v6045, v6046, v6047, v6048, v6049, v6050, "instanceof", v6051);
  var v6052 = TokenID.Interface;
  var v6053 = Reservation.TypeScriptAndJSFutureStrict;
  var v6054 = OperatorPrecedence.None;
  var v14967 = TypeScript$$22.NodeType;
  var v6055 = v14967.None;
  var v6056 = OperatorPrecedence.None;
  var v14968 = TypeScript$$22.NodeType;
  var v6057 = v14968.None;
  var v14969 = TypeScript$$22.ErrorRecoverySet;
  var v6058 = v14969.TypeScriptS;
  setTokenInfo(v6052, v6053, v6054, v6055, v6056, v6057, "interface", v6058);
  var v6059 = TokenID.Let;
  var v6060 = Reservation.JavascriptFutureStrict;
  var v6061 = OperatorPrecedence.None;
  var v14970 = TypeScript$$22.NodeType;
  var v6062 = v14970.None;
  var v6063 = OperatorPrecedence.None;
  var v14971 = TypeScript$$22.NodeType;
  var v6064 = v14971.None;
  var v14972 = TypeScript$$22.ErrorRecoverySet;
  var v6065 = v14972.None;
  setTokenInfo(v6059, v6060, v6061, v6062, v6063, v6064, "let", v6065);
  var v6066 = TokenID.Module;
  var v6067 = Reservation.TypeScript;
  var v6068 = OperatorPrecedence.None;
  var v14973 = TypeScript$$22.NodeType;
  var v6069 = v14973.None;
  var v6070 = OperatorPrecedence.None;
  var v14974 = TypeScript$$22.NodeType;
  var v6071 = v14974.None;
  var v14975 = TypeScript$$22.ErrorRecoverySet;
  var v6072 = v14975.TypeScriptS;
  setTokenInfo(v6066, v6067, v6068, v6069, v6070, v6071, "module", v6072);
  var v6073 = TokenID.New;
  var v6074 = Reservation.TypeScriptAndJS;
  var v6075 = OperatorPrecedence.None;
  var v14976 = TypeScript$$22.NodeType;
  var v6076 = v14976.None;
  var v6077 = OperatorPrecedence.None;
  var v14977 = TypeScript$$22.NodeType;
  var v6078 = v14977.None;
  var v14978 = TypeScript$$22.ErrorRecoverySet;
  var v6079 = v14978.PreOp;
  setTokenInfo(v6073, v6074, v6075, v6076, v6077, v6078, "new", v6079);
  var v6080 = TokenID.Number;
  var v6081 = Reservation.TypeScript;
  var v6082 = OperatorPrecedence.None;
  var v14979 = TypeScript$$22.NodeType;
  var v6083 = v14979.None;
  var v6084 = OperatorPrecedence.None;
  var v14980 = TypeScript$$22.NodeType;
  var v6085 = v14980.None;
  var v14981 = TypeScript$$22.ErrorRecoverySet;
  var v6086 = v14981.PrimType;
  setTokenInfo(v6080, v6081, v6082, v6083, v6084, v6085, "number", v6086);
  var v6087 = TokenID.Null;
  var v6088 = Reservation.TypeScriptAndJS;
  var v6089 = OperatorPrecedence.None;
  var v14982 = TypeScript$$22.NodeType;
  var v6090 = v14982.None;
  var v6091 = OperatorPrecedence.None;
  var v14983 = TypeScript$$22.NodeType;
  var v6092 = v14983.None;
  var v14984 = TypeScript$$22.ErrorRecoverySet;
  var v6093 = v14984.RLit;
  setTokenInfo(v6087, v6088, v6089, v6090, v6091, v6092, "null", v6093);
  var v6094 = TokenID.Package;
  var v6095 = Reservation.JavascriptFutureStrict;
  var v6096 = OperatorPrecedence.None;
  var v14985 = TypeScript$$22.NodeType;
  var v6097 = v14985.None;
  var v6098 = OperatorPrecedence.None;
  var v14986 = TypeScript$$22.NodeType;
  var v6099 = v14986.None;
  var v14987 = TypeScript$$22.ErrorRecoverySet;
  var v6100 = v14987.None;
  setTokenInfo(v6094, v6095, v6096, v6097, v6098, v6099, "package", v6100);
  var v6101 = TokenID.Private;
  var v6102 = Reservation.TypeScriptAndJSFutureStrict;
  var v6103 = OperatorPrecedence.None;
  var v14988 = TypeScript$$22.NodeType;
  var v6104 = v14988.None;
  var v6105 = OperatorPrecedence.None;
  var v14989 = TypeScript$$22.NodeType;
  var v6106 = v14989.None;
  var v14990 = TypeScript$$22.ErrorRecoverySet;
  var v6107 = v14990.TypeScriptS;
  setTokenInfo(v6101, v6102, v6103, v6104, v6105, v6106, "private", v6107);
  var v6108 = TokenID.Protected;
  var v6109 = Reservation.JavascriptFutureStrict;
  var v6110 = OperatorPrecedence.None;
  var v14991 = TypeScript$$22.NodeType;
  var v6111 = v14991.None;
  var v6112 = OperatorPrecedence.None;
  var v14992 = TypeScript$$22.NodeType;
  var v6113 = v14992.None;
  var v14993 = TypeScript$$22.ErrorRecoverySet;
  var v6114 = v14993.None;
  setTokenInfo(v6108, v6109, v6110, v6111, v6112, v6113, "protected", v6114);
  var v6115 = TokenID.Public;
  var v6116 = Reservation.TypeScriptAndJSFutureStrict;
  var v6117 = OperatorPrecedence.None;
  var v14994 = TypeScript$$22.NodeType;
  var v6118 = v14994.None;
  var v6119 = OperatorPrecedence.None;
  var v14995 = TypeScript$$22.NodeType;
  var v6120 = v14995.None;
  var v14996 = TypeScript$$22.ErrorRecoverySet;
  var v6121 = v14996.TypeScriptS;
  setTokenInfo(v6115, v6116, v6117, v6118, v6119, v6120, "public", v6121);
  var v6122 = TokenID.Return;
  var v6123 = Reservation.TypeScriptAndJS;
  var v6124 = OperatorPrecedence.None;
  var v14997 = TypeScript$$22.NodeType;
  var v6125 = v14997.None;
  var v6126 = OperatorPrecedence.None;
  var v14998 = TypeScript$$22.NodeType;
  var v6127 = v14998.None;
  var v14999 = TypeScript$$22.ErrorRecoverySet;
  var v6128 = v14999.Stmt;
  setTokenInfo(v6122, v6123, v6124, v6125, v6126, v6127, "return", v6128);
  var v6129 = TokenID.Static;
  var v6130 = Reservation.TypeScriptAndJSFutureStrict;
  var v6131 = OperatorPrecedence.None;
  var v15000 = TypeScript$$22.NodeType;
  var v6132 = v15000.None;
  var v6133 = OperatorPrecedence.None;
  var v15001 = TypeScript$$22.NodeType;
  var v6134 = v15001.None;
  var v15002 = TypeScript$$22.ErrorRecoverySet;
  var v6135 = v15002.None;
  setTokenInfo(v6129, v6130, v6131, v6132, v6133, v6134, "static", v6135);
  var v6136 = TokenID.String;
  var v6137 = Reservation.TypeScript;
  var v6138 = OperatorPrecedence.None;
  var v15003 = TypeScript$$22.NodeType;
  var v6139 = v15003.None;
  var v6140 = OperatorPrecedence.None;
  var v15004 = TypeScript$$22.NodeType;
  var v6141 = v15004.None;
  var v15005 = TypeScript$$22.ErrorRecoverySet;
  var v6142 = v15005.PrimType;
  setTokenInfo(v6136, v6137, v6138, v6139, v6140, v6141, "string", v6142);
  var v6143 = TokenID.Super;
  var v6144 = Reservation.TypeScriptAndJSFuture;
  var v6145 = OperatorPrecedence.None;
  var v15006 = TypeScript$$22.NodeType;
  var v6146 = v15006.None;
  var v6147 = OperatorPrecedence.None;
  var v15007 = TypeScript$$22.NodeType;
  var v6148 = v15007.None;
  var v15008 = TypeScript$$22.ErrorRecoverySet;
  var v6149 = v15008.RLit;
  setTokenInfo(v6143, v6144, v6145, v6146, v6147, v6148, "super", v6149);
  var v6150 = TokenID.Switch;
  var v6151 = Reservation.TypeScriptAndJS;
  var v6152 = OperatorPrecedence.None;
  var v15009 = TypeScript$$22.NodeType;
  var v6153 = v15009.None;
  var v6154 = OperatorPrecedence.None;
  var v15010 = TypeScript$$22.NodeType;
  var v6155 = v15010.None;
  var v15011 = TypeScript$$22.ErrorRecoverySet;
  var v6156 = v15011.Stmt;
  setTokenInfo(v6150, v6151, v6152, v6153, v6154, v6155, "switch", v6156);
  var v6157 = TokenID.This;
  var v6158 = Reservation.TypeScriptAndJS;
  var v6159 = OperatorPrecedence.None;
  var v15012 = TypeScript$$22.NodeType;
  var v6160 = v15012.None;
  var v6161 = OperatorPrecedence.None;
  var v15013 = TypeScript$$22.NodeType;
  var v6162 = v15013.None;
  var v15014 = TypeScript$$22.ErrorRecoverySet;
  var v6163 = v15014.RLit;
  setTokenInfo(v6157, v6158, v6159, v6160, v6161, v6162, "this", v6163);
  var v6164 = TokenID.Throw;
  var v6165 = Reservation.TypeScriptAndJS;
  var v6166 = OperatorPrecedence.None;
  var v15015 = TypeScript$$22.NodeType;
  var v6167 = v15015.None;
  var v6168 = OperatorPrecedence.None;
  var v15016 = TypeScript$$22.NodeType;
  var v6169 = v15016.None;
  var v15017 = TypeScript$$22.ErrorRecoverySet;
  var v6170 = v15017.Stmt;
  setTokenInfo(v6164, v6165, v6166, v6167, v6168, v6169, "throw", v6170);
  var v6171 = TokenID.True;
  var v6172 = Reservation.TypeScriptAndJS;
  var v6173 = OperatorPrecedence.None;
  var v15018 = TypeScript$$22.NodeType;
  var v6174 = v15018.None;
  var v6175 = OperatorPrecedence.None;
  var v15019 = TypeScript$$22.NodeType;
  var v6176 = v15019.None;
  var v15020 = TypeScript$$22.ErrorRecoverySet;
  var v6177 = v15020.RLit;
  setTokenInfo(v6171, v6172, v6173, v6174, v6175, v6176, "true", v6177);
  var v6178 = TokenID.Try;
  var v6179 = Reservation.TypeScriptAndJS;
  var v6180 = OperatorPrecedence.None;
  var v15021 = TypeScript$$22.NodeType;
  var v6181 = v15021.None;
  var v6182 = OperatorPrecedence.None;
  var v15022 = TypeScript$$22.NodeType;
  var v6183 = v15022.None;
  var v15023 = TypeScript$$22.ErrorRecoverySet;
  var v6184 = v15023.Stmt;
  setTokenInfo(v6178, v6179, v6180, v6181, v6182, v6183, "try", v6184);
  var v6185 = TokenID.TypeOf;
  var v6186 = Reservation.TypeScriptAndJS;
  var v6187 = OperatorPrecedence.None;
  var v15024 = TypeScript$$22.NodeType;
  var v6188 = v15024.None;
  var v6189 = OperatorPrecedence.Unary;
  var v15025 = TypeScript$$22.NodeType;
  var v6190 = v15025.Typeof;
  var v15026 = TypeScript$$22.ErrorRecoverySet;
  var v6191 = v15026.Prefix;
  setTokenInfo(v6185, v6186, v6187, v6188, v6189, v6190, "typeof", v6191);
  var v6192 = TokenID.Var;
  var v6193 = Reservation.TypeScriptAndJS;
  var v6194 = OperatorPrecedence.None;
  var v15027 = TypeScript$$22.NodeType;
  var v6195 = v15027.None;
  var v6196 = OperatorPrecedence.None;
  var v15028 = TypeScript$$22.NodeType;
  var v6197 = v15028.None;
  var v15029 = TypeScript$$22.ErrorRecoverySet;
  var v6198 = v15029.Var;
  setTokenInfo(v6192, v6193, v6194, v6195, v6196, v6197, "var", v6198);
  var v6199 = TokenID.Void;
  var v6200 = Reservation.TypeScriptAndJS;
  var v6201 = OperatorPrecedence.None;
  var v15030 = TypeScript$$22.NodeType;
  var v6202 = v15030.None;
  var v6203 = OperatorPrecedence.Unary;
  var v15031 = TypeScript$$22.NodeType;
  var v6204 = v15031.Void;
  var v15032 = TypeScript$$22.ErrorRecoverySet;
  var v6205 = v15032.Prefix;
  setTokenInfo(v6199, v6200, v6201, v6202, v6203, v6204, "void", v6205);
  var v6206 = TokenID.With;
  var v6207 = Reservation.TypeScriptAndJS;
  var v6208 = OperatorPrecedence.None;
  var v15033 = TypeScript$$22.NodeType;
  var v6209 = v15033.None;
  var v6210 = OperatorPrecedence.None;
  var v15034 = TypeScript$$22.NodeType;
  var v6211 = v15034.With;
  var v15035 = TypeScript$$22.ErrorRecoverySet;
  var v6212 = v15035.Stmt;
  setTokenInfo(v6206, v6207, v6208, v6209, v6210, v6211, "with", v6212);
  var v6213 = TokenID.While;
  var v6214 = Reservation.TypeScriptAndJS;
  var v6215 = OperatorPrecedence.None;
  var v15036 = TypeScript$$22.NodeType;
  var v6216 = v15036.None;
  var v6217 = OperatorPrecedence.None;
  var v15037 = TypeScript$$22.NodeType;
  var v6218 = v15037.None;
  var v15038 = TypeScript$$22.ErrorRecoverySet;
  var v6219 = v15038.While;
  setTokenInfo(v6213, v6214, v6215, v6216, v6217, v6218, "while", v6219);
  var v6220 = TokenID.Yield;
  var v6221 = Reservation.JavascriptFutureStrict;
  var v6222 = OperatorPrecedence.None;
  var v15039 = TypeScript$$22.NodeType;
  var v6223 = v15039.None;
  var v6224 = OperatorPrecedence.None;
  var v15040 = TypeScript$$22.NodeType;
  var v6225 = v15040.None;
  var v15041 = TypeScript$$22.ErrorRecoverySet;
  var v6226 = v15041.None;
  setTokenInfo(v6220, v6221, v6222, v6223, v6224, v6225, "yield", v6226);
  var v6227 = TokenID.Identifier;
  var v6228 = Reservation.None;
  var v6229 = OperatorPrecedence.None;
  var v15042 = TypeScript$$22.NodeType;
  var v6230 = v15042.None;
  var v6231 = OperatorPrecedence.None;
  var v15043 = TypeScript$$22.NodeType;
  var v6232 = v15043.None;
  var v15044 = TypeScript$$22.ErrorRecoverySet;
  var v6233 = v15044.ID;
  setTokenInfo(v6227, v6228, v6229, v6230, v6231, v6232, "identifier", v6233);
  var v6234 = TokenID.NumberLiteral;
  var v6235 = Reservation.None;
  var v6236 = OperatorPrecedence.None;
  var v15045 = TypeScript$$22.NodeType;
  var v6237 = v15045.None;
  var v6238 = OperatorPrecedence.None;
  var v15046 = TypeScript$$22.NodeType;
  var v6239 = v15046.None;
  var v15047 = TypeScript$$22.ErrorRecoverySet;
  var v6240 = v15047.Literal;
  setTokenInfo(v6234, v6235, v6236, v6237, v6238, v6239, "numberLiteral", v6240);
  var v6241 = TokenID.RegularExpressionLiteral;
  var v6242 = Reservation.None;
  var v6243 = OperatorPrecedence.None;
  var v15048 = TypeScript$$22.NodeType;
  var v6244 = v15048.None;
  var v6245 = OperatorPrecedence.None;
  var v15049 = TypeScript$$22.NodeType;
  var v6246 = v15049.None;
  var v15050 = TypeScript$$22.ErrorRecoverySet;
  var v6247 = v15050.RegExp;
  setTokenInfo(v6241, v6242, v6243, v6244, v6245, v6246, "regex", v6247);
  var v6248 = TokenID.StringLiteral;
  var v6249 = Reservation.None;
  var v6250 = OperatorPrecedence.None;
  var v15051 = TypeScript$$22.NodeType;
  var v6251 = v15051.None;
  var v6252 = OperatorPrecedence.None;
  var v15052 = TypeScript$$22.NodeType;
  var v6253 = v15052.None;
  var v15053 = TypeScript$$22.ErrorRecoverySet;
  var v6254 = v15053.Literal;
  setTokenInfo(v6248, v6249, v6250, v6251, v6252, v6253, "qstring", v6254);
  var v6255 = TokenID.Semicolon;
  var v6256 = Reservation.None;
  var v6257 = OperatorPrecedence.None;
  var v15054 = TypeScript$$22.NodeType;
  var v6258 = v15054.None;
  var v6259 = OperatorPrecedence.None;
  var v15055 = TypeScript$$22.NodeType;
  var v6260 = v15055.None;
  var v15056 = TypeScript$$22.ErrorRecoverySet;
  var v6261 = v15056.SColon;
  setTokenInfo(v6255, v6256, v6257, v6258, v6259, v6260, ";", v6261);
  var v6262 = TokenID.CloseParen;
  var v6263 = Reservation.None;
  var v6264 = OperatorPrecedence.None;
  var v15057 = TypeScript$$22.NodeType;
  var v6265 = v15057.None;
  var v6266 = OperatorPrecedence.None;
  var v15058 = TypeScript$$22.NodeType;
  var v6267 = v15058.None;
  var v15059 = TypeScript$$22.ErrorRecoverySet;
  var v6268 = v15059.RParen;
  setTokenInfo(v6262, v6263, v6264, v6265, v6266, v6267, ")", v6268);
  var v6269 = TokenID.CloseBracket;
  var v6270 = Reservation.None;
  var v6271 = OperatorPrecedence.None;
  var v15060 = TypeScript$$22.NodeType;
  var v6272 = v15060.None;
  var v6273 = OperatorPrecedence.None;
  var v15061 = TypeScript$$22.NodeType;
  var v6274 = v15061.None;
  var v15062 = TypeScript$$22.ErrorRecoverySet;
  var v6275 = v15062.RBrack;
  setTokenInfo(v6269, v6270, v6271, v6272, v6273, v6274, "]", v6275);
  var v6276 = TokenID.OpenBrace;
  var v6277 = Reservation.None;
  var v6278 = OperatorPrecedence.None;
  var v15063 = TypeScript$$22.NodeType;
  var v6279 = v15063.None;
  var v6280 = OperatorPrecedence.None;
  var v15064 = TypeScript$$22.NodeType;
  var v6281 = v15064.None;
  var v15065 = TypeScript$$22.ErrorRecoverySet;
  var v6282 = v15065.LCurly;
  setTokenInfo(v6276, v6277, v6278, v6279, v6280, v6281, "{", v6282);
  var v6283 = TokenID.CloseBrace;
  var v6284 = Reservation.None;
  var v6285 = OperatorPrecedence.None;
  var v15066 = TypeScript$$22.NodeType;
  var v6286 = v15066.None;
  var v6287 = OperatorPrecedence.None;
  var v15067 = TypeScript$$22.NodeType;
  var v6288 = v15067.None;
  var v15068 = TypeScript$$22.ErrorRecoverySet;
  var v6289 = v15068.RCurly;
  setTokenInfo(v6283, v6284, v6285, v6286, v6287, v6288, "}", v6289);
  var v6290 = TokenID.DotDotDot;
  var v6291 = Reservation.None;
  var v6292 = OperatorPrecedence.None;
  var v15069 = TypeScript$$22.NodeType;
  var v6293 = v15069.None;
  var v6294 = OperatorPrecedence.None;
  var v15070 = TypeScript$$22.NodeType;
  var v6295 = v15070.None;
  var v15071 = TypeScript$$22.ErrorRecoverySet;
  var v6296 = v15071.None;
  setTokenInfo(v6290, v6291, v6292, v6293, v6294, v6295, "...", v6296);
  var v6297 = TokenID.Comma;
  var v6298 = Reservation.None;
  var v6299 = OperatorPrecedence.Comma;
  var v15072 = TypeScript$$22.NodeType;
  var v6300 = v15072.Comma;
  var v6301 = OperatorPrecedence.None;
  var v15073 = TypeScript$$22.NodeType;
  var v6302 = v15073.None;
  var v15074 = TypeScript$$22.ErrorRecoverySet;
  var v6303 = v15074.Comma;
  setTokenInfo(v6297, v6298, v6299, v6300, v6301, v6302, ",", v6303);
  var v6304 = TokenID.Equals;
  var v6305 = Reservation.None;
  var v6306 = OperatorPrecedence.Assignment;
  var v15075 = TypeScript$$22.NodeType;
  var v6307 = v15075.Asg;
  var v6308 = OperatorPrecedence.None;
  var v15076 = TypeScript$$22.NodeType;
  var v6309 = v15076.None;
  var v15077 = TypeScript$$22.ErrorRecoverySet;
  var v6310 = v15077.Asg;
  setTokenInfo(v6304, v6305, v6306, v6307, v6308, v6309, "=", v6310);
  var v6311 = TokenID.PlusEquals;
  var v6312 = Reservation.None;
  var v6313 = OperatorPrecedence.Assignment;
  var v15078 = TypeScript$$22.NodeType;
  var v6314 = v15078.AsgAdd;
  var v6315 = OperatorPrecedence.None;
  var v15079 = TypeScript$$22.NodeType;
  var v6316 = v15079.None;
  var v15080 = TypeScript$$22.ErrorRecoverySet;
  var v6317 = v15080.BinOp;
  setTokenInfo(v6311, v6312, v6313, v6314, v6315, v6316, "+=", v6317);
  var v6318 = TokenID.MinusEquals;
  var v6319 = Reservation.None;
  var v6320 = OperatorPrecedence.Assignment;
  var v15081 = TypeScript$$22.NodeType;
  var v6321 = v15081.AsgSub;
  var v6322 = OperatorPrecedence.None;
  var v15082 = TypeScript$$22.NodeType;
  var v6323 = v15082.None;
  var v15083 = TypeScript$$22.ErrorRecoverySet;
  var v6324 = v15083.BinOp;
  setTokenInfo(v6318, v6319, v6320, v6321, v6322, v6323, "-=", v6324);
  var v6325 = TokenID.AsteriskEquals;
  var v6326 = Reservation.None;
  var v6327 = OperatorPrecedence.Assignment;
  var v15084 = TypeScript$$22.NodeType;
  var v6328 = v15084.AsgMul;
  var v6329 = OperatorPrecedence.None;
  var v15085 = TypeScript$$22.NodeType;
  var v6330 = v15085.None;
  var v15086 = TypeScript$$22.ErrorRecoverySet;
  var v6331 = v15086.BinOp;
  setTokenInfo(v6325, v6326, v6327, v6328, v6329, v6330, "*=", v6331);
  var v6332 = TokenID.SlashEquals;
  var v6333 = Reservation.None;
  var v6334 = OperatorPrecedence.Assignment;
  var v15087 = TypeScript$$22.NodeType;
  var v6335 = v15087.AsgDiv;
  var v6336 = OperatorPrecedence.None;
  var v15088 = TypeScript$$22.NodeType;
  var v6337 = v15088.None;
  var v15089 = TypeScript$$22.ErrorRecoverySet;
  var v6338 = v15089.BinOp;
  setTokenInfo(v6332, v6333, v6334, v6335, v6336, v6337, "/=", v6338);
  var v6339 = TokenID.PercentEquals;
  var v6340 = Reservation.None;
  var v6341 = OperatorPrecedence.Assignment;
  var v15090 = TypeScript$$22.NodeType;
  var v6342 = v15090.AsgMod;
  var v6343 = OperatorPrecedence.None;
  var v15091 = TypeScript$$22.NodeType;
  var v6344 = v15091.None;
  var v15092 = TypeScript$$22.ErrorRecoverySet;
  var v6345 = v15092.BinOp;
  setTokenInfo(v6339, v6340, v6341, v6342, v6343, v6344, "%=", v6345);
  var v6346 = TokenID.AmpersandEquals;
  var v6347 = Reservation.None;
  var v6348 = OperatorPrecedence.Assignment;
  var v15093 = TypeScript$$22.NodeType;
  var v6349 = v15093.AsgAnd;
  var v6350 = OperatorPrecedence.None;
  var v15094 = TypeScript$$22.NodeType;
  var v6351 = v15094.None;
  var v15095 = TypeScript$$22.ErrorRecoverySet;
  var v6352 = v15095.BinOp;
  setTokenInfo(v6346, v6347, v6348, v6349, v6350, v6351, "&=", v6352);
  var v6353 = TokenID.CaretEquals;
  var v6354 = Reservation.None;
  var v6355 = OperatorPrecedence.Assignment;
  var v15096 = TypeScript$$22.NodeType;
  var v6356 = v15096.AsgXor;
  var v6357 = OperatorPrecedence.None;
  var v15097 = TypeScript$$22.NodeType;
  var v6358 = v15097.None;
  var v15098 = TypeScript$$22.ErrorRecoverySet;
  var v6359 = v15098.BinOp;
  setTokenInfo(v6353, v6354, v6355, v6356, v6357, v6358, "^=", v6359);
  var v6360 = TokenID.BarEquals;
  var v6361 = Reservation.None;
  var v6362 = OperatorPrecedence.Assignment;
  var v15099 = TypeScript$$22.NodeType;
  var v6363 = v15099.AsgOr;
  var v6364 = OperatorPrecedence.None;
  var v15100 = TypeScript$$22.NodeType;
  var v6365 = v15100.None;
  var v15101 = TypeScript$$22.ErrorRecoverySet;
  var v6366 = v15101.BinOp;
  setTokenInfo(v6360, v6361, v6362, v6363, v6364, v6365, "|=", v6366);
  var v6367 = TokenID.LessThanLessThanEquals;
  var v6368 = Reservation.None;
  var v6369 = OperatorPrecedence.Assignment;
  var v15102 = TypeScript$$22.NodeType;
  var v6370 = v15102.AsgLsh;
  var v6371 = OperatorPrecedence.None;
  var v15103 = TypeScript$$22.NodeType;
  var v6372 = v15103.None;
  var v15104 = TypeScript$$22.ErrorRecoverySet;
  var v6373 = v15104.BinOp;
  setTokenInfo(v6367, v6368, v6369, v6370, v6371, v6372, "<<=", v6373);
  var v6374 = TokenID.GreaterThanGreaterThanEquals;
  var v6375 = Reservation.None;
  var v6376 = OperatorPrecedence.Assignment;
  var v15105 = TypeScript$$22.NodeType;
  var v6377 = v15105.AsgRsh;
  var v6378 = OperatorPrecedence.None;
  var v15106 = TypeScript$$22.NodeType;
  var v6379 = v15106.None;
  var v15107 = TypeScript$$22.ErrorRecoverySet;
  var v6380 = v15107.BinOp;
  setTokenInfo(v6374, v6375, v6376, v6377, v6378, v6379, ">>=", v6380);
  var v6381 = TokenID.GreaterThanGreaterThanGreaterThanEquals;
  var v6382 = Reservation.None;
  var v6383 = OperatorPrecedence.Assignment;
  var v15108 = TypeScript$$22.NodeType;
  var v6384 = v15108.AsgRs2;
  var v6385 = OperatorPrecedence.None;
  var v15109 = TypeScript$$22.NodeType;
  var v6386 = v15109.None;
  var v15110 = TypeScript$$22.ErrorRecoverySet;
  var v6387 = v15110.BinOp;
  setTokenInfo(v6381, v6382, v6383, v6384, v6385, v6386, ">>>=", v6387);
  var v6388 = TokenID.Question;
  var v6389 = Reservation.None;
  var v6390 = OperatorPrecedence.Conditional;
  var v15111 = TypeScript$$22.NodeType;
  var v6391 = v15111.ConditionalExpression;
  var v6392 = OperatorPrecedence.None;
  var v15112 = TypeScript$$22.NodeType;
  var v6393 = v15112.None;
  var v15113 = TypeScript$$22.ErrorRecoverySet;
  var v6394 = v15113.BinOp;
  setTokenInfo(v6388, v6389, v6390, v6391, v6392, v6393, "?", v6394);
  var v6395 = TokenID.Colon;
  var v6396 = Reservation.None;
  var v6397 = OperatorPrecedence.None;
  var v15114 = TypeScript$$22.NodeType;
  var v6398 = v15114.None;
  var v6399 = OperatorPrecedence.None;
  var v15115 = TypeScript$$22.NodeType;
  var v6400 = v15115.None;
  var v15116 = TypeScript$$22.ErrorRecoverySet;
  var v6401 = v15116.Colon;
  setTokenInfo(v6395, v6396, v6397, v6398, v6399, v6400, ":", v6401);
  var v6402 = TokenID.BarBar;
  var v6403 = Reservation.None;
  var v6404 = OperatorPrecedence.LogicalOr;
  var v15117 = TypeScript$$22.NodeType;
  var v6405 = v15117.LogOr;
  var v6406 = OperatorPrecedence.None;
  var v15118 = TypeScript$$22.NodeType;
  var v6407 = v15118.None;
  var v15119 = TypeScript$$22.ErrorRecoverySet;
  var v6408 = v15119.BinOp;
  setTokenInfo(v6402, v6403, v6404, v6405, v6406, v6407, "||", v6408);
  var v6409 = TokenID.AmpersandAmpersand;
  var v6410 = Reservation.None;
  var v6411 = OperatorPrecedence.LogicalAnd;
  var v15120 = TypeScript$$22.NodeType;
  var v6412 = v15120.LogAnd;
  var v6413 = OperatorPrecedence.None;
  var v15121 = TypeScript$$22.NodeType;
  var v6414 = v15121.None;
  var v15122 = TypeScript$$22.ErrorRecoverySet;
  var v6415 = v15122.BinOp;
  setTokenInfo(v6409, v6410, v6411, v6412, v6413, v6414, "&&", v6415);
  var v6416 = TokenID.Bar;
  var v6417 = Reservation.None;
  var v6418 = OperatorPrecedence.BitwiseOr;
  var v15123 = TypeScript$$22.NodeType;
  var v6419 = v15123.Or;
  var v6420 = OperatorPrecedence.None;
  var v15124 = TypeScript$$22.NodeType;
  var v6421 = v15124.None;
  var v15125 = TypeScript$$22.ErrorRecoverySet;
  var v6422 = v15125.BinOp;
  setTokenInfo(v6416, v6417, v6418, v6419, v6420, v6421, "|", v6422);
  var v6423 = TokenID.Caret;
  var v6424 = Reservation.None;
  var v6425 = OperatorPrecedence.BitwiseExclusiveOr;
  var v15126 = TypeScript$$22.NodeType;
  var v6426 = v15126.Xor;
  var v6427 = OperatorPrecedence.None;
  var v15127 = TypeScript$$22.NodeType;
  var v6428 = v15127.None;
  var v15128 = TypeScript$$22.ErrorRecoverySet;
  var v6429 = v15128.BinOp;
  setTokenInfo(v6423, v6424, v6425, v6426, v6427, v6428, "^", v6429);
  var v6430 = TokenID.And;
  var v6431 = Reservation.None;
  var v6432 = OperatorPrecedence.BitwiseAnd;
  var v15129 = TypeScript$$22.NodeType;
  var v6433 = v15129.And;
  var v6434 = OperatorPrecedence.None;
  var v15130 = TypeScript$$22.NodeType;
  var v6435 = v15130.None;
  var v15131 = TypeScript$$22.ErrorRecoverySet;
  var v6436 = v15131.BinOp;
  setTokenInfo(v6430, v6431, v6432, v6433, v6434, v6435, "&", v6436);
  var v6437 = TokenID.EqualsEquals;
  var v6438 = Reservation.None;
  var v6439 = OperatorPrecedence.Equality;
  var v15132 = TypeScript$$22.NodeType;
  var v6440 = v15132.Eq;
  var v6441 = OperatorPrecedence.None;
  var v15133 = TypeScript$$22.NodeType;
  var v6442 = v15133.None;
  var v15134 = TypeScript$$22.ErrorRecoverySet;
  var v6443 = v15134.BinOp;
  setTokenInfo(v6437, v6438, v6439, v6440, v6441, v6442, "==", v6443);
  var v6444 = TokenID.ExclamationEquals;
  var v6445 = Reservation.None;
  var v6446 = OperatorPrecedence.Equality;
  var v15135 = TypeScript$$22.NodeType;
  var v6447 = v15135.Ne;
  var v6448 = OperatorPrecedence.None;
  var v15136 = TypeScript$$22.NodeType;
  var v6449 = v15136.None;
  var v15137 = TypeScript$$22.ErrorRecoverySet;
  var v6450 = v15137.BinOp;
  setTokenInfo(v6444, v6445, v6446, v6447, v6448, v6449, "!=", v6450);
  var v6451 = TokenID.EqualsEqualsEquals;
  var v6452 = Reservation.None;
  var v6453 = OperatorPrecedence.Equality;
  var v15138 = TypeScript$$22.NodeType;
  var v6454 = v15138.Eqv;
  var v6455 = OperatorPrecedence.None;
  var v15139 = TypeScript$$22.NodeType;
  var v6456 = v15139.None;
  var v15140 = TypeScript$$22.ErrorRecoverySet;
  var v6457 = v15140.BinOp;
  setTokenInfo(v6451, v6452, v6453, v6454, v6455, v6456, "===", v6457);
  var v6458 = TokenID.ExclamationEqualsEquals;
  var v6459 = Reservation.None;
  var v6460 = OperatorPrecedence.Equality;
  var v15141 = TypeScript$$22.NodeType;
  var v6461 = v15141.NEqv;
  var v6462 = OperatorPrecedence.None;
  var v15142 = TypeScript$$22.NodeType;
  var v6463 = v15142.None;
  var v15143 = TypeScript$$22.ErrorRecoverySet;
  var v6464 = v15143.BinOp;
  setTokenInfo(v6458, v6459, v6460, v6461, v6462, v6463, "!==", v6464);
  var v6465 = TokenID.LessThan;
  var v6466 = Reservation.None;
  var v6467 = OperatorPrecedence.Relational;
  var v15144 = TypeScript$$22.NodeType;
  var v6468 = v15144.Lt;
  var v6469 = OperatorPrecedence.None;
  var v15145 = TypeScript$$22.NodeType;
  var v6470 = v15145.None;
  var v15146 = TypeScript$$22.ErrorRecoverySet;
  var v6471 = v15146.BinOp;
  setTokenInfo(v6465, v6466, v6467, v6468, v6469, v6470, "<", v6471);
  var v6472 = TokenID.LessThanEquals;
  var v6473 = Reservation.None;
  var v6474 = OperatorPrecedence.Relational;
  var v15147 = TypeScript$$22.NodeType;
  var v6475 = v15147.Le;
  var v6476 = OperatorPrecedence.None;
  var v15148 = TypeScript$$22.NodeType;
  var v6477 = v15148.None;
  var v15149 = TypeScript$$22.ErrorRecoverySet;
  var v6478 = v15149.BinOp;
  setTokenInfo(v6472, v6473, v6474, v6475, v6476, v6477, "<=", v6478);
  var v6479 = TokenID.GreaterThan;
  var v6480 = Reservation.None;
  var v6481 = OperatorPrecedence.Relational;
  var v15150 = TypeScript$$22.NodeType;
  var v6482 = v15150.Gt;
  var v6483 = OperatorPrecedence.None;
  var v15151 = TypeScript$$22.NodeType;
  var v6484 = v15151.None;
  var v15152 = TypeScript$$22.ErrorRecoverySet;
  var v6485 = v15152.BinOp;
  setTokenInfo(v6479, v6480, v6481, v6482, v6483, v6484, ">", v6485);
  var v6486 = TokenID.GreaterThanEquals;
  var v6487 = Reservation.None;
  var v6488 = OperatorPrecedence.Relational;
  var v15153 = TypeScript$$22.NodeType;
  var v6489 = v15153.Ge;
  var v6490 = OperatorPrecedence.None;
  var v15154 = TypeScript$$22.NodeType;
  var v6491 = v15154.None;
  var v15155 = TypeScript$$22.ErrorRecoverySet;
  var v6492 = v15155.BinOp;
  setTokenInfo(v6486, v6487, v6488, v6489, v6490, v6491, ">=", v6492);
  var v6493 = TokenID.LessThanLessThan;
  var v6494 = Reservation.None;
  var v6495 = OperatorPrecedence.Shift;
  var v15156 = TypeScript$$22.NodeType;
  var v6496 = v15156.Lsh;
  var v6497 = OperatorPrecedence.None;
  var v15157 = TypeScript$$22.NodeType;
  var v6498 = v15157.None;
  var v15158 = TypeScript$$22.ErrorRecoverySet;
  var v6499 = v15158.BinOp;
  setTokenInfo(v6493, v6494, v6495, v6496, v6497, v6498, "<<", v6499);
  var v6500 = TokenID.GreaterThanGreaterThan;
  var v6501 = Reservation.None;
  var v6502 = OperatorPrecedence.Shift;
  var v15159 = TypeScript$$22.NodeType;
  var v6503 = v15159.Rsh;
  var v6504 = OperatorPrecedence.None;
  var v15160 = TypeScript$$22.NodeType;
  var v6505 = v15160.None;
  var v15161 = TypeScript$$22.ErrorRecoverySet;
  var v6506 = v15161.BinOp;
  setTokenInfo(v6500, v6501, v6502, v6503, v6504, v6505, ">>", v6506);
  var v6507 = TokenID.GreaterThanGreaterThanGreaterThan;
  var v6508 = Reservation.None;
  var v6509 = OperatorPrecedence.Shift;
  var v15162 = TypeScript$$22.NodeType;
  var v6510 = v15162.Rs2;
  var v6511 = OperatorPrecedence.None;
  var v15163 = TypeScript$$22.NodeType;
  var v6512 = v15163.None;
  var v15164 = TypeScript$$22.ErrorRecoverySet;
  var v6513 = v15164.BinOp;
  setTokenInfo(v6507, v6508, v6509, v6510, v6511, v6512, ">>>", v6513);
  var v6514 = TokenID.Plus;
  var v6515 = Reservation.None;
  var v6516 = OperatorPrecedence.Additive;
  var v15165 = TypeScript$$22.NodeType;
  var v6517 = v15165.Add;
  var v6518 = OperatorPrecedence.Unary;
  var v15166 = TypeScript$$22.NodeType;
  var v6519 = v15166.Pos;
  var v15167 = TypeScript$$22.ErrorRecoverySet;
  var v6520 = v15167.AddOp;
  setTokenInfo(v6514, v6515, v6516, v6517, v6518, v6519, "+", v6520);
  var v6521 = TokenID.Minus;
  var v6522 = Reservation.None;
  var v6523 = OperatorPrecedence.Additive;
  var v15168 = TypeScript$$22.NodeType;
  var v6524 = v15168.Sub;
  var v6525 = OperatorPrecedence.Unary;
  var v15169 = TypeScript$$22.NodeType;
  var v6526 = v15169.Neg;
  var v15170 = TypeScript$$22.ErrorRecoverySet;
  var v6527 = v15170.AddOp;
  setTokenInfo(v6521, v6522, v6523, v6524, v6525, v6526, "-", v6527);
  var v6528 = TokenID.Asterisk;
  var v6529 = Reservation.None;
  var v6530 = OperatorPrecedence.Multiplicative;
  var v15171 = TypeScript$$22.NodeType;
  var v6531 = v15171.Mul;
  var v6532 = OperatorPrecedence.None;
  var v15172 = TypeScript$$22.NodeType;
  var v6533 = v15172.None;
  var v15173 = TypeScript$$22.ErrorRecoverySet;
  var v6534 = v15173.BinOp;
  setTokenInfo(v6528, v6529, v6530, v6531, v6532, v6533, "*", v6534);
  var v6535 = TokenID.Slash;
  var v6536 = Reservation.None;
  var v6537 = OperatorPrecedence.Multiplicative;
  var v15174 = TypeScript$$22.NodeType;
  var v6538 = v15174.Div;
  var v6539 = OperatorPrecedence.None;
  var v15175 = TypeScript$$22.NodeType;
  var v6540 = v15175.None;
  var v15176 = TypeScript$$22.ErrorRecoverySet;
  var v6541 = v15176.BinOp;
  setTokenInfo(v6535, v6536, v6537, v6538, v6539, v6540, "/", v6541);
  var v6542 = TokenID.Percent;
  var v6543 = Reservation.None;
  var v6544 = OperatorPrecedence.Multiplicative;
  var v15177 = TypeScript$$22.NodeType;
  var v6545 = v15177.Mod;
  var v6546 = OperatorPrecedence.None;
  var v15178 = TypeScript$$22.NodeType;
  var v6547 = v15178.None;
  var v15179 = TypeScript$$22.ErrorRecoverySet;
  var v6548 = v15179.BinOp;
  setTokenInfo(v6542, v6543, v6544, v6545, v6546, v6547, "%", v6548);
  var v6549 = TokenID.Tilde;
  var v6550 = Reservation.None;
  var v6551 = OperatorPrecedence.None;
  var v15180 = TypeScript$$22.NodeType;
  var v6552 = v15180.None;
  var v6553 = OperatorPrecedence.Unary;
  var v15181 = TypeScript$$22.NodeType;
  var v6554 = v15181.Not;
  var v15182 = TypeScript$$22.ErrorRecoverySet;
  var v6555 = v15182.PreOp;
  setTokenInfo(v6549, v6550, v6551, v6552, v6553, v6554, "~", v6555);
  var v6556 = TokenID.Exclamation;
  var v6557 = Reservation.None;
  var v6558 = OperatorPrecedence.None;
  var v15183 = TypeScript$$22.NodeType;
  var v6559 = v15183.None;
  var v6560 = OperatorPrecedence.Unary;
  var v15184 = TypeScript$$22.NodeType;
  var v6561 = v15184.LogNot;
  var v15185 = TypeScript$$22.ErrorRecoverySet;
  var v6562 = v15185.PreOp;
  setTokenInfo(v6556, v6557, v6558, v6559, v6560, v6561, "!", v6562);
  var v6563 = TokenID.PlusPlus;
  var v6564 = Reservation.None;
  var v6565 = OperatorPrecedence.None;
  var v15186 = TypeScript$$22.NodeType;
  var v6566 = v15186.None;
  var v6567 = OperatorPrecedence.Unary;
  var v15187 = TypeScript$$22.NodeType;
  var v6568 = v15187.IncPre;
  var v15188 = TypeScript$$22.ErrorRecoverySet;
  var v6569 = v15188.PreOp;
  setTokenInfo(v6563, v6564, v6565, v6566, v6567, v6568, "++", v6569);
  var v6570 = TokenID.MinusMinus;
  var v6571 = Reservation.None;
  var v6572 = OperatorPrecedence.None;
  var v15189 = TypeScript$$22.NodeType;
  var v6573 = v15189.None;
  var v6574 = OperatorPrecedence.Unary;
  var v15190 = TypeScript$$22.NodeType;
  var v6575 = v15190.DecPre;
  var v15191 = TypeScript$$22.ErrorRecoverySet;
  var v6576 = v15191.PreOp;
  setTokenInfo(v6570, v6571, v6572, v6573, v6574, v6575, "--", v6576);
  var v6577 = TokenID.OpenParen;
  var v6578 = Reservation.None;
  var v6579 = OperatorPrecedence.None;
  var v15192 = TypeScript$$22.NodeType;
  var v6580 = v15192.None;
  var v6581 = OperatorPrecedence.None;
  var v15193 = TypeScript$$22.NodeType;
  var v6582 = v15193.None;
  var v15194 = TypeScript$$22.ErrorRecoverySet;
  var v6583 = v15194.LParen;
  setTokenInfo(v6577, v6578, v6579, v6580, v6581, v6582, "(", v6583);
  var v6584 = TokenID.OpenBracket;
  var v6585 = Reservation.None;
  var v6586 = OperatorPrecedence.None;
  var v15195 = TypeScript$$22.NodeType;
  var v6587 = v15195.None;
  var v6588 = OperatorPrecedence.None;
  var v15196 = TypeScript$$22.NodeType;
  var v6589 = v15196.None;
  var v15197 = TypeScript$$22.ErrorRecoverySet;
  var v6590 = v15197.LBrack;
  setTokenInfo(v6584, v6585, v6586, v6587, v6588, v6589, "[", v6590);
  var v6591 = TokenID.Dot;
  var v6592 = Reservation.None;
  var v6593 = OperatorPrecedence.Unary;
  var v15198 = TypeScript$$22.NodeType;
  var v6594 = v15198.None;
  var v6595 = OperatorPrecedence.None;
  var v15199 = TypeScript$$22.NodeType;
  var v6596 = v15199.None;
  var v15200 = TypeScript$$22.ErrorRecoverySet;
  var v6597 = v15200.Dot;
  setTokenInfo(v6591, v6592, v6593, v6594, v6595, v6596, ".", v6597);
  var v6598 = TokenID.EndOfFile;
  var v6599 = Reservation.None;
  var v6600 = OperatorPrecedence.None;
  var v15201 = TypeScript$$22.NodeType;
  var v6601 = v15201.None;
  var v6602 = OperatorPrecedence.None;
  var v15202 = TypeScript$$22.NodeType;
  var v6603 = v15202.None;
  var v15203 = TypeScript$$22.ErrorRecoverySet;
  var v6604 = v15203.EOF;
  setTokenInfo(v6598, v6599, v6600, v6601, v6602, v6603, "<EOF>", v6604);
  var v6605 = TokenID.EqualsGreaterThan;
  var v6606 = Reservation.None;
  var v6607 = OperatorPrecedence.None;
  var v15204 = TypeScript$$22.NodeType;
  var v6608 = v15204.None;
  var v6609 = OperatorPrecedence.None;
  var v15205 = TypeScript$$22.NodeType;
  var v6610 = v15205.None;
  var v15206 = TypeScript$$22.ErrorRecoverySet;
  var v6611 = v15206.None;
  setTokenInfo(v6605, v6606, v6607, v6608, v6609, v6610, "=>", v6611);
  TypeScript$$22.lookupToken = lookupToken;
  var v15207 = TypeScript$$22.TokenClass;
  var v20415 = !v15207;
  if (v20415) {
    v15207 = TypeScript$$22.TokenClass = {};
  }
  var v6612 = v15207;
  v867(v6612);
  var TokenClass = TypeScript$$22.TokenClass;
  var SavedToken = v868();
  TypeScript$$22.SavedToken = SavedToken;
  var Token = v873();
  TypeScript$$22.Token = Token;
  var NumberLiteralToken = v876(Token);
  TypeScript$$22.NumberLiteralToken = NumberLiteralToken;
  var StringLiteralToken = v879(Token);
  TypeScript$$22.StringLiteralToken = StringLiteralToken;
  var IdentifierToken = v882(Token);
  TypeScript$$22.IdentifierToken = IdentifierToken;
  var WhitespaceToken = v885(Token);
  TypeScript$$22.WhitespaceToken = WhitespaceToken;
  var CommentToken = v888(Token);
  TypeScript$$22.CommentToken = CommentToken;
  var RegularExpressionLiteralToken = v891(Token);
  TypeScript$$22.RegularExpressionLiteralToken = RegularExpressionLiteralToken;
  var v6613 = TypeScript$$22;
  var v26994 = new Array;
  v6613.staticTokens = v26994;
  TypeScript$$22.initializeStaticTokens = initializeStaticTokens;
  return;
}
function v862(TypeScript$$21) {
  function v861(_super$$58) {
    function v860(name$$78, publicOnly$$23, typespace$$23) {
      var v15208 = _super$$58.prototype;
      var v6614 = v15208.findLocal;
      var sym$$27 = v6614.call(this, name$$78, publicOnly$$23, typespace$$23);
      if (sym$$27) {
        var v15209 = this.filter(sym$$27);
        var v6615 = !v15209;
        if (v6615) {
          return null;
        }
      }
      var v15210 = _super$$58.prototype;
      var v6616 = v15210.find;
      return v6616.call(this, name$$78, publicOnly$$23, typespace$$23);
    }
    function v859(filter$$6, name$$77, publicOnly$$22, typespace$$22) {
      throw new Error("please implement");
    }
    function v858(name$$76, publicOnly$$21, typespace$$21) {
      var v15211 = _super$$58.prototype;
      var v6617 = v15211.findLocal;
      var sym$$26 = v6617.call(this, name$$76, publicOnly$$21, typespace$$21);
      if (sym$$26) {
        var v15212 = this.filter(sym$$26);
        var v6618 = !v15212;
        if (v6618) {
          return null;
        }
      }
      return sym$$26;
    }
    function FilteredSymbolScopeBuilder$$1(valueMembers$$3, parent$$51, container$$10, filter$$5) {
      _super$$58.call(this, valueMembers$$3, null, null, null, parent$$51, container$$10);
      this.filter = filter$$5;
      return;
    }
    __extends(FilteredSymbolScopeBuilder$$1, _super$$58);
    var v6619 = FilteredSymbolScopeBuilder$$1.prototype;
    v6619.findLocal = v858;
    var v6620 = FilteredSymbolScopeBuilder$$1.prototype;
    v6620.search = v859;
    var v6621 = FilteredSymbolScopeBuilder$$1.prototype;
    v6621.find = v860;
    return FilteredSymbolScopeBuilder$$1;
  }
  function v857(_super$$57) {
    function v856(name$$75, publicOnly$$20, typespace$$20) {
      var v6622 = this.scope;
      return v6622.findLocal(name$$75, publicOnly$$20, typespace$$20);
    }
    function v855(name$$74, publicOnly$$19, typespace$$19) {
      var v6623 = this.filter;
      v6623.reset();
      var v6624 = this.scope;
      var v6625 = this.filter;
      return v6624.search(v6625, name$$74, publicOnly$$19, typespace$$19);
    }
    function v854(outfile$$10) {
      var v6626 = this.scope;
      v6626.print(outfile$$10);
      return;
    }
    function FilteredSymbolScope$$1(scope$$21, container$$9, filter$$4) {
      _super$$57.call(this, container$$9);
      this.scope = scope$$21;
      this.filter = filter$$4;
      return;
    }
    __extends(FilteredSymbolScope$$1, _super$$57);
    var v6627 = FilteredSymbolScope$$1.prototype;
    v6627.print = v854;
    var v6628 = FilteredSymbolScope$$1.prototype;
    v6628.find = v855;
    var v6629 = FilteredSymbolScope$$1.prototype;
    v6629.findLocal = v856;
    return FilteredSymbolScope$$1;
  }
  function v853(_super$$56) {
    function v852() {
      var v6630 = this.valueMembers;
      return v6630.allMembers;
    }
    function v851(container$$8, ast$$61, symbol$$7, errorReporter$$3, insertAsPublic, typespace$$18, ambient$$1) {
      var table$$6 = null;
      if (ambient$$1) {
        if (typespace$$18) {
          var v6631;
          var v20416 = this.ambientEnclosedTypes;
          var v15214 = v20416 == null;
          if (v15214) {
            v6631 = null;
          } else {
            var v15213;
            if (insertAsPublic) {
              var v20417 = this.ambientEnclosedTypes;
              v15213 = v20417.publicMembers;
            } else {
              var v20418 = this.ambientEnclosedTypes;
              v15213 = v20418.privateMembers;
            }
            v6631 = v15213;
          }
          table$$6 = v6631;
        } else {
          var v6632;
          var v20419 = this.ambientValueMembers;
          var v15216 = v20419 == null;
          if (v15216) {
            v6632 = null;
          } else {
            var v15215;
            if (insertAsPublic) {
              var v20420 = this.ambientValueMembers;
              v15215 = v20420.publicMembers;
            } else {
              var v20421 = this.ambientValueMembers;
              v15215 = v20421.privateMembers;
            }
            v6632 = v15215;
          }
          table$$6 = v6632;
        }
      } else {
        if (typespace$$18) {
          var v6633;
          var v20422 = this.enclosedTypes;
          var v15218 = v20422 == null;
          if (v15218) {
            v6633 = null;
          } else {
            var v15217;
            if (insertAsPublic) {
              var v20423 = this.enclosedTypes;
              v15217 = v20423.publicMembers;
            } else {
              var v20424 = this.enclosedTypes;
              v15217 = v20424.privateMembers;
            }
            v6633 = v15217;
          }
          table$$6 = v6633;
        } else {
          var v6634;
          var v20425 = this.valueMembers;
          var v15220 = v20425 == null;
          if (v15220) {
            v6634 = null;
          } else {
            var v15219;
            if (insertAsPublic) {
              var v20426 = this.valueMembers;
              v15219 = v20426.publicMembers;
            } else {
              var v20427 = this.valueMembers;
              v15219 = v20427.privateMembers;
            }
            v6634 = v15219;
          }
          table$$6 = v6634;
        }
      }
      if (table$$6) {
        var v20428 = symbol$$7.name;
        var v15221 = table$$6.add(v20428, symbol$$7);
        var v6636 = !v15221;
        if (v6636) {
          var v6635 = symbol$$7.name;
          errorReporter$$3.duplicateIdentifier(ast$$61, v6635);
        }
      } else {
        var v6637 = TypeScript$$21.CompilerDiagnostics;
        v6637.Alert("YYYYY");
      }
      symbol$$7.container = container$$8;
      return;
    }
    function v850(name$$73, publicOnly$$18, typespace$$17) {
      var sym$$25 = null;
      var v6638;
      var v20429 = this.valueMembers;
      var v15223 = v20429 == null;
      if (v15223) {
        v6638 = null;
      } else {
        var v15222;
        if (publicOnly$$18) {
          var v20430 = this.valueMembers;
          v15222 = v20430.publicMembers;
        } else {
          var v20431 = this.valueMembers;
          v15222 = v20431.allMembers;
        }
        v6638 = v15222;
      }
      var table$$5 = v6638;
      var v6639;
      var v20432 = this.ambientValueMembers;
      var v15225 = v20432 == null;
      if (v15225) {
        v6639 = null;
      } else {
        var v15224;
        if (publicOnly$$18) {
          var v20433 = this.ambientValueMembers;
          v15224 = v20433.publicMembers;
        } else {
          var v20434 = this.ambientValueMembers;
          v15224 = v20434.allMembers;
        }
        v6639 = v15224;
      }
      var ambientTable$$5 = v6639;
      if (typespace$$17) {
        var v6640;
        var v20435 = this.enclosedTypes;
        var v15227 = v20435 == null;
        if (v15227) {
          v6640 = null;
        } else {
          var v15226;
          if (publicOnly$$18) {
            var v20436 = this.enclosedTypes;
            v15226 = v20436.publicMembers;
          } else {
            var v20437 = this.enclosedTypes;
            v15226 = v20437.allMembers;
          }
          v6640 = v15226;
        }
        table$$5 = v6640;
        var v6641;
        var v20438 = this.ambientEnclosedTypes;
        var v15229 = v20438 == null;
        if (v15229) {
          v6641 = null;
        } else {
          var v15228;
          if (publicOnly$$18) {
            var v20439 = this.ambientEnclosedTypes;
            v15228 = v20439.publicMembers;
          } else {
            var v20440 = this.ambientEnclosedTypes;
            v15228 = v20440.allMembers;
          }
          v6641 = v15228;
        }
        ambientTable$$5 = v6641;
      }
      if (table$$5) {
        var v15230 = sym$$25 = table$$5.lookup(name$$73);
        var v6642 = v15230 != null;
        if (v6642) {
          if (sym$$25) {
            return sym$$25;
          }
        }
      }
      if (ambientTable$$5) {
        var v15231 = sym$$25 = ambientTable$$5.lookup(name$$73);
        var v6643 = v15231 != null;
        if (v6643) {
          if (sym$$25) {
            return sym$$25;
          }
        }
      }
      return null;
    }
    function v849(name$$72, publicOnly$$17, typespace$$16) {
      var sym$$24 = null;
      var v6644;
      var v20441 = this.ambientValueMembers;
      var v15233 = v20441 == null;
      if (v15233) {
        v6644 = null;
      } else {
        var v15232;
        if (publicOnly$$17) {
          var v20442 = this.ambientValueMembers;
          v15232 = v20442.publicMembers;
        } else {
          var v20443 = this.ambientValueMembers;
          v15232 = v20443.allMembers;
        }
        v6644 = v15232;
      }
      var ambientTable$$4 = v6644;
      if (typespace$$16) {
        var v6645;
        var v20444 = this.ambientEnclosedTypes;
        var v15235 = v20444 == null;
        if (v15235) {
          v6645 = null;
        } else {
          var v15234;
          if (publicOnly$$17) {
            var v20445 = this.ambientEnclosedTypes;
            v15234 = v20445.publicMembers;
          } else {
            var v20446 = this.ambientEnclosedTypes;
            v15234 = v20446.allMembers;
          }
          v6645 = v15234;
        }
        ambientTable$$4 = v6645;
      }
      var v15236 = ambientTable$$4;
      if (v15236) {
        var v20447 = sym$$24 = ambientTable$$4.lookup(name$$72);
        v15236 = v20447 != null;
      }
      var v6646 = v15236;
      if (v6646) {
        return sym$$24;
      }
      var v6648 = this.parent;
      if (v6648) {
        var v6647 = this.parent;
        return v6647.findAmbient(name$$72, publicOnly$$17, typespace$$16);
      }
      return null;
    }
    function v848(name$$71, publicOnly$$16, typespace$$15) {
      var sym$$23 = null;
      var v6649;
      var v20448 = this.valueMembers;
      var v15238 = v20448 == null;
      if (v15238) {
        v6649 = null;
      } else {
        var v15237;
        if (publicOnly$$16) {
          var v20449 = this.valueMembers;
          v15237 = v20449.publicMembers;
        } else {
          var v20450 = this.valueMembers;
          v15237 = v20450.allMembers;
        }
        v6649 = v15237;
      }
      var table$$4 = v6649;
      var v6650;
      var v20451 = this.ambientValueMembers;
      var v15240 = v20451 == null;
      if (v15240) {
        v6650 = null;
      } else {
        var v15239;
        if (publicOnly$$16) {
          var v20452 = this.ambientValueMembers;
          v15239 = v20452.publicMembers;
        } else {
          var v20453 = this.ambientValueMembers;
          v15239 = v20453.allMembers;
        }
        v6650 = v15239;
      }
      var ambientTable$$3 = v6650;
      if (typespace$$15) {
        var v6651;
        var v20454 = this.enclosedTypes;
        var v15242 = v20454 == null;
        if (v15242) {
          v6651 = null;
        } else {
          var v15241;
          if (publicOnly$$16) {
            var v20455 = this.enclosedTypes;
            v15241 = v20455.publicMembers;
          } else {
            var v20456 = this.enclosedTypes;
            v15241 = v20456.allMembers;
          }
          v6651 = v15241;
        }
        table$$4 = v6651;
        var v6652;
        var v20457 = this.ambientEnclosedTypes;
        var v15244 = v20457 == null;
        if (v15244) {
          v6652 = null;
        } else {
          var v15243;
          if (publicOnly$$16) {
            var v20458 = this.ambientEnclosedTypes;
            v15243 = v20458.publicMembers;
          } else {
            var v20459 = this.ambientEnclosedTypes;
            v15243 = v20459.allMembers;
          }
          v6652 = v15243;
        }
        ambientTable$$3 = v6652;
      }
      var v15245 = ambientTable$$3;
      if (v15245) {
        var v20460 = sym$$23 = ambientTable$$3.lookup(name$$71);
        v15245 = v20460 != null;
      }
      var v6653 = v15245;
      if (v6653) {
        return sym$$23;
      }
      var v15246 = table$$4;
      if (v15246) {
        var v20461 = sym$$23 = table$$4.lookup(name$$71);
        v15246 = v20461 != null;
      }
      var v6654 = v15246;
      if (v6654) {
        return sym$$23;
      }
      var v6656 = this.parent;
      if (v6656) {
        var v6655 = this.parent;
        return v6655.find(name$$71, publicOnly$$16, typespace$$15);
      }
      return null;
    }
    function v847(outfile$$9) {
      function v846(key$$42, s$$23, context$$48) {
        var sym$$22 = s$$23;
        var v6657 = "  " + key$$42;
        outfile$$9.WriteLine(v6657);
        return;
      }
      function v845(key$$41, s$$22, context$$47) {
        var sym$$21 = s$$22;
        var v6658 = "  " + key$$41;
        outfile$$9.WriteLine(v6658);
        return;
      }
      function v844(key$$40, s$$21, context$$46) {
        var sym$$20 = s$$21;
        var v6659 = "  " + key$$40;
        outfile$$9.WriteLine(v6659);
        return;
      }
      function v843(key$$39, s$$20, context$$45) {
        var sym$$19 = s$$20;
        var v6660 = "  " + key$$39;
        outfile$$9.WriteLine(v6660);
        return;
      }
      var v15247 = _super$$56.prototype;
      var v6661 = v15247.print;
      v6661.call(this, outfile$$9);
      var v6663 = this.ambientValueMembers;
      if (v6663) {
        var v15248 = this.ambientValueMembers;
        var v6662 = v15248.allMembers;
        v6662.map(v843, null);
      }
      var v6665 = this.valueMembers;
      if (v6665) {
        var v15249 = this.valueMembers;
        var v6664 = v15249.allMembers;
        v6664.map(v844, null);
      }
      var v6667 = this.ambientEnclosedTypes;
      if (v6667) {
        var v15250 = this.ambientEnclosedTypes;
        var v6666 = v15250.allMembers;
        v6666.map(v845, null);
      }
      var v6669 = this.enclosedTypes;
      if (v6669) {
        var v15251 = this.enclosedTypes;
        var v6668 = v15251.allMembers;
        v6668.map(v846, null);
      }
      var v6671 = this.parent;
      if (v6671) {
        var v6670 = this.parent;
        v6670.print(outfile$$9);
      }
      return;
    }
    function v842(filter$$3, name$$70, publicOnly$$15, typespace$$14) {
      var sym$$18 = null;
      var v6672;
      var v20462 = this.valueMembers;
      var v15253 = v20462 == null;
      if (v15253) {
        v6672 = null;
      } else {
        var v15252;
        if (publicOnly$$15) {
          var v20463 = this.valueMembers;
          v15252 = v20463.publicMembers;
        } else {
          var v20464 = this.valueMembers;
          v15252 = v20464.allMembers;
        }
        v6672 = v15252;
      }
      var table$$3 = v6672;
      var v6673;
      var v20465 = this.ambientValueMembers;
      var v15255 = v20465 == null;
      if (v15255) {
        v6673 = null;
      } else {
        var v15254;
        if (publicOnly$$15) {
          var v20466 = this.ambientValueMembers;
          v15254 = v20466.publicMembers;
        } else {
          var v20467 = this.ambientValueMembers;
          v15254 = v20467.allMembers;
        }
        v6673 = v15254;
      }
      var ambientTable$$2 = v6673;
      if (typespace$$14) {
        var v6674;
        var v20468 = this.enclosedTypes;
        var v15257 = v20468 == null;
        if (v15257) {
          v6674 = null;
        } else {
          var v15256;
          if (publicOnly$$15) {
            var v20469 = this.enclosedTypes;
            v15256 = v20469.publicMembers;
          } else {
            var v20470 = this.enclosedTypes;
            v15256 = v20470.allMembers;
          }
          v6674 = v15256;
        }
        table$$3 = v6674;
        var v6675;
        var v20471 = this.ambientEnclosedTypes;
        var v15259 = v20471 == null;
        if (v15259) {
          v6675 = null;
        } else {
          var v15258;
          if (publicOnly$$15) {
            var v20472 = this.ambientEnclosedTypes;
            v15258 = v20472.publicMembers;
          } else {
            var v20473 = this.ambientEnclosedTypes;
            v15258 = v20473.allMembers;
          }
          v6675 = v15258;
        }
        ambientTable$$2 = v6675;
      }
      if (ambientTable$$2) {
        var v15260 = sym$$18 = ambientTable$$2.lookup(name$$70);
        var v6677 = v15260 != null;
        if (v6677) {
          var v6676 = filter$$3.update(sym$$18);
          if (v6676) {
            return sym$$18;
          }
        }
      }
      if (table$$3) {
        var v15261 = sym$$18 = table$$3.lookup(name$$70);
        var v6679 = v15261 != null;
        if (v6679) {
          var v6678 = filter$$3.update(sym$$18);
          if (v6678) {
            return sym$$18;
          }
        }
      }
      var v6682 = this.parent;
      if (v6682) {
        var v6680 = this.parent;
        sym$$18 = v6680.search(filter$$3, name$$70, publicOnly$$15, typespace$$14);
        if (sym$$18) {
          var v6681 = filter$$3.update(sym$$18);
          if (v6681) {
            return sym$$18;
          }
        }
      }
      return filter$$3.result;
    }
    function v841(members$$24) {
      var result$$26 = [];
      var v6684 = this.ambientValueMembers;
      if (v6684) {
        var v20474 = this.ambientValueMembers;
        var v15262 = v20474.allMembers;
        var v6683 = v15262.getAllKeys();
        result$$26 = result$$26.concat(v6683);
      }
      var v6686 = this.valueMembers;
      if (v6686) {
        var v20475 = this.valueMembers;
        var v15263 = v20475.allMembers;
        var v6685 = v15263.getAllKeys();
        result$$26 = result$$26.concat(v6685);
      }
      var v15264 = !members$$24;
      if (v15264) {
        v15264 = this.parent;
      }
      var v6688 = v15264;
      if (v6688) {
        var v6687 = this.parent;
        var parentResult$$4 = v6687.getAllValueSymbolNames(members$$24);
        if (parentResult$$4) {
          result$$26 = result$$26.concat(parentResult$$4);
        }
      }
      return result$$26;
    }
    function v840(members$$23) {
      var result$$25 = [];
      var v6690 = this.ambientEnclosedTypes;
      if (v6690) {
        var v20476 = this.ambientEnclosedTypes;
        var v15265 = v20476.allMembers;
        var v6689 = v15265.getAllKeys();
        result$$25 = result$$25.concat(v6689);
      }
      var v6692 = this.enclosedTypes;
      if (v6692) {
        var v20477 = this.enclosedTypes;
        var v15266 = v20477.allMembers;
        var v6691 = v15266.getAllKeys();
        result$$25 = result$$25.concat(v6691);
      }
      var v15267 = !members$$23;
      if (v15267) {
        v15267 = this.parent;
      }
      var v6694 = v15267;
      if (v6694) {
        var v6693 = this.parent;
        var parentResult$$3 = v6693.getAllTypeSymbolNames(members$$23);
        if (parentResult$$3) {
          result$$25 = result$$25.concat(parentResult$$3);
        }
      }
      return result$$25;
    }
    function v839(members$$22) {
      var result$$24 = this.getAllTypeSymbolNames(members$$22);
      var v6695 = this.getAllValueSymbolNames(members$$22);
      return result$$24.concat(v6695);
    }
    function v838() {
      return "builder";
    }
    function SymbolScopeBuilder$$1(valueMembers$$2, ambientValueMembers$$2, enclosedTypes$$2, ambientEnclosedTypes$$2, parent$$50, container$$7) {
      _super$$56.call(this, container$$7);
      this.valueMembers = valueMembers$$2;
      this.ambientValueMembers = ambientValueMembers$$2;
      this.enclosedTypes = enclosedTypes$$2;
      this.ambientEnclosedTypes = ambientEnclosedTypes$$2;
      this.parent = parent$$50;
      this.container = container$$7;
      return;
    }
    __extends(SymbolScopeBuilder$$1, _super$$56);
    var v6696 = SymbolScopeBuilder$$1.prototype;
    v6696.printLabel = v838;
    var v6697 = SymbolScopeBuilder$$1.prototype;
    v6697.getAllSymbolNames = v839;
    var v6698 = SymbolScopeBuilder$$1.prototype;
    v6698.getAllTypeSymbolNames = v840;
    var v6699 = SymbolScopeBuilder$$1.prototype;
    v6699.getAllValueSymbolNames = v841;
    var v6700 = SymbolScopeBuilder$$1.prototype;
    v6700.search = v842;
    var v6701 = SymbolScopeBuilder$$1.prototype;
    v6701.print = v847;
    var v6702 = SymbolScopeBuilder$$1.prototype;
    v6702.find = v848;
    var v6703 = SymbolScopeBuilder$$1.prototype;
    v6703.findAmbient = v849;
    var v6704 = SymbolScopeBuilder$$1.prototype;
    v6704.findLocal = v850;
    var v6705 = SymbolScopeBuilder$$1.prototype;
    v6705.enter = v851;
    var v6706 = SymbolScopeBuilder$$1.prototype;
    v6706.getTable = v852;
    return SymbolScopeBuilder$$1;
  }
  function v837(_super$$55) {
    function v836() {
      var v6707 = this.valueMembers;
      return v6707.publicMembers;
    }
    function v835(name$$69, publicOnly$$14, typespace$$13) {
      var sym$$17 = this.find(name$$69, publicOnly$$14, typespace$$13);
      if (sym$$17) {
        var v15268 = sym$$17.kind();
        var v15269 = SymbolKind.Type;
        var v6712 = v15268 == v15269;
        if (v6712) {
          var typeSym$$1 = sym$$17;
          var v20478 = typeSym$$1.type;
          var v15270 = v20478.hasImplementation();
          var v6708 = !v15270;
          if (v6708) {
            sym$$17 = null;
          }
        } else {
          var v6711 = sym$$17.container;
          if (v6711) {
            var v20479 = sym$$17.container;
            var v15271 = v20479.kind();
            var v15272 = SymbolKind.Type;
            var v6710 = v15271 == v15272;
            if (v6710) {
              var ctypeSym = sym$$17.container;
              var v20480 = ctypeSym.type;
              var v15273 = v20480.hasImplementation();
              var v6709 = !v15273;
              if (v6709) {
                sym$$17 = null;
              }
            }
          }
        }
      }
      return sym$$17;
    }
    function v834(outfile$$8) {
      function v833(key$$38, sym$$16, context$$44) {
        var v6713 = "  " + key$$38;
        outfile$$8.WriteLine(v6713);
        return;
      }
      function v832(key$$37, sym$$15, context$$43) {
        var v6714 = "  " + key$$37;
        outfile$$8.WriteLine(v6714);
        return;
      }
      function v831(key$$36, sym$$14, context$$42) {
        var v6715 = "  " + key$$36;
        outfile$$8.WriteLine(v6715);
        return;
      }
      function v830(key$$35, sym$$13, context$$41) {
        var v6716 = "  " + key$$35;
        outfile$$8.WriteLine(v6716);
        return;
      }
      var v15274 = _super$$55.prototype;
      var v6717 = v15274.print;
      v6717.call(this, outfile$$8);
      var v6719 = this.ambientValueMembers;
      if (v6719) {
        var v15275 = this.ambientValueMembers;
        var v6718 = v15275.allMembers;
        v6718.map(v830, null);
      }
      var v6721 = this.valueMembers;
      if (v6721) {
        var v15276 = this.valueMembers;
        var v6720 = v15276.allMembers;
        v6720.map(v831, null);
      }
      var v6723 = this.ambientEnclosedTypes;
      if (v6723) {
        var v15277 = this.ambientEnclosedTypes;
        var v6722 = v15277.allMembers;
        v6722.map(v832, null);
      }
      var v6725 = this.enclosedTypes;
      if (v6725) {
        var v15278 = this.enclosedTypes;
        var v6724 = v15278.allMembers;
        v6724.map(v833, null);
      }
      return;
    }
    function v829(name$$68, publicOnly$$13, typespace$$12) {
      var v6726;
      var v20481 = this.ambientValueMembers;
      var v15280 = v20481 == null;
      if (v15280) {
        v6726 = null;
      } else {
        var v15279;
        if (publicOnly$$13) {
          var v20482 = this.ambientValueMembers;
          v15279 = v20482.publicMembers;
        } else {
          var v20483 = this.ambientValueMembers;
          v15279 = v20483.allMembers;
        }
        v6726 = v15279;
      }
      var ambientTable$$1 = v6726;
      if (typespace$$12) {
        var v6727;
        var v20484 = this.ambientEnclosedTypes;
        var v15282 = v20484 == null;
        if (v15282) {
          v6727 = null;
        } else {
          var v15281;
          if (publicOnly$$13) {
            var v20485 = this.ambientEnclosedTypes;
            v15281 = v20485.publicMembers;
          } else {
            var v20486 = this.ambientEnclosedTypes;
            v15281 = v20486.allMembers;
          }
          v6727 = v15281;
        }
        ambientTable$$1 = v6727;
      }
      if (ambientTable$$1) {
        var s$$19 = ambientTable$$1.lookup(name$$68);
        if (s$$19) {
          return s$$19;
        }
      }
      return null;
    }
    function v828(name$$67, publicOnly$$12, typespace$$11) {
      var table$$2 = null;
      var ambientTable = null;
      if (typespace$$11) {
        var v6728;
        var v20487 = this.enclosedTypes;
        var v15284 = v20487 == null;
        if (v15284) {
          v6728 = null;
        } else {
          var v15283;
          if (publicOnly$$12) {
            var v20488 = this.enclosedTypes;
            v15283 = v20488.publicMembers;
          } else {
            var v20489 = this.enclosedTypes;
            v15283 = v20489.allMembers;
          }
          v6728 = v15283;
        }
        table$$2 = v6728;
        var v6729;
        var v20490 = this.ambientEnclosedTypes;
        var v15286 = v20490 == null;
        if (v15286) {
          v6729 = null;
        } else {
          var v15285;
          if (publicOnly$$12) {
            var v20491 = this.ambientEnclosedTypes;
            v15285 = v20491.publicMembers;
          } else {
            var v20492 = this.ambientEnclosedTypes;
            v15285 = v20492.allMembers;
          }
          v6729 = v15285;
        }
        ambientTable = v6729;
      } else {
        var v6730;
        var v20493 = this.valueMembers;
        var v15288 = v20493 == null;
        if (v15288) {
          v6730 = null;
        } else {
          var v15287;
          if (publicOnly$$12) {
            var v20494 = this.valueMembers;
            v15287 = v20494.publicMembers;
          } else {
            var v20495 = this.valueMembers;
            v15287 = v20495.allMembers;
          }
          v6730 = v15287;
        }
        table$$2 = v6730;
        var v6731;
        var v20496 = this.ambientValueMembers;
        var v15290 = v20496 == null;
        if (v15290) {
          v6731 = null;
        } else {
          var v15289;
          if (publicOnly$$12) {
            var v20497 = this.ambientValueMembers;
            v15289 = v20497.publicMembers;
          } else {
            var v20498 = this.ambientValueMembers;
            v15289 = v20498.allMembers;
          }
          v6731 = v15289;
        }
        ambientTable = v6731;
      }
      if (ambientTable) {
        var s$$18 = ambientTable.lookup(name$$67);
        if (s$$18) {
          return s$$18;
        }
      }
      if (table$$2) {
        s$$18 = table$$2.lookup(name$$67);
        if (s$$18) {
          return s$$18;
        }
      }
      return null;
    }
    function v827(filter$$2, name$$66, publicOnly$$11, typespace$$10) {
      var sym$$12 = this.find(name$$66, publicOnly$$11, typespace$$10);
      filter$$2.update(sym$$12);
      return filter$$2.result;
    }
    function v826(members$$21) {
      var result$$23 = [];
      var v6733 = this.ambientValueMembers;
      if (v6733) {
        var v20499 = this.ambientValueMembers;
        var v15291 = v20499.allMembers;
        var v6732 = v15291.getAllKeys();
        result$$23 = result$$23.concat(v6732);
      }
      var v6735 = this.valueMembers;
      if (v6735) {
        var v20500 = this.valueMembers;
        var v15292 = v20500.allMembers;
        var v6734 = v15292.getAllKeys();
        result$$23 = result$$23.concat(v6734);
      }
      return result$$23;
    }
    function v825(members$$20) {
      var result$$22 = [];
      var v6737 = this.ambientEnclosedTypes;
      if (v6737) {
        var v20501 = this.ambientEnclosedTypes;
        var v15293 = v20501.allMembers;
        var v6736 = v15293.getAllKeys();
        result$$22 = result$$22.concat(v6736);
      }
      var v6739 = this.enclosedTypes;
      if (v6739) {
        var v20502 = this.enclosedTypes;
        var v15294 = v20502.allMembers;
        var v6738 = v15294.getAllKeys();
        result$$22 = result$$22.concat(v6738);
      }
      return result$$22;
    }
    function v824(members$$19) {
      var result$$21 = this.getAllTypeSymbolNames(members$$19);
      var v6740 = this.getAllValueSymbolNames(members$$19);
      return result$$21.concat(v6740);
    }
    function v823() {
      return "table";
    }
    function SymbolTableScope$$1(valueMembers$$1, ambientValueMembers$$1, enclosedTypes$$1, ambientEnclosedTypes$$1, container$$6) {
      _super$$55.call(this, container$$6);
      this.valueMembers = valueMembers$$1;
      this.ambientValueMembers = ambientValueMembers$$1;
      this.enclosedTypes = enclosedTypes$$1;
      this.ambientEnclosedTypes = ambientEnclosedTypes$$1;
      this.container = container$$6;
      return;
    }
    __extends(SymbolTableScope$$1, _super$$55);
    var v6741 = SymbolTableScope$$1.prototype;
    v6741.printLabel = v823;
    var v6742 = SymbolTableScope$$1.prototype;
    v6742.getAllSymbolNames = v824;
    var v6743 = SymbolTableScope$$1.prototype;
    v6743.getAllTypeSymbolNames = v825;
    var v6744 = SymbolTableScope$$1.prototype;
    v6744.getAllValueSymbolNames = v826;
    var v6745 = SymbolTableScope$$1.prototype;
    v6745.search = v827;
    var v6746 = SymbolTableScope$$1.prototype;
    v6746.find = v828;
    var v6747 = SymbolTableScope$$1.prototype;
    v6747.findAmbient = v829;
    var v6748 = SymbolTableScope$$1.prototype;
    v6748.print = v834;
    var v6749 = SymbolTableScope$$1.prototype;
    v6749.findImplementation = v835;
    var v6750 = SymbolTableScope$$1.prototype;
    v6750.getTable = v836;
    return SymbolTableScope$$1;
  }
  function v822(_super$$54) {
    function v821(parent$$49) {
      var v15295 = this.parents;
      var v6751 = v15295 == null;
      if (v6751) {
        var v26995 = new Array;
        this.parents = v26995;
      }
      var v6752 = this.parents;
      var v15296 = this.parents;
      var v6753 = v15296.length;
      v6752[v6753] = parent$$49;
      return;
    }
    function v820(name$$65, publicOnly$$10, typespace$$9) {
      var sym$$11 = null;
      var i$$72 = 0;
      var cache$$1 = this.valueAmbientCache;
      if (typespace$$9) {
        cache$$1 = this.typeAmbientCache;
      }
      var v15297 = cache$$1;
      if (v15297) {
        var v20503 = sym$$11 = cache$$1.lookup(name$$65);
        v15297 = v20503 != null;
      }
      var v6754 = v15297;
      if (v6754) {
        return sym$$11;
      }
      var v6757 = this.parents;
      if (v6757) {
        i$$72 = 0;
        var v20504 = this.parents;
        var v15298 = v20504.length;
        var v6756 = i$$72 < v15298;
        for (;v6756;) {
          var v15299 = this.parents;
          var v6755 = v15299[i$$72];
          sym$$11 = v6755.findAmbient(name$$65, publicOnly$$10, typespace$$9);
          if (sym$$11) {
            break;
          }
          i$$72 = i$$72 + 1;
          var v20505 = this.parents;
          var v15300 = v20505.length;
          v6756 = i$$72 < v15300;
        }
      }
      var v6760 = cache$$1 == null;
      if (v6760) {
        if (typespace$$9) {
          var v6758 = TypeScript$$21.StringHashTable;
          var v26996 = new v6758;
          this.typeAmbientCache = v26996;
          cache$$1 = this.typeAmbientCache;
        } else {
          var v6759 = TypeScript$$21.StringHashTable;
          var v26997 = new v6759;
          this.valueAmbientCache = v26997;
          cache$$1 = this.valueAmbientCache;
        }
      }
      cache$$1.add(name$$65, sym$$11);
      return sym$$11;
    }
    function v819(name$$64, publicOnly$$9, typespace$$8) {
      var sym$$10 = null;
      var i$$71 = 0;
      var cache = this.valueCache;
      if (typespace$$8) {
        cache = this.typeCache;
      }
      var v20506 = cache;
      if (v20506) {
        var v23848 = sym$$10 = cache.lookup(name$$64);
        v20506 = v23848 != null;
      }
      var v15301 = v20506;
      if (v15301) {
        var v20507;
        if (publicOnly$$9) {
          var v26168 = sym$$10.flags;
          var v26468 = TypeScript$$21.SymbolFlags;
          var v26169 = v26468.Private;
          var v25483 = TypeScript$$21.hasFlag(v26168, v26169);
          var v26171 = !v25483;
          if (v26171) {
            var v26469 = sym$$10.declAST;
            if (v26469) {
              var v26691 = sym$$10.declAST;
              var v26613 = v26691.nodeType;
              var v26692 = TypeScript$$21.NodeType;
              var v26614 = v26692.FuncDecl;
              v26469 = v26613 == v26614;
            }
            var v26170 = v26469;
            if (v26170) {
              var v26615 = sym$$10.declAST;
              var v26470 = v26615.fncFlags;
              var v26616 = TypeScript$$21.FncFlags;
              var v26471 = v26616.Private;
              v26170 = TypeScript$$21.hasFlag(v26470, v26471);
            }
            v25483 = v26170;
          }
          var v23849 = v25483;
          v20507 = !v23849;
        } else {
          v20507 = true;
        }
        v15301 = v20507;
      }
      var v6761 = v15301;
      if (v6761) {
        return sym$$10;
      }
      var v6764 = this.parents;
      if (v6764) {
        i$$71 = 0;
        var v20508 = this.parents;
        var v15302 = v20508.length;
        var v6763 = i$$71 < v15302;
        for (;v6763;) {
          var v15303 = this.parents;
          var v6762 = v15303[i$$71];
          sym$$10 = v6762.find(name$$64, publicOnly$$9, typespace$$8);
          if (sym$$10) {
            break;
          }
          i$$71 = i$$71 + 1;
          var v20509 = this.parents;
          var v15304 = v20509.length;
          v6763 = i$$71 < v15304;
        }
      }
      var v6767 = cache == null;
      if (v6767) {
        if (typespace$$8) {
          var v6765 = TypeScript$$21.StringHashTable;
          var v26998 = new v6765;
          this.typeCache = v26998;
          cache = this.typeCache;
        } else {
          var v6766 = TypeScript$$21.StringHashTable;
          var v26999 = new v6766;
          this.valueCache = v26999;
          cache = this.valueCache;
        }
      }
      cache.add(name$$64, sym$$10);
      return sym$$10;
    }
    function v818(name$$63, publicOnly$$8, typespace$$7) {
      var sym$$9 = null;
      var i$$70 = 0;
      var implCache = this.valueImplCache;
      if (typespace$$7) {
        implCache = this.typeImplCache;
      }
      var v20510 = implCache;
      if (v20510) {
        var v23850 = sym$$9 = implCache.lookup(name$$63);
        v20510 = v23850 != null;
      }
      var v15305 = v20510;
      if (v15305) {
        var v20511;
        if (publicOnly$$8) {
          var v26172 = sym$$9.flags;
          var v26472 = TypeScript$$21.SymbolFlags;
          var v26173 = v26472.Private;
          var v25484 = TypeScript$$21.hasFlag(v26172, v26173);
          var v26175 = !v25484;
          if (v26175) {
            var v26473 = sym$$9.declAST;
            if (v26473) {
              var v26693 = sym$$9.declAST;
              var v26617 = v26693.nodeType;
              var v26694 = TypeScript$$21.NodeType;
              var v26618 = v26694.FuncDecl;
              v26473 = v26617 == v26618;
            }
            var v26174 = v26473;
            if (v26174) {
              var v26619 = sym$$9.declAST;
              var v26474 = v26619.fncFlags;
              var v26620 = TypeScript$$21.FncFlags;
              var v26475 = v26620.Private;
              v26174 = TypeScript$$21.hasFlag(v26474, v26475);
            }
            v25484 = v26174;
          }
          var v23851 = v25484;
          v20511 = !v23851;
        } else {
          v20511 = true;
        }
        v15305 = v20511;
      }
      var v6768 = v15305;
      if (v6768) {
        return sym$$9;
      }
      var v6771 = this.parents;
      if (v6771) {
        i$$70 = 0;
        var v20512 = this.parents;
        var v15306 = v20512.length;
        var v6770 = i$$70 < v15306;
        for (;v6770;) {
          var v15307 = this.parents;
          var v6769 = v15307[i$$70];
          sym$$9 = v6769.findImplementation(name$$63, publicOnly$$8, typespace$$7);
          if (sym$$9) {
            break;
          }
          i$$70 = i$$70 + 1;
          var v20513 = this.parents;
          var v15308 = v20513.length;
          v6770 = i$$70 < v15308;
        }
      }
      if (implCache) {
        if (typespace$$7) {
          var v6772 = TypeScript$$21.StringHashTable;
          var v27000 = new v6772;
          this.typeImplCache = v27000;
          implCache = this.typeImplCache;
        } else {
          var v6773 = TypeScript$$21.StringHashTable;
          var v27001 = new v6773;
          this.valueImplCache = v27001;
          implCache = this.valueImplCache;
        }
      }
      implCache.add(name$$63, sym$$9);
      return sym$$9;
    }
    function v817(outfile$$7) {
      var v15309 = _super$$54.prototype;
      var v6774 = v15309.print;
      v6774.call(this, outfile$$7);
      var v6777 = this.parents;
      if (v6777) {
        var i$$69 = 0;
        var v20514 = this.parents;
        var v15310 = v20514.length;
        var v6776 = i$$69 < v15310;
        for (;v6776;) {
          var v15311 = this.parents;
          var v6775 = v15311[i$$69];
          v6775.print(outfile$$7);
          i$$69 = i$$69 + 1;
          var v20515 = this.parents;
          var v15312 = v20515.length;
          v6776 = i$$69 < v15312;
        }
      }
      return;
    }
    function v816(members$$18) {
      var result$$20 = [];
      var v6780 = this.parents;
      if (v6780) {
        var i$$68 = 0;
        var v20516 = this.parents;
        var v15313 = v20516.length;
        var v6779 = i$$68 < v15313;
        for (;v6779;) {
          var v15314 = this.parents;
          var v6778 = v15314[i$$68];
          var parentResult$$2 = v6778.getAllValueSymbolNames(members$$18);
          if (parentResult$$2) {
            result$$20 = result$$20.concat(parentResult$$2);
          }
          i$$68 = i$$68 + 1;
          var v20517 = this.parents;
          var v15315 = v20517.length;
          v6779 = i$$68 < v15315;
        }
      }
      return result$$20;
    }
    function v815(members$$17) {
      var result$$19 = [];
      var v6783 = this.parents;
      if (v6783) {
        var i$$67 = 0;
        var v20518 = this.parents;
        var v15316 = v20518.length;
        var v6782 = i$$67 < v15316;
        for (;v6782;) {
          var v15317 = this.parents;
          var v6781 = v15317[i$$67];
          var parentResult$$1 = v6781.getAllTypeSymbolNames(members$$17);
          if (parentResult$$1) {
            result$$19 = result$$19.concat(parentResult$$1);
          }
          i$$67 = i$$67 + 1;
          var v20519 = this.parents;
          var v15318 = v20519.length;
          v6782 = i$$67 < v15318;
        }
      }
      return result$$19;
    }
    function v814(members$$16) {
      var result$$18 = [];
      var v6786 = this.parents;
      if (v6786) {
        var i$$66 = 0;
        var v20520 = this.parents;
        var v15319 = v20520.length;
        var v6785 = i$$66 < v15319;
        for (;v6785;) {
          var v15320 = this.parents;
          var v6784 = v15320[i$$66];
          var parentResult = v6784.getAllSymbolNames(members$$16);
          if (parentResult) {
            result$$18 = result$$18.concat(parentResult);
          }
          i$$66 = i$$66 + 1;
          var v20521 = this.parents;
          var v15321 = v20521.length;
          v6785 = i$$66 < v15321;
        }
      }
      return result$$18;
    }
    function v813(filter$$1, name$$62, publicOnly$$7, typespace$$6) {
      var v6790 = this.parents;
      if (v6790) {
        var i$$65 = 0;
        var v20522 = this.parents;
        var v15322 = v20522.length;
        var v6789 = i$$65 < v15322;
        for (;v6789;) {
          var v15323 = this.parents;
          var v6787 = v15323[i$$65];
          var sym$$8 = v6787.search(filter$$1, name$$62, publicOnly$$7, typespace$$6);
          if (sym$$8) {
            var v6788 = filter$$1.update(sym$$8);
            if (v6788) {
              return sym$$8;
            }
          }
          i$$65 = i$$65 + 1;
          var v20523 = this.parents;
          var v15324 = v20523.length;
          v6789 = i$$65 < v15324;
        }
      }
      return filter$$1.result;
    }
    function v812() {
      return "agg";
    }
    function SymbolAggregateScope$$1(container$$5) {
      _super$$54.call(this, container$$5);
      this.valueCache = null;
      this.valueImplCache = null;
      this.valueAmbientCache = null;
      this.typeCache = null;
      this.typeImplCache = null;
      this.typeAmbientCache = null;
      this.parents = null;
      this.container = container$$5;
      return;
    }
    __extends(SymbolAggregateScope$$1, _super$$54);
    var v6791 = SymbolAggregateScope$$1.prototype;
    v6791.printLabel = v812;
    var v6792 = SymbolAggregateScope$$1.prototype;
    v6792.search = v813;
    var v6793 = SymbolAggregateScope$$1.prototype;
    v6793.getAllSymbolNames = v814;
    var v6794 = SymbolAggregateScope$$1.prototype;
    v6794.getAllTypeSymbolNames = v815;
    var v6795 = SymbolAggregateScope$$1.prototype;
    v6795.getAllValueSymbolNames = v816;
    var v6796 = SymbolAggregateScope$$1.prototype;
    v6796.print = v817;
    var v6797 = SymbolAggregateScope$$1.prototype;
    v6797.findImplementation = v818;
    var v6798 = SymbolAggregateScope$$1.prototype;
    v6798.find = v819;
    var v6799 = SymbolAggregateScope$$1.prototype;
    v6799.findAmbient = v820;
    var v6800 = SymbolAggregateScope$$1.prototype;
    v6800.addParentScope = v821;
    return SymbolAggregateScope$$1;
  }
  function v811() {
    function v810() {
      throw new Error("please implement in derived class");
    }
    function v809(container$$4, ast$$60, symbol$$6, errorReporter$$2, publicOnly$$6, typespace$$5, ambient) {
      throw new Error("please implement in derived class");
    }
    function v808(outfile$$6) {
      var v6803 = this.container;
      if (v6803) {
        var v23852 = this.printLabel();
        var v20524 = v23852 + " scope with container: ";
        var v23853 = this.container;
        var v20525 = v23853.name;
        var v15325 = v20524 + v20525;
        var v6801 = v15325 + "...";
        outfile$$6.WriteLine(v6801);
      } else {
        var v15326 = this.printLabel();
        var v6802 = v15326 + " scope...";
        outfile$$6.WriteLine(v6802);
      }
      return;
    }
    function v807(name$$61, publicOnly$$5, typespace$$4) {
      return null;
    }
    function v806(name$$60, publicOnly$$4, typespace$$3) {
      return null;
    }
    function v805(name$$59, publicOnly$$3, typespace$$2) {
      return null;
    }
    function v804(name$$58, publicOnly$$2, typespace$$1) {
      return null;
    }
    function v803(filter, name$$57, publicOnly$$1, typespace) {
      return null;
    }
    function v802(members$$15) {
      return["please", "implement", "in", "derived", "classes"];
    }
    function v801(members$$14) {
      return["please", "implement", "in", "derived", "classes"];
    }
    function v800(members$$13) {
      return["please", "implement", "in", "derived", "classes"];
    }
    function v799() {
      return "base";
    }
    function SymbolScope$$1(container$$3) {
      this.container = container$$3;
      return;
    }
    var v6804 = SymbolScope$$1.prototype;
    v6804.printLabel = v799;
    var v6805 = SymbolScope$$1.prototype;
    v6805.getAllSymbolNames = v800;
    var v6806 = SymbolScope$$1.prototype;
    v6806.getAllTypeSymbolNames = v801;
    var v6807 = SymbolScope$$1.prototype;
    v6807.getAllValueSymbolNames = v802;
    var v6808 = SymbolScope$$1.prototype;
    v6808.search = v803;
    var v6809 = SymbolScope$$1.prototype;
    v6809.findLocal = v804;
    var v6810 = SymbolScope$$1.prototype;
    v6810.find = v805;
    var v6811 = SymbolScope$$1.prototype;
    v6811.findImplementation = v806;
    var v6812 = SymbolScope$$1.prototype;
    v6812.findAmbient = v807;
    var v6813 = SymbolScope$$1.prototype;
    v6813.print = v808;
    var v6814 = SymbolScope$$1.prototype;
    v6814.enter = v809;
    var v6815 = SymbolScope$$1.prototype;
    v6815.getTable = v810;
    return SymbolScope$$1;
  }
  function v798(SymbolKind$$1) {
    SymbolKind$$1._map = [];
    var v6816 = SymbolKind$$1._map;
    v6816[0] = "None";
    SymbolKind$$1.None = 0;
    var v6817 = SymbolKind$$1._map;
    v6817[1] = "Type";
    SymbolKind$$1.Type = 1;
    var v6818 = SymbolKind$$1._map;
    v6818[2] = "Field";
    SymbolKind$$1.Field = 2;
    var v6819 = SymbolKind$$1._map;
    v6819[3] = "Parameter";
    SymbolKind$$1.Parameter = 3;
    var v6820 = SymbolKind$$1._map;
    v6820[4] = "Variable";
    SymbolKind$$1.Variable = 4;
    return;
  }
  function v797() {
    function v796(key$$34, data$$34) {
      var v15327 = this.dualMembers;
      var v6821 = v15327.secondaryTable;
      return v6821.add(key$$34, data$$34);
    }
    function v795(key$$33, data$$33) {
      var v15328 = this.dualMembers;
      var v6822 = v15328.primaryTable;
      return v6822.add(key$$33, data$$33);
    }
    function ScopedMembers$$1(dualMembers) {
      this.dualMembers = dualMembers;
      this.allMembers = this.dualMembers;
      var v6823 = this.dualMembers;
      this.publicMembers = v6823.primaryTable;
      var v6824 = this.dualMembers;
      this.privateMembers = v6824.secondaryTable;
      return;
    }
    var v6825 = ScopedMembers$$1.prototype;
    v6825.addPublicMember = v795;
    var v6826 = ScopedMembers$$1.prototype;
    v6826.addPrivateMember = v796;
    return ScopedMembers$$1;
  }
  var ScopedMembers = v797();
  TypeScript$$21.ScopedMembers = ScopedMembers;
  var v15329 = TypeScript$$21.SymbolKind;
  var v20526 = !v15329;
  if (v20526) {
    v15329 = TypeScript$$21.SymbolKind = {};
  }
  var v6827 = v15329;
  v798(v6827);
  var SymbolKind = TypeScript$$21.SymbolKind;
  var SymbolScope = v811();
  TypeScript$$21.SymbolScope = SymbolScope;
  var SymbolAggregateScope = v822(SymbolScope);
  TypeScript$$21.SymbolAggregateScope = SymbolAggregateScope;
  var SymbolTableScope = v837(SymbolScope);
  TypeScript$$21.SymbolTableScope = SymbolTableScope;
  var SymbolScopeBuilder = v853(SymbolScope);
  TypeScript$$21.SymbolScopeBuilder = SymbolScopeBuilder;
  var FilteredSymbolScope = v857(SymbolScope);
  TypeScript$$21.FilteredSymbolScope = FilteredSymbolScope;
  var FilteredSymbolScopeBuilder = v861(SymbolScopeBuilder);
  TypeScript$$21.FilteredSymbolScopeBuilder = FilteredSymbolScopeBuilder;
  return;
}
function v794(TypeScript$$20) {
  function v793(_super$$53) {
    function v792() {
      return true;
    }
    function v791(type$$36) {
      var v15330 = this.variable;
      var v6828 = v15330.typeLink;
      v6828.type = type$$36;
      return;
    }
    function v790(scope$$20) {
      var v6829 = TypeScript$$20.MemberName;
      var v15331 = this.getType();
      var v6830 = v15331.getScopedTypeNameEx(scope$$20);
      var v15332 = this.name;
      var v6831 = v15332 + ": ";
      return v6829.create(v6830, v6831, "");
    }
    function v789() {
      var v15333 = this.variable;
      var v6832 = v15333.typeLink;
      return v6832.type;
    }
    function v788() {
      return true;
    }
    function v787() {
      var v6833 = TypeScript$$20.SymbolKind;
      return v6833.Variable;
    }
    function VariableSymbol$$1(name$$56, location$$27, unitIndex$$9, variable) {
      var v6834 = name$$56.length;
      _super$$53.call(this, name$$56, location$$27, v6834, unitIndex$$9);
      this.variable = variable;
      return;
    }
    __extends(VariableSymbol$$1, _super$$53);
    var v6835 = VariableSymbol$$1.prototype;
    v6835.kind = v787;
    var v6836 = VariableSymbol$$1.prototype;
    v6836.writeable = v788;
    var v6837 = VariableSymbol$$1.prototype;
    v6837.getType = v789;
    var v6838 = VariableSymbol$$1.prototype;
    v6838.getTypeNameEx = v790;
    var v6839 = VariableSymbol$$1.prototype;
    v6839.setType = v791;
    var v6840 = VariableSymbol$$1.prototype;
    v6840.isVariable = v792;
    return VariableSymbol$$1;
  }
  function v786(_super$$52) {
    function v785() {
      var v15334 = this.paramDocComment;
      var v6849 = !v15334;
      if (v6849) {
        var parameterComments = [];
        var v6845 = this.funcDecl;
        if (v6845) {
          var v6841 = this.funcDecl;
          var fncDocComments$$1 = v6841.getDocComments();
          var v6842 = TypeScript$$20.Comment;
          var v6843 = this.name;
          var paramComment = v6842.getParameterDocCommentText(v6843, fncDocComments$$1);
          var v6844 = paramComment != "";
          if (v6844) {
            parameterComments.push(paramComment);
          }
        }
        var v6846 = TypeScript$$20.Comment;
        var v6847 = this.getDocComments();
        var docComments$$1 = v6846.getDocCommentText(v6847);
        var v6848 = docComments$$1 != "";
        if (v6848) {
          parameterComments.push(docComments$$1);
        }
        var v27002 = parameterComments.join("\n");
        this.paramDocComment = v27002;
      }
      return this.paramDocComment;
    }
    function v784(pattern$$7, replacement$$5, checker$$14) {
      var v20527 = this.parameter;
      var v15335 = v20527.typeLink;
      var v6850 = v15335.type;
      var rType$$1 = v6850.specializeType(pattern$$7, replacement$$5, checker$$14, false);
      var v23854 = this.parameter;
      var v20528 = v23854.typeLink;
      var v15336 = v20528.type;
      var v6853 = v15336 != rType$$1;
      if (v6853) {
        var paramDef$$1 = new ValueLocation;
        var v6851 = this.name;
        var v15337 = checker$$14.locationInfo;
        var v6852 = v15337.unitIndex;
        var result$$17 = new ParameterSymbol$$1(v6851, 0, v6852, paramDef$$1);
        paramDef$$1.symbol = result$$17;
        result$$17.setType(rType$$1);
        return result$$17;
      } else {
        return this;
      }
      return;
    }
    function v783() {
      var v6854 = this.getTypeNameEx(null);
      return v6854.toString();
    }
    function v782(scope$$19) {
      var v6855 = TypeScript$$20.MemberName;
      var v15338 = this.getType();
      var v6856 = v15338.getScopedTypeNameEx(scope$$19);
      var v20529 = this.name;
      var v23855;
      var v25485 = this.isOptional();
      if (v25485) {
        v23855 = "?";
      } else {
        v23855 = "";
      }
      var v20530 = v23855;
      var v15339 = v20529 + v20530;
      var v6857 = v15339 + ": ";
      return v6855.create(v6856, v6857, "");
    }
    function v781() {
      var v20531 = this.parameter;
      if (v20531) {
        var v23856 = this.parameter;
        v20531 = v23856.symbol;
      }
      var v15340 = v20531;
      if (v15340) {
        var v23857 = this.parameter;
        var v20532 = v23857.symbol;
        v15340 = v20532.declAST;
      }
      var v6859 = v15340;
      if (v6859) {
        var v20533 = this.parameter;
        var v15341 = v20533.symbol;
        var v6858 = v15341.declAST;
        return v6858.isOptional;
      } else {
        return false;
      }
      return;
    }
    function v780() {
      return true;
    }
    function v779(type$$35) {
      var v15342 = this.parameter;
      var v6860 = v15342.typeLink;
      v6860.type = type$$35;
      return;
    }
    function v778() {
      var v15343 = this.parameter;
      var v6861 = v15343.typeLink;
      return v6861.type;
    }
    function v777() {
      return true;
    }
    function v776() {
      var v6862 = TypeScript$$20.SymbolKind;
      return v6862.Parameter;
    }
    function ParameterSymbol$$1(name$$55, location$$26, unitIndex$$8, parameter) {
      var v6863 = name$$55.length;
      _super$$52.call(this, name$$55, location$$26, v6863, unitIndex$$8);
      this.parameter = parameter;
      this.paramDocComment = null;
      this.funcDecl = null;
      this.argsOffset = -1;
      this.name = name$$55;
      this.location = location$$26;
      return;
    }
    __extends(ParameterSymbol$$1, _super$$52);
    var v6864 = ParameterSymbol$$1.prototype;
    v6864.kind = v776;
    var v6865 = ParameterSymbol$$1.prototype;
    v6865.writeable = v777;
    var v6866 = ParameterSymbol$$1.prototype;
    v6866.getType = v778;
    var v6867 = ParameterSymbol$$1.prototype;
    v6867.setType = v779;
    var v6868 = ParameterSymbol$$1.prototype;
    v6868.isVariable = v780;
    var v6869 = ParameterSymbol$$1.prototype;
    v6869.isOptional = v781;
    var v6870 = ParameterSymbol$$1.prototype;
    v6870.getTypeNameEx = v782;
    var v6871 = ParameterSymbol$$1.prototype;
    v6871.toString = v783;
    var v6872 = ParameterSymbol$$1.prototype;
    v6872.specializeType = v784;
    var v6873 = ParameterSymbol$$1.prototype;
    v6873.getParameterDocComments = v785;
    return ParameterSymbol$$1;
  }
  function v775(_super$$51) {
    function v774() {
      var v20534 = this.getter;
      var v15344 = v20534 != null;
      var v20536 = !v15344;
      if (v20536) {
        var v20535 = this.setter;
        v15344 = v20535 != null;
      }
      var v6880 = v15344;
      if (v6880) {
        var comments$$11 = [];
        var v15345 = this.getter;
        var v6875 = v15345 != null;
        if (v6875) {
          var v15346 = this.getter;
          var v6874 = v15346.getDocComments();
          comments$$11 = comments$$11.concat(v6874);
        }
        var v15347 = this.setter;
        var v6877 = v15347 != null;
        if (v6877) {
          var v15348 = this.setter;
          var v6876 = v15348.getDocComments();
          comments$$11 = comments$$11.concat(v6876);
        }
        return comments$$11;
      } else {
        var v15349 = this.declAST;
        var v6879 = v15349 != null;
        if (v6879) {
          var v6878 = this.declAST;
          return v6878.getDocComments();
        }
      }
      return[];
    }
    function v773(pattern$$6, replacement$$4, checker$$13) {
      var v20537 = this.field;
      var v15350 = v20537.typeLink;
      var v6881 = v15350.type;
      var rType = v6881.specializeType(pattern$$6, replacement$$4, checker$$13, false);
      var v23858 = this.field;
      var v20538 = v23858.typeLink;
      var v15351 = v20538.type;
      var v6886 = rType != v15351;
      if (v6886) {
        var fieldDef = new ValueLocation;
        var v6882 = this.name;
        var v15352 = checker$$13.locationInfo;
        var v6883 = v15352.unitIndex;
        var v6884 = this.canWrite;
        var result$$16 = new FieldSymbol$$1(v6882, 0, v6883, v6884, fieldDef);
        result$$16.flags = this.flags;
        fieldDef.symbol = result$$16;
        var v6885 = fieldDef;
        var v15353 = TypeScript$$20.TypeLink;
        var v27003 = new v15353;
        v6885.typeLink = v27003;
        result$$16.setType(rType);
        result$$16.typeCheckStatus = TypeCheckStatus.Finished;
        return result$$16;
      } else {
        return this;
      }
      return;
    }
    function v772() {
      var v6887 = this.getTypeNameEx(null);
      return v6887.toString();
    }
    function v771() {
      return true;
    }
    function v770() {
      var v15354 = this.getter;
      var v6888 = v15354 != null;
      var v15356 = !v6888;
      if (v15356) {
        var v15355 = this.setter;
        v6888 = v15355 != null;
      }
      return v6888;
    }
    function v769(type$$34) {
      var v15357 = this.field;
      var v6889 = v15357.typeLink;
      v6889.type = type$$34;
      return;
    }
    function v768() {
      return true;
    }
    function v767(scope$$18) {
      var v6890 = TypeScript$$20.MemberName;
      var v23859 = this.field;
      var v20539 = v23859.typeLink;
      var v15358 = v20539.type;
      var v6891 = v15358.getScopedTypeNameEx(scope$$18);
      var v20540 = this.name;
      var v20541 = this.getOptionalNameString();
      var v15359 = v20540 + v20541;
      var v6892 = v15359 + ": ";
      return v6890.create(v6891, v6892, "");
    }
    function v766() {
      var v15360 = this.field;
      var v6893 = v15360.typeLink;
      return v6893.type;
    }
    function v765() {
      var v6894;
      var v15362 = this.isAccessor();
      if (v15362) {
        var v15361 = this.setter;
        v6894 = v15361 != null;
      } else {
        v6894 = this.canWrite;
      }
      return v6894;
    }
    function v764() {
      var v6895 = TypeScript$$20.SymbolKind;
      return v6895.Field;
    }
    function FieldSymbol$$1(name$$54, location$$25, unitIndex$$7, canWrite, field) {
      var v6896 = name$$54.length;
      _super$$51.call(this, name$$54, location$$25, v6896, unitIndex$$7);
      this.canWrite = canWrite;
      this.field = field;
      this.getter = null;
      this.setter = null;
      this.hasBeenEmitted = false;
      this.name = name$$54;
      this.location = location$$25;
      return;
    }
    __extends(FieldSymbol$$1, _super$$51);
    var v6897 = FieldSymbol$$1.prototype;
    v6897.kind = v764;
    var v6898 = FieldSymbol$$1.prototype;
    v6898.writeable = v765;
    var v6899 = FieldSymbol$$1.prototype;
    v6899.getType = v766;
    var v6900 = FieldSymbol$$1.prototype;
    v6900.getTypeNameEx = v767;
    var v6901 = FieldSymbol$$1.prototype;
    v6901.isMember = v768;
    var v6902 = FieldSymbol$$1.prototype;
    v6902.setType = v769;
    var v6903 = FieldSymbol$$1.prototype;
    v6903.isAccessor = v770;
    var v6904 = FieldSymbol$$1.prototype;
    v6904.isVariable = v771;
    var v6905 = FieldSymbol$$1.prototype;
    v6905.toString = v772;
    var v6906 = FieldSymbol$$1.prototype;
    v6906.specializeType = v773;
    var v6907 = FieldSymbol$$1.prototype;
    v6907.getDocComments = v774;
    return FieldSymbol$$1;
  }
  function v763(_super$$50) {
    function v762() {
      return true;
    }
    function WithSymbol$$1(location$$24, unitIndex$$6, withType$$1) {
      _super$$50.call(this, "with", location$$24, 4, unitIndex$$6, withType$$1);
      return;
    }
    __extends(WithSymbol$$1, _super$$50);
    var v6908 = WithSymbol$$1.prototype;
    v6908.isWith = v762;
    return WithSymbol$$1;
  }
  function v761(_super$$49) {
    function v760() {
      var comments$$10 = [];
      var v15363 = this.declAST;
      var v6910 = v15363 != null;
      if (v6910) {
        var v15364 = this.declAST;
        var v6909 = v15364.getDocComments();
        comments$$10 = comments$$10.concat(v6909);
      }
      var i$$64 = 0;
      var v20542 = this.expansionsDeclAST;
      var v15365 = v20542.length;
      var v6912 = i$$64 < v15365;
      for (;v6912;) {
        var v20543 = this.expansionsDeclAST;
        var v15366 = v20543[i$$64];
        var v6911 = v15366.getDocComments();
        comments$$10 = comments$$10.concat(v6911);
        i$$64 = i$$64 + 1;
        var v20544 = this.expansionsDeclAST;
        var v15367 = v20544.length;
        v6912 = i$$64 < v15367;
      }
      return comments$$10;
    }
    function v759(scopeSymbolPath) {
      var scopeSymbolPathLength = scopeSymbolPath.length;
      var externalSymbol = null;
      var v23860 = scopeSymbolPath.length;
      var v20545 = v23860 > 0;
      if (v20545) {
        var v26176 = scopeSymbolPathLength - 1;
        var v25486 = scopeSymbolPath[v26176];
        var v23861 = v25486.getType();
        v20545 = v23861.isModuleType();
      }
      var v15368 = v20545;
      if (v15368) {
        var v23862 = scopeSymbolPathLength - 1;
        var v20546 = scopeSymbolPath[v23862];
        v15368 = v20546.isDynamic;
      }
      var v6919 = v15368;
      if (v6919) {
        var v20547 = scopeSymbolPathLength > 1;
        if (v20547) {
          var v26177 = scopeSymbolPathLength - 2;
          var v25487 = scopeSymbolPath[v26177];
          var v23863 = v25487.getType();
          v20547 = v23863.isModuleType();
        }
        var v15369 = v20547;
        if (v15369) {
          var v23864 = scopeSymbolPathLength - 2;
          var v20548 = scopeSymbolPath[v23864];
          v15369 = v20548.isDynamic;
        }
        var v6915 = v15369;
        if (v6915) {
          var v15370 = scopeSymbolPathLength - 2;
          var v6913 = scopeSymbolPath[v15370];
          var moduleType = v6913.getType();
          var v6914 = this.type;
          externalSymbol = moduleType.findDynamicModuleName(v6914);
        }
        var v6918 = externalSymbol == null;
        if (v6918) {
          var v15371 = scopeSymbolPathLength - 1;
          var v6916 = scopeSymbolPath[v15371];
          moduleType = v6916.getType();
          var v6917 = this.type;
          externalSymbol = moduleType.findDynamicModuleName(v6917);
        }
      }
      return externalSymbol;
    }
    function v758(scopeSymbol$$1) {
      var v23865 = !scopeSymbol$$1;
      var v20549 = !v23865;
      if (v20549) {
        var v23866 = this.prettyName;
        v20549 = TypeScript$$20.isQuoted(v23866);
      }
      var v15372 = v20549;
      if (v15372) {
        var v20550 = this.type;
        v15372 = v20550.isModuleType();
      }
      var v6921 = v15372;
      if (v6921) {
        var symbolPath = scopeSymbol$$1.pathToRoot();
        var prettyName$$1 = this.getPrettyNameOfDynamicModule(symbolPath);
        var v6920 = prettyName$$1 != null;
        if (v6920) {
          return prettyName$$1.name;
        }
      }
      return this.prettyName;
    }
    function v757(pattern$$5, replacement$$3, checker$$12) {
      var v15373 = this.type;
      var v6925 = v15373 == pattern$$5;
      if (v6925) {
        return replacement$$3.symbol;
      } else {
        var v6922 = this.type;
        var replType = v6922.specializeType(pattern$$5, replacement$$3, checker$$12, false);
        var v15374 = this.type;
        var v6924 = replType != v15374;
        if (v6924) {
          var v6923 = this.name;
          var result$$15 = new TypeSymbol$$1(v6923, -1, 0, -1, replType);
          return result$$15;
        } else {
          return this;
        }
      }
      return;
    }
    function v756() {
      var v15375 = this.declAST;
      var v6926 = v15375 != null;
      if (v6926) {
        var v20551 = this.declAST;
        var v15376 = v20551.nodeType;
        var v20552 = TypeScript$$20.NodeType;
        var v15377 = v20552.FuncDecl;
        v6926 = v15376 == v15377;
      }
      return v6926;
    }
    function v755() {
      var v6927 = this.instanceType;
      return v6927 != null;
    }
    function v754() {
      var v6928 = this.type;
      var result$$14 = v6928.getTypeName();
      var v6930 = this.name;
      if (v6930) {
        var v15378 = this.name;
        var v6929 = v15378 + ":";
        result$$14 = v6929 + result$$14;
      }
      return result$$14;
    }
    function v753() {
      var v25488 = this.type;
      var v23867 = v25488.typeFlags;
      var v25489 = TypeScript$$20.TypeFlags;
      var v23868 = v25489.IsClass;
      var v20553 = v23867 & v23868;
      var v15379 = !v20553;
      if (v15379) {
        var v20554 = this.type;
        v15379 = v20554.isClass();
      }
      var v6933 = v15379;
      if (v6933) {
        var v15380 = this.type;
        var v6931 = v15380.instanceType;
        return v6931.constructorScope;
      } else {
        var v6932 = this.type;
        return v6932.containedScope;
      }
      return;
    }
    function v752(scope$$17) {
      var v6934 = this.type;
      var v15381;
      var v20557 = this.name;
      if (v20557) {
        var v20555 = this.name;
        var v20556 = this.getOptionalNameString();
        v15381 = v20555 + v20556;
      } else {
        v15381 = "";
      }
      var v6935 = v15381;
      return v6934.getMemberTypeNameEx(v6935, false, false, scope$$17);
    }
    function v751() {
      return this.type;
    }
    function v750() {
      return true;
    }
    function v749() {
      var v6936 = TypeScript$$20.SymbolKind;
      return v6936.Type;
    }
    function v748(loc) {
      var v15382 = this.additionalLocations;
      var v6937 = v15382 == null;
      if (v6937) {
        this.additionalLocations = [];
      }
      var v6938 = this.additionalLocations;
      var v15383 = this.additionalLocations;
      var v6939 = v15383.length;
      v6938[v6939] = loc;
      return;
    }
    function TypeSymbol$$1(locName, location$$23, length$$17, unitIndex$$5, type$$33) {
      _super$$49.call(this, locName, location$$23, length$$17, unitIndex$$5);
      this.type = type$$33;
      this.expansions = [];
      this.expansionsDeclAST = [];
      this.isDynamic = false;
      this.isMethod = false;
      this.aliasLink = null;
      this.onlyReferencedAsTypeRef = TypeScript$$20.optimizeModuleCodeGen;
      this.prettyName = this.name;
      return;
    }
    __extends(TypeSymbol$$1, _super$$49);
    var v6940 = TypeSymbol$$1.prototype;
    v6940.addLocation = v748;
    var v6941 = TypeSymbol$$1.prototype;
    v6941.kind = v749;
    var v6942 = TypeSymbol$$1.prototype;
    v6942.isType = v750;
    var v6943 = TypeSymbol$$1.prototype;
    v6943.getType = v751;
    var v6944 = TypeSymbol$$1.prototype;
    v6944.getTypeNameEx = v752;
    var v6945 = TypeSymbol$$1.prototype;
    v6945.instanceScope = v753;
    var v6946 = TypeSymbol$$1.prototype;
    v6946.toString = v754;
    var v6947 = TypeSymbol$$1.prototype;
    v6947.isClass = v755;
    var v6948 = TypeSymbol$$1.prototype;
    v6948.isFunction = v756;
    var v6949 = TypeSymbol$$1.prototype;
    v6949.specializeType = v757;
    var v6950 = TypeSymbol$$1.prototype;
    v6950.getPrettyName = v758;
    var v6951 = TypeSymbol$$1.prototype;
    v6951.getPrettyNameOfDynamicModule = v759;
    var v6952 = TypeSymbol$$1.prototype;
    v6952.getDocComments = v760;
    return TypeSymbol$$1;
  }
  function v747(_super$$48) {
    function v746(varFlags) {
      var v20558 = TypeScript$$20.VarFlags;
      var v15384 = v20558.Ambient;
      var v6953 = TypeScript$$20.hasFlag(varFlags, v15384);
      if (v6953) {
        var v15385 = this.flags;
        var v20559 = TypeScript$$20.SymbolFlags;
        var v15386 = v20559.Ambient;
        this.flags = v15385 | v15386;
      }
      var v20560 = TypeScript$$20.VarFlags;
      var v15387 = v20560.Constant;
      var v6954 = TypeScript$$20.hasFlag(varFlags, v15387);
      if (v6954) {
        var v15388 = this.flags;
        var v20561 = TypeScript$$20.SymbolFlags;
        var v15389 = v20561.Constant;
        this.flags = v15388 | v15389;
      }
      var v20562 = TypeScript$$20.VarFlags;
      var v15390 = v20562.Static;
      var v6955 = TypeScript$$20.hasFlag(varFlags, v15390);
      if (v6955) {
        var v15391 = this.flags;
        var v20563 = TypeScript$$20.SymbolFlags;
        var v15392 = v20563.Static;
        this.flags = v15391 | v15392;
      }
      var v20564 = TypeScript$$20.VarFlags;
      var v15393 = v20564.Property;
      var v6956 = TypeScript$$20.hasFlag(varFlags, v15393);
      if (v6956) {
        var v15394 = this.flags;
        var v20565 = TypeScript$$20.SymbolFlags;
        var v15395 = v20565.Property;
        this.flags = v15394 | v15395;
      }
      var v20566 = TypeScript$$20.VarFlags;
      var v15396 = v20566.Private;
      var v6957 = TypeScript$$20.hasFlag(varFlags, v15396);
      if (v6957) {
        var v15397 = this.flags;
        var v20567 = TypeScript$$20.SymbolFlags;
        var v15398 = v20567.Private;
        this.flags = v15397 | v15398;
      }
      var v20568 = TypeScript$$20.VarFlags;
      var v15399 = v20568.Public;
      var v6958 = TypeScript$$20.hasFlag(varFlags, v15399);
      if (v6958) {
        var v15400 = this.flags;
        var v20569 = TypeScript$$20.SymbolFlags;
        var v15401 = v20569.Public;
        this.flags = v15400 | v15401;
      }
      var v20570 = TypeScript$$20.VarFlags;
      var v15402 = v20570.Readonly;
      var v6959 = TypeScript$$20.hasFlag(varFlags, v15402);
      if (v6959) {
        var v15403 = this.flags;
        var v20571 = TypeScript$$20.SymbolFlags;
        var v15404 = v20571.Readonly;
        this.flags = v15403 | v15404;
      }
      var v20572 = TypeScript$$20.VarFlags;
      var v15405 = v20572.Exported;
      var v6960 = TypeScript$$20.hasFlag(varFlags, v15405);
      if (v6960) {
        var v15406 = this.flags;
        var v20573 = TypeScript$$20.SymbolFlags;
        var v15407 = v20573.Exported;
        this.flags = v15406 | v15407;
      }
      return;
    }
    function v745() {
      return true;
    }
    function InferenceSymbol$$1(name$$53, location$$22, length$$16, unitIndex$$4) {
      _super$$48.call(this, name$$53, location$$22, length$$16, unitIndex$$4);
      this.typeCheckStatus = TypeCheckStatus.NotStarted;
      return;
    }
    __extends(InferenceSymbol$$1, _super$$48);
    var v6961 = InferenceSymbol$$1.prototype;
    v6961.isInferenceSymbol = v745;
    var v6962 = InferenceSymbol$$1.prototype;
    v6962.transferVarFlags = v746;
    return InferenceSymbol$$1;
  }
  function v744() {
    function ValueLocation$$1() {
      return;
    }
    return ValueLocation$$1;
  }
  function v743() {
    function v742() {
      var v6963 = this.flags;
      var v15408 = TypeScript$$20.SymbolFlags;
      var v6964 = v15408.Static;
      return TypeScript$$20.hasFlag(v6963, v6964);
    }
    function v741() {
      var v15409 = this.declAST;
      var v6966 = v15409 != null;
      if (v6966) {
        var v6965 = this.declAST;
        return v6965.getDocComments();
      }
      return[];
    }
    function v740() {
      var v20574 = this.declAST;
      var v15410 = v20574 != null;
      if (v15410) {
        var v23869 = this.declAST;
        var v20575 = v23869.nodeType;
        var v23870 = TypeScript$$20.NodeType;
        var v20576 = v23870.VarDecl;
        v15410 = v20575 == v20576;
      }
      var v6967 = v15410;
      if (v6967) {
        return this.declAST;
      }
      return null;
    }
    function v739(checker$$11) {
      var v15411 = this.declAST;
      var v6971 = v15411 != null;
      if (v6971) {
        var v20577 = this.declAST;
        var v15412 = v20577.nodeType;
        var v20578 = TypeScript$$20.NodeType;
        var v15413 = v20578.InterfaceDeclaration;
        var v6970 = v15412 == v15413;
        if (v6970) {
          return this.declAST;
        } else {
          var v23871 = this.container;
          var v20579 = v23871 != null;
          if (v20579) {
            var v23872 = this.container;
            var v23873 = checker$$11.gloMod;
            v20579 = v23872 != v23873;
          }
          var v15414 = v20579;
          if (v15414) {
            var v25490 = this.container;
            var v23874 = v25490.declAST;
            var v20580 = v23874.nodeType;
            var v23875 = TypeScript$$20.NodeType;
            var v20581 = v23875.InterfaceDeclaration;
            v15414 = v20580 == v20581;
          }
          var v6969 = v15414;
          if (v6969) {
            var v6968 = this.container;
            return v6968.declAST;
          }
        }
      }
      return null;
    }
    function v738() {
      throw new Error("please implement in derived class");
    }
    function v737(type$$32) {
      throw new Error("please implement in derived class");
    }
    function v736(pattern$$4, replacement$$2, checker$$10) {
      throw new Error("please implement in derived class");
    }
    function v735(outfile$$5) {
      var v6972 = this.toString();
      outfile$$5.Write(v6972);
      return;
    }
    function v734() {
      var v6973 = this.name;
      if (v6973) {
        return this.name;
      } else {
        return "_anonymous";
      }
      return;
    }
    function v733(identifier) {
      var v15415 = this.refs;
      var v6974 = !v15415;
      if (v6974) {
        this.refs = [];
      }
      var v6975 = this.refs;
      var v15416 = this.refs;
      var v6976 = v15416.length;
      v6975[v6976] = identifier;
      return;
    }
    function v732(scope$$16, checker$$9) {
      var v15417 = checker$$9 == null;
      var v20584 = !v15417;
      if (v20584) {
        var v20582 = this.container;
        var v20583 = checker$$9.gloMod;
        v15417 = v20582 == v20583;
      }
      var v6977 = v15417;
      if (v6977) {
        return true;
      }
      var v15418 = this.flags;
      var v20585 = TypeScript$$20.SymbolFlags;
      var v15419 = v20585.ModuleMember;
      var v6993 = TypeScript$$20.hasFlag(v15418, v15419);
      if (v6993) {
        var v15420 = this.flags;
        var v20586 = TypeScript$$20.SymbolFlags;
        var v15421 = v20586.Exported;
        var v6981 = TypeScript$$20.hasFlag(v15420, v15421);
        if (v6981) {
          var v20587 = this.flags;
          var v23876 = TypeScript$$20.SymbolFlags;
          var v20588 = v23876.Private;
          var v15422 = TypeScript$$20.hasFlag(v20587, v20588);
          var v6979 = !v15422;
          if (v6979) {
            return true;
          } else {
            var v6978 = scope$$16.container;
            return aEnclosesB(this, v6978);
          }
        } else {
          var v15423 = checker$$9;
          if (v15423) {
            var v20589 = checker$$9.currentModDecl;
            var v20590 = this.declModule;
            v15423 = v20589 == v20590;
          }
          var v6980 = v15423;
          var v15425 = !v6980;
          if (v15425) {
            var v26476 = checker$$9.currentModDecl;
            if (v26476) {
              var v26621 = checker$$9.currentModDecl;
              v26476 = v26621.mod;
            }
            var v26178 = v26476;
            if (v26178) {
              var v26622 = checker$$9.currentModDecl;
              var v26477 = v26622.mod;
              v26178 = v26477.symbol;
            }
            var v25491 = v26178;
            if (v25491) {
              v25491 = this.declModule;
            }
            var v23877 = v25491;
            if (v23877) {
              var v25492 = this.declModule;
              v23877 = v25492.mod;
            }
            var v20591 = v23877;
            if (v20591) {
              var v25493 = this.declModule;
              var v23878 = v25493.mod;
              v20591 = v23878.symbol;
            }
            var v15424 = v20591;
            if (v15424) {
              var v25494 = checker$$9.currentModDecl;
              var v23879 = v25494.mod;
              var v20592 = v23879.symbol;
              var v25495 = this.declModule;
              var v23880 = v25495.mod;
              var v20593 = v23880.symbol;
              v15424 = aEnclosesB(v20592, v20593);
            }
            v6980 = v15424;
          }
          return v6980;
        }
      } else {
        var v6982 = this.declAST;
        if (v6982) {
          var v20594 = this.declAST;
          var v15426 = v20594.nodeType;
          var v20595 = TypeScript$$20.NodeType;
          var v15427 = v20595.FuncDecl;
          v6982 = v15426 == v15427;
        }
        var isFunction = v6982;
        var v6983 = isFunction;
        if (v6983) {
          var v15428 = this.declAST;
          v6983 = v15428.isMethod();
        }
        var isMethod$$2 = v6983;
        var v6984 = isFunction;
        if (v6984) {
          var v20596 = this.declAST;
          var v15429 = v20596.fncFlags;
          var v20597 = TypeScript$$20.FncFlags;
          var v15430 = v20597.Static;
          v6984 = TypeScript$$20.hasFlag(v15429, v15430);
        }
        var isStaticFunction = v6984;
        var v6985 = isMethod$$2;
        if (v6985) {
          var v20598 = this.declAST;
          var v15431 = v20598.fncFlags;
          var v20599 = TypeScript$$20.FncFlags;
          var v15432 = v20599.Private;
          v6985 = TypeScript$$20.hasFlag(v15431, v15432);
        }
        var isPrivateMethod = v6985;
        var v6986 = this.isType();
        if (v6986) {
          v6986 = this.aliasLink;
        }
        var isAlias = v6986;
        var v23881 = this.isMember();
        var v25496 = !v23881;
        if (v25496) {
          v23881 = isMethod$$2;
        }
        var v20600 = v23881;
        var v23882 = !v20600;
        if (v23882) {
          v20600 = isStaticFunction;
        }
        var v15433 = v20600;
        var v20601 = !v15433;
        if (v20601) {
          v15433 = isAlias;
        }
        var v6992 = v15433;
        if (v6992) {
          var v20602 = this.flags;
          var v23883 = TypeScript$$20.SymbolFlags;
          var v20603 = v23883.Private;
          var v15434 = TypeScript$$20.hasFlag(v20602, v20603);
          var v20604 = !v15434;
          if (v20604) {
            v15434 = isPrivateMethod;
          }
          var v6989 = v15434;
          if (v6989) {
            var v20605 = scope$$16.container;
            var v15435 = v20605 == null;
            if (v15435) {
              var v20606 = this.container;
              var v20607 = scope$$16.container;
              v15435 = v20606 != v20607;
            }
            var v6988 = v15435;
            if (v6988) {
              return false;
            } else {
              var v6987;
              var v20608 = this.container;
              var v15438 = v20608 == null;
              if (v15438) {
                v6987 = true;
              } else {
                var v15436 = scope$$16.container;
                var v15437 = this.container;
                v6987 = aEnclosesB(v15436, v15437);
              }
              return v6987;
            }
          } else {
            return true;
          }
        } else {
          var v6991 = this.container;
          if (v6991) {
            var v6990 = scope$$16.container;
            return aEnclosesB(this, v6990);
          } else {
            return true;
          }
        }
      }
      return;
    }
    function v731(checker$$8) {
      var v15439 = checker$$8.gloMod;
      var v6994 = this == v15439;
      if (v6994) {
        return true;
      }
      var v15440 = this.flags;
      var v20609 = TypeScript$$20.SymbolFlags;
      var v15441 = v20609.Private;
      var v6995 = TypeScript$$20.hasFlag(v15440, v15441);
      if (v6995) {
        return false;
      }
      var v20610 = this.flags;
      var v23884 = TypeScript$$20.SymbolFlags;
      var v20611 = v23884.Exported;
      var v15442 = TypeScript$$20.hasFlag(v20610, v20611);
      var v6998 = !v15442;
      if (v6998) {
        var v6996 = this.container;
        var v6997 = checker$$8.gloMod;
        return v6996 == v6997;
      }
      var v6999 = this.container;
      return v6999.isExternallyVisible(checker$$8);
    }
    function v730() {
      var builder$$4 = this.name;
      var ancestor = this.container;
      var v15443 = ancestor;
      if (v15443) {
        var v20612 = ancestor.name;
        var v20613 = TypeScript$$20.globalId;
        v15443 = v20612 != v20613;
      }
      var v7001 = v15443;
      for (;v7001;) {
        var v15444 = ancestor.name;
        var v7000 = v15444 + ".";
        builder$$4 = v7000 + builder$$4;
        ancestor = ancestor.container;
        var v15445 = ancestor;
        if (v15445) {
          var v20614 = ancestor.name;
          var v20615 = TypeScript$$20.globalId;
          v15445 = v20614 != v20615;
        }
        v7001 = v15445;
      }
      return builder$$4;
    }
    function v729(scope$$15) {
      var v7004 = scope$$15 == null;
      if (v7004) {
        var v7002 = this.getPrettyName(null);
        var v7003 = this.getOptionalNameString();
        return v7002 + v7003;
      }
      var v7005 = scope$$15.container;
      var lca = this.findCommonAncestorPath(v7005);
      var builder$$3 = "";
      var i$$63 = 0;
      var len$$24 = lca.length;
      var v7009 = i$$63 < len$$24;
      for (;v7009;) {
        var v7006 = lca[i$$63];
        var v15446;
        var v23885 = len$$24 - 1;
        var v20617 = i$$63 == v23885;
        if (v20617) {
          v15446 = scope$$15.container;
        } else {
          var v20616 = i$$63 + 1;
          v15446 = lca[v20616];
        }
        var v7007 = v15446;
        var prettyName = v7006.getPrettyName(v7007);
        var v7008 = prettyName + ".";
        builder$$3 = v7008 + builder$$3;
        i$$63 = i$$63 + 1;
        v7009 = i$$63 < len$$24;
      }
      var v15447 = builder$$3;
      var v25497;
      var v26179 = len$$24 == 0;
      if (v26179) {
        v25497 = scope$$15.container;
      } else {
        v25497 = lca[0];
      }
      var v23886 = v25497;
      var v20618 = this.getPrettyName(v23886);
      var v20619 = this.getOptionalNameString();
      var v15448 = v20618 + v20619;
      builder$$3 = v15447 + v15448;
      return builder$$3;
    }
    function v728(scopeSymbol) {
      return this.name;
    }
    function v727(b$$9) {
      var v15449 = this.container;
      var v7010 = v15449 == null;
      if (v7010) {
        return new Array;
      }
      var v7011 = this.container;
      var aPath = v7011.pathToRoot();
      var bPath;
      if (b$$9) {
        bPath = b$$9.pathToRoot();
      } else {
        bPath = new Array;
      }
      var commonNodeIndex = -1;
      var i$$62 = 0;
      var aLen = aPath.length;
      var v7015 = i$$62 < aLen;
      for (;v7015;) {
        var aNode = aPath[i$$62];
        var j$$8 = 0;
        var bLen = bPath.length;
        var v7013 = j$$8 < bLen;
        for (;v7013;) {
          var bNode = bPath[j$$8];
          var v7012 = aNode == bNode;
          if (v7012) {
            commonNodeIndex = i$$62;
            break;
          }
          j$$8 = j$$8 + 1;
          v7013 = j$$8 < bLen;
        }
        var v7014 = commonNodeIndex >= 0;
        if (v7014) {
          break;
        }
        i$$62 = i$$62 + 1;
        v7015 = i$$62 < aLen;
      }
      var v7016 = commonNodeIndex >= 0;
      if (v7016) {
        return aPath.slice(0, commonNodeIndex);
      } else {
        return aPath;
      }
      return;
    }
    function v726() {
      var path$$6 = new Array;
      var node$$2 = this;
      var v15450 = node$$2;
      if (v15450) {
        var v20620 = node$$2.name;
        var v20621 = TypeScript$$20.globalId;
        v15450 = v20620 != v20621;
      }
      var v7018 = v15450;
      for (;v7018;) {
        var v7017 = path$$6.length;
        path$$6[v7017] = node$$2;
        node$$2 = node$$2.container;
        var v15451 = node$$2;
        if (v15451) {
          var v20622 = node$$2.name;
          var v20623 = TypeScript$$20.globalId;
          v15451 = v20622 != v20623;
        }
        v7018 = v15451;
      }
      return path$$6;
    }
    function v725() {
      var v7019;
      var v20624 = this.flags;
      var v23887 = TypeScript$$20.SymbolFlags;
      var v20625 = v23887.Optional;
      var v15452 = TypeScript$$20.hasFlag(v20624, v20625);
      if (v15452) {
        v7019 = "?";
      } else {
        v7019 = "";
      }
      return v7019;
    }
    function v724(scope$$14) {
      var v7020 = TypeScript$$20.MemberName;
      var v7021 = this.toString();
      return v7020.create(v7021);
    }
    function v723(scope$$13) {
      var v7022 = this.getTypeNameEx(scope$$13);
      return v7022.toString();
    }
    function v722() {
      var v15453 = this.flags;
      var v20626 = TypeScript$$20.SymbolFlags;
      var v15454 = v20626.Property;
      var v7023 = TypeScript$$20.hasFlag(v15453, v15454);
      if (v7023) {
        var v20627 = this.flags;
        var v23888 = TypeScript$$20.SymbolFlags;
        var v20628 = v23888.ModuleMember;
        var v15455 = TypeScript$$20.hasFlag(v20627, v20628);
        v7023 = !v15455;
      }
      return v7023;
    }
    function v721() {
      return false;
    }
    function v720() {
      return null;
    }
    function v719() {
      return false;
    }
    function v718() {
      return false;
    }
    function v717() {
      return false;
    }
    function v716() {
      return false;
    }
    function v715() {
      return false;
    }
    function v714() {
      return false;
    }
    function v713() {
      return null;
    }
    function Symbol$$1(name$$52, location$$21, length$$15, unitIndex$$3) {
      this.name = name$$52;
      this.location = location$$21;
      this.length = length$$15;
      this.unitIndex = unitIndex$$3;
      this.bound = false;
      var v7024 = TypeScript$$20.SymbolFlags;
      this.flags = v7024.None;
      this.isObjectLitField = false;
      this.declAST = null;
      this.declModule = null;
      var v7025 = TypeScript$$20.CompilerDiagnostics;
      this.passSymbolCreated = v7025.analysisPass;
      return;
    }
    var v7026 = Symbol$$1.prototype;
    v7026.instanceScope = v713;
    var v7027 = Symbol$$1.prototype;
    v7027.isVariable = v714;
    var v7028 = Symbol$$1.prototype;
    v7028.isMember = v715;
    var v7029 = Symbol$$1.prototype;
    v7029.isInferenceSymbol = v716;
    var v7030 = Symbol$$1.prototype;
    v7030.isWith = v717;
    var v7031 = Symbol$$1.prototype;
    v7031.writeable = v718;
    var v7032 = Symbol$$1.prototype;
    v7032.isType = v719;
    var v7033 = Symbol$$1.prototype;
    v7033.getType = v720;
    var v7034 = Symbol$$1.prototype;
    v7034.isAccessor = v721;
    var v7035 = Symbol$$1.prototype;
    v7035.isInstanceProperty = v722;
    var v7036 = Symbol$$1.prototype;
    v7036.getTypeName = v723;
    var v7037 = Symbol$$1.prototype;
    v7037.getTypeNameEx = v724;
    var v7038 = Symbol$$1.prototype;
    v7038.getOptionalNameString = v725;
    var v7039 = Symbol$$1.prototype;
    v7039.pathToRoot = v726;
    var v7040 = Symbol$$1.prototype;
    v7040.findCommonAncestorPath = v727;
    var v7041 = Symbol$$1.prototype;
    v7041.getPrettyName = v728;
    var v7042 = Symbol$$1.prototype;
    v7042.scopeRelativeName = v729;
    var v7043 = Symbol$$1.prototype;
    v7043.fullName = v730;
    var v7044 = Symbol$$1.prototype;
    v7044.isExternallyVisible = v731;
    var v7045 = Symbol$$1.prototype;
    v7045.visible = v732;
    var v7046 = Symbol$$1.prototype;
    v7046.addRef = v733;
    var v7047 = Symbol$$1.prototype;
    v7047.toString = v734;
    var v7048 = Symbol$$1.prototype;
    v7048.print = v735;
    var v7049 = Symbol$$1.prototype;
    v7049.specializeType = v736;
    var v7050 = Symbol$$1.prototype;
    v7050.setType = v737;
    var v7051 = Symbol$$1.prototype;
    v7051.kind = v738;
    var v7052 = Symbol$$1.prototype;
    v7052.getInterfaceDeclFromSymbol = v739;
    var v7053 = Symbol$$1.prototype;
    v7053.getVarDeclFromSymbol = v740;
    var v7054 = Symbol$$1.prototype;
    v7054.getDocComments = v741;
    var v7055 = Symbol$$1.prototype;
    v7055.isStatic = v742;
    return Symbol$$1;
  }
  function v712(TypeCheckStatus$$1) {
    TypeCheckStatus$$1._map = [];
    var v7056 = TypeCheckStatus$$1._map;
    v7056[0] = "NotStarted";
    TypeCheckStatus$$1.NotStarted = 0;
    var v7057 = TypeCheckStatus$$1._map;
    v7057[1] = "Started";
    TypeCheckStatus$$1.Started = 1;
    var v7058 = TypeCheckStatus$$1._map;
    v7058[2] = "Finished";
    TypeCheckStatus$$1.Finished = 2;
    return;
  }
  function aLexicallyEnclosesB(a$$7, b$$7) {
    var v23889 = a$$7.declAST;
    if (v23889) {
      v23889 = b$$7;
    }
    var v20629 = v23889;
    if (v20629) {
      v20629 = b$$7.declAST;
    }
    var v15456 = v20629;
    if (v15456) {
      var v23890 = a$$7.declAST;
      var v20630 = v23890.nodeType;
      var v23891 = TypeScript$$20.NodeType;
      var v20631 = v23891.FuncDecl;
      v15456 = v20630 == v20631;
    }
    var v7060 = v15456;
    if (v7060) {
      var v20632 = a$$7.declAST;
      var v15457 = v20632.minChar;
      var v20633 = b$$7.declAST;
      var v15458 = v20633.minChar;
      var v7059 = v15457 <= v15458;
      if (v7059) {
        var v20634 = a$$7.declAST;
        var v15459 = v20634.limChar;
        var v20635 = b$$7.declAST;
        var v15460 = v20635.limChar;
        v7059 = v15459 >= v15460;
      }
      return v7059;
    } else {
      return false;
    }
    return;
  }
  function aEnclosesB(a$$8, b$$8) {
    var v7062 = a$$8.container;
    for (;v7062;) {
      var v15461 = a$$8 == b$$8;
      var v20637 = !v15461;
      if (v20637) {
        var v20636 = a$$8.container;
        v15461 = aLexicallyEnclosesB(v20636, b$$8);
      }
      var v7061 = v15461;
      if (v7061) {
        return true;
      }
      a$$8 = a$$8.container;
      v7062 = a$$8.container;
    }
    return false;
  }
  var v15462 = TypeScript$$20.TypeCheckStatus;
  var v20638 = !v15462;
  if (v20638) {
    v15462 = TypeScript$$20.TypeCheckStatus = {};
  }
  var v7063 = v15462;
  v712(v7063);
  var TypeCheckStatus = TypeScript$$20.TypeCheckStatus;
  TypeScript$$20.aLexicallyEnclosesB = aLexicallyEnclosesB;
  TypeScript$$20.aEnclosesB = aEnclosesB;
  var Symbol = v743();
  TypeScript$$20.Symbol = Symbol;
  var ValueLocation = v744();
  TypeScript$$20.ValueLocation = ValueLocation;
  var InferenceSymbol = v747(Symbol);
  TypeScript$$20.InferenceSymbol = InferenceSymbol;
  var TypeSymbol = v761(InferenceSymbol);
  TypeScript$$20.TypeSymbol = TypeSymbol;
  var WithSymbol = v763(TypeSymbol);
  TypeScript$$20.WithSymbol = WithSymbol;
  var FieldSymbol = v775(InferenceSymbol);
  TypeScript$$20.FieldSymbol = FieldSymbol;
  var ParameterSymbol = v786(InferenceSymbol);
  TypeScript$$20.ParameterSymbol = ParameterSymbol;
  var VariableSymbol = v793(InferenceSymbol);
  TypeScript$$20.VariableSymbol = VariableSymbol;
  return;
}
function v711(TypeScript$$19) {
  function v710() {
    function v709(checker$$7, ast$$59, hasConstruct) {
      var v7064 = this.hasBeenTypechecked;
      if (v7064) {
        return;
      }
      this.hasBeenTypechecked = true;
      var len$$23 = 0;
      var v15463 = this.signatures;
      if (v15463) {
        var v23892 = this.signatures;
        var v20639 = len$$23 = v23892.length;
        v15463 = v20639 > 0;
      }
      var v7074 = v15463;
      if (v7074) {
        var i$$61 = 0;
        var v7073 = i$$61 < len$$23;
        for (;v7073;) {
          var v25498 = !hasConstruct;
          if (v25498) {
            var v26180 = this.definitionSignature;
            v25498 = !v26180;
          }
          var v23893 = v25498;
          if (v23893) {
            var v26181 = this.signatures;
            var v25499 = v26181[i$$61];
            v23893 = v25499.declAST;
          }
          var v20640 = v23893;
          if (v20640) {
            var v26182 = this.signatures;
            var v25500 = v26182[i$$61];
            var v23894 = v25500.declAST;
            v20640 = v23894.isOverload;
          }
          var v15464 = v20640;
          if (v15464) {
            var v26478 = this.signatures;
            var v26183 = v26478[i$$61];
            var v25501 = v26183.declAST;
            var v23895 = v25501.fncFlags;
            var v25502 = TypeScript$$19.FncFlags;
            var v23896 = v25502.Ambient;
            var v20641 = TypeScript$$19.hasFlag(v23895, v23896);
            v15464 = !v20641;
          }
          var v7067 = v15464;
          if (v7067) {
            var v7065 = checker$$7.errorReporter;
            var v20642 = this.signatures;
            var v15465 = v20642[i$$61];
            var v7066 = v15465.declAST;
            v7065.simpleError(v7066, "Overload declaration lacks definition");
          }
          var v26184 = this.signatures;
          var v25503 = v26184[i$$61];
          var v23897 = v25503.declAST;
          if (v23897) {
            var v26479 = this.signatures;
            var v26185 = v26479[i$$61];
            var v25504 = v26185.declAST;
            v23897 = v25504.isConstructor;
          }
          var v20643 = v23897;
          if (v20643) {
            var v26186 = this.signatures;
            var v25505 = v26186[i$$61];
            var v23898 = v25505.declAST;
            v20643 = v23898.classDecl;
          }
          var v15466 = v20643;
          if (v15466) {
            var v26695 = this.signatures;
            var v26623 = v26695[i$$61];
            var v26480 = v26623.declAST;
            var v26187 = v26480.classDecl;
            var v25506 = v26187.type;
            var v23899 = v25506.symbol;
            var v20644 = v23899.typeCheckStatus;
            var v23900 = TypeScript$$19.TypeCheckStatus;
            var v20645 = v23900.NotStarted;
            v15466 = v20644 == v20645;
          }
          var v7070 = v15466;
          if (v7070) {
            var v7068 = checker$$7.typeFlow;
            var v23901 = this.signatures;
            var v20646 = v23901[i$$61];
            var v15467 = v20646.declAST;
            var v7069 = v15467.classDecl;
            v7068.typeCheck(v7069);
          }
          var v7071 = checker$$7.typeFlow;
          var v20647 = this.signatures;
          var v15468 = v20647[i$$61];
          var v7072 = v15468.declAST;
          v7071.typeCheck(v7072);
          i$$61 = i$$61 + 1;
          v7073 = i$$61 < len$$23;
        }
        this.verifySignatures(checker$$7);
      }
      return;
    }
    function v708(checker$$6) {
      var len$$22 = 0;
      var v15469 = this.signatures;
      if (v15469) {
        var v23902 = this.signatures;
        var v20648 = len$$22 = v23902.length;
        v15469 = v20648 > 0;
      }
      var v7085 = v15469;
      if (v7085) {
        var i$$60 = 0;
        var v7084 = i$$60 < len$$22;
        for (;v7084;) {
          var j$$7 = i$$60 + 1;
          var v7079 = j$$7 < len$$22;
          for (;v7079;) {
            var v26188 = this.signatures;
            var v25507 = v26188[i$$60];
            var v23903 = v25507.declAST;
            if (v23903) {
              var v26189 = this.signatures;
              var v25508 = v26189[j$$7];
              v23903 = v25508.declAST;
            }
            var v20649 = v23903;
            if (v20649) {
              var v26696 = this.signatures;
              var v26624 = v26696[i$$60];
              var v26481 = v26624.declAST;
              var v26190 = v26481.fncFlags;
              var v26482 = TypeScript$$19.FncFlags;
              var v26191 = v26482.Definition;
              var v25509 = TypeScript$$19.hasFlag(v26190, v26191);
              var v23904 = !v25509;
              if (v23904) {
                var v26697 = this.signatures;
                var v26625 = v26697[j$$7];
                var v26483 = v26625.declAST;
                var v26192 = v26483.fncFlags;
                var v26484 = TypeScript$$19.FncFlags;
                var v26193 = v26484.Definition;
                var v25510 = TypeScript$$19.hasFlag(v26192, v26193);
                v23904 = !v25510;
              }
              v20649 = v23904;
            }
            var v15470 = v20649;
            if (v15470) {
              var v23905 = this.signatures;
              var v20650 = v23905[i$$60];
              var v23906 = this.signatures;
              var v20651 = v23906[j$$7];
              v15470 = checker$$6.signaturesAreIdentical(v20650, v20651);
            }
            var v7078 = v15470;
            if (v7078) {
              var v7075 = checker$$6.errorReporter;
              var v20652 = this.signatures;
              var v15471 = v20652[i$$60];
              var v7076 = v15471.declAST;
              var v15472;
              var v26194 = this.signatures;
              var v25511 = v26194[i$$60];
              var v23907 = v25511.declAST;
              if (v23907) {
                var v26485 = this.signatures;
                var v26195 = v26485[i$$60];
                var v25512 = v26195.declAST;
                v23907 = v25512.name;
              }
              var v20654 = v23907;
              if (v20654) {
                var v26626 = this.signatures;
                var v26486 = v26626[i$$60];
                var v26196 = v26486.declAST;
                var v25513 = v26196.name;
                var v23908 = v25513.actualText;
                var v20653 = "Signature for '" + v23908;
                v15472 = v20653 + "' is duplicated";
              } else {
                v15472 = "Signature is duplicated";
              }
              var v7077 = v15472;
              v7075.simpleError(v7076, v7077);
            }
            j$$7 = j$$7 + 1;
            v7079 = j$$7 < len$$22;
          }
          var v7083 = this.definitionSignature;
          if (v7083) {
            var v20655 = this.definitionSignature;
            var v23909 = this.signatures;
            var v20656 = v23909[i$$60];
            var v15473 = checker$$6.signatureIsAssignableToTarget(v20655, v20656);
            var v7082 = !v15473;
            if (v7082) {
              var v7080 = checker$$6.errorReporter;
              var v20657 = this.signatures;
              var v15474 = v20657[i$$60];
              var v7081 = v15474.declAST;
              v7080.simpleError(v7081, "Overload signature is not compatible with function definition");
            }
          }
          i$$60 = i$$60 + 1;
          v7084 = i$$60 < len$$22;
        }
      }
      return;
    }
    function v707(pattern$$3, replacement$$1, checker$$5) {
      var result$$13 = new SignatureGroup$$1;
      var v7089 = this.signatures;
      if (v7089) {
        var i$$59 = 0;
        var v7086 = this.signatures;
        var len$$21 = v7086.length;
        var v7088 = i$$59 < len$$21;
        for (;v7088;) {
          var v20658 = this.signatures;
          var v15475 = v20658[i$$59];
          var v7087 = v15475.specializeType(pattern$$3, replacement$$1, checker$$5);
          result$$13.addSignature(v7087);
          i$$59 = i$$59 + 1;
          v7088 = i$$59 < len$$21;
        }
      }
      return result$$13;
    }
    function v706(prefix$$3, shortform$$2, scope$$12) {
      var result$$12 = [];
      var v7090 = this.signatures;
      var len$$20 = v7090.length;
      var v7091 = len$$20 > 1;
      if (v7091) {
        shortform$$2 = false;
      }
      var i$$58 = 0;
      var v7096 = i$$58 < len$$20;
      for (;v7096;) {
        var v15476 = len$$20 > 1;
        if (v15476) {
          var v23910 = this.signatures;
          var v20659 = v23910[i$$58];
          var v20660 = this.definitionSignature;
          v15476 = v20659 == v20660;
        }
        var v7092 = v15476;
        if (v7092) {
          i$$58 = i$$58 + 1;
          v7096 = i$$58 < len$$20;
          continue;
        }
        var v15477 = this.flags;
        var v20661 = TypeScript$$19.SignatureFlags;
        var v15478 = v20661.IsIndexer;
        var v7095 = v15477 & v15478;
        if (v7095) {
          var v20662 = this.signatures;
          var v15479 = v20662[i$$58];
          var v7093 = v15479.toStringHelperEx(shortform$$2, true, scope$$12);
          result$$12.push(v7093);
        } else {
          var v20663 = this.signatures;
          var v15480 = v20663[i$$58];
          var v7094 = v15480.toStringHelperEx(shortform$$2, false, scope$$12, prefix$$3);
          result$$12.push(v7094);
        }
        i$$58 = i$$58 + 1;
        v7096 = i$$58 < len$$20;
      }
      return result$$12;
    }
    function v705() {
      var v7097 = this.signatures;
      return v7097.toString();
    }
    function v704(signature$$2) {
      var v15481 = this.signatures;
      var v7098 = v15481 == null;
      if (v7098) {
        var v27004 = new Array;
        this.signatures = v27004;
      }
      var v7099 = this.signatures;
      var v15482 = this.signatures;
      var v7100 = v15482.length;
      v7099[v7100] = signature$$2;
      var v25514 = signature$$2.declAST;
      if (v25514) {
        var v26487 = signature$$2.declAST;
        var v26197 = v26487.isOverload;
        v25514 = !v26197;
      }
      var v23911 = v25514;
      if (v23911) {
        var v26198 = signature$$2.declAST;
        var v25515 = v26198.isSignature();
        v23911 = !v25515;
      }
      var v20664 = v23911;
      if (v20664) {
        var v26199 = signature$$2.declAST;
        var v25516 = v26199.fncFlags;
        var v26200 = TypeScript$$19.FncFlags;
        var v25517 = v26200.Ambient;
        var v23912 = TypeScript$$19.hasFlag(v25516, v25517);
        v20664 = !v23912;
      }
      var v15483 = v20664;
      if (v15483) {
        var v23913 = signature$$2.declAST;
        var v20665 = v23913.fncFlags;
        var v23914 = TypeScript$$19.FncFlags;
        var v20666 = v23914.Definition;
        v15483 = TypeScript$$19.hasFlag(v20665, v20666);
      }
      var v7101 = v15483;
      if (v7101) {
        this.definitionSignature = signature$$2;
      }
      return;
    }
    function SignatureGroup$$1() {
      this.signatures = [];
      this.hasImplementation = true;
      this.definitionSignature = null;
      this.hasBeenTypechecked = false;
      var v7102 = TypeScript$$19.SignatureFlags;
      this.flags = v7102.None;
      return;
    }
    var v7103 = SignatureGroup$$1.prototype;
    v7103.addSignature = v704;
    var v7104 = SignatureGroup$$1.prototype;
    v7104.toString = v705;
    var v7105 = SignatureGroup$$1.prototype;
    v7105.toStrings = v706;
    var v7106 = SignatureGroup$$1.prototype;
    v7106.specializeType = v707;
    var v7107 = SignatureGroup$$1.prototype;
    v7107.verifySignatures = v708;
    var v7108 = SignatureGroup$$1.prototype;
    v7108.typeCheck = v709;
    return SignatureGroup$$1;
  }
  function v703() {
    function v702(shortform$$1, brackets$$1, scope$$11, prefix$$2) {
      var v15484 = typeof prefix$$2;
      var v7109 = v15484 === "undefined";
      if (v7109) {
        prefix$$2 = "";
      }
      var v7110 = TypeScript$$19.MemberNameArray;
      var builder$$2 = new v7110;
      if (brackets$$1) {
        builder$$2.prefix = prefix$$2 + "[";
      } else {
        builder$$2.prefix = prefix$$2 + "(";
      }
      var v7111 = this.parameters;
      var paramLen$$1 = v7111.length;
      var v7112;
      var v15485 = this.hasVariableArgList;
      if (v15485) {
        v7112 = paramLen$$1 - 1;
      } else {
        v7112 = paramLen$$1;
      }
      var len$$19 = v7112;
      var i$$57 = 0;
      var v7117 = i$$57 < len$$19;
      for (;v7117;) {
        var v15486 = TypeScript$$19.MemberName;
        var v26201 = this.parameters;
        var v25518 = v26201[i$$57];
        var v23915 = v25518.name;
        var v25519;
        var v26627 = this.parameters;
        var v26488 = v26627[i$$57];
        var v26202 = v26488.isOptional();
        if (v26202) {
          v25519 = "?";
        } else {
          v25519 = "";
        }
        var v23916 = v25519;
        var v20667 = v23915 + v23916;
        var v15487 = v20667 + ": ";
        var v7113 = v15486.create(v15487);
        builder$$2.add(v7113);
        var v23917 = this.parameters;
        var v20668 = v23917[i$$57];
        var v15488 = v20668.getType();
        var v7114 = v15488.getScopedTypeNameEx(scope$$11);
        builder$$2.add(v7114);
        var v15489 = paramLen$$1 - 1;
        var v7116 = i$$57 < v15489;
        if (v7116) {
          var v15490 = TypeScript$$19.MemberName;
          var v7115 = v15490.create(", ");
          builder$$2.add(v7115);
        }
        i$$57 = i$$57 + 1;
        v7117 = i$$57 < len$$19;
      }
      var v7120 = this.hasVariableArgList;
      if (v7120) {
        var v15491 = TypeScript$$19.MemberName;
        var v26203 = this.parameters;
        var v25520 = v26203[i$$57];
        var v23918 = v25520.name;
        var v20669 = "..." + v23918;
        var v15492 = v20669 + ": ";
        var v7118 = v15491.create(v15492);
        builder$$2.add(v7118);
        var v23919 = this.parameters;
        var v20670 = v23919[i$$57];
        var v15493 = v20670.getType();
        var v7119 = v15493.getScopedTypeNameEx(scope$$11);
        builder$$2.add(v7119);
      }
      if (shortform$$1) {
        if (brackets$$1) {
          var v15494 = TypeScript$$19.MemberName;
          var v7121 = v15494.create("] => ");
          builder$$2.add(v7121);
        } else {
          var v15495 = TypeScript$$19.MemberName;
          var v7122 = v15495.create(") => ");
          builder$$2.add(v7122);
        }
      } else {
        if (brackets$$1) {
          var v15496 = TypeScript$$19.MemberName;
          var v7123 = v15496.create("]: ");
          builder$$2.add(v7123);
        } else {
          var v15497 = TypeScript$$19.MemberName;
          var v7124 = v15497.create("): ");
          builder$$2.add(v7124);
        }
      }
      var v15498 = this.returnType;
      var v7127 = v15498.type;
      if (v7127) {
        var v20671 = this.returnType;
        var v15499 = v20671.type;
        var v7125 = v15499.getScopedTypeNameEx(scope$$11);
        builder$$2.add(v7125);
      } else {
        var v15500 = TypeScript$$19.MemberName;
        var v7126 = v15500.create("any");
        builder$$2.add(v7126);
      }
      return builder$$2;
    }
    function v701(shortform, brackets, scope$$10) {
      var v7128 = this.toStringHelperEx(shortform, brackets, scope$$10);
      return v7128.toString();
    }
    function v700() {
      return this.toStringHelper(false, false, null);
    }
    function v699(pattern$$2, replacement, checker$$4) {
      var result$$11 = new Signature$$1;
      var v7129 = this.hasVariableArgList;
      if (v7129) {
        result$$11.hasVariableArgList = true;
      }
      var v7130 = result$$11;
      var v15501 = TypeScript$$19.TypeLink;
      var v27005 = new v15501;
      v7130.returnType = v27005;
      var v15502 = this.returnType;
      var v7133 = v15502.type;
      if (v7133) {
        var v7131 = result$$11.returnType;
        var v20672 = this.returnType;
        var v15503 = v20672.type;
        var v27006 = v15503.specializeType(pattern$$2, replacement, checker$$4, false);
        v7131.type = v27006;
      } else {
        var v7132 = result$$11.returnType;
        v7132.type = checker$$4.anyType;
      }
      var v7147 = this.parameters;
      if (v7147) {
        result$$11.parameters = [];
        var i$$56 = 0;
        var v7134 = this.parameters;
        var len$$18 = v7134.length;
        var v7146 = i$$56 < len$$18;
        for (;v7146;) {
          var v7135 = this.parameters;
          var oldSym = v7135[i$$56];
          var v7136 = TypeScript$$19.ValueLocation;
          var paramDef = new v7136;
          var v7137 = TypeScript$$19.ParameterSymbol;
          var v7138 = oldSym.name;
          var v7139 = oldSym.location;
          var v15504 = checker$$4.locationInfo;
          var v7140 = v15504.unitIndex;
          var paramSym$$1 = new v7137(v7138, v7139, v7140, paramDef);
          paramSym$$1.declAST = this.declAST;
          paramDef.symbol = paramSym$$1;
          var v7141 = paramDef;
          var v15505 = TypeScript$$19.TypeLink;
          var v27007 = new v15505;
          v7141.typeLink = v27007;
          var v7142 = result$$11.parameters;
          v7142[i$$56] = paramSym$$1;
          var oldType = oldSym.getType();
          if (oldType) {
            var v7143 = paramDef.typeLink;
            var v27008 = oldType.specializeType(pattern$$2, replacement, checker$$4, false);
            v7143.type = v27008;
            var v7144 = paramSym$$1.declAST;
            var v15506 = paramDef.typeLink;
            v7144.type = v15506.type;
          } else {
            var v7145 = paramDef.typeLink;
            v7145.type = checker$$4.anyType;
          }
          i$$56 = i$$56 + 1;
          v7146 = i$$56 < len$$18;
        }
      }
      result$$11.nonOptionalParameterCount = this.nonOptionalParameterCount;
      result$$11.declAST = this.declAST;
      return result$$11;
    }
    function Signature$$1() {
      this.hasVariableArgList = false;
      this.parameters = null;
      this.declAST = null;
      var v7148 = TypeScript$$19.TypeCheckStatus;
      this.typeCheckStatus = v7148.NotStarted;
      this.nonOptionalParameterCount = 0;
      return;
    }
    var v7149 = Signature$$1.prototype;
    v7149.specializeType = v699;
    var v7150 = Signature$$1.prototype;
    v7150.toString = v700;
    var v7151 = Signature$$1.prototype;
    v7151.toStringHelper = v701;
    var v7152 = Signature$$1.prototype;
    v7152.toStringHelperEx = v702;
    return Signature$$1;
  }
  var Signature = v703();
  TypeScript$$19.Signature = Signature;
  var SignatureGroup = v710();
  TypeScript$$19.SignatureGroup = SignatureGroup;
  return;
}
function v698(TypeScript$$18) {
  function v697() {
    function v696() {
      var v15507 = this.scriptFragment;
      var v7155 = v15507 == null;
      if (v7155) {
        var ast$$58 = this.scopeStartAST;
        var minChar$$31 = ast$$58.minChar;
        var v7153;
        var v15509 = this.isMemberCompletion;
        if (v15509) {
          v7153 = this.pos;
        } else {
          var v15508 = this.pos;
          v7153 = v15508 + 1;
        }
        var limChar$$10 = v7153;
        var v15510 = this.logger;
        var v15511 = this.text;
        var v7154 = TypeScript$$18.quickParse(v15510, ast$$58, v15511, minChar$$31, limChar$$10, null);
        this.scriptFragment = v7154.Script;
      }
      return this.scriptFragment;
    }
    function v695() {
      var v7156 = this.scopeStartAST;
      return v7156.minChar;
    }
    function v694() {
      return this.scopeStartAST;
    }
    function v693() {
      var v7157 = this.scopeStartAST;
      return v7157.minChar;
    }
    function v692() {
      return this.scopeStartAST;
    }
    function v691() {
      return this.objectLiteralScopeGetter();
    }
    function v690() {
      return this.scopeGetter();
    }
    function EnclosingScopeContext$$1(logger$$3, script$$13, text$$20, pos$$5, isMemberCompletion$$1) {
      this.logger = logger$$3;
      this.script = script$$13;
      this.text = text$$20;
      this.pos = pos$$5;
      this.isMemberCompletion = isMemberCompletion$$1;
      this.scopeGetter = null;
      this.objectLiteralScopeGetter = null;
      this.scopeStartAST = null;
      this.skipNextFuncDeclForClass = false;
      this.deepestModuleDecl = null;
      this.enclosingClassDecl = null;
      this.enclosingObjectLit = null;
      this.publicsOnly = true;
      this.useFullAst = false;
      return;
    }
    var v7158 = EnclosingScopeContext$$1.prototype;
    v7158.getScope = v690;
    var v7159 = EnclosingScopeContext$$1.prototype;
    v7159.getObjectLiteralScope = v691;
    var v7160 = EnclosingScopeContext$$1.prototype;
    v7160.getScopeAST = v692;
    var v7161 = EnclosingScopeContext$$1.prototype;
    v7161.getScopePosition = v693;
    var v7162 = EnclosingScopeContext$$1.prototype;
    v7162.getScriptFragmentStartAST = v694;
    var v7163 = EnclosingScopeContext$$1.prototype;
    v7163.getScriptFragmentPosition = v695;
    var v7164 = EnclosingScopeContext$$1.prototype;
    v7164.getScriptFragment = v696;
    return EnclosingScopeContext$$1;
  }
  function v689() {
    function MemberScopeContext$$1(flow, pos$$4, matchFlag) {
      this.flow = flow;
      this.pos = pos$$4;
      this.matchFlag = matchFlag;
      this.type = null;
      this.ast = null;
      var v7165 = TypeScript$$18.AstWalkOptions;
      var v27009 = new v7165;
      this.options = v27009;
      return;
    }
    return MemberScopeContext$$1;
  }
  function v688() {
    function TypeCollectionContext$$1(scopeChain$$1, checker$$3) {
      this.scopeChain = scopeChain$$1;
      this.checker = checker$$3;
      this.script = null;
      return;
    }
    return TypeCollectionContext$$1;
  }
  function preFindMemberScope(ast$$56, parent$$47, walker$$44) {
    var memScope = walker$$44.state;
    var v20673 = ast$$56.flags;
    var v20674 = memScope.matchFlag;
    var v15512 = TypeScript$$18.hasFlag(v20673, v20674);
    if (v15512) {
      var v23920 = memScope.pos;
      var v20675 = v23920 < 0;
      var v23923 = !v20675;
      if (v23923) {
        var v23921 = memScope.pos;
        var v23922 = ast$$56.limChar;
        v20675 = v23921 == v23922;
      }
      v15512 = v20675;
    }
    var v7170 = v15512;
    if (v7170) {
      memScope.ast = ast$$56;
      var v20676 = ast$$56.type;
      var v15513 = v20676 == null;
      if (v15513) {
        var v20677 = memScope.pos;
        v15513 = v20677 >= 0;
      }
      var v7168 = v15513;
      if (v7168) {
        var v7166 = memScope.flow;
        var v7167 = memScope.scope;
        v7166.inScopeTypeCheck(ast$$56, v7167);
      }
      memScope.type = ast$$56.type;
      var v7169 = memScope.options;
      v7169.stopWalk();
    }
    return ast$$56;
  }
  function pushTypeCollectionScope(container$$2, valueMembers, ambientValueMembers, enclosedTypes, ambientEnclosedTypes, context$$37, thisType$$1, classType$$2, moduleDecl$$5) {
    var v7171 = TypeScript$$18.SymbolScopeBuilder;
    var builder$$1 = new v7171(valueMembers, ambientValueMembers, enclosedTypes, ambientEnclosedTypes, null, container$$2);
    var v7172 = TypeScript$$18.ScopeChain;
    var v7173 = context$$37.scopeChain;
    var chain$$1 = new v7172(container$$2, v7173, builder$$1);
    chain$$1.thisType = thisType$$1;
    chain$$1.classType = classType$$2;
    chain$$1.moduleDecl = moduleDecl$$5;
    context$$37.scopeChain = chain$$1;
    return;
  }
  function popTypeCollectionScope(context$$38) {
    var v7174 = context$$38.scopeChain;
    context$$38.scopeChain = v7174.previous;
    return;
  }
  function preFindEnclosingScope(ast$$57, parent$$48, walker$$45) {
    function v687() {
      var v15514 = funcDecl$$15.isConstructor;
      if (v15514) {
        var v20678 = funcDecl$$15.fncFlags;
        var v23924 = TypeScript$$18.FncFlags;
        var v20679 = v23924.ClassMethod;
        v15514 = TypeScript$$18.hasFlag(v20678, v20679);
      }
      var v7177 = v15514;
      if (v7177) {
        var v15515 = ast$$57.type;
        if (v15515) {
          var v20680 = ast$$57.type;
          v15515 = v20680.enclosingType;
        }
        var v7176 = v15515;
        if (v7176) {
          var v15516 = ast$$57.type;
          var v7175 = v15516.enclosingType;
          return v7175.constructorScope;
        }
      }
      var v7179 = funcDecl$$15.scopeType;
      if (v7179) {
        var v7178 = funcDecl$$15.scopeType;
        return v7178.containedScope;
      }
      var v7181 = funcDecl$$15.type;
      if (v7181) {
        var v7180 = funcDecl$$15.type;
        return v7180.containedScope;
      }
      return null;
    }
    function v686() {
      var v7182;
      var v20681 = ast$$57.type;
      var v15518 = v20681 === null;
      if (v15518) {
        v7182 = null;
      } else {
        var v15517 = ast$$57.type;
        v7182 = v15517.containedScope;
      }
      return v7182;
    }
    function v685() {
      var v7183;
      var v20682 = ast$$57.type;
      var v15520 = v20682 === null;
      if (v15520) {
        v7183 = null;
      } else {
        var v15519 = ast$$57.type;
        v7183 = v15519.containedScope;
      }
      return v7183;
    }
    function v684() {
      var v7184 = objectLit.targetType;
      return v7184.memberScope;
    }
    function v683() {
      var v7185 = objectLit.targetType;
      return v7185.containedScope;
    }
    function v682() {
      var v7186;
      var v23925 = ast$$57.type;
      var v20683 = v23925 === null;
      var v23927 = !v20683;
      if (v23927) {
        var v26204 = ast$$57.type;
        var v25521 = v26204.instanceType;
        var v23926 = v25521.containedScope;
        v20683 = v23926 === null;
      }
      var v15522 = v20683;
      if (v15522) {
        v7186 = null;
      } else {
        var v20684 = ast$$57.type;
        var v15521 = v20684.instanceType;
        v7186 = v15521.containedScope;
      }
      return v7186;
    }
    function v681() {
      var v7187;
      var v20685 = script$$11.bod;
      var v15524 = v20685 === null;
      if (v15524) {
        v7187 = null;
      } else {
        var v15523 = script$$11.bod;
        v7187 = v15523.enclosingScope;
      }
      return v7187;
    }
    var context$$39 = walker$$45.state;
    var minChar$$30 = ast$$57.minChar;
    var limChar$$9 = ast$$57.limChar;
    var v20686 = ast$$57.nodeType;
    var v23928 = TypeScript$$18.NodeType;
    var v20687 = v23928.Script;
    var v15525 = v20686 == v20687;
    if (v15525) {
      var v20688 = context$$39.pos;
      v15525 = v20688 > limChar$$9;
    }
    var v7188 = v15525;
    if (v7188) {
      limChar$$9 = context$$39.pos;
    }
    var v20689 = context$$39.pos;
    var v15526 = minChar$$30 <= v20689;
    if (v15526) {
      var v20690 = context$$39.pos;
      v15526 = limChar$$9 >= v20690;
    }
    var v7194 = v15526;
    if (v7194) {
      var v7191 = ast$$57.nodeType;
      switch(v7191) {
        case TypeScript$$18.NodeType.Script:
          var script$$11 = ast$$57;
          context$$39.scopeGetter = v681;
          context$$39.scopeStartAST = script$$11;
          break;
        case TypeScript$$18.NodeType.ClassDeclaration:
          context$$39.scopeGetter = v682;
          context$$39.scopeStartAST = ast$$57;
          context$$39.enclosingClassDecl = ast$$57;
          break;
        case TypeScript$$18.NodeType.ObjectLit:
          var objectLit = ast$$57;
          var v7189 = objectLit.targetType;
          if (v7189) {
            context$$39.scopeGetter = v683;
            context$$39.objectLiteralScopeGetter = v684;
            context$$39.enclosingObjectLit = objectLit;
          }
          break;
        case TypeScript$$18.NodeType.ModuleDeclaration:
          context$$39.deepestModuleDecl = ast$$57;
          context$$39.scopeGetter = v685;
          context$$39.scopeStartAST = ast$$57;
          break;
        case TypeScript$$18.NodeType.InterfaceDeclaration:
          context$$39.scopeGetter = v686;
          context$$39.scopeStartAST = ast$$57;
          break;
        case TypeScript$$18.NodeType.FuncDecl:
          var funcDecl$$15 = ast$$57;
          var v7190 = context$$39.skipNextFuncDeclForClass;
          if (v7190) {
            context$$39.skipNextFuncDeclForClass = false;
          } else {
            context$$39.scopeGetter = v687;
            context$$39.scopeStartAST = ast$$57;
          }
        ;
      }
      var v7192 = walker$$45.options;
      v7192.goChildren = true;
    } else {
      var v7193 = walker$$45.options;
      v7193.goChildren = false;
    }
    return ast$$57;
  }
  function findEnclosingScopeAt(logger$$2, script$$12, text$$19, pos$$3, isMemberCompletion) {
    var context$$40 = new EnclosingScopeContext(logger$$2, script$$12, text$$19, pos$$3, isMemberCompletion);
    var v7195 = TypeScript$$18.getAstWalkerFactory();
    v7195.walk(script$$12, preFindEnclosingScope, null, null, context$$40);
    var v15527 = context$$40.scopeStartAST;
    var v7196 = v15527 === null;
    if (v7196) {
      return null;
    }
    return context$$40;
  }
  var TypeCollectionContext = v688();
  TypeScript$$18.TypeCollectionContext = TypeCollectionContext;
  var MemberScopeContext = v689();
  TypeScript$$18.MemberScopeContext = MemberScopeContext;
  var EnclosingScopeContext = v697();
  TypeScript$$18.EnclosingScopeContext = EnclosingScopeContext;
  TypeScript$$18.preFindMemberScope = preFindMemberScope;
  TypeScript$$18.pushTypeCollectionScope = pushTypeCollectionScope;
  TypeScript$$18.popTypeCollectionScope = popTypeCollectionScope;
  TypeScript$$18.preFindEnclosingScope = preFindEnclosingScope;
  TypeScript$$18.findEnclosingScopeAt = findEnclosingScopeAt;
  return;
}
function v680(TypeScript$$17) {
  function v679() {
    function v678(b$$6) {
      var v7197 = this.result;
      var v27010 = this.select(v7197, b$$6);
      this.result = v27010;
      var v7199 = this.result;
      if (v7199) {
        var v7198 = this.result;
        return this.stop(v7198);
      } else {
        return false;
      }
      return;
    }
    function v677() {
      this.result = null;
      return;
    }
    function ScopeSearchFilter$$1(select, stop$$1) {
      this.select = select;
      this.stop = stop$$1;
      this.result = null;
      return;
    }
    var v7200 = ScopeSearchFilter$$1.prototype;
    v7200.reset = v677;
    var v7201 = ScopeSearchFilter$$1.prototype;
    v7201.update = v678;
    return ScopeSearchFilter$$1;
  }
  function v676() {
    function AssignScopeContext$$1(scopeChain, typeFlow$$36, modDeclChain) {
      this.scopeChain = scopeChain;
      this.typeFlow = typeFlow$$36;
      this.modDeclChain = modDeclChain;
      return;
    }
    return AssignScopeContext$$1;
  }
  function pushAssignScope(scope$$9, context$$27, type$$31, classType, fnc) {
    var v7202 = TypeScript$$17.ScopeChain;
    var v7203 = context$$27.scopeChain;
    var chain = new v7202(null, v7203, scope$$9);
    chain.thisType = type$$31;
    chain.classType = classType;
    chain.fnc = fnc;
    context$$27.scopeChain = chain;
    return;
  }
  function popAssignScope(context$$28) {
    var v7204 = context$$28.scopeChain;
    context$$28.scopeChain = v7204.previous;
    return;
  }
  function instanceCompare(a$$6, b$$5) {
    var v15528 = a$$6 == null;
    var v20692 = !v15528;
    if (v20692) {
      var v20691 = a$$6.isInstanceProperty();
      v15528 = !v20691;
    }
    var v7205 = v15528;
    if (v7205) {
      return b$$5;
    } else {
      return a$$6;
    }
    return;
  }
  function instanceFilterStop(s$$17) {
    return s$$17.isInstanceProperty();
  }
  function preAssignModuleScopes(ast$$48, context$$29) {
    var moduleDecl$$4 = ast$$48;
    var memberScope$$1 = null;
    var aggScope = null;
    var v15529 = moduleDecl$$4.name;
    if (v15529) {
      v15529 = moduleDecl$$4.mod;
    }
    var v7207 = v15529;
    if (v7207) {
      var v7206 = moduleDecl$$4.name;
      var v15530 = moduleDecl$$4.mod;
      v7206.sym = v15530.symbol;
    }
    var mod$$1 = moduleDecl$$4.mod;
    var v7208 = !mod$$1;
    if (v7208) {
      return;
    }
    var v7209 = TypeScript$$17.SymbolTableScope;
    var v7210 = mod$$1.members;
    var v7211 = mod$$1.ambientMembers;
    var v7212 = mod$$1.enclosedTypes;
    var v7213 = mod$$1.ambientEnclosedTypes;
    var v7214 = mod$$1.symbol;
    memberScope$$1 = new v7209(v7210, v7211, v7212, v7213, v7214);
    mod$$1.memberScope = memberScope$$1;
    var v7215 = context$$29.modDeclChain;
    v7215.push(moduleDecl$$4);
    var v15531 = context$$29.typeFlow;
    var v7216 = v15531.checker;
    v7216.currentModDecl = moduleDecl$$4;
    var v7217 = TypeScript$$17.SymbolAggregateScope;
    var v7218 = mod$$1.symbol;
    aggScope = new v7217(v7218);
    aggScope.addParentScope(memberScope$$1);
    var v15532 = context$$29.scopeChain;
    var v7219 = v15532.scope;
    aggScope.addParentScope(v7219);
    pushAssignScope(aggScope, context$$29, null, null, null);
    mod$$1.containedScope = aggScope;
    var v7225 = mod$$1.symbol;
    if (v7225) {
      var v7220 = context$$29.typeFlow;
      var v7221 = mod$$1.containedScope;
      var v7222 = mod$$1.symbol;
      var v7223 = moduleDecl$$4.vars;
      var v15533 = mod$$1.members;
      var v7224 = v15533.privateMembers;
      v7220.addLocalsFromScope(v7221, v7222, v7223, v7224, true);
    }
    return;
  }
  function preAssignClassScopes(ast$$49, context$$30) {
    var classDecl$$6 = ast$$49;
    var memberScope$$2 = null;
    var aggScope$$1 = null;
    var v15534 = classDecl$$6.name;
    if (v15534) {
      v15534 = classDecl$$6.type;
    }
    var v7227 = v15534;
    if (v7227) {
      var v7226 = classDecl$$6.name;
      var v15535 = classDecl$$6.type;
      v7226.sym = v15535.symbol;
    }
    var classType$$1 = ast$$49.type;
    if (classType$$1) {
      var classSym = classType$$1.symbol;
      var v15536 = context$$30.typeFlow;
      var v7228 = v15536.checker;
      memberScope$$2 = v7228.scopeOf(classType$$1);
      var v7229 = TypeScript$$17.SymbolAggregateScope;
      var v7230 = classType$$1.symbol;
      aggScope$$1 = new v7229(v7230);
      aggScope$$1.addParentScope(memberScope$$2);
      var v15537 = context$$30.scopeChain;
      var v7231 = v15537.scope;
      aggScope$$1.addParentScope(v7231);
      classType$$1.containedScope = aggScope$$1;
      classType$$1.memberScope = memberScope$$2;
      var instanceType$$2 = classType$$1.instanceType;
      var v15538 = context$$30.typeFlow;
      var v7232 = v15538.checker;
      memberScope$$2 = v7232.scopeOf(instanceType$$2);
      instanceType$$2.memberScope = memberScope$$2;
      var v7233 = TypeScript$$17.SymbolAggregateScope;
      var v7234 = instanceType$$2.symbol;
      aggScope$$1 = new v7233(v7234);
      var v15539 = context$$30.scopeChain;
      var v7235 = v15539.scope;
      aggScope$$1.addParentScope(v7235);
      pushAssignScope(aggScope$$1, context$$30, instanceType$$2, classType$$1, null);
      instanceType$$2.containedScope = aggScope$$1;
    } else {
      var v7236 = context$$30.typeFlow;
      ast$$49.type = v7236.anyType;
    }
    return;
  }
  function preAssignInterfaceScopes(ast$$50, context$$31) {
    var interfaceDecl$$2 = ast$$50;
    var memberScope$$3 = null;
    var aggScope$$2 = null;
    var v15540 = interfaceDecl$$2.name;
    if (v15540) {
      v15540 = interfaceDecl$$2.type;
    }
    var v7238 = v15540;
    if (v7238) {
      var v7237 = interfaceDecl$$2.name;
      var v15541 = interfaceDecl$$2.type;
      v7237.sym = v15541.symbol;
    }
    var interfaceType = ast$$50.type;
    var v15542 = context$$31.typeFlow;
    var v7239 = v15542.checker;
    memberScope$$3 = v7239.scopeOf(interfaceType);
    interfaceType.memberScope = memberScope$$3;
    var v7240 = TypeScript$$17.SymbolAggregateScope;
    var v7241 = interfaceType.symbol;
    aggScope$$2 = new v7240(v7241);
    aggScope$$2.addParentScope(memberScope$$3);
    var v15543 = context$$31.scopeChain;
    var v7242 = v15543.scope;
    aggScope$$2.addParentScope(v7242);
    pushAssignScope(aggScope$$2, context$$31, null, null, null);
    interfaceType.containedScope = aggScope$$2;
    return;
  }
  function preAssignWithScopes(ast$$51, context$$32) {
    var withStmt$$1 = ast$$51;
    var withType = withStmt$$1.type;
    var v7243 = TypeScript$$17.ScopedMembers;
    var v15544 = TypeScript$$17.DualStringHashTable;
    var v20693 = TypeScript$$17.StringHashTable;
    var v15545 = new v20693;
    var v20694 = TypeScript$$17.StringHashTable;
    var v15546 = new v20694;
    var v7244 = new v15544(v15545, v15546);
    var members$$12 = new v7243(v7244);
    var v7245 = TypeScript$$17.ScopedMembers;
    var v15547 = TypeScript$$17.DualStringHashTable;
    var v20695 = TypeScript$$17.StringHashTable;
    var v15548 = new v20695;
    var v20696 = TypeScript$$17.StringHashTable;
    var v15549 = new v20696;
    var v7246 = new v15547(v15548, v15549);
    var ambientMembers$$1 = new v7245(v7246);
    var v7247 = TypeScript$$17.Type;
    withType = new v7247;
    var v7248 = TypeScript$$17.WithSymbol;
    var v7249 = withStmt$$1.minChar;
    var v23929 = context$$32.typeFlow;
    var v20697 = v23929.checker;
    var v15550 = v20697.locationInfo;
    var v7250 = v15550.unitIndex;
    var withSymbol = new v7248(v7249, v7250, withType);
    withType.members = members$$12;
    withType.ambientMembers = ambientMembers$$1;
    withType.symbol = withSymbol;
    withType.setHasImplementation();
    withStmt$$1.type = withType;
    var v7251 = TypeScript$$17.SymbolScopeBuilder;
    var v7252 = withType.members;
    var v7253 = withType.ambientMembers;
    var v15551 = context$$32.scopeChain;
    var v7254 = v15551.scope;
    var v7255 = withType.symbol;
    var withScope = new v7251(v7252, v7253, null, null, v7254, v7255);
    pushAssignScope(withScope, context$$32, null, null, null);
    withType.containedScope = withScope;
    return;
  }
  function preAssignFuncDeclScopes(ast$$52, context$$33) {
    var funcDecl$$13 = ast$$52;
    var container$$1 = null;
    var localContainer = null;
    var v7257 = funcDecl$$13.type;
    if (v7257) {
      var v7256 = ast$$52.type;
      localContainer = v7256.symbol;
    }
    var v7258 = funcDecl$$13.fncFlags;
    var v15552 = TypeScript$$17.FncFlags;
    var v7259 = v15552.Static;
    var isStatic$$5 = TypeScript$$17.hasFlag(v7258, v7259);
    var v7260 = isStatic$$5;
    if (v7260) {
      var v20698 = context$$33.scopeChain;
      var v15553 = v20698.fnc;
      v7260 = v15553 != null;
    }
    var isInnerStatic = v7260;
    var v7261;
    if (isInnerStatic) {
      var v23930 = context$$33.scopeChain;
      var v20699 = v23930.fnc;
      var v15554 = v20699.type;
      v7261 = v15554.memberScope;
    } else {
      var v15555 = context$$33.scopeChain;
      v7261 = v15555.scope;
    }
    var parentScope = v7261;
    var v20700 = context$$33.scopeChain;
    var v15556 = v20700.thisType;
    if (v15556) {
      var v23931 = funcDecl$$13.isConstructor;
      var v20701 = !v23931;
      var v23934 = !v20701;
      if (v23934) {
        var v23932 = funcDecl$$13.fncFlags;
        var v25522 = TypeScript$$17.FncFlags;
        var v23933 = v25522.ClassMethod;
        v20701 = TypeScript$$17.hasFlag(v23932, v23933);
      }
      v15556 = v20701;
    }
    var v7270 = v15556;
    if (v7270) {
      var v7262 = context$$33.scopeChain;
      var instType = v7262.thisType;
      var v23935 = instType.typeFlags;
      var v25523 = TypeScript$$17.TypeFlags;
      var v23936 = v25523.IsClass;
      var v20702 = v23935 & v23936;
      var v15557 = !v20702;
      if (v15557) {
        var v23937 = funcDecl$$13.fncFlags;
        var v25524 = TypeScript$$17.FncFlags;
        var v23938 = v25524.ClassMethod;
        var v20703 = TypeScript$$17.hasFlag(v23937, v23938);
        v15557 = !v20703;
      }
      var v7267 = v15557;
      if (v7267) {
        var v20704 = funcDecl$$13.isMethod();
        var v15558 = !v20704;
        var v20705 = !v15558;
        if (v20705) {
          v15558 = isStatic$$5;
        }
        var v7263 = v15558;
        if (v7263) {
          parentScope = instType.constructorScope;
        } else {
          parentScope = instType.containedScope;
        }
      } else {
        var v26489 = context$$33.scopeChain;
        var v26205 = v26489.previous;
        var v25525 = v26205.scope;
        var v23939 = v25525.container;
        if (v23939) {
          var v26628 = context$$33.scopeChain;
          var v26490 = v26628.previous;
          var v26206 = v26490.scope;
          var v25526 = v26206.container;
          v23939 = v25526.declAST;
        }
        var v20706 = v23939;
        if (v20706) {
          var v26698 = context$$33.scopeChain;
          var v26629 = v26698.previous;
          var v26491 = v26629.scope;
          var v26207 = v26491.container;
          var v25527 = v26207.declAST;
          var v23940 = v25527.nodeType;
          var v25528 = TypeScript$$17.NodeType;
          var v23941 = v25528.FuncDecl;
          v20706 = v23940 == v23941;
        }
        var v15559 = v20706;
        if (v15559) {
          var v26492 = context$$33.scopeChain;
          var v26208 = v26492.previous;
          var v25529 = v26208.scope;
          var v23942 = v25529.container;
          var v20707 = v23942.declAST;
          v15559 = v20707.isConstructor;
        }
        var v7266 = v15559;
        if (v7266) {
          parentScope = instType.constructorScope;
        } else {
          var v15560 = isStatic$$5;
          if (v15560) {
            var v20708 = context$$33.scopeChain;
            v15560 = v20708.classType;
          }
          var v7265 = v15560;
          if (v7265) {
            var v15561 = context$$33.scopeChain;
            var v7264 = v15561.classType;
            parentScope = v7264.containedScope;
          } else {
            parentScope = instType.containedScope;
          }
        }
      }
      container$$1 = instType.symbol;
    } else {
      var v15562 = funcDecl$$13.isConstructor;
      if (v15562) {
        var v20709 = context$$33.scopeChain;
        v15562 = v20709.thisType;
      }
      var v7269 = v15562;
      if (v7269) {
        var v15563 = context$$33.scopeChain;
        var v7268 = v15563.thisType;
        container$$1 = v7268.symbol;
      }
    }
    var v20710 = funcDecl$$13.type;
    var v15564 = v20710 == null;
    var v20713 = !v15564;
    if (v20713) {
      var v25530 = funcDecl$$13.type;
      var v23943 = v25530.symbol;
      var v20711 = v23943.flags;
      var v23944 = TypeScript$$17.SymbolFlags;
      var v20712 = v23944.TypeSetDuringScopeAssignment;
      v15564 = TypeScript$$17.hasFlag(v20711, v20712);
    }
    var v7287 = v15564;
    if (v7287) {
      var v20714 = context$$33.scopeChain;
      var v15565 = v20714.fnc;
      if (v15565) {
        var v23945 = context$$33.scopeChain;
        var v20715 = v23945.fnc;
        v15565 = v20715.type;
      }
      var v7272 = v15565;
      if (v7272) {
        var v20716 = context$$33.scopeChain;
        var v15566 = v20716.fnc;
        var v7271 = v15566.type;
        container$$1 = v7271.symbol;
      }
      var funcScope = null;
      var v7273 = context$$33.scopeChain;
      var outerFnc$$1 = v7273.fnc;
      var v7274;
      var v15568 = funcDecl$$13.name;
      if (v15568) {
        var v15567 = funcDecl$$13.name;
        v7274 = v15567.actualText;
      } else {
        v7274 = null;
      }
      var nameText$$1 = v7274;
      var fgSym = null;
      if (isStatic$$5) {
        var v23946 = outerFnc$$1.type;
        var v20717 = v23946.members;
        var v15569 = v20717 == null;
        if (v15569) {
          var v20718 = container$$1.getType();
          v15569 = v20718.memberScope;
        }
        var v7276 = v15569;
        if (v7276) {
          var v7275 = outerFnc$$1.type;
          var v20719 = container$$1.type;
          var v15570 = v20719.memberScope;
          v7275.members = v15570.valueMembers;
        }
        var v20720 = context$$33.scopeChain;
        var v15571 = v20720.fnc;
        var v7277 = v15571.type;
        funcScope = v7277.memberScope;
        var v7278 = outerFnc$$1.innerStaticFuncs;
        var v15572 = outerFnc$$1.innerStaticFuncs;
        var v7279 = v15572.length;
        v7278[v7279] = funcDecl$$13;
      } else {
        var v7280 = context$$33.scopeChain;
        funcScope = v7280.scope;
      }
      var v20721 = nameText$$1;
      if (v20721) {
        v20721 = nameText$$1 != "__missing";
      }
      var v15573 = v20721;
      if (v15573) {
        var v20722 = funcDecl$$13.isAccessor();
        v15573 = !v20722;
      }
      var v7281 = v15573;
      if (v7281) {
        if (isStatic$$5) {
          fgSym = funcScope.findLocal(nameText$$1, false, false);
        } else {
          fgSym = funcScope.findLocal(nameText$$1, false, false);
        }
      }
      var v15574 = context$$33.typeFlow;
      var v7282 = v15574.checker;
      var v7283 = fgSym == null;
      v7282.createFunctionSignature(funcDecl$$13, container$$1, funcScope, fgSym, v7283);
      var v26209 = funcDecl$$13.accessorSymbol;
      var v25531 = !v26209;
      if (v25531) {
        var v26210 = funcDecl$$13.fncFlags;
        var v26493 = TypeScript$$17.FncFlags;
        var v26211 = v26493.ClassMethod;
        v25531 = v26210 & v26211;
      }
      var v23947 = v25531;
      if (v23947) {
        v23947 = container$$1;
      }
      var v20723 = v23947;
      if (v20723) {
        var v25532 = !fgSym;
        var v26214 = !v25532;
        if (v26214) {
          var v26494 = fgSym.declAST;
          var v26212 = v26494.nodeType;
          var v26495 = TypeScript$$17.NodeType;
          var v26213 = v26495.FuncDecl;
          v25532 = v26212 != v26213;
        }
        var v23948 = v25532;
        if (v23948) {
          v23948 = funcDecl$$13.isAccessor();
        }
        v20723 = v23948;
      }
      var v15575 = v20723;
      var v20725 = !v15575;
      if (v20725) {
        var v20724 = fgSym;
        if (v20724) {
          v20724 = fgSym.isAccessor();
        }
        v15575 = v20724;
      }
      var v7285 = v15575;
      if (v7285) {
        var v7284 = funcDecl$$13;
        var v20726 = context$$33.typeFlow;
        var v15576 = v20726.checker;
        var v15577 = container$$1.getType();
        var v20727 = funcDecl$$13.isMethod();
        if (v20727) {
          v20727 = isStatic$$5;
        }
        var v15578 = v20727;
        var v27011 = v15576.createAccessorSymbol(funcDecl$$13, fgSym, v15577, v15578, true, funcScope, container$$1);
        v7284.accessorSymbol = v27011;
      }
      var v15579 = funcDecl$$13.type;
      var v7286 = v15579.symbol;
      var v20728 = v7286.flags;
      var v23949 = TypeScript$$17.SymbolFlags;
      var v20729 = v23949.TypeSetDuringScopeAssignment;
      v7286.flags = v20728 | v20729;
    }
    var v15580 = funcDecl$$13.name;
    if (v15580) {
      v15580 = funcDecl$$13.type;
    }
    var v7289 = v15580;
    if (v7289) {
      var v7288 = funcDecl$$13.name;
      var v15581 = funcDecl$$13.type;
      v7288.sym = v15581.symbol;
    }
    funcDecl$$13.scopeType = funcDecl$$13.type;
    var v7290 = funcDecl$$13.isOverload;
    if (v7290) {
      return;
    }
    var v7291 = TypeScript$$17.StringHashTable;
    var funcTable = new v7291;
    var v7292 = TypeScript$$17.ScopedMembers;
    var v15582 = TypeScript$$17.DualStringHashTable;
    var v20730 = TypeScript$$17.StringHashTable;
    var v15583 = new v20730;
    var v7293 = new v15582(funcTable, v15583);
    var funcMembers = new v7292(v7293);
    var v7294 = TypeScript$$17.StringHashTable;
    var ambientFuncTable = new v7294;
    var v7295 = TypeScript$$17.ScopedMembers;
    var v15584 = TypeScript$$17.DualStringHashTable;
    var v20731 = TypeScript$$17.StringHashTable;
    var v15585 = new v20731;
    var v7296 = new v15584(ambientFuncTable, v15585);
    var ambientFuncMembers = new v7295(v7296);
    var v7297 = TypeScript$$17.StringHashTable;
    var funcStaticTable = new v7297;
    var v7298 = TypeScript$$17.ScopedMembers;
    var v15586 = TypeScript$$17.DualStringHashTable;
    var v20732 = TypeScript$$17.StringHashTable;
    var v15587 = new v20732;
    var v7299 = new v15586(funcStaticTable, v15587);
    var funcStaticMembers = new v7298(v7299);
    var v7300 = TypeScript$$17.StringHashTable;
    var ambientFuncStaticTable = new v7300;
    var v7301 = TypeScript$$17.ScopedMembers;
    var v15588 = TypeScript$$17.DualStringHashTable;
    var v20733 = TypeScript$$17.StringHashTable;
    var v15589 = new v20733;
    var v7302 = new v15588(ambientFuncStaticTable, v15589);
    var ambientFuncStaticMembers = new v7301(v7302);
    var v20734 = context$$33.typeFlow;
    var v15590 = v20734.checker;
    var v7303 = v15590.locationInfo;
    funcDecl$$13.unitIndex = v7303.unitIndex;
    var v7304 = TypeScript$$17.SymbolScopeBuilder;
    var locals = new v7304(funcMembers, ambientFuncMembers, null, null, parentScope, localContainer);
    var v7305 = TypeScript$$17.SymbolScopeBuilder;
    var statics$$1 = new v7305(funcStaticMembers, ambientFuncStaticMembers, null, null, parentScope, null);
    var v15591 = funcDecl$$13.isConstructor;
    if (v15591) {
      var v20735 = context$$33.scopeChain;
      v15591 = v20735.thisType;
    }
    var v7307 = v15591;
    if (v7307) {
      var v15592 = context$$33.scopeChain;
      var v7306 = v15592.thisType;
      v7306.constructorScope = locals;
    }
    funcDecl$$13.symbols = funcTable;
    var v15593 = funcDecl$$13.isSpecialFn();
    var v7326 = !v15593;
    if (v7326) {
      var group = funcDecl$$13.type;
      var signature$$1 = funcDecl$$13.signature;
      var v15594 = funcDecl$$13.isConstructor;
      var v7308 = !v15594;
      if (v7308) {
        group.containedScope = locals;
        locals.container = group.symbol;
        group.memberScope = statics$$1;
        statics$$1.container = group.symbol;
      }
      var v7309 = context$$33.scopeChain;
      funcDecl$$13.enclosingFnc = v7309.fnc;
      var v7310;
      if (isStatic$$5) {
        var v15595 = context$$33.scopeChain;
        v7310 = v15595.classType;
      } else {
        var v15596 = context$$33.scopeChain;
        v7310 = v15596.thisType;
      }
      group.enclosingType = v7310;
      var v7311 = ast$$52.type;
      fgSym = v7311.symbol;
      var v23950 = funcDecl$$13.fncFlags;
      var v25533 = TypeScript$$17.FncFlags;
      var v23951 = v25533.Signature;
      var v20736 = v23950 & v23951;
      var v23952 = TypeScript$$17.FncFlags;
      var v20737 = v23952.None;
      var v15597 = v20736 == v20737;
      if (v15597) {
        v15597 = funcDecl$$13.vars;
      }
      var v7316 = v15597;
      if (v7316) {
        var v7312 = context$$33.typeFlow;
        var v7313 = funcDecl$$13.vars;
        v7312.addLocalsFromScope(locals, fgSym, v7313, funcTable, false);
        var v7314 = context$$33.typeFlow;
        var v7315 = funcDecl$$13.statics;
        v7314.addLocalsFromScope(statics$$1, fgSym, v7315, funcStaticTable, false);
      }
      var v7322 = signature$$1.parameters;
      if (v7322) {
        var v7317 = signature$$1.parameters;
        var len$$17 = v7317.length;
        var i$$55 = 0;
        var v7321 = i$$55 < len$$17;
        for (;v7321;) {
          var v7318 = signature$$1.parameters;
          var paramSym = v7318[i$$55];
          var v15598 = context$$33.typeFlow;
          var v7319 = v15598.checker;
          var v15599 = paramSym.parameter;
          var v7320 = v15599.typeLink;
          v7319.resolveTypeLink(locals, v7320, true);
          i$$55 = i$$55 + 1;
          v7321 = i$$55 < len$$17;
        }
      }
      var v15600 = context$$33.typeFlow;
      var v7323 = v15600.checker;
      var v7324 = signature$$1.returnType;
      var v7325 = funcDecl$$13.isSignature();
      v7323.resolveTypeLink(locals, v7324, v7325);
    }
    var v20738 = funcDecl$$13.isConstructor;
    var v15601 = !v20738;
    var v20741 = !v15601;
    if (v20741) {
      var v20739 = funcDecl$$13.fncFlags;
      var v23953 = TypeScript$$17.FncFlags;
      var v20740 = v23953.ClassMethod;
      v15601 = TypeScript$$17.hasFlag(v20739, v20740);
    }
    var v7328 = v15601;
    if (v7328) {
      var v7327;
      var v20742 = funcDecl$$13.isConstructor;
      if (v20742) {
        var v23954 = funcDecl$$13.fncFlags;
        var v25534 = TypeScript$$17.FncFlags;
        var v23955 = v25534.ClassMethod;
        v20742 = TypeScript$$17.hasFlag(v23954, v23955);
      }
      var v15603 = v20742;
      if (v15603) {
        var v15602 = context$$33.scopeChain;
        v7327 = v15602.thisType;
      } else {
        v7327 = null;
      }
      var thisType = v7327;
      pushAssignScope(locals, context$$33, thisType, null, funcDecl$$13);
    }
    var v15604 = funcDecl$$13.name;
    if (v15604) {
      var v20743 = funcDecl$$13.fncFlags;
      var v23956 = TypeScript$$17.FncFlags;
      var v20744 = v23956.IsFunctionExpression;
      v15604 = TypeScript$$17.hasFlag(v20743, v20744);
    }
    var v7332 = v15604;
    if (v7332) {
      var v15605 = funcDecl$$13.name;
      var v7331 = v15605.sym;
      if (v7331) {
        var v15606 = funcDecl$$13.name;
        var v7329 = v15606.actualText;
        var v15607 = funcDecl$$13.name;
        var v7330 = v15607.sym;
        funcTable.add(v7329, v7330);
      }
    }
    return;
  }
  function preAssignCatchScopes(ast$$53, context$$34) {
    var catchBlock = ast$$53;
    var v7341 = catchBlock.param;
    if (v7341) {
      var v7333 = TypeScript$$17.ScopedMembers;
      var v15608 = TypeScript$$17.DualStringHashTable;
      var v20745 = TypeScript$$17.StringHashTable;
      var v15609 = new v20745;
      var v20746 = TypeScript$$17.StringHashTable;
      var v15610 = new v20746;
      var v7334 = new v15608(v15609, v15610);
      var catchTable = new v7333(v7334);
      var v7335 = TypeScript$$17.SymbolScopeBuilder;
      var v15611 = context$$34.scopeChain;
      var v7336 = v15611.scope;
      var v20747 = context$$34.scopeChain;
      var v15612 = v20747.scope;
      var v7337 = v15612.container;
      var catchLocals = new v7335(catchTable, null, null, null, v7336, v7337);
      catchBlock.containedScope = catchLocals;
      var v15613 = context$$34.scopeChain;
      var v7338 = v15613.thisType;
      var v15614 = context$$34.scopeChain;
      var v7339 = v15614.classType;
      var v15615 = context$$34.scopeChain;
      var v7340 = v15615.fnc;
      pushAssignScope(catchLocals, context$$34, v7338, v7339, v7340);
    }
    return;
  }
  function preAssignScopes(ast$$54, parent$$45, walker$$42) {
    var context$$35 = walker$$42.state;
    var go = true;
    if (ast$$54) {
      var v15616 = ast$$54.nodeType;
      var v20748 = TypeScript$$17.NodeType;
      var v15617 = v20748.List;
      var v7350 = v15616 == v15617;
      if (v7350) {
        var list$$2 = ast$$54;
        var v7342 = context$$35.scopeChain;
        list$$2.enclosingScope = v7342.scope;
      } else {
        var v15618 = ast$$54.nodeType;
        var v20749 = TypeScript$$17.NodeType;
        var v15619 = v20749.ModuleDeclaration;
        var v7349 = v15618 == v15619;
        if (v7349) {
          preAssignModuleScopes(ast$$54, context$$35);
        } else {
          var v15620 = ast$$54.nodeType;
          var v20750 = TypeScript$$17.NodeType;
          var v15621 = v20750.ClassDeclaration;
          var v7348 = v15620 == v15621;
          if (v7348) {
            preAssignClassScopes(ast$$54, context$$35);
          } else {
            var v15622 = ast$$54.nodeType;
            var v20751 = TypeScript$$17.NodeType;
            var v15623 = v20751.InterfaceDeclaration;
            var v7347 = v15622 == v15623;
            if (v7347) {
              preAssignInterfaceScopes(ast$$54, context$$35);
            } else {
              var v15624 = ast$$54.nodeType;
              var v20752 = TypeScript$$17.NodeType;
              var v15625 = v20752.With;
              var v7346 = v15624 == v15625;
              if (v7346) {
                preAssignWithScopes(ast$$54, context$$35);
              } else {
                var v15626 = ast$$54.nodeType;
                var v20753 = TypeScript$$17.NodeType;
                var v15627 = v20753.FuncDecl;
                var v7345 = v15626 == v15627;
                if (v7345) {
                  preAssignFuncDeclScopes(ast$$54, context$$35);
                } else {
                  var v15628 = ast$$54.nodeType;
                  var v20754 = TypeScript$$17.NodeType;
                  var v15629 = v20754.Catch;
                  var v7344 = v15628 == v15629;
                  if (v7344) {
                    preAssignCatchScopes(ast$$54, context$$35);
                  } else {
                    var v15630 = ast$$54.nodeType;
                    var v20755 = TypeScript$$17.NodeType;
                    var v15631 = v20755.TypeRef;
                    var v7343 = v15630 == v15631;
                    if (v7343) {
                      go = false;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    var v7351 = walker$$42.options;
    v7351.goChildren = go;
    return ast$$54;
  }
  function postAssignScopes(ast$$55, parent$$46, walker$$43) {
    var context$$36 = walker$$43.state;
    var go$$1 = true;
    if (ast$$55) {
      var v15632 = ast$$55.nodeType;
      var v20756 = TypeScript$$17.NodeType;
      var v15633 = v20756.ModuleDeclaration;
      var v7362 = v15632 == v15633;
      if (v7362) {
        var prevModDecl = ast$$55;
        popAssignScope(context$$36);
        var v7352 = context$$36.modDeclChain;
        v7352.pop();
        var v20757 = context$$36.modDeclChain;
        var v15634 = v20757.length;
        var v7354 = v15634 >= 1;
        if (v7354) {
          var v15635 = context$$36.typeFlow;
          var v7353 = v15635.checker;
          var v15636 = context$$36.modDeclChain;
          var v23957 = context$$36.modDeclChain;
          var v20758 = v23957.length;
          var v15637 = v20758 - 1;
          v7353.currentModDecl = v15636[v15637];
        }
      } else {
        var v15638 = ast$$55.nodeType;
        var v20759 = TypeScript$$17.NodeType;
        var v15639 = v20759.ClassDeclaration;
        var v7361 = v15638 == v15639;
        if (v7361) {
          popAssignScope(context$$36);
        } else {
          var v15640 = ast$$55.nodeType;
          var v20760 = TypeScript$$17.NodeType;
          var v15641 = v20760.InterfaceDeclaration;
          var v7360 = v15640 == v15641;
          if (v7360) {
            popAssignScope(context$$36);
          } else {
            var v15642 = ast$$55.nodeType;
            var v20761 = TypeScript$$17.NodeType;
            var v15643 = v20761.With;
            var v7359 = v15642 == v15643;
            if (v7359) {
              popAssignScope(context$$36);
            } else {
              var v15644 = ast$$55.nodeType;
              var v20762 = TypeScript$$17.NodeType;
              var v15645 = v20762.FuncDecl;
              var v7358 = v15644 == v15645;
              if (v7358) {
                var funcDecl$$14 = ast$$55;
                var v23958 = funcDecl$$14.isConstructor;
                var v20763 = !v23958;
                var v23961 = !v20763;
                if (v23961) {
                  var v23959 = funcDecl$$14.fncFlags;
                  var v25535 = TypeScript$$17.FncFlags;
                  var v23960 = v25535.ClassMethod;
                  v20763 = TypeScript$$17.hasFlag(v23959, v23960);
                }
                var v15646 = v20763;
                if (v15646) {
                  var v20764 = funcDecl$$14.isOverload;
                  v15646 = !v20764;
                }
                var v7355 = v15646;
                if (v7355) {
                  popAssignScope(context$$36);
                }
              } else {
                var v15647 = ast$$55.nodeType;
                var v20765 = TypeScript$$17.NodeType;
                var v15648 = v20765.Catch;
                var v7357 = v15647 == v15648;
                if (v7357) {
                  var catchBlock$$1 = ast$$55;
                  var v7356 = catchBlock$$1.param;
                  if (v7356) {
                    popAssignScope(context$$36);
                  }
                } else {
                  go$$1 = false;
                }
              }
            }
          }
        }
      }
    }
    var v7363 = walker$$43.options;
    v7363.goChildren = go$$1;
    return ast$$55;
  }
  var AssignScopeContext = v676();
  TypeScript$$17.AssignScopeContext = AssignScopeContext;
  TypeScript$$17.pushAssignScope = pushAssignScope;
  TypeScript$$17.popAssignScope = popAssignScope;
  TypeScript$$17.instanceCompare = instanceCompare;
  TypeScript$$17.instanceFilterStop = instanceFilterStop;
  var ScopeSearchFilter = v679();
  TypeScript$$17.ScopeSearchFilter = ScopeSearchFilter;
  var v7364 = TypeScript$$17;
  var v27012 = new ScopeSearchFilter(instanceCompare, instanceFilterStop);
  v7364.instanceFilter = v27012;
  TypeScript$$17.preAssignModuleScopes = preAssignModuleScopes;
  TypeScript$$17.preAssignClassScopes = preAssignClassScopes;
  TypeScript$$17.preAssignInterfaceScopes = preAssignInterfaceScopes;
  TypeScript$$17.preAssignWithScopes = preAssignWithScopes;
  TypeScript$$17.preAssignFuncDeclScopes = preAssignFuncDeclScopes;
  TypeScript$$17.preAssignCatchScopes = preAssignCatchScopes;
  TypeScript$$17.preAssignScopes = preAssignScopes;
  TypeScript$$17.postAssignScopes = postAssignScopes;
  return;
}
function v675(TypeScript$$16) {
  function v674() {
    function v673(message$$16) {
      var v7365 = this.reportError;
      if (v7365) {
        this.reportError(message$$16);
      }
      return;
    }
    function v672() {
      var rtok$$1;
      this.tokenStart();
      var v27013 = this.peekChar();
      this.ch = v27013;
      var v15649 = this.pos;
      var v15650 = this.len;
      var v7528 = v15649 < v15650;
      start: for (;v7528;) {
        var v23962 = this.ch;
        var v20766 = lexIdStartTable[v23962];
        var v23965 = !v20766;
        if (v23965) {
          var v23963 = this.ch;
          var v23964 = TypeScript$$16.LexCodeBSL;
          v20766 = v23963 == v23964;
        }
        var v15651 = v20766;
        var v20768 = !v15651;
        if (v20768) {
          var v23966 = this.ch;
          var v23967 = TypeScript$$16.LexCodeASCIIChars;
          var v20767 = v23966 >= v23967;
          if (v20767) {
            var v23968 = this.ch;
            v20767 = LexIsUnicodeIdStart(v23968);
          }
          v15651 = v20767;
        }
        var v7527 = v15651;
        if (v7527) {
          return this.scanIdentifier();
        } else {
          var v15652 = this.ch;
          var v15653 = TypeScript$$16.LexCodeSpace;
          var v7526 = v15652 == v15653;
          if (v7526) {
            var v15654 = this.interveningWhitespace;
            var v7366 = !v15654;
            if (v7366) {
              this.interveningWhitespacePos = this.pos;
            }
            var v15655 = this.ch;
            var v15656 = TypeScript$$16.LexCodeSpace;
            var v7367 = v15655 == v15656;
            do {
              this.nextChar();
              var v15657 = this.ch;
              var v15658 = TypeScript$$16.LexCodeSpace;
              v7367 = v15657 == v15658;
            } while (v7367);
            var v15659 = this.mode;
            var v15660 = LexMode.Line;
            var v7373 = v15659 == v15660;
            if (v7373) {
              var v7368 = this.src;
              var v7369 = this.startPos;
              var v7370 = this.pos;
              var whitespaceText = v7368.substring(v7369, v7370);
              var v7371 = TypeScript$$16.WhitespaceToken;
              var v15661 = TypeScript$$16.TokenID;
              var v7372 = v15661.Whitespace;
              return new v7371(v7372, whitespaceText);
            } else {
              this.tokenStart();
              this.interveningWhitespace = true;
            }
          } else {
            var v15662 = this.ch;
            var v15663 = TypeScript$$16.LexCodeSLH;
            var v7525 = v15662 == v15663;
            if (v7525) {
              this.nextChar();
              var commentText$$2;
              var v15664 = this.ch;
              var v15665 = TypeScript$$16.LexCodeSLH;
              var v7397 = v15664 == v15665;
              if (v7397) {
                var v15666 = this.interveningWhitespace;
                var v7375 = !v15666;
                if (v7375) {
                  var v7374 = this.pos;
                  this.interveningWhitespacePos = v7374 - 1;
                }
                var v7376 = this.pos;
                var commentStartPos = v7376 - 1;
                var commentStartLine = this.line;
                this.finishSinglelineComment();
                var v7377 = this.src;
                var v7378 = this.pos;
                commentText$$2 = v7377.substring(commentStartPos, v7378);
                var v7379 = TypeScript$$16.CommentToken;
                var v15667 = TypeScript$$16.TokenID;
                var v7380 = v15667.Comment;
                var commentToken = new v7379(v7380, commentText$$2, false, commentStartPos, commentStartLine, false);
                var v7381 = this.scanComments;
                if (v7381) {
                  this.startPos = commentStartPos;
                  return commentToken;
                } else {
                  this.pushComment(commentToken);
                }
                this.interveningWhitespace = true;
              } else {
                var v15668 = this.ch;
                var v15669 = TypeScript$$16.LexCodeMUL;
                var v7396 = v15668 == v15669;
                if (v7396) {
                  var v15670 = this.interveningWhitespace;
                  var v7383 = !v15670;
                  if (v7383) {
                    var v7382 = this.pos;
                    this.interveningWhitespacePos = v7382 - 1;
                  }
                  var v7384 = this.pos;
                  commentStartPos = v7384 - 1;
                  commentStartLine = this.line;
                  this.nextChar();
                  this.finishMultilineComment();
                  var v7385 = this.src;
                  var v7386 = this.pos;
                  commentText$$2 = v7385.substring(commentStartPos, v7386);
                  var v7387 = this.peekChar();
                  var endsLine$$1 = this.endsLine(v7387);
                  var v7388 = TypeScript$$16.CommentToken;
                  var v15671 = TypeScript$$16.TokenID;
                  var v7389 = v15671.Comment;
                  commentToken = new v7388(v7389, commentText$$2, true, commentStartPos, commentStartLine, endsLine$$1);
                  var v7390 = this.scanComments;
                  if (v7390) {
                    this.startPos = commentStartPos;
                    return commentToken;
                  } else {
                    this.pushComment(commentToken);
                  }
                  this.interveningWhitespace = true;
                } else {
                  var regexTok = this.speculateRegex();
                  if (regexTok) {
                    return regexTok;
                  } else {
                    var v20769 = this.pos;
                    var v15672 = this.peekCharAt(v20769);
                    var v15673 = TypeScript$$16.LexCodeEQ;
                    var v7395 = v15672 == v15673;
                    if (v7395) {
                      this.nextChar();
                      var v7391 = TypeScript$$16.staticTokens;
                      var v15674 = TypeScript$$16.TokenID;
                      var v7392 = v15674.SlashEquals;
                      return v7391[v7392];
                    } else {
                      var v7393 = TypeScript$$16.staticTokens;
                      var v15675 = TypeScript$$16.TokenID;
                      var v7394 = v15675.Slash;
                      return v7393[v7394];
                    }
                  }
                }
              }
            } else {
              var v15676 = this.ch;
              var v15677 = TypeScript$$16.LexCodeSMC;
              var v7524 = v15676 == v15677;
              if (v7524) {
                this.nextChar();
                var v7398 = TypeScript$$16.staticTokens;
                var v15678 = TypeScript$$16.TokenID;
                var v7399 = v15678.Semicolon;
                return v7398[v7399];
              } else {
                var v20770 = this.ch;
                var v20771 = TypeScript$$16.LexCodeAPO;
                var v15679 = v20770 == v20771;
                var v20774 = !v15679;
                if (v20774) {
                  var v20772 = this.ch;
                  var v20773 = TypeScript$$16.LexCodeQUO;
                  v15679 = v20772 == v20773;
                }
                var v7523 = v15679;
                if (v7523) {
                  return this.scanStringConstant();
                } else {
                  var v15680 = this.ch;
                  var v7522 = autoToken[v15680];
                  if (v7522) {
                    var v7400 = this.ch;
                    var atok = autoToken[v7400];
                    var v15681 = atok.tokenId;
                    var v20775 = TypeScript$$16.TokenID;
                    var v15682 = v20775.OpenBrace;
                    var v7402 = v15681 == v15682;
                    if (v7402) {
                      var v15683 = this.leftCurlyCount;
                      this.leftCurlyCount = v15683 + 1;
                    } else {
                      var v15684 = atok.tokenId;
                      var v20776 = TypeScript$$16.TokenID;
                      var v15685 = v20776.CloseBrace;
                      var v7401 = v15684 == v15685;
                      if (v7401) {
                        var v15686 = this.rightCurlyCount;
                        this.rightCurlyCount = v15686 + 1;
                      }
                    }
                    this.nextChar();
                    return atok;
                  } else {
                    var v20777 = this.ch;
                    var v20778 = TypeScript$$16.LexCode_0;
                    var v15687 = v20777 >= v20778;
                    if (v15687) {
                      var v20779 = this.ch;
                      var v20780 = TypeScript$$16.LexCode_9;
                      v15687 = v20779 <= v20780;
                    }
                    var v7521 = v15687;
                    if (v7521) {
                      rtok$$1 = this.scanNumber();
                      if (rtok$$1) {
                        return rtok$$1;
                      } else {
                        this.nextChar();
                        var v7403 = TypeScript$$16.staticTokens;
                        var v15688 = TypeScript$$16.TokenID;
                        var v7404 = v15688.Error;
                        return v7403[v7404];
                      }
                    } else {
                      var v7520 = this.ch;
                      switch(v7520) {
                        case TypeScript$$16.LexCodeTAB:
                        ;
                        case TypeScript$$16.LexCodeVTAB:
                          var v15689 = this.interveningWhitespace;
                          var v7405 = !v15689;
                          if (v7405) {
                            this.interveningWhitespacePos = this.pos;
                          }
                          var v15690 = this.mode;
                          var v15691 = LexMode.Line;
                          var v7412 = v15690 == v15691;
                          if (v7412) {
                            var v20781 = this.ch;
                            var v20782 = TypeScript$$16.LexCodeSpace;
                            var v15692 = v20781 == v20782;
                            var v20784 = !v15692;
                            if (v20784) {
                              var v20783 = this.ch;
                              v15692 = v20783 == 9;
                            }
                            var v7406 = v15692;
                            do {
                              this.nextChar();
                              var v20785 = this.ch;
                              var v20786 = TypeScript$$16.LexCodeSpace;
                              var v15693 = v20785 == v20786;
                              var v20788 = !v15693;
                              if (v20788) {
                                var v20787 = this.ch;
                                v15693 = v20787 == 9;
                              }
                              v7406 = v15693;
                            } while (v7406);
                            var v7407 = this.src;
                            var v7408 = this.startPos;
                            var v7409 = this.pos;
                            var wsText = v7407.substring(v7408, v7409);
                            var v7410 = TypeScript$$16.WhitespaceToken;
                            var v15694 = TypeScript$$16.TokenID;
                            var v7411 = v15694.Whitespace;
                            return new v7410(v7411, wsText);
                          } else {
                            this.interveningWhitespace = true;
                          }
                        ;
                        case 255:
                        ;
                        case 254:
                        ;
                        case 239:
                        ;
                        case 187:
                        ;
                        case 191:
                        ;
                        case TypeScript$$16.LexCodeLS:
                        ;
                        case TypeScript$$16.LexCodePS:
                        ;
                        case TypeScript$$16.LexCodeNWL:
                        ;
                        case TypeScript$$16.LexCodeRET:
                          var v15695 = this.ch;
                          var v15696 = TypeScript$$16.LexCodeNWL;
                          var v7416 = v15695 == v15696;
                          if (v7416) {
                            this.newLine();
                            var v15697 = this.mode;
                            var v15698 = LexMode.Line;
                            var v7415 = v15697 == v15698;
                            if (v7415) {
                              var v7413 = TypeScript$$16.staticTokens;
                              var v15699 = TypeScript$$16.TokenID;
                              var v7414 = v15699.EndOfFile;
                              return v7413[v7414];
                            }
                          }
                          var v15700 = this.interveningWhitespace;
                          var v7417 = !v15700;
                          if (v7417) {
                            this.interveningWhitespacePos = this.pos;
                          }
                          this.nextChar();
                          this.tokenStart();
                          this.interveningWhitespace = true;
                          break;
                        case TypeScript$$16.LexCodeDOT:
                          var v23969 = this.pos;
                          var v20789 = v23969 + 1;
                          var v15701 = this.peekCharAt(v20789);
                          var v15702 = TypeScript$$16.LexCodeDOT;
                          var v7425 = v15701 == v15702;
                          if (v7425) {
                            var v23970 = this.pos;
                            var v20790 = v23970 + 2;
                            var v15703 = this.peekCharAt(v20790);
                            var v15704 = TypeScript$$16.LexCodeDOT;
                            var v7422 = v15703 == v15704;
                            if (v7422) {
                              this.advanceChar(3);
                              var v7418 = TypeScript$$16.staticTokens;
                              var v15705 = TypeScript$$16.TokenID;
                              var v7419 = v15705.DotDotDot;
                              return v7418[v7419];
                            } else {
                              this.nextChar();
                              var v7420 = TypeScript$$16.staticTokens;
                              var v15706 = TypeScript$$16.TokenID;
                              var v7421 = v15706.Dot;
                              return v7420[v7421];
                            }
                          } else {
                            this.nextChar();
                            rtok$$1 = this.scanFraction();
                            if (rtok$$1) {
                              return rtok$$1;
                            } else {
                              var v7423 = TypeScript$$16.staticTokens;
                              var v15707 = TypeScript$$16.TokenID;
                              var v7424 = v15707.Dot;
                              return v7423[v7424];
                            }
                          }
                        ;
                        case TypeScript$$16.LexCodeEQ:
                          var v23971 = this.pos;
                          var v20791 = v23971 + 1;
                          var v15708 = this.peekCharAt(v20791);
                          var v15709 = TypeScript$$16.LexCodeEQ;
                          var v7436 = v15708 == v15709;
                          if (v7436) {
                            var v23972 = this.pos;
                            var v20792 = v23972 + 2;
                            var v15710 = this.peekCharAt(v20792);
                            var v15711 = TypeScript$$16.LexCodeEQ;
                            var v7430 = v15710 == v15711;
                            if (v7430) {
                              this.advanceChar(3);
                              var v7426 = TypeScript$$16.staticTokens;
                              var v15712 = TypeScript$$16.TokenID;
                              var v7427 = v15712.EqualsEqualsEquals;
                              return v7426[v7427];
                            } else {
                              this.advanceChar(2);
                              var v7428 = TypeScript$$16.staticTokens;
                              var v15713 = TypeScript$$16.TokenID;
                              var v7429 = v15713.EqualsEquals;
                              return v7428[v7429];
                            }
                          } else {
                            var v23973 = this.pos;
                            var v20793 = v23973 + 1;
                            var v15714 = this.peekCharAt(v20793);
                            var v15715 = TypeScript$$16.LexCodeGT;
                            var v7435 = v15714 == v15715;
                            if (v7435) {
                              this.advanceChar(2);
                              var v7431 = TypeScript$$16.staticTokens;
                              var v15716 = TypeScript$$16.TokenID;
                              var v7432 = v15716.EqualsGreaterThan;
                              return v7431[v7432];
                            } else {
                              this.nextChar();
                              var v7433 = TypeScript$$16.staticTokens;
                              var v15717 = TypeScript$$16.TokenID;
                              var v7434 = v15717.Equals;
                              return v7433[v7434];
                            }
                          }
                        ;
                        case TypeScript$$16.LexCodeBNG:
                          var v23974 = this.pos;
                          var v20794 = v23974 + 1;
                          var v15718 = this.peekCharAt(v20794);
                          var v15719 = TypeScript$$16.LexCodeEQ;
                          var v7444 = v15718 == v15719;
                          if (v7444) {
                            var v23975 = this.pos;
                            var v20795 = v23975 + 2;
                            var v15720 = this.peekCharAt(v20795);
                            var v15721 = TypeScript$$16.LexCodeEQ;
                            var v7441 = v15720 == v15721;
                            if (v7441) {
                              this.advanceChar(3);
                              var v7437 = TypeScript$$16.staticTokens;
                              var v15722 = TypeScript$$16.TokenID;
                              var v7438 = v15722.ExclamationEqualsEquals;
                              return v7437[v7438];
                            } else {
                              this.advanceChar(2);
                              var v7439 = TypeScript$$16.staticTokens;
                              var v15723 = TypeScript$$16.TokenID;
                              var v7440 = v15723.ExclamationEquals;
                              return v7439[v7440];
                            }
                          } else {
                            this.nextChar();
                            var v7442 = TypeScript$$16.staticTokens;
                            var v15724 = TypeScript$$16.TokenID;
                            var v7443 = v15724.Exclamation;
                            return v7442[v7443];
                          }
                        ;
                        case TypeScript$$16.LexCodePLS:
                          var v23976 = this.pos;
                          var v20796 = v23976 + 1;
                          var v15725 = this.peekCharAt(v20796);
                          var v15726 = TypeScript$$16.LexCodeEQ;
                          var v7452 = v15725 == v15726;
                          if (v7452) {
                            this.advanceChar(2);
                            var v7445 = TypeScript$$16.staticTokens;
                            var v15727 = TypeScript$$16.TokenID;
                            var v7446 = v15727.PlusEquals;
                            return v7445[v7446];
                          } else {
                            var v23977 = this.pos;
                            var v20797 = v23977 + 1;
                            var v15728 = this.peekCharAt(v20797);
                            var v15729 = TypeScript$$16.LexCodePLS;
                            var v7451 = v15728 == v15729;
                            if (v7451) {
                              this.advanceChar(2);
                              var v7447 = TypeScript$$16.staticTokens;
                              var v15730 = TypeScript$$16.TokenID;
                              var v7448 = v15730.PlusPlus;
                              return v7447[v7448];
                            } else {
                              this.nextChar();
                              var v7449 = TypeScript$$16.staticTokens;
                              var v15731 = TypeScript$$16.TokenID;
                              var v7450 = v15731.Plus;
                              return v7449[v7450];
                            }
                          }
                        ;
                        case TypeScript$$16.LexCodeMIN:
                          var v23978 = this.pos;
                          var v20798 = v23978 + 1;
                          var v15732 = this.peekCharAt(v20798);
                          var v15733 = TypeScript$$16.LexCodeEQ;
                          var v7460 = v15732 == v15733;
                          if (v7460) {
                            this.advanceChar(2);
                            var v7453 = TypeScript$$16.staticTokens;
                            var v15734 = TypeScript$$16.TokenID;
                            var v7454 = v15734.MinusEquals;
                            return v7453[v7454];
                          } else {
                            var v23979 = this.pos;
                            var v20799 = v23979 + 1;
                            var v15735 = this.peekCharAt(v20799);
                            var v15736 = TypeScript$$16.LexCodeMIN;
                            var v7459 = v15735 == v15736;
                            if (v7459) {
                              this.advanceChar(2);
                              var v7455 = TypeScript$$16.staticTokens;
                              var v15737 = TypeScript$$16.TokenID;
                              var v7456 = v15737.MinusMinus;
                              return v7455[v7456];
                            } else {
                              this.nextChar();
                              var v7457 = TypeScript$$16.staticTokens;
                              var v15738 = TypeScript$$16.TokenID;
                              var v7458 = v15738.Minus;
                              return v7457[v7458];
                            }
                          }
                        ;
                        case TypeScript$$16.LexCodeMUL:
                          var v23980 = this.pos;
                          var v20800 = v23980 + 1;
                          var v15739 = this.peekCharAt(v20800);
                          var v15740 = TypeScript$$16.LexCodeEQ;
                          var v7465 = v15739 == v15740;
                          if (v7465) {
                            this.advanceChar(2);
                            var v7461 = TypeScript$$16.staticTokens;
                            var v15741 = TypeScript$$16.TokenID;
                            var v7462 = v15741.AsteriskEquals;
                            return v7461[v7462];
                          } else {
                            this.nextChar();
                            var v7463 = TypeScript$$16.staticTokens;
                            var v15742 = TypeScript$$16.TokenID;
                            var v7464 = v15742.Asterisk;
                            return v7463[v7464];
                          }
                        ;
                        case TypeScript$$16.LexCodePCT:
                          var v23981 = this.pos;
                          var v20801 = v23981 + 1;
                          var v15743 = this.peekCharAt(v20801);
                          var v15744 = TypeScript$$16.LexCodeEQ;
                          var v7470 = v15743 == v15744;
                          if (v7470) {
                            this.advanceChar(2);
                            var v7466 = TypeScript$$16.staticTokens;
                            var v15745 = TypeScript$$16.TokenID;
                            var v7467 = v15745.PercentEquals;
                            return v7466[v7467];
                          } else {
                            this.nextChar();
                            var v7468 = TypeScript$$16.staticTokens;
                            var v15746 = TypeScript$$16.TokenID;
                            var v7469 = v15746.Percent;
                            return v7468[v7469];
                          }
                        ;
                        case TypeScript$$16.LexCodeLT:
                          var v23982 = this.pos;
                          var v20802 = v23982 + 1;
                          var v15747 = this.peekCharAt(v20802);
                          var v15748 = TypeScript$$16.LexCodeLT;
                          var v7481 = v15747 == v15748;
                          if (v7481) {
                            var v23983 = this.pos;
                            var v20803 = v23983 + 2;
                            var v15749 = this.peekCharAt(v20803);
                            var v15750 = TypeScript$$16.LexCodeEQ;
                            var v7475 = v15749 == v15750;
                            if (v7475) {
                              this.advanceChar(3);
                              var v7471 = TypeScript$$16.staticTokens;
                              var v15751 = TypeScript$$16.TokenID;
                              var v7472 = v15751.LessThanLessThanEquals;
                              return v7471[v7472];
                            } else {
                              this.advanceChar(2);
                              var v7473 = TypeScript$$16.staticTokens;
                              var v15752 = TypeScript$$16.TokenID;
                              var v7474 = v15752.LessThanLessThan;
                              return v7473[v7474];
                            }
                          } else {
                            var v23984 = this.pos;
                            var v20804 = v23984 + 1;
                            var v15753 = this.peekCharAt(v20804);
                            var v15754 = TypeScript$$16.LexCodeEQ;
                            var v7480 = v15753 == v15754;
                            if (v7480) {
                              this.advanceChar(2);
                              var v7476 = TypeScript$$16.staticTokens;
                              var v15755 = TypeScript$$16.TokenID;
                              var v7477 = v15755.LessThanEquals;
                              return v7476[v7477];
                            } else {
                              this.nextChar();
                              var v7478 = TypeScript$$16.staticTokens;
                              var v15756 = TypeScript$$16.TokenID;
                              var v7479 = v15756.LessThan;
                              return v7478[v7479];
                            }
                          }
                        ;
                        case TypeScript$$16.LexCodeGT:
                          var v23985 = this.pos;
                          var v20805 = v23985 + 1;
                          var v15757 = this.peekCharAt(v20805);
                          var v15758 = TypeScript$$16.LexCodeGT;
                          var v7498 = v15757 == v15758;
                          if (v7498) {
                            var v23986 = this.pos;
                            var v20806 = v23986 + 2;
                            var v15759 = this.peekCharAt(v20806);
                            var v15760 = TypeScript$$16.LexCodeEQ;
                            var v7492 = v15759 == v15760;
                            if (v7492) {
                              this.advanceChar(3);
                              var v7482 = TypeScript$$16.staticTokens;
                              var v15761 = TypeScript$$16.TokenID;
                              var v7483 = v15761.GreaterThanGreaterThanEquals;
                              return v7482[v7483];
                            } else {
                              var v23987 = this.pos;
                              var v20807 = v23987 + 2;
                              var v15762 = this.peekCharAt(v20807);
                              var v15763 = TypeScript$$16.LexCodeGT;
                              var v7491 = v15762 == v15763;
                              if (v7491) {
                                var v23988 = this.pos;
                                var v20808 = v23988 + 3;
                                var v15764 = this.peekCharAt(v20808);
                                var v15765 = TypeScript$$16.LexCodeEQ;
                                var v7488 = v15764 == v15765;
                                if (v7488) {
                                  this.advanceChar(4);
                                  var v7484 = TypeScript$$16.staticTokens;
                                  var v15766 = TypeScript$$16.TokenID;
                                  var v7485 = v15766.GreaterThanGreaterThanGreaterThanEquals;
                                  return v7484[v7485];
                                } else {
                                  this.advanceChar(3);
                                  var v7486 = TypeScript$$16.staticTokens;
                                  var v15767 = TypeScript$$16.TokenID;
                                  var v7487 = v15767.GreaterThanGreaterThanGreaterThan;
                                  return v7486[v7487];
                                }
                              } else {
                                this.advanceChar(2);
                                var v7489 = TypeScript$$16.staticTokens;
                                var v15768 = TypeScript$$16.TokenID;
                                var v7490 = v15768.GreaterThanGreaterThan;
                                return v7489[v7490];
                              }
                            }
                          } else {
                            var v23989 = this.pos;
                            var v20809 = v23989 + 1;
                            var v15769 = this.peekCharAt(v20809);
                            var v15770 = TypeScript$$16.LexCodeEQ;
                            var v7497 = v15769 == v15770;
                            if (v7497) {
                              this.advanceChar(2);
                              var v7493 = TypeScript$$16.staticTokens;
                              var v15771 = TypeScript$$16.TokenID;
                              var v7494 = v15771.GreaterThanEquals;
                              return v7493[v7494];
                            } else {
                              this.nextChar();
                              var v7495 = TypeScript$$16.staticTokens;
                              var v15772 = TypeScript$$16.TokenID;
                              var v7496 = v15772.GreaterThan;
                              return v7495[v7496];
                            }
                          }
                        ;
                        case TypeScript$$16.LexCodeXOR:
                          var v23990 = this.pos;
                          var v20810 = v23990 + 1;
                          var v15773 = this.peekCharAt(v20810);
                          var v15774 = TypeScript$$16.LexCodeEQ;
                          var v7503 = v15773 == v15774;
                          if (v7503) {
                            this.advanceChar(2);
                            var v7499 = TypeScript$$16.staticTokens;
                            var v15775 = TypeScript$$16.TokenID;
                            var v7500 = v15775.CaretEquals;
                            return v7499[v7500];
                          } else {
                            this.nextChar();
                            var v7501 = TypeScript$$16.staticTokens;
                            var v15776 = TypeScript$$16.TokenID;
                            var v7502 = v15776.Caret;
                            return v7501[v7502];
                          }
                        ;
                        case TypeScript$$16.LexCodeBAR:
                          var v23991 = this.pos;
                          var v20811 = v23991 + 1;
                          var v15777 = this.peekCharAt(v20811);
                          var v15778 = TypeScript$$16.LexCodeEQ;
                          var v7511 = v15777 == v15778;
                          if (v7511) {
                            this.advanceChar(2);
                            var v7504 = TypeScript$$16.staticTokens;
                            var v15779 = TypeScript$$16.TokenID;
                            var v7505 = v15779.BarEquals;
                            return v7504[v7505];
                          } else {
                            var v23992 = this.pos;
                            var v20812 = v23992 + 1;
                            var v15780 = this.peekCharAt(v20812);
                            var v15781 = TypeScript$$16.LexCodeBAR;
                            var v7510 = v15780 == v15781;
                            if (v7510) {
                              this.advanceChar(2);
                              var v7506 = TypeScript$$16.staticTokens;
                              var v15782 = TypeScript$$16.TokenID;
                              var v7507 = v15782.BarBar;
                              return v7506[v7507];
                            } else {
                              this.nextChar();
                              var v7508 = TypeScript$$16.staticTokens;
                              var v15783 = TypeScript$$16.TokenID;
                              var v7509 = v15783.Bar;
                              return v7508[v7509];
                            }
                          }
                        ;
                        case TypeScript$$16.LexCodeAMP:
                          var v23993 = this.pos;
                          var v20813 = v23993 + 1;
                          var v15784 = this.peekCharAt(v20813);
                          var v15785 = TypeScript$$16.LexCodeEQ;
                          var v7519 = v15784 == v15785;
                          if (v7519) {
                            this.advanceChar(2);
                            var v7512 = TypeScript$$16.staticTokens;
                            var v15786 = TypeScript$$16.TokenID;
                            var v7513 = v15786.AmpersandEquals;
                            return v7512[v7513];
                          } else {
                            var v23994 = this.pos;
                            var v20814 = v23994 + 1;
                            var v15787 = this.peekCharAt(v20814);
                            var v15788 = TypeScript$$16.LexCodeAMP;
                            var v7518 = v15787 == v15788;
                            if (v7518) {
                              this.advanceChar(2);
                              var v7514 = TypeScript$$16.staticTokens;
                              var v15789 = TypeScript$$16.TokenID;
                              var v7515 = v15789.AmpersandAmpersand;
                              return v7514[v7515];
                            } else {
                              this.nextChar();
                              var v7516 = TypeScript$$16.staticTokens;
                              var v15790 = TypeScript$$16.TokenID;
                              var v7517 = v15790.And;
                              return v7516[v7517];
                            }
                          }
                        ;
                        default:
                          this.reportScannerError("Invalid character");
                          this.nextChar();
                      }
                    }
                  }
                }
              }
            }
          }
        }
        var v15791 = this.pos;
        var v15792 = this.len;
        v7528 = v15791 < v15792;
      }
      var v7529 = TypeScript$$16.staticTokens;
      var v15793 = TypeScript$$16.TokenID;
      var v7530 = v15793.EndOfFile;
      return v7529[v7530];
    }
    function v671() {
      var hasEscape = false;
      var v7531 = this.ch;
      var v7532 = TypeScript$$16.LexCodeBSL;
      var isFirstChar = v7531 == v7532;
      var hasUnicode = false;
      for (;;) {
        var v23995 = this.ch;
        var v20815 = lexIdStartTable[v23995];
        var v23997 = !v20815;
        if (v23997) {
          var v23996 = this.ch;
          v20815 = LexIsDigit(v23996);
        }
        var v15794 = v20815;
        var v20817 = !v15794;
        if (v20817) {
          var v23998 = this.ch;
          var v23999 = TypeScript$$16.LexCodeASCIIChars;
          var v20816 = v23998 >= v23999;
          if (v20816) {
            v20816 = this.isValidUnicodeIdentifierChar();
          }
          v15794 = v20816;
        }
        var v7533 = v15794;
        for (;v7533;) {
          this.nextChar();
          var v24000 = this.ch;
          var v20818 = lexIdStartTable[v24000];
          var v24002 = !v20818;
          if (v24002) {
            var v24001 = this.ch;
            v20818 = LexIsDigit(v24001);
          }
          var v15795 = v20818;
          var v20820 = !v15795;
          if (v20820) {
            var v24003 = this.ch;
            var v24004 = TypeScript$$16.LexCodeASCIIChars;
            var v20819 = v24003 >= v24004;
            if (v20819) {
              v20819 = this.isValidUnicodeIdentifierChar();
            }
            v15795 = v20819;
          }
          v7533 = v15795;
        }
        var v15796 = this.ch;
        var v15797 = TypeScript$$16.LexCodeBSL;
        var v7545 = v15796 == v15797;
        if (v7545) {
          this.nextChar();
          var v15798 = this.ch;
          var v15799 = TypeScript$$16.LexCode_u;
          var v7542 = v15798 == v15799;
          if (v7542) {
            this.nextChar();
            var h$$4 = 0;
            var v7537 = h$$4 < 4;
            for (;v7537;) {
              var v15800 = this.ch;
              var v7536 = this.IsHexDigit(v15800);
              if (v7536) {
                this.nextChar();
              } else {
                this.reportScannerError("Invalid Unicode escape sequence");
                var v7534 = TypeScript$$16.staticTokens;
                var v15801 = TypeScript$$16.TokenID;
                var v7535 = v15801.Error;
                return v7534[v7535];
              }
              h$$4 = h$$4 + 1;
              v7537 = h$$4 < 4;
            }
            var v15802 = this.src;
            var v20821 = this.pos;
            var v15803 = v20821 - 4;
            var v15804 = this.pos;
            var v7538 = v15802.substring(v15803, v15804);
            var hexChar = parseInt(v7538, 16);
            var v20822 = lexIdStartTable[hexChar];
            var v24006 = !v20822;
            if (v24006) {
              var v24005 = !isFirstChar;
              if (v24005) {
                v24005 = LexIsDigit(hexChar);
              }
              v20822 = v24005;
            }
            var v15805 = v20822;
            var v20824 = !v15805;
            if (v20824) {
              var v24007 = TypeScript$$16.LexCodeASCIIChars;
              var v20823 = hexChar >= v24007;
              if (v20823) {
                var v24008 = LexIsUnicodeIdStart(hexChar);
                var v25537 = !v24008;
                if (v25537) {
                  var v25536 = !isFirstChar;
                  if (v25536) {
                    v25536 = LexIsUnicodeDigit(hexChar);
                  }
                  v24008 = v25536;
                }
                v20823 = v24008;
              }
              v15805 = v20823;
            }
            var v7541 = v15805;
            if (v7541) {
            } else {
              this.reportScannerError("Invalid identifier character");
              var v7539 = TypeScript$$16.staticTokens;
              var v15806 = TypeScript$$16.TokenID;
              var v7540 = v15806.Error;
              return v7539[v7540];
            }
            hasEscape = true;
            isFirstChar = false;
            continue;
          }
          this.reportScannerError("Invalid Unicode escape sequence");
          var v7543 = TypeScript$$16.staticTokens;
          var v15807 = TypeScript$$16.TokenID;
          var v7544 = v15807.Error;
          return v7543[v7544];
        }
        break;
      }
      var id$$16;
      var v7546 = this.src;
      var v7547 = this.startPos;
      var v7548 = this.pos;
      var text$$18 = v7546.substring(v7547, v7548);
      var v15808 = !hasEscape;
      if (v15808) {
        var v24009 = TypeScript$$16.LexKeywordTable;
        var v20825 = id$$16 = v24009.lookup(text$$18);
        v15808 = v20825 != null;
      }
      var v7551 = v15808;
      if (v7551) {
        var v7549 = TypeScript$$16.staticTokens;
        return v7549[id$$16];
      } else {
        var v7550 = TypeScript$$16.IdentifierToken;
        return new v7550(text$$18, hasEscape);
      }
      return;
    }
    function v670() {
      var endCode = this.ch;
      this.nextChar();
      scanStringConstantLoop: for (;;) {
        var v7560 = this.ch;
        switch(v7560) {
          case TypeScript$$16.LexEOF:
            this.reportScannerError("Unterminated string constant");
            break scanStringConstantLoop;
          case TypeScript$$16.LexCodeLS:
          ;
          case TypeScript$$16.LexCodePS:
            this.seenUnicodeChar = true;
          case TypeScript$$16.LexCodeRET:
          ;
          case TypeScript$$16.LexCodeNWL:
            this.reportScannerError("Unterminated string constant");
            break scanStringConstantLoop;
          case TypeScript$$16.LexCodeAPO:
          ;
          case TypeScript$$16.LexCodeQUO:
            var v15809 = this.ch;
            var v7552 = v15809 == endCode;
            if (v7552) {
              this.nextChar();
              break scanStringConstantLoop;
            }
            break;
          case TypeScript$$16.LexCodeBSL:
            this.nextChar();
            var v7559 = this.ch;
            switch(v7559) {
              case TypeScript$$16.LexCodeAPO:
              ;
              case TypeScript$$16.LexCodeQUO:
              ;
              case TypeScript$$16.LexCodeBSL:
                this.nextChar();
                continue scanStringConstantLoop;
              case TypeScript$$16.LexCodeLS:
              ;
              case TypeScript$$16.LexCodePS:
                this.seenUnicodeChar = true;
              case TypeScript$$16.LexCodeRET:
              ;
              case TypeScript$$16.LexCodeNWL:
                var v20826 = this.ch;
                var v20827 = TypeScript$$16.LexCodeRET;
                var v15810 = v20826 == v20827;
                if (v15810) {
                  var v25538 = this.pos;
                  var v24010 = v25538 + 1;
                  var v20828 = this.peekCharAt(v24010);
                  var v20829 = TypeScript$$16.LexCodeNWL;
                  v15810 = v20828 == v20829;
                }
                var v7553 = v15810;
                if (v7553) {
                  this.nextChar();
                }
                this.nextChar();
                this.newLine();
                var v15811 = this.mode;
                var v15812 = LexMode.Line;
                var v7555 = v15811 == v15812;
                if (v7555) {
                  var v7554;
                  var v20830 = TypeScript$$16.LexCodeAPO;
                  var v15813 = endCode == v20830;
                  if (v15813) {
                    v7554 = LexState.InMultilineSingleQuoteString;
                  } else {
                    v7554 = LexState.InMultilineDoubleQuoteString;
                  }
                  this.lexState = v7554;
                  break scanStringConstantLoop;
                }
                break;
              case TypeScript$$16.LexCode_x:
              ;
              case TypeScript$$16.LexCode_u:
                var v7556;
                var v20831 = this.ch;
                var v20832 = TypeScript$$16.LexCode_x;
                var v15814 = v20831 == v20832;
                if (v15814) {
                  v7556 = 2;
                } else {
                  v7556 = 4;
                }
                var expectedHexDigits = v7556;
                this.nextChar();
                var i$$54 = 0;
                var v7558 = i$$54 < expectedHexDigits;
                for (;v7558;) {
                  var v15815 = this.ch;
                  var v7557 = this.IsHexDigit(v15815);
                  if (v7557) {
                    this.nextChar();
                  } else {
                    this.reportScannerError("Invalid Unicode escape sequence");
                    break;
                  }
                  i$$54 = i$$54 + 1;
                  v7558 = i$$54 < expectedHexDigits;
                }
                continue scanStringConstantLoop;
            }
          ;
        }
        var v15816 = this.ch;
        var v15817 = TypeScript$$16.LexCodeASCIIChars;
        var v7561 = v15816 >= v15817;
        if (v7561) {
          this.seenUnicodeChar = true;
        }
        this.nextChar();
      }
      var v7562 = TypeScript$$16.StringLiteralToken;
      var v15818 = this.src;
      var v15819 = this.startPos;
      var v15820 = this.pos;
      var v7563 = v15818.substring(v15819, v15820);
      return new v7562(v7563);
    }
    function v669() {
      var v15821 = this.ch;
      var v7564 = LexIsUnicodeIdStart(v15821);
      var v15823 = !v7564;
      if (v15823) {
        var v15822 = this.ch;
        v7564 = LexIsUnicodeDigit(v15822);
      }
      var valid = v7564;
      var v7565 = this.seenUnicodeChar;
      var v15824 = !v7565;
      if (v15824) {
        v7565 = valid;
      }
      this.seenUnicodeChar = v7565;
      return valid;
    }
    function v668() {
      this.prevLine = this.line;
      var v27014 = this.innerScan();
      this.prevTok = v27014;
      var v7568 = this.saveScan;
      if (v7568) {
        var v7566 = this.saveScan;
        var v7567 = this.prevTok;
        v7566.addToken(v7567, this);
      }
      return this.prevTok;
    }
    function v667() {
      var v20833 = this.lexState;
      var v20834 = LexState.InMultilineComment;
      var v15825 = v20833 == v20834;
      if (v15825) {
        v15825 = this.scanComments;
      }
      var v7580 = v15825;
      if (v7580) {
        var v27015 = this.peekChar();
        this.ch = v27015;
        var commentLine = this.line;
        this.finishMultilineComment();
        var v15826 = this.startPos;
        var v15827 = this.pos;
        var v7577 = v15826 < v15827;
        if (v7577) {
          var v7569 = this.src;
          var v7570 = this.startPos;
          var v7571 = this.pos;
          var commentText$$1 = v7569.substring(v7570, v7571);
          this.tokenStart();
          var v7572 = TypeScript$$16.CommentToken;
          var v15828 = TypeScript$$16.TokenID;
          var v7573 = v15828.Comment;
          var v7574 = this.startPos;
          return new v7572(v7573, commentText$$1, true, v7574, commentLine, true);
        } else {
          var v7575 = TypeScript$$16.staticTokens;
          var v15829 = TypeScript$$16.TokenID;
          var v7576 = v15829.EndOfFile;
          return v7575[v7576];
        }
      } else {
        var v20835 = this.lexState;
        var v20836 = LexState.InMultilineSingleQuoteString;
        var v15830 = v20835 == v20836;
        if (v15830) {
          var v20837 = this.pos;
          var v20838 = this.len;
          v15830 = v20837 < v20838;
        }
        var v7579 = v15830;
        if (v7579) {
          this.ch = TypeScript$$16.LexCodeAPO;
          this.lexState = LexState.Start;
          return this.scanStringConstant();
        } else {
          var v20839 = this.lexState;
          var v20840 = LexState.InMultilineDoubleQuoteString;
          var v15831 = v20839 == v20840;
          if (v15831) {
            var v20841 = this.pos;
            var v20842 = this.len;
            v15831 = v20841 < v20842;
          }
          var v7578 = v15831;
          if (v7578) {
            this.ch = TypeScript$$16.LexCodeQUO;
            this.lexState = LexState.Start;
            return this.scanStringConstant();
          }
        }
      }
      this.prevLine = this.line;
      var prevTok$$1 = this.innerScan();
      var v15832 = prevTok$$1.tokenId;
      var v20843 = TypeScript$$16.TokenID;
      var v15833 = v20843.Whitespace;
      var v7581 = v15832 != v15833;
      if (v7581) {
        this.prevTok = prevTok$$1;
      }
      return prevTok$$1;
    }
    function v666() {
      var prevLine$$1 = this.prevLine;
      var line$$9 = this.line;
      var col = this.col;
      var pos$$2 = this.pos;
      var startPos$$1 = this.startPos;
      var startCol = this.startCol;
      var startLine$$41 = this.startLine;
      var ch = this.ch;
      var prevTok = this.prevTok;
      var lexState = this.lexState;
      var interveningWhitespace = this.interveningWhitespace;
      var interveningWhitespacePos = this.interveningWhitespacePos;
      var leftCurlyCount$$6 = this.leftCurlyCount;
      var rightCurlyCount$$6 = this.rightCurlyCount;
      var seenUnicodeChar = this.seenUnicodeChar;
      var seenUnicodeCharInComment = this.seenUnicodeCharInComment;
      var v7582 = this.commentStack;
      var commentStackLength = v7582.length;
      var lookAheadToken = this.scan();
      this.prevLine = prevLine$$1;
      this.line = line$$9;
      this.col = col;
      this.pos = pos$$2;
      this.startPos = startPos$$1;
      this.startCol = startCol;
      this.startLine = startLine$$41;
      this.ch = ch;
      this.prevTok = prevTok;
      this.lexState = lexState;
      this.interveningWhitespace = interveningWhitespace;
      this.interveningWhitespacePos = interveningWhitespacePos;
      this.leftCurlyCount = leftCurlyCount$$6;
      this.rightCurlyCount = rightCurlyCount$$6;
      this.seenUnicodeChar = seenUnicodeChar;
      this.seenUnicodeCharInComment = seenUnicodeCharInComment;
      var v7583 = this.commentStack;
      v7583.length = commentStackLength;
      return lookAheadToken;
    }
    function v665() {
      var v15834 = this.pos;
      this.pos = v15834 + 1;
      var v15835 = this.col;
      this.col = v15835 + 1;
      var v27016 = this.peekChar();
      this.ch = v27016;
      return;
    }
    function v664(amt) {
      var v15836 = this.pos;
      this.pos = v15836 + amt;
      var v15837 = this.col;
      this.col = v15837 + amt;
      var v27017 = this.peekChar();
      this.ch = v27017;
      return;
    }
    function v663() {
      var v7584;
      var v15838 = this.interveningWhitespace;
      if (v15838) {
        v7584 = this.interveningWhitespacePos;
      } else {
        v7584 = this.startPos;
      }
      return v7584;
    }
    function v662() {
      var v7585 = this.prevLine;
      var v7586 = this.startLine;
      return v7585 != v7586;
    }
    function v661() {
      var v20844 = TypeScript$$16.noRegexTable;
      var v24011 = this.prevTok;
      var v20845 = v24011.tokenId;
      var v15839 = v20844[v20845];
      var v7587 = v15839 != undefined;
      if (v7587) {
        return null;
      }
      var svPos$$2 = this.pos;
      var svCol$$1 = this.col;
      var index$$49 = this.findClosingSLH();
      var v7595 = index$$49 > 0;
      if (v7595) {
        var v7588 = this.src;
        var pattern$$1 = v7588.substring(svPos$$2, index$$49);
        var flags$$2 = "";
        this.pos = index$$49 + 1;
        var v27018 = this.peekChar();
        this.ch = v27018;
        var flagsStart = this.pos;
        var v24012 = this.ch;
        var v24013 = TypeScript$$16.LexCode_i;
        var v20846 = v24012 == v24013;
        var v24016 = !v20846;
        if (v24016) {
          var v24014 = this.ch;
          var v24015 = TypeScript$$16.LexCode_g;
          v20846 = v24014 == v24015;
        }
        var v15840 = v20846;
        var v20849 = !v15840;
        if (v20849) {
          var v20847 = this.ch;
          var v20848 = TypeScript$$16.LexCode_m;
          v15840 = v20847 == v20848;
        }
        var v7589 = v15840;
        for (;v7589;) {
          this.nextChar();
          var v24017 = this.ch;
          var v24018 = TypeScript$$16.LexCode_i;
          var v20850 = v24017 == v24018;
          var v24021 = !v20850;
          if (v24021) {
            var v24019 = this.ch;
            var v24020 = TypeScript$$16.LexCode_g;
            v20850 = v24019 == v24020;
          }
          var v15841 = v20850;
          var v20853 = !v15841;
          if (v20853) {
            var v20851 = this.ch;
            var v20852 = TypeScript$$16.LexCode_m;
            v15841 = v20851 == v20852;
          }
          v7589 = v15841;
        }
        var v20854 = this.pos;
        var v15842 = v20854 - flagsStart;
        var v7592 = v15842 > 3;
        if (v7592) {
          return null;
        } else {
          var v7590 = this.src;
          var v7591 = this.pos;
          flags$$2 = v7590.substring(flagsStart, v7591);
        }
        var regex$$2 = undefined;
        try {
          regex$$2 = new RegExp(pattern$$1, flags$$2);
        } catch (regexException) {
        }
        if (regex$$2) {
          var v15843 = this.pos;
          var v15844 = this.startPos;
          var v7593 = v15843 - v15844;
          this.col = svCol$$1 + v7593;
          var v7594 = TypeScript$$16.RegularExpressionLiteralToken;
          return new v7594(regex$$2);
        }
      }
      this.pos = svPos$$2;
      this.col = svCol$$1;
      return null;
    }
    function v660() {
      var index$$48 = this.pos;
      var v7596 = this.src;
      var ch2$$1 = v7596.charCodeAt(index$$48);
      var prevCh = 0;
      var liveEsc = false;
      var v20855 = this.endsLine(ch2$$1);
      var v15845 = !v20855;
      if (v15845) {
        var v20856 = this.len;
        v15845 = index$$48 < v20856;
      }
      var v7600 = v15845;
      for (;v7600;) {
        var v20857 = TypeScript$$16.LexCodeSLH;
        var v15846 = ch2$$1 == v20857;
        if (v15846) {
          v15846 = !liveEsc;
        }
        var v7597 = v15846;
        if (v7597) {
          return index$$48;
        }
        prevCh = ch2$$1;
        index$$48 = index$$48 + 1;
        if (liveEsc) {
          liveEsc = false;
        } else {
          var v7598 = TypeScript$$16.LexCodeBSL;
          liveEsc = prevCh == v7598;
        }
        var v7599 = this.src;
        ch2$$1 = v7599.charCodeAt(index$$48);
        var v20858 = this.endsLine(ch2$$1);
        var v15847 = !v20858;
        if (v15847) {
          var v20859 = this.len;
          v15847 = index$$48 < v20859;
        }
        v7600 = v15847;
      }
      return-1;
    }
    function v659() {
      var v7601 = this.src;
      var v7602 = this.startPos;
      var v7603 = this.pos;
      return v7601.substring(v7602, v7603);
    }
    function v658() {
      var v15848 = this.pos;
      var v15849 = this.len;
      var v7606 = v15848 < v15849;
      for (;v7606;) {
        var v15850 = this.ch;
        var v7604 = this.endsLine(v15850);
        if (v7604) {
          break;
        }
        var v15851 = this.ch;
        var v15852 = TypeScript$$16.LexCodeASCIIChars;
        var v7605 = v15851 >= v15852;
        if (v7605) {
          this.seenUnicodeCharInComment = true;
        }
        this.nextChar();
        var v15853 = this.pos;
        var v15854 = this.len;
        v7606 = v15853 < v15854;
      }
      var v15855 = this.mode;
      var v15856 = LexMode.File;
      var v7607 = v15855 == v15856;
      if (v7607) {
        this.tokenStart();
      }
      return;
    }
    function v657(c$$10) {
      var v24022 = TypeScript$$16.LexCodeNWL;
      var v20860 = c$$10 == v24022;
      var v24024 = !v20860;
      if (v24024) {
        var v24023 = TypeScript$$16.LexCodeRET;
        v20860 = c$$10 == v24023;
      }
      var v15857 = v20860;
      var v20862 = !v15857;
      if (v20862) {
        var v20861 = TypeScript$$16.LexCodeLS;
        v15857 = c$$10 == v20861;
      }
      var v7608 = v15857;
      var v15859 = !v7608;
      if (v15859) {
        var v15858 = TypeScript$$16.LexCodePS;
        v7608 = c$$10 == v15858;
      }
      return v7608;
    }
    function v656() {
      this.commentStack = [];
      return;
    }
    function v655(line$$8) {
      var comments$$9 = null;
      var v24025 = this.commentStack;
      var v20863 = v24025.length;
      var v15860 = v20863 > 0;
      if (v15860) {
        var v25539 = this.commentStack;
        var v24026 = v25539[0];
        var v20864 = v24026.line;
        v15860 = v20864 == line$$8;
      }
      var v7612 = v15860;
      for (;v7612;) {
        var v7611 = comments$$9 == null;
        if (v7611) {
          var v15861 = this.commentStack;
          var v7609 = v15861.shift();
          comments$$9 = [v7609];
        } else {
          var v20865 = this.commentStack;
          var v15862 = v20865.shift();
          var v7610 = [v15862];
          comments$$9 = comments$$9.concat(v7610);
        }
        var v24027 = this.commentStack;
        var v20866 = v24027.length;
        var v15863 = v20866 > 0;
        if (v15863) {
          var v25540 = this.commentStack;
          var v24028 = v25540[0];
          var v20867 = v24028.line;
          v15863 = v20867 == line$$8;
        }
        v7612 = v15863;
      }
      return comments$$9;
    }
    function v654() {
      var stack$$2 = this.commentStack;
      this.commentStack = [];
      return stack$$2;
    }
    function v653(comment$$4) {
      var v7613 = this.commentStack;
      v7613.push(comment$$4);
      return;
    }
    function v652() {
      var ch2;
      this.lexState = LexState.InMultilineComment;
      var v15864 = this.pos;
      var v15865 = this.len;
      var v7621 = v15864 < v15865;
      for (;v7621;) {
        var v15866 = this.ch;
        var v15867 = TypeScript$$16.LexCodeMUL;
        var v7620 = v15866 == v15867;
        if (v7620) {
          var v15868 = this.pos;
          var v7614 = v15868 + 1;
          ch2 = this.peekCharAt(v7614);
          var v15869 = TypeScript$$16.LexCodeSLH;
          var v7616 = ch2 == v15869;
          if (v7616) {
            this.advanceChar(2);
            var v15870 = this.mode;
            var v15871 = LexMode.File;
            var v7615 = v15870 == v15871;
            if (v7615) {
              this.tokenStart();
            }
            this.lexState = LexState.Start;
            return true;
          }
        } else {
          var v15872 = this.ch;
          var v15873 = TypeScript$$16.LexCodeNWL;
          var v7619 = v15872 == v15873;
          if (v7619) {
            this.newLine();
            var v15874 = this.mode;
            var v15875 = LexMode.Line;
            var v7617 = v15874 == v15875;
            if (v7617) {
              this.nextChar();
              return false;
            }
          } else {
            var v15876 = this.ch;
            var v15877 = TypeScript$$16.LexCodeASCIIChars;
            var v7618 = v15876 >= v15877;
            if (v7618) {
              this.seenUnicodeCharInComment = true;
            }
          }
        }
        this.nextChar();
        var v15878 = this.pos;
        var v15879 = this.len;
        v7621 = v15878 < v15879;
      }
      return false;
    }
    function v651() {
      this.col = 0;
      var v15880 = this.mode;
      var v15881 = LexMode.File;
      var v7624 = v15880 == v15881;
      if (v7624) {
        var v15882 = this.line;
        this.line = v15882 + 1;
        var v7622 = this.lineMap;
        var v7623 = this.line;
        var v15883 = this.pos;
        v7622[v7623] = v15883 + 1;
      }
      return;
    }
    function v650() {
      var v7625 = NumberScanState.InFraction;
      return this.scanDecimalNumber(v7625);
    }
    function v649() {
      var v15884 = this.peekChar();
      var v15885 = TypeScript$$16.LexCode_0;
      var v7629 = v15884 == v15885;
      if (v7629) {
        var v20868 = this.pos;
        var v15886 = v20868 + 1;
        var v7627 = this.peekCharAt(v15886);
        switch(v7627) {
          case TypeScript$$16.LexCode_x:
          ;
          case TypeScript$$16.LexCode_X:
            this.advanceChar(2);
            return this.scanHexDigits();
          case TypeScript$$16.LexCode_8:
          ;
          case TypeScript$$16.LexCode_9:
          ;
          case TypeScript$$16.LexCodeDOT:
            var v7626 = NumberScanState.Start;
            return this.scanDecimalNumber(v7626);
          default:
            return this.scanOctalDigits();
        }
      } else {
        var v7628 = NumberScanState.Start;
        return this.scanDecimalNumber(v7628);
      }
      return;
    }
    function v648(state$$4) {
      var atLeastOneDigit$$2 = false;
      var svPos$$1 = this.pos;
      var svCol = this.col;
      for (;;) {
        var v15887 = this.ch;
        var v7655 = LexIsDigit(v15887);
        if (v7655) {
          atLeastOneDigit$$2 = true;
          var v20869 = this.ch;
          var v20870 = TypeScript$$16.LexCode_0;
          var v15888 = v20869 != v20870;
          if (v15888) {
            var v20871 = NumberScanState.InEmptyFraction;
            v15888 = state$$4 == v20871;
          }
          var v7630 = v15888;
          if (v7630) {
            state$$4 = NumberScanState.InFraction;
          }
          this.nextChar();
        } else {
          var v15889 = this.ch;
          var v15890 = TypeScript$$16.LexCodeDOT;
          var v7654 = v15889 == v15890;
          if (v7654) {
            var v15891 = NumberScanState.Start;
            var v7634 = state$$4 == v15891;
            if (v7634) {
              this.nextChar();
              state$$4 = NumberScanState.InEmptyFraction;
            } else {
              if (atLeastOneDigit$$2) {
                var v7631 = TypeScript$$16.NumberLiteralToken;
                var v20872 = this.src;
                var v20873 = this.startPos;
                var v20874 = this.pos;
                var v15892 = v20872.substring(v20873, v20874);
                var v7632 = parseFloat(v15892);
                var v15893 = NumberScanState.InEmptyFraction;
                var v7633 = state$$4 == v15893;
                return new v7631(v7632, v7633);
              } else {
                this.pos = svPos$$1;
                this.col = svCol;
                return null;
              }
            }
          } else {
            var v20875 = this.ch;
            var v20876 = TypeScript$$16.LexCode_e;
            var v15894 = v20875 == v20876;
            var v20879 = !v15894;
            if (v20879) {
              var v20877 = this.ch;
              var v20878 = TypeScript$$16.LexCode_E;
              v15894 = v20877 == v20878;
            }
            var v7653 = v15894;
            if (v7653) {
              var v15895 = NumberScanState.Start;
              var v7638 = state$$4 == v15895;
              if (v7638) {
                if (atLeastOneDigit$$2) {
                  atLeastOneDigit$$2 = false;
                  this.nextChar();
                  state$$4 = NumberScanState.InExponent;
                } else {
                  this.pos = svPos$$1;
                  this.col = svCol;
                  return null;
                }
              } else {
                var v20880 = NumberScanState.InFraction;
                var v15896 = state$$4 == v20880;
                var v20882 = !v15896;
                if (v20882) {
                  var v20881 = NumberScanState.InEmptyFraction;
                  v15896 = state$$4 == v20881;
                }
                var v7637 = v15896;
                if (v7637) {
                  this.nextChar();
                  state$$4 = NumberScanState.InExponent;
                  atLeastOneDigit$$2 = false;
                } else {
                  if (atLeastOneDigit$$2) {
                    var v7635 = TypeScript$$16.NumberLiteralToken;
                    var v20883 = this.src;
                    var v20884 = this.startPos;
                    var v20885 = this.pos;
                    var v15897 = v20883.substring(v20884, v20885);
                    var v7636 = parseFloat(v15897);
                    return new v7635(v7636);
                  } else {
                    this.pos = svPos$$1;
                    this.col = svCol;
                    return null;
                  }
                }
              }
            } else {
              var v20886 = this.ch;
              var v20887 = TypeScript$$16.LexCodePLS;
              var v15898 = v20886 == v20887;
              var v20890 = !v15898;
              if (v20890) {
                var v20888 = this.ch;
                var v20889 = TypeScript$$16.LexCodeMIN;
                v15898 = v20888 == v20889;
              }
              var v7652 = v15898;
              if (v7652) {
                var v15899 = NumberScanState.InExponent;
                var v7647 = state$$4 == v15899;
                if (v7647) {
                  var v7639 = !atLeastOneDigit$$2;
                  if (v7639) {
                    this.nextChar();
                  } else {
                    this.pos = svPos$$1;
                    this.col = svCol;
                    return null;
                  }
                } else {
                  var v20891 = NumberScanState.InEmptyFraction;
                  var v15900 = state$$4 == v20891;
                  var v20893 = !v15900;
                  if (v20893) {
                    var v20892 = NumberScanState.InFraction;
                    v15900 = state$$4 == v20892;
                  }
                  var v7646 = v15900;
                  if (v7646) {
                    var v7640 = TypeScript$$16.NumberLiteralToken;
                    var v20894 = this.src;
                    var v20895 = this.startPos;
                    var v20896 = this.pos;
                    var v15901 = v20894.substring(v20895, v20896);
                    var v7641 = parseFloat(v15901);
                    var v15902 = NumberScanState.InEmptyFraction;
                    var v7642 = state$$4 == v15902;
                    return new v7640(v7641, v7642);
                  } else {
                    var v7645 = !atLeastOneDigit$$2;
                    if (v7645) {
                      this.pos = svPos$$1;
                      this.col = svCol;
                      return null;
                    } else {
                      var v7643 = TypeScript$$16.NumberLiteralToken;
                      var v20897 = this.src;
                      var v20898 = this.startPos;
                      var v20899 = this.pos;
                      var v15903 = v20897.substring(v20898, v20899);
                      var v7644 = parseFloat(v15903);
                      return new v7643(v7644);
                    }
                  }
                }
              } else {
                var v7651 = !atLeastOneDigit$$2;
                if (v7651) {
                  this.pos = svPos$$1;
                  this.col = svCol;
                  return null;
                } else {
                  var v7648 = TypeScript$$16.NumberLiteralToken;
                  var v20900 = this.src;
                  var v20901 = this.startPos;
                  var v20902 = this.pos;
                  var v15904 = v20900.substring(v20901, v20902);
                  var v7649 = parseFloat(v15904);
                  var v15905 = NumberScanState.InEmptyFraction;
                  var v7650 = state$$4 == v15905;
                  return new v7648(v7649, v7650);
                }
              }
            }
          }
        }
      }
      return;
    }
    function v647() {
      var atLeastOneDigit$$1 = false;
      for (;;) {
        var v15906 = this.ch;
        var v7658 = this.IsOctalDigit(v15906);
        if (v7658) {
          this.nextChar();
          atLeastOneDigit$$1 = true;
        } else {
          if (atLeastOneDigit$$1) {
            var v7656 = TypeScript$$16.NumberLiteralToken;
            var v20903 = this.src;
            var v20904 = this.startPos;
            var v20905 = this.pos;
            var v15907 = v20903.substring(v20904, v20905);
            var v7657 = parseInt(v15907);
            return new v7656(v7657);
          } else {
            return null;
          }
        }
      }
      return;
    }
    function v646() {
      var atLeastOneDigit = false;
      for (;;) {
        var v15908 = this.ch;
        var v7661 = this.IsHexDigit(v15908);
        if (v7661) {
          this.nextChar();
          atLeastOneDigit = true;
        } else {
          if (atLeastOneDigit) {
            var v7659 = TypeScript$$16.NumberLiteralToken;
            var v20906 = this.src;
            var v20907 = this.startPos;
            var v20908 = this.pos;
            var v15909 = v20906.substring(v20907, v20908);
            var v7660 = parseInt(v15909);
            return new v7659(v7660);
          } else {
            return null;
          }
        }
      }
      return;
    }
    function v645(c$$9) {
      var v20909 = TypeScript$$16.LexCode_0;
      var v15910 = c$$9 >= v20909;
      if (v15910) {
        var v20910 = TypeScript$$16.LexCode_7;
        v15910 = c$$9 <= v20910;
      }
      var v7662 = v15910;
      var v15912 = !v7662;
      if (v15912) {
        var v20911 = TypeScript$$16.LexCode_a;
        var v15911 = c$$9 >= v20911;
        if (v15911) {
          var v20912 = TypeScript$$16.LexCode_f;
          v15911 = c$$9 <= v20912;
        }
        v7662 = v15911;
      }
      return v7662;
    }
    function v644(c$$8) {
      var v24029 = TypeScript$$16.LexCode_0;
      var v20913 = c$$8 >= v24029;
      if (v20913) {
        var v24030 = TypeScript$$16.LexCode_9;
        v20913 = c$$8 <= v24030;
      }
      var v15913 = v20913;
      var v20915 = !v15913;
      if (v20915) {
        var v24031 = TypeScript$$16.LexCode_A;
        var v20914 = c$$8 >= v24031;
        if (v20914) {
          var v24032 = TypeScript$$16.LexCode_F;
          v20914 = c$$8 <= v24032;
        }
        v15913 = v20914;
      }
      var v7663 = v15913;
      var v15915 = !v7663;
      if (v15915) {
        var v20916 = TypeScript$$16.LexCode_a;
        var v15914 = c$$8 >= v20916;
        if (v15914) {
          var v20917 = TypeScript$$16.LexCode_f;
          v15914 = c$$8 <= v20917;
        }
        v7663 = v15914;
      }
      return v7663;
    }
    function v643(index$$47) {
      var v15916 = this.len;
      var v7665 = index$$47 < v15916;
      if (v7665) {
        var v7664 = this.src;
        return v7664.charCodeAt(index$$47);
      } else {
        return TypeScript$$16.LexEOF;
      }
      return;
    }
    function v642() {
      var v15917 = this.pos;
      var v15918 = this.len;
      var v7668 = v15917 < v15918;
      if (v7668) {
        var v7666 = this.src;
        var v7667 = this.pos;
        return v7666.charCodeAt(v7667);
      } else {
        return TypeScript$$16.LexEOF;
      }
      return;
    }
    function v641() {
      this.startPos = this.pos;
      this.startLine = this.line;
      this.startCol = this.col;
      this.interveningWhitespace = false;
      return;
    }
    function v640() {
      return this.lexState;
    }
    function v639(value$$34) {
      this.scanComments = value$$34;
      return;
    }
    function v638(newSrc$$2, textMode$$2) {
      var v7669 = new StringSourceText(newSrc$$2);
      this.setSourceText(v7669, textMode$$2);
      return;
    }
    function v637(savedTokens) {
      this.saveScan = savedTokens;
      return;
    }
    function v636(reportError$$1) {
      this.reportError = reportError$$1;
      return;
    }
    function v635(newSrc$$1, textMode$$1) {
      this.mode = textMode$$1;
      var v7670 = this.mode;
      var v7671 = LexMode.Line;
      this.scanComments = v7670 === v7671;
      this.pos = 0;
      this.interveningWhitespacePos = 0;
      this.startPos = 0;
      this.line = 1;
      this.col = 0;
      this.startCol = this.col;
      this.startLine = this.line;
      this.len = 0;
      var v7672 = newSrc$$1.getLength();
      var v27019 = newSrc$$1.getText(0, v7672);
      this.src = v27019;
      var v7673 = this.src;
      this.len = v7673.length;
      this.lineMap = [];
      var v7674 = this.lineMap;
      v7674[1] = 0;
      this.commentStack = [];
      this.leftCurlyCount = 0;
      this.rightCurlyCount = 0;
      this.seenUnicodeChar = false;
      this.seenUnicodeCharInComment = false;
      return;
    }
    function v634() {
      return this.prevTok;
    }
    function Scanner$$1() {
      this.prevLine = 1;
      this.line = 1;
      this.col = 0;
      this.pos = 0;
      this.startPos = 0;
      this.len = 0;
      this.lineMap = [];
      this.ch = TypeScript$$16.LexEOF;
      this.lexState = LexState.Start;
      this.mode = LexMode.File;
      this.scanComments = true;
      this.interveningWhitespace = false;
      this.interveningWhitespacePos = 0;
      this.leftCurlyCount = 0;
      this.rightCurlyCount = 0;
      var v27020 = new Array;
      this.commentStack = v27020;
      this.saveScan = null;
      this.seenUnicodeChar = false;
      this.seenUnicodeCharInComment = false;
      var v7675 = TypeScript$$16.staticTokens;
      var v15919 = TypeScript$$16.TokenID;
      var v7676 = v15919.EndOfFile;
      this.prevTok = v7675[v7676];
      this.startCol = this.col;
      this.startLine = this.line;
      var v7677 = this.lineMap;
      v7677[1] = 0;
      var v15920 = TypeScript$$16.LexKeywordTable;
      var v7678 = !v15920;
      if (v7678) {
        LexInitialize();
      }
      return;
    }
    var v7679 = Scanner$$1.prototype;
    v7679.previousToken = v634;
    var v7680 = Scanner$$1.prototype;
    v7680.setSourceText = v635;
    var v7681 = Scanner$$1.prototype;
    v7681.setErrorHandler = v636;
    var v7682 = Scanner$$1.prototype;
    v7682.setSaveScan = v637;
    var v7683 = Scanner$$1.prototype;
    v7683.setText = v638;
    var v7684 = Scanner$$1.prototype;
    v7684.setScanComments = v639;
    var v7685 = Scanner$$1.prototype;
    v7685.getLexState = v640;
    var v7686 = Scanner$$1.prototype;
    v7686.tokenStart = v641;
    var v7687 = Scanner$$1.prototype;
    v7687.peekChar = v642;
    var v7688 = Scanner$$1.prototype;
    v7688.peekCharAt = v643;
    var v7689 = Scanner$$1.prototype;
    v7689.IsHexDigit = v644;
    var v7690 = Scanner$$1.prototype;
    v7690.IsOctalDigit = v645;
    var v7691 = Scanner$$1.prototype;
    v7691.scanHexDigits = v646;
    var v7692 = Scanner$$1.prototype;
    v7692.scanOctalDigits = v647;
    var v7693 = Scanner$$1.prototype;
    v7693.scanDecimalNumber = v648;
    var v7694 = Scanner$$1.prototype;
    v7694.scanNumber = v649;
    var v7695 = Scanner$$1.prototype;
    v7695.scanFraction = v650;
    var v7696 = Scanner$$1.prototype;
    v7696.newLine = v651;
    var v7697 = Scanner$$1.prototype;
    v7697.finishMultilineComment = v652;
    var v7698 = Scanner$$1.prototype;
    v7698.pushComment = v653;
    var v7699 = Scanner$$1.prototype;
    v7699.getComments = v654;
    var v7700 = Scanner$$1.prototype;
    v7700.getCommentsForLine = v655;
    var v7701 = Scanner$$1.prototype;
    v7701.resetComments = v656;
    var v7702 = Scanner$$1.prototype;
    v7702.endsLine = v657;
    var v7703 = Scanner$$1.prototype;
    v7703.finishSinglelineComment = v658;
    var v7704 = Scanner$$1.prototype;
    v7704.tokenText = v659;
    var v7705 = Scanner$$1.prototype;
    v7705.findClosingSLH = v660;
    var v7706 = Scanner$$1.prototype;
    v7706.speculateRegex = v661;
    var v7707 = Scanner$$1.prototype;
    v7707.lastTokenHadNewline = v662;
    var v7708 = Scanner$$1.prototype;
    v7708.lastTokenLimChar = v663;
    var v7709 = Scanner$$1.prototype;
    v7709.advanceChar = v664;
    var v7710 = Scanner$$1.prototype;
    v7710.nextChar = v665;
    var v7711 = Scanner$$1.prototype;
    v7711.getLookAheadToken = v666;
    var v7712 = Scanner$$1.prototype;
    v7712.scanInLine = v667;
    var v7713 = Scanner$$1.prototype;
    v7713.scan = v668;
    var v7714 = Scanner$$1.prototype;
    v7714.isValidUnicodeIdentifierChar = v669;
    var v7715 = Scanner$$1.prototype;
    v7715.scanStringConstant = v670;
    var v7716 = Scanner$$1.prototype;
    v7716.scanIdentifier = v671;
    var v7717 = Scanner$$1.prototype;
    v7717.innerScan = v672;
    var v7718 = Scanner$$1.prototype;
    v7718.reportScannerError = v673;
    return Scanner$$1;
  }
  function v633() {
    function v632() {
      throw new Error("Invalid operation.");
    }
    function v631(reportError) {
      return;
    }
    function v630(newSrc, textMode) {
      return;
    }
    function v629() {
      this.commentStack = [];
      return;
    }
    function v628(line$$7) {
      var comments$$8 = null;
      var v24033 = this.commentStack;
      var v20918 = v24033.length;
      var v15921 = v20918 > 0;
      if (v15921) {
        var v25541 = this.commentStack;
        var v24034 = v25541[0];
        var v20919 = v24034.line;
        v15921 = v20919 == line$$7;
      }
      var v7722 = v15921;
      for (;v7722;) {
        var v7721 = comments$$8 == null;
        if (v7721) {
          var v15922 = this.commentStack;
          var v7719 = v15922.shift();
          comments$$8 = [v7719];
        } else {
          var v20920 = this.commentStack;
          var v15923 = v20920.shift();
          var v7720 = [v15923];
          comments$$8 = comments$$8.concat(v7720);
        }
        var v24035 = this.commentStack;
        var v20921 = v24035.length;
        var v15924 = v20921 > 0;
        if (v15924) {
          var v25542 = this.commentStack;
          var v24036 = v25542[0];
          var v20922 = v24036.line;
          v15924 = v20922 == line$$7;
        }
        v7722 = v15924;
      }
      return comments$$8;
    }
    function v627() {
      var stack$$1 = this.commentStack;
      this.commentStack = [];
      return stack$$1;
    }
    function v626(comment$$3) {
      var v7723 = this.commentStack;
      v7723.push(comment$$3);
      return;
    }
    function v625() {
      var v7724 = this.prevLine;
      var v7725 = this.startLine;
      return v7724 != v7725;
    }
    function v624() {
      var v15925 = this.prevSavedToken;
      var v7727 = v15925 !== null;
      if (v7727) {
        var v7726 = this.prevSavedToken;
        return v7726.limChar;
      } else {
        return 0;
      }
      return;
    }
    function v623(offset$$8) {
      var v7728 = this.lineMap;
      var v27021 = getLineNumberFromPosition(v7728, offset$$8);
      this.line = v27021;
      this.currentTokenIndex = 0;
      var v15926 = this.lineMap;
      var v15927 = this.line;
      var v7729 = v15926[v15927];
      var tmpCol = offset$$8 - v7729;
      var v24037 = this.lexStateByLine;
      var v24038 = this.line;
      var v20923 = v24037[v24038];
      var v20924 = LexState.InMultilineComment;
      var v15928 = v20923 == v20924;
      if (v15928) {
        var v20925 = this.line;
        v15928 = v20925 > 0;
      }
      var v7730 = v15928;
      for (;v7730;) {
        var v15929 = this.line;
        this.line = v15929 - 1;
        tmpCol = 0;
        var v24039 = this.lexStateByLine;
        var v24040 = this.line;
        var v20926 = v24039[v24040];
        var v20927 = LexState.InMultilineComment;
        var v15930 = v20926 == v20927;
        if (v15930) {
          var v20928 = this.line;
          v15930 = v20928 > 0;
        }
        v7730 = v15930;
      }
      var v15931 = this.lineMap;
      var v7731 = v15931.length;
      var lenMin1 = v7731 - 1;
      var v7732 = this.tokensByLine;
      var v7733 = this.line;
      this.currentTokens = v7732[v7733];
      var v24041 = this.currentTokens;
      var v20929 = v24041.length;
      var v15932 = v20929 == 0;
      if (v15932) {
        var v20930 = this.line;
        v15932 = v20930 < lenMin1;
      }
      var v7736 = v15932;
      for (;v7736;) {
        var v15933 = this.line;
        this.line = v15933 + 1;
        var v7734 = this.tokensByLine;
        var v7735 = this.line;
        this.currentTokens = v7734[v7735];
        tmpCol = 0;
        var v24042 = this.currentTokens;
        var v20931 = v24042.length;
        var v15934 = v20931 == 0;
        if (v15934) {
          var v20932 = this.line;
          v15934 = v20932 < lenMin1;
        }
        v7736 = v15934;
      }
      var v15935 = this.line;
      var v7742 = v15935 <= lenMin1;
      if (v7742) {
        var v20933 = this.currentTokenIndex;
        var v24043 = this.currentTokens;
        var v20934 = v24043.length;
        var v15936 = v20933 < v20934;
        if (v15936) {
          var v25543 = this.currentTokens;
          var v25544 = this.currentTokenIndex;
          var v24044 = v25543[v25544];
          var v20935 = v24044.limChar;
          v15936 = tmpCol > v20935;
        }
        var v7737 = v15936;
        for (;v7737;) {
          var v15937 = this.currentTokenIndex;
          this.currentTokenIndex = v15937 + 1;
          var v20936 = this.currentTokenIndex;
          var v24045 = this.currentTokens;
          var v20937 = v24045.length;
          var v15938 = v20936 < v20937;
          if (v15938) {
            var v25545 = this.currentTokens;
            var v25546 = this.currentTokenIndex;
            var v24046 = v25545[v25546];
            var v20938 = v24046.limChar;
            v15938 = tmpCol > v20938;
          }
          v7737 = v15938;
        }
        var v15939 = this.currentTokenIndex;
        var v20939 = this.currentTokens;
        var v15940 = v20939.length;
        var v7741 = v15939 < v15940;
        if (v7741) {
          var v15941 = this.currentTokens;
          var v15942 = this.currentTokenIndex;
          var v7738 = v15941[v15942];
          this.col = v7738.minChar;
          var v7739 = this.col;
          var v15943 = this.lineMap;
          var v15944 = this.line;
          var v7740 = v15943[v15944];
          return v7739 + v7740;
        }
      }
      return-1;
    }
    function v622() {
      this.startLine = this.line;
      this.startPos = this.col;
      var v15945 = this.currentTokenIndex;
      var v20940 = this.currentTokens;
      var v15946 = v20940.length;
      var v7748 = v15945 == v15946;
      if (v7748) {
        var v15947 = this.line;
        var v20941 = this.lineMap;
        var v15948 = v20941.length;
        var v7747 = v15947 < v15948;
        if (v7747) {
          var v15949 = this.line;
          this.line = v15949 + 1;
          this.col = 0;
          this.currentTokenIndex = 0;
          var v7743 = this.tokensByLine;
          var v7744 = this.line;
          this.currentTokens = v7743[v7744];
        } else {
          var v7745 = TypeScript$$16.staticTokens;
          var v15950 = TypeScript$$16.TokenID;
          var v7746 = v15950.EndOfFile;
          return v7745[v7746];
        }
      }
      var v15951 = this.currentTokenIndex;
      var v20942 = this.currentTokens;
      var v15952 = v20942.length;
      var v7757 = v15951 < v15952;
      if (v7757) {
        var v7749 = this.curSavedToken;
        this.prevToken = v7749.tok;
        this.prevSavedToken = this.curSavedToken;
        var v7750 = this.currentTokens;
        var v7751 = this.currentTokenIndex;
        var v20943 = this.currentTokenIndex;
        this.currentTokenIndex = v20943 + 1;
        this.curSavedToken = v7750[v7751];
        var v7752 = this.curSavedToken;
        var curToken = v7752.tok;
        var v7753 = this.curSavedToken;
        this.pos = v7753.limChar;
        var v15953 = this.col;
        var v24047 = this.curSavedToken;
        var v20944 = v24047.limChar;
        var v24048 = this.curSavedToken;
        var v20945 = v24048.minChar;
        var v15954 = v20944 - v20945;
        this.col = v15953 + v15954;
        var v7754 = this.curSavedToken;
        this.startPos = v7754.minChar;
        this.prevLine = this.line;
        return curToken;
      } else {
        var v7755 = TypeScript$$16.staticTokens;
        var v15955 = TypeScript$$16.TokenID;
        var v7756 = v15955.EndOfFile;
        return v7755[v7756];
      }
      return;
    }
    function v621(tok$$3, scanner) {
      var v7758 = this.tokens;
      var v7759 = this.currentToken;
      var v20946 = this.currentToken;
      this.currentToken = v20946 + 1;
      var v15956 = TypeScript$$16.SavedToken;
      var v15957 = scanner.startPos;
      var v15958 = scanner.pos;
      var v27022 = new v15956(tok$$3, v15957, v15958);
      v7758[v7759] = v27022;
      return;
    }
    function v620() {
      this.currentToken = 0;
      return;
    }
    function v619() {
      return this.prevToken;
    }
    function SavedTokens$$1() {
      this.prevToken = null;
      this.curSavedToken = null;
      this.prevSavedToken = null;
      this.prevToken = null;
      this.currentToken = 0;
      var v27023 = new Array;
      this.tokens = v27023;
      this.seenUnicodeChar = false;
      this.seenUnicodeCharInComment = false;
      this.prevLine = 1;
      this.line = 1;
      this.col = 0;
      this.lexState = LexState.Start;
      var v27024 = new Array;
      this.commentStack = v27024;
      this.lineMap = [];
      return;
    }
    var v7760 = SavedTokens$$1.prototype;
    v7760.previousToken = v619;
    var v7761 = SavedTokens$$1.prototype;
    v7761.close = v620;
    var v7762 = SavedTokens$$1.prototype;
    v7762.addToken = v621;
    var v7763 = SavedTokens$$1.prototype;
    v7763.scan = v622;
    var v7764 = SavedTokens$$1.prototype;
    v7764.syncToTok = v623;
    var v7765 = SavedTokens$$1.prototype;
    v7765.lastTokenLimChar = v624;
    var v7766 = SavedTokens$$1.prototype;
    v7766.lastTokenHadNewline = v625;
    var v7767 = SavedTokens$$1.prototype;
    v7767.pushComment = v626;
    var v7768 = SavedTokens$$1.prototype;
    v7768.getComments = v627;
    var v7769 = SavedTokens$$1.prototype;
    v7769.getCommentsForLine = v628;
    var v7770 = SavedTokens$$1.prototype;
    v7770.resetComments = v629;
    var v7771 = SavedTokens$$1.prototype;
    v7771.setSourceText = v630;
    var v7772 = SavedTokens$$1.prototype;
    v7772.setErrorHandler = v631;
    var v7773 = SavedTokens$$1.prototype;
    v7773.getLookAheadToken = v632;
    return SavedTokens$$1;
  }
  function v618() {
    function v617(start$$11, end$$5) {
      var v7774 = this.fetchSegment(start$$11, end$$5);
      return v7774.substring(start$$11, end$$5);
    }
    function v616(index$$46) {
      var v15959 = index$$46 + 1;
      var v7775 = this.fetchSegment(index$$46, v15959);
      return v7775.charCodeAt(index$$46);
    }
    function v615(start$$10, end$$4) {
      var v25547 = this.agg;
      var v24049 = v25547.seg1;
      var v20947 = v24049.segmentStart;
      var v15960 = v20947 <= start$$10;
      if (v15960) {
        var v25548 = this.agg;
        var v24050 = v25548.seg1;
        var v20948 = v24050.segmentEnd;
        v15960 = end$$4 <= v20948;
      }
      var v7777 = v15960;
      if (v7777) {
        var v7776 = this.agg;
        return v7776.seg1;
      }
      var v25549 = this.agg;
      var v24051 = v25549.seg2;
      var v20949 = v24051.segmentStart;
      var v15961 = v20949 <= start$$10;
      if (v15961) {
        var v25550 = this.agg;
        var v24052 = v25550.seg1;
        var v20950 = v24052.segmentEnd;
        v15961 = end$$4 <= v20950;
      }
      var v7778 = v15961;
      if (v7778) {
        return this.agg;
      }
      var v7779 = this.agg;
      var prev = v7779.seg1;
      var s$$16 = prev.segmentEnd;
      var v7780 = s$$16 + 512;
      var e$$9 = TypeScript$$16.max(v7780, end$$4);
      var v7781 = this.len;
      e$$9 = TypeScript$$16.min(e$$9, v7781);
      var v7782 = this.sourceText;
      var src$$1 = v7782.getText(s$$16, e$$9);
      var newSeg = new SourceTextSegment(s$$16, e$$9, src$$1);
      var v7783 = this.agg;
      v7783.seg2 = prev;
      var v7784 = this.agg;
      v7784.seg1 = newSeg;
      return this.agg;
    }
    function v614(a$$5, b$$4) {
      var v7785;
      var v15962 = a$$5 <= b$$4;
      if (v15962) {
        v7785 = a$$5;
      } else {
        v7785 = b$$4;
      }
      return v7785;
    }
    function v613(a$$4, b$$3) {
      var v7786;
      var v15963 = a$$4 >= b$$3;
      if (v15963) {
        v7786 = a$$4;
      } else {
        v7786 = b$$3;
      }
      return v7786;
    }
    function ScannerTextStream$$1(sourceText$$3) {
      this.sourceText = sourceText$$3;
      var v7787 = ScannerTextStream$$1.emptySegment;
      var v7788 = ScannerTextStream$$1.emptySegment;
      var v27025 = new AggerateSourceTextSegment(v7787, v7788);
      this.agg = v27025;
      var v7789 = this.sourceText;
      var v27026 = v7789.getLength();
      this.len = v27026;
      return;
    }
    var v7790 = ScannerTextStream$$1;
    var v27027 = new SourceTextSegment(0, 0, "");
    v7790.emptySegment = v27027;
    var v7791 = ScannerTextStream$$1.prototype;
    v7791.max = v613;
    var v7792 = ScannerTextStream$$1.prototype;
    v7792.min = v614;
    var v7793 = ScannerTextStream$$1.prototype;
    v7793.fetchSegment = v615;
    var v7794 = ScannerTextStream$$1.prototype;
    v7794.charCodeAt = v616;
    var v7795 = ScannerTextStream$$1.prototype;
    v7795.substring = v617;
    return ScannerTextStream$$1;
  }
  function v612() {
    function v611(start$$9, end$$3) {
      var v24053 = this.seg1;
      var v20951 = v24053.segmentStart;
      var v15964 = v20951 <= start$$9;
      if (v15964) {
        var v24054 = this.seg1;
        var v20952 = v24054.segmentEnd;
        v15964 = end$$3 <= v20952;
      }
      var v7799 = v15964;
      if (v7799) {
        var v15965 = this.seg1;
        var v7796 = v15965.segment;
        var v20953 = this.seg1;
        var v15966 = v20953.segmentStart;
        var v7797 = start$$9 - v15966;
        var v20954 = this.seg1;
        var v15967 = v20954.segmentStart;
        var v7798 = end$$3 - v15967;
        return v7796.substring(v7797, v7798);
      }
      var v20955 = this.seg2;
      var v15968 = v20955.segment;
      var v24055 = this.seg2;
      var v20956 = v24055.segmentStart;
      var v15969 = start$$9 - v20956;
      var v7800 = v15968.substring(v15969);
      var v20957 = this.seg1;
      var v15970 = v20957.segment;
      var v24056 = this.seg1;
      var v20958 = v24056.segmentStart;
      var v15971 = end$$3 - v20958;
      var v7801 = v15970.substring(0, v15971);
      return v7800 + v7801;
    }
    function v610(index$$45) {
      var v24057 = this.seg1;
      var v20959 = v24057.segmentStart;
      var v15972 = v20959 <= index$$45;
      if (v15972) {
        var v24058 = this.seg1;
        var v20960 = v24058.segmentEnd;
        v15972 = index$$45 < v20960;
      }
      var v7804 = v15972;
      if (v7804) {
        var v15973 = this.seg1;
        var v7802 = v15973.segment;
        var v20961 = this.seg1;
        var v15974 = v20961.segmentStart;
        var v7803 = index$$45 - v15974;
        return v7802.charCodeAt(v7803);
      }
      var v15975 = this.seg2;
      var v7805 = v15975.segment;
      var v20962 = this.seg2;
      var v15976 = v20962.segmentStart;
      var v7806 = index$$45 - v15976;
      return v7805.charCodeAt(v7806);
    }
    function AggerateSourceTextSegment$$1(seg1, seg2) {
      this.seg1 = seg1;
      this.seg2 = seg2;
      return;
    }
    var v7807 = AggerateSourceTextSegment$$1.prototype;
    v7807.charCodeAt = v610;
    var v7808 = AggerateSourceTextSegment$$1.prototype;
    v7808.substring = v611;
    return AggerateSourceTextSegment$$1;
  }
  function v609() {
    function v608(start$$8, end$$2) {
      var v7809 = this.segment;
      var v15977 = this.segmentStart;
      var v7810 = start$$8 - v15977;
      var v15978 = this.segmentStart;
      var v7811 = end$$2 - v15978;
      return v7809.substring(v7810, v7811);
    }
    function v607(index$$44) {
      var v7812 = this.segment;
      var v15979 = this.segmentStart;
      var v7813 = index$$44 - v15979;
      return v7812.charCodeAt(v7813);
    }
    function SourceTextSegment$$1(segmentStart, segmentEnd, segment) {
      this.segmentStart = segmentStart;
      this.segmentEnd = segmentEnd;
      this.segment = segment;
      return;
    }
    var v7814 = SourceTextSegment$$1.prototype;
    v7814.charCodeAt = v607;
    var v7815 = SourceTextSegment$$1.prototype;
    v7815.substring = v608;
    return SourceTextSegment$$1;
  }
  function v606() {
    function v605() {
      var v7816 = this.text;
      return v7816.length;
    }
    function v604(start$$7, end$$1) {
      var v7817 = this.text;
      return v7817.substring(start$$7, end$$1);
    }
    function StringSourceText$$1(text$$17) {
      this.text = text$$17;
      return;
    }
    var v7818 = StringSourceText$$1.prototype;
    v7818.getText = v604;
    var v7819 = StringSourceText$$1.prototype;
    v7819.getLength = v605;
    return StringSourceText$$1;
  }
  function v603(CommentStyle$$1) {
    CommentStyle$$1._map = [];
    var v7820 = CommentStyle$$1._map;
    v7820[0] = "Line";
    CommentStyle$$1.Line = 0;
    var v7821 = CommentStyle$$1._map;
    v7821[1] = "Block";
    CommentStyle$$1.Block = 1;
    return;
  }
  function v602(LexMode$$1) {
    LexMode$$1._map = [];
    var v7822 = LexMode$$1._map;
    v7822[0] = "Line";
    LexMode$$1.Line = 0;
    var v7823 = LexMode$$1._map;
    v7823[1] = "File";
    LexMode$$1.File = 1;
    return;
  }
  function v601(LexState$$1) {
    LexState$$1._map = [];
    var v7824 = LexState$$1._map;
    v7824[0] = "Start";
    LexState$$1.Start = 0;
    var v7825 = LexState$$1._map;
    v7825[1] = "InMultilineComment";
    LexState$$1.InMultilineComment = 1;
    var v7826 = LexState$$1._map;
    v7826[2] = "InMultilineSingleQuoteString";
    LexState$$1.InMultilineSingleQuoteString = 2;
    var v7827 = LexState$$1._map;
    v7827[3] = "InMultilineDoubleQuoteString";
    LexState$$1.InMultilineDoubleQuoteString = 3;
    return;
  }
  function v600(NumberScanState$$1) {
    NumberScanState$$1._map = [];
    var v7828 = NumberScanState$$1._map;
    v7828[0] = "Start";
    NumberScanState$$1.Start = 0;
    var v7829 = NumberScanState$$1._map;
    v7829[1] = "InFraction";
    NumberScanState$$1.InFraction = 1;
    var v7830 = NumberScanState$$1._map;
    v7830[2] = "InEmptyFraction";
    NumberScanState$$1.InEmptyFraction = 2;
    var v7831 = NumberScanState$$1._map;
    v7831[3] = "InExponent";
    NumberScanState$$1.InExponent = 3;
    return;
  }
  function LexLookUpUnicodeMap(code$$2, map$$1) {
    var lo = 0;
    var hi = map$$1.length;
    var mid;
    var v15980 = lo + 1;
    var v7835 = v15980 < hi;
    for (;v7835;) {
      var v15981 = hi - lo;
      var v7832 = v15981 / 2;
      mid = lo + v7832;
      var v15982 = mid % 2;
      mid = mid - v15982;
      var v20963 = map$$1[mid];
      var v15983 = v20963 <= code$$2;
      if (v15983) {
        var v24059 = mid + 1;
        var v20964 = map$$1[v24059];
        v15983 = code$$2 <= v20964;
      }
      var v7833 = v15983;
      if (v7833) {
        return true;
      }
      var v15984 = map$$1[mid];
      var v7834 = code$$2 < v15984;
      if (v7834) {
        hi = mid;
      } else {
        lo = mid + 2;
      }
      var v15985 = lo + 1;
      v7835 = v15985 < hi;
    }
    return false;
  }
  function LexIsUnicodeDigit(code$$3) {
    var v15986 = TypeScript$$16.codeGenTarget;
    var v20965 = TypeScript$$16.CodeGenTarget;
    var v15987 = v20965.ES3;
    var v7836 = v15986 == v15987;
    if (v7836) {
      return LexLookUpUnicodeMap(code$$3, unicodeES3IdCont);
    } else {
      return LexLookUpUnicodeMap(code$$3, unicodeES5IdCont);
    }
    return;
  }
  function LexIsUnicodeIdStart(code$$4) {
    var v15988 = TypeScript$$16.codeGenTarget;
    var v20966 = TypeScript$$16.CodeGenTarget;
    var v15989 = v20966.ES3;
    var v7837 = v15988 == v15989;
    if (v7837) {
      return LexLookUpUnicodeMap(code$$4, unicodeES3IdStart);
    } else {
      return LexLookUpUnicodeMap(code$$4, unicodeES5IdStart);
    }
    return;
  }
  function LexInitialize() {
    TypeScript$$16.initializeStaticTokens();
    var v7838 = TypeScript$$16.LexCodeLPR;
    var v15990 = TypeScript$$16.staticTokens;
    var v20967 = TypeScript$$16.TokenID;
    var v15991 = v20967.OpenParen;
    autoToken[v7838] = v15990[v15991];
    var v7839 = TypeScript$$16.LexCodeRPR;
    var v15992 = TypeScript$$16.staticTokens;
    var v20968 = TypeScript$$16.TokenID;
    var v15993 = v20968.CloseParen;
    autoToken[v7839] = v15992[v15993];
    var v7840 = TypeScript$$16.LexCodeCMA;
    var v15994 = TypeScript$$16.staticTokens;
    var v20969 = TypeScript$$16.TokenID;
    var v15995 = v20969.Comma;
    autoToken[v7840] = v15994[v15995];
    var v7841 = TypeScript$$16.LexCodeSMC;
    var v15996 = TypeScript$$16.staticTokens;
    var v20970 = TypeScript$$16.TokenID;
    var v15997 = v20970.Semicolon;
    autoToken[v7841] = v15996[v15997];
    var v7842 = TypeScript$$16.LexCodeLBR;
    var v15998 = TypeScript$$16.staticTokens;
    var v20971 = TypeScript$$16.TokenID;
    var v15999 = v20971.OpenBracket;
    autoToken[v7842] = v15998[v15999];
    var v7843 = TypeScript$$16.LexCodeRBR;
    var v16000 = TypeScript$$16.staticTokens;
    var v20972 = TypeScript$$16.TokenID;
    var v16001 = v20972.CloseBracket;
    autoToken[v7843] = v16000[v16001];
    var v7844 = TypeScript$$16.LexCodeTIL;
    var v16002 = TypeScript$$16.staticTokens;
    var v20973 = TypeScript$$16.TokenID;
    var v16003 = v20973.Tilde;
    autoToken[v7844] = v16002[v16003];
    var v7845 = TypeScript$$16.LexCodeQUE;
    var v16004 = TypeScript$$16.staticTokens;
    var v20974 = TypeScript$$16.TokenID;
    var v16005 = v20974.Question;
    autoToken[v7845] = v16004[v16005];
    var v7846 = TypeScript$$16.LexCodeLC;
    var v16006 = TypeScript$$16.staticTokens;
    var v20975 = TypeScript$$16.TokenID;
    var v16007 = v20975.OpenBrace;
    autoToken[v7846] = v16006[v16007];
    var v7847 = TypeScript$$16.LexCodeRC;
    var v16008 = TypeScript$$16.staticTokens;
    var v20976 = TypeScript$$16.TokenID;
    var v16009 = v20976.CloseBrace;
    autoToken[v7847] = v16008[v16009];
    var v7848 = TypeScript$$16.LexCodeCOL;
    var v16010 = TypeScript$$16.staticTokens;
    var v20977 = TypeScript$$16.TokenID;
    var v16011 = v20977.Colon;
    autoToken[v7848] = v16010[v16011];
    var v7849 = TypeScript$$16;
    var v16012 = TypeScript$$16.StringHashTable;
    var v27028 = new v16012;
    v7849.LexKeywordTable = v27028;
    var i$$53;
    var v16013 = TypeScript$$16.TokenID;
    var v7853 = v16013._map;
    for (i$$53 in v7853) {
      var v20978 = TypeScript$$16.TokenID;
      var v16014 = v20978.LimKeyword;
      var v7852 = i$$53 <= v16014;
      if (v7852) {
        var v7850 = TypeScript$$16.LexKeywordTable;
        var v24060 = TypeScript$$16.TokenID;
        var v20979 = v24060._map;
        var v16015 = v20979[i$$53];
        var v7851 = v16015.toLowerCase();
        v7850.add(v7851, i$$53);
      }
    }
    var j$$6 = 0;
    var v16016 = TypeScript$$16.LexCodeASCIIChars;
    var v7855 = j$$6 < v16016;
    for (;v7855;) {
      var v7854 = LexIsIdentifierStartChar(j$$6);
      if (v7854) {
        lexIdStartTable[j$$6] = true;
      } else {
        lexIdStartTable[j$$6] = false;
      }
      j$$6 = j$$6 + 1;
      var v16017 = TypeScript$$16.LexCodeASCIIChars;
      v7855 = j$$6 < v16017;
    }
    return;
  }
  function LexAdjustIndent(code$$5, indentAmt) {
    var v24061 = TypeScript$$16.LexCodeLBR;
    var v20980 = code$$5 == v24061;
    var v24063 = !v20980;
    if (v24063) {
      var v24062 = TypeScript$$16.LexCodeLC;
      v20980 = code$$5 == v24062;
    }
    var v16018 = v20980;
    var v20982 = !v16018;
    if (v20982) {
      var v20981 = TypeScript$$16.LexCodeLPR;
      v16018 = code$$5 == v20981;
    }
    var v7857 = v16018;
    if (v7857) {
      return indentAmt + 1;
    } else {
      var v24064 = TypeScript$$16.LexCodeRBR;
      var v20983 = code$$5 == v24064;
      var v24066 = !v20983;
      if (v24066) {
        var v24065 = TypeScript$$16.LexCodeRC;
        v20983 = code$$5 == v24065;
      }
      var v16019 = v20983;
      var v20985 = !v16019;
      if (v20985) {
        var v20984 = TypeScript$$16.LexCodeRPR;
        v16019 = code$$5 == v20984;
      }
      var v7856 = v16019;
      if (v7856) {
        return indentAmt - 1;
      } else {
        return indentAmt;
      }
    }
    return;
  }
  function LexIsIdentifierStartChar(code$$6) {
    var v24067 = code$$6 >= 97;
    if (v24067) {
      v24067 = code$$6 <= 122;
    }
    var v20986 = v24067;
    var v24069 = !v20986;
    if (v24069) {
      var v24068 = code$$6 >= 65;
      if (v24068) {
        v24068 = code$$6 <= 90;
      }
      v20986 = v24068;
    }
    var v16020 = v20986;
    var v20988 = !v16020;
    if (v20988) {
      var v20987 = TypeScript$$16.LexCodeDollar;
      v16020 = code$$6 == v20987;
    }
    var v7858 = v16020;
    var v16022 = !v7858;
    if (v16022) {
      var v16021 = TypeScript$$16.LexCodeUnderscore;
      v7858 = code$$6 == v16021;
    }
    return v7858;
  }
  function LexIsDigit(code$$7) {
    var v7859 = code$$7 >= 48;
    if (v7859) {
      v7859 = code$$7 <= 57;
    }
    return v7859;
  }
  function LexIsIdentifierChar(code$$8) {
    var v7860 = lexIdStartTable[code$$8];
    var v16023 = !v7860;
    if (v16023) {
      v7860 = LexIsDigit(code$$8);
    }
    return v7860;
  }
  function LexMatchingOpen(code$$9) {
    var v16024 = TypeScript$$16.LexCodeRBR;
    var v7863 = code$$9 == v16024;
    if (v7863) {
      return TypeScript$$16.LexCodeLBR;
    } else {
      var v16025 = TypeScript$$16.LexCodeRC;
      var v7862 = code$$9 == v16025;
      if (v7862) {
        return TypeScript$$16.LexCodeLC;
      } else {
        var v16026 = TypeScript$$16.LexCodeRPR;
        var v7861 = code$$9 == v16026;
        if (v7861) {
          return TypeScript$$16.LexCodeLPR;
        } else {
          return 0;
        }
      }
    }
    return;
  }
  function convertTokToIDName(tok) {
    return convertTokToIDBase(tok, true, false);
  }
  function convertTokToID(tok$$1, strictMode) {
    return convertTokToIDBase(tok$$1, false, strictMode);
  }
  function convertTokToIDBase(tok$$2, identifierName, strictMode$$1) {
    var v16027 = tok$$2.tokenId;
    var v20989 = TypeScript$$16.TokenID;
    var v16028 = v20989.LimKeyword;
    var v7869 = v16027 <= v16028;
    if (v7869) {
      var v7864 = tok$$2.tokenId;
      var tokInfo = TypeScript$$16.lookupToken(v7864);
      var v7868 = tokInfo != undefined;
      if (v7868) {
        var v16029 = TypeScript$$16.Reservation;
        var v7865 = v16029.Javascript;
        var v16030 = TypeScript$$16.Reservation;
        var v7866 = v16030.JavascriptFuture;
        var resFlags = v7865 | v7866;
        if (strictMode$$1) {
          var v20990 = TypeScript$$16.Reservation;
          var v16031 = v20990.JavascriptFutureStrict;
          resFlags = resFlags | v16031;
        }
        var v16032 = identifierName;
        var v20992 = !v16032;
        if (v20992) {
          var v24070 = tokInfo.reservation;
          var v20991 = TypeScript$$16.hasFlag(v24070, resFlags);
          v16032 = !v20991;
        }
        var v7867 = v16032;
        if (v7867) {
          return true;
        }
      } else {
        return false;
      }
    } else {
      return false;
    }
    return;
  }
  function getLineNumberFromPosition(lineMap$$1, position$$2) {
    var v7870 = position$$2 === -1;
    if (v7870) {
      return 0;
    }
    var min$$2 = 0;
    var v7871 = lineMap$$1.length;
    var max$$1 = v7871 - 1;
    var v7875 = min$$2 < max$$1;
    for (;v7875;) {
      var v7872 = min$$2 + max$$1;
      var med = v7872 >> 1;
      var v16033 = lineMap$$1[med];
      var v7874 = position$$2 < v16033;
      if (v7874) {
        max$$1 = med - 1;
      } else {
        var v20993 = med + 1;
        var v16034 = lineMap$$1[v20993];
        var v7873 = position$$2 < v16034;
        if (v7873) {
          min$$2 = max$$1 = med;
        } else {
          min$$2 = med + 1;
        }
      }
      v7875 = min$$2 < max$$1;
    }
    return min$$2;
  }
  function getSourceLineColFromMap(lineCol$$5, minChar$$29, lineMap$$2) {
    var line$$5 = getLineNumberFromPosition(lineMap$$2, minChar$$29);
    var v7877 = line$$5 > 0;
    if (v7877) {
      lineCol$$5.line = line$$5;
      var v7876 = lineMap$$2[line$$5];
      lineCol$$5.col = minChar$$29 - v7876;
    }
    return;
  }
  function getLineColumnFromPosition(script$$9, position$$3) {
    var result$$10 = {line:-1, col:-1};
    var v16035 = script$$9.locationInfo;
    var v7878 = v16035.lineMap;
    getSourceLineColFromMap(result$$10, position$$3, v7878);
    var v16036 = result$$10.col;
    var v7879 = v16036 >= 0;
    if (v7879) {
      var v16037 = result$$10.col;
      result$$10.col = v16037 + 1;
    }
    return result$$10;
  }
  function getPositionFromLineColumn(script$$10, line$$6, column) {
    var v20994 = script$$10.locationInfo;
    var v16038 = v20994.lineMap;
    var v7880 = v16038[line$$6];
    var v7881 = column - 1;
    return v7880 + v7881;
  }
  function isPrimitiveTypeToken(token$$5) {
    var v7882 = token$$5.tokenId;
    switch(v7882) {
      case TypeScript$$16.TokenID.Any:
      ;
      case TypeScript$$16.TokenID.Bool:
      ;
      case TypeScript$$16.TokenID.Number:
      ;
      case TypeScript$$16.TokenID.String:
        return true;
    }
    return false;
  }
  function isModifier(token$$6) {
    var v7883 = token$$6.tokenId;
    switch(v7883) {
      case TypeScript$$16.TokenID.Public:
      ;
      case TypeScript$$16.TokenID.Private:
      ;
      case TypeScript$$16.TokenID.Static:
        return true;
    }
    return false;
  }
  TypeScript$$16.LexEOF = -1;
  TypeScript$$16.LexCodeNWL = 10;
  TypeScript$$16.LexCodeRET = 13;
  TypeScript$$16.LexCodeLS = 8232;
  TypeScript$$16.LexCodePS = 8233;
  TypeScript$$16.LexCodeTAB = 9;
  TypeScript$$16.LexCodeVTAB = 11;
  var v7884 = TypeScript$$16;
  var v27029 = "e".charCodeAt(0);
  v7884.LexCode_e = v27029;
  var v7885 = TypeScript$$16;
  var v27030 = "E".charCodeAt(0);
  v7885.LexCode_E = v27030;
  var v7886 = TypeScript$$16;
  var v27031 = "x".charCodeAt(0);
  v7886.LexCode_x = v27031;
  var v7887 = TypeScript$$16;
  var v27032 = "X".charCodeAt(0);
  v7887.LexCode_X = v27032;
  var v7888 = TypeScript$$16;
  var v27033 = "a".charCodeAt(0);
  v7888.LexCode_a = v27033;
  var v7889 = TypeScript$$16;
  var v27034 = "A".charCodeAt(0);
  v7889.LexCode_A = v27034;
  var v7890 = TypeScript$$16;
  var v27035 = "f".charCodeAt(0);
  v7890.LexCode_f = v27035;
  var v7891 = TypeScript$$16;
  var v27036 = "F".charCodeAt(0);
  v7891.LexCode_F = v27036;
  var v7892 = TypeScript$$16;
  var v27037 = "g".charCodeAt(0);
  v7892.LexCode_g = v27037;
  var v7893 = TypeScript$$16;
  var v27038 = "m".charCodeAt(0);
  v7893.LexCode_m = v27038;
  var v7894 = TypeScript$$16;
  var v27039 = "i".charCodeAt(0);
  v7894.LexCode_i = v27039;
  var v7895 = TypeScript$$16;
  var v27040 = "u".charCodeAt(0);
  v7895.LexCode_u = v27040;
  var v7896 = TypeScript$$16;
  var v27041 = "0".charCodeAt(0);
  v7896.LexCode_0 = v27041;
  var v7897 = TypeScript$$16;
  var v27042 = "9".charCodeAt(0);
  v7897.LexCode_9 = v27042;
  var v7898 = TypeScript$$16;
  var v27043 = "8".charCodeAt(0);
  v7898.LexCode_8 = v27043;
  var v7899 = TypeScript$$16;
  var v27044 = "7".charCodeAt(0);
  v7899.LexCode_7 = v27044;
  var v7900 = TypeScript$$16;
  var v27045 = "\\".charCodeAt(0);
  v7900.LexCodeBSL = v27045;
  var v7901 = TypeScript$$16;
  var v27046 = "#".charCodeAt(0);
  v7901.LexCodeSHP = v27046;
  var v7902 = TypeScript$$16;
  var v27047 = "!".charCodeAt(0);
  v7902.LexCodeBNG = v27047;
  var v7903 = TypeScript$$16;
  var v27048 = '"'.charCodeAt(0);
  v7903.LexCodeQUO = v27048;
  var v7904 = TypeScript$$16;
  var v27049 = "'".charCodeAt(0);
  v7904.LexCodeAPO = v27049;
  var v7905 = TypeScript$$16;
  var v27050 = "%".charCodeAt(0);
  v7905.LexCodePCT = v27050;
  var v7906 = TypeScript$$16;
  var v27051 = "&".charCodeAt(0);
  v7906.LexCodeAMP = v27051;
  var v7907 = TypeScript$$16;
  var v27052 = "(".charCodeAt(0);
  v7907.LexCodeLPR = v27052;
  var v7908 = TypeScript$$16;
  var v27053 = ")".charCodeAt(0);
  v7908.LexCodeRPR = v27053;
  var v7909 = TypeScript$$16;
  var v27054 = "+".charCodeAt(0);
  v7909.LexCodePLS = v27054;
  var v7910 = TypeScript$$16;
  var v27055 = "-".charCodeAt(0);
  v7910.LexCodeMIN = v27055;
  var v7911 = TypeScript$$16;
  var v27056 = "*".charCodeAt(0);
  v7911.LexCodeMUL = v27056;
  var v7912 = TypeScript$$16;
  var v27057 = "/".charCodeAt(0);
  v7912.LexCodeSLH = v27057;
  var v7913 = TypeScript$$16;
  var v27058 = "^".charCodeAt(0);
  v7913.LexCodeXOR = v27058;
  var v7914 = TypeScript$$16;
  var v27059 = ",".charCodeAt(0);
  v7914.LexCodeCMA = v27059;
  var v7915 = TypeScript$$16;
  var v27060 = ".".charCodeAt(0);
  v7915.LexCodeDOT = v27060;
  var v7916 = TypeScript$$16;
  var v27061 = "<".charCodeAt(0);
  v7916.LexCodeLT = v27061;
  var v7917 = TypeScript$$16;
  var v27062 = "=".charCodeAt(0);
  v7917.LexCodeEQ = v27062;
  var v7918 = TypeScript$$16;
  var v27063 = ">".charCodeAt(0);
  v7918.LexCodeGT = v27063;
  var v7919 = TypeScript$$16;
  var v27064 = "?".charCodeAt(0);
  v7919.LexCodeQUE = v27064;
  var v7920 = TypeScript$$16;
  var v27065 = "[".charCodeAt(0);
  v7920.LexCodeLBR = v27065;
  var v7921 = TypeScript$$16;
  var v27066 = "]".charCodeAt(0);
  v7921.LexCodeRBR = v27066;
  var v7922 = TypeScript$$16;
  var v27067 = "_".charCodeAt(0);
  v7922.LexCodeUSC = v27067;
  var v7923 = TypeScript$$16;
  var v27068 = "{".charCodeAt(0);
  v7923.LexCodeLC = v27068;
  var v7924 = TypeScript$$16;
  var v27069 = "}".charCodeAt(0);
  v7924.LexCodeRC = v27069;
  var v7925 = TypeScript$$16;
  var v27070 = "|".charCodeAt(0);
  v7925.LexCodeBAR = v27070;
  var v7926 = TypeScript$$16;
  var v27071 = "~".charCodeAt(0);
  v7926.LexCodeTIL = v27071;
  var v7927 = TypeScript$$16;
  var v27072 = ":".charCodeAt(0);
  v7927.LexCodeCOL = v27072;
  var v7928 = TypeScript$$16;
  var v27073 = ";".charCodeAt(0);
  v7928.LexCodeSMC = v27073;
  var v7929 = TypeScript$$16;
  var v27074 = "_".charCodeAt(0);
  v7929.LexCodeUnderscore = v27074;
  var v7930 = TypeScript$$16;
  var v27075 = "$".charCodeAt(0);
  v7930.LexCodeDollar = v27075;
  TypeScript$$16.LexCodeSpace = 32;
  var v7931 = TypeScript$$16;
  var v27076 = "@".charCodeAt(0);
  v7931.LexCodeAtSign = v27076;
  TypeScript$$16.LexCodeASCIIChars = 128;
  TypeScript$$16.LexKeywordTable = undefined;
  var v7932 = TypeScript$$16.LexCodeASCIIChars;
  var autoToken = new Array(v7932);
  var v7933 = TypeScript$$16.LexCodeASCIIChars;
  var lexIdStartTable = new Array(v7933);
  var v27440 = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1610, 1649, 1747, 1749, 1749, 1765, 1766, 1786, 1788, 1808, 1808, 1810, 1836, 1920, 1957, 2309, 2361, 2365, 2365, 2384, 2384, 
  2392, 2401, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2784, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2949, 2954, 2958, 2960, 2962, 2965, 
  2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3294, 3294, 3296, 3297, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3424, 3425, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 
  3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805, 3840, 3840, 3904, 3911, 3913, 3946, 3976, 3979, 4096, 4129, 4131, 4135, 4137, 4138, 4176, 4181, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 
  4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6067, 6176, 6263, 6272, 6312, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8319, 8319, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 
  8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12346, 12353, 12436, 12445, 12446, 12449, 12538, 12540, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 13312, 19893, 19893, 19968, 19968, 40869, 40869, 40960, 42124, 44032, 44032, 55203, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 
  65019, 65136, 65138];
  var v27441 = [65140, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500];
  var unicodeES3IdStart = v27440.concat(v27441);
  var unicodeES3IdCont = [768, 846, 864, 866, 1155, 1158, 1425, 1441, 1443, 1465, 1467, 1469, 1471, 1471, 1473, 1474, 1476, 1476, 1611, 1621, 1632, 1641, 1648, 1648, 1750, 1756, 1759, 1764, 1767, 1768, 1770, 1773, 1776, 1785, 1809, 1809, 1840, 1866, 1958, 1968, 2305, 2307, 2364, 2364, 2366, 2381, 2385, 2388, 2402, 2403, 2406, 2415, 2433, 2435, 2492, 2492, 2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2530, 2531, 2534, 2543, 2562, 2562, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2662, 2673, 
  2689, 2691, 2748, 2748, 2750, 2757, 2759, 2761, 2763, 2765, 2790, 2799, 2817, 2819, 2876, 2876, 2878, 2883, 2887, 2888, 2891, 2893, 2902, 2903, 2918, 2927, 2946, 2947, 3006, 3010, 3014, 3016, 3018, 3021, 3031, 3031, 3047, 3055, 3073, 3075, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3174, 3183, 3202, 3203, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3302, 3311, 3330, 3331, 3390, 3395, 3398, 3400, 3402, 3405, 3415, 3415, 3430, 3439, 3458, 3459, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 
  3570, 3571, 3633, 3633, 3636, 3642, 3655, 3662, 3664, 3673, 3761, 3761, 3764, 3769, 3771, 3772, 3784, 3789, 3792, 3801, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3903, 3953, 3972, 3974, 3975, 3984, 3991, 3993, 4028, 4038, 4038, 4140, 4146, 4150, 4153, 4160, 4169, 4182, 4185, 4969, 4977, 6068, 6099, 6112, 6121, 6160, 6169, 6313, 6313, 8255, 8256, 8400, 8412, 8417, 8417, 12330, 12335, 12441, 12442, 12539, 12539, 64286, 64286, 65056, 65059, 65075, 65076, 65101, 65103, 65296, 
  65305, 65343, 65343, 65381, 65381];
  var v27442 = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 
  2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821, 2828, 2831, 2832, 2835, 
  2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 
  3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 
  4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6E3, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 
  6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455];
  var v27443 = [8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 
  12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 13312, 19893, 19893, 19968, 19968, 40908, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43E3, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 
  43442, 43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44002, 44032, 44032, 55203, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 
  64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500];
  var unicodeES5IdStart = v27442.concat(v27443);
  var unicodeES5IdCont = [768, 879, 1155, 1159, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1552, 1562, 1611, 1641, 1648, 1648, 1750, 1756, 1759, 1764, 1767, 1768, 1770, 1773, 1776, 1785, 1809, 1809, 1840, 1866, 1958, 1968, 1984, 1993, 2027, 2035, 2070, 2073, 2075, 2083, 2085, 2087, 2089, 2093, 2137, 2139, 2276, 2302, 2304, 2307, 2362, 2364, 2366, 2383, 2385, 2391, 2402, 2403, 2406, 2415, 2433, 2435, 2492, 2492, 2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2530, 2531, 2534, 2543, 
  2561, 2563, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2662, 2673, 2677, 2677, 2689, 2691, 2748, 2748, 2750, 2757, 2759, 2761, 2763, 2765, 2786, 2787, 2790, 2799, 2817, 2819, 2876, 2876, 2878, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2914, 2915, 2918, 2927, 2946, 2946, 3006, 3010, 3014, 3016, 3018, 3021, 3031, 3031, 3046, 3055, 3073, 3075, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3170, 3171, 3174, 3183, 3202, 3203, 3260, 3260, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 
  3298, 3299, 3302, 3311, 3330, 3331, 3390, 3396, 3398, 3400, 3402, 3405, 3415, 3415, 3426, 3427, 3430, 3439, 3458, 3459, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3633, 3633, 3636, 3642, 3655, 3662, 3664, 3673, 3761, 3761, 3764, 3769, 3771, 3772, 3784, 3789, 3792, 3801, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3903, 3953, 3972, 3974, 3975, 3981, 3991, 3993, 4028, 4038, 4038, 4139, 4158, 4160, 4169, 4182, 4185, 4190, 4192, 4194, 4196, 4199, 4205, 4209, 4212, 
  4226, 4237, 4239, 4253, 4957, 4959, 5906, 5908, 5938, 5940, 5970, 5971, 6002, 6003, 6068, 6099, 6109, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6313, 6313, 6432, 6443, 6448, 6459, 6470, 6479, 6576, 6592, 6600, 6601, 6608, 6617, 6679, 6683, 6741, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6912, 6916, 6964, 6980, 6992, 7001, 7019, 7027, 7040, 7042, 7073, 7085, 7088, 7097, 7142, 7155, 7204, 7223, 7232, 7241, 7248, 7257, 7376, 7378, 7380, 7400, 7405, 7405, 7410, 7412, 7616, 7654, 7676, 7679, 8204, 8205, 
  8255, 8256, 8276, 8276, 8400, 8412, 8417, 8417, 8421, 8432, 11503, 11505, 11647, 11647, 11744, 11775, 12330, 12335, 12441, 12442, 42528, 42537, 42607, 42607, 42612, 42621, 42655, 42655, 42736, 42737, 43010, 43010, 43014, 43014, 43019, 43019, 43043, 43047, 43136, 43137, 43188, 43204, 43216, 43225, 43232, 43249, 43264, 43273, 43302, 43309, 43335, 43347, 43392, 43395, 43443, 43456, 43472, 43481, 43561, 43574, 43587, 43587, 43596, 43597, 43600, 43609, 43643, 43643, 43696, 43696, 43698, 43700, 43703, 
  43704, 43710, 43711, 43713, 43713, 43755, 43759, 43765, 43766, 44003, 44010, 44012, 44013, 44016, 44025, 64286, 64286, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65296, 65305, 65343, 65343];
  TypeScript$$16.LexLookUpUnicodeMap = LexLookUpUnicodeMap;
  TypeScript$$16.LexIsUnicodeDigit = LexIsUnicodeDigit;
  TypeScript$$16.LexIsUnicodeIdStart = LexIsUnicodeIdStart;
  TypeScript$$16.LexInitialize = LexInitialize;
  TypeScript$$16.LexAdjustIndent = LexAdjustIndent;
  TypeScript$$16.LexIsIdentifierStartChar = LexIsIdentifierStartChar;
  TypeScript$$16.LexIsDigit = LexIsDigit;
  TypeScript$$16.LexIsIdentifierChar = LexIsIdentifierChar;
  TypeScript$$16.LexMatchingOpen = LexMatchingOpen;
  var v16039 = TypeScript$$16.NumberScanState;
  var v20995 = !v16039;
  if (v20995) {
    v16039 = TypeScript$$16.NumberScanState = {};
  }
  var v7934 = v16039;
  v600(v7934);
  var NumberScanState = TypeScript$$16.NumberScanState;
  var v16040 = TypeScript$$16.LexState;
  var v20996 = !v16040;
  if (v20996) {
    v16040 = TypeScript$$16.LexState = {};
  }
  var v7935 = v16040;
  v601(v7935);
  var LexState = TypeScript$$16.LexState;
  var v16041 = TypeScript$$16.LexMode;
  var v20997 = !v16041;
  if (v20997) {
    v16041 = TypeScript$$16.LexMode = {};
  }
  var v7936 = v16041;
  v602(v7936);
  var LexMode = TypeScript$$16.LexMode;
  var v16042 = TypeScript$$16.CommentStyle;
  var v20998 = !v16042;
  if (v20998) {
    v16042 = TypeScript$$16.CommentStyle = {};
  }
  var v7937 = v16042;
  v603(v7937);
  var CommentStyle = TypeScript$$16.CommentStyle;
  var StringSourceText = v606();
  TypeScript$$16.StringSourceText = StringSourceText;
  var SourceTextSegment = v609();
  TypeScript$$16.SourceTextSegment = SourceTextSegment;
  var AggerateSourceTextSegment = v612();
  TypeScript$$16.AggerateSourceTextSegment = AggerateSourceTextSegment;
  var ScannerTextStream = v618();
  TypeScript$$16.ScannerTextStream = ScannerTextStream;
  var SavedTokens = v633();
  TypeScript$$16.SavedTokens = SavedTokens;
  var Scanner = v674();
  TypeScript$$16.Scanner = Scanner;
  TypeScript$$16.convertTokToIDName = convertTokToIDName;
  TypeScript$$16.convertTokToID = convertTokToID;
  TypeScript$$16.getLineNumberFromPosition = getLineNumberFromPosition;
  TypeScript$$16.getSourceLineColFromMap = getSourceLineColFromMap;
  TypeScript$$16.getLineColumnFromPosition = getLineColumnFromPosition;
  TypeScript$$16.getPositionFromLineColumn = getPositionFromLineColumn;
  TypeScript$$16.isPrimitiveTypeToken = isPrimitiveTypeToken;
  TypeScript$$16.isModifier = isModifier;
  return;
}
function v599(TypeScript$$15) {
  function v598() {
    function v597(s$$15) {
      var v16043 = this.builder;
      this.builder = v16043 + s$$15;
      var v7938 = this.outfile;
      var v7939 = this.builder;
      v7938.WriteLine(v7939);
      this.builder = "";
      return;
    }
    function v596(s$$14) {
      var v16044 = this.builder;
      this.builder = v16044 + s$$14;
      return;
    }
    function v595() {
      var v20999 = this.builder;
      var v16045 = v20999.length;
      var v7942 = v16045 > 0;
      if (v7942) {
        var v7940 = TypeScript$$15.CompilerDiagnostics;
        var v7941 = this.builder;
        v7940.Alert(v7941);
      }
      var v7943 = this.indentStrings;
      var v7944 = this.indentAmt;
      var indentString$$1 = v7943[v7944];
      var v7948 = indentString$$1 === undefined;
      if (v7948) {
        indentString$$1 = "";
        var i$$52 = 0;
        var v16046 = this.indentAmt;
        var v7945 = i$$52 < v16046;
        for (;v7945;) {
          var v16047 = this.indent1;
          indentString$$1 = indentString$$1 + v16047;
          i$$52 = i$$52 + 1;
          var v16048 = this.indentAmt;
          v7945 = i$$52 < v16048;
        }
        var v7946 = this.indentStrings;
        var v7947 = this.indentAmt;
        v7946[v7947] = indentString$$1;
      }
      var v16049 = this.builder;
      this.builder = v16049 + indentString$$1;
      return;
    }
    function v594() {
      var v16050 = this.indentAmt;
      this.indentAmt = v16050 - 1;
      return;
    }
    function v593() {
      var v16051 = this.indentAmt;
      this.indentAmt = v16051 + 1;
      return;
    }
    function PrintContext$$1(outfile$$4, parser$$1) {
      this.outfile = outfile$$4;
      this.parser = parser$$1;
      this.builder = "";
      this.indent1 = "  ";
      this.indentStrings = [];
      this.indentAmt = 0;
      return;
    }
    var v7949 = PrintContext$$1.prototype;
    v7949.increaseIndent = v593;
    var v7950 = PrintContext$$1.prototype;
    v7950.decreaseIndent = v594;
    var v7951 = PrintContext$$1.prototype;
    v7951.startLine = v595;
    var v7952 = PrintContext$$1.prototype;
    v7952.write = v596;
    var v7953 = PrintContext$$1.prototype;
    v7953.writeLine = v597;
    return PrintContext$$1;
  }
  function prePrintAST(ast$$46, parent$$43, walker$$40) {
    var pc = walker$$40.state;
    ast$$46.print(pc);
    pc.increaseIndent();
    return ast$$46;
  }
  function postPrintAST(ast$$47, parent$$44, walker$$41) {
    var pc$$1 = walker$$41.state;
    pc$$1.decreaseIndent();
    return ast$$47;
  }
  var PrintContext = v598();
  TypeScript$$15.PrintContext = PrintContext;
  TypeScript$$15.prePrintAST = prePrintAST;
  TypeScript$$15.postPrintAST = postPrintAST;
  return;
}
function v592(TypeScript$$14) {
  function v591() {
    function v590(sourceText$$2, filename$$2, unitIndex$$2, allowedElements$$4) {
      function v589(message$$15) {
        return _this$$2.reportParseError(message$$15);
      }
      var v16052 = typeof allowedElements$$4;
      var v7955 = v16052 === "undefined";
      if (v7955) {
        var v7954 = TypeScript$$14.AllowedElements;
        allowedElements$$4 = v7954.Global;
      }
      var _this$$2 = this;
      this.ambientModule = false;
      this.topLevel = true;
      this.hasTopLevelImportOrExport = false;
      this.requiresExtendsBlock = false;
      this.fname = filename$$2;
      this.currentUnitIndex = unitIndex$$2;
      this.amdDependencies = [];
      var v7956 = this.scanner;
      v7956.resetComments();
      var v7957 = this.scanner;
      v7957.setErrorHandler(v589);
      var v7958 = this.scanner;
      var v16053 = TypeScript$$14.LexMode;
      var v7959 = v16053.File;
      v7958.setSourceText(sourceText$$2, v7959);
      var v7960 = this.scanner;
      var leftCurlyCount$$5 = v7960.leftCurlyCount;
      var v7961 = this.scanner;
      var rightCurlyCount$$5 = v7961.rightCurlyCount;
      var v7962 = this.scanner;
      var minChar$$28 = v7962.pos;
      var v7963 = this.scanner;
      var v27077 = v7963.scan();
      this.currentToken = v27077;
      this.pushDeclLists();
      var v7964 = TypeScript$$14.ASTList;
      var bod$$3 = new v7964;
      bod$$3.minChar = minChar$$28;
      this.state = ParseState.StartScript;
      var v7965 = TypeScript$$14.isDSTRFile(filename$$2);
      var v16054 = !v7965;
      if (v16054) {
        v7965 = TypeScript$$14.isDTSFile(filename$$2);
      }
      this.parsingDeclareFile = v7965;
      for (;true;) {
        var v21000 = TypeScript$$14.ErrorRecoverySet;
        var v16055 = v21000.EOF;
        var v21001 = TypeScript$$14.ErrorRecoverySet;
        var v16056 = v21001.Func;
        var v7966 = v16055 | v16056;
        var v16057 = TypeScript$$14.Modifiers;
        var v7967 = v16057.None;
        this.parseStatementList(v7966, bod$$3, true, false, allowedElements$$4, v7967);
        var v21002 = this.currentToken;
        var v16058 = v21002.tokenId;
        var v21003 = TypeScript$$14.TokenID;
        var v16059 = v21003.EndOfFile;
        var v7968 = v16058 === v16059;
        if (v7968) {
          break;
        }
        var v7969 = TypeScript$$14.tokenTable;
        var v16060 = this.currentToken;
        var v7970 = v16060.tokenId;
        var badToken = v7969[v7970];
        var v21004 = badToken.text;
        var v16061 = "Unexpected statement block terminator '" + v21004;
        var v7971 = v16061 + "'";
        this.reportParseError(v7971);
        var v7972 = this.scanner;
        var v27078 = v7972.scan();
        this.currentToken = v27078;
      }
      this.state = ParseState.EndScript;
      var v7973 = this.scanner;
      bod$$3.limChar = v7973.pos;
      var topLevelMod = null;
      var v21005 = TypeScript$$14.moduleGenTarget;
      var v24071 = TypeScript$$14.ModuleGenTarget;
      var v21006 = v24071.Local;
      var v16062 = v21005 != v21006;
      if (v16062) {
        v16062 = this.hasTopLevelImportOrExport;
      }
      var v7984 = v16062;
      if (v7984) {
        var correctedFileName = TypeScript$$14.switchToForwardSlashes(filename$$2);
        var v7974 = TypeScript$$14.Identifier;
        var id$$15 = new v7974(correctedFileName);
        var v7975 = TypeScript$$14.ModuleDeclaration;
        var v7976 = this.topVarList();
        var v7977 = this.topScopeList();
        topLevelMod = new v7975(id$$15, bod$$3, v7976, v7977, null);
        var v16063 = topLevelMod.modFlags;
        var v21007 = TypeScript$$14.ModuleFlags;
        var v16064 = v21007.IsDynamic;
        topLevelMod.modFlags = v16063 | v16064;
        var v16065 = topLevelMod.modFlags;
        var v21008 = TypeScript$$14.ModuleFlags;
        var v16066 = v21008.IsWholeFile;
        topLevelMod.modFlags = v16065 | v16066;
        var v16067 = topLevelMod.modFlags;
        var v21009 = TypeScript$$14.ModuleFlags;
        var v16068 = v21009.Exported;
        topLevelMod.modFlags = v16067 | v16068;
        var v7978 = this.parsingDeclareFile;
        if (v7978) {
          var v16069 = topLevelMod.modFlags;
          var v21010 = TypeScript$$14.ModuleFlags;
          var v16070 = v21010.Ambient;
          topLevelMod.modFlags = v16069 | v16070;
        }
        topLevelMod.minChar = minChar$$28;
        var v7979 = this.scanner;
        topLevelMod.limChar = v7979.pos;
        var v7980 = topLevelMod;
        var v27079 = TypeScript$$14.getPrettyName(correctedFileName);
        v7980.prettyName = v27079;
        var v7981 = this.scanner;
        topLevelMod.containsUnicodeChar = v7981.seenUnicodeChar;
        var v7982 = this.scanner;
        topLevelMod.containsUnicodeCharInComment = v7982.seenUnicodeCharInComment;
        topLevelMod.amdDependencies = this.amdDependencies;
        var v7983 = TypeScript$$14.ASTList;
        bod$$3 = new v7983;
        bod$$3.minChar = topLevelMod.minChar;
        bod$$3.limChar = topLevelMod.limChar;
        bod$$3.append(topLevelMod);
      }
      var v7985 = TypeScript$$14.Script;
      var v7986 = this.topVarList();
      var v7987 = this.topScopeList();
      var script$$8 = new v7985(v7986, v7987);
      script$$8.bod = bod$$3;
      this.popDeclLists();
      script$$8.minChar = minChar$$28;
      var v7988 = this.scanner;
      script$$8.limChar = v7988.pos;
      var v7989 = script$$8;
      var v16071 = TypeScript$$14.LocationInfo;
      var v21011 = this.scanner;
      var v16072 = v21011.lineMap;
      var v27080 = new v16071(filename$$2, v16072, unitIndex$$2);
      v7989.locationInfo = v27080;
      var v16073 = this.scanner;
      var v7990 = v16073.leftCurlyCount;
      script$$8.leftCurlyCount = v7990 - leftCurlyCount$$5;
      var v16074 = this.scanner;
      var v7991 = v16074.rightCurlyCount;
      script$$8.rightCurlyCount = v7991 - rightCurlyCount$$5;
      script$$8.isDeclareFile = this.parsingDeclareFile;
      script$$8.topLevelMod = topLevelMod;
      var v7992 = this.scanner;
      script$$8.containsUnicodeChar = v7992.seenUnicodeChar;
      var v7993 = this.scanner;
      script$$8.containsUnicodeCharInComment = v7993.seenUnicodeCharInComment;
      script$$8.requiresExtendsBlock = this.requiresExtendsBlock;
      return script$$8;
    }
    function v588(sourceText$$1, filename$$1, unitIndex$$1) {
      var svGenTarget = TypeScript$$14.moduleGenTarget;
      try {
        var v7994 = TypeScript$$14.ModuleGenTarget;
        TypeScript$$14.moduleGenTarget = v7994.Local;
        var v16075 = TypeScript$$14.AllowedElements;
        var v7995 = v16075.QuickParse;
        var script$$7 = this.parse(sourceText$$1, filename$$1, unitIndex$$1, v7995);
        var v16076 = this.scanner;
        var v7996 = v16076.lexState;
        return new QuickParseResult(script$$7, v7996);
      } finally {
        TypeScript$$14.moduleGenTarget = svGenTarget;
      }
      return;
    }
    function v587(errorRecoverySet$$38, statements$$1, sourceElms, noLeadingCase, allowedElements$$3, parentModifiers$$8) {
      var directivePrologue = sourceElms;
      var v7997 = this.scanner;
      statements$$1.minChar = v7997.startPos;
      var v7998 = this.scanner;
      var limChar$$8 = v7998.pos;
      var v21012 = TypeScript$$14.AllowedElements;
      var v16077 = v21012.ModuleDeclarations;
      var v7999 = allowedElements$$3 & v16077;
      var v16078 = TypeScript$$14.AllowedElements;
      var v8000 = v16078.None;
      var innerStmts = v7999 == v8000;
      var v21013 = TypeScript$$14.AllowedElements;
      var v16079 = v21013.ClassDeclarations;
      var v8001 = allowedElements$$3 & v16079;
      var v16080 = TypeScript$$14.AllowedElements;
      var v8002 = v16080.None;
      var classNope = v8001 == v8002;
      var v24072 = TypeScript$$14.ErrorRecoverySet;
      var v21014 = v24072.TypeScriptS;
      var v24073 = TypeScript$$14.ErrorRecoverySet;
      var v21015 = v24073.RCurly;
      var v16081 = v21014 | v21015;
      errorRecoverySet$$38 = errorRecoverySet$$38 | v16081;
      this.state = ParseState.StartStatementList;
      var oldStrictMode = this.strictMode;
      var v16082 = this.nestingLevel;
      this.nestingLevel = v16082 + 1;
      for (;;) {
        var v26496 = this.currentToken;
        var v26215 = v26496.tokenId;
        var v26497 = TypeScript$$14.TokenID;
        var v26216 = v26497.CloseBrace;
        var v25551 = v26215 == v26216;
        var v26218 = !v25551;
        if (v26218) {
          var v26217 = noLeadingCase;
          if (v26217) {
            var v26699 = this.currentToken;
            var v26630 = v26699.tokenId;
            var v26700 = TypeScript$$14.TokenID;
            var v26631 = v26700.Case;
            var v26498 = v26630 == v26631;
            var v26634 = !v26498;
            if (v26634) {
              var v26701 = this.currentToken;
              var v26632 = v26701.tokenId;
              var v26702 = TypeScript$$14.TokenID;
              var v26633 = v26702.Default;
              v26498 = v26632 == v26633;
            }
            v26217 = v26498;
          }
          v25551 = v26217;
        }
        var v24074 = v25551;
        var v25553 = !v24074;
        if (v25553) {
          var v25552 = innerStmts;
          if (v25552) {
            var v26499 = this.currentToken;
            var v26219 = v26499.tokenId;
            var v26500 = TypeScript$$14.TokenID;
            var v26220 = v26500.Export;
            v25552 = v26219 == v26220;
          }
          v24074 = v25552;
        }
        var v21016 = v24074;
        var v24076 = !v21016;
        if (v24076) {
          var v24075 = classNope;
          if (v24075) {
            var v26221 = this.currentToken;
            var v25554 = v26221.tokenId;
            var v26222 = TypeScript$$14.TokenID;
            var v25555 = v26222.Class;
            v24075 = v25554 == v25555;
          }
          v21016 = v24075;
        }
        var v16083 = v21016;
        var v21019 = !v16083;
        if (v21019) {
          var v24077 = this.currentToken;
          var v21017 = v24077.tokenId;
          var v24078 = TypeScript$$14.TokenID;
          var v21018 = v24078.EndOfFile;
          v16083 = v21017 == v21018;
        }
        var v8006 = v16083;
        if (v8006) {
          this.state = ParseState.EndStmtList;
          statements$$1.limChar = limChar$$8;
          var v21020 = statements$$1.members;
          var v16084 = v21020.length;
          var v8005 = v16084 == 0;
          if (v8005) {
            var v8003 = statements$$1;
            var v27081 = this.parseComments();
            v8003.preComments = v27081;
          } else {
            var v8004 = statements$$1;
            var v27082 = this.parseComments();
            v8004.postComments = v27082;
          }
          this.strictMode = oldStrictMode;
          var v16085 = this.nestingLevel;
          this.nestingLevel = v16085 - 1;
          return;
        }
        var v26501 = TypeScript$$14.ErrorRecoverySet;
        var v26223 = v26501.Else;
        var v26502 = TypeScript$$14.ErrorRecoverySet;
        var v26224 = v26502.RParen;
        var v25556 = v26223 | v26224;
        var v26225 = TypeScript$$14.ErrorRecoverySet;
        var v25557 = v26225.Catch;
        var v24079 = v25556 | v25557;
        var v25558 = TypeScript$$14.ErrorRecoverySet;
        var v24080 = v25558.Colon;
        var v21021 = v24079 | v24080;
        var v16086 = ~v21021;
        var v8007 = errorRecoverySet$$38 & v16086;
        var stmt$$4 = this.parseStatement(v8007, allowedElements$$3, parentModifiers$$8);
        if (stmt$$4) {
          var v8008 = stmt$$4;
          var v16087 = stmt$$4.postComments;
          var v24081 = this.scanner;
          var v21022 = v24081.prevLine;
          var v16088 = this.parseCommentsForLine(v21022);
          var v27083 = this.combineComments(v16087, v16088);
          v8008.postComments = v27083;
          statements$$1.append(stmt$$4);
          limChar$$8 = stmt$$4.limChar;
          if (directivePrologue) {
            var v16089 = stmt$$4.nodeType;
            var v21023 = TypeScript$$14.NodeType;
            var v16090 = v21023.QString;
            var v8010 = v16089 == v16090;
            if (v8010) {
              var qstring = stmt$$4;
              var v16091 = qstring.text;
              var v8009 = v16091 == '"use strict"';
              if (v8009) {
                var v16092 = statements$$1.flags;
                var v21024 = TypeScript$$14.ASTFlags;
                var v16093 = v21024.StrictMode;
                statements$$1.flags = v16092 | v16093;
                this.strictMode = true;
              } else {
                directivePrologue = false;
              }
            } else {
              directivePrologue = false;
            }
          }
        }
      }
      return;
    }
    function v586(ast$$45) {
      var nt = ast$$45.nodeType;
      var v26703 = TypeScript$$14.NodeType;
      var v26635 = v26703.ClassDeclaration;
      var v26503 = nt == v26635;
      var v26637 = !v26503;
      if (v26637) {
        var v26704 = TypeScript$$14.NodeType;
        var v26636 = v26704.ImportDeclaration;
        v26503 = nt == v26636;
      }
      var v26226 = v26503;
      var v26505 = !v26226;
      if (v26505) {
        var v26638 = TypeScript$$14.NodeType;
        var v26504 = v26638.InterfaceDeclaration;
        v26226 = nt == v26504;
      }
      var v25559 = v26226;
      var v26228 = !v25559;
      if (v26228) {
        var v26506 = TypeScript$$14.NodeType;
        var v26227 = v26506.ModuleDeclaration;
        v25559 = nt == v26227;
      }
      var v24082 = v25559;
      var v25561 = !v24082;
      if (v25561) {
        var v26229 = TypeScript$$14.NodeType;
        var v25560 = v26229.Empty;
        v24082 = nt == v25560;
      }
      var v21025 = v24082;
      var v24084 = !v21025;
      if (v24084) {
        var v25562 = TypeScript$$14.NodeType;
        var v24083 = v25562.VarDecl;
        v21025 = nt == v24083;
      }
      var v16094 = v21025;
      var v21027 = !v16094;
      if (v21027) {
        var v25563 = TypeScript$$14.NodeType;
        var v24085 = v25563.Block;
        var v21026 = nt == v24085;
        if (v21026) {
          var v24086 = ast$$45.isStatementBlock;
          v21026 = !v24086;
        }
        v16094 = v21026;
      }
      var v8011 = v16094;
      var v16096 = !v8011;
      if (v16096) {
        var v24087 = TypeScript$$14.NodeType;
        var v21028 = v24087.FuncDecl;
        var v16095 = nt == v21028;
        if (v16095) {
          v16095 = ast$$45.isMethod();
        }
        v8011 = v16095;
      }
      return v8011;
    }
    function v585(errorRecoverySet$$37, allowedElements$$2, parentModifiers$$7) {
      function isAmbient$$3() {
        var v21029 = TypeScript$$14.Modifiers;
        var v16097 = v21029.Ambient;
        var v8012 = TypeScript$$14.hasFlag(modifiers$$12, v16097);
        var v16099 = !v8012;
        if (v16099) {
          var v21030 = TypeScript$$14.Modifiers;
          var v16098 = v21030.Ambient;
          v8012 = TypeScript$$14.hasFlag(parentModifiers$$7, v16098);
        }
        return v8012;
      }
      function mayNotBeExported() {
        var v21031 = TypeScript$$14.Modifiers;
        var v16100 = v21031.Exported;
        var v8013 = TypeScript$$14.hasFlag(modifiers$$12, v16100);
        if (v8013) {
          this.reportError("Statement may not be exported");
        }
        return;
      }
      var ast$$44 = null;
      var labelList$$1 = null;
      var astList = null;
      var temp$$15;
      var v8014 = TypeScript$$14.Modifiers;
      var modifiers$$12 = v8014.None;
      var v8015 = this.scanner;
      var minChar$$27 = v8015.startPos;
      var forInOk = false;
      var needTerminator = false;
      var fnOrVar = null;
      var preComments$$8 = this.parseComments();
      this.state = ParseState.StartStatement;
      for (;;) {
        var v16101 = this.currentToken;
        var v8331 = v16101.tokenId;
        switch(v8331) {
          case TypeScript$$14.TokenID.EndOfFile:
            var v8016 = TypeScript$$14.AST;
            var v16102 = TypeScript$$14.NodeType;
            var v8017 = v16102.Error;
            ast$$44 = new v8016(v8017);
            ast$$44.minChar = minChar$$27;
            var v8018 = this.scanner;
            ast$$44.limChar = v8018.pos;
            break;
          case TypeScript$$14.TokenID.Function:
            var v21032 = this.parsingDeclareFile;
            var v24088 = !v21032;
            if (v24088) {
              v21032 = isAmbient$$3();
            }
            var v16103 = v21032;
            var v21033 = !v16103;
            if (v21033) {
              v16103 = this.ambientModule;
            }
            var v8028 = v16103;
            if (v8028) {
              var v8019 = this.scanner;
              var v27084 = v8019.scan();
              this.currentToken = v27084;
              var v21034 = TypeScript$$14.ErrorRecoverySet;
              var v16104 = v21034.SColon;
              var v8020 = errorRecoverySet$$37 | v16104;
              fnOrVar = this.parsePropertyDeclaration(v8020, modifiers$$12, true, false);
              var v16105 = fnOrVar.nodeType;
              var v21035 = TypeScript$$14.NodeType;
              var v16106 = v21035.VarDecl;
              var v8022 = v16105 == v16106;
              if (v8022) {
                this.reportParseError("function keyword can only introduce function declaration");
              } else {
                var v21036 = fnOrVar.nodeType;
                var v24089 = TypeScript$$14.NodeType;
                var v21037 = v24089.FuncDecl;
                var v16107 = v21036 == v21037;
                if (v16107) {
                  fnOrVar.fncFlags;
                  var v24090 = TypeScript$$14.FncFlags;
                  v16107 = v24090.IsFatArrowFunction;
                }
                var v8021 = v16107;
                if (v8021) {
                  needTerminator = true;
                }
              }
              ast$$44 = fnOrVar;
              var v16108 = this.parsingDeclareFile;
              var v21039 = !v16108;
              if (v21039) {
                var v21038 = this.ambientModule;
                if (v21038) {
                  var v24091 = ast$$44.nodeType;
                  var v25564 = TypeScript$$14.NodeType;
                  var v24092 = v25564.FuncDecl;
                  v21038 = v24091 == v24092;
                }
                v16108 = v21038;
              }
              var v8023 = v16108;
              if (v8023) {
                var v16109 = ast$$44.fncFlags;
                var v21040 = TypeScript$$14.FncFlags;
                var v16110 = v21040.Exported;
                ast$$44.fncFlags = v16109 | v16110;
              }
            } else {
              var v8024 = isAmbient$$3();
              ast$$44 = this.parseFncDecl(errorRecoverySet$$37, true, false, false, null, false, false, v8024, modifiers$$12, null, true);
              var v16111 = ast$$44.fncFlags;
              var v21041 = TypeScript$$14.FncFlags;
              var v16112 = v21041.IsFatArrowFunction;
              var v8025 = TypeScript$$14.hasFlag(v16111, v16112);
              if (v8025) {
                needTerminator = true;
              }
              var v8026 = this.ambientModule;
              if (v8026) {
                this.reportParseError("function declaration not permitted within ambient module");
              }
              var v21042 = TypeScript$$14.Modifiers;
              var v16113 = v21042.Exported;
              var v8027 = TypeScript$$14.hasFlag(modifiers$$12, v16113);
              if (v8027) {
                var v16114 = ast$$44.fncFlags;
                var v21043 = TypeScript$$14.FncFlags;
                var v16115 = v21043.Exported;
                ast$$44.fncFlags = v16114 | v16115;
              }
            }
            break;
          case TypeScript$$14.TokenID.Module:
            var v24093 = TypeScript$$14.AllowedElements;
            var v21044 = v24093.ModuleDeclarations;
            var v16116 = allowedElements$$2 & v21044;
            var v21045 = TypeScript$$14.AllowedElements;
            var v16117 = v21045.None;
            var v8033 = v16116 == v16117;
            if (v8033) {
              this.reportParseError("module not allowed in this context");
              var v8029 = this.scanner;
              var v27085 = v8029.scan();
              this.currentToken = v27085;
              var v8030 = TypeScript$$14.AST;
              var v16118 = TypeScript$$14.NodeType;
              var v8031 = v16118.Error;
              ast$$44 = new v8030(v8031);
              ast$$44.minChar = minChar$$27;
              var v8032 = ast$$44;
              var v16119 = this.scanner;
              var v27086 = v16119.lastTokenLimChar();
              v8032.limChar = v27086;
            } else {
              ast$$44 = this.parseModuleDecl(errorRecoverySet$$37, modifiers$$12, preComments$$8);
              preComments$$8 = null;
            }
            break;
          case TypeScript$$14.TokenID.Import:
            var v24094 = TypeScript$$14.AllowedElements;
            var v21046 = v24094.ModuleDeclarations;
            var v16120 = allowedElements$$2 & v21046;
            var v21047 = TypeScript$$14.AllowedElements;
            var v16121 = v21047.None;
            var v8039 = v16120 == v16121;
            if (v8039) {
              this.reportParseError("module not allowed in this context");
              var v8034 = this.scanner;
              var v27087 = v8034.scan();
              this.currentToken = v27087;
              var v8035 = TypeScript$$14.AST;
              var v16122 = TypeScript$$14.NodeType;
              var v8036 = v16122.Error;
              ast$$44 = new v8035(v8036);
              ast$$44.minChar = minChar$$27;
              var v8037 = ast$$44;
              var v16123 = this.scanner;
              var v27088 = v16123.lastTokenLimChar();
              v8037.limChar = v27088;
            } else {
              var v21048 = TypeScript$$14.Modifiers;
              var v16124 = v21048.Exported;
              var v8038 = TypeScript$$14.hasFlag(modifiers$$12, v16124);
              if (v8038) {
                this.reportParseError("export keyword not permitted on import declaration");
              }
              ast$$44 = this.parseImportDeclaration(errorRecoverySet$$37, modifiers$$12);
              needTerminator = true;
            }
            break;
          case TypeScript$$14.TokenID.Export:
            var v24095 = TypeScript$$14.AllowedElements;
            var v21049 = v24095.ModuleDeclarations;
            var v16125 = allowedElements$$2 & v21049;
            var v21050 = TypeScript$$14.AllowedElements;
            var v16126 = v21050.None;
            var v8044 = v16125 == v16126;
            if (v8044) {
              this.reportParseError("'export' statements are only allowed at the global and module levels");
              var v8040 = this.scanner;
              var v27089 = v8040.scan();
              this.currentToken = v27089;
              var v8041 = TypeScript$$14.AST;
              var v16127 = TypeScript$$14.NodeType;
              var v8042 = v16127.Error;
              ast$$44 = new v8041(v8042);
              ast$$44.minChar = minChar$$27;
              var v8043 = ast$$44;
              var v16128 = this.scanner;
              var v27090 = v16128.lastTokenLimChar();
              v8043.limChar = v27090;
            }
            var v8045 = this.topLevel;
            if (v8045) {
              this.hasTopLevelImportOrExport = true;
            }
            var v21051 = TypeScript$$14.Modifiers;
            var v16129 = v21051.Exported;
            modifiers$$12 = modifiers$$12 | v16129;
            var v8046 = this.scanner;
            var v27091 = v8046.scan();
            this.currentToken = v27091;
            break;
          case TypeScript$$14.TokenID.Private:
            var v21052 = TypeScript$$14.Modifiers;
            var v16130 = v21052.Private;
            modifiers$$12 = modifiers$$12 | v16130;
            var v8047 = this.scanner;
            var v27092 = v8047.scan();
            this.currentToken = v27092;
            var v8074 = this.parsingClassConstructorDefinition;
            if (v8074) {
              var v16131 = this.inferPropertiesFromThisAssignment;
              var v8048 = !v16131;
              if (v8048) {
                this.reportParseError("Property declarations are not permitted within constructor bodies");
              }
              var v8049 = this.scanner;
              minChar$$27 = v8049.pos;
              var v16132 = this.inferPropertiesFromThisAssignment;
              if (v16132) {
                var v25565 = this.currentToken;
                var v24096 = v25565.tokenId;
                var v25566 = TypeScript$$14.TokenID;
                var v24097 = v25566.This;
                var v21053 = v24096 != v24097;
                var v24100 = !v21053;
                if (v24100) {
                  var v26230 = this.scanner;
                  var v27093 = v26230.scan();
                  var v25567 = this.currentToken = v27093;
                  var v24098 = v25567.tokenId;
                  var v25568 = TypeScript$$14.TokenID;
                  var v24099 = v25568.Dot;
                  v21053 = v24098 != v24099;
                }
                v16132 = v21053;
              }
              var v8061 = v16132;
              if (v8061) {
                this.reportParseError("Expected 'this.' for property declaration");
                var v8050 = this.scanner;
                var v27094 = v8050.scan();
                this.currentToken = v27094;
                var v8051 = TypeScript$$14.AST;
                var v16133 = TypeScript$$14.NodeType;
                var v8052 = v16133.Error;
                ast$$44 = new v8051(v8052);
                ast$$44.minChar = minChar$$27;
                var v8053 = ast$$44;
                var v16134 = this.scanner;
                var v27095 = v16134.lastTokenLimChar();
                v8053.limChar = v27095;
              } else {
                var v8054 = this.scanner;
                var v27096 = v8054.scan();
                this.currentToken = v27096;
                var v8055 = TypeScript$$14.Identifier;
                var v8056 = this.currentToken;
                var id$$14 = v8055.fromToken(v8056);
                var v8057 = this.scanner;
                id$$14.minChar = v8057.startPos;
                var v8058 = this.scanner;
                id$$14.limChar = v8058.pos;
                var v8059 = this.scanner;
                var v27097 = v8059.scan();
                this.currentToken = v27097;
                var v8060 = this.parsingClassConstructorDefinition;
                ast$$44 = this.parseClassMemberVariableDeclaration(id$$14, minChar$$27, v8060, errorRecoverySet$$37, modifiers$$12);
              }
            } else {
              var v21054 = this.currentToken;
              var v16135 = v21054.tokenId;
              var v21055 = TypeScript$$14.TokenID;
              var v16136 = v21055.Interface;
              var v8073 = v16135 != v16136;
              if (v8073) {
                var v21056 = this.currentToken;
                var v16137 = v21056.tokenId;
                var v21057 = TypeScript$$14.TokenID;
                var v16138 = v21057.Get;
                var v8069 = v16137 == v16138;
                if (v8069) {
                  this.prevIDTok = this.currentToken;
                  var v8062 = this.scanner;
                  var v27098 = v8062.scan();
                  this.currentToken = v27098;
                  var v16139 = TypeScript$$14.codeGenTarget;
                  var v21058 = TypeScript$$14.CodeGenTarget;
                  var v16140 = v21058.ES5;
                  var v8063 = v16139 < v16140;
                  if (v8063) {
                    this.reportParseError("Property accessors are only available when targeting ES5 or greater");
                  }
                  var v24101 = this.currentToken;
                  var v21059 = v24101.tokenId;
                  var v24102 = TypeScript$$14.TokenID;
                  var v21060 = v24102.Identifier;
                  var v16141 = v21059 == v21060;
                  var v21063 = !v16141;
                  if (v21063) {
                    var v21061 = this.currentToken;
                    var v21062 = this.strictMode;
                    v16141 = TypeScript$$14.convertTokToID(v21061, v21062);
                  }
                  var v8064 = v16141;
                  if (v8064) {
                    var v21064 = TypeScript$$14.Modifiers;
                    var v16142 = v21064.Getter;
                    modifiers$$12 = modifiers$$12 | v16142;
                    this.prevIDTok = null;
                  }
                } else {
                  var v21065 = this.currentToken;
                  var v16143 = v21065.tokenId;
                  var v21066 = TypeScript$$14.TokenID;
                  var v16144 = v21066.Set;
                  var v8068 = v16143 == v16144;
                  if (v8068) {
                    this.prevIDTok = this.currentToken;
                    var v8065 = this.scanner;
                    var v27099 = v8065.scan();
                    this.currentToken = v27099;
                    var v16145 = TypeScript$$14.codeGenTarget;
                    var v21067 = TypeScript$$14.CodeGenTarget;
                    var v16146 = v21067.ES5;
                    var v8066 = v16145 < v16146;
                    if (v8066) {
                      this.reportParseError("Property accessors are only available when targeting ES5 or greater");
                    }
                    var v24103 = this.currentToken;
                    var v21068 = v24103.tokenId;
                    var v24104 = TypeScript$$14.TokenID;
                    var v21069 = v24104.Identifier;
                    var v16147 = v21068 == v21069;
                    var v21072 = !v16147;
                    if (v21072) {
                      var v21070 = this.currentToken;
                      var v21071 = this.strictMode;
                      v16147 = TypeScript$$14.convertTokToID(v21070, v21071);
                    }
                    var v8067 = v16147;
                    if (v8067) {
                      var v21073 = TypeScript$$14.Modifiers;
                      var v16148 = v21073.Setter;
                      modifiers$$12 = modifiers$$12 | v16148;
                      this.prevIDTok = null;
                    }
                  }
                }
                var v21074 = TypeScript$$14.ErrorRecoverySet;
                var v16149 = v21074.SColon;
                var v8070 = errorRecoverySet$$37 | v16149;
                var v8071 = isAmbient$$3();
                fnOrVar = this.parsePropertyDeclaration(v8070, modifiers$$12, v8071, false);
                var v21075 = fnOrVar.nodeType;
                var v24105 = TypeScript$$14.NodeType;
                var v21076 = v24105.VarDecl;
                var v16150 = v21075 == v21076;
                var v21078 = !v16150;
                if (v21078) {
                  var v24106 = fnOrVar.nodeType;
                  var v25569 = TypeScript$$14.NodeType;
                  var v24107 = v25569.FuncDecl;
                  var v21077 = v24106 == v24107;
                  if (v21077) {
                    var v24108 = fnOrVar.fncFlags;
                    var v25570 = TypeScript$$14.FncFlags;
                    var v24109 = v25570.IsFatArrowFunction;
                    v21077 = TypeScript$$14.hasFlag(v24108, v24109);
                  }
                  v16150 = v21077;
                }
                var v8072 = v16150;
                if (v8072) {
                  needTerminator = true;
                }
                ast$$44 = fnOrVar;
              }
            }
            break;
          case TypeScript$$14.TokenID.Public:
            var v8107 = this.parsingClassConstructorDefinition;
            if (v8107) {
              var v16151 = this.inferPropertiesFromThisAssignment;
              var v8075 = !v16151;
              if (v8075) {
                this.reportParseError("Property declarations are not permitted within constructor bodies");
              }
              var v8076 = this.scanner;
              var v27100 = v8076.scan();
              this.currentToken = v27100;
              var v8077 = this.scanner;
              minChar$$27 = v8077.pos;
              var v21079 = TypeScript$$14.Modifiers;
              var v16152 = v21079.Public;
              modifiers$$12 = modifiers$$12 | v16152;
              var v16153 = this.inferPropertiesFromThisAssignment;
              if (v16153) {
                var v25571 = this.currentToken;
                var v24110 = v25571.tokenId;
                var v25572 = TypeScript$$14.TokenID;
                var v24111 = v25572.This;
                var v21080 = v24110 != v24111;
                var v24114 = !v21080;
                if (v24114) {
                  var v26231 = this.scanner;
                  var v27101 = v26231.scan();
                  var v25573 = this.currentToken = v27101;
                  var v24112 = v25573.tokenId;
                  var v25574 = TypeScript$$14.TokenID;
                  var v24113 = v25574.Dot;
                  v21080 = v24112 != v24113;
                }
                v16153 = v21080;
              }
              var v8089 = v16153;
              if (v8089) {
                this.reportParseError("Expected 'this.' for property declaration");
                var v8078 = this.scanner;
                var v27102 = v8078.scan();
                this.currentToken = v27102;
                var v8079 = TypeScript$$14.AST;
                var v16154 = TypeScript$$14.NodeType;
                var v8080 = v16154.Error;
                ast$$44 = new v8079(v8080);
                ast$$44.minChar = minChar$$27;
                var v8081 = ast$$44;
                var v16155 = this.scanner;
                var v27103 = v16155.lastTokenLimChar();
                v8081.limChar = v27103;
              } else {
                var v8082 = this.scanner;
                var v27104 = v8082.scan();
                this.currentToken = v27104;
                var v8083 = TypeScript$$14.Identifier;
                var v8084 = this.currentToken;
                id$$14 = v8083.fromToken(v8084);
                var v8085 = this.scanner;
                id$$14.minChar = v8085.startPos;
                var v8086 = this.scanner;
                id$$14.limChar = v8086.pos;
                var v8087 = this.scanner;
                var v27105 = v8087.scan();
                this.currentToken = v27105;
                var v8088 = this.parsingClassConstructorDefinition;
                ast$$44 = this.parseClassMemberVariableDeclaration(id$$14, minChar$$27, v8088, errorRecoverySet$$37, modifiers$$12);
              }
            } else {
              var v24115 = TypeScript$$14.AllowedElements;
              var v21081 = v24115.Properties;
              var v16156 = allowedElements$$2 & v21081;
              var v21082 = TypeScript$$14.AllowedElements;
              var v16157 = v21082.None;
              var v8106 = v16156 == v16157;
              if (v8106) {
                this.reportParseError("'property' statements are only allowed within classes");
                var v8090 = this.scanner;
                var v27106 = v8090.scan();
                this.currentToken = v27106;
                var v8091 = TypeScript$$14.AST;
                var v16158 = TypeScript$$14.NodeType;
                var v8092 = v16158.Error;
                ast$$44 = new v8091(v8092);
                ast$$44.minChar = minChar$$27;
                var v8093 = ast$$44;
                var v16159 = this.scanner;
                var v27107 = v16159.lastTokenLimChar();
                v8093.limChar = v27107;
              } else {
                var v21083 = TypeScript$$14.Modifiers;
                var v16160 = v21083.Public;
                modifiers$$12 = modifiers$$12 | v16160;
                var v8094 = this.scanner;
                var v27108 = v8094.scan();
                this.currentToken = v27108;
                var v21084 = this.currentToken;
                var v16161 = v21084.tokenId;
                var v21085 = TypeScript$$14.TokenID;
                var v16162 = v21085.Get;
                var v8102 = v16161 == v16162;
                if (v8102) {
                  this.prevIDTok = this.currentToken;
                  var v8095 = this.scanner;
                  var v27109 = v8095.scan();
                  this.currentToken = v27109;
                  var v16163 = TypeScript$$14.codeGenTarget;
                  var v21086 = TypeScript$$14.CodeGenTarget;
                  var v16164 = v21086.ES5;
                  var v8096 = v16163 < v16164;
                  if (v8096) {
                    this.reportParseError("Property accessors are only available when targeting ES5 or greater");
                  }
                  var v24116 = this.currentToken;
                  var v21087 = v24116.tokenId;
                  var v24117 = TypeScript$$14.TokenID;
                  var v21088 = v24117.Identifier;
                  var v16165 = v21087 == v21088;
                  var v21091 = !v16165;
                  if (v21091) {
                    var v21089 = this.currentToken;
                    var v21090 = this.strictMode;
                    v16165 = TypeScript$$14.convertTokToID(v21089, v21090);
                  }
                  var v8097 = v16165;
                  if (v8097) {
                    var v21092 = TypeScript$$14.Modifiers;
                    var v16166 = v21092.Getter;
                    modifiers$$12 = modifiers$$12 | v16166;
                    this.prevIDTok = null;
                  }
                } else {
                  var v21093 = this.currentToken;
                  var v16167 = v21093.tokenId;
                  var v21094 = TypeScript$$14.TokenID;
                  var v16168 = v21094.Set;
                  var v8101 = v16167 == v16168;
                  if (v8101) {
                    this.prevIDTok = this.currentToken;
                    var v8098 = this.scanner;
                    var v27110 = v8098.scan();
                    this.currentToken = v27110;
                    var v16169 = TypeScript$$14.codeGenTarget;
                    var v21095 = TypeScript$$14.CodeGenTarget;
                    var v16170 = v21095.ES5;
                    var v8099 = v16169 < v16170;
                    if (v8099) {
                      this.reportParseError("Property accessors are only available when targeting ES5 or greater");
                    }
                    var v24118 = this.currentToken;
                    var v21096 = v24118.tokenId;
                    var v24119 = TypeScript$$14.TokenID;
                    var v21097 = v24119.Identifier;
                    var v16171 = v21096 == v21097;
                    var v21100 = !v16171;
                    if (v21100) {
                      var v21098 = this.currentToken;
                      var v21099 = this.strictMode;
                      v16171 = TypeScript$$14.convertTokToID(v21098, v21099);
                    }
                    var v8100 = v16171;
                    if (v8100) {
                      var v21101 = TypeScript$$14.Modifiers;
                      var v16172 = v21101.Setter;
                      modifiers$$12 = modifiers$$12 | v16172;
                      this.prevIDTok = null;
                    }
                  }
                }
                var v21102 = TypeScript$$14.ErrorRecoverySet;
                var v16173 = v21102.SColon;
                var v8103 = errorRecoverySet$$37 | v16173;
                var v8104 = isAmbient$$3();
                fnOrVar = this.parsePropertyDeclaration(v8103, modifiers$$12, v8104, false);
                var v21103 = fnOrVar.nodeType;
                var v24120 = TypeScript$$14.NodeType;
                var v21104 = v24120.VarDecl;
                var v16174 = v21103 == v21104;
                var v21106 = !v16174;
                if (v21106) {
                  var v24121 = fnOrVar.nodeType;
                  var v25575 = TypeScript$$14.NodeType;
                  var v24122 = v25575.FuncDecl;
                  var v21105 = v24121 == v24122;
                  if (v21105) {
                    var v24123 = fnOrVar.fncFlags;
                    var v25576 = TypeScript$$14.FncFlags;
                    var v24124 = v25576.IsFatArrowFunction;
                    v21105 = TypeScript$$14.hasFlag(v24123, v24124);
                  }
                  v16174 = v21105;
                }
                var v8105 = v16174;
                if (v8105) {
                  needTerminator = true;
                }
                ast$$44 = fnOrVar;
              }
            }
            break;
          case TypeScript$$14.TokenID.Declare:
            var v24125 = TypeScript$$14.AllowedElements;
            var v21107 = v24125.AmbientDeclarations;
            var v16175 = allowedElements$$2 & v21107;
            var v8108 = !v16175;
            if (v8108) {
              this.reportParseError("Ambient declarations are only allowed at the top-level or module scopes");
            }
            var v21108 = this.parsingDeclareFile;
            var v16176 = !v21108;
            if (v16176) {
              var v24126 = TypeScript$$14.Modifiers;
              var v21109 = v24126.Ambient;
              v16176 = TypeScript$$14.hasFlag(parentModifiers$$7, v21109);
            }
            var v8109 = v16176;
            if (v8109) {
              this.reportParseError("Duplicate ambient declaration in this context. (Is the enclosing module or class already ambient?)");
            }
            var v21110 = TypeScript$$14.Modifiers;
            var v16177 = v21110.Ambient;
            modifiers$$12 = modifiers$$12 | v16177;
            var v8110 = this.scanner;
            var v27111 = v8110.scan();
            this.currentToken = v27111;
            break;
          case TypeScript$$14.TokenID.Class:
            var v24127 = TypeScript$$14.AllowedElements;
            var v21111 = v24127.ClassDeclarations;
            var v16178 = allowedElements$$2 & v21111;
            var v21112 = TypeScript$$14.AllowedElements;
            var v16179 = v21112.None;
            var v8115 = v16178 == v16179;
            if (v8115) {
              this.reportParseError("class not allowed in this context");
              var v8111 = this.scanner;
              var v27112 = v8111.scan();
              this.currentToken = v27112;
              var v8112 = TypeScript$$14.AST;
              var v16180 = TypeScript$$14.NodeType;
              var v8113 = v16180.Error;
              ast$$44 = new v8112(v8113);
              ast$$44.minChar = minChar$$27;
              var v8114 = ast$$44;
              var v16181 = this.scanner;
              var v27113 = v16181.lastTokenLimChar();
              v8114.limChar = v27113;
            } else {
              ast$$44 = this.parseClassDecl(errorRecoverySet$$37, minChar$$27, modifiers$$12);
            }
            break;
          case TypeScript$$14.TokenID.Interface:
            var v24128 = TypeScript$$14.AllowedElements;
            var v21113 = v24128.InterfaceDeclarations;
            var v16182 = allowedElements$$2 & v21113;
            var v21114 = TypeScript$$14.AllowedElements;
            var v16183 = v21114.None;
            var v8120 = v16182 == v16183;
            if (v8120) {
              this.reportParseError("interface not allowed in this context");
              var v8116 = this.scanner;
              var v27114 = v8116.scan();
              this.currentToken = v27114;
              var v8117 = TypeScript$$14.AST;
              var v16184 = TypeScript$$14.NodeType;
              var v8118 = v16184.Error;
              ast$$44 = new v8117(v8118);
              ast$$44.minChar = minChar$$27;
              var v8119 = ast$$44;
              var v16185 = this.scanner;
              var v27115 = v16185.lastTokenLimChar();
              v8119.limChar = v27115;
            } else {
              ast$$44 = this.parseInterfaceDecl(errorRecoverySet$$37, modifiers$$12);
            }
            break;
          case TypeScript$$14.TokenID.Var:
            var v21115 = TypeScript$$14.ErrorRecoverySet;
            var v16186 = v21115.StmtStart;
            var v8121 = errorRecoverySet$$37 | v16186;
            var declAst = this.parseVariableDeclaration(v8121, modifiers$$12, true, false);
            var v16187 = declAst.nodeType;
            var v21116 = TypeScript$$14.NodeType;
            var v16188 = v21116.VarDecl;
            var v8123 = v16187 == v16188;
            if (v8123) {
              ast$$44 = declAst;
            } else {
              var v8122 = TypeScript$$14.Block;
              ast$$44 = new v8122(declAst, false);
            }
            needTerminator = true;
            break;
          case TypeScript$$14.TokenID.Static:
            var v16189 = this.currentClassDecl;
            var v8124 = v16189 == null;
            if (v8124) {
              this.reportParseError("Statics may only be class members");
            }
            mayNotBeExported();
            var v21117 = TypeScript$$14.Modifiers;
            var v16190 = v21117.Public;
            modifiers$$12 = modifiers$$12 | v16190;
            var v8125 = this.scanner;
            var v27116 = v8125.scan();
            this.currentToken = v27116;
            var v21118 = this.currentToken;
            var v16191 = v21118.tokenId;
            var v21119 = TypeScript$$14.TokenID;
            var v16192 = v21119.Get;
            var v8133 = v16191 == v16192;
            if (v8133) {
              this.prevIDTok = this.currentToken;
              var v8126 = this.scanner;
              var v27117 = v8126.scan();
              this.currentToken = v27117;
              var v16193 = TypeScript$$14.codeGenTarget;
              var v21120 = TypeScript$$14.CodeGenTarget;
              var v16194 = v21120.ES5;
              var v8127 = v16193 < v16194;
              if (v8127) {
                this.reportParseError("Property accessors are only available when targeting ES5 or greater");
              }
              var v24129 = this.currentToken;
              var v21121 = v24129.tokenId;
              var v24130 = TypeScript$$14.TokenID;
              var v21122 = v24130.Identifier;
              var v16195 = v21121 == v21122;
              var v21125 = !v16195;
              if (v21125) {
                var v21123 = this.currentToken;
                var v21124 = this.strictMode;
                v16195 = TypeScript$$14.convertTokToID(v21123, v21124);
              }
              var v8128 = v16195;
              if (v8128) {
                var v21126 = TypeScript$$14.Modifiers;
                var v16196 = v21126.Getter;
                modifiers$$12 = modifiers$$12 | v16196;
                this.prevIDTok = null;
              }
            } else {
              var v21127 = this.currentToken;
              var v16197 = v21127.tokenId;
              var v21128 = TypeScript$$14.TokenID;
              var v16198 = v21128.Set;
              var v8132 = v16197 == v16198;
              if (v8132) {
                var v8129 = this.scanner;
                var v27118 = v8129.scan();
                this.currentToken = v27118;
                var v16199 = TypeScript$$14.codeGenTarget;
                var v21129 = TypeScript$$14.CodeGenTarget;
                var v16200 = v21129.ES5;
                var v8130 = v16199 < v16200;
                if (v8130) {
                  this.reportParseError("Property accessors are only available when targeting ES5 or greater");
                }
                var v24131 = this.currentToken;
                var v21130 = v24131.tokenId;
                var v24132 = TypeScript$$14.TokenID;
                var v21131 = v24132.Identifier;
                var v16201 = v21130 == v21131;
                var v21134 = !v16201;
                if (v21134) {
                  var v21132 = this.currentToken;
                  var v21133 = this.strictMode;
                  v16201 = TypeScript$$14.convertTokToID(v21132, v21133);
                }
                var v8131 = v16201;
                if (v8131) {
                  var v21135 = TypeScript$$14.Modifiers;
                  var v16202 = v21135.Setter;
                  modifiers$$12 = modifiers$$12 | v16202;
                }
              }
            }
            var v8134 = isAmbient$$3();
            if (v8134) {
              var v21136 = TypeScript$$14.Modifiers;
              var v16203 = v21136.Ambient;
              modifiers$$12 = modifiers$$12 | v16203;
            }
            var v21137 = TypeScript$$14.ErrorRecoverySet;
            var v16204 = v21137.SColon;
            var v8135 = errorRecoverySet$$37 | v16204;
            var v16205 = this.parsingDeclareFile;
            var v21140 = !v16205;
            if (v21140) {
              var v25577 = TypeScript$$14.Modifiers;
              var v24133 = v25577.Ambient;
              var v21138 = modifiers$$12 & v24133;
              var v24134 = TypeScript$$14.Modifiers;
              var v21139 = v24134.None;
              v16205 = v21138 != v21139;
            }
            var v8136 = v16205;
            fnOrVar = this.parsePropertyDeclaration(v8135, modifiers$$12, v8136, true);
            var staticsList = this.topStaticsList();
            var v16206 = staticsList;
            if (v16206) {
              var v21141 = fnOrVar.nodeType;
              var v24135 = TypeScript$$14.NodeType;
              var v21142 = v24135.VarDecl;
              v16206 = v21141 == v21142;
            }
            var v8137 = v16206;
            if (v8137) {
              staticsList.append(fnOrVar);
            }
            var v21143 = fnOrVar.nodeType;
            var v24136 = TypeScript$$14.NodeType;
            var v21144 = v24136.VarDecl;
            var v16207 = v21143 == v21144;
            var v21146 = !v16207;
            if (v21146) {
              var v24137 = fnOrVar.nodeType;
              var v25578 = TypeScript$$14.NodeType;
              var v24138 = v25578.FuncDecl;
              var v21145 = v24137 == v24138;
              if (v21145) {
                var v24139 = fnOrVar.fncFlags;
                var v25579 = TypeScript$$14.FncFlags;
                var v24140 = v25579.IsFatArrowFunction;
                v21145 = TypeScript$$14.hasFlag(v24139, v24140);
              }
              v16207 = v21145;
            }
            var v8138 = v16207;
            if (v8138) {
              needTerminator = true;
            }
            ast$$44 = fnOrVar;
            break;
          case TypeScript$$14.TokenID.For:
            mayNotBeExported();
            var v21147 = TypeScript$$14.Modifiers;
            var v16208 = v21147.None;
            var v8139 = modifiers$$12 != v16208;
            if (v8139) {
              this.reportParseError("syntax error: for statement does not take modifiers");
            }
            var v8140 = this.scanner;
            minChar$$27 = v8140.startPos;
            var v16209 = TypeScript$$14.TokenID;
            var v8141 = v16209.OpenParen;
            var v24141 = TypeScript$$14.ErrorRecoverySet;
            var v21148 = v24141.ExprStart;
            var v16210 = errorRecoverySet$$37 | v21148;
            var v21149 = TypeScript$$14.ErrorRecoverySet;
            var v16211 = v21149.Var;
            var v8142 = v16210 | v16211;
            this.checkNextToken(v8141, v8142);
            this.state = ParseState.ForInit;
            forInOk = true;
            var v16212 = this.currentToken;
            var v8148 = v16212.tokenId;
            switch(v8148) {
              case TypeScript$$14.TokenID.Var:
                var v24142 = TypeScript$$14.ErrorRecoverySet;
                var v21150 = v24142.SColon;
                var v16213 = errorRecoverySet$$37 | v21150;
                var v21151 = TypeScript$$14.ErrorRecoverySet;
                var v16214 = v21151.In;
                var v8143 = v16213 | v16214;
                var v16215 = TypeScript$$14.Modifiers;
                var v8144 = v16215.None;
                temp$$15 = this.parseVariableDeclaration(v8143, v8144, false, false);
                break;
              case TypeScript$$14.TokenID.Semicolon:
                temp$$15 = null;
                this.state = ParseState.ForCondStart;
                break;
              default:
                var v24143 = TypeScript$$14.ErrorRecoverySet;
                var v21152 = v24143.SColon;
                var v16216 = errorRecoverySet$$37 | v21152;
                var v21153 = TypeScript$$14.ErrorRecoverySet;
                var v16217 = v21153.In;
                var v8145 = v16216 | v16217;
                var v16218 = TypeScript$$14.OperatorPrecedence;
                var v8146 = v16218.None;
                var v8147 = TypeContext.NoTypes;
                temp$$15 = this.parseExpr(v8145, v8146, false, v8147);
            }
            this.state = ParseState.ForInitAfterVar;
            var v21154 = this.currentToken;
            var v16219 = v21154.tokenId;
            var v21155 = TypeScript$$14.TokenID;
            var v16220 = v21155.In;
            var v8176 = v16219 == v16220;
            if (v8176) {
              var v16221 = temp$$15 == null;
              var v21156 = !v16221;
              if (v21156) {
                v16221 = !forInOk;
              }
              var v8162 = v16221;
              if (v8162) {
                this.reportParseError("malformed for statement");
                var v8152 = this.errorRecovery;
                if (v8152) {
                  var v21157 = TypeScript$$14.ErrorRecoverySet;
                  var v16222 = v21157.StmtStart;
                  var v8149 = errorRecoverySet$$37 | v16222;
                  this.skip(v8149);
                  var v8150 = TypeScript$$14.AST;
                  var v16223 = TypeScript$$14.NodeType;
                  var v8151 = v16223.Empty;
                  ast$$44 = new v8150(v8151);
                  var v16224 = ast$$44.flags;
                  var v21158 = TypeScript$$14.ASTFlags;
                  var v16225 = v21158.Error;
                  ast$$44.flags = v16224 | v16225;
                }
              } else {
                var v8153 = this.scanner;
                var v27119 = v8153.scan();
                this.currentToken = v27119;
                var v8154 = TypeScript$$14.ForInStatement;
                var v24144 = TypeScript$$14.ErrorRecoverySet;
                var v21159 = v24144.RParen;
                var v16226 = v21159 | errorRecoverySet$$37;
                var v21160 = TypeScript$$14.OperatorPrecedence;
                var v16227 = v21160.Comma;
                var v16228 = TypeContext.NoTypes;
                var v8155 = this.parseExpr(v16226, v16227, false, v16228);
                var forInStmt = new v8154(temp$$15, v8155);
                var v8156 = this.scanner;
                forInStmt.limChar = v8156.pos;
                var v8157 = forInStmt.statement;
                v8157.minChar = minChar$$27;
                var v8158 = forInStmt.statement;
                var v16229 = this.scanner;
                v8158.limChar = v16229.pos;
                var v16230 = TypeScript$$14.TokenID;
                var v8159 = v16230.CloseParen;
                var v21161 = TypeScript$$14.ErrorRecoverySet;
                var v16231 = v21161.StmtStart;
                var v8160 = v16231 | errorRecoverySet$$37;
                this.checkCurrentToken(v8159, v8160);
                this.pushStmt(forInStmt, labelList$$1);
                var v8161 = forInStmt;
                var v27120 = this.parseStatement(errorRecoverySet$$37, allowedElements$$2, parentModifiers$$7);
                v8161.body = v27120;
                this.popStmt();
                forInStmt.minChar = minChar$$27;
                ast$$44 = forInStmt;
              }
            } else {
              var v8163 = TypeScript$$14.ForStatement;
              var forStmt = new v8163(temp$$15);
              forStmt.minChar = minChar$$27;
              var v16232 = TypeScript$$14.TokenID;
              var v8164 = v16232.Semicolon;
              this.checkCurrentToken(v8164, errorRecoverySet$$37);
              var v21162 = this.currentToken;
              var v16233 = v21162.tokenId;
              var v21163 = TypeScript$$14.TokenID;
              var v16234 = v21163.Semicolon;
              var v8168 = v16233 == v16234;
              if (v8168) {
                forStmt.cond = null;
              } else {
                var v8165 = forStmt;
                var v25580 = TypeScript$$14.ErrorRecoverySet;
                var v24145 = v25580.SColon;
                var v21164 = errorRecoverySet$$37 | v24145;
                var v24146 = TypeScript$$14.ErrorRecoverySet;
                var v21165 = v24146.RParen;
                var v16235 = v21164 | v21165;
                var v21166 = TypeScript$$14.OperatorPrecedence;
                var v16236 = v21166.None;
                var v16237 = TypeContext.NoTypes;
                var v27121 = this.parseExpr(v16235, v16236, true, v16237);
                v8165.cond = v27121;
                var v21167 = this.currentToken;
                var v16238 = v21167.tokenId;
                var v21168 = TypeScript$$14.TokenID;
                var v16239 = v21168.Semicolon;
                var v8167 = v16238 != v16239;
                if (v8167) {
                  var v21169 = TypeScript$$14.ErrorRecoverySet;
                  var v16240 = v21169.StmtStart;
                  var v8166 = errorRecoverySet$$37 | v16240;
                  this.skip(v8166);
                  ast$$44 = forStmt;
                  var v16241 = ast$$44.flags;
                  var v21170 = TypeScript$$14.ASTFlags;
                  var v16242 = v21170.Error;
                  ast$$44.flags = v16241 | v16242;
                }
              }
              var v8169 = this.scanner;
              var v27122 = v8169.scan();
              this.currentToken = v27122;
              var v21171 = this.currentToken;
              var v16243 = v21171.tokenId;
              var v21172 = TypeScript$$14.TokenID;
              var v16244 = v21172.CloseParen;
              var v8171 = v16243 == v16244;
              if (v8171) {
                forStmt.incr = null;
              } else {
                var v8170 = forStmt;
                var v25581 = TypeScript$$14.ErrorRecoverySet;
                var v24147 = v25581.SColon;
                var v21173 = errorRecoverySet$$37 | v24147;
                var v24148 = TypeScript$$14.ErrorRecoverySet;
                var v21174 = v24148.RParen;
                var v16245 = v21173 | v21174;
                var v21175 = TypeScript$$14.OperatorPrecedence;
                var v16246 = v21175.None;
                var v16247 = TypeContext.NoTypes;
                var v27123 = this.parseExpr(v16245, v16246, true, v16247);
                v8170.incr = v27123;
              }
              var v16248 = TypeScript$$14.TokenID;
              var v8172 = v16248.CloseParen;
              var v21176 = TypeScript$$14.ErrorRecoverySet;
              var v16249 = v21176.LCurly;
              var v8173 = errorRecoverySet$$37 | v16249;
              this.checkCurrentToken(v8172, v8173);
              this.pushStmt(forStmt, labelList$$1);
              var v8174 = forStmt;
              var v27124 = this.parseStatement(errorRecoverySet$$37, allowedElements$$2, parentModifiers$$7);
              v8174.body = v27124;
              this.popStmt();
              var v8175 = forStmt.body;
              forStmt.limChar = v8175.limChar;
              ast$$44 = forStmt;
            }
            break;
          case TypeScript$$14.TokenID.With:
            var v16250 = TypeScript$$14.codeGenTarget;
            var v21177 = TypeScript$$14.CodeGenTarget;
            var v16251 = v21177.ES5;
            var v8177 = v16250 < v16251;
            if (v8177) {
              this.reportParseError("'with' statements are only available in ES5 codegen mode or better");
            }
            var v8178 = this.strictMode;
            if (v8178) {
              this.reportParseError("'with' statements are not available in strict mode");
            }
            mayNotBeExported();
            var v21178 = TypeScript$$14.Modifiers;
            var v16252 = v21178.None;
            var v8179 = modifiers$$12 != v16252;
            if (v8179) {
              this.reportParseError("'with' statement does not take modifiers");
            }
            var v8180 = this.scanner;
            minChar$$27 = v8180.startPos;
            var v16253 = TypeScript$$14.TokenID;
            var v8181 = v16253.OpenParen;
            var v24149 = TypeScript$$14.ErrorRecoverySet;
            var v21179 = v24149.ExprStart;
            var v16254 = errorRecoverySet$$37 | v21179;
            var v21180 = TypeScript$$14.ErrorRecoverySet;
            var v16255 = v21180.Var;
            var v8182 = v16254 | v16255;
            this.checkNextToken(v8181, v8182);
            var v21181 = TypeScript$$14.ErrorRecoverySet;
            var v16256 = v21181.Colon;
            var v8183 = errorRecoverySet$$37 | v16256;
            var v16257 = TypeScript$$14.OperatorPrecedence;
            var v8184 = v16257.None;
            var v8185 = TypeContext.NoTypes;
            var expr$$5 = this.parseExpr(v8183, v8184, true, v8185);
            var v16258 = TypeScript$$14.TokenID;
            var v8186 = v16258.CloseParen;
            var v21182 = TypeScript$$14.ErrorRecoverySet;
            var v16259 = v21182.LCurly;
            var v8187 = errorRecoverySet$$37 | v16259;
            this.checkCurrentToken(v8186, v8187);
            var v8188 = TypeScript$$14.WithStatement;
            var withStmt = new v8188(expr$$5);
            var v8189 = withStmt;
            var v27125 = this.parseStatement(errorRecoverySet$$37, allowedElements$$2, parentModifiers$$7);
            v8189.body = v27125;
            withStmt.minChar = minChar$$27;
            var v8190 = withStmt.body;
            withStmt.limChar = v8190.limChar;
            ast$$44 = withStmt;
            break;
          case TypeScript$$14.TokenID.Switch:
            mayNotBeExported();
            var v21183 = TypeScript$$14.Modifiers;
            var v16260 = v21183.None;
            var v8191 = modifiers$$12 != v16260;
            if (v8191) {
              this.reportParseError("'switch' statement does not take modifiers");
            }
            var v16261 = TypeScript$$14.TokenID;
            var v8192 = v16261.OpenParen;
            var v21184 = TypeScript$$14.ErrorRecoverySet;
            var v16262 = v21184.ExprStart;
            var v8193 = errorRecoverySet$$37 | v16262;
            this.checkNextToken(v8192, v8193);
            var v8194 = TypeScript$$14.SwitchStatement;
            var v24150 = TypeScript$$14.ErrorRecoverySet;
            var v21185 = v24150.RParen;
            var v16263 = errorRecoverySet$$37 | v21185;
            var v21186 = TypeScript$$14.OperatorPrecedence;
            var v16264 = v21186.None;
            var v16265 = TypeContext.NoTypes;
            var v8195 = this.parseExpr(v16263, v16264, true, v16265);
            var switchStmt = new v8194(v8195);
            var v8196 = switchStmt.statement;
            v8196.minChar = minChar$$27;
            var v8197 = switchStmt.statement;
            var v16266 = this.scanner;
            v8197.limChar = v16266.pos;
            var v16267 = TypeScript$$14.TokenID;
            var v8198 = v16267.CloseParen;
            var v21187 = TypeScript$$14.ErrorRecoverySet;
            var v16268 = v21187.LCurly;
            var v8199 = errorRecoverySet$$37 | v16268;
            this.checkCurrentToken(v8198, v8199);
            var v8200 = this.scanner;
            var caseListMinChar = v8200.startPos;
            var v16269 = TypeScript$$14.TokenID;
            var v8201 = v16269.OpenBrace;
            var v21188 = TypeScript$$14.ErrorRecoverySet;
            var v16270 = v21188.SCase;
            var v8202 = errorRecoverySet$$37 | v16270;
            this.checkCurrentToken(v8201, v8202);
            switchStmt.defaultCase = null;
            var v8203 = switchStmt;
            var v16271 = TypeScript$$14.ASTList;
            var v27126 = new v16271;
            v8203.caseList = v27126;
            var caseStmt = null;
            this.pushStmt(switchStmt, labelList$$1);
            for (;;) {
              var v24151 = this.currentToken;
              var v21189 = v24151.tokenId;
              var v24152 = TypeScript$$14.TokenID;
              var v21190 = v24152.Case;
              var v16272 = v21189 == v21190;
              var v21193 = !v16272;
              if (v21193) {
                var v24153 = this.currentToken;
                var v21191 = v24153.tokenId;
                var v24154 = TypeScript$$14.TokenID;
                var v21192 = v24154.Default;
                v16272 = v21191 == v21192;
              }
              var v8217 = v16272;
              if (v8217) {
                var v16273 = this.currentToken;
                var v8204 = v16273.tokenId;
                var v16274 = TypeScript$$14.TokenID;
                var v8205 = v16274.Default;
                var isDefault = v8204 == v8205;
                var v8206 = TypeScript$$14.CaseStatement;
                caseStmt = new v8206;
                var v8207 = this.scanner;
                caseStmt.minChar = v8207.startPos;
                var v8208 = this.scanner;
                var v27127 = v8208.scan();
                this.currentToken = v27127;
                if (isDefault) {
                  switchStmt.defaultCase = caseStmt;
                } else {
                  var v8209 = caseStmt;
                  var v24155 = TypeScript$$14.ErrorRecoverySet;
                  var v21194 = v24155.Colon;
                  var v16275 = errorRecoverySet$$37 | v21194;
                  var v21195 = TypeScript$$14.OperatorPrecedence;
                  var v16276 = v21195.None;
                  var v16277 = TypeContext.NoTypes;
                  var v27128 = this.parseExpr(v16275, v16276, true, v16277);
                  v8209.expr = v27128;
                }
                var v16278 = TypeScript$$14.TokenID;
                var v8210 = v16278.Colon;
                var v21196 = TypeScript$$14.ErrorRecoverySet;
                var v16279 = v21196.StmtStart;
                var v8211 = errorRecoverySet$$37 | v16279;
                this.checkCurrentToken(v8210, v8211);
                var v8212 = caseStmt;
                var v16280 = TypeScript$$14.ASTList;
                var v27129 = new v16280;
                v8212.body = v27129;
                var v21197 = TypeScript$$14.ErrorRecoverySet;
                var v16281 = v21197.RCurly;
                var v8213 = errorRecoverySet$$37 | v16281;
                var v8214 = caseStmt.body;
                this.parseStatementList(v8213, v8214, false, true, allowedElements$$2, modifiers$$12);
                var v8215 = caseStmt.body;
                caseStmt.limChar = v8215.limChar;
                var v8216 = switchStmt.caseList;
                v8216.append(caseStmt);
              } else {
                break;
              }
            }
            var v8218 = switchStmt.caseList;
            v8218.minChar = caseListMinChar;
            var v8219 = switchStmt.caseList;
            var v16282 = this.scanner;
            v8219.limChar = v16282.pos;
            var v8220 = switchStmt.caseList;
            switchStmt.limChar = v8220.limChar;
            var v16283 = TypeScript$$14.TokenID;
            var v8221 = v16283.CloseBrace;
            this.checkCurrentToken(v8221, errorRecoverySet$$37);
            this.popStmt();
            ast$$44 = switchStmt;
            break;
          case TypeScript$$14.TokenID.While:
            mayNotBeExported();
            var v21198 = TypeScript$$14.Modifiers;
            var v16284 = v21198.None;
            var v8222 = modifiers$$12 != v16284;
            if (v8222) {
              this.reportParseError("'while' statement does not take modifiers");
            }
            var v8223 = this.scanner;
            minChar$$27 = v8223.startPos;
            var v16285 = TypeScript$$14.TokenID;
            var v8224 = v16285.OpenParen;
            var v21199 = TypeScript$$14.ErrorRecoverySet;
            var v16286 = v21199.ExprStart;
            var v8225 = v16286 | errorRecoverySet$$37;
            this.checkNextToken(v8224, v8225);
            var v8226 = TypeScript$$14.WhileStatement;
            var v24156 = TypeScript$$14.ErrorRecoverySet;
            var v21200 = v24156.RParen;
            var v16287 = errorRecoverySet$$37 | v21200;
            var v21201 = TypeScript$$14.OperatorPrecedence;
            var v16288 = v21201.None;
            var v16289 = TypeContext.NoTypes;
            var v8227 = this.parseExpr(v16287, v16288, true, v16289);
            var whileStmt = new v8226(v8227);
            whileStmt.minChar = minChar$$27;
            var v16290 = TypeScript$$14.TokenID;
            var v8228 = v16290.CloseParen;
            var v21202 = TypeScript$$14.ErrorRecoverySet;
            var v16291 = v21202.StmtStart;
            var v8229 = errorRecoverySet$$37 | v16291;
            this.checkCurrentToken(v8228, v8229);
            this.pushStmt(whileStmt, labelList$$1);
            var v8230 = whileStmt;
            var v27130 = this.parseStatement(errorRecoverySet$$37, allowedElements$$2, parentModifiers$$7);
            v8230.body = v27130;
            var v8231 = whileStmt.body;
            whileStmt.limChar = v8231.limChar;
            this.popStmt();
            ast$$44 = whileStmt;
            break;
          case TypeScript$$14.TokenID.Do:
            mayNotBeExported();
            var v21203 = TypeScript$$14.Modifiers;
            var v16292 = v21203.None;
            var v8232 = modifiers$$12 != v16292;
            if (v8232) {
              this.reportParseError("'do' statement does not take modifiers");
            }
            var v8233 = this.scanner;
            minChar$$27 = v8233.startPos;
            var v8234 = this.scanner;
            var v27131 = v8234.scan();
            this.currentToken = v27131;
            var v8235 = TypeScript$$14.DoWhileStatement;
            var doStmt = new v8235;
            doStmt.minChar = minChar$$27;
            this.pushStmt(doStmt, labelList$$1);
            var v8236 = doStmt;
            var v24157 = TypeScript$$14.ErrorRecoverySet;
            var v21204 = v24157.While;
            var v16293 = errorRecoverySet$$37 | v21204;
            var v27132 = this.parseStatement(v16293, allowedElements$$2, parentModifiers$$7);
            v8236.body = v27132;
            this.popStmt();
            var v8237 = doStmt;
            var v16294 = TypeScript$$14.Identifier;
            var v27133 = new v16294("while");
            v8237.whileAST = v27133;
            var v8238 = doStmt.whileAST;
            var v16295 = this.scanner;
            v8238.minChar = v16295.startPos;
            var v16296 = TypeScript$$14.TokenID;
            var v8239 = v16296.While;
            var v21205 = TypeScript$$14.ErrorRecoverySet;
            var v16297 = v21205.LParen;
            var v8240 = errorRecoverySet$$37 | v16297;
            this.checkCurrentToken(v8239, v8240);
            var v8241 = doStmt.whileAST;
            var v21206 = doStmt.whileAST;
            var v16298 = v21206.minChar;
            v8241.limChar = v16298 + 5;
            var v16299 = TypeScript$$14.TokenID;
            var v8242 = v16299.OpenParen;
            var v21207 = TypeScript$$14.ErrorRecoverySet;
            var v16300 = v21207.ExprStart;
            var v8243 = errorRecoverySet$$37 | v16300;
            this.checkCurrentToken(v8242, v8243);
            var v8244 = doStmt;
            var v24158 = TypeScript$$14.ErrorRecoverySet;
            var v21208 = v24158.RParen;
            var v16301 = errorRecoverySet$$37 | v21208;
            var v21209 = TypeScript$$14.OperatorPrecedence;
            var v16302 = v21209.None;
            var v16303 = TypeContext.NoTypes;
            var v27134 = this.parseExpr(v16301, v16302, true, v16303);
            v8244.cond = v27134;
            var v8245 = this.scanner;
            doStmt.limChar = v8245.pos;
            var v16304 = TypeScript$$14.TokenID;
            var v8246 = v16304.CloseParen;
            this.checkCurrentToken(v8246, errorRecoverySet$$37);
            ast$$44 = doStmt;
            var v21210 = this.currentToken;
            var v16305 = v21210.tokenId;
            var v21211 = TypeScript$$14.TokenID;
            var v16306 = v21211.Semicolon;
            var v8248 = v16305 == v16306;
            if (v8248) {
              var v8247 = this.scanner;
              var v27135 = v8247.scan();
              this.currentToken = v27135;
            }
            break;
          case TypeScript$$14.TokenID.If:
            mayNotBeExported();
            var v21212 = TypeScript$$14.Modifiers;
            var v16307 = v21212.None;
            var v8249 = modifiers$$12 != v16307;
            if (v8249) {
              this.reportParseError("if statement does not take modifiers");
            }
            var v8250 = this.scanner;
            minChar$$27 = v8250.startPos;
            var v16308 = TypeScript$$14.TokenID;
            var v8251 = v16308.OpenParen;
            var v21213 = TypeScript$$14.ErrorRecoverySet;
            var v16309 = v21213.ExprStart;
            var v8252 = errorRecoverySet$$37 | v16309;
            this.checkNextToken(v8251, v8252);
            var v8253 = TypeScript$$14.IfStatement;
            var v24159 = TypeScript$$14.ErrorRecoverySet;
            var v21214 = v24159.LParen;
            var v16310 = errorRecoverySet$$37 | v21214;
            var v21215 = TypeScript$$14.OperatorPrecedence;
            var v16311 = v21215.None;
            var v16312 = TypeContext.NoTypes;
            var v8254 = this.parseExpr(v16310, v16311, true, v16312);
            var ifStmt = new v8253(v8254);
            ifStmt.minChar = minChar$$27;
            var v8255 = ifStmt.statement;
            v8255.minChar = minChar$$27;
            var v8256 = ifStmt.statement;
            var v16313 = this.scanner;
            v8256.limChar = v16313.pos;
            var v16314 = TypeScript$$14.TokenID;
            var v8257 = v16314.CloseParen;
            var v21216 = TypeScript$$14.ErrorRecoverySet;
            var v16315 = v21216.StmtStart;
            var v8258 = errorRecoverySet$$37 | v16315;
            this.checkCurrentToken(v8257, v8258);
            this.pushStmt(ifStmt, labelList$$1);
            var v8259 = ifStmt;
            var v24160 = TypeScript$$14.ErrorRecoverySet;
            var v21217 = v24160.Else;
            var v16316 = v21217 | errorRecoverySet$$37;
            var v27136 = this.parseStatement(v16316, allowedElements$$2, parentModifiers$$7);
            v8259.thenBod = v27136;
            var v8260 = ifStmt.thenBod;
            ifStmt.limChar = v8260.limChar;
            var v21218 = this.currentToken;
            var v16317 = v21218.tokenId;
            var v21219 = TypeScript$$14.TokenID;
            var v16318 = v21219.Else;
            var v8264 = v16317 == v16318;
            if (v8264) {
              var v8261 = this.scanner;
              var v27137 = v8261.scan();
              this.currentToken = v27137;
              var v8262 = ifStmt;
              var v27138 = this.parseStatement(errorRecoverySet$$37, allowedElements$$2, parentModifiers$$7);
              v8262.elseBod = v27138;
              var v8263 = ifStmt.elseBod;
              ifStmt.limChar = v8263.limChar;
            }
            this.popStmt();
            ast$$44 = ifStmt;
            break;
          case TypeScript$$14.TokenID.Try:
            mayNotBeExported();
            var v21220 = TypeScript$$14.Modifiers;
            var v16319 = v21220.None;
            var v8265 = modifiers$$12 != v16319;
            if (v8265) {
              this.reportParseError("try statement does not take modifiers");
            }
            var v8266 = this.scanner;
            minChar$$27 = v8266.startPos;
            ast$$44 = this.parseTryCatchFinally(errorRecoverySet$$37, parentModifiers$$7, labelList$$1);
            break;
          case TypeScript$$14.TokenID.OpenBrace:
            mayNotBeExported();
            var v21221 = TypeScript$$14.Modifiers;
            var v16320 = v21221.None;
            var v8267 = modifiers$$12 != v16320;
            if (v8267) {
              this.reportParseError("block does not take modifiers");
            }
            var v8268 = this.scanner;
            minChar$$27 = v8268.startPos;
            var v8269 = this.scanner;
            var v27139 = v8269.scan();
            this.currentToken = v27139;
            var v8270 = TypeScript$$14.Block;
            var v16321 = TypeScript$$14.ASTList;
            var v8271 = new v16321;
            var block$$1 = new v8270(v8271, true);
            this.pushStmt(block$$1, labelList$$1);
            var v21222 = TypeScript$$14.ErrorRecoverySet;
            var v16322 = v21222.RCurly;
            var v8272 = errorRecoverySet$$37 | v16322;
            var v8273 = block$$1.statements;
            var v16323 = TypeScript$$14.AllowedElements;
            var v8274 = v16323.None;
            this.parseStatementList(v8272, v8273, false, false, v8274, modifiers$$12);
            this.popStmt();
            var v8275 = block$$1.statements;
            v8275.minChar = minChar$$27;
            var v8276 = block$$1.statements;
            var v16324 = this.scanner;
            v8276.limChar = v16324.pos;
            var v8277 = block$$1.statements;
            block$$1.minChar = v8277.minChar;
            var v8278 = block$$1.statements;
            block$$1.limChar = v8278.limChar;
            var v16325 = TypeScript$$14.TokenID;
            var v8279 = v16325.CloseBrace;
            this.checkCurrentToken(v8279, errorRecoverySet$$37);
            ast$$44 = block$$1;
            break;
          case TypeScript$$14.TokenID.Semicolon:
            mayNotBeExported();
            var v21223 = TypeScript$$14.Modifiers;
            var v16326 = v21223.None;
            var v8280 = modifiers$$12 != v16326;
            if (v8280) {
              this.reportParseError("modifier can not appear here");
            }
            var v8281 = TypeScript$$14.AST;
            var v16327 = TypeScript$$14.NodeType;
            var v8282 = v16327.Empty;
            ast$$44 = new v8281(v8282);
            var v8283 = this.scanner;
            var v27140 = v8283.scan();
            this.currentToken = v27140;
            break;
          case TypeScript$$14.TokenID.Break:
          ;
          case TypeScript$$14.TokenID.Continue:
            mayNotBeExported();
            var v21224 = TypeScript$$14.Modifiers;
            var v16328 = v21224.None;
            var v8284 = modifiers$$12 != v16328;
            if (v8284) {
              this.reportParseError("modifiers can not appear before jump statement");
            }
            var v8285 = TypeScript$$14.Jump;
            var v16329;
            var v25582 = this.currentToken;
            var v24161 = v25582.tokenId;
            var v25583 = TypeScript$$14.TokenID;
            var v24162 = v25583.Break;
            var v21227 = v24161 == v24162;
            if (v21227) {
              var v21225 = TypeScript$$14.NodeType;
              v16329 = v21225.Break;
            } else {
              var v21226 = TypeScript$$14.NodeType;
              v16329 = v21226.Continue;
            }
            var v8286 = v16329;
            var jump$$1 = new v8285(v8286);
            var v8287 = this.scanner;
            var v27141 = v8287.scan();
            this.currentToken = v27141;
            var v24163 = this.currentToken;
            var v21228 = v24163.tokenId;
            var v24164 = TypeScript$$14.TokenID;
            var v21229 = v24164.Identifier;
            var v16330 = v21228 == v21229;
            if (v16330) {
              var v24165 = this.scanner;
              var v21230 = v24165.lastTokenHadNewline();
              v16330 = !v21230;
            }
            var v8290 = v16330;
            if (v8290) {
              var v8288 = jump$$1;
              var v16331 = this.currentToken;
              var v27142 = v16331.getText();
              v8288.target = v27142;
              var v8289 = this.scanner;
              var v27143 = v8289.scan();
              this.currentToken = v27143;
            }
            this.resolveJumpTarget(jump$$1);
            ast$$44 = jump$$1;
            needTerminator = true;
            break;
          case TypeScript$$14.TokenID.Return:
            mayNotBeExported();
            var v21231 = TypeScript$$14.Modifiers;
            var v16332 = v21231.None;
            var v8291 = modifiers$$12 != v16332;
            if (v8291) {
              this.reportParseError("modifiers can not appear before return statement");
            }
            var v16333 = this.inFunction;
            var v8292 = !v16333;
            if (v8292) {
              this.reportParseError("return statement outside of function body");
            }
            var v8293 = this.scanner;
            minChar$$27 = v8293.startPos;
            var v8294 = this.scanner;
            var v27144 = v8294.scan();
            this.currentToken = v27144;
            var v8295 = TypeScript$$14.ReturnStatement;
            var retStmt$$1 = new v8295;
            retStmt$$1.minChar = minChar$$27;
            var v25584 = this.currentToken;
            var v24166 = v25584.tokenId;
            var v25585 = TypeScript$$14.TokenID;
            var v24167 = v25585.Semicolon;
            var v21232 = v24166 != v24167;
            if (v21232) {
              var v25586 = this.currentToken;
              var v24168 = v25586.tokenId;
              var v25587 = TypeScript$$14.TokenID;
              var v24169 = v25587.CloseBrace;
              v21232 = v24168 != v24169;
            }
            var v16334 = v21232;
            if (v16334) {
              var v24170 = this.scanner;
              var v21233 = v24170.lastTokenHadNewline();
              v16334 = !v21233;
            }
            var v8297 = v16334;
            if (v8297) {
              var v8296 = retStmt$$1;
              var v24171 = TypeScript$$14.ErrorRecoverySet;
              var v21234 = v24171.SColon;
              var v16335 = errorRecoverySet$$37 | v21234;
              var v21235 = TypeScript$$14.OperatorPrecedence;
              var v16336 = v21235.None;
              var v16337 = TypeContext.NoTypes;
              var v27145 = this.parseExpr(v16335, v16336, true, v16337);
              v8296.returnExpression = v27145;
            }
            needTerminator = true;
            var v8298 = retStmt$$1;
            var v16338 = this.scanner;
            var v27146 = v16338.lastTokenLimChar();
            v8298.limChar = v27146;
            ast$$44 = retStmt$$1;
            break;
          case TypeScript$$14.TokenID.Throw:
            mayNotBeExported();
            var v21236 = TypeScript$$14.Modifiers;
            var v16339 = v21236.None;
            var v8299 = modifiers$$12 != v16339;
            if (v8299) {
              this.reportParseError("modifiers can not appear before a throw statement");
            }
            var v8300 = this.scanner;
            minChar$$27 = v8300.startPos;
            var v8301 = this.scanner;
            var v27147 = v8301.scan();
            this.currentToken = v27147;
            var v25588 = this.currentToken;
            var v24172 = v25588.tokenId;
            var v25589 = TypeScript$$14.TokenID;
            var v24173 = v25589.Semicolon;
            var v21237 = v24172 != v24173;
            if (v21237) {
              var v25590 = this.currentToken;
              var v24174 = v25590.tokenId;
              var v25591 = TypeScript$$14.TokenID;
              var v24175 = v25591.CloseBrace;
              v21237 = v24174 != v24175;
            }
            var v16340 = v21237;
            if (v16340) {
              var v24176 = this.scanner;
              var v21238 = v24176.lastTokenHadNewline();
              v16340 = !v21238;
            }
            var v8305 = v16340;
            if (v8305) {
              var v21239 = TypeScript$$14.ErrorRecoverySet;
              var v16341 = v21239.SColon;
              var v8302 = errorRecoverySet$$37 | v16341;
              var v16342 = TypeScript$$14.OperatorPrecedence;
              var v8303 = v16342.None;
              var v8304 = TypeContext.NoTypes;
              temp$$15 = this.parseExpr(v8302, v8303, true, v8304);
            } else {
              this.reportParseError("throw with no target");
              temp$$15 = null;
            }
            var v8306 = TypeScript$$14.UnaryExpression;
            var v16343 = TypeScript$$14.NodeType;
            var v8307 = v16343.Throw;
            ast$$44 = new v8306(v8307, temp$$15);
            var v8308 = ast$$44;
            var v16344 = this.scanner;
            var v27148 = v16344.lastTokenLimChar();
            v8308.limChar = v27148;
            needTerminator = true;
            break;
          case TypeScript$$14.TokenID.Enum:
            var v8309 = this.scanner;
            var v27149 = v8309.scan();
            this.currentToken = v27149;
            ast$$44 = this.parseEnumDecl(errorRecoverySet$$37, modifiers$$12);
            ast$$44.minChar = minChar$$27;
            var v8310 = ast$$44;
            var v16345 = this.scanner;
            var v27150 = v16345.lastTokenLimChar();
            v8310.limChar = v27150;
            var v21240 = this.parsingDeclareFile;
            var v24177 = !v21240;
            if (v24177) {
              v21240 = this.ambientModule;
            }
            var v16346 = v21240;
            var v21242 = !v16346;
            if (v21242) {
              var v24178 = TypeScript$$14.Modifiers;
              var v21241 = v24178.Ambient;
              v16346 = TypeScript$$14.hasFlag(modifiers$$12, v21241);
            }
            var v8311 = v16346;
            if (v8311) {
              var v16347 = ast$$44.modFlags;
              var v21243 = TypeScript$$14.ModuleFlags;
              var v16348 = v21243.Ambient;
              ast$$44.modFlags = v16347 | v16348;
            }
            var v21244 = this.parsingDeclareFile;
            var v24179 = !v21244;
            if (v24179) {
              v21244 = this.ambientModule;
            }
            var v16349 = v21244;
            var v21246 = !v16349;
            if (v21246) {
              var v24180 = TypeScript$$14.Modifiers;
              var v21245 = v24180.Exported;
              v16349 = TypeScript$$14.hasFlag(modifiers$$12, v21245);
            }
            var v8312 = v16349;
            if (v8312) {
              var v16350 = ast$$44.modFlags;
              var v21247 = TypeScript$$14.ModuleFlags;
              var v16351 = v21247.Exported;
              ast$$44.modFlags = v16350 | v16351;
            }
            break;
          case TypeScript$$14.TokenID.Debugger:
            mayNotBeExported();
            var v21248 = TypeScript$$14.Modifiers;
            var v16352 = v21248.None;
            var v8313 = modifiers$$12 != v16352;
            if (v8313) {
              this.reportParseError("modifiers can not appear before debugger statement");
            }
            var v8314 = this.scanner;
            minChar$$27 = v8314.startPos;
            var v8315 = this.scanner;
            var v27151 = v8315.scan();
            this.currentToken = v27151;
            var v8316 = TypeScript$$14.DebuggerStatement;
            var debuggerStmt = new v8316;
            debuggerStmt.minChar = minChar$$27;
            needTerminator = true;
            var v8317 = debuggerStmt;
            var v16353 = this.scanner;
            var v27152 = v16353.lastTokenLimChar();
            v8317.limChar = v27152;
            ast$$44 = debuggerStmt;
            break;
          default:
            var v21249 = TypeScript$$14.Modifiers;
            var v16354 = v21249.None;
            var v8318 = modifiers$$12 != v16354;
            if (v8318) {
              this.reportParseError("modifiers can not appear before an expression statement or label");
            }
            var v8319 = this.scanner;
            minChar$$27 = v8319.startPos;
            var v8320 = this.scanner;
            var svPos = v8320.pos;
            var v24181 = TypeScript$$14.ErrorRecoverySet;
            var v21250 = v24181.Colon;
            var v24182 = TypeScript$$14.ErrorRecoverySet;
            var v21251 = v24182.StmtStart;
            var v16355 = v21250 | v21251;
            var v8321 = v16355 | errorRecoverySet$$37;
            var v16356 = TypeScript$$14.OperatorPrecedence;
            var v8322 = v16356.None;
            var v8323 = TypeContext.NoTypes;
            temp$$15 = this.parseExpr(v8321, v8322, true, v8323);
            var v21252 = this.scanner;
            var v16357 = v21252.pos;
            var v8330 = v16357 == svPos;
            if (v8330) {
              var v8324 = this.scanner;
              var v27153 = v8324.scan();
              this.currentToken = v27153;
              ast$$44 = temp$$15;
            } else {
              var v26232 = this.currentToken;
              var v25592 = v26232.tokenId;
              var v26233 = TypeScript$$14.TokenID;
              var v25593 = v26233.Colon;
              var v24183 = v25592 == v25593;
              if (v24183) {
                var v26234 = this.scanner;
                var v25594 = v26234.lastTokenHadNewline();
                v24183 = !v25594;
              }
              var v21253 = v24183;
              if (v21253) {
                v21253 = temp$$15;
              }
              var v16358 = v21253;
              if (v16358) {
                var v21254 = temp$$15.nodeType;
                var v24184 = TypeScript$$14.NodeType;
                var v21255 = v24184.Name;
                v16358 = v21254 == v21255;
              }
              var v8329 = v16358;
              if (v8329) {
                var v8326 = labelList$$1 == null;
                if (v8326) {
                  var v8325 = TypeScript$$14.ASTList;
                  labelList$$1 = new v8325;
                }
                var v16359 = TypeScript$$14.Label;
                var v8327 = new v16359(temp$$15);
                labelList$$1.append(v8327);
                var v8328 = this.scanner;
                var v27154 = v8328.scan();
                this.currentToken = v27154;
              } else {
                ast$$44 = temp$$15;
                needTerminator = true;
              }
            }
          ;
        }
        if (ast$$44) {
          break;
        }
      }
      if (needTerminator) {
        var v16360 = this.currentToken;
        var v8337 = v16360.tokenId;
        switch(v8337) {
          case TypeScript$$14.TokenID.Semicolon:
            var v8332 = this.scanner;
            var v27155 = v8332.scan();
            this.currentToken = v27155;
            var v16361 = ast$$44.flags;
            var v21256 = TypeScript$$14.ASTFlags;
            var v16362 = v21256.ExplicitSemicolon;
            ast$$44.flags = v16361 | v16362;
            break;
          case TypeScript$$14.TokenID.EndOfFile:
            var v8333 = this.scanner;
            ast$$44.limChar = v8333.pos;
          case TypeScript$$14.TokenID.CloseBrace:
            var v16363 = ast$$44.flags;
            var v21257 = TypeScript$$14.ASTFlags;
            var v16364 = v21257.AutomaticSemicolon;
            ast$$44.flags = v16363 | v16364;
            var v8334 = this.style_requireSemi;
            if (v8334) {
              this.reportParseStyleError("no automatic semicolon");
            }
            break;
          default:
            var v21258 = this.scanner;
            var v16365 = v21258.lastTokenHadNewline();
            var v8336 = !v16365;
            if (v8336) {
              this.reportParseError("Expected ';'");
            } else {
              var v16366 = ast$$44.flags;
              var v21259 = TypeScript$$14.ASTFlags;
              var v16367 = v21259.AutomaticSemicolon;
              ast$$44.flags = v16366 | v16367;
              var v8335 = this.style_requireSemi;
              if (v8335) {
                this.reportParseStyleError("no automatic semicolon");
              }
            }
          ;
        }
      }
      if (labelList$$1) {
        var v8338 = TypeScript$$14.LabeledStatement;
        ast$$44 = new v8338(labelList$$1, ast$$44);
      }
      ast$$44.minChar = minChar$$27;
      var v8339 = ast$$44;
      var v16368 = ast$$44.limChar;
      var v21260 = this.scanner;
      var v16369 = v21260.lastTokenLimChar();
      var v27156 = TypeScript$$14.max(v16368, v16369);
      v8339.limChar = v27156;
      if (preComments$$8) {
        ast$$44.preComments = preComments$$8;
      }
      var v16370 = this.ambientModule;
      if (v16370) {
        var v21261 = this.okAmbientModuleMember(ast$$44);
        v16370 = !v21261;
      }
      var v8340 = v16370;
      if (v8340) {
        this.reportParseError("statement not permitted within ambient module");
      }
      var v16371 = ast$$44.flags;
      var v21262 = TypeScript$$14.ASTFlags;
      var v16372 = v21262.IsStatement;
      ast$$44.flags = v16371 | v16372;
      return ast$$44;
    }
    function v584(errorRecoverySet$$36, parentModifiers$$6, labelList) {
      var v8341 = TypeScript$$14.Try;
      var tryPart = new v8341(null);
      var v8342 = this.scanner;
      var tryMinChar = v8342.startPos;
      this.pushStmt(tryPart, labelList);
      var v21263 = TypeScript$$14.ErrorRecoverySet;
      var v16373 = v21263.Catch;
      var v8343 = errorRecoverySet$$36 | v16373;
      this.parseTry(tryPart, v8343, parentModifiers$$6);
      this.popStmt();
      var tc$$1 = null;
      var tf = null;
      var v21264 = this.currentToken;
      var v16374 = v21264.tokenId;
      var v21265 = TypeScript$$14.TokenID;
      var v16375 = v21265.Catch;
      var v8346 = v16374 == v16375;
      if (v8346) {
        var v21266 = TypeScript$$14.ErrorRecoverySet;
        var v16376 = v21266.Catch;
        var v8344 = errorRecoverySet$$36 | v16376;
        var catchPart = this.parseCatch(v8344, parentModifiers$$6);
        var v8345 = TypeScript$$14.TryCatch;
        tc$$1 = new v8345(tryPart, catchPart);
        tc$$1.minChar = tryPart.minChar;
        tc$$1.limChar = catchPart.limChar;
      }
      var v21267 = this.currentToken;
      var v16377 = v21267.tokenId;
      var v21268 = TypeScript$$14.TokenID;
      var v16378 = v21268.Finally;
      var v8356 = v16377 != v16378;
      if (v8356) {
        var v8354 = tc$$1 == null;
        if (v8354) {
          this.reportParseError("try with neither catch nor finally");
          var v8351 = this.errorRecovery;
          if (v8351) {
            var v8347 = TypeScript$$14.TryFinally;
            var v16379 = TypeScript$$14.Finally;
            var v21269 = TypeScript$$14.AST;
            var v24185 = TypeScript$$14.NodeType;
            var v21270 = v24185.Empty;
            var v16380 = new v21269(v21270);
            var v8348 = new v16379(v16380);
            var etf = new v8347(tryPart, v8348);
            var v16381 = etf.flags;
            var v21271 = TypeScript$$14.ASTFlags;
            var v16382 = v21271.Error;
            etf.flags = v16381 | v16382;
            var v8349 = this.scanner;
            etf.minChar = v8349.startPos;
            var v8350 = this.scanner;
            etf.limChar = v8350.pos;
            return etf;
          }
          var v8352 = TypeScript$$14.TryFinally;
          var v16383 = TypeScript$$14.Finally;
          var v21272 = TypeScript$$14.AST;
          var v24186 = TypeScript$$14.NodeType;
          var v21273 = v24186.Empty;
          var v16384 = new v21272(v21273);
          var v8353 = new v16383(v16384);
          return new v8352(tryPart, v8353);
        } else {
          return tc$$1;
        }
      } else {
        if (tc$$1) {
          tryPart = tc$$1;
        }
        var finallyPart = this.parseFinally(errorRecoverySet$$36, parentModifiers$$6);
        var v8355 = TypeScript$$14.TryFinally;
        tf = new v8355(tryPart, finallyPart);
        tf.minChar = tryMinChar;
        tf.limChar = finallyPart.limChar;
        return tf;
      }
      return;
    }
    function v583(errorRecoverySet$$35, parentModifiers$$5) {
      var v8357 = this.scanner;
      var finMinChar = v8357.startPos;
      var preComments$$7 = this.parseComments();
      var v8358 = this.scanner;
      var v27157 = v8358.scan();
      this.currentToken = v27157;
      var v21274 = this.currentToken;
      var v16385 = v21274.tokenId;
      var v21275 = TypeScript$$14.TokenID;
      var v16386 = v21275.OpenBrace;
      var v8364 = v16385 != v16386;
      if (v8364) {
        this.reportParseError("Expected '{' to start body of finally statement");
        var v8363 = this.errorRecovery;
        if (v8363) {
          this.skip(errorRecoverySet$$35);
          var v8359 = TypeScript$$14.Finally;
          var v16387 = TypeScript$$14.Statement;
          var v21276 = TypeScript$$14.NodeType;
          var v16388 = v21276.Empty;
          var v8360 = new v16387(v16388);
          var efin = new v8359(v8360);
          var v16389 = efin.flags;
          var v21277 = TypeScript$$14.ASTFlags;
          var v16390 = v21277.Error;
          efin.flags = v16389 | v16390;
          var v8361 = this.scanner;
          efin.minChar = v8361.startPos;
          var v8362 = this.scanner;
          efin.limChar = v8362.pos;
          return efin;
        }
      }
      var v16391 = TypeScript$$14.AllowedElements;
      var v8365 = v16391.None;
      var finBody = this.parseStatement(errorRecoverySet$$35, v8365, parentModifiers$$5);
      var v8366 = TypeScript$$14.Finally;
      var fin = new v8366(finBody);
      fin.minChar = finMinChar;
      var v8367 = fin.body;
      fin.limChar = v8367.limChar;
      fin.preComments = preComments$$7;
      var v8368 = fin;
      var v27158 = this.parseComments();
      v8368.postComments = v27158;
      return fin;
    }
    function v582(errorRecoverySet$$34, parentModifiers$$4) {
      var v8369 = this.scanner;
      var catchMinChar = v8369.startPos;
      var preComments$$6 = this.parseComments();
      var v8370 = this.scanner;
      var v27159 = v8370.scan();
      this.currentToken = v27159;
      var v16392 = TypeScript$$14.TokenID;
      var v8371 = v16392.OpenParen;
      var v21278 = TypeScript$$14.ErrorRecoverySet;
      var v16393 = v21278.ExprStart;
      var v8372 = errorRecoverySet$$34 | v16393;
      this.checkCurrentToken(v8371, v8372);
      var v24187 = this.currentToken;
      var v21279 = v24187.tokenId;
      var v24188 = TypeScript$$14.TokenID;
      var v21280 = v24188.Identifier;
      var v16394 = v21279 != v21280;
      var v21283 = !v16394;
      if (v21283) {
        var v21281 = this.currentToken;
        var v21282 = this.strictMode;
        v16394 = TypeScript$$14.convertTokToID(v21281, v21282);
      }
      var v8381 = v16394;
      if (v8381) {
        this.reportParseError("Expected identifier in catch header");
        var v8380 = this.errorRecovery;
        if (v8380) {
          this.skip(errorRecoverySet$$34);
          var v8373 = TypeScript$$14.Catch;
          var v16395 = TypeScript$$14.VarDecl;
          var v21284 = TypeScript$$14.MissingIdentifier;
          var v16396 = new v21284;
          var v16397 = this.nestingLevel;
          var v8374 = new v16395(v16396, v16397);
          var v16398 = TypeScript$$14.Statement;
          var v21285 = TypeScript$$14.NodeType;
          var v16399 = v21285.Empty;
          var v8375 = new v16398(v16399);
          var ecatch = new v8373(v8374, v8375);
          var v8376 = ecatch.statement;
          v8376.minChar = catchMinChar;
          var v8377 = ecatch.statement;
          var v16400 = this.scanner;
          v8377.limChar = v16400.pos;
          var v8378 = this.scanner;
          ecatch.minChar = v8378.startPos;
          var v8379 = this.scanner;
          ecatch.limChar = v8379.pos;
          var v16401 = ecatch.flags;
          var v21286 = TypeScript$$14.ASTFlags;
          var v16402 = v21286.Error;
          ecatch.flags = v16401 | v16402;
          return ecatch;
        }
      }
      var v8382 = TypeScript$$14.VarDecl;
      var v16403 = TypeScript$$14.Identifier;
      var v16404 = this.currentToken;
      var v8383 = v16403.fromToken(v16404);
      var v8384 = this.nestingLevel;
      var param$$5 = new v8382(v8383, v8384);
      var v8385 = param$$5.id;
      var v16405 = this.scanner;
      v8385.minChar = v16405.startPos;
      var v8386 = param$$5.id;
      var v16406 = this.scanner;
      v8386.limChar = v16406.pos;
      var v8387 = param$$5.id;
      param$$5.minChar = v8387.minChar;
      var v8388 = param$$5.id;
      param$$5.limChar = v8388.limChar;
      var v8389 = this.scanner;
      var v27160 = v8389.scan();
      this.currentToken = v27160;
      var v8390 = this.scanner;
      var statementPos = v8390.pos;
      var v16407 = TypeScript$$14.TokenID;
      var v8391 = v16407.CloseParen;
      var v21287 = TypeScript$$14.ErrorRecoverySet;
      var v16408 = v21287.StmtStart;
      var v8392 = errorRecoverySet$$34 | v16408;
      this.checkCurrentToken(v8391, v8392);
      var v21288 = this.currentToken;
      var v16409 = v21288.tokenId;
      var v21289 = TypeScript$$14.TokenID;
      var v16410 = v21289.OpenBrace;
      var v8401 = v16409 != v16410;
      if (v8401) {
        this.reportParseError("Expected '{' to start catch body");
        var v8400 = this.errorRecovery;
        if (v8400) {
          this.skip(errorRecoverySet$$34);
          var v8393 = TypeScript$$14.Catch;
          var v16411 = TypeScript$$14.VarDecl;
          var v21290 = TypeScript$$14.MissingIdentifier;
          var v16412 = new v21290;
          var v16413 = this.nestingLevel;
          var v8394 = new v16411(v16412, v16413);
          var v16414 = TypeScript$$14.Statement;
          var v21291 = TypeScript$$14.NodeType;
          var v16415 = v21291.Empty;
          var v8395 = new v16414(v16415);
          ecatch = new v8393(v8394, v8395);
          var v8396 = ecatch.statement;
          v8396.minChar = catchMinChar;
          var v8397 = ecatch.statement;
          v8397.limChar = statementPos;
          var v8398 = this.scanner;
          ecatch.minChar = v8398.startPos;
          var v8399 = this.scanner;
          ecatch.limChar = v8399.pos;
          var v16416 = ecatch.flags;
          var v21292 = TypeScript$$14.ASTFlags;
          var v16417 = v21292.Error;
          ecatch.flags = v16416 | v16417;
          return ecatch;
        }
      }
      var v16418 = TypeScript$$14.AllowedElements;
      var v8402 = v16418.None;
      var catchStmt = this.parseStatement(errorRecoverySet$$34, v8402, parentModifiers$$4);
      var v8403 = TypeScript$$14.Catch;
      var catchNode$$1 = new v8403(param$$5, catchStmt);
      var v8404 = catchNode$$1.statement;
      v8404.minChar = catchMinChar;
      var v8405 = catchNode$$1.statement;
      v8405.limChar = statementPos;
      catchNode$$1.minChar = catchMinChar;
      catchNode$$1.limChar = catchStmt.limChar;
      catchNode$$1.preComments = preComments$$6;
      var v8406 = catchNode$$1;
      var v27161 = this.parseComments();
      v8406.postComments = v27161;
      return catchNode$$1;
    }
    function v581(tryNode$$2, errorRecoverySet$$33, parentModifiers$$3) {
      var v8407 = this.scanner;
      var minChar$$26 = v8407.startPos;
      var preComments$$5 = this.parseComments();
      var v8408 = this.scanner;
      var v27162 = v8408.scan();
      this.currentToken = v27162;
      var v21293 = this.currentToken;
      var v16419 = v21293.tokenId;
      var v21294 = TypeScript$$14.TokenID;
      var v16420 = v21294.OpenBrace;
      var v8411 = v16419 != v16420;
      if (v8411) {
        this.reportParseError("Expected '{'");
        var v8410 = this.errorRecovery;
        if (v8410) {
          var etryNode = tryNode$$2;
          etryNode.minChar = minChar$$26;
          var v8409 = etryNode;
          var v16421 = this.scanner;
          var v27163 = v16421.lastTokenLimChar();
          v8409.limChar = v27163;
          var v16422 = etryNode.flags;
          var v21295 = TypeScript$$14.ASTFlags;
          var v16423 = v21295.Error;
          etryNode.flags = v16422 | v16423;
          return etryNode;
        }
      }
      var v8412 = tryNode$$2;
      var v21296 = TypeScript$$14.AllowedElements;
      var v16424 = v21296.None;
      var v27164 = this.parseStatement(errorRecoverySet$$33, v16424, parentModifiers$$3);
      v8412.body = v27164;
      tryNode$$2.minChar = minChar$$26;
      var v8413 = tryNode$$2.body;
      tryNode$$2.limChar = v8413.limChar;
      tryNode$$2.preComments = preComments$$5;
      var v8414 = tryNode$$2;
      var v27165 = this.parseComments();
      v8414.postComments = v27165;
      return tryNode$$2;
    }
    function v580(errorRecoverySet$$32, ast$$43, allowCall$$1, inNew$$1, typeContext$$2, lhsMinChar, lhsLimChar) {
      var count$$4 = 0;
      var v8417 = !ast$$43;
      if (v8417) {
        var v8415 = TypeScript$$14.AST;
        var v16425 = TypeScript$$14.NodeType;
        var v8416 = v16425.EmptyExpr;
        ast$$43 = new v8415(v8416);
        ast$$43.isParenthesized = true;
      }
      ast$$43.minChar = lhsMinChar;
      ast$$43.limChar = lhsLimChar;
      for (;;) {
        var v16426 = this.currentToken;
        var v8456 = v16426.tokenId;
        switch(v8456) {
          case TypeScript$$14.TokenID.OpenParen:
            if (inNew$$1) {
              var callExpr = ast$$43;
              var v8418 = callExpr;
              var v27166 = this.parseArgList(errorRecoverySet$$32);
              v8418.arguments = v27166;
              inNew$$1 = false;
            } else {
              var v8419 = !allowCall$$1;
              if (v8419) {
                return ast$$43;
              }
              var v8420 = TypeScript$$14.CallExpression;
              var v16427 = TypeScript$$14.NodeType;
              var v8421 = v16427.Call;
              var v8422 = this.parseArgList(errorRecoverySet$$32);
              ast$$43 = new v8420(v8421, ast$$43, v8422);
              ast$$43.minChar = lhsMinChar;
            }
            var v8423 = this.scanner;
            ast$$43.limChar = v8423.pos;
            var v16428 = TypeScript$$14.TokenID;
            var v8424 = v16428.CloseParen;
            this.checkCurrentToken(v8424, errorRecoverySet$$32);
            break;
          case TypeScript$$14.TokenID.OpenBracket:
            var v8425 = this.scanner;
            var v27167 = v8425.scan();
            this.currentToken = v27167;
            var v21297 = this.currentToken;
            var v16429 = v21297.tokenId;
            var v21298 = TypeScript$$14.TokenID;
            var v16430 = v21298.CloseBracket;
            var v8432 = v16429 == v16430;
            if (v8432) {
              var v16431 = TypeContext.ArraySuffix;
              var v8431 = TypeScript$$14.hasFlag(typeContext$$2, v16431);
              if (v8431) {
                var v8426 = this.scanner;
                var v27168 = v8426.scan();
                this.currentToken = v27168;
                var v16432 = ast$$43.nodeType;
                var v21299 = TypeScript$$14.NodeType;
                var v16433 = v21299.TypeRef;
                var v8429 = v16432 == v16433;
                if (v8429) {
                  var typeRef$$1 = ast$$43;
                  var v16434 = typeRef$$1.arrayCount;
                  typeRef$$1.arrayCount = v16434 + 1;
                } else {
                  var v8427 = TypeScript$$14.BinaryExpression;
                  var v16435 = TypeScript$$14.NodeType;
                  var v8428 = v16435.Index;
                  ast$$43 = new v8427(v8428, ast$$43, null);
                }
                var v8430 = this.scanner;
                ast$$43.limChar = v8430.pos;
                break;
              }
            }
            var v8433 = TypeScript$$14.BinaryExpression;
            var v16436 = TypeScript$$14.NodeType;
            var v8434 = v16436.Index;
            var v24189 = TypeScript$$14.ErrorRecoverySet;
            var v21300 = v24189.RBrack;
            var v16437 = errorRecoverySet$$32 | v21300;
            var v21301 = TypeScript$$14.OperatorPrecedence;
            var v16438 = v21301.None;
            var v16439 = TypeContext.NoTypes;
            var v8435 = this.parseExpr(v16437, v16438, true, v16439);
            ast$$43 = new v8433(v8434, ast$$43, v8435);
            ast$$43.minChar = lhsMinChar;
            var v8436 = this.scanner;
            ast$$43.limChar = v8436.pos;
            var v16440 = TypeScript$$14.TokenID;
            var v8437 = v16440.CloseBracket;
            this.checkCurrentToken(v8437, errorRecoverySet$$32);
            break;
          case TypeScript$$14.TokenID.Dot:
            var name$$51 = null;
            var v8438 = this.scanner;
            var curpos$$2 = v8438.pos;
            var v8439 = this.scanner;
            var v27169 = v8439.scan();
            this.currentToken = v27169;
            var v16441 = this.currentToken;
            var v8441 = v16441 === undefined;
            if (v8441) {
              var v8440 = this.scanner;
              var v27170 = v8440.scan();
              this.currentToken = v27170;
              continue;
            }
            var v24190 = this.currentToken;
            var v21302 = v24190.tokenId;
            var v24191 = TypeScript$$14.TokenID;
            var v21303 = v24191.Identifier;
            var v16442 = v21302 == v21303;
            var v21305 = !v16442;
            if (v21305) {
              var v25595 = this.errorRecovery;
              var v24192 = !v25595;
              var v25597 = !v24192;
              if (v25597) {
                var v26235 = this.scanner;
                var v25596 = v26235.lastTokenHadNewline();
                v24192 = !v25596;
              }
              var v21304 = v24192;
              if (v21304) {
                var v24193 = this.currentToken;
                v21304 = TypeScript$$14.convertTokToIDName(v24193);
              }
              v16442 = v21304;
            }
            var v8449 = v16442;
            if (v8449) {
              var v16443 = ast$$43.flags;
              var v21306 = TypeScript$$14.ASTFlags;
              var v16444 = v21306.DotLHS;
              ast$$43.flags = v16443 | v16444;
              var v16445 = this.currentToken;
              var v8442 = v16445.getText();
              var v16446 = this.currentToken;
              var v8443 = v16446.hasEscapeSequence;
              var v16447 = this.scanner;
              var v8444 = v16447.startPos;
              name$$51 = this.createRef(v8442, v8443, v8444);
              var v8445 = this.scanner;
              name$$51.limChar = v8445.pos;
              var v8446 = this.scanner;
              var v27171 = v8446.scan();
              this.currentToken = v27171;
            } else {
              this.reportParseError("Expected identifier following dot");
              var v8448 = this.errorRecovery;
              if (v8448) {
                this.skip(errorRecoverySet$$32);
                var v16448 = ast$$43.flags;
                var v24194 = TypeScript$$14.ASTFlags;
                var v21307 = v24194.Error;
                var v24195 = TypeScript$$14.ASTFlags;
                var v21308 = v24195.DotLHS;
                var v16449 = v21307 | v21308;
                ast$$43.flags = v16448 | v16449;
                return ast$$43;
              } else {
                var v8447 = TypeScript$$14.MissingIdentifier;
                name$$51 = new v8447;
              }
            }
            var v8450 = TypeScript$$14.BinaryExpression;
            var v16450 = TypeScript$$14.NodeType;
            var v8451 = v16450.Dot;
            ast$$43 = new v8450(v8451, ast$$43, name$$51);
            ast$$43.minChar = lhsMinChar;
            var v8452 = ast$$43;
            var v16451 = this.scanner;
            var v27172 = v16451.lastTokenLimChar();
            v8452.limChar = v27172;
            break;
          case TypeScript$$14.TokenID.EqualsGreaterThan:
            var v16452 = TypeScript$$14.Modifiers;
            var v8453 = v16452.None;
            var v8454 = {preProcessedLambdaArgs:ast$$43};
            ast$$43 = this.parseFncDecl(errorRecoverySet$$32, false, false, false, null, false, false, false, v8453, v8454, false);
            var v16453 = ast$$43.fncFlags;
            var v21309 = TypeScript$$14.FncFlags;
            var v16454 = v21309.IsFunctionExpression;
            ast$$43.fncFlags = v16453 | v16454;
            ast$$43.minChar = lhsMinChar;
            var v8455 = ast$$43;
            var v16455 = this.scanner;
            var v27173 = v16455.lastTokenLimChar();
            v8455.limChar = v27173;
            break;
          default:
            return ast$$43;
        }
      }
      return;
    }
    function v579(errorRecoverySet$$31, minPrecedence, allowIn$$1, typeContext$$1, possiblyInLambda) {
      var v16456 = typeof possiblyInLambda;
      var v8457 = v16456 === "undefined";
      if (v8457) {
        possiblyInLambda = false;
      }
      var ast$$42 = null;
      var v16457 = this.currentToken;
      var v8458 = v16457.tokenId;
      var tokenInfo$$1 = TypeScript$$14.lookupToken(v8458);
      var canAssign = true;
      var idHint$$1 = null;
      var v8459 = this.scanner;
      var minChar$$25 = v8459.startPos;
      var preComments$$4 = this.parseComments();
      var exprIsAnonLambda = false;
      var v16458 = tokenInfo$$1 != undefined;
      if (v16458) {
        var v21310 = tokenInfo$$1.unopNodeType;
        var v24196 = TypeScript$$14.NodeType;
        var v21311 = v24196.None;
        v16458 = v21310 != v21311;
      }
      var v8486 = v16458;
      if (v8486) {
        canAssign = false;
        var v8460 = this.scanner;
        var v27174 = v8460.scan();
        this.currentToken = v27174;
        var v21312 = TypeScript$$14.ErrorRecoverySet;
        var v16459 = v21312.BinOp;
        var v8461 = v16459 | errorRecoverySet$$31;
        var v8462 = tokenInfo$$1.unopPrecedence;
        var v8463 = TypeContext.NoTypes;
        var tempExpr = this.parseExpr(v8461, v8462, allowIn$$1, v8463);
        var v21313 = tokenInfo$$1.unopNodeType;
        var v24197 = TypeScript$$14.NodeType;
        var v21314 = v24197.Pos;
        var v16460 = v21313 == v21314;
        if (v16460) {
          var v21315 = tempExpr.nodeType;
          var v24198 = TypeScript$$14.NodeType;
          var v21316 = v24198.NumberLit;
          v16460 = v21315 == v21316;
        }
        var v8469 = v16460;
        if (v8469) {
          ast$$42 = tempExpr;
        } else {
          var v21317 = tokenInfo$$1.unopNodeType;
          var v24199 = TypeScript$$14.NodeType;
          var v21318 = v24199.Neg;
          var v16461 = v21317 == v21318;
          if (v16461) {
            var v21319 = tempExpr.nodeType;
            var v24200 = TypeScript$$14.NodeType;
            var v21320 = v24200.NumberLit;
            v16461 = v21319 == v21320;
          }
          var v8468 = v16461;
          if (v8468) {
            var numLit$$1 = tempExpr;
            var v8464 = numLit$$1.value;
            numLit$$1.value = -v8464;
            var v16462 = numLit$$1.value;
            var v8465 = v16462 == 0;
            if (v8465) {
              numLit$$1.isNegativeZero = true;
            }
            ast$$42 = tempExpr;
          } else {
            var v8466 = TypeScript$$14.UnaryExpression;
            var v8467 = tokenInfo$$1.unopNodeType;
            ast$$42 = new v8466(v8467, tempExpr);
            ast$$42.limChar = tempExpr.limChar;
          }
        }
        ast$$42.minChar = minChar$$25;
      } else {
        var v24201 = TypeScript$$14.ErrorRecoverySet;
        var v21321 = v24201.BinOp;
        var v24202 = TypeScript$$14.ErrorRecoverySet;
        var v21322 = v24202.AddOp;
        var v16463 = v21321 | v21322;
        var v8470 = v16463 | errorRecoverySet$$31;
        ast$$42 = this.parseTerm(v8470, true, typeContext$$1, false);
        var id$$13;
        var temp$$14;
        var v16464 = ast$$42.nodeType;
        var v21323 = TypeScript$$14.NodeType;
        var v16465 = v21323.Name;
        var v8480 = v16464 == v16465;
        if (v8480) {
          id$$13 = ast$$42;
          idHint$$1 = id$$13.actualText;
        } else {
          var v16466 = ast$$42.nodeType;
          var v21324 = TypeScript$$14.NodeType;
          var v16467 = v21324.Dot;
          var v8479 = v16466 == v16467;
          if (v8479) {
            var subsumedExpr = false;
            var v25598 = this.inferPropertiesFromThisAssignment;
            if (v25598) {
              var v26639 = this.currentToken;
              var v26507 = v26639.tokenId;
              var v26640 = TypeScript$$14.TokenID;
              var v26508 = v26640.Colon;
              var v26236 = v26507 == v26508;
              var v26511 = !v26236;
              if (v26511) {
                var v26641 = this.currentToken;
                var v26509 = v26641.tokenId;
                var v26642 = TypeScript$$14.TokenID;
                var v26510 = v26642.Equals;
                v26236 = v26509 == v26510;
              }
              v25598 = v26236;
            }
            var v24203 = v25598;
            if (v24203) {
              v24203 = this.parsingClassConstructorDefinition;
            }
            var v21325 = v24203;
            if (v21325) {
              var v24204 = this.nestingLevel;
              var v25599 = this.currentClassDefinition;
              var v24205 = v25599.constructorNestingLevel;
              v21325 = v24204 == v24205;
            }
            var v16468 = v21325;
            if (v16468) {
              var v24206 = ast$$42.operand1;
              var v21326 = v24206.nodeType;
              var v24207 = TypeScript$$14.NodeType;
              var v21327 = v24207.This;
              v16468 = v21326 == v21327;
            }
            var v8475 = v16468;
            if (v8475) {
              var v21328 = ast$$42.operand2;
              var v16469 = v21328.nodeType;
              var v21329 = TypeScript$$14.NodeType;
              var v16470 = v21329.Name;
              var v8474 = v16469 == v16470;
              if (v8474) {
                var op2ID = ast$$42.operand2;
                var v24208 = this.currentClassDefinition;
                var v21330 = v24208.knownMemberNames;
                var v21331 = op2ID.actualText;
                var v16471 = v21330[v21331];
                var v8473 = !v16471;
                if (v8473) {
                  var v8471 = ast$$42.minChar;
                  var v16472 = TypeScript$$14.Modifiers;
                  var v8472 = v16472.Public;
                  ast$$42 = this.parseClassMemberVariableDeclaration(op2ID, v8471, true, errorRecoverySet$$31, v8472);
                  subsumedExpr = true;
                }
              }
            }
            var v8478 = !subsumedExpr;
            if (v8478) {
              temp$$14 = ast$$42;
              var v16473 = temp$$14.nodeType;
              var v21332 = TypeScript$$14.NodeType;
              var v16474 = v21332.Dot;
              var v8476 = v16473 == v16474;
              for (;v8476;) {
                var binExpr$$1 = temp$$14;
                temp$$14 = binExpr$$1.operand2;
                var v16475 = temp$$14.nodeType;
                var v21333 = TypeScript$$14.NodeType;
                var v16476 = v21333.Dot;
                v8476 = v16475 == v16476;
              }
              var v16477 = temp$$14.nodeType;
              var v21334 = TypeScript$$14.NodeType;
              var v16478 = v21334.Name;
              var v8477 = v16477 == v16478;
              if (v8477) {
                id$$13 = temp$$14;
                idHint$$1 = id$$13.actualText;
              }
            }
          }
        }
        var v24209 = this.scanner;
        var v21335 = v24209.lastTokenHadNewline();
        var v16479 = !v21335;
        if (v16479) {
          var v25600 = this.currentToken;
          var v24210 = v25600.tokenId;
          var v25601 = TypeScript$$14.TokenID;
          var v24211 = v25601.PlusPlus;
          var v21336 = v24210 == v24211;
          var v24214 = !v21336;
          if (v24214) {
            var v25602 = this.currentToken;
            var v24212 = v25602.tokenId;
            var v25603 = TypeScript$$14.TokenID;
            var v24213 = v25603.MinusMinus;
            v21336 = v24212 == v24213;
          }
          v16479 = v21336;
        }
        var v8485 = v16479;
        if (v8485) {
          canAssign = false;
          var operand$$2 = ast$$42;
          var v8481 = TypeScript$$14.UnaryExpression;
          var v16480;
          var v25604 = this.currentToken;
          var v24215 = v25604.tokenId;
          var v25605 = TypeScript$$14.TokenID;
          var v24216 = v25605.PlusPlus;
          var v21339 = v24215 == v24216;
          if (v21339) {
            var v21337 = TypeScript$$14.NodeType;
            v16480 = v21337.IncPost;
          } else {
            var v21338 = TypeScript$$14.NodeType;
            v16480 = v21338.DecPost;
          }
          var v8482 = v16480;
          ast$$42 = new v8481(v8482, operand$$2);
          var v8483 = this.scanner;
          ast$$42.limChar = v8483.pos;
          ast$$42.minChar = operand$$2.minChar;
          var v8484 = this.scanner;
          var v27175 = v8484.scan();
          this.currentToken = v27175;
        }
      }
      for (;;) {
        var v16481 = this.currentToken;
        var v8487 = v16481.tokenId;
        tokenInfo$$1 = TypeScript$$14.lookupToken(v8487);
        var v16482 = tokenInfo$$1 == undefined;
        var v21342 = !v16482;
        if (v21342) {
          var v21340 = tokenInfo$$1.binopNodeType;
          var v24217 = TypeScript$$14.NodeType;
          var v21341 = v24217.None;
          v16482 = v21340 == v21341;
        }
        var v8488 = v16482;
        if (v8488) {
          break;
        }
        var v16483 = !allowIn$$1;
        if (v16483) {
          var v21343 = tokenInfo$$1.binopNodeType;
          var v24218 = TypeScript$$14.NodeType;
          var v21344 = v24218.In;
          v16483 = v21343 == v21344;
        }
        var v8489 = v16483;
        if (v8489) {
          break;
        }
        var v16484 = tokenInfo$$1.binopPrecedence;
        var v21345 = TypeScript$$14.OperatorPrecedence;
        var v16485 = v21345.Assignment;
        var v8493 = v16484 == v16485;
        if (v8493) {
          var v16486 = tokenInfo$$1.binopPrecedence;
          var v8490 = v16486 < minPrecedence;
          if (v8490) {
            break;
          }
          var v8491 = !canAssign;
          if (v8491) {
            this.reportParseError("illegal assignment");
          }
        } else {
          var v16487 = tokenInfo$$1.binopPrecedence;
          var v8492 = v16487 <= minPrecedence;
          if (v8492) {
            break;
          }
        }
        var v21346 = possiblyInLambda;
        if (v21346) {
          var v25606 = this.currentToken;
          var v24219 = v25606.tokenId;
          var v25607 = TypeScript$$14.TokenID;
          var v24220 = v25607.Comma;
          v21346 = v24219 == v24220;
        }
        var v16488 = v21346;
        if (v16488) {
          var v25608 = this.scanner;
          var v24221 = v25608.getLookAheadToken();
          var v21347 = v24221.tokenId;
          var v24222 = TypeScript$$14.TokenID;
          var v21348 = v24222.DotDotDot;
          v16488 = v21347 == v21348;
        }
        var v8494 = v16488;
        if (v8494) {
          exprIsAnonLambda = true;
          canAssign = false;
          ast$$42 = this.parseLambdaExpr(errorRecoverySet$$31, ast$$42, false, true);
          break;
        }
        var v8495 = this.scanner;
        var v27176 = v8495.scan();
        this.currentToken = v27176;
        canAssign = false;
        var v16489 = tokenInfo$$1.binopNodeType;
        var v21349 = TypeScript$$14.NodeType;
        var v16490 = v21349.ConditionalExpression;
        var v8511 = v16489 == v16490;
        if (v8511) {
          var v16491 = possiblyInLambda;
          if (v16491) {
            var v26512 = this.currentToken;
            var v26237 = v26512.tokenId;
            var v26513 = TypeScript$$14.TokenID;
            var v26238 = v26513.Equals;
            var v25609 = v26237 == v26238;
            var v26241 = !v25609;
            if (v26241) {
              var v26514 = this.currentToken;
              var v26239 = v26514.tokenId;
              var v26515 = TypeScript$$14.TokenID;
              var v26240 = v26515.Colon;
              v25609 = v26239 == v26240;
            }
            var v24223 = v25609;
            var v25612 = !v24223;
            if (v25612) {
              var v26242 = this.currentToken;
              var v25610 = v26242.tokenId;
              var v26243 = TypeScript$$14.TokenID;
              var v25611 = v26243.CloseParen;
              v24223 = v25610 == v25611;
            }
            var v21350 = v24223;
            var v24226 = !v21350;
            if (v24226) {
              var v25613 = this.currentToken;
              var v24224 = v25613.tokenId;
              var v25614 = TypeScript$$14.TokenID;
              var v24225 = v25614.Comma;
              v21350 = v24224 == v24225;
            }
            v16491 = v21350;
          }
          var v8505 = v16491;
          if (v8505) {
            exprIsAnonLambda = true;
            canAssign = true;
          } else {
            this.prevExpr = ast$$42;
            var v21351 = TypeScript$$14.ErrorRecoverySet;
            var v16492 = v21351.Colon;
            var v8496 = errorRecoverySet$$31 | v16492;
            var v16493 = TypeScript$$14.OperatorPrecedence;
            var v8497 = v16493.Assignment;
            var v8498 = TypeContext.NoTypes;
            var whenTrue = this.parseExpr(v8496, v8497, allowIn$$1, v8498);
            this.prevExpr = null;
            var v16494 = TypeScript$$14.TokenID;
            var v8499 = v16494.Colon;
            var v21352 = TypeScript$$14.ErrorRecoverySet;
            var v16495 = v21352.ExprStart;
            var v8500 = errorRecoverySet$$31 | v16495;
            this.checkCurrentToken(v8499, v8500);
            var v21353 = TypeScript$$14.ErrorRecoverySet;
            var v16496 = v21353.BinOp;
            var v8501 = errorRecoverySet$$31 | v16496;
            var v16497 = TypeScript$$14.OperatorPrecedence;
            var v8502 = v16497.Assignment;
            var v8503 = TypeContext.NoTypes;
            var whenFalse = this.parseExpr(v8501, v8502, allowIn$$1, v8503);
            var v8504 = TypeScript$$14.ConditionalExpression;
            ast$$42 = new v8504(ast$$42, whenTrue, whenFalse);
          }
        } else {
          var tc = TypeContext.NoTypes;
          var binExpr2;
          var v8506 = TypeScript$$14.BinaryExpression;
          var v8507 = tokenInfo$$1.binopNodeType;
          var v24227 = TypeScript$$14.ErrorRecoverySet;
          var v21354 = v24227.BinOp;
          var v16498 = errorRecoverySet$$31 | v21354;
          var v16499 = tokenInfo$$1.binopPrecedence;
          var v16500 = TypeContext.NoTypes;
          var v8508 = this.parseExpr(v16498, v16499, allowIn$$1, v16500, possiblyInLambda);
          binExpr2 = new v8506(v8507, ast$$42, v8508);
          var v21355 = binExpr2.operand2;
          var v16501 = v21355.nodeType;
          var v21356 = TypeScript$$14.NodeType;
          var v16502 = v21356.FuncDecl;
          var v8509 = v16501 == v16502;
          if (v8509) {
            var funcDecl$$12 = binExpr2.operand2;
            funcDecl$$12.hint = idHint$$1;
          }
          binExpr2.minChar = ast$$42.minChar;
          var v8510 = binExpr2;
          var v16503 = this.scanner;
          var v27177 = v16503.lastTokenLimChar();
          v8510.limChar = v27177;
          idHint$$1 = null;
          ast$$42 = binExpr2;
        }
      }
      if (canAssign) {
        var v16504 = ast$$42.flags;
        var v21357 = TypeScript$$14.ASTFlags;
        var v16505 = v21357.Writeable;
        ast$$42.flags = v16504 | v16505;
      }
      var v8514 = !exprIsAnonLambda;
      if (v8514) {
        ast$$42.minChar = minChar$$25;
        var v8512 = ast$$42;
        var v16506 = ast$$42.limChar;
        var v21358 = this.scanner;
        var v16507 = v21358.lastTokenLimChar();
        var v27178 = TypeScript$$14.max(v16506, v16507);
        v8512.limChar = v27178;
        ast$$42.preComments = preComments$$4;
        var v8513 = ast$$42;
        var v21359 = this.scanner;
        var v16508 = v21359.line;
        var v27179 = this.parseCommentsForLine(v16508);
        v8513.postComments = v27179;
      }
      return ast$$42;
    }
    function v578(errorRecoverySet$$30, lambdaArgs, skipNextRParen, expectClosingRParen$$2) {
      var v16509 = TypeScript$$14.Modifiers;
      var v8515 = v16509.None;
      var v8516 = {preProcessedLambdaArgs:lambdaArgs};
      var ast$$41 = this.parseFncDecl(errorRecoverySet$$30, false, false, false, null, false, false, false, v8515, v8516, expectClosingRParen$$2);
      var v16510 = ast$$41.fncFlags;
      var v21360 = TypeScript$$14.FncFlags;
      var v16511 = v21360.IsFunctionExpression;
      ast$$41.fncFlags = v16510 | v16511;
      var v16512 = ast$$41.fncFlags;
      var v21361 = TypeScript$$14.FncFlags;
      var v16513 = v21361.IsFatArrowFunction;
      ast$$41.fncFlags = v16512 | v16513;
      var v8517 = !skipNextRParen;
      if (v8517) {
        var v16514 = ast$$41.flags;
        var v21362 = TypeScript$$14.ASTFlags;
        var v16515 = v21362.SkipNextRParen;
        ast$$41.flags = v16514 | v16515;
      }
      var v8518 = ast$$41;
      var v16516 = this.scanner;
      var v27180 = v16516.lastTokenLimChar();
      v8518.limChar = v27180;
      return ast$$41;
    }
    function v577(errorRecoverySet$$29, allowCall, typeContext, inCast) {
      var ast$$40 = null;
      var sawId = false;
      var inNew = false;
      var v8519 = this.scanner;
      var minChar$$24 = v8519.startPos;
      var v8520 = this.scanner;
      var limChar$$7 = v8520.pos;
      var parseAsLambda = false;
      var expectlambdaRParen = false;
      var v16517 = this.currentToken;
      var v8554 = v16517.tokenId;
      switch(v8554) {
        case TypeScript$$14.TokenID.Number:
        ;
        case TypeScript$$14.TokenID.Bool:
        ;
        case TypeScript$$14.TokenID.Any:
        ;
        case TypeScript$$14.TokenID.String:
          var v8521 = TypeScript$$14.Identifier;
          var v21363 = TypeScript$$14.tokenTable;
          var v24228 = this.currentToken;
          var v21364 = v24228.tokenId;
          var v16518 = v21363[v21364];
          var v8522 = v16518.text;
          var tid = new v8521(v8522);
          var v16519 = TypeContext.Primitive;
          var v8524 = TypeScript$$14.hasFlag(typeContext, v16519);
          if (v8524) {
            var v8523 = TypeScript$$14.TypeReference;
            ast$$40 = new v8523(tid, 0);
            sawId = true;
          } else {
            ast$$40 = tid;
            sawId = true;
          }
          ast$$40.minChar = minChar$$24;
          var v8525 = this.scanner;
          var v27181 = v8525.scan();
          this.currentToken = v27181;
          var v8526 = this.scanner;
          limChar$$7 = v8526.lastTokenLimChar();
          break;
        case TypeScript$$14.TokenID.This:
          var v8527 = TypeScript$$14.AST;
          var v16520 = TypeScript$$14.NodeType;
          var v8528 = v16520.This;
          ast$$40 = new v8527(v8528);
          ast$$40.minChar = minChar$$24;
          var v8529 = this.scanner;
          var v27182 = v8529.scan();
          this.currentToken = v27182;
          var v8530 = this.scanner;
          limChar$$7 = v8530.lastTokenLimChar();
          break;
        case TypeScript$$14.TokenID.Super:
          var v8531 = TypeScript$$14.AST;
          var v16521 = TypeScript$$14.NodeType;
          var v8532 = v16521.Super;
          ast$$40 = new v8531(v8532);
          ast$$40.minChar = minChar$$24;
          var v8533 = this.scanner;
          var v27183 = v8533.scan();
          this.currentToken = v27183;
          var v8534 = this.scanner;
          limChar$$7 = v8534.lastTokenLimChar();
          break;
        case TypeScript$$14.TokenID.True:
          var v8535 = TypeScript$$14.AST;
          var v16522 = TypeScript$$14.NodeType;
          var v8536 = v16522.True;
          ast$$40 = new v8535(v8536);
          var v8537 = this.scanner;
          var v27184 = v8537.scan();
          this.currentToken = v27184;
          ast$$40.minChar = minChar$$24;
          break;
        case TypeScript$$14.TokenID.False:
          var v8538 = TypeScript$$14.AST;
          var v16523 = TypeScript$$14.NodeType;
          var v8539 = v16523.False;
          ast$$40 = new v8538(v8539);
          var v8540 = this.scanner;
          var v27185 = v8540.scan();
          this.currentToken = v27185;
          ast$$40.minChar = minChar$$24;
          break;
        case TypeScript$$14.TokenID.Null:
          var v8541 = TypeScript$$14.AST;
          var v16524 = TypeScript$$14.NodeType;
          var v8542 = v16524.Null;
          ast$$40 = new v8541(v8542);
          var v8543 = this.scanner;
          var v27186 = v8543.scan();
          this.currentToken = v27186;
          ast$$40.minChar = minChar$$24;
          break;
        case TypeScript$$14.TokenID.New:
          var v8544 = this.scanner;
          minChar$$24 = v8544.pos;
          var v8545 = this.scanner;
          var v27187 = v8545.scan();
          this.currentToken = v27187;
          var v8546 = TypeContext.AllSimpleTypes;
          var target$$30 = this.parseTerm(errorRecoverySet$$29, false, v8546, inCast);
          var v21365 = target$$30.nodeType;
          var v24229 = TypeScript$$14.NodeType;
          var v21366 = v24229.Error;
          var v16525 = v21365 == v21366;
          var v21368 = !v16525;
          if (v21368) {
            var v24230 = target$$30.nodeType;
            var v25615 = TypeScript$$14.NodeType;
            var v24231 = v25615.Index;
            var v21367 = v24230 == v24231;
            if (v21367) {
              var v25616 = target$$30.operand1;
              var v24232 = v25616.nodeType;
              var v25617 = TypeScript$$14.NodeType;
              var v24233 = v25617.TypeRef;
              v21367 = v24232 == v24233;
            }
            v16525 = v21367;
          }
          var v8550 = v16525;
          if (v8550) {
            this.reportParseError("Cannot invoke 'new' on this expression");
          } else {
            var v8547 = TypeScript$$14.CallExpression;
            var v16526 = TypeScript$$14.NodeType;
            var v8548 = v16526.New;
            ast$$40 = new v8547(v8548, target$$30, null);
            ast$$40.minChar = minChar$$24;
            var v8549 = this.scanner;
            limChar$$7 = v8549.lastTokenLimChar();
            inNew = true;
          }
          break;
        case TypeScript$$14.TokenID.Function:
          var v8551 = this.scanner;
          minChar$$24 = v8551.pos;
          var v16527 = TypeScript$$14.Modifiers;
          var v8552 = v16527.None;
          ast$$40 = this.parseFncDecl(errorRecoverySet$$29, false, false, false, null, false, false, false, v8552, null, true);
          var v16528 = ast$$40.fncFlags;
          var v21369 = TypeScript$$14.FncFlags;
          var v16529 = v21369.IsFunctionExpression;
          ast$$40.fncFlags = v16528 | v16529;
          ast$$40.minChar = minChar$$24;
          var v8553 = this.scanner;
          limChar$$7 = v8553.lastTokenLimChar();
          ast$$40.limChar = limChar$$7;
      }
      var v8561 = ast$$40 == null;
      if (v8561) {
        var v24234 = this.currentToken;
        var v21370 = v24234.tokenId;
        var v24235 = TypeScript$$14.TokenID;
        var v21371 = v24235.Identifier;
        var v16530 = v21370 == v21371;
        var v21374 = !v16530;
        if (v21374) {
          var v21372 = this.currentToken;
          var v21373 = this.strictMode;
          v16530 = TypeScript$$14.convertTokToID(v21372, v21373);
        }
        var v8560 = v16530;
        if (v8560) {
          var v8555 = this.currentToken;
          var idText$$1 = v8555.getText();
          var v16531 = this.currentToken;
          var v8556 = v16531.hasEscapeSequence;
          ast$$40 = this.createRef(idText$$1, v8556, minChar$$24);
          sawId = true;
          ast$$40.minChar = minChar$$24;
          var v8557 = this.scanner;
          var v27188 = v8557.scan();
          this.currentToken = v27188;
          var v21375 = this.currentToken;
          var v16532 = v21375.tokenId;
          var v21376 = TypeScript$$14.TokenID;
          var v16533 = v21376.Question;
          var v8558 = v16532 == v16533;
          if (v8558) {
            var v16534 = ast$$40.flags;
            var v21377 = TypeScript$$14.ASTFlags;
            var v16535 = v21377.PossibleOptionalParameter;
            ast$$40.flags = v16534 | v16535;
          }
          var v8559 = this.scanner;
          limChar$$7 = v8559.lastTokenLimChar();
        }
      }
      if (inCast) {
        var v16536 = TypeScript$$14.TokenID;
        var v8562 = v16536.GreaterThan;
        this.checkCurrentToken(v8562, errorRecoverySet$$29);
      }
      var v8623 = ast$$40 == null;
      if (v8623) {
        var v16537 = this.currentToken;
        var v8622 = v16537.tokenId;
        switch(v8622) {
          case TypeScript$$14.TokenID.OpenParen:
            var v8563 = this.scanner;
            minChar$$24 = v8563.pos;
            var v16538 = this.scanner;
            var v8564 = v16538.previousToken();
            var prevTokId = v8564.tokenId;
            var v8565 = this.scanner;
            var v27189 = v8565.scan();
            this.currentToken = v27189;
            var v25618 = TypeScript$$14.TokenID;
            var v24236 = v25618.OpenParen;
            var v21378 = prevTokId == v24236;
            var v24238 = !v21378;
            if (v24238) {
              var v25619 = TypeScript$$14.TokenID;
              var v24237 = v25619.Comma;
              v21378 = prevTokId == v24237;
            }
            var v16539 = v21378;
            var v21380 = !v16539;
            if (v21380) {
              var v24239 = TypeScript$$14.TokenID;
              var v21379 = v24239.EqualsEquals;
              v16539 = prevTokId == v21379;
            }
            var v8566 = v16539;
            var v16541 = !v8566;
            if (v16541) {
              var v21381 = TypeScript$$14.TokenID;
              var v16540 = v21381.Colon;
              v8566 = prevTokId == v16540;
            }
            var couldBeLambda = v8566;
            var v16542 = couldBeLambda;
            if (v16542) {
              var v24240 = this.currentToken;
              var v21382 = v24240.tokenId;
              var v24241 = TypeScript$$14.TokenID;
              var v21383 = v24241.CloseParen;
              v16542 = v21382 == v21383;
            }
            var v8574 = v16542;
            if (v8574) {
              parseAsLambda = true;
              expectlambdaRParen = false;
              var v8567 = this.scanner;
              var v27190 = v8567.scan();
              this.currentToken = v27190;
            } else {
              var v16543 = couldBeLambda;
              if (v16543) {
                var v24242 = this.currentToken;
                var v21384 = v24242.tokenId;
                var v24243 = TypeScript$$14.TokenID;
                var v21385 = v24243.DotDotDot;
                v16543 = v21384 == v21385;
              }
              var v8573 = v16543;
              if (v8573) {
                parseAsLambda = true;
                expectlambdaRParen = true;
              } else {
                var v21386 = TypeScript$$14.ErrorRecoverySet;
                var v16544 = v21386.RParen;
                var v8568 = errorRecoverySet$$29 | v16544;
                var v16545 = TypeScript$$14.OperatorPrecedence;
                var v8569 = v16545.None;
                var v8570 = TypeContext.NoTypes;
                ast$$40 = this.parseExpr(v8568, v8569, true, v8570, couldBeLambda);
                var v8571 = this.scanner;
                limChar$$7 = v8571.lastTokenLimChar();
                var v16546 = couldBeLambda;
                if (v16546) {
                  var v24244 = ast$$40.nodeType;
                  var v25620 = TypeScript$$14.NodeType;
                  var v24245 = v25620.Name;
                  var v21387 = v24244 == v24245;
                  var v24248 = !v21387;
                  if (v24248) {
                    var v24246 = ast$$40.nodeType;
                    var v25621 = TypeScript$$14.NodeType;
                    var v24247 = v25621.Comma;
                    v21387 = v24246 == v24247;
                  }
                  v16546 = v21387;
                }
                var v8572 = v16546;
                if (v8572) {
                  var v24249 = this.currentToken;
                  var v21388 = v24249.tokenId;
                  var v24250 = TypeScript$$14.TokenID;
                  var v21389 = v24250.Colon;
                  var v16547 = v21388 == v21389;
                  var v21392 = !v16547;
                  if (v21392) {
                    var v24251 = this.currentToken;
                    var v21390 = v24251.tokenId;
                    var v24252 = TypeScript$$14.TokenID;
                    var v21391 = v24252.Question;
                    v16547 = v21390 == v21391;
                  }
                  v8572 = v16547;
                }
                parseAsLambda = v8572;
                expectlambdaRParen = true;
              }
            }
            var v16548 = ast$$40;
            if (v16548) {
              v16548 = !parseAsLambda;
            }
            var v8579 = v16548;
            if (v8579) {
              var v16549 = ast$$40.flags;
              var v21393 = TypeScript$$14.ASTFlags;
              var v16550 = v21393.SkipNextRParen;
              var v8577 = TypeScript$$14.hasFlag(v16549, v16550);
              if (v8577) {
                var v8575 = ast$$40.flags;
                var v21394 = TypeScript$$14.ASTFlags;
                var v16551 = v21394.SkipNextRParen;
                var v8576 = ~v16551;
                ast$$40.flags = v8575 & v8576;
                break;
              }
              var v16552 = TypeScript$$14.TokenID;
              var v8578 = v16552.CloseParen;
              this.checkCurrentToken(v8578, errorRecoverySet$$29);
              ast$$40.isParenthesized = true;
            }
            break;
          case TypeScript$$14.TokenID.NumberLiteral:
            var numTok = this.currentToken;
            var v8580 = this.scanner;
            var v27191 = v8580.scan();
            this.currentToken = v27191;
            var v8581 = TypeScript$$14.NumberLiteral;
            var v8582 = numTok.value;
            var v8583 = numTok.hasEmptyFraction;
            ast$$40 = new v8581(v8582, v8583);
            ast$$40.minChar = minChar$$24;
            var v8584 = this.scanner;
            limChar$$7 = v8584.lastTokenLimChar();
            break;
          case TypeScript$$14.TokenID.StringLiteral:
            var v8585 = TypeScript$$14.StringLiteral;
            var v16553 = this.currentToken;
            var v8586 = v16553.getText();
            ast$$40 = new v8585(v8586);
            var v8587 = this.scanner;
            var v27192 = v8587.scan();
            this.currentToken = v27192;
            ast$$40.minChar = minChar$$24;
            var v8588 = this.scanner;
            limChar$$7 = v8588.lastTokenLimChar();
            break;
          case TypeScript$$14.TokenID.RegularExpressionLiteral:
            var rtok = this.currentToken;
            var v8589 = TypeScript$$14.RegexLiteral;
            var v8590 = rtok.regex;
            ast$$40 = new v8589(v8590);
            var v8591 = this.scanner;
            var v27193 = v8591.scan();
            this.currentToken = v27193;
            ast$$40.minChar = minChar$$24;
            var v8592 = this.scanner;
            limChar$$7 = v8592.lastTokenLimChar();
            break;
          case TypeScript$$14.TokenID.OpenBracket:
            var v8593 = this.scanner;
            minChar$$24 = v8593.startPos;
            var v8594 = this.scanner;
            var v27194 = v8594.scan();
            this.currentToken = v27194;
            var v21395 = TypeScript$$14.ErrorRecoverySet;
            var v16554 = v21395.RBrack;
            var v8595 = v16554 | errorRecoverySet$$29;
            ast$$40 = this.parseArrayLiteral(v8595);
            ast$$40.minChar = minChar$$24;
            var v8596 = this.scanner;
            limChar$$7 = v8596.pos;
            var v16555 = TypeScript$$14.TokenID;
            var v8597 = v16555.CloseBracket;
            this.checkCurrentToken(v8597, errorRecoverySet$$29);
            break;
          case TypeScript$$14.TokenID.OpenBrace:
            var v8598 = this.scanner;
            minChar$$24 = v8598.startPos;
            var v8599 = this.scanner;
            var v27195 = v8599.scan();
            this.currentToken = v27195;
            var v21396 = TypeScript$$14.ErrorRecoverySet;
            var v16556 = v21396.RCurly;
            var v8600 = v16556 | errorRecoverySet$$29;
            var members$$11 = this.parseMemberList(v8600);
            var v16557 = TypeScript$$14.TokenID;
            var v8601 = v16557.CloseBrace;
            this.checkCurrentToken(v8601, errorRecoverySet$$29);
            var v8602 = TypeScript$$14.UnaryExpression;
            var v16558 = TypeScript$$14.NodeType;
            var v8603 = v16558.ObjectLit;
            ast$$40 = new v8602(v8603, members$$11);
            ast$$40.minChar = minChar$$24;
            var v8604 = this.scanner;
            limChar$$7 = v8604.lastTokenLimChar();
            members$$11.minChar = minChar$$24;
            members$$11.limChar = limChar$$7;
            break;
          case TypeScript$$14.TokenID.LessThan:
            var v8605 = this.scanner;
            minChar$$24 = v8605.startPos;
            var v8606 = this.scanner;
            var v27196 = v8606.scan();
            this.currentToken = v27196;
            var v16559 = TypeScript$$14.ErrorRecoverySet;
            var v8607 = v16559.BinOp;
            var term$$3 = this.parseTypeReference(v8607, false);
            var v16560 = TypeScript$$14.TokenID;
            var v8608 = v16560.GreaterThan;
            this.checkCurrentToken(v8608, errorRecoverySet$$29);
            var v8609 = TypeScript$$14.UnaryExpression;
            var v16561 = TypeScript$$14.NodeType;
            var v8610 = v16561.TypeAssertion;
            var v21397 = TypeScript$$14.OperatorPrecedence;
            var v16562 = v21397.Unary;
            var v16563 = TypeContext.NoTypes;
            var v8611 = this.parseExpr(errorRecoverySet$$29, v16562, false, v16563);
            ast$$40 = new v8609(v8610, v8611);
            ast$$40.castTerm = term$$3;
            break;
          default:
            var v16564 = this.prevExpr;
            if (v16564) {
              var v24253 = this.prevExpr;
              var v21398 = v24253.flags;
              var v24254 = TypeScript$$14.ASTFlags;
              var v21399 = v24254.PossibleOptionalParameter;
              v16564 = TypeScript$$14.hasFlag(v21398, v21399);
            }
            var v8621 = v16564;
            if (v8621) {
              parseAsLambda = true;
              ast$$40 = this.prevExpr;
            } else {
              this.reportParseError("Check format of expression term");
              var v8620 = this.errorRecovery;
              if (v8620) {
                var v8612 = TypeScript$$14.MissingIdentifier;
                var ident$$1 = new v8612;
                ident$$1.minChar = minChar$$24;
                var v16565 = ident$$1.flags;
                var v21400 = TypeScript$$14.ASTFlags;
                var v16566 = v21400.Error;
                ident$$1.flags = v16565 | v16566;
                var v21401 = TypeScript$$14.ErrorRecoverySet;
                var v16567 = v21401.Postfix;
                var v8613 = errorRecoverySet$$29 | v16567;
                this.skip(v8613);
                var v24255 = this.currentToken;
                var v21402 = v24255.tokenId;
                var v24256 = TypeScript$$14.TokenID;
                var v21403 = v24256.Identifier;
                var v16568 = v21402 == v21403;
                var v21406 = !v16568;
                if (v21406) {
                  var v21404 = this.currentToken;
                  var v21405 = this.strictMode;
                  v16568 = TypeScript$$14.convertTokToID(v21404, v21405);
                }
                var v8619 = v16568;
                if (v8619) {
                  var v16569 = this.currentToken;
                  var v8614 = v16569.getText();
                  var v16570 = this.currentToken;
                  var v8615 = v16570.hasEscapeSequence;
                  ident$$1.setText(v8614, v8615);
                  var v8616 = this.scanner;
                  var v27197 = v8616.scan();
                  this.currentToken = v27197;
                  var v8617 = this.scanner;
                  limChar$$7 = v8617.lastTokenLimChar();
                } else {
                  var v8618 = this.scanner;
                  limChar$$7 = v8618.lastTokenLimChar();
                }
                ast$$40 = ident$$1;
              }
            }
          ;
        }
      }
      if (parseAsLambda) {
        var v26244 = this.currentToken;
        var v25622 = v26244.tokenId;
        var v26245 = TypeScript$$14.TokenID;
        var v25623 = v26245.Colon;
        var v24257 = v25622 == v25623;
        var v25626 = !v24257;
        if (v25626) {
          var v26246 = this.currentToken;
          var v25624 = v26246.tokenId;
          var v26247 = TypeScript$$14.TokenID;
          var v25625 = v26247.Comma;
          v24257 = v25624 == v25625;
        }
        var v21407 = v24257;
        var v24260 = !v21407;
        if (v24260) {
          var v25627 = this.currentToken;
          var v24258 = v25627.tokenId;
          var v25628 = TypeScript$$14.TokenID;
          var v24259 = v25628.CloseParen;
          v21407 = v24258 == v24259;
        }
        var v16571 = v21407;
        var v21410 = !v16571;
        if (v21410) {
          var v24261 = this.currentToken;
          var v21408 = v24261.tokenId;
          var v24262 = TypeScript$$14.TokenID;
          var v21409 = v24262.DotDotDot;
          v16571 = v21408 == v21409;
        }
        var v8625 = v16571;
        if (v8625) {
          ast$$40 = this.parseLambdaExpr(errorRecoverySet$$29, ast$$40, true, expectlambdaRParen);
          ast$$40.minChar = minChar$$24;
          var v8624 = this.scanner;
          limChar$$7 = v8624.lastTokenLimChar();
          ast$$40.limChar = limChar$$7;
        } else {
          if (ast$$40) {
            ast$$40.isParenthesized = true;
          }
        }
      }
      var v16572 = sawId;
      if (v16572) {
        var v21411 = TypeContext.NoTypes;
        v16572 = typeContext != v21411;
      }
      var v8626 = v16572;
      if (v8626) {
        var v16573 = TypeContext.ArraySuffix;
        typeContext = typeContext | v16573;
      }
      var postFix = this.parsePostfixOperators(errorRecoverySet$$29, ast$$40, allowCall, inNew, typeContext, minChar$$24, limChar$$7);
      if (postFix) {
        var v16574 = sawId;
        if (v16574) {
          var v21412 = postFix.nodeType;
          var v24263 = TypeScript$$14.NodeType;
          var v21413 = v24263.Index;
          v16574 = v21412 == v21413;
        }
        var v8628 = v16574;
        if (v8628) {
          var binExpr = postFix;
          var v16575 = binExpr.operand2;
          var v8627 = v16575 == null;
          if (v8627) {
            postFix = this.convertToTypeReference(postFix);
          }
        }
        postFix.minChar = minChar$$24;
        var v8629 = postFix;
        var v16576 = postFix.limChar;
        var v21414 = this.scanner;
        var v16577 = v21414.lastTokenLimChar();
        var v27198 = TypeScript$$14.max(v16576, v16577);
        v8629.limChar = v27198;
        return postFix;
      } else {
        var v8630 = TypeScript$$14.AST;
        var v16578 = TypeScript$$14.NodeType;
        var v8631 = v16578.Error;
        return new v8630(v8631);
      }
      return;
    }
    function v576(errorRecoverySet$$28) {
      var arrayLiteral = null;
      var v8632 = TypeScript$$14.UnaryExpression;
      var v16579 = TypeScript$$14.NodeType;
      var v8633 = v16579.ArrayLit;
      var v8634 = this.parseArrayList(errorRecoverySet$$28);
      arrayLiteral = new v8632(v8633, v8634);
      return arrayLiteral;
    }
    function v575(errorRecoverySet$$27) {
      var elements$$1 = null;
      var v21415 = this.currentToken;
      var v16580 = v21415.tokenId;
      var v21416 = TypeScript$$14.TokenID;
      var v16581 = v21416.CloseBracket;
      var v8637 = v16580 == v16581;
      if (v8637) {
        return elements$$1;
      } else {
        var v8635 = TypeScript$$14.ASTList;
        elements$$1 = new v8635;
        var v8636 = this.scanner;
        elements$$1.minChar = v8636.startPos;
      }
      var arg$$9;
      for (;;) {
        var v24264 = this.currentToken;
        var v21417 = v24264.tokenId;
        var v24265 = TypeScript$$14.TokenID;
        var v21418 = v24265.Comma;
        var v16582 = v21417 == v21418;
        var v21421 = !v16582;
        if (v21421) {
          var v24266 = this.currentToken;
          var v21419 = v24266.tokenId;
          var v24267 = TypeScript$$14.TokenID;
          var v21420 = v24267.CloseBracket;
          v16582 = v21419 == v21420;
        }
        var v8643 = v16582;
        if (v8643) {
          var v8638 = TypeScript$$14.AST;
          var v16583 = TypeScript$$14.NodeType;
          var v8639 = v16583.EmptyExpr;
          arg$$9 = new v8638(v8639);
        } else {
          var v21422 = TypeScript$$14.ErrorRecoverySet;
          var v16584 = v21422.Comma;
          var v8640 = v16584 | errorRecoverySet$$27;
          var v16585 = TypeScript$$14.OperatorPrecedence;
          var v8641 = v16585.Comma;
          var v8642 = TypeContext.NoTypes;
          arg$$9 = this.parseExpr(v8640, v8641, true, v8642);
        }
        elements$$1.append(arg$$9);
        var v21423 = this.currentToken;
        var v16586 = v21423.tokenId;
        var v21424 = TypeScript$$14.TokenID;
        var v16587 = v21424.Comma;
        var v8644 = v16586 != v16587;
        if (v8644) {
          break;
        }
        var v8645 = this.scanner;
        var v27199 = v8645.scan();
        this.currentToken = v27199;
      }
      var v8646 = elements$$1;
      var v16588 = this.scanner;
      var v27200 = v16588.lastTokenLimChar();
      v8646.limChar = v27200;
      return elements$$1;
    }
    function v574(errorRecoverySet$$26) {
      var v8647 = TypeScript$$14.ASTList;
      var elements = new v8647;
      var v21425 = this.currentToken;
      var v16589 = v21425.tokenId;
      var v21426 = TypeScript$$14.TokenID;
      var v16590 = v21426.CloseBrace;
      var v8648 = v16589 == v16590;
      if (v8648) {
        return elements;
      }
      var idHint = null;
      var memberName$$1 = null;
      var memberExpr = null;
      var member$$2 = null;
      var v8649 = this.scanner;
      var minChar$$23 = v8649.startPos;
      var isSet = false;
      var skippedTokenForGetSetId = false;
      var getSetTok = null;
      var getSetStartPos = 0;
      var getSetPos = 0;
      for (;;) {
        var accessorPattern = false;
        var v24268 = this.currentToken;
        var v21427 = v24268.tokenId;
        var v24269 = TypeScript$$14.TokenID;
        var v21428 = v24269.Get;
        var v16591 = v21427 == v21428;
        var v21431 = !v16591;
        if (v21431) {
          var v24270 = this.currentToken;
          var v21429 = v24270.tokenId;
          var v24271 = TypeScript$$14.TokenID;
          var v21430 = v24271.Set;
          v16591 = v21429 == v21430;
        }
        var v8686 = v16591;
        if (v8686) {
          var v16592 = this.currentToken;
          var v8650 = v16592.tokenId;
          var v16593 = TypeScript$$14.TokenID;
          var v8651 = v16593.Set;
          isSet = v8650 == v8651;
          getSetTok = this.currentToken;
          var v8652 = this.scanner;
          getSetStartPos = v8652.startPos;
          var v8653 = this.scanner;
          getSetPos = v8653.pos;
          var v8654 = this.scanner;
          var v27201 = v8654.scan();
          this.currentToken = v27201;
          var v24272 = this.currentToken;
          var v21432 = v24272.tokenId;
          var v24273 = TypeScript$$14.TokenID;
          var v21433 = v24273.Identifier;
          var v16594 = v21432 == v21433;
          var v21435 = !v16594;
          if (v21435) {
            var v21434 = this.currentToken;
            v16594 = TypeScript$$14.convertTokToIDName(v21434);
          }
          var v8664 = v16594;
          if (v8664) {
            var v8655;
            if (isSet) {
              v8655 = "set";
            } else {
              v8655 = "get";
            }
            idHint = v8655;
            var v8656 = idHint;
            var v16595 = this.currentToken;
            var v8657 = v16595.getText();
            idHint = v8656 + v8657;
            var v8658 = TypeScript$$14.Identifier;
            var v8659 = this.currentToken;
            memberName$$1 = v8658.fromToken(v8659);
            var v8660 = this.scanner;
            memberName$$1.minChar = v8660.startPos;
            accessorPattern = true;
            var v16596 = TypeScript$$14.codeGenTarget;
            var v21436 = TypeScript$$14.CodeGenTarget;
            var v16597 = v21436.ES5;
            var v8661 = v16596 < v16597;
            if (v8661) {
              this.reportParseError("Property accessors are only available when targeting ES5 or greater");
            }
          } else {
            var v21437 = this.currentToken;
            var v16598 = v21437.tokenId;
            var v21438 = TypeScript$$14.TokenID;
            var v16599 = v21438.Colon;
            var v8663 = v16598 != v16599;
            if (v8663) {
              this.reportParseError("Expected identifier, string or number as accessor name");
            } else {
              skippedTokenForGetSetId = true;
              var v8662 = TypeScript$$14.Identifier;
              memberName$$1 = v8662.fromToken(getSetTok);
              memberName$$1.minChar = getSetStartPos;
              memberName$$1.limChar = getSetPos;
            }
          }
        } else {
          var v24274 = this.currentToken;
          var v21439 = v24274.tokenId;
          var v24275 = TypeScript$$14.TokenID;
          var v21440 = v24275.Identifier;
          var v16600 = v21439 == v21440;
          var v21442 = !v16600;
          if (v21442) {
            var v21441 = this.currentToken;
            v16600 = TypeScript$$14.convertTokToIDName(v21441);
          }
          var v8685 = v16600;
          if (v8685) {
            var v8665 = this.currentToken;
            idHint = v8665.getText();
            var v8666 = TypeScript$$14.Identifier;
            var v8667 = this.currentToken;
            memberName$$1 = v8666.fromToken(v8667);
            var v8668 = this.scanner;
            memberName$$1.minChar = v8668.startPos;
            var v8669 = this.scanner;
            memberName$$1.limChar = v8669.pos;
          } else {
            var v21443 = this.currentToken;
            var v16601 = v21443.tokenId;
            var v21444 = TypeScript$$14.TokenID;
            var v16602 = v21444.StringLiteral;
            var v8684 = v16601 == v16602;
            if (v8684) {
              var v8670 = this.currentToken;
              idHint = v8670.getText();
              var v8671 = TypeScript$$14.StringLiteral;
              memberName$$1 = new v8671(idHint);
              var v8672 = this.scanner;
              memberName$$1.minChar = v8672.startPos;
              var v8673 = this.scanner;
              memberName$$1.limChar = v8673.pos;
            } else {
              var v21445 = this.currentToken;
              var v16603 = v21445.tokenId;
              var v21446 = TypeScript$$14.TokenID;
              var v16604 = v21446.NumberLiteral;
              var v8683 = v16603 == v16604;
              if (v8683) {
                var ntok = this.currentToken;
                var v8674 = ntok.value;
                idHint = v8674.toString();
                var v8675 = TypeScript$$14.StringLiteral;
                memberName$$1 = new v8675(idHint);
                var v8676 = this.scanner;
                memberName$$1.minChar = v8676.startPos;
                var v8677 = this.scanner;
                memberName$$1.limChar = v8677.pos;
              } else {
                this.reportParseError("Expected identifier, string or number as member name");
                var v8682 = this.errorRecovery;
                if (v8682) {
                  var v8678 = TypeScript$$14.MissingIdentifier;
                  memberName$$1 = new v8678;
                  var v8679 = this.scanner;
                  memberName$$1.minChar = v8679.startPos;
                  var v16605 = memberName$$1.flags;
                  var v21447 = TypeScript$$14.ASTFlags;
                  var v16606 = v21447.Error;
                  memberName$$1.flags = v16605 | v16606;
                  var v21448 = TypeScript$$14.ErrorRecoverySet;
                  var v16607 = v21448.Comma;
                  var v8680 = errorRecoverySet$$26 | v16607;
                  this.skip(v8680);
                  var v8681 = memberName$$1;
                  var v16608 = this.scanner;
                  var v27202 = v16608.lastTokenLimChar();
                  v8681.limChar = v27202;
                }
              }
            }
          }
        }
        var v8688 = !skippedTokenForGetSetId;
        if (v8688) {
          var v8687 = this.scanner;
          var v27203 = v8687.scan();
          this.currentToken = v27203;
        } else {
          skippedTokenForGetSetId = false;
        }
        var v21449 = this.currentToken;
        var v16609 = v21449.tokenId;
        var v21450 = TypeScript$$14.TokenID;
        var v16610 = v21450.Question;
        var v8690 = v16609 == v16610;
        if (v8690) {
          var v16611 = memberName$$1.flags;
          var v21451 = TypeScript$$14.ASTFlags;
          var v16612 = v21451.OptionalName;
          memberName$$1.flags = v16611 | v16612;
          var v8689 = this.scanner;
          var v27204 = v8689.scan();
          this.currentToken = v27204;
        }
        if (accessorPattern) {
          var v8691 = TypeScript$$14.ASTList;
          var args$$10 = new v8691;
          var v21452 = TypeScript$$14.ErrorRecoverySet;
          var v16613 = v21452.RParen;
          var v8692 = errorRecoverySet$$26 | v16613;
          var v8693 = !isSet;
          this.parseFormalParameterList(v8692, args$$10, false, true, false, v8693, isSet, false, null, true);
          var v21453 = TypeScript$$14.ErrorRecoverySet;
          var v16614 = v21453.RCurly;
          var v8694 = errorRecoverySet$$26 | v16614;
          var v16615 = TypeScript$$14.AllowedElements;
          var v8695 = v16615.None;
          var v16616 = this.scanner;
          var v8696 = v16616.startPos;
          var v16617 = TypeScript$$14.Modifiers;
          var v8697 = v16617.None;
          var funcDecl$$11 = this.parseFunctionStatements(v8694, memberName$$1, false, true, args$$10, v8695, v8696, false, v8697);
          var v16618 = isSet;
          if (v16618) {
            v16618 = funcDecl$$11.returnTypeAnnotation;
          }
          var v8698 = v16618;
          if (v8698) {
            this.reportParseError("Property setters may not declare a return type");
          }
          var v16619 = funcDecl$$11.fncFlags;
          var v21454;
          if (isSet) {
            var v24276 = TypeScript$$14.FncFlags;
            v21454 = v24276.SetAccessor;
          } else {
            var v24277 = TypeScript$$14.FncFlags;
            v21454 = v24277.GetAccessor;
          }
          var v16620 = v21454;
          funcDecl$$11.fncFlags = v16619 | v16620;
          var v16621 = funcDecl$$11.fncFlags;
          var v21455 = TypeScript$$14.FncFlags;
          var v16622 = v21455.IsFunctionExpression;
          funcDecl$$11.fncFlags = v16621 | v16622;
          funcDecl$$11.hint = idHint;
          memberExpr = funcDecl$$11;
          var v8699 = TypeScript$$14.BinaryExpression;
          var v16623 = TypeScript$$14.NodeType;
          var v8700 = v16623.Member;
          member$$2 = new v8699(v8700, memberName$$1, memberExpr);
          member$$2.minChar = memberName$$1.minChar;
          var v16624 = memberExpr.nodeType;
          var v21456 = TypeScript$$14.NodeType;
          var v16625 = v21456.FuncDecl;
          var v8701 = v16624 == v16625;
          if (v8701) {
            funcDecl$$11 = memberExpr;
            funcDecl$$11.hint = idHint;
          }
        } else {
          var v21457 = this.currentToken;
          var v16626 = v21457.tokenId;
          var v21458 = TypeScript$$14.TokenID;
          var v16627 = v21458.Colon;
          var v8712 = v16626 == v16627;
          if (v8712) {
            var v8702 = this.scanner;
            var v27205 = v8702.scan();
            this.currentToken = v27205;
            var v21459 = TypeScript$$14.ErrorRecoverySet;
            var v16628 = v21459.Comma;
            var v8703 = v16628 | errorRecoverySet$$26;
            var v16629 = TypeScript$$14.OperatorPrecedence;
            var v8704 = v16629.Comma;
            var v8705 = TypeContext.NoTypes;
            memberExpr = this.parseExpr(v8703, v8704, true, v8705);
            var v16630 = memberExpr.nodeType;
            var v21460 = TypeScript$$14.NodeType;
            var v16631 = v21460.TypeRef;
            var v8706 = v16630 == v16631;
            if (v8706) {
              this.reportParseError("Expected 'new' on array declaration in member definition");
            }
            var v8707 = TypeScript$$14.BinaryExpression;
            var v16632 = TypeScript$$14.NodeType;
            var v8708 = v16632.Member;
            member$$2 = new v8707(v8708, memberName$$1, memberExpr);
            member$$2.minChar = memberName$$1.minChar;
            var v16633 = memberExpr.nodeType;
            var v21461 = TypeScript$$14.NodeType;
            var v16634 = v21461.FuncDecl;
            var v8709 = v16633 == v16634;
            if (v8709) {
              funcDecl$$11 = memberExpr;
              funcDecl$$11.hint = idHint;
            }
          } else {
            this.reportParseError("Expected ':' in member definition");
            var v8711 = this.errorRecovery;
            if (v8711) {
              this.skip(errorRecoverySet$$26);
              var v16635 = elements.flags;
              var v21462 = TypeScript$$14.ASTFlags;
              var v16636 = v21462.Error;
              elements.flags = v16635 | v16636;
              elements.minChar = minChar$$23;
              var v8710 = elements;
              var v16637 = this.scanner;
              var v27206 = v16637.lastTokenLimChar();
              v8710.limChar = v27206;
              return elements;
            }
          }
        }
        idHint = null;
        elements.append(member$$2);
        var v8713 = member$$2;
        var v16638 = this.scanner;
        var v27207 = v16638.lastTokenLimChar();
        v8713.limChar = v27207;
        var v21463 = this.currentToken;
        var v16639 = v21463.tokenId;
        var v21464 = TypeScript$$14.TokenID;
        var v16640 = v21464.Comma;
        var v8715 = v16639 != v16640;
        if (v8715) {
          break;
        } else {
          var v8714 = this.scanner;
          var v27208 = v8714.scan();
          this.currentToken = v27208;
        }
        var v21465 = this.currentToken;
        var v16641 = v21465.tokenId;
        var v21466 = TypeScript$$14.TokenID;
        var v16642 = v21466.CloseBrace;
        var v8716 = v16641 == v16642;
        if (v8716) {
          break;
        }
      }
      if (member$$2) {
        elements.limChar = member$$2.limChar;
      }
      elements.minChar = minChar$$23;
      return elements;
    }
    function v573(errorRecoverySet$$25, modifiers$$11, allowIn, isStatic$$4) {
      var v16643 = TypeScript$$14.Modifiers;
      var v8717 = v16643.Readonly;
      var isConst = TypeScript$$14.hasFlag(modifiers$$11, v8717);
      var v8718 = this.scanner;
      var minChar$$22 = v8718.startPos;
      var varDecl$$10 = null;
      var declList = null;
      var multivar = false;
      var v8719 = this.scanner;
      var v27209 = v8719.scan();
      this.currentToken = v27209;
      var varDeclPreComments = this.parseComments();
      for (;true;) {
        var v24278 = this.currentToken;
        var v21467 = v24278.tokenId;
        var v24279 = TypeScript$$14.TokenID;
        var v21468 = v24279.Identifier;
        var v16644 = v21467 != v21468;
        if (v16644) {
          var v24280 = this.currentToken;
          var v24281 = this.strictMode;
          var v21469 = TypeScript$$14.convertTokToID(v24280, v24281);
          v16644 = !v21469;
        }
        var v8725 = v16644;
        if (v8725) {
          this.reportParseError("Expected identifier in variable declaration");
          var v8724 = this.errorRecovery;
          if (v8724) {
            var v8720 = TypeScript$$14.VarDecl;
            var v16645 = TypeScript$$14.MissingIdentifier;
            var v8721 = new v16645;
            var v8722 = this.nestingLevel;
            varDecl$$10 = new v8720(v8721, v8722);
            varDecl$$10.minChar = minChar$$22;
            this.skip(errorRecoverySet$$25);
            var v16646 = varDecl$$10.flags;
            var v21470 = TypeScript$$14.ASTFlags;
            var v16647 = v21470.Error;
            varDecl$$10.flags = v16646 | v16647;
            var v8723 = varDecl$$10;
            var v16648 = this.scanner;
            var v27210 = v16648.lastTokenLimChar();
            v8723.limChar = v27210;
            return varDecl$$10;
          }
        }
        var v8726 = TypeScript$$14.Identifier;
        var v8727 = this.currentToken;
        var varDeclName = v8726.fromToken(v8727);
        var v16649 = this.strictMode;
        if (v16649) {
          var v21471 = varDeclName.text;
          v16649 = v21471 == "eval";
        }
        var v8728 = v16649;
        if (v8728) {
          this.reportParseError("'eval' may not name a variable in strict mode");
        }
        var v8729 = this.nestingLevel;
        varDecl$$10 = this.makeVarDecl(varDeclName, v8729);
        var v8730 = varDecl$$10.id;
        var v16650 = this.scanner;
        v8730.minChar = v16650.startPos;
        var v8731 = varDecl$$10.id;
        var v16651 = this.scanner;
        v8731.limChar = v16651.pos;
        varDecl$$10.preComments = varDeclPreComments;
        if (isStatic$$4) {
          var v16652 = varDecl$$10.varFlags;
          var v21472 = TypeScript$$14.VarFlags;
          var v16653 = v21472.Static;
          varDecl$$10.varFlags = v16652 | v16653;
        }
        var v21473 = TypeScript$$14.Modifiers;
        var v16654 = v21473.Readonly;
        var v8732 = TypeScript$$14.hasFlag(modifiers$$11, v16654);
        if (v8732) {
          var v16655 = varDecl$$10.varFlags;
          var v21474 = TypeScript$$14.VarFlags;
          var v16656 = v21474.Readonly;
          varDecl$$10.varFlags = v16655 | v16656;
        }
        var v21475 = this.parsingDeclareFile;
        var v24282 = !v21475;
        if (v24282) {
          v21475 = this.ambientModule;
        }
        var v16657 = v21475;
        var v21477 = !v16657;
        if (v21477) {
          var v24283 = TypeScript$$14.Modifiers;
          var v21476 = v24283.Ambient;
          v16657 = TypeScript$$14.hasFlag(modifiers$$11, v21476);
        }
        var v8733 = v16657;
        if (v8733) {
          var v16658 = varDecl$$10.varFlags;
          var v21478 = TypeScript$$14.VarFlags;
          var v16659 = v21478.Ambient;
          varDecl$$10.varFlags = v16658 | v16659;
        }
        var v21479 = this.parsingDeclareFile;
        var v24284 = !v21479;
        if (v24284) {
          v21479 = this.ambientModule;
        }
        var v16660 = v21479;
        var v21481 = !v16660;
        if (v21481) {
          var v24285 = TypeScript$$14.Modifiers;
          var v21480 = v24285.Exported;
          v16660 = TypeScript$$14.hasFlag(modifiers$$11, v21480);
        }
        var v8734 = v16660;
        if (v8734) {
          var v16661 = varDecl$$10.varFlags;
          var v21482 = TypeScript$$14.VarFlags;
          var v16662 = v21482.Exported;
          varDecl$$10.varFlags = v16661 | v16662;
        }
        varDecl$$10.minChar = minChar$$22;
        if (declList) {
          declList.append(varDecl$$10);
        }
        var v8735 = this.scanner;
        var v27211 = v8735.scan();
        this.currentToken = v27211;
        var v21483 = this.currentToken;
        var v16663 = v21483.tokenId;
        var v21484 = TypeScript$$14.TokenID;
        var v16664 = v21484.Colon;
        var v8738 = v16663 == v16664;
        if (v8738) {
          var v8736 = this.scanner;
          var v27212 = v8736.scan();
          this.currentToken = v27212;
          var prevInFncDecl = this.inFncDecl;
          this.inFncDecl = false;
          var v8737 = varDecl$$10;
          var v25629 = TypeScript$$14.ErrorRecoverySet;
          var v24286 = v25629.Asg;
          var v21485 = errorRecoverySet$$25 | v24286;
          var v24287 = TypeScript$$14.ErrorRecoverySet;
          var v21486 = v24287.Comma;
          var v16665 = v21485 | v21486;
          var v27213 = this.parseTypeReference(v16665, false);
          v8737.typeExpr = v27213;
          this.inFncDecl = prevInFncDecl;
        }
        var v21487 = this.currentToken;
        var v16666 = v21487.tokenId;
        var v21488 = TypeScript$$14.TokenID;
        var v16667 = v21488.Equals;
        var v8746 = v16666 == v16667;
        if (v8746) {
          var v16668 = varDecl$$10.varFlags;
          var v21489 = TypeScript$$14.VarFlags;
          var v16669 = v21489.Ambient;
          var v8739 = TypeScript$$14.hasFlag(v16668, v16669);
          if (v8739) {
            this.reportParseError("Ambient variable can not have an initializer");
          }
          var v8740 = this.scanner;
          var v27214 = v8740.scan();
          this.currentToken = v27214;
          var v8741 = varDecl$$10;
          var v24288 = TypeScript$$14.ErrorRecoverySet;
          var v21490 = v24288.Comma;
          var v16670 = v21490 | errorRecoverySet$$25;
          var v21491 = TypeScript$$14.OperatorPrecedence;
          var v16671 = v21491.Comma;
          var v16672 = TypeContext.NoTypes;
          var v27215 = this.parseExpr(v16670, v16671, allowIn, v16672);
          v8741.init = v27215;
          var v8742 = varDecl$$10.init;
          varDecl$$10.limChar = v8742.limChar;
          var v21492 = varDecl$$10.init;
          var v16673 = v21492.nodeType;
          var v21493 = TypeScript$$14.NodeType;
          var v16674 = v21493.FuncDecl;
          var v8744 = v16673 == v16674;
          if (v8744) {
            var funcDecl$$10 = varDecl$$10.init;
            var v8743 = varDecl$$10.id;
            funcDecl$$10.hint = v8743.actualText;
          }
        } else {
          if (isConst) {
            this.reportParseError("const declaration requires initializer");
          }
          var v8745 = this.scanner;
          varDecl$$10.limChar = v8745.pos;
        }
        var v8747 = varDecl$$10;
        var v21494 = this.scanner;
        var v16675 = v21494.line;
        var v27216 = this.parseCommentsForLine(v16675);
        v8747.postComments = v27216;
        var v21495 = this.currentToken;
        var v16676 = v21495.tokenId;
        var v21496 = TypeScript$$14.TokenID;
        var v16677 = v21496.Comma;
        var v8748 = v16676 != v16677;
        if (v8748) {
          if (declList) {
            declList.limChar = varDecl$$10.limChar;
            return declList;
          } else {
            return varDecl$$10;
          }
        }
        var v8750 = !multivar;
        if (v8750) {
          var v8749 = TypeScript$$14.ASTList;
          declList = new v8749;
          declList.minChar = varDecl$$10.minChar;
          declList.append(varDecl$$10);
          multivar = true;
        }
        var v8751 = this.scanner;
        var v27217 = v8751.scan();
        this.currentToken = v27217;
        var v8752 = this.scanner;
        minChar$$22 = v8752.startPos;
      }
      return;
    }
    function v572(errorRecoverySet$$24, modifiers$$10, requireSignature, isStatic$$3) {
      var text$$16 = null;
      var v8753 = this.scanner;
      var minChar$$21 = v8753.startPos;
      var nameLimChar = minChar$$21;
      var isNew = false;
      var isIndexer$$1 = false;
      var v8754 = this.prevIDTok;
      var wasAccessorID$$1 = v8754 != null;
      var v21497 = TypeScript$$14.Modifiers;
      var v16678 = v21497.Getter;
      var v8755 = TypeScript$$14.hasFlag(modifiers$$10, v16678);
      var v16680 = !v8755;
      if (v16680) {
        var v21498 = TypeScript$$14.Modifiers;
        var v16679 = v21498.Setter;
        v8755 = TypeScript$$14.hasFlag(modifiers$$10, v16679);
      }
      var isAccessor$$1 = v8755;
      var v21499 = this.parsingDeclareFile;
      var v24289 = !v21499;
      if (v24289) {
        v21499 = this.ambientModule;
      }
      var v16681 = v21499;
      var v21501 = !v16681;
      if (v21501) {
        var v24290 = TypeScript$$14.Modifiers;
        var v21500 = v24290.Ambient;
        v16681 = TypeScript$$14.hasFlag(modifiers$$10, v21500);
      }
      var v8756 = v16681;
      if (v8756) {
        requireSignature = true;
      }
      var v24291 = this.currentToken;
      var v21502 = v24291.tokenId;
      var v24292 = TypeScript$$14.TokenID;
      var v21503 = v24292.OpenParen;
      var v16682 = v21502 == v21503;
      if (v16682) {
        v16682 = !wasAccessorID$$1;
      }
      var v8796 = v16682;
      if (v8796) {
        var v16683 = !requireSignature;
        if (v16683) {
          v16683 = !isStatic$$3;
        }
        var v8759 = v16683;
        if (v8759) {
          this.reportParseError("Expected identifier in property declaration");
          var v8758 = this.errorRecovery;
          if (v8758) {
            this.skip(errorRecoverySet$$24);
            var v8757 = TypeScript$$14.MissingIdentifier;
            text$$16 = new v8757;
          }
        }
      } else {
        var v21504 = this.currentToken;
        var v16684 = v21504.tokenId;
        var v21505 = TypeScript$$14.TokenID;
        var v16685 = v21505.New;
        var v8795 = v16684 == v16685;
        if (v8795) {
          if (requireSignature) {
            var v8760 = this.scanner;
            var v27218 = v8760.scan();
            this.currentToken = v27218;
            var v21506 = this.currentToken;
            var v16686 = v21506.tokenId;
            var v21507 = TypeScript$$14.TokenID;
            var v16687 = v21507.OpenParen;
            var v8761 = v16686 == v16687;
            if (v8761) {
              isNew = true;
            }
          }
          var v8768 = !isNew;
          if (v8768) {
            var v8763 = !requireSignature;
            if (v8763) {
              var v8762 = this.scanner;
              var v27219 = v8762.scan();
              this.currentToken = v27219;
            }
            var v8764 = TypeScript$$14.Identifier;
            text$$16 = new v8764("new");
            var v16688 = this.scanner;
            var v8765 = v16688.pos;
            text$$16.minChar = v8765 - 3;
            var v8766 = this.scanner;
            text$$16.limChar = v8766.pos;
            var v8767 = this.scanner;
            nameLimChar = v8767.pos;
          }
        } else {
          var v24293 = this.currentToken;
          var v21508 = v24293.tokenId;
          var v24294 = TypeScript$$14.TokenID;
          var v21509 = v24294.OpenBracket;
          var v16689 = v21508 == v21509;
          if (v16689) {
            v16689 = requireSignature;
          }
          var v8794 = v16689;
          if (v8794) {
            isIndexer$$1 = true;
            var v8769 = TypeScript$$14.Identifier;
            text$$16 = new v8769("__item");
          } else {
            var v25630 = this.currentToken;
            var v24295 = v25630.tokenId;
            var v25631 = TypeScript$$14.TokenID;
            var v24296 = v25631.Identifier;
            var v21510 = v24295 != v24296;
            if (v21510) {
              var v25632 = this.currentToken;
              var v24297 = TypeScript$$14.convertTokToIDName(v25632);
              v21510 = !v24297;
            }
            var v16690 = v21510;
            if (v16690) {
              v16690 = !wasAccessorID$$1;
            }
            var v8793 = v16690;
            if (v8793) {
              this.reportParseError("Expected identifier in property declaration");
              var v8779 = this.errorRecovery;
              if (v8779) {
                var v8770 = this.scanner;
                var eminChar = v8770.startPos;
                var v8771 = this.scanner;
                var curpos$$1 = v8771.pos;
                var v24298 = TypeScript$$14.ErrorRecoverySet;
                var v21511 = v24298.Comma;
                var v16691 = ~v21511;
                var v8772 = errorRecoverySet$$24 & v16691;
                this.skip(v8772);
                var v21512 = this.scanner;
                var v16692 = v21512.pos;
                var v8774 = v16692 == curpos$$1;
                if (v8774) {
                  var v8773 = this.scanner;
                  var v27220 = v8773.scan();
                  this.currentToken = v27220;
                }
                var v8775 = TypeScript$$14.VarDecl;
                var v16693 = TypeScript$$14.MissingIdentifier;
                var v8776 = new v16693;
                var v8777 = this.nestingLevel;
                var epd = new v8775(v8776, v8777);
                var v16694 = epd.flags;
                var v21513 = TypeScript$$14.ASTFlags;
                var v16695 = v21513.Error;
                epd.flags = v16694 | v16695;
                epd.minChar = eminChar;
                var v8778 = epd;
                var v16696 = this.scanner;
                var v27221 = v16696.lastTokenLimChar();
                v8778.limChar = v27221;
                return epd;
              }
            } else {
              if (wasAccessorID$$1) {
                var v8780 = TypeScript$$14.Identifier;
                var v8781 = this.prevIDTok;
                text$$16 = v8780.fromToken(v8781);
                var v8782 = text$$16;
                var v21514 = this.scanner;
                var v16697 = v21514.lastTokenLimChar();
                v8782.minChar = v16697 - 3;
                var v8783 = text$$16;
                var v16698 = this.scanner;
                var v27222 = v16698.lastTokenLimChar();
                v8783.limChar = v27222;
                nameLimChar = text$$16.limChar;
                var v16699 = TypeScript$$14.codeGenTarget;
                var v21515 = TypeScript$$14.CodeGenTarget;
                var v16700 = v21515.ES5;
                var v8784 = v16699 < v16700;
                if (v8784) {
                  this.reportParseError("Property accessors are only available when targeting ES5 or greater");
                }
                var v24299 = this.currentToken;
                var v21516 = v24299.getText();
                var v21517 = text$$16.actualText;
                var v16701 = v21516 == v21517;
                if (v16701) {
                  var v21518 = this.currentToken;
                  var v21519 = this.prevIDTok;
                  v16701 = v21518 != v21519;
                }
                var v8786 = v16701;
                if (v8786) {
                  var v8785 = this.scanner;
                  var v27223 = v8785.scan();
                  this.currentToken = v27223;
                }
                this.prevIDTok = null;
              } else {
                var v8787 = TypeScript$$14.Identifier;
                var v8788 = this.currentToken;
                text$$16 = v8787.fromToken(v8788);
                var v8789 = this.scanner;
                text$$16.minChar = v8789.startPos;
                var v8790 = this.scanner;
                text$$16.limChar = v8790.pos;
                var v8791 = this.scanner;
                nameLimChar = v8791.pos;
                var v8792 = this.scanner;
                var v27224 = v8792.scan();
                this.currentToken = v27224;
              }
            }
          }
        }
      }
      var v21520 = this.currentToken;
      var v16702 = v21520.tokenId;
      var v21521 = TypeScript$$14.TokenID;
      var v16703 = v21521.Question;
      var v8799 = v16702 == v16703;
      if (v8799) {
        var v16704 = this.inInterfaceDecl;
        if (v16704) {
          v16704 = text$$16;
        }
        var v8797 = v16704;
        if (v8797) {
          var v16705 = text$$16.flags;
          var v21522 = TypeScript$$14.ASTFlags;
          var v16706 = v21522.OptionalName;
          text$$16.flags = v16705 | v16706;
        } else {
          this.reportParseError("Optional properties may only be declared on interface or object types");
        }
        var v8798 = this.scanner;
        var v27225 = v8798.scan();
        this.currentToken = v27225;
      }
      var v24300 = this.currentToken;
      var v21523 = v24300.tokenId;
      var v24301 = TypeScript$$14.TokenID;
      var v21524 = v24301.OpenParen;
      var v16707 = v21523 == v21524;
      var v21526 = !v16707;
      if (v21526) {
        var v21525 = isIndexer$$1;
        if (v21525) {
          var v25633 = this.currentToken;
          var v24302 = v25633.tokenId;
          var v25634 = TypeScript$$14.TokenID;
          var v24303 = v25634.OpenBracket;
          v21525 = v24302 == v24303;
        }
        v16707 = v21525;
      }
      var v8837 = v16707;
      if (v8837) {
        var v16708 = TypeScript$$14.ErrorRecoverySet;
        var v8800 = v16708.RParen;
        var ers = errorRecoverySet$$24 | v8800;
        if (isIndexer$$1) {
          var v16709 = TypeScript$$14.ErrorRecoverySet;
          var v8801 = v16709.RBrack;
          ers = errorRecoverySet$$24 | v8801;
        }
        var v16710 = this.inFncDecl;
        var v8802 = !v16710;
        var v16711 = this.parsingDeclareFile;
        var v21528 = !v16711;
        if (v21528) {
          var v24304 = TypeScript$$14.Modifiers;
          var v21527 = v24304.Ambient;
          v16711 = TypeScript$$14.hasFlag(modifiers$$10, v21527);
        }
        var v8803 = v16711;
        var ast$$39 = this.parseFncDecl(ers, true, requireSignature, v8802, text$$16, isIndexer$$1, isStatic$$3, v8803, modifiers$$10, null, true);
        var funcDecl$$9;
        var v16712 = ast$$39.nodeType;
        var v21529 = TypeScript$$14.NodeType;
        var v16713 = v21529.Error;
        var v8804 = v16712 == v16713;
        if (v8804) {
          return ast$$39;
        } else {
          funcDecl$$9 = ast$$39;
        }
        var v8807 = funcDecl$$9.name;
        if (v8807) {
          var v8805 = funcDecl$$9.name;
          v8805.minChar = minChar$$21;
          var v8806 = funcDecl$$9.name;
          v8806.limChar = nameLimChar;
        }
        var v24305 = TypeScript$$14.Modifiers;
        var v21530 = v24305.Public;
        var v16714 = modifiers$$10 & v21530;
        var v21531 = TypeScript$$14.Modifiers;
        var v16715 = v21531.None;
        var v8808 = v16714 != v16715;
        if (v8808) {
          var v16716 = funcDecl$$9.fncFlags;
          var v21532 = TypeScript$$14.FncFlags;
          var v16717 = v21532.Public;
          funcDecl$$9.fncFlags = v16716 | v16717;
        }
        var v24306 = TypeScript$$14.Modifiers;
        var v21533 = v24306.Private;
        var v16718 = modifiers$$10 & v21533;
        var v21534 = TypeScript$$14.Modifiers;
        var v16719 = v21534.None;
        var v8809 = v16718 != v16719;
        if (v8809) {
          var v16720 = funcDecl$$9.fncFlags;
          var v21535 = TypeScript$$14.FncFlags;
          var v16721 = v21535.Private;
          funcDecl$$9.fncFlags = v16720 | v16721;
        }
        if (isStatic$$3) {
          var v16722 = funcDecl$$9.fncFlags;
          var v21536 = TypeScript$$14.FncFlags;
          var v16723 = v21536.Static;
          funcDecl$$9.fncFlags = v16722 | v16723;
        }
        var v16724 = this.parsingDeclareFile;
        var v21538 = !v16724;
        if (v21538) {
          var v24307 = TypeScript$$14.Modifiers;
          var v21537 = v24307.Ambient;
          v16724 = TypeScript$$14.hasFlag(modifiers$$10, v21537);
        }
        var v8810 = v16724;
        if (v8810) {
          var v16725 = funcDecl$$9.fncFlags;
          var v21539 = TypeScript$$14.FncFlags;
          var v16726 = v21539.Ambient;
          funcDecl$$9.fncFlags = v16725 | v16726;
        }
        if (isAccessor$$1) {
          var v21540 = TypeScript$$14.Modifiers;
          var v16727 = v21540.Getter;
          var v8813 = TypeScript$$14.hasFlag(modifiers$$10, v16727);
          if (v8813) {
            var v16728 = funcDecl$$9.fncFlags;
            var v21541 = TypeScript$$14.FncFlags;
            var v16729 = v21541.GetAccessor;
            funcDecl$$9.fncFlags = v16728 | v16729;
            var v16730 = funcDecl$$9.name;
            var v8811 = v16730.actualText;
            funcDecl$$9.hint = "get" + v8811;
          } else {
            var v16731 = funcDecl$$9.fncFlags;
            var v21542 = TypeScript$$14.FncFlags;
            var v16732 = v21542.SetAccessor;
            funcDecl$$9.fncFlags = v16731 | v16732;
            var v16733 = funcDecl$$9.name;
            var v8812 = v16733.actualText;
            funcDecl$$9.hint = "set" + v8812;
          }
          var v16734 = funcDecl$$9.fncFlags;
          var v21543 = TypeScript$$14.FncFlags;
          var v16735 = v21543.IsFunctionExpression;
          funcDecl$$9.fncFlags = v16734 | v16735;
          var v21544 = TypeScript$$14.Modifiers;
          var v16736 = v21544.Ambient;
          var v8814 = modifiers$$10 & v16736;
          if (v8814) {
            this.reportParseError("Property accessors may not be declared in ambient types");
          }
        }
        var v8815 = text$$16 == null;
        if (v8815) {
          if (isNew) {
            var v16737 = funcDecl$$9.fncFlags;
            var v21545 = TypeScript$$14.FncFlags;
            var v16738 = v21545.ConstructMember;
            funcDecl$$9.fncFlags = v16737 | v16738;
            funcDecl$$9.hint = "_construct";
            funcDecl$$9.classDecl = this.currentClassDecl;
          } else {
            funcDecl$$9.hint = "_call";
            var v16739 = funcDecl$$9.fncFlags;
            var v21546 = TypeScript$$14.FncFlags;
            var v16740 = v21546.CallMember;
            funcDecl$$9.fncFlags = v16739 | v16740;
          }
        }
        return funcDecl$$9;
      } else {
        var v8816 = TypeScript$$14.VarDecl;
        var v8817 = this.nestingLevel;
        var varDecl$$9 = new v8816(text$$16, v8817);
        var v8818 = varDecl$$9;
        var v27226 = this.parseComments();
        v8818.preComments = v27226;
        varDecl$$9.minChar = minChar$$21;
        var v21547 = this.currentToken;
        var v16741 = v21547.tokenId;
        var v21548 = TypeScript$$14.TokenID;
        var v16742 = v21548.Colon;
        var v8824 = v16741 == v16742;
        if (v8824) {
          var v8819 = this.scanner;
          var v27227 = v8819.scan();
          this.currentToken = v27227;
          var v8820 = varDecl$$9;
          var v25635 = TypeScript$$14.ErrorRecoverySet;
          var v24308 = v25635.Asg;
          var v21549 = errorRecoverySet$$24 | v24308;
          var v24309 = TypeScript$$14.ErrorRecoverySet;
          var v21550 = v24309.Comma;
          var v16743 = v21549 | v21550;
          var v27228 = this.parseTypeReference(v16743, false);
          v8820.typeExpr = v27228;
          var v16744 = varDecl$$9.typeExpr;
          if (v16744) {
            var v24310 = varDecl$$9.typeExpr;
            var v21551 = v24310.nodeType;
            var v24311 = TypeScript$$14.NodeType;
            var v21552 = v24311.TypeRef;
            v16744 = v21551 == v21552;
          }
          var v8823 = v16744;
          if (v8823) {
            var typeExpr$$1 = varDecl$$9.typeExpr;
            var v16745 = typeExpr$$1.term;
            if (v16745) {
              var v24312 = typeExpr$$1.term;
              var v21553 = v24312.nodeType;
              var v24313 = TypeScript$$14.NodeType;
              var v21554 = v24313.FuncDecl;
              v16745 = v21553 == v21554;
            }
            var v8822 = v16745;
            if (v8822) {
              var v8821 = typeExpr$$1.term;
              v8821.preComments = varDecl$$9.preComments;
            }
          }
        }
        var v21555 = this.currentToken;
        var v16746 = v21555.tokenId;
        var v21556 = TypeScript$$14.TokenID;
        var v16747 = v21556.Equals;
        var v8833 = v16746 == v16747;
        if (v8833) {
          if (requireSignature) {
            this.reportParseError("context does not permit variable initializer");
            var v8826 = this.errorRecovery;
            if (v8826) {
              this.skip(errorRecoverySet$$24);
              var v16748 = varDecl$$9.flags;
              var v21557 = TypeScript$$14.ASTFlags;
              var v16749 = v21557.Error;
              varDecl$$9.flags = v16748 | v16749;
              var v8825 = varDecl$$9;
              var v16750 = this.scanner;
              var v27229 = v16750.lastTokenLimChar();
              v8825.limChar = v27229;
              return varDecl$$9;
            }
          }
          var v8827 = this.scanner;
          var v27230 = v8827.scan();
          this.currentToken = v27230;
          var v8828 = varDecl$$9;
          var v24314 = TypeScript$$14.ErrorRecoverySet;
          var v21558 = v24314.Comma;
          var v16751 = v21558 | errorRecoverySet$$24;
          var v21559 = TypeScript$$14.OperatorPrecedence;
          var v16752 = v21559.Comma;
          var v16753 = TypeContext.NoTypes;
          var v27231 = this.parseExpr(v16751, v16752, true, v16753);
          v8828.init = v27231;
          var v8829 = varDecl$$9.init;
          varDecl$$9.limChar = v8829.limChar;
          var v21560 = varDecl$$9.init;
          var v16754 = v21560.nodeType;
          var v21561 = TypeScript$$14.NodeType;
          var v16755 = v21561.FuncDecl;
          var v8831 = v16754 == v16755;
          if (v8831) {
            funcDecl$$9 = varDecl$$9.init;
            var v8830 = varDecl$$9.id;
            funcDecl$$9.hint = v8830.text;
            funcDecl$$9.boundToProperty = varDecl$$9;
          } else {
            if (isAccessor$$1) {
              this.reportParseError("Accessors may only be functions");
            }
          }
        } else {
          var v8832 = this.scanner;
          varDecl$$9.limChar = v8832.pos;
        }
        var v24315 = TypeScript$$14.Modifiers;
        var v21562 = v24315.Readonly;
        var v16756 = modifiers$$10 & v21562;
        var v21563 = TypeScript$$14.Modifiers;
        var v16757 = v21563.None;
        var v8834 = v16756 != v16757;
        if (v8834) {
          var v16758 = varDecl$$9.varFlags;
          var v21564 = TypeScript$$14.VarFlags;
          var v16759 = v21564.Readonly;
          varDecl$$9.varFlags = v16758 | v16759;
        }
        if (isStatic$$3) {
          var v16760 = varDecl$$9.varFlags;
          var v21565 = TypeScript$$14.VarFlags;
          var v16761 = v21565.Static;
          varDecl$$9.varFlags = v16760 | v16761;
        }
        var v24316 = TypeScript$$14.Modifiers;
        var v21566 = v24316.Public;
        var v16762 = modifiers$$10 & v21566;
        var v21567 = TypeScript$$14.Modifiers;
        var v16763 = v21567.None;
        var v8835 = v16762 != v16763;
        if (v8835) {
          var v16764 = varDecl$$9.varFlags;
          var v21568 = TypeScript$$14.VarFlags;
          var v16765 = v21568.Public;
          varDecl$$9.varFlags = v16764 | v16765;
        }
        var v24317 = TypeScript$$14.Modifiers;
        var v21569 = v24317.Private;
        var v16766 = modifiers$$10 & v21569;
        var v21570 = TypeScript$$14.Modifiers;
        var v16767 = v21570.None;
        var v8836 = v16766 != v16767;
        if (v8836) {
          var v16768 = varDecl$$9.varFlags;
          var v21571 = TypeScript$$14.VarFlags;
          var v16769 = v21571.Private;
          varDecl$$9.varFlags = v16768 | v16769;
        }
        var v16770 = varDecl$$9.varFlags;
        var v21572 = TypeScript$$14.VarFlags;
        var v16771 = v21572.Property;
        varDecl$$9.varFlags = v16770 | v16771;
        return varDecl$$9;
      }
      return;
    }
    function v571(id$$12, nest$$1) {
      var v8838 = TypeScript$$14.VarDecl;
      var varDecl$$8 = new v8838(id$$12, nest$$1);
      var currentVarList = this.topVarList();
      if (currentVarList) {
        currentVarList.append(varDecl$$8);
      }
      return varDecl$$8;
    }
    function v570(errorRecoverySet$$23, modifiers$$9) {
      var v8839 = this.scanner;
      var leftCurlyCount$$4 = v8839.leftCurlyCount;
      var v8840 = this.scanner;
      var rightCurlyCount$$4 = v8840.rightCurlyCount;
      var v8841 = this.scanner;
      var v27232 = v8841.scan();
      this.currentToken = v27232;
      var v8842 = this.scanner;
      var minChar$$20 = v8842.pos;
      var name$$50 = null;
      var v24318 = this.currentToken;
      var v21573 = v24318.tokenId;
      var v24319 = TypeScript$$14.TokenID;
      var v21574 = v24319.Identifier;
      var v16772 = v21573 == v21574;
      var v21576 = !v16772;
      if (v21576) {
        var v25636 = this.currentToken;
        var v24320 = TypeScript$$14.isPrimitiveTypeToken(v25636);
        var v21575 = !v24320;
        if (v21575) {
          var v24321 = this.currentToken;
          var v24322 = this.strictMode;
          v21575 = TypeScript$$14.convertTokToID(v24321, v24322);
        }
        v16772 = v21575;
      }
      var v8852 = v16772;
      if (v8852) {
        var v8843 = TypeScript$$14.Identifier;
        var v8844 = this.currentToken;
        name$$50 = v8843.fromToken(v8844);
        var v8845 = this.scanner;
        name$$50.minChar = v8845.startPos;
        var v8846 = this.scanner;
        name$$50.limChar = v8846.pos;
        var v8847 = this.scanner;
        var v27233 = v8847.scan();
        this.currentToken = v27233;
      } else {
        this.reportParseError("interface missing name");
        var v8851 = this.errorRecovery;
        if (v8851) {
          var v8848 = TypeScript$$14.MissingIdentifier;
          name$$50 = new v8848;
          var v8849 = this.scanner;
          name$$50.minChar = v8849.pos;
          var v8850 = this.scanner;
          name$$50.limChar = v8850.pos;
          var v16773 = name$$50.flags;
          var v21577 = TypeScript$$14.ASTFlags;
          var v16774 = v21577.Error;
          name$$50.flags = v16773 | v16774;
        }
      }
      var extendsList$$6 = null;
      var implementsList$$5 = null;
      var v24323 = this.currentToken;
      var v21578 = v24323.tokenId;
      var v24324 = TypeScript$$14.TokenID;
      var v21579 = v24324.Extends;
      var v16775 = v21578 === v21579;
      var v21582 = !v16775;
      if (v21582) {
        var v24325 = this.currentToken;
        var v21580 = v24325.tokenId;
        var v24326 = TypeScript$$14.TokenID;
        var v21581 = v24326.Implements;
        v16775 = v21580 === v21581;
      }
      var v8857 = v16775;
      if (v8857) {
        var v21583 = this.currentToken;
        var v16776 = v21583.tokenId;
        var v21584 = TypeScript$$14.TokenID;
        var v16777 = v21584.Implements;
        var v8853 = v16776 === v16777;
        if (v8853) {
          this.reportParseError("Expected 'extends'");
        }
        var v8854 = TypeScript$$14.ASTList;
        extendsList$$6 = new v8854;
        var v8855 = TypeScript$$14.ASTList;
        implementsList$$5 = new v8855;
        var v8856 = this.scanner;
        extendsList$$6.minChar = v8856.startPos;
        this.parseBaseList(extendsList$$6, implementsList$$5, errorRecoverySet$$23, false);
      }
      var v8858 = this.scanner;
      var membersMinChar$$2 = v8858.startPos;
      var v16778 = TypeScript$$14.TokenID;
      var v8859 = v16778.OpenBrace;
      var v21585 = TypeScript$$14.ErrorRecoverySet;
      var v16779 = v21585.TypeScriptS;
      var v8860 = errorRecoverySet$$23 | v16779;
      this.checkCurrentToken(v8859, v8860);
      var v8861 = TypeScript$$14.ASTList;
      var members$$10 = new v8861;
      members$$10.minChar = membersMinChar$$2;
      var prevInInterfaceDecl$$1 = this.inInterfaceDecl;
      this.inInterfaceDecl = true;
      var v21586 = TypeScript$$14.ErrorRecoverySet;
      var v16780 = v21586.RCurly;
      var v8862 = errorRecoverySet$$23 | v16780;
      this.parseTypeMemberList(v8862, members$$10);
      this.inInterfaceDecl = prevInInterfaceDecl$$1;
      var v16781 = TypeScript$$14.TokenID;
      var v8863 = v16781.CloseBrace;
      this.checkCurrentToken(v8863, errorRecoverySet$$23);
      var v8864 = TypeScript$$14.InterfaceDeclaration;
      var interfaceDecl$$1 = new v8864(name$$50, members$$10, extendsList$$6, null);
      var v21587 = TypeScript$$14.Modifiers;
      var v16782 = v21587.Private;
      var v8865 = TypeScript$$14.hasFlag(modifiers$$9, v16782);
      if (v8865) {
        var v16783 = interfaceDecl$$1.varFlags;
        var v21588 = TypeScript$$14.VarFlags;
        var v16784 = v21588.Private;
        interfaceDecl$$1.varFlags = v16783 | v16784;
      }
      var v21589 = TypeScript$$14.Modifiers;
      var v16785 = v21589.Public;
      var v8866 = TypeScript$$14.hasFlag(modifiers$$9, v16785);
      if (v8866) {
        var v16786 = interfaceDecl$$1.varFlags;
        var v21590 = TypeScript$$14.VarFlags;
        var v16787 = v21590.Public;
        interfaceDecl$$1.varFlags = v16786 | v16787;
      }
      var v21591 = this.parsingDeclareFile;
      var v24327 = !v21591;
      if (v24327) {
        v21591 = this.ambientModule;
      }
      var v16788 = v21591;
      var v21593 = !v16788;
      if (v21593) {
        var v24328 = TypeScript$$14.Modifiers;
        var v21592 = v24328.Exported;
        v16788 = TypeScript$$14.hasFlag(modifiers$$9, v21592);
      }
      var v8867 = v16788;
      if (v8867) {
        var v16789 = interfaceDecl$$1.varFlags;
        var v21594 = TypeScript$$14.VarFlags;
        var v16790 = v21594.Exported;
        interfaceDecl$$1.varFlags = v16789 | v16790;
      }
      interfaceDecl$$1.limChar = members$$10.limChar;
      var v16791 = this.scanner;
      var v8868 = v16791.leftCurlyCount;
      interfaceDecl$$1.leftCurlyCount = v8868 - leftCurlyCount$$4;
      var v16792 = this.scanner;
      var v8869 = v16792.rightCurlyCount;
      interfaceDecl$$1.rightCurlyCount = v8869 - rightCurlyCount$$4;
      return interfaceDecl$$1;
    }
    function v569(errorRecoverySet$$22, members$$9) {
      var v21595 = TypeScript$$14.ErrorRecoverySet;
      var v16793 = v21595.TypeScriptS;
      errorRecoverySet$$22 = errorRecoverySet$$22 | v16793;
      for (;true;) {
        var v16794 = this.currentToken;
        var v8871 = v16794.tokenId;
        switch(v8871) {
          case TypeScript$$14.TokenID.CloseBrace:
          ;
          case TypeScript$$14.TokenID.EndOfFile:
            var v8870 = this.scanner;
            members$$9.limChar = v8870.pos;
            return;
        }
        var element$$2 = this.parseTypeMember(errorRecoverySet$$22);
        if (element$$2) {
          members$$9.append(element$$2);
        }
      }
      return;
    }
    function v568(errorRecoverySet$$21) {
      var v8872 = this.scanner;
      var minChar$$19 = v8872.startPos;
      var v16795 = TypeScript$$14.Modifiers;
      var v8873 = v16795.Public;
      var propertyDecl = this.parsePropertyDeclaration(errorRecoverySet$$21, v8873, true, false);
      if (propertyDecl) {
        propertyDecl.minChar = minChar$$19;
        var v16796 = propertyDecl.nodeType;
        var v21596 = TypeScript$$14.NodeType;
        var v16797 = v21596.VarDecl;
        var v8875 = v16796 == v16797;
        if (v8875) {
          var v16798 = TypeScript$$14.TokenID;
          var v8874 = v16798.Semicolon;
          this.checkCurrentToken(v8874, errorRecoverySet$$21);
        }
      }
      return propertyDecl;
    }
    function v567(methodName$$1, minChar$$18, errorRecoverySet$$20, modifiers$$8) {
      var v8876 = this.prevIDTok;
      var wasAccessorID = v8876 != null;
      var v21597 = TypeScript$$14.Modifiers;
      var v16799 = v21597.Getter;
      var v8877 = TypeScript$$14.hasFlag(modifiers$$8, v16799);
      var v16801 = !v8877;
      if (v16801) {
        var v21598 = TypeScript$$14.Modifiers;
        var v16800 = v21598.Setter;
        v8877 = TypeScript$$14.hasFlag(modifiers$$8, v16800);
      }
      var isAccessor = v8877;
      var v16802 = TypeScript$$14.Modifiers;
      var v8878 = v16802.Static;
      var isStatic$$2 = TypeScript$$14.hasFlag(modifiers$$8, v8878);
      var v8879 = this.ambientModule;
      var v16804 = !v8879;
      if (v16804) {
        var v21599 = TypeScript$$14.Modifiers;
        var v16803 = v21599.Ambient;
        v8879 = TypeScript$$14.hasFlag(modifiers$$8, v16803);
      }
      var isAmbient$$2 = v8879;
      var v21600 = TypeScript$$14.ErrorRecoverySet;
      var v16805 = v21600.RParen;
      errorRecoverySet$$20 = errorRecoverySet$$20 | v16805;
      var v16806 = isAccessor;
      if (v16806) {
        var v24329 = TypeScript$$14.Modifiers;
        var v21601 = v24329.Ambient;
        v16806 = modifiers$$8 & v21601;
      }
      var v8880 = v16806;
      if (v8880) {
        this.reportParseError("Property accessors may not be declared in ambient classes");
      }
      var ast$$38 = this.parseFncDecl(errorRecoverySet$$20, true, isAmbient$$2, true, methodName$$1, false, isStatic$$2, isAmbient$$2, modifiers$$8, null, true);
      var v16807 = ast$$38.nodeType;
      var v21602 = TypeScript$$14.NodeType;
      var v16808 = v21602.Error;
      var v8881 = v16807 == v16808;
      if (v8881) {
        return ast$$38;
      }
      var funcDecl$$8 = ast$$38;
      funcDecl$$8.minChar = minChar$$18;
      var v16809 = funcDecl$$8.bod;
      var v8883 = v16809 !== null;
      if (v8883) {
        var v8882 = funcDecl$$8.bod;
        funcDecl$$8.limChar = v8882.limChar;
      }
      var v21603 = TypeScript$$14.Modifiers;
      var v16810 = v21603.Private;
      var v8884 = modifiers$$8 & v16810;
      if (v8884) {
        var v16811 = funcDecl$$8.fncFlags;
        var v21604 = TypeScript$$14.FncFlags;
        var v16812 = v21604.Private;
        funcDecl$$8.fncFlags = v16811 | v16812;
      } else {
        var v16813 = funcDecl$$8.fncFlags;
        var v21605 = TypeScript$$14.FncFlags;
        var v16814 = v21605.Public;
        funcDecl$$8.fncFlags = v16813 | v16814;
      }
      if (isStatic$$2) {
        var v16815 = funcDecl$$8.fncFlags;
        var v21606 = TypeScript$$14.FncFlags;
        var v16816 = v21606.Static;
        funcDecl$$8.fncFlags = v16815 | v16816;
      }
      if (isAccessor) {
        var v21607 = TypeScript$$14.Modifiers;
        var v16817 = v21607.Getter;
        var v8887 = TypeScript$$14.hasFlag(modifiers$$8, v16817);
        if (v8887) {
          var v16818 = funcDecl$$8.fncFlags;
          var v21608 = TypeScript$$14.FncFlags;
          var v16819 = v21608.GetAccessor;
          funcDecl$$8.fncFlags = v16818 | v16819;
          var v16820 = funcDecl$$8.name;
          var v8885 = v16820.actualText;
          funcDecl$$8.hint = "get" + v8885;
        } else {
          var v16821 = funcDecl$$8.fncFlags;
          var v21609 = TypeScript$$14.FncFlags;
          var v16822 = v21609.SetAccessor;
          funcDecl$$8.fncFlags = v16821 | v16822;
          var v16823 = funcDecl$$8.name;
          var v8886 = v16823.actualText;
          funcDecl$$8.hint = "set" + v8886;
        }
        var v16824 = funcDecl$$8.fncFlags;
        var v21610 = TypeScript$$14.FncFlags;
        var v16825 = v21610.IsFunctionExpression;
        funcDecl$$8.fncFlags = v16824 | v16825;
        var v16826 = TypeScript$$14.codeGenTarget;
        var v21611 = TypeScript$$14.CodeGenTarget;
        var v16827 = v21611.ES5;
        var v8890 = v16826 < v16827;
        if (v8890) {
          var v8888 = funcDecl$$8.minChar;
          var v8889 = funcDecl$$8.limChar;
          this.reportParseError("Property accessors are only available when targeting ES5 or greater", v8888, v8889);
        }
      }
      var v16828 = funcDecl$$8.fncFlags;
      var v21612 = TypeScript$$14.FncFlags;
      var v16829 = v21612.ClassMethod;
      funcDecl$$8.fncFlags = v16828 | v16829;
      var v16830 = this.currentClassDefinition;
      var v8891 = v16830.knownMemberNames;
      var v8892 = methodName$$1.actualText;
      v8891[v8892] = true;
      var v21613 = this.currentClassDefinition;
      var v16831 = v21613.members;
      var v8893 = v16831.members;
      var v24330 = this.currentClassDefinition;
      var v21614 = v24330.members;
      var v16832 = v21614.members;
      var v8894 = v16832.length;
      v8893[v8894] = funcDecl$$8;
      return funcDecl$$8;
    }
    function v566(text$$15, minChar$$17, isDeclaredInConstructor, errorRecoverySet$$19, modifiers$$7) {
      var v8895 = TypeScript$$14.VarDecl;
      var v8896 = this.nestingLevel;
      var varDecl$$7 = new v8895(text$$15, v8896);
      varDecl$$7.minChar = minChar$$17;
      var isStatic$$1 = false;
      var v8897 = varDecl$$7;
      var v27234 = this.parseComments();
      v8897.preComments = v27234;
      var v21615 = this.currentToken;
      var v16833 = v21615.tokenId;
      var v21616 = TypeScript$$14.TokenID;
      var v16834 = v21616.Colon;
      var v8903 = v16833 == v16834;
      if (v8903) {
        var v8898 = this.scanner;
        var v27235 = v8898.scan();
        this.currentToken = v27235;
        var v8899 = varDecl$$7;
        var v25637 = TypeScript$$14.ErrorRecoverySet;
        var v24331 = v25637.Asg;
        var v21617 = errorRecoverySet$$19 | v24331;
        var v24332 = TypeScript$$14.ErrorRecoverySet;
        var v21618 = v24332.Comma;
        var v16835 = v21617 | v21618;
        var v27236 = this.parseTypeReference(v16835, false);
        v8899.typeExpr = v27236;
        var v16836 = varDecl$$7.typeExpr;
        if (v16836) {
          var v24333 = varDecl$$7.typeExpr;
          var v21619 = v24333.nodeType;
          var v24334 = TypeScript$$14.NodeType;
          var v21620 = v24334.TypeRef;
          v16836 = v21619 == v21620;
        }
        var v8902 = v16836;
        if (v8902) {
          var typeExpr = varDecl$$7.typeExpr;
          var v16837 = typeExpr.term;
          if (v16837) {
            var v24335 = typeExpr.term;
            var v21621 = v24335.nodeType;
            var v24336 = TypeScript$$14.NodeType;
            var v21622 = v24336.FuncDecl;
            v16837 = v21621 == v21622;
          }
          var v8901 = v16837;
          if (v8901) {
            var v8900 = typeExpr.term;
            v8900.preComments = varDecl$$7.preComments;
          }
        }
      }
      var v21623 = this.currentToken;
      var v16838 = v21623.tokenId;
      var v21624 = TypeScript$$14.TokenID;
      var v16839 = v21624.Equals;
      var v8913 = v16838 == v16839;
      if (v8913) {
        var v16840 = this.parsingDeclareFile;
        var v21626 = !v16840;
        if (v21626) {
          var v24337 = TypeScript$$14.Modifiers;
          var v21625 = v24337.Ambient;
          v16840 = TypeScript$$14.hasFlag(modifiers$$7, v21625);
        }
        var v8906 = v16840;
        if (v8906) {
          this.reportParseError("context does not permit variable initializer");
          var v8905 = this.errorRecovery;
          if (v8905) {
            this.skip(errorRecoverySet$$19);
            var v16841 = varDecl$$7.flags;
            var v21627 = TypeScript$$14.ASTFlags;
            var v16842 = v21627.Error;
            varDecl$$7.flags = v16841 | v16842;
            var v8904 = varDecl$$7;
            var v16843 = this.scanner;
            var v27237 = v16843.lastTokenLimChar();
            v8904.limChar = v27237;
            return varDecl$$7;
          }
        }
        var v8907 = this.scanner;
        var v27238 = v8907.scan();
        this.currentToken = v27238;
        var v8908 = varDecl$$7;
        var v24338 = TypeScript$$14.ErrorRecoverySet;
        var v21628 = v24338.Comma;
        var v16844 = v21628 | errorRecoverySet$$19;
        var v21629 = TypeScript$$14.OperatorPrecedence;
        var v16845 = v21629.Comma;
        var v16846 = TypeContext.NoTypes;
        var v27239 = this.parseExpr(v16844, v16845, true, v16846);
        v8908.init = v27239;
        var v8909 = varDecl$$7.init;
        varDecl$$7.limChar = v8909.limChar;
        var v24339 = TypeScript$$14.Modifiers;
        var v21630 = v24339.Static;
        var v16847 = modifiers$$7 & v21630;
        var v8911 = !v16847;
        if (v8911) {
          var v8910 = this.currentClassDefinition;
          var v21631 = v8910.varFlags;
          var v24340 = TypeScript$$14.VarFlags;
          var v21632 = v24340.ClassSuperMustBeFirstCallInConstructor;
          v8910.varFlags = v21631 | v21632;
        }
      } else {
        var v8912 = this.scanner;
        varDecl$$7.limChar = v8912.pos;
      }
      var v21633 = TypeScript$$14.Modifiers;
      var v16848 = v21633.Static;
      var v8914 = modifiers$$7 & v16848;
      if (v8914) {
        var v16849 = varDecl$$7.varFlags;
        var v21634 = TypeScript$$14.VarFlags;
        var v16850 = v21634.Static;
        varDecl$$7.varFlags = v16849 | v16850;
        isStatic$$1 = true;
      }
      var v24341 = TypeScript$$14.Modifiers;
      var v21635 = v24341.Private;
      var v16851 = modifiers$$7 & v21635;
      var v21636 = TypeScript$$14.Modifiers;
      var v16852 = v21636.None;
      var v8915 = v16851 != v16852;
      if (v8915) {
        var v16853 = varDecl$$7.varFlags;
        var v21637 = TypeScript$$14.VarFlags;
        var v16854 = v21637.Private;
        varDecl$$7.varFlags = v16853 | v16854;
      } else {
        var v16855 = varDecl$$7.varFlags;
        var v21638 = TypeScript$$14.VarFlags;
        var v16856 = v21638.Public;
        varDecl$$7.varFlags = v16855 | v16856;
      }
      var v16857 = varDecl$$7.varFlags;
      var v21639 = TypeScript$$14.VarFlags;
      var v16858 = v21639.Property;
      varDecl$$7.varFlags = v16857 | v16858;
      if (isDeclaredInConstructor) {
        var v16859 = varDecl$$7.varFlags;
        var v21640 = TypeScript$$14.VarFlags;
        var v16860 = v21640.ClassConstructorProperty;
        varDecl$$7.varFlags = v16859 | v16860;
      }
      var v16861 = !isDeclaredInConstructor;
      if (v16861) {
        v16861 = !isStatic$$1;
      }
      var v8916 = v16861;
      if (v8916) {
        var v16862 = varDecl$$7.varFlags;
        var v21641 = TypeScript$$14.VarFlags;
        var v16863 = v21641.ClassBodyProperty;
        varDecl$$7.varFlags = v16862 | v16863;
      }
      var v16864 = this.currentClassDefinition;
      var v8917 = v16864.knownMemberNames;
      var v8918 = text$$15.actualText;
      v8917[v8918] = true;
      var v8921 = !isDeclaredInConstructor;
      if (v8921) {
        var v21642 = this.currentClassDefinition;
        var v16865 = v21642.members;
        var v8919 = v16865.members;
        var v24342 = this.currentClassDefinition;
        var v21643 = v24342.members;
        var v16866 = v21643.members;
        var v8920 = v16866.length;
        v8919[v8920] = varDecl$$7;
      }
      var v8922 = varDecl$$7;
      var v27240 = this.parseComments();
      v8922.postComments = v27240;
      return varDecl$$7;
    }
    function v565(minChar$$16, errorRecoverySet$$18, modifiers$$6) {
      this.parsingClassConstructorDefinition = true;
      var v8923 = this.parsingDeclareFile;
      var v16868 = !v8923;
      if (v16868) {
        var v21644 = TypeScript$$14.Modifiers;
        var v16867 = v21644.Ambient;
        v8923 = TypeScript$$14.hasFlag(modifiers$$6, v16867);
      }
      var isAmbient$$1 = v8923;
      var v8924 = TypeScript$$14.ASTList;
      var args$$9 = new v8924;
      var variableArgList$$2 = false;
      var preComments$$3 = this.parseComments();
      var v8925 = this.scanner;
      var v27241 = v8925.scan();
      this.currentToken = v27241;
      var v21645 = this.currentToken;
      var v16869 = v21645.tokenId;
      var v21646 = TypeScript$$14.TokenID;
      var v16870 = v21646.OpenParen;
      var v8929 = v16869 == v16870;
      if (v8929) {
        variableArgList$$2 = this.parseFormalParameterList(errorRecoverySet$$18, args$$9, true, isAmbient$$1, false, false, false, false, null, true);
        var v21647 = args$$9.members;
        var v16871 = v21647.length;
        var v8928 = v16871 > 0;
        if (v8928) {
          var v8926 = args$$9.members;
          var v21648 = args$$9.members;
          var v16872 = v21648.length;
          var v8927 = v16872 - 1;
          var lastArg$$1 = v8926[v8927];
        }
      }
      var v8930 = isAmbient$$1;
      var v16875 = !v8930;
      if (v16875) {
        var v21649 = this.currentToken;
        var v16873 = v21649.tokenId;
        var v21650 = TypeScript$$14.TokenID;
        var v16874 = v21650.Semicolon;
        v8930 = v16873 == v16874;
      }
      var requiresSignature$$3 = v8930;
      if (requiresSignature$$3) {
        var i$$51 = 0;
        var v21651 = args$$9.members;
        var v16876 = v21651.length;
        var v8935 = i$$51 < v16876;
        for (;v8935;) {
          var v8931 = args$$9.members;
          var arg$$8 = v8931[i$$51];
          var v16877 = arg$$8.varFlags;
          var v21652 = TypeScript$$14.VarFlags;
          var v16878 = v21652.Property;
          var v8934 = TypeScript$$14.hasFlag(v16877, v16878);
          if (v8934) {
            var v8932 = arg$$8.minChar;
            var v8933 = arg$$8.limChar;
            this.reportParseError("Overload or ambient signatures may not specify parameter properties", v8932, v8933);
          }
          i$$51 = i$$51 + 1;
          var v21653 = args$$9.members;
          var v16879 = v21653.length;
          v8935 = i$$51 < v16879;
        }
      }
      var v8937 = !requiresSignature$$3;
      if (v8937) {
        var v8936 = this.currentClassDefinition;
        var v16880 = this.nestingLevel;
        v8936.constructorNestingLevel = v16880 + 1;
      }
      var v21654 = TypeScript$$14.ErrorRecoverySet;
      var v16881 = v21654.RCurly;
      var v8938 = errorRecoverySet$$18 | v16881;
      var v16882 = this.currentClassDefinition;
      var v8939 = v16882.name;
      var v16883 = TypeScript$$14.AllowedElements;
      var v8940 = v16883.Properties;
      var constructorFuncDecl = this.parseFunctionStatements(v8938, v8939, true, false, args$$9, v8940, minChar$$16, requiresSignature$$3, modifiers$$6);
      constructorFuncDecl.preComments = preComments$$3;
      var v16884 = requiresSignature$$3;
      if (v16884) {
        v16884 = !isAmbient$$1;
      }
      var v8941 = v16884;
      if (v8941) {
        constructorFuncDecl.isOverload = true;
      }
      constructorFuncDecl.variableArgList = variableArgList$$2;
      this.currentClassDecl = null;
      var v8942 = constructorFuncDecl;
      var v21655 = this.currentClassDefinition;
      var v16885 = v21655.name;
      var v27242 = this.convertToTypeReference(v16885);
      v8942.returnTypeAnnotation = v27242;
      constructorFuncDecl.classDecl = this.currentClassDefinition;
      if (isAmbient$$1) {
        var v16886 = constructorFuncDecl.fncFlags;
        var v21656 = TypeScript$$14.FncFlags;
        var v16887 = v21656.Ambient;
        constructorFuncDecl.fncFlags = v16886 | v16887;
      }
      if (requiresSignature$$3) {
        var v16888 = constructorFuncDecl.fncFlags;
        var v21657 = TypeScript$$14.FncFlags;
        var v16889 = v21657.Signature;
        constructorFuncDecl.fncFlags = v16888 | v16889;
      }
      var v16890 = this.ambientModule;
      var v21659 = !v16890;
      if (v21659) {
        var v24343 = TypeScript$$14.Modifiers;
        var v21658 = v24343.Exported;
        v16890 = TypeScript$$14.hasFlag(modifiers$$6, v21658);
      }
      var v8943 = v16890;
      if (v8943) {
        var v16891 = constructorFuncDecl.fncFlags;
        var v21660 = TypeScript$$14.FncFlags;
        var v16892 = v21660.Exported;
        constructorFuncDecl.fncFlags = v16891 | v16892;
      }
      var v16893 = this.currentClassDefinition;
      var v8945 = v16893.constructorDecl;
      if (v8945) {
        var v21661 = !isAmbient$$1;
        if (v21661) {
          var v26248 = this.currentClassDefinition;
          var v25638 = v26248.constructorDecl;
          var v24344 = v25638.isSignature();
          v21661 = !v24344;
        }
        var v16894 = v21661;
        if (v16894) {
          var v21662 = constructorFuncDecl.isSignature();
          v16894 = !v21662;
        }
        var v8944 = v16894;
        if (v8944) {
          this.reportParseError("Duplicate constructor definition");
        }
      }
      var v16895 = isAmbient$$1;
      var v21664 = !v16895;
      if (v21664) {
        var v21663 = constructorFuncDecl.isSignature();
        v16895 = !v21663;
      }
      var v8947 = v16895;
      if (v8947) {
        var v8946 = this.currentClassDefinition;
        v8946.constructorDecl = constructorFuncDecl;
      }
      var v16896 = constructorFuncDecl.fncFlags;
      var v21665 = TypeScript$$14.FncFlags;
      var v16897 = v21665.ClassMethod;
      constructorFuncDecl.fncFlags = v16896 | v16897;
      var v21666 = this.currentClassDefinition;
      var v16898 = v21666.members;
      var v8948 = v16898.members;
      var v24345 = this.currentClassDefinition;
      var v21667 = v24345.members;
      var v16899 = v21667.members;
      var v8949 = v16899.length;
      v8948[v8949] = constructorFuncDecl;
      this.parsingClassConstructorDefinition = false;
      return constructorFuncDecl;
    }
    function v564(classDecl$$5, errorRecoverySet$$17, parentModifiers$$2) {
      var modifiers$$5 = parentModifiers$$2;
      var resetModifiers = false;
      var v8950 = this.scanner;
      var membersMinChar$$1 = v8950.startPos;
      var v16900 = TypeScript$$14.TokenID;
      var v8951 = v16900.OpenBrace;
      this.checkCurrentToken(v8951, errorRecoverySet$$17);
      var v16901 = this.nestingLevel;
      this.nestingLevel = v16901 + 1;
      var v8952 = this.scanner;
      var currentMemberMinChar = v8952.startPos;
      var wasGetOrSetId = false;
      var v25639 = this.currentToken;
      var v24346 = v25639.tokenId;
      var v25640 = TypeScript$$14.TokenID;
      var v24347 = v25640.CloseBrace;
      var v21668 = v24346 == v24347;
      var v24350 = !v21668;
      if (v24350) {
        var v25641 = this.currentToken;
        var v24348 = v25641.tokenId;
        var v25642 = TypeScript$$14.TokenID;
        var v24349 = v25642.EndOfFile;
        v21668 = v24348 == v24349;
      }
      var v16902 = v21668;
      var v8991 = !v16902;
      for (;v8991;) {
        var scanNext = true;
        var v16903 = TypeScript$$14.Modifiers;
        var v8953 = v16903.Public;
        var v16904 = TypeScript$$14.Modifiers;
        var v8954 = v16904.Private;
        var publicOrPrivateFlags = v8953 | v8954;
        var v21669 = this.currentToken;
        var v16905 = v21669.tokenId;
        var v21670 = TypeScript$$14.TokenID;
        var v16906 = v21670.Get;
        var v8986 = v16905 == v16906;
        if (v8986) {
          var v21671 = TypeScript$$14.Modifiers;
          var v16907 = v21671.Getter;
          var v8955 = modifiers$$5 & v16907;
          if (v8955) {
            this.reportParseError("Duplicate 'get' declaration in class body");
          }
          var v21672 = TypeScript$$14.Modifiers;
          var v16908 = v21672.Setter;
          var v8956 = modifiers$$5 & v16908;
          if (v8956) {
            this.reportParseError("Getter already marked as a setter");
          }
          var v21673 = TypeScript$$14.Modifiers;
          var v16909 = v21673.Getter;
          modifiers$$5 = modifiers$$5 | v16909;
        } else {
          var v21674 = this.currentToken;
          var v16910 = v21674.tokenId;
          var v21675 = TypeScript$$14.TokenID;
          var v16911 = v21675.Set;
          var v8985 = v16910 == v16911;
          if (v8985) {
            var v21676 = TypeScript$$14.Modifiers;
            var v16912 = v21676.Setter;
            var v8957 = modifiers$$5 & v16912;
            if (v8957) {
              this.reportParseError("Duplicate 'set' declaration in class body");
            }
            var v21677 = TypeScript$$14.Modifiers;
            var v16913 = v21677.Getter;
            var v8958 = modifiers$$5 & v16913;
            if (v8958) {
              this.reportParseError("Setter already marked as a getter");
            }
            var v21678 = TypeScript$$14.Modifiers;
            var v16914 = v21678.Setter;
            modifiers$$5 = modifiers$$5 | v16914;
          } else {
            var v21679 = this.currentToken;
            var v16915 = v21679.tokenId;
            var v21680 = TypeScript$$14.TokenID;
            var v16916 = v21680.Private;
            var v8984 = v16915 == v16916;
            if (v8984) {
              var v8959 = modifiers$$5 & publicOrPrivateFlags;
              if (v8959) {
                this.reportParseError("Multiple modifiers may not be applied to class members");
              }
              var v21681 = TypeScript$$14.Modifiers;
              var v16917 = v21681.Private;
              modifiers$$5 = modifiers$$5 | v16917;
            } else {
              var v21682 = this.currentToken;
              var v16918 = v21682.tokenId;
              var v21683 = TypeScript$$14.TokenID;
              var v16919 = v21683.Public;
              var v8983 = v16918 == v16919;
              if (v8983) {
                var v8960 = modifiers$$5 & publicOrPrivateFlags;
                if (v8960) {
                  this.reportParseError("Multiple modifiers may not be applied to class members");
                }
                var v21684 = TypeScript$$14.Modifiers;
                var v16920 = v21684.Public;
                modifiers$$5 = modifiers$$5 | v16920;
              } else {
                var v21685 = this.currentToken;
                var v16921 = v21685.tokenId;
                var v21686 = TypeScript$$14.TokenID;
                var v16922 = v21686.Static;
                var v8982 = v16921 == v16922;
                if (v8982) {
                  var v21687 = TypeScript$$14.Modifiers;
                  var v16923 = v21687.Static;
                  var v8961 = modifiers$$5 & v16923;
                  if (v8961) {
                    this.reportParseError("Multiple modifiers may not be applied to class members");
                  }
                  var v21688 = TypeScript$$14.Modifiers;
                  var v16924 = v21688.Static;
                  modifiers$$5 = modifiers$$5 | v16924;
                } else {
                  var v21689 = this.currentToken;
                  var v16925 = v21689.tokenId;
                  var v21690 = TypeScript$$14.TokenID;
                  var v16926 = v21690.Constructor;
                  var v8981 = v16925 == v16926;
                  if (v8981) {
                    var v8962 = modifiers$$5 != parentModifiers$$2;
                    if (v8962) {
                      this.reportParseError("Constructors may not have modifiers");
                    }
                    this.parseClassConstructorDeclaration(currentMemberMinChar, errorRecoverySet$$17, modifiers$$5);
                    scanNext = false;
                    resetModifiers = true;
                  } else {
                    var v21691 = wasGetOrSetId;
                    var v24353 = !v21691;
                    if (v24353) {
                      var v25643 = this.currentToken;
                      var v24351 = v25643.tokenId;
                      var v25644 = TypeScript$$14.TokenID;
                      var v24352 = v25644.Identifier;
                      v21691 = v24351 == v24352;
                    }
                    var v16927 = v21691;
                    var v21693 = !v16927;
                    if (v21693) {
                      var v21692 = this.currentToken;
                      v16927 = TypeScript$$14.convertTokToIDName(v21692);
                    }
                    var v8980 = v16927;
                    if (v8980) {
                      var v8963;
                      if (wasGetOrSetId) {
                        var v16928;
                        var v25645 = TypeScript$$14.Modifiers;
                        var v24354 = v25645.Getter;
                        var v21694 = modifiers$$5 & v24354;
                        if (v21694) {
                          v16928 = "get";
                        } else {
                          v16928 = "set";
                        }
                        v8963 = v16928;
                      } else {
                        var v16929 = this.currentToken;
                        v8963 = v16929.getText();
                      }
                      var idText = v8963;
                      var v8964;
                      if (wasGetOrSetId) {
                        var v16930 = TypeScript$$14.Identifier;
                        v8964 = new v16930(idText);
                      } else {
                        var v16931 = TypeScript$$14.Identifier;
                        var v16932 = this.currentToken;
                        v8964 = v16931.fromToken(v16932);
                      }
                      var id$$11 = v8964;
                      var v8965 = this.scanner;
                      id$$11.minChar = v8965.startPos;
                      var v8966 = this.scanner;
                      id$$11.limChar = v8966.pos;
                      if (wasGetOrSetId) {
                        var v16933;
                        var v25646 = TypeScript$$14.Modifiers;
                        var v24355 = v25646.Getter;
                        var v21697 = modifiers$$5 & v24355;
                        if (v21697) {
                          var v21695 = TypeScript$$14.Modifiers;
                          v16933 = v21695.Getter;
                        } else {
                          var v21696 = TypeScript$$14.Modifiers;
                          v16933 = v21696.Setter;
                        }
                        var v8967 = v16933;
                        modifiers$$5 = modifiers$$5 ^ v8967;
                        wasGetOrSetId = false;
                      } else {
                        var v8968 = this.scanner;
                        var v27243 = v8968.scan();
                        this.currentToken = v27243;
                      }
                      var v21698 = this.currentToken;
                      var v16934 = v21698.tokenId;
                      var v21699 = TypeScript$$14.TokenID;
                      var v16935 = v21699.OpenParen;
                      var v8975 = v16934 == v16935;
                      if (v8975) {
                        this.parseClassMemberFunctionDeclaration(id$$11, currentMemberMinChar, errorRecoverySet$$17, modifiers$$5);
                        scanNext = false;
                      } else {
                        var v24356 = TypeScript$$14.Modifiers;
                        var v21700 = v24356.Getter;
                        var v16936 = modifiers$$5 & v21700;
                        var v21702 = !v16936;
                        if (v21702) {
                          var v24357 = TypeScript$$14.Modifiers;
                          var v21701 = v24357.Setter;
                          v16936 = modifiers$$5 & v21701;
                        }
                        var v8969 = v16936;
                        if (v8969) {
                          this.reportParseError("Property accessors must be functions");
                        }
                        var varDecl$$6 = this.parseClassMemberVariableDeclaration(id$$11, currentMemberMinChar, false, errorRecoverySet$$17, modifiers$$5);
                        var v16937 = varDecl$$6.init;
                        if (v16937) {
                          var v24358 = varDecl$$6.init;
                          var v21703 = v24358.nodeType;
                          var v24359 = TypeScript$$14.NodeType;
                          var v21704 = v24359.FuncDecl;
                          v16937 = v21703 == v21704;
                        }
                        var v8974 = v16937;
                        if (v8974) {
                          var v21705 = this.currentToken;
                          var v16938 = v21705.tokenId;
                          var v21706 = TypeScript$$14.TokenID;
                          var v16939 = v21706.CloseBrace;
                          var v8970 = v16938 == v16939;
                          if (v8970) {
                            scanNext = false;
                          }
                        } else {
                          var v21707 = varDecl$$6.init;
                          if (v21707) {
                            var v25647 = varDecl$$6.init;
                            var v24360 = v25647.nodeType;
                            var v25648 = TypeScript$$14.NodeType;
                            var v24361 = v25648.ObjectLit;
                            v21707 = v24360 == v24361;
                          }
                          var v16940 = v21707;
                          if (v16940) {
                            var v24362 = this.currentToken;
                            var v21708 = v24362.tokenId;
                            var v24363 = TypeScript$$14.TokenID;
                            var v21709 = v24363.Semicolon;
                            v16940 = v21708 != v21709;
                          }
                          var v8973 = v16940;
                          if (v8973) {
                            scanNext = false;
                            var v8971 = varDecl$$6.init;
                            var v21710 = v8971.flags;
                            var v24364 = TypeScript$$14.ASTFlags;
                            var v21711 = v24364.AutomaticSemicolon;
                            v8971.flags = v21710 | v21711;
                          } else {
                            var v21712 = this.currentToken;
                            var v16941 = v21712.tokenId;
                            var v21713 = TypeScript$$14.TokenID;
                            var v16942 = v21713.Semicolon;
                            var v8972 = v16941 != v16942;
                            if (v8972) {
                              this.reportParseError("Expected ';'");
                              scanNext = false;
                            }
                          }
                        }
                      }
                      resetModifiers = true;
                    } else {
                      var v21714 = this.currentToken;
                      var v16943 = v21714.tokenId;
                      var v21715 = TypeScript$$14.TokenID;
                      var v16944 = v21715.Super;
                      var v8979 = v16943 == v16944;
                      if (v8979) {
                        this.reportParseError("Base class initializers must be the first statement in a class definition");
                      } else {
                        var v21716 = !wasGetOrSetId;
                        if (v21716) {
                          var v26249 = TypeScript$$14.Modifiers;
                          var v25649 = v26249.Getter;
                          var v24365 = modifiers$$5 & v25649;
                          var v25651 = !v24365;
                          if (v25651) {
                            var v26250 = TypeScript$$14.Modifiers;
                            var v25650 = v26250.Setter;
                            v24365 = modifiers$$5 & v25650;
                          }
                          v21716 = v24365;
                        }
                        var v16945 = v21716;
                        if (v16945) {
                          var v26516 = this.currentToken;
                          var v26251 = v26516.tokenId;
                          var v26517 = TypeScript$$14.TokenID;
                          var v26252 = v26517.OpenParen;
                          var v25652 = v26251 == v26252;
                          var v26255 = !v25652;
                          if (v26255) {
                            var v26518 = this.currentToken;
                            var v26253 = v26518.tokenId;
                            var v26519 = TypeScript$$14.TokenID;
                            var v26254 = v26519.Equals;
                            v25652 = v26253 == v26254;
                          }
                          var v24366 = v25652;
                          var v25655 = !v24366;
                          if (v25655) {
                            var v26256 = this.currentToken;
                            var v25653 = v26256.tokenId;
                            var v26257 = TypeScript$$14.TokenID;
                            var v25654 = v26257.Colon;
                            v24366 = v25653 == v25654;
                          }
                          var v21717 = v24366;
                          var v24369 = !v21717;
                          if (v24369) {
                            var v25656 = this.currentToken;
                            var v24367 = v25656.tokenId;
                            var v25657 = TypeScript$$14.TokenID;
                            var v24368 = v25657.Semicolon;
                            v21717 = v24367 == v24368;
                          }
                          v16945 = v21717;
                        }
                        var v8978 = v16945;
                        if (v8978) {
                          wasGetOrSetId = true;
                          scanNext = false;
                        } else {
                          var v21718 = this.currentToken;
                          var v16946 = v21718.tokenId;
                          var v21719 = TypeScript$$14.TokenID;
                          var v16947 = v21719.Semicolon;
                          var v8977 = v16946 != v16947;
                          if (v8977) {
                            var v24370 = this.currentToken;
                            var v21720 = v24370.getText();
                            var v16948 = "Unexpected '" + v21720;
                            var v8976 = v16948 + "' in class definition";
                            this.reportParseError(v8976);
                            resetModifiers = true;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (scanNext) {
          var v8987 = this.scanner;
          var v27244 = v8987.scan();
          this.currentToken = v27244;
          var v16949 = this.currentToken;
          var v8989 = v16949 === undefined;
          if (v8989) {
            var v8988 = this.scanner;
            var v27245 = v8988.scan();
            this.currentToken = v27245;
          }
        }
        if (resetModifiers) {
          modifiers$$5 = parentModifiers$$2;
          var v8990 = this.scanner;
          currentMemberMinChar = v8990.startPos;
          resetModifiers = false;
        }
        var v25658 = this.currentToken;
        var v24371 = v25658.tokenId;
        var v25659 = TypeScript$$14.TokenID;
        var v24372 = v25659.CloseBrace;
        var v21721 = v24371 == v24372;
        var v24375 = !v21721;
        if (v24375) {
          var v25660 = this.currentToken;
          var v24373 = v25660.tokenId;
          var v25661 = TypeScript$$14.TokenID;
          var v24374 = v25661.EndOfFile;
          v21721 = v24373 == v24374;
        }
        var v16950 = v21721;
        v8991 = !v16950;
      }
      var v8992 = this.scanner;
      var membersLimChar = v8992.pos;
      var v21722 = this.currentToken;
      var v16951 = v21722.tokenId;
      var v21723 = TypeScript$$14.TokenID;
      var v16952 = v21723.CloseBrace;
      var v8999 = v16951 == v16952;
      if (v8999) {
        var v8993 = classDecl$$5;
        var v16953 = TypeScript$$14.ASTSpan;
        var v27246 = new v16953;
        v8993.endingToken = v27246;
        var v8994 = classDecl$$5.endingToken;
        var v16954 = this.scanner;
        v8994.minChar = v16954.startPos;
        var v8995 = classDecl$$5.endingToken;
        var v16955 = this.scanner;
        v8995.limChar = v16955.pos;
        var v25662 = this.currentClassDefinition;
        var v24376 = v25662.members;
        var v21724 = v24376.members;
        var v16956 = v21724.length;
        var v8997 = !v16956;
        if (v8997) {
          var v8996 = this.currentClassDefinition;
          var v27247 = this.parseComments();
          v8996.preComments = v27247;
        }
        var v8998 = this.scanner;
        var v27248 = v8998.scan();
        this.currentToken = v27248;
      }
      var v16957 = this.nestingLevel;
      this.nestingLevel = v16957 - 1;
      var v16958 = this.currentClassDefinition;
      var v9000 = v16958.members;
      v9000.minChar = membersMinChar$$1;
      var v16959 = this.currentClassDefinition;
      var v9001 = v16959.members;
      v9001.limChar = membersLimChar;
      var v9002 = this.currentClassDefinition;
      v9002.limChar = membersLimChar;
      this.currentClassDefinition = null;
      return;
    }
    function v563(errorRecoverySet$$16, minChar$$15, modifiers$$4) {
      var v9003 = this.scanner;
      var leftCurlyCount$$3 = v9003.leftCurlyCount;
      var v9004 = this.scanner;
      var rightCurlyCount$$3 = v9004.rightCurlyCount;
      var v24377 = TypeScript$$14.Modifiers;
      var v21725 = v24377.Readonly;
      var v16960 = modifiers$$4 & v21725;
      var v21726 = TypeScript$$14.Modifiers;
      var v16961 = v21726.None;
      var v9005 = v16960 != v16961;
      if (v9005) {
        this.reportParseError("const modifier is implicit for class");
      }
      var v16962 = this.parsingDeclareFile;
      var v21727 = !v16962;
      if (v21727) {
        v16962 = this.ambientModule;
      }
      var v9006 = v16962;
      if (v9006) {
        var v21728 = TypeScript$$14.Modifiers;
        var v16963 = v21728.Ambient;
        modifiers$$4 = modifiers$$4 | v16963;
        var v21729 = TypeScript$$14.Modifiers;
        var v16964 = v21729.Exported;
        modifiers$$4 = modifiers$$4 | v16964;
      }
      var v9007 = this.parsingDeclareFile;
      var v16967 = !v9007;
      if (v16967) {
        var v24378 = TypeScript$$14.Modifiers;
        var v21730 = v24378.Ambient;
        var v16965 = modifiers$$4 & v21730;
        var v21731 = TypeScript$$14.Modifiers;
        var v16966 = v21731.None;
        v9007 = v16965 != v16966;
      }
      var classIsMarkedAsAmbient = v9007;
      var svAmbientClass = this.ambientClass;
      this.ambientClass = classIsMarkedAsAmbient;
      var v9008 = this.scanner;
      var v27249 = v9008.scan();
      this.currentToken = v27249;
      var name$$49 = null;
      var v24379 = this.currentToken;
      var v21732 = v24379.tokenId;
      var v24380 = TypeScript$$14.TokenID;
      var v21733 = v24380.Identifier;
      var v16968 = v21732 == v21733;
      var v21735 = !v16968;
      if (v21735) {
        var v25663 = this.currentToken;
        var v24381 = TypeScript$$14.isPrimitiveTypeToken(v25663);
        var v21734 = !v24381;
        if (v21734) {
          var v24382 = this.currentToken;
          var v24383 = this.strictMode;
          v21734 = TypeScript$$14.convertTokToID(v24382, v24383);
        }
        v16968 = v21734;
      }
      var v9018 = v16968;
      if (v9018) {
        var v9009 = TypeScript$$14.Identifier;
        var v9010 = this.currentToken;
        name$$49 = v9009.fromToken(v9010);
        var v9011 = this.scanner;
        name$$49.minChar = v9011.startPos;
        var v9012 = this.scanner;
        name$$49.limChar = v9012.pos;
        var v9013 = this.scanner;
        var v27250 = v9013.scan();
        this.currentToken = v27250;
      } else {
        this.reportParseError("class missing name");
        var v9017 = this.errorRecovery;
        if (v9017) {
          var v9014 = TypeScript$$14.MissingIdentifier;
          name$$49 = new v9014;
          var v9015 = this.scanner;
          name$$49.minChar = v9015.pos;
          var v9016 = this.scanner;
          name$$49.limChar = v9016.pos;
          var v16969 = name$$49.flags;
          var v21736 = TypeScript$$14.ASTFlags;
          var v16970 = v21736.Error;
          name$$49.flags = v16969 | v16970;
        }
      }
      var extendsList$$5 = null;
      var implementsList$$4 = null;
      var requiresSignature$$2 = false;
      var v24384 = this.currentToken;
      var v21737 = v24384.tokenId;
      var v24385 = TypeScript$$14.TokenID;
      var v21738 = v24385.Extends;
      var v16971 = v21737 == v21738;
      var v21741 = !v16971;
      if (v21741) {
        var v24386 = this.currentToken;
        var v21739 = v24386.tokenId;
        var v24387 = TypeScript$$14.TokenID;
        var v21740 = v24387.Implements;
        v16971 = v21739 == v21740;
      }
      var v9021 = v16971;
      if (v9021) {
        var v9019 = TypeScript$$14.ASTList;
        extendsList$$5 = new v9019;
        var v9020 = TypeScript$$14.ASTList;
        implementsList$$4 = new v9020;
        this.parseBaseList(extendsList$$5, implementsList$$4, errorRecoverySet$$16, true);
      }
      var v9022 = TypeScript$$14.ClassDeclaration;
      var v16972 = TypeScript$$14.ASTList;
      var v9023 = new v16972;
      var classDecl$$4 = new v9022(name$$49, v9023, extendsList$$5, implementsList$$4);
      this.currentClassDefinition = classDecl$$4;
      this.parseClassElements(classDecl$$4, errorRecoverySet$$16, modifiers$$4);
      var v21742 = this.ambientModule;
      var v24388 = !v21742;
      if (v24388) {
        v21742 = this.parsingDeclareFile;
      }
      var v16973 = v21742;
      var v21744 = !v16973;
      if (v21744) {
        var v24389 = TypeScript$$14.Modifiers;
        var v21743 = v24389.Exported;
        v16973 = TypeScript$$14.hasFlag(modifiers$$4, v21743);
      }
      var v9024 = v16973;
      if (v9024) {
        var v16974 = classDecl$$4.varFlags;
        var v21745 = TypeScript$$14.VarFlags;
        var v16975 = v21745.Exported;
        classDecl$$4.varFlags = v16974 | v16975;
      }
      var v16976 = this.ambientModule;
      var v21747 = !v16976;
      if (v21747) {
        var v24390 = TypeScript$$14.Modifiers;
        var v21746 = v24390.Ambient;
        v16976 = TypeScript$$14.hasFlag(modifiers$$4, v21746);
      }
      var v9025 = v16976;
      if (v9025) {
        var v16977 = classDecl$$4.varFlags;
        var v21748 = TypeScript$$14.VarFlags;
        var v16978 = v21748.Ambient;
        classDecl$$4.varFlags = v16977 | v16978;
      }
      var v16979 = classDecl$$4.varFlags;
      var v21749 = TypeScript$$14.VarFlags;
      var v16980 = v21749.Class;
      classDecl$$4.varFlags = v16979 | v16980;
      this.ambientClass = svAmbientClass;
      var v16981 = this.scanner;
      var v9026 = v16981.leftCurlyCount;
      classDecl$$4.leftCurlyCount = v9026 - leftCurlyCount$$3;
      var v16982 = this.scanner;
      var v9027 = v16982.rightCurlyCount;
      classDecl$$4.rightCurlyCount = v9027 - rightCurlyCount$$3;
      return classDecl$$4;
    }
    function v562(extendsList$$4, implementsList$$3, errorRecoverySet$$15, isClass) {
      var keyword = true;
      var currentList = extendsList$$4;
      for (;;) {
        if (keyword) {
          var v21750 = this.currentToken;
          var v16983 = v21750.tokenId;
          var v21751 = TypeScript$$14.TokenID;
          var v16984 = v21751.Implements;
          var v9029 = v16983 === v16984;
          if (v9029) {
            currentList = implementsList$$3;
          } else {
            var v24391 = this.currentToken;
            var v21752 = v24391.tokenId;
            var v24392 = TypeScript$$14.TokenID;
            var v21753 = v24392.Extends;
            var v16985 = v21752 == v21753;
            if (v16985) {
              var v21754 = this.requiresExtendsBlock;
              v16985 = !v21754;
            }
            var v9028 = v16985;
            if (v9028) {
              this.requiresExtendsBlock = isClass;
            }
          }
          var v9030 = this.scanner;
          var v27251 = v9030.scan();
          this.currentToken = v27251;
          keyword = false;
        }
        var baseName$$3 = null;
        var v24393 = this.currentToken;
        var v21755 = v24393.tokenId;
        var v24394 = TypeScript$$14.TokenID;
        var v21756 = v24394.Identifier;
        var v16986 = v21755 == v21756;
        var v21759 = !v16986;
        if (v21759) {
          var v21757 = this.currentToken;
          var v21758 = this.strictMode;
          v16986 = TypeScript$$14.convertTokToID(v21757, v21758);
        }
        var v9040 = v16986;
        if (v9040) {
          var v9031 = this.scanner;
          var minChar$$14 = v9031.startPos;
          var v9032 = TypeScript$$14.Identifier;
          var v9033 = this.currentToken;
          baseName$$3 = v9032.fromToken(v9033);
          baseName$$3.minChar = minChar$$14;
          var v9034 = this.scanner;
          baseName$$3.limChar = v9034.pos;
          var v21760 = TypeScript$$14.ErrorRecoverySet;
          var v16987 = v21760.LCurly;
          var v9035 = errorRecoverySet$$15 | v16987;
          baseName$$3 = this.parseNamedType(v9035, minChar$$14, baseName$$3, false);
        } else {
          this.reportParseError("Expected base name");
          var v9039 = this.errorRecovery;
          if (v9039) {
            var v9036 = TypeScript$$14.MissingIdentifier;
            baseName$$3 = new v9036;
            var v9037 = this.scanner;
            baseName$$3.minChar = v9037.pos;
            var v9038 = this.scanner;
            baseName$$3.limChar = v9038.pos;
            var v16988 = baseName$$3.flags;
            var v21761 = TypeScript$$14.ASTFlags;
            var v16989 = v21761.Error;
            baseName$$3.flags = v16988 | v16989;
          }
        }
        var v21762 = this.currentToken;
        var v16990 = v21762.tokenId;
        var v21763 = TypeScript$$14.TokenID;
        var v16991 = v21763.OpenParen;
        var v9041 = v16990 == v16991;
        if (v9041) {
          if (isClass) {
            this.reportParseError("Base classes may only be initialized via a 'super' call within the constructor body");
          } else {
            this.reportParseError("Interfaces may not be extended with a call expression");
          }
        } else {
          currentList.append(baseName$$3);
        }
        var v21764 = isClass;
        if (v21764) {
          v21764 = currentList == extendsList$$4;
        }
        var v16992 = v21764;
        if (v16992) {
          var v24395 = extendsList$$4.members;
          var v21765 = v24395.length;
          v16992 = v21765 > 1;
        }
        var v9042 = v16992;
        if (v9042) {
          this.reportParseError("A class may only extend one other class");
        }
        var v21766 = this.currentToken;
        var v16993 = v21766.tokenId;
        var v21767 = TypeScript$$14.TokenID;
        var v16994 = v21767.Comma;
        var v9046 = v16993 == v16994;
        if (v9046) {
          var v9043 = this.scanner;
          var v27252 = v9043.scan();
          this.currentToken = v27252;
          continue;
        } else {
          var v24396 = this.currentToken;
          var v21768 = v24396.tokenId;
          var v24397 = TypeScript$$14.TokenID;
          var v21769 = v24397.Extends;
          var v16995 = v21768 == v21769;
          var v21772 = !v16995;
          if (v21772) {
            var v24398 = this.currentToken;
            var v21770 = v24398.tokenId;
            var v24399 = TypeScript$$14.TokenID;
            var v21771 = v24399.Implements;
            v16995 = v21770 == v21771;
          }
          var v9045 = v16995;
          if (v9045) {
            var v24400 = this.currentToken;
            var v21773 = v24400.tokenId;
            var v24401 = TypeScript$$14.TokenID;
            var v21774 = v24401.Extends;
            var v16996 = v21773 == v21774;
            if (v16996) {
              var v21775 = this.requiresExtendsBlock;
              v16996 = !v21775;
            }
            var v9044 = v16996;
            if (v9044) {
              this.requiresExtendsBlock = isClass;
            }
            currentList = extendsList$$4;
            keyword = true;
            continue;
          }
        }
        break;
      }
      return;
    }
    function v561(errorRecoverySet$$14) {
      var v9047 = TypeScript$$14.ASTList;
      var args$$8 = new v9047;
      var v9048 = this.scanner;
      args$$8.minChar = v9048.startPos;
      var v9049 = this.scanner;
      var v27253 = v9049.scan();
      this.currentToken = v27253;
      var v21776 = this.currentToken;
      var v16997 = v21776.tokenId;
      var v21777 = TypeScript$$14.TokenID;
      var v16998 = v21777.CloseParen;
      var v9056 = v16997 !== v16998;
      if (v9056) {
        for (;true;) {
          var v21778 = args$$8.members;
          var v16999 = v21778.length;
          var v9050 = v16999 > 65535;
          if (v9050) {
            this.reportParseError("max number of args exceeded");
            break;
          }
          var v21779 = TypeScript$$14.ErrorRecoverySet;
          var v17000 = v21779.Comma;
          var v9051 = v17000 | errorRecoverySet$$14;
          var v17001 = TypeScript$$14.OperatorPrecedence;
          var v9052 = v17001.Comma;
          var v9053 = TypeContext.NoTypes;
          var arg$$7 = this.parseExpr(v9051, v9052, true, v9053);
          args$$8.append(arg$$7);
          var v21780 = this.currentToken;
          var v17002 = v21780.tokenId;
          var v21781 = TypeScript$$14.TokenID;
          var v17003 = v21781.Comma;
          var v9054 = v17002 != v17003;
          if (v9054) {
            break;
          }
          var v9055 = this.scanner;
          var v27254 = v9055.scan();
          this.currentToken = v27254;
        }
      }
      var v9057 = this.scanner;
      args$$8.limChar = v9057.pos;
      return args$$8;
    }
    function v560(ast$$37) {
      var result$$9;
      var v9062 = ast$$37.nodeType;
      switch(v9062) {
        case TypeScript$$14.NodeType.TypeRef:
          return ast$$37;
        case TypeScript$$14.NodeType.Name:
          var v9058 = TypeScript$$14.TypeReference;
          result$$9 = new v9058(ast$$37, 0);
          result$$9.minChar = ast$$37.minChar;
          result$$9.limChar = ast$$37.limChar;
          return result$$9;
        case TypeScript$$14.NodeType.Index:
          var expr$$4 = ast$$37;
          var v9059 = expr$$4.operand1;
          result$$9 = this.convertToTypeReference(v9059);
          if (result$$9) {
            var v17004 = result$$9.arrayCount;
            result$$9.arrayCount = v17004 + 1;
            result$$9.minChar = expr$$4.minChar;
            result$$9.limChar = expr$$4.limChar;
            return result$$9;
          } else {
            var v9060 = TypeScript$$14.AST;
            var v17005 = TypeScript$$14.NodeType;
            var v9061 = v17005.Error;
            var etr$$1 = new v9060(v9061);
            return etr$$1;
          }
        ;
      }
      return null;
    }
    function v559(errorRecoverySet$$13, isDecl, requiresSignature$$1, isMethod$$1, methodName, indexer, isStatic, markedAsAmbient, modifiers$$3, lambdaArgContext, expectClosingRParen$$1) {
      var v9063 = this.scanner;
      var leftCurlyCount$$2 = v9063.leftCurlyCount;
      var v9064 = this.scanner;
      var rightCurlyCount$$2 = v9064.rightCurlyCount;
      var prevInConstr = this.parsingClassConstructorDefinition;
      this.parsingClassConstructorDefinition = false;
      var name$$48 = null;
      var v9065 = this.scanner;
      var fnMin = v9065.startPos;
      var v9066 = this.scanner;
      var minChar$$13 = v9066.pos;
      var prevNestingLevel = this.nestingLevel;
      var preComments$$2 = this.parseComments();
      var v9067 = !lambdaArgContext;
      var isLambda$$1 = !v9067;
      this.nestingLevel = 0;
      var v21782 = this.style_funcInLoop;
      var v17006 = !v21782;
      if (v17006) {
        v17006 = this.inLoop();
      }
      var v9068 = v17006;
      if (v9068) {
        this.reportParseStyleError("function declaration in loop");
      }
      var v24402 = !isMethod$$1;
      if (v24402) {
        v24402 = !isStatic;
      }
      var v21783 = v24402;
      if (v21783) {
        v21783 = !indexer;
      }
      var v17007 = v21783;
      if (v17007) {
        v17007 = !lambdaArgContext;
      }
      var v9078 = v17007;
      if (v9078) {
        var v9069 = this.scanner;
        var v27255 = v9069.scan();
        this.currentToken = v27255;
        this.state = ParseState.StartFncDecl;
        var v24403 = this.currentToken;
        var v21784 = v24403.tokenId;
        var v24404 = TypeScript$$14.TokenID;
        var v21785 = v24404.Identifier;
        var v17008 = v21784 != v21785;
        if (v17008) {
          var v24405 = this.currentToken;
          var v24406 = this.strictMode;
          var v21786 = TypeScript$$14.convertTokToID(v24405, v24406);
          v17008 = !v21786;
        }
        var v9077 = v17008;
        if (v9077) {
          if (isDecl) {
            this.reportParseError("Function declaration must include identifier");
            this.nestingLevel = prevNestingLevel;
            var v9070 = TypeScript$$14.IncompleteAST;
            var v17009 = this.scanner;
            var v9071 = v17009.pos;
            return new v9070(fnMin, v9071);
          }
        } else {
          var v9072 = TypeScript$$14.Identifier;
          var v9073 = this.currentToken;
          name$$48 = v9072.fromToken(v9073);
          var v9074 = this.scanner;
          name$$48.minChar = v9074.startPos;
          var v9075 = this.scanner;
          name$$48.limChar = v9075.pos;
          var v9076 = this.scanner;
          var v27256 = v9076.scan();
          this.currentToken = v27256;
        }
      } else {
        if (methodName) {
          name$$48 = methodName;
        }
      }
      this.state = ParseState.FncDeclName;
      var v9079 = TypeScript$$14.ASTList;
      var args$$7 = new v9079;
      var variableArgList$$1 = false;
      var isOverload = false;
      var v17010 = TypeScript$$14.Modifiers;
      var v9080 = v17010.Getter;
      var isGetter$$1 = TypeScript$$14.hasFlag(modifiers$$3, v9080);
      var v17011 = TypeScript$$14.Modifiers;
      var v9081 = v17011.Setter;
      var isSetter$$1 = TypeScript$$14.hasFlag(modifiers$$3, v9081);
      var v25664 = this.currentToken;
      var v24407 = v25664.tokenId;
      var v25665 = TypeScript$$14.TokenID;
      var v24408 = v25665.OpenParen;
      var v21787 = v24407 == v24408;
      var v24410 = !v21787;
      if (v24410) {
        var v24409 = indexer;
        if (v24409) {
          var v26258 = this.currentToken;
          var v25666 = v26258.tokenId;
          var v26259 = TypeScript$$14.TokenID;
          var v25667 = v26259.OpenBracket;
          v24409 = v25666 == v25667;
        }
        v21787 = v24409;
      }
      var v17012 = v21787;
      var v21789 = !v17012;
      if (v21789) {
        var v21788 = lambdaArgContext;
        if (v21788) {
          var v24411 = lambdaArgContext.preProcessedLambdaArgs;
          var v25670 = !v24411;
          if (v25670) {
            var v26260 = this.currentToken;
            var v25668 = v26260.tokenId;
            var v26261 = TypeScript$$14.TokenID;
            var v25669 = v26261.DotDotDot;
            v24411 = v25668 == v25669;
          }
          v21788 = v24411;
        }
        v17012 = v21788;
      }
      var v9083 = v17012;
      if (v9083) {
        var v17013;
        if (lambdaArgContext) {
          v17013 = lambdaArgContext.preProcessedLambdaArgs;
        } else {
          v17013 = null;
        }
        var v9082 = v17013;
        variableArgList$$1 = this.parseFormalParameterList(errorRecoverySet$$13, args$$7, false, requiresSignature$$1, indexer, isGetter$$1, isSetter$$1, isLambda$$1, v9082, expectClosingRParen$$1);
      }
      this.state = ParseState.FncDeclArgs;
      var returnType$$1 = null;
      var v21790 = this.currentToken;
      var v17014 = v21790.tokenId;
      var v21791 = TypeScript$$14.TokenID;
      var v17015 = v21791.Colon;
      var v9086 = v17014 == v17015;
      if (v9086) {
        var v9084 = this.scanner;
        var v27257 = v9084.scan();
        this.currentToken = v27257;
        var v21792 = TypeScript$$14.Modifiers;
        var v17016 = v21792.Setter;
        var v9085 = TypeScript$$14.hasFlag(modifiers$$3, v17016);
        if (v9085) {
          this.reportParseError("Property setters may not declare a return type");
        }
        returnType$$1 = this.parseTypeReference(errorRecoverySet$$13, true);
      }
      var v17017 = indexer;
      if (v17017) {
        var v24412 = args$$7.members;
        var v21793 = v24412.length;
        v17017 = v21793 == 0;
      }
      var v9087 = v17017;
      if (v9087) {
        this.reportParseError("Index signatures require a parameter type to be specified");
      }
      this.state = ParseState.FncDeclReturnType;
      var v17018 = isLambda$$1;
      if (v17018) {
        var v24413 = this.currentToken;
        var v21794 = v24413.tokenId;
        var v24414 = TypeScript$$14.TokenID;
        var v21795 = v24414.EqualsGreaterThan;
        v17018 = v21794 != v21795;
      }
      var v9088 = v17018;
      if (v9088) {
        this.reportParseError("Expected '=>'");
      }
      var v24415 = isDecl;
      if (v24415) {
        var v26262 = this.parsingDeclareFile;
        var v26520 = !v26262;
        if (v26520) {
          v26262 = markedAsAmbient;
        }
        var v25671 = v26262;
        v24415 = !v25671;
      }
      var v21796 = v24415;
      if (v21796) {
        var v24416 = !isMethod$$1;
        var v25673 = !v24416;
        if (v25673) {
          var v26521 = this.ambientModule;
          var v26643 = !v26521;
          if (v26643) {
            v26521 = this.ambientClass;
          }
          var v26263 = v26521;
          var v26522 = !v26263;
          if (v26522) {
            v26263 = this.inInterfaceDecl;
          }
          var v25672 = v26263;
          v24416 = !v25672;
        }
        v21796 = v24416;
      }
      var v17019 = v21796;
      if (v17019) {
        var v24417 = this.currentToken;
        var v21797 = v24417.tokenId;
        var v24418 = TypeScript$$14.TokenID;
        var v21798 = v24418.Semicolon;
        v17019 = v21797 == v21798;
      }
      var v9089 = v17019;
      if (v9089) {
        isOverload = true;
        isDecl = false;
        requiresSignature$$1 = true;
      }
      var svInFncDecl = this.inFncDecl;
      this.inFncDecl = true;
      var v21799 = TypeScript$$14.ErrorRecoverySet;
      var v17020 = v21799.RCurly;
      var v9090 = errorRecoverySet$$13 | v17020;
      var v17021 = TypeScript$$14.AllowedElements;
      var v9091 = v17021.None;
      var v17022 = TypeScript$$14.Modifiers;
      var v9092 = v17022.None;
      var funcDecl$$7 = this.parseFunctionStatements(v9090, name$$48, false, isMethod$$1, args$$7, v9091, minChar$$13, requiresSignature$$1, v9092);
      this.inFncDecl = svInFncDecl;
      funcDecl$$7.variableArgList = variableArgList$$1;
      funcDecl$$7.isOverload = isOverload;
      var v9093 = !requiresSignature$$1;
      if (v9093) {
        var v17023 = funcDecl$$7.fncFlags;
        var v21800 = TypeScript$$14.FncFlags;
        var v17024 = v21800.Definition;
        funcDecl$$7.fncFlags = v17023 | v17024;
      }
      if (isStatic) {
        var v17025 = funcDecl$$7.fncFlags;
        var v21801 = TypeScript$$14.FncFlags;
        var v17026 = v21801.Static;
        funcDecl$$7.fncFlags = v17025 | v17026;
      }
      if (requiresSignature$$1) {
        var v17027 = funcDecl$$7.fncFlags;
        var v21802 = TypeScript$$14.FncFlags;
        var v17028 = v21802.Signature;
        funcDecl$$7.fncFlags = v17027 | v17028;
      }
      if (indexer) {
        var v17029 = funcDecl$$7.fncFlags;
        var v21803 = TypeScript$$14.FncFlags;
        var v17030 = v21803.IndexerMember;
        funcDecl$$7.fncFlags = v17029 | v17030;
      }
      funcDecl$$7.returnTypeAnnotation = returnType$$1;
      if (isMethod$$1) {
        var v17031 = funcDecl$$7.fncFlags;
        var v21804 = TypeScript$$14.FncFlags;
        var v17032 = v21804.Method;
        funcDecl$$7.fncFlags = v17031 | v17032;
        var v17033 = funcDecl$$7.fncFlags;
        var v21805 = TypeScript$$14.FncFlags;
        var v17034 = v21805.ClassPropertyMethodExported;
        funcDecl$$7.fncFlags = v17033 | v17034;
      }
      var v17035 = this.scanner;
      var v9094 = v17035.leftCurlyCount;
      funcDecl$$7.leftCurlyCount = v9094 - leftCurlyCount$$2;
      var v17036 = this.scanner;
      var v9095 = v17036.rightCurlyCount;
      funcDecl$$7.rightCurlyCount = v9095 - rightCurlyCount$$2;
      this.nestingLevel = prevNestingLevel;
      this.parsingClassConstructorDefinition = prevInConstr;
      funcDecl$$7.preComments = preComments$$2;
      return funcDecl$$7;
    }
    function v558(errorRecoverySet$$12, formals$$2, isClassConstr, isSig, isIndexer, isGetter, isSetter, isLambda, preProcessedLambdaArgs, expectClosingRParen) {
      var v9096 = this.scanner;
      formals$$2.minChar = v9096.startPos;
      if (isIndexer) {
        var v9097 = this.scanner;
        var v27258 = v9097.scan();
        this.currentToken = v27258;
      } else {
        var v9100 = !isLambda;
        if (v9100) {
          var v17037 = TypeScript$$14.TokenID;
          var v9098 = v17037.OpenParen;
          var v21806 = TypeScript$$14.ErrorRecoverySet;
          var v17038 = v21806.RParen;
          var v9099 = errorRecoverySet$$12 | v17038;
          this.checkCurrentToken(v9098, v9099);
        }
      }
      var sawEllipsis = false;
      var firstArg = true;
      var hasOptional = false;
      var haveFirstArgID = false;
      var v17039 = isLambda && preProcessedLambdaArgs;
      if (v17039) {
        var v21807 = preProcessedLambdaArgs.nodeType;
        var v24419 = TypeScript$$14.NodeType;
        var v21808 = v24419.EmptyExpr;
        v17039 = v21807 != v21808;
      }
      var v9101 = v17039;
      if (v9101) {
        hasOptional = this.transformAnonymousArgsIntoFormals(formals$$2, preProcessedLambdaArgs);
        haveFirstArgID = true;
      }
      for (;true;) {
        var munchedArg = false;
        var v9102 = TypeScript$$14.VarFlags;
        var argFlags = v9102.None;
        var v9103 = this.scanner;
        var argMinChar = v9103.startPos;
        var v17040 = this.inferPropertiesFromThisAssignment;
        if (v17040) {
          var v24420 = this.currentToken;
          var v21809 = v24420.tokenId;
          var v24421 = TypeScript$$14.TokenID;
          var v21810 = v24421.This;
          v17040 = v21809 == v21810;
        }
        var v9108 = v17040;
        if (v9108) {
          var v9104 = !isClassConstr;
          if (v9104) {
            this.reportParseError("Instance property declarations using 'this' may only be used in class constructors");
          }
          var v9105 = this.scanner;
          var v27259 = v9105.scan();
          this.currentToken = v27259;
          var v24422 = TypeScript$$14.VarFlags;
          var v21811 = v24422.Public;
          var v24423 = TypeScript$$14.VarFlags;
          var v21812 = v24423.Property;
          var v17041 = v21811 | v21812;
          argFlags = argFlags | v17041;
          var v9107 = this.currentClassDefinition;
          if (v9107) {
            var v9106 = this.currentClassDefinition;
            var v21813 = v9106.varFlags;
            var v24424 = TypeScript$$14.VarFlags;
            var v21814 = v24424.ClassSuperMustBeFirstCallInConstructor;
            v9106.varFlags = v21813 | v21814;
          }
        }
        var v21815 = this.currentToken;
        var v17042 = v21815.tokenId;
        var v21816 = TypeScript$$14.TokenID;
        var v17043 = v21816.Public;
        var v9116 = v17042 == v17043;
        if (v9116) {
          var v24425 = TypeScript$$14.VarFlags;
          var v21817 = v24425.Public;
          var v24426 = TypeScript$$14.VarFlags;
          var v21818 = v24426.Property;
          var v17044 = v21817 | v21818;
          argFlags = argFlags | v17044;
          var v9110 = this.currentClassDefinition;
          if (v9110) {
            var v9109 = this.currentClassDefinition;
            var v21819 = v9109.varFlags;
            var v24427 = TypeScript$$14.VarFlags;
            var v21820 = v24427.ClassSuperMustBeFirstCallInConstructor;
            v9109.varFlags = v21819 | v21820;
          }
        } else {
          var v21821 = this.currentToken;
          var v17045 = v21821.tokenId;
          var v21822 = TypeScript$$14.TokenID;
          var v17046 = v21822.Private;
          var v9115 = v17045 == v17046;
          if (v9115) {
            var v24428 = TypeScript$$14.VarFlags;
            var v21823 = v24428.Private;
            var v24429 = TypeScript$$14.VarFlags;
            var v21824 = v24429.Property;
            var v17047 = v21823 | v21824;
            argFlags = argFlags | v17047;
            var v9112 = this.currentClassDefinition;
            if (v9112) {
              var v9111 = this.currentClassDefinition;
              var v21825 = v9111.varFlags;
              var v24430 = TypeScript$$14.VarFlags;
              var v21826 = v24430.ClassSuperMustBeFirstCallInConstructor;
              v9111.varFlags = v21825 | v21826;
            }
          } else {
            var v24431 = this.currentToken;
            var v21827 = v24431.tokenId;
            var v24432 = TypeScript$$14.TokenID;
            var v21828 = v24432.Static;
            var v17048 = v21827 == v21828;
            if (v17048) {
              v17048 = isClassConstr;
            }
            var v9114 = v17048;
            if (v9114) {
              this.reportParseError("Static properties can not be declared as parameter properties");
              var v9113 = this.scanner;
              var v27260 = v9113.scan();
              this.currentToken = v27260;
            }
          }
        }
        var v21829 = TypeScript$$14.VarFlags;
        var v17049 = v21829.None;
        var v9128 = argFlags != v17049;
        if (v9128) {
          var v9117 = !isClassConstr;
          if (v9117) {
            this.reportParseError("only constructor parameters can be properties");
          }
          var v9118 = this.scanner;
          var v27261 = v9118.scan();
          this.currentToken = v27261;
          var v17050 = this.currentToken;
          var v9120 = TypeScript$$14.isModifier(v17050);
          if (v9120) {
            this.reportParseError("Multiple modifiers may not be applied to parameters");
            var v9119 = this.scanner;
            var v27262 = v9119.scan();
            this.currentToken = v27262;
          }
          var v17051 = this.inferPropertiesFromThisAssignment;
          if (v17051) {
            var v24433 = this.currentToken;
            var v21830 = v24433.tokenId;
            var v24434 = TypeScript$$14.TokenID;
            var v21831 = v24434.This;
            v17051 = v21830 == v21831;
          }
          var v9124 = v17051;
          if (v9124) {
            var v9121 = !isClassConstr;
            if (v9121) {
              this.reportParseError("Instance property declarations using 'this' may only be used in class constructors");
            }
            var v9122 = this.scanner;
            var v27263 = v9122.scan();
            this.currentToken = v27263;
            var v9123 = this.scanner;
            var v27264 = v9123.scan();
            this.currentToken = v27264;
          }
        } else {
          var v21832 = this.currentToken;
          var v17052 = v21832.tokenId;
          var v21833 = TypeScript$$14.TokenID;
          var v17053 = v21833.DotDotDot;
          var v9127 = v17052 == v17053;
          if (v9127) {
            sawEllipsis = true;
            var v9125 = this.scanner;
            var v27265 = v9125.scan();
            this.currentToken = v27265;
            var v25674 = this.currentToken;
            var v24435 = v25674.tokenId;
            var v25675 = TypeScript$$14.TokenID;
            var v24436 = v25675.Identifier;
            var v21834 = v24435 == v24436;
            var v17054 = !v21834;
            var v21837 = !v17054;
            if (v21837) {
              var v21835 = this.currentToken;
              var v21836 = this.strictMode;
              v17054 = TypeScript$$14.convertTokToID(v21835, v21836);
            }
            var v9126 = v17054;
            if (v9126) {
              this.reportParseError("'...' parameters require both a parameter name and an array type annotation to be specified");
              sawEllipsis = false;
            }
          }
        }
        var argId = null;
        var v21838 = !haveFirstArgID;
        if (v21838) {
          var v25676 = this.currentToken;
          var v24437 = v25676.tokenId;
          var v25677 = TypeScript$$14.TokenID;
          var v24438 = v25677.Identifier;
          v21838 = v24437 == v24438;
        }
        var v17055 = v21838;
        var v21841 = !v17055;
        if (v21841) {
          var v21839 = this.currentToken;
          var v21840 = this.strictMode;
          v17055 = TypeScript$$14.convertTokToID(v21839, v21840);
        }
        var v9133 = v17055;
        if (v9133) {
          var v9129 = TypeScript$$14.Identifier;
          var v9130 = this.currentToken;
          argId = v9129.fromToken(v9130);
          var v9131 = this.scanner;
          argId.minChar = v9131.startPos;
          var v9132 = this.scanner;
          argId.limChar = v9132.pos;
        }
        var v9155 = haveFirstArgID || argId;
        if (v9155) {
          munchedArg = true;
          var type$$30 = null;
          var arg$$6 = null;
          var v17056 = haveFirstArgID;
          if (v17056) {
            var v21842 = formals$$2.members;
            v17056 = v21842.length;
          }
          var v9141 = v17056;
          if (v9141) {
            var v9134 = formals$$2.members;
            var v21843 = formals$$2.members;
            var v17057 = v21843.length;
            var v9135 = v17057 - 1;
            arg$$6 = v9134[v9135];
            var v9136 = arg$$6.isOptional;
            if (v9136) {
              hasOptional = true;
            }
          } else {
            var v9137 = TypeScript$$14.ArgDecl;
            arg$$6 = new v9137(argId);
            if (isGetter) {
              this.reportParseError("Property getters may not take any arguments");
            }
            var v17058 = isSetter;
            if (v17058) {
              v17058 = !firstArg;
            }
            var v9138 = v17058;
            if (v9138) {
              this.reportParseError("Property setters may only take one argument");
            }
            arg$$6.minChar = argMinChar;
            var v9139 = arg$$6;
            var v27266 = this.parseComments();
            v9139.preComments = v27266;
            var v9140 = this.scanner;
            var v27267 = v9140.scan();
            this.currentToken = v27267;
          }
          var v21844 = this.currentToken;
          var v17059 = v21844.tokenId;
          var v21845 = TypeScript$$14.TokenID;
          var v17060 = v21845.Question;
          var v9143 = v17059 == v17060;
          if (v9143) {
            arg$$6.isOptional = true;
            hasOptional = true;
            var v9142 = this.scanner;
            var v27268 = v9142.scan();
            this.currentToken = v27268;
          }
          var v21846 = this.currentToken;
          var v17061 = v21846.tokenId;
          var v21847 = TypeScript$$14.TokenID;
          var v17062 = v21847.Colon;
          var v9145 = v17061 == v17062;
          if (v9145) {
            var v9144 = this.scanner;
            var v27269 = v9144.scan();
            this.currentToken = v27269;
            type$$30 = this.parseTypeReference(errorRecoverySet$$12, false);
          }
          var v21848 = this.currentToken;
          var v17063 = v21848.tokenId;
          var v21849 = TypeScript$$14.TokenID;
          var v17064 = v21849.Equals;
          var v9148 = v17063 == v17064;
          if (v9148) {
            if (isSig) {
              this.reportParseError("Arguments in signatures may not have default values");
            }
            hasOptional = true;
            var v9146 = this.scanner;
            var v27270 = v9146.scan();
            this.currentToken = v27270;
            var v9147 = arg$$6;
            var v24439 = TypeScript$$14.ErrorRecoverySet;
            var v21850 = v24439.Comma;
            var v17065 = v21850 | errorRecoverySet$$12;
            var v21851 = TypeScript$$14.OperatorPrecedence;
            var v17066 = v21851.Comma;
            var v17067 = TypeContext.NoTypes;
            var v27271 = this.parseExpr(v17065, v17066, false, v17067);
            v9147.init = v27271;
          }
          var v21852 = hasOptional;
          if (v21852) {
            var v24440 = arg$$6.isOptionalArg();
            v21852 = !v24440;
          }
          var v17068 = v21852;
          if (v17068) {
            v17068 = !sawEllipsis;
          }
          var v9149 = v17068;
          if (v9149) {
            this.reportParseError("Optional parameters may only be followed by other optional parameters");
          }
          var v17069 = sawEllipsis;
          if (v17069) {
            v17069 = arg$$6.isOptionalArg();
          }
          var v9150 = v17069;
          if (v9150) {
            this.reportParseError("Varargs may not be optional or have default parameters");
          }
          var v17070 = sawEllipsis;
          if (v17070) {
            v17070 = !type$$30;
          }
          var v9151 = v17070;
          if (v9151) {
            this.reportParseError("'...' parameters require both a parameter name and an array type annotation to be specified");
          }
          var v9152 = arg$$6;
          var v27272 = this.parseComments();
          v9152.postComments = v27272;
          arg$$6.typeExpr = type$$30;
          var v9153 = arg$$6;
          var v17071 = this.scanner;
          var v27273 = v17071.lastTokenLimChar();
          v9153.limChar = v27273;
          var v17072 = arg$$6.varFlags;
          arg$$6.varFlags = v17072 | argFlags;
          var v9154 = !haveFirstArgID;
          if (v9154) {
            formals$$2.append(arg$$6);
          } else {
            haveFirstArgID = false;
          }
        }
        firstArg = false;
        var v21853 = this.currentToken;
        var v17073 = v21853.tokenId;
        var v21854 = TypeScript$$14.TokenID;
        var v17074 = v21854.Comma;
        var v9160 = v17073 == v17074;
        if (v9160) {
          var v17075 = munchedArg;
          if (v17075) {
            v17075 = !sawEllipsis;
          }
          var v9159 = v17075;
          if (v9159) {
            var v9156 = this.scanner;
            var v27274 = v9156.scan();
            this.currentToken = v27274;
          } else {
            this.reportParseError("Unexpected ',' in argument list");
            var v9158 = this.errorRecovery;
            if (v9158) {
              var v9157 = this.scanner;
              var v27275 = v9157.scan();
              this.currentToken = v27275;
            }
          }
        } else {
          break;
        }
      }
      if (isIndexer) {
        var v17076 = TypeScript$$14.TokenID;
        var v9161 = v17076.CloseBracket;
        var v24441 = TypeScript$$14.ErrorRecoverySet;
        var v21855 = v24441.LCurly;
        var v17077 = errorRecoverySet$$12 | v21855;
        var v21856 = TypeScript$$14.ErrorRecoverySet;
        var v17078 = v21856.SColon;
        var v9162 = v17077 | v17078;
        this.checkCurrentToken(v9161, v9162);
      } else {
        if (expectClosingRParen) {
          var v17079 = TypeScript$$14.TokenID;
          var v9163 = v17079.CloseParen;
          var v24442 = TypeScript$$14.ErrorRecoverySet;
          var v21857 = v24442.LCurly;
          var v17080 = errorRecoverySet$$12 | v21857;
          var v21858 = TypeScript$$14.ErrorRecoverySet;
          var v17081 = v21858.SColon;
          var v9164 = v17080 | v17081;
          this.checkCurrentToken(v9163, v9164);
        }
      }
      var v9165 = formals$$2;
      var v17082 = this.scanner;
      var v27276 = v17082.lastTokenLimChar();
      v9165.limChar = v27276;
      return sawEllipsis;
    }
    function v557(formals$$1, argList) {
      function translateBinExOperand(operand$$1) {
        var v17083 = operand$$1.nodeType;
        var v21859 = TypeScript$$14.NodeType;
        var v17084 = v21859.Comma;
        var v9172 = v17083 == v17084;
        if (v9172) {
          return _this$$1.transformAnonymousArgsIntoFormals(formals$$1, operand$$1);
        } else {
          var v21860 = operand$$1.nodeType;
          var v24443 = TypeScript$$14.NodeType;
          var v21861 = v24443.Name;
          var v17085 = v21860 == v21861;
          var v21864 = !v17085;
          if (v21864) {
            var v21862 = operand$$1.nodeType;
            var v24444 = TypeScript$$14.NodeType;
            var v21863 = v24444.Asg;
            v17085 = v21862 == v21863;
          }
          var v9171 = v17085;
          if (v9171) {
            var v9166;
            var v21865 = operand$$1.nodeType;
            var v24445 = TypeScript$$14.NodeType;
            var v21866 = v24445.Asg;
            var v17086 = v21865 == v21866;
            if (v17086) {
              v9166 = operand$$1.operand1;
            } else {
              v9166 = operand$$1;
            }
            var opArg = v9166;
            var v9167 = TypeScript$$14.ArgDecl;
            var arg$$5 = new v9167(opArg);
            arg$$5.preComments = opArg.preComments;
            arg$$5.postComments = opArg.postComments;
            arg$$5.minChar = operand$$1.minChar;
            arg$$5.limChar = operand$$1.limChar;
            var v17087 = opArg.flags;
            var v21867 = TypeScript$$14.ASTFlags;
            var v17088 = v21867.PossibleOptionalParameter;
            var v9168 = TypeScript$$14.hasFlag(v17087, v17088);
            if (v9168) {
              arg$$5.isOptional = true;
            }
            var v17089 = operand$$1.nodeType;
            var v21868 = TypeScript$$14.NodeType;
            var v17090 = v21868.Asg;
            var v9169 = v17089 == v17090;
            if (v9169) {
              arg$$5.init = operand$$1.operand2;
            }
            formals$$1.append(arg$$5);
            var v9170 = arg$$5.isOptional;
            var v17091 = !v9170;
            if (v17091) {
              v9170 = arg$$5.init;
            }
            return v9170;
          } else {
            _this$$1.reportParseError("Invalid lambda argument");
          }
        }
        return false;
      }
      var _this$$1 = this;
      if (argList) {
        var v17092 = argList.nodeType;
        var v21869 = TypeScript$$14.NodeType;
        var v17093 = v21869.Comma;
        var v9181 = v17092 == v17093;
        if (v9181) {
          var commaList = argList;
          var v17094 = commaList.operand1;
          var v9175 = v17094.isParenthesized;
          if (v9175) {
            var v17095 = commaList.operand1;
            var v9173 = v17095.minChar;
            var v17096 = commaList.operand1;
            var v9174 = v17096.limChar;
            this.reportParseError("Invalid lambda argument", v9173, v9174);
          }
          var v17097 = commaList.operand2;
          var v9178 = v17097.isParenthesized;
          if (v9178) {
            var v17098 = commaList.operand2;
            var v9176 = v17098.minChar;
            var v17099 = commaList.operand2;
            var v9177 = v17099.limChar;
            this.reportParseError("Invalid lambda argument", v9176, v9177);
          }
          var v9179 = commaList.operand1;
          var isOptional = translateBinExOperand(v9179);
          var v17100 = commaList.operand2;
          var v9180 = translateBinExOperand(v17100);
          var v17101 = !v9180;
          if (v17101) {
            v9180 = isOptional;
          }
          isOptional = v9180;
          return isOptional;
        } else {
          return translateBinExOperand(argList);
        }
      }
      return;
    }
    function v556(errorRecoverySet$$11, name$$47, isConstructor$$1, isMethod, args$$6, allowedElements$$1, minChar$$12, requiresSignature, parentModifiers$$1) {
      this.pushDeclLists();
      var svStmtStack = this.statementInfoStack;
      this.resetStmtStack();
      var bod$$2 = null;
      var wasShorthand = false;
      var isAnonLambda = false;
      var limChar$$6;
      if (requiresSignature) {
        var v9182 = this.scanner;
        limChar$$6 = v9182.pos;
        var v21870 = this.currentToken;
        var v17102 = v21870.tokenId;
        var v21871 = TypeScript$$14.TokenID;
        var v17103 = v21871.OpenBrace;
        var v9189 = v17102 === v17103;
        if (v9189) {
          this.reportParseError("Function declarations are not permitted within interfaces, ambient modules or classes");
          var v9183 = TypeScript$$14.ASTList;
          bod$$2 = new v9183;
          var v9184 = this.scanner;
          var bodMinChar$$1 = v9184.startPos;
          this.parseFunctionBlock(errorRecoverySet$$11, allowedElements$$1, parentModifiers$$1, bod$$2, bodMinChar$$1);
          var v17104 = TypeScript$$14.TokenID;
          var v9185 = v17104.CloseBrace;
          this.checkCurrentToken(v9185, errorRecoverySet$$11);
          var v21872 = this.currentToken;
          var v17105 = v21872.tokenId;
          var v21873 = TypeScript$$14.TokenID;
          var v17106 = v21873.Semicolon;
          var v9187 = v17105 === v17106;
          if (v9187) {
            var v9186 = this.scanner;
            var v27277 = v9186.scan();
            this.currentToken = v27277;
          }
        } else {
          var v17107 = TypeScript$$14.TokenID;
          var v9188 = v17107.Semicolon;
          this.checkCurrentToken(v9188, errorRecoverySet$$11, "Expected ';'");
        }
      } else {
        var v9190 = TypeScript$$14.ASTList;
        bod$$2 = new v9190;
        var v9191 = this.scanner;
        bodMinChar$$1 = v9191.startPos;
        var v21874 = this.currentToken;
        var v17108 = v21874.tokenId;
        var v21875 = TypeScript$$14.TokenID;
        var v17109 = v21875.EqualsGreaterThan;
        var v9193 = v17108 == v17109;
        if (v9193) {
          if (isMethod) {
            this.reportParseError("'=>' may not be used for class methods");
          }
          wasShorthand = true;
          var v9192 = this.scanner;
          var v27278 = v9192.scan();
          this.currentToken = v27278;
        }
        var v17110 = wasShorthand;
        if (v17110) {
          var v24446 = this.currentToken;
          var v21876 = v24446.tokenId;
          var v24447 = TypeScript$$14.TokenID;
          var v21877 = v24447.OpenBrace;
          v17110 = v21876 != v21877;
        }
        var v9198 = v17110;
        if (v9198) {
          var v21878 = TypeScript$$14.ErrorRecoverySet;
          var v17111 = v21878.SColon;
          var v9194 = errorRecoverySet$$11 | v17111;
          var v17112 = TypeScript$$14.OperatorPrecedence;
          var v9195 = v17112.Assignment;
          var v9196 = TypeContext.NoTypes;
          var retExpr = this.parseExpr(v9194, v9195, true, v9196);
          var v9197 = TypeScript$$14.ReturnStatement;
          var retStmt = new v9197;
          retStmt.returnExpression = retExpr;
          retStmt.minChar = retExpr.minChar;
          retStmt.limChar = retExpr.limChar;
          bod$$2.minChar = bodMinChar$$1;
          bod$$2.append(retStmt);
        } else {
          isAnonLambda = wasShorthand;
          this.parseFunctionBlock(errorRecoverySet$$11, allowedElements$$1, parentModifiers$$1, bod$$2, bodMinChar$$1);
        }
        var v9199 = this.scanner;
        limChar$$6 = v9199.pos;
      }
      var v9200 = TypeScript$$14.FuncDecl;
      var v9201 = this.topVarList();
      var v9202 = this.topScopeList();
      var v9203 = this.topStaticsList();
      var v17113 = TypeScript$$14.NodeType;
      var v9204 = v17113.FuncDecl;
      var funcDecl$$6 = new v9200(name$$47, bod$$2, isConstructor$$1, args$$6, v9201, v9202, v9203, v9204);
      this.popDeclLists();
      var scopeList = this.topScopeList();
      scopeList.append(funcDecl$$6);
      var staticFuncDecl = false;
      var v9213 = !requiresSignature;
      if (v9213) {
        var v17114 = !wasShorthand;
        var v21879 = !v17114;
        if (v21879) {
          v17114 = isAnonLambda;
        }
        var v9212 = v17114;
        if (v9212) {
          var v9205 = funcDecl$$6;
          var v17115 = TypeScript$$14.ASTSpan;
          var v27279 = new v17115;
          v9205.endingToken = v27279;
          var v9206 = funcDecl$$6.endingToken;
          var v17116 = this.scanner;
          v9206.minChar = v17116.startPos;
          var v9207 = funcDecl$$6.endingToken;
          var v17117 = this.scanner;
          v9207.limChar = v17117.pos;
          var v17118 = TypeScript$$14.TokenID;
          var v9208 = v17118.CloseBrace;
          this.checkCurrentToken(v9208, errorRecoverySet$$11);
          if (isAnonLambda) {
            var v17119 = funcDecl$$6.fncFlags;
            var v21880 = TypeScript$$14.FncFlags;
            var v17120 = v21880.IsFatArrowFunction;
            funcDecl$$6.fncFlags = v17119 | v17120;
          }
        } else {
          var v17121 = funcDecl$$6.fncFlags;
          var v21881 = TypeScript$$14.FncFlags;
          var v17122 = v21881.IsFatArrowFunction;
          funcDecl$$6.fncFlags = v17121 | v17122;
          var v9209 = funcDecl$$6;
          var v17123 = TypeScript$$14.ASTSpan;
          var v27280 = new v17123;
          v9209.endingToken = v27280;
          var v9210 = funcDecl$$6.endingToken;
          var v21882 = bod$$2.members;
          var v17124 = v21882[0];
          v9210.minChar = v17124.minChar;
          var v9211 = funcDecl$$6.endingToken;
          var v21883 = bod$$2.members;
          var v17125 = v21883[0];
          v9211.limChar = v17125.limChar;
        }
      }
      funcDecl$$6.minChar = minChar$$12;
      funcDecl$$6.limChar = limChar$$6;
      var v9214 = !requiresSignature;
      if (v9214) {
        var v17126 = funcDecl$$6.fncFlags;
        var v21884 = TypeScript$$14.FncFlags;
        var v17127 = v21884.Definition;
        funcDecl$$6.fncFlags = v17126 | v17127;
      }
      this.statementInfoStack = svStmtStack;
      return funcDecl$$6;
    }
    function v555(errorRecoverySet$$10, allowedElements, parentModifiers, bod$$1, bodMinChar) {
      this.state = ParseState.StartStatementList;
      var v17128 = TypeScript$$14.TokenID;
      var v9215 = v17128.OpenBrace;
      var v21885 = TypeScript$$14.ErrorRecoverySet;
      var v17129 = v21885.StmtStart;
      var v9216 = errorRecoverySet$$10 | v17129;
      this.checkCurrentToken(v9215, v9216);
      var savedInFunction = this.inFunction;
      this.inFunction = true;
      var v24448 = TypeScript$$14.ErrorRecoverySet;
      var v21886 = v24448.RCurly;
      var v17130 = errorRecoverySet$$10 | v21886;
      var v21887 = TypeScript$$14.ErrorRecoverySet;
      var v17131 = v21887.StmtStart;
      var v9217 = v17130 | v17131;
      this.parseStatementList(v9217, bod$$1, true, false, allowedElements, parentModifiers);
      bod$$1.minChar = bodMinChar;
      var v9218 = this.scanner;
      bod$$1.limChar = v9218.pos;
      this.inFunction = savedInFunction;
      var v9219 = TypeScript$$14.EndCode;
      var ec = new v9219;
      ec.minChar = bod$$1.limChar;
      ec.limChar = ec.minChar;
      bod$$1.append(ec);
      return;
    }
    function v554(minChar$$11, errorRecoverySet$$9) {
      var v9220 = this.scanner;
      var v27281 = v9220.scan();
      this.currentToken = v27281;
      var v9221 = TypeScript$$14.ASTList;
      var members$$8 = new v9221;
      members$$8.minChar = minChar$$11;
      var prevInInterfaceDecl = this.inInterfaceDecl;
      this.inInterfaceDecl = true;
      var v21888 = TypeScript$$14.ErrorRecoverySet;
      var v17132 = v21888.RCurly;
      var v9222 = errorRecoverySet$$9 | v17132;
      this.parseTypeMemberList(v9222, members$$8);
      this.inInterfaceDecl = prevInInterfaceDecl;
      var v17133 = TypeScript$$14.TokenID;
      var v9223 = v17133.CloseBrace;
      this.checkCurrentToken(v9223, errorRecoverySet$$9);
      var v9224 = TypeScript$$14.InterfaceDeclaration;
      var v9225 = this.anonId;
      var interfaceDecl = new v9224(v9225, members$$8, null, null);
      interfaceDecl.minChar = minChar$$11;
      interfaceDecl.limChar = members$$8.limChar;
      return this.parseTypeReferenceTail(errorRecoverySet$$9, minChar$$11, interfaceDecl);
    }
    function v553(errorRecoverySet$$8, allowVoid) {
      var v9226 = this.scanner;
      var minChar$$10 = v9226.startPos;
      var isConstructorMember = false;
      var v17134 = this.currentToken;
      var v9245 = v17134.tokenId;
      switch(v9245) {
        case TypeScript$$14.TokenID.Void:
          var v9227 = !allowVoid;
          if (v9227) {
            this.reportParseError("void not a valid type in this context");
          }
        ;
        case TypeScript$$14.TokenID.Any:
        ;
        case TypeScript$$14.TokenID.Number:
        ;
        case TypeScript$$14.TokenID.Bool:
        ;
        case TypeScript$$14.TokenID.String:
          var v17135 = TypeScript$$14.tokenTable;
          var v21889 = this.currentToken;
          var v17136 = v21889.tokenId;
          var v9228 = v17135[v17136];
          var text$$14 = v9228.text;
          var v9229 = TypeScript$$14.Identifier;
          var predefinedIdentifier = new v9229(text$$14);
          predefinedIdentifier.minChar = minChar$$10;
          var v9230 = this.scanner;
          predefinedIdentifier.limChar = v9230.pos;
          var v9231 = this.scanner;
          var v27282 = v9231.scan();
          this.currentToken = v27282;
          return this.parseTypeReferenceTail(errorRecoverySet$$8, minChar$$10, predefinedIdentifier);
        case TypeScript$$14.TokenID.Identifier:
          var v17137 = this.currentToken;
          var v9232 = v17137.getText();
          var v17138 = this.currentToken;
          var v9233 = v17138.hasEscapeSequence;
          var ident = this.createRef(v9232, v9233, minChar$$10);
          var v9234 = this.scanner;
          ident.limChar = v9234.pos;
          return this.parseNamedType(errorRecoverySet$$8, minChar$$10, ident, true);
        case TypeScript$$14.TokenID.OpenBrace:
          return this.parseObjectType(minChar$$10, errorRecoverySet$$8);
        case TypeScript$$14.TokenID.New:
          var v9235 = this.scanner;
          var v27283 = v9235.scan();
          this.currentToken = v27283;
          var v21890 = this.currentToken;
          var v17139 = v21890.tokenId;
          var v21891 = TypeScript$$14.TokenID;
          var v17140 = v21891.OpenParen;
          var v9236 = v17139 != v17140;
          if (v9236) {
            this.reportParseError("Expected '('");
          } else {
            isConstructorMember = true;
          }
        ;
        case TypeScript$$14.TokenID.OpenParen:
          var v9237 = TypeScript$$14.ASTList;
          var formals = new v9237;
          var v21892 = TypeScript$$14.ErrorRecoverySet;
          var v17141 = v21892.RParen;
          var v9238 = errorRecoverySet$$8 | v17141;
          var variableArgList = this.parseFormalParameterList(v9238, formals, false, true, false, false, false, false, null, true);
          var v17142 = TypeScript$$14.TokenID;
          var v9239 = v17142.EqualsGreaterThan;
          this.checkCurrentToken(v9239, errorRecoverySet$$8);
          var returnType = this.parseTypeReference(errorRecoverySet$$8, true);
          var v9240 = TypeScript$$14.FuncDecl;
          var v17143 = TypeScript$$14.NodeType;
          var v9241 = v17143.FuncDecl;
          var funcDecl$$5 = new v9240(null, null, false, formals, null, null, null, v9241);
          funcDecl$$5.returnTypeAnnotation = returnType;
          funcDecl$$5.variableArgList = variableArgList;
          var v17144 = funcDecl$$5.fncFlags;
          var v21893 = TypeScript$$14.FncFlags;
          var v17145 = v21893.Signature;
          funcDecl$$5.fncFlags = v17144 | v17145;
          if (isConstructorMember) {
            var v17146 = funcDecl$$5.fncFlags;
            var v21894 = TypeScript$$14.FncFlags;
            var v17147 = v21894.ConstructMember;
            funcDecl$$5.fncFlags = v17146 | v17147;
            funcDecl$$5.hint = "_construct";
            funcDecl$$5.classDecl = null;
          }
          funcDecl$$5.minChar = minChar$$10;
          return this.parseTypeReferenceTail(errorRecoverySet$$8, minChar$$10, funcDecl$$5);
        default:
          this.reportParseError("Expected type name");
          var v9242 = TypeScript$$14.TypeReference;
          var etr = new v9242(null, 0);
          var v17148 = etr.flags;
          var v21895 = TypeScript$$14.ASTFlags;
          var v17149 = v21895.Error;
          etr.flags = v17148 | v17149;
          var v9243 = this.scanner;
          etr.minChar = v9243.pos;
          var v9244 = this.scanner;
          etr.limChar = v9244.pos;
          return etr;
      }
      return;
    }
    function v552(errorRecoverySet$$7, minChar$$9, term$$2, tail) {
      var v9246 = this.scanner;
      var v27284 = v9246.scan();
      this.currentToken = v27284;
      var v21896 = this.currentToken;
      var v17150 = v21896.tokenId;
      var v21897 = TypeScript$$14.TokenID;
      var v17151 = v21897.Dot;
      var v9263 = v17150 == v17151;
      if (v9263) {
        var v9247 = this.scanner;
        var curpos = v9247.pos;
        var v9248 = this.scanner;
        var v27285 = v9248.scan();
        this.currentToken = v27285;
        var v24449 = this.currentToken;
        var v21898 = v24449.tokenId;
        var v24450 = TypeScript$$14.TokenID;
        var v21899 = v24450.Identifier;
        var v17152 = v21898 == v21899;
        var v21901 = !v17152;
        if (v21901) {
          var v25678 = this.errorRecovery;
          var v24451 = !v25678;
          var v25680 = !v24451;
          if (v25680) {
            var v26264 = this.scanner;
            var v25679 = v26264.lastTokenHadNewline();
            v24451 = !v25679;
          }
          var v21900 = v24451;
          if (v21900) {
            var v24452 = this.currentToken;
            var v24453 = this.strictMode;
            v21900 = TypeScript$$14.convertTokToID(v24452, v24453);
          }
          v17152 = v21900;
        }
        var v9262 = v17152;
        if (v9262) {
          var v9249 = TypeScript$$14.Identifier;
          var v9250 = this.currentToken;
          var op2 = v9249.fromToken(v9250);
          var v9251 = this.scanner;
          op2.minChar = v9251.startPos;
          var v9252 = this.scanner;
          op2.limChar = v9252.pos;
          var v9253 = TypeScript$$14.BinaryExpression;
          var v17153 = TypeScript$$14.NodeType;
          var v9254 = v17153.Dot;
          var dotNode$$1 = new v9253(v9254, term$$2, op2);
          dotNode$$1.minChar = term$$2.minChar;
          dotNode$$1.limChar = op2.limChar;
          return this.parseNamedType(errorRecoverySet$$7, minChar$$9, dotNode$$1, tail);
        } else {
          this.reportParseError("need identifier after '.'");
          var v9261 = this.errorRecovery;
          if (v9261) {
            var v17154 = term$$2.flags;
            var v21902 = TypeScript$$14.ASTFlags;
            var v17155 = v21902.DotLHS;
            term$$2.flags = v17154 | v17155;
            var v9255 = term$$2;
            var v17156 = this.scanner;
            var v27286 = v17156.lastTokenLimChar();
            v9255.limChar = v27286;
            return term$$2;
          } else {
            var v9256 = TypeScript$$14.MissingIdentifier;
            var eop2 = new v9256;
            var v9257 = this.scanner;
            eop2.minChar = v9257.pos;
            var v9258 = this.scanner;
            eop2.limChar = v9258.pos;
            var v9259 = TypeScript$$14.BinaryExpression;
            var v17157 = TypeScript$$14.NodeType;
            var v9260 = v17157.Dot;
            var edotNode = new v9259(v9260, term$$2, eop2);
            var v17158 = edotNode.flags;
            var v21903 = TypeScript$$14.ASTFlags;
            var v17159 = v21903.Error;
            edotNode.flags = v17158 | v17159;
            edotNode.minChar = term$$2.minChar;
            edotNode.limChar = eop2.limChar;
            return this.parseNamedType(errorRecoverySet$$7, minChar$$9, edotNode, tail);
          }
        }
      } else {
        if (tail) {
          return this.parseTypeReferenceTail(errorRecoverySet$$7, minChar$$9, term$$2);
        } else {
          return term$$2;
        }
      }
      return;
    }
    function v551(errorRecoverySet$$6, minChar$$8, term$$1) {
      var v9264 = TypeScript$$14.TypeReference;
      var result$$8 = new v9264(term$$1, 0);
      result$$8.minChar = minChar$$8;
      var v21904 = this.currentToken;
      var v17160 = v21904.tokenId;
      var v21905 = TypeScript$$14.TokenID;
      var v17161 = v21905.OpenBracket;
      var v9268 = v17160 == v17161;
      for (;v9268;) {
        var v9265 = this.scanner;
        var v27287 = v9265.scan();
        this.currentToken = v27287;
        var v17162 = result$$8.arrayCount;
        result$$8.arrayCount = v17162 + 1;
        var v17163 = TypeScript$$14.TokenID;
        var v9266 = v17163.CloseBracket;
        var v21906 = TypeScript$$14.ErrorRecoverySet;
        var v17164 = v21906.LBrack;
        var v9267 = errorRecoverySet$$6 | v17164;
        this.checkCurrentToken(v9266, v9267);
        var v21907 = this.currentToken;
        var v17165 = v21907.tokenId;
        var v21908 = TypeScript$$14.TokenID;
        var v17166 = v21908.OpenBracket;
        v9268 = v17165 == v17166;
      }
      var v9269 = result$$8;
      var v17167 = this.scanner;
      var v27288 = v17167.lastTokenLimChar();
      v9269.limChar = v27288;
      return result$$8;
    }
    function v550(errorRecoverySet$$5, modifiers$$2, preComments$$1) {
      var v9270 = this.scanner;
      var leftCurlyCount$$1 = v9270.leftCurlyCount;
      var v9271 = this.scanner;
      var rightCurlyCount$$1 = v9271.rightCurlyCount;
      var svAmbient = this.ambientModule;
      var svTopLevel = this.topLevel;
      this.topLevel = false;
      var v21909 = this.parsingDeclareFile;
      var v24454 = !v21909;
      if (v24454) {
        v21909 = svAmbient;
      }
      var v17168 = v21909;
      var v21911 = !v17168;
      if (v21911) {
        var v24455 = TypeScript$$14.Modifiers;
        var v21910 = v24455.Ambient;
        v17168 = TypeScript$$14.hasFlag(modifiers$$2, v21910);
      }
      var v9272 = v17168;
      if (v9272) {
        this.ambientModule = true;
      }
      var v9273 = this.scanner;
      var v27289 = v9273.scan();
      this.currentToken = v27289;
      var name$$46 = null;
      var enclosedList$$1 = null;
      this.pushDeclLists();
      var v9274 = this.scanner;
      var minChar$$7 = v9274.startPos;
      var isDynamicMod$$1 = false;
      var v25681 = this.currentToken;
      var v24456 = v25681.tokenId;
      var v25682 = TypeScript$$14.TokenID;
      var v24457 = v25682.Identifier;
      var v21912 = v24456 == v24457;
      var v24460 = !v21912;
      if (v24460) {
        var v25683 = this.currentToken;
        var v24458 = v25683.tokenId;
        var v25684 = TypeScript$$14.TokenID;
        var v24459 = v25684.StringLiteral;
        v21912 = v24458 == v24459;
      }
      var v17169 = v21912;
      var v21914 = !v17169;
      if (v21914) {
        var v25685 = this.currentToken;
        var v24461 = TypeScript$$14.isPrimitiveTypeToken(v25685);
        var v21913 = !v24461;
        if (v21913) {
          var v24462 = this.currentToken;
          var v24463 = this.strictMode;
          v21913 = TypeScript$$14.convertTokToID(v24462, v24463);
        }
        v17169 = v21913;
      }
      var v9286 = v17169;
      if (v9286) {
        var v9275 = this.currentToken;
        var nameText = v9275.getText();
        var v21915 = this.currentToken;
        var v17170 = v21915.tokenId;
        var v21916 = TypeScript$$14.TokenID;
        var v17171 = v21916.StringLiteral;
        var v9278 = v17170 == v17171;
        if (v9278) {
          isDynamicMod$$1 = true;
          var v17172 = this.ambientModule;
          var v9276 = !v17172;
          if (v9276) {
            this.reportParseError("Only ambient dynamic modules may have string literal names");
          }
          var v9277 = !svTopLevel;
          if (v9277) {
            this.reportParseError("Dynamic modules may not be nested within other modules");
          }
        }
        var v9279 = TypeScript$$14.Identifier;
        var v9280 = this.currentToken;
        name$$46 = v9279.fromToken(v9280);
        var v9281 = this.scanner;
        name$$46.minChar = v9281.startPos;
        var v9282 = this.scanner;
        name$$46.limChar = v9282.pos;
        var v9283 = this.scanner;
        var v27290 = v9283.scan();
        this.currentToken = v27290;
      } else {
        var v21917 = this.currentToken;
        var v17173 = v21917.tokenId;
        var v21918 = TypeScript$$14.TokenID;
        var v17174 = v21918.OpenBrace;
        var v9285 = v17173 == v17174;
        if (v9285) {
          this.reportParseError("Module name missing");
          var v9284 = TypeScript$$14.Identifier;
          name$$46 = new v9284("");
          name$$46.minChar = minChar$$7;
          name$$46.limChar = minChar$$7;
        }
      }
      var v21919 = this.currentToken;
      var v17175 = v21919.tokenId;
      var v21920 = TypeScript$$14.TokenID;
      var v17176 = v21920.Dot;
      var v9287 = v17175 == v17176;
      if (v9287) {
        enclosedList$$1 = new Array;
        this.parseDottedName(enclosedList$$1);
      }
      var v9289 = name$$46 == null;
      if (v9289) {
        var v9288 = TypeScript$$14.MissingIdentifier;
        name$$46 = new v9288;
      }
      var v9290 = TypeScript$$14.ASTList;
      var moduleBody = new v9290;
      var v9291 = this.scanner;
      var bodyMinChar = v9291.startPos;
      var v17177 = TypeScript$$14.TokenID;
      var v9292 = v17177.OpenBrace;
      var v21921 = TypeScript$$14.ErrorRecoverySet;
      var v17178 = v21921.ID;
      var v9293 = errorRecoverySet$$5 | v17178;
      this.checkCurrentToken(v9292, v9293);
      var v9294 = svTopLevel && isDynamicMod$$1;
      if (v9294) {
        this.allowImportDeclaration = true;
      } else {
        this.allowImportDeclaration = false;
      }
      var v21922 = TypeScript$$14.ErrorRecoverySet;
      var v17179 = v21922.RCurly;
      var v9295 = errorRecoverySet$$5 | v17179;
      var v17180 = TypeScript$$14.AllowedElements;
      var v9296 = v17180.Global;
      this.parseStatementList(v9295, moduleBody, true, true, v9296, modifiers$$2);
      moduleBody.minChar = bodyMinChar;
      var v9297 = this.scanner;
      moduleBody.limChar = v9297.pos;
      var v9298 = TypeScript$$14.ASTSpan;
      var endingToken$$2 = new v9298;
      var v9299 = this.scanner;
      endingToken$$2.minChar = v9299.startPos;
      var v9300 = this.scanner;
      endingToken$$2.limChar = v9300.pos;
      var v17181 = TypeScript$$14.TokenID;
      var v9301 = v17181.CloseBrace;
      this.checkCurrentToken(v9301, errorRecoverySet$$5);
      var v9302 = this.scanner;
      var limChar$$5 = v9302.lastTokenLimChar();
      var moduleDecl$$3;
      this.allowImportDeclaration = svTopLevel;
      var v17182 = enclosedList$$1;
      if (v17182) {
        var v21923 = enclosedList$$1.length;
        v17182 = v21923 > 0;
      }
      var v9321 = v17182;
      if (v9321) {
        var len$$16 = enclosedList$$1.length;
        var v9303 = len$$16 - 1;
        var innerName = enclosedList$$1[v9303];
        var v9304 = TypeScript$$14.ModuleDeclaration;
        var v9305 = this.topVarList();
        var v9306 = this.topScopeList();
        var innerDecl = new v9304(innerName, moduleBody, v9305, v9306, endingToken$$2);
        innerDecl.preComments = preComments$$1;
        var v17183 = this.parsingDeclareFile;
        var v21925 = !v17183;
        if (v21925) {
          var v24464 = TypeScript$$14.Modifiers;
          var v21924 = v24464.Ambient;
          v17183 = TypeScript$$14.hasFlag(modifiers$$2, v21924);
        }
        var v9307 = v17183;
        if (v9307) {
          var v17184 = innerDecl.modFlags;
          var v21926 = TypeScript$$14.ModuleFlags;
          var v17185 = v21926.Ambient;
          innerDecl.modFlags = v17184 | v17185;
        }
        var v17186 = innerDecl.modFlags;
        var v21927 = TypeScript$$14.ModuleFlags;
        var v17187 = v21927.Exported;
        innerDecl.modFlags = v17186 | v17187;
        innerDecl.minChar = minChar$$7;
        innerDecl.limChar = limChar$$5;
        this.popDeclLists();
        var outerModBod;
        var i$$50 = len$$16 - 2;
        var v9313 = i$$50 >= 0;
        for (;v9313;) {
          var v9308 = TypeScript$$14.ASTList;
          outerModBod = new v9308;
          outerModBod.append(innerDecl);
          innerName = enclosedList$$1[i$$50];
          var v9309 = TypeScript$$14.ModuleDeclaration;
          var v17188 = TypeScript$$14.ASTList;
          var v9310 = new v17188;
          var v17189 = TypeScript$$14.ASTList;
          var v9311 = new v17189;
          innerDecl = new v9309(innerName, outerModBod, v9310, v9311, endingToken$$2);
          outerModBod.minChar = innerDecl.minChar = minChar$$7;
          outerModBod.limChar = innerDecl.limChar = limChar$$5;
          var v17190 = this.parsingDeclareFile;
          var v21929 = !v17190;
          if (v21929) {
            var v24465 = TypeScript$$14.Modifiers;
            var v21928 = v24465.Ambient;
            v17190 = TypeScript$$14.hasFlag(modifiers$$2, v21928);
          }
          var v9312 = v17190;
          if (v9312) {
            var v17191 = innerDecl.modFlags;
            var v21930 = TypeScript$$14.ModuleFlags;
            var v17192 = v21930.Ambient;
            innerDecl.modFlags = v17191 | v17192;
          }
          var v17193 = innerDecl.modFlags;
          var v21931 = TypeScript$$14.ModuleFlags;
          var v17194 = v21931.Exported;
          innerDecl.modFlags = v17193 | v17194;
          i$$50 = i$$50 - 1;
          v9313 = i$$50 >= 0;
        }
        var v9314 = TypeScript$$14.ASTList;
        outerModBod = new v9314;
        outerModBod.append(innerDecl);
        outerModBod.minChar = minChar$$7;
        outerModBod.limChar = limChar$$5;
        var v9315 = TypeScript$$14.ModuleDeclaration;
        var v17195 = TypeScript$$14.ASTList;
        var v9316 = new v17195;
        var v17196 = TypeScript$$14.ASTList;
        var v9317 = new v17196;
        moduleDecl$$3 = new v9315(name$$46, outerModBod, v9316, v9317, endingToken$$2);
      } else {
        var v9318 = TypeScript$$14.ModuleDeclaration;
        var v9319 = this.topVarList();
        var v9320 = this.topScopeList();
        moduleDecl$$3 = new v9318(name$$46, moduleBody, v9319, v9320, endingToken$$2);
        moduleDecl$$3.preComments = preComments$$1;
        this.popDeclLists();
      }
      var v21932 = this.parsingDeclareFile;
      var v24466 = !v21932;
      if (v24466) {
        v21932 = svAmbient;
      }
      var v17197 = v21932;
      var v21934 = !v17197;
      if (v21934) {
        var v24467 = TypeScript$$14.Modifiers;
        var v21933 = v24467.Ambient;
        v17197 = TypeScript$$14.hasFlag(modifiers$$2, v21933);
      }
      var v9322 = v17197;
      if (v9322) {
        var v17198 = moduleDecl$$3.modFlags;
        var v21935 = TypeScript$$14.ModuleFlags;
        var v17199 = v21935.Ambient;
        moduleDecl$$3.modFlags = v17198 | v17199;
      }
      var v17200 = svAmbient;
      var v21937 = !v17200;
      if (v21937) {
        var v24468 = TypeScript$$14.Modifiers;
        var v21936 = v24468.Exported;
        v17200 = TypeScript$$14.hasFlag(modifiers$$2, v21936);
      }
      var v9323 = v17200;
      if (v9323) {
        var v17201 = moduleDecl$$3.modFlags;
        var v21938 = TypeScript$$14.ModuleFlags;
        var v17202 = v21938.Exported;
        moduleDecl$$3.modFlags = v17201 | v17202;
      }
      if (isDynamicMod$$1) {
        var v17203 = moduleDecl$$3.modFlags;
        var v21939 = TypeScript$$14.ModuleFlags;
        var v17204 = v21939.IsDynamic;
        moduleDecl$$3.modFlags = v17203 | v17204;
      }
      this.ambientModule = svAmbient;
      this.topLevel = svTopLevel;
      var v17205 = this.scanner;
      var v9324 = v17205.leftCurlyCount;
      moduleDecl$$3.leftCurlyCount = v9324 - leftCurlyCount$$1;
      var v17206 = this.scanner;
      var v9325 = v17206.rightCurlyCount;
      moduleDecl$$3.rightCurlyCount = v9325 - rightCurlyCount$$1;
      moduleDecl$$3.limChar = moduleBody.limChar;
      return moduleDecl$$3;
    }
    function v549(errorRecoverySet$$4, modifiers$$1) {
      var name$$45 = null;
      var alias$$1 = null;
      var importDecl = null;
      var v9326 = this.scanner;
      var minChar$$6 = v9326.startPos;
      var isDynamicImport = false;
      var v9327 = this.scanner;
      var v27291 = v9327.scan();
      this.currentToken = v27291;
      var v24469 = this.currentToken;
      var v21940 = v24469.tokenId;
      var v24470 = TypeScript$$14.TokenID;
      var v21941 = v24470.Identifier;
      var v17207 = v21940 == v21941;
      var v21944 = !v17207;
      if (v21944) {
        var v21942 = this.currentToken;
        var v21943 = this.strictMode;
        v17207 = TypeScript$$14.convertTokToID(v21942, v21943);
      }
      var v9331 = v17207;
      if (v9331) {
        var v9328 = TypeScript$$14.Identifier;
        var v9329 = this.currentToken;
        name$$45 = v9328.fromToken(v9329);
      } else {
        this.reportParseError("Expected identifer after 'import'");
        var v9330 = TypeScript$$14.MissingIdentifier;
        name$$45 = new v9330;
      }
      var v9332 = this.scanner;
      name$$45.minChar = v9332.startPos;
      var v9333 = this.scanner;
      name$$45.limChar = v9333.pos;
      var v9334 = this.scanner;
      var v27292 = v9334.scan();
      this.currentToken = v27292;
      var v17208 = TypeScript$$14.TokenID;
      var v9335 = v17208.Equals;
      var v21945 = TypeScript$$14.ErrorRecoverySet;
      var v17209 = v21945.ID;
      var v9336 = errorRecoverySet$$4 | v17209;
      this.checkCurrentToken(v9335, v9336);
      var aliasPreComments = this.parseComments();
      var limChar$$4;
      var v24471 = this.currentToken;
      var v21946 = v24471.tokenId;
      var v24472 = TypeScript$$14.TokenID;
      var v21947 = v24472.Identifier;
      var v17210 = v21946 == v21947;
      var v21950 = !v17210;
      if (v21950) {
        var v21948 = this.currentToken;
        var v21949 = this.strictMode;
        v17210 = TypeScript$$14.convertTokToID(v21948, v21949);
      }
      var v9370 = v17210;
      if (v9370) {
        var v21951 = this.currentToken;
        var v17211 = v21951.tokenId;
        var v21952 = TypeScript$$14.TokenID;
        var v17212 = v21952.Module;
        var v9363 = v17211 == v17212;
        if (v9363) {
          var v9337 = this.scanner;
          limChar$$4 = v9337.pos;
          var v9338 = this.scanner;
          var v27293 = v9338.scan();
          this.currentToken = v27293;
          var v21953 = this.currentToken;
          var v17213 = v21953.tokenId;
          var v21954 = TypeScript$$14.TokenID;
          var v17214 = v21954.OpenParen;
          var v9358 = v17213 == v17214;
          if (v9358) {
            var v9339 = this.scanner;
            var v27294 = v9339.scan();
            this.currentToken = v27294;
            var v25686 = this.currentToken;
            var v24473 = v25686.tokenId;
            var v25687 = TypeScript$$14.TokenID;
            var v24474 = v25687.StringLiteral;
            var v21955 = v24473 == v24474;
            var v24477 = !v21955;
            if (v24477) {
              var v25688 = this.currentToken;
              var v24475 = v25688.tokenId;
              var v25689 = TypeScript$$14.TokenID;
              var v24476 = v25689.Identifier;
              v21955 = v24475 == v24476;
            }
            var v17215 = v21955;
            var v21958 = !v17215;
            if (v21958) {
              var v21956 = this.currentToken;
              var v21957 = this.strictMode;
              v17215 = TypeScript$$14.convertTokToID(v21956, v21957);
            }
            var v9353 = v17215;
            if (v9353) {
              var v21959 = this.currentToken;
              var v17216 = v21959.tokenId;
              var v21960 = TypeScript$$14.TokenID;
              var v17217 = v21960.StringLiteral;
              var v9352 = v17216 == v17217;
              if (v9352) {
                var v9341 = this.topLevel;
                if (v9341) {
                  this.hasTopLevelImportOrExport = true;
                } else {
                  var v17218 = this.allowImportDeclaration;
                  var v9340 = !v17218;
                  if (v9340) {
                    this.reportParseError("Import declaration of external module is permitted only in global or top level dynamic modules");
                  }
                }
                var v9342 = this.currentToken;
                var aliasText = v9342.getText();
                var v9343 = TypeScript$$14.Identifier;
                var v9344 = this.currentToken;
                alias$$1 = v9343.fromToken(v9344);
                var v9345 = this.scanner;
                alias$$1.minChar = v9345.startPos;
                var v9346 = this.scanner;
                alias$$1.limChar = v9346.pos;
                var v21961 = alias$$1.text;
                var v17219 = this.isValidImportPath(v21961);
                var v9347 = !v17219;
                if (v9347) {
                  this.reportParseError("Invalid import path");
                }
                isDynamicImport = true;
                var v9348 = this.scanner;
                var v27295 = v9348.scan();
                this.currentToken = v27295;
                alias$$1.preComments = aliasPreComments;
              } else {
                var v21962 = TypeScript$$14.ErrorRecoverySet;
                var v17220 = v21962.SColon;
                var v9349 = errorRecoverySet$$4 | v17220;
                var v17221 = TypeScript$$14.OperatorPrecedence;
                var v9350 = v17221.Assignment;
                var v9351 = TypeContext.NoTypes;
                alias$$1 = this.parseExpr(v9349, v9350, true, v9351);
                alias$$1.preComments = aliasPreComments;
              }
            }
            var v9354 = this.scanner;
            limChar$$4 = v9354.pos;
            var v17222 = TypeScript$$14.TokenID;
            var v9355 = v17222.CloseParen;
            var v21963 = TypeScript$$14.ErrorRecoverySet;
            var v17223 = v21963.ID;
            var v9356 = errorRecoverySet$$4 | v17223;
            this.checkCurrentToken(v9355, v9356);
            if (alias$$1) {
              var v9357 = alias$$1;
              var v27296 = this.parseComments();
              v9357.postComments = v27296;
            }
          }
        } else {
          var v21964 = TypeScript$$14.ErrorRecoverySet;
          var v17224 = v21964.SColon;
          var v9359 = errorRecoverySet$$4 | v17224;
          var v17225 = TypeScript$$14.OperatorPrecedence;
          var v9360 = v17225.Assignment;
          var v9361 = TypeContext.NoTypes;
          alias$$1 = this.parseExpr(v9359, v9360, true, v9361);
          var v9362 = this.scanner;
          limChar$$4 = v9362.pos;
        }
      } else {
        this.reportParseError("Expected module name");
        var v9364 = TypeScript$$14.MissingIdentifier;
        alias$$1 = new v9364;
        var v9365 = this.scanner;
        alias$$1.minChar = v9365.startPos;
        var v21965 = this.currentToken;
        var v17226 = v21965.tokenId;
        var v21966 = TypeScript$$14.TokenID;
        var v17227 = v21966.Semicolon;
        var v9369 = v17226 == v17227;
        if (v9369) {
          var v9366 = this.scanner;
          alias$$1.limChar = v9366.startPos;
        } else {
          var v9367 = this.scanner;
          alias$$1.limChar = v9367.pos;
          var v9368 = this.scanner;
          var v27297 = v9368.scan();
          this.currentToken = v27297;
        }
        var v17228 = alias$$1.flags;
        var v21967 = TypeScript$$14.ASTFlags;
        var v17229 = v21967.Error;
        alias$$1.flags = v17228 | v17229;
        limChar$$4 = alias$$1.limChar;
      }
      var v9371 = TypeScript$$14.ImportDeclaration;
      importDecl = new v9371(name$$45, alias$$1);
      importDecl.isDynamicImport = isDynamicImport;
      importDecl.minChar = minChar$$6;
      importDecl.limChar = limChar$$4;
      return importDecl;
    }
    function v548(importPath) {
      importPath = TypeScript$$14.stripQuotes(importPath);
      var v24478 = !importPath;
      var v25691 = !v24478;
      if (v25691) {
        var v25690 = importPath.indexOf(":");
        v24478 = v25690 != -1;
      }
      var v21968 = v24478;
      var v24480 = !v21968;
      if (v24480) {
        var v24479 = importPath.indexOf("\\");
        v21968 = v24479 != -1;
      }
      var v17230 = v21968;
      var v21970 = !v17230;
      if (v21970) {
        var v21969 = importPath.charAt(0);
        v17230 = v21969 == "/";
      }
      var v9372 = v17230;
      if (v9372) {
        return false;
      }
      return true;
    }
    function v547(enclosedList) {
      var v9373 = this.scanner;
      var v27298 = v9373.scan();
      this.currentToken = v27298;
      var v24481 = this.currentToken;
      var v21971 = v24481.tokenId;
      var v24482 = TypeScript$$14.TokenID;
      var v21972 = v24482.Identifier;
      var v17231 = v21971 == v21972;
      var v21975 = !v17231;
      if (v21975) {
        var v21973 = this.currentToken;
        var v21974 = this.strictMode;
        v17231 = TypeScript$$14.convertTokToID(v21973, v21974);
      }
      var v9382 = v17231;
      if (v9382) {
        var v9374 = TypeScript$$14.Identifier;
        var v9375 = this.currentToken;
        var id$$10 = v9374.fromToken(v9375);
        var v9376 = id$$10;
        var v27299 = this.parseComments();
        v9376.preComments = v27299;
        var v9377 = enclosedList.length;
        enclosedList[v9377] = id$$10;
        var v9378 = this.scanner;
        id$$10.minChar = v9378.startPos;
        var v9379 = this.scanner;
        id$$10.limChar = v9379.pos;
        var v9380 = this.scanner;
        var v27300 = v9380.scan();
        this.currentToken = v27300;
        var v21976 = this.currentToken;
        var v17232 = v21976.tokenId;
        var v21977 = TypeScript$$14.TokenID;
        var v17233 = v21977.Dot;
        var v9381 = v17232 == v17233;
        if (v9381) {
          this.parseDottedName(enclosedList);
        }
      } else {
        this.reportParseError("need identifier after '.'");
      }
      return;
    }
    function v546(errorRecoverySet$$3, modifiers) {
      var v9383 = this.scanner;
      var leftCurlyCount = v9383.leftCurlyCount;
      var v9384 = this.scanner;
      var rightCurlyCount = v9384.rightCurlyCount;
      var name$$44 = null;
      var v24483 = this.currentToken;
      var v21978 = v24483.tokenId;
      var v24484 = TypeScript$$14.TokenID;
      var v21979 = v24484.Identifier;
      var v17234 = v21978 == v21979;
      var v21982 = !v17234;
      if (v21982) {
        var v21980 = this.currentToken;
        var v21981 = this.strictMode;
        v17234 = TypeScript$$14.convertTokToID(v21980, v21981);
      }
      var v9394 = v17234;
      if (v9394) {
        var v9385 = TypeScript$$14.Identifier;
        var v9386 = this.currentToken;
        name$$44 = v9385.fromToken(v9386);
        var v9387 = this.scanner;
        name$$44.minChar = v9387.startPos;
        var v9388 = this.scanner;
        name$$44.limChar = v9388.pos;
        var v9389 = this.scanner;
        var v27301 = v9389.scan();
        this.currentToken = v27301;
      } else {
        this.reportParseError("Enum declaration requires identifier");
        var v9393 = this.errorRecovery;
        if (v9393) {
          var v9390 = TypeScript$$14.MissingIdentifier;
          name$$44 = new v9390;
          var v9391 = this.scanner;
          name$$44.minChar = v9391.startPos;
          var v9392 = this.scanner;
          name$$44.limChar = v9392.startPos;
          var v17235 = name$$44.flags;
          var v21983 = TypeScript$$14.ASTFlags;
          var v17236 = v21983.Error;
          name$$44.flags = v17235 | v17236;
        }
      }
      var v9395 = this.scanner;
      var membersMinChar = v9395.startPos;
      var v17237 = TypeScript$$14.TokenID;
      var v9396 = v17237.OpenBrace;
      var v21984 = TypeScript$$14.ErrorRecoverySet;
      var v17238 = v21984.ID;
      var v9397 = errorRecoverySet$$3 | v17238;
      this.checkCurrentToken(v9396, v9397);
      this.pushDeclLists();
      var v9398 = TypeScript$$14.ASTList;
      var members$$7 = new v9398;
      members$$7.minChar = membersMinChar;
      var v9399 = TypeScript$$14.VarDecl;
      var v17239 = TypeScript$$14.Identifier;
      var v9400 = new v17239("_map");
      var mapDecl = new v9399(v9400, 0);
      var v17240 = mapDecl.varFlags;
      var v21985 = TypeScript$$14.VarFlags;
      var v17241 = v21985.Exported;
      mapDecl.varFlags = v17240 | v17241;
      var v17242 = mapDecl.varFlags;
      var v21986 = TypeScript$$14.VarFlags;
      var v17243 = v21986.Private;
      mapDecl.varFlags = v17242 | v17243;
      var v17244 = mapDecl.varFlags;
      var v24485 = TypeScript$$14.VarFlags;
      var v21987 = v24485.Property;
      var v24486 = TypeScript$$14.VarFlags;
      var v21988 = v24486.Public;
      var v17245 = v21987 | v21988;
      mapDecl.varFlags = v17244 | v17245;
      var v9401 = mapDecl;
      var v17246 = TypeScript$$14.UnaryExpression;
      var v21989 = TypeScript$$14.NodeType;
      var v17247 = v21989.ArrayLit;
      var v27302 = new v17246(v17247, null);
      v9401.init = v27302;
      members$$7.append(mapDecl);
      var lastValue = null;
      for (;;) {
        var v9402 = this.scanner;
        var minChar$$5 = v9402.startPos;
        var limChar$$3;
        var memberName = null;
        var memberValue = null;
        var preComments = null;
        var postComments = null;
        var v24487 = this.currentToken;
        var v21990 = v24487.tokenId;
        var v24488 = TypeScript$$14.TokenID;
        var v21991 = v24488.Identifier;
        var v17248 = v21990 == v21991;
        var v21993 = !v17248;
        if (v21993) {
          var v21992 = this.currentToken;
          v17248 = TypeScript$$14.convertTokToIDName(v21992);
        }
        var v9412 = v17248;
        if (v9412) {
          var v9403 = TypeScript$$14.Identifier;
          var v9404 = this.currentToken;
          memberName = v9403.fromToken(v9404);
          var v9405 = this.scanner;
          memberName.minChar = v9405.startPos;
          var v9406 = this.scanner;
          memberName.limChar = v9406.pos;
        } else {
          var v21994 = this.currentToken;
          var v17249 = v21994.tokenId;
          var v21995 = TypeScript$$14.TokenID;
          var v17250 = v21995.CloseBrace;
          var v9411 = v17249 == v17250;
          if (v9411) {
            break;
          } else {
            this.reportParseError("Expected identifer of enum member");
            var v9410 = this.errorRecovery;
            if (v9410) {
              var v9407 = TypeScript$$14.MissingIdentifier;
              memberName = new v9407;
              var v9408 = this.scanner;
              memberName.minChar = v9408.startPos;
              var v9409 = this.scanner;
              memberName.limChar = v9409.startPos;
              var v17251 = memberName.flags;
              var v21996 = TypeScript$$14.ASTFlags;
              var v17252 = v21996.Error;
              memberName.flags = v17251 | v17252;
            }
          }
        }
        var v9413 = this.scanner;
        limChar$$3 = v9413.pos;
        preComments = this.parseComments();
        var v9414 = this.scanner;
        var v27303 = v9414.scan();
        this.currentToken = v27303;
        postComments = this.parseComments();
        var v21997 = this.currentToken;
        var v17253 = v21997.tokenId;
        var v21998 = TypeScript$$14.TokenID;
        var v17254 = v21998.Equals;
        var v9426 = v17253 == v17254;
        if (v9426) {
          var v9415 = this.scanner;
          var v27304 = v9415.scan();
          this.currentToken = v27304;
          var v17255 = TypeScript$$14.OperatorPrecedence;
          var v9416 = v17255.Comma;
          var v9417 = TypeContext.NoTypes;
          memberValue = this.parseExpr(errorRecoverySet$$3, v9416, true, v9417);
          lastValue = memberValue;
          limChar$$3 = memberValue.limChar;
        } else {
          var v9421 = lastValue == null;
          if (v9421) {
            var v9418 = TypeScript$$14.NumberLiteral;
            memberValue = new v9418(0);
            lastValue = memberValue;
          } else {
            var v9419 = TypeScript$$14.NumberLiteral;
            var v17256 = lastValue.value;
            var v9420 = v17256 + 1;
            memberValue = new v9419(v9420);
            lastValue = memberValue;
          }
          var v9422 = TypeScript$$14.BinaryExpression;
          var v17257 = TypeScript$$14.NodeType;
          var v9423 = v17257.Asg;
          var v17258 = TypeScript$$14.BinaryExpression;
          var v21999 = TypeScript$$14.NodeType;
          var v17259 = v21999.Index;
          var v22000 = TypeScript$$14.Identifier;
          var v17260 = new v22000("_map");
          var v9424 = new v17258(v17259, v17260, memberValue);
          var v17261 = TypeScript$$14.StringLiteral;
          var v24489 = memberName.actualText;
          var v22001 = '"' + v24489;
          var v17262 = v22001 + '"';
          var v9425 = new v17261(v17262);
          var map = new v9422(v9423, v9424, v9425);
          members$$7.append(map);
        }
        var v9427 = TypeScript$$14.VarDecl;
        var v9428 = this.nestingLevel;
        var member$$1 = new v9427(memberName, v9428);
        member$$1.minChar = minChar$$5;
        member$$1.limChar = limChar$$3;
        member$$1.init = memberValue;
        var v9429 = member$$1;
        var v17263 = TypeScript$$14.TypeReference;
        var v22002 = name$$44.actualText;
        var v22003 = name$$44.hasEscapeSequence;
        var v17264 = this.createRef(v22002, v22003, -1);
        var v27305 = new v17263(v17264, 0);
        v9429.typeExpr = v27305;
        var v17265 = member$$1.varFlags;
        var v24490 = TypeScript$$14.VarFlags;
        var v22004 = v24490.Readonly;
        var v24491 = TypeScript$$14.VarFlags;
        var v22005 = v24491.Property;
        var v17266 = v22004 | v22005;
        member$$1.varFlags = v17265 | v17266;
        var v17267 = memberValue.nodeType;
        var v22006 = TypeScript$$14.NodeType;
        var v17268 = v22006.NumberLit;
        var v9430 = v17267 == v17268;
        if (v9430) {
          var v17269 = member$$1.varFlags;
          var v22007 = TypeScript$$14.VarFlags;
          var v17270 = v22007.Constant;
          member$$1.varFlags = v17269 | v17270;
        }
        member$$1.preComments = preComments;
        members$$7.append(member$$1);
        member$$1.postComments = postComments;
        var v17271 = member$$1.varFlags;
        var v22008 = TypeScript$$14.VarFlags;
        var v17272 = v22008.Exported;
        member$$1.varFlags = v17271 | v17272;
        var v22009 = this.currentToken;
        var v17273 = v22009.tokenId;
        var v22010 = TypeScript$$14.TokenID;
        var v17274 = v22010.Comma;
        var v9434 = v17273 == v17274;
        if (v9434) {
          var v9431 = this.scanner;
          var v27306 = v9431.scan();
          this.currentToken = v27306;
          var v9432 = member$$1;
          var v17275 = member$$1.postComments;
          var v24492 = this.scanner;
          var v22011 = v24492.prevLine;
          var v17276 = this.parseCommentsForLine(v22011);
          var v27307 = this.combineComments(v17275, v17276);
          v9432.postComments = v27307;
          var v24493 = this.currentToken;
          var v22012 = v24493.tokenId;
          var v24494 = TypeScript$$14.TokenID;
          var v22013 = v24494.Identifier;
          var v17277 = v22012 == v22013;
          var v22015 = !v17277;
          if (v22015) {
            var v22014 = this.currentToken;
            v17277 = TypeScript$$14.convertTokToIDName(v22014);
          }
          var v9433 = v17277;
          if (v9433) {
            continue;
          }
        }
        break;
      }
      var v9435 = TypeScript$$14.ASTSpan;
      var endingToken$$1 = new v9435;
      var v9436 = this.scanner;
      endingToken$$1.minChar = v9436.startPos;
      var v9437 = this.scanner;
      endingToken$$1.limChar = v9437.pos;
      var v17278 = TypeScript$$14.TokenID;
      var v9438 = v17278.CloseBrace;
      this.checkCurrentToken(v9438, errorRecoverySet$$3);
      var v9439 = members$$7;
      var v17279 = this.scanner;
      var v27308 = v17279.lastTokenLimChar();
      v9439.limChar = v27308;
      var v9440 = TypeScript$$14.ModuleDeclaration;
      var v9441 = this.topVarList();
      var v9442 = this.topScopeList();
      var modDecl = new v9440(name$$44, members$$7, v9441, v9442, endingToken$$1);
      var v17280 = modDecl.modFlags;
      var v22016 = TypeScript$$14.ModuleFlags;
      var v17281 = v22016.IsEnum;
      modDecl.modFlags = v17280 | v17281;
      this.popDeclLists();
      var v17282 = this.scanner;
      var v9443 = v17282.leftCurlyCount;
      modDecl.leftCurlyCount = v9443 - leftCurlyCount;
      var v17283 = this.scanner;
      var v9444 = v17283.rightCurlyCount;
      modDecl.rightCurlyCount = v9444 - rightCurlyCount;
      return modDecl;
    }
    function v545(comment1, comment2) {
      var v9446 = comment1 == null;
      if (v9446) {
        return comment2;
      } else {
        var v9445 = comment2 == null;
        if (v9445) {
          return comment1;
        } else {
          return comment1.concat(comment2);
        }
      }
      return;
    }
    function v544(line$$4) {
      var v9447 = this.scanner;
      var comments$$7 = v9447.getCommentsForLine(line$$4);
      return this.parseCommentsInner(comments$$7);
    }
    function v543() {
      var v9448 = this.scanner;
      var comments$$6 = v9448.getComments();
      return this.parseCommentsInner(comments$$6);
    }
    function v542(comments$$5) {
      if (comments$$5) {
        var commentASTs = new Array;
        var i$$49 = 0;
        var v17284 = comments$$5.length;
        var v9450 = i$$49 < v17284;
        for (;v9450;) {
          var v17285 = comments$$5[i$$49];
          var v9449 = this.parseComment(v17285);
          commentASTs.push(v9449);
          i$$49 = i$$49 + 1;
          var v17286 = comments$$5.length;
          v9450 = i$$49 < v17286;
        }
        return commentASTs;
      } else {
        return null;
      }
      return;
    }
    function v541(comment$$2) {
      if (comment$$2) {
        var v9451 = TypeScript$$14.Comment;
        var v9452 = comment$$2.value;
        var v9453 = comment$$2.isBlock;
        var v9454 = comment$$2.endsLine;
        var c$$7 = new v9451(v9452, v9453, v9454);
        c$$7.minChar = comment$$2.startPos;
        var v9455 = comment$$2.startPos;
        var v17287 = comment$$2.value;
        var v9456 = v17287.length;
        c$$7.limChar = v9455 + v9456;
        var lineCol$$4 = {line:-1, col:-1};
        var v9457 = c$$7.minChar;
        this.getSourceLineCol(lineCol$$4, v9457);
        c$$7.minLine = lineCol$$4.line;
        var v9458 = c$$7.limChar;
        this.getSourceLineCol(lineCol$$4, v9458);
        c$$7.limLine = lineCol$$4.line;
        var v24495 = comment$$2.isBlock;
        var v22017 = !v24495;
        if (v22017) {
          var v25692 = comment$$2.value;
          var v24496 = v25692.length;
          v22017 = v24496 > 3;
        }
        var v17288 = v22017;
        if (v17288) {
          var v24497 = comment$$2.value;
          var v22018 = v24497.substring(0, 3);
          v17288 = v22018 == "///";
        }
        var v9462 = v17288;
        if (v9462) {
          var v9459 = comment$$2.value;
          var dependencyPath = TypeScript$$14.getAdditionalDependencyPath(v9459);
          if (dependencyPath) {
            var v9460 = this.amdDependencies;
            v9460.push(dependencyPath);
          }
          var v17289 = comment$$2.value;
          var v9461 = TypeScript$$14.getImplicitImport(v17289);
          if (v9461) {
            this.hasTopLevelImportOrExport = true;
          }
        }
        return c$$7;
      } else {
        return null;
      }
      return;
    }
    function v540() {
      var v9463 = this.staticsLists;
      var v22019 = this.staticsLists;
      var v17290 = v22019.length;
      var v9464 = v17290 - 1;
      return v9463[v9464];
    }
    function v539() {
      var v9465 = this.scopeLists;
      var v22020 = this.scopeLists;
      var v17291 = v22020.length;
      var v9466 = v17291 - 1;
      return v9465[v9466];
    }
    function v538() {
      var v9467 = this.varLists;
      var v22021 = this.varLists;
      var v17292 = v22021.length;
      var v9468 = v17292 - 1;
      return v9467[v9468];
    }
    function v537() {
      var v9469 = this.staticsLists;
      v9469.pop();
      var v9470 = this.varLists;
      v9470.pop();
      var v9471 = this.scopeLists;
      v9471.pop();
      return;
    }
    function v536() {
      var v9472 = this.staticsLists;
      var v17293 = TypeScript$$14.ASTList;
      var v9473 = new v17293;
      v9472.push(v9473);
      var v9474 = this.varLists;
      var v17294 = TypeScript$$14.ASTList;
      var v9475 = new v17294;
      v9474.push(v9475);
      var v9476 = this.scopeLists;
      var v17295 = TypeScript$$14.ASTList;
      var v9477 = new v17295;
      v9476.push(v9477);
      return;
    }
    function v535(tokenId$$43, errorRecoverySet$$2, errorText$$1) {
      var v17296 = typeof errorText$$1;
      var v9478 = v17296 === "undefined";
      if (v9478) {
        errorText$$1 = null;
      }
      var v22022 = this.currentToken;
      var v17297 = v22022.tokenId;
      var v9482 = v17297 != tokenId$$43;
      if (v9482) {
        var v9479;
        var v17299 = errorText$$1 == null;
        if (v17299) {
          var v25693 = TypeScript$$14.tokenTable;
          var v24498 = v25693[tokenId$$43];
          var v22023 = v24498.text;
          var v17298 = "Expected '" + v22023;
          v9479 = v17298 + "'";
        } else {
          v9479 = errorText$$1;
        }
        errorText$$1 = v9479;
        this.reportParseError(errorText$$1);
        var v9480 = this.errorRecovery;
        if (v9480) {
          this.skip(errorRecoverySet$$2);
        }
      } else {
        var v9481 = this.scanner;
        var v27309 = v9481.scan();
        this.currentToken = v27309;
      }
      return;
    }
    function v534(errorRecoverySet$$1) {
      var v22024 = TypeScript$$14.ErrorRecoverySet;
      var v17300 = v22024.EOF;
      errorRecoverySet$$1 = errorRecoverySet$$1 | v17300;
      var v9483 = TypeScript$$14.ErrorRecoverySet;
      var ersTok = v9483.None;
      var v17301 = this.currentToken;
      var v9484 = v17301.tokenId;
      var tokenInfo = TypeScript$$14.lookupToken(v9484);
      var v9485 = tokenInfo != undefined;
      if (v9485) {
        ersTok = tokenInfo.ers;
      }
      var pendingRightCurlies = 0;
      var v22025 = ersTok & errorRecoverySet$$1;
      var v24499 = TypeScript$$14.ErrorRecoverySet;
      var v22026 = v24499.None;
      var v17302 = v22025 == v22026;
      var v22028 = !v17302;
      if (v22028) {
        var v25694 = this.currentToken;
        var v24500 = v25694.tokenId;
        var v25695 = TypeScript$$14.TokenID;
        var v24501 = v25695.CloseBrace;
        var v22027 = v24500 == v24501;
        if (v22027) {
          v22027 = pendingRightCurlies > 0;
        }
        v17302 = v22027;
      }
      var v9492 = v17302;
      for (;v9492;) {
        var v22029 = this.currentToken;
        var v17303 = v22029.tokenId;
        var v22030 = TypeScript$$14.TokenID;
        var v17304 = v22030.OpenBrace;
        var v9487 = v17303 == v17304;
        if (v9487) {
          pendingRightCurlies = pendingRightCurlies + 1;
        } else {
          var v22031 = this.currentToken;
          var v17305 = v22031.tokenId;
          var v22032 = TypeScript$$14.TokenID;
          var v17306 = v22032.CloseBrace;
          var v9486 = v17305 == v17306;
          if (v9486) {
            pendingRightCurlies = pendingRightCurlies - 1;
          }
        }
        var v9488 = this.scanner;
        var v27310 = v9488.scan();
        this.currentToken = v27310;
        var v9489 = TypeScript$$14.ErrorRecoverySet;
        ersTok = v9489.None;
        var v17307 = this.currentToken;
        var v9490 = v17307.tokenId;
        tokenInfo = TypeScript$$14.lookupToken(v9490);
        var v9491 = tokenInfo != undefined;
        if (v9491) {
          ersTok = tokenInfo.ers;
        }
        var v22033 = ersTok & errorRecoverySet$$1;
        var v24502 = TypeScript$$14.ErrorRecoverySet;
        var v22034 = v24502.None;
        var v17308 = v22033 == v22034;
        var v22036 = !v17308;
        if (v22036) {
          var v25696 = this.currentToken;
          var v24503 = v25696.tokenId;
          var v25697 = TypeScript$$14.TokenID;
          var v24504 = v25697.CloseBrace;
          var v22035 = v24503 == v24504;
          if (v22035) {
            v22035 = pendingRightCurlies > 0;
          }
          v17308 = v22035;
        }
        v9492 = v17308;
      }
      return;
    }
    function v533(tokenId$$42, errorRecoverySet, errorText) {
      var v17309 = typeof errorText;
      var v9493 = v17309 === "undefined";
      if (v9493) {
        errorText = null;
      }
      var v9494 = this.scanner;
      var v27311 = v9494.scan();
      this.currentToken = v27311;
      this.checkCurrentToken(tokenId$$42, errorRecoverySet, errorText);
      return;
    }
    function v532(message$$14, startPos, pos$$1) {
      var v17310 = typeof startPos;
      var v9496 = v17310 === "undefined";
      if (v9496) {
        var v9495 = this.scanner;
        startPos = v9495.startPos;
      }
      var v17311 = typeof pos$$1;
      var v9498 = v17311 === "undefined";
      if (v9498) {
        var v9497 = this.scanner;
        pos$$1 = v9497.pos;
      }
      var v9499 = pos$$1 - startPos;
      var len$$15 = Math.max(1, v9499);
      var v9506 = this.errorCallback;
      if (v9506) {
        var v9500 = this.currentUnitIndex;
        this.errorCallback(startPos, len$$15, message$$14, v9500);
      } else {
        var v9505 = this.errorRecovery;
        if (v9505) {
          var lineCol$$3 = {line:-1, col:-1};
          this.getSourceLineCol(lineCol$$3, startPos);
          var v9503 = this.outfile;
          if (v9503) {
            var v9501 = this.outfile;
            var v26644 = this.fname;
            var v26523 = "// " + v26644;
            var v26265 = v26523 + " (";
            var v26266 = lineCol$$3.line;
            var v25698 = v26265 + v26266;
            var v24505 = v25698 + ",";
            var v24506 = lineCol$$3.col;
            var v22037 = v24505 + v24506;
            var v17312 = v22037 + "): ";
            var v9502 = v17312 + message$$14;
            v9501.WriteLine(v9502);
          }
        } else {
          var v26524 = this.fname;
          var v26267 = v26524 + " (";
          var v26525 = this.scanner;
          var v26268 = v26525.line;
          var v25699 = v26267 + v26268;
          var v24507 = v25699 + ",";
          var v25700 = this.scanner;
          var v24508 = v25700.col;
          var v22038 = v24507 + v24508;
          var v17313 = v22038 + "): ";
          var v9504 = v17313 + message$$14;
          throw new SyntaxError(v9504);
        }
      }
      return;
    }
    function v531(message$$13) {
      var v9507 = "STYLE: " + message$$13;
      this.reportParseError(v9507);
      return;
    }
    function v530(text$$13, hasEscapeSequence$$2, minChar$$4) {
      var v9508 = TypeScript$$14.Identifier;
      var id$$9 = new v9508(text$$13, hasEscapeSequence$$2);
      id$$9.minChar = minChar$$4;
      return id$$9;
    }
    function v529(lineCol$$2, minChar$$3) {
      var v17314 = this.scanner;
      var v9509 = v17314.lineMap;
      TypeScript$$14.getSourceLineColFromMap(lineCol$$2, minChar$$3, v9509);
      return;
    }
    function v528(outfile$$3) {
      this.outfile = outfile$$3;
      this.errorRecovery = true;
      return;
    }
    function v527(jump) {
      var v9510 = TypeScript$$14.AST;
      var v9511 = jump.target;
      var resolvedTarget = v9510.getResolvedIdentifierName(v9511);
      var v9512 = this.statementInfoStack;
      var len$$14 = v9512.length;
      var i$$48 = len$$14 - 1;
      var v9525 = i$$48 >= 0;
      for (;v9525;) {
        var v9513 = this.statementInfoStack;
        var info$$1 = v9513[i$$48];
        var v9524 = jump.target;
        if (v9524) {
          var v17315 = info$$1.labels;
          if (v17315) {
            var v25701 = info$$1.labels;
            var v24509 = v25701.members;
            var v22039 = v24509.length;
            v17315 = v22039 > 0;
          }
          var v9519 = v17315;
          if (v9519) {
            var j$$5 = 0;
            var v17316 = info$$1.labels;
            var v9514 = v17316.members;
            var labLen = v9514.length;
            var v9518 = j$$5 < labLen;
            for (;v9518;) {
              var v17317 = info$$1.labels;
              var v9515 = v17317.members;
              var label = v9515[j$$5];
              var v22040 = label.id;
              var v17318 = v22040.text;
              var v9517 = v17318 == resolvedTarget;
              if (v9517) {
                var v9516 = info$$1.stmt;
                jump.setResolvedTarget(this, v9516);
                return;
              }
              j$$5 = j$$5 + 1;
              v9518 = j$$5 < labLen;
            }
          }
        } else {
          var v17319 = info$$1.stmt;
          var v9523 = v17319.isLoop();
          if (v9523) {
            var v9520 = info$$1.stmt;
            jump.setResolvedTarget(this, v9520);
            return;
          } else {
            var v24510 = info$$1.stmt;
            var v22041 = v24510.nodeType;
            var v24511 = TypeScript$$14.NodeType;
            var v22042 = v24511.Switch;
            var v17320 = v22041 == v22042;
            if (v17320) {
              var v22043 = jump.nodeType;
              var v24512 = TypeScript$$14.NodeType;
              var v22044 = v24512.Break;
              v17320 = v22043 == v22044;
            }
            var v9522 = v17320;
            if (v9522) {
              var v9521 = info$$1.stmt;
              jump.setResolvedTarget(this, v9521);
              return;
            }
          }
        }
        i$$48 = i$$48 - 1;
        v9525 = i$$48 >= 0;
      }
      var v9528 = jump.target;
      if (v9528) {
        var v17321 = jump.target;
        var v9526 = "could not find enclosing statement with label " + v17321;
        this.reportParseError(v9526);
      } else {
        var v17322 = jump.nodeType;
        var v22045 = TypeScript$$14.NodeType;
        var v17323 = v22045.Break;
        var v9527 = v17322 == v17323;
        if (v9527) {
          this.reportParseError("break statement requires enclosing loop or switch");
        } else {
          this.reportParseError("continue statement requires enclosing loop");
        }
      }
      return;
    }
    function v526() {
      var v9529 = this.statementInfoStack;
      return v9529.pop();
    }
    function v525(stmt$$3, labels$$1) {
      var info = {stmt:stmt$$3, labels:labels$$1};
      var v9530 = this.statementInfoStack;
      v9530.push(info);
      return;
    }
    function v524() {
      var v17324 = this.statementInfoStack;
      var v9531 = v17324.length;
      var j$$4 = v9531 - 1;
      var v9533 = j$$4 >= 0;
      for (;v9533;) {
        var v24513 = this.statementInfoStack;
        var v22046 = v24513[j$$4];
        var v17325 = v22046.stmt;
        var v9532 = v17325.isLoop();
        if (v9532) {
          return true;
        }
        j$$4 = j$$4 - 1;
        v9533 = j$$4 >= 0;
      }
      return false;
    }
    function v523() {
      var v27312 = new Array;
      this.statementInfoStack = v27312;
      return;
    }
    function Parser$$1() {
      this.varLists = [];
      this.scopeLists = [];
      this.staticsLists = [];
      var v9534 = TypeScript$$14.Scanner;
      var v27313 = new v9534;
      this.scanner = v27313;
      this.currentToken = null;
      this.needTerminator = false;
      this.inFunction = false;
      this.inInterfaceDecl = false;
      this.currentClassDecl = null;
      this.inFncDecl = false;
      var v9535 = TypeScript$$14.Identifier;
      var v27314 = new v9535("_anonymous");
      this.anonId = v27314;
      this.style_requireSemi = false;
      this.style_funcInLoop = true;
      this.incremental = false;
      this.errorRecovery = false;
      this.outfile = undefined;
      this.errorCallback = null;
      this.state = ParseState.StartStatementList;
      this.ambientModule = false;
      this.ambientClass = false;
      this.topLevel = true;
      this.allowImportDeclaration = true;
      this.currentUnitIndex = -1;
      this.prevIDTok = null;
      var v27315 = new Array;
      this.statementInfoStack = v27315;
      this.hasTopLevelImportOrExport = false;
      this.strictMode = false;
      this.nestingLevel = 0;
      this.prevExpr = null;
      this.currentClassDefinition = null;
      this.parsingClassConstructorDefinition = false;
      this.parsingDeclareFile = false;
      this.amdDependencies = [];
      this.inferPropertiesFromThisAssignment = false;
      this.requiresExtendsBlock = false;
      this.fname = "";
      return;
    }
    var v9536 = Parser$$1.prototype;
    v9536.resetStmtStack = v523;
    var v9537 = Parser$$1.prototype;
    v9537.inLoop = v524;
    var v9538 = Parser$$1.prototype;
    v9538.pushStmt = v525;
    var v9539 = Parser$$1.prototype;
    v9539.popStmt = v526;
    var v9540 = Parser$$1.prototype;
    v9540.resolveJumpTarget = v527;
    var v9541 = Parser$$1.prototype;
    v9541.setErrorRecovery = v528;
    var v9542 = Parser$$1.prototype;
    v9542.getSourceLineCol = v529;
    var v9543 = Parser$$1.prototype;
    v9543.createRef = v530;
    var v9544 = Parser$$1.prototype;
    v9544.reportParseStyleError = v531;
    var v9545 = Parser$$1.prototype;
    v9545.reportParseError = v532;
    var v9546 = Parser$$1.prototype;
    v9546.checkNextToken = v533;
    var v9547 = Parser$$1.prototype;
    v9547.skip = v534;
    var v9548 = Parser$$1.prototype;
    v9548.checkCurrentToken = v535;
    var v9549 = Parser$$1.prototype;
    v9549.pushDeclLists = v536;
    var v9550 = Parser$$1.prototype;
    v9550.popDeclLists = v537;
    var v9551 = Parser$$1.prototype;
    v9551.topVarList = v538;
    var v9552 = Parser$$1.prototype;
    v9552.topScopeList = v539;
    var v9553 = Parser$$1.prototype;
    v9553.topStaticsList = v540;
    var v9554 = Parser$$1.prototype;
    v9554.parseComment = v541;
    var v9555 = Parser$$1.prototype;
    v9555.parseCommentsInner = v542;
    var v9556 = Parser$$1.prototype;
    v9556.parseComments = v543;
    var v9557 = Parser$$1.prototype;
    v9557.parseCommentsForLine = v544;
    var v9558 = Parser$$1.prototype;
    v9558.combineComments = v545;
    var v9559 = Parser$$1.prototype;
    v9559.parseEnumDecl = v546;
    var v9560 = Parser$$1.prototype;
    v9560.parseDottedName = v547;
    var v9561 = Parser$$1.prototype;
    v9561.isValidImportPath = v548;
    var v9562 = Parser$$1.prototype;
    v9562.parseImportDeclaration = v549;
    var v9563 = Parser$$1.prototype;
    v9563.parseModuleDecl = v550;
    var v9564 = Parser$$1.prototype;
    v9564.parseTypeReferenceTail = v551;
    var v9565 = Parser$$1.prototype;
    v9565.parseNamedType = v552;
    var v9566 = Parser$$1.prototype;
    v9566.parseTypeReference = v553;
    var v9567 = Parser$$1.prototype;
    v9567.parseObjectType = v554;
    var v9568 = Parser$$1.prototype;
    v9568.parseFunctionBlock = v555;
    var v9569 = Parser$$1.prototype;
    v9569.parseFunctionStatements = v556;
    var v9570 = Parser$$1.prototype;
    v9570.transformAnonymousArgsIntoFormals = v557;
    var v9571 = Parser$$1.prototype;
    v9571.parseFormalParameterList = v558;
    var v9572 = Parser$$1.prototype;
    v9572.parseFncDecl = v559;
    var v9573 = Parser$$1.prototype;
    v9573.convertToTypeReference = v560;
    var v9574 = Parser$$1.prototype;
    v9574.parseArgList = v561;
    var v9575 = Parser$$1.prototype;
    v9575.parseBaseList = v562;
    var v9576 = Parser$$1.prototype;
    v9576.parseClassDecl = v563;
    var v9577 = Parser$$1.prototype;
    v9577.parseClassElements = v564;
    var v9578 = Parser$$1.prototype;
    v9578.parseClassConstructorDeclaration = v565;
    var v9579 = Parser$$1.prototype;
    v9579.parseClassMemberVariableDeclaration = v566;
    var v9580 = Parser$$1.prototype;
    v9580.parseClassMemberFunctionDeclaration = v567;
    var v9581 = Parser$$1.prototype;
    v9581.parseTypeMember = v568;
    var v9582 = Parser$$1.prototype;
    v9582.parseTypeMemberList = v569;
    var v9583 = Parser$$1.prototype;
    v9583.parseInterfaceDecl = v570;
    var v9584 = Parser$$1.prototype;
    v9584.makeVarDecl = v571;
    var v9585 = Parser$$1.prototype;
    v9585.parsePropertyDeclaration = v572;
    var v9586 = Parser$$1.prototype;
    v9586.parseVariableDeclaration = v573;
    var v9587 = Parser$$1.prototype;
    v9587.parseMemberList = v574;
    var v9588 = Parser$$1.prototype;
    v9588.parseArrayList = v575;
    var v9589 = Parser$$1.prototype;
    v9589.parseArrayLiteral = v576;
    var v9590 = Parser$$1.prototype;
    v9590.parseTerm = v577;
    var v9591 = Parser$$1.prototype;
    v9591.parseLambdaExpr = v578;
    var v9592 = Parser$$1.prototype;
    v9592.parseExpr = v579;
    var v9593 = Parser$$1.prototype;
    v9593.parsePostfixOperators = v580;
    var v9594 = Parser$$1.prototype;
    v9594.parseTry = v581;
    var v9595 = Parser$$1.prototype;
    v9595.parseCatch = v582;
    var v9596 = Parser$$1.prototype;
    v9596.parseFinally = v583;
    var v9597 = Parser$$1.prototype;
    v9597.parseTryCatchFinally = v584;
    var v9598 = Parser$$1.prototype;
    v9598.parseStatement = v585;
    var v9599 = Parser$$1.prototype;
    v9599.okAmbientModuleMember = v586;
    var v9600 = Parser$$1.prototype;
    v9600.parseStatementList = v587;
    var v9601 = Parser$$1.prototype;
    v9601.quickParse = v588;
    var v9602 = Parser$$1.prototype;
    v9602.parse = v590;
    return Parser$$1;
  }
  function v522() {
    function QuickParseResult$$1(Script$$2, endLexState) {
      this.Script = Script$$2;
      this.endLexState = endLexState;
      return;
    }
    return QuickParseResult$$1;
  }
  function v521(ParseState$$1) {
    ParseState$$1._map = [];
    var v9603 = ParseState$$1._map;
    v9603[0] = "None";
    ParseState$$1.None = 0;
    var v9604 = ParseState$$1._map;
    v9604[1] = "StartScript";
    ParseState$$1.StartScript = 1;
    var v9605 = ParseState$$1._map;
    v9605[2] = "StartStatementList";
    ParseState$$1.StartStatementList = 2;
    var v9606 = ParseState$$1._map;
    v9606[3] = "StartStatement";
    ParseState$$1.StartStatement = 3;
    var v9607 = ParseState$$1._map;
    v9607[4] = "StartFncDecl";
    ParseState$$1.StartFncDecl = 4;
    var v9608 = ParseState$$1._map;
    v9608[5] = "FncDeclName";
    ParseState$$1.FncDeclName = 5;
    var v9609 = ParseState$$1._map;
    v9609[6] = "FncDeclArgs";
    ParseState$$1.FncDeclArgs = 6;
    var v9610 = ParseState$$1._map;
    v9610[7] = "FncDeclReturnType";
    ParseState$$1.FncDeclReturnType = 7;
    var v9611 = ParseState$$1._map;
    v9611[8] = "ForInit";
    ParseState$$1.ForInit = 8;
    var v9612 = ParseState$$1._map;
    v9612[9] = "ForInitAfterVar";
    ParseState$$1.ForInitAfterVar = 9;
    var v9613 = ParseState$$1._map;
    v9613[10] = "ForCondStart";
    ParseState$$1.ForCondStart = 10;
    var v9614 = ParseState$$1._map;
    v9614[11] = "EndStmtList";
    ParseState$$1.EndStmtList = 11;
    var v9615 = ParseState$$1._map;
    v9615[12] = "EndScript";
    ParseState$$1.EndScript = 12;
    return;
  }
  function v520(TypeContext$$1) {
    TypeContext$$1._map = [];
    TypeContext$$1.NoTypes = 0;
    TypeContext$$1.ArraySuffix = 1;
    TypeContext$$1.Primitive = 2;
    TypeContext$$1.Named = 4;
    var v9616 = TypeContext$$1.Primitive;
    var v9617 = TypeContext$$1.Named;
    TypeContext$$1.AllSimpleTypes = v9616 | v9617;
    var v17326 = TypeContext$$1.Primitive;
    var v17327 = TypeContext$$1.Named;
    var v9618 = v17326 | v17327;
    var v9619 = TypeContext$$1.ArraySuffix;
    TypeContext$$1.AllTypes = v9618 | v9619;
    return;
  }
  function quickParse(logger$$1, scopeStartAST, sourceText, minChar$$2, limChar$$2, errorCapture) {
    var fragment = sourceText.getText(minChar$$2, limChar$$2);
    var v26269 = "Quick parse range (" + minChar$$2;
    var v25702 = v26269 + ",";
    var v24514 = v25702 + limChar$$2;
    var v22047 = v24514 + '): "';
    var v22048 = TypeScript$$14.stringToLiteral(fragment, 100);
    var v17328 = v22047 + v22048;
    var v9620 = v17328 + '"';
    logger$$1.log(v9620);
    var quickParser = new Parser;
    quickParser.setErrorRecovery(null);
    quickParser.errorCallback = errorCapture;
    var v9621 = TypeScript$$14.ClassDeclaration;
    var quickClassDecl = new v9621(null, null, null, null);
    quickParser.currentClassDecl = quickClassDecl;
    var v17329 = TypeScript$$14.StringSourceText;
    var v9622 = new v17329(fragment);
    var result$$7 = quickParser.quickParse(v9622, "", 0);
    return result$$7;
  }
  var v17330 = TypeScript$$14.TypeContext;
  var v22049 = !v17330;
  if (v22049) {
    v17330 = TypeScript$$14.TypeContext = {};
  }
  var v9623 = v17330;
  v520(v9623);
  var TypeContext = TypeScript$$14.TypeContext;
  var v17331 = TypeScript$$14.ParseState;
  var v22050 = !v17331;
  if (v22050) {
    v17331 = TypeScript$$14.ParseState = {};
  }
  var v9624 = v17331;
  v521(v9624);
  var ParseState = TypeScript$$14.ParseState;
  var QuickParseResult = v522();
  TypeScript$$14.QuickParseResult = QuickParseResult;
  var Parser = v591();
  TypeScript$$14.Parser = Parser;
  TypeScript$$14.quickParse = quickParse;
  return;
}
function v519(TypeScript$$13) {
  function v518() {
    function v517(ast$$36, op$$1, type$$29) {
      var v24515 = "Operator '" + op$$1;
      var v22051 = v24515 + "' cannot be applied to type '";
      var v22052 = type$$29.getTypeName();
      var v17332 = v22051 + v22052;
      var v9625 = v17332 + "'";
      this.reportError(ast$$36, v9625);
      return;
    }
    function v516(ast$$35) {
      this.simpleError(ast$$35, "Expected var, class, interface, or module");
      return;
    }
    function v515(ast$$34, t1, t2, op, scope$$8, comparisonInfo) {
      var v9627 = !t1;
      if (v9627) {
        var v9626 = this.checker;
        t1 = v9626.anyType;
      }
      var v9629 = !t2;
      if (v9629) {
        var v9628 = this.checker;
        t2 = v9628.anyType;
      }
      var v9630;
      if (comparisonInfo) {
        v9630 = comparisonInfo.message;
      } else {
        v9630 = "";
      }
      var reason = v9630;
      if (op) {
        var v26526 = "Operator '" + op;
        var v26270 = v26526 + "' cannot be applied to types '";
        var v26271 = t1.getScopedTypeName(scope$$8);
        var v25703 = v26270 + v26271;
        var v24516 = v25703 + "' and '";
        var v24517 = t2.getScopedTypeName(scope$$8);
        var v22053 = v24516 + v24517;
        var v17333 = v22053 + "'";
        var v22054;
        if (reason) {
          v22054 = ": " + reason;
        } else {
          v22054 = "";
        }
        var v17334 = v22054;
        var v9631 = v17333 + v17334;
        this.reportError(ast$$34, v9631);
      } else {
        var v26272 = t1.getScopedTypeName(scope$$8);
        var v25704 = "Cannot convert '" + v26272;
        var v24518 = v25704 + "' to '";
        var v24519 = t2.getScopedTypeName(scope$$8);
        var v22055 = v24518 + v24519;
        var v17335 = v22055 + "'";
        var v22056;
        if (reason) {
          v22056 = ": " + reason;
        } else {
          v22056 = "";
        }
        var v17336 = v22056;
        var v9632 = v17335 + v17336;
        this.reportError(ast$$34, v9632);
      }
      return;
    }
    function v514(ast$$33, scope$$7) {
      var v17337 = ast$$33.operand1;
      var v9633 = v17337.type;
      var targetType$$2 = v9633.getScopedTypeName(scope$$7);
      var v17338 = ast$$33.operand2;
      var v9634 = v17338.type;
      var indexType = v9634.getScopedTypeName(scope$$7);
      var v24520 = "Value of type '" + targetType$$2;
      var v22057 = v24520 + "' is not indexable by type '";
      var v17339 = v22057 + indexType;
      var v9635 = v17339 + "'";
      this.simpleError(ast$$33, v9635);
      return;
    }
    function v513(ast$$32, nodeType$$13, scope$$6) {
      var v9636 = ast$$32.target;
      var targetType$$1 = v9636.type;
      var typeName = targetType$$1.getScopedTypeName(scope$$6);
      var v17340 = targetType$$1.construct;
      if (v17340) {
        var v24521 = TypeScript$$13.NodeType;
        var v22058 = v24521.Call;
        v17340 = nodeType$$13 == v22058;
      }
      var v9640 = v17340;
      if (v9640) {
        var v17341 = "Value of type '" + typeName;
        var v9637 = v17341 + "' is not callable.  Did you mean to include 'new'?";
        this.reportError(ast$$32, v9637);
      } else {
        var v9638;
        var v24522 = TypeScript$$13.NodeType;
        var v22059 = v24522.Call;
        var v17342 = nodeType$$13 == v22059;
        if (v17342) {
          v9638 = "callable";
        } else {
          v9638 = "newable";
        }
        var catString = v9638;
        var v22060 = "Value of type '" + typeName;
        var v17343 = v22060 + "' is not ";
        var v9639 = v17343 + catString;
        this.reportError(ast$$32, v9639);
      }
      return;
    }
    function v512(ast$$31) {
      this.simpleError(ast$$31, "The left-hand side of an assignment expression must be a variable, property or indexer");
      return;
    }
    function v511(ast$$30) {
      this.simpleError(ast$$30, "Keyword 'super' can only be used inside a class instance method");
      return;
    }
    function v510(sym$$6, msg$$3) {
      this.reportErrorFromSym(sym$$6, msg$$3);
      return;
    }
    function v509(ast$$29, msg$$2) {
      this.reportError(ast$$29, msg$$2);
      return;
    }
    function v508(ast$$28, msg$$1) {
      var bkThrow = this.pushToErrorSink;
      this.pushToErrorSink = false;
      var v9641 = "STYLE: " + msg$$1;
      this.reportError(ast$$28, v9641);
      this.pushToErrorSink = bkThrow;
      return;
    }
    function v507(ast$$27, name$$43) {
      var v17344 = "The name '" + name$$43;
      var v9642 = v17344 + "' does not refer to a value";
      this.reportError(ast$$27, v9642);
      return;
    }
    function v506(ast$$26, name$$42) {
      var v17345 = "The name '" + name$$42;
      var v9643 = v17345 + "' does not exist in the current scope";
      this.reportError(ast$$26, v9643);
      return;
    }
    function v505(ast$$25, text$$12, symbol$$5) {
      var defLineCol = {line:-1, col:-1};
      var v9644 = this.parser;
      var v9645 = symbol$$5.location;
      v9644.getSourceLineCol(defLineCol, v9645);
      var v26273 = "symbol " + text$$12;
      var v25705 = v26273 + " defined at (";
      var v25706 = defLineCol.line;
      var v24523 = v25705 + v25706;
      var v22061 = v24523 + ",";
      var v22062 = defLineCol.col;
      var v17346 = v22061 + v22062;
      var v9646 = v17346 + ")";
      this.reportError(ast$$25, v9646);
      return;
    }
    function v504(ast$$24, name$$41) {
      var v17347 = "Duplicate identifier '" + name$$41;
      var v9647 = v17347 + "'";
      this.reportError(ast$$24, v9647);
      return;
    }
    function v503(ast$$23, message$$12) {
      this.reportError(ast$$23, message$$12);
      throw Error("EmitError");
    }
    function v502(symbol$$4, message$$11) {
      var v9648 = this.pushToErrorSink;
      if (v9648) {
        this.captureError(message$$11);
        return;
      }
      this.hasErrors = true;
      var v22063 = this.parser;
      var v17348 = v22063.errorRecovery;
      if (v17348) {
        var v22064 = this.parser;
        v17348 = v22064.errorCallback;
      }
      var v9654 = v17348;
      if (v9654) {
        var v9649 = this.parser;
        var v9650 = symbol$$4.location;
        var v9651 = symbol$$4.length;
        var v22065 = this.checker;
        var v17349 = v22065.locationInfo;
        var v9652 = v17349.unitIndex;
        v9649.errorCallback(v9650, v9651, message$$11, v9652);
      } else {
        this.writePrefixFromSym(symbol$$4);
        var v9653 = this.outfile;
        v9653.WriteLine(message$$11);
      }
      return;
    }
    function v501(ast$$22, message$$10) {
      var v9655 = this.pushToErrorSink;
      if (v9655) {
        this.captureError(message$$10);
        return;
      }
      this.hasErrors = true;
      var v22066 = ast$$22;
      if (v22066) {
        var v24524 = this.parser;
        v22066 = v24524.errorRecovery;
      }
      var v17350 = v22066;
      if (v17350) {
        var v22067 = this.parser;
        v17350 = v22067.errorCallback;
      }
      var v9662 = v17350;
      if (v9662) {
        var v9656 = ast$$22.limChar;
        var v9657 = ast$$22.minChar;
        var len$$13 = v9656 - v9657;
        var v9658 = this.parser;
        var v9659 = ast$$22.minChar;
        var v22068 = this.checker;
        var v17351 = v22068.locationInfo;
        var v9660 = v17351.unitIndex;
        v9658.errorCallback(v9659, len$$13, message$$10, v9660);
      } else {
        this.writePrefix(ast$$22);
        var v9661 = this.outfile;
        v9661.WriteLine(message$$10);
      }
      return;
    }
    function v500(ast$$21) {
      if (ast$$21) {
        var v17352 = ast$$21.flags;
        var v22069 = TypeScript$$13.ASTFlags;
        var v17353 = v22069.Error;
        ast$$21.flags = v17352 | v17353;
        var v22070 = this.checker;
        var v17354 = v22070.locationInfo;
        var v9666 = v17354.lineMap;
        if (v9666) {
          var v9663 = this.lineCol;
          var v9664 = ast$$21.minChar;
          var v22071 = this.checker;
          var v17355 = v22071.locationInfo;
          var v9665 = v17355.lineMap;
          TypeScript$$13.getSourceLineColFromMap(v9663, v9664, v9665);
        }
      }
      return;
    }
    function v499(symbol$$3) {
      var v17356 = symbol$$3;
      if (v17356) {
        var v24525 = this.checker;
        var v22072 = v24525.locationInfo;
        v17356 = v22072.lineMap;
      }
      var v9672 = v17356;
      if (v9672) {
        var v9667 = this.lineCol;
        var v9668 = symbol$$3.location;
        var v22073 = this.checker;
        var v17357 = v22073.locationInfo;
        var v9669 = v17357.lineMap;
        TypeScript$$13.getSourceLineColFromMap(v9667, v9668, v9669);
      } else {
        var v9670 = this.lineCol;
        v9670.line = -1;
        var v9671 = this.lineCol;
        v9671.col = -1;
      }
      this.emitPrefix();
      return;
    }
    function v498(ast$$20) {
      if (ast$$20) {
        this.setError(ast$$20);
      } else {
        var v9673 = this.lineCol;
        v9673.line = 0;
        var v9674 = this.lineCol;
        v9674.col = 0;
      }
      this.emitPrefix();
      return;
    }
    function v497() {
      var v9676 = this.emitAsComments;
      if (v9676) {
        var v9675 = this.outfile;
        v9675.Write("// ");
      }
      var v9677 = this.outfile;
      var v26645 = this.checker;
      var v26527 = v26645.locationInfo;
      var v26274 = v26527.filename;
      var v25707 = v26274 + "(";
      var v26275 = this.lineCol;
      var v25708 = v26275.line;
      var v24526 = v25707 + v25708;
      var v22074 = v24526 + ",";
      var v24527 = this.lineCol;
      var v22075 = v24527.col;
      var v17358 = v22074 + v22075;
      var v9678 = v17358 + "): ";
      v9677.Write(v9678);
      return;
    }
    function v496(outerr$$1) {
      this.outfile = outerr$$1;
      this.emitAsComments = false;
      return;
    }
    function v495(emsg) {
      var v9679 = this.errorSink;
      var v17359 = this.errorSink;
      var v9680 = v17359.length;
      v9679[v9680] = emsg;
      return;
    }
    function v494() {
      this.errorSink = [];
      return;
    }
    function v493() {
      return this.errorSink;
    }
    function ErrorReporter$$1(outfile$$2) {
      this.outfile = outfile$$2;
      this.parser = null;
      this.checker = null;
      this.lineCol = {line:0, col:0};
      this.emitAsComments = true;
      this.hasErrors = false;
      this.pushToErrorSink = false;
      this.errorSink = [];
      return;
    }
    var v9681 = ErrorReporter$$1.prototype;
    v9681.getCapturedErrors = v493;
    var v9682 = ErrorReporter$$1.prototype;
    v9682.freeCapturedErrors = v494;
    var v9683 = ErrorReporter$$1.prototype;
    v9683.captureError = v495;
    var v9684 = ErrorReporter$$1.prototype;
    v9684.setErrOut = v496;
    var v9685 = ErrorReporter$$1.prototype;
    v9685.emitPrefix = v497;
    var v9686 = ErrorReporter$$1.prototype;
    v9686.writePrefix = v498;
    var v9687 = ErrorReporter$$1.prototype;
    v9687.writePrefixFromSym = v499;
    var v9688 = ErrorReporter$$1.prototype;
    v9688.setError = v500;
    var v9689 = ErrorReporter$$1.prototype;
    v9689.reportError = v501;
    var v9690 = ErrorReporter$$1.prototype;
    v9690.reportErrorFromSym = v502;
    var v9691 = ErrorReporter$$1.prototype;
    v9691.emitterError = v503;
    var v9692 = ErrorReporter$$1.prototype;
    v9692.duplicateIdentifier = v504;
    var v9693 = ErrorReporter$$1.prototype;
    v9693.showRef = v505;
    var v9694 = ErrorReporter$$1.prototype;
    v9694.unresolvedSymbol = v506;
    var v9695 = ErrorReporter$$1.prototype;
    v9695.symbolDoesNotReferToAValue = v507;
    var v9696 = ErrorReporter$$1.prototype;
    v9696.styleError = v508;
    var v9697 = ErrorReporter$$1.prototype;
    v9697.simpleError = v509;
    var v9698 = ErrorReporter$$1.prototype;
    v9698.simpleErrorFromSym = v510;
    var v9699 = ErrorReporter$$1.prototype;
    v9699.invalidSuperReference = v511;
    var v9700 = ErrorReporter$$1.prototype;
    v9700.valueCannotBeModified = v512;
    var v9701 = ErrorReporter$$1.prototype;
    v9701.invalidCall = v513;
    var v9702 = ErrorReporter$$1.prototype;
    v9702.indexLHS = v514;
    var v9703 = ErrorReporter$$1.prototype;
    v9703.incompatibleTypes = v515;
    var v9704 = ErrorReporter$$1.prototype;
    v9704.expectedClassOrInterface = v516;
    var v9705 = ErrorReporter$$1.prototype;
    v9705.unaryOperatorTypeError = v517;
    return ErrorReporter$$1;
  }
  var ErrorReporter = v518();
  TypeScript$$13.ErrorReporter = ErrorReporter;
  return;
}
function v492(TypeScript$$12) {
  function v491() {
    function v490(fileName$$2, useUTF8) {
      try {
        var v17360 = this.emitOptions;
        var v9706 = v17360.ioHost;
        return v9706.createFile(fileName$$2, useUTF8);
      } catch (ex$$2) {
        var v9707 = this.errorReporter;
        var v9708 = ex$$2.message;
        v9707.emitterError(null, v9708);
      }
      return;
    }
    function shouldCaptureThis(func$$3) {
      var v9709 = func$$3.hasSelfReference();
      var v17361 = !v9709;
      if (v17361) {
        v9709 = func$$3.hasSuperReferenceInFatArrowFunction();
      }
      return v9709;
    }
    function v489() {
      var v22076 = this.thisFnc;
      if (v22076) {
        var v25709 = this.thisFnc;
        var v24528 = v25709.isMethod();
        v22076 = !v24528;
      }
      var v17362 = v22076;
      if (v17362) {
        var v24529 = this.thisFnc;
        var v22077 = v24529.isConstructor;
        v17362 = !v22077;
      }
      var v9710 = v17362;
      if (v9710) {
        this.writeToOutput("_this");
      } else {
        this.writeToOutput("this");
      }
      return;
    }
    function v488(callEx) {
      var v22078 = callEx.target;
      var v17363 = v22078.nodeType;
      var v22079 = TypeScript$$12.NodeType;
      var v17364 = v22079.Dot;
      var v9716 = v17363 == v17364;
      if (v9716) {
        var dotNode = callEx.target;
        var v22080 = dotNode.operand1;
        var v17365 = v22080.nodeType;
        var v22081 = TypeScript$$12.NodeType;
        var v17366 = v22081.Super;
        var v9715 = v17365 == v17366;
        if (v9715) {
          var v17367 = TypeScript$$12.TokenID;
          var v9711 = v17367.OpenParen;
          this.emitJavascript(dotNode, v9711, false);
          this.writeToOutput(".call(");
          this.emitThis();
          var v17368 = callEx.arguments;
          if (v17368) {
            var v25710 = callEx.arguments;
            var v24530 = v25710.members;
            var v22082 = v24530.length;
            v17368 = v22082 > 0;
          }
          var v9714 = v17368;
          if (v9714) {
            this.writeToOutput(", ");
            var v9712 = callEx.arguments;
            var v17369 = TypeScript$$12.TokenID;
            var v9713 = v17369.Comma;
            this.emitJavascriptList(v9712, ", ", v9713, false, false, false);
          }
          this.writeToOutput(")");
          return true;
        }
      }
      return false;
    }
    function v487() {
      this.writeToOutput("_super.prototype");
      return;
    }
    function v486(reqInherits) {
      var v17370 = this.prologueEmitted;
      var v9719 = !v17370;
      if (v9719) {
        if (reqInherits) {
          this.prologueEmitted = true;
          this.writeLineToOutput("var __extends = this.__extends || function (d, b) {");
          this.writeLineToOutput("    function __() { this.constructor = d; }");
          this.writeLineToOutput("    __.prototype = b.prototype;");
          this.writeLineToOutput("    d.prototype = new __();");
          this.writeLineToOutput("};");
        }
        var v17371 = this.checker;
        var v9718 = v17371.mustCaptureGlobalThis;
        if (v9718) {
          this.prologueEmitted = true;
          var v9717 = this.captureThisStmtString;
          this.writeLineToOutput(v9717);
        }
      }
      return;
    }
    function v485(classDecl$$3) {
      var v22083 = classDecl$$3.varFlags;
      var v24531 = TypeScript$$12.VarFlags;
      var v22084 = v24531.Ambient;
      var v17372 = TypeScript$$12.hasFlag(v22083, v22084);
      var v9769 = !v17372;
      if (v9769) {
        var svClassNode = this.thisClassNode;
        var i$$47 = 0;
        this.thisClassNode = classDecl$$3;
        var v9720 = classDecl$$3.name;
        var className$$3 = v9720.actualText;
        this.emitParensAndCommentsInPlace(classDecl$$3, true);
        var v9721 = EmitContainer.Class;
        var temp$$13 = this.setContainer(v9721);
        this.recordSourceMappingStart(classDecl$$3);
        var v22085 = classDecl$$3.varFlags;
        var v24532 = TypeScript$$12.VarFlags;
        var v22086 = v24532.Exported;
        var v17373 = TypeScript$$12.hasFlag(v22085, v22086);
        if (v17373) {
          var v25711 = classDecl$$3.type;
          var v24533 = v25711.symbol;
          var v22087 = v24533.container;
          var v24534 = this.checker;
          var v22088 = v24534.gloMod;
          v17373 = v22087 == v22088;
        }
        var v9724 = v17373;
        if (v9724) {
          var v9722 = "this." + className$$3;
          this.writeToOutput(v9722);
        } else {
          var v9723 = "var " + className$$3;
          this.writeToOutput(v9723);
        }
        var v9725 = classDecl$$3.extendsList;
        if (v9725) {
          var v22089 = classDecl$$3.extendsList;
          var v17374 = v22089.members;
          v9725 = v17374.length;
        }
        var hasBaseClass = v9725;
        var baseNameDecl = null;
        var baseName$$2 = null;
        if (hasBaseClass) {
          this.writeLineToOutput(" = (function (_super) {");
        } else {
          this.writeLineToOutput(" = (function () {");
        }
        this.recordSourceMappingNameStart(className$$3);
        var v9726 = this.indenter;
        v9726.increaseIndent();
        if (hasBaseClass) {
          var v17375 = classDecl$$3.extendsList;
          var v9727 = v17375.members;
          baseNameDecl = v9727[0];
          var v9728;
          var v22090 = baseNameDecl.nodeType;
          var v24535 = TypeScript$$12.NodeType;
          var v22091 = v24535.Call;
          var v17376 = v22090 == v22091;
          if (v17376) {
            v9728 = baseNameDecl.target;
          } else {
            v9728 = baseNameDecl;
          }
          baseName$$2 = v9728;
          this.emitIndent();
          var v17377 = "__extends(" + className$$3;
          var v9729 = v17377 + ", _super);";
          this.writeLineToOutput(v9729);
        }
        this.emitIndent();
        var constrDecl = classDecl$$3.constructorDecl;
        if (constrDecl) {
          var v9730 = classDecl$$3.constructorDecl;
          var v17378 = TypeScript$$12.TokenID;
          var v9731 = v17378.OpenParen;
          this.emitJavascript(v9730, v9731, false);
        } else {
          var wroteProps = 0;
          this.recordSourceMappingStart(classDecl$$3);
          var v9732 = this.indenter;
          v9732.increaseIndent();
          var v24536 = classDecl$$3.name;
          var v22092 = v24536.actualText;
          var v17379 = "function " + v22092;
          var v9733 = v17379 + "() {";
          this.writeToOutput(v9733);
          this.recordSourceMappingNameStart("constructor");
          if (hasBaseClass) {
            this.writeLineToOutput("");
            this.emitIndent();
            this.writeLineToOutput("_super.apply(this, arguments);");
            wroteProps = wroteProps + 1;
          }
          var v17380 = classDecl$$3.varFlags;
          var v22093 = TypeScript$$12.VarFlags;
          var v17381 = v22093.MustCaptureThis;
          var v9734 = v17380 & v17381;
          if (v9734) {
            this.writeCaptureThisStatement(classDecl$$3);
          }
          var v17382 = this.thisClassNode;
          var v9735 = v17382.members;
          var members$$6 = v9735.members;
          i$$47 = 0;
          var v17383 = members$$6.length;
          var v9739 = i$$47 < v17383;
          for (;v9739;) {
            var v22094 = members$$6[i$$47];
            var v17384 = v22094.nodeType;
            var v22095 = TypeScript$$12.NodeType;
            var v17385 = v22095.VarDecl;
            var v9738 = v17384 == v17385;
            if (v9738) {
              var varDecl$$5 = members$$6[i$$47];
              var v24537 = varDecl$$5.varFlags;
              var v25712 = TypeScript$$12.VarFlags;
              var v24538 = v25712.Static;
              var v22096 = TypeScript$$12.hasFlag(v24537, v24538);
              var v17386 = !v22096;
              if (v17386) {
                v17386 = varDecl$$5.init;
              }
              var v9737 = v17386;
              if (v9737) {
                this.writeLineToOutput("");
                this.emitIndent();
                var v17387 = TypeScript$$12.TokenID;
                var v9736 = v17387.Tilde;
                this.emitJavascriptVarDecl(varDecl$$5, v9736);
                wroteProps = wroteProps + 1;
              }
            }
            i$$47 = i$$47 + 1;
            var v17388 = members$$6.length;
            v9739 = i$$47 < v17388;
          }
          if (wroteProps) {
            this.writeLineToOutput("");
            var v9740 = this.indenter;
            v9740.decreaseIndent();
            this.emitIndent();
            this.writeLineToOutput("}");
          } else {
            this.writeLineToOutput(" }");
            var v9741 = this.indenter;
            v9741.decreaseIndent();
          }
          this.recordSourceMappingNameEnd();
          this.recordSourceMappingEnd(classDecl$$3);
        }
        var v17389 = classDecl$$3.members;
        var v9742 = v17389.members;
        var membersLen = v9742.length;
        var j$$3 = 0;
        var v9758 = j$$3 < membersLen;
        for (;v9758;) {
          var v17390 = classDecl$$3.members;
          var v9743 = v17390.members;
          var memberDecl = v9743[j$$3];
          var v17391 = memberDecl.nodeType;
          var v22097 = TypeScript$$12.NodeType;
          var v17392 = v22097.FuncDecl;
          var v9757 = v17391 == v17392;
          if (v9757) {
            var fn$$6 = memberDecl;
            var v22098 = fn$$6.fncFlags;
            var v24539 = TypeScript$$12.FncFlags;
            var v22099 = v24539.Method;
            var v17393 = TypeScript$$12.hasFlag(v22098, v22099);
            if (v17393) {
              var v22100 = fn$$6.isSignature();
              v17393 = !v22100;
            }
            var v9750 = v17393;
            if (v9750) {
              var v22101 = fn$$6.fncFlags;
              var v24540 = TypeScript$$12.FncFlags;
              var v22102 = v24540.Static;
              var v17394 = TypeScript$$12.hasFlag(v22101, v22102);
              var v9749 = !v17394;
              if (v9749) {
                this.emitPrototypeMember(fn$$6, className$$3);
              } else {
                var v9748 = fn$$6.isAccessor();
                if (v9748) {
                  var v22103 = this.thisClassNode;
                  var v17395 = v22103.name;
                  var v9744 = v17395.actualText;
                  this.emitPropertyAccessor(fn$$6, v9744, false);
                } else {
                  this.emitIndent();
                  this.recordSourceMappingStart(fn$$6);
                  var v25713 = classDecl$$3.name;
                  var v24541 = v25713.actualText;
                  var v22104 = v24541 + ".";
                  var v24542 = fn$$6.name;
                  var v22105 = v24542.actualText;
                  var v17396 = v22104 + v22105;
                  var v9745 = v17396 + " = ";
                  this.writeToOutput(v9745);
                  var v17397 = fn$$6.name;
                  if (v17397) {
                    var v24543 = fn$$6.name;
                    var v22106 = v24543.isMissing();
                    v17397 = !v22106;
                  }
                  var v9746 = v17397;
                  var v9747 = Emitter$$1.shouldCaptureThis(fn$$6);
                  this.emitInnerFunction(fn$$6, v9746, true, null, v9747, null);
                  this.writeLineToOutput(";");
                }
              }
            }
          } else {
            var v17398 = memberDecl.nodeType;
            var v22107 = TypeScript$$12.NodeType;
            var v17399 = v22107.VarDecl;
            var v9756 = v17398 == v17399;
            if (v9756) {
              varDecl$$5 = memberDecl;
              var v17400 = varDecl$$5.varFlags;
              var v22108 = TypeScript$$12.VarFlags;
              var v17401 = v22108.Static;
              var v9755 = TypeScript$$12.hasFlag(v17400, v17401);
              if (v9755) {
                var v9754 = varDecl$$5.init;
                if (v9754) {
                  this.emitIndent();
                  this.recordSourceMappingStart(varDecl$$5);
                  var v25714 = classDecl$$3.name;
                  var v24544 = v25714.actualText;
                  var v22109 = v24544 + ".";
                  var v24545 = varDecl$$5.id;
                  var v22110 = v24545.actualText;
                  var v17402 = v22109 + v22110;
                  var v9751 = v17402 + " = ";
                  this.writeToOutput(v9751);
                  var v9752 = varDecl$$5.init;
                  var v17403 = TypeScript$$12.TokenID;
                  var v9753 = v17403.Equals;
                  this.emitJavascript(v9752, v9753, false);
                  this.writeLineToOutput(";");
                  this.recordSourceMappingEnd(varDecl$$5);
                }
              }
            } else {
              throw Error("We want to catch this");
            }
          }
          j$$3 = j$$3 + 1;
          v9758 = j$$3 < membersLen;
        }
        this.emitIndent();
        var v9759 = classDecl$$3.endingToken;
        this.recordSourceMappingStart(v9759);
        var v17404 = "return " + className$$3;
        var v9760 = v17404 + ";";
        this.writeLineToOutput(v9760);
        var v9761 = classDecl$$3.endingToken;
        this.recordSourceMappingEnd(v9761);
        var v9762 = this.indenter;
        v9762.decreaseIndent();
        this.emitIndent();
        var v9763 = classDecl$$3.endingToken;
        this.recordSourceMappingStart(v9763);
        this.writeToOutput("}");
        this.recordSourceMappingNameEnd();
        var v9764 = classDecl$$3.endingToken;
        this.recordSourceMappingEnd(v9764);
        this.recordSourceMappingStart(classDecl$$3);
        this.writeToOutput(")(");
        if (hasBaseClass) {
          var v17405 = TypeScript$$12.TokenID;
          var v9765 = v17405.Tilde;
          this.emitJavascript(baseName$$2, v9765, false);
        }
        this.writeToOutput(");");
        this.recordSourceMappingEnd(classDecl$$3);
        var v24546 = EmitContainer.Module;
        var v22111 = temp$$13 == v24546;
        var v24548 = !v22111;
        if (v24548) {
          var v24547 = EmitContainer.DynamicModule;
          v22111 = temp$$13 == v24547;
        }
        var v17406 = v22111;
        if (v17406) {
          var v22112 = classDecl$$3.varFlags;
          var v24549 = TypeScript$$12.VarFlags;
          var v22113 = v24549.Exported;
          v17406 = TypeScript$$12.hasFlag(v22112, v22113);
        }
        var v9768 = v17406;
        if (v9768) {
          this.writeLineToOutput("");
          this.emitIndent();
          var v9766;
          var v22114 = EmitContainer.Module;
          var v17407 = temp$$13 == v22114;
          if (v17407) {
            v9766 = this.moduleName;
          } else {
            v9766 = "exports";
          }
          var modName$$2 = v9766;
          this.recordSourceMappingStart(classDecl$$3);
          var v25715 = modName$$2 + ".";
          var v24550 = v25715 + className$$3;
          var v22115 = v24550 + " = ";
          var v17408 = v22115 + className$$3;
          var v9767 = v17408 + ";";
          this.writeToOutput(v9767);
          this.recordSourceMappingEnd(classDecl$$3);
        }
        this.emitIndent();
        this.recordSourceMappingEnd(classDecl$$3);
        this.emitParensAndCommentsInPlace(classDecl$$3, false);
        this.setContainer(temp$$13);
        this.thisClassNode = svClassNode;
      }
      return;
    }
    function v484(className$$2, base$$1, classDecl$$2) {
      function v483(key$$32, s$$13, c$$6) {
        var sym$$5 = s$$13;
        var v22116 = sym$$5.kind();
        var v24551 = TypeScript$$12.SymbolKind;
        var v22117 = v24551.Type;
        var v17409 = v22116 == v22117;
        if (v17409) {
          var v22118 = sym$$5.type;
          v17409 = v22118.call;
        }
        var v9773 = v17409;
        if (v9773) {
          var v9770 = sym$$5.declAST;
          this.recordSourceMappingStart(v9770);
          var v26528 = className$$2 + ".prototype.";
          var v26529 = sym$$5.name;
          var v26276 = v26528 + v26529;
          var v25716 = v26276 + " = ";
          var v24552 = v25716 + baseName$$1;
          var v22119 = v24552 + ".prototype.";
          var v22120 = sym$$5.name;
          var v17410 = v22119 + v22120;
          var v9771 = v17410 + ";";
          this.writeLineToOutput(v9771);
          var v9772 = sym$$5.declAST;
          this.recordSourceMappingEnd(v9772);
        }
        return;
      }
      var v9776 = base$$1.members;
      if (v9776) {
        var baseSymbol$$1 = base$$1.symbol;
        var baseName$$1 = baseSymbol$$1.name;
        var v17411 = baseSymbol$$1.declModule;
        var v24553 = classDecl$$2.type;
        var v22121 = v24553.symbol;
        var v17412 = v22121.declModule;
        var v9774 = v17411 != v17412;
        if (v9774) {
          baseName$$1 = baseSymbol$$1.fullName();
        }
        var v17413 = base$$1.members;
        var v9775 = v17413.allMembers;
        v9775.map(v483, null);
      }
      var v9780 = base$$1.extendsList;
      if (v9780) {
        var i$$46 = 0;
        var v9777 = base$$1.extendsList;
        var len$$12 = v9777.length;
        var v9779 = i$$46 < len$$12;
        for (;v9779;) {
          var v17414 = base$$1.extendsList;
          var v9778 = v17414[i$$46];
          this.emitAddBaseMethods(className$$2, v9778, classDecl$$2);
          i$$46 = i$$46 + 1;
          v9779 = i$$46 < len$$12;
        }
      }
      return;
    }
    function v482(member, className$$1) {
      var v17415 = member.nodeType;
      var v22122 = TypeScript$$12.NodeType;
      var v17416 = v22122.FuncDecl;
      var v9791 = v17415 == v17416;
      if (v9791) {
        var funcDecl$$4 = member;
        var v9783 = funcDecl$$4.isAccessor();
        if (v9783) {
          this.emitPropertyAccessor(funcDecl$$4, className$$1, true);
        } else {
          this.emitIndent();
          this.recordSourceMappingStart(funcDecl$$4);
          var v22123 = className$$1 + ".prototype.";
          var v22124 = funcDecl$$4.getNameText();
          var v17417 = v22123 + v22124;
          var v9781 = v17417 + " = ";
          this.writeToOutput(v9781);
          var v9782 = Emitter$$1.shouldCaptureThis(funcDecl$$4);
          this.emitInnerFunction(funcDecl$$4, false, true, null, v9782, null);
          this.writeLineToOutput(";");
        }
      } else {
        var v17418 = member.nodeType;
        var v22125 = TypeScript$$12.NodeType;
        var v17419 = v22125.VarDecl;
        var v9790 = v17418 == v17419;
        if (v9790) {
          var varDecl$$4 = member;
          var v9789 = varDecl$$4.init;
          if (v9789) {
            this.emitIndent();
            this.recordSourceMappingStart(varDecl$$4);
            var v9784 = varDecl$$4.id;
            this.recordSourceMappingStart(v9784);
            var v17420 = className$$1 + ".prototype.";
            var v22126 = varDecl$$4.id;
            var v17421 = v22126.actualText;
            var v9785 = v17420 + v17421;
            this.writeToOutput(v9785);
            var v9786 = varDecl$$4.id;
            this.recordSourceMappingEnd(v9786);
            this.writeToOutput(" = ");
            var v9787 = varDecl$$4.init;
            var v17422 = TypeScript$$12.TokenID;
            var v9788 = v17422.Equals;
            this.emitJavascript(v9787, v9788, false);
            this.recordSourceMappingEnd(varDecl$$4);
            this.writeLineToOutput(";");
          }
        }
      }
      return;
    }
    function v481(funcDecl$$3, className, isProto) {
      var v22127 = funcDecl$$3.accessorSymbol;
      var v17423 = v22127.hasBeenEmitted;
      var v9801 = !v17423;
      if (v9801) {
        var accessorSymbol = funcDecl$$3.accessorSymbol;
        this.emitIndent();
        this.recordSourceMappingStart(funcDecl$$3);
        var v25717 = "Object.defineProperty(" + className;
        var v26277;
        if (isProto) {
          v26277 = '.prototype, "';
        } else {
          v26277 = ', "';
        }
        var v25718 = v26277;
        var v24554 = v25717 + v25718;
        var v25719 = funcDecl$$3.name;
        var v24555 = v25719.actualText;
        var v22128 = v24554 + v24555;
        var v17424 = v22128 + '"';
        var v9792 = v17424 + ", {";
        this.writeLineToOutput(v9792);
        var v9793 = this.indenter;
        v9793.increaseIndent();
        var v9796 = accessorSymbol.getter;
        if (v9796) {
          var v9794 = accessorSymbol.getter;
          var getter = v9794.declAST;
          this.emitIndent();
          this.recordSourceMappingStart(getter);
          this.writeToOutput("get: ");
          var v9795 = Emitter$$1.shouldCaptureThis(getter);
          this.emitInnerFunction(getter, false, isProto, null, v9795, null);
          this.writeLineToOutput(",");
        }
        var v9799 = accessorSymbol.setter;
        if (v9799) {
          var v9797 = accessorSymbol.setter;
          var setter = v9797.declAST;
          this.emitIndent();
          this.recordSourceMappingStart(setter);
          this.writeToOutput("set: ");
          var v9798 = Emitter$$1.shouldCaptureThis(setter);
          this.emitInnerFunction(setter, false, isProto, null, v9798, null);
          this.writeLineToOutput(",");
        }
        this.emitIndent();
        this.writeLineToOutput("enumerable: true,");
        this.emitIndent();
        this.writeLineToOutput("configurable: true");
        var v9800 = this.indenter;
        v9800.decreaseIndent();
        this.emitIndent();
        this.writeLineToOutput("});");
        this.recordSourceMappingEnd(funcDecl$$3);
        accessorSymbol.hasBeenEmitted = true;
      }
      return;
    }
    function v480(ast$$19, tokenId$$41, startLine$$40) {
      var v9802 = ast$$19 == null;
      if (v9802) {
        return;
      }
      var v24556 = startLine$$40;
      if (v24556) {
        var v26278 = this.indenter;
        var v25720 = v26278.indentAmt;
        v24556 = v25720 > 0;
      }
      var v22129 = v24556;
      if (v22129) {
        var v24557 = ast$$19.nodeType;
        var v25721 = TypeScript$$12.NodeType;
        var v24558 = v25721.List;
        v22129 = v24557 != v24558;
      }
      var v17425 = v22129;
      if (v17425) {
        var v22130 = ast$$19.nodeType;
        var v24559 = TypeScript$$12.NodeType;
        var v22131 = v24559.Block;
        v17425 = v22130 != v22131;
      }
      var v9804 = v17425;
      if (v9804) {
        var v25722 = ast$$19.nodeType;
        var v26279 = TypeScript$$12.NodeType;
        var v25723 = v26279.InterfaceDeclaration;
        var v24560 = v25722 != v25723;
        if (v24560) {
          var v26705 = ast$$19.nodeType;
          var v26731 = TypeScript$$12.NodeType;
          var v26706 = v26731.VarDecl;
          var v26646 = v26705 == v26706;
          if (v26646) {
            var v26732 = ast$$19.varFlags;
            var v26750 = TypeScript$$12.VarFlags;
            var v26733 = v26750.Ambient;
            var v26707 = v26732 & v26733;
            var v26734 = TypeScript$$12.VarFlags;
            var v26708 = v26734.Ambient;
            v26646 = v26707 == v26708;
          }
          var v26530 = v26646;
          if (v26530) {
            var v26647 = ast$$19.init;
            v26530 = v26647 == null;
          }
          var v26280 = v26530;
          var v25724 = !v26280;
          if (v25724) {
            var v26281 = this.varListCount();
            v25724 = v26281 >= 0;
          }
          v24560 = v25724;
        }
        var v22132 = v24560;
        if (v22132) {
          var v24561 = ast$$19.nodeType;
          var v25725 = TypeScript$$12.NodeType;
          var v24562 = v25725.EndCode;
          v22132 = v24561 != v24562;
        }
        var v17426 = v22132;
        if (v17426) {
          var v24563 = ast$$19.nodeType;
          var v25726 = TypeScript$$12.NodeType;
          var v24564 = v25726.FuncDecl;
          var v22133 = v24563 != v24564;
          var v24567 = !v22133;
          if (v24567) {
            var v25727 = this.emitState;
            var v24565 = v25727.container;
            var v24566 = EmitContainer.Constructor;
            v22133 = v24565 != v24566;
          }
          v17426 = v22133;
        }
        var v9803 = v17426;
        if (v9803) {
          this.emitIndent();
        }
      }
      ast$$19.emit(this, tokenId$$41, startLine$$40);
      var v24568 = TypeScript$$12.TokenID;
      var v22134 = v24568.Semicolon;
      var v17427 = tokenId$$41 == v22134;
      if (v17427) {
        var v22135 = ast$$19.nodeType;
        var v24569 = TypeScript$$12.NodeType;
        var v22136 = v24569.GeneralNode;
        v17427 = v22135 < v22136;
      }
      var v9805 = v17427;
      if (v9805) {
        this.writeToOutput(";");
      }
      return;
    }
    function v479(ast$$18, delimiter, tokenId$$40, startLine$$39, onlyStatics, emitClassPropertiesAfterSuperCall$$1, emitPrologue, requiresExtendsBlock) {
      var v17428 = typeof emitClassPropertiesAfterSuperCall$$1;
      var v9806 = v17428 === "undefined";
      if (v9806) {
        emitClassPropertiesAfterSuperCall$$1 = false;
      }
      var v17429 = typeof emitPrologue;
      var v9807 = v17429 === "undefined";
      if (v9807) {
        emitPrologue = false;
      }
      var v9837 = ast$$18 == null;
      if (v9837) {
      } else {
        var v17430 = ast$$18.nodeType;
        var v22137 = TypeScript$$12.NodeType;
        var v17431 = v22137.List;
        var v9836 = v17430 != v17431;
        if (v9836) {
          this.emitPrologue(emitPrologue);
          this.emitJavascript(ast$$18, tokenId$$40, startLine$$39);
        } else {
          var list$$1 = ast$$18;
          var v22138 = list$$1.members;
          var v17432 = v22138.length;
          var v9808 = v17432 == 0;
          if (v9808) {
            return;
          }
          this.emitParensAndCommentsInPlace(ast$$18, true);
          var v9809 = list$$1.members;
          var len$$11 = v9809.length;
          var i$$45 = 0;
          var v9835 = i$$45 < len$$11;
          for (;v9835;) {
            if (emitPrologue) {
              var v17433 = i$$45 == 1;
              var v22140 = !v17433;
              if (v22140) {
                var v24570 = list$$1.flags;
                var v25728 = TypeScript$$12.ASTFlags;
                var v24571 = v25728.StrictMode;
                var v22139 = TypeScript$$12.hasFlag(v24570, v24571);
                v17433 = !v22139;
              }
              var v9810 = v17433;
              if (v9810) {
                this.emitPrologue(requiresExtendsBlock);
                emitPrologue = false;
              }
            }
            var v17434 = i$$45 == 1;
            if (v17434) {
              v17434 = emitClassPropertiesAfterSuperCall$$1;
            }
            var v9829 = v17434;
            if (v9829) {
              var v9811 = this.thisClassNode;
              var constructorDecl = v9811.constructorDecl;
              var v17435 = constructorDecl;
              if (v17435) {
                v17435 = constructorDecl.arguments;
              }
              var v9822 = v17435;
              if (v9822) {
                var v17436 = constructorDecl.arguments;
                var v9812 = v17436.members;
                var argsLen$$1 = v9812.length;
                var iArg = 0;
                var v9821 = iArg < argsLen$$1;
                for (;v9821;) {
                  var v17437 = constructorDecl.arguments;
                  var v9813 = v17437.members;
                  var arg$$4 = v9813[iArg];
                  var v22141 = arg$$4.varFlags;
                  var v24572 = TypeScript$$12.VarFlags;
                  var v22142 = v24572.Property;
                  var v17438 = v22141 & v22142;
                  var v22143 = TypeScript$$12.VarFlags;
                  var v17439 = v22143.None;
                  var v9820 = v17438 != v17439;
                  if (v9820) {
                    this.emitIndent();
                    this.recordSourceMappingStart(arg$$4);
                    var v9814 = arg$$4.id;
                    this.recordSourceMappingStart(v9814);
                    var v22144 = arg$$4.id;
                    var v17440 = v22144.actualText;
                    var v9815 = "this." + v17440;
                    this.writeToOutput(v9815);
                    var v9816 = arg$$4.id;
                    this.recordSourceMappingEnd(v9816);
                    this.writeToOutput(" = ");
                    var v9817 = arg$$4.id;
                    this.recordSourceMappingStart(v9817);
                    var v17441 = arg$$4.id;
                    var v9818 = v17441.actualText;
                    this.writeToOutput(v9818);
                    var v9819 = arg$$4.id;
                    this.recordSourceMappingEnd(v9819);
                    this.writeLineToOutput(";");
                    this.recordSourceMappingEnd(arg$$4);
                  }
                  iArg = iArg + 1;
                  v9821 = iArg < argsLen$$1;
                }
              }
              var v22145 = this.thisClassNode;
              var v17442 = v22145.members;
              var v9823 = v17442.members;
              var nProps$$1 = v9823.length;
              var iMember = 0;
              var v9828 = iMember < nProps$$1;
              for (;v9828;) {
                var v26282 = this.thisClassNode;
                var v25729 = v26282.members;
                var v24573 = v25729.members;
                var v22146 = v24573[iMember];
                var v17443 = v22146.nodeType;
                var v22147 = TypeScript$$12.NodeType;
                var v17444 = v22147.VarDecl;
                var v9827 = v17443 == v17444;
                if (v9827) {
                  var v22148 = this.thisClassNode;
                  var v17445 = v22148.members;
                  var v9824 = v17445.members;
                  var varDecl$$3 = v9824[iMember];
                  var v24574 = varDecl$$3.varFlags;
                  var v25730 = TypeScript$$12.VarFlags;
                  var v24575 = v25730.Static;
                  var v22149 = TypeScript$$12.hasFlag(v24574, v24575);
                  var v17446 = !v22149;
                  if (v17446) {
                    v17446 = varDecl$$3.init;
                  }
                  var v9826 = v17446;
                  if (v9826) {
                    this.emitIndent();
                    var v17447 = TypeScript$$12.TokenID;
                    var v9825 = v17447.Tilde;
                    this.emitJavascriptVarDecl(varDecl$$3, v9825);
                    this.writeLineToOutput("");
                  }
                }
                iMember = iMember + 1;
                v9828 = iMember < nProps$$1;
              }
            }
            var v9830 = list$$1.members;
            var emitNode = v9830[i$$45];
            var v22150 = emitNode.nodeType;
            var v24576 = TypeScript$$12.NodeType;
            var v22151 = v24576.FuncDecl;
            var v17448 = v22150 == v22151;
            if (v17448) {
              var v22152 = emitNode.fncFlags;
              var v24577 = TypeScript$$12.FncFlags;
              var v22153 = v24577.Static;
              v17448 = TypeScript$$12.hasFlag(v22152, v22153);
            }
            var v9831 = v17448;
            var v17450 = !v9831;
            if (v17450) {
              var v22154 = emitNode.nodeType;
              var v24578 = TypeScript$$12.NodeType;
              var v22155 = v24578.VarDecl;
              var v17449 = v22154 == v22155;
              if (v17449) {
                var v22156 = emitNode.varFlags;
                var v24579 = TypeScript$$12.VarFlags;
                var v22157 = v24579.Static;
                v17449 = TypeScript$$12.hasFlag(v22156, v22157);
              }
              v9831 = v17449;
            }
            var isStaticDecl = v9831;
            var v17451;
            if (onlyStatics) {
              v17451 = !isStaticDecl;
            } else {
              v17451 = isStaticDecl;
            }
            var v9832 = v17451;
            if (v9832) {
              i$$45 = i$$45 + 1;
              v9835 = i$$45 < len$$11;
              continue;
            }
            this.emitJavascript(emitNode, tokenId$$40, startLine$$39);
            var v17452 = delimiter;
            if (v17452) {
              var v22158 = len$$11 - 1;
              v17452 = i$$45 < v22158;
            }
            var v9834 = v17452;
            if (v9834) {
              if (startLine$$39) {
                this.writeLineToOutput(delimiter);
              } else {
                this.writeToOutput(delimiter);
              }
            } else {
              var v26531 = startLine$$39;
              if (v26531) {
                var v26648 = emitNode.nodeType;
                var v26709 = TypeScript$$12.NodeType;
                var v26649 = v26709.ModuleDeclaration;
                v26531 = v26648 != v26649;
              }
              var v26283 = v26531;
              if (v26283) {
                var v26532 = emitNode.nodeType;
                var v26650 = TypeScript$$12.NodeType;
                var v26533 = v26650.InterfaceDeclaration;
                v26283 = v26532 != v26533;
              }
              var v25731 = v26283;
              if (v25731) {
                var v26735 = emitNode.nodeType;
                var v26751 = TypeScript$$12.NodeType;
                var v26736 = v26751.VarDecl;
                var v26710 = v26735 == v26736;
                if (v26710) {
                  var v26752 = emitNode.varFlags;
                  var v26760 = TypeScript$$12.VarFlags;
                  var v26753 = v26760.Ambient;
                  var v26737 = v26752 & v26753;
                  var v26754 = TypeScript$$12.VarFlags;
                  var v26738 = v26754.Ambient;
                  v26710 = v26737 == v26738;
                }
                var v26651 = v26710;
                if (v26651) {
                  var v26711 = emitNode.init;
                  v26651 = v26711 == null;
                }
                var v26534 = v26651;
                var v26284 = !v26534;
                if (v26284) {
                  var v26535 = this.varListCount();
                  v26284 = v26535 >= 0;
                }
                v25731 = v26284;
              }
              var v24580 = v25731;
              if (v24580) {
                var v26285 = emitNode.nodeType;
                var v26536 = TypeScript$$12.NodeType;
                var v26286 = v26536.Block;
                var v25732 = v26285 != v26286;
                var v26287 = !v25732;
                if (v26287) {
                  v25732 = emitNode.isStatementBlock;
                }
                v24580 = v25732;
              }
              var v22159 = v24580;
              if (v22159) {
                var v24581 = emitNode.nodeType;
                var v25733 = TypeScript$$12.NodeType;
                var v24582 = v25733.EndCode;
                v22159 = v24581 != v24582;
              }
              var v17453 = v22159;
              if (v17453) {
                var v22160 = emitNode.nodeType;
                var v24583 = TypeScript$$12.NodeType;
                var v22161 = v24583.FuncDecl;
                v17453 = v22160 != v22161;
              }
              var v9833 = v17453;
              if (v9833) {
                this.writeLineToOutput("");
              }
            }
            i$$45 = i$$45 + 1;
            v9835 = i$$45 < len$$11;
          }
          this.emitParensAndCommentsInPlace(ast$$18, false);
        }
      }
      return;
    }
    function v478() {
      var v17454 = this.sourceMapper;
      var v9840 = v17454 != null;
      if (v9840) {
        var v9838 = TypeScript$$12.SourceMapper;
        var v9839 = this.allSourceMappers;
        v9838.EmitSourceMapping(v9839);
      }
      try {
        var v9841 = this.outfile;
        v9841.Close();
      } catch (ex$$1) {
        var v9842 = this.errorReporter;
        var v9843 = ex$$1.message;
        v9842.emitterError(null, v9843);
      }
      return;
    }
    function v477(ast$$17) {
      var v17455 = this.sourceMapper;
      if (v17455) {
        v17455 = TypeScript$$12.isValidAstNode(ast$$17);
      }
      var v9850 = v17455;
      if (v9850) {
        var v17456 = this.sourceMapper;
        var v9844 = v17456.currentMappings;
        v9844.pop();
        var v17457 = this.sourceMapper;
        var v9845 = v17457.currentMappings;
        var v24584 = this.sourceMapper;
        var v22162 = v24584.currentMappings;
        var v17458 = v22162.length;
        var v9846 = v17458 - 1;
        var siblings$$1 = v9845[v9846];
        var v17459 = siblings$$1.length;
        var v9847 = v17459 - 1;
        var sourceMapping$$2 = siblings$$1[v9847];
        var v9848 = sourceMapping$$2.end;
        var v17460 = this.emitState;
        v9848.emittedColumn = v17460.column;
        var v9849 = sourceMapping$$2.end;
        var v17461 = this.emitState;
        v9849.emittedLine = v17461.line;
      }
      return;
    }
    function v476(ast$$16) {
      var v17462 = this.sourceMapper;
      if (v17462) {
        v17462 = TypeScript$$12.isValidAstNode(ast$$16);
      }
      var v9869 = v17462;
      if (v9869) {
        var lineCol$$1 = {line:-1, col:-1};
        var v9851 = TypeScript$$12.SourceMapping;
        var sourceMapping$$1 = new v9851;
        var v9852 = sourceMapping$$1.start;
        var v17463 = this.emitState;
        v9852.emittedColumn = v17463.column;
        var v9853 = sourceMapping$$1.start;
        var v17464 = this.emitState;
        v9853.emittedLine = v17464.line;
        var v9854 = ast$$16.minChar;
        var v22163 = this.checker;
        var v17465 = v22163.locationInfo;
        var v9855 = v17465.lineMap;
        TypeScript$$12.getSourceLineColFromMap(lineCol$$1, v9854, v9855);
        var v9856 = sourceMapping$$1.start;
        v9856.sourceColumn = lineCol$$1.col;
        var v9857 = sourceMapping$$1.start;
        v9857.sourceLine = lineCol$$1.line;
        var v9858 = ast$$16.limChar;
        var v22164 = this.checker;
        var v17466 = v22164.locationInfo;
        var v9859 = v17466.lineMap;
        TypeScript$$12.getSourceLineColFromMap(lineCol$$1, v9858, v9859);
        var v9860 = sourceMapping$$1.end;
        v9860.sourceColumn = lineCol$$1.col;
        var v9861 = sourceMapping$$1.end;
        v9861.sourceLine = lineCol$$1.line;
        var v24585 = this.sourceMapper;
        var v22165 = v24585.currentNameIndex;
        var v17467 = v22165.length;
        var v9864 = v17467 > 0;
        if (v9864) {
          var v17468 = this.sourceMapper;
          var v9862 = v17468.currentNameIndex;
          var v24586 = this.sourceMapper;
          var v22166 = v24586.currentNameIndex;
          var v17469 = v22166.length;
          var v9863 = v17469 - 1;
          sourceMapping$$1.nameIndex = v9862[v9863];
        }
        var v17470 = this.sourceMapper;
        var v9865 = v17470.currentMappings;
        var v24587 = this.sourceMapper;
        var v22167 = v24587.currentMappings;
        var v17471 = v22167.length;
        var v9866 = v17471 - 1;
        var siblings = v9865[v9866];
        siblings.push(sourceMapping$$1);
        var v17472 = this.sourceMapper;
        var v9867 = v17472.currentMappings;
        var v9868 = sourceMapping$$1.childMappings;
        v9867.push(v9868);
      }
      return;
    }
    function v475() {
      var v9871 = this.sourceMapper;
      if (v9871) {
        var v17473 = this.sourceMapper;
        var v9870 = v17473.currentNameIndex;
        v9870.pop();
      }
      return;
    }
    function v474(name$$40) {
      var v9878 = this.sourceMapper;
      if (v9878) {
        var finalName = name$$40;
        var v9874 = !name$$40;
        if (v9874) {
          finalName = "";
        } else {
          var v24588 = this.sourceMapper;
          var v22168 = v24588.currentNameIndex;
          var v17474 = v22168.length;
          var v9873 = v17474 > 0;
          if (v9873) {
            var v24589 = this.sourceMapper;
            var v22169 = v24589.names;
            var v26288 = this.sourceMapper;
            var v25734 = v26288.currentNameIndex;
            var v24590 = v25734.length;
            var v22170 = v24590 - 1;
            var v17475 = v22169[v22170];
            var v9872 = v17475 + ".";
            finalName = v9872 + name$$40;
          }
        }
        var v17476 = this.sourceMapper;
        var v9875 = v17476.names;
        v9875.push(finalName);
        var v17477 = this.sourceMapper;
        var v9876 = v17477.currentNameIndex;
        var v24591 = this.sourceMapper;
        var v22171 = v24591.names;
        var v17478 = v22171.length;
        var v9877 = v17478 - 1;
        v9876.push(v9877);
      }
      return;
    }
    function v473(stmts$$2, emitClassPropertiesAfterSuperCall) {
      var v17479 = typeof emitClassPropertiesAfterSuperCall;
      var v9879 = v17479 === "undefined";
      if (v9879) {
        emitClassPropertiesAfterSuperCall = false;
      }
      var v17480 = stmts$$2.nodeType;
      var v22172 = TypeScript$$12.NodeType;
      var v17481 = v22172.Block;
      var v9887 = v17480 != v17481;
      if (v9887) {
        var v17482 = stmts$$2.nodeType;
        var v22173 = TypeScript$$12.NodeType;
        var v17483 = v22173.List;
        var v9885 = v17482 == v17483;
        if (v9885) {
          var stmtList = stmts$$2;
          var v25735 = stmtList.members;
          var v24592 = v25735.length;
          var v22174 = v24592 == 2;
          if (v22174) {
            var v26289 = stmtList.members;
            var v25736 = v26289[0];
            var v24593 = v25736.nodeType;
            var v25737 = TypeScript$$12.NodeType;
            var v24594 = v25737.Block;
            v22174 = v24593 == v24594;
          }
          var v17484 = v22174;
          if (v17484) {
            var v25738 = stmtList.members;
            var v24595 = v25738[1];
            var v22175 = v24595.nodeType;
            var v24596 = TypeScript$$12.NodeType;
            var v22176 = v24596.EndCode;
            v17484 = v22175 == v22176;
          }
          var v9883 = v17484;
          if (v9883) {
            var v17485 = stmtList.members;
            var v9880 = v17485[0];
            var v17486 = TypeScript$$12.TokenID;
            var v9881 = v17486.Semicolon;
            this.emitJavascript(v9880, v9881, true);
            this.writeLineToOutput("");
          } else {
            var v17487 = TypeScript$$12.TokenID;
            var v9882 = v17487.Semicolon;
            this.emitJavascriptList(stmts$$2, null, v9882, true, false, emitClassPropertiesAfterSuperCall);
          }
        } else {
          var v17488 = TypeScript$$12.TokenID;
          var v9884 = v17488.Semicolon;
          this.emitJavascript(stmts$$2, v9884, true);
        }
      } else {
        var v17489 = TypeScript$$12.TokenID;
        var v9886 = v17489.Semicolon;
        this.emitJavascript(stmts$$2, v9886, true);
      }
      return;
    }
    function v472(stmts$$1, emitEmptyBod) {
      if (stmts$$1) {
        var v17490 = stmts$$1.nodeType;
        var v22177 = TypeScript$$12.NodeType;
        var v17491 = v22177.Block;
        var v9897 = v17490 != v17491;
        if (v9897) {
          var v9888 = stmts$$1;
          if (v9888) {
            var v22178 = stmts$$1.nodeType;
            var v24597 = TypeScript$$12.NodeType;
            var v22179 = v24597.List;
            var v17492 = v22178 != v22179;
            var v22181 = !v17492;
            if (v22181) {
              var v24598 = stmts$$1.members;
              var v22180 = v24598.length;
              v17492 = v22180 > 0;
            }
            v9888 = v17492;
          }
          var hasContents = v9888;
          var v9895 = emitEmptyBod || hasContents;
          if (v9895) {
            var v17493 = stmts$$1.nodeType;
            var v22182 = TypeScript$$12.NodeType;
            var v17494 = v22182.Block;
            var v9889 = v17493 == v17494;
            var v17496 = !v9889;
            if (v17496) {
              var v24599 = stmts$$1.nodeType;
              var v25739 = TypeScript$$12.NodeType;
              var v24600 = v25739.List;
              var v22183 = v24599 == v24600;
              if (v22183) {
                var v25740 = stmts$$1.members;
                var v24601 = v25740.length;
                v22183 = v24601 == 1;
              }
              var v17495 = v22183;
              if (v17495) {
                var v25741 = stmts$$1.members;
                var v24602 = v25741[0];
                var v22184 = v24602.nodeType;
                var v24603 = TypeScript$$12.NodeType;
                var v22185 = v24603.Block;
                v17495 = v22184 == v22185;
              }
              v9889 = v17495;
            }
            var hasOnlyBlockStatement = v9889;
            this.recordSourceMappingStart(stmts$$1);
            var v9891 = !hasOnlyBlockStatement;
            if (v9891) {
              this.writeLineToOutput(" {");
              var v9890 = this.indenter;
              v9890.increaseIndent();
            }
            var v17497 = TypeScript$$12.TokenID;
            var v9892 = v17497.Semicolon;
            this.emitJavascriptList(stmts$$1, null, v9892, true, false, false);
            var v9894 = !hasOnlyBlockStatement;
            if (v9894) {
              this.writeLineToOutput("");
              var v9893 = this.indenter;
              v9893.decreaseIndent();
              this.emitIndent();
              this.writeToOutput("}");
            }
            this.recordSourceMappingEnd(stmts$$1);
          }
        } else {
          var v17498 = TypeScript$$12.TokenID;
          var v9896 = v17498.Semicolon;
          this.emitJavascript(stmts$$1, v9896, true);
        }
      } else {
        if (emitEmptyBod) {
          this.writeToOutput("{ }");
        }
      }
      return;
    }
    function v471(name$$39, addThis) {
      var sym$$4 = name$$39.sym;
      this.emitParensAndCommentsInPlace(name$$39, true);
      this.recordSourceMappingStart(name$$39);
      var v17499 = name$$39.isMissing();
      var v9923 = !v17499;
      if (v9923) {
        var v22186 = addThis;
        if (v22186) {
          var v25742 = this.emitState;
          var v24604 = v25742.container;
          var v24605 = EmitContainer.Args;
          v22186 = v24604 != v24605;
        }
        var v17500 = v22186;
        if (v17500) {
          v17500 = sym$$4;
        }
        var v9914 = v17500;
        if (v9914) {
          var v17501 = sym$$4.container;
          if (v17501) {
            var v24606 = sym$$4.container;
            var v22187 = v24606.name;
            var v22188 = TypeScript$$12.globalId;
            v17501 = v22187 != v22188;
          }
          var v9913 = v17501;
          if (v9913) {
            var v22189 = sym$$4.flags;
            var v24607 = TypeScript$$12.SymbolFlags;
            var v22190 = v24607.Static;
            var v17502 = TypeScript$$12.hasFlag(v22189, v22190);
            if (v17502) {
              var v22191 = sym$$4.flags;
              var v24608 = TypeScript$$12.SymbolFlags;
              var v22192 = v24608.Property;
              v17502 = TypeScript$$12.hasFlag(v22191, v22192);
            }
            var v9911 = v17502;
            if (v9911) {
              var v17503 = sym$$4.declModule;
              if (v17503) {
                var v24609 = sym$$4.declModule;
                var v22193 = v24609.modFlags;
                var v24610 = TypeScript$$12.ModuleFlags;
                var v22194 = v24610.IsDynamic;
                v17503 = TypeScript$$12.hasFlag(v22193, v22194);
              }
              var v9899 = v17503;
              if (v9899) {
                this.writeToOutput("exports.");
              } else {
                var v22195 = sym$$4.container;
                var v17504 = v22195.name;
                var v9898 = v17504 + ".";
                this.writeToOutput(v9898);
              }
            } else {
              var v17505 = sym$$4.kind();
              var v22196 = TypeScript$$12.SymbolKind;
              var v17506 = v22196.Field;
              var v9910 = v17505 == v17506;
              if (v9910) {
                var fieldSym = sym$$4;
                var v17507 = fieldSym.flags;
                var v22197 = TypeScript$$12.SymbolFlags;
                var v17508 = v22197.ModuleMember;
                var v9904 = TypeScript$$12.hasFlag(v17507, v17508);
                if (v9904) {
                  var v22198 = sym$$4.container;
                  var v24611 = this.checker;
                  var v22199 = v24611.gloMod;
                  var v17509 = v22198 != v22199;
                  if (v17509) {
                    var v24612 = sym$$4.flags;
                    var v25743 = TypeScript$$12.SymbolFlags;
                    var v24613 = v25743.Property;
                    var v22200 = TypeScript$$12.hasFlag(v24612, v24613);
                    var v24616 = !v22200;
                    if (v24616) {
                      var v24614 = sym$$4.flags;
                      var v25744 = TypeScript$$12.SymbolFlags;
                      var v24615 = v25744.Exported;
                      v22200 = TypeScript$$12.hasFlag(v24614, v24615);
                    }
                    v17509 = v22200;
                  }
                  var v9902 = v17509;
                  if (v9902) {
                    var v22201 = sym$$4.declModule;
                    var v17510 = v22201.modFlags;
                    var v22202 = TypeScript$$12.ModuleFlags;
                    var v17511 = v22202.IsDynamic;
                    var v9901 = TypeScript$$12.hasFlag(v17510, v17511);
                    if (v9901) {
                      this.writeToOutput("exports.");
                    } else {
                      var v22203 = sym$$4.container;
                      var v17512 = v22203.name;
                      var v9900 = v17512 + ".";
                      this.writeToOutput(v9900);
                    }
                  }
                } else {
                  var v9903 = sym$$4.isInstanceProperty();
                  if (v9903) {
                    this.emitThis();
                    this.writeToOutput(".");
                  }
                }
              } else {
                var v17513 = sym$$4.kind();
                var v22204 = TypeScript$$12.SymbolKind;
                var v17514 = v22204.Type;
                var v9909 = v17513 == v17514;
                if (v9909) {
                  var v9908 = sym$$4.isInstanceProperty();
                  if (v9908) {
                    var typeSym = sym$$4;
                    var type$$28 = typeSym.type;
                    var v17515 = type$$28.call;
                    if (v17515) {
                      var v24617 = sym$$4.flags;
                      var v25745 = TypeScript$$12.SymbolFlags;
                      var v24618 = v25745.ModuleMember;
                      var v22205 = TypeScript$$12.hasFlag(v24617, v24618);
                      v17515 = !v22205;
                    }
                    var v9905 = v17515;
                    if (v9905) {
                      this.emitThis();
                      this.writeToOutput(".");
                    }
                  } else {
                    var v22206 = sym$$4.unitIndex;
                    var v25746 = this.checker;
                    var v24619 = v25746.locationInfo;
                    var v22207 = v24619.unitIndex;
                    var v17516 = v22206 != v22207;
                    var v22209 = !v17516;
                    if (v22209) {
                      var v24620 = sym$$4.declModule;
                      var v22208 = this.declEnclosed(v24620);
                      v17516 = !v22208;
                    }
                    var v9907 = v17516;
                    if (v9907) {
                      var v22210 = sym$$4.container;
                      var v17517 = v22210.name;
                      var v9906 = v17517 + ".";
                      this.writeToOutput(v9906);
                    }
                  }
                }
              }
            }
          } else {
            var v26537 = sym$$4.container;
            var v26652 = this.checker;
            var v26538 = v26652.gloMod;
            var v26290 = v26537 == v26538;
            if (v26290) {
              var v26539 = sym$$4.flags;
              var v26653 = TypeScript$$12.SymbolFlags;
              var v26540 = v26653.Exported;
              v26290 = TypeScript$$12.hasFlag(v26539, v26540);
            }
            var v25747 = v26290;
            if (v25747) {
              var v26541 = sym$$4.flags;
              var v26654 = TypeScript$$12.SymbolFlags;
              var v26542 = v26654.Ambient;
              var v26291 = TypeScript$$12.hasFlag(v26541, v26542);
              v25747 = !v26291;
            }
            var v24621 = v25747;
            if (v24621) {
              var v26655 = sym$$4.isType();
              var v26712 = !v26655;
              if (v26712) {
                v26655 = sym$$4.isMember();
              }
              var v26543 = v26655;
              if (v26543) {
                v26543 = sym$$4.declModule;
              }
              var v26292 = v26543;
              if (v26292) {
                var v26656 = sym$$4.declModule;
                var v26544 = v26656.modFlags;
                var v26657 = TypeScript$$12.ModuleFlags;
                var v26545 = v26657.Ambient;
                v26292 = TypeScript$$12.hasFlag(v26544, v26545);
              }
              var v25748 = v26292;
              v24621 = !v25748;
            }
            var v22211 = v24621;
            if (v22211) {
              var v25749 = this.emitState;
              var v24622 = v25749.container;
              var v24623 = EmitContainer.Prog;
              v22211 = v24622 == v24623;
            }
            var v17518 = v22211;
            if (v17518) {
              var v24624 = sym$$4.declAST;
              var v22212 = v24624.nodeType;
              var v24625 = TypeScript$$12.NodeType;
              var v22213 = v24625.FuncDecl;
              v17518 = v22212 != v22213;
            }
            var v9912 = v17518;
            if (v9912) {
              this.writeToOutput("this.");
            }
          }
        }
        var v24626 = sym$$4;
        if (v24626) {
          v24626 = sym$$4.declAST;
        }
        var v22214 = v24626;
        if (v22214) {
          var v25750 = sym$$4.declAST;
          var v24627 = v25750.nodeType;
          var v25751 = TypeScript$$12.NodeType;
          var v24628 = v25751.ModuleDeclaration;
          v22214 = v24627 == v24628;
        }
        var v17519 = v22214;
        if (v17519) {
          var v24629 = sym$$4.declAST;
          var v22215 = v24629.modFlags;
          var v24630 = TypeScript$$12.ModuleFlags;
          var v22216 = v24630.IsDynamic;
          v17519 = TypeScript$$12.hasFlag(v22215, v22216);
        }
        var v9922 = v17519;
        if (v9922) {
          var moduleDecl$$2 = sym$$4.declAST;
          var v17520 = TypeScript$$12.moduleGenTarget;
          var v22217 = TypeScript$$12.ModuleGenTarget;
          var v17521 = v22217.Asynchronous;
          var v9920 = v17520 == v17521;
          if (v9920) {
            var v22218 = this.modAliasId;
            var v17522 = "__" + v22218;
            var v9915 = v17522 + "__;";
            this.writeLineToOutput(v9915);
          } else {
            var modPath$$1 = name$$39.actualText;
            var v22219 = moduleDecl$$2.mod;
            var v17523 = v22219.symbol;
            var v9916 = v17523.declAST;
            if (v9916) {
              var v25752 = moduleDecl$$2.mod;
              var v24631 = v25752.symbol;
              var v22220 = v24631.declAST;
              var v17524 = v22220.modFlags;
              var v22221 = TypeScript$$12.ModuleFlags;
              var v17525 = v22221.Ambient;
              v9916 = TypeScript$$12.hasFlag(v17524, v17525);
            }
            var isAmbient = v9916;
            var v9917;
            if (isAmbient) {
              v9917 = modPath$$1;
            } else {
              var v17526;
              var v22222 = this.firstModAlias;
              if (v22222) {
                v17526 = this.firstModAlias;
              } else {
                v17526 = TypeScript$$12.quoteBaseName(modPath$$1);
              }
              v9917 = v17526;
            }
            modPath$$1 = v9917;
            var v9918;
            if (isAmbient) {
              v9918 = modPath$$1;
            } else {
              var v17527;
              var v25753 = TypeScript$$12.stripQuotes(modPath$$1);
              var v24632 = TypeScript$$12.isRelative(v25753);
              var v22224 = !v24632;
              if (v22224) {
                var v24633 = TypeScript$$12.stripQuotes(modPath$$1);
                var v22223 = "./" + v24633;
                v17527 = TypeScript$$12.quoteStr(v22223);
              } else {
                v17527 = modPath$$1;
              }
              v9918 = v17527;
            }
            modPath$$1 = v9918;
            var v17528 = "require(" + modPath$$1;
            var v9919 = v17528 + ")";
            this.writeToOutput(v9919);
          }
        } else {
          var v9921 = name$$39.actualText;
          this.writeToOutput(v9921);
        }
      }
      this.recordSourceMappingEnd(name$$39);
      this.emitParensAndCommentsInPlace(name$$39, false);
      return;
    }
    function v470(moduleDecl$$1) {
      var v9924 = moduleDecl$$1 == null;
      if (v9924) {
        return true;
      }
      var i$$44 = 0;
      var v9925 = this.moduleDeclList;
      var len$$10 = v9925.length;
      var v9927 = i$$44 < len$$10;
      for (;v9927;) {
        var v22225 = this.moduleDeclList;
        var v17529 = v22225[i$$44];
        var v9926 = v17529 == moduleDecl$$1;
        if (v9926) {
          return true;
        }
        i$$44 = i$$44 + 1;
        v9927 = i$$44 < len$$10;
      }
      return false;
    }
    function v469(varDecl$$2, tokenId$$39) {
      var v22226 = varDecl$$2.varFlags;
      var v24634 = TypeScript$$12.VarFlags;
      var v22227 = v24634.Ambient;
      var v17530 = v22226 & v22227;
      var v22228 = TypeScript$$12.VarFlags;
      var v17531 = v22228.Ambient;
      var v9953 = v17530 == v17531;
      if (v9953) {
        this.emitAmbientVarDecl(varDecl$$2);
        this.onEmitVar();
      } else {
        var sym$$3 = varDecl$$2.sym;
        var v9928 = varDecl$$2.init;
        var hasInitializer = v9928 != null;
        this.emitParensAndCommentsInPlace(varDecl$$2, true);
        this.recordSourceMappingStart(varDecl$$2);
        var v24635 = sym$$3;
        if (v24635) {
          v24635 = sym$$3.isMember();
        }
        var v22229 = v24635;
        if (v22229) {
          v22229 = sym$$3.container;
        }
        var v17532 = v22229;
        if (v17532) {
          var v24636 = sym$$3.container;
          var v22230 = v24636.kind();
          var v24637 = TypeScript$$12.SymbolKind;
          var v22231 = v24637.Type;
          v17532 = v22230 == v22231;
        }
        var v9942 = v17532;
        if (v9942) {
          var v9929 = sym$$3.container;
          var type$$27 = v9929.type;
          var v17533 = type$$27.isClass();
          if (v17533) {
            var v24638 = sym$$3.flags;
            var v25754 = TypeScript$$12.SymbolFlags;
            var v24639 = v25754.ModuleMember;
            var v22232 = TypeScript$$12.hasFlag(v24638, v24639);
            v17533 = !v22232;
          }
          var v9940 = v17533;
          if (v9940) {
            var v22233 = this.emitState;
            var v17534 = v22233.container;
            var v17535 = EmitContainer.Args;
            var v9932 = v17534 != v17535;
            if (v9932) {
              var v17536 = sym$$3.flags;
              var v22234 = TypeScript$$12.SymbolFlags;
              var v17537 = v22234.Static;
              var v9931 = TypeScript$$12.hasFlag(v17536, v17537);
              if (v9931) {
                var v22235 = sym$$3.container;
                var v17538 = v22235.name;
                var v9930 = v17538 + ".";
                this.writeToOutput(v9930);
              } else {
                this.writeToOutput("this.");
              }
            }
          } else {
            var v9939 = type$$27.hasImplementation();
            if (v9939) {
              var v24640 = sym$$3.flags;
              var v25755 = TypeScript$$12.SymbolFlags;
              var v24641 = v25755.Exported;
              var v22236 = TypeScript$$12.hasFlag(v24640, v24641);
              var v17539 = !v22236;
              if (v17539) {
                var v24642 = sym$$3.container;
                var v25756 = this.checker;
                var v24643 = v25756.gloMod;
                var v22237 = v24642 == v24643;
                var v24645 = !v22237;
                if (v24645) {
                  var v25757 = sym$$3.flags;
                  var v26293 = TypeScript$$12.SymbolFlags;
                  var v25758 = v26293.Property;
                  var v24644 = TypeScript$$12.hasFlag(v25757, v25758);
                  v22237 = !v24644;
                }
                v17539 = v22237;
              }
              var v9936 = v17539;
              if (v9936) {
                this.emitVarDeclVar();
              } else {
                var v17540 = varDecl$$2.varFlags;
                var v22238 = TypeScript$$12.VarFlags;
                var v17541 = v22238.LocalStatic;
                var v9935 = TypeScript$$12.hasFlag(v17540, v17541);
                if (v9935) {
                  this.writeToOutput(".");
                } else {
                  var v22239 = this.emitState;
                  var v17542 = v22239.container;
                  var v17543 = EmitContainer.DynamicModule;
                  var v9934 = v17542 == v17543;
                  if (v9934) {
                    this.writeToOutput("exports.");
                  } else {
                    var v17544 = this.moduleName;
                    var v9933 = v17544 + ".";
                    this.writeToOutput(v9933);
                  }
                }
              }
            } else {
              var v22240 = TypeScript$$12.TokenID;
              var v17545 = v22240.OpenParen;
              var v9938 = tokenId$$39 != v17545;
              if (v9938) {
                var v22241 = sym$$3.flags;
                var v24646 = TypeScript$$12.SymbolFlags;
                var v22242 = v24646.Exported;
                var v17546 = TypeScript$$12.hasFlag(v22241, v22242);
                if (v17546) {
                  var v22243 = sym$$3.container;
                  var v24647 = this.checker;
                  var v22244 = v24647.gloMod;
                  v17546 = v22243 == v22244;
                }
                var v9937 = v17546;
                if (v9937) {
                  this.writeToOutput("this.");
                } else {
                  this.emitVarDeclVar();
                }
              }
            }
          }
        } else {
          var v22245 = TypeScript$$12.TokenID;
          var v17547 = v22245.OpenParen;
          var v9941 = tokenId$$39 != v17547;
          if (v9941) {
            this.emitVarDeclVar();
          }
        }
        var v9943 = varDecl$$2.id;
        this.recordSourceMappingStart(v9943);
        var v17548 = varDecl$$2.id;
        var v9944 = v17548.actualText;
        this.writeToOutput(v9944);
        var v9945 = varDecl$$2.id;
        this.recordSourceMappingEnd(v9945);
        if (hasInitializer) {
          this.writeToOutputTrimmable(" = ");
          var v9946 = this.varListCountStack;
          v9946.push(0);
          var v9947 = varDecl$$2.init;
          var v17549 = TypeScript$$12.TokenID;
          var v9948 = v17549.Comma;
          this.emitJavascript(v9947, v9948, false);
          var v9949 = this.varListCountStack;
          v9949.pop();
        }
        this.onEmitVar();
        var v22246 = TypeScript$$12.TokenID;
        var v17550 = v22246.OpenParen;
        var v9952 = tokenId$$39 != v17550;
        if (v9952) {
          var v17551 = this.varListCount();
          var v9951 = v17551 < 0;
          if (v9951) {
            this.writeToOutput(", ");
          } else {
            var v22247 = TypeScript$$12.TokenID;
            var v17552 = v22247.For;
            var v9950 = tokenId$$39 != v17552;
            if (v9950) {
              this.writeToOutputTrimmable(";");
            }
          }
        }
        this.recordSourceMappingEnd(varDecl$$2);
        this.emitParensAndCommentsInPlace(varDecl$$2, false);
      }
      return;
    }
    function v468() {
      var v17553 = this.varListCount();
      var v9957 = v17553 > 0;
      if (v9957) {
        var v17554 = this.varListCount();
        var v9954 = v17554 - 1;
        this.setInVarBlock(v9954);
      } else {
        var v17555 = this.varListCount();
        var v9956 = v17555 < 0;
        if (v9956) {
          var v17556 = this.varListCount();
          var v9955 = v17556 + 1;
          this.setInVarBlock(v9955);
        }
      }
      return;
    }
    function v467() {
      var v17557 = this.varListCount();
      var v9959 = v17557 >= 0;
      if (v9959) {
        this.writeToOutput("var ");
        var v17558 = this.varListCount();
        var v9958 = -v17558;
        this.setInVarBlock(v9958);
      }
      return true;
    }
    function v466() {
      var v9960 = this.varListCountStack;
      var v22248 = this.varListCountStack;
      var v17559 = v22248.length;
      var v9961 = v17559 - 1;
      return v9960[v9961];
    }
    function v465(varDecl$$1) {
      var v9967 = varDecl$$1.init;
      if (v9967) {
        this.emitParensAndCommentsInPlace(varDecl$$1, true);
        this.recordSourceMappingStart(varDecl$$1);
        var v9962 = varDecl$$1.id;
        this.recordSourceMappingStart(v9962);
        var v17560 = varDecl$$1.id;
        var v9963 = v17560.actualText;
        this.writeToOutput(v9963);
        var v9964 = varDecl$$1.id;
        this.recordSourceMappingEnd(v9964);
        this.writeToOutput(" = ");
        var v9965 = varDecl$$1.init;
        var v17561 = TypeScript$$12.TokenID;
        var v9966 = v17561.Comma;
        this.emitJavascript(v9965, v9966, false);
        this.recordSourceMappingEnd(varDecl$$1);
        this.writeToOutput(";");
        this.emitParensAndCommentsInPlace(varDecl$$1, false);
      }
      return;
    }
    function v464(funcDecl$$2) {
      var v22249 = funcDecl$$2.fncFlags;
      var v24648 = TypeScript$$12.FncFlags;
      var v22250 = v24648.Signature;
      var v17562 = TypeScript$$12.hasFlag(v22249, v22250);
      var v22251 = !v17562;
      if (v22251) {
        v17562 = funcDecl$$2.isOverload;
      }
      var v9968 = v17562;
      if (v9968) {
        return;
      }
      var temp$$12;
      var tempFnc = this.thisFnc;
      this.thisFnc = funcDecl$$2;
      var v9971 = funcDecl$$2.isConstructor;
      if (v9971) {
        var v9969 = EmitContainer.Constructor;
        temp$$12 = this.setContainer(v9969);
      } else {
        var v9970 = EmitContainer.Function;
        temp$$12 = this.setContainer(v9970);
      }
      var bases$$2 = null;
      var hasSelfRef$$1 = false;
      var funcName = funcDecl$$2.getNameText();
      var v24649 = this.emitState;
      var v22252 = v24649.inObjectLiteral;
      var v24651 = !v22252;
      if (v24651) {
        var v24650 = funcDecl$$2.isAccessor();
        v22252 = !v24650;
      }
      var v17563 = v22252;
      if (v17563) {
        var v24652 = EmitContainer.Constructor;
        var v22253 = temp$$12 != v24652;
        var v24655 = !v22253;
        if (v24655) {
          var v25759 = funcDecl$$2.fncFlags;
          var v26294 = TypeScript$$12.FncFlags;
          var v25760 = v26294.Method;
          var v24653 = v25759 & v25760;
          var v25761 = TypeScript$$12.FncFlags;
          var v24654 = v25761.None;
          v22253 = v24653 == v24654;
        }
        v17563 = v22253;
      }
      var v9979 = v17563;
      if (v9979) {
        var tempLit = this.setInObjectLiteral(false);
        var v9973 = this.thisClassNode;
        if (v9973) {
          var v9972 = this.thisClassNode;
          bases$$2 = v9972.extendsList;
        }
        hasSelfRef$$1 = Emitter$$1.shouldCaptureThis(funcDecl$$2);
        this.recordSourceMappingStart(funcDecl$$2);
        var v24656 = funcDecl$$2.fncFlags;
        var v26295 = TypeScript$$12.FncFlags;
        var v25762 = v26295.Exported;
        var v26296 = TypeScript$$12.FncFlags;
        var v25763 = v26296.ClassPropertyMethodExported;
        var v24657 = v25762 | v25763;
        var v22254 = TypeScript$$12.hasFlag(v24656, v24657);
        if (v22254) {
          var v26297 = funcDecl$$2.type;
          var v25764 = v26297.symbol;
          var v24658 = v25764.container;
          var v25765 = this.checker;
          var v24659 = v25765.gloMod;
          v22254 = v24658 == v24659;
        }
        var v17564 = v22254;
        if (v17564) {
          var v22255 = funcDecl$$2.isConstructor;
          v17564 = !v22255;
        }
        var v9978 = v17564;
        if (v9978) {
          var v17565 = "this." + funcName;
          var v9974 = v17565 + " = ";
          this.writeToOutput(v9974);
          var v9975 = this.thisClassNode;
          this.emitInnerFunction(funcDecl$$2, false, false, bases$$2, hasSelfRef$$1, v9975);
        } else {
          var v17566 = funcDecl$$2.name;
          if (v17566) {
            var v24660 = funcDecl$$2.name;
            var v22256 = v24660.isMissing();
            v17566 = !v22256;
          }
          var v9976 = v17566;
          var v9977 = this.thisClassNode;
          this.emitInnerFunction(funcDecl$$2, v9976, false, bases$$2, hasSelfRef$$1, v9977);
        }
        this.setInObjectLiteral(tempLit);
      }
      this.setContainer(temp$$12);
      this.thisFnc = tempFnc;
      var v17567 = funcDecl$$2.fncFlags;
      var v22257 = TypeScript$$12.FncFlags;
      var v17568 = v22257.Definition;
      var v9988 = TypeScript$$12.hasFlag(v17567, v17568);
      if (v9988) {
        var v17569 = funcDecl$$2.fncFlags;
        var v22258 = TypeScript$$12.FncFlags;
        var v17570 = v22258.Static;
        var v9987 = TypeScript$$12.hasFlag(v17569, v17570);
        if (v9987) {
          var v9983 = this.thisClassNode;
          if (v9983) {
            var v9982 = funcDecl$$2.isAccessor();
            if (v9982) {
              var v22259 = this.thisClassNode;
              var v17571 = v22259.name;
              var v9980 = v17571.actualText;
              this.emitPropertyAccessor(funcDecl$$2, v9980, false);
            } else {
              this.emitIndent();
              this.recordSourceMappingStart(funcDecl$$2);
              var v26658 = this.thisClassNode;
              var v26546 = v26658.name;
              var v26298 = v26546.actualText;
              var v25766 = v26298 + ".";
              var v24661 = v25766 + funcName;
              var v22260 = v24661 + " = ";
              var v17572 = v22260 + funcName;
              var v9981 = v17572 + ";";
              this.writeLineToOutput(v9981);
              this.recordSourceMappingEnd(funcDecl$$2);
            }
          }
        } else {
          var v25767 = this.emitState;
          var v24662 = v25767.container;
          var v24663 = EmitContainer.Module;
          var v22261 = v24662 == v24663;
          var v24666 = !v22261;
          if (v24666) {
            var v25768 = this.emitState;
            var v24664 = v25768.container;
            var v24665 = EmitContainer.DynamicModule;
            v22261 = v24664 == v24665;
          }
          var v17573 = v22261;
          if (v17573) {
            var v22262 = funcDecl$$2.fncFlags;
            var v25769 = TypeScript$$12.FncFlags;
            var v24667 = v25769.Exported;
            var v25770 = TypeScript$$12.FncFlags;
            var v24668 = v25770.ClassPropertyMethodExported;
            var v22263 = v24667 | v24668;
            v17573 = TypeScript$$12.hasFlag(v22262, v22263);
          }
          var v9986 = v17573;
          if (v9986) {
            this.emitIndent();
            var v9984;
            var v24669 = this.emitState;
            var v22264 = v24669.container;
            var v22265 = EmitContainer.Module;
            var v17574 = v22264 == v22265;
            if (v17574) {
              v9984 = this.moduleName;
            } else {
              v9984 = "exports";
            }
            var modName$$1 = v9984;
            this.recordSourceMappingStart(funcDecl$$2);
            var v25771 = modName$$1 + ".";
            var v24670 = v25771 + funcName;
            var v22266 = v24670 + " = ";
            var v17575 = v22266 + funcName;
            var v9985 = v17575 + ";";
            this.writeLineToOutput(v9985);
            this.recordSourceMappingEnd(funcDecl$$2);
          }
        }
      }
      return;
    }
    function v463(text$$11) {
      this.writeToOutput(text$$11);
      return;
    }
    function v462(operand1$$2, operand2$$2) {
      var temp$$11 = this.setInObjectLiteral(false);
      var v17576 = TypeScript$$12.TokenID;
      var v9989 = v17576.Tilde;
      this.emitJavascript(operand1$$2, v9989, false);
      this.writeToOutput("[");
      var v17577 = TypeScript$$12.TokenID;
      var v9990 = v17577.Comma;
      this.emitJavascriptList(operand2$$2, ", ", v9990, false, false, false);
      this.writeToOutput("]");
      this.setInObjectLiteral(temp$$11);
      return;
    }
    function v461(moduleDecl) {
      var v9991 = moduleDecl.name;
      var modName = v9991.actualText;
      var v9997 = TypeScript$$12.isTSFile(modName);
      if (v9997) {
        var v9992 = moduleDecl.name;
        var v22267 = modName.length;
        var v17578 = v22267 - 3;
        var v9993 = modName.substring(0, v17578);
        v9992.setText(v9993);
      } else {
        var v9996 = TypeScript$$12.isSTRFile(modName);
        if (v9996) {
          var v9994 = moduleDecl.name;
          var v22268 = modName.length;
          var v17579 = v22268 - 4;
          var v9995 = modName.substring(0, v17579);
          v9994.setText(v9995);
        }
      }
      var v22269 = moduleDecl.modFlags;
      var v24671 = TypeScript$$12.ModuleFlags;
      var v22270 = v24671.Ambient;
      var v17580 = TypeScript$$12.hasFlag(v22269, v22270);
      var v10077 = !v17580;
      if (v10077) {
        var v9998 = moduleDecl.modFlags;
        var v17581 = TypeScript$$12.ModuleFlags;
        var v9999 = v17581.IsDynamic;
        var isDynamicMod = TypeScript$$12.hasFlag(v9998, v9999);
        var prevOutFile = this.outfile;
        var prevOutFileName = this.emittingFileName;
        var prevAllSourceMappers = this.allSourceMappers;
        var prevSourceMapper = this.sourceMapper;
        var v10000 = this.emitState;
        var prevColumn = v10000.column;
        var v10001 = this.emitState;
        var prevLine = v10001.line;
        var v10002 = EmitContainer.Module;
        var temp$$10 = this.setContainer(v10002);
        var svModuleName = this.moduleName;
        var v10003 = moduleDecl.modFlags;
        var v17582 = TypeScript$$12.ModuleFlags;
        var v10004 = v17582.Exported;
        var isExported = TypeScript$$12.hasFlag(v10003, v10004);
        var v10005 = this.moduleDeclList;
        var v17583 = this.moduleDeclList;
        var v10006 = v17583.length;
        v10005[v10006] = moduleDecl;
        var v10007 = moduleDecl.modFlags;
        var v17584 = TypeScript$$12.ModuleFlags;
        var v10008 = v17584.IsWholeFile;
        var isWholeFile = TypeScript$$12.hasFlag(v10007, v10008);
        var v10009 = moduleDecl.name;
        this.moduleName = v10009.actualText;
        if (isDynamicMod) {
          var v17585 = moduleDecl.name;
          var v10010 = v17585.actualText;
          var tsModFileName = TypeScript$$12.stripQuotes(v10010);
          var v10011 = TypeScript$$12.trimModName(tsModFileName);
          var modFilePath = v10011 + ".js";
          var v10012 = this.emitOptions;
          var v17586 = TypeScript$$12.TypeScriptCompiler;
          var v10013 = v17586.mapToJSFileName;
          modFilePath = v10012.mapOutputFileName(modFilePath, v10013);
          var v17587 = this.emitOptions;
          var v10024 = v17587.ioHost;
          if (v10024) {
            var v17588 = TypeScript$$12.switchToForwardSlashes(modFilePath);
            var v22271 = this.emittingFileName;
            var v17589 = TypeScript$$12.switchToForwardSlashes(v22271);
            var v10023 = v17588 != v17589;
            if (v10023) {
              this.emittingFileName = modFilePath;
              var v10014 = moduleDecl.containsUnicodeChar;
              var v17591 = !v10014;
              if (v17591) {
                var v22272 = this.emitOptions;
                var v17590 = v22272.emitComments;
                if (v17590) {
                  v17590 = moduleDecl.containsUnicodeCharInComment;
                }
                v10014 = v17590;
              }
              var useUTF8InOutputfile = v10014;
              var v10015 = this.emittingFileName;
              var v27316 = this.createFile(v10015, useUTF8InOutputfile);
              this.outfile = v27316;
              var v10020 = prevSourceMapper != null;
              if (v10020) {
                this.allSourceMappers = [];
                var v17592 = this.emittingFileName;
                var v22273 = TypeScript$$12.SourceMapper;
                var v17593 = v22273.MapFileExtension;
                var v10016 = v17592 + v17593;
                var sourceMappingFile = this.createFile(v10016, false);
                var v17594 = TypeScript$$12.SourceMapper;
                var v17595 = this.emittingFileName;
                var v17596 = this.outfile;
                var v17597 = this.errorReporter;
                var v10017 = new v17594(tsModFileName, v17595, v17596, sourceMappingFile, v17597);
                this.setSourceMappings(v10017);
                var v10018 = this.emitState;
                v10018.column = 0;
                var v10019 = this.emitState;
                v10019.line = 0;
              }
            } else {
              var v10021 = TypeScript$$12.CompilerDiagnostics;
              var v17598 = this.emitOptions;
              var v10022 = v17598.outputMany;
              v10021.assert(v10022, "Cannot have dynamic modules compiling into single file");
            }
          }
          var v10025 = EmitContainer.DynamicModule;
          this.setContainer(v10025);
          this.recordSourceMappingStart(moduleDecl);
          var v17599 = TypeScript$$12.moduleGenTarget;
          var v22274 = TypeScript$$12.ModuleGenTarget;
          var v17600 = v22274.Asynchronous;
          var v10032 = v17599 == v17600;
          if (v10032) {
            var dependencyList = '["require", "exports"';
            var importList = "require, exports";
            var importStatement = null;
            var i$$43 = 0;
            var v24672 = moduleDecl.mod;
            var v22275 = v24672.importedModules;
            var v17601 = v22275.length;
            var v10029 = i$$43 < v17601;
            for (;v10029;) {
              var v17602 = moduleDecl.mod;
              var v10026 = v17602.importedModules;
              importStatement = v10026[i$$43];
              var v22276 = importStatement.id;
              var v17603 = v22276.sym;
              if (v17603) {
                var v25772 = importStatement.id;
                var v24673 = v25772.sym;
                var v22277 = v24673.onlyReferencedAsTypeRef;
                v17603 = !v22277;
              }
              var v10028 = v17603;
              if (v10028) {
                var v25773 = moduleDecl.mod;
                var v24674 = v25773.importedModules;
                var v22278 = v24674.length;
                var v17604 = v22278 - 1;
                var v10027 = i$$43 <= v17604;
                if (v10027) {
                  dependencyList = dependencyList + ", ";
                  importList = importList + ", ";
                }
                var v25774 = importStatement.id;
                var v24675 = v25774.actualText;
                var v22279 = "__" + v24675;
                var v17605 = v22279 + "__";
                importList = importList + v17605;
                var v17606 = dependencyList;
                var v17607 = importStatement.firstAliasedModToString();
                dependencyList = v17606 + v17607;
              }
              i$$43 = i$$43 + 1;
              var v24676 = moduleDecl.mod;
              var v22280 = v24676.importedModules;
              var v17608 = v22280.length;
              v10029 = i$$43 < v17608;
            }
            i$$43 = 0;
            var v22281 = moduleDecl.amdDependencies;
            var v17609 = v22281.length;
            var v10030 = i$$43 < v17609;
            for (;v10030;) {
              var v25775 = moduleDecl.amdDependencies;
              var v24677 = v25775[i$$43];
              var v22282 = ', "' + v24677;
              var v17610 = v22282 + '"';
              dependencyList = dependencyList + v17610;
              i$$43 = i$$43 + 1;
              var v22283 = moduleDecl.amdDependencies;
              var v17611 = v22283.length;
              v10030 = i$$43 < v17611;
            }
            dependencyList = dependencyList + "]";
            var v25776 = "define(" + dependencyList;
            var v24678 = v25776 + ",";
            var v22284 = v24678 + " function(";
            var v17612 = v22284 + importList;
            var v10031 = v17612 + ") {";
            this.writeLineToOutput(v10031);
          } else {
          }
        } else {
          var v10036 = !isExported;
          if (v10036) {
            this.recordSourceMappingStart(moduleDecl);
            this.writeToOutput("var ");
            var v10033 = moduleDecl.name;
            this.recordSourceMappingStart(v10033);
            var v10034 = this.moduleName;
            this.writeToOutput(v10034);
            var v10035 = moduleDecl.name;
            this.recordSourceMappingEnd(v10035);
            this.writeLineToOutput(";");
            this.recordSourceMappingEnd(moduleDecl);
            this.emitIndent();
          }
          this.writeToOutput("(");
          this.recordSourceMappingStart(moduleDecl);
          this.writeToOutput("function (");
          var v10037 = moduleDecl.name;
          this.recordSourceMappingStart(v10037);
          var v10038 = this.moduleName;
          this.writeToOutput(v10038);
          var v10039 = moduleDecl.name;
          this.recordSourceMappingEnd(v10039);
          this.writeLineToOutput(") {");
        }
        var v10041 = !isWholeFile;
        if (v10041) {
          var v10040 = this.moduleName;
          this.recordSourceMappingNameStart(v10040);
        }
        var v17613 = !isDynamicMod;
        var v22287 = !v17613;
        if (v22287) {
          var v22285 = TypeScript$$12.moduleGenTarget;
          var v24679 = TypeScript$$12.ModuleGenTarget;
          var v22286 = v24679.Asynchronous;
          v17613 = v22285 == v22286;
        }
        var v10043 = v17613;
        if (v10043) {
          var v10042 = this.indenter;
          v10042.increaseIndent();
        }
        var v17614 = moduleDecl.modFlags;
        var v22288 = TypeScript$$12.ModuleFlags;
        var v17615 = v22288.MustCaptureThis;
        var v10044 = v17614 & v17615;
        if (v10044) {
          this.writeCaptureThisStatement(moduleDecl);
        }
        var v10045 = moduleDecl.members;
        var v17616 = TypeScript$$12.TokenID;
        var v10046 = v17616.Semicolon;
        this.emitJavascriptList(v10045, null, v10046, true, false, false);
        var v17617 = !isDynamicMod;
        var v22291 = !v17617;
        if (v22291) {
          var v22289 = TypeScript$$12.moduleGenTarget;
          var v24680 = TypeScript$$12.ModuleGenTarget;
          var v22290 = v24680.Asynchronous;
          v17617 = v22289 == v22290;
        }
        var v10048 = v17617;
        if (v10048) {
          var v10047 = this.indenter;
          v10047.decreaseIndent();
        }
        this.emitIndent();
        if (isDynamicMod) {
          var v17618 = TypeScript$$12.moduleGenTarget;
          var v22292 = TypeScript$$12.ModuleGenTarget;
          var v17619 = v22292.Asynchronous;
          var v10049 = v17618 == v17619;
          if (v10049) {
            this.writeLineToOutput("})");
          } else {
          }
          var v10050 = !isWholeFile;
          if (v10050) {
            this.recordSourceMappingNameEnd();
          }
          this.recordSourceMappingEnd(moduleDecl);
          var v17620 = this.outfile;
          var v10054 = v17620 != prevOutFile;
          if (v10054) {
            this.Close();
            var v10053 = prevSourceMapper != null;
            if (v10053) {
              this.allSourceMappers = prevAllSourceMappers;
              this.sourceMapper = prevSourceMapper;
              var v10051 = this.emitState;
              v10051.column = prevColumn;
              var v10052 = this.emitState;
              v10052.line = prevLine;
            }
            this.outfile = prevOutFile;
            this.emittingFileName = prevOutFileName;
          }
        } else {
          var containingMod = null;
          var v22293 = moduleDecl.type;
          if (v22293) {
            var v25777 = moduleDecl.type;
            var v24681 = v25777.symbol;
            v22293 = v24681.container;
          }
          var v17621 = v22293;
          if (v17621) {
            var v25778 = moduleDecl.type;
            var v24682 = v25778.symbol;
            var v22294 = v24682.container;
            v17621 = v22294.declAST;
          }
          var v10056 = v17621;
          if (v10056) {
            var v22295 = moduleDecl.type;
            var v17622 = v22295.symbol;
            var v10055 = v17622.container;
            containingMod = v10055.declAST;
          }
          var v10057 = containingMod;
          if (v10057) {
            var v17623 = containingMod.modFlags;
            var v22296 = TypeScript$$12.ModuleFlags;
            var v17624 = v22296.IsDynamic;
            v10057 = TypeScript$$12.hasFlag(v17623, v17624);
          }
          var parentIsDynamic = v10057;
          var v10058 = moduleDecl.endingToken;
          this.recordSourceMappingStart(v10058);
          var v22297 = EmitContainer.Prog;
          var v17625 = temp$$10 == v22297;
          if (v17625) {
            v17625 = isExported;
          }
          var v10073 = v17625;
          if (v10073) {
            this.writeToOutput("}");
            var v10059 = !isWholeFile;
            if (v10059) {
              this.recordSourceMappingNameEnd();
            }
            var v10060 = moduleDecl.endingToken;
            this.recordSourceMappingEnd(v10060);
            var v25779 = this.moduleName;
            var v24683 = ")(this." + v25779;
            var v22298 = v24683 + " || (this.";
            var v22299 = this.moduleName;
            var v17626 = v22298 + v22299;
            var v10061 = v17626 + " = {}));";
            this.writeLineToOutput(v10061);
          } else {
            var v17627 = isExported;
            var v22301 = !v17627;
            if (v22301) {
              var v22300 = EmitContainer.Prog;
              v17627 = temp$$10 == v22300;
            }
            var v10072 = v17627;
            if (v10072) {
              var v10062;
              var v17629 = svModuleName != "";
              if (v17629) {
                var v22302;
                if (parentIsDynamic) {
                  v22302 = "exports";
                } else {
                  v22302 = svModuleName;
                }
                var v17628 = v22302;
                v10062 = v17628 + ".";
              } else {
                v10062 = svModuleName;
              }
              var dotMod = v10062;
              this.writeToOutput("}");
              var v10063 = !isWholeFile;
              if (v10063) {
                this.recordSourceMappingNameEnd();
              }
              var v10064 = moduleDecl.endingToken;
              this.recordSourceMappingEnd(v10064);
              var v26299 = ")(" + dotMod;
              var v26300 = this.moduleName;
              var v25780 = v26299 + v26300;
              var v24684 = v25780 + " || (";
              var v22303 = v24684 + dotMod;
              var v22304 = this.moduleName;
              var v17630 = v22303 + v22304;
              var v10065 = v17630 + " = {}));";
              this.writeLineToOutput(v10065);
            } else {
              var v17631 = !isExported;
              if (v17631) {
                var v22305 = EmitContainer.Prog;
                v17631 = temp$$10 != v22305;
              }
              var v10071 = v17631;
              if (v10071) {
                this.writeToOutput("}");
                var v10066 = !isWholeFile;
                if (v10066) {
                  this.recordSourceMappingNameEnd();
                }
                var v10067 = moduleDecl.endingToken;
                this.recordSourceMappingEnd(v10067);
                var v25781 = this.moduleName;
                var v24685 = ")(" + v25781;
                var v22306 = v24685 + " || (";
                var v22307 = this.moduleName;
                var v17632 = v22306 + v22307;
                var v10068 = v17632 + " = {}));";
                this.writeLineToOutput(v10068);
              } else {
                this.writeToOutput("}");
                var v10069 = !isWholeFile;
                if (v10069) {
                  this.recordSourceMappingNameEnd();
                }
                var v10070 = moduleDecl.endingToken;
                this.recordSourceMappingEnd(v10070);
                this.writeLineToOutput(")();");
              }
            }
          }
          this.recordSourceMappingEnd(moduleDecl);
          var v22308 = EmitContainer.Prog;
          var v17633 = temp$$10 != v22308;
          if (v17633) {
            v17633 = isExported;
          }
          var v10076 = v17633;
          if (v10076) {
            this.emitIndent();
            this.recordSourceMappingStart(moduleDecl);
            if (parentIsDynamic) {
              var v25782 = this.moduleName;
              var v24686 = "var " + v25782;
              var v22309 = v24686 + " = exports.";
              var v22310 = this.moduleName;
              var v17634 = v22309 + v22310;
              var v10074 = v17634 + ";";
              this.writeLineToOutput(v10074);
            } else {
              var v26547 = this.moduleName;
              var v26301 = "var " + v26547;
              var v25783 = v26301 + " = ";
              var v24687 = v25783 + svModuleName;
              var v22311 = v24687 + ".";
              var v22312 = this.moduleName;
              var v17635 = v22311 + v22312;
              var v10075 = v17635 + ";";
              this.writeLineToOutput(v10075);
            }
            this.recordSourceMappingEnd(moduleDecl);
          }
        }
        this.setContainer(temp$$10);
        this.moduleName = svModuleName;
        var v17636 = this.moduleDeclList;
        var v24688 = this.moduleDeclList;
        var v22313 = v24688.length;
        v17636.length = v22313 - 1;
      }
      return;
    }
    function v460(funcDecl$$1, printName, isMember, bases$$1, hasSelfRef, classDecl$$1) {
      var v10078 = funcDecl$$1.isConstructor;
      if (v10078) {
        var v17637 = funcDecl$$1.fncFlags;
        var v22314 = TypeScript$$12.FncFlags;
        var v17638 = v22314.ClassMethod;
        v10078 = TypeScript$$12.hasFlag(v17637, v17638);
      }
      var isClassConstructor = v10078;
      var v17639 = isClassConstructor;
      if (v17639) {
        var v26302 = this.thisClassNode;
        var v25784 = v26302.type;
        var v24689 = v25784.instanceType;
        var v22315 = v24689.typeFlags;
        var v24690 = TypeScript$$12.TypeFlags;
        var v22316 = v24690.HasBaseType;
        v17639 = TypeScript$$12.hasFlag(v22315, v22316);
      }
      var v10079 = v17639;
      if (v10079) {
        var v26303 = this.thisClassNode;
        var v25785 = v26303.type;
        var v24691 = v25785.instanceType;
        var v22317 = v24691.typeFlags;
        var v24692 = TypeScript$$12.TypeFlags;
        var v22318 = v24692.HasBaseTypeOfObject;
        var v17640 = TypeScript$$12.hasFlag(v22317, v22318);
        v10079 = !v17640;
      }
      var hasNonObjectBaseType = v10079;
      var v10080 = hasNonObjectBaseType;
      if (v10080) {
        var v22319 = this.thisClassNode;
        var v17641 = v22319.varFlags;
        var v22320 = TypeScript$$12.VarFlags;
        var v17642 = v22320.ClassSuperMustBeFirstCallInConstructor;
        v10080 = TypeScript$$12.hasFlag(v17641, v17642);
      }
      var classPropertiesMustComeAfterSuperCall = v10080;
      var v24693 = funcDecl$$1.fncFlags;
      var v25786 = TypeScript$$12.FncFlags;
      var v24694 = v25786.IsFunctionExpression;
      var v22321 = TypeScript$$12.hasFlag(v24693, v24694);
      if (v22321) {
        var v24695 = funcDecl$$1.isParenthesized;
        v22321 = !v24695;
      }
      var v17643 = v22321;
      if (v17643) {
        var v22322 = funcDecl$$1.isAccessor();
        v17643 = !v22322;
      }
      var v10081 = v17643;
      if (v10081) {
        var v22323 = funcDecl$$1.flags;
        var v24696 = TypeScript$$12.ASTFlags;
        var v22324 = v24696.ExplicitSemicolon;
        var v17644 = TypeScript$$12.hasFlag(v22323, v22324);
        var v22327 = !v17644;
        if (v22327) {
          var v22325 = funcDecl$$1.flags;
          var v24697 = TypeScript$$12.ASTFlags;
          var v22326 = v24697.AutomaticSemicolon;
          v17644 = TypeScript$$12.hasFlag(v22325, v22326);
        }
        v10081 = v17644;
      }
      var shouldParenthesize = v10081;
      this.emitParensAndCommentsInPlace(funcDecl$$1, true);
      if (shouldParenthesize) {
        this.writeToOutput("(");
      }
      this.recordSourceMappingStart(funcDecl$$1);
      var v22328 = funcDecl$$1.isAccessor();
      if (v22328) {
        var v24698 = funcDecl$$1.accessorSymbol;
        v22328 = v24698.isObjectLitField;
      }
      var v17645 = v22328;
      var v10082 = !v17645;
      if (v10082) {
        this.writeToOutput("function ");
      }
      if (printName) {
        var id$$8 = funcDecl$$1.getNameText();
        var v17646 = id$$8;
        if (v17646) {
          var v22329 = funcDecl$$1.isAccessor();
          v17646 = !v22329;
        }
        var v10087 = v17646;
        if (v10087) {
          var v10084 = funcDecl$$1.name;
          if (v10084) {
            var v10083 = funcDecl$$1.name;
            this.recordSourceMappingStart(v10083);
          }
          this.writeToOutput(id$$8);
          var v10086 = funcDecl$$1.name;
          if (v10086) {
            var v10085 = funcDecl$$1.name;
            this.recordSourceMappingEnd(v10085);
          }
        }
      }
      this.writeToOutput("(");
      var argsLen = 0;
      var i$$42 = 0;
      var arg$$3;
      var defaultArgs = [];
      var v10096 = funcDecl$$1.arguments;
      if (v10096) {
        var v10088 = EmitContainer.Args;
        var tempContainer = this.setContainer(v10088);
        var v17647 = funcDecl$$1.arguments;
        var v10089 = v17647.members;
        argsLen = v10089.length;
        var printLen = argsLen;
        var v10090 = funcDecl$$1.variableArgList;
        if (v10090) {
          printLen = printLen - 1;
        }
        i$$42 = 0;
        var v10095 = i$$42 < printLen;
        for (;v10095;) {
          var v17648 = funcDecl$$1.arguments;
          var v10091 = v17648.members;
          arg$$3 = v10091[i$$42];
          var v10092 = arg$$3.init;
          if (v10092) {
            defaultArgs.push(arg$$3);
          }
          var v17649 = TypeScript$$12.TokenID;
          var v10093 = v17649.OpenParen;
          this.emitJavascript(arg$$3, v10093, false);
          var v17650 = printLen - 1;
          var v10094 = i$$42 < v17650;
          if (v10094) {
            this.writeToOutput(", ");
          }
          i$$42 = i$$42 + 1;
          v10095 = i$$42 < printLen;
        }
        this.setContainer(tempContainer);
      }
      this.writeLineToOutput(") {");
      var v10102 = funcDecl$$1.isConstructor;
      if (v10102) {
        this.recordSourceMappingNameStart("constructor");
      } else {
        var v10101 = funcDecl$$1.isGetAccessor();
        if (v10101) {
          var v17651 = funcDecl$$1.getNameText();
          var v10097 = "get_" + v17651;
          this.recordSourceMappingNameStart(v10097);
        } else {
          var v10100 = funcDecl$$1.isSetAccessor();
          if (v10100) {
            var v17652 = funcDecl$$1.getNameText();
            var v10098 = "set_" + v17652;
            this.recordSourceMappingNameStart(v10098);
          } else {
            var v10099 = funcDecl$$1.getNameText();
            this.recordSourceMappingNameStart(v10099);
          }
        }
      }
      var v10103 = this.indenter;
      v10103.increaseIndent();
      i$$42 = 0;
      var v17653 = defaultArgs.length;
      var v10110 = i$$42 < v17653;
      for (;v10110;) {
        arg$$3 = defaultArgs[i$$42];
        this.emitIndent();
        this.recordSourceMappingStart(arg$$3);
        var v24699 = arg$$3.id;
        var v22330 = v24699.actualText;
        var v17654 = "if (typeof " + v22330;
        var v10104 = v17654 + ' === "undefined") { ';
        this.writeToOutput(v10104);
        var v10105 = arg$$3.id;
        this.recordSourceMappingStart(v10105);
        var v17655 = arg$$3.id;
        var v10106 = v17655.actualText;
        this.writeToOutput(v10106);
        var v10107 = arg$$3.id;
        this.recordSourceMappingEnd(v10107);
        this.writeToOutput(" = ");
        var v10108 = arg$$3.init;
        var v17656 = TypeScript$$12.TokenID;
        var v10109 = v17656.OpenParen;
        this.emitJavascript(v10108, v10109, false);
        this.writeLineToOutput("; }");
        this.recordSourceMappingEnd(arg$$3);
        i$$42 = i$$42 + 1;
        var v17657 = defaultArgs.length;
        v10110 = i$$42 < v17657;
      }
      var v17658 = funcDecl$$1.isConstructor;
      if (v17658) {
        var v24700 = funcDecl$$1.classDecl;
        var v22331 = v24700.varFlags;
        var v24701 = TypeScript$$12.VarFlags;
        var v22332 = v24701.MustCaptureThis;
        v17658 = v22331 & v22332;
      }
      var v10111 = v17658;
      if (v10111) {
        this.writeCaptureThisStatement(funcDecl$$1);
      }
      var v17659 = funcDecl$$1.isConstructor;
      if (v17659) {
        v17659 = !classPropertiesMustComeAfterSuperCall;
      }
      var v10124 = v17659;
      if (v10124) {
        var v10122 = funcDecl$$1.arguments;
        if (v10122) {
          var v17660 = funcDecl$$1.arguments;
          var v10112 = v17660.members;
          argsLen = v10112.length;
          i$$42 = 0;
          var v10121 = i$$42 < argsLen;
          for (;v10121;) {
            var v17661 = funcDecl$$1.arguments;
            var v10113 = v17661.members;
            arg$$3 = v10113[i$$42];
            var v22333 = arg$$3.varFlags;
            var v24702 = TypeScript$$12.VarFlags;
            var v22334 = v24702.Property;
            var v17662 = v22333 & v22334;
            var v22335 = TypeScript$$12.VarFlags;
            var v17663 = v22335.None;
            var v10120 = v17662 != v17663;
            if (v10120) {
              this.emitIndent();
              this.recordSourceMappingStart(arg$$3);
              var v10114 = arg$$3.id;
              this.recordSourceMappingStart(v10114);
              var v22336 = arg$$3.id;
              var v17664 = v22336.actualText;
              var v10115 = "this." + v17664;
              this.writeToOutput(v10115);
              var v10116 = arg$$3.id;
              this.recordSourceMappingEnd(v10116);
              this.writeToOutput(" = ");
              var v10117 = arg$$3.id;
              this.recordSourceMappingStart(v10117);
              var v17665 = arg$$3.id;
              var v10118 = v17665.actualText;
              this.writeToOutput(v10118);
              var v10119 = arg$$3.id;
              this.recordSourceMappingEnd(v10119);
              this.writeLineToOutput(";");
              this.recordSourceMappingEnd(arg$$3);
            }
            i$$42 = i$$42 + 1;
            v10121 = i$$42 < argsLen;
          }
        }
        var v22337 = funcDecl$$1.fncFlags;
        var v24703 = TypeScript$$12.FncFlags;
        var v22338 = v24703.ClassMethod;
        var v17666 = TypeScript$$12.hasFlag(v22337, v22338);
        var v10123 = !v17666;
        if (v10123) {
          this.emitConstructorCalls(bases$$1, classDecl$$1);
        }
      }
      if (hasSelfRef) {
        this.writeCaptureThisStatement(funcDecl$$1);
      }
      var v10135 = funcDecl$$1.variableArgList;
      if (v10135) {
        var v17667 = funcDecl$$1.arguments;
        var v10125 = v17667.members;
        argsLen = v10125.length;
        var v17668 = funcDecl$$1.arguments;
        var v10126 = v17668.members;
        var v10127 = argsLen - 1;
        var lastArg = v10126[v10127];
        this.emitIndent();
        this.recordSourceMappingStart(lastArg);
        this.writeToOutput("var ");
        var v10128 = lastArg.id;
        this.recordSourceMappingStart(v10128);
        var v17669 = lastArg.id;
        var v10129 = v17669.actualText;
        this.writeToOutput(v10129);
        var v10130 = lastArg.id;
        this.recordSourceMappingEnd(v10130);
        this.writeLineToOutput(" = [];");
        this.recordSourceMappingEnd(lastArg);
        this.emitIndent();
        this.writeToOutput("for (");
        this.recordSourceMappingStart(lastArg);
        this.writeToOutput("var _i = 0;");
        this.recordSourceMappingEnd(lastArg);
        this.writeToOutput(" ");
        this.recordSourceMappingStart(lastArg);
        var v22339 = argsLen - 1;
        var v17670 = "_i < (arguments.length - " + v22339;
        var v10131 = v17670 + ")";
        this.writeToOutput(v10131);
        this.recordSourceMappingEnd(lastArg);
        this.writeToOutput("; ");
        this.recordSourceMappingStart(lastArg);
        this.writeToOutput("_i++");
        this.recordSourceMappingEnd(lastArg);
        this.writeLineToOutput(") {");
        var v10132 = this.indenter;
        v10132.increaseIndent();
        this.emitIndent();
        this.recordSourceMappingStart(lastArg);
        var v25787 = lastArg.id;
        var v24704 = v25787.actualText;
        var v22340 = v24704 + "[_i] = arguments[_i + ";
        var v22341 = argsLen - 1;
        var v17671 = v22340 + v22341;
        var v10133 = v17671 + "];";
        this.writeToOutput(v10133);
        this.recordSourceMappingEnd(lastArg);
        this.writeLineToOutput("");
        var v10134 = this.indenter;
        v10134.decreaseIndent();
        this.emitIndent();
        this.writeLineToOutput("}");
      }
      var v22342 = funcDecl$$1.isConstructor;
      if (v22342) {
        var v24705 = funcDecl$$1.fncFlags;
        var v25788 = TypeScript$$12.FncFlags;
        var v24706 = v25788.ClassMethod;
        v22342 = TypeScript$$12.hasFlag(v24705, v24706);
      }
      var v17672 = v22342;
      if (v17672) {
        v17672 = !classPropertiesMustComeAfterSuperCall;
      }
      var v10142 = v17672;
      if (v10142) {
        var v22343 = this.thisClassNode;
        var v17673 = v22343.members;
        var v10136 = v17673.members;
        var nProps = v10136.length;
        i$$42 = 0;
        var v10141 = i$$42 < nProps;
        for (;v10141;) {
          var v26304 = this.thisClassNode;
          var v25789 = v26304.members;
          var v24707 = v25789.members;
          var v22344 = v24707[i$$42];
          var v17674 = v22344.nodeType;
          var v22345 = TypeScript$$12.NodeType;
          var v17675 = v22345.VarDecl;
          var v10140 = v17674 == v17675;
          if (v10140) {
            var v22346 = this.thisClassNode;
            var v17676 = v22346.members;
            var v10137 = v17676.members;
            var varDecl = v10137[i$$42];
            var v24708 = varDecl.varFlags;
            var v25790 = TypeScript$$12.VarFlags;
            var v24709 = v25790.Static;
            var v22347 = TypeScript$$12.hasFlag(v24708, v24709);
            var v17677 = !v22347;
            if (v17677) {
              v17677 = varDecl.init;
            }
            var v10139 = v17677;
            if (v10139) {
              this.emitIndent();
              var v17678 = TypeScript$$12.TokenID;
              var v10138 = v17678.Tilde;
              this.emitJavascriptVarDecl(varDecl, v10138);
              this.writeLineToOutput("");
            }
          }
          i$$42 = i$$42 + 1;
          v10141 = i$$42 < nProps;
        }
      }
      var v10143 = funcDecl$$1.bod;
      this.emitBareJavascriptStatements(v10143, classPropertiesMustComeAfterSuperCall);
      var v10144 = this.indenter;
      v10144.decreaseIndent();
      this.emitIndent();
      var v10145 = funcDecl$$1.endingToken;
      this.recordSourceMappingStart(v10145);
      this.writeToOutput("}");
      this.recordSourceMappingNameEnd();
      var v10146 = funcDecl$$1.endingToken;
      this.recordSourceMappingEnd(v10146);
      this.recordSourceMappingEnd(funcDecl$$1);
      if (shouldParenthesize) {
        this.writeToOutput(")");
      }
      this.recordSourceMappingEnd(funcDecl$$1);
      this.emitParensAndCommentsInPlace(funcDecl$$1, false);
      var v22348 = !isMember;
      if (v22348) {
        var v25791 = funcDecl$$1.fncFlags;
        var v26305 = TypeScript$$12.FncFlags;
        var v25792 = v26305.IsFunctionExpression;
        var v24710 = TypeScript$$12.hasFlag(v25791, v25792);
        v22348 = !v24710;
      }
      var v17679 = v22348;
      if (v17679) {
        var v24711 = funcDecl$$1.fncFlags;
        var v25793 = TypeScript$$12.FncFlags;
        var v24712 = v25793.Definition;
        var v22349 = TypeScript$$12.hasFlag(v24711, v24712);
        var v24713 = !v22349;
        if (v24713) {
          v22349 = funcDecl$$1.isConstructor;
        }
        v17679 = v22349;
      }
      var v10149 = v17679;
      if (v10149) {
        this.writeLineToOutput("");
      } else {
        var v17680 = funcDecl$$1.fncFlags;
        var v22350 = TypeScript$$12.FncFlags;
        var v17681 = v22350.IsFunctionExpression;
        var v10148 = TypeScript$$12.hasFlag(v17680, v17681);
        if (v10148) {
          var v22351 = funcDecl$$1.flags;
          var v24714 = TypeScript$$12.ASTFlags;
          var v22352 = v24714.ExplicitSemicolon;
          var v17682 = TypeScript$$12.hasFlag(v22351, v22352);
          var v22355 = !v17682;
          if (v22355) {
            var v22353 = funcDecl$$1.flags;
            var v24715 = TypeScript$$12.ASTFlags;
            var v22354 = v24715.AutomaticSemicolon;
            v17682 = TypeScript$$12.hasFlag(v22353, v22354);
          }
          var v10147 = v17682;
          if (v10147) {
            this.writeLineToOutput(";");
          }
        }
      }
      return;
    }
    function v459(bases, classDecl) {
      var v10150 = bases == null;
      if (v10150) {
        return;
      }
      var v10151 = bases.members;
      var basesLen = v10151.length;
      this.recordSourceMappingStart(classDecl);
      var i$$41 = 0;
      var v10162 = i$$41 < basesLen;
      for (;v10162;) {
        var v10152 = bases.members;
        var baseExpr = v10152[i$$41];
        var baseSymbol = null;
        var v17683 = baseExpr.nodeType;
        var v22356 = TypeScript$$12.NodeType;
        var v17684 = v22356.Call;
        var v10155 = v17683 == v17684;
        if (v10155) {
          var v17685 = baseExpr.target;
          var v10153 = v17685.type;
          baseSymbol = v10153.symbol;
        } else {
          var v10154 = baseExpr.type;
          baseSymbol = v10154.symbol;
        }
        var baseName = baseSymbol.name;
        var v17686 = baseSymbol.declModule;
        var v24716 = classDecl.type;
        var v22357 = v24716.symbol;
        var v17687 = v22357.declModule;
        var v10156 = v17686 != v17687;
        if (v10156) {
          baseName = baseSymbol.fullName();
        }
        var v17688 = baseExpr.nodeType;
        var v22358 = TypeScript$$12.NodeType;
        var v17689 = v22358.Call;
        var v10161 = v17688 == v17689;
        if (v10161) {
          this.emitIndent();
          this.writeToOutput("_super.call(this");
          var args$$5 = baseExpr.arguments;
          var v17690 = args$$5;
          if (v17690) {
            var v24717 = args$$5.members;
            var v22359 = v24717.length;
            v17690 = v22359 > 0;
          }
          var v10158 = v17690;
          if (v10158) {
            this.writeToOutput(", ");
            var v17691 = TypeScript$$12.TokenID;
            var v10157 = v17691.Comma;
            this.emitJavascriptList(args$$5, ", ", v10157, false, false, false);
          }
          this.writeToOutput(")");
        } else {
          var v17692 = baseExpr.type;
          if (v17692) {
            var v22360 = baseExpr.type;
            v17692 = v22360.isClassInstance();
          }
          var v10160 = v17692;
          if (v10160) {
            this.emitIndent();
            var v22361 = classDecl.name;
            var v17693 = v22361.actualText;
            var v10159 = v17693 + "._super.constructor";
            this.writeToOutput(v10159);
            this.writeToOutput(".call(this)");
          }
        }
        i$$41 = i$$41 + 1;
        v10162 = i$$41 < basesLen;
      }
      this.recordSourceMappingEnd(classDecl);
      return;
    }
    function v458(callNode, target$$29, args$$4) {
      var v17694 = this.emitSuperCall(callNode);
      var v10178 = !v17694;
      if (v10178) {
        var v22362 = callNode.flags;
        var v24718 = TypeScript$$12.ASTFlags;
        var v22363 = v24718.ClassBaseConstructorCall;
        var v17695 = TypeScript$$12.hasFlag(v22362, v22363);
        var v10177 = !v17695;
        if (v10177) {
          var v22364 = target$$29.nodeType;
          var v24719 = TypeScript$$12.NodeType;
          var v22365 = v24719.FuncDecl;
          var v17696 = v22364 == v22365;
          if (v17696) {
            var v22366 = target$$29.isParenthesized;
            v17696 = !v22366;
          }
          var v10163 = v17696;
          if (v10163) {
            this.writeToOutput("(");
          }
          var v24720 = callNode.target;
          var v22367 = v24720.nodeType;
          var v24721 = TypeScript$$12.NodeType;
          var v22368 = v24721.Super;
          var v17697 = v22367 == v22368;
          if (v17697) {
            var v24722 = this.emitState;
            var v22369 = v24722.container;
            var v22370 = EmitContainer.Constructor;
            v17697 = v22369 == v22370;
          }
          var v10165 = v17697;
          if (v10165) {
            this.writeToOutput("_super.call");
          } else {
            var v17698 = TypeScript$$12.TokenID;
            var v10164 = v17698.OpenParen;
            this.emitJavascript(target$$29, v10164, false);
          }
          var v22371 = target$$29.nodeType;
          var v24723 = TypeScript$$12.NodeType;
          var v22372 = v24723.FuncDecl;
          var v17699 = v22371 == v22372;
          if (v17699) {
            var v22373 = target$$29.isParenthesized;
            v17699 = !v22373;
          }
          var v10166 = v17699;
          if (v10166) {
            this.writeToOutput(")");
          }
          this.recordSourceMappingStart(args$$4);
          this.writeToOutput("(");
          var v24724 = callNode.target;
          var v22374 = v24724.nodeType;
          var v24725 = TypeScript$$12.NodeType;
          var v22375 = v24725.Super;
          var v17700 = v22374 == v22375;
          if (v17700) {
            var v24726 = this.emitState;
            var v22376 = v24726.container;
            var v22377 = EmitContainer.Constructor;
            v17700 = v22376 == v22377;
          }
          var v10168 = v17700;
          if (v10168) {
            this.writeToOutput("this");
            var v17701 = args$$4;
            if (v17701) {
              var v22378 = args$$4.members;
              v17701 = v22378.length;
            }
            var v10167 = v17701;
            if (v10167) {
              this.writeToOutput(", ");
            }
          }
          var v17702 = TypeScript$$12.TokenID;
          var v10169 = v17702.Comma;
          this.emitJavascriptList(args$$4, ", ", v10169, false, false, false);
          this.writeToOutput(")");
          this.recordSourceMappingEnd(args$$4);
        } else {
          var v10170 = this.indenter;
          v10170.decreaseIndent();
          var v10171 = this.indenter;
          v10171.decreaseIndent();
          var v10172 = TypeScript$$12.ASTList;
          var constructorCall = new v10172;
          var v10173 = constructorCall.members;
          v10173[0] = callNode;
          var v10174 = this.thisClassNode;
          this.emitConstructorCalls(constructorCall, v10174);
          var v10175 = this.indenter;
          v10175.increaseIndent();
          var v10176 = this.indenter;
          v10176.increaseIndent();
        }
      }
      return;
    }
    function v457(dotExpr$$2) {
      var v22379 = this.emitOptions;
      var v17703 = v22379.propagateConstants;
      var v10179 = !v17703;
      if (v10179) {
        return false;
      }
      var propertyName$$7 = dotExpr$$2.operand2;
      var v22380 = propertyName$$7;
      if (v22380) {
        v22380 = propertyName$$7.sym;
      }
      var v17704 = v22380;
      if (v17704) {
        var v22381 = propertyName$$7.sym;
        v17704 = v22381.isVariable();
      }
      var v10185 = v17704;
      if (v10185) {
        var v22382 = propertyName$$7.sym;
        var v17705 = v22382.flags;
        var v22383 = TypeScript$$12.SymbolFlags;
        var v17706 = v22383.Constant;
        var v10184 = TypeScript$$12.hasFlag(v17705, v17706);
        if (v10184) {
          var v17707 = propertyName$$7.sym;
          var v10183 = v17707.declAST;
          if (v10183) {
            var v10180 = propertyName$$7.sym;
            var boundDecl = v10180.declAST;
            var v17708 = boundDecl.init;
            if (v17708) {
              var v24727 = boundDecl.init;
              var v22384 = v24727.nodeType;
              var v24728 = TypeScript$$12.NodeType;
              var v22385 = v24728.NumberLit;
              v17708 = v22384 == v22385;
            }
            var v10182 = v17708;
            if (v10182) {
              var numLit = boundDecl.init;
              var v17709 = numLit.value;
              var v10181 = v17709.toString();
              this.writeToOutput(v10181);
              var comment$$1 = " /* ";
              var v17710 = propertyName$$7.actualText;
              comment$$1 = comment$$1 + v17710;
              comment$$1 = comment$$1 + " */ ";
              this.writeToOutput(comment$$1);
              return true;
            }
          }
        }
      }
      return false;
    }
    function v456(target$$28, args$$3) {
      this.writeToOutput("new ");
      var v17711 = target$$28.nodeType;
      var v22386 = TypeScript$$12.NodeType;
      var v17712 = v22386.TypeRef;
      var v10191 = v17711 == v17712;
      if (v10191) {
        var typeRef = target$$28;
        var v10188 = typeRef.arrayCount;
        if (v10188) {
          this.writeToOutput("Array()");
        } else {
          var v10186 = typeRef.term;
          var v17713 = TypeScript$$12.TokenID;
          var v10187 = v17713.Tilde;
          this.emitJavascript(v10186, v10187, false);
          this.writeToOutput("()");
        }
      } else {
        var v17714 = TypeScript$$12.TokenID;
        var v10189 = v17714.Tilde;
        this.emitJavascript(target$$28, v10189, false);
        this.recordSourceMappingStart(args$$3);
        this.writeToOutput("(");
        var v17715 = TypeScript$$12.TokenID;
        var v10190 = v17715.Comma;
        this.emitJavascriptList(args$$3, ", ", v10190, false, false, false);
        this.writeToOutput(")");
        this.recordSourceMappingEnd(args$$3);
      }
      return;
    }
    function v455(content$$3) {
      this.writeToOutput("[");
      if (content$$3) {
        this.writeLineToOutput("");
        var v10192 = this.indenter;
        v10192.increaseIndent();
        var v17716 = TypeScript$$12.TokenID;
        var v10193 = v17716.Comma;
        this.emitJavascriptList(content$$3, ", ", v10193, true, false, false);
        var v10194 = this.indenter;
        v10194.decreaseIndent();
        this.emitIndent();
      }
      this.writeToOutput("]");
      return;
    }
    function v454(content$$2) {
      this.writeLineToOutput("{");
      var v10195 = this.indenter;
      v10195.increaseIndent();
      var inObjectLiteral = this.setInObjectLiteral(true);
      var v17717 = TypeScript$$12.TokenID;
      var v10196 = v17717.Comma;
      this.emitJavascriptList(content$$2, ",", v10196, true, false, false);
      this.setInObjectLiteral(inObjectLiteral);
      var v10197 = this.indenter;
      v10197.decreaseIndent();
      this.emitIndent();
      this.writeToOutput("}");
      return;
    }
    function v453(ast$$15, pre$$10) {
      var v10198;
      if (pre$$10) {
        v10198 = ast$$15.preComments;
      } else {
        v10198 = ast$$15.postComments;
      }
      var comments$$4 = v10198;
      var v17718 = ast$$15.isParenthesized;
      if (v17718) {
        v17718 = !pre$$10;
      }
      var v10199 = v17718;
      if (v10199) {
        this.writeToOutput(")");
      }
      var v24729 = this.emitOptions;
      var v22387 = v24729.emitComments;
      if (v22387) {
        v22387 = comments$$4;
      }
      var v17719 = v22387;
      if (v17719) {
        var v22388 = comments$$4.length;
        v17719 = v22388 != 0;
      }
      var v10202 = v17719;
      if (v10202) {
        var i$$40 = 0;
        var v17720 = comments$$4.length;
        var v10201 = i$$40 < v17720;
        for (;v10201;) {
          var v10200 = comments$$4[i$$40];
          this.emitCommentInPlace(v10200);
          i$$40 = i$$40 + 1;
          var v17721 = comments$$4.length;
          v10201 = i$$40 < v17721;
        }
      }
      var v17722 = ast$$15.isParenthesized;
      if (v17722) {
        v17722 = pre$$10;
      }
      var v10203 = v17722;
      if (v10203) {
        this.writeToOutput("(");
      }
      return;
    }
    function v452(comment) {
      this.recordSourceMappingStart(comment);
      var text$$10 = comment.getText();
      var hadNewLine = false;
      var v10211 = comment.isBlockComment;
      if (v10211) {
        var v22389 = this.emitState;
        var v17723 = v22389.column;
        var v10204 = v17723 == 0;
        if (v10204) {
          this.emitIndent();
        }
        var v10205 = text$$10[0];
        this.writeToOutput(v10205);
        var v22390 = text$$10.length;
        var v17724 = v22390 > 1;
        var v22391 = !v17724;
        if (v22391) {
          v17724 = comment.endsLine;
        }
        var v10208 = v17724;
        if (v10208) {
          this.writeLineToOutput("");
          var i$$39 = 1;
          var v17725 = text$$10.length;
          var v10207 = i$$39 < v17725;
          for (;v10207;) {
            this.emitIndent();
            var v10206 = text$$10[i$$39];
            this.writeLineToOutput(v10206);
            i$$39 = i$$39 + 1;
            var v17726 = text$$10.length;
            v10207 = i$$39 < v17726;
          }
          hadNewLine = true;
        }
      } else {
        var v22392 = this.emitState;
        var v17727 = v22392.column;
        var v10209 = v17727 == 0;
        if (v10209) {
          this.emitIndent();
        }
        var v10210 = text$$10[0];
        this.writeLineToOutput(v10210);
        hadNewLine = true;
      }
      if (hadNewLine) {
        this.emitIndent();
      } else {
        this.writeToOutput(" ");
      }
      this.recordSourceMappingEnd(comment);
      return;
    }
    function v451() {
      var v10212 = this.getIndentString();
      this.writeToOutput(v10212);
      return;
    }
    function v450() {
      var v17728 = this.emitOptions;
      var v10214 = v17728.minWhitespace;
      if (v10214) {
        return "";
      } else {
        var v10213 = this.indenter;
        return v10213.getIndent();
      }
      return;
    }
    function v449(c$$5) {
      var v10215 = this.emitState;
      var temp$$9 = v10215.container;
      var v10216 = this.emitState;
      v10216.container = c$$5;
      return temp$$9;
    }
    function v448(val$$5) {
      var v10217 = this.emitState;
      var temp$$8 = v10217.inObjectLiteral;
      var v10218 = this.emitState;
      v10218.inObjectLiteral = val$$5;
      return temp$$8;
    }
    function v447(count$$3) {
      var v10219 = this.varListCountStack;
      var v22393 = this.varListCountStack;
      var v17729 = v22393.length;
      var v10220 = v17729 - 1;
      v10219[v10220] = count$$3;
      return;
    }
    function v446(ast$$14) {
      this.emitIndent();
      this.recordSourceMappingStart(ast$$14);
      var v10221 = this.captureThisStmtString;
      this.writeToOutput(v10221);
      this.recordSourceMappingEnd(ast$$14);
      this.writeLineToOutput("");
      return;
    }
    function v445(s$$12) {
      var v17730 = this.emitOptions;
      var v10226 = v17730.minWhitespace;
      if (v10226) {
        this.writeToOutput(s$$12);
        var v17731 = s$$12.length;
        var v10222 = v17731 - 1;
        var c$$4 = s$$12.charCodeAt(v10222);
        var v25794 = TypeScript$$12.LexCodeSpace;
        var v24730 = c$$4 == v25794;
        var v25796 = !v24730;
        if (v25796) {
          var v25795 = TypeScript$$12.LexCodeSMC;
          v24730 = c$$4 == v25795;
        }
        var v22394 = v24730;
        var v24732 = !v22394;
        if (v24732) {
          var v24731 = TypeScript$$12.LexCodeLBR;
          v22394 = c$$4 == v24731;
        }
        var v17732 = v22394;
        var v10223 = !v17732;
        if (v10223) {
          this.writeToOutput(" ");
        }
      } else {
        var v10224 = this.outfile;
        v10224.WriteLine(s$$12);
        var v10225 = this.emitState;
        v10225.column = 0;
        var v17733 = this.emitState;
        var v24733 = this.emitState;
        var v22395 = v24733.line;
        v17733.line = v22395 + 1;
      }
      return;
    }
    function v444(s$$11) {
      var v17734 = this.emitOptions;
      var v10227 = v17734.minWhitespace;
      if (v10227) {
        s$$11 = s$$11.replace(/[\s]*/g, "");
      }
      this.writeToOutput(s$$11);
      return;
    }
    function v443(s$$10) {
      var v10228 = this.outfile;
      v10228.Write(s$$10);
      var v10229 = this.emitState;
      var v22396 = v10229.column;
      var v22397 = s$$10.length;
      v10229.column = v22396 + v22397;
      return;
    }
    function v442(mapper) {
      var v10230 = this.allSourceMappers;
      v10230.push(mapper);
      this.sourceMapper = mapper;
      return;
    }
    function Emitter$$1(checker$$2, emittingFileName, outfile$$1, emitOptions$$1, errorReporter$$1) {
      this.checker = checker$$2;
      this.emittingFileName = emittingFileName;
      this.outfile = outfile$$1;
      this.emitOptions = emitOptions$$1;
      this.errorReporter = errorReporter$$1;
      this.prologueEmitted = false;
      this.thisClassNode = null;
      this.thisFnc = null;
      this.moduleDeclList = [];
      this.moduleName = "";
      var v27317 = new EmitState;
      this.emitState = v27317;
      var v27318 = new Indenter;
      this.indenter = v27318;
      this.ambientModule = false;
      this.modAliasId = null;
      this.firstModAlias = null;
      this.allSourceMappers = [];
      this.sourceMapper = null;
      this.captureThisStmtString = "var _this = this;";
      this.varListCountStack = [0];
      return;
    }
    var v10231 = Emitter$$1.prototype;
    v10231.setSourceMappings = v442;
    var v10232 = Emitter$$1.prototype;
    v10232.writeToOutput = v443;
    var v10233 = Emitter$$1.prototype;
    v10233.writeToOutputTrimmable = v444;
    var v10234 = Emitter$$1.prototype;
    v10234.writeLineToOutput = v445;
    var v10235 = Emitter$$1.prototype;
    v10235.writeCaptureThisStatement = v446;
    var v10236 = Emitter$$1.prototype;
    v10236.setInVarBlock = v447;
    var v10237 = Emitter$$1.prototype;
    v10237.setInObjectLiteral = v448;
    var v10238 = Emitter$$1.prototype;
    v10238.setContainer = v449;
    var v10239 = Emitter$$1.prototype;
    v10239.getIndentString = v450;
    var v10240 = Emitter$$1.prototype;
    v10240.emitIndent = v451;
    var v10241 = Emitter$$1.prototype;
    v10241.emitCommentInPlace = v452;
    var v10242 = Emitter$$1.prototype;
    v10242.emitParensAndCommentsInPlace = v453;
    var v10243 = Emitter$$1.prototype;
    v10243.emitObjectLiteral = v454;
    var v10244 = Emitter$$1.prototype;
    v10244.emitArrayLiteral = v455;
    var v10245 = Emitter$$1.prototype;
    v10245.emitNew = v456;
    var v10246 = Emitter$$1.prototype;
    v10246.tryEmitConstant = v457;
    var v10247 = Emitter$$1.prototype;
    v10247.emitCall = v458;
    var v10248 = Emitter$$1.prototype;
    v10248.emitConstructorCalls = v459;
    var v10249 = Emitter$$1.prototype;
    v10249.emitInnerFunction = v460;
    var v10250 = Emitter$$1.prototype;
    v10250.emitJavascriptModule = v461;
    var v10251 = Emitter$$1.prototype;
    v10251.emitIndex = v462;
    var v10252 = Emitter$$1.prototype;
    v10252.emitStringLiteral = v463;
    var v10253 = Emitter$$1.prototype;
    v10253.emitJavascriptFunction = v464;
    var v10254 = Emitter$$1.prototype;
    v10254.emitAmbientVarDecl = v465;
    var v10255 = Emitter$$1.prototype;
    v10255.varListCount = v466;
    var v10256 = Emitter$$1.prototype;
    v10256.emitVarDeclVar = v467;
    var v10257 = Emitter$$1.prototype;
    v10257.onEmitVar = v468;
    var v10258 = Emitter$$1.prototype;
    v10258.emitJavascriptVarDecl = v469;
    var v10259 = Emitter$$1.prototype;
    v10259.declEnclosed = v470;
    var v10260 = Emitter$$1.prototype;
    v10260.emitJavascriptName = v471;
    var v10261 = Emitter$$1.prototype;
    v10261.emitJavascriptStatements = v472;
    var v10262 = Emitter$$1.prototype;
    v10262.emitBareJavascriptStatements = v473;
    var v10263 = Emitter$$1.prototype;
    v10263.recordSourceMappingNameStart = v474;
    var v10264 = Emitter$$1.prototype;
    v10264.recordSourceMappingNameEnd = v475;
    var v10265 = Emitter$$1.prototype;
    v10265.recordSourceMappingStart = v476;
    var v10266 = Emitter$$1.prototype;
    v10266.recordSourceMappingEnd = v477;
    var v10267 = Emitter$$1.prototype;
    v10267.Close = v478;
    var v10268 = Emitter$$1.prototype;
    v10268.emitJavascriptList = v479;
    var v10269 = Emitter$$1.prototype;
    v10269.emitJavascript = v480;
    var v10270 = Emitter$$1.prototype;
    v10270.emitPropertyAccessor = v481;
    var v10271 = Emitter$$1.prototype;
    v10271.emitPrototypeMember = v482;
    var v10272 = Emitter$$1.prototype;
    v10272.emitAddBaseMethods = v484;
    var v10273 = Emitter$$1.prototype;
    v10273.emitJavascriptClass = v485;
    var v10274 = Emitter$$1.prototype;
    v10274.emitPrologue = v486;
    var v10275 = Emitter$$1.prototype;
    v10275.emitSuperReference = v487;
    var v10276 = Emitter$$1.prototype;
    v10276.emitSuperCall = v488;
    var v10277 = Emitter$$1.prototype;
    v10277.emitThis = v489;
    Emitter$$1.shouldCaptureThis = shouldCaptureThis;
    var v10278 = Emitter$$1.prototype;
    v10278.createFile = v490;
    return Emitter$$1;
  }
  function v441() {
    function v440() {
      var v10279 = Indenter$$1.indentStrings;
      var v10280 = this.indentAmt;
      var indentString = v10279[v10280];
      var v10284 = indentString === undefined;
      if (v10284) {
        indentString = "";
        var i$$38 = 0;
        var v17735 = this.indentAmt;
        var v10281 = i$$38 < v17735;
        for (;v10281;) {
          var v17736 = Indenter$$1.indentStepString;
          indentString = indentString + v17736;
          var v17737 = Indenter$$1.indentStep;
          i$$38 = i$$38 + v17737;
          var v17738 = this.indentAmt;
          v10281 = i$$38 < v17738;
        }
        var v10282 = Indenter$$1.indentStrings;
        var v10283 = this.indentAmt;
        v10282[v10283] = indentString;
      }
      return indentString;
    }
    function v439() {
      var v17739 = this.indentAmt;
      var v17740 = Indenter$$1.indentStep;
      this.indentAmt = v17739 - v17740;
      return;
    }
    function v438() {
      var v17741 = this.indentAmt;
      var v17742 = Indenter$$1.indentStep;
      this.indentAmt = v17741 + v17742;
      return;
    }
    function Indenter$$1() {
      this.indentAmt = 0;
      return;
    }
    Indenter$$1.indentStep = 4;
    Indenter$$1.indentStepString = "    ";
    Indenter$$1.indentStrings = [];
    var v10285 = Indenter$$1.prototype;
    v10285.increaseIndent = v438;
    var v10286 = Indenter$$1.prototype;
    v10286.decreaseIndent = v439;
    var v10287 = Indenter$$1.prototype;
    v10287.getIndent = v440;
    return Indenter$$1;
  }
  function v437() {
    function v436(fileName$$1, extensionChanger) {
      var v10292 = this.outputMany;
      if (v10292) {
        var updatedFileName = fileName$$1;
        var v17743 = this.outputOption;
        var v10290 = v17743 != "";
        if (v10290) {
          var v10288 = this.commonDirectoryPath;
          updatedFileName = fileName$$1.replace(v10288, "");
          var v10289 = this.outputOption;
          updatedFileName = v10289 + updatedFileName;
        }
        return extensionChanger(updatedFileName, false);
      } else {
        var v10291 = this.outputOption;
        return extensionChanger(v10291, true);
      }
      return;
    }
    function EmitOptions$$1(settings$$1) {
      this.ioHost = null;
      this.outputMany = true;
      this.commonDirectoryPath = "";
      this.minWhitespace = settings$$1.minWhitespace;
      this.propagateConstants = settings$$1.propagateConstants;
      this.emitComments = settings$$1.emitComments;
      this.outputOption = settings$$1.outputOption;
      return;
    }
    var v10293 = EmitOptions$$1.prototype;
    v10293.mapOutputFileName = v436;
    return EmitOptions$$1;
  }
  function v435() {
    function EmitState$$1() {
      this.column = 0;
      this.line = 0;
      this.pretty = false;
      this.inObjectLiteral = false;
      this.container = EmitContainer.Prog;
      return;
    }
    return EmitState$$1;
  }
  function v434(EmitContainer$$1) {
    EmitContainer$$1._map = [];
    var v10294 = EmitContainer$$1._map;
    v10294[0] = "Prog";
    EmitContainer$$1.Prog = 0;
    var v10295 = EmitContainer$$1._map;
    v10295[1] = "Module";
    EmitContainer$$1.Module = 1;
    var v10296 = EmitContainer$$1._map;
    v10296[2] = "DynamicModule";
    EmitContainer$$1.DynamicModule = 2;
    var v10297 = EmitContainer$$1._map;
    v10297[3] = "Class";
    EmitContainer$$1.Class = 3;
    var v10298 = EmitContainer$$1._map;
    v10298[4] = "Constructor";
    EmitContainer$$1.Constructor = 4;
    var v10299 = EmitContainer$$1._map;
    v10299[5] = "Function";
    EmitContainer$$1.Function = 5;
    var v10300 = EmitContainer$$1._map;
    v10300[6] = "Args";
    EmitContainer$$1.Args = 6;
    var v10301 = EmitContainer$$1._map;
    v10301[7] = "Interface";
    EmitContainer$$1.Interface = 7;
    return;
  }
  var v17744 = TypeScript$$12.EmitContainer;
  var v22398 = !v17744;
  if (v22398) {
    v17744 = TypeScript$$12.EmitContainer = {};
  }
  var v10302 = v17744;
  v434(v10302);
  var EmitContainer = TypeScript$$12.EmitContainer;
  var EmitState = v435();
  TypeScript$$12.EmitState = EmitState;
  var EmitOptions = v437();
  TypeScript$$12.EmitOptions = EmitOptions;
  var Indenter = v441();
  TypeScript$$12.Indenter = Indenter;
  var Emitter = v491();
  TypeScript$$12.Emitter = Emitter;
  return;
}
function v433(TypeScript$$11) {
  function v432() {
    function EmitSourceMapping(allSourceMappers) {
      function v431(sourceMappings) {
        var i$$37 = 0;
        var v17745 = sourceMappings.length;
        var v10308 = i$$37 < v17745;
        for (;v10308;) {
          var sourceMapping = sourceMappings[i$$37];
          var v10303 = sourceMapping.start;
          var v10304 = sourceMapping.nameIndex;
          recordSourceMapping(v10303, v10304);
          var v10305 = sourceMapping.childMappings;
          recordSourceMappingSiblings(v10305);
          var v10306 = sourceMapping.end;
          var v10307 = sourceMapping.nameIndex;
          recordSourceMapping(v10306, v10307);
          i$$37 = i$$37 + 1;
          var v17746 = sourceMappings.length;
          v10308 = i$$37 < v17746;
        }
        return;
      }
      function v430(mappedPosition, nameIndex) {
        var v22399 = recordedPosition != null;
        if (v22399) {
          var v24734 = recordedPosition.emittedColumn;
          var v24735 = mappedPosition.emittedColumn;
          v22399 = v24734 == v24735;
        }
        var v17747 = v22399;
        if (v17747) {
          var v22400 = recordedPosition.emittedLine;
          var v22401 = mappedPosition.emittedLine;
          v17747 = v22400 == v22401;
        }
        var v10309 = v17747;
        if (v10309) {
          return;
        }
        var v17748 = mappedPosition.emittedLine;
        var v10311 = prevEmittedLine !== v17748;
        if (v10311) {
          var v17749 = mappedPosition.emittedLine;
          var v10310 = prevEmittedLine < v17749;
          for (;v10310;) {
            prevEmittedColumn = 0;
            mappingsString = mappingsString + ";";
            prevEmittedLine = prevEmittedLine + 1;
            var v17750 = mappedPosition.emittedLine;
            v10310 = prevEmittedLine < v17750;
          }
          emitComma = false;
        } else {
          if (emitComma) {
            mappingsString = mappingsString + ",";
          }
        }
        var v10312 = mappingsString;
        var v17751 = TypeScript$$11.Base64VLQFormat;
        var v22402 = mappedPosition.emittedColumn;
        var v17752 = v22402 - prevEmittedColumn;
        var v10313 = v17751.encode(v17752);
        mappingsString = v10312 + v10313;
        prevEmittedColumn = mappedPosition.emittedColumn;
        var v10314 = mappingsString;
        var v17753 = TypeScript$$11.Base64VLQFormat;
        var v17754 = currentSourceIndex - prevSourceIndex;
        var v10315 = v17753.encode(v17754);
        mappingsString = v10314 + v10315;
        prevSourceIndex = currentSourceIndex;
        var v10316 = mappingsString;
        var v17755 = TypeScript$$11.Base64VLQFormat;
        var v24736 = mappedPosition.sourceLine;
        var v22403 = v24736 - 1;
        var v17756 = v22403 - prevSourceLine;
        var v10317 = v17755.encode(v17756);
        mappingsString = v10316 + v10317;
        var v10318 = mappedPosition.sourceLine;
        prevSourceLine = v10318 - 1;
        var v10319 = mappingsString;
        var v17757 = TypeScript$$11.Base64VLQFormat;
        var v22404 = mappedPosition.sourceColumn;
        var v17758 = v22404 - prevSourceColumn;
        var v10320 = v17757.encode(v17758);
        mappingsString = v10319 + v10320;
        prevSourceColumn = mappedPosition.sourceColumn;
        var v10323 = nameIndex >= 0;
        if (v10323) {
          var v10321 = mappingsString;
          var v17759 = TypeScript$$11.Base64VLQFormat;
          var v22405 = namesCount + nameIndex;
          var v17760 = v22405 - prevNameIndex;
          var v10322 = v17759.encode(v17760);
          mappingsString = v10321 + v10322;
          prevNameIndex = namesCount + nameIndex;
        }
        emitComma = true;
        recordedPosition = mappedPosition;
        return;
      }
      var sourceMapper = allSourceMappers[0];
      var v10324 = sourceMapper.jsFile;
      var v22406 = sourceMapper.jsFileName;
      var v17761 = "//@ sourceMappingURL=" + v22406;
      var v17762 = SourceMapper$$1.MapFileExtension;
      var v10325 = v17761 + v17762;
      v10324.WriteLine(v10325);
      var sourceMapOut$$1 = sourceMapper.sourceMapOut;
      var mappingsString = "";
      var tsFiles = [];
      var prevEmittedColumn = 0;
      var prevEmittedLine = 0;
      var prevSourceColumn = 0;
      var prevSourceLine = 0;
      var prevSourceIndex = 0;
      var prevNameIndex = 0;
      var namesList = [];
      var namesCount = 0;
      var emitComma = false;
      var recordedPosition = null;
      var sourceMapperIndex = 0;
      var v17763 = allSourceMappers.length;
      var v10332 = sourceMapperIndex < v17763;
      for (;v10332;) {
        sourceMapper = allSourceMappers[sourceMapperIndex];
        var currentSourceIndex = tsFiles.length;
        var v10326 = sourceMapper.tsFileName;
        tsFiles.push(v10326);
        var v22407 = sourceMapper.names;
        var v17764 = v22407.length;
        var v10329 = v17764 > 0;
        if (v10329) {
          var v10327 = namesList.push;
          var v10328 = sourceMapper.names;
          v10327.apply(namesList, v10328);
        }
        var recordSourceMapping = v430;
        var recordSourceMappingSiblings = v431;
        var v10330 = sourceMapper.sourceMappings;
        recordSourceMappingSiblings(v10330, -1);
        var v17765 = sourceMapper.names;
        var v10331 = v17765.length;
        namesCount = namesCount + v10331;
        sourceMapperIndex = sourceMapperIndex + 1;
        var v17766 = allSourceMappers.length;
        v10332 = sourceMapperIndex < v17766;
      }
      var v10334 = mappingsString != "";
      if (v10334) {
        var v22408 = sourceMapper.jsFileName;
        var v17767 = {version:3, file:v22408, sources:tsFiles, names:namesList, mappings:mappingsString};
        var v10333 = JSON2.stringify(v17767);
        sourceMapOut$$1.Write(v10333);
      }
      try {
        sourceMapOut$$1.Close();
      } catch (ex) {
        var v10335 = sourceMapper.errorReporter;
        var v10336 = ex.message;
        v10335.emitterError(null, v10336);
      }
      return;
    }
    function SourceMapper$$1(tsFileName, jsFileName, jsFile, sourceMapOut, errorReporter) {
      this.jsFile = jsFile;
      this.sourceMapOut = sourceMapOut;
      this.errorReporter = errorReporter;
      this.sourceMappings = [];
      this.currentMappings = [];
      this.names = [];
      this.currentNameIndex = [];
      var v10337 = this.currentMappings;
      var v10338 = this.sourceMappings;
      v10337.push(v10338);
      jsFileName = TypeScript$$11.switchToForwardSlashes(jsFileName);
      var v27319 = TypeScript$$11.getPrettyName(jsFileName, false, true);
      this.jsFileName = v27319;
      var v10339 = this.jsFileName;
      var removalIndex = jsFileName.lastIndexOf(v10339);
      var fixedPath = jsFileName.substring(0, removalIndex);
      var v27320 = TypeScript$$11.getRelativePathToFixedPath(fixedPath, tsFileName);
      this.tsFileName = v27320;
      return;
    }
    SourceMapper$$1.MapFileExtension = ".map";
    SourceMapper$$1.EmitSourceMapping = EmitSourceMapping;
    return SourceMapper$$1;
  }
  function v429() {
    function SourceMapping$$1() {
      var v27321 = new SourceMapPosition;
      this.start = v27321;
      var v27322 = new SourceMapPosition;
      this.end = v27322;
      this.nameIndex = -1;
      this.childMappings = [];
      return;
    }
    return SourceMapping$$1;
  }
  function v428() {
    function SourceMapPosition$$1() {
      return;
    }
    return SourceMapPosition$$1;
  }
  var SourceMapPosition = v428();
  TypeScript$$11.SourceMapPosition = SourceMapPosition;
  var SourceMapping = v429();
  TypeScript$$11.SourceMapping = SourceMapping;
  var SourceMapper = v432();
  TypeScript$$11.SourceMapper = SourceMapper;
  return;
}
function v427() {
  function v426(text$$9, reviver) {
    function v425(a$$3) {
      var v24737 = a$$3.charCodeAt(0);
      var v22409 = v24737.toString(16);
      var v17768 = "0000" + v22409;
      var v10340 = v17768.slice(-4);
      return "\\u" + v10340;
    }
    function walk$$1(holder$$1, key$$31) {
      var k$$6 = null;
      var v$$1;
      var value$$33 = holder$$1[key$$31];
      var v17769 = value$$33;
      if (v17769) {
        var v22410 = typeof value$$33;
        v17769 = v22410 === "object";
      }
      var v10343 = v17769;
      if (v10343) {
        for (k$$6 in value$$33) {
          var v22411 = Object.prototype;
          var v17770 = v22411.hasOwnProperty;
          var v10342 = v17770.call(value$$33, k$$6);
          if (v10342) {
            v$$1 = walk$$1(value$$33, k$$6);
            var v10341 = v$$1 !== undefined;
            if (v10341) {
              value$$33[k$$6] = v$$1;
            } else {
              delete value$$33[k$$6];
            }
          }
        }
      }
      return reviver.call(holder$$1, key$$31, value$$33);
    }
    var j$$2;
    text$$9 = String(text$$9);
    cx.lastIndex = 0;
    var v10344 = cx.test(text$$9);
    if (v10344) {
      text$$9 = text$$9.replace(cx, v425);
    }
    var v24738 = text$$9.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@");
    var v22412 = v24738.replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]");
    var v17771 = v22412.replace(/(?:^|:|,)(?:\s*\[)+/g, "");
    var v10347 = /^[\],:{}\s]*$/.test(v17771);
    if (v10347) {
      var v17772 = "(" + text$$9;
      var v10345 = v17772 + ")";
      j$$2 = eval(v10345);
      var v10346;
      var v22413 = typeof reviver;
      var v17774 = v22413 === "function";
      if (v17774) {
        var v17773 = {"":j$$2};
        v10346 = walk$$1(v17773, "");
      } else {
        v10346 = j$$2;
      }
      return v10346;
    }
    throw new SyntaxError("JSON.parse");
  }
  function v424(value$$32, replacer, space) {
    var i$$36;
    gap = "";
    indent$$3 = "";
    var v17775 = typeof space;
    var v10350 = v17775 === "number";
    if (v10350) {
      i$$36 = 0;
      var v10348 = i$$36 < space;
      for (;v10348;) {
        indent$$3 = indent$$3 + " ";
        i$$36 = i$$36 + 1;
        v10348 = i$$36 < space;
      }
    } else {
      var v17776 = typeof space;
      var v10349 = v17776 === "string";
      if (v10349) {
        indent$$3 = space;
      }
    }
    rep = replacer;
    var v22414 = replacer;
    if (v22414) {
      var v24739 = typeof replacer;
      v22414 = v24739 !== "function";
    }
    var v17777 = v22414;
    if (v17777) {
      var v24740 = typeof replacer;
      var v22415 = v24740 !== "object";
      var v24742 = !v22415;
      if (v24742) {
        var v25797 = replacer.length;
        var v24741 = typeof v25797;
        v22415 = v24741 !== "number";
      }
      v17777 = v22415;
    }
    var v10351 = v17777;
    if (v10351) {
      throw new Error("JSON.stringify");
    }
    var v10352 = {"":value$$32};
    return str$$6("", v10352);
  }
  function v423(key$$30) {
    return this.valueOf();
  }
  function v422(key$$29) {
    var v10353;
    var v22416 = this.valueOf();
    var v17779 = isFinite(v22416);
    if (v17779) {
      var v26761 = this.getUTCFullYear();
      var v26755 = v26761 + "-";
      var v26763 = this.getUTCMonth();
      var v26762 = v26763 + 1;
      var v26756 = f(v26762);
      var v26739 = v26755 + v26756;
      var v26713 = v26739 + "-";
      var v26740 = this.getUTCDate();
      var v26714 = f(v26740);
      var v26659 = v26713 + v26714;
      var v26548 = v26659 + "T";
      var v26660 = this.getUTCHours();
      var v26549 = f(v26660);
      var v26306 = v26548 + v26549;
      var v25798 = v26306 + ":";
      var v26307 = this.getUTCMinutes();
      var v25799 = f(v26307);
      var v24743 = v25798 + v25799;
      var v22417 = v24743 + ":";
      var v24744 = this.getUTCSeconds();
      var v22418 = f(v24744);
      var v17778 = v22417 + v22418;
      v10353 = v17778 + "Z";
    } else {
      v10353 = null;
    }
    return v10353;
  }
  function f(n$$1) {
    var v10354;
    var v17780 = n$$1 < 10;
    if (v17780) {
      v10354 = "0" + n$$1;
    } else {
      v10354 = n$$1;
    }
    return v10354;
  }
  function quote(string) {
    function v421(a$$2) {
      var c$$3 = meta[a$$2];
      var v10355;
      var v22419 = typeof c$$3;
      var v17782 = v22419 === "string";
      if (v17782) {
        v10355 = c$$3;
      } else {
        var v25800 = a$$2.charCodeAt(0);
        var v24745 = v25800.toString(16);
        var v22420 = "0000" + v24745;
        var v17781 = v22420.slice(-4);
        v10355 = "\\u" + v17781;
      }
      return v10355;
    }
    escapable.lastIndex = 0;
    var v10356;
    var v17785 = escapable.test(string);
    if (v17785) {
      var v22421 = string.replace(escapable, v421);
      var v17783 = '"' + v22421;
      v10356 = v17783 + '"';
    } else {
      var v17784 = '"' + string;
      v10356 = v17784 + '"';
    }
    return v10356;
  }
  function str$$6(key$$28, holder) {
    var i$$35;
    var k$$5 = null;
    var v;
    var length$$14;
    var mind = gap;
    var partial;
    var value$$31 = holder[key$$28];
    var v22422 = value$$31;
    if (v22422) {
      var v24746 = typeof value$$31;
      v22422 = v24746 === "object";
    }
    var v17786 = v22422;
    if (v17786) {
      var v24747 = value$$31.toJSON;
      var v22423 = typeof v24747;
      v17786 = v22423 === "function";
    }
    var v10357 = v17786;
    if (v10357) {
      value$$31 = value$$31.toJSON(key$$28);
    }
    var v17787 = typeof rep;
    var v10358 = v17787 === "function";
    if (v10358) {
      value$$31 = rep.call(holder, key$$28, value$$31);
    }
    var v10373 = typeof value$$31;
    switch(v10373) {
      case "string":
        return quote(value$$31);
      case "number":
        var v10359;
        var v17788 = isFinite(value$$31);
        if (v17788) {
          v10359 = String(value$$31);
        } else {
          v10359 = "null";
        }
        return v10359;
      case "boolean":
      ;
      case "null":
        return String(value$$31);
      case "object":
        var v10360 = !value$$31;
        if (v10360) {
          return "null";
        }
        gap = gap + indent$$3;
        partial = [];
        var v24748 = Object.prototype;
        var v22424 = v24748.toString;
        var v17789 = v22424.apply(value$$31, []);
        var v10365 = v17789 === "[object Array]";
        if (v10365) {
          length$$14 = value$$31.length;
          i$$35 = 0;
          var v10363 = i$$35 < length$$14;
          for (;v10363;) {
            var v10361 = partial;
            var v10362 = i$$35;
            var v17790 = str$$6(i$$35, value$$31);
            var v22425 = !v17790;
            if (v22425) {
              v17790 = "null";
            }
            v10361[v10362] = v17790;
            i$$35 = i$$35 + 1;
            v10363 = i$$35 < length$$14;
          }
          var v10364;
          var v22426 = partial.length;
          var v17792 = v22426 === 0;
          if (v17792) {
            v10364 = "[]";
          } else {
            var v17791;
            if (gap) {
              var v26308 = "[\n" + gap;
              var v26550 = ",\n" + gap;
              var v26309 = partial.join(v26550);
              var v25801 = v26308 + v26309;
              var v24749 = v25801 + "\n";
              var v22427 = v24749 + mind;
              v17791 = v22427 + "]";
            } else {
              var v24750 = partial.join(",");
              var v22428 = "[" + v24750;
              v17791 = v22428 + "]";
            }
            v10364 = v17791;
          }
          v = v10364;
          gap = mind;
          return v;
        }
        var v17793 = rep;
        if (v17793) {
          var v22429 = typeof rep;
          v17793 = v22429 === "object";
        }
        var v10371 = v17793;
        if (v10371) {
          length$$14 = rep.length;
          i$$35 = 0;
          var v10368 = i$$35 < length$$14;
          for (;v10368;) {
            var v22430 = rep[i$$35];
            var v17794 = typeof v22430;
            var v10367 = v17794 === "string";
            if (v10367) {
              k$$5 = rep[i$$35];
              v = str$$6(k$$5, value$$31);
              if (v) {
                var v22431 = quote(k$$5);
                var v24751;
                if (gap) {
                  v24751 = ": ";
                } else {
                  v24751 = ":";
                }
                var v22432 = v24751;
                var v17795 = v22431 + v22432;
                var v10366 = v17795 + v;
                partial.push(v10366);
              }
            }
            i$$35 = i$$35 + 1;
            v10368 = i$$35 < length$$14;
          }
        } else {
          for (k$$5 in value$$31) {
            var v22433 = Object.prototype;
            var v17796 = v22433.hasOwnProperty;
            var v10370 = v17796.call(value$$31, k$$5);
            if (v10370) {
              v = str$$6(k$$5, value$$31);
              if (v) {
                var v22434 = quote(k$$5);
                var v24752;
                if (gap) {
                  v24752 = ": ";
                } else {
                  v24752 = ":";
                }
                var v22435 = v24752;
                var v17797 = v22434 + v22435;
                var v10369 = v17797 + v;
                partial.push(v10369);
              }
            }
          }
        }
        var v10372;
        var v22436 = partial.length;
        var v17799 = v22436 === 0;
        if (v17799) {
          v10372 = "{}";
        } else {
          var v17798;
          if (gap) {
            var v26310 = "{\n" + gap;
            var v26551 = ",\n" + gap;
            var v26311 = partial.join(v26551);
            var v25802 = v26310 + v26311;
            var v24753 = v25802 + "\n";
            var v22437 = v24753 + mind;
            v17798 = v22437 + "}";
          } else {
            var v24754 = partial.join(",");
            var v22438 = "{" + v24754;
            v17798 = v22438 + "}";
          }
          v10372 = v17798;
        }
        v = v10372;
        gap = mind;
        return v;
    }
    return;
  }
  var v24755 = Date.prototype;
  var v22439 = v24755.toJSON;
  var v17800 = typeof v22439;
  var v10376 = v17800 !== "function";
  if (v10376) {
    var v10374 = Date.prototype;
    v10374.toJSON = v422;
    var strProto = String.prototype;
    var numProto = Number.prototype;
    var v10375 = Boolean.prototype;
    numProto.JSON = strProto.JSON = v10375.toJSON = v423;
  }
  var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
  var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
  var gap;
  var indent$$3;
  var meta = {"\b":"\\b", "\t":"\\t", "\n":"\\n", "\f":"\\f", "\r":"\\r", '"':'\\"', "\\":"\\\\"};
  var rep;
  var v22440 = JSON2.stringify;
  var v17801 = typeof v22440;
  var v10377 = v17801 !== "function";
  if (v10377) {
    JSON2.stringify = v424;
  }
  var v22441 = JSON2.parse;
  var v17802 = typeof v22441;
  var v10378 = v17802 !== "function";
  if (v10378) {
    JSON2.parse = v426;
  }
  return;
}
function v420(TypeScript$$10) {
  function v419() {
    function decode(inString) {
      var result$$6 = 0;
      var negative = false;
      var shift = 0;
      var i$$34 = 0;
      var v17803 = inString.length;
      var v10387 = i$$34 < v17803;
      for (;v10387;) {
        var v10379 = inString[i$$34];
        var byte = Base64Format.decodeChar(v10379);
        var v10383 = i$$34 === 0;
        if (v10383) {
          var v17804 = byte & 1;
          var v10380 = v17804 === 1;
          if (v10380) {
            negative = true;
          }
          var v10381 = byte >> 1;
          result$$6 = v10381 & 15;
        } else {
          var v17805 = byte & 31;
          var v10382 = v17805 << shift;
          result$$6 = result$$6 | v10382;
        }
        var v22442;
        var v24756 = i$$34 == 0;
        if (v24756) {
          v22442 = 4;
        } else {
          v22442 = 5;
        }
        var v17806 = v22442;
        shift = shift + v17806;
        var v17807 = byte & 32;
        var v10386 = v17807 === 32;
        if (v10386) {
        } else {
          var v17808;
          if (negative) {
            v17808 = -result$$6;
          } else {
            v17808 = result$$6;
          }
          var v10384 = v17808;
          var v17809 = i$$34 + 1;
          var v10385 = inString.substr(v17809);
          return{value:v10384, rest:v10385};
        }
        i$$34 = i$$34 + 1;
        var v17810 = inString.length;
        v10387 = i$$34 < v17810;
      }
      var v17811 = 'Base64 value "' + inString;
      var v10388 = v17811 + '" finished with a continuation bit';
      throw new Error(v10388);
    }
    function encode$$1(inValue$$1) {
      var v10390 = inValue$$1 < 0;
      if (v10390) {
        var v17812 = -inValue$$1;
        var v10389 = v17812 << 1;
        inValue$$1 = v10389 + 1;
      } else {
        inValue$$1 = inValue$$1 << 1;
      }
      var encodedStr = "";
      var v10394 = inValue$$1 > 0;
      do {
        var currentDigit = inValue$$1 & 31;
        inValue$$1 = inValue$$1 >> 5;
        var v10391 = inValue$$1 > 0;
        if (v10391) {
          currentDigit = currentDigit | 32;
        }
        var v10392 = encodedStr;
        var v10393 = Base64Format.encode(currentDigit);
        encodedStr = v10392 + v10393;
        v10394 = inValue$$1 > 0;
      } while (v10394);
      return encodedStr;
    }
    function Base64VLQFormat$$1() {
      return;
    }
    Base64VLQFormat$$1.encode = encode$$1;
    Base64VLQFormat$$1.decode = decode;
    return Base64VLQFormat$$1;
  }
  function v418() {
    function decodeChar(inChar) {
      var v17813 = inChar.length;
      var v10397 = v17813 === 1;
      if (v10397) {
        var v10395 = Base64Format$$1.encodedValues;
        return v10395.indexOf(inChar);
      } else {
        var v17814 = '"' + inChar;
        var v10396 = v17814 + '" must have length 1';
        throw TypeError(v10396);
      }
      return;
    }
    function encode(inValue) {
      var v10399 = inValue < 64;
      if (v10399) {
        var v10398 = Base64Format$$1.encodedValues;
        return v10398.charAt(inValue);
      }
      var v10400 = inValue + ": not a 64 based value";
      throw TypeError(v10400);
    }
    function Base64Format$$1() {
      return;
    }
    Base64Format$$1.encodedValues = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    Base64Format$$1.encode = encode;
    Base64Format$$1.decodeChar = decodeChar;
    return Base64Format$$1;
  }
  var Base64Format = v418();
  var Base64VLQFormat = v419();
  TypeScript$$10.Base64VLQFormat = Base64VLQFormat;
  return;
}
function v417(TypeScript$$9) {
  function v416() {
    function v415(scope$$5, table$$1) {
      function v414(key$$27, sym$$2, binder) {
        binder.bindSymbol(scope$$5, sym$$2);
        return;
      }
      table$$1.map(v414, this);
      return;
    }
    function v413(scope$$4, symbol$$2) {
      function v412(id$$7) {
        return scope$$4.find(id$$7, false, true);
      }
      var v17815 = symbol$$2.bound;
      var v10423 = !v17815;
      if (v10423) {
        var v10401 = this.checker;
        var prevLocationInfo = v10401.locationInfo;
        var v24757 = this.checker;
        var v22443 = v24757.units;
        if (v22443) {
          var v24758 = symbol$$2.unitIndex;
          v22443 = v24758 >= 0;
        }
        var v17816 = v22443;
        if (v17816) {
          var v22444 = symbol$$2.unitIndex;
          var v25803 = this.checker;
          var v24759 = v25803.units;
          var v22445 = v24759.length;
          v17816 = v22444 < v22445;
        }
        var v10403 = v17816;
        if (v10403) {
          var v10402 = this.checker;
          var v22446 = this.checker;
          var v17817 = v22446.units;
          var v17818 = symbol$$2.unitIndex;
          v10402.locationInfo = v17817[v17818];
        }
        var v10421 = symbol$$2.kind();
        switch(v10421) {
          case TypeScript$$9.SymbolKind.Type:
            var v17819 = symbol$$2.flags;
            var v22447 = TypeScript$$9.SymbolFlags;
            var v17820 = v22447.Bound;
            var v10404 = v17819 & v17820;
            if (v10404) {
              break;
            }
            var typeSymbol = symbol$$2;
            var v17821 = typeSymbol.flags;
            var v22448 = TypeScript$$9.SymbolFlags;
            var v17822 = v22448.Bound;
            typeSymbol.flags = v17821 | v17822;
            var v22449 = typeSymbol.aliasLink;
            if (v22449) {
              var v24760 = typeSymbol.type;
              v22449 = !v24760;
            }
            var v17823 = v22449;
            if (v17823) {
              var v25804 = typeSymbol.aliasLink;
              var v24761 = v25804.alias;
              var v22450 = v24761.nodeType;
              var v24762 = TypeScript$$9.NodeType;
              var v22451 = v24762.Name;
              v17823 = v22450 == v22451;
            }
            var v10409 = v17823;
            if (v10409) {
              var v17824 = typeSymbol.aliasLink;
              var v10405 = v17824.alias;
              var modPath = v10405.text;
              var v10406 = this.checker;
              var v22452 = this.checker;
              var v17825 = v22452.locationInfo;
              var v10407 = v17825.filename;
              var modSym = v10406.findSymbolForDynamicModule(modPath, v10407, v412);
              if (modSym) {
                var v10408 = typeSymbol;
                var v27323 = modSym.getType();
                v10408.type = v27323;
              }
            }
            var v17826 = typeSymbol.type;
            if (v17826) {
              var v22453 = typeSymbol.type;
              var v24763 = this.checker;
              var v22454 = v24763.gloModType;
              v17826 = v22453 != v22454;
            }
            var v10416 = v17826;
            if (v10416) {
              var v10410 = typeSymbol.type;
              var v10411 = typeSymbol.instanceType;
              this.bindType(scope$$4, v10410, v10411);
              var v17827 = typeSymbol.type;
              var v10415 = v17827.isModuleType();
              if (v10415) {
                var i$$33 = 0;
                var v22455 = typeSymbol.expansions;
                var v17828 = v22455.length;
                var v10414 = i$$33 < v17828;
                for (;v10414;) {
                  var v17829 = typeSymbol.expansions;
                  var v10412 = v17829[i$$33];
                  var v10413 = typeSymbol.instanceType;
                  this.bindType(scope$$4, v10412, v10413);
                  i$$33 = i$$33 + 1;
                  var v22456 = typeSymbol.expansions;
                  var v17830 = v22456.length;
                  v10414 = i$$33 < v17830;
                }
              }
            }
            break;
          case TypeScript$$9.SymbolKind.Field:
            var v10417 = this.checker;
            var v17831 = symbol$$2.field;
            var v10418 = v17831.typeLink;
            v10417.resolveTypeLink(scope$$4, v10418, false);
            break;
          case TypeScript$$9.SymbolKind.Parameter:
            var v10419 = this.checker;
            var v17832 = symbol$$2.parameter;
            var v10420 = v17832.typeLink;
            v10419.resolveTypeLink(scope$$4, v10420, true);
        }
        var v10422 = this.checker;
        v10422.locationInfo = prevLocationInfo;
      }
      symbol$$2.bound = true;
      return;
    }
    function v411(scope$$3, type$$26, instanceType$$1) {
      if (instanceType$$1) {
        this.bindType(scope$$3, instanceType$$1, null);
      }
      var v10439 = type$$26.hasMembers();
      if (v10439) {
        var members$$5 = type$$26.members;
        var ambientMembers = type$$26.ambientMembers;
        var typeMembers = type$$26.getAllEnclosedTypes();
        var ambientTypeMembers = type$$26.getAllAmbientEnclosedTypes();
        var v10424 = TypeScript$$9.SymbolTableScope;
        var v10425 = type$$26.symbol;
        var memberScope = new v10424(members$$5, ambientMembers, typeMembers, ambientTypeMembers, v10425);
        var v10426 = TypeScript$$9.SymbolAggregateScope;
        var v10427 = type$$26.symbol;
        var agg = new v10426(v10427);
        var v10428 = this.checker;
        var prevCurrentModDecl = v10428.currentModDecl;
        var v10429 = this.checker;
        var prevBindStatus = v10429.inBind;
        agg.addParentScope(memberScope);
        agg.addParentScope(scope$$3);
        var v10432 = type$$26.isModuleType();
        if (v10432) {
          var v10430 = this.checker;
          var v17833 = type$$26.symbol;
          v10430.currentModDecl = v17833.declAST;
          var v10431 = this.checker;
          v10431.inBind = true;
        }
        if (members$$5) {
          var v17834 = type$$26.members;
          var v10433 = v17834.allMembers;
          this.bind(agg, v10433);
        }
        if (typeMembers) {
          var v10434 = typeMembers.allMembers;
          this.bind(agg, v10434);
        }
        if (ambientMembers) {
          var v10435 = ambientMembers.allMembers;
          this.bind(agg, v10435);
        }
        if (ambientTypeMembers) {
          var v10436 = ambientTypeMembers.allMembers;
          this.bind(agg, v10436);
        }
        var v10437 = this.checker;
        v10437.currentModDecl = prevCurrentModDecl;
        var v10438 = this.checker;
        v10438.inBind = prevBindStatus;
      }
      var v10440 = type$$26.extendsTypeLinks;
      if (v10440) {
        this.resolveBases(scope$$3, type$$26);
      }
      var v10442 = type$$26.construct;
      if (v10442) {
        var v10441 = type$$26.construct;
        this.resolveSignatureGroup(v10441, scope$$3, instanceType$$1);
      }
      var v10444 = type$$26.call;
      if (v10444) {
        var v10443 = type$$26.call;
        this.resolveSignatureGroup(v10443, scope$$3, null);
      }
      var v10446 = type$$26.index;
      if (v10446) {
        var v10445 = type$$26.index;
        this.resolveSignatureGroup(v10445, scope$$3, null);
      }
      var v10448 = type$$26.elementType;
      if (v10448) {
        var v10447 = type$$26.elementType;
        this.bindType(scope$$3, v10447, null);
      }
      return;
    }
    function v410(signatureGroup, scope$$2, instanceType) {
      var v10449 = signatureGroup.hasImplementation;
      var supplyVar = !v10449;
      var i$$32 = 0;
      var v10450 = signatureGroup.signatures;
      var len$$9 = v10450.length;
      var v10464 = i$$32 < len$$9;
      for (;v10464;) {
        var v10451 = signatureGroup.signatures;
        var signature = v10451[i$$32];
        if (instanceType) {
          var v10452 = signature.returnType;
          v10452.type = instanceType;
        } else {
          var v10453 = this.checker;
          var v10454 = signature.returnType;
          v10453.resolveTypeLink(scope$$2, v10454, supplyVar);
        }
        var v10455 = signature.parameters;
        var paramLen = v10455.length;
        var j$$1 = 0;
        var v10457 = j$$1 < paramLen;
        for (;v10457;) {
          var v17835 = signature.parameters;
          var v10456 = v17835[j$$1];
          this.bindSymbol(scope$$2, v10456);
          j$$1 = j$$1 + 1;
          v10457 = j$$1 < paramLen;
        }
        var v10463 = signature.hasVariableArgList;
        if (v10463) {
          var v10458 = signature.parameters;
          var v10459 = paramLen - 1;
          var lastParam = v10458[v10459];
          lastParam.argsOffset = paramLen - 1;
          var v22457 = lastParam.getType();
          var v17836 = v22457.isArray();
          var v10462 = !v17836;
          if (v10462) {
            var v17837 = this.checker;
            var v10460 = v17837.errorReporter;
            v10460.simpleErrorFromSym(lastParam, "... parameter must have array type");
            var v17838 = lastParam.parameter;
            var v10461 = v17838.typeLink;
            var v17839 = this.checker;
            var v24764 = lastParam.parameter;
            var v22458 = v24764.typeLink;
            var v17840 = v22458.type;
            var v27324 = v17839.makeArrayType(v17840);
            v10461.type = v27324;
          }
        }
        i$$32 = i$$32 + 1;
        v10464 = i$$32 < len$$9;
      }
      return;
    }
    function v409(scope$$1, type$$25) {
      var v10465 = type$$25;
      var v17841 = type$$25.extendsTypeLinks;
      var v27325 = this.resolveBaseTypeLinks(v17841, scope$$1);
      v10465.extendsList = v27325;
      var i$$31 = 0;
      var v10466 = type$$25.extendsList;
      var len$$8 = v10466.length;
      var derivedIsClass = type$$25.isClassInstance();
      var v10475 = i$$31 < len$$8;
      for (;v10475;) {
        var v17842 = type$$25.extendsList;
        var v10467 = v17842[i$$31];
        var baseIsClass = v10467.isClassInstance();
        var v22459 = type$$25.extendsList;
        var v17843 = v22459[i$$31];
        var v22460 = this.checker;
        var v17844 = v22460.anyType;
        var v10474 = v17843 != v17844;
        if (v10474) {
          var v17845 = type$$25.extendsTypeLinks;
          var v10468 = v17845[i$$31];
          var baseRef = v10468.ast;
          if (derivedIsClass) {
            var v10471 = !baseIsClass;
            if (v10471) {
              var v17846 = this.checker;
              var v10469 = v17846.errorReporter;
              var v26312 = type$$25.extendsList;
              var v25805 = v26312[i$$31];
              var v24765 = v25805.symbol;
              var v22461 = v24765.fullName();
              var v17847 = "A class may only extend other classes, " + v22461;
              var v10470 = v17847 + " is not a class.";
              v10469.simpleError(baseRef, v10470);
            }
          } else {
            if (baseIsClass) {
              var v17848 = this.checker;
              var v10472 = v17848.errorReporter;
              var v26313 = type$$25.extendsList;
              var v25806 = v26313[i$$31];
              var v24766 = v25806.symbol;
              var v22462 = v24766.fullName();
              var v17849 = "An interface may only extend other interfaces, " + v22462;
              var v10473 = v17849 + " is a class.";
              v10472.simpleError(baseRef, v10473);
            }
          }
        }
        i$$31 = i$$31 + 1;
        v10475 = i$$31 < len$$8;
      }
      var v10476 = type$$25;
      var v17850 = type$$25.implementsTypeLinks;
      var v27326 = this.resolveBaseTypeLinks(v17850, scope$$1);
      v10476.implementsList = v27326;
      var v10483 = type$$25.implementsList;
      if (v10483) {
        i$$31 = 0;
        var v17851 = type$$25.implementsList;
        len$$8 = v17851.length;
        var v10482 = i$$31 < len$$8;
        for (;v10482;) {
          var v10477 = type$$25.implementsList;
          var iface = v10477[i$$31];
          var v17852 = type$$25.implementsTypeLinks;
          var v10478 = v17852[i$$31];
          baseRef = v10478.ast;
          var v10481 = iface.isClassInstance();
          if (v10481) {
            if (derivedIsClass) {
              var v17853 = this.checker;
              var v10479 = v17853.errorReporter;
              var v24767 = iface.symbol;
              var v22463 = v24767.fullName();
              var v17854 = "A class may only implement an interface; " + v22463;
              var v10480 = v17854 + " is a class.";
              v10479.simpleError(baseRef, v10480);
            }
          }
          i$$31 = i$$31 + 1;
          v10482 = i$$31 < len$$8;
        }
      }
      return;
    }
    function v408(typeLinks, scope) {
      var extendsList$$3 = null;
      if (typeLinks) {
        extendsList$$3 = new Array;
        var i$$30 = 0;
        var len$$7 = typeLinks.length;
        var v10486 = i$$30 < len$$7;
        for (;v10486;) {
          var v10484 = extendsList$$3;
          var v10485 = i$$30;
          var v17855 = this.checker;
          var v17856 = typeLinks[i$$30];
          var v27327 = v17855.resolveBaseTypeLink(v17856, scope);
          v10484[v10485] = v27327;
          i$$30 = i$$30 + 1;
          v10486 = i$$30 < len$$7;
        }
      }
      return extendsList$$3;
    }
    function Binder$$1(checker$$1) {
      this.checker = checker$$1;
      return;
    }
    var v10487 = Binder$$1.prototype;
    v10487.resolveBaseTypeLinks = v408;
    var v10488 = Binder$$1.prototype;
    v10488.resolveBases = v409;
    var v10489 = Binder$$1.prototype;
    v10489.resolveSignatureGroup = v410;
    var v10490 = Binder$$1.prototype;
    v10490.bindType = v411;
    var v10491 = Binder$$1.prototype;
    v10491.bindSymbol = v413;
    var v10492 = Binder$$1.prototype;
    v10492.bind = v415;
    return Binder$$1;
  }
  var Binder = v416();
  TypeScript$$9.Binder = Binder;
  return;
}
function v407(TypeScript$$8) {
  function v406() {
    function v405(script$$6, position$$1) {
      var lineInfo = {line:-1, col:-1};
      var v17857 = script$$6.locationInfo;
      var v10493 = v17857.lineMap;
      TypeScript$$8.getSourceLineColFromMap(lineInfo, position$$1, v10493);
      var v17858 = lineInfo.col;
      var v10494 = v17858 !== -1;
      if (v10494) {
        var v17859 = lineInfo.col;
        lineInfo.col = v17859 + 1;
      }
      var v24768 = lineInfo.line;
      var v22464 = "(" + v24768;
      var v17860 = v22464 + ", ";
      var v17861 = lineInfo.col;
      var v10495 = v17860 + v17861;
      return v10495 + ")";
    }
    function v404(s$$9, targetLength, paddingString, leftPadding) {
      var v10496;
      if (leftPadding) {
        v10496 = "";
      } else {
        v10496 = s$$9;
      }
      var result$$5 = v10496;
      var i$$29 = s$$9.length;
      var v10497 = i$$29 < targetLength;
      for (;v10497;) {
        result$$5 = result$$5 + paddingString;
        i$$29 = i$$29 + 1;
        v10497 = i$$29 < targetLength;
      }
      var v17862;
      if (leftPadding) {
        v17862 = s$$9;
      } else {
        v17862 = "";
      }
      var v10498 = v17862;
      result$$5 = result$$5 + v10498;
      return result$$5;
    }
    function v403(linemap) {
      var result$$4 = "[";
      var i$$28 = 0;
      var v17863 = linemap.length;
      var v10500 = i$$28 < v17863;
      for (;v10500;) {
        var v10499 = i$$28 > 0;
        if (v10499) {
          result$$4 = result$$4 + ",";
        }
        var v17864 = linemap[i$$28];
        result$$4 = result$$4 + v17864;
        i$$28 = i$$28 + 1;
        var v17865 = linemap.length;
        v10500 = i$$28 < v17865;
      }
      result$$4 = result$$4 + "]";
      var v10501 = this.logger;
      var v10502 = "linemap: " + result$$4;
      v10501.log(v10502);
      return;
    }
    function v402(script$$5, comments$$3, indent$$2) {
      var v10503 = comments$$3 == null;
      if (v10503) {
        return;
      }
      var i$$27 = 0;
      var v17866 = comments$$3.length;
      var v10505 = i$$27 < v17866;
      for (;v10505;) {
        var v10504 = comments$$3[i$$27];
        this.logNode(script$$5, v10504, indent$$2);
        i$$27 = i$$27 + 1;
        var v17867 = comments$$3.length;
        v10505 = i$$27 < v17867;
      }
      return;
    }
    function v401(script$$4, cur$$8, indent$$1) {
      var msg = this.addPadding("", indent$$1, "| ", true);
      var v17868 = cur$$8.treeViewLabel();
      var v10506 = "+ " + v17868;
      msg = msg.concat(v10506);
      msg = this.addPadding(msg, 70, " ", false);
      var v10507 = msg;
      var v17869 = cur$$8.minChar;
      var v10508 = this.addLineColumn(script$$4, v17869);
      msg = v10507 + v10508;
      msg = this.addPadding(msg, 80, " ", false);
      msg = msg + "=> ";
      var v10509 = msg;
      var v17870 = cur$$8.limChar;
      var v10510 = this.addLineColumn(script$$4, v17870);
      msg = v10509 + v10510;
      msg = this.addPadding(msg, 102, " ", false);
      var v26552 = cur$$8.minChar;
      var v26314 = v26552.toString();
      var v25807 = this.addPadding(v26314, 1, " ", true);
      var v24769 = "[" + v25807;
      var v22465 = v24769 + ", ";
      var v25808 = cur$$8.limChar;
      var v24770 = v25808.toString();
      var v22466 = this.addPadding(v24770, 1, " ", true);
      var v17871 = v22465 + v22466;
      var v10511 = v17871 + "]";
      msg = msg.concat(v10511);
      msg = this.addPadding(msg, 115, " ", false);
      var v17872 = cur$$8.sym;
      var v10512 = "sym=" + v17872;
      msg = msg.concat(v10512);
      msg = this.addPadding(msg, 135, " ", false);
      var v22467;
      var v25809 = cur$$8.type;
      var v24772 = v25809 === null;
      if (v24772) {
        v22467 = "null";
      } else {
        var v24771 = cur$$8.type;
        v22467 = v24771.getTypeName();
      }
      var v17873 = v22467;
      var v10513 = "type=" + v17873;
      msg = msg.concat(v10513);
      var v10514 = this.logger;
      v10514.log(msg);
      return;
    }
    function v400(script$$3) {
      function post$$6(cur$$7, parent$$42) {
        stack.pop();
        return cur$$7;
      }
      function pre$$9(cur$$6, parent$$41) {
        stack.push(cur$$6);
        var v17874 = stack.length;
        var v10515 = v17874 - 1;
        var indent = v10515 * 2;
        var v10516 = cur$$6.preComments;
        _this.logComments(script$$3, v10516, indent);
        _this.logNode(script$$3, cur$$6, indent);
        var v10517 = cur$$6.postComments;
        _this.logComments(script$$3, v10517, indent);
        return cur$$6;
      }
      var _this = this;
      var v17875 = script$$3.locationInfo;
      var v10518 = v17875.lineMap;
      this.logLinemap(v10518);
      var stack = [];
      var v10519 = TypeScript$$8.getAstWalkerFactory();
      v10519.walk(script$$3, pre$$9, post$$6);
      return;
    }
    function AstLogger$$1(logger) {
      this.logger = logger;
      return;
    }
    var v10520 = AstLogger$$1.prototype;
    v10520.logScript = v400;
    var v10521 = AstLogger$$1.prototype;
    v10521.logNode = v401;
    var v10522 = AstLogger$$1.prototype;
    v10522.logComments = v402;
    var v10523 = AstLogger$$1.prototype;
    v10523.logLinemap = v403;
    var v10524 = AstLogger$$1.prototype;
    v10524.addPadding = v404;
    var v10525 = AstLogger$$1.prototype;
    v10525.addLineColumn = v405;
    return AstLogger$$1;
  }
  var AstLogger = v406();
  TypeScript$$8.AstLogger = AstLogger;
  return;
}
function v399(TypeScript$$7) {
  function v398(GetAstPathOptions$$1) {
    GetAstPathOptions$$1._map = [];
    GetAstPathOptions$$1.Default = 0;
    GetAstPathOptions$$1.EdgeInclusive = 1;
    GetAstPathOptions$$1.DontPruneSearchBasedOnPosition = 1 << 1;
    return;
  }
  function v397() {
    function AstPathContext$$1() {
      var v10526 = TypeScript$$7.AstPath;
      var v27328 = new v10526;
      this.path = v27328;
      return;
    }
    return AstPathContext$$1;
  }
  function v396() {
    function v395() {
      var v22468 = this.count();
      var v17876 = v22468 >= 1;
      if (v17876) {
        var v25810 = this.asts;
        var v26315 = this.top;
        var v25811 = v26315 - 0;
        var v24773 = v25810[v25811];
        var v22469 = v24773.nodeType;
        var v24774 = TypeScript$$7.NodeType;
        var v22470 = v24774.Block;
        v17876 = v22469 === v22470;
      }
      var v10527 = v17876;
      if (v10527) {
        var v24775 = this.asts;
        var v25812 = this.top;
        var v24776 = v25812 - 0;
        var v22471 = v24775[v24776];
        var v17877 = v22471.isStatementBlock;
        v10527 = v17877 === false;
      }
      return v10527;
    }
    function v394() {
      var v24777 = this.count();
      var v22472 = v24777 >= 2;
      if (v22472) {
        var v26316 = this.asts;
        var v26553 = this.top;
        var v26317 = v26553 - 0;
        var v25813 = v26316[v26317];
        var v24778 = v25813.nodeType;
        var v25814 = TypeScript$$7.NodeType;
        var v24779 = v25814.List;
        v22472 = v24778 === v24779;
      }
      var v17878 = v22472;
      if (v17878) {
        var v25815 = this.asts;
        var v26318 = this.top;
        var v25816 = v26318 - 1;
        var v24780 = v25815[v25816];
        var v22473 = v24780.nodeType;
        var v24781 = TypeScript$$7.NodeType;
        var v22474 = v24781.New;
        v17878 = v22473 === v22474;
      }
      var v10528 = v17878;
      if (v10528) {
        var v24782 = this.asts;
        var v25817 = this.top;
        var v24783 = v25817 - 1;
        var v22475 = v24782[v24783];
        var v17879 = v22475.arguments;
        var v22476 = this.asts;
        var v24784 = this.top;
        var v22477 = v24784 - 0;
        var v17880 = v22476[v22477];
        v10528 = v17879 === v17880;
      }
      return v10528;
    }
    function v393() {
      var v24785 = this.count();
      var v22478 = v24785 >= 2;
      if (v22478) {
        var v26319 = this.asts;
        var v26554 = this.top;
        var v26320 = v26554 - 0;
        var v25818 = v26319[v26320];
        var v24786 = v25818.nodeType;
        var v25819 = TypeScript$$7.NodeType;
        var v24787 = v25819.List;
        v22478 = v24786 === v24787;
      }
      var v17881 = v22478;
      if (v17881) {
        var v25820 = this.asts;
        var v26321 = this.top;
        var v25821 = v26321 - 1;
        var v24788 = v25820[v25821];
        var v22479 = v24788.nodeType;
        var v24789 = TypeScript$$7.NodeType;
        var v22480 = v24789.Call;
        v17881 = v22479 === v22480;
      }
      var v10529 = v17881;
      if (v10529) {
        var v24790 = this.asts;
        var v25822 = this.top;
        var v24791 = v25822 - 1;
        var v22481 = v24790[v24791];
        var v17882 = v22481.arguments;
        var v22482 = this.asts;
        var v24792 = this.top;
        var v22483 = v24792 - 0;
        var v17883 = v22482[v22483];
        v10529 = v17882 === v17883;
      }
      return v10529;
    }
    function v392() {
      var v24793 = this.count();
      var v22484 = v24793 >= 3;
      if (v22484) {
        var v26322 = this.asts;
        var v26555 = this.top;
        var v26323 = v26555 - 1;
        var v25823 = v26322[v26323];
        var v24794 = v25823.nodeType;
        var v25824 = TypeScript$$7.NodeType;
        var v24795 = v25824.List;
        v22484 = v24794 === v24795;
      }
      var v17884 = v22484;
      if (v17884) {
        var v25825 = this.asts;
        var v26324 = this.top;
        var v25826 = v26324 - 2;
        var v24796 = v25825[v25826];
        var v22485 = v24796.nodeType;
        var v24797 = TypeScript$$7.NodeType;
        var v22486 = v24797.FuncDecl;
        v17884 = v22485 === v22486;
      }
      var v10530 = v17884;
      if (v10530) {
        var v24798 = this.asts;
        var v25827 = this.top;
        var v24799 = v25827 - 2;
        var v22487 = v24798[v24799];
        var v17885 = v22487.arguments;
        var v22488 = this.asts;
        var v24800 = this.top;
        var v22489 = v24800 - 1;
        var v17886 = v22488[v22489];
        v10530 = v17885 === v17886;
      }
      return v10530;
    }
    function v391() {
      var v24801 = this.count();
      var v22490 = v24801 >= 2;
      if (v22490) {
        var v26325 = this.asts;
        var v26556 = this.top;
        var v26326 = v26556 - 0;
        var v25828 = v26325[v26326];
        var v24802 = v25828.nodeType;
        var v25829 = TypeScript$$7.NodeType;
        var v24803 = v25829.List;
        v22490 = v24802 === v24803;
      }
      var v17887 = v22490;
      if (v17887) {
        var v25830 = this.asts;
        var v26327 = this.top;
        var v25831 = v26327 - 1;
        var v24804 = v25830[v25831];
        var v22491 = v24804.nodeType;
        var v24805 = TypeScript$$7.NodeType;
        var v22492 = v24805.FuncDecl;
        v17887 = v22491 === v22492;
      }
      var v10531 = v17887;
      if (v10531) {
        var v24806 = this.asts;
        var v25832 = this.top;
        var v24807 = v25832 - 1;
        var v22493 = v24806[v24807];
        var v17888 = v22493.arguments;
        var v22494 = this.asts;
        var v24808 = this.top;
        var v22495 = v24808 - 0;
        var v17889 = v22494[v22495];
        v10531 = v17888 === v17889;
      }
      return v10531;
    }
    function v390() {
      var v22496 = this.count();
      var v17890 = v22496 >= 1;
      if (v17890) {
        var v25833 = this.asts;
        var v25834 = this.top;
        var v24809 = v25833[v25834];
        var v22497 = v24809.nodeType;
        var v24810 = TypeScript$$7.NodeType;
        var v22498 = v24810.List;
        v17890 = v22497 === v22498;
      }
      var v10532 = v17890;
      if (v10532) {
        var v25835 = this.asts;
        var v25836 = this.top;
        var v24811 = v25835[v25836];
        var v22499 = v24811.members;
        var v17891 = v22499.length;
        v10532 = v17891 === 1;
      }
      return v10532;
    }
    function v389() {
      return this.isBodyOfCase();
    }
    function v388() {
      var v22500 = this.count();
      var v17892 = v22500 >= 2;
      if (v17892) {
        var v25837 = this.asts;
        var v26328 = this.top;
        var v25838 = v26328 - 1;
        var v24812 = v25837[v25838];
        var v22501 = v24812.nodeType;
        var v24813 = TypeScript$$7.NodeType;
        var v22502 = v24813.If;
        v17892 = v22501 === v22502;
      }
      var v10533 = v17892;
      if (v10533) {
        var v24814 = this.asts;
        var v25839 = this.top;
        var v24815 = v25839 - 1;
        var v22503 = v24814[v24815];
        var v17893 = v22503.elseBod;
        var v22504 = this.asts;
        var v24816 = this.top;
        var v22505 = v24816 - 0;
        var v17894 = v22504[v22505];
        v10533 = v17893 == v17894;
      }
      return v10533;
    }
    function v387() {
      var v22506 = this.count();
      var v17895 = v22506 >= 2;
      if (v17895) {
        var v25840 = this.asts;
        var v26329 = this.top;
        var v25841 = v26329 - 1;
        var v24817 = v25840[v25841];
        var v22507 = v24817.nodeType;
        var v24818 = TypeScript$$7.NodeType;
        var v22508 = v24818.If;
        v17895 = v22507 === v22508;
      }
      var v10534 = v17895;
      if (v10534) {
        var v24819 = this.asts;
        var v25842 = this.top;
        var v24820 = v25842 - 1;
        var v22509 = v24819[v24820];
        var v17896 = v22509.thenBod;
        var v22510 = this.asts;
        var v24821 = this.top;
        var v22511 = v24821 - 0;
        var v17897 = v22510[v22511];
        v10534 = v17896 == v17897;
      }
      return v10534;
    }
    function v386() {
      var v17898 = this.count();
      var v10535 = v17898 >= 2;
      if (v10535) {
        var v24822 = this.asts;
        var v25843 = this.top;
        var v24823 = v25843 - 1;
        var v22512 = v24822[v24823];
        var v17899 = v22512.nodeType;
        var v22513 = TypeScript$$7.NodeType;
        var v17900 = v22513.List;
        v10535 = v17899 === v17900;
      }
      return v10535;
    }
    function v385() {
      var v22514 = this.count();
      var v17901 = v22514 >= 2;
      if (v17901) {
        var v25844 = this.asts;
        var v26330 = this.top;
        var v25845 = v26330 - 1;
        var v24824 = v25844[v25845];
        var v22515 = v24824.nodeType;
        var v24825 = TypeScript$$7.NodeType;
        var v22516 = v24825.Member;
        v17901 = v22515 === v22516;
      }
      var v10536 = v17901;
      if (v10536) {
        var v24826 = this.asts;
        var v25846 = this.top;
        var v24827 = v25846 - 1;
        var v22517 = v24826[v24827];
        var v17902 = v22517.operand2;
        var v22518 = this.asts;
        var v24828 = this.top;
        var v22519 = v24828 - 0;
        var v17903 = v22518[v22519];
        v10536 = v17902 === v17903;
      }
      return v10536;
    }
    function v384() {
      var v22520 = this.count();
      var v17904 = v22520 >= 2;
      if (v17904) {
        var v25847 = this.asts;
        var v26331 = this.top;
        var v25848 = v26331 - 1;
        var v24829 = v25847[v25848];
        var v22521 = v24829.nodeType;
        var v24830 = TypeScript$$7.NodeType;
        var v22522 = v24830.Member;
        v17904 = v22521 === v22522;
      }
      var v10537 = v17904;
      if (v10537) {
        var v24831 = this.asts;
        var v25849 = this.top;
        var v24832 = v25849 - 1;
        var v22523 = v24831[v24832];
        var v17905 = v22523.operand1;
        var v22524 = this.asts;
        var v24833 = this.top;
        var v22525 = v24833 - 0;
        var v17906 = v22524[v22525];
        v10537 = v17905 === v17906;
      }
      return v10537;
    }
    function v383() {
      var v24834 = this.count();
      var v22526 = v24834 >= 2;
      if (v22526) {
        var v26332 = this.asts;
        var v26557 = this.top;
        var v26333 = v26557 - 1;
        var v25850 = v26332[v26333];
        var v24835 = v25850.nodeType;
        var v25851 = TypeScript$$7.NodeType;
        var v24836 = v25851.ArrayLit;
        v22526 = v24835 === v24836;
      }
      var v17907 = v22526;
      if (v17907) {
        var v25852 = this.asts;
        var v26334 = this.top;
        var v25853 = v26334 - 0;
        var v24837 = v25852[v25853];
        var v22527 = v24837.nodeType;
        var v24838 = TypeScript$$7.NodeType;
        var v22528 = v24838.List;
        v17907 = v22527 === v22528;
      }
      var v10538 = v17907;
      if (v10538) {
        var v24839 = this.asts;
        var v25854 = this.top;
        var v24840 = v25854 - 1;
        var v22529 = v24839[v24840];
        var v17908 = v22529.operand;
        var v22530 = this.asts;
        var v24841 = this.top;
        var v22531 = v24841 - 0;
        var v17909 = v22530[v22531];
        v10538 = v17908 == v17909;
      }
      return v10538;
    }
    function v382() {
      var v26335 = this.count();
      var v25855 = v26335 >= 4;
      if (v25855) {
        var v26661 = this.asts;
        var v26715 = this.top;
        var v26662 = v26715 - 3;
        var v26558 = v26661[v26662];
        var v26336 = v26558.nodeType;
        var v26559 = TypeScript$$7.NodeType;
        var v26337 = v26559.ObjectLit;
        v25855 = v26336 === v26337;
      }
      var v24842 = v25855;
      if (v24842) {
        var v26560 = this.asts;
        var v26663 = this.top;
        var v26561 = v26663 - 2;
        var v26338 = v26560[v26561];
        var v25856 = v26338.nodeType;
        var v26339 = TypeScript$$7.NodeType;
        var v25857 = v26339.List;
        v24842 = v25856 === v25857;
      }
      var v22532 = v24842;
      if (v22532) {
        var v26340 = this.asts;
        var v26562 = this.top;
        var v26341 = v26562 - 1;
        var v25858 = v26340[v26341];
        var v24843 = v25858.nodeType;
        var v25859 = TypeScript$$7.NodeType;
        var v24844 = v25859.Member;
        v22532 = v24843 === v24844;
      }
      var v17910 = v22532;
      if (v17910) {
        var v25860 = this.asts;
        var v26342 = this.top;
        var v25861 = v26342 - 0;
        var v24845 = v25860[v25861];
        var v22533 = v24845.nodeType;
        var v24846 = TypeScript$$7.NodeType;
        var v22534 = v24846.Name;
        v17910 = v22533 === v22534;
      }
      var v10539 = v17910;
      if (v10539) {
        var v24847 = this.asts;
        var v25862 = this.top;
        var v24848 = v25862 - 3;
        var v22535 = v24847[v24848];
        var v17911 = v22535.operand;
        var v22536 = this.asts;
        var v24849 = this.top;
        var v22537 = v24849 - 2;
        var v17912 = v22536[v22537];
        v10539 = v17911 == v17912;
      }
      return v10539;
    }
    function v381() {
      var v25863 = this.count();
      var v24850 = v25863 >= 3;
      if (v24850) {
        var v26563 = this.asts;
        var v26664 = this.top;
        var v26564 = v26664 - 2;
        var v26343 = v26563[v26564];
        var v25864 = v26343.nodeType;
        var v26344 = TypeScript$$7.NodeType;
        var v25865 = v26344.ObjectLit;
        v24850 = v25864 === v25865;
      }
      var v22538 = v24850;
      if (v22538) {
        var v26345 = this.asts;
        var v26565 = this.top;
        var v26346 = v26565 - 1;
        var v25866 = v26345[v26346];
        var v24851 = v25866.nodeType;
        var v25867 = TypeScript$$7.NodeType;
        var v24852 = v25867.List;
        v22538 = v24851 === v24852;
      }
      var v17913 = v22538;
      if (v17913) {
        var v25868 = this.asts;
        var v26347 = this.top;
        var v25869 = v26347 - 0;
        var v24853 = v25868[v25869];
        var v22539 = v24853.nodeType;
        var v24854 = TypeScript$$7.NodeType;
        var v22540 = v24854.Member;
        v17913 = v22539 === v22540;
      }
      var v10540 = v17913;
      if (v10540) {
        var v24855 = this.asts;
        var v25870 = this.top;
        var v24856 = v25870 - 2;
        var v22541 = v24855[v24856];
        var v17914 = v22541.operand;
        var v22542 = this.asts;
        var v24857 = this.top;
        var v22543 = v24857 - 1;
        var v17915 = v22542[v22543];
        v10540 = v17914 == v17915;
      }
      return v10540;
    }
    function v380() {
      var v25871 = this.count();
      var v24858 = v25871 >= 2;
      if (v24858) {
        var v26566 = this.asts;
        var v26665 = this.top;
        var v26567 = v26665 - 1;
        var v26348 = v26566[v26567];
        var v25872 = v26348.nodeType;
        var v26349 = TypeScript$$7.NodeType;
        var v25873 = v26349.ObjectLit;
        v24858 = v25872 === v25873;
      }
      var v22544 = v24858;
      if (v22544) {
        var v26350 = this.asts;
        var v26568 = this.top;
        var v26351 = v26568 - 0;
        var v25874 = v26350[v26351];
        var v24859 = v25874.nodeType;
        var v25875 = TypeScript$$7.NodeType;
        var v24860 = v25875.List;
        v22544 = v24859 === v24860;
      }
      var v17916 = v22544;
      if (v17916) {
        var v25876 = this.asts;
        var v26352 = this.top;
        var v25877 = v26352 - 1;
        var v24861 = v25876[v25877];
        var v22545 = v24861.operand;
        var v24862 = this.asts;
        var v25878 = this.top;
        var v24863 = v25878 - 0;
        var v22546 = v24862[v24863];
        v17916 = v22545 == v22546;
      }
      var v10541 = v17916;
      if (v10541) {
        var v25879 = this.asts;
        var v26353 = this.top;
        var v25880 = v26353 - 0;
        var v24864 = v25879[v25880];
        var v22547 = v24864.members;
        var v17917 = v22547.length;
        v10541 = v17917 == 0;
      }
      return v10541;
    }
    function v379() {
      return this.isListOfObjectLit();
    }
    function v378() {
      var v24865 = this.count();
      var v22548 = v24865 >= 2;
      if (v22548) {
        var v26354 = this.asts;
        var v26569 = this.top;
        var v26355 = v26569 - 1;
        var v25881 = v26354[v26355];
        var v24866 = v25881.nodeType;
        var v25882 = TypeScript$$7.NodeType;
        var v24867 = v25882.ObjectLit;
        v22548 = v24866 === v24867;
      }
      var v17918 = v22548;
      if (v17918) {
        var v25883 = this.asts;
        var v26356 = this.top;
        var v25884 = v26356 - 0;
        var v24868 = v25883[v25884];
        var v22549 = v24868.nodeType;
        var v24869 = TypeScript$$7.NodeType;
        var v22550 = v24869.List;
        v17918 = v22549 === v22550;
      }
      var v10542 = v17918;
      if (v10542) {
        var v24870 = this.asts;
        var v25885 = this.top;
        var v24871 = v25885 - 1;
        var v22551 = v24870[v24871];
        var v17919 = v22551.operand;
        var v22552 = this.asts;
        var v24872 = this.top;
        var v22553 = v24872 - 0;
        var v17920 = v22552[v22553];
        v10542 = v17919 == v17920;
      }
      return v10542;
    }
    function v377() {
      var v25886 = this.count();
      var v24873 = v25886 >= 3;
      if (v24873) {
        var v26570 = this.asts;
        var v26666 = this.top;
        var v26571 = v26666 - 2;
        var v26357 = v26570[v26571];
        var v25887 = v26357.nodeType;
        var v26358 = TypeScript$$7.NodeType;
        var v25888 = v26358.Switch;
        v24873 = v25887 === v25888;
      }
      var v22554 = v24873;
      if (v22554) {
        var v26359 = this.asts;
        var v26572 = this.top;
        var v26360 = v26572 - 1;
        var v25889 = v26359[v26360];
        var v24874 = v25889.nodeType;
        var v25890 = TypeScript$$7.NodeType;
        var v24875 = v25890.List;
        v22554 = v24874 === v24875;
      }
      var v17921 = v22554;
      if (v17921) {
        var v25891 = this.asts;
        var v26361 = this.top;
        var v25892 = v26361 - 2;
        var v24876 = v25891[v25892];
        var v22555 = v24876.caseList;
        var v24877 = this.asts;
        var v25893 = this.top;
        var v24878 = v25893 - 1;
        var v22556 = v24877[v24878];
        v17921 = v22555 == v22556;
      }
      var v10543 = v17921;
      if (v10543) {
        var v24879 = this.asts;
        var v25894 = this.top;
        var v24880 = v25894 - 2;
        var v22557 = v24879[v24880];
        var v17922 = v22557.defaultCase;
        var v22558 = this.asts;
        var v24881 = this.top;
        var v22559 = v24881 - 0;
        var v17923 = v22558[v22559];
        v10543 = v17922 == v17923;
      }
      return v10543;
    }
    function v376() {
      var v24882 = this.count();
      var v22560 = v24882 >= 3;
      if (v22560) {
        var v26362 = this.asts;
        var v26573 = this.top;
        var v26363 = v26573 - 2;
        var v25895 = v26362[v26363];
        var v24883 = v25895.nodeType;
        var v25896 = TypeScript$$7.NodeType;
        var v24884 = v25896.Switch;
        v22560 = v24883 === v24884;
      }
      var v17924 = v22560;
      if (v17924) {
        var v25897 = this.asts;
        var v26364 = this.top;
        var v25898 = v26364 - 1;
        var v24885 = v25897[v25898];
        var v22561 = v24885.nodeType;
        var v24886 = TypeScript$$7.NodeType;
        var v22562 = v24886.List;
        v17924 = v22561 === v22562;
      }
      var v10544 = v17924;
      if (v10544) {
        var v24887 = this.asts;
        var v25899 = this.top;
        var v24888 = v25899 - 2;
        var v22563 = v24887[v24888];
        var v17925 = v22563.caseList;
        var v22564 = this.asts;
        var v24889 = this.top;
        var v22565 = v24889 - 1;
        var v17926 = v22564[v22565];
        v10544 = v17925 == v17926;
      }
      return v10544;
    }
    function v375() {
      var v22566 = this.count();
      var v17927 = v22566 >= 2;
      if (v17927) {
        var v25900 = this.asts;
        var v26365 = this.top;
        var v25901 = v26365 - 1;
        var v24890 = v25900[v25901];
        var v22567 = v24890.nodeType;
        var v24891 = TypeScript$$7.NodeType;
        var v22568 = v24891.Finally;
        v17927 = v22567 === v22568;
      }
      var v10545 = v17927;
      if (v10545) {
        var v24892 = this.asts;
        var v25902 = this.top;
        var v24893 = v25902 - 1;
        var v22569 = v24892[v24893];
        var v17928 = v22569.body;
        var v22570 = this.asts;
        var v24894 = this.top;
        var v22571 = v24894 - 0;
        var v17929 = v22570[v22571];
        v10545 = v17928 == v17929;
      }
      return v10545;
    }
    function v374() {
      var v22572 = this.count();
      var v17930 = v22572 >= 2;
      if (v17930) {
        var v25903 = this.asts;
        var v26366 = this.top;
        var v25904 = v26366 - 1;
        var v24895 = v25903[v25904];
        var v22573 = v24895.nodeType;
        var v24896 = TypeScript$$7.NodeType;
        var v22574 = v24896.With;
        v17930 = v22573 === v22574;
      }
      var v10546 = v17930;
      if (v10546) {
        var v24897 = this.asts;
        var v25905 = this.top;
        var v24898 = v25905 - 1;
        var v22575 = v24897[v24898];
        var v17931 = v22575.body;
        var v22576 = this.asts;
        var v24899 = this.top;
        var v22577 = v24899 - 0;
        var v17932 = v22576[v22577];
        v10546 = v17931 == v17932;
      }
      return v10546;
    }
    function v373() {
      var v22578 = this.count();
      var v17933 = v22578 >= 2;
      if (v17933) {
        var v25906 = this.asts;
        var v26367 = this.top;
        var v25907 = v26367 - 1;
        var v24900 = v25906[v25907];
        var v22579 = v24900.nodeType;
        var v24901 = TypeScript$$7.NodeType;
        var v22580 = v24901.ForIn;
        v17933 = v22579 === v22580;
      }
      var v10547 = v17933;
      if (v10547) {
        var v24902 = this.asts;
        var v25908 = this.top;
        var v24903 = v25908 - 1;
        var v22581 = v24902[v24903];
        var v17934 = v22581.body;
        var v22582 = this.asts;
        var v24904 = this.top;
        var v22583 = v24904 - 0;
        var v17935 = v22582[v22583];
        v10547 = v17934 == v17935;
      }
      return v10547;
    }
    function v372() {
      var v22584 = this.count();
      var v17936 = v22584 >= 2;
      if (v17936) {
        var v25909 = this.asts;
        var v26368 = this.top;
        var v25910 = v26368 - 1;
        var v24905 = v25909[v25910];
        var v22585 = v24905.nodeType;
        var v24906 = TypeScript$$7.NodeType;
        var v22586 = v24906.While;
        v17936 = v22585 === v22586;
      }
      var v10548 = v17936;
      if (v10548) {
        var v24907 = this.asts;
        var v25911 = this.top;
        var v24908 = v25911 - 1;
        var v22587 = v24907[v24908];
        var v17937 = v22587.body;
        var v22588 = this.asts;
        var v24909 = this.top;
        var v22589 = v24909 - 0;
        var v17938 = v22588[v22589];
        v10548 = v17937 == v17938;
      }
      return v10548;
    }
    function v371() {
      var v22590 = this.count();
      var v17939 = v22590 >= 2;
      if (v17939) {
        var v25912 = this.asts;
        var v26369 = this.top;
        var v25913 = v26369 - 1;
        var v24910 = v25912[v25913];
        var v22591 = v24910.nodeType;
        var v24911 = TypeScript$$7.NodeType;
        var v22592 = v24911.DoWhile;
        v17939 = v22591 === v22592;
      }
      var v10549 = v17939;
      if (v10549) {
        var v24912 = this.asts;
        var v25914 = this.top;
        var v24913 = v25914 - 1;
        var v22593 = v24912[v24913];
        var v17940 = v22593.body;
        var v22594 = this.asts;
        var v24914 = this.top;
        var v22595 = v24914 - 0;
        var v17941 = v22594[v22595];
        v10549 = v17940 == v17941;
      }
      return v10549;
    }
    function v370() {
      var v22596 = this.count();
      var v17942 = v22596 >= 2;
      if (v17942) {
        var v25915 = this.asts;
        var v26370 = this.top;
        var v25916 = v26370 - 1;
        var v24915 = v25915[v25916];
        var v22597 = v24915.nodeType;
        var v24916 = TypeScript$$7.NodeType;
        var v22598 = v24916.Catch;
        v17942 = v22597 === v22598;
      }
      var v10550 = v17942;
      if (v10550) {
        var v24917 = this.asts;
        var v25917 = this.top;
        var v24918 = v25917 - 1;
        var v22599 = v24917[v24918];
        var v17943 = v22599.body;
        var v22600 = this.asts;
        var v24919 = this.top;
        var v22601 = v24919 - 0;
        var v17944 = v22600[v22601];
        v10550 = v17943 == v17944;
      }
      return v10550;
    }
    function v369() {
      var v22602 = this.count();
      var v17945 = v22602 >= 2;
      if (v17945) {
        var v25918 = this.asts;
        var v26371 = this.top;
        var v25919 = v26371 - 1;
        var v24920 = v25918[v25919];
        var v22603 = v24920.nodeType;
        var v24921 = TypeScript$$7.NodeType;
        var v22604 = v24921.Try;
        v17945 = v22603 === v22604;
      }
      var v10551 = v17945;
      if (v10551) {
        var v24922 = this.asts;
        var v25920 = this.top;
        var v24923 = v25920 - 1;
        var v22605 = v24922[v24923];
        var v17946 = v22605.body;
        var v22606 = this.asts;
        var v24924 = this.top;
        var v22607 = v24924 - 0;
        var v17947 = v22606[v22607];
        v10551 = v17946 == v17947;
      }
      return v10551;
    }
    function v368() {
      var v22608 = this.count();
      var v17948 = v22608 >= 2;
      if (v17948) {
        var v25921 = this.asts;
        var v26372 = this.top;
        var v25922 = v26372 - 1;
        var v24925 = v25921[v25922];
        var v22609 = v24925.nodeType;
        var v24926 = TypeScript$$7.NodeType;
        var v22610 = v24926.Case;
        v17948 = v22609 === v22610;
      }
      var v10552 = v17948;
      if (v10552) {
        var v24927 = this.asts;
        var v25923 = this.top;
        var v24928 = v25923 - 1;
        var v22611 = v24927[v24928];
        var v17949 = v22611.body;
        var v22612 = this.asts;
        var v24929 = this.top;
        var v22613 = v24929 - 0;
        var v17950 = v22612[v22613];
        v10552 = v17949 == v17950;
      }
      return v10552;
    }
    function v367() {
      var v22614 = this.count();
      var v17951 = v22614 >= 2;
      if (v17951) {
        var v25924 = this.asts;
        var v26373 = this.top;
        var v25925 = v26373 - 1;
        var v24930 = v25924[v25925];
        var v22615 = v24930.nodeType;
        var v24931 = TypeScript$$7.NodeType;
        var v22616 = v24931.For;
        v17951 = v22615 === v22616;
      }
      var v10553 = v17951;
      if (v10553) {
        var v24932 = this.asts;
        var v25926 = this.top;
        var v24933 = v25926 - 1;
        var v22617 = v24932[v24933];
        var v17952 = v22617.body;
        var v22618 = this.asts;
        var v24934 = this.top;
        var v22619 = v24934 - 0;
        var v17953 = v22618[v22619];
        v10553 = v17952 == v17953;
      }
      return v10553;
    }
    function v366() {
      var v22620 = this.count();
      var v17954 = v22620 >= 2;
      if (v17954) {
        var v25927 = this.asts;
        var v26374 = this.top;
        var v25928 = v26374 - 1;
        var v24935 = v25927[v25928];
        var v22621 = v24935.nodeType;
        var v24936 = TypeScript$$7.NodeType;
        var v22622 = v24936.Block;
        v17954 = v22621 === v22622;
      }
      var v10554 = v17954;
      if (v10554) {
        var v24937 = this.asts;
        var v25929 = this.top;
        var v24938 = v25929 - 1;
        var v22623 = v24937[v24938];
        var v17955 = v22623.statements;
        var v22624 = this.asts;
        var v24939 = this.top;
        var v22625 = v24939 - 0;
        var v17956 = v22624[v22625];
        v10554 = v17955 == v17956;
      }
      return v10554;
    }
    function v365() {
      var v22626 = this.count();
      var v17957 = v22626 >= 2;
      if (v17957) {
        var v25930 = this.asts;
        var v26375 = this.top;
        var v25931 = v26375 - 1;
        var v24940 = v25930[v25931];
        var v22627 = v24940.nodeType;
        var v24941 = TypeScript$$7.NodeType;
        var v22628 = v24941.InterfaceDeclaration;
        v17957 = v22627 === v22628;
      }
      var v10555 = v17957;
      if (v10555) {
        var v24942 = this.asts;
        var v25932 = this.top;
        var v24943 = v25932 - 1;
        var v22629 = v24942[v24943];
        var v17958 = v22629.members;
        var v22630 = this.asts;
        var v24944 = this.top;
        var v22631 = v24944 - 0;
        var v17959 = v22630[v22631];
        v10555 = v17958 == v17959;
      }
      return v10555;
    }
    function v364() {
      var v22632 = this.count();
      var v17960 = v22632 >= 2;
      if (v17960) {
        var v25933 = this.asts;
        var v26376 = this.top;
        var v25934 = v26376 - 1;
        var v24945 = v25933[v25934];
        var v22633 = v24945.nodeType;
        var v24946 = TypeScript$$7.NodeType;
        var v22634 = v24946.FuncDecl;
        v17960 = v22633 === v22634;
      }
      var v10556 = v17960;
      if (v10556) {
        var v24947 = this.asts;
        var v25935 = this.top;
        var v24948 = v25935 - 1;
        var v22635 = v24947[v24948];
        var v17961 = v22635.bod;
        var v22636 = this.asts;
        var v24949 = this.top;
        var v22637 = v24949 - 0;
        var v17962 = v22636[v22637];
        v10556 = v17961 == v17962;
      }
      return v10556;
    }
    function v363() {
      var v22638 = this.count();
      var v17963 = v22638 >= 2;
      if (v17963) {
        var v25936 = this.asts;
        var v26377 = this.top;
        var v25937 = v26377 - 1;
        var v24950 = v25936[v25937];
        var v22639 = v24950.nodeType;
        var v24951 = TypeScript$$7.NodeType;
        var v22640 = v24951.ClassDeclaration;
        v17963 = v22639 === v22640;
      }
      var v10557 = v17963;
      if (v10557) {
        var v24952 = this.asts;
        var v25938 = this.top;
        var v24953 = v25938 - 1;
        var v22641 = v24952[v24953];
        var v17964 = v22641.members;
        var v22642 = this.asts;
        var v24954 = this.top;
        var v22643 = v24954 - 0;
        var v17965 = v22642[v22643];
        v10557 = v17964 == v17965;
      }
      return v10557;
    }
    function v362() {
      var v22644 = this.count();
      var v17966 = v22644 >= 2;
      if (v17966) {
        var v25939 = this.asts;
        var v26378 = this.top;
        var v25940 = v26378 - 1;
        var v24955 = v25939[v25940];
        var v22645 = v24955.nodeType;
        var v24956 = TypeScript$$7.NodeType;
        var v22646 = v24956.ModuleDeclaration;
        v17966 = v22645 === v22646;
      }
      var v10558 = v17966;
      if (v10558) {
        var v24957 = this.asts;
        var v25941 = this.top;
        var v24958 = v25941 - 1;
        var v22647 = v24957[v24958];
        var v17967 = v22647.members;
        var v22648 = this.asts;
        var v24959 = this.top;
        var v22649 = v24959 - 0;
        var v17968 = v22648[v22649];
        v10558 = v17967 == v17968;
      }
      return v10558;
    }
    function v361() {
      var v22650 = this.count();
      var v17969 = v22650 >= 2;
      if (v17969) {
        var v25942 = this.asts;
        var v26379 = this.top;
        var v25943 = v26379 - 1;
        var v24960 = v25942[v25943];
        var v22651 = v24960.nodeType;
        var v24961 = TypeScript$$7.NodeType;
        var v22652 = v24961.Switch;
        v17969 = v22651 === v22652;
      }
      var v10559 = v17969;
      if (v10559) {
        var v24962 = this.asts;
        var v25944 = this.top;
        var v24963 = v25944 - 1;
        var v22653 = v24962[v24963];
        var v17970 = v22653.caseList;
        var v22654 = this.asts;
        var v24964 = this.top;
        var v22655 = v24964 - 0;
        var v17971 = v22654[v22655];
        v10559 = v17970 == v17971;
      }
      return v10559;
    }
    function v360() {
      var v22656 = this.count();
      var v17972 = v22656 >= 2;
      if (v17972) {
        var v25945 = this.asts;
        var v26380 = this.top;
        var v25946 = v26380 - 1;
        var v24965 = v25945[v25946];
        var v22657 = v24965.nodeType;
        var v24966 = TypeScript$$7.NodeType;
        var v22658 = v24966.Script;
        v17972 = v22657 === v22658;
      }
      var v10560 = v17972;
      if (v10560) {
        var v24967 = this.asts;
        var v25947 = this.top;
        var v24968 = v25947 - 1;
        var v22659 = v24967[v24968];
        var v17973 = v22659.bod;
        var v22660 = this.asts;
        var v24969 = this.top;
        var v22661 = v24969 - 0;
        var v17974 = v22660[v22661];
        v10560 = v17973 == v17974;
      }
      return v10560;
    }
    function v359() {
      var v25948 = this.count();
      var v24970 = v25948 >= 2;
      if (v24970) {
        var v26574 = this.asts;
        var v26667 = this.top;
        var v26575 = v26667 - 0;
        var v26381 = v26574[v26575];
        var v25949 = v26381.nodeType;
        var v26382 = TypeScript$$7.NodeType;
        var v25950 = v26382.List;
        v24970 = v25949 === v25950;
      }
      var v22662 = v24970;
      if (v22662) {
        var v26383 = this.asts;
        var v26576 = this.top;
        var v26384 = v26576 - 1;
        var v25951 = v26383[v26384];
        var v24971 = v25951.nodeType;
        var v25952 = TypeScript$$7.NodeType;
        var v24972 = v25952.ModuleDeclaration;
        v22662 = v24971 === v24972;
      }
      var v17975 = v22662;
      if (v17975) {
        var v25953 = this.asts;
        var v26385 = this.top;
        var v25954 = v26385 - 1;
        var v24973 = v25953[v25954];
        var v22663 = v24973.members;
        var v24974 = this.asts;
        var v25955 = this.top;
        var v24975 = v25955 - 0;
        var v22664 = v24974[v24975];
        v17975 = v22663 == v22664;
      }
      var v10561 = v17975;
      if (v10561) {
        var v24976 = this.asts;
        var v25956 = this.top;
        var v24977 = v25956 - 1;
        var v22665 = v24976[v24977];
        var v17976 = v22665.modFlags;
        var v22666 = TypeScript$$7.ModuleFlags;
        var v17977 = v22666.IsWholeFile;
        v10561 = TypeScript$$7.hasFlag(v17976, v17977);
      }
      return v10561;
    }
    function v358() {
      var v22667 = this.count();
      var v17978 = v22667 >= 1;
      if (v17978) {
        var v25957 = this.asts;
        var v25958 = this.top;
        var v24978 = v25957[v25958];
        var v22668 = v24978.nodeType;
        var v24979 = TypeScript$$7.NodeType;
        var v22669 = v24979.ModuleDeclaration;
        v17978 = v22668 === v22669;
      }
      var v10562 = v17978;
      if (v10562) {
        var v24980 = this.asts;
        var v24981 = this.top;
        var v22670 = v24980[v24981];
        var v17979 = v22670.modFlags;
        var v22671 = TypeScript$$7.ModuleFlags;
        var v17980 = v22671.IsWholeFile;
        v10562 = TypeScript$$7.hasFlag(v17979, v17980);
      }
      return v10562;
    }
    function v357() {
      var v10563 = this.asts;
      var ast$$13 = lastOf(v10563);
      var v24982 = this.count();
      var v22672 = v24982 >= 3;
      if (v22672) {
        var v25959 = this.asts;
        var v25960 = this.top;
        var v24983 = v25959[v25960];
        v22672 = v24983 === ast$$13;
      }
      var v17981 = v22672;
      if (v17981) {
        var v25961 = this.asts;
        var v26386 = this.top;
        var v25962 = v26386 - 1;
        var v24984 = v25961[v25962];
        var v22673 = v24984.nodeType;
        var v24985 = TypeScript$$7.NodeType;
        var v22674 = v24985.List;
        v17981 = v22673 === v22674;
      }
      var v10564 = v17981;
      if (v10564) {
        var v24986 = this.asts;
        var v25963 = this.top;
        var v24987 = v25963 - 2;
        var v22675 = v24986[v24987];
        var v17982 = v22675.nodeType;
        var v22676 = TypeScript$$7.NodeType;
        var v17983 = v22676.InterfaceDeclaration;
        v10564 = v17982 === v17983;
      }
      return v10564;
    }
    function v356() {
      var v10565 = this.asts;
      var ast$$12 = lastOf(v10565);
      var v26716 = this.count();
      var v26668 = v26716 >= 5;
      if (v26668) {
        var v26741 = this.asts;
        var v26742 = this.top;
        var v26717 = v26741[v26742];
        v26668 = v26717 === ast$$12;
      }
      var v26577 = v26668;
      if (v26577) {
        var v26743 = this.asts;
        var v26757 = this.top;
        var v26744 = v26757 - 1;
        var v26718 = v26743[v26744];
        var v26669 = v26718.nodeType;
        var v26719 = TypeScript$$7.NodeType;
        var v26670 = v26719.List;
        v26577 = v26669 === v26670;
      }
      var v26387 = v26577;
      if (v26387) {
        var v26720 = this.asts;
        var v26745 = this.top;
        var v26721 = v26745 - 2;
        var v26671 = v26720[v26721];
        var v26578 = v26671.nodeType;
        var v26672 = TypeScript$$7.NodeType;
        var v26579 = v26672.FuncDecl;
        v26387 = v26578 === v26579;
      }
      var v25964 = v26387;
      if (v25964) {
        var v26673 = this.asts;
        var v26722 = this.top;
        var v26674 = v26722 - 3;
        var v26580 = v26673[v26674];
        var v26388 = v26580.nodeType;
        var v26581 = TypeScript$$7.NodeType;
        var v26389 = v26581.List;
        v25964 = v26388 === v26389;
      }
      var v24988 = v25964;
      if (v24988) {
        var v26582 = this.asts;
        var v26675 = this.top;
        var v26583 = v26675 - 4;
        var v26390 = v26582[v26583];
        var v25965 = v26390.nodeType;
        var v26391 = TypeScript$$7.NodeType;
        var v25966 = v26391.ClassDeclaration;
        v24988 = v25965 === v25966;
      }
      var v22677 = v24988;
      if (v22677) {
        var v25967 = this.asts;
        var v26392 = this.top;
        var v25968 = v26392 - 2;
        var v24989 = v25967[v25968];
        v22677 = v24989.isConstructor;
      }
      var v17984 = v22677;
      if (v17984) {
        var v25969 = this.asts;
        var v26393 = this.top;
        var v25970 = v26393 - 2;
        var v24990 = v25969[v25970];
        var v22678 = v24990.arguments;
        var v24991 = this.asts;
        var v25971 = this.top;
        var v24992 = v25971 - 1;
        var v22679 = v24991[v24992];
        v17984 = v22678 === v22679;
      }
      var v10566 = v17984;
      if (v10566) {
        var v24993 = this.asts;
        var v25972 = this.top;
        var v24994 = v25972 - 4;
        var v22680 = v24993[v24994];
        var v17985 = v22680.constructorDecl;
        var v22681 = this.asts;
        var v24995 = this.top;
        var v22682 = v24995 - 2;
        var v17986 = v22681[v22682];
        v10566 = v17985 === v17986;
      }
      return v10566;
    }
    function v355() {
      var v10567 = this.asts;
      var ast$$11 = lastOf(v10567);
      var v24996 = this.count();
      var v22683 = v24996 >= 3;
      if (v22683) {
        var v25973 = this.asts;
        var v25974 = this.top;
        var v24997 = v25973[v25974];
        v22683 = v24997 === ast$$11;
      }
      var v17987 = v22683;
      if (v17987) {
        var v25975 = this.asts;
        var v26394 = this.top;
        var v25976 = v26394 - 1;
        var v24998 = v25975[v25976];
        var v22684 = v24998.nodeType;
        var v24999 = TypeScript$$7.NodeType;
        var v22685 = v24999.List;
        v17987 = v22684 === v22685;
      }
      var v10568 = v17987;
      if (v10568) {
        var v25000 = this.asts;
        var v25977 = this.top;
        var v25001 = v25977 - 2;
        var v22686 = v25000[v25001];
        var v17988 = v22686.nodeType;
        var v22687 = TypeScript$$7.NodeType;
        var v17989 = v22687.ClassDeclaration;
        v10568 = v17988 === v17989;
      }
      return v10568;
    }
    function v354() {
      var v10569 = this.asts;
      var ast$$10 = lastOf(v10569);
      var v25002 = this.count();
      var v22688 = v25002 >= 3;
      if (v22688) {
        var v25978 = this.asts;
        var v25979 = this.top;
        var v25003 = v25978[v25979];
        v22688 = v25003 === ast$$10;
      }
      var v17990 = v22688;
      if (v17990) {
        var v25980 = this.asts;
        var v26395 = this.top;
        var v25981 = v26395 - 1;
        var v25004 = v25980[v25981];
        var v22689 = v25004.nodeType;
        var v25005 = TypeScript$$7.NodeType;
        var v22690 = v25005.List;
        v17990 = v22689 === v22690;
      }
      var v10570 = v17990;
      if (v10570) {
        var v25006 = this.asts;
        var v25982 = this.top;
        var v25007 = v25982 - 2;
        var v22691 = v25006[v25007];
        var v17991 = v22691.nodeType;
        var v22692 = TypeScript$$7.NodeType;
        var v17992 = v22692.ModuleDeclaration;
        v10570 = v17991 === v17992;
      }
      return v10570;
    }
    function v353() {
      var v10571 = this.asts;
      var ast$$9 = lastOf(v10571);
      var v25008 = this.count();
      var v22693 = v25008 >= 3;
      if (v22693) {
        var v25983 = this.asts;
        var v25984 = this.top;
        var v25009 = v25983[v25984];
        v22693 = v25009 === ast$$9;
      }
      var v17993 = v22693;
      if (v17993) {
        var v25985 = this.asts;
        var v26396 = this.top;
        var v25986 = v26396 - 1;
        var v25010 = v25985[v25986];
        var v22694 = v25010.nodeType;
        var v25011 = TypeScript$$7.NodeType;
        var v22695 = v25011.List;
        v17993 = v22694 === v22695;
      }
      var v10572 = v17993;
      if (v10572) {
        var v25012 = this.asts;
        var v25987 = this.top;
        var v25013 = v25987 - 2;
        var v22696 = v25012[v25013];
        var v17994 = v22696.nodeType;
        var v22697 = TypeScript$$7.NodeType;
        var v17995 = v22697.Script;
        v10572 = v17994 === v17995;
      }
      return v10572;
    }
    function v352() {
      var v22698 = this.ast();
      var v17996 = v22698 === null;
      var v22700 = !v17996;
      if (v22700) {
        var v22699 = this.parent();
        v17996 = v22699 === null;
      }
      var v10573 = v17996;
      if (v10573) {
        return false;
      }
      var v25014 = this.ast();
      var v22701 = v25014.nodeType;
      var v25015 = TypeScript$$7.NodeType;
      var v22702 = v25015.Name;
      var v17997 = v22701 === v22702;
      if (v17997) {
        var v25016 = this.parent();
        var v22703 = v25016.nodeType;
        var v25017 = TypeScript$$7.NodeType;
        var v22704 = v25017.FuncDecl;
        v17997 = v22703 === v22704;
      }
      var v10574 = v17997;
      if (v10574) {
        var v22705 = this.parent();
        var v17998 = v22705.name;
        var v17999 = this.ast();
        v10574 = v17998 === v17999;
      }
      return v10574;
    }
    function v351() {
      var v22706 = this.ast();
      var v18000 = v22706 === null;
      var v22708 = !v18000;
      if (v22708) {
        var v22707 = this.parent();
        v18000 = v22707 === null;
      }
      var v10575 = v18000;
      if (v10575) {
        return false;
      }
      var v25018 = this.ast();
      var v22709 = v25018.nodeType;
      var v25019 = TypeScript$$7.NodeType;
      var v22710 = v25019.Name;
      var v18001 = v22709 === v22710;
      if (v18001) {
        var v25020 = this.parent();
        var v22711 = v25020.nodeType;
        var v25021 = TypeScript$$7.NodeType;
        var v22712 = v25021.ModuleDeclaration;
        v18001 = v22711 === v22712;
      }
      var v10576 = v18001;
      if (v10576) {
        var v22713 = this.parent();
        var v18002 = v22713.name;
        var v18003 = this.ast();
        v10576 = v18002 === v18003;
      }
      return v10576;
    }
    function v350() {
      var v22714 = this.ast();
      var v18004 = v22714 === null;
      var v22716 = !v18004;
      if (v22716) {
        var v22715 = this.parent();
        v18004 = v22715 === null;
      }
      var v10577 = v18004;
      if (v10577) {
        return false;
      }
      var v25022 = this.ast();
      var v22717 = v25022.nodeType;
      var v25023 = TypeScript$$7.NodeType;
      var v22718 = v25023.Name;
      var v18005 = v22717 === v22718;
      if (v18005) {
        var v25024 = this.parent();
        var v22719 = v25024.nodeType;
        var v25025 = TypeScript$$7.NodeType;
        var v22720 = v25025.VarDecl;
        v18005 = v22719 === v22720;
      }
      var v10578 = v18005;
      if (v10578) {
        var v22721 = this.parent();
        var v18006 = v22721.id;
        var v18007 = this.ast();
        v10578 = v18006 === v18007;
      }
      return v10578;
    }
    function v349() {
      var v22722 = this.ast();
      var v18008 = v22722 === null;
      var v22724 = !v18008;
      if (v22724) {
        var v22723 = this.parent();
        v18008 = v22723 === null;
      }
      var v10579 = v18008;
      if (v10579) {
        return false;
      }
      var v25026 = this.ast();
      var v22725 = v25026.nodeType;
      var v25027 = TypeScript$$7.NodeType;
      var v22726 = v25027.Name;
      var v18009 = v22725 === v22726;
      if (v18009) {
        var v25028 = this.parent();
        var v22727 = v25028.nodeType;
        var v25029 = TypeScript$$7.NodeType;
        var v22728 = v25029.ArgDecl;
        v18009 = v22727 === v22728;
      }
      var v10580 = v18009;
      if (v10580) {
        var v22729 = this.parent();
        var v18010 = v22729.id;
        var v18011 = this.ast();
        v10580 = v18010 === v18011;
      }
      return v10580;
    }
    function v348() {
      var v22730 = this.ast();
      var v18012 = v22730 === null;
      var v22732 = !v18012;
      if (v22732) {
        var v22731 = this.parent();
        v18012 = v22731 === null;
      }
      var v10581 = v18012;
      if (v10581) {
        return false;
      }
      var v25030 = this.ast();
      var v22733 = v25030.nodeType;
      var v25031 = TypeScript$$7.NodeType;
      var v22734 = v25031.Name;
      var v18013 = v22733 === v22734;
      if (v18013) {
        var v25032 = this.parent();
        var v22735 = v25032.nodeType;
        var v25033 = TypeScript$$7.NodeType;
        var v22736 = v25033.InterfaceDeclaration;
        v18013 = v22735 === v22736;
      }
      var v10582 = v18013;
      if (v10582) {
        var v22737 = this.parent();
        var v18014 = v22737.name;
        var v18015 = this.ast();
        v10582 = v18014 === v18015;
      }
      return v10582;
    }
    function v347() {
      var v22738 = this.ast();
      var v18016 = v22738 === null;
      var v22740 = !v18016;
      if (v22740) {
        var v22739 = this.parent();
        v18016 = v22739 === null;
      }
      var v10583 = v18016;
      if (v10583) {
        return false;
      }
      var v25034 = this.ast();
      var v22741 = v25034.nodeType;
      var v25035 = TypeScript$$7.NodeType;
      var v22742 = v25035.Name;
      var v18017 = v22741 === v22742;
      if (v18017) {
        var v25036 = this.parent();
        var v22743 = v25036.nodeType;
        var v25037 = TypeScript$$7.NodeType;
        var v22744 = v25037.ClassDeclaration;
        v18017 = v22743 === v22744;
      }
      var v10584 = v18017;
      if (v10584) {
        var v22745 = this.parent();
        var v18018 = v22745.name;
        var v18019 = this.ast();
        v10584 = v18018 === v18019;
      }
      return v10584;
    }
    function v346(index$$43) {
      var v10585 = this.asts;
      return v10585[index$$43];
    }
    function v345() {
      var v10586 = this.top;
      return v10586 + 1;
    }
    function v344() {
      var v10587 = this.asts;
      var v22746 = this.asts;
      var v18020 = v22746.length;
      var v18021 = this.top;
      var v10588 = v18020 - v18021;
      return AstPath$$1.reverseIndexOf(v10587, v10588);
    }
    function v343() {
      var v10589 = this.asts;
      var v22747 = this.asts;
      var v18022 = v22747.length;
      var v22748 = this.top;
      var v18023 = v22748 + 1;
      var v10590 = v18022 - v18023;
      return AstPath$$1.reverseIndexOf(v10589, v10590);
    }
    function v342() {
      var v18024 = this.ast();
      var v10592 = v18024 == null;
      if (v10592) {
        var v10591 = TypeScript$$7.NodeType;
        return v10591.None;
      }
      var v10593 = this.ast();
      return v10593.nodeType;
    }
    function v341() {
      var v18025 = this.top;
      var v25038 = this.ast;
      var v22749 = v25038.length;
      var v18026 = v22749 - 1;
      var v10594 = v18025 == v18026;
      if (v10594) {
        throw new Error("Invalid call to 'down'");
      }
      var v18027 = this.top;
      this.top = v18027 + 1;
      return;
    }
    function v340() {
      var v18028 = this.top;
      var v10595 = v18028 <= -1;
      if (v10595) {
        throw new Error("Invalid call to 'up'");
      }
      var v18029 = this.top;
      this.top = v18029 - 1;
      return;
    }
    function v339(ast$$8) {
      var v22750 = this.asts;
      var v18030 = v22750.length;
      var v18031 = this.count();
      var v10597 = v18030 > v18031;
      for (;v10597;) {
        var v10596 = this.asts;
        v10596.pop();
        var v22751 = this.asts;
        var v18032 = v22751.length;
        var v18033 = this.count();
        v10597 = v18032 > v18033;
      }
      var v10598 = this.asts;
      this.top = v10598.length;
      var v10599 = this.asts;
      v10599.push(ast$$8);
      return;
    }
    function v338() {
      var head = this.ast();
      this.up();
      var v22752 = this.asts;
      var v18034 = v22752.length;
      var v18035 = this.count();
      var v10601 = v18034 > v18035;
      for (;v10601;) {
        var v10600 = this.asts;
        v10600.pop();
        var v22753 = this.asts;
        var v18036 = v22753.length;
        var v18037 = this.count();
        v10601 = v18036 > v18037;
      }
      return head;
    }
    function v337() {
      function v336(value$$30) {
        return value$$30;
      }
      var clone = new AstPath$$1;
      var v10602 = clone;
      var v18038 = this.asts;
      var v27329 = v18038.map(v336);
      v10602.asts = v27329;
      clone.top = this.top;
      return clone;
    }
    function reverseIndexOf(items$$1, index$$42) {
      var v10603;
      var v22754 = items$$1 === null;
      var v25040 = !v22754;
      if (v25040) {
        var v25039 = items$$1.length;
        v22754 = v25039 <= index$$42;
      }
      var v18040 = v22754;
      if (v18040) {
        v10603 = null;
      } else {
        var v25041 = items$$1.length;
        var v22755 = v25041 - index$$42;
        var v18039 = v22755 - 1;
        v10603 = items$$1[v18039];
      }
      return v10603;
    }
    function AstPath$$1() {
      this.asts = [];
      this.top = -1;
      return;
    }
    AstPath$$1.reverseIndexOf = reverseIndexOf;
    var v10604 = AstPath$$1.prototype;
    v10604.clone = v337;
    var v10605 = AstPath$$1.prototype;
    v10605.pop = v338;
    var v10606 = AstPath$$1.prototype;
    v10606.push = v339;
    var v10607 = AstPath$$1.prototype;
    v10607.up = v340;
    var v10608 = AstPath$$1.prototype;
    v10608.down = v341;
    var v10609 = AstPath$$1.prototype;
    v10609.nodeType = v342;
    var v10610 = AstPath$$1.prototype;
    v10610.ast = v343;
    var v10611 = AstPath$$1.prototype;
    v10611.parent = v344;
    var v10612 = AstPath$$1.prototype;
    v10612.count = v345;
    var v10613 = AstPath$$1.prototype;
    v10613.get = v346;
    var v10614 = AstPath$$1.prototype;
    v10614.isNameOfClass = v347;
    var v10615 = AstPath$$1.prototype;
    v10615.isNameOfInterface = v348;
    var v10616 = AstPath$$1.prototype;
    v10616.isNameOfArgument = v349;
    var v10617 = AstPath$$1.prototype;
    v10617.isNameOfVariable = v350;
    var v10618 = AstPath$$1.prototype;
    v10618.isNameOfModule = v351;
    var v10619 = AstPath$$1.prototype;
    v10619.isNameOfFunction = v352;
    var v10620 = AstPath$$1.prototype;
    v10620.isChildOfScript = v353;
    var v10621 = AstPath$$1.prototype;
    v10621.isChildOfModule = v354;
    var v10622 = AstPath$$1.prototype;
    v10622.isChildOfClass = v355;
    var v10623 = AstPath$$1.prototype;
    v10623.isArgumentOfClassConstructor = v356;
    var v10624 = AstPath$$1.prototype;
    v10624.isChildOfInterface = v357;
    var v10625 = AstPath$$1.prototype;
    v10625.isTopLevelImplicitModule = v358;
    var v10626 = AstPath$$1.prototype;
    v10626.isBodyOfTopLevelImplicitModule = v359;
    var v10627 = AstPath$$1.prototype;
    v10627.isBodyOfScript = v360;
    var v10628 = AstPath$$1.prototype;
    v10628.isBodyOfSwitch = v361;
    var v10629 = AstPath$$1.prototype;
    v10629.isBodyOfModule = v362;
    var v10630 = AstPath$$1.prototype;
    v10630.isBodyOfClass = v363;
    var v10631 = AstPath$$1.prototype;
    v10631.isBodyOfFunction = v364;
    var v10632 = AstPath$$1.prototype;
    v10632.isBodyOfInterface = v365;
    var v10633 = AstPath$$1.prototype;
    v10633.isBodyOfBlock = v366;
    var v10634 = AstPath$$1.prototype;
    v10634.isBodyOfFor = v367;
    var v10635 = AstPath$$1.prototype;
    v10635.isBodyOfCase = v368;
    var v10636 = AstPath$$1.prototype;
    v10636.isBodyOfTry = v369;
    var v10637 = AstPath$$1.prototype;
    v10637.isBodyOfCatch = v370;
    var v10638 = AstPath$$1.prototype;
    v10638.isBodyOfDoWhile = v371;
    var v10639 = AstPath$$1.prototype;
    v10639.isBodyOfWhile = v372;
    var v10640 = AstPath$$1.prototype;
    v10640.isBodyOfForIn = v373;
    var v10641 = AstPath$$1.prototype;
    v10641.isBodyOfWith = v374;
    var v10642 = AstPath$$1.prototype;
    v10642.isBodyOfFinally = v375;
    var v10643 = AstPath$$1.prototype;
    v10643.isCaseOfSwitch = v376;
    var v10644 = AstPath$$1.prototype;
    v10644.isDefaultCaseOfSwitch = v377;
    var v10645 = AstPath$$1.prototype;
    v10645.isListOfObjectLit = v378;
    var v10646 = AstPath$$1.prototype;
    v10646.isBodyOfObjectLit = v379;
    var v10647 = AstPath$$1.prototype;
    v10647.isEmptyListOfObjectLit = v380;
    var v10648 = AstPath$$1.prototype;
    v10648.isMemberOfObjectLit = v381;
    var v10649 = AstPath$$1.prototype;
    v10649.isNameOfMemberOfObjectLit = v382;
    var v10650 = AstPath$$1.prototype;
    v10650.isListOfArrayLit = v383;
    var v10651 = AstPath$$1.prototype;
    v10651.isTargetOfMember = v384;
    var v10652 = AstPath$$1.prototype;
    v10652.isMemberOfMember = v385;
    var v10653 = AstPath$$1.prototype;
    v10653.isItemOfList = v386;
    var v10654 = AstPath$$1.prototype;
    v10654.isThenOfIf = v387;
    var v10655 = AstPath$$1.prototype;
    v10655.isElseOfIf = v388;
    var v10656 = AstPath$$1.prototype;
    v10656.isBodyOfDefaultCase = v389;
    var v10657 = AstPath$$1.prototype;
    v10657.isSingleStatementList = v390;
    var v10658 = AstPath$$1.prototype;
    v10658.isArgumentListOfFunction = v391;
    var v10659 = AstPath$$1.prototype;
    v10659.isArgumentOfFunction = v392;
    var v10660 = AstPath$$1.prototype;
    v10660.isArgumentListOfCall = v393;
    var v10661 = AstPath$$1.prototype;
    v10661.isArgumentListOfNew = v394;
    var v10662 = AstPath$$1.prototype;
    v10662.isSynthesizedBlock = v395;
    return AstPath$$1;
  }
  function lastOf(items) {
    var v10663;
    var v22756 = items === null;
    var v25043 = !v22756;
    if (v25043) {
      var v25042 = items.length;
      v22756 = v25042 === 0;
    }
    var v18042 = v22756;
    if (v18042) {
      v10663 = null;
    } else {
      var v22757 = items.length;
      var v18041 = v22757 - 1;
      v10663 = items[v18041];
    }
    return v10663;
  }
  function max(a, b$$1) {
    var v10664;
    var v18043 = a >= b$$1;
    if (v18043) {
      v10664 = a;
    } else {
      v10664 = b$$1;
    }
    return v10664;
  }
  function min$$1(a$$1, b$$2) {
    var v10665;
    var v18044 = a$$1 <= b$$2;
    if (v18044) {
      v10665 = a$$1;
    } else {
      v10665 = b$$2;
    }
    return v10665;
  }
  function isValidAstNode(ast$$6) {
    var v10666 = ast$$6 === null;
    if (v10666) {
      return false;
    }
    var v22758 = ast$$6.minChar;
    var v18045 = v22758 === -1;
    var v22760 = !v18045;
    if (v22760) {
      var v22759 = ast$$6.limChar;
      v18045 = v22759 === -1;
    }
    var v10667 = v18045;
    if (v10667) {
      return false;
    }
    return true;
  }
  function getAstPathToPosition(script$$1, pos, options$$5) {
    function pre$$6(cur$$2, parent$$37, walker$$36) {
      var v10681 = isValidAstNode(cur$$2);
      if (v10681) {
        var v22761 = GetAstPathOptions.EdgeInclusive;
        var v18046 = TypeScript$$7.hasFlag(options$$5, v22761);
        var v22764 = !v18046;
        if (v22764) {
          var v22762 = cur$$2.nodeType;
          var v25044 = TypeScript$$7.NodeType;
          var v22763 = v25044.Name;
          v18046 = v22762 === v22763;
        }
        var v10668 = v18046;
        var v18048 = !v10668;
        if (v18048) {
          var v18047 = script$$1.limChar;
          v10668 = pos === v18047;
        }
        var inclusive = v10668;
        var minChar$$1 = cur$$2.minChar;
        var v10669 = cur$$2.limChar;
        var v18049;
        if (inclusive) {
          v18049 = 1;
        } else {
          v18049 = 0;
        }
        var v10670 = v18049;
        var limChar$$1 = v10669 + v10670;
        var v18050 = pos >= minChar$$1;
        if (v18050) {
          v18050 = pos < limChar$$1;
        }
        var v10674 = v18050;
        if (v10674) {
          var v10671 = ctx.path;
          var previous = v10671.ast();
          var v18051 = previous == null;
          var v22766 = !v18051;
          if (v22766) {
            var v25045 = cur$$2.minChar;
            var v25046 = previous.minChar;
            var v22765 = v25045 >= v25046;
            if (v22765) {
              var v25047 = cur$$2.limChar;
              var v25048 = previous.limChar;
              v22765 = v25047 <= v25048;
            }
            v18051 = v22765;
          }
          var v10673 = v18051;
          if (v10673) {
            var v10672 = ctx.path;
            v10672.push(cur$$2);
          } else {
          }
        }
        var v10676 = pos < limChar$$1;
        if (v10676) {
          var v10675 = cur$$2.preComments;
          lookInComments(v10675);
        }
        var v10678 = pos >= minChar$$1;
        if (v10678) {
          var v10677 = cur$$2.postComments;
          lookInComments(v10677);
        }
        var v22767 = GetAstPathOptions.DontPruneSearchBasedOnPosition;
        var v18052 = TypeScript$$7.hasFlag(options$$5, v22767);
        var v10680 = !v18052;
        if (v10680) {
          var v10679 = walker$$36.options;
          var v18053 = minChar$$1 <= pos;
          if (v18053) {
            v18053 = pos <= limChar$$1;
          }
          v10679.goChildren = v18053;
        }
      }
      return cur$$2;
    }
    function lookInComments(comments$$2) {
      var v18054 = comments$$2;
      if (v18054) {
        var v22768 = comments$$2.length;
        v18054 = v22768 > 0;
      }
      var v10689 = v18054;
      if (v10689) {
        var i$$26 = 0;
        var v18055 = comments$$2.length;
        var v10688 = i$$26 < v18055;
        for (;v10688;) {
          var v10682 = comments$$2[i$$26];
          var minChar = v10682.minChar;
          var v10683 = comments$$2[i$$26];
          var limChar = v10683.limChar;
          var v22769 = comments$$2[i$$26];
          var v18056 = v22769.isBlockComment;
          var v10684 = !v18056;
          if (v10684) {
            limChar = limChar + 1;
          }
          var v18057 = pos >= minChar;
          if (v18057) {
            v18057 = pos < limChar;
          }
          var v10687 = v18057;
          if (v10687) {
            var v10685 = ctx.path;
            var v10686 = comments$$2[i$$26];
            v10685.push(v10686);
          }
          i$$26 = i$$26 + 1;
          var v18058 = comments$$2.length;
          v10688 = i$$26 < v18058;
        }
      }
      return;
    }
    var v18059 = typeof options$$5;
    var v10690 = v18059 === "undefined";
    if (v10690) {
      options$$5 = GetAstPathOptions.Default;
    }
    var ctx = new AstPathContext;
    var v10691 = TypeScript$$7.getAstWalkerFactory();
    v10691.walk(script$$1, pre$$6, null, null, ctx);
    return ctx.path;
  }
  function getTokenizationOffset(script$$2, position) {
    function pre$$7(cur$$3, parent$$38, walker$$37) {
      var v10696 = TypeScript$$7.isValidAstNode(cur$$3);
      if (v10696) {
        var v18060 = cur$$3.minChar;
        var v10693 = v18060 <= position;
        if (v10693) {
          var v10692 = cur$$3.minChar;
          bestOffset = max(bestOffset, v10692);
        }
        var v22770 = cur$$3.minChar;
        var v18061 = v22770 > position;
        var v22772 = !v18061;
        if (v22772) {
          var v22771 = cur$$3.limChar;
          v18061 = v22771 < bestOffset;
        }
        var v10695 = v18061;
        if (v10695) {
          var v10694 = walker$$37.options;
          v10694.goChildren = false;
        }
      }
      return cur$$3;
    }
    var bestOffset = 0;
    var v10697 = TypeScript$$7.getAstWalkerFactory();
    v10697.walk(script$$2, pre$$7);
    return bestOffset;
  }
  function walkAST(ast$$7, callback$$27) {
    function post$$5(cur$$5, parent$$40, walker$$39) {
      var path$$5 = walker$$39.state;
      path$$5.pop();
      return cur$$5;
    }
    function pre$$8(cur$$4, parent$$39, walker$$38) {
      var path$$4 = walker$$38.state;
      path$$4.push(cur$$4);
      callback$$27(path$$4, walker$$38);
      return cur$$4;
    }
    var path$$3 = new AstPath;
    var v10698 = TypeScript$$7.getAstWalkerFactory();
    v10698.walk(ast$$7, pre$$8, post$$5, null, path$$3);
    return;
  }
  TypeScript$$7.lastOf = lastOf;
  TypeScript$$7.max = max;
  TypeScript$$7.min = min$$1;
  var AstPath = v396();
  TypeScript$$7.AstPath = AstPath;
  TypeScript$$7.isValidAstNode = isValidAstNode;
  var AstPathContext = v397();
  TypeScript$$7.AstPathContext = AstPathContext;
  var v18062 = TypeScript$$7.GetAstPathOptions;
  var v22773 = !v18062;
  if (v22773) {
    v18062 = TypeScript$$7.GetAstPathOptions = {};
  }
  var v10699 = v18062;
  v398(v10699);
  var GetAstPathOptions = TypeScript$$7.GetAstPathOptions;
  TypeScript$$7.getAstPathToPosition = getAstPathToPosition;
  TypeScript$$7.getTokenizationOffset = getTokenizationOffset;
  TypeScript$$7.walkAST = walkAST;
  return;
}
function v335(TypeScript$$6) {
  function v334(AstWalkerWithDetailCallback$$1) {
    function walk(script, callback$$25) {
      function post$$4(cur$$1, parent$$36) {
        AstWalkerCallback(false, cur$$1, callback$$25);
        return cur$$1;
      }
      function pre$$4(cur, parent$$35) {
        var v10700 = walker$$35.options;
        var v27330 = AstWalkerCallback(true, cur, callback$$25);
        v10700.goChildren = v27330;
        return cur;
      }
      var v10701 = TypeScript$$6.getAstWalkerFactory();
      var walker$$35 = v10701.getWalker(pre$$4, post$$4);
      walker$$35.walk(script, null);
      return;
    }
    function AstWalkerCallback(pre$$5, ast$$5, callback$$26) {
      var nodeType$$12 = ast$$5.nodeType;
      var v22774 = TypeScript$$6.NodeType;
      var v18063 = v22774._map;
      var v10702 = v18063[nodeType$$12];
      var callbackString = v10702 + "Callback";
      var v10703 = callback$$26[callbackString];
      if (v10703) {
        return callback$$26[callbackString](pre$$5, ast$$5);
      }
      var v10704 = callback$$26.DefaultCallback;
      if (v10704) {
        return callback$$26.DefaultCallback(pre$$5, ast$$5);
      }
      return true;
    }
    AstWalkerWithDetailCallback$$1.walk = walk;
    return;
  }
  var v18064 = TypeScript$$6.AstWalkerWithDetailCallback;
  var v22775 = !v18064;
  if (v22775) {
    v18064 = TypeScript$$6.AstWalkerWithDetailCallback = {};
  }
  var v10705 = v18064;
  v334(v10705);
  var AstWalkerWithDetailCallback = TypeScript$$6.AstWalkerWithDetailCallback;
  return;
}
function v333(TypeScript$$5) {
  function v332(ChildrenWalkers$$1) {
    function walkNone(preAst$$1, parent$$2, walker$$2) {
      return;
    }
    function walkListChildren(preAst$$2, parent$$3, walker$$3) {
      var v10706 = preAst$$2.members;
      var len$$6 = v10706.length;
      var v18065 = walker$$3.options;
      var v10715 = v18065.reverseSiblings;
      if (v10715) {
        var i$$25 = len$$6 - 1;
        var v10710 = i$$25 >= 0;
        for (;v10710;) {
          var v18066 = walker$$3.options;
          var v10709 = v18066.goNextSibling;
          if (v10709) {
            var v10707 = preAst$$2.members;
            var v10708 = i$$25;
            var v22776 = preAst$$2.members;
            var v18067 = v22776[i$$25];
            var v27331 = walker$$3.walk(v18067, preAst$$2);
            v10707[v10708] = v27331;
          }
          i$$25 = i$$25 - 1;
          v10710 = i$$25 >= 0;
        }
      } else {
        i$$25 = 0;
        var v10714 = i$$25 < len$$6;
        for (;v10714;) {
          var v18068 = walker$$3.options;
          var v10713 = v18068.goNextSibling;
          if (v10713) {
            var v10711 = preAst$$2.members;
            var v10712 = i$$25;
            var v22777 = preAst$$2.members;
            var v18069 = v22777[i$$25];
            var v27332 = walker$$3.walk(v18069, preAst$$2);
            v10711[v10712] = v27332;
          }
          i$$25 = i$$25 + 1;
          v10714 = i$$25 < len$$6;
        }
      }
      return;
    }
    function walkUnaryExpressionChildren(preAst$$3, parent$$4, walker$$4) {
      var v10717 = preAst$$3.castTerm;
      if (v10717) {
        var v10716 = preAst$$3;
        var v18070 = preAst$$3.castTerm;
        var v27333 = walker$$4.walk(v18070, preAst$$3);
        v10716.castTerm = v27333;
      }
      var v10719 = preAst$$3.operand;
      if (v10719) {
        var v10718 = preAst$$3;
        var v18071 = preAst$$3.operand;
        var v27334 = walker$$4.walk(v18071, preAst$$3);
        v10718.operand = v27334;
      }
      return;
    }
    function walkBinaryExpressionChildren(preAst$$4, parent$$5, walker$$5) {
      var v18072 = walker$$5.options;
      var v10728 = v18072.reverseSiblings;
      if (v10728) {
        var v10721 = preAst$$4.operand2;
        if (v10721) {
          var v10720 = preAst$$4;
          var v18073 = preAst$$4.operand2;
          var v27335 = walker$$5.walk(v18073, preAst$$4);
          v10720.operand2 = v27335;
        }
        var v18074 = preAst$$4.operand1;
        if (v18074) {
          var v22778 = walker$$5.options;
          v18074 = v22778.goNextSibling;
        }
        var v10723 = v18074;
        if (v10723) {
          var v10722 = preAst$$4;
          var v18075 = preAst$$4.operand1;
          var v27336 = walker$$5.walk(v18075, preAst$$4);
          v10722.operand1 = v27336;
        }
      } else {
        var v10725 = preAst$$4.operand1;
        if (v10725) {
          var v10724 = preAst$$4;
          var v18076 = preAst$$4.operand1;
          var v27337 = walker$$5.walk(v18076, preAst$$4);
          v10724.operand1 = v27337;
        }
        var v18077 = preAst$$4.operand2;
        if (v18077) {
          var v22779 = walker$$5.options;
          v18077 = v22779.goNextSibling;
        }
        var v10727 = v18077;
        if (v10727) {
          var v10726 = preAst$$4;
          var v18078 = preAst$$4.operand2;
          var v27338 = walker$$5.walk(v18078, preAst$$4);
          v10726.operand2 = v27338;
        }
      }
      return;
    }
    function walkTypeReferenceChildren(preAst$$5, parent$$6, walker$$6) {
      var v10730 = preAst$$5.term;
      if (v10730) {
        var v10729 = preAst$$5;
        var v18079 = preAst$$5.term;
        var v27339 = walker$$6.walk(v18079, preAst$$5);
        v10729.term = v27339;
      }
      return;
    }
    function walkCallExpressionChildren(preAst$$6, parent$$7, walker$$7) {
      var v22780 = walker$$7.options;
      var v18080 = v22780.reverseSiblings;
      var v10732 = !v18080;
      if (v10732) {
        var v10731 = preAst$$6;
        var v18081 = preAst$$6.target;
        var v27340 = walker$$7.walk(v18081, preAst$$6);
        v10731.target = v27340;
      }
      var v18082 = preAst$$6.arguments;
      if (v18082) {
        var v22781 = walker$$7.options;
        v18082 = v22781.goNextSibling;
      }
      var v10734 = v18082;
      if (v10734) {
        var v10733 = preAst$$6;
        var v18083 = preAst$$6.arguments;
        var v27341 = walker$$7.walk(v18083, preAst$$6);
        v10733.arguments = v27341;
      }
      var v22782 = walker$$7.options;
      var v18084 = v22782.reverseSiblings;
      if (v18084) {
        var v22783 = walker$$7.options;
        v18084 = v22783.goNextSibling;
      }
      var v10736 = v18084;
      if (v10736) {
        var v10735 = preAst$$6;
        var v18085 = preAst$$6.target;
        var v27342 = walker$$7.walk(v18085, preAst$$6);
        v10735.target = v27342;
      }
      return;
    }
    function walkTrinaryExpressionChildren(preAst$$7, parent$$8, walker$$8) {
      var v10738 = preAst$$7.operand1;
      if (v10738) {
        var v10737 = preAst$$7;
        var v18086 = preAst$$7.operand1;
        var v27343 = walker$$8.walk(v18086, preAst$$7);
        v10737.operand1 = v27343;
      }
      var v18087 = preAst$$7.operand2;
      if (v18087) {
        var v22784 = walker$$8.options;
        v18087 = v22784.goNextSibling;
      }
      var v10740 = v18087;
      if (v10740) {
        var v10739 = preAst$$7;
        var v18088 = preAst$$7.operand2;
        var v27344 = walker$$8.walk(v18088, preAst$$7);
        v10739.operand2 = v27344;
      }
      var v18089 = preAst$$7.operand3;
      if (v18089) {
        var v22785 = walker$$8.options;
        v18089 = v22785.goNextSibling;
      }
      var v10742 = v18089;
      if (v10742) {
        var v10741 = preAst$$7;
        var v18090 = preAst$$7.operand3;
        var v27345 = walker$$8.walk(v18090, preAst$$7);
        v10741.operand3 = v27345;
      }
      return;
    }
    function walkFuncDeclChildren(preAst$$8, parent$$9, walker$$9) {
      var v10744 = preAst$$8.name;
      if (v10744) {
        var v10743 = preAst$$8;
        var v18091 = preAst$$8.name;
        var v27346 = walker$$9.walk(v18091, preAst$$8);
        v10743.name = v27346;
      }
      var v22786 = preAst$$8.arguments;
      if (v22786) {
        var v26397 = preAst$$8.arguments;
        var v25988 = v26397.members;
        var v25049 = v25988.length;
        v22786 = v25049 > 0;
      }
      var v18092 = v22786;
      if (v18092) {
        var v22787 = walker$$9.options;
        v18092 = v22787.goNextSibling;
      }
      var v10746 = v18092;
      if (v10746) {
        var v10745 = preAst$$8;
        var v18093 = preAst$$8.arguments;
        var v27347 = walker$$9.walk(v18093, preAst$$8);
        v10745.arguments = v27347;
      }
      var v18094 = preAst$$8.returnTypeAnnotation;
      if (v18094) {
        var v22788 = walker$$9.options;
        v18094 = v22788.goNextSibling;
      }
      var v10748 = v18094;
      if (v10748) {
        var v10747 = preAst$$8;
        var v18095 = preAst$$8.returnTypeAnnotation;
        var v27348 = walker$$9.walk(v18095, preAst$$8);
        v10747.returnTypeAnnotation = v27348;
      }
      var v22789 = preAst$$8.bod;
      if (v22789) {
        var v26398 = preAst$$8.bod;
        var v25989 = v26398.members;
        var v25050 = v25989.length;
        v22789 = v25050 > 0;
      }
      var v18096 = v22789;
      if (v18096) {
        var v22790 = walker$$9.options;
        v18096 = v22790.goNextSibling;
      }
      var v10750 = v18096;
      if (v10750) {
        var v10749 = preAst$$8;
        var v18097 = preAst$$8.bod;
        var v27349 = walker$$9.walk(v18097, preAst$$8);
        v10749.bod = v27349;
      }
      return;
    }
    function walkBoundDeclChildren(preAst$$9, parent$$10, walker$$10) {
      var v10752 = preAst$$9.id;
      if (v10752) {
        var v10751 = preAst$$9;
        var v18098 = preAst$$9.id;
        var v27350 = walker$$10.walk(v18098, preAst$$9);
        v10751.id = v27350;
      }
      var v10754 = preAst$$9.init;
      if (v10754) {
        var v10753 = preAst$$9;
        var v18099 = preAst$$9.init;
        var v27351 = walker$$10.walk(v18099, preAst$$9);
        v10753.init = v27351;
      }
      var v18100 = preAst$$9.typeExpr;
      if (v18100) {
        var v22791 = walker$$10.options;
        v18100 = v22791.goNextSibling;
      }
      var v10756 = v18100;
      if (v10756) {
        var v10755 = preAst$$9;
        var v18101 = preAst$$9.typeExpr;
        var v27352 = walker$$10.walk(v18101, preAst$$9);
        v10755.typeExpr = v27352;
      }
      return;
    }
    function walkReturnStatementChildren(preAst$$10, parent$$11, walker$$11) {
      var v10758 = preAst$$10.returnExpression;
      if (v10758) {
        var v10757 = preAst$$10;
        var v18102 = preAst$$10.returnExpression;
        var v27353 = walker$$11.walk(v18102, preAst$$10);
        v10757.returnExpression = v27353;
      }
      return;
    }
    function walkForStatementChildren(preAst$$11, parent$$12, walker$$12) {
      var v10760 = preAst$$11.init;
      if (v10760) {
        var v10759 = preAst$$11;
        var v18103 = preAst$$11.init;
        var v27354 = walker$$12.walk(v18103, preAst$$11);
        v10759.init = v27354;
      }
      var v18104 = preAst$$11.cond;
      if (v18104) {
        var v22792 = walker$$12.options;
        v18104 = v22792.goNextSibling;
      }
      var v10762 = v18104;
      if (v10762) {
        var v10761 = preAst$$11;
        var v18105 = preAst$$11.cond;
        var v27355 = walker$$12.walk(v18105, preAst$$11);
        v10761.cond = v27355;
      }
      var v18106 = preAst$$11.incr;
      if (v18106) {
        var v22793 = walker$$12.options;
        v18106 = v22793.goNextSibling;
      }
      var v10764 = v18106;
      if (v10764) {
        var v10763 = preAst$$11;
        var v18107 = preAst$$11.incr;
        var v27356 = walker$$12.walk(v18107, preAst$$11);
        v10763.incr = v27356;
      }
      var v18108 = preAst$$11.body;
      if (v18108) {
        var v22794 = walker$$12.options;
        v18108 = v22794.goNextSibling;
      }
      var v10766 = v18108;
      if (v10766) {
        var v10765 = preAst$$11;
        var v18109 = preAst$$11.body;
        var v27357 = walker$$12.walk(v18109, preAst$$11);
        v10765.body = v27357;
      }
      return;
    }
    function walkForInStatementChildren(preAst$$12, parent$$13, walker$$13) {
      var v10767 = preAst$$12;
      var v18110 = preAst$$12.lval;
      var v27358 = walker$$13.walk(v18110, preAst$$12);
      v10767.lval = v27358;
      var v18111 = walker$$13.options;
      var v10769 = v18111.goNextSibling;
      if (v10769) {
        var v10768 = preAst$$12;
        var v18112 = preAst$$12.obj;
        var v27359 = walker$$13.walk(v18112, preAst$$12);
        v10768.obj = v27359;
      }
      var v18113 = preAst$$12.body;
      if (v18113) {
        var v22795 = walker$$13.options;
        v18113 = v22795.goNextSibling;
      }
      var v10771 = v18113;
      if (v10771) {
        var v10770 = preAst$$12;
        var v18114 = preAst$$12.body;
        var v27360 = walker$$13.walk(v18114, preAst$$12);
        v10770.body = v27360;
      }
      return;
    }
    function walkIfStatementChildren(preAst$$13, parent$$14, walker$$14) {
      var v10772 = preAst$$13;
      var v18115 = preAst$$13.cond;
      var v27361 = walker$$14.walk(v18115, preAst$$13);
      v10772.cond = v27361;
      var v18116 = preAst$$13.thenBod;
      if (v18116) {
        var v22796 = walker$$14.options;
        v18116 = v22796.goNextSibling;
      }
      var v10774 = v18116;
      if (v10774) {
        var v10773 = preAst$$13;
        var v18117 = preAst$$13.thenBod;
        var v27362 = walker$$14.walk(v18117, preAst$$13);
        v10773.thenBod = v27362;
      }
      var v18118 = preAst$$13.elseBod;
      if (v18118) {
        var v22797 = walker$$14.options;
        v18118 = v22797.goNextSibling;
      }
      var v10776 = v18118;
      if (v10776) {
        var v10775 = preAst$$13;
        var v18119 = preAst$$13.elseBod;
        var v27363 = walker$$14.walk(v18119, preAst$$13);
        v10775.elseBod = v27363;
      }
      return;
    }
    function walkWhileStatementChildren(preAst$$14, parent$$15, walker$$15) {
      var v10777 = preAst$$14;
      var v18120 = preAst$$14.cond;
      var v27364 = walker$$15.walk(v18120, preAst$$14);
      v10777.cond = v27364;
      var v18121 = preAst$$14.body;
      if (v18121) {
        var v22798 = walker$$15.options;
        v18121 = v22798.goNextSibling;
      }
      var v10779 = v18121;
      if (v10779) {
        var v10778 = preAst$$14;
        var v18122 = preAst$$14.body;
        var v27365 = walker$$15.walk(v18122, preAst$$14);
        v10778.body = v27365;
      }
      return;
    }
    function walkDoWhileStatementChildren(preAst$$15, parent$$16, walker$$16) {
      var v10780 = preAst$$15;
      var v18123 = preAst$$15.cond;
      var v27366 = walker$$16.walk(v18123, preAst$$15);
      v10780.cond = v27366;
      var v18124 = preAst$$15.body;
      if (v18124) {
        var v22799 = walker$$16.options;
        v18124 = v22799.goNextSibling;
      }
      var v10782 = v18124;
      if (v10782) {
        var v10781 = preAst$$15;
        var v18125 = preAst$$15.body;
        var v27367 = walker$$16.walk(v18125, preAst$$15);
        v10781.body = v27367;
      }
      return;
    }
    function walkBlockChildren(preAst$$16, parent$$17, walker$$17) {
      var v10784 = preAst$$16.statements;
      if (v10784) {
        var v10783 = preAst$$16;
        var v18126 = preAst$$16.statements;
        var v27368 = walker$$17.walk(v18126, preAst$$16);
        v10783.statements = v27368;
      }
      return;
    }
    function walkCaseStatementChildren(preAst$$17, parent$$18, walker$$18) {
      var v10786 = preAst$$17.expr;
      if (v10786) {
        var v10785 = preAst$$17;
        var v18127 = preAst$$17.expr;
        var v27369 = walker$$18.walk(v18127, preAst$$17);
        v10785.expr = v27369;
      }
      var v18128 = preAst$$17.body;
      if (v18128) {
        var v22800 = walker$$18.options;
        v18128 = v22800.goNextSibling;
      }
      var v10788 = v18128;
      if (v10788) {
        var v10787 = preAst$$17;
        var v18129 = preAst$$17.body;
        var v27370 = walker$$18.walk(v18129, preAst$$17);
        v10787.body = v27370;
      }
      return;
    }
    function walkSwitchStatementChildren(preAst$$18, parent$$19, walker$$19) {
      var v10790 = preAst$$18.val;
      if (v10790) {
        var v10789 = preAst$$18;
        var v18130 = preAst$$18.val;
        var v27371 = walker$$19.walk(v18130, preAst$$18);
        v10789.val = v27371;
      }
      var v18131 = preAst$$18.caseList;
      if (v18131) {
        var v22801 = walker$$19.options;
        v18131 = v22801.goNextSibling;
      }
      var v10792 = v18131;
      if (v10792) {
        var v10791 = preAst$$18;
        var v18132 = preAst$$18.caseList;
        var v27372 = walker$$19.walk(v18132, preAst$$18);
        v10791.caseList = v27372;
      }
      return;
    }
    function walkTryChildren(preAst$$19, parent$$20, walker$$20) {
      var v10794 = preAst$$19.body;
      if (v10794) {
        var v10793 = preAst$$19;
        var v18133 = preAst$$19.body;
        var v27373 = walker$$20.walk(v18133, preAst$$19);
        v10793.body = v27373;
      }
      return;
    }
    function walkTryCatchChildren(preAst$$20, parent$$21, walker$$21) {
      var v10796 = preAst$$20.tryNode;
      if (v10796) {
        var v10795 = preAst$$20;
        var v18134 = preAst$$20.tryNode;
        var v27374 = walker$$21.walk(v18134, preAst$$20);
        v10795.tryNode = v27374;
      }
      var v18135 = preAst$$20.catchNode;
      if (v18135) {
        var v22802 = walker$$21.options;
        v18135 = v22802.goNextSibling;
      }
      var v10798 = v18135;
      if (v10798) {
        var v10797 = preAst$$20;
        var v18136 = preAst$$20.catchNode;
        var v27375 = walker$$21.walk(v18136, preAst$$20);
        v10797.catchNode = v27375;
      }
      return;
    }
    function walkTryFinallyChildren(preAst$$21, parent$$22, walker$$22) {
      var v10800 = preAst$$21.tryNode;
      if (v10800) {
        var v10799 = preAst$$21;
        var v18137 = preAst$$21.tryNode;
        var v27376 = walker$$22.walk(v18137, preAst$$21);
        v10799.tryNode = v27376;
      }
      var v18138 = preAst$$21.finallyNode;
      if (v18138) {
        var v22803 = walker$$22.options;
        v18138 = v22803.goNextSibling;
      }
      var v10802 = v18138;
      if (v10802) {
        var v10801 = preAst$$21;
        var v18139 = preAst$$21.finallyNode;
        var v27377 = walker$$22.walk(v18139, preAst$$21);
        v10801.finallyNode = v27377;
      }
      return;
    }
    function walkFinallyChildren(preAst$$22, parent$$23, walker$$23) {
      var v10804 = preAst$$22.body;
      if (v10804) {
        var v10803 = preAst$$22;
        var v18140 = preAst$$22.body;
        var v27378 = walker$$23.walk(v18140, preAst$$22);
        v10803.body = v27378;
      }
      return;
    }
    function walkCatchChildren(preAst$$23, parent$$24, walker$$24) {
      var v10806 = preAst$$23.param;
      if (v10806) {
        var v10805 = preAst$$23;
        var v18141 = preAst$$23.param;
        var v27379 = walker$$24.walk(v18141, preAst$$23);
        v10805.param = v27379;
      }
      var v18142 = preAst$$23.body;
      if (v18142) {
        var v22804 = walker$$24.options;
        v18142 = v22804.goNextSibling;
      }
      var v10808 = v18142;
      if (v10808) {
        var v10807 = preAst$$23;
        var v18143 = preAst$$23.body;
        var v27380 = walker$$24.walk(v18143, preAst$$23);
        v10807.body = v27380;
      }
      return;
    }
    function walkRecordChildren(preAst$$24, parent$$25, walker$$25) {
      var v10809 = preAst$$24;
      var v18144 = preAst$$24.name;
      var v27381 = walker$$25.walk(v18144, preAst$$24);
      v10809.name = v27381;
      var v22805 = walker$$25.options;
      var v18145 = v22805.goNextSibling;
      if (v18145) {
        v18145 = preAst$$24.members;
      }
      var v10811 = v18145;
      if (v10811) {
        var v10810 = preAst$$24;
        var v18146 = preAst$$24.members;
        var v27382 = walker$$25.walk(v18146, preAst$$24);
        v10810.members = v27382;
      }
      return;
    }
    function walkNamedTypeChildren(preAst$$25, parent$$26, walker$$26) {
      walkRecordChildren(preAst$$25, parent$$26, walker$$26);
      return;
    }
    function walkClassDeclChildren(preAst$$26, parent$$27, walker$$27) {
      walkRecordChildren(preAst$$26, parent$$27, walker$$27);
      var v22806 = walker$$27.options;
      var v18147 = v22806.goNextSibling;
      if (v18147) {
        v18147 = preAst$$26.extendsList;
      }
      var v10813 = v18147;
      if (v10813) {
        var v10812 = preAst$$26;
        var v18148 = preAst$$26.extendsList;
        var v27383 = walker$$27.walk(v18148, preAst$$26);
        v10812.extendsList = v27383;
      }
      var v22807 = walker$$27.options;
      var v18149 = v22807.goNextSibling;
      if (v18149) {
        v18149 = preAst$$26.implementsList;
      }
      var v10815 = v18149;
      if (v10815) {
        var v10814 = preAst$$26;
        var v18150 = preAst$$26.implementsList;
        var v27384 = walker$$27.walk(v18150, preAst$$26);
        v10814.implementsList = v27384;
      }
      return;
    }
    function walkScriptChildren(preAst$$27, parent$$28, walker$$28) {
      var v10817 = preAst$$27.bod;
      if (v10817) {
        var v10816 = preAst$$27;
        var v18151 = preAst$$27.bod;
        var v27385 = walker$$28.walk(v18151, preAst$$27);
        v10816.bod = v27385;
      }
      return;
    }
    function walkTypeDeclChildren(preAst$$28, parent$$29, walker$$29) {
      walkRecordChildren(preAst$$28, parent$$29, walker$$29);
      var v22808 = walker$$29.options;
      var v18152 = v22808.goNextSibling;
      if (v18152) {
        v18152 = preAst$$28.extendsList;
      }
      var v10819 = v18152;
      if (v10819) {
        var v10818 = preAst$$28;
        var v18153 = preAst$$28.extendsList;
        var v27386 = walker$$29.walk(v18153, preAst$$28);
        v10818.extendsList = v27386;
      }
      var v22809 = walker$$29.options;
      var v18154 = v22809.goNextSibling;
      if (v18154) {
        v18154 = preAst$$28.implementsList;
      }
      var v10821 = v18154;
      if (v10821) {
        var v10820 = preAst$$28;
        var v18155 = preAst$$28.implementsList;
        var v27387 = walker$$29.walk(v18155, preAst$$28);
        v10820.implementsList = v27387;
      }
      return;
    }
    function walkModuleDeclChildren(preAst$$29, parent$$30, walker$$30) {
      walkRecordChildren(preAst$$29, parent$$30, walker$$30);
      return;
    }
    function walkImportDeclChildren(preAst$$30, parent$$31, walker$$31) {
      var v10823 = preAst$$30.id;
      if (v10823) {
        var v10822 = preAst$$30;
        var v18156 = preAst$$30.id;
        var v27388 = walker$$31.walk(v18156, preAst$$30);
        v10822.id = v27388;
      }
      var v10825 = preAst$$30.alias;
      if (v10825) {
        var v10824 = preAst$$30;
        var v18157 = preAst$$30.alias;
        var v27389 = walker$$31.walk(v18157, preAst$$30);
        v10824.alias = v27389;
      }
      return;
    }
    function walkWithStatementChildren(preAst$$31, parent$$32, walker$$32) {
      var v10827 = preAst$$31.expr;
      if (v10827) {
        var v10826 = preAst$$31;
        var v18158 = preAst$$31.expr;
        var v27390 = walker$$32.walk(v18158, preAst$$31);
        v10826.expr = v27390;
      }
      var v18159 = preAst$$31.body;
      if (v18159) {
        var v22810 = walker$$32.options;
        v18159 = v22810.goNextSibling;
      }
      var v10829 = v18159;
      if (v10829) {
        var v10828 = preAst$$31;
        var v18160 = preAst$$31.body;
        var v27391 = walker$$32.walk(v18160, preAst$$31);
        v10828.body = v27391;
      }
      return;
    }
    function walkLabelChildren(preAst$$32, parent$$33, walker$$33) {
      return;
    }
    function walkLabeledStatementChildren(preAst$$33, parent$$34, walker$$34) {
      var v10830 = preAst$$33;
      var v18161 = preAst$$33.labels;
      var v27392 = walker$$34.walk(v18161, preAst$$33);
      v10830.labels = v27392;
      var v18162 = walker$$34.options;
      var v10832 = v18162.goNextSibling;
      if (v10832) {
        var v10831 = preAst$$33;
        var v18163 = preAst$$33.stmt;
        var v27393 = walker$$34.walk(v18163, preAst$$33);
        v10831.stmt = v27393;
      }
      return;
    }
    ChildrenWalkers$$1.walkNone = walkNone;
    ChildrenWalkers$$1.walkListChildren = walkListChildren;
    ChildrenWalkers$$1.walkUnaryExpressionChildren = walkUnaryExpressionChildren;
    ChildrenWalkers$$1.walkBinaryExpressionChildren = walkBinaryExpressionChildren;
    ChildrenWalkers$$1.walkTypeReferenceChildren = walkTypeReferenceChildren;
    ChildrenWalkers$$1.walkCallExpressionChildren = walkCallExpressionChildren;
    ChildrenWalkers$$1.walkTrinaryExpressionChildren = walkTrinaryExpressionChildren;
    ChildrenWalkers$$1.walkFuncDeclChildren = walkFuncDeclChildren;
    ChildrenWalkers$$1.walkBoundDeclChildren = walkBoundDeclChildren;
    ChildrenWalkers$$1.walkReturnStatementChildren = walkReturnStatementChildren;
    ChildrenWalkers$$1.walkForStatementChildren = walkForStatementChildren;
    ChildrenWalkers$$1.walkForInStatementChildren = walkForInStatementChildren;
    ChildrenWalkers$$1.walkIfStatementChildren = walkIfStatementChildren;
    ChildrenWalkers$$1.walkWhileStatementChildren = walkWhileStatementChildren;
    ChildrenWalkers$$1.walkDoWhileStatementChildren = walkDoWhileStatementChildren;
    ChildrenWalkers$$1.walkBlockChildren = walkBlockChildren;
    ChildrenWalkers$$1.walkCaseStatementChildren = walkCaseStatementChildren;
    ChildrenWalkers$$1.walkSwitchStatementChildren = walkSwitchStatementChildren;
    ChildrenWalkers$$1.walkTryChildren = walkTryChildren;
    ChildrenWalkers$$1.walkTryCatchChildren = walkTryCatchChildren;
    ChildrenWalkers$$1.walkTryFinallyChildren = walkTryFinallyChildren;
    ChildrenWalkers$$1.walkFinallyChildren = walkFinallyChildren;
    ChildrenWalkers$$1.walkCatchChildren = walkCatchChildren;
    ChildrenWalkers$$1.walkRecordChildren = walkRecordChildren;
    ChildrenWalkers$$1.walkNamedTypeChildren = walkNamedTypeChildren;
    ChildrenWalkers$$1.walkClassDeclChildren = walkClassDeclChildren;
    ChildrenWalkers$$1.walkScriptChildren = walkScriptChildren;
    ChildrenWalkers$$1.walkTypeDeclChildren = walkTypeDeclChildren;
    ChildrenWalkers$$1.walkModuleDeclChildren = walkModuleDeclChildren;
    ChildrenWalkers$$1.walkImportDeclChildren = walkImportDeclChildren;
    ChildrenWalkers$$1.walkWithStatementChildren = walkWithStatementChildren;
    ChildrenWalkers$$1.walkLabelChildren = walkLabelChildren;
    ChildrenWalkers$$1.walkLabeledStatementChildren = walkLabeledStatementChildren;
    return;
  }
  function v331() {
    function v330() {
      var v10833 = this.childrenWalkers;
      var v18164 = TypeScript$$5.NodeType;
      var v10834 = v18164.None;
      v10833[v10834] = ChildrenWalkers.walkNone;
      var v10835 = this.childrenWalkers;
      var v18165 = TypeScript$$5.NodeType;
      var v10836 = v18165.Empty;
      v10835[v10836] = ChildrenWalkers.walkNone;
      var v10837 = this.childrenWalkers;
      var v18166 = TypeScript$$5.NodeType;
      var v10838 = v18166.EmptyExpr;
      v10837[v10838] = ChildrenWalkers.walkNone;
      var v10839 = this.childrenWalkers;
      var v18167 = TypeScript$$5.NodeType;
      var v10840 = v18167.True;
      v10839[v10840] = ChildrenWalkers.walkNone;
      var v10841 = this.childrenWalkers;
      var v18168 = TypeScript$$5.NodeType;
      var v10842 = v18168.False;
      v10841[v10842] = ChildrenWalkers.walkNone;
      var v10843 = this.childrenWalkers;
      var v18169 = TypeScript$$5.NodeType;
      var v10844 = v18169.This;
      v10843[v10844] = ChildrenWalkers.walkNone;
      var v10845 = this.childrenWalkers;
      var v18170 = TypeScript$$5.NodeType;
      var v10846 = v18170.Super;
      v10845[v10846] = ChildrenWalkers.walkNone;
      var v10847 = this.childrenWalkers;
      var v18171 = TypeScript$$5.NodeType;
      var v10848 = v18171.QString;
      v10847[v10848] = ChildrenWalkers.walkNone;
      var v10849 = this.childrenWalkers;
      var v18172 = TypeScript$$5.NodeType;
      var v10850 = v18172.Regex;
      v10849[v10850] = ChildrenWalkers.walkNone;
      var v10851 = this.childrenWalkers;
      var v18173 = TypeScript$$5.NodeType;
      var v10852 = v18173.Null;
      v10851[v10852] = ChildrenWalkers.walkNone;
      var v10853 = this.childrenWalkers;
      var v18174 = TypeScript$$5.NodeType;
      var v10854 = v18174.ArrayLit;
      v10853[v10854] = ChildrenWalkers.walkUnaryExpressionChildren;
      var v10855 = this.childrenWalkers;
      var v18175 = TypeScript$$5.NodeType;
      var v10856 = v18175.ObjectLit;
      v10855[v10856] = ChildrenWalkers.walkUnaryExpressionChildren;
      var v10857 = this.childrenWalkers;
      var v18176 = TypeScript$$5.NodeType;
      var v10858 = v18176.Void;
      v10857[v10858] = ChildrenWalkers.walkUnaryExpressionChildren;
      var v10859 = this.childrenWalkers;
      var v18177 = TypeScript$$5.NodeType;
      var v10860 = v18177.Comma;
      v10859[v10860] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10861 = this.childrenWalkers;
      var v18178 = TypeScript$$5.NodeType;
      var v10862 = v18178.Pos;
      v10861[v10862] = ChildrenWalkers.walkUnaryExpressionChildren;
      var v10863 = this.childrenWalkers;
      var v18179 = TypeScript$$5.NodeType;
      var v10864 = v18179.Neg;
      v10863[v10864] = ChildrenWalkers.walkUnaryExpressionChildren;
      var v10865 = this.childrenWalkers;
      var v18180 = TypeScript$$5.NodeType;
      var v10866 = v18180.Delete;
      v10865[v10866] = ChildrenWalkers.walkUnaryExpressionChildren;
      var v10867 = this.childrenWalkers;
      var v18181 = TypeScript$$5.NodeType;
      var v10868 = v18181.Await;
      v10867[v10868] = ChildrenWalkers.walkUnaryExpressionChildren;
      var v10869 = this.childrenWalkers;
      var v18182 = TypeScript$$5.NodeType;
      var v10870 = v18182.In;
      v10869[v10870] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10871 = this.childrenWalkers;
      var v18183 = TypeScript$$5.NodeType;
      var v10872 = v18183.Dot;
      v10871[v10872] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10873 = this.childrenWalkers;
      var v18184 = TypeScript$$5.NodeType;
      var v10874 = v18184.From;
      v10873[v10874] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10875 = this.childrenWalkers;
      var v18185 = TypeScript$$5.NodeType;
      var v10876 = v18185.Is;
      v10875[v10876] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10877 = this.childrenWalkers;
      var v18186 = TypeScript$$5.NodeType;
      var v10878 = v18186.InstOf;
      v10877[v10878] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10879 = this.childrenWalkers;
      var v18187 = TypeScript$$5.NodeType;
      var v10880 = v18187.Typeof;
      v10879[v10880] = ChildrenWalkers.walkUnaryExpressionChildren;
      var v10881 = this.childrenWalkers;
      var v18188 = TypeScript$$5.NodeType;
      var v10882 = v18188.NumberLit;
      v10881[v10882] = ChildrenWalkers.walkNone;
      var v10883 = this.childrenWalkers;
      var v18189 = TypeScript$$5.NodeType;
      var v10884 = v18189.Name;
      v10883[v10884] = ChildrenWalkers.walkNone;
      var v10885 = this.childrenWalkers;
      var v18190 = TypeScript$$5.NodeType;
      var v10886 = v18190.TypeRef;
      v10885[v10886] = ChildrenWalkers.walkTypeReferenceChildren;
      var v10887 = this.childrenWalkers;
      var v18191 = TypeScript$$5.NodeType;
      var v10888 = v18191.Index;
      v10887[v10888] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10889 = this.childrenWalkers;
      var v18192 = TypeScript$$5.NodeType;
      var v10890 = v18192.Call;
      v10889[v10890] = ChildrenWalkers.walkCallExpressionChildren;
      var v10891 = this.childrenWalkers;
      var v18193 = TypeScript$$5.NodeType;
      var v10892 = v18193.New;
      v10891[v10892] = ChildrenWalkers.walkCallExpressionChildren;
      var v10893 = this.childrenWalkers;
      var v18194 = TypeScript$$5.NodeType;
      var v10894 = v18194.Asg;
      v10893[v10894] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10895 = this.childrenWalkers;
      var v18195 = TypeScript$$5.NodeType;
      var v10896 = v18195.AsgAdd;
      v10895[v10896] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10897 = this.childrenWalkers;
      var v18196 = TypeScript$$5.NodeType;
      var v10898 = v18196.AsgSub;
      v10897[v10898] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10899 = this.childrenWalkers;
      var v18197 = TypeScript$$5.NodeType;
      var v10900 = v18197.AsgDiv;
      v10899[v10900] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10901 = this.childrenWalkers;
      var v18198 = TypeScript$$5.NodeType;
      var v10902 = v18198.AsgMul;
      v10901[v10902] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10903 = this.childrenWalkers;
      var v18199 = TypeScript$$5.NodeType;
      var v10904 = v18199.AsgMod;
      v10903[v10904] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10905 = this.childrenWalkers;
      var v18200 = TypeScript$$5.NodeType;
      var v10906 = v18200.AsgAnd;
      v10905[v10906] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10907 = this.childrenWalkers;
      var v18201 = TypeScript$$5.NodeType;
      var v10908 = v18201.AsgXor;
      v10907[v10908] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10909 = this.childrenWalkers;
      var v18202 = TypeScript$$5.NodeType;
      var v10910 = v18202.AsgOr;
      v10909[v10910] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10911 = this.childrenWalkers;
      var v18203 = TypeScript$$5.NodeType;
      var v10912 = v18203.AsgLsh;
      v10911[v10912] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10913 = this.childrenWalkers;
      var v18204 = TypeScript$$5.NodeType;
      var v10914 = v18204.AsgRsh;
      v10913[v10914] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10915 = this.childrenWalkers;
      var v18205 = TypeScript$$5.NodeType;
      var v10916 = v18205.AsgRs2;
      v10915[v10916] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10917 = this.childrenWalkers;
      var v18206 = TypeScript$$5.NodeType;
      var v10918 = v18206.ConditionalExpression;
      v10917[v10918] = ChildrenWalkers.walkTrinaryExpressionChildren;
      var v10919 = this.childrenWalkers;
      var v18207 = TypeScript$$5.NodeType;
      var v10920 = v18207.LogOr;
      v10919[v10920] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10921 = this.childrenWalkers;
      var v18208 = TypeScript$$5.NodeType;
      var v10922 = v18208.LogAnd;
      v10921[v10922] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10923 = this.childrenWalkers;
      var v18209 = TypeScript$$5.NodeType;
      var v10924 = v18209.Or;
      v10923[v10924] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10925 = this.childrenWalkers;
      var v18210 = TypeScript$$5.NodeType;
      var v10926 = v18210.Xor;
      v10925[v10926] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10927 = this.childrenWalkers;
      var v18211 = TypeScript$$5.NodeType;
      var v10928 = v18211.And;
      v10927[v10928] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10929 = this.childrenWalkers;
      var v18212 = TypeScript$$5.NodeType;
      var v10930 = v18212.Eq;
      v10929[v10930] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10931 = this.childrenWalkers;
      var v18213 = TypeScript$$5.NodeType;
      var v10932 = v18213.Ne;
      v10931[v10932] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10933 = this.childrenWalkers;
      var v18214 = TypeScript$$5.NodeType;
      var v10934 = v18214.Eqv;
      v10933[v10934] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10935 = this.childrenWalkers;
      var v18215 = TypeScript$$5.NodeType;
      var v10936 = v18215.NEqv;
      v10935[v10936] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10937 = this.childrenWalkers;
      var v18216 = TypeScript$$5.NodeType;
      var v10938 = v18216.Lt;
      v10937[v10938] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10939 = this.childrenWalkers;
      var v18217 = TypeScript$$5.NodeType;
      var v10940 = v18217.Le;
      v10939[v10940] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10941 = this.childrenWalkers;
      var v18218 = TypeScript$$5.NodeType;
      var v10942 = v18218.Gt;
      v10941[v10942] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10943 = this.childrenWalkers;
      var v18219 = TypeScript$$5.NodeType;
      var v10944 = v18219.Ge;
      v10943[v10944] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10945 = this.childrenWalkers;
      var v18220 = TypeScript$$5.NodeType;
      var v10946 = v18220.Add;
      v10945[v10946] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10947 = this.childrenWalkers;
      var v18221 = TypeScript$$5.NodeType;
      var v10948 = v18221.Sub;
      v10947[v10948] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10949 = this.childrenWalkers;
      var v18222 = TypeScript$$5.NodeType;
      var v10950 = v18222.Mul;
      v10949[v10950] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10951 = this.childrenWalkers;
      var v18223 = TypeScript$$5.NodeType;
      var v10952 = v18223.Div;
      v10951[v10952] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10953 = this.childrenWalkers;
      var v18224 = TypeScript$$5.NodeType;
      var v10954 = v18224.Mod;
      v10953[v10954] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10955 = this.childrenWalkers;
      var v18225 = TypeScript$$5.NodeType;
      var v10956 = v18225.Lsh;
      v10955[v10956] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10957 = this.childrenWalkers;
      var v18226 = TypeScript$$5.NodeType;
      var v10958 = v18226.Rsh;
      v10957[v10958] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10959 = this.childrenWalkers;
      var v18227 = TypeScript$$5.NodeType;
      var v10960 = v18227.Rs2;
      v10959[v10960] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10961 = this.childrenWalkers;
      var v18228 = TypeScript$$5.NodeType;
      var v10962 = v18228.Not;
      v10961[v10962] = ChildrenWalkers.walkUnaryExpressionChildren;
      var v10963 = this.childrenWalkers;
      var v18229 = TypeScript$$5.NodeType;
      var v10964 = v18229.LogNot;
      v10963[v10964] = ChildrenWalkers.walkUnaryExpressionChildren;
      var v10965 = this.childrenWalkers;
      var v18230 = TypeScript$$5.NodeType;
      var v10966 = v18230.IncPre;
      v10965[v10966] = ChildrenWalkers.walkUnaryExpressionChildren;
      var v10967 = this.childrenWalkers;
      var v18231 = TypeScript$$5.NodeType;
      var v10968 = v18231.DecPre;
      v10967[v10968] = ChildrenWalkers.walkUnaryExpressionChildren;
      var v10969 = this.childrenWalkers;
      var v18232 = TypeScript$$5.NodeType;
      var v10970 = v18232.IncPost;
      v10969[v10970] = ChildrenWalkers.walkUnaryExpressionChildren;
      var v10971 = this.childrenWalkers;
      var v18233 = TypeScript$$5.NodeType;
      var v10972 = v18233.DecPost;
      v10971[v10972] = ChildrenWalkers.walkUnaryExpressionChildren;
      var v10973 = this.childrenWalkers;
      var v18234 = TypeScript$$5.NodeType;
      var v10974 = v18234.TypeAssertion;
      v10973[v10974] = ChildrenWalkers.walkUnaryExpressionChildren;
      var v10975 = this.childrenWalkers;
      var v18235 = TypeScript$$5.NodeType;
      var v10976 = v18235.FuncDecl;
      v10975[v10976] = ChildrenWalkers.walkFuncDeclChildren;
      var v10977 = this.childrenWalkers;
      var v18236 = TypeScript$$5.NodeType;
      var v10978 = v18236.Member;
      v10977[v10978] = ChildrenWalkers.walkBinaryExpressionChildren;
      var v10979 = this.childrenWalkers;
      var v18237 = TypeScript$$5.NodeType;
      var v10980 = v18237.VarDecl;
      v10979[v10980] = ChildrenWalkers.walkBoundDeclChildren;
      var v10981 = this.childrenWalkers;
      var v18238 = TypeScript$$5.NodeType;
      var v10982 = v18238.ArgDecl;
      v10981[v10982] = ChildrenWalkers.walkBoundDeclChildren;
      var v10983 = this.childrenWalkers;
      var v18239 = TypeScript$$5.NodeType;
      var v10984 = v18239.Return;
      v10983[v10984] = ChildrenWalkers.walkReturnStatementChildren;
      var v10985 = this.childrenWalkers;
      var v18240 = TypeScript$$5.NodeType;
      var v10986 = v18240.Break;
      v10985[v10986] = ChildrenWalkers.walkNone;
      var v10987 = this.childrenWalkers;
      var v18241 = TypeScript$$5.NodeType;
      var v10988 = v18241.Continue;
      v10987[v10988] = ChildrenWalkers.walkNone;
      var v10989 = this.childrenWalkers;
      var v18242 = TypeScript$$5.NodeType;
      var v10990 = v18242.Throw;
      v10989[v10990] = ChildrenWalkers.walkUnaryExpressionChildren;
      var v10991 = this.childrenWalkers;
      var v18243 = TypeScript$$5.NodeType;
      var v10992 = v18243.For;
      v10991[v10992] = ChildrenWalkers.walkForStatementChildren;
      var v10993 = this.childrenWalkers;
      var v18244 = TypeScript$$5.NodeType;
      var v10994 = v18244.ForIn;
      v10993[v10994] = ChildrenWalkers.walkForInStatementChildren;
      var v10995 = this.childrenWalkers;
      var v18245 = TypeScript$$5.NodeType;
      var v10996 = v18245.If;
      v10995[v10996] = ChildrenWalkers.walkIfStatementChildren;
      var v10997 = this.childrenWalkers;
      var v18246 = TypeScript$$5.NodeType;
      var v10998 = v18246.While;
      v10997[v10998] = ChildrenWalkers.walkWhileStatementChildren;
      var v10999 = this.childrenWalkers;
      var v18247 = TypeScript$$5.NodeType;
      var v11000 = v18247.DoWhile;
      v10999[v11000] = ChildrenWalkers.walkDoWhileStatementChildren;
      var v11001 = this.childrenWalkers;
      var v18248 = TypeScript$$5.NodeType;
      var v11002 = v18248.Block;
      v11001[v11002] = ChildrenWalkers.walkBlockChildren;
      var v11003 = this.childrenWalkers;
      var v18249 = TypeScript$$5.NodeType;
      var v11004 = v18249.Case;
      v11003[v11004] = ChildrenWalkers.walkCaseStatementChildren;
      var v11005 = this.childrenWalkers;
      var v18250 = TypeScript$$5.NodeType;
      var v11006 = v18250.Switch;
      v11005[v11006] = ChildrenWalkers.walkSwitchStatementChildren;
      var v11007 = this.childrenWalkers;
      var v18251 = TypeScript$$5.NodeType;
      var v11008 = v18251.Try;
      v11007[v11008] = ChildrenWalkers.walkTryChildren;
      var v11009 = this.childrenWalkers;
      var v18252 = TypeScript$$5.NodeType;
      var v11010 = v18252.TryCatch;
      v11009[v11010] = ChildrenWalkers.walkTryCatchChildren;
      var v11011 = this.childrenWalkers;
      var v18253 = TypeScript$$5.NodeType;
      var v11012 = v18253.TryFinally;
      v11011[v11012] = ChildrenWalkers.walkTryFinallyChildren;
      var v11013 = this.childrenWalkers;
      var v18254 = TypeScript$$5.NodeType;
      var v11014 = v18254.Finally;
      v11013[v11014] = ChildrenWalkers.walkFinallyChildren;
      var v11015 = this.childrenWalkers;
      var v18255 = TypeScript$$5.NodeType;
      var v11016 = v18255.Catch;
      v11015[v11016] = ChildrenWalkers.walkCatchChildren;
      var v11017 = this.childrenWalkers;
      var v18256 = TypeScript$$5.NodeType;
      var v11018 = v18256.List;
      v11017[v11018] = ChildrenWalkers.walkListChildren;
      var v11019 = this.childrenWalkers;
      var v18257 = TypeScript$$5.NodeType;
      var v11020 = v18257.Script;
      v11019[v11020] = ChildrenWalkers.walkScriptChildren;
      var v11021 = this.childrenWalkers;
      var v18258 = TypeScript$$5.NodeType;
      var v11022 = v18258.ClassDeclaration;
      v11021[v11022] = ChildrenWalkers.walkClassDeclChildren;
      var v11023 = this.childrenWalkers;
      var v18259 = TypeScript$$5.NodeType;
      var v11024 = v18259.InterfaceDeclaration;
      v11023[v11024] = ChildrenWalkers.walkTypeDeclChildren;
      var v11025 = this.childrenWalkers;
      var v18260 = TypeScript$$5.NodeType;
      var v11026 = v18260.ModuleDeclaration;
      v11025[v11026] = ChildrenWalkers.walkModuleDeclChildren;
      var v11027 = this.childrenWalkers;
      var v18261 = TypeScript$$5.NodeType;
      var v11028 = v18261.ImportDeclaration;
      v11027[v11028] = ChildrenWalkers.walkImportDeclChildren;
      var v11029 = this.childrenWalkers;
      var v18262 = TypeScript$$5.NodeType;
      var v11030 = v18262.With;
      v11029[v11030] = ChildrenWalkers.walkWithStatementChildren;
      var v11031 = this.childrenWalkers;
      var v18263 = TypeScript$$5.NodeType;
      var v11032 = v18263.Label;
      v11031[v11032] = ChildrenWalkers.walkLabelChildren;
      var v11033 = this.childrenWalkers;
      var v18264 = TypeScript$$5.NodeType;
      var v11034 = v18264.LabeledStatement;
      v11033[v11034] = ChildrenWalkers.walkLabeledStatementChildren;
      var v11035 = this.childrenWalkers;
      var v18265 = TypeScript$$5.NodeType;
      var v11036 = v18265.EBStart;
      v11035[v11036] = ChildrenWalkers.walkNone;
      var v11037 = this.childrenWalkers;
      var v18266 = TypeScript$$5.NodeType;
      var v11038 = v18266.GotoEB;
      v11037[v11038] = ChildrenWalkers.walkNone;
      var v11039 = this.childrenWalkers;
      var v18267 = TypeScript$$5.NodeType;
      var v11040 = v18267.EndCode;
      v11039[v11040] = ChildrenWalkers.walkNone;
      var v11041 = this.childrenWalkers;
      var v18268 = TypeScript$$5.NodeType;
      var v11042 = v18268.Error;
      v11041[v11042] = ChildrenWalkers.walkNone;
      var v11043 = this.childrenWalkers;
      var v18269 = TypeScript$$5.NodeType;
      var v11044 = v18269.Comment;
      v11043[v11044] = ChildrenWalkers.walkNone;
      var v11045 = this.childrenWalkers;
      var v18270 = TypeScript$$5.NodeType;
      var v11046 = v18270.Debugger;
      v11045[v11046] = ChildrenWalkers.walkNone;
      var e$$8;
      var v18271 = TypeScript$$5.NodeType;
      var v11048 = v18271._map;
      for (e$$8 in v11048) {
        var v22811 = this.childrenWalkers;
        var v18272 = v22811[e$$8];
        var v11047 = v18272 === undefined;
        if (v11047) {
          throw new Error("initWalkers function is not up to date with enum content!");
        }
      }
      return;
    }
    function v329(pre$$3, post$$3, options$$4, state$$3) {
      var v11049 = !options$$4;
      if (v11049) {
        options$$4 = new AstWalkOptions;
      }
      var v11050 = this.childrenWalkers;
      return new AstWalker(v11050, pre$$3, post$$3, options$$4, state$$3);
    }
    function v328(pre$$2, post$$2, options$$3, state$$2) {
      return this.getSlowWalker(pre$$2, post$$2, options$$3, state$$2);
    }
    function v327(ast$$4, pre$$1, post$$1, options$$2, state$$1) {
      var v11051 = this.getWalker(pre$$1, post$$1, options$$2, state$$1);
      return v11051.walk(ast$$4, null);
    }
    function AstWalkerFactory$$1() {
      this.childrenWalkers = [];
      this.initChildrenWalkers();
      return;
    }
    var v11052 = AstWalkerFactory$$1.prototype;
    v11052.walk = v327;
    var v11053 = AstWalkerFactory$$1.prototype;
    v11053.getWalker = v328;
    var v11054 = AstWalkerFactory$$1.prototype;
    v11054.getSlowWalker = v329;
    var v11055 = AstWalkerFactory$$1.prototype;
    v11055.initChildrenWalkers = v330;
    return AstWalkerFactory$$1;
  }
  function v326() {
    function v325(ast$$3, parent$$1) {
      var preAst = this.pre(ast$$3, parent$$1, this);
      var v11056 = preAst === undefined;
      if (v11056) {
        preAst = ast$$3;
      }
      var v18273 = this.options;
      var v11063 = v18273.goChildren;
      if (v11063) {
        var v11057 = this.options;
        var svGoSib = v11057.goNextSibling;
        var v11058 = this.options;
        v11058.goNextSibling = true;
        var v11059 = this.childrenWalkers;
        var v11060 = ast$$3.nodeType;
        v11059[v11060](ast$$3, parent$$1, this);
        var v11061 = this.options;
        v11061.goNextSibling = svGoSib;
      } else {
        var v11062 = this.options;
        v11062.goChildren = true;
      }
      var v11065 = this.post;
      if (v11065) {
        var postAst = this.post(preAst, parent$$1, this);
        var v11064 = postAst === undefined;
        if (v11064) {
          postAst = preAst;
        }
        return postAst;
      } else {
        return preAst;
      }
      return;
    }
    function AstWalker$$1(childrenWalkers, pre, post, options$$1, state) {
      this.childrenWalkers = childrenWalkers;
      this.pre = pre;
      this.post = post;
      this.options = options$$1;
      this.state = state;
      return;
    }
    var v11066 = AstWalker$$1.prototype;
    v11066.walk = v325;
    return AstWalker$$1;
  }
  function v324() {
    function v323(stop) {
      var v18274 = typeof stop;
      var v11067 = v18274 === "undefined";
      if (v11067) {
        stop = true;
      }
      this.goChildren = !stop;
      this.goNextSibling = !stop;
      return;
    }
    function AstWalkOptions$$1() {
      this.goChildren = true;
      this.goNextSibling = true;
      this.reverseSiblings = false;
      return;
    }
    var v11068 = AstWalkOptions$$1.prototype;
    v11068.stopWalk = v323;
    return AstWalkOptions$$1;
  }
  function getAstWalkerFactory() {
    var v11069 = !globalAstWalkerFactory;
    if (v11069) {
      globalAstWalkerFactory = new AstWalkerFactory;
    }
    return globalAstWalkerFactory;
  }
  var AstWalkOptions = v324();
  TypeScript$$5.AstWalkOptions = AstWalkOptions;
  var AstWalker = v326();
  var AstWalkerFactory = v331();
  TypeScript$$5.AstWalkerFactory = AstWalkerFactory;
  var globalAstWalkerFactory;
  TypeScript$$5.getAstWalkerFactory = getAstWalkerFactory;
  var ChildrenWalkers;
  var v18275 = ChildrenWalkers;
  var v22812 = !v18275;
  if (v22812) {
    v18275 = ChildrenWalkers = {};
  }
  var v11070 = v18275;
  v332(v11070);
  return;
}
function v322(TypeScript$$4) {
  function v321(_super$$47) {
    function v320(emitter$$38, tokenId$$38, startLine$$38) {
      emitter$$38.emitParensAndCommentsInPlace(this, true);
      emitter$$38.recordSourceMappingStart(this);
      emitter$$38.writeLineToOutput("debugger;");
      emitter$$38.recordSourceMappingEnd(this);
      emitter$$38.emitParensAndCommentsInPlace(this, false);
      return;
    }
    function DebuggerStatement$$1() {
      var v18276 = TypeScript$$4.NodeType;
      var v11071 = v18276.Debugger;
      _super$$47.call(this, v11071);
      return;
    }
    __extends(DebuggerStatement$$1, _super$$47);
    var v11072 = DebuggerStatement$$1.prototype;
    v11072.emit = v320;
    return DebuggerStatement$$1;
  }
  function v319(_super$$46) {
    function getDocCommentTextOfSignatures(signatures) {
      var comments$$1 = [];
      var i$$24 = 0;
      var v18277 = signatures.length;
      var v11076 = i$$24 < v18277;
      for (;v11076;) {
        var v11073 = TypeScript$$4.Comment;
        var v22813 = signatures[i$$24];
        var v18278 = v22813.declAST;
        var v11074 = v18278.getDocComments();
        var signatureDocComment = v11073.getDocCommentText(v11074);
        var v11075 = signatureDocComment != "";
        if (v11075) {
          comments$$1.push(signatureDocComment);
        }
        i$$24 = i$$24 + 1;
        var v18279 = signatures.length;
        v11076 = i$$24 < v18279;
      }
      return comments$$1.join("\n");
    }
    function getParameterDocCommentText(param$$4, fncDocComments) {
      var v22814 = fncDocComments.length;
      var v18280 = v22814 == 0;
      var v22816 = !v18280;
      if (v22816) {
        var v25051 = fncDocComments[0];
        var v22815 = v25051.isBlockComment;
        v18280 = !v22815;
      }
      var v11077 = v18280;
      if (v11077) {
        return "";
      }
      var i$$23 = 0;
      var v18281 = fncDocComments.length;
      var v11101 = i$$23 < v18281;
      for (;v11101;) {
        var v11078 = fncDocComments[i$$23];
        var commentContents = v11078.content;
        var j = commentContents.indexOf("@param", 0);
        var v11100 = 0 <= j;
        for (;v11100;) {
          j = j + 6;
          var v18282 = Comment$$2.isSpaceChar(commentContents, j);
          var v11079 = !v18282;
          if (v11079) {
            j = commentContents.indexOf("@param", j);
            v11100 = 0 <= j;
            continue;
          }
          j = Comment$$2.consumeLeadingSpace(commentContents, j);
          var v11080 = j == -1;
          if (v11080) {
            break;
          }
          var v18283 = commentContents.charCodeAt(j);
          var v18284 = TypeScript$$4.LexCodeLC;
          var v11090 = v18283 == v18284;
          if (v11090) {
            j = j + 1;
            var charCode$$3 = 0;
            var curlies = 1;
            var v18285 = commentContents.length;
            var v11085 = j < v18285;
            for (;v11085;) {
              charCode$$3 = commentContents.charCodeAt(j);
              var v18286 = TypeScript$$4.LexCodeLC;
              var v11081 = charCode$$3 == v18286;
              if (v11081) {
                curlies = curlies + 1;
                j = j + 1;
                var v18287 = commentContents.length;
                v11085 = j < v18287;
                continue;
              }
              var v18288 = TypeScript$$4.LexCodeRC;
              var v11083 = charCode$$3 == v18288;
              if (v11083) {
                curlies = curlies - 1;
                var v11082 = curlies == 0;
                if (v11082) {
                  break;
                } else {
                  j = j + 1;
                  var v18289 = commentContents.length;
                  v11085 = j < v18289;
                  continue;
                }
              }
              var v18290 = TypeScript$$4.LexCodeAtSign;
              var v11084 = charCode$$3 == v18290;
              if (v11084) {
                break;
              }
              j = j + 1;
              var v18291 = commentContents.length;
              v11085 = j < v18291;
            }
            var v18292 = commentContents.length;
            var v11086 = j == v18292;
            if (v11086) {
              break;
            }
            var v18293 = TypeScript$$4.LexCodeAtSign;
            var v11087 = charCode$$3 == v18293;
            if (v11087) {
              j = commentContents.indexOf("@param", j);
              v11100 = 0 <= j;
              continue;
            }
            var v11088 = j + 1;
            j = Comment$$2.consumeLeadingSpace(commentContents, v11088);
            var v11089 = j == -1;
            if (v11089) {
              break;
            }
          }
          var v22817 = param$$4;
          var v25052 = param$$4.length;
          var v22818 = commentContents.substr(j, v25052);
          var v18294 = v22817 != v22818;
          var v22820 = !v18294;
          if (v22820) {
            var v25990 = param$$4.length;
            var v25053 = j + v25990;
            var v22819 = Comment$$2.isSpaceChar(commentContents, v25053);
            v18294 = !v22819;
          }
          var v11091 = v18294;
          if (v11091) {
            j = commentContents.indexOf("@param", j);
            v11100 = 0 <= j;
            continue;
          }
          var v18295 = param$$4.length;
          var v11092 = j + v18295;
          j = Comment$$2.consumeLeadingSpace(commentContents, v11092);
          var v11093 = j == -1;
          if (v11093) {
            return "";
          }
          var endOfParam = commentContents.indexOf("@", j);
          var v18296;
          var v22821 = endOfParam < 0;
          if (v22821) {
            v18296 = commentContents.length;
          } else {
            v18296 = endOfParam;
          }
          var v11094 = v18296;
          var paramHelpString = commentContents.substring(j, v11094);
          var paramSpacesToRemove = undefined;
          var v18297 = commentContents.substring(0, j);
          var v11095 = v18297.lastIndexOf("\n");
          var paramLineIndex = v11095 + 1;
          var v11097 = paramLineIndex != 0;
          if (v11097) {
            var v18298 = paramLineIndex < j;
            if (v18298) {
              var v25054 = paramLineIndex + 1;
              var v22822 = commentContents.charAt(v25054);
              v18298 = v22822 == "\r";
            }
            var v11096 = v18298;
            if (v11096) {
              paramLineIndex = paramLineIndex + 1;
            }
          }
          var startSpaceRemovalIndex = Comment$$2.consumeLeadingSpace(commentContents, paramLineIndex);
          var v18299 = startSpaceRemovalIndex != j;
          if (v18299) {
            var v22823 = commentContents.charAt(startSpaceRemovalIndex);
            v18299 = v22823 == "*";
          }
          var v11099 = v18299;
          if (v11099) {
            var v11098 = j - startSpaceRemovalIndex;
            paramSpacesToRemove = v11098 - 1;
          }
          return Comment$$2.cleanJSDocComment(paramHelpString, paramSpacesToRemove);
        }
        i$$23 = i$$23 + 1;
        var v18300 = fncDocComments.length;
        v11101 = i$$23 < v18300;
      }
      return "";
    }
    function getDocCommentText(comments) {
      var docCommentText$$1 = [];
      var c$$2 = 0;
      var v18301 = comments.length;
      var v11104 = c$$2 < v18301;
      for (;v11104;) {
        var v11102 = comments[c$$2];
        var commentText = v11102.getDocCommentText();
        var v11103 = commentText != "";
        if (v11103) {
          docCommentText$$1.push(commentText);
        }
        c$$2 = c$$2 + 1;
        var v18302 = comments.length;
        v11104 = c$$2 < v18302;
      }
      return docCommentText$$1.join("\n");
    }
    function cleanJSDocComment(content$$1, spacesToRemove) {
      var docCommentLines = [];
      content$$1 = content$$1.replace("/**", "");
      var v25055 = content$$1.length;
      var v22824 = v25055 >= 2;
      if (v22824) {
        var v26399 = content$$1.length;
        var v25991 = v26399 - 1;
        var v25056 = content$$1.charAt(v25991);
        v22824 = v25056 == "/";
      }
      var v18303 = v22824;
      if (v18303) {
        var v25992 = content$$1.length;
        var v25057 = v25992 - 2;
        var v22825 = content$$1.charAt(v25057);
        v18303 = v22825 == "*";
      }
      var v11106 = v18303;
      if (v11106) {
        var v18304 = content$$1.length;
        var v11105 = v18304 - 2;
        content$$1 = content$$1.substring(0, v11105);
      }
      var lines = content$$1.split("\n");
      var inParamTag = false;
      var l = 0;
      var v18305 = lines.length;
      var v11114 = l < v18305;
      for (;v11114;) {
        var line$$3 = lines[l];
        var cleanLinePos = Comment$$2.cleanDocCommentLine(line$$3, true, spacesToRemove);
        var v11107 = !cleanLinePos;
        if (v11107) {
          l = l + 1;
          var v18306 = lines.length;
          v11114 = l < v18306;
          continue;
        }
        var docCommentText = "";
        var prevPos = cleanLinePos.minChar;
        var v11108 = cleanLinePos.minChar;
        var i$$22 = line$$3.indexOf("@", v11108);
        var v18307 = 0 <= i$$22;
        if (v18307) {
          var v22826 = cleanLinePos.limChar;
          v18307 = i$$22 < v22826;
        }
        var v11111 = v18307;
        for (;v11111;) {
          var wasInParamtag = inParamTag;
          var v25058 = i$$22 + 1;
          var v22827 = line$$3.indexOf("param", v25058);
          var v22828 = i$$22 + 1;
          var v18308 = v22827 == v22828;
          if (v18308) {
            var v22829 = i$$22 + 6;
            v18308 = Comment$$2.isSpaceChar(line$$3, v22829);
          }
          var v11110 = v18308;
          if (v11110) {
            var v11109 = !wasInParamtag;
            if (v11109) {
              var v18309 = docCommentText;
              var v18310 = line$$3.substring(prevPos, i$$22);
              docCommentText = v18309 + v18310;
            }
            prevPos = i$$22;
            inParamTag = true;
          } else {
            if (wasInParamtag) {
              prevPos = i$$22;
              inParamTag = false;
            }
          }
          var v18311 = i$$22 + 1;
          i$$22 = line$$3.indexOf("@", v18311);
          var v18312 = 0 <= i$$22;
          if (v18312) {
            var v22830 = cleanLinePos.limChar;
            v18312 = i$$22 < v22830;
          }
          v11111 = v18312;
        }
        var v11112 = !inParamTag;
        if (v11112) {
          var v18313 = docCommentText;
          var v22831 = cleanLinePos.limChar;
          var v18314 = line$$3.substring(prevPos, v22831);
          docCommentText = v18313 + v18314;
        }
        var newCleanPos = Comment$$2.cleanDocCommentLine(docCommentText, false);
        if (newCleanPos) {
          var v11113 = spacesToRemove == undefined;
          if (v11113) {
            spacesToRemove = cleanLinePos.jsDocSpacesRemoved;
          }
          docCommentLines.push(docCommentText);
        }
        l = l + 1;
        var v18315 = lines.length;
        v11114 = l < v18315;
      }
      return docCommentLines.join("\n");
    }
    function cleanDocCommentLine(line$$2, jsDocStyleComment, jsDocLineSpaceToRemove) {
      var nonSpaceIndex = Comment$$2.consumeLeadingSpace(line$$2, 0);
      var v11118 = nonSpaceIndex != -1;
      if (v11118) {
        var jsDocSpacesRemoved = nonSpaceIndex;
        var v18316 = jsDocStyleComment;
        if (v18316) {
          var v22832 = line$$2.charAt(nonSpaceIndex);
          v18316 = v22832 == "*";
        }
        var v11116 = v18316;
        if (v11116) {
          var startIndex$$1 = nonSpaceIndex + 1;
          nonSpaceIndex = Comment$$2.consumeLeadingSpace(line$$2, startIndex$$1, jsDocLineSpaceToRemove);
          var v11115 = nonSpaceIndex != -1;
          if (v11115) {
            jsDocSpacesRemoved = nonSpaceIndex - startIndex$$1;
          } else {
            return null;
          }
        }
        var v18317;
        var v26400 = line$$2.length;
        var v25993 = v26400 - 1;
        var v25059 = line$$2.charAt(v25993);
        var v22834 = v25059 == "\r";
        if (v22834) {
          var v22833 = line$$2.length;
          v18317 = v22833 - 1;
        } else {
          v18317 = line$$2.length;
        }
        var v11117 = v18317;
        return{minChar:nonSpaceIndex, limChar:v11117, jsDocSpacesRemoved:jsDocSpacesRemoved};
      }
      return null;
    }
    function isSpaceChar(line$$1, index$$41) {
      var length$$13 = line$$1.length;
      var v11120 = index$$41 < length$$13;
      if (v11120) {
        var charCode$$2 = line$$1.charCodeAt(index$$41);
        var v18318 = TypeScript$$4.LexCodeSpace;
        var v11119 = charCode$$2 == v18318;
        var v18320 = !v11119;
        if (v18320) {
          var v18319 = TypeScript$$4.LexCodeTAB;
          v11119 = charCode$$2 == v18319;
        }
        return v11119;
      }
      return index$$41 == length$$13;
    }
    function consumeLeadingSpace(line, startIndex, maxSpacesToRemove) {
      var endIndex = line.length;
      var v11122 = maxSpacesToRemove != undefined;
      if (v11122) {
        var v11121 = startIndex + maxSpacesToRemove;
        endIndex = TypeScript$$4.min(v11121, endIndex);
      }
      var v11124 = startIndex < endIndex;
      for (;v11124;) {
        var charCode$$1 = line.charCodeAt(startIndex);
        var v22835 = TypeScript$$4.LexCodeSpace;
        var v18321 = charCode$$1 != v22835;
        if (v18321) {
          var v22836 = TypeScript$$4.LexCodeTAB;
          v18321 = charCode$$1 != v22836;
        }
        var v11123 = v18321;
        if (v11123) {
          return startIndex;
        }
        startIndex = startIndex + 1;
        v11124 = startIndex < endIndex;
      }
      var v18322 = line.length;
      var v11125 = endIndex != v18322;
      if (v11125) {
        return endIndex;
      }
      return-1;
    }
    function v318() {
      var v18323 = this.docCommentText;
      var v11127 = v18323 == null;
      if (v11127) {
        var v11126 = this.content;
        var v27394 = Comment$$2.cleanJSDocComment(v11126);
        this.docCommentText = v27394;
      }
      return this.docCommentText;
    }
    function v317() {
      var v11129 = this.isBlockComment;
      if (v11129) {
        var v18324 = this.content;
        var v11128 = v18324.charAt(2);
        return v11128 == "*";
      }
      return false;
    }
    function v316() {
      var v18325 = this.text;
      var v11136 = v18325 == null;
      if (v11136) {
        var v11135 = this.isBlockComment;
        if (v11135) {
          var v11130 = this.content;
          var v27395 = v11130.split("\n");
          this.text = v27395;
          var i$$21 = 0;
          var v22837 = this.text;
          var v18326 = v22837.length;
          var v11133 = i$$21 < v18326;
          for (;v11133;) {
            var v11131 = this.text;
            var v11132 = i$$21;
            var v22838 = this.text;
            var v18327 = v22838[i$$21];
            var v27396 = v18327.replace(/^\s+|\s+$/g, "");
            v11131[v11132] = v27396;
            i$$21 = i$$21 + 1;
            var v22839 = this.text;
            var v18328 = v22839.length;
            v11133 = i$$21 < v18328;
          }
        } else {
          var v18329 = this.content;
          var v11134 = v18329.replace(/^\s+|\s+$/g, "");
          this.text = [v11134];
        }
      }
      return this.text;
    }
    function Comment$$2(content, isBlockComment, endsLine) {
      var v18330 = TypeScript$$4.NodeType;
      var v11137 = v18330.Comment;
      _super$$46.call(this, v11137);
      this.content = content;
      this.isBlockComment = isBlockComment;
      this.endsLine = endsLine;
      this.text = null;
      this.docCommentText = null;
      return;
    }
    __extends(Comment$$2, _super$$46);
    var v11138 = Comment$$2.prototype;
    v11138.getText = v316;
    var v11139 = Comment$$2.prototype;
    v11139.isDocComment = v317;
    var v11140 = Comment$$2.prototype;
    v11140.getDocCommentText = v318;
    Comment$$2.consumeLeadingSpace = consumeLeadingSpace;
    Comment$$2.isSpaceChar = isSpaceChar;
    Comment$$2.cleanDocCommentLine = cleanDocCommentLine;
    Comment$$2.cleanJSDocComment = cleanJSDocComment;
    Comment$$2.getDocCommentText = getDocCommentText;
    Comment$$2.getParameterDocCommentText = getParameterDocCommentText;
    Comment$$2.getDocCommentTextOfSignatures = getDocCommentTextOfSignatures;
    return Comment$$2;
  }
  function v315(_super$$45) {
    function v314(typeFlow$$35) {
      var v11141 = this.body;
      var v27397 = typeFlow$$35.typeCheck(v11141);
      this.body = v27397;
      return this;
    }
    function v313(context$$26) {
      var v11143 = this.body;
      if (v11143) {
        var v11142 = this.body;
        context$$26.walk(v11142, this);
      }
      var v18331 = context$$26.walker;
      var v11144 = v18331.options;
      v11144.goChildren = false;
      context$$26.noContinuation = false;
      return;
    }
    function v312(emitter$$37, tokenId$$37, startLine$$37) {
      emitter$$37.emitParensAndCommentsInPlace(this, true);
      emitter$$37.recordSourceMappingStart(this);
      emitter$$37.writeToOutput("finally");
      var v11145 = this.body;
      var v18332 = TypeScript$$4.TokenID;
      var v11146 = v18332.Finally;
      emitter$$37.emitJavascript(v11145, v11146, false);
      emitter$$37.recordSourceMappingEnd(this);
      emitter$$37.emitParensAndCommentsInPlace(this, false);
      return;
    }
    function Finally$$1(body$$2) {
      var v18333 = TypeScript$$4.NodeType;
      var v11147 = v18333.Finally;
      _super$$45.call(this, v11147);
      this.body = body$$2;
      return;
    }
    __extends(Finally$$1, _super$$45);
    var v11148 = Finally$$1.prototype;
    v11148.emit = v312;
    var v11149 = Finally$$1.prototype;
    v11149.addToControlFlow = v313;
    var v11150 = Finally$$1.prototype;
    v11150.typeCheck = v314;
    return Finally$$1;
  }
  function v311(_super$$44) {
    function v310(typeFlow$$34) {
      var prevScope = typeFlow$$34.scope;
      typeFlow$$34.scope = this.containedScope;
      var v11151 = this.param;
      var v27398 = typeFlow$$34.typeCheck(v11151);
      this.param = v27398;
      var v11152 = TypeScript$$4.ValueLocation;
      var exceptVar = new v11152;
      var v11153 = TypeScript$$4.VariableSymbol;
      var v22840 = this.param;
      var v18334 = v22840.id;
      var v11154 = v18334.text;
      var v18335 = this.param;
      var v11155 = v18335.minChar;
      var v22841 = typeFlow$$34.checker;
      var v18336 = v22841.locationInfo;
      var v11156 = v18336.unitIndex;
      var varSym = new v11153(v11154, v11155, v11156, exceptVar);
      exceptVar.symbol = varSym;
      var v11157 = exceptVar;
      var v18337 = TypeScript$$4.TypeLink;
      var v27399 = new v18337;
      v11157.typeLink = v27399;
      var v11158 = exceptVar.typeLink;
      v11158.type = typeFlow$$34.anyType;
      var thisFnc = typeFlow$$34.thisFnc;
      var v18338 = thisFnc;
      if (v18338) {
        v18338 = thisFnc.type;
      }
      var v11161 = v18338;
      if (v11161) {
        var v11159 = exceptVar.symbol;
        var v18339 = thisFnc.type;
        v11159.container = v18339.symbol;
      } else {
        var v11160 = exceptVar.symbol;
        v11160.container = null;
      }
      var v11162 = this.param;
      v11162.sym = exceptVar.symbol;
      var v11163 = typeFlow$$34.scope;
      var v18340 = exceptVar.symbol;
      var v11164 = v18340.container;
      var v11165 = this.param;
      var v11166 = exceptVar.symbol;
      var v18341 = typeFlow$$34.checker;
      var v11167 = v18341.errorReporter;
      v11163.enter(v11164, v11165, v11166, v11167, false, false, false);
      var v11168 = this.body;
      var v27400 = typeFlow$$34.typeCheck(v11168);
      this.body = v27400;
      var v18342 = typeFlow$$34.checker;
      var v11172 = v18342.inProvisionalTypecheckMode();
      if (v11172) {
        var v11169 = typeFlow$$34.scope;
        var table = v11169.getTable();
        var v18343 = table.secondaryTable;
        var v11170 = v18343.table;
        var v18344 = exceptVar.symbol;
        var v11171 = v18344.name;
        v11170[v11171] = undefined;
      }
      this.type = typeFlow$$34.voidType;
      typeFlow$$34.scope = prevScope;
      return this;
    }
    function v309(context$$25) {
      var v11176 = this.param;
      if (v11176) {
        var v11173 = this.param;
        context$$25.addContent(v11173);
        var v11174 = TypeScript$$4.BasicBlock;
        var bodBlock = new v11174;
        var v11175 = context$$25.current;
        v11175.addSuccessor(bodBlock);
        context$$25.current = bodBlock;
      }
      var v11178 = this.body;
      if (v11178) {
        var v11177 = this.body;
        context$$25.walk(v11177, this);
      }
      context$$25.noContinuation = false;
      var v18345 = context$$25.walker;
      var v11179 = v18345.options;
      v11179.goChildren = false;
      return;
    }
    function v308(emitter$$36, tokenId$$36, startLine$$36) {
      emitter$$36.emitParensAndCommentsInPlace(this, true);
      emitter$$36.recordSourceMappingStart(this);
      emitter$$36.writeToOutput(" ");
      var v11180 = this.statement;
      emitter$$36.recordSourceMappingStart(v11180);
      emitter$$36.writeToOutput("catch (");
      var v11181 = this.param;
      var v18346 = TypeScript$$4.TokenID;
      var v11182 = v18346.OpenParen;
      emitter$$36.emitJavascript(v11181, v11182, false);
      emitter$$36.writeToOutput(")");
      var v11183 = this.statement;
      emitter$$36.recordSourceMappingEnd(v11183);
      var v11184 = this.body;
      var v18347 = TypeScript$$4.TokenID;
      var v11185 = v18347.Catch;
      emitter$$36.emitJavascript(v11184, v11185, false);
      emitter$$36.recordSourceMappingEnd(this);
      emitter$$36.emitParensAndCommentsInPlace(this, false);
      return;
    }
    function Catch$$1(param$$3, body$$1) {
      var v18348 = TypeScript$$4.NodeType;
      var v11186 = v18348.Catch;
      _super$$44.call(this, v11186);
      this.param = param$$3;
      this.body = body$$1;
      var v27401 = new ASTSpan;
      this.statement = v27401;
      this.containedScope = null;
      var v11188 = this.param;
      if (v11188) {
        var v11187 = this.param;
        var v22842 = v11187.varFlags;
        var v25060 = TypeScript$$4.VarFlags;
        var v22843 = v25060.AutoInit;
        v11187.varFlags = v22842 | v22843;
      }
      return;
    }
    __extends(Catch$$1, _super$$44);
    var v11189 = Catch$$1.prototype;
    v11189.emit = v308;
    var v11190 = Catch$$1.prototype;
    v11190.addToControlFlow = v309;
    var v11191 = Catch$$1.prototype;
    v11191.typeCheck = v310;
    return Catch$$1;
  }
  function v307(_super$$43) {
    function v306(context$$24) {
      var v11193 = this.body;
      if (v11193) {
        var v11192 = this.body;
        context$$24.walk(v11192, this);
      }
      var v18349 = context$$24.walker;
      var v11194 = v18349.options;
      v11194.goChildren = false;
      context$$24.noContinuation = false;
      return;
    }
    function v305(typeFlow$$33) {
      var v11195 = this.body;
      var v27402 = typeFlow$$33.typeCheck(v11195);
      this.body = v27402;
      return this;
    }
    function v304(emitter$$35, tokenId$$35, startLine$$35) {
      emitter$$35.emitParensAndCommentsInPlace(this, true);
      emitter$$35.recordSourceMappingStart(this);
      emitter$$35.writeToOutput("try ");
      var v11196 = this.body;
      var v18350 = TypeScript$$4.TokenID;
      var v11197 = v18350.Try;
      emitter$$35.emitJavascript(v11196, v11197, false);
      emitter$$35.recordSourceMappingEnd(this);
      emitter$$35.emitParensAndCommentsInPlace(this, false);
      return;
    }
    function Try$$1(body) {
      var v18351 = TypeScript$$4.NodeType;
      var v11198 = v18351.Try;
      _super$$43.call(this, v11198);
      this.body = body;
      return;
    }
    __extends(Try$$1, _super$$43);
    var v11199 = Try$$1.prototype;
    v11199.emit = v304;
    var v11200 = Try$$1.prototype;
    v11200.typeCheck = v305;
    var v11201 = Try$$1.prototype;
    v11201.addToControlFlow = v306;
    return Try$$1;
  }
  function v303(_super$$42) {
    function v302(typeFlow$$32) {
      var v11202 = this.tryNode;
      var v27403 = typeFlow$$32.typeCheck(v11202);
      this.tryNode = v27403;
      var v11203 = this.catchNode;
      var v27404 = typeFlow$$32.typeCheck(v11203);
      this.catchNode = v27404;
      this.type = typeFlow$$32.voidType;
      return this;
    }
    function v301(context$$23) {
      var beforeTry = context$$23.current;
      var v11204 = TypeScript$$4.BasicBlock;
      var tryBlock = new v11204;
      beforeTry.addSuccessor(tryBlock);
      context$$23.current = tryBlock;
      var v11205 = TypeScript$$4.BasicBlock;
      var afterTryCatch = new v11205;
      context$$23.pushStatement(this, null, afterTryCatch);
      var v11206 = this.tryNode;
      context$$23.walk(v11206, this);
      var v18352 = context$$23.noContinuation;
      var v11209 = !v18352;
      if (v11209) {
        var v11208 = context$$23.current;
        if (v11208) {
          var v11207 = context$$23.current;
          v11207.addSuccessor(afterTryCatch);
        }
      }
      var v11210 = context$$23;
      var v18353 = TypeScript$$4.BasicBlock;
      var v27405 = new v18353;
      v11210.current = v27405;
      var v11211 = context$$23.current;
      beforeTry.addSuccessor(v11211);
      var v11212 = this.catchNode;
      context$$23.walk(v11212, this);
      context$$23.popStatement();
      var v18354 = context$$23.noContinuation;
      var v11215 = !v18354;
      if (v11215) {
        var v11214 = context$$23.current;
        if (v11214) {
          var v11213 = context$$23.current;
          v11213.addSuccessor(afterTryCatch);
        }
      }
      context$$23.current = afterTryCatch;
      var v18355 = context$$23.walker;
      var v11216 = v18355.options;
      v11216.goChildren = false;
      return;
    }
    function v300(emitter$$34, tokenId$$34, startLine$$34) {
      emitter$$34.emitParensAndCommentsInPlace(this, true);
      emitter$$34.recordSourceMappingStart(this);
      var v11217 = this.tryNode;
      var v18356 = TypeScript$$4.TokenID;
      var v11218 = v18356.Try;
      emitter$$34.emitJavascript(v11217, v11218, false);
      var v11219 = this.catchNode;
      var v18357 = TypeScript$$4.TokenID;
      var v11220 = v18357.Catch;
      emitter$$34.emitJavascript(v11219, v11220, false);
      emitter$$34.recordSourceMappingEnd(this);
      emitter$$34.emitParensAndCommentsInPlace(this, false);
      return;
    }
    function v299() {
      return true;
    }
    function TryCatch$$1(tryNode$$1, catchNode) {
      var v18358 = TypeScript$$4.NodeType;
      var v11221 = v18358.TryCatch;
      _super$$42.call(this, v11221);
      this.tryNode = tryNode$$1;
      this.catchNode = catchNode;
      return;
    }
    __extends(TryCatch$$1, _super$$42);
    var v11222 = TryCatch$$1.prototype;
    v11222.isCompoundStatement = v299;
    var v11223 = TryCatch$$1.prototype;
    v11223.emit = v300;
    var v11224 = TryCatch$$1.prototype;
    v11224.addToControlFlow = v301;
    var v11225 = TryCatch$$1.prototype;
    v11225.typeCheck = v302;
    return TryCatch$$1;
  }
  function v298(_super$$41) {
    function v297(context$$22) {
      var v11226 = TypeScript$$4.BasicBlock;
      var afterFinally = new v11226;
      var v11227 = this.tryNode;
      context$$22.walk(v11227, this);
      var v11228 = TypeScript$$4.BasicBlock;
      var finBlock = new v11228;
      var v11230 = context$$22.current;
      if (v11230) {
        var v11229 = context$$22.current;
        v11229.addSuccessor(finBlock);
      }
      context$$22.current = finBlock;
      context$$22.pushStatement(this, null, afterFinally);
      var v11231 = this.finallyNode;
      context$$22.walk(v11231, this);
      var v22844 = context$$22.noContinuation;
      var v18359 = !v22844;
      if (v18359) {
        v18359 = context$$22.current;
      }
      var v11233 = v18359;
      if (v11233) {
        var v11232 = context$$22.current;
        v11232.addSuccessor(afterFinally);
      }
      var v22845 = afterFinally.predecessors;
      var v18360 = v22845.length;
      var v11234 = v18360 > 0;
      if (v11234) {
        context$$22.current = afterFinally;
      } else {
        context$$22.noContinuation = true;
      }
      context$$22.popStatement();
      var v18361 = context$$22.walker;
      var v11235 = v18361.options;
      v11235.goChildren = false;
      return;
    }
    function v296(typeFlow$$31) {
      var v11236 = this.tryNode;
      var v27406 = typeFlow$$31.typeCheck(v11236);
      this.tryNode = v27406;
      var v11237 = this.finallyNode;
      var v27407 = typeFlow$$31.typeCheck(v11237);
      this.finallyNode = v27407;
      this.type = typeFlow$$31.voidType;
      return this;
    }
    function v295(emitter$$33, tokenId$$33, startLine$$33) {
      emitter$$33.recordSourceMappingStart(this);
      var v11238 = this.tryNode;
      var v18362 = TypeScript$$4.TokenID;
      var v11239 = v18362.Try;
      emitter$$33.emitJavascript(v11238, v11239, false);
      var v11240 = this.finallyNode;
      var v18363 = TypeScript$$4.TokenID;
      var v11241 = v18363.Finally;
      emitter$$33.emitJavascript(v11240, v11241, false);
      emitter$$33.recordSourceMappingEnd(this);
      return;
    }
    function v294() {
      return true;
    }
    function TryFinally$$1(tryNode, finallyNode) {
      var v18364 = TypeScript$$4.NodeType;
      var v11242 = v18364.TryFinally;
      _super$$41.call(this, v11242);
      this.tryNode = tryNode;
      this.finallyNode = finallyNode;
      return;
    }
    __extends(TryFinally$$1, _super$$41);
    var v11243 = TryFinally$$1.prototype;
    v11243.isCompoundStatement = v294;
    var v11244 = TryFinally$$1.prototype;
    v11244.emit = v295;
    var v11245 = TryFinally$$1.prototype;
    v11245.typeCheck = v296;
    var v11246 = TryFinally$$1.prototype;
    v11246.addToControlFlow = v297;
    return TryFinally$$1;
  }
  function v293(_super$$40) {
    function v292(typeFlow$$30) {
      var prevInTCTR = typeFlow$$30.inTypeRefTypeCheck;
      typeFlow$$30.inTypeRefTypeCheck = true;
      var v11247 = typeFlow$$30.checker;
      var typeLink = TypeScript$$4.getTypeLink(this, v11247, true);
      var v11248 = typeFlow$$30.checker;
      var v11249 = typeFlow$$30.scope;
      v11248.resolveTypeLink(v11249, typeLink, false);
      var v11251 = this.term;
      if (v11251) {
        var v11250 = this.term;
        typeFlow$$30.typeCheck(v11250);
      }
      var v11252 = typeLink.type;
      typeFlow$$30.checkForVoidConstructor(v11252, this);
      this.type = typeLink.type;
      var v11254 = this.term;
      if (v11254) {
        var v11253 = this.term;
        v11253.type = this.type;
      }
      typeFlow$$30.inTypeRefTypeCheck = prevInTCTR;
      return this;
    }
    function v291(emitter$$32, tokenId$$32, startLine$$32) {
      throw new Error("should not emit a type ref");
    }
    function TypeReference$$1(term, arrayCount) {
      var v18365 = TypeScript$$4.NodeType;
      var v11255 = v18365.TypeRef;
      _super$$40.call(this, v11255);
      this.term = term;
      this.arrayCount = arrayCount;
      return;
    }
    __extends(TypeReference$$1, _super$$40);
    var v11256 = TypeReference$$1.prototype;
    v11256.emit = v291;
    var v11257 = TypeReference$$1.prototype;
    v11257.typeCheck = v292;
    return TypeReference$$1;
  }
  function v290(_super$$39) {
    function v289(context$$21) {
      var v11258 = TypeScript$$4.BasicBlock;
      var execBlock$$1 = new v11258;
      var v11259 = context$$21.currentSwitch;
      var v22846 = context$$21.currentSwitch;
      var v18366 = v22846.length;
      var v11260 = v18366 - 1;
      var sw$$2 = v11259[v11260];
      var v11263 = this.expr;
      if (v11263) {
        var v11261 = TypeScript$$4.BasicBlock;
        var exprBlock = new v11261;
        context$$21.current = exprBlock;
        sw$$2.addSuccessor(exprBlock);
        var v11262 = this.expr;
        context$$21.addContent(v11262);
        exprBlock.addSuccessor(execBlock$$1);
      } else {
        sw$$2.addSuccessor(execBlock$$1);
      }
      context$$21.current = execBlock$$1;
      var v11265 = this.body;
      if (v11265) {
        var v11264 = this.body;
        context$$21.walk(v11264, this);
      }
      context$$21.noContinuation = false;
      var v18367 = context$$21.walker;
      var v11266 = v18367.options;
      v11266.goChildren = false;
      return;
    }
    function v288(typeFlow$$29) {
      var v11267 = this.expr;
      var v27408 = typeFlow$$29.typeCheck(v11267);
      this.expr = v27408;
      var v11268 = this.body;
      typeFlow$$29.typeCheck(v11268);
      this.type = typeFlow$$29.voidType;
      return this;
    }
    function v287(emitter$$31, tokenId$$31, startLine$$31) {
      emitter$$31.emitParensAndCommentsInPlace(this, true);
      emitter$$31.recordSourceMappingStart(this);
      var v11271 = this.expr;
      if (v11271) {
        emitter$$31.writeToOutput("case ");
        var v11269 = this.expr;
        var v18368 = TypeScript$$4.TokenID;
        var v11270 = v18368.Identifier;
        emitter$$31.emitJavascript(v11269, v11270, false);
      } else {
        emitter$$31.writeToOutput("default");
      }
      emitter$$31.writeToOutput(":");
      var v25994 = this.body;
      var v25061 = v25994.members;
      var v22847 = v25061.length;
      var v18369 = v22847 == 1;
      if (v18369) {
        var v26401 = this.body;
        var v25995 = v26401.members;
        var v25062 = v25995[0];
        var v22848 = v25062.nodeType;
        var v25063 = TypeScript$$4.NodeType;
        var v22849 = v25063.Block;
        v18369 = v22848 == v22849;
      }
      var v11276 = v18369;
      if (v11276) {
        var v11272 = this.body;
        emitter$$31.emitJavascriptStatements(v11272, false);
      } else {
        emitter$$31.writeLineToOutput("");
        var v11273 = emitter$$31.indenter;
        v11273.increaseIndent();
        var v11274 = this.body;
        emitter$$31.emitBareJavascriptStatements(v11274);
        var v11275 = emitter$$31.indenter;
        v11275.decreaseIndent();
      }
      emitter$$31.recordSourceMappingEnd(this);
      emitter$$31.emitParensAndCommentsInPlace(this, false);
      return;
    }
    function CaseStatement$$1() {
      var v18370 = TypeScript$$4.NodeType;
      var v11277 = v18370.Case;
      _super$$39.call(this, v11277);
      this.expr = null;
      return;
    }
    __extends(CaseStatement$$1, _super$$39);
    var v11278 = CaseStatement$$1.prototype;
    v11278.emit = v287;
    var v11279 = CaseStatement$$1.prototype;
    v11279.typeCheck = v288;
    var v11280 = CaseStatement$$1.prototype;
    v11280.addToControlFlow = v289;
    return CaseStatement$$1;
  }
  function v286(_super$$38) {
    function v285(context$$20) {
      var condBlock$$2 = context$$20.current;
      var v11281 = this.val;
      context$$20.addContent(v11281);
      var v11282 = TypeScript$$4.BasicBlock;
      var execBlock = new v11282;
      var v11283 = TypeScript$$4.BasicBlock;
      var afterSwitch = new v11283;
      condBlock$$2.addSuccessor(execBlock);
      context$$20.pushSwitch(execBlock);
      context$$20.current = execBlock;
      context$$20.pushStatement(this, execBlock, afterSwitch);
      var v11284 = this.caseList;
      context$$20.walk(v11284, this);
      context$$20.popSwitch();
      var targetInfo$$4 = context$$20.popStatement();
      var v11285 = this.defaultCase;
      var hasCondContinuation = v11285 == null;
      var v18371 = this.defaultCase;
      var v11286 = v18371 == null;
      if (v11286) {
        condBlock$$2.addSuccessor(afterSwitch);
      }
      var v22850 = afterSwitch.predecessors;
      var v18372 = v22850.length;
      var v11287 = v18372 > 0;
      if (v11287) {
        context$$20.noContinuation = false;
        context$$20.current = afterSwitch;
      } else {
        context$$20.noContinuation = true;
      }
      var v18373 = context$$20.walker;
      var v11288 = v18373.options;
      v11288.goChildren = false;
      return;
    }
    function v284(typeFlow$$28) {
      var v18374 = this.caseList;
      var v11289 = v18374.members;
      var len$$5 = v11289.length;
      var v11290 = this.val;
      var v27409 = typeFlow$$28.typeCheck(v11290);
      this.val = v27409;
      var i$$20 = 0;
      var v11293 = i$$20 < len$$5;
      for (;v11293;) {
        var v18375 = this.caseList;
        var v11291 = v18375.members;
        var v11292 = i$$20;
        var v25064 = this.caseList;
        var v22851 = v25064.members;
        var v18376 = v22851[i$$20];
        var v27410 = typeFlow$$28.typeCheck(v18376);
        v11291[v11292] = v27410;
        i$$20 = i$$20 + 1;
        v11293 = i$$20 < len$$5;
      }
      var v11294 = this.defaultCase;
      var v27411 = typeFlow$$28.typeCheck(v11294);
      this.defaultCase = v27411;
      this.type = typeFlow$$28.voidType;
      return this;
    }
    function v283(emitter$$30, tokenId$$30, startLine$$30) {
      emitter$$30.emitParensAndCommentsInPlace(this, true);
      emitter$$30.recordSourceMappingStart(this);
      var temp$$7 = emitter$$30.setInObjectLiteral(false);
      var v11295 = this.statement;
      emitter$$30.recordSourceMappingStart(v11295);
      emitter$$30.writeToOutput("switch(");
      var v11296 = this.val;
      var v18377 = TypeScript$$4.TokenID;
      var v11297 = v18377.Identifier;
      emitter$$30.emitJavascript(v11296, v11297, false);
      emitter$$30.writeToOutput(")");
      var v11298 = this.statement;
      emitter$$30.recordSourceMappingEnd(v11298);
      emitter$$30.writeLineToOutput(" {");
      var v11299 = emitter$$30.indenter;
      v11299.increaseIndent();
      var v18378 = this.caseList;
      var v11300 = v18378.members;
      var casesLen = v11300.length;
      var i$$19 = 0;
      var v11303 = i$$19 < casesLen;
      for (;v11303;) {
        var v18379 = this.caseList;
        var v11301 = v18379.members;
        var caseExpr = v11301[i$$19];
        var v18380 = TypeScript$$4.TokenID;
        var v11302 = v18380.Case;
        emitter$$30.emitJavascript(caseExpr, v11302, true);
        i$$19 = i$$19 + 1;
        v11303 = i$$19 < casesLen;
      }
      var v11304 = emitter$$30.indenter;
      v11304.decreaseIndent();
      emitter$$30.emitIndent();
      emitter$$30.writeToOutput("}");
      emitter$$30.setInObjectLiteral(temp$$7);
      emitter$$30.recordSourceMappingEnd(this);
      emitter$$30.emitParensAndCommentsInPlace(this, false);
      return;
    }
    function v282() {
      return true;
    }
    function SwitchStatement$$1(val$$4) {
      var v18381 = TypeScript$$4.NodeType;
      var v11305 = v18381.Switch;
      _super$$38.call(this, v11305);
      this.val = val$$4;
      this.defaultCase = null;
      var v27412 = new ASTSpan;
      this.statement = v27412;
      return;
    }
    __extends(SwitchStatement$$1, _super$$38);
    var v11306 = SwitchStatement$$1.prototype;
    v11306.isCompoundStatement = v282;
    var v11307 = SwitchStatement$$1.prototype;
    v11307.emit = v283;
    var v11308 = SwitchStatement$$1.prototype;
    v11308.typeCheck = v284;
    var v11309 = SwitchStatement$$1.prototype;
    v11309.addToControlFlow = v285;
    return SwitchStatement$$1;
  }
  function v281(_super$$37) {
    function v280(typeFlow$$27) {
      return typeFlow$$27.typeCheckWith(this);
    }
    function v279(emitter$$29, tokenId$$29, startLine$$29) {
      emitter$$29.emitParensAndCommentsInPlace(this, true);
      emitter$$29.recordSourceMappingStart(this);
      emitter$$29.writeToOutput("with (");
      var v11312 = this.expr;
      if (v11312) {
        var v11310 = this.expr;
        var v18382 = TypeScript$$4.TokenID;
        var v11311 = v18382.With;
        emitter$$29.emitJavascript(v11310, v11311, false);
      }
      emitter$$29.writeToOutput(")");
      var v11313 = this.body;
      emitter$$29.emitJavascriptStatements(v11313, true);
      emitter$$29.recordSourceMappingEnd(this);
      emitter$$29.emitParensAndCommentsInPlace(this, false);
      return;
    }
    function v278() {
      return true;
    }
    function WithStatement$$1(expr$$3) {
      var v18383 = TypeScript$$4.NodeType;
      var v11314 = v18383.With;
      _super$$37.call(this, v11314);
      this.expr = expr$$3;
      this.withSym = null;
      return;
    }
    __extends(WithStatement$$1, _super$$37);
    var v11315 = WithStatement$$1.prototype;
    v11315.isCompoundStatement = v278;
    var v11316 = WithStatement$$1.prototype;
    v11316.emit = v279;
    var v11317 = WithStatement$$1.prototype;
    v11317.typeCheck = v280;
    return WithStatement$$1;
  }
  function v277(_super$$36) {
    function v276(context$$19) {
      var v11319 = this.init;
      if (v11319) {
        var v11318 = this.init;
        context$$19.addContent(v11318);
      }
      var loopHeader$$3 = context$$19.current;
      var v11320 = TypeScript$$4.BasicBlock;
      var loopStart$$3 = new v11320;
      var v11321 = TypeScript$$4.BasicBlock;
      var afterLoop$$3 = new v11321;
      loopHeader$$3.addSuccessor(loopStart$$3);
      context$$19.current = loopStart$$3;
      var condBlock$$1 = null;
      var continueTarget = loopStart$$3;
      var incrBB = null;
      var v11323 = this.incr;
      if (v11323) {
        var v11322 = TypeScript$$4.BasicBlock;
        incrBB = new v11322;
        continueTarget = incrBB;
      }
      var v11327 = this.cond;
      if (v11327) {
        condBlock$$1 = context$$19.current;
        var v11324 = this.cond;
        context$$19.addContent(v11324);
        var v11325 = context$$19;
        var v18384 = TypeScript$$4.BasicBlock;
        var v27413 = new v18384;
        v11325.current = v27413;
        var v11326 = context$$19.current;
        condBlock$$1.addSuccessor(v11326);
      }
      var targetInfo$$3 = null;
      var v11329 = this.body;
      if (v11329) {
        context$$19.pushStatement(this, continueTarget, afterLoop$$3);
        var v11328 = this.body;
        context$$19.walk(v11328, this);
        targetInfo$$3 = context$$19.popStatement();
      }
      var v11335 = this.incr;
      if (v11335) {
        var v11334 = context$$19.noContinuation;
        if (v11334) {
          var v22852 = incrBB.predecessors;
          var v18385 = v22852.length;
          var v11331 = v18385 == 0;
          if (v11331) {
            var v11330 = this.incr;
            context$$19.addUnreachable(v11330);
          }
        } else {
          var v11332 = context$$19.current;
          v11332.addSuccessor(incrBB);
          context$$19.current = incrBB;
          var v11333 = this.incr;
          context$$19.addContent(v11333);
        }
      }
      var loopEnd$$3 = context$$19.current;
      var v18386 = context$$19.noContinuation;
      var v11336 = !v18386;
      if (v11336) {
        loopEnd$$3.addSuccessor(loopStart$$3);
      }
      if (condBlock$$1) {
        condBlock$$1.addSuccessor(afterLoop$$3);
        context$$19.noContinuation = false;
      }
      var v22853 = afterLoop$$3.predecessors;
      var v18387 = v22853.length;
      var v11337 = v18387 > 0;
      if (v11337) {
        context$$19.noContinuation = false;
        context$$19.current = afterLoop$$3;
      }
      var v18388 = context$$19.walker;
      var v11338 = v18388.options;
      v11338.goChildren = false;
      return;
    }
    function v275(typeFlow$$26) {
      return typeFlow$$26.typeCheckFor(this);
    }
    function v274(emitter$$28, tokenId$$28, startLine$$28) {
      emitter$$28.emitParensAndCommentsInPlace(this, true);
      emitter$$28.recordSourceMappingStart(this);
      var temp$$6 = emitter$$28.setInObjectLiteral(false);
      emitter$$28.writeToOutput("for(");
      var v11345 = this.init;
      if (v11345) {
        var v22854 = this.init;
        var v18389 = v22854.nodeType;
        var v22855 = TypeScript$$4.NodeType;
        var v18390 = v22855.List;
        var v11344 = v18389 != v18390;
        if (v11344) {
          var v11339 = this.init;
          var v18391 = TypeScript$$4.TokenID;
          var v11340 = v18391.For;
          emitter$$28.emitJavascript(v11339, v11340, false);
        } else {
          var v22856 = this.init;
          var v18392 = v22856.members;
          var v11341 = v18392.length;
          emitter$$28.setInVarBlock(v11341);
          var v11342 = this.init;
          var v18393 = TypeScript$$4.TokenID;
          var v11343 = v18393.For;
          emitter$$28.emitJavascriptList(v11342, null, v11343, false, false, false);
        }
      }
      emitter$$28.writeToOutput("; ");
      var v11346 = this.cond;
      var v18394 = TypeScript$$4.TokenID;
      var v11347 = v18394.For;
      emitter$$28.emitJavascript(v11346, v11347, false);
      emitter$$28.writeToOutput("; ");
      var v11348 = this.incr;
      var v18395 = TypeScript$$4.TokenID;
      var v11349 = v18395.For;
      emitter$$28.emitJavascript(v11348, v11349, false);
      emitter$$28.writeToOutput(")");
      var v11350 = this.body;
      emitter$$28.emitJavascriptStatements(v11350, true);
      emitter$$28.setInObjectLiteral(temp$$6);
      emitter$$28.recordSourceMappingEnd(this);
      emitter$$28.emitParensAndCommentsInPlace(this, false);
      return;
    }
    function v273() {
      return true;
    }
    function ForStatement$$1(init) {
      var v18396 = TypeScript$$4.NodeType;
      var v11351 = v18396.For;
      _super$$36.call(this, v11351);
      this.init = init;
      return;
    }
    __extends(ForStatement$$1, _super$$36);
    var v11352 = ForStatement$$1.prototype;
    v11352.isLoop = v273;
    var v11353 = ForStatement$$1.prototype;
    v11353.emit = v274;
    var v11354 = ForStatement$$1.prototype;
    v11354.typeCheck = v275;
    var v11355 = ForStatement$$1.prototype;
    v11355.addToControlFlow = v276;
    return ForStatement$$1;
  }
  function v272(_super$$35) {
    function v271(context$$18) {
      var v11357 = this.lval;
      if (v11357) {
        var v11356 = this.lval;
        context$$18.addContent(v11356);
      }
      var v11359 = this.obj;
      if (v11359) {
        var v11358 = this.obj;
        context$$18.addContent(v11358);
      }
      var loopHeader$$2 = context$$18.current;
      var v11360 = TypeScript$$4.BasicBlock;
      var loopStart$$2 = new v11360;
      var v11361 = TypeScript$$4.BasicBlock;
      var afterLoop$$2 = new v11361;
      loopHeader$$2.addSuccessor(loopStart$$2);
      context$$18.current = loopStart$$2;
      var v11363 = this.body;
      if (v11363) {
        context$$18.pushStatement(this, loopStart$$2, afterLoop$$2);
        var v11362 = this.body;
        context$$18.walk(v11362, this);
        context$$18.popStatement();
      }
      var v18397 = context$$18.noContinuation;
      var v11364 = !v18397;
      if (v11364) {
        var loopEnd$$2 = context$$18.current;
        loopEnd$$2.addSuccessor(loopStart$$2);
      }
      context$$18.current = afterLoop$$2;
      context$$18.noContinuation = false;
      loopHeader$$2.addSuccessor(afterLoop$$2);
      var v18398 = context$$18.walker;
      var v11365 = v18398.options;
      v11365.goChildren = false;
      return;
    }
    function v270(typeFlow$$25) {
      var v22857 = typeFlow$$25.checker;
      var v18399 = v22857.styleSettings;
      var v11368 = v18399.forin;
      if (v11368) {
        var v18400 = this.isFiltered();
        var v11367 = !v18400;
        if (v11367) {
          var v18401 = typeFlow$$25.checker;
          var v11366 = v18401.errorReporter;
          v11366.styleError(this, "no hasOwnProperty filter");
        }
      }
      return typeFlow$$25.typeCheckForIn(this);
    }
    function v269(emitter$$27, tokenId$$27, startLine$$27) {
      emitter$$27.emitParensAndCommentsInPlace(this, true);
      emitter$$27.recordSourceMappingStart(this);
      var temp$$5 = emitter$$27.setInObjectLiteral(false);
      var v11369 = this.statement;
      emitter$$27.recordSourceMappingStart(v11369);
      emitter$$27.writeToOutput("for(");
      var v11370 = this.lval;
      var v18402 = TypeScript$$4.TokenID;
      var v11371 = v18402.For;
      emitter$$27.emitJavascript(v11370, v11371, false);
      emitter$$27.writeToOutput(" in ");
      var v11372 = this.obj;
      var v18403 = TypeScript$$4.TokenID;
      var v11373 = v18403.For;
      emitter$$27.emitJavascript(v11372, v11373, false);
      emitter$$27.writeToOutput(")");
      var v11374 = this.statement;
      emitter$$27.recordSourceMappingEnd(v11374);
      var v11375 = this.body;
      emitter$$27.emitJavascriptStatements(v11375, true);
      emitter$$27.setInObjectLiteral(temp$$5);
      emitter$$27.recordSourceMappingEnd(this);
      emitter$$27.emitParensAndCommentsInPlace(this, false);
      return;
    }
    function v268() {
      var v11392 = this.body;
      if (v11392) {
        var singleItem = null;
        var v22858 = this.body;
        var v18404 = v22858.nodeType;
        var v22859 = TypeScript$$4.NodeType;
        var v18405 = v22859.List;
        var v11378 = v18404 == v18405;
        if (v11378) {
          var stmts = this.body;
          var v22860 = stmts.members;
          var v18406 = v22860.length;
          var v11377 = v18406 == 1;
          if (v11377) {
            var v11376 = stmts.members;
            singleItem = v11376[0];
          }
        } else {
          singleItem = this.body;
        }
        var v11391 = singleItem !== null;
        if (v11391) {
          var v18407 = singleItem.nodeType;
          var v22861 = TypeScript$$4.NodeType;
          var v18408 = v22861.Block;
          var v11381 = v18407 == v18408;
          if (v11381) {
            var block = singleItem;
            var v22862 = block.statements;
            var v18409 = v22862 !== null;
            if (v18409) {
              var v25996 = block.statements;
              var v25065 = v25996.members;
              var v22863 = v25065.length;
              v18409 = v22863 == 1;
            }
            var v11380 = v18409;
            if (v11380) {
              var v18410 = block.statements;
              var v11379 = v18410.members;
              singleItem = v11379[0];
            }
          }
          var v18411 = singleItem.nodeType;
          var v22864 = TypeScript$$4.NodeType;
          var v18412 = v22864.If;
          var v11390 = v18411 == v18412;
          if (v11390) {
            var cond$$2 = singleItem.cond;
            var v18413 = cond$$2.nodeType;
            var v22865 = TypeScript$$4.NodeType;
            var v18414 = v22865.Call;
            var v11389 = v18413 == v18414;
            if (v11389) {
              var target$$27 = cond$$2.target;
              var v18415 = target$$27.nodeType;
              var v22866 = TypeScript$$4.NodeType;
              var v18416 = v22866.Dot;
              var v11388 = v18415 == v18416;
              if (v11388) {
                var binex = target$$27;
                var v25997 = binex.operand1;
                var v25066 = v25997.nodeType;
                var v25998 = TypeScript$$4.NodeType;
                var v25067 = v25998.Name;
                var v22867 = v25066 == v25067;
                if (v22867) {
                  var v25999 = this.obj;
                  var v25068 = v25999.nodeType;
                  var v26000 = TypeScript$$4.NodeType;
                  var v25069 = v26000.Name;
                  v22867 = v25068 == v25069;
                }
                var v18417 = v22867;
                if (v18417) {
                  var v25070 = binex.operand1;
                  var v22868 = v25070.actualText;
                  var v25071 = this.obj;
                  var v22869 = v25071.actualText;
                  v18417 = v22868 == v22869;
                }
                var v11387 = v18417;
                if (v11387) {
                  var prop$$4 = binex.operand2;
                  var v18418 = prop$$4.actualText;
                  var v11386 = v18418 == "hasOwnProperty";
                  if (v11386) {
                    var args$$2 = cond$$2.arguments;
                    var v18419 = args$$2 !== null;
                    if (v18419) {
                      var v25072 = args$$2.members;
                      var v22870 = v25072.length;
                      v18419 = v22870 == 1;
                    }
                    var v11385 = v18419;
                    if (v11385) {
                      var v11382 = args$$2.members;
                      var arg$$2 = v11382[0];
                      var v22871 = arg$$2.nodeType;
                      var v25073 = TypeScript$$4.NodeType;
                      var v22872 = v25073.Name;
                      var v18420 = v22871 == v22872;
                      if (v18420) {
                        var v25074 = this.lval;
                        var v22873 = v25074.nodeType;
                        var v25075 = TypeScript$$4.NodeType;
                        var v22874 = v25075.Name;
                        v18420 = v22873 == v22874;
                      }
                      var v11384 = v18420;
                      if (v11384) {
                        var v22875 = this.lval;
                        var v18421 = v22875.actualText;
                        var v18422 = arg$$2.actualText;
                        var v11383 = v18421 == v18422;
                        if (v11383) {
                          return true;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      return false;
    }
    function v267() {
      return true;
    }
    function ForInStatement$$1(lval, obj$$16) {
      var v18423 = TypeScript$$4.NodeType;
      var v11393 = v18423.ForIn;
      _super$$35.call(this, v11393);
      this.lval = lval;
      this.obj = obj$$16;
      var v27414 = new ASTSpan;
      this.statement = v27414;
      var v18424 = this.lval;
      if (v18424) {
        var v25076 = this.lval;
        var v22876 = v25076.nodeType;
        var v25077 = TypeScript$$4.NodeType;
        var v22877 = v25077.VarDecl;
        v18424 = v22876 == v22877;
      }
      var v11395 = v18424;
      if (v11395) {
        var v11394 = this.lval;
        var v22878 = v11394.varFlags;
        var v25078 = TypeScript$$4.VarFlags;
        var v22879 = v25078.AutoInit;
        v11394.varFlags = v22878 | v22879;
      }
      return;
    }
    __extends(ForInStatement$$1, _super$$35);
    var v11396 = ForInStatement$$1.prototype;
    v11396.isLoop = v267;
    var v11397 = ForInStatement$$1.prototype;
    v11397.isFiltered = v268;
    var v11398 = ForInStatement$$1.prototype;
    v11398.emit = v269;
    var v11399 = ForInStatement$$1.prototype;
    v11399.typeCheck = v270;
    var v11400 = ForInStatement$$1.prototype;
    v11400.addToControlFlow = v271;
    return ForInStatement$$1;
  }
  function v266(_super$$34) {
    function EndCode$$1() {
      var v18425 = TypeScript$$4.NodeType;
      var v11401 = v18425.EndCode;
      _super$$34.call(this, v11401);
      return;
    }
    __extends(EndCode$$1, _super$$34);
    return EndCode$$1;
  }
  function v265(_super$$33) {
    function v264(typeFlow$$24) {
      return typeFlow$$24.typeCheckReturn(this);
    }
    function v263(context$$17) {
      var v18426 = _super$$33.prototype;
      var v11402 = v18426.addToControlFlow;
      v11402.call(this, context$$17);
      context$$17.returnStmt();
      return;
    }
    function v262(emitter$$26, tokenId$$26, startLine$$26) {
      emitter$$26.emitParensAndCommentsInPlace(this, true);
      emitter$$26.recordSourceMappingStart(this);
      var temp$$4 = emitter$$26.setInObjectLiteral(false);
      var v11406 = this.returnExpression;
      if (v11406) {
        emitter$$26.writeToOutput("return ");
        var v11403 = this.returnExpression;
        var v18427 = TypeScript$$4.TokenID;
        var v11404 = v18427.Semicolon;
        emitter$$26.emitJavascript(v11403, v11404, false);
        var v22880 = this.returnExpression;
        var v18428 = v22880.nodeType;
        var v22881 = TypeScript$$4.NodeType;
        var v18429 = v22881.FuncDecl;
        var v11405 = v18428 === v18429;
        if (v11405) {
          emitter$$26.writeToOutput(";");
        }
      } else {
        emitter$$26.writeToOutput("return;");
      }
      emitter$$26.setInObjectLiteral(temp$$4);
      emitter$$26.recordSourceMappingEnd(this);
      emitter$$26.emitParensAndCommentsInPlace(this, false);
      return;
    }
    function ReturnStatement$$1() {
      var v18430 = TypeScript$$4.NodeType;
      var v11407 = v18430.Return;
      _super$$33.call(this, v11407);
      this.returnExpression = null;
      return;
    }
    __extends(ReturnStatement$$1, _super$$33);
    var v11408 = ReturnStatement$$1.prototype;
    v11408.emit = v262;
    var v11409 = ReturnStatement$$1.prototype;
    v11409.addToControlFlow = v263;
    var v11410 = ReturnStatement$$1.prototype;
    v11410.typeCheck = v264;
    return ReturnStatement$$1;
  }
  function v261(_super$$32) {
    function v260(context$$16) {
      var v11411 = this.cond;
      v11411.addToControlFlow(context$$16);
      var v11412 = TypeScript$$4.BasicBlock;
      var afterIf = new v11412;
      var beforeIf = context$$16.current;
      context$$16.pushStatement(this, beforeIf, afterIf);
      var hasContinuation = false;
      var v11413 = context$$16;
      var v18431 = TypeScript$$4.BasicBlock;
      var v27415 = new v18431;
      v11413.current = v27415;
      var v11414 = context$$16.current;
      beforeIf.addSuccessor(v11414);
      var v11415 = this.thenBod;
      context$$16.walk(v11415, this);
      var v18432 = context$$16.noContinuation;
      var v11417 = !v18432;
      if (v11417) {
        hasContinuation = true;
        var v11416 = context$$16.current;
        v11416.addSuccessor(afterIf);
      }
      var v11423 = this.elseBod;
      if (v11423) {
        var v11418 = context$$16;
        var v18433 = TypeScript$$4.BasicBlock;
        var v27416 = new v18433;
        v11418.current = v27416;
        context$$16.noContinuation = false;
        var v11419 = context$$16.current;
        beforeIf.addSuccessor(v11419);
        var v11420 = this.elseBod;
        context$$16.walk(v11420, this);
        var v18434 = context$$16.noContinuation;
        var v11422 = !v18434;
        if (v11422) {
          hasContinuation = true;
          var v11421 = context$$16.current;
          v11421.addSuccessor(afterIf);
        } else {
          if (hasContinuation) {
            context$$16.noContinuation = false;
          }
        }
      } else {
        beforeIf.addSuccessor(afterIf);
        context$$16.noContinuation = false;
        hasContinuation = true;
      }
      var targetInfo$$2 = context$$16.popStatement();
      var v22882 = afterIf.predecessors;
      var v18435 = v22882.length;
      var v11424 = v18435 > 0;
      if (v11424) {
        context$$16.noContinuation = false;
        hasContinuation = true;
      }
      if (hasContinuation) {
        context$$16.current = afterIf;
      }
      var v18436 = context$$16.walker;
      var v11425 = v18436.options;
      v11425.goChildren = false;
      return;
    }
    function v259(typeFlow$$23) {
      return typeFlow$$23.typeCheckIf(this);
    }
    function v258(emitter$$25, tokenId$$25, startLine$$25) {
      emitter$$25.emitParensAndCommentsInPlace(this, true);
      emitter$$25.recordSourceMappingStart(this);
      var temp$$3 = emitter$$25.setInObjectLiteral(false);
      var v11426 = this.statement;
      emitter$$25.recordSourceMappingStart(v11426);
      emitter$$25.writeToOutput("if(");
      var v11427 = this.cond;
      var v18437 = TypeScript$$4.TokenID;
      var v11428 = v18437.If;
      emitter$$25.emitJavascript(v11427, v11428, false);
      emitter$$25.writeToOutput(")");
      var v11429 = this.statement;
      emitter$$25.recordSourceMappingEnd(v11429);
      var v11430 = this.thenBod;
      emitter$$25.emitJavascriptStatements(v11430, true);
      var v11434 = this.elseBod;
      if (v11434) {
        var v22883 = this.elseBod;
        var v18438 = v22883.nodeType;
        var v22884 = TypeScript$$4.NodeType;
        var v18439 = v22884.If;
        var v11433 = v18438 === v18439;
        if (v11433) {
          emitter$$25.writeToOutput(" else ");
          var v11431 = this.elseBod;
          v11431.emit(emitter$$25, tokenId$$25, false);
        } else {
          emitter$$25.writeToOutput(" else");
          var v11432 = this.elseBod;
          emitter$$25.emitJavascriptStatements(v11432, true);
        }
      }
      emitter$$25.setInObjectLiteral(temp$$3);
      emitter$$25.recordSourceMappingEnd(this);
      emitter$$25.emitParensAndCommentsInPlace(this, false);
      return;
    }
    function v257() {
      return true;
    }
    function IfStatement$$1(cond$$1) {
      var v18440 = TypeScript$$4.NodeType;
      var v11435 = v18440.If;
      _super$$32.call(this, v11435);
      this.cond = cond$$1;
      this.elseBod = null;
      var v27417 = new ASTSpan;
      this.statement = v27417;
      return;
    }
    __extends(IfStatement$$1, _super$$32);
    var v11436 = IfStatement$$1.prototype;
    v11436.isCompoundStatement = v257;
    var v11437 = IfStatement$$1.prototype;
    v11437.emit = v258;
    var v11438 = IfStatement$$1.prototype;
    v11438.typeCheck = v259;
    var v11439 = IfStatement$$1.prototype;
    v11439.addToControlFlow = v260;
    return IfStatement$$1;
  }
  function v256(_super$$31) {
    function v255(context$$15) {
      var loopHeader$$1 = context$$15.current;
      var v11440 = TypeScript$$4.BasicBlock;
      var loopStart$$1 = new v11440;
      var v11441 = TypeScript$$4.BasicBlock;
      var afterLoop$$1 = new v11441;
      loopHeader$$1.addSuccessor(loopStart$$1);
      context$$15.current = loopStart$$1;
      var targetInfo$$1 = null;
      var v11443 = this.body;
      if (v11443) {
        context$$15.pushStatement(this, loopStart$$1, afterLoop$$1);
        var v11442 = this.body;
        context$$15.walk(v11442, this);
        targetInfo$$1 = context$$15.popStatement();
      }
      var v18441 = context$$15.noContinuation;
      var v11446 = !v18441;
      if (v11446) {
        var loopEnd$$1 = context$$15.current;
        loopEnd$$1.addSuccessor(loopStart$$1);
        var v11444 = this.cond;
        context$$15.addContent(v11444);
        context$$15.current = afterLoop$$1;
        loopEnd$$1.addSuccessor(afterLoop$$1);
      } else {
        var v11445 = this.cond;
        context$$15.addUnreachable(v11445);
      }
      var v18442 = context$$15.walker;
      var v11447 = v18442.options;
      v11447.goChildren = false;
      return;
    }
    function v254(typeFlow$$22) {
      return typeFlow$$22.typeCheckDoWhile(this);
    }
    function v253(emitter$$24, tokenId$$24, startLine$$24) {
      emitter$$24.emitParensAndCommentsInPlace(this, true);
      emitter$$24.recordSourceMappingStart(this);
      var temp$$2 = emitter$$24.setInObjectLiteral(false);
      emitter$$24.writeToOutput("do");
      var v11448 = this.body;
      emitter$$24.emitJavascriptStatements(v11448, true);
      var v11449 = this.whileAST;
      emitter$$24.recordSourceMappingStart(v11449);
      emitter$$24.writeToOutput("while");
      var v11450 = this.whileAST;
      emitter$$24.recordSourceMappingEnd(v11450);
      emitter$$24.writeToOutput("(");
      var v11451 = this.cond;
      var v18443 = TypeScript$$4.TokenID;
      var v11452 = v18443.CloseParen;
      emitter$$24.emitJavascript(v11451, v11452, false);
      emitter$$24.writeToOutput(")");
      emitter$$24.setInObjectLiteral(temp$$2);
      emitter$$24.recordSourceMappingEnd(this);
      emitter$$24.writeToOutput(";");
      emitter$$24.emitParensAndCommentsInPlace(this, false);
      return;
    }
    function v252() {
      return true;
    }
    function DoWhileStatement$$1() {
      var v18444 = TypeScript$$4.NodeType;
      var v11453 = v18444.DoWhile;
      _super$$31.call(this, v11453);
      this.body = null;
      this.whileAST = null;
      this.cond = null;
      return;
    }
    __extends(DoWhileStatement$$1, _super$$31);
    var v11454 = DoWhileStatement$$1.prototype;
    v11454.isLoop = v252;
    var v11455 = DoWhileStatement$$1.prototype;
    v11455.emit = v253;
    var v11456 = DoWhileStatement$$1.prototype;
    v11456.typeCheck = v254;
    var v11457 = DoWhileStatement$$1.prototype;
    v11457.addToControlFlow = v255;
    return DoWhileStatement$$1;
  }
  function v251(_super$$30) {
    function v250(context$$14) {
      var loopHeader = context$$14.current;
      var v11458 = TypeScript$$4.BasicBlock;
      var loopStart = new v11458;
      var v11459 = TypeScript$$4.BasicBlock;
      var afterLoop = new v11459;
      loopHeader.addSuccessor(loopStart);
      context$$14.current = loopStart;
      var v11460 = this.cond;
      context$$14.addContent(v11460);
      var condBlock = context$$14.current;
      var targetInfo = null;
      var v11464 = this.body;
      if (v11464) {
        var v11461 = context$$14;
        var v18445 = TypeScript$$4.BasicBlock;
        var v27418 = new v18445;
        v11461.current = v27418;
        var v11462 = context$$14.current;
        condBlock.addSuccessor(v11462);
        context$$14.pushStatement(this, loopStart, afterLoop);
        var v11463 = this.body;
        context$$14.walk(v11463, this);
        targetInfo = context$$14.popStatement();
      }
      var v18446 = context$$14.noContinuation;
      var v11465 = !v18446;
      if (v11465) {
        var loopEnd = context$$14.current;
        loopEnd.addSuccessor(loopStart);
      }
      context$$14.current = afterLoop;
      condBlock.addSuccessor(afterLoop);
      context$$14.noContinuation = false;
      var v18447 = context$$14.walker;
      var v11466 = v18447.options;
      v11466.goChildren = false;
      return;
    }
    function v249(typeFlow$$21) {
      return typeFlow$$21.typeCheckWhile(this);
    }
    function v248(emitter$$23, tokenId$$23, startLine$$23) {
      emitter$$23.emitParensAndCommentsInPlace(this, true);
      emitter$$23.recordSourceMappingStart(this);
      var temp$$1 = emitter$$23.setInObjectLiteral(false);
      emitter$$23.writeToOutput("while(");
      var v11467 = this.cond;
      var v18448 = TypeScript$$4.TokenID;
      var v11468 = v18448.While;
      emitter$$23.emitJavascript(v11467, v11468, false);
      emitter$$23.writeToOutput(")");
      var v11469 = this.body;
      emitter$$23.emitJavascriptStatements(v11469, false);
      emitter$$23.setInObjectLiteral(temp$$1);
      emitter$$23.recordSourceMappingEnd(this);
      emitter$$23.emitParensAndCommentsInPlace(this, false);
      return;
    }
    function v247() {
      return true;
    }
    function WhileStatement$$1(cond) {
      var v18449 = TypeScript$$4.NodeType;
      var v11470 = v18449.While;
      _super$$30.call(this, v11470);
      this.cond = cond;
      this.body = null;
      return;
    }
    __extends(WhileStatement$$1, _super$$30);
    var v11471 = WhileStatement$$1.prototype;
    v11471.isLoop = v247;
    var v11472 = WhileStatement$$1.prototype;
    v11472.emit = v248;
    var v11473 = WhileStatement$$1.prototype;
    v11473.typeCheck = v249;
    var v11474 = WhileStatement$$1.prototype;
    v11474.addToControlFlow = v250;
    return WhileStatement$$1;
  }
  function v246(_super$$29) {
    function v245(emitter$$22, tokenId$$22, startLine$$22) {
      emitter$$22.emitParensAndCommentsInPlace(this, true);
      emitter$$22.recordSourceMappingStart(this);
      var v18450 = this.nodeType;
      var v22885 = TypeScript$$4.NodeType;
      var v18451 = v22885.Break;
      var v11475 = v18450 == v18451;
      if (v11475) {
        emitter$$22.writeToOutput("break");
      } else {
        emitter$$22.writeToOutput("continue");
      }
      var v11477 = this.target;
      if (v11477) {
        var v18452 = this.target;
        var v11476 = " " + v18452;
        emitter$$22.writeToOutput(v11476);
      }
      emitter$$22.recordSourceMappingEnd(this);
      emitter$$22.writeToOutput(";");
      emitter$$22.emitParensAndCommentsInPlace(this, false);
      return;
    }
    function v244(context$$13) {
      var v18453 = _super$$29.prototype;
      var v11478 = v18453.addToControlFlow;
      v11478.call(this, context$$13);
      var v11479 = this.resolvedTarget;
      var v18454 = this.nodeType;
      var v22886 = TypeScript$$4.NodeType;
      var v18455 = v22886.Continue;
      var v11480 = v18454 == v18455;
      context$$13.unconditionalBranch(v11479, v11480);
      return;
    }
    function v243(parser, stmt$$2) {
      var v11481 = stmt$$2.isLoop();
      if (v11481) {
        this.resolvedTarget = stmt$$2;
        return true;
      }
      var v18456 = this.nodeType;
      var v22887 = TypeScript$$4.NodeType;
      var v18457 = v22887.Continue;
      var v11483 = v18456 === v18457;
      if (v11483) {
        parser.reportParseError("continue statement applies only to loops");
        return false;
      } else {
        var v22888 = stmt$$2.nodeType;
        var v25079 = TypeScript$$4.NodeType;
        var v22889 = v25079.Switch;
        var v18458 = v22888 == v22889;
        var v22890 = !v18458;
        if (v22890) {
          v18458 = this.target;
        }
        var v11482 = v18458;
        if (v11482) {
          this.resolvedTarget = stmt$$2;
          return true;
        } else {
          parser.reportParseError("break statement with no label can apply only to a loop or switch statement");
          return false;
        }
      }
      return;
    }
    function v242() {
      return this.target;
    }
    function Jump$$1(nodeType$$11) {
      _super$$29.call(this, nodeType$$11);
      this.target = null;
      this.resolvedTarget = null;
      return;
    }
    __extends(Jump$$1, _super$$29);
    var v11484 = Jump$$1.prototype;
    v11484.hasExplicitTarget = v242;
    var v11485 = Jump$$1.prototype;
    v11485.setResolvedTarget = v243;
    var v11486 = Jump$$1.prototype;
    v11486.addToControlFlow = v244;
    var v11487 = Jump$$1.prototype;
    v11487.emit = v245;
    return Jump$$1;
  }
  function v241(_super$$28) {
    function v240(typeFlow$$20) {
      var v25080 = typeFlow$$20.checker;
      var v22891 = v25080.styleSettings;
      var v18459 = v22891.emptyBlocks;
      var v11490 = !v18459;
      if (v11490) {
        var v22892 = this.statements;
        var v18460 = v22892 === null;
        var v22894 = !v18460;
        if (v22894) {
          var v26001 = this.statements;
          var v25081 = v26001.members;
          var v22893 = v25081.length;
          v18460 = v22893 == 0;
        }
        var v11489 = v18460;
        if (v11489) {
          var v18461 = typeFlow$$20.checker;
          var v11488 = v18461.errorReporter;
          v11488.styleError(this, "empty block");
        }
      }
      var v11491 = this.statements;
      typeFlow$$20.typeCheck(v11491);
      return this;
    }
    function v239(context$$12) {
      var v11492 = TypeScript$$4.BasicBlock;
      var afterIfNeeded = new v11492;
      var v11493 = context$$12.current;
      context$$12.pushStatement(this, v11493, afterIfNeeded);
      var v11495 = this.statements;
      if (v11495) {
        var v11494 = this.statements;
        context$$12.walk(v11494, this);
      }
      var v18462 = context$$12.walker;
      var v11496 = v18462.options;
      v11496.goChildren = false;
      context$$12.popStatement();
      var v22895 = afterIfNeeded.predecessors;
      var v18463 = v22895.length;
      var v11498 = v18463 > 0;
      if (v11498) {
        var v11497 = context$$12.current;
        v11497.addSuccessor(afterIfNeeded);
        context$$12.current = afterIfNeeded;
      }
      return;
    }
    function v238(emitter$$21, tokenId$$21, startLine$$21) {
      emitter$$21.emitParensAndCommentsInPlace(this, true);
      emitter$$21.recordSourceMappingStart(this);
      var v11501 = this.isStatementBlock;
      if (v11501) {
        emitter$$21.writeLineToOutput(" {");
        var v11499 = emitter$$21.indenter;
        v11499.increaseIndent();
      } else {
        var v22896 = this.statements;
        var v18464 = v22896.members;
        var v11500 = v18464.length;
        emitter$$21.setInVarBlock(v11500);
      }
      var temp = emitter$$21.setInObjectLiteral(false);
      var v11504 = this.statements;
      if (v11504) {
        var v11502 = this.statements;
        var v18465 = TypeScript$$4.TokenID;
        var v11503 = v18465.Semicolon;
        emitter$$21.emitJavascriptList(v11502, null, v11503, true, false, false);
      }
      var v11506 = this.isStatementBlock;
      if (v11506) {
        var v11505 = emitter$$21.indenter;
        v11505.decreaseIndent();
        emitter$$21.emitIndent();
        emitter$$21.writeToOutput("}");
      }
      emitter$$21.setInObjectLiteral(temp);
      emitter$$21.recordSourceMappingEnd(this);
      emitter$$21.emitParensAndCommentsInPlace(this, false);
      return;
    }
    function Block$$1(statements, isStatementBlock) {
      var v18466 = TypeScript$$4.NodeType;
      var v11507 = v18466.Block;
      _super$$28.call(this, v11507);
      this.statements = statements;
      this.isStatementBlock = isStatementBlock;
      return;
    }
    __extends(Block$$1, _super$$28);
    var v11508 = Block$$1.prototype;
    v11508.emit = v238;
    var v11509 = Block$$1.prototype;
    v11509.addToControlFlow = v239;
    var v11510 = Block$$1.prototype;
    v11510.typeCheck = v240;
    return Block$$1;
  }
  function v237(_super$$27) {
    function v236(context$$11) {
      var beforeBB = context$$11.current;
      var v11511 = TypeScript$$4.BasicBlock;
      var bb = new v11511;
      context$$11.current = bb;
      beforeBB.addSuccessor(bb);
      return;
    }
    function v235(typeFlow$$19) {
      var v11512 = this.labels;
      typeFlow$$19.typeCheck(v11512);
      var v11513 = this.stmt;
      var v27419 = v11513.typeCheck(typeFlow$$19);
      this.stmt = v27419;
      return this;
    }
    function v234(emitter$$20, tokenId$$20, startLine$$20) {
      emitter$$20.emitParensAndCommentsInPlace(this, true);
      emitter$$20.recordSourceMappingStart(this);
      var v11517 = this.labels;
      if (v11517) {
        var v18467 = this.labels;
        var v11514 = v18467.members;
        var labelsLen = v11514.length;
        var i$$18 = 0;
        var v11516 = i$$18 < labelsLen;
        for (;v11516;) {
          var v22897 = this.labels;
          var v18468 = v22897.members;
          var v11515 = v18468[i$$18];
          v11515.emit(emitter$$20, tokenId$$20, startLine$$20);
          i$$18 = i$$18 + 1;
          v11516 = i$$18 < labelsLen;
        }
      }
      var v11518 = this.stmt;
      v11518.emit(emitter$$20, tokenId$$20, true);
      emitter$$20.recordSourceMappingEnd(this);
      emitter$$20.emitParensAndCommentsInPlace(this, false);
      return;
    }
    function LabeledStatement$$1(labels, stmt$$1) {
      var v18469 = TypeScript$$4.NodeType;
      var v11519 = v18469.LabeledStatement;
      _super$$27.call(this, v11519);
      this.labels = labels;
      this.stmt = stmt$$1;
      return;
    }
    __extends(LabeledStatement$$1, _super$$27);
    var v11520 = LabeledStatement$$1.prototype;
    v11520.emit = v234;
    var v11521 = LabeledStatement$$1.prototype;
    v11521.typeCheck = v235;
    var v11522 = LabeledStatement$$1.prototype;
    v11522.addToControlFlow = v236;
    return LabeledStatement$$1;
  }
  function v233(_super$$26) {
    function v232(typeFlow$$18) {
      this.type = typeFlow$$18.voidType;
      return this;
    }
    function v231() {
      return this.isLoop();
    }
    function v230() {
      return true;
    }
    function v229() {
      return false;
    }
    function Statement$$1(nodeType$$10) {
      _super$$26.call(this, nodeType$$10);
      var v18470 = this.flags;
      var v22898 = TypeScript$$4.ASTFlags;
      var v18471 = v22898.IsStatement;
      this.flags = v18470 | v18471;
      return;
    }
    __extends(Statement$$1, _super$$26);
    var v11523 = Statement$$1.prototype;
    v11523.isLoop = v229;
    var v11524 = Statement$$1.prototype;
    v11524.isStatementOrExpression = v230;
    var v11525 = Statement$$1.prototype;
    v11525.isCompoundStatement = v231;
    var v11526 = Statement$$1.prototype;
    v11526.typeCheck = v232;
    return Statement$$1;
  }
  function v228(_super$$25) {
    function v227(emitter$$19, tokenId$$19, startLine$$19) {
      return;
    }
    function v226(typeFlow$$17) {
      return typeFlow$$17.typeCheckInterface(this);
    }
    function InterfaceDeclaration$$1(name$$38, members$$4, extendsList$$2, implementsList$$2) {
      var v18472 = TypeScript$$4.NodeType;
      var v11527 = v18472.InterfaceDeclaration;
      _super$$25.call(this, v11527, name$$38, extendsList$$2, implementsList$$2, members$$4);
      return;
    }
    __extends(InterfaceDeclaration$$1, _super$$25);
    var v11528 = InterfaceDeclaration$$1.prototype;
    v11528.typeCheck = v226;
    var v11529 = InterfaceDeclaration$$1.prototype;
    v11529.emit = v227;
    return InterfaceDeclaration$$1;
  }
  function v225(_super$$24) {
    function v224(emitter$$18, tokenId$$18, startLine$$18) {
      emitter$$18.emitJavascriptClass(this);
      return;
    }
    function v223(typeFlow$$16) {
      return typeFlow$$16.typeCheckClass(this);
    }
    function ClassDeclaration$$1(name$$37, members$$3, extendsList$$1, implementsList$$1) {
      var v18473 = TypeScript$$4.NodeType;
      var v11530 = v18473.ClassDeclaration;
      _super$$24.call(this, v11530, name$$37, extendsList$$1, implementsList$$1, members$$3);
      this.knownMemberNames = {};
      this.constructorDecl = null;
      this.constructorNestingLevel = 0;
      this.endingToken = null;
      return;
    }
    __extends(ClassDeclaration$$1, _super$$24);
    var v11531 = ClassDeclaration$$1.prototype;
    v11531.typeCheck = v223;
    var v11532 = ClassDeclaration$$1.prototype;
    v11532.emit = v224;
    return ClassDeclaration$$1;
  }
  function v222(_super$$23) {
    function v221() {
      var v11533 = this.varFlags;
      var v18474 = TypeScript$$4.VarFlags;
      var v11534 = v18474.Ambient;
      return TypeScript$$4.hasFlag(v11533, v11534);
    }
    function v220() {
      var v11535 = this.varFlags;
      var v18475 = TypeScript$$4.VarFlags;
      var v11536 = v18475.Exported;
      return TypeScript$$4.hasFlag(v11535, v11536);
    }
    function TypeDeclaration$$1(nodeType$$9, name$$36, extendsList, implementsList, members$$2) {
      _super$$23.call(this, nodeType$$9, name$$36, members$$2);
      this.extendsList = extendsList;
      this.implementsList = implementsList;
      var v11537 = TypeScript$$4.VarFlags;
      this.varFlags = v11537.None;
      return;
    }
    __extends(TypeDeclaration$$1, _super$$23);
    var v11538 = TypeDeclaration$$1.prototype;
    v11538.isExported = v220;
    var v11539 = TypeDeclaration$$1.prototype;
    v11539.isAmbient = v221;
    return TypeDeclaration$$1;
  }
  function v219(_super$$22) {
    function v218(emitter$$17, tokenId$$17, startLine$$17) {
      var v22899 = this.modFlags;
      var v25082 = TypeScript$$4.ModuleFlags;
      var v22900 = v25082.ShouldEmitModuleDecl;
      var v18476 = TypeScript$$4.hasFlag(v22899, v22900);
      var v11540 = !v18476;
      if (v11540) {
        emitter$$17.emitParensAndCommentsInPlace(this, true);
        emitter$$17.recordSourceMappingStart(this);
        emitter$$17.emitJavascriptModule(this);
        emitter$$17.recordSourceMappingEnd(this);
        emitter$$17.emitParensAndCommentsInPlace(this, false);
      }
      return;
    }
    function v217(typeFlow$$15) {
      return typeFlow$$15.typeCheckModule(this);
    }
    function v216() {
      var v18477 = this.modFlags;
      var v25083 = TypeScript$$4.ModuleFlags;
      var v22901 = v25083.ShouldEmitModuleDecl;
      var v18478 = ~v22901;
      this.modFlags = v18477 & v18478;
      return;
    }
    function v215() {
      var v11541 = this.modFlags;
      var v18479 = TypeScript$$4.ModuleFlags;
      var v11542 = v18479.IsEnum;
      return TypeScript$$4.hasFlag(v11541, v11542);
    }
    function v214() {
      var v11543 = this.modFlags;
      var v18480 = TypeScript$$4.ModuleFlags;
      var v11544 = v18480.Ambient;
      return TypeScript$$4.hasFlag(v11543, v11544);
    }
    function v213() {
      var v11545 = this.modFlags;
      var v18481 = TypeScript$$4.ModuleFlags;
      var v11546 = v18481.Exported;
      return TypeScript$$4.hasFlag(v11545, v11546);
    }
    function ModuleDeclaration$$1(name$$35, members$$1, vars$$2, scopes$$2, endingToken) {
      var v18482 = TypeScript$$4.NodeType;
      var v11547 = v18482.ModuleDeclaration;
      _super$$22.call(this, v11547, name$$35, members$$1);
      this.endingToken = endingToken;
      var v11548 = TypeScript$$4.ModuleFlags;
      this.modFlags = v11548.ShouldEmitModuleDecl;
      this.amdDependencies = [];
      this.containsUnicodeChar = false;
      this.containsUnicodeCharInComment = false;
      this.vars = vars$$2;
      this.scopes = scopes$$2;
      var v11549 = this.name;
      this.prettyName = v11549.actualText;
      return;
    }
    __extends(ModuleDeclaration$$1, _super$$22);
    var v11550 = ModuleDeclaration$$1.prototype;
    v11550.isExported = v213;
    var v11551 = ModuleDeclaration$$1.prototype;
    v11551.isAmbient = v214;
    var v11552 = ModuleDeclaration$$1.prototype;
    v11552.isEnum = v215;
    var v11553 = ModuleDeclaration$$1.prototype;
    v11553.recordNonInterface = v216;
    var v11554 = ModuleDeclaration$$1.prototype;
    v11554.typeCheck = v217;
    var v11555 = ModuleDeclaration$$1.prototype;
    v11555.emit = v218;
    return ModuleDeclaration$$1;
  }
  function v212(_super$$21) {
    function v211() {
      return true;
    }
    function NamedDeclaration$$1(nodeType$$8, name$$34, members) {
      _super$$21.call(this, nodeType$$8);
      this.name = name$$34;
      this.members = members;
      this.leftCurlyCount = 0;
      this.rightCurlyCount = 0;
      return;
    }
    __extends(NamedDeclaration$$1, _super$$21);
    var v11556 = NamedDeclaration$$1.prototype;
    v11556.isDeclaration = v211;
    return NamedDeclaration$$1;
  }
  function v210(_super$$20) {
    function v209(symbol$$1) {
      var i$$17 = 0;
      var v22902 = this.externallyVisibleImportedSymbols;
      var v18483 = v22902.length;
      var v11558 = i$$17 < v18483;
      for (;v11558;) {
        var v22903 = this.externallyVisibleImportedSymbols;
        var v18484 = v22903[i$$17];
        var v11557 = v18484 == symbol$$1;
        if (v11557) {
          return true;
        }
        i$$17 = i$$17 + 1;
        var v22904 = this.externallyVisibleImportedSymbols;
        var v18485 = v22904.length;
        v11558 = i$$17 < v18485;
      }
      return false;
    }
    function v208(symbol, checker) {
      var v11559 = this.isExternallyVisibleSymbol(symbol);
      if (v11559) {
        return;
      }
      var v25084 = symbol.getType();
      var v22905 = v25084.symbol;
      var v18486 = v22905.isExternallyVisible(checker);
      var v11565 = !v18486;
      if (v11565) {
        var quotes = "";
        var v18487 = symbol.getType();
        var v11560 = v18487.symbol;
        var moduleName = v11560.prettyName;
        var v18488 = TypeScript$$4.isQuoted(moduleName);
        var v11561 = !v18488;
        if (v11561) {
          quotes = "'";
        }
        var v11562 = checker.errorReporter;
        var v11563 = symbol.declAST;
        var v22906 = "Externally visible import statement uses non exported module " + quotes;
        var v18489 = v22906 + moduleName;
        var v11564 = v18489 + quotes;
        v11562.simpleError(v11563, v11564);
      }
      var v11566 = this.externallyVisibleImportedSymbols;
      v11566.push(symbol);
      return;
    }
    function v207(emitter$$16, tokenId$$16, startLine$$16) {
      var v18490 = emitter$$16.emitOptions;
      var v11572 = this.emitRequired(v18490);
      if (v11572) {
        var v11567 = this.bod;
        emitter$$16.emitParensAndCommentsInPlace(v11567, true);
        var v11568 = this.bod;
        var v18491 = TypeScript$$4.TokenID;
        var v11569 = v18491.Semicolon;
        var v11570 = this.requiresExtendsBlock;
        emitter$$16.emitJavascriptList(v11568, null, v11569, true, false, false, true, v11570);
        var v11571 = this.bod;
        emitter$$16.emitParensAndCommentsInPlace(v11571, false);
      }
      return;
    }
    function v206(emitOptions) {
      var v18492 = this.cachedEmitRequired;
      var v11573 = v18492 != undefined;
      if (v11573) {
        return this.cachedEmitRequired;
      }
      var v25085 = this.isDeclareFile;
      var v22907 = !v25085;
      if (v22907) {
        var v25086 = this.isResident;
        v22907 = !v25086;
      }
      var v18493 = v22907;
      if (v18493) {
        v18493 = this.bod;
      }
      var v11587 = v18493;
      if (v11587) {
        var i$$16 = 0;
        var v18494 = this.bod;
        var v11574 = v18494.members;
        var len$$4 = v11574.length;
        var v11585 = i$$16 < len$$4;
        for (;v11585;) {
          var v18495 = this.bod;
          var v11575 = v18495.members;
          var stmt = v11575[i$$16];
          var v18496 = stmt.nodeType;
          var v22908 = TypeScript$$4.NodeType;
          var v18497 = v22908.ModuleDeclaration;
          var v11584 = v18496 == v18497;
          if (v11584) {
            var v22909 = stmt.modFlags;
            var v26002 = TypeScript$$4.ModuleFlags;
            var v25087 = v26002.ShouldEmitModuleDecl;
            var v26003 = TypeScript$$4.ModuleFlags;
            var v25088 = v26003.Ambient;
            var v22910 = v25087 | v25088;
            var v18498 = TypeScript$$4.hasFlag(v22909, v22910);
            var v11576 = !v18498;
            if (v11576) {
              return this.setCachedEmitRequired(true);
            }
          } else {
            var v18499 = stmt.nodeType;
            var v22911 = TypeScript$$4.NodeType;
            var v18500 = v22911.ClassDeclaration;
            var v11583 = v18499 == v18500;
            if (v11583) {
              var v22912 = stmt.varFlags;
              var v25089 = TypeScript$$4.VarFlags;
              var v22913 = v25089.Ambient;
              var v18501 = TypeScript$$4.hasFlag(v22912, v22913);
              var v11577 = !v18501;
              if (v11577) {
                return this.setCachedEmitRequired(true);
              }
            } else {
              var v18502 = stmt.nodeType;
              var v22914 = TypeScript$$4.NodeType;
              var v18503 = v22914.VarDecl;
              var v11582 = v18502 == v18503;
              if (v11582) {
                var v22915 = stmt.varFlags;
                var v25090 = TypeScript$$4.VarFlags;
                var v22916 = v25090.Ambient;
                var v18504 = TypeScript$$4.hasFlag(v22915, v22916);
                var v11578 = !v18504;
                if (v11578) {
                  return this.setCachedEmitRequired(true);
                }
              } else {
                var v18505 = stmt.nodeType;
                var v22917 = TypeScript$$4.NodeType;
                var v18506 = v22917.FuncDecl;
                var v11581 = v18505 == v18506;
                if (v11581) {
                  var v18507 = stmt.isSignature();
                  var v11579 = !v18507;
                  if (v11579) {
                    return this.setCachedEmitRequired(true);
                  }
                } else {
                  var v22918 = stmt.nodeType;
                  var v25091 = TypeScript$$4.NodeType;
                  var v22919 = v25091.InterfaceDeclaration;
                  var v18508 = v22918 != v22919;
                  if (v18508) {
                    var v22920 = stmt.nodeType;
                    var v25092 = TypeScript$$4.NodeType;
                    var v22921 = v25092.Empty;
                    v18508 = v22920 != v22921;
                  }
                  var v11580 = v18508;
                  if (v11580) {
                    return this.setCachedEmitRequired(true);
                  }
                }
              }
            }
          }
          i$$16 = i$$16 + 1;
          v11585 = i$$16 < len$$4;
        }
        var v18509 = emitOptions.emitComments;
        if (v18509) {
          var v26004 = this.bod;
          var v25093 = v26004.preComments;
          if (v25093) {
            var v26584 = this.bod;
            var v26402 = v26584.preComments;
            var v26005 = v26402.length;
            v25093 = v26005 > 0;
          }
          var v22922 = v25093;
          var v25095 = !v22922;
          if (v25095) {
            var v26006 = this.bod;
            var v25094 = v26006.postComments;
            if (v25094) {
              var v26585 = this.bod;
              var v26403 = v26585.postComments;
              var v26007 = v26403.length;
              v25094 = v26007 > 0;
            }
            v22922 = v25094;
          }
          v18509 = v22922;
        }
        var v11586 = v18509;
        if (v11586) {
          return this.setCachedEmitRequired(true);
        }
      }
      return this.setCachedEmitRequired(false);
    }
    function v205() {
      return "Script";
    }
    function v204(typeFlow$$14) {
      return typeFlow$$14.typeCheckScript(this);
    }
    function v203(value$$29) {
      this.cachedEmitRequired = value$$29;
      return this.cachedEmitRequired;
    }
    function Script$$1(vars$$1, scopes$$1) {
      var v11588 = new Identifier("script");
      var v18510 = TypeScript$$4.NodeType;
      var v11589 = v18510.Script;
      _super$$20.call(this, v11588, null, false, null, vars$$1, scopes$$1, null, v11589);
      this.locationInfo = null;
      this.referencedFiles = [];
      this.requiresGlobal = false;
      this.requiresExtendsBlock = false;
      this.isResident = false;
      this.isDeclareFile = false;
      this.hasBeenTypeChecked = false;
      this.topLevelMod = null;
      this.leftCurlyCount = 0;
      this.rightCurlyCount = 0;
      this.containsUnicodeChar = false;
      this.containsUnicodeCharInComment = false;
      this.externallyVisibleImportedSymbols = [];
      this.vars = vars$$1;
      this.scopes = scopes$$1;
      return;
    }
    __extends(Script$$1, _super$$20);
    var v11590 = Script$$1.prototype;
    v11590.setCachedEmitRequired = v203;
    var v11591 = Script$$1.prototype;
    v11591.typeCheck = v204;
    var v11592 = Script$$1.prototype;
    v11592.treeViewLabel = v205;
    var v11593 = Script$$1.prototype;
    v11593.emitRequired = v206;
    var v11594 = Script$$1.prototype;
    v11594.emit = v207;
    var v11595 = Script$$1.prototype;
    v11595.AddExternallyVisibleImportedSymbol = v208;
    var v11596 = Script$$1.prototype;
    v11596.isExternallyVisibleSymbol = v209;
    return Script$$1;
  }
  function v202() {
    function LocationInfo$$1(filename, lineMap, unitIndex) {
      this.filename = filename;
      this.lineMap = lineMap;
      this.unitIndex = unitIndex;
      return;
    }
    return LocationInfo$$1;
  }
  function v201(_super$$19) {
    function v200() {
      var v18511 = this.fncFlags;
      var v22923 = TypeScript$$4.FncFlags;
      var v18512 = v22923.Signature;
      var v11597 = v18511 & v18512;
      var v18513 = TypeScript$$4.FncFlags;
      var v11598 = v18513.None;
      return v11597 != v11598;
    }
    function v199() {
      var v11599 = TypeScript$$4.FncFlags;
      this.fncFlags = v11599.None;
      return;
    }
    function v198() {
      var v18514 = this.name;
      var v11601 = v18514 == null;
      if (v11601) {
        return "funcExpr";
      } else {
        var v18515 = this.name;
        var v11600 = v18515.actualText;
        return "func: " + v11600;
      }
      return;
    }
    function v197() {
      var v11602 = this.fncFlags;
      var v18516 = TypeScript$$4.FncFlags;
      var v11603 = v18516.Static;
      return TypeScript$$4.hasFlag(v11602, v11603);
    }
    function v196() {
      var v11604 = this.fncFlags;
      var v18517 = TypeScript$$4.FncFlags;
      var v11605 = v18517.Public;
      return TypeScript$$4.hasFlag(v11604, v11605);
    }
    function v195() {
      var v11606 = this.fncFlags;
      var v18518 = TypeScript$$4.FncFlags;
      var v11607 = v18518.Private;
      return TypeScript$$4.hasFlag(v11606, v11607);
    }
    function v194() {
      var v11608 = this.fncFlags;
      var v18519 = TypeScript$$4.FncFlags;
      var v11609 = v18519.Exported;
      return TypeScript$$4.hasFlag(v11608, v11609);
    }
    function v193() {
      var v11610 = this.fncFlags;
      var v18520 = TypeScript$$4.FncFlags;
      var v11611 = v18520.Ambient;
      return TypeScript$$4.hasFlag(v11610, v11611);
    }
    function v192() {
      var v11612 = this.fncFlags;
      var v18521 = TypeScript$$4.FncFlags;
      var v11613 = v18521.SetAccessor;
      return TypeScript$$4.hasFlag(v11612, v11613);
    }
    function v191() {
      var v11614 = this.fncFlags;
      var v18522 = TypeScript$$4.FncFlags;
      var v11615 = v18522.GetAccessor;
      return TypeScript$$4.hasFlag(v11614, v11615);
    }
    function v190() {
      var v18523 = this.fncFlags;
      var v22924 = TypeScript$$4.FncFlags;
      var v18524 = v22924.GetAccessor;
      var v11616 = TypeScript$$4.hasFlag(v18523, v18524);
      var v18527 = !v11616;
      if (v18527) {
        var v18525 = this.fncFlags;
        var v22925 = TypeScript$$4.FncFlags;
        var v18526 = v22925.SetAccessor;
        v11616 = TypeScript$$4.hasFlag(v18525, v18526);
      }
      return v11616;
    }
    function v189() {
      var v11617 = this.name;
      return v11617 === null;
    }
    function v188() {
      var v18528 = this.isCallMember();
      var v22926 = !v18528;
      if (v22926) {
        v18528 = this.isIndexerMember();
      }
      var v11618 = v18528;
      var v18529 = !v11618;
      if (v18529) {
        v11618 = this.isConstructMember();
      }
      return v11618;
    }
    function v187() {
      var v11619 = this.fncFlags;
      var v18530 = TypeScript$$4.FncFlags;
      var v11620 = v18530.IndexerMember;
      return TypeScript$$4.hasFlag(v11619, v11620);
    }
    function v186() {
      var v11621 = this.fncFlags;
      var v18531 = TypeScript$$4.FncFlags;
      var v11622 = v18531.ConstructMember;
      return TypeScript$$4.hasFlag(v11621, v11622);
    }
    function v185() {
      var v11623 = this.fncFlags;
      var v18532 = TypeScript$$4.FncFlags;
      var v11624 = v18532.CallMember;
      return TypeScript$$4.hasFlag(v11623, v11624);
    }
    function v184() {
      var v18533 = this.fncFlags;
      var v22927 = TypeScript$$4.FncFlags;
      var v18534 = v22927.Method;
      var v11625 = v18533 & v18534;
      var v18535 = TypeScript$$4.FncFlags;
      var v11626 = v18535.None;
      return v11625 != v11626;
    }
    function v183() {
      var v11628 = this.name;
      if (v11628) {
        var v11627 = this.name;
        return v11627.actualText;
      } else {
        return this.hint;
      }
      return;
    }
    function v182(emitter$$15, tokenId$$15, startLine$$15) {
      emitter$$15.emitJavascriptFunction(this);
      return;
    }
    function v181(typeFlow$$13) {
      return typeFlow$$13.typeCheckFunction(this);
    }
    function v180() {
      function controlFlowPrefix(ast$$2, parent, walker$$1) {
        var v11629 = walker$$1.state;
        ast$$2.addToControlFlow(v11629);
        return ast$$2;
      }
      var v11630 = TypeScript$$4.BasicBlock;
      var entry$$1 = new v11630;
      var v11631 = TypeScript$$4.BasicBlock;
      var exit = new v11631;
      var v11632 = TypeScript$$4.ControlFlowContext;
      var context$$10 = new v11632(entry$$1, exit);
      var v11633 = TypeScript$$4.getAstWalkerFactory();
      var walker = v11633.getWalker(controlFlowPrefix, null, null, context$$10);
      context$$10.walker = walker;
      var v11634 = this.bod;
      walker.walk(v11634, this);
      return context$$10;
    }
    function v179(sym$$1) {
      var v18536 = this.jumpRefs;
      var v11635 = v18536 == null;
      if (v11635) {
        var v27420 = new Array;
        this.jumpRefs = v27420;
      }
      var v11636 = sym$$1.name;
      var id$$6 = new Identifier(v11636);
      var v11637 = this.jumpRefs;
      var v18537 = this.jumpRefs;
      var v11638 = v18537.length;
      v11637[v11638] = id$$6;
      id$$6.sym = sym$$1;
      var v11639 = id$$6;
      var v27421 = this.addCloRef(id$$6, null);
      v11639.cloId = v27421;
      return;
    }
    function v178(id$$5, sym) {
      var v18538 = this.envids;
      var v11640 = v18538 == null;
      if (v11640) {
        var v27422 = new Array;
        this.envids = v27422;
      }
      var v11641 = this.envids;
      var v18539 = this.envids;
      var v11642 = v18539.length;
      v11641[v11642] = id$$5;
      var outerFnc = this.enclosingFnc;
      if (sym) {
        var v18540 = outerFnc;
        if (v18540) {
          var v25096 = outerFnc.type;
          var v22928 = v25096.symbol;
          var v22929 = sym.container;
          v18540 = v22928 != v22929;
        }
        var v11643 = v18540;
        for (;v11643;) {
          outerFnc.addJumpRef(sym);
          outerFnc = outerFnc.enclosingFnc;
          var v18541 = outerFnc;
          if (v18541) {
            var v25097 = outerFnc.type;
            var v22930 = v25097.symbol;
            var v22931 = sym.container;
            v18541 = v22930 != v22931;
          }
          v11643 = v18541;
        }
      }
      var v18542 = this.envids;
      var v11644 = v18542.length;
      return v11644 - 1;
    }
    function v177() {
      var v18543 = this.fncFlags;
      var v22932 = TypeScript$$4.FncFlags;
      var v18544 = v22932.HasSuperReferenceInFatArrowFunction;
      this.fncFlags = v18543 | v18544;
      return;
    }
    function v176() {
      var v11645 = this.fncFlags;
      var v18545 = TypeScript$$4.FncFlags;
      var v11646 = v18545.HasSuperReferenceInFatArrowFunction;
      return TypeScript$$4.hasFlag(v11645, v11646);
    }
    function v175() {
      var v18546 = this.fncFlags;
      var v22933 = TypeScript$$4.FncFlags;
      var v18547 = v22933.HasSelfReference;
      this.fncFlags = v18546 | v18547;
      return;
    }
    function v174() {
      var v11647 = this.fncFlags;
      var v18548 = TypeScript$$4.FncFlags;
      var v11648 = v18548.HasSelfReference;
      return TypeScript$$4.hasFlag(v11647, v11648);
    }
    function v173() {
      var v18549 = this.internalNameCache;
      var v11650 = v18549 == null;
      if (v11650) {
        var extName = this.getNameText();
        if (extName) {
          this.internalNameCache = "_internal_" + extName;
        } else {
          var v11649 = internalId;
          internalId = internalId + 1;
          this.internalNameCache = "_internal_" + v11649;
        }
      }
      return this.internalNameCache;
    }
    function v172() {
      return true;
    }
    function FuncDecl$$1(name$$33, bod, isConstructor, args$$1, vars, scopes, statics, nodeType$$7) {
      _super$$19.call(this, nodeType$$7);
      this.name = name$$33;
      this.bod = bod;
      this.isConstructor = isConstructor;
      this.arguments = args$$1;
      this.vars = vars;
      this.scopes = scopes;
      this.statics = statics;
      this.hint = null;
      var v11651 = TypeScript$$4.FncFlags;
      this.fncFlags = v11651.None;
      this.returnTypeAnnotation = null;
      this.variableArgList = false;
      this.jumpRefs = null;
      this.internalNameCache = null;
      this.tmp1Declared = false;
      this.enclosingFnc = null;
      this.freeVariables = [];
      this.unitIndex = -1;
      this.classDecl = null;
      this.boundToProperty = null;
      this.isOverload = false;
      this.innerStaticFuncs = [];
      this.isTargetTypedAsMethod = false;
      this.isInlineCallLiteral = false;
      this.accessorSymbol = null;
      this.leftCurlyCount = 0;
      this.rightCurlyCount = 0;
      this.returnStatementsWithExpressions = [];
      this.scopeType = null;
      this.endingToken = null;
      return;
    }
    __extends(FuncDecl$$1, _super$$19);
    var v11652 = FuncDecl$$1.prototype;
    v11652.isDeclaration = v172;
    var v11653 = FuncDecl$$1.prototype;
    v11653.internalName = v173;
    var v11654 = FuncDecl$$1.prototype;
    v11654.hasSelfReference = v174;
    var v11655 = FuncDecl$$1.prototype;
    v11655.setHasSelfReference = v175;
    var v11656 = FuncDecl$$1.prototype;
    v11656.hasSuperReferenceInFatArrowFunction = v176;
    var v11657 = FuncDecl$$1.prototype;
    v11657.setHasSuperReferenceInFatArrowFunction = v177;
    var v11658 = FuncDecl$$1.prototype;
    v11658.addCloRef = v178;
    var v11659 = FuncDecl$$1.prototype;
    v11659.addJumpRef = v179;
    var v11660 = FuncDecl$$1.prototype;
    v11660.buildControlFlow = v180;
    var v11661 = FuncDecl$$1.prototype;
    v11661.typeCheck = v181;
    var v11662 = FuncDecl$$1.prototype;
    v11662.emit = v182;
    var v11663 = FuncDecl$$1.prototype;
    v11663.getNameText = v183;
    var v11664 = FuncDecl$$1.prototype;
    v11664.isMethod = v184;
    var v11665 = FuncDecl$$1.prototype;
    v11665.isCallMember = v185;
    var v11666 = FuncDecl$$1.prototype;
    v11666.isConstructMember = v186;
    var v11667 = FuncDecl$$1.prototype;
    v11667.isIndexerMember = v187;
    var v11668 = FuncDecl$$1.prototype;
    v11668.isSpecialFn = v188;
    var v11669 = FuncDecl$$1.prototype;
    v11669.isAnonymousFn = v189;
    var v11670 = FuncDecl$$1.prototype;
    v11670.isAccessor = v190;
    var v11671 = FuncDecl$$1.prototype;
    v11671.isGetAccessor = v191;
    var v11672 = FuncDecl$$1.prototype;
    v11672.isSetAccessor = v192;
    var v11673 = FuncDecl$$1.prototype;
    v11673.isAmbient = v193;
    var v11674 = FuncDecl$$1.prototype;
    v11674.isExported = v194;
    var v11675 = FuncDecl$$1.prototype;
    v11675.isPrivate = v195;
    var v11676 = FuncDecl$$1.prototype;
    v11676.isPublic = v196;
    var v11677 = FuncDecl$$1.prototype;
    v11677.isStatic = v197;
    var v11678 = FuncDecl$$1.prototype;
    v11678.treeViewLabel = v198;
    var v11679 = FuncDecl$$1.prototype;
    v11679.ClearFlags = v199;
    var v11680 = FuncDecl$$1.prototype;
    v11680.isSignature = v200;
    return FuncDecl$$1;
  }
  function v171(_super$$18) {
    function v170(emitter$$14, tokenId$$14, startLine$$14) {
      emitter$$14.emitParensAndCommentsInPlace(this, true);
      emitter$$14.recordSourceMappingStart(this);
      var v18550 = this.id;
      var v11681 = v18550.actualText;
      emitter$$14.writeToOutput(v11681);
      emitter$$14.recordSourceMappingEnd(this);
      emitter$$14.emitParensAndCommentsInPlace(this, false);
      return;
    }
    function v169() {
      var v18551 = this.id;
      var v11682 = v18551.actualText;
      return "arg: " + v11682;
    }
    function v168() {
      var v11683 = this.isOptional;
      var v18552 = !v11683;
      if (v18552) {
        v11683 = this.init;
      }
      return v11683;
    }
    function ArgDecl$$1(id$$4) {
      var v18553 = TypeScript$$4.NodeType;
      var v11684 = v18553.ArgDecl;
      _super$$18.call(this, id$$4, v11684, 0);
      this.isOptional = false;
      this.parameterPropertySym = null;
      return;
    }
    __extends(ArgDecl$$1, _super$$18);
    var v11685 = ArgDecl$$1.prototype;
    v11685.isOptionalArg = v168;
    var v11686 = ArgDecl$$1.prototype;
    v11686.treeViewLabel = v169;
    var v11687 = ArgDecl$$1.prototype;
    v11687.emit = v170;
    return ArgDecl$$1;
  }
  function v167(_super$$17) {
    function v166() {
      var v18554 = this.id;
      var v11688 = v18554.actualText;
      return "var " + v11688;
    }
    function v165(emitter$$13, tokenId$$13, startLine$$13) {
      emitter$$13.emitJavascriptVarDecl(this, tokenId$$13);
      return;
    }
    function v164() {
      var v11689 = this.varFlags;
      var v18555 = TypeScript$$4.VarFlags;
      var v11690 = v18555.Static;
      return TypeScript$$4.hasFlag(v11689, v11690);
    }
    function v163() {
      var v11691 = this.varFlags;
      var v18556 = TypeScript$$4.VarFlags;
      var v11692 = v18556.Exported;
      return TypeScript$$4.hasFlag(v11691, v11692);
    }
    function v162() {
      var v11693 = this.varFlags;
      var v18557 = TypeScript$$4.VarFlags;
      var v11694 = v18557.Ambient;
      return TypeScript$$4.hasFlag(v11693, v11694);
    }
    function VarDecl$$1(id$$3, nest) {
      var v18558 = TypeScript$$4.NodeType;
      var v11695 = v18558.VarDecl;
      _super$$17.call(this, id$$3, v11695, nest);
      return;
    }
    __extends(VarDecl$$1, _super$$17);
    var v11696 = VarDecl$$1.prototype;
    v11696.isAmbient = v162;
    var v11697 = VarDecl$$1.prototype;
    v11697.isExported = v163;
    var v11698 = VarDecl$$1.prototype;
    v11698.isStatic = v164;
    var v11699 = VarDecl$$1.prototype;
    v11699.emit = v165;
    var v11700 = VarDecl$$1.prototype;
    v11700.treeViewLabel = v166;
    return VarDecl$$1;
  }
  function v161(_super$$16) {
    function v160() {
      return this.treeViewLabel();
    }
    function v159(typeFlow$$12) {
      return typeFlow$$12.typeCheckBoundDecl(this);
    }
    function v158() {
      var v11701 = this.varFlags;
      var v18559 = TypeScript$$4.VarFlags;
      var v11702 = v18559.Property;
      return TypeScript$$4.hasFlag(v11701, v11702);
    }
    function v157() {
      var v11703 = this.varFlags;
      var v18560 = TypeScript$$4.VarFlags;
      var v11704 = v18560.Public;
      return TypeScript$$4.hasFlag(v11703, v11704);
    }
    function v156() {
      var v11705 = this.varFlags;
      var v18561 = TypeScript$$4.VarFlags;
      var v11706 = v18561.Private;
      return TypeScript$$4.hasFlag(v11705, v11706);
    }
    function v155() {
      return true;
    }
    function v154() {
      return true;
    }
    function BoundDecl$$1(id$$2, nodeType$$6, nestingLevel) {
      _super$$16.call(this, nodeType$$6);
      this.id = id$$2;
      this.nestingLevel = nestingLevel;
      this.init = null;
      this.typeExpr = null;
      var v11707 = TypeScript$$4.VarFlags;
      this.varFlags = v11707.None;
      this.sym = null;
      return;
    }
    __extends(BoundDecl$$1, _super$$16);
    var v11708 = BoundDecl$$1.prototype;
    v11708.isDeclaration = v154;
    var v11709 = BoundDecl$$1.prototype;
    v11709.isStatementOrExpression = v155;
    var v11710 = BoundDecl$$1.prototype;
    v11710.isPrivate = v156;
    var v11711 = BoundDecl$$1.prototype;
    v11711.isPublic = v157;
    var v11712 = BoundDecl$$1.prototype;
    v11712.isProperty = v158;
    var v11713 = BoundDecl$$1.prototype;
    v11713.typeCheck = v159;
    var v11714 = BoundDecl$$1.prototype;
    v11714.printLabel = v160;
    return BoundDecl$$1;
  }
  function v153(_super$$15) {
    function v152() {
      var v22934 = this.alias;
      var v18562 = v22934.nodeType;
      var v22935 = TypeScript$$4.NodeType;
      var v18563 = v22935.Name;
      var v11716 = v18562 == v18563;
      if (v11716) {
        var v11715 = this.alias;
        return v11715.actualText;
      } else {
        var dotExpr$$1 = this.alias;
        var firstMod = dotExpr$$1.operand1;
        return firstMod.actualText;
      }
      return;
    }
    function v151(aliasAST) {
      var v18564 = typeof aliasAST;
      var v11717 = v18564 === "undefined";
      if (v11717) {
        aliasAST = this.alias;
      }
      var v18565 = aliasAST.nodeType;
      var v22936 = TypeScript$$4.NodeType;
      var v18566 = v22936.Name;
      var v11720 = v18565 == v18566;
      if (v11720) {
        return aliasAST.actualText;
      } else {
        var dotExpr = aliasAST;
        var v22937 = dotExpr.operand1;
        var v18567 = this.getAliasName(v22937);
        var v11718 = v18567 + ".";
        var v18568 = dotExpr.operand2;
        var v11719 = this.getAliasName(v18568);
        return v11718 + v11719;
      }
      return;
    }
    function v150(typeFlow$$11) {
      return typeFlow$$11.typeCheckImportDecl(this);
    }
    function v149(emitter$$12, tokenId$$12, startLine$$12) {
      var v11721 = this.alias;
      var mod = v11721.type;
      var v22938 = this.isDynamicImport;
      var v18569 = !v22938;
      var v22940 = !v18569;
      if (v22940) {
        var v25098 = this.id;
        var v22939 = v25098.sym;
        if (v22939) {
          var v26404 = this.id;
          var v26008 = v26404.sym;
          var v25099 = v26008.onlyReferencedAsTypeRef;
          v22939 = !v25099;
        }
        v18569 = v22939;
      }
      var v11728 = v18569;
      if (v11728) {
        var prevModAliasId = emitter$$12.modAliasId;
        var prevFirstModAlias = emitter$$12.firstModAlias;
        emitter$$12.recordSourceMappingStart(this);
        emitter$$12.emitParensAndCommentsInPlace(this, true);
        var v25100 = this.id;
        var v22941 = v25100.actualText;
        var v18570 = "var " + v22941;
        var v11722 = v18570 + " = ";
        emitter$$12.writeToOutput(v11722);
        var v11723 = this.id;
        emitter$$12.modAliasId = v11723.actualText;
        var v11724 = emitter$$12;
        var v27423 = this.firstAliasedModToString();
        v11724.firstModAlias = v27423;
        var v11725 = this.alias;
        var v18571 = TypeScript$$4.TokenID;
        var v11726 = v18571.Tilde;
        emitter$$12.emitJavascript(v11725, v11726, false);
        var v18572 = this.isDynamicImport;
        var v11727 = !v18572;
        if (v11727) {
          emitter$$12.writeToOutput(";");
        }
        emitter$$12.emitParensAndCommentsInPlace(this, false);
        emitter$$12.recordSourceMappingEnd(this);
        emitter$$12.modAliasId = prevModAliasId;
        emitter$$12.firstModAlias = prevFirstModAlias;
      }
      return;
    }
    function v148() {
      return true;
    }
    function v147() {
      return true;
    }
    function ImportDeclaration$$1(id$$1, alias) {
      var v18573 = TypeScript$$4.NodeType;
      var v11729 = v18573.ImportDeclaration;
      _super$$15.call(this, v11729);
      this.id = id$$1;
      this.alias = alias;
      var v11730 = TypeScript$$4.VarFlags;
      this.varFlags = v11730.None;
      this.isDynamicImport = false;
      return;
    }
    __extends(ImportDeclaration$$1, _super$$15);
    var v11731 = ImportDeclaration$$1.prototype;
    v11731.isStatementOrExpression = v147;
    var v11732 = ImportDeclaration$$1.prototype;
    v11732.isDeclaration = v148;
    var v11733 = ImportDeclaration$$1.prototype;
    v11733.emit = v149;
    var v11734 = ImportDeclaration$$1.prototype;
    v11734.typeCheck = v150;
    var v11735 = ImportDeclaration$$1.prototype;
    v11735.getAliasName = v151;
    var v11736 = ImportDeclaration$$1.prototype;
    v11736.firstAliasedModToString = v152;
    return ImportDeclaration$$1;
  }
  function v146(_super$$14) {
    function ModuleElement$$1(nodeType$$5) {
      _super$$14.call(this, nodeType$$5);
      return;
    }
    __extends(ModuleElement$$1, _super$$14);
    return ModuleElement$$1;
  }
  function v145(_super$$13) {
    function v144() {
      return this.text;
    }
    function v143() {
      var v11737 = this.text;
      return "st: " + v11737;
    }
    function v142(typeFlow$$10) {
      this.type = typeFlow$$10.stringType;
      return this;
    }
    function v141(emitter$$11, tokenId$$11, startLine$$11) {
      emitter$$11.emitParensAndCommentsInPlace(this, true);
      emitter$$11.recordSourceMappingStart(this);
      var v11738 = this.text;
      emitter$$11.emitStringLiteral(v11738);
      emitter$$11.recordSourceMappingEnd(this);
      emitter$$11.emitParensAndCommentsInPlace(this, false);
      return;
    }
    function StringLiteral$$1(text$$8) {
      var v18574 = TypeScript$$4.NodeType;
      var v11739 = v18574.QString;
      _super$$13.call(this, v11739);
      this.text = text$$8;
      return;
    }
    __extends(StringLiteral$$1, _super$$13);
    var v11740 = StringLiteral$$1.prototype;
    v11740.emit = v141;
    var v11741 = StringLiteral$$1.prototype;
    v11741.typeCheck = v142;
    var v11742 = StringLiteral$$1.prototype;
    v11742.treeViewLabel = v143;
    var v11743 = StringLiteral$$1.prototype;
    v11743.printLabel = v144;
    return StringLiteral$$1;
  }
  function v140(_super$$12) {
    function v139(emitter$$10, tokenId$$10, startLine$$10) {
      emitter$$10.emitParensAndCommentsInPlace(this, true);
      emitter$$10.recordSourceMappingStart(this);
      var v18575 = this.regex;
      var v11744 = v18575.toString();
      emitter$$10.writeToOutput(v11744);
      emitter$$10.recordSourceMappingEnd(this);
      emitter$$10.emitParensAndCommentsInPlace(this, false);
      return;
    }
    function v138(typeFlow$$9) {
      this.type = typeFlow$$9.regexType;
      return this;
    }
    function RegexLiteral$$1(regex$$1) {
      var v18576 = TypeScript$$4.NodeType;
      var v11745 = v18576.Regex;
      _super$$12.call(this, v11745);
      this.regex = regex$$1;
      return;
    }
    __extends(RegexLiteral$$1, _super$$12);
    var v11746 = RegexLiteral$$1.prototype;
    v11746.typeCheck = v138;
    var v11747 = RegexLiteral$$1.prototype;
    v11747.emit = v139;
    return RegexLiteral$$1;
  }
  function v137(_super$$11) {
    function v136() {
      var v22942 = this.value;
      var v18577 = Math.floor(v22942);
      var v18578 = this.value;
      var v11752 = v18577 != v18578;
      if (v11752) {
        var v18579 = this.value;
        var v11748 = v18579.toFixed(2);
        return v11748.toString();
      } else {
        var v11751 = this.hasEmptyFraction;
        if (v11751) {
          var v18580 = this.value;
          var v11749 = v18580.toString();
          return v11749 + ".0";
        } else {
          var v11750 = this.value;
          return v11750.toString();
        }
      }
      return;
    }
    function v135(emitter$$9, tokenId$$9, startLine$$9) {
      emitter$$9.emitParensAndCommentsInPlace(this, true);
      emitter$$9.recordSourceMappingStart(this);
      var v11753 = this.isNegativeZero;
      if (v11753) {
        emitter$$9.writeToOutput("-");
      }
      var v18581 = this.value;
      var v11754 = v18581.toString();
      emitter$$9.writeToOutput(v11754);
      var v11755 = this.hasEmptyFraction;
      if (v11755) {
        emitter$$9.writeToOutput(".0");
      }
      emitter$$9.recordSourceMappingEnd(this);
      emitter$$9.emitParensAndCommentsInPlace(this, false);
      return;
    }
    function v134() {
      var v11756 = this.printLabel();
      return "num: " + v11756;
    }
    function v133(typeFlow$$8) {
      this.type = typeFlow$$8.doubleType;
      return this;
    }
    function NumberLiteral$$1(value$$28, hasEmptyFraction) {
      var v18582 = TypeScript$$4.NodeType;
      var v11757 = v18582.NumberLit;
      _super$$11.call(this, v11757);
      this.value = value$$28;
      this.hasEmptyFraction = hasEmptyFraction;
      this.isNegativeZero = false;
      return;
    }
    __extends(NumberLiteral$$1, _super$$11);
    var v11758 = NumberLiteral$$1.prototype;
    v11758.typeCheck = v133;
    var v11759 = NumberLiteral$$1.prototype;
    v11759.treeViewLabel = v134;
    var v11760 = NumberLiteral$$1.prototype;
    v11760.emit = v135;
    var v11761 = NumberLiteral$$1.prototype;
    v11761.printLabel = v136;
    return NumberLiteral$$1;
  }
  function v132(_super$$10) {
    function v131(emitter$$8, tokenId$$8, startLine$$8) {
      emitter$$8.emitParensAndCommentsInPlace(this, true);
      emitter$$8.recordSourceMappingStart(this);
      var v11762 = this.operand1;
      var v18583 = TypeScript$$4.TokenID;
      var v11763 = v18583.Question;
      emitter$$8.emitJavascript(v11762, v11763, false);
      emitter$$8.writeToOutput(" ? ");
      var v11764 = this.operand2;
      var v18584 = TypeScript$$4.TokenID;
      var v11765 = v18584.Question;
      emitter$$8.emitJavascript(v11764, v11765, false);
      emitter$$8.writeToOutput(" : ");
      var v11766 = this.operand3;
      var v18585 = TypeScript$$4.TokenID;
      var v11767 = v18585.Question;
      emitter$$8.emitJavascript(v11766, v11767, false);
      emitter$$8.recordSourceMappingEnd(this);
      emitter$$8.emitParensAndCommentsInPlace(this, false);
      return;
    }
    function v130(typeFlow$$7) {
      return typeFlow$$7.typeCheckQMark(this);
    }
    function ConditionalExpression$$1(operand1$$1, operand2$$1, operand3) {
      var v18586 = TypeScript$$4.NodeType;
      var v11768 = v18586.ConditionalExpression;
      _super$$10.call(this, v11768);
      this.operand1 = operand1$$1;
      this.operand2 = operand2$$1;
      this.operand3 = operand3;
      return;
    }
    __extends(ConditionalExpression$$1, _super$$10);
    var v11769 = ConditionalExpression$$1.prototype;
    v11769.typeCheck = v130;
    var v11770 = ConditionalExpression$$1.prototype;
    v11770.emit = v131;
    return ConditionalExpression$$1;
  }
  function v129(_super$$9) {
    function v128(emitter$$7, tokenId$$7, startLine$$7) {
      var v11771 = TypeScript$$4.nodeTypeToTokTable;
      var v11772 = this.nodeType;
      var binTokenId = v11771[v11772];
      emitter$$7.emitParensAndCommentsInPlace(this, true);
      emitter$$7.recordSourceMappingStart(this);
      var v11798 = binTokenId != undefined;
      if (v11798) {
        var v11773 = this.operand1;
        emitter$$7.emitJavascript(v11773, binTokenId, false);
        var v25101 = TypeScript$$4.tokenTable;
        var v22943 = v25101[binTokenId];
        var v18587 = v22943.text;
        var v11776 = v18587 == "instanceof";
        if (v11776) {
          emitter$$7.writeToOutput(" instanceof ");
        } else {
          var v25102 = TypeScript$$4.tokenTable;
          var v22944 = v25102[binTokenId];
          var v18588 = v22944.text;
          var v11775 = v18588 == "in";
          if (v11775) {
            emitter$$7.writeToOutput(" in ");
          } else {
            var v26009 = TypeScript$$4.tokenTable;
            var v25103 = v26009[binTokenId];
            var v22945 = v25103.text;
            var v18589 = " " + v22945;
            var v11774 = v18589 + " ";
            emitter$$7.writeToOutputTrimmable(v11774);
          }
        }
        var v11777 = this.operand2;
        emitter$$7.emitJavascript(v11777, binTokenId, false);
      } else {
        var v11797 = this.nodeType;
        switch(v11797) {
          case TypeScript$$4.NodeType.Dot:
            var v18590 = emitter$$7.tryEmitConstant(this);
            var v11781 = !v18590;
            if (v11781) {
              var v11778 = this.operand1;
              var v18591 = TypeScript$$4.TokenID;
              var v11779 = v18591.Dot;
              emitter$$7.emitJavascript(v11778, v11779, false);
              emitter$$7.writeToOutput(".");
              var v11780 = this.operand2;
              emitter$$7.emitJavascriptName(v11780, false);
            }
            break;
          case TypeScript$$4.NodeType.Index:
            var v11782 = this.operand1;
            var v11783 = this.operand2;
            emitter$$7.emitIndex(v11782, v11783);
            break;
          case TypeScript$$4.NodeType.Member:
            var v25104 = this.operand2;
            var v22946 = v25104.nodeType;
            var v25105 = TypeScript$$4.NodeType;
            var v22947 = v25105.FuncDecl;
            var v18592 = v22946 == v22947;
            if (v18592) {
              var v22948 = this.operand2;
              v18592 = v22948.isAccessor();
            }
            var v11789 = v18592;
            if (v11789) {
              var funcDecl = this.operand2;
              var v18593 = funcDecl.fncFlags;
              var v22949 = TypeScript$$4.FncFlags;
              var v18594 = v22949.GetAccessor;
              var v11784 = TypeScript$$4.hasFlag(v18593, v18594);
              if (v11784) {
                emitter$$7.writeToOutput("get ");
              } else {
                emitter$$7.writeToOutput("set ");
              }
              var v11785 = this.operand1;
              var v18595 = TypeScript$$4.TokenID;
              var v11786 = v18595.Colon;
              emitter$$7.emitJavascript(v11785, v11786, false);
            } else {
              var v11787 = this.operand1;
              var v18596 = TypeScript$$4.TokenID;
              var v11788 = v18596.Colon;
              emitter$$7.emitJavascript(v11787, v11788, false);
              emitter$$7.writeToOutputTrimmable(": ");
            }
            var v11790 = this.operand2;
            var v18597 = TypeScript$$4.TokenID;
            var v11791 = v18597.Comma;
            emitter$$7.emitJavascript(v11790, v11791, false);
            break;
          case TypeScript$$4.NodeType.Comma:
            var v11792 = this.operand1;
            var v18598 = TypeScript$$4.TokenID;
            var v11793 = v18598.Comma;
            emitter$$7.emitJavascript(v11792, v11793, false);
            var v18599 = emitter$$7.emitState;
            var v11794 = v18599.inObjectLiteral;
            if (v11794) {
              emitter$$7.writeLineToOutput(", ");
            } else {
              emitter$$7.writeToOutput(",");
            }
            var v11795 = this.operand2;
            var v18600 = TypeScript$$4.TokenID;
            var v11796 = v18600.Comma;
            emitter$$7.emitJavascript(v11795, v11796, false);
            break;
          case TypeScript$$4.NodeType.Is:
            throw new Error("should be de-sugared during type check");;
          default:
            throw new Error("please implement in derived class");;
        }
      }
      emitter$$7.recordSourceMappingEnd(this);
      emitter$$7.emitParensAndCommentsInPlace(this, false);
      return;
    }
    function v127(typeFlow$$6) {
      var v11811 = this.nodeType;
      switch(v11811) {
        case TypeScript$$4.NodeType.Dot:
          return typeFlow$$6.typeCheckDotOperator(this);
        case TypeScript$$4.NodeType.Asg:
          return typeFlow$$6.typeCheckAsgOperator(this);
        case TypeScript$$4.NodeType.Add:
        ;
        case TypeScript$$4.NodeType.Sub:
        ;
        case TypeScript$$4.NodeType.Mul:
        ;
        case TypeScript$$4.NodeType.Div:
        ;
        case TypeScript$$4.NodeType.Mod:
        ;
        case TypeScript$$4.NodeType.Or:
        ;
        case TypeScript$$4.NodeType.And:
          return typeFlow$$6.typeCheckArithmeticOperator(this, false);
        case TypeScript$$4.NodeType.Xor:
          return typeFlow$$6.typeCheckBitwiseOperator(this, false);
        case TypeScript$$4.NodeType.Ne:
        ;
        case TypeScript$$4.NodeType.Eq:
          var text$$7;
          var v22950 = typeFlow$$6.checker;
          var v18601 = v22950.styleSettings;
          var v11809 = v18601.eqeqeq;
          if (v11809) {
            var v11799 = TypeScript$$4.nodeTypeTable;
            var v11800 = this.nodeType;
            text$$7 = v11799[v11800];
            var v18602 = typeFlow$$6.checker;
            var v11801 = v18602.errorReporter;
            var v11802 = "use of " + text$$7;
            v11801.styleError(this, v11802);
          } else {
            var v22951 = typeFlow$$6.checker;
            var v18603 = v22951.styleSettings;
            var v11808 = v18603.eqnull;
            if (v11808) {
              var v11803 = TypeScript$$4.nodeTypeTable;
              var v11804 = this.nodeType;
              text$$7 = v11803[v11804];
              var v22952 = this.operand2;
              var v18604 = v22952 !== null;
              if (v18604) {
                var v25106 = this.operand2;
                var v22953 = v25106.nodeType;
                var v25107 = TypeScript$$4.NodeType;
                var v22954 = v25107.Null;
                v18604 = v22953 == v22954;
              }
              var v11807 = v18604;
              if (v11807) {
                var v18605 = typeFlow$$6.checker;
                var v11805 = v18605.errorReporter;
                var v18606 = "use of " + text$$7;
                var v11806 = v18606 + " to compare with null";
                v11805.styleError(this, v11806);
              }
            }
          }
        ;
        case TypeScript$$4.NodeType.Eqv:
        ;
        case TypeScript$$4.NodeType.NEqv:
        ;
        case TypeScript$$4.NodeType.Lt:
        ;
        case TypeScript$$4.NodeType.Le:
        ;
        case TypeScript$$4.NodeType.Ge:
        ;
        case TypeScript$$4.NodeType.Gt:
          return typeFlow$$6.typeCheckBooleanOperator(this);
        case TypeScript$$4.NodeType.Index:
          return typeFlow$$6.typeCheckIndex(this);
        case TypeScript$$4.NodeType.Member:
          this.type = typeFlow$$6.voidType;
          return this;
        case TypeScript$$4.NodeType.LogOr:
          return typeFlow$$6.typeCheckLogOr(this);
        case TypeScript$$4.NodeType.LogAnd:
          return typeFlow$$6.typeCheckLogAnd(this);
        case TypeScript$$4.NodeType.AsgAdd:
        ;
        case TypeScript$$4.NodeType.AsgSub:
        ;
        case TypeScript$$4.NodeType.AsgMul:
        ;
        case TypeScript$$4.NodeType.AsgDiv:
        ;
        case TypeScript$$4.NodeType.AsgMod:
        ;
        case TypeScript$$4.NodeType.AsgOr:
        ;
        case TypeScript$$4.NodeType.AsgAnd:
          return typeFlow$$6.typeCheckArithmeticOperator(this, true);
        case TypeScript$$4.NodeType.AsgXor:
          return typeFlow$$6.typeCheckBitwiseOperator(this, true);
        case TypeScript$$4.NodeType.Lsh:
        ;
        case TypeScript$$4.NodeType.Rsh:
        ;
        case TypeScript$$4.NodeType.Rs2:
          return typeFlow$$6.typeCheckShift(this, false);
        case TypeScript$$4.NodeType.AsgLsh:
        ;
        case TypeScript$$4.NodeType.AsgRsh:
        ;
        case TypeScript$$4.NodeType.AsgRs2:
          return typeFlow$$6.typeCheckShift(this, true);
        case TypeScript$$4.NodeType.Comma:
          return typeFlow$$6.typeCheckCommaOperator(this);
        case TypeScript$$4.NodeType.InstOf:
          return typeFlow$$6.typeCheckInstOf(this);
        case TypeScript$$4.NodeType.In:
          return typeFlow$$6.typeCheckInOperator(this);
        case TypeScript$$4.NodeType.From:
          var v18607 = typeFlow$$6.checker;
          var v11810 = v18607.errorReporter;
          v11810.simpleError(this, "Illegal use of 'from' keyword in binary expression");
          break;
        default:
          throw new Error("please implement in derived class");;
      }
      return this;
    }
    function BinaryExpression$$1(nodeType$$4, operand1, operand2) {
      _super$$9.call(this, nodeType$$4);
      this.operand1 = operand1;
      this.operand2 = operand2;
      return;
    }
    __extends(BinaryExpression$$1, _super$$9);
    var v11812 = BinaryExpression$$1.prototype;
    v11812.typeCheck = v127;
    var v11813 = BinaryExpression$$1.prototype;
    v11813.emit = v128;
    return BinaryExpression$$1;
  }
  function v126(_super$$8) {
    function v125(emitter$$6, tokenId$$6, startLine$$6) {
      emitter$$6.emitParensAndCommentsInPlace(this, true);
      emitter$$6.recordSourceMappingStart(this);
      var v18608 = this.nodeType;
      var v22955 = TypeScript$$4.NodeType;
      var v18609 = v22955.New;
      var v11818 = v18608 == v18609;
      if (v11818) {
        var v11814 = this.target;
        var v11815 = this.arguments;
        emitter$$6.emitNew(v11814, v11815);
      } else {
        var v11816 = this.target;
        var v11817 = this.arguments;
        emitter$$6.emitCall(this, v11816, v11817);
      }
      emitter$$6.recordSourceMappingEnd(this);
      emitter$$6.emitParensAndCommentsInPlace(this, false);
      return;
    }
    function v124(typeFlow$$5) {
      var v18610 = this.nodeType;
      var v22956 = TypeScript$$4.NodeType;
      var v18611 = v22956.New;
      var v11819 = v18610 == v18611;
      if (v11819) {
        return typeFlow$$5.typeCheckNew(this);
      } else {
        return typeFlow$$5.typeCheckCall(this);
      }
      return;
    }
    function CallExpression$$1(nodeType$$3, target$$26, args) {
      _super$$8.call(this, nodeType$$3);
      this.target = target$$26;
      this.arguments = args;
      this.signature = null;
      var v11820 = this.target;
      this.minChar = v11820.minChar;
      return;
    }
    __extends(CallExpression$$1, _super$$8);
    var v11821 = CallExpression$$1.prototype;
    v11821.typeCheck = v124;
    var v11822 = CallExpression$$1.prototype;
    v11822.emit = v125;
    return CallExpression$$1;
  }
  function v123(_super$$7) {
    function v122(emitter$$5, tokenId$$5, startLine$$5) {
      emitter$$5.emitParensAndCommentsInPlace(this, true);
      emitter$$5.recordSourceMappingStart(this);
      var v11855 = this.nodeType;
      switch(v11855) {
        case TypeScript$$4.NodeType.IncPost:
          var v11823 = this.operand;
          var v18612 = TypeScript$$4.TokenID;
          var v11824 = v18612.PlusPlus;
          emitter$$5.emitJavascript(v11823, v11824, false);
          emitter$$5.writeToOutput("++");
          break;
        case TypeScript$$4.NodeType.LogNot:
          emitter$$5.writeToOutput("!");
          var v11825 = this.operand;
          var v18613 = TypeScript$$4.TokenID;
          var v11826 = v18613.Exclamation;
          emitter$$5.emitJavascript(v11825, v11826, false);
          break;
        case TypeScript$$4.NodeType.DecPost:
          var v11827 = this.operand;
          var v18614 = TypeScript$$4.TokenID;
          var v11828 = v18614.MinusMinus;
          emitter$$5.emitJavascript(v11827, v11828, false);
          emitter$$5.writeToOutput("--");
          break;
        case TypeScript$$4.NodeType.ObjectLit:
          var v11829 = this.operand;
          emitter$$5.emitObjectLiteral(v11829);
          break;
        case TypeScript$$4.NodeType.ArrayLit:
          var v11830 = this.operand;
          emitter$$5.emitArrayLiteral(v11830);
          break;
        case TypeScript$$4.NodeType.Not:
          emitter$$5.writeToOutput("~");
          var v11831 = this.operand;
          var v18615 = TypeScript$$4.TokenID;
          var v11832 = v18615.Tilde;
          emitter$$5.emitJavascript(v11831, v11832, false);
          break;
        case TypeScript$$4.NodeType.Neg:
          emitter$$5.writeToOutput("-");
          var v22957 = this.operand;
          var v18616 = v22957.nodeType;
          var v22958 = TypeScript$$4.NodeType;
          var v18617 = v22958.Neg;
          var v11834 = v18616 == v18617;
          if (v11834) {
            var v11833 = this.operand;
            v11833.isParenthesized = true;
          }
          var v11835 = this.operand;
          var v18618 = TypeScript$$4.TokenID;
          var v11836 = v18618.Minus;
          emitter$$5.emitJavascript(v11835, v11836, false);
          break;
        case TypeScript$$4.NodeType.Pos:
          emitter$$5.writeToOutput("+");
          var v22959 = this.operand;
          var v18619 = v22959.nodeType;
          var v22960 = TypeScript$$4.NodeType;
          var v18620 = v22960.Pos;
          var v11838 = v18619 == v18620;
          if (v11838) {
            var v11837 = this.operand;
            v11837.isParenthesized = true;
          }
          var v11839 = this.operand;
          var v18621 = TypeScript$$4.TokenID;
          var v11840 = v18621.Plus;
          emitter$$5.emitJavascript(v11839, v11840, false);
          break;
        case TypeScript$$4.NodeType.IncPre:
          emitter$$5.writeToOutput("++");
          var v11841 = this.operand;
          var v18622 = TypeScript$$4.TokenID;
          var v11842 = v18622.PlusPlus;
          emitter$$5.emitJavascript(v11841, v11842, false);
          break;
        case TypeScript$$4.NodeType.DecPre:
          emitter$$5.writeToOutput("--");
          var v11843 = this.operand;
          var v18623 = TypeScript$$4.TokenID;
          var v11844 = v18623.MinusMinus;
          emitter$$5.emitJavascript(v11843, v11844, false);
          break;
        case TypeScript$$4.NodeType.Throw:
          emitter$$5.writeToOutput("throw ");
          var v11845 = this.operand;
          var v18624 = TypeScript$$4.TokenID;
          var v11846 = v18624.Tilde;
          emitter$$5.emitJavascript(v11845, v11846, false);
          emitter$$5.writeToOutput(";");
          break;
        case TypeScript$$4.NodeType.Typeof:
          emitter$$5.writeToOutput("typeof ");
          var v11847 = this.operand;
          var v18625 = TypeScript$$4.TokenID;
          var v11848 = v18625.Tilde;
          emitter$$5.emitJavascript(v11847, v11848, false);
          break;
        case TypeScript$$4.NodeType.Delete:
          emitter$$5.writeToOutput("delete ");
          var v11849 = this.operand;
          var v18626 = TypeScript$$4.TokenID;
          var v11850 = v18626.Tilde;
          emitter$$5.emitJavascript(v11849, v11850, false);
          break;
        case TypeScript$$4.NodeType.Void:
          emitter$$5.writeToOutput("void ");
          var v11851 = this.operand;
          var v18627 = TypeScript$$4.TokenID;
          var v11852 = v18627.Tilde;
          emitter$$5.emitJavascript(v11851, v11852, false);
          break;
        case TypeScript$$4.NodeType.TypeAssertion:
          var v11853 = this.operand;
          var v18628 = TypeScript$$4.TokenID;
          var v11854 = v18628.Tilde;
          emitter$$5.emitJavascript(v11853, v11854, false);
          break;
        default:
          throw new Error("please implement in derived class");;
      }
      emitter$$5.recordSourceMappingEnd(this);
      emitter$$5.emitParensAndCommentsInPlace(this, false);
      return;
    }
    function v121(typeFlow$$4) {
      var v11870 = this.nodeType;
      switch(v11870) {
        case TypeScript$$4.NodeType.Not:
          return typeFlow$$4.typeCheckBitNot(this);
        case TypeScript$$4.NodeType.LogNot:
          return typeFlow$$4.typeCheckLogNot(this);
        case TypeScript$$4.NodeType.Pos:
        ;
        case TypeScript$$4.NodeType.Neg:
          return typeFlow$$4.typeCheckUnaryNumberOperator(this);
        case TypeScript$$4.NodeType.IncPost:
        ;
        case TypeScript$$4.NodeType.IncPre:
        ;
        case TypeScript$$4.NodeType.DecPost:
        ;
        case TypeScript$$4.NodeType.DecPre:
          return typeFlow$$4.typeCheckIncOrDec(this);
        case TypeScript$$4.NodeType.ArrayLit:
          typeFlow$$4.typeCheckArrayLit(this);
          return this;
        case TypeScript$$4.NodeType.ObjectLit:
          typeFlow$$4.typeCheckObjectLit(this);
          return this;
        case TypeScript$$4.NodeType.Throw:
          var v11856 = this.operand;
          var v27424 = typeFlow$$4.typeCheck(v11856);
          this.operand = v27424;
          this.type = typeFlow$$4.voidType;
          return this;
        case TypeScript$$4.NodeType.Typeof:
          var v11857 = this.operand;
          var v27425 = typeFlow$$4.typeCheck(v11857);
          this.operand = v27425;
          this.type = typeFlow$$4.stringType;
          return this;
        case TypeScript$$4.NodeType.Delete:
          var v11858 = this.operand;
          var v27426 = typeFlow$$4.typeCheck(v11858);
          this.operand = v27426;
          this.type = typeFlow$$4.booleanType;
          break;
        case TypeScript$$4.NodeType.TypeAssertion:
          var v11859 = this.castTerm;
          var v27427 = typeFlow$$4.typeCheck(v11859);
          this.castTerm = v27427;
          var v18629 = this.operand;
          var v11860 = v18629.isParenthesized;
          var applyTargetType = !v11860;
          var v11861;
          if (applyTargetType) {
            var v18630 = this.castTerm;
            v11861 = v18630.type;
          } else {
            v11861 = null;
          }
          var targetType = v11861;
          var v11862 = typeFlow$$4.checker;
          var v18631 = typeFlow$$4.checker;
          var v11863 = v18631.inProvisionalTypecheckMode();
          var v11864 = this.operand;
          v11862.typeCheckWithContextualType(targetType, v11863, true, v11864);
          var v11865 = this.operand;
          var v18632 = this.castTerm;
          var v11866 = v18632.type;
          typeFlow$$4.castWithCoercion(v11865, v11866, false, true);
          var v11867 = this.castTerm;
          this.type = v11867.type;
          return this;
        case TypeScript$$4.NodeType.Void:
          var v11868 = this.operand;
          var v27428 = typeFlow$$4.typeCheck(v11868);
          this.operand = v27428;
          var v11869 = typeFlow$$4.checker;
          this.type = v11869.undefinedType;
          break;
        default:
          throw new Error("please implement in derived class");;
      }
      return this;
    }
    function v120(context$$9) {
      var v18633 = _super$$7.prototype;
      var v11871 = v18633.addToControlFlow;
      v11871.call(this, context$$9);
      var v18634 = this.nodeType;
      var v22961 = TypeScript$$4.NodeType;
      var v18635 = v22961.Throw;
      var v11872 = v18634 == v18635;
      if (v11872) {
        context$$9.returnStmt();
      }
      return;
    }
    function UnaryExpression$$1(nodeType$$2, operand) {
      _super$$7.call(this, nodeType$$2);
      this.operand = operand;
      this.targetType = null;
      this.castTerm = null;
      return;
    }
    __extends(UnaryExpression$$1, _super$$7);
    var v11873 = UnaryExpression$$1.prototype;
    v11873.addToControlFlow = v120;
    var v11874 = UnaryExpression$$1.prototype;
    v11874.typeCheck = v121;
    var v11875 = UnaryExpression$$1.prototype;
    v11875.emit = v122;
    return UnaryExpression$$1;
  }
  function v119(_super$$6) {
    function v118() {
      return true;
    }
    function v117() {
      return true;
    }
    function Expression$$1(nodeType$$1) {
      _super$$6.call(this, nodeType$$1);
      return;
    }
    __extends(Expression$$1, _super$$6);
    var v11876 = Expression$$1.prototype;
    v11876.isExpression = v117;
    var v11877 = Expression$$1.prototype;
    v11877.isStatementOrExpression = v118;
    return Expression$$1;
  }
  function v116(_super$$5) {
    function v115(emitter$$4, tokenId$$4, startLine$$4) {
      emitter$$4.emitParensAndCommentsInPlace(this, true);
      emitter$$4.recordSourceMappingStart(this);
      var v11878 = this.id;
      emitter$$4.recordSourceMappingStart(v11878);
      var v18636 = this.id;
      var v11879 = v18636.actualText;
      emitter$$4.writeToOutput(v11879);
      var v11880 = this.id;
      emitter$$4.recordSourceMappingEnd(v11880);
      emitter$$4.writeLineToOutput(":");
      emitter$$4.recordSourceMappingEnd(this);
      emitter$$4.emitParensAndCommentsInPlace(this, false);
      return;
    }
    function v114(typeFlow$$3) {
      this.type = typeFlow$$3.voidType;
      return this;
    }
    function v113() {
      var v18637 = this.id;
      var v11881 = v18637.actualText;
      return v11881 + ":";
    }
    function Label$$1(id) {
      var v18638 = TypeScript$$4.NodeType;
      var v11882 = v18638.Label;
      _super$$5.call(this, v11882);
      this.id = id;
      return;
    }
    __extends(Label$$1, _super$$5);
    var v11883 = Label$$1.prototype;
    v11883.printLabel = v113;
    var v11884 = Label$$1.prototype;
    v11884.typeCheck = v114;
    var v11885 = Label$$1.prototype;
    v11885.emit = v115;
    return Label$$1;
  }
  function v112(_super$$4) {
    function v111(emitter$$3, tokenId$$3, startLine$$3) {
      return;
    }
    function v110() {
      return true;
    }
    function MissingIdentifier$$1() {
      _super$$4.call(this, "__missing");
      return;
    }
    __extends(MissingIdentifier$$1, _super$$4);
    var v11886 = MissingIdentifier$$1.prototype;
    v11886.isMissing = v110;
    var v11887 = MissingIdentifier$$1.prototype;
    v11887.emit = v111;
    return MissingIdentifier$$1;
  }
  function v109(_super$$3) {
    function fromToken(token$$4) {
      var v11888 = token$$4.getText();
      var v11889 = token$$4.hasEscapeSequence;
      return new Identifier$$1(v11888, v11889);
    }
    function v108(emitter$$2, tokenId$$2, startLine$$2) {
      emitter$$2.emitJavascriptName(this, true);
      return;
    }
    function v107(typeFlow$$2) {
      return typeFlow$$2.typeCheckName(this);
    }
    function v106() {
      var v11891 = this.actualText;
      if (v11891) {
        var v11890 = this.actualText;
        return "id: " + v11890;
      } else {
        return "name node";
      }
      return;
    }
    function v105() {
      var v11892 = this.actualText;
      return "id: " + v11892;
    }
    function v104() {
      return true;
    }
    function v103() {
      return false;
    }
    function v102(actualText$$1, hasEscapeSequence$$1) {
      this.actualText = actualText$$1;
      if (hasEscapeSequence$$1) {
        var v27429 = AST.getResolvedIdentifierName(actualText$$1);
        this.text = v27429;
      } else {
        this.text = actualText$$1;
      }
      return;
    }
    function Identifier$$1(actualText, hasEscapeSequence) {
      var v18639 = TypeScript$$4.NodeType;
      var v11893 = v18639.Name;
      _super$$3.call(this, v11893);
      this.actualText = actualText;
      this.hasEscapeSequence = hasEscapeSequence;
      this.sym = null;
      this.cloId = -1;
      this.setText(actualText, hasEscapeSequence);
      return;
    }
    __extends(Identifier$$1, _super$$3);
    var v11894 = Identifier$$1.prototype;
    v11894.setText = v102;
    var v11895 = Identifier$$1.prototype;
    v11895.isMissing = v103;
    var v11896 = Identifier$$1.prototype;
    v11896.isLeaf = v104;
    var v11897 = Identifier$$1.prototype;
    v11897.treeViewLabel = v105;
    var v11898 = Identifier$$1.prototype;
    v11898.printLabel = v106;
    var v11899 = Identifier$$1.prototype;
    v11899.typeCheck = v107;
    var v11900 = Identifier$$1.prototype;
    v11900.emit = v108;
    Identifier$$1.fromToken = fromToken;
    return Identifier$$1;
  }
  function v101(_super$$2) {
    function v100(typeFlow$$1) {
      var v11901 = this.members;
      var len$$3 = v11901.length;
      var v18640 = typeFlow$$1.nestingLevel;
      typeFlow$$1.nestingLevel = v18640 + 1;
      var i$$15 = 0;
      var v11905 = i$$15 < len$$3;
      for (;v11905;) {
        var v18641 = this.members;
        var v11904 = v18641[i$$15];
        if (v11904) {
          var v11902 = this.members;
          var v11903 = i$$15;
          var v22962 = this.members;
          var v18642 = v22962[i$$15];
          var v27430 = v18642.typeCheck(typeFlow$$1);
          v11902[v11903] = v27430;
        }
        i$$15 = i$$15 + 1;
        v11905 = i$$15 < len$$3;
      }
      var v18643 = typeFlow$$1.nestingLevel;
      typeFlow$$1.nestingLevel = v18643 - 1;
      return this;
    }
    function v99(emitter$$1, tokenId$$1, startLine$$1) {
      emitter$$1.recordSourceMappingStart(this);
      var v18644 = TypeScript$$4.TokenID;
      var v11906 = v18644.Semicolon;
      emitter$$1.emitJavascriptList(this, null, v11906, startLine$$1, false, false);
      emitter$$1.recordSourceMappingEnd(this);
      return;
    }
    function v98(ast$$1) {
      var v18645 = ast$$1.nodeType;
      var v22963 = TypeScript$$4.NodeType;
      var v18646 = v22963.List;
      var v11910 = v18645 == v18646;
      if (v11910) {
        var list = ast$$1;
        var i$$14 = 0;
        var v11907 = list.members;
        var len$$2 = v11907.length;
        var v11909 = i$$14 < len$$2;
        for (;v11909;) {
          var v18647 = list.members;
          var v11908 = v18647[i$$14];
          this.append(v11908);
          i$$14 = i$$14 + 1;
          v11909 = i$$14 < len$$2;
        }
      } else {
        this.append(ast$$1);
      }
      return this;
    }
    function v97(ast) {
      var v11911 = this.members;
      var v18648 = this.members;
      var v11912 = v18648.length;
      v11911[v11912] = ast;
      return this;
    }
    function v96(context$$8) {
      var v11913 = this.members;
      var len$$1 = v11913.length;
      var i$$13 = 0;
      var v11918 = i$$13 < len$$1;
      for (;v11918;) {
        var v11917 = context$$8.noContinuation;
        if (v11917) {
          var v18649 = this.members;
          var v11914 = v18649[i$$13];
          context$$8.addUnreachable(v11914);
          break;
        } else {
          var v11915 = this.members;
          var v11916 = i$$13;
          var v22964 = this.members;
          var v18650 = v22964[i$$13];
          var v27431 = context$$8.walk(v18650, this);
          v11915[v11916] = v27431;
        }
        i$$13 = i$$13 + 1;
        v11918 = i$$13 < len$$1;
      }
      var v18651 = context$$8.walker;
      var v11919 = v18651.options;
      v11919.goChildren = false;
      return;
    }
    function ASTList$$1() {
      var v18652 = TypeScript$$4.NodeType;
      var v11920 = v18652.List;
      _super$$2.call(this, v11920);
      this.enclosingScope = null;
      var v27432 = new Array;
      this.members = v27432;
      return;
    }
    __extends(ASTList$$1, _super$$2);
    var v11921 = ASTList$$1.prototype;
    v11921.addToControlFlow = v96;
    var v11922 = ASTList$$1.prototype;
    v11922.append = v97;
    var v11923 = ASTList$$1.prototype;
    v11923.appendAll = v98;
    var v11924 = ASTList$$1.prototype;
    v11924.emit = v99;
    var v11925 = ASTList$$1.prototype;
    v11925.typeCheck = v100;
    return ASTList$$1;
  }
  function v95(_super$$1) {
    function IncompleteAST$$1(min, lim) {
      var v18653 = TypeScript$$4.NodeType;
      var v11926 = v18653.Error;
      _super$$1.call(this, v11926);
      this.minChar = min;
      this.limChar = lim;
      return;
    }
    __extends(IncompleteAST$$1, _super$$1);
    return IncompleteAST$$1;
  }
  function v94(_super) {
    function v93() {
      var v25108 = this.isDeclaration();
      var v22965 = !v25108;
      var v25110 = !v22965;
      if (v25110) {
        var v25109 = this.preComments;
        v22965 = !v25109;
      }
      var v18654 = v22965;
      var v22967 = !v18654;
      if (v22967) {
        var v25111 = this.preComments;
        var v22966 = v25111.length;
        v18654 = v22966 == 0;
      }
      var v11927 = v18654;
      if (v11927) {
        return[];
      }
      var v18655 = this.docComments;
      var v11934 = !v18655;
      if (v11934) {
        var v11928 = this.preComments;
        var preCommentsLength = v11928.length;
        var docComments = [];
        var i$$12 = preCommentsLength - 1;
        var v11933 = i$$12 >= 0;
        for (;v11933;) {
          var v22968 = this.preComments;
          var v18656 = v22968[i$$12];
          var v11932 = v18656.isDocComment();
          if (v11932) {
            var v11929;
            var v22969 = docComments.length;
            var v18658 = v22969 > 0;
            if (v18658) {
              var v22970 = docComments.length;
              var v18657 = v22970 - 1;
              v11929 = docComments[v18657];
            } else {
              v11929 = null;
            }
            var prevDocComment = v11929;
            var v18659 = prevDocComment == null;
            var v22972 = !v18659;
            if (v22972) {
              var v26405 = this.preComments;
              var v26010 = v26405[i$$12];
              var v25112 = v26010.limLine;
              var v25113 = prevDocComment.minLine;
              var v22971 = v25112 == v25113;
              var v25116 = !v22971;
              if (v25116) {
                var v26586 = this.preComments;
                var v26406 = v26586[i$$12];
                var v26011 = v26406.limLine;
                var v25114 = v26011 + 1;
                var v25115 = prevDocComment.minLine;
                v22971 = v25114 == v25115;
              }
              v18659 = v22971;
            }
            var v11931 = v18659;
            if (v11931) {
              var v18660 = this.preComments;
              var v11930 = v18660[i$$12];
              docComments.push(v11930);
              i$$12 = i$$12 - 1;
              v11933 = i$$12 >= 0;
              continue;
            }
          }
          break;
        }
        var v27433 = docComments.reverse();
        this.docComments = v27433;
      }
      return this.docComments;
    }
    function getResolvedIdentifierName(name$$32) {
      var v11935 = !name$$32;
      if (v11935) {
        return "";
      }
      var resolved = "";
      var start$$6 = 0;
      var i$$11 = 0;
      var v22973 = name$$32.length;
      var v18661 = v22973 - 6;
      var v11938 = i$$11 <= v18661;
      for (;v11938;) {
        var v22974 = name$$32.charAt(i$$11);
        var v18662 = v22974 == "\\";
        if (v18662) {
          var v25117 = i$$11 + 1;
          var v22975 = name$$32.charAt(v25117);
          v18662 = v22975 == "u";
        }
        var v11937 = v18662;
        if (v11937) {
          var v18663 = i$$11 + 2;
          var v11936 = name$$32.substr(v18663, 4);
          var charCode = parseInt(v11936, 16);
          var v18664 = resolved;
          var v22976 = i$$11 - start$$6;
          var v18665 = name$$32.substr(start$$6, v22976);
          resolved = v18664 + v18665;
          var v18666 = resolved;
          var v18667 = String.fromCharCode(charCode);
          resolved = v18666 + v18667;
          i$$11 = i$$11 + 6;
          start$$6 = i$$11;
          var v22977 = name$$32.length;
          var v18668 = v22977 - 6;
          v11938 = i$$11 <= v18668;
          continue;
        }
        i$$11 = i$$11 + 1;
        var v22978 = name$$32.length;
        var v18669 = v22978 - 6;
        v11938 = i$$11 <= v18669;
      }
      var v18670 = resolved;
      var v18671 = name$$32.substring(start$$6);
      resolved = v18670 + v18671;
      return resolved;
    }
    function v92() {
      var v18672 = TypeScript$$4.NodeType;
      var v11939 = v18672._map;
      var v11940 = this.nodeType;
      return v11939[v11940];
    }
    function v91(container, freeUses) {
      return;
    }
    function v90(context$$7) {
      var v18673 = context$$7.walker;
      var v11941 = v18673.options;
      v11941.goChildren = false;
      context$$7.addContent(this);
      return;
    }
    function v89() {
      var v22979 = TypeScript$$4.nodeTypeTable;
      var v22980 = this.nodeType;
      var v18674 = v22979[v22980];
      var v11946 = v18674 !== undefined;
      if (v11946) {
        var v11942 = TypeScript$$4.nodeTypeTable;
        var v11943 = this.nodeType;
        return v11942[v11943];
      } else {
        var v18675 = TypeScript$$4.NodeType;
        var v11944 = v18675._map;
        var v11945 = this.nodeType;
        return v11944[v11945];
      }
      return;
    }
    function v88(context$$6) {
      context$$6.startLine();
      var lineCol = {line:-1, col:-1};
      var limLineCol = {line:-1, col:-1};
      var v18676 = context$$6.parser;
      var v11952 = v18676 !== null;
      if (v11952) {
        var v11947 = context$$6.parser;
        var v11948 = this.minChar;
        v11947.getSourceLineCol(lineCol, v11948);
        var v11949 = context$$6.parser;
        var v11950 = this.limChar;
        v11949.getSourceLineCol(limLineCol, v11950);
        var v26746 = lineCol.line;
        var v26723 = "(" + v26746;
        var v26676 = v26723 + ",";
        var v26677 = lineCol.col;
        var v26587 = v26676 + v26677;
        var v26407 = v26587 + ")--";
        var v26012 = v26407 + "(";
        var v26013 = limLineCol.line;
        var v25118 = v26012 + v26013;
        var v22981 = v25118 + ",";
        var v22982 = limLineCol.col;
        var v18677 = v22981 + v22982;
        var v11951 = v18677 + "): ";
        context$$6.write(v11951);
      }
      var lab = this.printLabel();
      var v18678 = this.flags;
      var v22983 = TypeScript$$4.ASTFlags;
      var v18679 = v22983.Error;
      var v11953 = TypeScript$$4.hasFlag(v18678, v18679);
      if (v11953) {
        lab = lab + " (Error)";
      }
      context$$6.writeLine(lab);
      return;
    }
    function v87(emitter, tokenId, startLine) {
      emitter.emitParensAndCommentsInPlace(this, true);
      var v11955 = this.nodeType;
      switch(v11955) {
        case TypeScript$$4.NodeType.This:
          emitter.recordSourceMappingStart(this);
          var v18680 = emitter.thisFnc;
          if (v18680) {
            var v25119 = emitter.thisFnc;
            var v22984 = v25119.fncFlags;
            var v25120 = TypeScript$$4.FncFlags;
            var v22985 = v25120.IsFatArrowFunction;
            v18680 = TypeScript$$4.hasFlag(v22984, v22985);
          }
          var v11954 = v18680;
          if (v11954) {
            emitter.writeToOutput("_this");
          } else {
            emitter.writeToOutput("this");
          }
          emitter.recordSourceMappingEnd(this);
          break;
        case TypeScript$$4.NodeType.Null:
          emitter.recordSourceMappingStart(this);
          emitter.writeToOutput("null");
          emitter.recordSourceMappingEnd(this);
          break;
        case TypeScript$$4.NodeType.False:
          emitter.recordSourceMappingStart(this);
          emitter.writeToOutput("false");
          emitter.recordSourceMappingEnd(this);
          break;
        case TypeScript$$4.NodeType.True:
          emitter.recordSourceMappingStart(this);
          emitter.writeToOutput("true");
          emitter.recordSourceMappingEnd(this);
          break;
        case TypeScript$$4.NodeType.Super:
          emitter.recordSourceMappingStart(this);
          emitter.emitSuperReference();
          emitter.recordSourceMappingEnd(this);
          break;
        case TypeScript$$4.NodeType.EndCode:
        ;
        case TypeScript$$4.NodeType.Error:
        ;
        case TypeScript$$4.NodeType.EmptyExpr:
          break;
        case TypeScript$$4.NodeType.Empty:
          emitter.recordSourceMappingStart(this);
          emitter.recordSourceMappingEnd(this);
          break;
        case TypeScript$$4.NodeType.Void:
          emitter.recordSourceMappingStart(this);
          emitter.writeToOutput("void ");
          emitter.recordSourceMappingEnd(this);
          break;
        default:
          throw new Error("please implement in derived class");;
      }
      emitter.emitParensAndCommentsInPlace(this, false);
      return;
    }
    function v86(typeFlow) {
      var v11956 = this.nodeType;
      switch(v11956) {
        case TypeScript$$4.NodeType.Error:
        ;
        case TypeScript$$4.NodeType.EmptyExpr:
          this.type = typeFlow.anyType;
          break;
        case TypeScript$$4.NodeType.This:
          return typeFlow.typeCheckThis(this);
        case TypeScript$$4.NodeType.Null:
          this.type = typeFlow.nullType;
          break;
        case TypeScript$$4.NodeType.False:
        ;
        case TypeScript$$4.NodeType.True:
          this.type = typeFlow.booleanType;
          break;
        case TypeScript$$4.NodeType.Super:
          return typeFlow.typeCheckSuper(this);
        case TypeScript$$4.NodeType.EndCode:
        ;
        case TypeScript$$4.NodeType.Empty:
        ;
        case TypeScript$$4.NodeType.Void:
          this.type = typeFlow.voidType;
          break;
        default:
          throw new Error("please implement in derived class");;
      }
      return this;
    }
    function v85() {
      return false;
    }
    function v84() {
      var v11957 = this.isStatementOrExpression();
      if (v11957) {
        var v18681 = this.isCompoundStatement();
        v11957 = !v18681;
      }
      return v11957;
    }
    function v83() {
      return false;
    }
    function v82() {
      return false;
    }
    function v81() {
      return false;
    }
    function AST$$1(nodeType) {
      _super.call(this);
      this.nodeType = nodeType;
      this.type = null;
      var v11958 = TypeScript$$4.ASTFlags;
      this.flags = v11958.Writeable;
      var v11959 = TypeScript$$4.CompilerDiagnostics;
      this.passCreated = v11959.analysisPass;
      this.preComments = null;
      this.postComments = null;
      this.docComments = null;
      this.isParenthesized = false;
      return;
    }
    __extends(AST$$1, _super);
    var v11960 = AST$$1.prototype;
    v11960.isExpression = v81;
    var v11961 = AST$$1.prototype;
    v11961.isStatementOrExpression = v82;
    var v11962 = AST$$1.prototype;
    v11962.isCompoundStatement = v83;
    var v11963 = AST$$1.prototype;
    v11963.isLeaf = v84;
    var v11964 = AST$$1.prototype;
    v11964.isDeclaration = v85;
    var v11965 = AST$$1.prototype;
    v11965.typeCheck = v86;
    var v11966 = AST$$1.prototype;
    v11966.emit = v87;
    var v11967 = AST$$1.prototype;
    v11967.print = v88;
    var v11968 = AST$$1.prototype;
    v11968.printLabel = v89;
    var v11969 = AST$$1.prototype;
    v11969.addToControlFlow = v90;
    var v11970 = AST$$1.prototype;
    v11970.netFreeUses = v91;
    var v11971 = AST$$1.prototype;
    v11971.treeViewLabel = v92;
    AST$$1.getResolvedIdentifierName = getResolvedIdentifierName;
    var v11972 = AST$$1.prototype;
    v11972.getDocComments = v93;
    return AST$$1;
  }
  function v80() {
    function ASTSpan$$1() {
      this.minChar = -1;
      this.limChar = -1;
      return;
    }
    return ASTSpan$$1;
  }
  var ASTSpan = v80();
  TypeScript$$4.ASTSpan = ASTSpan;
  var AST = v94(ASTSpan);
  TypeScript$$4.AST = AST;
  var IncompleteAST = v95(AST);
  TypeScript$$4.IncompleteAST = IncompleteAST;
  var ASTList = v101(AST);
  TypeScript$$4.ASTList = ASTList;
  var Identifier = v109(AST);
  TypeScript$$4.Identifier = Identifier;
  var MissingIdentifier = v112(Identifier);
  TypeScript$$4.MissingIdentifier = MissingIdentifier;
  var Label = v116(AST);
  TypeScript$$4.Label = Label;
  var Expression = v119(AST);
  TypeScript$$4.Expression = Expression;
  var UnaryExpression = v123(Expression);
  TypeScript$$4.UnaryExpression = UnaryExpression;
  var CallExpression = v126(Expression);
  TypeScript$$4.CallExpression = CallExpression;
  var BinaryExpression = v129(Expression);
  TypeScript$$4.BinaryExpression = BinaryExpression;
  var ConditionalExpression = v132(Expression);
  TypeScript$$4.ConditionalExpression = ConditionalExpression;
  var NumberLiteral = v137(Expression);
  TypeScript$$4.NumberLiteral = NumberLiteral;
  var RegexLiteral = v140(Expression);
  TypeScript$$4.RegexLiteral = RegexLiteral;
  var StringLiteral = v145(Expression);
  TypeScript$$4.StringLiteral = StringLiteral;
  var ModuleElement = v146(AST);
  TypeScript$$4.ModuleElement = ModuleElement;
  var ImportDeclaration = v153(ModuleElement);
  TypeScript$$4.ImportDeclaration = ImportDeclaration;
  var BoundDecl = v161(AST);
  TypeScript$$4.BoundDecl = BoundDecl;
  var VarDecl = v167(BoundDecl);
  TypeScript$$4.VarDecl = VarDecl;
  var ArgDecl = v171(BoundDecl);
  TypeScript$$4.ArgDecl = ArgDecl;
  var internalId = 0;
  var FuncDecl = v201(AST);
  TypeScript$$4.FuncDecl = FuncDecl;
  var LocationInfo = v202();
  TypeScript$$4.LocationInfo = LocationInfo;
  var v11973 = TypeScript$$4;
  var v27434 = new LocationInfo("unknown", null, -1);
  v11973.unknownLocationInfo = v27434;
  var Script = v210(FuncDecl);
  TypeScript$$4.Script = Script;
  var NamedDeclaration = v212(ModuleElement);
  TypeScript$$4.NamedDeclaration = NamedDeclaration;
  var ModuleDeclaration = v219(NamedDeclaration);
  TypeScript$$4.ModuleDeclaration = ModuleDeclaration;
  var TypeDeclaration = v222(NamedDeclaration);
  TypeScript$$4.TypeDeclaration = TypeDeclaration;
  var ClassDeclaration = v225(TypeDeclaration);
  TypeScript$$4.ClassDeclaration = ClassDeclaration;
  var InterfaceDeclaration = v228(TypeDeclaration);
  TypeScript$$4.InterfaceDeclaration = InterfaceDeclaration;
  var Statement = v233(ModuleElement);
  TypeScript$$4.Statement = Statement;
  var LabeledStatement = v237(Statement);
  TypeScript$$4.LabeledStatement = LabeledStatement;
  var Block = v241(Statement);
  TypeScript$$4.Block = Block;
  var Jump = v246(Statement);
  TypeScript$$4.Jump = Jump;
  var WhileStatement = v251(Statement);
  TypeScript$$4.WhileStatement = WhileStatement;
  var DoWhileStatement = v256(Statement);
  TypeScript$$4.DoWhileStatement = DoWhileStatement;
  var IfStatement = v261(Statement);
  TypeScript$$4.IfStatement = IfStatement;
  var ReturnStatement = v265(Statement);
  TypeScript$$4.ReturnStatement = ReturnStatement;
  var EndCode = v266(AST);
  TypeScript$$4.EndCode = EndCode;
  var ForInStatement = v272(Statement);
  TypeScript$$4.ForInStatement = ForInStatement;
  var ForStatement = v277(Statement);
  TypeScript$$4.ForStatement = ForStatement;
  var WithStatement = v281(Statement);
  TypeScript$$4.WithStatement = WithStatement;
  var SwitchStatement = v286(Statement);
  TypeScript$$4.SwitchStatement = SwitchStatement;
  var CaseStatement = v290(Statement);
  TypeScript$$4.CaseStatement = CaseStatement;
  var TypeReference = v293(AST);
  TypeScript$$4.TypeReference = TypeReference;
  var TryFinally = v298(Statement);
  TypeScript$$4.TryFinally = TryFinally;
  var TryCatch = v303(Statement);
  TypeScript$$4.TryCatch = TryCatch;
  var Try = v307(Statement);
  TypeScript$$4.Try = Try;
  var Catch = v311(Statement);
  TypeScript$$4.Catch = Catch;
  var Finally = v315(Statement);
  TypeScript$$4.Finally = Finally;
  var Comment$$1 = v319(AST);
  TypeScript$$4.Comment = Comment$$1;
  var DebuggerStatement = v321(Statement);
  TypeScript$$4.DebuggerStatement = DebuggerStatement;
  return;
}
function v79(d, b) {
  function __() {
    this.constructor = d;
    return;
  }
  __.prototype = b.prototype;
  var v11974 = d;
  var v27435 = new __;
  v11974.prototype = v27435;
  return;
}
function v78(TypeScript$$3) {
  function v77() {
    function v76(key$$26, data$$32) {
      var lookupData = this.lookup(key$$26);
      if (lookupData) {
        return false;
      }
      var v11975 = this.keys;
      var v18682 = this.keys;
      var v11976 = v18682.length;
      v11975[v11976] = key$$26;
      var v11977 = this.values;
      var v18683 = this.values;
      var v11978 = v18683.length;
      v11977[v11978] = data$$32;
      return true;
    }
    function v75(key$$25, findValue) {
      var searchArray = this.keys;
      if (findValue) {
        searchArray = this.values;
      }
      var i$$10 = 0;
      var v18684 = searchArray.length;
      var v11982 = i$$10 < v18684;
      for (;v11982;) {
        var v18685 = searchArray[i$$10];
        var v11981 = v18685 == key$$25;
        if (v11981) {
          var v18686 = this.keys;
          var v11979 = v18686[i$$10];
          var v18687 = this.values;
          var v11980 = v18687[i$$10];
          return{key:v11979, data:v11980};
        }
        i$$10 = i$$10 + 1;
        var v18688 = searchArray.length;
        v11982 = i$$10 < v18688;
      }
      return null;
    }
    function SimpleHashTable$$1() {
      this.keys = [];
      this.values = [];
      return;
    }
    var v11983 = SimpleHashTable$$1.prototype;
    v11983.lookup = v75;
    var v11984 = SimpleHashTable$$1.prototype;
    v11984.add = v76;
    return SimpleHashTable$$1;
  }
  function v74() {
    function v73(key$$24) {
      var current$$2;
      var val$$3 = this.hashFn(key$$24);
      var v11985 = this.size;
      val$$3 = val$$3 % v11985;
      var v11986 = this.table;
      current$$2 = v11986[val$$3];
      var v11988 = current$$2 != null;
      for (;v11988;) {
        var v18689 = current$$2.key;
        var v11987 = this.equalsFn(key$$24, v18689);
        if (v11987) {
          return current$$2.data;
        }
        current$$2 = current$$2.next;
        v11988 = current$$2 != null;
      }
      return null;
    }
    function v72() {
      return this.itemCount;
    }
    function v71(key$$23) {
      var current$$1;
      var val$$2 = this.hashFn(key$$23);
      var v11989 = this.size;
      val$$2 = val$$2 % v11989;
      var result$$3 = null;
      var prevEntry = null;
      var v11990 = this.table;
      current$$1 = v11990[val$$2];
      var v11993 = current$$1 != null;
      for (;v11993;) {
        var v18690 = current$$1.key;
        var v11992 = this.equalsFn(key$$23, v18690);
        if (v11992) {
          result$$3 = current$$1.data;
          var v18691 = this.itemCount;
          this.itemCount = v18691 - 1;
          if (prevEntry) {
            prevEntry.next = current$$1.next;
          } else {
            var v11991 = this.table;
            v11991[val$$2] = current$$1.next;
          }
          break;
        }
        prevEntry = current$$1;
        current$$1 = current$$1.next;
        v11993 = current$$1 != null;
      }
      return result$$3;
    }
    function v70(key$$22, data$$31) {
      var current;
      var entry = new HashEntry(key$$22, data$$31);
      var val$$1 = this.hashFn(key$$22);
      var v11994 = this.size;
      val$$1 = val$$1 % v11994;
      var v11995 = this.table;
      current = v11995[val$$1];
      var v11997 = current != null;
      for (;v11997;) {
        var v18692 = current.key;
        var v11996 = this.equalsFn(key$$22, v18692);
        if (v11996) {
          return false;
        }
        current = current.next;
        v11997 = current != null;
      }
      var v11998 = this.table;
      entry.next = v11998[val$$1];
      var v11999 = this.table;
      v11999[val$$1] = entry;
      var v18693 = this.itemCount;
      this.itemCount = v18693 + 1;
      return true;
    }
    function HashTable$$1(size$$4, hashFn, equalsFn) {
      this.size = size$$4;
      this.hashFn = hashFn;
      this.equalsFn = equalsFn;
      this.itemCount = 0;
      var v27436 = new Array;
      this.table = v27436;
      var i$$9 = 0;
      var v18694 = this.size;
      var v12001 = i$$9 < v18694;
      for (;v12001;) {
        var v12000 = this.table;
        v12000[i$$9] = null;
        i$$9 = i$$9 + 1;
        var v18695 = this.size;
        v12001 = i$$9 < v18695;
      }
      return;
    }
    var v12002 = HashTable$$1.prototype;
    v12002.add = v70;
    var v12003 = HashTable$$1.prototype;
    v12003.remove = v71;
    var v12004 = HashTable$$1.prototype;
    v12004.count = v72;
    var v12005 = HashTable$$1.prototype;
    v12005.lookup = v73;
    return HashTable$$1;
  }
  function v69() {
    function HashEntry$$1(key$$21, data$$30) {
      this.key = key$$21;
      this.data = data$$30;
      return;
    }
    return HashEntry$$1;
  }
  function v68() {
    function v67(key$$20) {
      var v12006 = this.primaryTable;
      var data$$29 = v12006.lookup(key$$20);
      var v12008 = data$$29 != undefined;
      if (v12008) {
        return data$$29;
      } else {
        var v12007 = this.secondaryTable;
        return v12007.lookup(key$$20);
      }
      return;
    }
    function v66() {
      var v18696 = this.primaryTable;
      var v12009 = v18696.count();
      var v18697 = this.secondaryTable;
      var v12010 = v18697.count();
      return v12009 + v12010;
    }
    function v65(fn$$5, context$$5) {
      var v18698 = this.primaryTable;
      var v12011 = v18698.some(fn$$5, context$$5);
      var v18700 = !v12011;
      if (v18700) {
        var v18699 = this.secondaryTable;
        v12011 = v18699.some(fn$$5, context$$5);
      }
      return v12011;
    }
    function v64(fn$$4, context$$4) {
      var v18701 = this.primaryTable;
      var v12012 = v18701.every(fn$$4, context$$4);
      if (v12012) {
        var v18702 = this.secondaryTable;
        v12012 = v18702.every(fn$$4, context$$4);
      }
      return v12012;
    }
    function v63(fn$$3, context$$3) {
      var v12013 = this.primaryTable;
      v12013.map(fn$$3, context$$3);
      var v12014 = this.secondaryTable;
      v12014.map(fn$$3, context$$3);
      return;
    }
    function v62(key$$19, data$$28) {
      var v12017 = this.insertPrimary;
      if (v12017) {
        var v12015 = this.primaryTable;
        return v12015.addOrUpdate(key$$19, data$$28);
      } else {
        var v12016 = this.secondaryTable;
        return v12016.addOrUpdate(key$$19, data$$28);
      }
      return;
    }
    function v61(key$$18, data$$27) {
      var v12020 = this.insertPrimary;
      if (v12020) {
        var v12018 = this.primaryTable;
        return v12018.add(key$$18, data$$27);
      } else {
        var v12019 = this.secondaryTable;
        return v12019.add(key$$18, data$$27);
      }
      return;
    }
    function v60() {
      var v18703 = this.primaryTable;
      var v12021 = v18703.getAllKeys();
      var v18704 = this.secondaryTable;
      var v12022 = v18704.getAllKeys();
      return v12021.concat(v12022);
    }
    function DualStringHashTable$$1(primaryTable, secondaryTable) {
      this.primaryTable = primaryTable;
      this.secondaryTable = secondaryTable;
      this.insertPrimary = true;
      return;
    }
    var v12023 = DualStringHashTable$$1.prototype;
    v12023.getAllKeys = v60;
    var v12024 = DualStringHashTable$$1.prototype;
    v12024.add = v61;
    var v12025 = DualStringHashTable$$1.prototype;
    v12025.addOrUpdate = v62;
    var v12026 = DualStringHashTable$$1.prototype;
    v12026.map = v63;
    var v12027 = DualStringHashTable$$1.prototype;
    v12027.every = v64;
    var v12028 = DualStringHashTable$$1.prototype;
    v12028.some = v65;
    var v12029 = DualStringHashTable$$1.prototype;
    v12029.count = v66;
    var v12030 = DualStringHashTable$$1.prototype;
    v12030.lookup = v67;
    return DualStringHashTable$$1;
  }
  function v59() {
    function v58(key$$17) {
      var v12031 = this.table;
      var data$$26 = v12031[key$$17];
      var v12032 = data$$26 != undefined;
      if (v12032) {
        return data$$26;
      } else {
        return null;
      }
      return;
    }
    function v57() {
      return this.itemCount;
    }
    function v56(fn$$2, context$$2) {
      var k$$4;
      var v12036 = this.table;
      for (k$$4 in v12036) {
        var v12033 = this.table;
        var data$$25 = v12033[k$$4];
        var v12035 = data$$25 != undefined;
        if (v12035) {
          var v22986 = this.table;
          var v18705 = v22986[k$$4];
          var v12034 = fn$$2(k$$4, v18705, context$$2);
          if (v12034) {
            return true;
          }
        }
      }
      return false;
    }
    function v55(fn$$1, context$$1) {
      var k$$3;
      var v12040 = this.table;
      for (k$$3 in v12040) {
        var v12037 = this.table;
        var data$$24 = v12037[k$$3];
        var v12039 = data$$24 != undefined;
        if (v12039) {
          var v25121 = this.table;
          var v22987 = v25121[k$$3];
          var v18706 = fn$$1(k$$3, v22987, context$$1);
          var v12038 = !v18706;
          if (v12038) {
            return false;
          }
        }
      }
      return true;
    }
    function v54(fn, context) {
      var k$$2;
      var v12044 = this.table;
      for (k$$2 in v12044) {
        var v12041 = this.table;
        var data$$23 = v12041[k$$2];
        var v12043 = data$$23 != undefined;
        if (v12043) {
          var v18707 = this.table;
          var v12042 = v18707[k$$2];
          fn(k$$2, v12042, context);
        }
      }
      return;
    }
    function v53(key$$16, data$$22) {
      var v22988 = this.table;
      var v18708 = v22988[key$$16];
      var v12046 = v18708 != undefined;
      if (v12046) {
        var v12045 = this.table;
        v12045[key$$16] = data$$22;
        return false;
      }
      var v12047 = this.table;
      v12047[key$$16] = data$$22;
      var v18709 = this.itemCount;
      this.itemCount = v18709 + 1;
      return true;
    }
    function v52(key$$15, data$$21) {
      var v22989 = this.table;
      var v18710 = v22989[key$$15];
      var v12048 = v18710 != undefined;
      if (v12048) {
        return false;
      }
      var v12049 = this.table;
      v12049[key$$15] = data$$21;
      var v18711 = this.itemCount;
      this.itemCount = v18711 + 1;
      return true;
    }
    function v51() {
      var result$$2 = [];
      var k$$1;
      var v12052 = this.table;
      for (k$$1 in v12052) {
        var v22990 = this.table;
        var v18712 = v22990[k$$1];
        var v12051 = v18712 != undefined;
        if (v12051) {
          var v12050 = result$$2.length;
          result$$2[v12050] = k$$1;
        }
      }
      return result$$2;
    }
    function StringHashTable$$1() {
      this.itemCount = 0;
      var v27437 = new BlockIntrinsics;
      this.table = v27437;
      return;
    }
    var v12053 = StringHashTable$$1.prototype;
    v12053.getAllKeys = v51;
    var v12054 = StringHashTable$$1.prototype;
    v12054.add = v52;
    var v12055 = StringHashTable$$1.prototype;
    v12055.addOrUpdate = v53;
    var v12056 = StringHashTable$$1.prototype;
    v12056.map = v54;
    var v12057 = StringHashTable$$1.prototype;
    v12057.every = v55;
    var v12058 = StringHashTable$$1.prototype;
    v12058.some = v56;
    var v12059 = StringHashTable$$1.prototype;
    v12059.count = v57;
    var v12060 = StringHashTable$$1.prototype;
    v12060.lookup = v58;
    return StringHashTable$$1;
  }
  function v50() {
    function BlockIntrinsics$$1() {
      this.prototype = undefined;
      this.toString = undefined;
      this.toLocaleString = undefined;
      this.valueOf = undefined;
      this.hasOwnProperty = undefined;
      this.propertyIsEnumerable = undefined;
      this.isPrototypeOf = undefined;
      this["constructor"] = undefined;
      return;
    }
    return BlockIntrinsics$$1;
  }
  function numberHashFn(key$$14) {
    var c2 = 668265261;
    var v12061 = key$$14 ^ 61;
    var v12062 = key$$14 >>> 16;
    key$$14 = v12061 ^ v12062;
    var v12063 = key$$14 << 3;
    key$$14 = key$$14 + v12063;
    var v12064 = key$$14 >>> 4;
    key$$14 = key$$14 ^ v12064;
    key$$14 = key$$14 * c2;
    var v12065 = key$$14 >>> 15;
    key$$14 = key$$14 ^ v12065;
    return key$$14;
  }
  function combineHashes(key1, key2) {
    var v18713 = key1 >> 5;
    var v12066 = v18713 + key1;
    return key2 ^ v12066;
  }
  var BlockIntrinsics = v50();
  TypeScript$$3.BlockIntrinsics = BlockIntrinsics;
  var StringHashTable = v59();
  TypeScript$$3.StringHashTable = StringHashTable;
  var DualStringHashTable = v68();
  TypeScript$$3.DualStringHashTable = DualStringHashTable;
  TypeScript$$3.numberHashFn = numberHashFn;
  TypeScript$$3.combineHashes = combineHashes;
  var HashEntry = v69();
  TypeScript$$3.HashEntry = HashEntry;
  var HashTable = v74();
  TypeScript$$3.HashTable = HashTable;
  var SimpleHashTable = v77();
  TypeScript$$3.SimpleHashTable = SimpleHashTable;
  return;
}
function v49(TypeScript$$2) {
  var v12067 = TypeScript$$2.NodeType;
  var v18714 = !v12067;
  if (v18714) {
    v12067 = TypeScript$$2.NodeType = {};
  }
  var NodeType$$inline_0 = v12067;
  NodeType$$inline_0._map = [];
  var v12068 = NodeType$$inline_0._map;
  v12068[0] = "None";
  NodeType$$inline_0.None = 0;
  var v12069 = NodeType$$inline_0._map;
  v12069[1] = "Empty";
  NodeType$$inline_0.Empty = 1;
  var v12070 = NodeType$$inline_0._map;
  v12070[2] = "EmptyExpr";
  NodeType$$inline_0.EmptyExpr = 2;
  var v12071 = NodeType$$inline_0._map;
  v12071[3] = "True";
  NodeType$$inline_0.True = 3;
  var v12072 = NodeType$$inline_0._map;
  v12072[4] = "False";
  NodeType$$inline_0.False = 4;
  var v12073 = NodeType$$inline_0._map;
  v12073[5] = "This";
  NodeType$$inline_0.This = 5;
  var v12074 = NodeType$$inline_0._map;
  v12074[6] = "Super";
  NodeType$$inline_0.Super = 6;
  var v12075 = NodeType$$inline_0._map;
  v12075[7] = "QString";
  NodeType$$inline_0.QString = 7;
  var v12076 = NodeType$$inline_0._map;
  v12076[8] = "Regex";
  NodeType$$inline_0.Regex = 8;
  var v12077 = NodeType$$inline_0._map;
  v12077[9] = "Null";
  NodeType$$inline_0.Null = 9;
  var v12078 = NodeType$$inline_0._map;
  v12078[10] = "ArrayLit";
  NodeType$$inline_0.ArrayLit = 10;
  var v12079 = NodeType$$inline_0._map;
  v12079[11] = "ObjectLit";
  NodeType$$inline_0.ObjectLit = 11;
  var v12080 = NodeType$$inline_0._map;
  v12080[12] = "Void";
  NodeType$$inline_0.Void = 12;
  var v12081 = NodeType$$inline_0._map;
  v12081[13] = "Comma";
  NodeType$$inline_0.Comma = 13;
  var v12082 = NodeType$$inline_0._map;
  v12082[14] = "Pos";
  NodeType$$inline_0.Pos = 14;
  var v12083 = NodeType$$inline_0._map;
  v12083[15] = "Neg";
  NodeType$$inline_0.Neg = 15;
  var v12084 = NodeType$$inline_0._map;
  v12084[16] = "Delete";
  NodeType$$inline_0.Delete = 16;
  var v12085 = NodeType$$inline_0._map;
  v12085[17] = "Await";
  NodeType$$inline_0.Await = 17;
  var v12086 = NodeType$$inline_0._map;
  v12086[18] = "In";
  NodeType$$inline_0.In = 18;
  var v12087 = NodeType$$inline_0._map;
  v12087[19] = "Dot";
  NodeType$$inline_0.Dot = 19;
  var v12088 = NodeType$$inline_0._map;
  v12088[20] = "From";
  NodeType$$inline_0.From = 20;
  var v12089 = NodeType$$inline_0._map;
  v12089[21] = "Is";
  NodeType$$inline_0.Is = 21;
  var v12090 = NodeType$$inline_0._map;
  v12090[22] = "InstOf";
  NodeType$$inline_0.InstOf = 22;
  var v12091 = NodeType$$inline_0._map;
  v12091[23] = "Typeof";
  NodeType$$inline_0.Typeof = 23;
  var v12092 = NodeType$$inline_0._map;
  v12092[24] = "NumberLit";
  NodeType$$inline_0.NumberLit = 24;
  var v12093 = NodeType$$inline_0._map;
  v12093[25] = "Name";
  NodeType$$inline_0.Name = 25;
  var v12094 = NodeType$$inline_0._map;
  v12094[26] = "TypeRef";
  NodeType$$inline_0.TypeRef = 26;
  var v12095 = NodeType$$inline_0._map;
  v12095[27] = "Index";
  NodeType$$inline_0.Index = 27;
  var v12096 = NodeType$$inline_0._map;
  v12096[28] = "Call";
  NodeType$$inline_0.Call = 28;
  var v12097 = NodeType$$inline_0._map;
  v12097[29] = "New";
  NodeType$$inline_0.New = 29;
  var v12098 = NodeType$$inline_0._map;
  v12098[30] = "Asg";
  NodeType$$inline_0.Asg = 30;
  var v12099 = NodeType$$inline_0._map;
  v12099[31] = "AsgAdd";
  NodeType$$inline_0.AsgAdd = 31;
  var v12100 = NodeType$$inline_0._map;
  v12100[32] = "AsgSub";
  NodeType$$inline_0.AsgSub = 32;
  var v12101 = NodeType$$inline_0._map;
  v12101[33] = "AsgDiv";
  NodeType$$inline_0.AsgDiv = 33;
  var v12102 = NodeType$$inline_0._map;
  v12102[34] = "AsgMul";
  NodeType$$inline_0.AsgMul = 34;
  var v12103 = NodeType$$inline_0._map;
  v12103[35] = "AsgMod";
  NodeType$$inline_0.AsgMod = 35;
  var v12104 = NodeType$$inline_0._map;
  v12104[36] = "AsgAnd";
  NodeType$$inline_0.AsgAnd = 36;
  var v12105 = NodeType$$inline_0._map;
  v12105[37] = "AsgXor";
  NodeType$$inline_0.AsgXor = 37;
  var v12106 = NodeType$$inline_0._map;
  v12106[38] = "AsgOr";
  NodeType$$inline_0.AsgOr = 38;
  var v12107 = NodeType$$inline_0._map;
  v12107[39] = "AsgLsh";
  NodeType$$inline_0.AsgLsh = 39;
  var v12108 = NodeType$$inline_0._map;
  v12108[40] = "AsgRsh";
  NodeType$$inline_0.AsgRsh = 40;
  var v12109 = NodeType$$inline_0._map;
  v12109[41] = "AsgRs2";
  NodeType$$inline_0.AsgRs2 = 41;
  var v12110 = NodeType$$inline_0._map;
  v12110[42] = "ConditionalExpression";
  NodeType$$inline_0.ConditionalExpression = 42;
  var v12111 = NodeType$$inline_0._map;
  v12111[43] = "LogOr";
  NodeType$$inline_0.LogOr = 43;
  var v12112 = NodeType$$inline_0._map;
  v12112[44] = "LogAnd";
  NodeType$$inline_0.LogAnd = 44;
  var v12113 = NodeType$$inline_0._map;
  v12113[45] = "Or";
  NodeType$$inline_0.Or = 45;
  var v12114 = NodeType$$inline_0._map;
  v12114[46] = "Xor";
  NodeType$$inline_0.Xor = 46;
  var v12115 = NodeType$$inline_0._map;
  v12115[47] = "And";
  NodeType$$inline_0.And = 47;
  var v12116 = NodeType$$inline_0._map;
  v12116[48] = "Eq";
  NodeType$$inline_0.Eq = 48;
  var v12117 = NodeType$$inline_0._map;
  v12117[49] = "Ne";
  NodeType$$inline_0.Ne = 49;
  var v12118 = NodeType$$inline_0._map;
  v12118[50] = "Eqv";
  NodeType$$inline_0.Eqv = 50;
  var v12119 = NodeType$$inline_0._map;
  v12119[51] = "NEqv";
  NodeType$$inline_0.NEqv = 51;
  var v12120 = NodeType$$inline_0._map;
  v12120[52] = "Lt";
  NodeType$$inline_0.Lt = 52;
  var v12121 = NodeType$$inline_0._map;
  v12121[53] = "Le";
  NodeType$$inline_0.Le = 53;
  var v12122 = NodeType$$inline_0._map;
  v12122[54] = "Gt";
  NodeType$$inline_0.Gt = 54;
  var v12123 = NodeType$$inline_0._map;
  v12123[55] = "Ge";
  NodeType$$inline_0.Ge = 55;
  var v12124 = NodeType$$inline_0._map;
  v12124[56] = "Add";
  NodeType$$inline_0.Add = 56;
  var v12125 = NodeType$$inline_0._map;
  v12125[57] = "Sub";
  NodeType$$inline_0.Sub = 57;
  var v12126 = NodeType$$inline_0._map;
  v12126[58] = "Mul";
  NodeType$$inline_0.Mul = 58;
  var v12127 = NodeType$$inline_0._map;
  v12127[59] = "Div";
  NodeType$$inline_0.Div = 59;
  var v12128 = NodeType$$inline_0._map;
  v12128[60] = "Mod";
  NodeType$$inline_0.Mod = 60;
  var v12129 = NodeType$$inline_0._map;
  v12129[61] = "Lsh";
  NodeType$$inline_0.Lsh = 61;
  var v12130 = NodeType$$inline_0._map;
  v12130[62] = "Rsh";
  NodeType$$inline_0.Rsh = 62;
  var v12131 = NodeType$$inline_0._map;
  v12131[63] = "Rs2";
  NodeType$$inline_0.Rs2 = 63;
  var v12132 = NodeType$$inline_0._map;
  v12132[64] = "Not";
  NodeType$$inline_0.Not = 64;
  var v12133 = NodeType$$inline_0._map;
  v12133[65] = "LogNot";
  NodeType$$inline_0.LogNot = 65;
  var v12134 = NodeType$$inline_0._map;
  v12134[66] = "IncPre";
  NodeType$$inline_0.IncPre = 66;
  var v12135 = NodeType$$inline_0._map;
  v12135[67] = "DecPre";
  NodeType$$inline_0.DecPre = 67;
  var v12136 = NodeType$$inline_0._map;
  v12136[68] = "IncPost";
  NodeType$$inline_0.IncPost = 68;
  var v12137 = NodeType$$inline_0._map;
  v12137[69] = "DecPost";
  NodeType$$inline_0.DecPost = 69;
  var v12138 = NodeType$$inline_0._map;
  v12138[70] = "TypeAssertion";
  NodeType$$inline_0.TypeAssertion = 70;
  var v12139 = NodeType$$inline_0._map;
  v12139[71] = "FuncDecl";
  NodeType$$inline_0.FuncDecl = 71;
  var v12140 = NodeType$$inline_0._map;
  v12140[72] = "Member";
  NodeType$$inline_0.Member = 72;
  var v12141 = NodeType$$inline_0._map;
  v12141[73] = "VarDecl";
  NodeType$$inline_0.VarDecl = 73;
  var v12142 = NodeType$$inline_0._map;
  v12142[74] = "ArgDecl";
  NodeType$$inline_0.ArgDecl = 74;
  var v12143 = NodeType$$inline_0._map;
  v12143[75] = "Return";
  NodeType$$inline_0.Return = 75;
  var v12144 = NodeType$$inline_0._map;
  v12144[76] = "Break";
  NodeType$$inline_0.Break = 76;
  var v12145 = NodeType$$inline_0._map;
  v12145[77] = "Continue";
  NodeType$$inline_0.Continue = 77;
  var v12146 = NodeType$$inline_0._map;
  v12146[78] = "Throw";
  NodeType$$inline_0.Throw = 78;
  var v12147 = NodeType$$inline_0._map;
  v12147[79] = "For";
  NodeType$$inline_0.For = 79;
  var v12148 = NodeType$$inline_0._map;
  v12148[80] = "ForIn";
  NodeType$$inline_0.ForIn = 80;
  var v12149 = NodeType$$inline_0._map;
  v12149[81] = "If";
  NodeType$$inline_0.If = 81;
  var v12150 = NodeType$$inline_0._map;
  v12150[82] = "While";
  NodeType$$inline_0.While = 82;
  var v12151 = NodeType$$inline_0._map;
  v12151[83] = "DoWhile";
  NodeType$$inline_0.DoWhile = 83;
  var v12152 = NodeType$$inline_0._map;
  v12152[84] = "Block";
  NodeType$$inline_0.Block = 84;
  var v12153 = NodeType$$inline_0._map;
  v12153[85] = "Case";
  NodeType$$inline_0.Case = 85;
  var v12154 = NodeType$$inline_0._map;
  v12154[86] = "Switch";
  NodeType$$inline_0.Switch = 86;
  var v12155 = NodeType$$inline_0._map;
  v12155[87] = "Try";
  NodeType$$inline_0.Try = 87;
  var v12156 = NodeType$$inline_0._map;
  v12156[88] = "TryCatch";
  NodeType$$inline_0.TryCatch = 88;
  var v12157 = NodeType$$inline_0._map;
  v12157[89] = "TryFinally";
  NodeType$$inline_0.TryFinally = 89;
  var v12158 = NodeType$$inline_0._map;
  v12158[90] = "Finally";
  NodeType$$inline_0.Finally = 90;
  var v12159 = NodeType$$inline_0._map;
  v12159[91] = "Catch";
  NodeType$$inline_0.Catch = 91;
  var v12160 = NodeType$$inline_0._map;
  v12160[92] = "List";
  NodeType$$inline_0.List = 92;
  var v12161 = NodeType$$inline_0._map;
  v12161[93] = "Script";
  NodeType$$inline_0.Script = 93;
  var v12162 = NodeType$$inline_0._map;
  v12162[94] = "ClassDeclaration";
  NodeType$$inline_0.ClassDeclaration = 94;
  var v12163 = NodeType$$inline_0._map;
  v12163[95] = "InterfaceDeclaration";
  NodeType$$inline_0.InterfaceDeclaration = 95;
  var v12164 = NodeType$$inline_0._map;
  v12164[96] = "ModuleDeclaration";
  NodeType$$inline_0.ModuleDeclaration = 96;
  var v12165 = NodeType$$inline_0._map;
  v12165[97] = "ImportDeclaration";
  NodeType$$inline_0.ImportDeclaration = 97;
  var v12166 = NodeType$$inline_0._map;
  v12166[98] = "With";
  NodeType$$inline_0.With = 98;
  var v12167 = NodeType$$inline_0._map;
  v12167[99] = "Label";
  NodeType$$inline_0.Label = 99;
  var v12168 = NodeType$$inline_0._map;
  v12168[100] = "LabeledStatement";
  NodeType$$inline_0.LabeledStatement = 100;
  var v12169 = NodeType$$inline_0._map;
  v12169[101] = "EBStart";
  NodeType$$inline_0.EBStart = 101;
  var v12170 = NodeType$$inline_0._map;
  v12170[102] = "GotoEB";
  NodeType$$inline_0.GotoEB = 102;
  var v12171 = NodeType$$inline_0._map;
  v12171[103] = "EndCode";
  NodeType$$inline_0.EndCode = 103;
  var v12172 = NodeType$$inline_0._map;
  v12172[104] = "Error";
  NodeType$$inline_0.Error = 104;
  var v12173 = NodeType$$inline_0._map;
  v12173[105] = "Comment";
  NodeType$$inline_0.Comment = 105;
  var v12174 = NodeType$$inline_0._map;
  v12174[106] = "Debugger";
  NodeType$$inline_0.Debugger = 106;
  NodeType$$inline_0.GeneralNode = NodeType$$inline_0.FuncDecl;
  NodeType$$inline_0.LastAsg = NodeType$$inline_0.AsgRs2;
  var NodeType = TypeScript$$2.NodeType;
  return;
}
function v48(TypeScript$$1) {
  function v47(ModuleGenTarget$$1) {
    ModuleGenTarget$$1._map = [];
    ModuleGenTarget$$1.Synchronous = 0;
    ModuleGenTarget$$1.Asynchronous = 1;
    ModuleGenTarget$$1.Local = 1 << 1;
    return;
  }
  function v46(CodeGenTarget$$1) {
    CodeGenTarget$$1._map = [];
    CodeGenTarget$$1.ES3 = 0;
    CodeGenTarget$$1.ES5 = 1;
    return;
  }
  function v45(TypeRelationshipFlags$$1) {
    TypeRelationshipFlags$$1._map = [];
    TypeRelationshipFlags$$1.SuccessfulComparison = 0;
    TypeRelationshipFlags$$1.SourceIsNullTargetIsVoidOrUndefined = 1;
    TypeRelationshipFlags$$1.RequiredPropertyIsMissing = 1 << 1;
    TypeRelationshipFlags$$1.IncompatibleSignatures = 1 << 2;
    TypeRelationshipFlags$$1.SourceSignatureHasTooManyParameters = 3;
    TypeRelationshipFlags$$1.IncompatibleReturnTypes = 1 << 4;
    TypeRelationshipFlags$$1.IncompatiblePropertyTypes = 1 << 5;
    TypeRelationshipFlags$$1.IncompatibleParameterTypes = 1 << 6;
    return;
  }
  function v44(TypeFlags$$1) {
    TypeFlags$$1._map = [];
    TypeFlags$$1.None = 0;
    TypeFlags$$1.HasImplementation = 1;
    TypeFlags$$1.HasSelfReference = 1 << 1;
    TypeFlags$$1.MergeResult = 1 << 2;
    TypeFlags$$1.IsEnum = 1 << 3;
    TypeFlags$$1.BuildingName = 1 << 4;
    TypeFlags$$1.HasBaseType = 1 << 5;
    TypeFlags$$1.HasBaseTypeOfObject = 1 << 6;
    TypeFlags$$1.IsClass = 1 << 7;
    return;
  }
  function v43(SignatureFlags$$1) {
    SignatureFlags$$1._map = [];
    SignatureFlags$$1.None = 0;
    SignatureFlags$$1.IsIndexer = 1;
    SignatureFlags$$1.IsStringIndexer = 1 << 1;
    SignatureFlags$$1.IsNumberIndexer = 1 << 2;
    return;
  }
  function v42(FncFlags$$1) {
    FncFlags$$1._map = [];
    FncFlags$$1.None = 0;
    FncFlags$$1.Exported = 1;
    FncFlags$$1.Private = 1 << 1;
    FncFlags$$1.Public = 1 << 2;
    FncFlags$$1.Ambient = 1 << 3;
    FncFlags$$1.Static = 1 << 4;
    FncFlags$$1.LocalStatic = 1 << 5;
    FncFlags$$1.GetAccessor = 1 << 6;
    FncFlags$$1.SetAccessor = 1 << 7;
    FncFlags$$1.Definition = 1 << 8;
    FncFlags$$1.Signature = 1 << 9;
    FncFlags$$1.Method = 1 << 10;
    FncFlags$$1.HasReturnExpression = 1 << 11;
    FncFlags$$1.CallMember = 1 << 12;
    FncFlags$$1.ConstructMember = 1 << 13;
    FncFlags$$1.HasSelfReference = 1 << 14;
    FncFlags$$1.IsFatArrowFunction = 1 << 15;
    FncFlags$$1.IndexerMember = 1 << 16;
    FncFlags$$1.IsFunctionExpression = 1 << 17;
    FncFlags$$1.ClassMethod = 1 << 18;
    FncFlags$$1.ClassPropertyMethodExported = 1 << 19;
    FncFlags$$1.HasSuperReferenceInFatArrowFunction = 1 << 20;
    FncFlags$$1.IsPropertyBound = 1 << 21;
    return;
  }
  function v41(VarFlags$$1) {
    VarFlags$$1._map = [];
    VarFlags$$1.None = 0;
    VarFlags$$1.Exported = 1;
    VarFlags$$1.Private = 1 << 1;
    VarFlags$$1.Public = 1 << 2;
    VarFlags$$1.Ambient = 1 << 3;
    VarFlags$$1.Static = 1 << 4;
    VarFlags$$1.LocalStatic = 1 << 5;
    VarFlags$$1.GetAccessor = 1 << 6;
    VarFlags$$1.SetAccessor = 1 << 7;
    VarFlags$$1.AutoInit = 1 << 8;
    VarFlags$$1.Property = 1 << 9;
    VarFlags$$1.Readonly = 1 << 10;
    VarFlags$$1.Class = 1 << 11;
    VarFlags$$1.ClassProperty = 1 << 12;
    VarFlags$$1.ClassBodyProperty = 1 << 13;
    VarFlags$$1.ClassConstructorProperty = 1 << 14;
    VarFlags$$1.ClassSuperMustBeFirstCallInConstructor = 1 << 15;
    VarFlags$$1.Constant = 1 << 16;
    VarFlags$$1.MustCaptureThis = 1 << 17;
    return;
  }
  function v40(SymbolFlags$$1) {
    SymbolFlags$$1._map = [];
    SymbolFlags$$1.None = 0;
    SymbolFlags$$1.Exported = 1;
    SymbolFlags$$1.Private = 1 << 1;
    SymbolFlags$$1.Public = 1 << 2;
    SymbolFlags$$1.Ambient = 1 << 3;
    SymbolFlags$$1.Static = 1 << 4;
    SymbolFlags$$1.LocalStatic = 1 << 5;
    SymbolFlags$$1.GetAccessor = 1 << 6;
    SymbolFlags$$1.SetAccessor = 1 << 7;
    SymbolFlags$$1.Property = 1 << 8;
    SymbolFlags$$1.Readonly = 1 << 9;
    SymbolFlags$$1.ModuleMember = 1 << 10;
    SymbolFlags$$1.InterfaceMember = 1 << 11;
    SymbolFlags$$1.ClassMember = 1 << 12;
    SymbolFlags$$1.BuiltIn = 1 << 13;
    SymbolFlags$$1.TypeSetDuringScopeAssignment = 1 << 14;
    SymbolFlags$$1.Constant = 1 << 15;
    SymbolFlags$$1.Optional = 1 << 16;
    SymbolFlags$$1.RecursivelyReferenced = 1 << 17;
    SymbolFlags$$1.Bound = 1 << 18;
    SymbolFlags$$1.CompilerGenerated = 1 << 19;
    return;
  }
  function v39(ModuleFlags$$1) {
    ModuleFlags$$1._map = [];
    ModuleFlags$$1.None = 0;
    ModuleFlags$$1.Exported = 1;
    ModuleFlags$$1.Private = 1 << 1;
    ModuleFlags$$1.Public = 1 << 2;
    ModuleFlags$$1.Ambient = 1 << 3;
    ModuleFlags$$1.Static = 1 << 4;
    ModuleFlags$$1.LocalStatic = 1 << 5;
    ModuleFlags$$1.GetAccessor = 1 << 6;
    ModuleFlags$$1.SetAccessor = 1 << 7;
    ModuleFlags$$1.IsEnum = 1 << 8;
    ModuleFlags$$1.ShouldEmitModuleDecl = 1 << 9;
    ModuleFlags$$1.IsWholeFile = 1 << 10;
    ModuleFlags$$1.IsDynamic = 1 << 11;
    ModuleFlags$$1.MustCaptureThis = 1 << 12;
    return;
  }
  function v38(DeclFlags$$1) {
    DeclFlags$$1._map = [];
    DeclFlags$$1.None = 0;
    DeclFlags$$1.Exported = 1;
    DeclFlags$$1.Private = 1 << 1;
    DeclFlags$$1.Public = 1 << 2;
    DeclFlags$$1.Ambient = 1 << 3;
    DeclFlags$$1.Static = 1 << 4;
    DeclFlags$$1.LocalStatic = 1 << 5;
    DeclFlags$$1.GetAccessor = 1 << 6;
    DeclFlags$$1.SetAccessor = 1 << 7;
    return;
  }
  function v37(ASTFlags$$1) {
    ASTFlags$$1._map = [];
    ASTFlags$$1.None = 0;
    ASTFlags$$1.ExplicitSemicolon = 1;
    ASTFlags$$1.AutomaticSemicolon = 1 << 1;
    ASTFlags$$1.Writeable = 1 << 2;
    ASTFlags$$1.Error = 1 << 3;
    ASTFlags$$1.DotLHSPartial = 1 << 4;
    ASTFlags$$1.DotLHS = 1 << 5;
    ASTFlags$$1.IsStatement = 1 << 6;
    ASTFlags$$1.StrictMode = 1 << 7;
    ASTFlags$$1.PossibleOptionalParameter = 1 << 8;
    ASTFlags$$1.ClassBaseConstructorCall = 1 << 9;
    ASTFlags$$1.OptionalName = 1 << 10;
    ASTFlags$$1.SkipNextRParen = 1 << 11;
    return;
  }
  function v36(Modifiers$$1) {
    Modifiers$$1._map = [];
    Modifiers$$1.None = 0;
    Modifiers$$1.Private = 1;
    Modifiers$$1.Public = 1 << 1;
    Modifiers$$1.Readonly = 1 << 2;
    Modifiers$$1.Ambient = 1 << 3;
    Modifiers$$1.Exported = 1 << 4;
    Modifiers$$1.Getter = 1 << 5;
    Modifiers$$1.Setter = 1 << 6;
    Modifiers$$1.Static = 1 << 7;
    return;
  }
  function v35(AllowedElements$$1) {
    AllowedElements$$1._map = [];
    AllowedElements$$1.None = 0;
    AllowedElements$$1.ModuleDeclarations = 1 << 2;
    AllowedElements$$1.ClassDeclarations = 1 << 3;
    AllowedElements$$1.InterfaceDeclarations = 1 << 4;
    AllowedElements$$1.AmbientDeclarations = 1 << 10;
    AllowedElements$$1.Properties = 1 << 11;
    var v22991 = AllowedElements$$1.ModuleDeclarations;
    var v22992 = AllowedElements$$1.ClassDeclarations;
    var v18715 = v22991 | v22992;
    var v18716 = AllowedElements$$1.InterfaceDeclarations;
    var v12175 = v18715 | v18716;
    var v12176 = AllowedElements$$1.AmbientDeclarations;
    AllowedElements$$1.Global = v12175 | v12176;
    var v12177 = AllowedElements$$1.Global;
    var v12178 = AllowedElements$$1.Properties;
    AllowedElements$$1.QuickParse = v12177 | v12178;
    return;
  }
  function v34(ErrorRecoverySet$$1) {
    ErrorRecoverySet$$1._map = [];
    ErrorRecoverySet$$1.None = 0;
    ErrorRecoverySet$$1.Comma = 1;
    ErrorRecoverySet$$1.SColon = 1 << 1;
    ErrorRecoverySet$$1.Asg = 1 << 2;
    ErrorRecoverySet$$1.BinOp = 1 << 3;
    ErrorRecoverySet$$1.RBrack = 1 << 4;
    ErrorRecoverySet$$1.RCurly = 1 << 5;
    ErrorRecoverySet$$1.RParen = 1 << 6;
    ErrorRecoverySet$$1.Dot = 1 << 7;
    ErrorRecoverySet$$1.Colon = 1 << 8;
    ErrorRecoverySet$$1.PrimType = 1 << 9;
    ErrorRecoverySet$$1.AddOp = 1 << 10;
    ErrorRecoverySet$$1.LCurly = 1 << 11;
    ErrorRecoverySet$$1.PreOp = 1 << 12;
    ErrorRecoverySet$$1.RegExp = 1 << 13;
    ErrorRecoverySet$$1.LParen = 1 << 14;
    ErrorRecoverySet$$1.LBrack = 1 << 15;
    ErrorRecoverySet$$1.Scope = 1 << 16;
    ErrorRecoverySet$$1.In = 1 << 17;
    ErrorRecoverySet$$1.SCase = 1 << 18;
    ErrorRecoverySet$$1.Else = 1 << 19;
    ErrorRecoverySet$$1.Catch = 1 << 20;
    ErrorRecoverySet$$1.Var = 1 << 21;
    ErrorRecoverySet$$1.Stmt = 1 << 22;
    ErrorRecoverySet$$1.While = 1 << 23;
    ErrorRecoverySet$$1.ID = 1 << 24;
    ErrorRecoverySet$$1.Prefix = 1 << 25;
    ErrorRecoverySet$$1.Literal = 1 << 26;
    ErrorRecoverySet$$1.RLit = 1 << 27;
    ErrorRecoverySet$$1.Func = 1 << 28;
    ErrorRecoverySet$$1.EOF = 1 << 29;
    ErrorRecoverySet$$1.TypeScriptS = 1 << 30;
    var v26758 = ErrorRecoverySet$$1.SColon;
    var v26759 = ErrorRecoverySet$$1.AddOp;
    var v26747 = v26758 | v26759;
    var v26748 = ErrorRecoverySet$$1.LCurly;
    var v26724 = v26747 | v26748;
    var v26725 = ErrorRecoverySet$$1.PreOp;
    var v26678 = v26724 | v26725;
    var v26679 = ErrorRecoverySet$$1.RegExp;
    var v26588 = v26678 | v26679;
    var v26589 = ErrorRecoverySet$$1.LParen;
    var v26408 = v26588 | v26589;
    var v26409 = ErrorRecoverySet$$1.LBrack;
    var v26014 = v26408 | v26409;
    var v26015 = ErrorRecoverySet$$1.ID;
    var v25122 = v26014 | v26015;
    var v25123 = ErrorRecoverySet$$1.Prefix;
    var v22993 = v25122 | v25123;
    var v22994 = ErrorRecoverySet$$1.RLit;
    var v18717 = v22993 | v22994;
    var v18718 = ErrorRecoverySet$$1.Func;
    var v12179 = v18717 | v18718;
    var v12180 = ErrorRecoverySet$$1.Literal;
    ErrorRecoverySet$$1.ExprStart = v12179 | v12180;
    var v26016 = ErrorRecoverySet$$1.ExprStart;
    var v26017 = ErrorRecoverySet$$1.SColon;
    var v25124 = v26016 | v26017;
    var v25125 = ErrorRecoverySet$$1.Var;
    var v22995 = v25124 | v25125;
    var v22996 = ErrorRecoverySet$$1.Stmt;
    var v18719 = v22995 | v22996;
    var v18720 = ErrorRecoverySet$$1.While;
    var v12181 = v18719 | v18720;
    var v12182 = ErrorRecoverySet$$1.TypeScriptS;
    ErrorRecoverySet$$1.StmtStart = v12181 | v12182;
    var v18721 = ErrorRecoverySet$$1.Dot;
    var v18722 = ErrorRecoverySet$$1.LParen;
    var v12183 = v18721 | v18722;
    var v12184 = ErrorRecoverySet$$1.LBrack;
    ErrorRecoverySet$$1.Postfix = v12183 | v12184;
    return;
  }
  function hasFlag(val, flag$$1) {
    var v12185 = val & flag$$1;
    return v12185 != 0;
  }
  function ToDeclFlags(fncOrVarOrSymbolOrModuleFlags) {
    return fncOrVarOrSymbolOrModuleFlags;
  }
  function flagsToString(e$$7, flags$$1) {
    var builder = "";
    var i$$8 = 1;
    var v18723 = 1 << 31;
    var v12189 = i$$8 < v18723;
    for (;v12189;) {
      var v18724 = flags$$1 & i$$8;
      var v12188 = v18724 != 0;
      if (v12188) {
        var k;
        for (k in e$$7) {
          var v18725 = e$$7[k];
          var v12187 = v18725 == i$$8;
          if (v12187) {
            var v18726 = builder.length;
            var v12186 = v18726 > 0;
            if (v12186) {
              builder = builder + "|";
            }
            builder = builder + k;
            break;
          }
        }
      }
      i$$8 = i$$8 << 1;
      var v18727 = 1 << 31;
      v12189 = i$$8 < v18727;
    }
    return builder;
  }
  TypeScript$$1.hasFlag = hasFlag;
  var v18728 = TypeScript$$1.ErrorRecoverySet;
  var v22997 = !v18728;
  if (v22997) {
    v18728 = TypeScript$$1.ErrorRecoverySet = {};
  }
  var v12190 = v18728;
  v34(v12190);
  var ErrorRecoverySet = TypeScript$$1.ErrorRecoverySet;
  var v18729 = TypeScript$$1.AllowedElements;
  var v22998 = !v18729;
  if (v22998) {
    v18729 = TypeScript$$1.AllowedElements = {};
  }
  var v12191 = v18729;
  v35(v12191);
  var AllowedElements = TypeScript$$1.AllowedElements;
  var v18730 = TypeScript$$1.Modifiers;
  var v22999 = !v18730;
  if (v22999) {
    v18730 = TypeScript$$1.Modifiers = {};
  }
  var v12192 = v18730;
  v36(v12192);
  var Modifiers = TypeScript$$1.Modifiers;
  var v18731 = TypeScript$$1.ASTFlags;
  var v23000 = !v18731;
  if (v23000) {
    v18731 = TypeScript$$1.ASTFlags = {};
  }
  var v12193 = v18731;
  v37(v12193);
  var ASTFlags = TypeScript$$1.ASTFlags;
  var v18732 = TypeScript$$1.DeclFlags;
  var v23001 = !v18732;
  if (v23001) {
    v18732 = TypeScript$$1.DeclFlags = {};
  }
  var v12194 = v18732;
  v38(v12194);
  var DeclFlags = TypeScript$$1.DeclFlags;
  var v18733 = TypeScript$$1.ModuleFlags;
  var v23002 = !v18733;
  if (v23002) {
    v18733 = TypeScript$$1.ModuleFlags = {};
  }
  var v12195 = v18733;
  v39(v12195);
  var ModuleFlags = TypeScript$$1.ModuleFlags;
  var v18734 = TypeScript$$1.SymbolFlags;
  var v23003 = !v18734;
  if (v23003) {
    v18734 = TypeScript$$1.SymbolFlags = {};
  }
  var v12196 = v18734;
  v40(v12196);
  var SymbolFlags = TypeScript$$1.SymbolFlags;
  var v18735 = TypeScript$$1.VarFlags;
  var v23004 = !v18735;
  if (v23004) {
    v18735 = TypeScript$$1.VarFlags = {};
  }
  var v12197 = v18735;
  v41(v12197);
  var VarFlags = TypeScript$$1.VarFlags;
  var v18736 = TypeScript$$1.FncFlags;
  var v23005 = !v18736;
  if (v23005) {
    v18736 = TypeScript$$1.FncFlags = {};
  }
  var v12198 = v18736;
  v42(v12198);
  var FncFlags = TypeScript$$1.FncFlags;
  var v18737 = TypeScript$$1.SignatureFlags;
  var v23006 = !v18737;
  if (v23006) {
    v18737 = TypeScript$$1.SignatureFlags = {};
  }
  var v12199 = v18737;
  v43(v12199);
  var SignatureFlags = TypeScript$$1.SignatureFlags;
  TypeScript$$1.ToDeclFlags = ToDeclFlags;
  var v18738 = TypeScript$$1.TypeFlags;
  var v23007 = !v18738;
  if (v23007) {
    v18738 = TypeScript$$1.TypeFlags = {};
  }
  var v12200 = v18738;
  v44(v12200);
  var TypeFlags = TypeScript$$1.TypeFlags;
  var v18739 = TypeScript$$1.TypeRelationshipFlags;
  var v23008 = !v18739;
  if (v23008) {
    v18739 = TypeScript$$1.TypeRelationshipFlags = {};
  }
  var v12201 = v18739;
  v45(v12201);
  var TypeRelationshipFlags = TypeScript$$1.TypeRelationshipFlags;
  var v18740 = TypeScript$$1.CodeGenTarget;
  var v23009 = !v18740;
  if (v23009) {
    v18740 = TypeScript$$1.CodeGenTarget = {};
  }
  var v12202 = v18740;
  v46(v12202);
  var CodeGenTarget = TypeScript$$1.CodeGenTarget;
  var v18741 = TypeScript$$1.ModuleGenTarget;
  var v23010 = !v18741;
  if (v23010) {
    v18741 = TypeScript$$1.ModuleGenTarget = {};
  }
  var v12203 = v18741;
  v47(v12203);
  var ModuleGenTarget = TypeScript$$1.ModuleGenTarget;
  TypeScript$$1.codeGenTarget = CodeGenTarget.ES3;
  TypeScript$$1.moduleGenTarget = ModuleGenTarget.Synchronous;
  TypeScript$$1.optimizeModuleCodeGen = true;
  TypeScript$$1.flagsToString = flagsToString;
  return;
}
function v33(s$$8) {
  var i$$7 = 0;
  var v18742 = s$$8.length;
  var v12205 = i$$7 < v18742;
  for (;v12205;) {
    var c$$1 = s$$8.charCodeAt(i$$7);
    var v18743 = this.cumulative_checksum;
    var v12204 = v18743 << 1;
    this.cumulative_checksum = v12204 ^ c$$1;
    i$$7 = i$$7 + 1;
    var v18744 = s$$8.length;
    v12205 = i$$7 < v18744;
  }
  return;
}
function v32() {
  var v18745 = this.checksum;
  var v18746 = this.cumulative_checksum;
  var v12206 = v18745 != v18746;
  if (v12206) {
    throw new Error("Wrong checksum.");
  }
  this.cumulative_checksum = 0;
  return;
}
function v31(s$$7) {
  var v12207 = s$$7 + "\n";
  this.Verify(v12207);
  return;
}
function v30(s$$6) {
  this.Verify(s$$6);
  return;
}
function v29(s$$5) {
  var i$$6 = 0;
  var v18747 = s$$5.length;
  var v12209 = i$$6 < v18747;
  for (;v12209;) {
    var c = s$$5.charCodeAt(i$$6);
    var v18748 = this.cumulative_checksum;
    var v12208 = v18748 << 1;
    this.cumulative_checksum = v12208 ^ c;
    i$$6 = i$$6 + 1;
    var v18749 = s$$5.length;
    v12209 = i$$6 < v18749;
  }
  return;
}
function v28() {
  var v18750 = this.checksum;
  var v18751 = this.cumulative_checksum;
  var v12210 = v18750 != v18751;
  if (v12210) {
    throw new Error("Wrong checksum.");
  }
  this.cumulative_checksum = 0;
  return;
}
function v27(s$$4) {
  var v12211 = s$$4 + "\n";
  this.Verify(v12211);
  return;
}
function v26(s$$3) {
  this.Verify(s$$3);
  return;
}
function v25(runner$$2) {
  function RunNextSetup() {
    var v12213 = index$$40 < length$$12;
    if (v12213) {
      try {
        var v18752 = suite$$1.benchmarks;
        var v12212 = v18752[index$$40];
        v12212.Setup();
      } catch (e$$4) {
        suite$$1.NotifyError(e$$4);
        return null;
      }
      return RunNextBenchmark;
    }
    suite$$1.NotifyResult();
    return null;
  }
  function RunNextBenchmark() {
    try {
      var v18753 = suite$$1.benchmarks;
      var v12214 = v18753[index$$40];
      data$$20 = suite$$1.RunSingleBenchmark(v12214, data$$20);
    } catch (e$$5) {
      suite$$1.NotifyError(e$$5);
      return null;
    }
    var v12215;
    var v18754 = data$$20 == null;
    if (v18754) {
      v12215 = RunNextTearDown;
    } else {
      v12215 = RunNextBenchmark();
    }
    return v12215;
  }
  function RunNextTearDown() {
    try {
      var v18755 = suite$$1.benchmarks;
      var v18756 = index$$40;
      index$$40 = index$$40 + 1;
      var v12216 = v18755[v18756];
      v12216.TearDown();
    } catch (e$$6) {
      suite$$1.NotifyError(e$$6);
      return null;
    }
    return RunNextSetup;
  }
  BenchmarkSuite.ResetRNG();
  this.results = [];
  this.runner = runner$$2;
  var v12217 = this.benchmarks;
  var length$$12 = v12217.length;
  var index$$40 = 0;
  var suite$$1 = this;
  var data$$20;
  return RunNextSetup();
}
function v24(benchmark$$1, data$$18) {
  function Measure(data$$19) {
    var elapsed = 0;
    var start$$4 = new Date;
    var i$$5 = 0;
    var v18757;
    if (doDeterministic$$1) {
      var v23011 = benchmark$$1.deterministicIterations;
      v18757 = i$$5 < v23011;
    } else {
      v18757 = elapsed < 1E3;
    }
    var v12219 = v18757;
    for (;v12219;) {
      benchmark$$1.run();
      var v12218 = new Date;
      elapsed = v12218 - start$$4;
      i$$5 = i$$5 + 1;
      var v18758;
      if (doDeterministic$$1) {
        var v23012 = benchmark$$1.deterministicIterations;
        v18758 = i$$5 < v23012;
      } else {
        v18758 = elapsed < 1E3;
      }
      v12219 = v18758;
    }
    var v12220 = data$$19 != null;
    if (v12220) {
      var v18759 = data$$19.runs;
      data$$19.runs = v18759 + i$$5;
      var v18760 = data$$19.elapsed;
      data$$19.elapsed = v18760 + elapsed;
    }
    return;
  }
  var config = BenchmarkSuite.config;
  var v12221;
  var v23013 = config.doWarmup;
  var v18761 = v23013 !== undefined;
  if (v18761) {
    v12221 = config.doWarmup;
  } else {
    v12221 = benchmark$$1.doWarmup;
  }
  var doWarmup$$1 = v12221;
  var v12222;
  var v23014 = config.doDeterministic;
  var v18762 = v23014 !== undefined;
  if (v18762) {
    v12222 = config.doDeterministic;
  } else {
    v12222 = benchmark$$1.doDeterministic;
  }
  var doDeterministic$$1 = v12222;
  var v18763 = !doWarmup$$1;
  if (v18763) {
    v18763 = data$$18 == null;
  }
  var v12223 = v18763;
  if (v12223) {
    data$$18 = {runs:0, elapsed:0};
  }
  var v12229 = data$$18 == null;
  if (v12229) {
    Measure(null);
    return{runs:0, elapsed:0};
  } else {
    Measure(data$$18);
    var v18764 = data$$18.runs;
    var v18765 = benchmark$$1.minIterations;
    var v12224 = v18764 < v18765;
    if (v12224) {
      return data$$18;
    }
    var v18766 = data$$18.elapsed;
    var v12225 = v18766 * 1E3;
    var v12226 = data$$18.runs;
    var usec = v12225 / v12226;
    var v12227;
    var v23015 = benchmark$$1.rmsResult;
    var v18767 = v23015 != null;
    if (v18767) {
      v12227 = benchmark$$1.rmsResult();
    } else {
      v12227 = 0;
    }
    var rms = v12227;
    var v12228 = new BenchmarkResult(benchmark$$1, usec, rms);
    this.NotifyStep(v12228);
    return null;
  }
  return;
}
function v23(error$$1) {
  var v18768 = this.runner;
  var v12232 = v18768.NotifyError;
  if (v12232) {
    var v12230 = this.runner;
    var v12231 = this.name;
    v12230.NotifyError(v12231, error$$1);
  }
  var v18769 = this.runner;
  var v12235 = v18769.NotifyStep;
  if (v12235) {
    var v12233 = this.runner;
    var v12234 = this.name;
    v12233.NotifyStep(v12234);
  }
  return;
}
function v22(runner$$1) {
  var v12236 = BenchmarkSuite.scores;
  v12236.push(1);
  var v12238 = runner$$1.NotifyResult;
  if (v12238) {
    var v12237 = this.name;
    runner$$1.NotifyResult(v12237, "Skipped");
  }
  return;
}
function v21() {
  var v12239 = this.results;
  var mean = BenchmarkSuite.GeometricMeanTime(v12239);
  var v18770 = this.reference;
  var v12240 = v18770[0];
  var score$$1 = v12240 / mean;
  var v12241 = BenchmarkSuite.scores;
  v12241.push(score$$1);
  var v18771 = this.runner;
  var v12245 = v18771.NotifyResult;
  if (v12245) {
    var v12242 = 100 * score$$1;
    var formatted$$1 = BenchmarkSuite.FormatScore(v12242);
    var v12243 = this.runner;
    var v12244 = this.name;
    v12243.NotifyResult(v12244, formatted$$1);
  }
  var v23016 = this.reference;
  var v18772 = v23016.length;
  var v12254 = v18772 == 2;
  if (v12254) {
    var v12246 = this.results;
    var meanLatency = BenchmarkSuite.GeometricMeanLatency(v12246);
    var v12253 = meanLatency != 0;
    if (v12253) {
      var v18773 = this.reference;
      var v12247 = v18773[1];
      var scoreLatency = v12247 / meanLatency;
      var v12248 = BenchmarkSuite.scores;
      v12248.push(scoreLatency);
      var v18774 = this.runner;
      var v12252 = v18774.NotifyResult;
      if (v12252) {
        var v12249 = 100 * scoreLatency;
        var formattedLatency = BenchmarkSuite.FormatScore(v12249);
        var v12250 = this.runner;
        var v18775 = this.name;
        var v12251 = v18775 + "Latency";
        v12250.NotifyResult(v12251, formattedLatency);
      }
    }
  }
  return;
}
function v20(result$$1) {
  var v12255 = this.results;
  v12255.push(result$$1);
  var v18776 = this.runner;
  var v12258 = v18776.NotifyStep;
  if (v12258) {
    var v12256 = this.runner;
    var v18777 = result$$1.benchmark;
    var v12257 = v18777.name;
    v12256.NotifyStep(v12257);
  }
  return;
}
function v19(value$$27) {
  var v12259 = value$$27 > 100;
  if (v12259) {
    return value$$27.toFixed(0);
  } else {
    return value$$27.toPrecision(3);
  }
  return;
}
function v18(measurements$$1) {
  var log$$2 = 0;
  var hasLatencyResult = false;
  var i$$4 = 0;
  var v18778 = measurements$$1.length;
  var v12261 = i$$4 < v18778;
  for (;v12261;) {
    var v23017 = measurements$$1[i$$4];
    var v18779 = v23017.latency;
    var v12260 = v18779 != 0;
    if (v12260) {
      var v18780 = log$$2;
      var v25126 = measurements$$1[i$$4];
      var v23018 = v25126.latency;
      var v18781 = Math.log(v23018);
      log$$2 = v18780 + v18781;
      hasLatencyResult = true;
    }
    i$$4 = i$$4 + 1;
    var v18782 = measurements$$1.length;
    v12261 = i$$4 < v18782;
  }
  if (hasLatencyResult) {
    var v12262 = Math.E;
    var v18783 = measurements$$1.length;
    var v12263 = log$$2 / v18783;
    return Math.pow(v12262, v12263);
  } else {
    return 0;
  }
  return;
}
function v17(measurements) {
  var log$$1 = 0;
  var i$$3 = 0;
  var v18784 = measurements.length;
  var v12264 = i$$3 < v18784;
  for (;v12264;) {
    var v18785 = log$$1;
    var v25127 = measurements[i$$3];
    var v23019 = v25127.time;
    var v18786 = Math.log(v23019);
    log$$1 = v18785 + v18786;
    i$$3 = i$$3 + 1;
    var v18787 = measurements.length;
    v12264 = i$$3 < v18787;
  }
  var v12265 = Math.E;
  var v18788 = measurements.length;
  var v12266 = log$$1 / v18788;
  return Math.pow(v12265, v12266);
}
function v16(numbers) {
  var log = 0;
  var i$$2 = 0;
  var v18789 = numbers.length;
  var v12267 = i$$2 < v18789;
  for (;v12267;) {
    var v18790 = log;
    var v23020 = numbers[i$$2];
    var v18791 = Math.log(v23020);
    log = v18790 + v18791;
    i$$2 = i$$2 + 1;
    var v18792 = numbers.length;
    v12267 = i$$2 < v18792;
  }
  var v12268 = Math.E;
  var v18793 = numbers.length;
  var v12269 = log / v18793;
  return Math.pow(v12268, v12269);
}
function v15() {
  var result = 0;
  var suites$$1 = BenchmarkSuite.suites;
  var i$$1 = 0;
  var v18794 = suites$$1.length;
  var v12270 = i$$1 < v18794;
  for (;v12270;) {
    var v25128 = suites$$1[i$$1];
    var v23021 = v25128.benchmarks;
    var v18795 = v23021.length;
    result = result + v18795;
    i$$1 = i$$1 + 1;
    var v18796 = suites$$1.length;
    v12270 = i$$1 < v18796;
  }
  return result;
}
function v14(runner, skipBenchmarks$$1) {
  function RunStep() {
    var v18797 = continuation;
    var v23022 = !v18797;
    if (v23022) {
      v18797 = index$$39 < length$$11;
    }
    var v12276 = v18797;
    for (;v12276;) {
      if (continuation) {
        continuation = continuation();
      } else {
        var v12271 = index$$39;
        index$$39 = index$$39 + 1;
        var suite = suites[v12271];
        var v12273 = runner.NotifyStart;
        if (v12273) {
          var v12272 = suite.name;
          runner.NotifyStart(v12272);
        }
        var v23023 = suite.name;
        var v18798 = skipBenchmarks$$1.indexOf(v23023);
        var v12274 = v18798 > -1;
        if (v12274) {
          suite.NotifySkipped(runner);
        } else {
          continuation = suite.RunStep(runner);
        }
      }
      var v23024 = continuation;
      if (v23024) {
        var v25129 = typeof window;
        v23024 = v25129 != "undefined";
      }
      var v18799 = v23024;
      if (v18799) {
        v18799 = window.setTimeout;
      }
      var v12275 = v18799;
      if (v12275) {
        window.setTimeout(RunStep, 25);
        return;
      }
      var v18800 = continuation;
      var v23025 = !v18800;
      if (v23025) {
        v18800 = index$$39 < length$$11;
      }
      v12276 = v18800;
    }
    var v12279 = runner.NotifyScore;
    if (v12279) {
      var v12277 = BenchmarkSuite.scores;
      var score = BenchmarkSuite.GeometricMean(v12277);
      var v12278 = 100 * score;
      var formatted = BenchmarkSuite.FormatScore(v12278);
      runner.NotifyScore(formatted);
    }
    return;
  }
  var v12280;
  var v23026 = typeof skipBenchmarks$$1;
  var v18801 = v23026 === "undefined";
  if (v18801) {
    v12280 = [];
  } else {
    v12280 = skipBenchmarks$$1;
  }
  skipBenchmarks$$1 = v12280;
  var continuation = null;
  var suites = BenchmarkSuite.suites;
  var length$$11 = suites.length;
  BenchmarkSuite.scores = [];
  var index$$39 = 0;
  RunStep();
  return;
}
function v13() {
  function v12() {
    function v11() {
      var v18802 = seed + 2127912214;
      var v18803 = seed << 12;
      var v12281 = v18802 + v18803;
      seed = v12281 & 4294967295;
      var v18804 = seed ^ 3345072700;
      var v18805 = seed >>> 19;
      var v12282 = v18804 ^ v18805;
      seed = v12282 & 4294967295;
      var v18806 = seed + 374761393;
      var v18807 = seed << 5;
      var v12283 = v18806 + v18807;
      seed = v12283 & 4294967295;
      var v18808 = seed + 3550635116;
      var v18809 = seed << 9;
      var v12284 = v18808 ^ v18809;
      seed = v12284 & 4294967295;
      var v18810 = seed + 4251993797;
      var v18811 = seed << 3;
      var v12285 = v18810 + v18811;
      seed = v12285 & 4294967295;
      var v18812 = seed ^ 3042594569;
      var v18813 = seed >>> 16;
      var v12286 = v18812 ^ v18813;
      seed = v12286 & 4294967295;
      var v12287 = seed & 268435455;
      return v12287 / 268435456;
    }
    var seed = 49734321;
    return v11;
  }
  var v12288 = Math;
  var v27438 = v12();
  v12288.random = v27438;
  return;
}
function v10(s$$2) {
  throw "Alert called with argument: " + s$$2;
}
function v9() {
  return this.time;
}
function v8() {
  var v26018 = performance.now;
  var v26410 = !v26018;
  if (v26410) {
    v26018 = performance.mozNow;
  }
  var v25130 = v26018;
  var v26019 = !v25130;
  if (v26019) {
    v25130 = performance.msNow;
  }
  var v23027 = v25130;
  var v25131 = !v23027;
  if (v25131) {
    v23027 = performance.oNow;
  }
  var v18814 = v23027;
  var v23028 = !v18814;
  if (v23028) {
    v18814 = performance.webkitNow;
  }
  var v12289 = v18814;
  var v18815 = !v12289;
  if (v18815) {
    v12289 = Date.now;
  }
  return v12289;
}
function Benchmark(name$$30, doWarmup, doDeterministic, deterministicIterations, run, setup, tearDown, rmsResult, minIterations) {
  function v1() {
    return;
  }
  function v0() {
    return;
  }
  this.name = name$$30;
  this.doWarmup = doWarmup;
  this.doDeterministic = doDeterministic;
  this.deterministicIterations = deterministicIterations;
  this.run = run;
  var v12290;
  if (setup) {
    v12290 = setup;
  } else {
    v12290 = v0;
  }
  this.Setup = v12290;
  var v12291;
  if (tearDown) {
    v12291 = tearDown;
  } else {
    v12291 = v1;
  }
  this.TearDown = v12291;
  var v12292;
  if (rmsResult) {
    v12292 = rmsResult;
  } else {
    v12292 = null;
  }
  this.rmsResult = v12292;
  var v12293;
  if (minIterations) {
    v12293 = minIterations;
  } else {
    v12293 = 32;
  }
  this.minIterations = v12293;
  return;
}
function BenchmarkResult(benchmark, time, latency) {
  this.benchmark = benchmark;
  this.time = time;
  this.latency = latency;
  return;
}
function BenchmarkSuite(name$$31, reference, benchmarks$$1) {
  this.name = name$$31;
  this.reference = reference;
  this.benchmarks = benchmarks$$1;
  var v12294 = BenchmarkSuite.suites;
  v12294.push(this);
  return;
}
function setupTypescript() {
  return;
}
function tearDownTypescript() {
  compiler_input = null;
  return;
}
function runTypescript() {
  function v5(path$$2) {
    return path$$2;
  }
  function v4(path$$1) {
    return false;
  }
  function v3(path) {
    return false;
  }
  function v2(fileName) {
    return outfile;
  }
  var compiler = createCompiler();
  compiler.addUnit(compiler_input, "compiler_input.ts");
  parseErrors = [];
  compiler.reTypeCheck();
  var v12295 = {createFile:v2, fileExists:v3, directoryExists:v4, resolvePath:v5};
  compiler.emit(v12295);
  var v23029 = parseErrors.length;
  var v18816 = v23029 != 192;
  if (v18816) {
    var v23030 = parseErrors.length;
    v18816 = v23030 != 193;
  }
  var v12296 = v18816;
  if (v12296) {
    throw new Error("Parse errors.");
  }
  compiler = null;
  return;
}
function createCompiler() {
  function v6(start$$5, len, message$$9) {
    var v12297 = {start:start$$5, len:len, message:message$$9};
    parseErrors.push(v12297);
    return;
  }
  var v12298 = TypeScript.CompilationSettings;
  var settings = new v12298;
  var v12299 = TypeScript.CodeGenTarget;
  settings.codeGenTarget = v12299.ES5;
  var v12300 = TypeScript.TypeScriptCompiler;
  var v18817 = TypeScript.NullLogger;
  var v12301 = new v18817;
  var compiler$$1 = new v12300(outerr, v12301, settings);
  compiler$$1.setErrorCallback(v6);
  var v12302 = compiler$$1.parser;
  v12302.errorRecovery = true;
  compiler$$1.typeCheck();
  return compiler$$1;
}
function ShowBox(name$$92) {
  function v7(entry$$3) {
    var v18818 = name$$92.valueOf();
    var v18819 = entry$$3.valueOf();
    var v12305 = v18818 === v18819;
    if (v12305) {
      var v18820 = "Box-" + name$$92;
      var v12303 = v18820 + "Latency";
      var box1 = document.getElementById(v12303);
      var v12304 = box1.style;
      v12304.visibility = "visible";
    }
    return;
  }
  var v12306 = "Box-" + name$$92;
  var box = document.getElementById(v12306);
  var v12307 = box.style;
  v12307.visibility = "visible";
  var v18821 = document.getElementById("progress-bar");
  var v12308 = v18821.style;
  var v26020 = completed = completed + 1;
  var v25132 = v26020 / benchmarks;
  var v23031 = v25132 * 100;
  var v18822 = "" + v23031;
  var bar = v12308.width = v18822 + "%";
  latencyBenchmarks.forEach(v7);
  return;
}
function AddResult(name$$93, result$$41) {
  var v18823 = name$$93 + ": ";
  var v12309 = v18823 + result$$41;
  console.log(v12309);
  var v12310 = "Result-" + name$$93;
  var box$$1 = document.getElementById(v12310);
  box$$1.innerHTML = result$$41;
  return;
}
function AddError(name$$94, error$$3) {
  var v18824 = name$$94 + ": ";
  var v18825 = error$$3.message;
  var v12311 = v18824 + v18825;
  console.log(v12311);
  var v12313 = error$$3 == "TypedArrayUnsupported";
  if (v12313) {
    AddResult(name$$94, "<b>Unsupported</b>");
  } else {
    var v12312 = error$$3 == "PerformanceNowUnsupported";
    if (v12312) {
      AddResult(name$$94, "<b>Timer error</b>");
    } else {
      AddResult(name$$94, "<b>Error</b>");
    }
  }
  success = false;
  return;
}
function AddScore(score$$2) {
  var status$$1 = document.getElementById("main-banner");
  if (success) {
    status$$1.innerHTML = "Octane Score: " + score$$2;
  } else {
    status$$1.innerHTML = "Octane Score (incomplete): " + score$$2;
  }
  var v18826 = document.getElementById("progress-bar-container");
  var v12314 = v18826.style;
  v12314.visibility = "hidden";
  var v18827 = document.getElementById("bottom-text");
  var v12315 = v18827.style;
  v12315.visibility = "visible";
  var v12316 = document.getElementById("inside-anchor");
  var v12317 = document.getElementById("bar-appendix");
  v12316.removeChild(v12317);
  var v18828 = document.getElementById("alertbox");
  var v12318 = v18828.style;
  v12318.visibility = "hidden";
  return;
}
function Run() {
  var v12319 = document.getElementById("main-banner");
  v12319.innerHTML = "Running Octane...";
  var v12320 = document.getElementById("bar-appendix");
  v12320.innerHTML = '<br/><div class="progress progress-striped" id="progress-bar-container" style="visibility:hidden"><div class="bar"style="width: 0%;" id="progress-bar"></div></div>';
  var anchor = document.getElementById("run-octane");
  var parent$$73 = document.getElementById("main-container");
  var v12321 = document.getElementById("inside-anchor");
  parent$$73.appendChild(v12321);
  parent$$73.removeChild(anchor);
  var v12322 = document.getElementById("startup-text");
  v12322.innerHTML = "";
  var v18829 = document.getElementById("progress-bar-container");
  var v12323 = v18829.style;
  v12323.visibility = "visible";
  var v12324 = {NotifyStart:ShowBox, NotifyError:AddError, NotifyResult:AddResult, NotifyScore:AddScore};
  BenchmarkSuite.RunSuites(v12324, skipBenchmarks);
  return;
}
function CheckCompatibility() {
  var v23032 = typeof Uint8Array;
  var v18830 = v23032 != "undefined";
  if (v18830) {
    var v23033 = typeof Float64Array;
    v18830 = v23033 != "undefined";
  }
  var v12325 = v18830;
  if (v12325) {
    var v25133 = new Uint8Array(0);
    var v23034 = v25133.subarray;
    var v18831 = typeof v23034;
    v12325 = v18831 != "undefined";
  }
  var hasTypedArrays = v12325;
  var v12327 = !hasTypedArrays;
  if (v12327) {
    console.log("Typed Arrays not supported");
    var v18832 = document.getElementById("alertbox");
    var v12326 = v18832.style;
    v12326.display = "block";
  }
  var v25134 = window.document;
  var v23035 = v25134.URL;
  var v18833 = v23035.indexOf("skip_zlib=1");
  var v12328 = v18833 >= 0;
  if (v12328) {
    skipBenchmarks.push("zlib");
  }
  var v25135 = window.document;
  var v23036 = v25135.URL;
  var v18834 = v23036.indexOf("auto=1");
  var v12329 = v18834 >= 0;
  if (v12329) {
    Run();
  }
  return;
}
function Load() {
  setTimeout(CheckCompatibility, 200);
  return;
}
var performance = performance || {};
var v12330 = performance;
var v27439 = v8();
v12330.now = v27439;
var v12331 = BenchmarkResult.prototype;
v12331.valueOf = v9;
BenchmarkSuite.suites = [];
BenchmarkSuite.version = "9";
BenchmarkSuite.config = {doWarmup:undefined, doDeterministic:undefined};
alert = v10;
BenchmarkSuite.ResetRNG = v13;
BenchmarkSuite.RunSuites = v14;
BenchmarkSuite.CountBenchmarks = v15;
BenchmarkSuite.GeometricMean = v16;
BenchmarkSuite.GeometricMeanTime = v17;
BenchmarkSuite.GeometricMeanLatency = v18;
BenchmarkSuite.FormatScore = v19;
var v12332 = BenchmarkSuite.prototype;
v12332.NotifyStep = v20;
var v12333 = BenchmarkSuite.prototype;
v12333.NotifyResult = v21;
var v12334 = BenchmarkSuite.prototype;
v12334.NotifySkipped = v22;
var v12335 = BenchmarkSuite.prototype;
v12335.NotifyError = v23;
var v12336 = BenchmarkSuite.prototype;
v12336.RunSingleBenchmark = v24;
var v12337 = BenchmarkSuite.prototype;
v12337.RunStep = v25;
var v12338 = [255011322];
var v18835 = new Benchmark("Typescript", false, true, 5, runTypescript, setupTypescript, tearDownTypescript, null, 1);
var v12339 = [v18835];
var typescript = new BenchmarkSuite("Typescript", v12338, v12339);
var parseErrors = [];
var outfile = {checksum:-412589664, cumulative_checksum:0, Write:v26, WriteLine:v27, Close:v28, Verify:v29};
var outerr = {checksum:0, cumulative_checksum:0, Write:v30, WriteLine:v31, Close:v32, Verify:v33};
var v27691 = '//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nmodule TypeScript {\n    export class AstLogger {\n\n        constructor (public logger: ILogger) { }\n\n        public logScript(script: TypeScript.Script): void {\n            this.logLinemap(script.locationInfo.lineMap);\n\n            var stack: AST[]= [];\n\n            var pre = (cur: TypeScript.AST, parent: TypeScript.AST) => {\n                stack.push(cur);\n                var indent = (stack.length - 1) * 2;\n                this.logComments(script, cur.preComments, indent);\n                this.logNode(script, cur, indent);\n                this.logComments(script, cur.postComments, indent);\n                return cur;\n            }\n\n            var post = (cur: TypeScript.AST, parent: TypeScript.AST) => {\n                stack.pop();\n                return cur;\n            }\n\n            TypeScript.getAstWalkerFactory().walk(script, pre, post);\n        }\n\n\n        public logNode(script: TypeScript.Script, cur: TypeScript.AST, indent: number) {\n            var msg = this.addPadding("", indent, "| ", true);\n\n            msg = msg.concat("+ " + cur.treeViewLabel());\n            msg = this.addPadding(msg, 70, " ", false);\n\n            msg = msg + this.addLineColumn(script, cur.minChar);\n            msg = this.addPadding(msg, 80, " ", false);\n\n            msg = msg + "=> ";\n            msg = msg + this.addLineColumn(script, cur.limChar);\n            msg = this.addPadding(msg, 102, " ", false);\n\n            msg = msg.concat("[" + this.addPadding(cur.minChar.toString(), 1, " ", true) + ", " + this.addPadding(cur.limChar.toString(), 1, " ", true) + "]");\n\n            msg = this.addPadding(msg, 115, " ", false);\n            msg = msg.concat("sym=" + (<any>cur).sym);\n\n            msg = this.addPadding(msg, 135, " ", false);\n            msg = msg.concat("type=" + (cur.type === null ? "null" : cur.type.getTypeName()));\n            this.logger.log(msg);\n        }\n\n        private logComments(script: TypeScript.Script, comments: TypeScript.AST[], indent: number) {\n            if (comments == null)\n                return;\n\n            for (var i = 0; i < comments.length; i++) {\n                this.logNode(script, comments[i], indent);\n            }\n        }\n\n        public logLinemap(linemap: number[]) {\n            var result = "[";\n            for (var i = 0; i < linemap.length; i++) {\n                if (i > 0)\n                    result += ",";\n                result += linemap[i];\n            }\n            result += "]";\n            this.logger.log("linemap: " + result);\n        }\n\n        private addPadding(s: string, targetLength: number, paddingString: string, leftPadding: bool): string {\n            var result = (leftPadding ? "" : s);\n            for (var i = s.length; i < targetLength; i++) {\n                result = result + paddingString;\n            }\n            result = result + (leftPadding ? s : "");\n            return result;\n        }\n\n        private addLineColumn(script: TypeScript.Script, position: numbe' + 
'r): string {\n            // just for calling getSourceLineColFromMap\n            var lineInfo = {\n                line: -1,\n                col: -1\n            }\n            TypeScript.getSourceLineColFromMap(lineInfo, position, script.locationInfo.lineMap);\n\n            if (lineInfo.col !== -1) {\n                lineInfo.col++; //TODO: function above seems to consider line as 1-based, and column as 0-based\n            }\n\n            return "(" + lineInfo.line + ", " + lineInfo.col + ")";\n        }\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export function lastOf(items: any[]): any {\n        return (items === null || items.length === 0) ? null : items[items.length - 1];\n    }\n\n    export function max(a: number, b: number): number {\n        return a >= b ? a : b;\n    }\n\n    export function min(a: number, b: number): number {\n        return a <= b ? a : b;\n    }\n\n    //\n    // Helper class representing a path from a root ast node to a (grand)child ast node.\n    // This is helpful as our tree don\'t have parents.\n    //\n    export class AstPath {\n        public asts: TypeScript.AST[] = [];\n        public top: number = -1;\n\n        static reverseIndexOf(items: any[], index: number): any {\n            return (items === null || items.length <= index) ? null : items[items.length - index - 1];\n        }\n\n        public clone(): AstPath {\n            var clone = new AstPath();\n            clone.asts = this.asts.map((value) => { return value; });\n            clone.top = this.top;\n            return clone;\n        }\n\n        public pop(): TypeScript.AST {\n            var head = this.ast();\n            this.up();\n\n            while (this.asts.length > this.count()) {\n                this.asts.pop();\n            }\n            return head;\n        }\n\n        public push(ast: TypeScript.AST) {\n            while (this.asts.length > this.count()) {\n                this.asts.pop();\n            }\n            this.top = this.asts.length;\n            this.asts.push(ast);\n        }\n\n        public up() {\n            if (this.top <= -1)\n                throw new Error("Invalid call to \'up\'");\n            this.top--;\n        }\n\n        public down() {\n            if (this.top == this.ast.length - 1)\n                throw new Error("Invalid call to \'down\'");\n            this.top++;\n        }\n\n        public nodeType(): TypeScript.NodeType {\n            if (this.ast() == null)\n                return TypeScript.NodeType.None;\n            return this.ast().nodeType;\n        }\n\n        public ast() {\n            return <TypeScript.AST>AstPath.reverseIndexOf(this.asts, this.asts.length - (this.top + 1));\n        }\n\n        public parent() {\n            return <TypeScript.AST>AstPath.reverseIndexOf(this.asts, this.asts.length - this.top);\n        }\n\n        public count() {\n            return this.top + 1;\n        }\n\n        public get(index: number): TypeScript.AST {\n            return this.asts[index];\n        }\n\n        public isNameOfClass(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === TypeScript.NodeType.Name) &&\n                (this.parent().nodeType === TypeScript.NodeType.ClassDeclaration) &&\n                ((<TypeScript.InterfaceDeclaration>this.parent()).name === this.ast());\n        }\n\n        public isNameOfInterface(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === TypeScript.NodeType.Name) &&\n                (this.parent().nodeType === TypeScript.NodeType.InterfaceDeclaration) &&\n                ((<TypeScript.InterfaceDeclaration>this.parent()).name === this.ast());\n        }\n\n        public isNameOfArgument(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === TypeScript.NodeType.Name) &&\n                (this.parent().nodeType === TypeScript.NodeType.ArgDecl) &&\n                ((<TypeScript.ArgDecl>this.parent()).id === this.ast());\n        }\n\n        public isNameOfVariable(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === TypeScript.NodeType.Name) &&\n                (this.parent().nodeType === Ty';
var v27690 = v27691 + "peScript.NodeType.VarDecl) &&\n                ((<TypeScript.VarDecl>this.parent()).id === this.ast());\n        }\n\n        public isNameOfModule(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === TypeScript.NodeType.Name) &&\n                (this.parent().nodeType === TypeScript.NodeType.ModuleDeclaration) &&\n                ((<TypeScript.ModuleDeclaration>this.parent()).name === this.ast());\n        }\n\n        public isNameOfFunction(): bool {\n            if (this.ast() === null || this.parent() === null)\n                return false;\n\n            return (this.ast().nodeType === TypeScript.NodeType.Name) &&\n                (this.parent().nodeType === TypeScript.NodeType.FuncDecl) &&\n                ((<TypeScript.FuncDecl>this.parent()).name === this.ast());\n        }\n\n        public isChildOfScript(): bool {\n            var ast = lastOf(this.asts);\n            return this.count() >= 3 &&\n                this.asts[this.top] === ast &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.Script;\n        }\n\n        public isChildOfModule(): bool {\n            var ast = lastOf(this.asts);\n            return this.count() >= 3 &&\n                this.asts[this.top] === ast &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.ModuleDeclaration;\n        }\n\n        public isChildOfClass(): bool {\n            var ast = lastOf(this.asts);\n            return this.count() >= 3 &&\n                this.asts[this.top] === ast &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.ClassDeclaration;\n        }\n\n        public isArgumentOfClassConstructor(): bool {\n            var ast = lastOf(this.asts);\n            return this.count() >= 5 &&\n                this.asts[this.top] === ast &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.FuncDecl &&\n                this.asts[this.top - 3].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 4].nodeType === TypeScript.NodeType.ClassDeclaration &&\n                ((<TypeScript.FuncDecl>this.asts[this.top - 2]).isConstructor) &&\n                ((<TypeScript.FuncDecl>this.asts[this.top - 2]).arguments === this.asts[this.top - 1]) &&\n                ((<TypeScript.ClassDeclaration>this.asts[this.top - 4]).constructorDecl === this.asts[this.top - 2]);\n        }\n\n        public isChildOfInterface(): bool {\n            var ast = lastOf(this.asts);\n            return this.count() >= 3 &&\n                this.asts[this.top] === ast &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.InterfaceDeclaration;\n        }\n\n        public isTopLevelImplicitModule() {\n            return this.count() >= 1 &&\n                this.asts[this.top].nodeType === TypeScript.NodeType.ModuleDeclaration &&\n                TypeScript.hasFlag((<TypeScript.ModuleDeclaration>this.asts[this.top]).modFlags, TypeScript.ModuleFlags.IsWholeFile);\n        }\n\n        public isBodyOfTopLevelImplicitModule() {\n            return this.count() >= 2 &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ModuleDeclaration &&\n                 (<TypeScript.ModuleDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0] &&\n                TypeScript.hasFlag((<TypeScript.ModuleDeclaration>this.asts[this.top - 1]).modFlags, TypeScript.ModuleFlags.IsWholeFile);\n        }\n\n        public isBodyOfScript(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Script &&\n                 (<TypeScript.Script>this.asts[this.top - 1]).bod == this.asts[this.top - 0];\n        }\n\n        public isBodyOfSwitch(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Switch &&\n                 (<TypeScript.SwitchStatement>this.asts[this.top - 1]).caseList == this.asts[this.top - 0];\n        }\n\n        public isBodyOfModule(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ModuleDeclaration &&\n                 (<TypeScript.ModuleDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0];\n        }\n\n        public isBodyOfClass(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ClassDeclaration &&\n                 (<T";
var v27689 = v27690 + "ypeScript.ClassDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0];\n        }\n\n        public isBodyOfFunction(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.FuncDecl &&\n                 (<TypeScript.FuncDecl>this.asts[this.top - 1]).bod == this.asts[this.top - 0];\n        }\n\n        public isBodyOfInterface(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.InterfaceDeclaration &&\n                 (<TypeScript.InterfaceDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0];\n        }\n\n        public isBodyOfBlock(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Block &&\n                (<TypeScript.Block>this.asts[this.top - 1]).statements == this.asts[this.top - 0];\n        }\n\n        public isBodyOfFor(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.For &&\n                (<TypeScript.ForStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfCase(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Case &&\n                (<TypeScript.CaseStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfTry(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Try &&\n                (<TypeScript.Try>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfCatch(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Catch &&\n                (<TypeScript.Catch>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfDoWhile(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.DoWhile &&\n                (<TypeScript.DoWhileStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfWhile(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.While &&\n                (<TypeScript.WhileStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfForIn(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ForIn &&\n                (<TypeScript.ForInStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfWith(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.With &&\n                (<TypeScript.WithStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isBodyOfFinally(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Finally &&\n                (<TypeScript.Finally>this.asts[this.top - 1]).body == this.asts[this.top - 0];\n        }\n\n        public isCaseOfSwitch(): bool {\n            return this.count() >= 3 &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.Switch &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                (<TypeScript.SwitchStatement>this.asts[this.top - 2]).caseList == this.asts[this.top - 1];\n        }\n\n        public isDefaultCaseOfSwitch(): bool {\n            return this.count() >= 3 &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.Switch &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                (<TypeScript.SwitchStatement>this.asts[this.top - 2]).caseList == this.asts[this.top - 1] &&\n                (<TypeScript.SwitchStatement>this.asts[this.top - 2]).defaultCase == this.asts[this.top - 0];\n        }\n\n        public isListOfObjectLit(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ObjectLit &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&\n                (<TypeScript.UnaryExpression>this.asts[this.top - 1]).operand == this.asts[this.top - 0];\n        }\n\n        public isBodyOfObjectLit(): bool {\n            return this.isListOfObjectLit();\n        }\n\n        public isEmptyListOfObjectLit(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ObjectLit &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&\n                (<TypeScript.UnaryExpression>this.asts[t";
var v27688 = v27689 + "his.top - 1]).operand == this.asts[this.top - 0] &&\n                (<TypeScript.ASTList>this.asts[this.top - 0]).members.length == 0;\n        }\n\n        public isMemberOfObjectLit(): bool {\n            return this.count() >= 3 &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.ObjectLit &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.Member &&\n                (<TypeScript.UnaryExpression>this.asts[this.top - 2]).operand == this.asts[this.top - 1];\n        }\n\n        public isNameOfMemberOfObjectLit(): bool {\n            return this.count() >= 4 &&\n                this.asts[this.top - 3].nodeType === TypeScript.NodeType.ObjectLit &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Member &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.Name &&\n                (<TypeScript.UnaryExpression>this.asts[this.top - 3]).operand == this.asts[this.top - 2];\n        }\n\n        public isListOfArrayLit(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ArrayLit &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&\n                (<TypeScript.UnaryExpression>this.asts[this.top - 1]).operand == this.asts[this.top - 0];\n        }\n\n        public isTargetOfMember(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Member &&\n                (<TypeScript.BinaryExpression>this.asts[this.top - 1]).operand1 === this.asts[this.top - 0];\n        }\n\n        public isMemberOfMember(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Member &&\n                (<TypeScript.BinaryExpression>this.asts[this.top - 1]).operand2 === this.asts[this.top - 0];\n        }\n\n        public isItemOfList(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List;\n            //(<Tools.ASTList>this.asts[this.top - 1]).operand2 === this.asts[this.top - 0];\n        }\n\n        public isThenOfIf(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.If &&\n                (<TypeScript.IfStatement>this.asts[this.top - 1]).thenBod == this.asts[this.top - 0];\n        }\n\n        public isElseOfIf(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.If &&\n                (<TypeScript.IfStatement>this.asts[this.top - 1]).elseBod == this.asts[this.top - 0];\n        }\n\n        public isBodyOfDefaultCase(): bool {\n            return this.isBodyOfCase();\n        }\n\n        public isSingleStatementList(): bool {\n            return this.count() >= 1 &&\n                this.asts[this.top].nodeType === TypeScript.NodeType.List &&\n                (<TypeScript.ASTList>this.asts[this.top]).members.length === 1;\n        }\n\n        public isArgumentListOfFunction(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.FuncDecl &&\n                (<TypeScript.FuncDecl>this.asts[this.top - 1]).arguments === this.asts[this.top - 0];\n        }\n\n        public isArgumentOfFunction(): bool {\n            return this.count() >= 3 &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 2].nodeType === TypeScript.NodeType.FuncDecl &&\n                (<TypeScript.FuncDecl>this.asts[this.top - 2]).arguments === this.asts[this.top - 1];\n        }\n\n        public isArgumentListOfCall(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Call &&\n                (<TypeScript.CallExpression>this.asts[this.top - 1]).arguments === this.asts[this.top - 0];\n        }\n\n        public isArgumentListOfNew(): bool {\n            return this.count() >= 2 &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&\n                this.asts[this.top - 1].nodeType === TypeScript.NodeType.New &&\n                (<TypeScript.CallExpression>this.asts[this.top - 1]).arguments === this.asts[this.top - 0];\n        }\n\n        public isSynthesizedBlock(): bool {\n            return this.count() >= 1 &&\n                this.asts[this.top - 0].nodeType === TypeScript.NodeType.Block &&\n                (<TypeScript.Block>this.asts[this.top - 0]).isStatementBlock === false;\n        }\n    }\n\n    export function isValidAstNode(ast: Typ";
var v27687 = v27688 + 'eScript.ASTSpan): bool {\n        if (ast === null)\n            return false;\n\n        if (ast.minChar === -1 || ast.limChar === -1)\n            return false;\n\n        return true;\n    }\n\n    export class AstPathContext {\n        public path = new TypeScript.AstPath();\n    }\n\n    export enum GetAstPathOptions {\n        Default = 0,\n        EdgeInclusive = 1,\n        //We need this options dealing with an AST coming from an incomplete AST. For example:\n        //     class foo { // r\n        // If we ask for the AST at the position after the "r" character, we won\'t see we are \n        // inside a comment, because the "class" AST node has a limChar corresponding to the position of \n        // the "{" character, meaning we don\'t traverse the tree down to the stmt list of the class, meaning\n        // we don\'t find the "precomment" attached to the errorneous empty stmt.\n        //TODO: It would be nice to be able to get rid of this.\n        DontPruneSearchBasedOnPosition = 1 << 1,\n    }\n\n    ///\n    /// Return the stack of AST nodes containing "position"\n    ///\n    export function getAstPathToPosition(script: TypeScript.AST, pos: number, options = GetAstPathOptions.Default): TypeScript.AstPath {\n        var lookInComments = (comments: TypeScript.Comment[]) => {\n            if (comments && comments.length > 0) {\n                for (var i = 0; i < comments.length; i++) {\n                    var minChar = comments[i].minChar;\n                    var limChar = comments[i].limChar;\n                    if (!comments[i].isBlockComment) {\n                        limChar++; // For single line comments, include 1 more character (for the newline)\n                    }\n                    if (pos >= minChar && pos < limChar) {\n                        ctx.path.push(comments[i]);\n                    }\n                }\n            }\n        }\n\n        var pre = function (cur: TypeScript.AST, parent: TypeScript.AST, walker: IAstWalker) {\n            if (isValidAstNode(cur)) {\n\n                // Add "cur" to the stack if it contains our position\n                // For "identifier" nodes, we need a special case: A position equal to "limChar" is\n                // valid, since the position corresponds to a caret position (in between characters)\n                // For example:\n                //  bar\n                //  0123\n                // If "position == 3", the caret is at the "right" of the "r" character, which should be considered valid\n                var inclusive =\n                    hasFlag(options, GetAstPathOptions.EdgeInclusive) ||\n                    cur.nodeType === TypeScript.NodeType.Name ||\n                    pos === script.limChar; // Special "EOF" case\n\n                var minChar = cur.minChar;\n                var limChar = cur.limChar + (inclusive ? 1 : 0)\n                if (pos >= minChar && pos < limChar) {\n\n                    // TODO: Since AST is sometimes not correct wrt to position, only add "cur" if it\'s better\n                    //       than top of the stack.\n                    var previous = ctx.path.ast();\n                    if (previous == null || (cur.minChar >= previous.minChar && cur.limChar <= previous.limChar)) {\n                        ctx.path.push(cur);\n                    }\n                    else {\n                        //logger.log("TODO: Ignoring node because minChar, limChar not better than previous node in stack");\n                    }\n                }\n\n                // The AST walker skips comments, but we might be in one, so check the pre/post comments for this node manually\n                if (pos < limChar) {\n                    lookInComments(cur.preComments);\n                }\n                if (pos >= minChar) {\n                    lookInComments(cur.postComments);\n                }\n\n                if (!hasFlag(options, GetAstPathOptions.DontPruneSearchBasedOnPosition)) {\n                    // Don\'t go further down the tree if pos is outside of [minChar, limChar]\n                    walker.options.goChildren = (minChar <= pos && pos <= limChar);\n                }\n            }\n            return cur;\n        }\n\n        var ctx = new AstPathContext();\n        TypeScript.getAstWalkerFactory().walk(script, pre, null, null, ctx);\n        return ctx.path;\n    }\n\n    //\n    // Find a source text offset that is safe for lexing tokens at the given position.\n    // This is used when "position" might be inside a comment or string, etc.\n    //\n    export function getTokenizationOffset(script: TypeScript.Script, position: number): number {\n        var bestOffset = 0;\n        var pre = (cur: TypeScript.AST, parent: TypeScript.AST, walker: TypeScript.IAstWalker): TypeScript.AST => {\n            if (TypeScript.isValidAstNode(cur)) {\n                // Did we find a closer offset?\n                if (cur.minChar <= position) {\n                    bestOffset = max(bestOffset, cur.minChar);\n                }\n\n                // Stop the walk if this node is not related to ';
var v27686 = v27687 + '"minChar"\n                if (cur.minChar > position || cur.limChar < bestOffset) {\n                    walker.options.goChildren = false;\n                }\n            }\n\n            return cur;\n        }\n\n        TypeScript.getAstWalkerFactory().walk(script, pre);\n        return bestOffset;\n    }\n\n    ///\n    /// Simple function to Walk an AST using a simple callback function.\n    ///\n    export function walkAST(ast: TypeScript.AST, callback: (path: AstPath, walker: TypeScript.IAstWalker) => void ): void {\n        var pre = function (cur: TypeScript.AST, parent: TypeScript.AST, walker: TypeScript.IAstWalker) {\n            var path: TypeScript.AstPath = walker.state;\n            path.push(cur);\n            callback(path, walker);\n            return cur;\n        }\n        var post = function (cur: TypeScript.AST, parent: TypeScript.AST, walker: TypeScript.IAstWalker) {\n            var path: TypeScript.AstPath = walker.state;\n            path.pop();\n            return cur;\n        }\n\n        var path = new AstPath();\n        TypeScript.getAstWalkerFactory().walk(ast, pre, post, null, path);\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class ASTSpan {\n        public minChar: number = -1;  // -1 = "undefined" or "compiler generated"\n        public limChar: number = -1;  // -1 = "undefined" or "compiler generated"   \n    }\n\n    export class AST extends ASTSpan {\n        public type: Type = null;\n        public flags = ASTFlags.Writeable;\n\n        // REVIEW: for diagnostic purposes\n        public passCreated: number = CompilerDiagnostics.analysisPass;\n\n        public preComments: Comment[] = null;\n        public postComments: Comment[] = null;\n        private docComments: Comment[] = null;\n\n        public isParenthesized = false;\n\n        constructor (public nodeType: NodeType) {\n            super();\n        }\n\n        public isExpression() { return false; }\n\n        public isStatementOrExpression() { return false; }\n\n        public isCompoundStatement() { return false; }\n\n        public isLeaf() { return this.isStatementOrExpression() && (!this.isCompoundStatement()); }\n        \n        public isDeclaration() { return false; }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            switch (this.nodeType) {\n                case NodeType.Error:\n                case NodeType.EmptyExpr:\n                    this.type = typeFlow.anyType;\n                    break;\n                case NodeType.This:\n                    return typeFlow.typeCheckThis(this);\n                case NodeType.Null:\n                    this.type = typeFlow.nullType;\n                    break;\n                case NodeType.False:\n                case NodeType.True:\n                    this.type = typeFlow.booleanType;\n                    break;\n                case NodeType.Super:\n                    return typeFlow.typeCheckSuper(this);\n                case NodeType.EndCode:\n                case NodeType.Empty:\n                case NodeType.Void:\n                    this.type = typeFlow.voidType;\n                    break;\n                default:\n                    throw new Error("please implement in derived class");\n            }\n            return this;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            switch (this.nodeType) {\n                case NodeType.This:\n                    emitter.recordSourceMappingStart(this);\n                    if (emitter.thisFnc && (hasFlag(emitter.thisFnc.fncFlags, FncFlags.IsFatArrowFunction))) {\n                        emitter.writeToOutput("_this");\n                    }\n                    else {\n                        emitter.writeToOutput("this");\n                    }\n                    emitter.recordSourceMappingEnd(this);\n                    break;\n                case NodeType.Null:\n                    emitter.recordSourceMappingStart(this);\n                    emitter.writeToOutput("null");\n                    emitter.recordSourceMappingEnd(this);\n                    break;\n                case NodeType.False:\n                    emitter.recordSourceMappingStart(this);\n                    emitter.writeToOutput("false");\n                    emitter.recordSourceMappingEnd(this);\n                    break;\n                case NodeType.True';
var v27685 = v27686 + ':\n                    emitter.recordSourceMappingStart(this);\n                    emitter.writeToOutput("true");\n                    emitter.recordSourceMappingEnd(this);\n                    break;\n                case NodeType.Super:\n                    emitter.recordSourceMappingStart(this);\n                    emitter.emitSuperReference();\n                    emitter.recordSourceMappingEnd(this);\n                    break;\n                case NodeType.EndCode:\n                case NodeType.Error:\n                case NodeType.EmptyExpr:\n                    break;\n                case NodeType.Empty:\n                    emitter.recordSourceMappingStart(this);\n                    emitter.recordSourceMappingEnd(this);\n                    break;\n                case NodeType.Void:\n                    emitter.recordSourceMappingStart(this);\n                    emitter.writeToOutput("void ");\n                    emitter.recordSourceMappingEnd(this);\n                    break;\n                default:\n                    throw new Error("please implement in derived class");\n            }\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public print(context: PrintContext) {\n            context.startLine();\n            var lineCol = { line: -1, col: -1 };\n            var limLineCol = { line: -1, col: -1 };\n            if (context.parser !== null) {\n                context.parser.getSourceLineCol(lineCol, this.minChar);\n                context.parser.getSourceLineCol(limLineCol, this.limChar);\n                context.write("(" + lineCol.line + "," + lineCol.col + ")--" +\n                              "(" + limLineCol.line + "," + limLineCol.col + "): ");\n            }\n            var lab = this.printLabel();\n            if (hasFlag(this.flags, ASTFlags.Error)) {\n                lab += " (Error)";\n            }\n            context.writeLine(lab);\n        }\n\n        public printLabel() {\n            if (nodeTypeTable[this.nodeType] !== undefined) {\n                return nodeTypeTable[this.nodeType];\n            }\n            else {\n                return (<any>NodeType)._map[this.nodeType];\n            }\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            // by default, AST adds itself to current basic block and does not check its children\n            context.walker.options.goChildren = false;\n            context.addContent(this);\n        }\n\n        public netFreeUses(container: Symbol, freeUses: StringHashTable) {\n        }\n\n        public treeViewLabel() {\n            return (<any>NodeType)._map[this.nodeType];\n        }\n\n        public static getResolvedIdentifierName(name: string): string {\n            if (!name) return "";\n\n            var resolved = "";\n            var start = 0;\n            var i = 0;\n            while(i <= name.length - 6) {\n                // Look for escape sequence \\uxxxx\n                if (name.charAt(i) == \'\\\\\' && name.charAt(i+1) == \'u\') {\n                    var charCode = parseInt(name.substr(i + 2, 4), 16);\n                    resolved += name.substr(start, i - start);\n                    resolved += String.fromCharCode(charCode);\n                    i += 6;\n                    start = i;\n                    continue;\n                } \n                i++;\n            }\n            // Append remaining string\n            resolved += name.substring(start);\n            return resolved;\n        }\n\n        public getDocComments() : Comment[] {\n            if (!this.isDeclaration() || !this.preComments || this.preComments.length == 0) {\n                return [];\n            }\n\n            if (!this.docComments) {\n                var preCommentsLength = this.preComments.length;\n                var docComments: Comment[] = [];\n                for (var i = preCommentsLength - 1; i >= 0; i--) {\n                    if (this.preComments[i].isDocComment()) {\n                        var prevDocComment = docComments.length > 0 ? docComments[docComments.length - 1] : null;\n                        if (prevDocComment == null || // If the help comments were not yet set then this is the comment\n                             (this.preComments[i].limLine == prevDocComment.minLine ||\n                              this.preComments[i].limLine + 1 == prevDocComment.minLine)) { // On same line or next line\n                            docComments.push(this.preComments[i]);\n                            continue;\n                        }\n                    }\n                    break;\n                }\n\n                this.docComments = docComments.reverse();\n            }\n\n            return this.docComments;\n        }\n    }\n\n    export class IncompleteAST extends AST {\n        constructor (min: number, lim: number) {\n            super(NodeType.Error);\n\n            this.minChar = min;\n            this.limChar = lim;\n        }\n    }\n\n    export class ASTList extends AST {\n        public enclosingScope: SymbolScope = null;\n        publ';
var v27684 = v27685 + "ic members: AST[] = new AST[];\n\n        constructor () {\n            super(NodeType.List);\n        }\n\n        public addToControlFlow(context: ControlFlowContext) {\n            var len = this.members.length;\n            for (var i = 0; i < len; i++) {\n                if (context.noContinuation) {\n                    context.addUnreachable(this.members[i]);\n                    break;\n                }\n                else {\n                    this.members[i] = context.walk(this.members[i], this);\n                }\n            }\n            context.walker.options.goChildren = false;\n        }\n\n        public append(ast: AST) {\n            this.members[this.members.length] = ast;\n            return this;\n        }\n\n        public appendAll(ast: AST) {\n            if (ast.nodeType == NodeType.List) {\n                var list = <ASTList>ast;\n                for (var i = 0, len = list.members.length; i < len; i++) {\n                    this.append(list.members[i]);\n                }\n            }\n            else {\n                this.append(ast);\n            }\n            return this;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.recordSourceMappingStart(this);\n            emitter.emitJavascriptList(this, null, TokenID.Semicolon, startLine, false, false);\n            emitter.recordSourceMappingEnd(this);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            var len = this.members.length;\n            typeFlow.nestingLevel++;\n            for (var i = 0; i < len; i++) {\n                if (this.members[i]) {\n                    this.members[i] = this.members[i].typeCheck(typeFlow);\n                }\n            }\n            typeFlow.nestingLevel--;\n            return this;\n        }\n    }\n\n    export class Identifier extends AST {\n        public sym: Symbol = null;\n        public cloId = -1;\n        public text: string;\n\n        // 'actualText' is the text that the user has entered for the identifier. the text might \n        // include any Unicode escape sequences (e.g.: \\u0041 for 'A'). 'text', however, contains \n        // the resolved value of any escape sequences in the actual text; so in the previous \n        // example, actualText = '\\u0041', text = 'A'.\n        //\n        // For purposes of finding a symbol, use text, as this will allow you to match all \n        // variations of the variable text. For full-fidelity translation of the user input, such\n        // as emitting, use the actualText field.\n        // \n        // Note: \n        //    To change text, and to avoid running into a situation where 'actualText' does not \n        //    match 'text', always use setText.\n        constructor (public actualText: string, public hasEscapeSequence?: bool) {\n            super(NodeType.Name);\n            this.setText(actualText, hasEscapeSequence);\n        }\n\n        public setText(actualText: string, hasEscapeSequence?: bool) {\n            this.actualText = actualText;\n            if (hasEscapeSequence) {\n                this.text = AST.getResolvedIdentifierName(actualText);\n            }\n            else {\n                this.text = actualText;\n            }\n        }\n\n        public isMissing() { return false; }\n        public isLeaf() { return true; }\n\n        public treeViewLabel() {\n            return \"id: \" + this.actualText;\n        }\n\n        public printLabel() {\n            if (this.actualText) {\n                return \"id: \" + this.actualText;\n            }\n            else {\n                return \"name node\";\n            }\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckName(this);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitJavascriptName(this, true);\n        }\n\n        public static fromToken(token: Token): Identifier {\n            return new Identifier(token.getText(), (<IdentifierToken>token).hasEscapeSequence);\n        }\n    }\n\n    export class MissingIdentifier extends Identifier {\n        constructor () {\n            super(\"__missing\");\n        }\n\n        public isMissing() {\n            return true;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            // Emit nothing for a missing ID\n        }\n    }\n\n    export class Label extends AST {\n        constructor (public id: Identifier) {\n            super(NodeType.Label);\n        }\n\n        public printLabel() { return this.id.actualText + \":\"; }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.type = typeFlow.voidType;\n            return this;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.recordSourceMappingStart(this.id);\n            emitter.writeToOutput(this.id.actualText);\n            emitter.recordSourceMappingEnd(this.id);";
var v27683 = v27684 + '\n            emitter.writeLineToOutput(":");\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export class Expression extends AST {\n        constructor (nodeType: NodeType) {\n            super(nodeType);\n        }\n\n        public isExpression() { return true; }\n\n        public isStatementOrExpression() { return true; }\n    }\n\n    export class UnaryExpression extends Expression {\n        public targetType: Type = null; // Target type for an object literal (null if no target type)\n        public castTerm: AST = null;\n\n        constructor (nodeType: NodeType, public operand: AST) {\n            super(nodeType);\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            super.addToControlFlow(context);\n            // TODO: add successor as catch block/finally block if present\n            if (this.nodeType == NodeType.Throw) {\n                context.returnStmt();\n            }\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            switch (this.nodeType) {\n                case NodeType.Not:\n                    return typeFlow.typeCheckBitNot(this);\n\n                case NodeType.LogNot:\n                    return typeFlow.typeCheckLogNot(this);\n\n                case NodeType.Pos:\n                case NodeType.Neg:\n                    return typeFlow.typeCheckUnaryNumberOperator(this);\n\n                case NodeType.IncPost:\n                case NodeType.IncPre:\n                case NodeType.DecPost:\n                case NodeType.DecPre:\n                    return typeFlow.typeCheckIncOrDec(this);\n\n                case NodeType.ArrayLit:\n                    typeFlow.typeCheckArrayLit(this);\n                    return this;\n\n                case NodeType.ObjectLit:\n                    typeFlow.typeCheckObjectLit(this);\n                    return this;\n\n                case NodeType.Throw:\n                    this.operand = typeFlow.typeCheck(this.operand);\n                    this.type = typeFlow.voidType;\n                    return this;\n\n                case NodeType.Typeof:\n                    this.operand = typeFlow.typeCheck(this.operand);\n                    this.type = typeFlow.stringType;\n                    return this;\n\n                case NodeType.Delete:\n                    this.operand = typeFlow.typeCheck(this.operand);\n                    this.type = typeFlow.booleanType;\n                    break;\n\n                case NodeType.TypeAssertion:\n                    this.castTerm = typeFlow.typeCheck(this.castTerm);\n                    var applyTargetType = !this.operand.isParenthesized;\n\n                    var targetType = applyTargetType ? this.castTerm.type : null;\n\n                    typeFlow.checker.typeCheckWithContextualType(targetType, typeFlow.checker.inProvisionalTypecheckMode(), true, this.operand);\n                    typeFlow.castWithCoercion(this.operand, this.castTerm.type, false, true);\n                    this.type = this.castTerm.type;\n                    return this;\n\n                case NodeType.Void:\n                    // REVIEW - Although this is good to do for completeness\'s sake,\n                    // this shouldn\'t be strictly necessary from the void operator\'s\n                    // point of view\n                    this.operand = typeFlow.typeCheck(this.operand);\n                    this.type = typeFlow.checker.undefinedType;\n                    break;\n\n                default:\n                    throw new Error("please implement in derived class");\n            }\n            return this;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            switch (this.nodeType) {\n                case NodeType.IncPost:\n                    emitter.emitJavascript(this.operand, TokenID.PlusPlus, false);\n                    emitter.writeToOutput("++");\n                    break;\n                case NodeType.LogNot:\n                    emitter.writeToOutput("!");\n                    emitter.emitJavascript(this.operand, TokenID.Exclamation, false);\n                    break;\n                case NodeType.DecPost:\n                    emitter.emitJavascript(this.operand, TokenID.MinusMinus, false);\n                    emitter.writeToOutput("--");\n                    break;\n                case NodeType.ObjectLit:\n                    emitter.emitObjectLiteral(<ASTList>this.operand);\n                    break;\n                case NodeType.ArrayLit:\n                    emitter.emitArrayLiteral(<ASTList>this.operand);\n                    break;\n                case NodeType.Not:\n                    emitter.writeToOutput("~");\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    break;\n                case NodeType.Neg:\n                    emitter.writeToOutput("-"';
var v27682 = v27683 + ');\n                    if (this.operand.nodeType == NodeType.Neg) {\n                        this.operand.isParenthesized = true;\n                    }\n                    emitter.emitJavascript(this.operand, TokenID.Minus, false);\n                    break;\n                case NodeType.Pos:\n                    emitter.writeToOutput("+");\n                    if (this.operand.nodeType == NodeType.Pos) {\n                        this.operand.isParenthesized = true;\n                    }\n                    emitter.emitJavascript(this.operand, TokenID.Plus, false);\n                    break;\n                case NodeType.IncPre:\n                    emitter.writeToOutput("++");\n                    emitter.emitJavascript(this.operand, TokenID.PlusPlus, false);\n                    break;\n                case NodeType.DecPre:\n                    emitter.writeToOutput("--");\n                    emitter.emitJavascript(this.operand, TokenID.MinusMinus, false);\n                    break;\n                case NodeType.Throw:\n                    emitter.writeToOutput("throw ");\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    emitter.writeToOutput(";");\n                    break;\n                case NodeType.Typeof:\n                    emitter.writeToOutput("typeof ");\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    break;\n                case NodeType.Delete:\n                    emitter.writeToOutput("delete ");\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    break;\n                case NodeType.Void:\n                    emitter.writeToOutput("void ");\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    break;\n                case NodeType.TypeAssertion:\n                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);\n                    break;\n                default:\n                    throw new Error("please implement in derived class");\n            }\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export class CallExpression extends Expression {\n        constructor (nodeType: NodeType,\n                     public target: AST,\n                     public arguments: ASTList) {\n            super(nodeType);\n            this.minChar = this.target.minChar;\n        }\n\n        public signature: Signature = null;\n\n        public typeCheck(typeFlow: TypeFlow) {\n            if (this.nodeType == NodeType.New) {\n                return typeFlow.typeCheckNew(this);\n            }\n            else {\n                return typeFlow.typeCheckCall(this);\n            }\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n\n            if (this.nodeType == NodeType.New) {\n                emitter.emitNew(this.target, this.arguments);\n            }\n            else {\n                emitter.emitCall(this, this.target, this.arguments);\n            }\n\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export class BinaryExpression extends Expression {\n        constructor (nodeType: NodeType, public operand1: AST, public operand2: AST) {\n            super(nodeType);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            switch (this.nodeType) {\n                case NodeType.Dot:\n                    return typeFlow.typeCheckDotOperator(this);\n                case NodeType.Asg:\n                    return typeFlow.typeCheckAsgOperator(this);\n                case NodeType.Add:\n                case NodeType.Sub:\n                case NodeType.Mul:\n                case NodeType.Div:\n                case NodeType.Mod:\n                case NodeType.Or:\n                case NodeType.And:\n                    return typeFlow.typeCheckArithmeticOperator(this, false);\n                case NodeType.Xor:\n                    return typeFlow.typeCheckBitwiseOperator(this, false);\n                case NodeType.Ne:\n                case NodeType.Eq:\n                    var text: string;\n                    if (typeFlow.checker.styleSettings.eqeqeq) {\n                        text = nodeTypeTable[this.nodeType];\n                        typeFlow.checker.errorReporter.styleError(this, "use of " + text);\n                    }\n                    else if (typeFlow.checker.styleSettings.eqnull) {\n                        text = nodeTypeTable[this.nodeType];\n                        if ((this.operand2 !== null) && (this.operand2.nodeType == NodeType.Null)) {\n                            typeFlow.checker.errorReporter.styleError(this, "use of " + text + " to compare with null");\n                        }\n                    }\n         ';
var v27681 = v27682 + '       case NodeType.Eqv:\n                case NodeType.NEqv:\n                case NodeType.Lt:\n                case NodeType.Le:\n                case NodeType.Ge:\n                case NodeType.Gt:\n                    return typeFlow.typeCheckBooleanOperator(this);\n                case NodeType.Index:\n                    return typeFlow.typeCheckIndex(this);\n                case NodeType.Member:\n                    this.type = typeFlow.voidType;\n                    return this;\n                case NodeType.LogOr:\n                    return typeFlow.typeCheckLogOr(this);\n                case NodeType.LogAnd:\n                    return typeFlow.typeCheckLogAnd(this);\n                case NodeType.AsgAdd:\n                case NodeType.AsgSub:\n                case NodeType.AsgMul:\n                case NodeType.AsgDiv:\n                case NodeType.AsgMod:\n                case NodeType.AsgOr:\n                case NodeType.AsgAnd:\n                    return typeFlow.typeCheckArithmeticOperator(this, true);\n                case NodeType.AsgXor:\n                    return typeFlow.typeCheckBitwiseOperator(this, true);\n                case NodeType.Lsh:\n                case NodeType.Rsh:\n                case NodeType.Rs2:\n                    return typeFlow.typeCheckShift(this, false);\n                case NodeType.AsgLsh:\n                case NodeType.AsgRsh:\n                case NodeType.AsgRs2:\n                    return typeFlow.typeCheckShift(this, true);\n                case NodeType.Comma:\n                    return typeFlow.typeCheckCommaOperator(this);\n                case NodeType.InstOf:\n                    return typeFlow.typeCheckInstOf(this);\n                case NodeType.In:\n                    return typeFlow.typeCheckInOperator(this);\n                case NodeType.From:\n                    typeFlow.checker.errorReporter.simpleError(this, "Illegal use of \'from\' keyword in binary expression");\n                    break;\n                default:\n                    throw new Error("please implement in derived class");\n            }\n            return this;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            var binTokenId = nodeTypeToTokTable[this.nodeType];\n\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (binTokenId != undefined) {\n\n                emitter.emitJavascript(this.operand1, binTokenId, false);\n\n                if (tokenTable[binTokenId].text == "instanceof") {\n                    emitter.writeToOutput(" instanceof ");\n                }\n                else if (tokenTable[binTokenId].text == "in") {\n                    emitter.writeToOutput(" in ");\n                }\n                else {\n                    emitter.writeToOutputTrimmable(" " + tokenTable[binTokenId].text + " ");\n                }\n\n                emitter.emitJavascript(this.operand2, binTokenId, false);\n            }\n            else {\n                switch (this.nodeType) {\n                    case NodeType.Dot:\n                        if (!emitter.tryEmitConstant(this)) {\n                            emitter.emitJavascript(this.operand1, TokenID.Dot, false);\n                            emitter.writeToOutput(".");\n                            emitter.emitJavascriptName(<Identifier>this.operand2, false);\n                        }\n                        break;\n                    case NodeType.Index:\n                        emitter.emitIndex(this.operand1, this.operand2);\n                        break;\n\n                    case NodeType.Member:\n                        if (this.operand2.nodeType == NodeType.FuncDecl && (<FuncDecl>this.operand2).isAccessor()) {\n                            var funcDecl = <FuncDecl>this.operand2;\n                            if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {\n                                emitter.writeToOutput("get ");\n                            }\n                            else {\n                                emitter.writeToOutput("set ");\n                            }\n                            emitter.emitJavascript(this.operand1, TokenID.Colon, false);\n                        }\n                        else {\n                            emitter.emitJavascript(this.operand1, TokenID.Colon, false);\n                            emitter.writeToOutputTrimmable(": ");\n                        }\n                        emitter.emitJavascript(this.operand2, TokenID.Comma, false);\n                        break;\n                    case NodeType.Comma:\n                        emitter.emitJavascript(this.operand1, TokenID.Comma, false);\n                        if (emitter.emitState.inObjectLiteral) {\n                            emitter.writeLineToOutput(", ");\n                        }\n                        else {\n                            emitter.writeToOutput(",");\n                        }\n                        emitter.emitJavascript(this.op';
var v27680 = v27681 + 'erand2, TokenID.Comma, false);\n                        break;\n                    case NodeType.Is:\n                        throw new Error("should be de-sugared during type check");\n                    default:\n                        throw new Error("please implement in derived class");\n                }\n            }\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export class ConditionalExpression extends Expression {\n        constructor (public operand1: AST,\n                     public operand2: AST,\n                     public operand3: AST) {\n            super(NodeType.ConditionalExpression);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckQMark(this);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.emitJavascript(this.operand1, TokenID.Question, false);\n            emitter.writeToOutput(" ? ");\n            emitter.emitJavascript(this.operand2, TokenID.Question, false);\n            emitter.writeToOutput(" : ");\n            emitter.emitJavascript(this.operand3, TokenID.Question, false);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export class NumberLiteral extends Expression {\n        constructor (public value: number, public hasEmptyFraction?: bool) {\n            super(NodeType.NumberLit);\n        }\n\n        public isNegativeZero = false;\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.type = typeFlow.doubleType;\n            return this;\n        }\n\n        public treeViewLabel() {\n            return "num: " + this.printLabel();\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (this.isNegativeZero) {\n                emitter.writeToOutput("-");\n            }\n\n            emitter.writeToOutput(this.value.toString());\n\n            if (this.hasEmptyFraction)\n                emitter.writeToOutput(".0");\n\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public printLabel() {\n            if (Math.floor(this.value) != this.value) {\n                return this.value.toFixed(2).toString();\n            }\n            else if (this.hasEmptyFraction) {\n                return this.value.toString() + ".0";\n            }\n            else {\n                return this.value.toString();\n            }\n        }\n    }\n\n    export class RegexLiteral extends Expression {\n        constructor (public regex) {\n            super(NodeType.Regex);\n        }\n        \n        public typeCheck(typeFlow: TypeFlow) {\n            this.type = typeFlow.regexType;\n            return this;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput(this.regex.toString());\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export class StringLiteral extends Expression {\n        constructor (public text: string) {\n            super(NodeType.QString);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.emitStringLiteral(this.text);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.type = typeFlow.stringType;\n            return this;\n        }\n\n        public treeViewLabel() {\n            return "st: " + this.text;\n        }\n\n        public printLabel() {\n            return this.text;\n        }\n    }\n\n    export class ModuleElement extends AST {\n        constructor (nodeType: NodeType) {\n            super(nodeType);\n        }\n    }\n\n    export class ImportDeclaration extends ModuleElement {\n        public isStatementOrExpression() { return true; }\n        public varFlags = VarFlags.None;\n        public isDynamicImport = false;\n        public isDeclaration() { return true; }\n\n        constructor (public id: Identifier, public alias: AST) {\n            super(NodeType.ImportDeclaration);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            var mod = <ModuleType>this.alias.type;\n            // REVIEW: Only modules may be aliased for now, though there\'s no real\n            // restriction on what the typ';
var v27679 = v27680 + 'e symbol may be\n            if (!this.isDynamicImport || (this.id.sym && !(<TypeSymbol>this.id.sym).onlyReferencedAsTypeRef)) {\n                var prevModAliasId = emitter.modAliasId;\n                var prevFirstModAlias = emitter.firstModAlias;\n\n                emitter.recordSourceMappingStart(this);\n                emitter.emitParensAndCommentsInPlace(this, true);\n                emitter.writeToOutput("var " + this.id.actualText + " = ");\n                emitter.modAliasId = this.id.actualText;\n                emitter.firstModAlias = this.firstAliasedModToString();\n                emitter.emitJavascript(this.alias, TokenID.Tilde, false);\n                // the dynamic import case will insert the semi-colon automatically\n                if (!this.isDynamicImport) {\n                    emitter.writeToOutput(";");\n                }\n                emitter.emitParensAndCommentsInPlace(this, false);\n                emitter.recordSourceMappingEnd(this);\n\n                emitter.modAliasId = prevModAliasId;\n                emitter.firstModAlias = prevFirstModAlias;\n            }\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckImportDecl(this);\n        }\n\n        public getAliasName(aliasAST?: AST = this.alias) : string {\n            if (aliasAST.nodeType == NodeType.Name) {\n                return (<Identifier>aliasAST).actualText;\n            } else {\n                var dotExpr = <BinaryExpression>aliasAST;\n                return this.getAliasName(dotExpr.operand1) + "." + this.getAliasName(dotExpr.operand2);\n            }\n        }\n\n        public firstAliasedModToString() {\n            if (this.alias.nodeType == NodeType.Name) {\n                return (<Identifier>this.alias).actualText;\n            }\n            else {\n                var dotExpr = <BinaryExpression>this.alias;\n                var firstMod = <Identifier>dotExpr.operand1;\n                return firstMod.actualText;\n            }\n        }\n    }\n\n    export class BoundDecl extends AST {\n        public init: AST = null;\n        public typeExpr: AST = null;\n        public varFlags = VarFlags.None;\n        public sym: Symbol = null;\n        public isDeclaration() { return true; }\n\n        constructor (public id: Identifier, nodeType: NodeType, public nestingLevel: number) {\n            super(nodeType);\n        }\n\n        public isStatementOrExpression() { return true; }\n\n        public isPrivate() { return hasFlag(this.varFlags, VarFlags.Private); }\n        public isPublic() { return hasFlag(this.varFlags, VarFlags.Public); }\n        public isProperty() { return hasFlag(this.varFlags, VarFlags.Property); }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckBoundDecl(this);\n        }\n\n        public printLabel() {\n            return this.treeViewLabel();\n        }\n    }\n\n    export class VarDecl extends BoundDecl {\n        constructor (id: Identifier, nest: number) {\n            super(id, NodeType.VarDecl, nest);\n        }\n\n        public isAmbient() { return hasFlag(this.varFlags, VarFlags.Ambient); }\n        public isExported() { return hasFlag(this.varFlags, VarFlags.Exported); }\n        public isStatic() { return hasFlag(this.varFlags, VarFlags.Static); }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitJavascriptVarDecl(this, tokenId);\n        }\n\n        public treeViewLabel() {\n            return "var " + this.id.actualText;\n        }\n    }\n\n    export class ArgDecl extends BoundDecl {\n        constructor (id: Identifier) {\n            super(id, NodeType.ArgDecl, 0);\n        }\n\n        public isOptional = false;\n\n        public isOptionalArg() { return this.isOptional || this.init; }\n\n        public treeViewLabel() {\n            return "arg: " + this.id.actualText;\n        }\n\n        public parameterPropertySym: FieldSymbol = null;\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput(this.id.actualText);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    var internalId = 0;\n\n    export class FuncDecl extends AST {\n        public hint: string = null;\n        public fncFlags = FncFlags.None;\n        public returnTypeAnnotation: AST = null;\n        public symbols: IHashTable;\n        public variableArgList = false;\n        public signature: Signature;\n        public envids: Identifier[];\n        public jumpRefs: Identifier[] = null;\n        public internalNameCache: string = null;\n        public tmp1Declared = false;\n        public enclosingFnc: FuncDecl = null;\n        public freeVariables: Symbol[] = [];\n        public unitIndex = -1;\n        public classDecl: NamedDeclaration = null;\n        public boundToProperty: VarDecl = null;\n        public isOverload = fa';
var v27678 = v27679 + 'lse;\n        public innerStaticFuncs: FuncDecl[] = [];\n        public isTargetTypedAsMethod = false;\n        public isInlineCallLiteral = false;\n        public accessorSymbol: Symbol = null;\n        public leftCurlyCount = 0;\n        public rightCurlyCount = 0;\n        public returnStatementsWithExpressions: ReturnStatement[] = [];\n        public scopeType: Type = null; // Type of the FuncDecl, before target typing\n        public endingToken: ASTSpan = null;\n        public isDeclaration() { return true; }\n\n        constructor (public name: Identifier, public bod: ASTList, public isConstructor: bool,\n                     public arguments: ASTList, public vars: ASTList, public scopes: ASTList, public statics: ASTList,\n                     nodeType: number) {\n\n            super(nodeType);\n        }\n\n        public internalName(): string {\n            if (this.internalNameCache == null) {\n                var extName = this.getNameText();\n                if (extName) {\n                    this.internalNameCache = "_internal_" + extName;\n                }\n                else {\n                    this.internalNameCache = "_internal_" + internalId++;\n                }\n            }\n            return this.internalNameCache;\n        }\n\n        public hasSelfReference() { return hasFlag(this.fncFlags, FncFlags.HasSelfReference); }\n        public setHasSelfReference() { this.fncFlags |= FncFlags.HasSelfReference; }\n\n        public hasSuperReferenceInFatArrowFunction() { return hasFlag(this.fncFlags, FncFlags.HasSuperReferenceInFatArrowFunction); }\n        public setHasSuperReferenceInFatArrowFunction() { this.fncFlags |= FncFlags.HasSuperReferenceInFatArrowFunction; }\n\n        public addCloRef(id: Identifier, sym: Symbol): number {\n            if (this.envids == null) {\n                this.envids = new Identifier[];\n            }\n            this.envids[this.envids.length] = id;\n            var outerFnc = this.enclosingFnc;\n            if (sym) {\n                while (outerFnc && (outerFnc.type.symbol != sym.container)) {\n                    outerFnc.addJumpRef(sym);\n                    outerFnc = outerFnc.enclosingFnc;\n                }\n            }\n            return this.envids.length - 1;\n        }\n\n        public addJumpRef(sym: Symbol): void {\n            if (this.jumpRefs == null) {\n                this.jumpRefs = new Identifier[];\n            }\n            var id = new Identifier(sym.name);\n            this.jumpRefs[this.jumpRefs.length] = id;\n            id.sym = sym;\n            id.cloId = this.addCloRef(id, null);\n        }\n\n        public buildControlFlow(): ControlFlowContext {\n            var entry = new BasicBlock();\n            var exit = new BasicBlock();\n\n            var context = new ControlFlowContext(entry, exit);\n\n            var controlFlowPrefix = (ast: AST, parent: AST, walker: IAstWalker) => {\n                ast.addToControlFlow(walker.state);\n                return ast;\n            }\n\n            var walker = getAstWalkerFactory().getWalker(controlFlowPrefix, null, null, context);\n            context.walker = walker;\n            walker.walk(this.bod, this);\n\n            return context;\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckFunction(this);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitJavascriptFunction(this);\n        }\n\n        public getNameText() {\n            if (this.name) {\n                return this.name.actualText;\n            }\n            else {\n                return this.hint;\n            }\n        }\n\n        public isMethod() {\n            return (this.fncFlags & FncFlags.Method) != FncFlags.None;\n        }\n\n        public isCallMember() { return hasFlag(this.fncFlags, FncFlags.CallMember); }\n        public isConstructMember() { return hasFlag(this.fncFlags, FncFlags.ConstructMember); }\n        public isIndexerMember() { return hasFlag(this.fncFlags, FncFlags.IndexerMember); }\n        public isSpecialFn() { return this.isCallMember() || this.isIndexerMember() || this.isConstructMember(); }\n        public isAnonymousFn() { return this.name === null; }\n        public isAccessor() { return hasFlag(this.fncFlags, FncFlags.GetAccessor) || hasFlag(this.fncFlags, FncFlags.SetAccessor); }\n        public isGetAccessor() { return hasFlag(this.fncFlags, FncFlags.GetAccessor); }\n        public isSetAccessor() { return hasFlag(this.fncFlags, FncFlags.SetAccessor); }\n        public isAmbient() { return hasFlag(this.fncFlags, FncFlags.Ambient); }\n        public isExported() { return hasFlag(this.fncFlags, FncFlags.Exported); }\n        public isPrivate() { return hasFlag(this.fncFlags, FncFlags.Private); }\n        public isPublic() { return hasFlag(this.fncFlags, FncFlags.Public); }\n        public isStatic() { return hasFlag(this.fncFlags, FncFlags.Static); }\n\n        public treeViewLabel() {\n            if (this.name == null) {\n                return "funcExpr";\n      ';
var v27677 = v27678 + '      }\n            else {\n                return "func: " + this.name.actualText\n            }\n        }\n\n        public ClearFlags(): void {\n            this.fncFlags = FncFlags.None;\n        }\n\n        public isSignature() { return (this.fncFlags & FncFlags.Signature) != FncFlags.None; }\n    }\n\n    export class LocationInfo {\n        constructor (public filename: string, public lineMap: number[], public unitIndex) { }\n    }\n\n    export var unknownLocationInfo = new LocationInfo("unknown", null, -1);\n\n    export class Script extends FuncDecl {\n        public locationInfo: LocationInfo = null;\n        public referencedFiles: IFileReference[] = [];\n        public requiresGlobal = false;\n        public requiresExtendsBlock = false;\n        public isResident = false;\n        public isDeclareFile = false;\n        public hasBeenTypeChecked = false;\n        public topLevelMod: ModuleDeclaration = null;\n        public leftCurlyCount = 0;\n        public rightCurlyCount = 0;\n        public vars: ASTList;\n        public scopes: ASTList;\n        // Remember if the script contains Unicode chars, that is needed when generating code for this script object to decide the output file correct encoding.\n        public containsUnicodeChar = false;\n        public containsUnicodeCharInComment = false;\n        public cachedEmitRequired: bool;\n\n        private setCachedEmitRequired(value: bool) {\n            this.cachedEmitRequired = value;\n            return this.cachedEmitRequired;\n        }\n\n        constructor (vars: ASTList, scopes: ASTList) {\n            super(new Identifier("script"), null, false, null, vars, scopes, null, NodeType.Script);\n            this.vars = vars;\n            this.scopes = scopes;\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckScript(this);\n        }\n\n        public treeViewLabel() {\n            return "Script";\n        }\n\n        public emitRequired(emitOptions: EmitOptions) {\n            if (this.cachedEmitRequired != undefined) {\n                return this.cachedEmitRequired;\n            }\n\n            if (!this.isDeclareFile && !this.isResident && this.bod) {\n                if (this.bod.members.length == 0) {\n                    // allow empty files that are not declare files \n                    return this.setCachedEmitRequired(true);\n                }\n\n                for (var i = 0, len = this.bod.members.length; i < len; i++) {\n                    var stmt = this.bod.members[i];\n                    if (stmt.nodeType == NodeType.ModuleDeclaration) {\n                        if (!hasFlag((<ModuleDeclaration>stmt).modFlags, ModuleFlags.ShouldEmitModuleDecl | ModuleFlags.Ambient)) {\n                            return this.setCachedEmitRequired(true);\n                        }\n                    }\n                    else if (stmt.nodeType == NodeType.ClassDeclaration) {\n                        if (!hasFlag((<ClassDeclaration>stmt).varFlags, VarFlags.Ambient)) {\n                            return this.setCachedEmitRequired(true);\n                        }\n                    }\n                    else if (stmt.nodeType == NodeType.VarDecl) {\n                        if (!hasFlag((<VarDecl>stmt).varFlags, VarFlags.Ambient)) {\n                            return this.setCachedEmitRequired(true);\n                        }\n                    }\n                    else if (stmt.nodeType == NodeType.FuncDecl) {\n                        if (!(<FuncDecl>stmt).isSignature()) {\n                            return this.setCachedEmitRequired(true);\n                        }\n                    }\n                    else if (stmt.nodeType != NodeType.InterfaceDeclaration && stmt.nodeType != NodeType.Empty) {\n                        return this.setCachedEmitRequired(true);\n                    }\n                }\n\n                if ( emitOptions.emitComments &&\n                    ((this.bod.preComments && this.bod.preComments.length > 0) || (this.bod.postComments && this.bod.postComments.length > 0))) {\n                    return this.setCachedEmitRequired(true);\n                }\n            }\n            return this.setCachedEmitRequired(false);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            if (this.emitRequired(emitter.emitOptions)) {\n                emitter.emitParensAndCommentsInPlace(this.bod, true);\n                emitter.emitJavascriptList(this.bod, null, TokenID.Semicolon, true, false, false, true, this.requiresExtendsBlock);\n                emitter.emitParensAndCommentsInPlace(this.bod, false);\n            }\n        }\n\n        private externallyVisibleImportedSymbols: Symbol[] = [];\n\n        public AddExternallyVisibleImportedSymbol(symbol: Symbol, checker: TypeChecker) {\n            if (this.isExternallyVisibleSymbol(symbol)) {\n                return;\n            }\n\n            // Before adding check if the external symbol is also marked for visibility\n            if (!symbol.getType().symbol.isExter';
var v27676 = v27677 + 'nallyVisible(checker)) {\n                // Report error\n                var quotes = "";\n                var moduleName = symbol.getType().symbol.prettyName;\n                if (!isQuoted(moduleName)) {\n                    quotes = "\'";\n                }\n                checker.errorReporter.simpleError(symbol.declAST, "Externally visible import statement uses non exported module " + quotes + moduleName + quotes);\n            }\n            this.externallyVisibleImportedSymbols.push(symbol);\n        }\n\n        public isExternallyVisibleSymbol(symbol: Symbol) {\n            for (var i = 0 ; i < this.externallyVisibleImportedSymbols.length; i++) {\n                if (this.externallyVisibleImportedSymbols[i] == symbol) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    export class NamedDeclaration extends ModuleElement {\n        public leftCurlyCount = 0;\n        public rightCurlyCount = 0;\n        public isDeclaration() { return true; }\n\n        constructor (nodeType: NodeType,\n                     public name: Identifier,\n                     public members: ASTList) {\n            super(nodeType);\n        }\n    }\n\n    export class ModuleDeclaration extends NamedDeclaration {\n        public modFlags = ModuleFlags.ShouldEmitModuleDecl;\n        public mod: ModuleType;\n        public prettyName: string;\n        public amdDependencies: string[] = [];\n        public vars: ASTList;\n        public scopes: ASTList;\n        // Remember if the module contains Unicode chars, that is needed for dynamic module as we will generate a file for each.\n        public containsUnicodeChar = false;\n        public containsUnicodeCharInComment = false;\n\n        constructor (name: Identifier, members: ASTList, vars: ASTList, scopes: ASTList, public endingToken: ASTSpan) {\n            super(NodeType.ModuleDeclaration, name, members);\n\n            this.vars = vars;\n            this.scopes = scopes;\n            this.prettyName = this.name.actualText;\n        }\n\n        public isExported() { return hasFlag(this.modFlags, ModuleFlags.Exported); }\n        public isAmbient() { return hasFlag(this.modFlags, ModuleFlags.Ambient); }\n        public isEnum() { return hasFlag(this.modFlags, ModuleFlags.IsEnum); }\n\n        public recordNonInterface() {\n            this.modFlags &= ~ModuleFlags.ShouldEmitModuleDecl;\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckModule(this);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            if (!hasFlag(this.modFlags, ModuleFlags.ShouldEmitModuleDecl)) {\n                emitter.emitParensAndCommentsInPlace(this, true);\n                emitter.emitJavascriptModule(this);\n                emitter.emitParensAndCommentsInPlace(this, false);\n            }\n        }\n    }\n\n    export class TypeDeclaration extends NamedDeclaration {\n        public varFlags = VarFlags.None;\n\n        constructor (nodeType: NodeType,\n                     name: Identifier,\n                     public extendsList: ASTList,\n                     public implementsList: ASTList,\n                     members: ASTList) {\n            super(nodeType, name, members);\n        }\n\n        public isExported() { \n            return hasFlag(this.varFlags, VarFlags.Exported);\n        }\n\n        public isAmbient() {\n            return hasFlag(this.varFlags, VarFlags.Ambient);\n        }\n    }\n\n    export class ClassDeclaration extends TypeDeclaration {\n        public knownMemberNames: any = {};\n        public constructorDecl: FuncDecl = null;\n        public constructorNestingLevel = 0;\n        public endingToken: ASTSpan = null;\n\n        constructor (name: Identifier,\n                     members: ASTList,\n                     extendsList: ASTList,\n                     implementsList: ASTList) {\n            super(NodeType.ClassDeclaration, name, extendsList, implementsList, members);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckClass(this);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitJavascriptClass(this);\n        }\n    }\n\n    export class InterfaceDeclaration extends TypeDeclaration {\n        constructor (name: Identifier,\n                     members: ASTList,\n                     extendsList: ASTList,\n                     implementsList: ASTList) {\n            super(NodeType.InterfaceDeclaration, name, extendsList, implementsList, members);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckInterface(this);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n        }\n    }\n\n    export class Statement extends ModuleElement {\n        constructor (nodeType: NodeType) {\n            super(nodeType);\n            this.flags |= ASTFlags.IsStatement;\n        }\n\n        public isLoop() { return false; }\n\n        public i';
var v27675 = v27676 + 'sStatementOrExpression() { return true; }\n\n        public isCompoundStatement() { return this.isLoop(); }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.type = typeFlow.voidType;\n            return this;\n        }\n    }\n\n    export class LabeledStatement extends Statement {\n        constructor (public labels: ASTList, public stmt: AST) {\n            super(NodeType.LabeledStatement);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (this.labels) {\n                var labelsLen = this.labels.members.length;\n                for (var i = 0; i < labelsLen; i++) {\n                    this.labels.members[i].emit(emitter, tokenId, startLine);\n                }\n            }\n            this.stmt.emit(emitter, tokenId, true);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            typeFlow.typeCheck(this.labels);\n            this.stmt = this.stmt.typeCheck(typeFlow);\n            return this;\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            var beforeBB = context.current;\n            var bb = new BasicBlock();\n            context.current = bb;\n            beforeBB.addSuccessor(bb);\n        }\n    }\n\n    export class Block extends Statement {\n        constructor (public statements: ASTList,\n                     public isStatementBlock: bool) {\n            super(NodeType.Block);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (this.isStatementBlock) {\n                emitter.writeLineToOutput(" {");\n                emitter.indenter.increaseIndent();\n            } else {\n                emitter.setInVarBlock(this.statements.members.length);\n            }\n            var temp = emitter.setInObjectLiteral(false);\n            if (this.statements) {\n                emitter.emitJavascriptList(this.statements, null, TokenID.Semicolon, true, false, false);\n            }\n            if (this.isStatementBlock) {\n                emitter.indenter.decreaseIndent();\n                emitter.emitIndent();\n                emitter.writeToOutput("}");\n            }\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public addToControlFlow(context: ControlFlowContext) {\n            var afterIfNeeded = new BasicBlock();\n            context.pushStatement(this, context.current, afterIfNeeded);\n            if (this.statements) {\n                context.walk(this.statements, this);\n            }\n            context.walker.options.goChildren = false;\n            context.popStatement();\n            if (afterIfNeeded.predecessors.length > 0) {\n                context.current.addSuccessor(afterIfNeeded);\n                context.current = afterIfNeeded;\n            }\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            if (!typeFlow.checker.styleSettings.emptyBlocks) {\n                if ((this.statements === null) || (this.statements.members.length == 0)) {\n                    typeFlow.checker.errorReporter.styleError(this, "empty block");\n                }\n            }\n\n            typeFlow.typeCheck(this.statements);\n            return this;\n        }\n    }\n\n    export class Jump extends Statement {\n        public target: string = null;\n        public hasExplicitTarget() { return (this.target); }\n        public resolvedTarget: Statement = null;\n\n        constructor (nodeType: NodeType) {\n            super(nodeType);\n        }\n\n        public setResolvedTarget(parser: Parser, stmt: Statement): bool {\n            if (stmt.isLoop()) {\n                this.resolvedTarget = stmt;\n                return true;\n            }\n            if (this.nodeType === NodeType.Continue) {\n                parser.reportParseError("continue statement applies only to loops");\n                return false;\n            }\n            else {\n                if ((stmt.nodeType == NodeType.Switch) || this.hasExplicitTarget()) {\n                    this.resolvedTarget = stmt;\n                    return true;\n                }\n                else {\n                    parser.reportParseError("break statement with no label can apply only to a loop or switch statement");\n                    return false;\n                }\n            }\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            super.addToControlFlow(context);\n            context.unconditionalBranch(this.resolvedTarget, (this.nodeType == NodeType.Continue));\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, s';
var v27674 = v27675 + 'tartLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (this.nodeType == NodeType.Break) {\n                emitter.writeToOutput("break");\n            }\n            else {\n                emitter.writeToOutput("continue");\n            }\n            if (this.hasExplicitTarget()) {\n                emitter.writeToOutput(" " + this.target);\n            }\n            emitter.recordSourceMappingEnd(this);\n            emitter.writeToOutput(";");\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n\n    export class WhileStatement extends Statement {\n        public body: AST = null;\n\n        constructor (public cond: AST) {\n            super(NodeType.While);\n        }\n\n        public isLoop() { return true; }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.writeToOutput("while(");\n            emitter.emitJavascript(this.cond, TokenID.While, false);\n            emitter.writeToOutput(")");\n            emitter.emitJavascriptStatements(this.body, false);\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckWhile(this);\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            var loopHeader = context.current;\n            var loopStart = new BasicBlock();\n            var afterLoop = new BasicBlock();\n\n            loopHeader.addSuccessor(loopStart);\n            context.current = loopStart;\n            context.addContent(this.cond);\n            var condBlock = context.current;\n            var targetInfo: ITargetInfo = null;\n            if (this.body) {\n                context.current = new BasicBlock();\n                condBlock.addSuccessor(context.current);\n                context.pushStatement(this, loopStart, afterLoop);\n                context.walk(this.body, this);\n                targetInfo = context.popStatement();\n            }\n            if (!(context.noContinuation)) {\n                var loopEnd = context.current;\n                loopEnd.addSuccessor(loopStart);\n            }\n            context.current = afterLoop;\n            condBlock.addSuccessor(afterLoop);\n            // TODO: check for while (true) and then only continue if afterLoop has predecessors\n            context.noContinuation = false;\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class DoWhileStatement extends Statement {\n        public body: AST = null;\n        public whileAST: AST = null;\n        public cond: AST = null;\n        public isLoop() { return true; }\n\n        constructor () {\n            super(NodeType.DoWhile);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.writeToOutput("do");\n            emitter.emitJavascriptStatements(this.body, true);\n            emitter.recordSourceMappingStart(this.whileAST);\n            emitter.writeToOutput("while");\n            emitter.recordSourceMappingEnd(this.whileAST);\n            emitter.writeToOutput(\'(\');\n            emitter.emitJavascript(this.cond, TokenID.CloseParen, false);\n            emitter.writeToOutput(")");\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.writeToOutput(";");\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckDoWhile(this);\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            var loopHeader = context.current;\n            var loopStart = new BasicBlock();\n            var afterLoop = new BasicBlock();\n            loopHeader.addSuccessor(loopStart);\n            context.current = loopStart;\n            var targetInfo: ITargetInfo = null;\n            if (this.body) {\n                context.pushStatement(this, loopStart, afterLoop);\n                context.walk(this.body, this);\n                targetInfo = context.popStatement();\n            }\n            if (!(context.noContinuation)) {\n                var loopEnd = context.current;\n                loopEnd.addSuccessor(loopStart);\n                context.addContent(this.cond);\n                // TODO: check for while (true) \n                context.current = afterLoop;\n                loopEnd.addSuccessor(afterLoop);\n            }\n            else {\n                context.addUnreachable(t';
var v27673 = v27674 + 'his.cond);\n            }\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class IfStatement extends Statement {\n        public thenBod: AST;\n        public elseBod: AST = null;\n        public statement: ASTSpan = new ASTSpan();\n\n        constructor (public cond: AST) {\n            super(NodeType.If);\n        }\n\n        public isCompoundStatement() { return true; }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.recordSourceMappingStart(this.statement);\n            emitter.writeToOutput("if(");\n            emitter.emitJavascript(this.cond, TokenID.If, false);\n            emitter.writeToOutput(")");\n            emitter.recordSourceMappingEnd(this.statement);\n            emitter.emitJavascriptStatements(this.thenBod, true);\n            if (this.elseBod) {\n                if (this.elseBod.nodeType === NodeType.If) {\n                    emitter.writeToOutput(" else ");\n                    this.elseBod.emit(emitter, tokenId, /*startLine:*/ false);\n                }\n                else {\n                    emitter.writeToOutput(" else");\n                    emitter.emitJavascriptStatements(this.elseBod, true);\n                }\n            }\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckIf(this);\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            this.cond.addToControlFlow(context);\n            var afterIf = new BasicBlock();\n            var beforeIf = context.current;\n            context.pushStatement(this, beforeIf, afterIf);\n            var hasContinuation = false;\n            context.current = new BasicBlock();\n            beforeIf.addSuccessor(context.current);\n            context.walk(this.thenBod, this);\n            if (!context.noContinuation) {\n                hasContinuation = true;\n                context.current.addSuccessor(afterIf);\n            }\n            if (this.elseBod) {\n                // current block will be thenBod\n                context.current = new BasicBlock();\n                context.noContinuation = false;\n                beforeIf.addSuccessor(context.current);\n                context.walk(this.elseBod, this);\n                if (!context.noContinuation) {\n                    hasContinuation = true;\n                    context.current.addSuccessor(afterIf);\n                }\n                else {\n                    // thenBod created continuation for if statement\n                    if (hasContinuation) {\n                        context.noContinuation = false;\n                    }\n                }\n            }\n            else {\n                beforeIf.addSuccessor(afterIf);\n                context.noContinuation = false;\n                hasContinuation = true;\n            }\n            var targetInfo = context.popStatement();\n            if (afterIf.predecessors.length > 0) {\n                context.noContinuation = false;\n                hasContinuation = true;\n            }\n            if (hasContinuation) {\n                context.current = afterIf;\n            }\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class ReturnStatement extends Statement {\n        public returnExpression: AST = null;\n\n        constructor () {\n            super(NodeType.Return);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            if (this.returnExpression) {\n                emitter.writeToOutput("return ");\n                emitter.emitJavascript(this.returnExpression, TokenID.Semicolon, false);\n\n                if (this.returnExpression.nodeType === NodeType.FuncDecl) {\n                    emitter.writeToOutput(";");\n                }\n            }\n            else {\n                emitter.writeToOutput("return;");\n            }\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            super.addToControlFlow(context);\n            context.returnStmt();\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckReturn(this);\n        }\n    }\n\n    export class EndCode extends AST {\n        constructor () {\n            super(NodeType.EndCode);\n        }\n    }\n\n    export class ForInStatement extends Statement {\n        constructor ';
var v27672 = v27673 + '(public lval: AST, public obj: AST) {\n            super(NodeType.ForIn);\n            if (this.lval && (this.lval.nodeType == NodeType.VarDecl)) {\n                (<BoundDecl>this.lval).varFlags |= VarFlags.AutoInit;\n            }\n        }\n        public statement: ASTSpan = new ASTSpan();\n        public body: AST;\n\n        public isLoop() { return true; }\n\n        public isFiltered() {\n            if (this.body) {\n                var singleItem: AST = null;\n                if (this.body.nodeType == NodeType.List) {\n                    var stmts = <ASTList>this.body;\n                    if (stmts.members.length == 1) {\n                        singleItem = stmts.members[0];\n                    }\n                }\n                else {\n                    singleItem = this.body;\n                }\n                // match template for filtering \'own\' properties from obj\n                if (singleItem !== null) {\n                    if (singleItem.nodeType == NodeType.Block) {\n                        var block = <Block>singleItem;\n                        if ((block.statements !== null) && (block.statements.members.length == 1)) {\n                            singleItem = block.statements.members[0];\n                        }\n                    }\n                    if (singleItem.nodeType == NodeType.If) {\n                        var cond = (<IfStatement>singleItem).cond;\n                        if (cond.nodeType == NodeType.Call) {\n                            var target = (<CallExpression>cond).target;\n                            if (target.nodeType == NodeType.Dot) {\n                                var binex = <BinaryExpression>target;\n                                if ((binex.operand1.nodeType == NodeType.Name) &&\n                                    (this.obj.nodeType == NodeType.Name) &&\n                                    ((<Identifier>binex.operand1).actualText == (<Identifier>this.obj).actualText)) {\n                                    var prop = <Identifier>binex.operand2;\n                                    if (prop.actualText == "hasOwnProperty") {\n                                        var args = (<CallExpression>cond).arguments;\n                                        if ((args !== null) && (args.members.length == 1)) {\n                                            var arg = args.members[0];\n                                            if ((arg.nodeType == NodeType.Name) &&\n                                                 (this.lval.nodeType == NodeType.Name)) {\n                                                if (((<Identifier>this.lval).actualText) == (<Identifier>arg).actualText) {\n                                                    return true;\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.recordSourceMappingStart(this.statement);\n            emitter.writeToOutput("for(");\n            emitter.emitJavascript(this.lval, TokenID.For, false);\n            emitter.writeToOutput(" in ");\n            emitter.emitJavascript(this.obj, TokenID.For, false);\n            emitter.writeToOutput(")");\n            emitter.recordSourceMappingEnd(this.statement);\n            emitter.emitJavascriptStatements(this.body, true);\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            if (typeFlow.checker.styleSettings.forin) {\n                if (!this.isFiltered()) {\n                    typeFlow.checker.errorReporter.styleError(this, "no hasOwnProperty filter");\n                }\n            }\n            return typeFlow.typeCheckForIn(this);\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            if (this.lval) {\n                context.addContent(this.lval);\n            }\n            if (this.obj) {\n                context.addContent(this.obj);\n            }\n\n            var loopHeader = context.current;\n            var loopStart = new BasicBlock();\n            var afterLoop = new BasicBlock();\n\n            loopHeader.addSuccessor(loopStart);\n            context.current = loopStart;\n            if (this.body) {\n                context.pushStatement(this, loopStart, afterLoop);\n                context.walk(this.body, this);\n                context.popStatement();\n            }\n            if (!(context.noContinuation)) {\n                var loopE';
var v27671 = v27672 + 'nd = context.current;\n                loopEnd.addSuccessor(loopStart);\n            }\n            context.current = afterLoop;\n            context.noContinuation = false;\n            loopHeader.addSuccessor(afterLoop);\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class ForStatement extends Statement {\n        public cond: AST;\n        public body: AST;\n        public incr: AST;\n\n        constructor (public init: AST) {\n            super(NodeType.For);\n        }\n\n        public isLoop() { return true; }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.writeToOutput("for(");\n            if (this.init) {\n                if (this.init.nodeType != NodeType.List) {\n                    emitter.emitJavascript(this.init, TokenID.For, false);\n                }\n                else {\n                    emitter.setInVarBlock((<ASTList>this.init).members.length); \n                    emitter.emitJavascriptList(this.init, null, TokenID.For, false, false, false);\n                }\n            }\n            emitter.writeToOutput("; ");\n            emitter.emitJavascript(this.cond, TokenID.For, false);\n            emitter.writeToOutput("; ");\n            emitter.emitJavascript(this.incr, TokenID.For, false);\n            emitter.writeToOutput(")");\n            emitter.emitJavascriptStatements(this.body, true);\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckFor(this);\n        }\n\n        public addToControlFlow(context: ControlFlowContext): void {\n            if (this.init) {\n                context.addContent(this.init);\n            }\n            var loopHeader = context.current;\n            var loopStart = new BasicBlock();\n            var afterLoop = new BasicBlock();\n\n            loopHeader.addSuccessor(loopStart);\n            context.current = loopStart;\n            var condBlock: BasicBlock = null;\n            var continueTarget = loopStart;\n            var incrBB: BasicBlock = null;\n            if (this.incr) {\n                incrBB = new BasicBlock();\n                continueTarget = incrBB;\n            }\n            if (this.cond) {\n                condBlock = context.current;\n                context.addContent(this.cond);\n                context.current = new BasicBlock();\n                condBlock.addSuccessor(context.current);\n            }\n            var targetInfo: ITargetInfo = null;\n            if (this.body) {\n                context.pushStatement(this, continueTarget, afterLoop);\n                context.walk(this.body, this);\n                targetInfo = context.popStatement();\n            }\n            if (this.incr) {\n                if (context.noContinuation) {\n                    if (incrBB.predecessors.length == 0) {\n                        context.addUnreachable(this.incr);\n                    }\n                }\n                else {\n                    context.current.addSuccessor(incrBB);\n                    context.current = incrBB;\n                    context.addContent(this.incr);\n                }\n            }\n            var loopEnd = context.current;\n            if (!(context.noContinuation)) {\n                loopEnd.addSuccessor(loopStart);\n\n            }\n            if (condBlock) {\n                condBlock.addSuccessor(afterLoop);\n                context.noContinuation = false;\n            }\n            if (afterLoop.predecessors.length > 0) {\n                context.noContinuation = false;\n                context.current = afterLoop;\n            }\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class WithStatement extends Statement {\n        public body: AST;\n\n        public isCompoundStatement() { return true; }\n\n        public withSym: WithSymbol = null;\n\n        constructor (public expr: AST) {\n            super(NodeType.With);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput("with (");\n            if (this.expr) {\n                emitter.emitJavascript(this.expr, TokenID.With, false);\n            }\n\n            emitter.writeToOutput(")");\n            emitter.emitJavascriptStatements(this.body, true);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            return typeFlow.typeCheckWith(this);\n        }\n    }\n\n    export class SwitchStatement extends Statement {\n        public caseList:';
var v27670 = v27671 + ' ASTList;\n        public defaultCase: CaseStatement = null;\n        public statement: ASTSpan = new ASTSpan();\n\n        constructor (public val: AST) {\n            super(NodeType.Switch);\n        }\n\n        public isCompoundStatement() { return true; }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            var temp = emitter.setInObjectLiteral(false);\n            emitter.recordSourceMappingStart(this.statement);\n            emitter.writeToOutput("switch(");\n            emitter.emitJavascript(this.val, TokenID.Identifier, false);\n            emitter.writeToOutput(")"); \n            emitter.recordSourceMappingEnd(this.statement);\n            emitter.writeLineToOutput(" {");\n            emitter.indenter.increaseIndent();\n            var casesLen = this.caseList.members.length;\n            for (var i = 0; i < casesLen; i++) {\n                var caseExpr = this.caseList.members[i];\n                emitter.emitJavascript(caseExpr, TokenID.Case, true);\n            }\n            emitter.indenter.decreaseIndent();\n            emitter.emitIndent();\n            emitter.writeToOutput("}");\n            emitter.setInObjectLiteral(temp);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            var len = this.caseList.members.length;\n            this.val = typeFlow.typeCheck(this.val);\n            for (var i = 0; i < len; i++) {\n                this.caseList.members[i] = typeFlow.typeCheck(this.caseList.members[i]);\n            }\n            this.defaultCase = <CaseStatement>typeFlow.typeCheck(this.defaultCase);\n            this.type = typeFlow.voidType;\n            return this;\n        }\n\n        // if there are break statements that match this switch, then just link cond block with block after switch\n        public addToControlFlow(context: ControlFlowContext) {\n            var condBlock = context.current;\n            context.addContent(this.val);\n            var execBlock = new BasicBlock();\n            var afterSwitch = new BasicBlock();\n\n            condBlock.addSuccessor(execBlock);\n            context.pushSwitch(execBlock);\n            context.current = execBlock;\n            context.pushStatement(this, execBlock, afterSwitch);\n            context.walk(this.caseList, this);\n            context.popSwitch();\n            var targetInfo = context.popStatement();\n            var hasCondContinuation = (this.defaultCase == null);\n            if (this.defaultCase == null) {\n                condBlock.addSuccessor(afterSwitch);\n            }\n            if (afterSwitch.predecessors.length > 0) {\n                context.noContinuation = false;\n                context.current = afterSwitch;\n            }\n            else {\n                context.noContinuation = true;\n            }\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class CaseStatement extends Statement {\n        public expr: AST = null;\n        public body: ASTList;\n\n        constructor () {\n            super(NodeType.Case);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            if (this.expr) {\n                emitter.writeToOutput("case ");\n                emitter.emitJavascript(this.expr, TokenID.Identifier, false);\n            }\n            else {\n                emitter.writeToOutput("default");\n            }\n            emitter.writeToOutput(":");\n            if (this.body.members.length == 1 && this.body.members[0].nodeType == NodeType.Block) {\n                // The case statement was written with curly braces, so emit it with the appropriate formatting\n                emitter.emitJavascriptStatements(this.body, false);\n            }\n            else {\n                // No curly braces. Format in the expected way\n                emitter.writeLineToOutput("");\n                emitter.indenter.increaseIndent();\n                emitter.emitBareJavascriptStatements(this.body);\n                emitter.indenter.decreaseIndent();\n            }\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.expr = typeFlow.typeCheck(this.expr);\n            typeFlow.typeCheck(this.body);\n            this.type = typeFlow.voidType;\n            return this;\n        }\n\n        // TODO: more reasoning about unreachable cases (such as duplicate literals as case expressions)\n        // for now, assume all cases are reachable, regardless of whether some cases fall through\n        public addToControlFlow(context: ControlFlowContext) {\n            var execBlock = new BasicBlock();\n            v';
var v27669 = v27670 + 'ar sw = context.currentSwitch[context.currentSwitch.length - 1];\n            // TODO: fall-through from previous (+ to end of switch)\n            if (this.expr) {\n                var exprBlock = new BasicBlock();\n                context.current = exprBlock;\n                sw.addSuccessor(exprBlock);\n                context.addContent(this.expr);\n                exprBlock.addSuccessor(execBlock);\n            }\n            else {\n                sw.addSuccessor(execBlock);\n            }\n            context.current = execBlock;\n            if (this.body) {\n                context.walk(this.body, this);\n            }\n            context.noContinuation = false;\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class TypeReference extends AST {\n        constructor (public term: AST, public arrayCount: number) {\n            super(NodeType.TypeRef);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            throw new Error("should not emit a type ref");\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            var prevInTCTR = typeFlow.inTypeRefTypeCheck;\n            typeFlow.inTypeRefTypeCheck = true;\n            var typeLink = getTypeLink(this, typeFlow.checker, true);\n            typeFlow.checker.resolveTypeLink(typeFlow.scope, typeLink, false);\n\n            if (this.term) {\n                typeFlow.typeCheck(this.term);\n            }\n\n            typeFlow.checkForVoidConstructor(typeLink.type, this);\n\n            this.type = typeLink.type;\n\n            // in error recovery cases, there may not be a term\n            if (this.term) {\n                this.term.type = this.type;\n            }\n\n            typeFlow.inTypeRefTypeCheck = prevInTCTR;\n            return this;\n        }\n    }\n\n    export class TryFinally extends Statement {\n        constructor (public tryNode: AST, public finallyNode: Finally) {\n            super(NodeType.TryFinally);\n        }\n\n        public isCompoundStatement() { return true; }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.recordSourceMappingStart(this);\n            emitter.emitJavascript(this.tryNode, TokenID.Try, false);\n            emitter.emitJavascript(this.finallyNode, TokenID.Finally, false);\n            emitter.recordSourceMappingEnd(this);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.tryNode = typeFlow.typeCheck(this.tryNode);\n            this.finallyNode = <Finally>typeFlow.typeCheck(this.finallyNode);\n            this.type = typeFlow.voidType;\n            return this;\n        }\n\n        public addToControlFlow(context: ControlFlowContext) {\n            var afterFinally = new BasicBlock();\n            context.walk(this.tryNode, this);\n            var finBlock = new BasicBlock();\n            if (context.current) {\n                context.current.addSuccessor(finBlock);\n            }\n            context.current = finBlock;\n            context.pushStatement(this, null, afterFinally);\n            context.walk(this.finallyNode, this);\n            if (!context.noContinuation && context.current) {\n                context.current.addSuccessor(afterFinally);\n            }\n            if (afterFinally.predecessors.length > 0) {\n                context.current = afterFinally;\n            }\n            else {\n                context.noContinuation = true;\n            }\n            context.popStatement();\n            context.walker.options.goChildren = false;\n        }\n    }\n\n    export class TryCatch extends Statement {\n        constructor (public tryNode: Try, public catchNode: Catch) {\n            super(NodeType.TryCatch);\n        }\n\n        public isCompoundStatement() { return true; }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.emitJavascript(this.tryNode, TokenID.Try, false);\n            emitter.emitJavascript(this.catchNode, TokenID.Catch, false);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public addToControlFlow(context: ControlFlowContext) {\n            var beforeTry = context.current;\n            var tryBlock = new BasicBlock();\n            beforeTry.addSuccessor(tryBlock);\n            context.current = tryBlock;\n            var afterTryCatch = new BasicBlock();\n            context.pushStatement(this, null, afterTryCatch);\n            context.walk(this.tryNode, this);\n            if (!context.noContinuation) {\n                if (context.current) {\n                    context.current.addSuccessor(afterTryCatch);\n                }\n            }\n            context.current = new BasicBlock();\n            beforeTry.addSuccessor(context.current);\n            context.walk(this.catchNode, this);\n            context.popStatement();\n            if (!context.noContinuation)';
var v27668 = v27669 + ' {\n                if (context.current) {\n                    context.current.addSuccessor(afterTryCatch);\n                }\n            }\n            context.current = afterTryCatch;\n            context.walker.options.goChildren = false;\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.tryNode = <Try>typeFlow.typeCheck(this.tryNode);\n            this.catchNode = <Catch>typeFlow.typeCheck(this.catchNode);\n            this.type = typeFlow.voidType;\n            return this;\n        }\n    }\n\n    export class Try extends Statement {\n        constructor (public body: AST) {\n            super(NodeType.Try);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput("try ");\n            emitter.emitJavascript(this.body, TokenID.Try, false);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.body = typeFlow.typeCheck(this.body);\n            return this;\n        }\n\n        public addToControlFlow(context: ControlFlowContext) {\n            if (this.body) {\n                context.walk(this.body, this);\n            }\n            context.walker.options.goChildren = false;\n            context.noContinuation = false;\n        }\n    }\n\n    export class Catch extends Statement {\n        constructor (public param: VarDecl, public body: AST) {\n            super(NodeType.Catch);\n            if (this.param) {\n                this.param.varFlags |= VarFlags.AutoInit;\n            }\n        }\n        public statement: ASTSpan = new ASTSpan();\n        public containedScope: SymbolScope = null;\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput(" ");\n            emitter.recordSourceMappingStart(this.statement);\n            emitter.writeToOutput("catch (");\n            emitter.emitJavascript(this.param, TokenID.OpenParen, false);\n            emitter.writeToOutput(")");\n            emitter.recordSourceMappingEnd(this.statement);\n            emitter.emitJavascript(this.body, TokenID.Catch, false);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public addToControlFlow(context: ControlFlowContext) {\n            if (this.param) {\n                context.addContent(this.param);\n                var bodBlock = new BasicBlock();\n                context.current.addSuccessor(bodBlock);\n                context.current = bodBlock;\n            }\n            if (this.body) {\n                context.walk(this.body, this);\n            }\n            context.noContinuation = false;\n            context.walker.options.goChildren = false;\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            var prevScope = typeFlow.scope;\n            typeFlow.scope = this.containedScope;\n            this.param = <VarDecl>typeFlow.typeCheck(this.param);\n            var exceptVar = new ValueLocation();\n            var varSym = new VariableSymbol((<VarDecl>this.param).id.text,\n                                          this.param.minChar,\n                                          typeFlow.checker.locationInfo.unitIndex,\n                                          exceptVar);\n            exceptVar.symbol = varSym;\n            exceptVar.typeLink = new TypeLink();\n            // var type for now (add syntax for type annotation)\n            exceptVar.typeLink.type = typeFlow.anyType;\n            var thisFnc = typeFlow.thisFnc;\n            if (thisFnc && thisFnc.type) {\n                exceptVar.symbol.container = thisFnc.type.symbol;\n            }\n            else {\n                exceptVar.symbol.container = null;\n            }\n            this.param.sym = exceptVar.symbol;\n            typeFlow.scope.enter(exceptVar.symbol.container, this.param, exceptVar.symbol,\n                                 typeFlow.checker.errorReporter, false, false, false);\n            this.body = typeFlow.typeCheck(this.body);\n\n            // if we\'re in provisional typecheck mode, clean up the symbol entry\n            // REVIEW: This is obviously bad form, since we\'re counting on the internal\n            // layout of the symbol table, but this is also the only place where we insert\n            // symbols during typecheck\n            if (typeFlow.checker.inProvisionalTypecheckMode()) {\n                var table = typeFlow.scope.getTable();\n                (<any>table).secondaryTable.table[exceptVar.symbol.name] = undefined;\n            }\n            this.type = typeFlow.voidType;\n            typeFlow.scope = prevScope;\n            return this;\n        }\n    }\n\n    export class Finally extends Statement ';
var v27667 = v27668 + '{\n        constructor (public body: AST) {\n            super(NodeType.Finally);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeToOutput("finally");\n            emitter.emitJavascript(this.body, TokenID.Finally, false);\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n\n        public addToControlFlow(context: ControlFlowContext) {\n            if (this.body) {\n                context.walk(this.body, this);\n            }\n            context.walker.options.goChildren = false;\n            context.noContinuation = false;\n        }\n\n        public typeCheck(typeFlow: TypeFlow) {\n            this.body = typeFlow.typeCheck(this.body);\n            return this;\n        }\n    }\n\n    export class Comment extends AST {\n\n        public text: string[] = null;\n        public minLine: number;\n        public limLine: number;\n        private docCommentText: string = null;\n\n        constructor (public content: string, public isBlockComment: bool, public endsLine) {\n            super(NodeType.Comment);\n        }\n\n        public getText(): string[] {\n            if (this.text == null) {\n                if (this.isBlockComment) {\n                    this.text = this.content.split("\\n");\n                    for (var i = 0; i < this.text.length; i++) {\n                        this.text[i] = this.text[i].replace(/^\\s+|\\s+$/g, \'\');\n                    }\n                }\n                else {\n                    this.text = [(this.content.replace(/^\\s+|\\s+$/g, \'\'))];\n                }\n            }\n\n            return this.text;\n        }\n\n        public isDocComment() {\n            if (this.isBlockComment) {\n                return this.content.charAt(2) == "*";\n            }\n\n            return false;\n        }\n\n        public getDocCommentText() {\n            if (this.docCommentText == null) {\n                this.docCommentText = Comment.cleanJSDocComment(this.content);\n            }\n\n            return this.docCommentText;\n        }\n\n        static consumeLeadingSpace(line: string, startIndex: number, maxSpacesToRemove?: number) {\n            var endIndex = line.length;\n            if (maxSpacesToRemove != undefined) {\n                endIndex = min(startIndex + maxSpacesToRemove, endIndex);\n            }\n\n            for (; startIndex < endIndex; startIndex++) {\n                var charCode = line.charCodeAt(startIndex);\n                if (charCode != LexCodeSpace && charCode != LexCodeTAB) {\n                    return startIndex;\n                }\n            }\n            \n            if (endIndex != line.length) {\n                return endIndex;\n            }\n\n            return -1;\n        }\n\n        static isSpaceChar(line: string, index: number) {\n            var length = line.length;\n            if (index < length) {\n                var charCode = line.charCodeAt(index);\n                // If the character is space\n                return charCode == LexCodeSpace || charCode == LexCodeTAB;\n            }\n\n            // If the index is end of the line it is space\n            return index == length;\n        }\n\n        static cleanDocCommentLine(line: string, jsDocStyleComment: bool, jsDocLineSpaceToRemove?: number) {\n            var nonSpaceIndex = Comment.consumeLeadingSpace(line, 0);\n            if (nonSpaceIndex != -1) {\n                var jsDocSpacesRemoved = nonSpaceIndex;\n                if (jsDocStyleComment && line.charAt(nonSpaceIndex) == \'*\') { // remove leading * in case of jsDocComment\n                    var startIndex = nonSpaceIndex + 1;\n                    nonSpaceIndex = Comment.consumeLeadingSpace(line, startIndex, jsDocLineSpaceToRemove);\n\n                    if (nonSpaceIndex != -1) {\n                        jsDocSpacesRemoved = nonSpaceIndex - startIndex;\n                    } else {\n                        return null;\n                    }\n                }\n\n                return {\n                    minChar: nonSpaceIndex,\n                    limChar: line.charAt(line.length - 1) == "\\r" ? line.length - 1 : line.length,\n                    jsDocSpacesRemoved: jsDocSpacesRemoved\n                };\n            }\n\n            return null;\n        }\n\n        static cleanJSDocComment(content: string, spacesToRemove?: number) {\n            var docCommentLines: string[] = [];\n            content = content.replace("/**", ""); // remove /**\n            if (content.length >= 2 && content.charAt(content.length - 1) == "/" && content.charAt(content.length - 2) == "*") {\n                content = content.substring(0, content.length - 2); // remove last */\n            }\n            var lines = content.split("\\n");\n            var inParamTag = false;\n            for (var l = 0; l < lines.length; l++) {\n                var line = lines[l];\n                var clean';
var v27666 = v27667 + 'LinePos = Comment.cleanDocCommentLine(line, true, spacesToRemove);\n                if (!cleanLinePos) {\n                    // Whole line empty, read next line\n                    continue;\n                }\n\n                var docCommentText = "";\n                var prevPos = cleanLinePos.minChar;\n                for (var i = line.indexOf("@", cleanLinePos.minChar); 0 <= i && i < cleanLinePos.limChar; i = line.indexOf("@", i + 1)) {\n                    // We have encoutered @. \n                    // If we were omitting param comment, we dont have to do anything\n                    // other wise the content of the text till @ tag goes as doc comment\n                    var wasInParamtag = inParamTag;\n\n                    // Parse contents next to @\n                    if (line.indexOf("param", i + 1) == i + 1 && Comment.isSpaceChar(line, i + 6)) {\n                        // It is param tag. \n\n                        // If we were not in param tag earlier, push the contents from prev pos of the tag this tag start as docComment\n                        if (!wasInParamtag) {\n                            docCommentText += line.substring(prevPos, i);\n                        }\n\n                        // New start of contents \n                        prevPos = i;\n                        inParamTag = true;\n                    } else if (wasInParamtag) {\n                        // Non param tag start\n                        prevPos = i;\n                        inParamTag = false;\n                    }\n                }\n\n                if (!inParamTag) {\n                    docCommentText += line.substring(prevPos, cleanLinePos.limChar);\n                }\n\n                // Add line to comment text if it is not only white space line\n                var newCleanPos = Comment.cleanDocCommentLine(docCommentText, false);\n                if (newCleanPos) {\n                    if (spacesToRemove == undefined) {\n                        spacesToRemove = cleanLinePos.jsDocSpacesRemoved;\n                    }\n                    docCommentLines.push(docCommentText);\n                }\n            }\n            \n            return docCommentLines.join("\\n");\n        }\n\n        static getDocCommentText(comments: Comment[]) {\n            var docCommentText: string[] = [];\n            for (var c = 0 ; c < comments.length; c++) {\n                var commentText = comments[c].getDocCommentText();\n                if (commentText != "") {\n                    docCommentText.push(commentText);\n                }\n            }\n            return docCommentText.join("\\n");\n        }\n\n        static getParameterDocCommentText(param: string, fncDocComments: Comment[]) {\n            if (fncDocComments.length == 0 || !fncDocComments[0].isBlockComment) {\n                // there were no fnc doc comments and the comment is not block comment then it cannot have \n                // @param comment that can be parsed\n                return "";\n            }\n            \n            for (var i = 0; i < fncDocComments.length; i++) {\n                var commentContents = fncDocComments[i].content;\n                for (var j = commentContents.indexOf("@param", 0); 0 <= j; j = commentContents.indexOf("@param", j)) {\n                    j += 6;\n                    if (!Comment.isSpaceChar(commentContents, j)) {\n                        // This is not param tag but a tag line @paramxxxxx\n                        continue;\n                    }\n\n                    // This is param tag. Check if it is what we are looking for\n                    j = Comment.consumeLeadingSpace(commentContents, j);\n                    if (j == -1) {\n                        break;\n                    }\n                    \n                    // Ignore the type expression\n                    if (commentContents.charCodeAt(j) == LexCodeLC) {\n                        j++;\n                        // Consume the type\n                        var charCode = 0;\n                        for (var curlies = 1; j < commentContents.length; j++) {\n                            charCode = commentContents.charCodeAt(j);\n                            // { character means we need to find another } to match the found one\n                            if (charCode == LexCodeLC) {\n                                curlies++;\n                                continue;\n                            }\n\n                            // } char\n                            if (charCode == LexCodeRC) {\n                                curlies--;\n                                if (curlies == 0) {\n                                    // We do not have any more } to match the type expression is ignored completely\n                                    break;\n                                } else {\n                                    // there are more { to be matched with }\n                                    continue;\n                                }\n                            }\n\n                            // Found start';
var v27665 = v27666 + ' of another tag\n                            if (charCode == LexCodeAtSign) {\n                                break;\n                            }\n                        }\n\n                        // End of the comment\n                        if (j == commentContents.length) {\n                            break;\n                        }\n\n                        // End of the tag, go onto looking for next tag\n                        if (charCode == LexCodeAtSign) {\n                            continue;\n                        }\n\n                        j = Comment.consumeLeadingSpace(commentContents, j + 1);\n                        if (j == -1) {\n                            break;\n                        }\n                    }\n\n                    // Parameter name\n                    if (param != commentContents.substr(j, param.length) || !Comment.isSpaceChar(commentContents, j + param.length)) {\n                        // this is not the parameter we are looking for\n                        continue;\n                    }\n\n                    // Found the parameter we were looking for\n                    j = Comment.consumeLeadingSpace(commentContents, j + param.length);\n                    if (j == -1) {\n                        return "";\n                    }\n                    \n                    var endOfParam = commentContents.indexOf("@", j);\n                    var paramHelpString = commentContents.substring(j, endOfParam < 0 ? commentContents.length : endOfParam);\n\n                    // Find alignement spaces to remove\n                    var paramSpacesToRemove: number = undefined;\n                    var paramLineIndex = commentContents.substring(0, j).lastIndexOf("\\n") + 1;\n                    if (paramLineIndex != 0) {\n                        if (paramLineIndex < j && commentContents.charAt(paramLineIndex + 1) == "\\r") {\n                            paramLineIndex++;\n                        }\n                    }\n                    var startSpaceRemovalIndex = Comment.consumeLeadingSpace(commentContents, paramLineIndex);\n                    if (startSpaceRemovalIndex != j && commentContents.charAt(startSpaceRemovalIndex) == "*") {\n                        paramSpacesToRemove = j - startSpaceRemovalIndex - 1;\n                    }\n\n                    // Clean jsDocComment and return\n                    return Comment.cleanJSDocComment(paramHelpString, paramSpacesToRemove);\n                }\n            }\n\n            return "";\n        }\n\n        static getDocCommentTextOfSignatures(signatures: Signature[]) {\n            var comments: string[] = [];\n            for (var i = 0; i < signatures.length; i++) {\n                var signatureDocComment = TypeScript.Comment.getDocCommentText(signatures[i].declAST.getDocComments());\n                if (signatureDocComment != "") {\n                    comments.push(signatureDocComment);\n                }\n            }\n\n            return comments.join("\\n");\n        }\n    }\n\n    export class DebuggerStatement extends Statement {\n        constructor () {\n            super(NodeType.Debugger);\n        }\n\n        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {\n            emitter.emitParensAndCommentsInPlace(this, true);\n            emitter.recordSourceMappingStart(this);\n            emitter.writeLineToOutput("debugger;");\n            emitter.recordSourceMappingEnd(this);\n            emitter.emitParensAndCommentsInPlace(this, false);\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript.AstWalkerWithDetailCallback {\n    export interface AstWalkerDetailCallback {\n        EmptyCallback? (pre, ast: AST): bool;\n        EmptyExprCallback? (pre, ast: AST): bool;\n        TrueCallback? (pre, ast: AST): bool;\n        FalseCallback? (pre, ast: AST): bool;\n        ThisCallback? (pre, ast: AST): bool;\n        SuperCallback? (pre, ast: AST): bool;\n        QStringCallback? (pre, ast: AST): bool;\n        RegexCallback? (pre, ast: AST): bool;\n        NullCallback? (pre, ast: AST): bool;\n        ArrayLitCallback? (pre, ast: AST): bool;\n        ObjectLitCallback? (pre, ast: AST): bool;\n        VoidCallback? (pre, ast: AST): bool;\n        CommaCallback? (pre, ast: AST): bool;\n        PosCallback? (pre, ast: AST): bool;\n        NegCallback? (pre, ast: AST): bool;\n        DeleteCallback? (pre, ast: AST): bool;\n        AwaitCal';
var v27664 = v27665 + "lback? (pre, ast: AST): bool;\n        InCallback? (pre, ast: AST): bool;\n        DotCallback? (pre, ast: AST): bool;\n        FromCallback? (pre, ast: AST): bool;\n        IsCallback? (pre, ast: AST): bool;\n        InstOfCallback? (pre, ast: AST): bool;\n        TypeofCallback? (pre, ast: AST): bool;\n        NumberLitCallback? (pre, ast: AST): bool;\n        NameCallback? (pre, identifierAst: Identifier): bool;\n        TypeRefCallback? (pre, ast: AST): bool;\n        IndexCallback? (pre, ast: AST): bool;\n        CallCallback? (pre, ast: AST): bool;\n        NewCallback? (pre, ast: AST): bool;\n        AsgCallback? (pre, ast: AST): bool;\n        AsgAddCallback? (pre, ast: AST): bool;\n        AsgSubCallback? (pre, ast: AST): bool;\n        AsgDivCallback? (pre, ast: AST): bool;\n        AsgMulCallback? (pre, ast: AST): bool;\n        AsgModCallback? (pre, ast: AST): bool;\n        AsgAndCallback? (pre, ast: AST): bool;\n        AsgXorCallback? (pre, ast: AST): bool;\n        AsgOrCallback? (pre, ast: AST): bool;\n        AsgLshCallback? (pre, ast: AST): bool;\n        AsgRshCallback? (pre, ast: AST): bool;\n        AsgRs2Callback? (pre, ast: AST): bool;\n        QMarkCallback? (pre, ast: AST): bool;\n        LogOrCallback? (pre, ast: AST): bool;\n        LogAndCallback? (pre, ast: AST): bool;\n        OrCallback? (pre, ast: AST): bool;\n        XorCallback? (pre, ast: AST): bool;\n        AndCallback? (pre, ast: AST): bool;\n        EqCallback? (pre, ast: AST): bool;\n        NeCallback? (pre, ast: AST): bool;\n        EqvCallback? (pre, ast: AST): bool;\n        NEqvCallback? (pre, ast: AST): bool;\n        LtCallback? (pre, ast: AST): bool;\n        LeCallback? (pre, ast: AST): bool;\n        GtCallback? (pre, ast: AST): bool;\n        GeCallback? (pre, ast: AST): bool;\n        AddCallback? (pre, ast: AST): bool;\n        SubCallback? (pre, ast: AST): bool;\n        MulCallback? (pre, ast: AST): bool;\n        DivCallback? (pre, ast: AST): bool;\n        ModCallback? (pre, ast: AST): bool;\n        LshCallback? (pre, ast: AST): bool;\n        RshCallback? (pre, ast: AST): bool;\n        Rs2Callback? (pre, ast: AST): bool;\n        NotCallback? (pre, ast: AST): bool;\n        LogNotCallback? (pre, ast: AST): bool;\n        IncPreCallback? (pre, ast: AST): bool;\n        DecPreCallback? (pre, ast: AST): bool;\n        IncPostCallback? (pre, ast: AST): bool;\n        DecPostCallback? (pre, ast: AST): bool;\n        TypeAssertionCallback? (pre, ast: AST): bool;\n        FuncDeclCallback? (pre, funcDecl: FuncDecl): bool;\n        MemberCallback? (pre, ast: AST): bool;\n        VarDeclCallback? (pre, varDecl: VarDecl): bool;\n        ArgDeclCallback? (pre, ast: AST): bool;\n        ReturnCallback? (pre, ast: AST): bool;\n        BreakCallback? (pre, ast: AST): bool;\n        ContinueCallback? (pre, ast: AST): bool;\n        ThrowCallback? (pre, ast: AST): bool;\n        ForCallback? (pre, ast: AST): bool;\n        ForInCallback? (pre, ast: AST): bool;\n        IfCallback? (pre, ast: AST): bool;\n        WhileCallback? (pre, ast: AST): bool;\n        DoWhileCallback? (pre, ast: AST): bool;\n        BlockCallback? (pre, block: Block): bool;\n        CaseCallback? (pre, ast: AST): bool;\n        SwitchCallback? (pre, ast: AST): bool;\n        TryCallback? (pre, ast: AST): bool;\n        TryCatchCallback? (pre, ast: AST): bool;\n        TryFinallyCallback? (pre, ast: AST): bool;\n        FinallyCallback? (pre, ast: AST): bool;\n        CatchCallback? (pre, ast: AST): bool;\n        ListCallback? (pre, astList: ASTList): bool;\n        ScriptCallback? (pre, script: Script): bool;\n        ClassDeclarationCallback? (pre, ast: AST): bool;\n        InterfaceDeclarationCallback? (pre, interfaceDecl: InterfaceDeclaration): bool;\n        ModuleDeclarationCallback? (pre, moduleDecl: ModuleDeclaration): bool;\n        ImportDeclarationCallback? (pre, ast: AST): bool;\n        WithCallback? (pre, ast: AST): bool;\n        LabelCallback? (pre, labelAST: AST): bool;\n        LabeledStatementCallback? (pre, ast: AST): bool;\n        EBStartCallback? (pre, ast: AST): bool;\n        GotoEBCallback? (pre, ast: AST): bool;\n        EndCodeCallback? (pre, ast: AST): bool;\n        ErrorCallback? (pre, ast: AST): bool;\n        CommentCallback? (pre, ast: AST): bool;\n        DebuggerCallback? (pre, ast: AST): bool;\n        DefaultCallback? (pre, ast: AST): bool;\n    }\n\n    export function walk(script: Script, callback: AstWalkerDetailCallback): void {\n        var pre = (cur: AST, parent: AST) => {\n            walker.options.goChildren = AstWalkerCallback(true, cur, callback);\n            return cur;\n        }\n\n        var post = (cur: AST, parent: AST) => {\n            AstWalkerCallback(false, cur, callback);\n            return cur;\n        }\n\n        var walker = TypeScript.getAstWalkerFactory().getWalker(pre, post);\n        walker.walk(script, null);\n    }\n\n    function AstWalkerCallback(pre: bool, ast: AST, callback: AstWalkerDetailCallback): bool {\n        // See if the Callback needs to be handled using spe";
var v27663 = v27664 + 'cific one or default one\n        var nodeType = ast.nodeType;\n        var callbackString = (<any>NodeType)._map[nodeType] + "Callback";\n        if (callback[callbackString]) {\n            return callback[callbackString](pre, ast);\n        }\n\n        if (callback.DefaultCallback) {\n            return callback.DefaultCallback(pre, ast);\n        }\n\n        return true;\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export interface IAstWalker {\n        walk(ast: AST, parent: AST): AST;\n        options: AstWalkOptions;\n        state: any; // user state object\n    }\n\n    export class AstWalkOptions {\n        public goChildren = true;\n        public goNextSibling = true;\n        public reverseSiblings = false; // visit siblings in reverse execution order\n\n        public stopWalk(stop:bool = true) {\n            this.goChildren = !stop;\n            this.goNextSibling = !stop;\n        }\n    }\n\n    export interface IAstWalkCallback {\n        (ast: AST, parent: AST, walker: IAstWalker): AST;\n    }\n\n    export interface IAstWalkChildren {\n        (preAst: AST, parent: AST, walker: IAstWalker): void;\n    }\n\n    class AstWalker implements IAstWalker {\n        constructor (\n            private childrenWalkers: IAstWalkChildren[],\n            private pre: IAstWalkCallback,\n            private post: IAstWalkCallback,\n            public options: AstWalkOptions,\n            public state: any) {\n        }\n\n        public walk(ast: AST, parent: AST): AST {\n            var preAst = this.pre(ast, parent, this);\n            if (preAst === undefined) {\n                preAst = ast;\n            }\n            if (this.options.goChildren) {\n                var svGoSib = this.options.goNextSibling;\n                this.options.goNextSibling = true;\n                // Call the "walkChildren" function corresponding to "nodeType".\n                this.childrenWalkers[ast.nodeType](ast, parent, this);\n                this.options.goNextSibling = svGoSib;\n            }\n            else {\n                // no go only applies to children of node issuing it\n                this.options.goChildren = true;\n            }\n            if (this.post) {\n                var postAst = this.post(preAst, parent, this);\n                if (postAst === undefined) {\n                    postAst = preAst;\n                }\n                return postAst;\n            }\n            else {\n                return preAst;\n            }\n        }\n    }\n\n    export class AstWalkerFactory {\n        private childrenWalkers: IAstWalkChildren[] = [];\n\n        constructor () {\n            this.initChildrenWalkers();\n        }\n\n        public walk(ast: AST, pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any): AST {\n            return this.getWalker(pre, post, options, state).walk(ast, null)\n        }\n\n        public getWalker(pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any): IAstWalker {\n            return this.getSlowWalker(pre, post, options, state);\n        }\n\n        private getSlowWalker(pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any): IAstWalker {\n            if (!options) {\n                options = new AstWalkOptions();\n            }\n\n            return new AstWalker(this.childrenWalkers, pre, post, options, state);\n        }\n\n        private initChildrenWalkers(): void {\n            this.childrenWalkers[NodeType.None] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Empty] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.EmptyExpr] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.True] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.False] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.This] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Super] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.QString] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Regex] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Null] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.ArrayLit] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.ObjectLit] = ChildrenWalkers.walkUnaryExpressionChild';
var v27662 = v27663 + "ren;\n            this.childrenWalkers[NodeType.Void] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.Comma] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Pos] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.Neg] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.Delete] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.Await] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.In] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Dot] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.From] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Is] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.InstOf] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Typeof] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.NumberLit] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Name] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.TypeRef] = ChildrenWalkers.walkTypeReferenceChildren;\n            this.childrenWalkers[NodeType.Index] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Call] = ChildrenWalkers.walkCallExpressionChildren;\n            this.childrenWalkers[NodeType.New] = ChildrenWalkers.walkCallExpressionChildren;\n            this.childrenWalkers[NodeType.Asg] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgAdd] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgSub] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgDiv] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgMul] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgMod] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgAnd] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgXor] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgOr] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgLsh] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgRsh] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.AsgRs2] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.ConditionalExpression] = ChildrenWalkers.walkTrinaryExpressionChildren;\n            this.childrenWalkers[NodeType.LogOr] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.LogAnd] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Or] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Xor] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.And] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Eq] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Ne] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Eqv] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.NEqv] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Lt] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Le] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Gt] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Ge] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Add] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Sub] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Mul] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Div] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Mod] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Lsh] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Rsh] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.Rs2] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalker";
var v27661 = v27662 + 's[NodeType.Not] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.LogNot] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.IncPre] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.DecPre] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.IncPost] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.DecPost] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.TypeAssertion] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.FuncDecl] = ChildrenWalkers.walkFuncDeclChildren;\n            this.childrenWalkers[NodeType.Member] = ChildrenWalkers.walkBinaryExpressionChildren;\n            this.childrenWalkers[NodeType.VarDecl] = ChildrenWalkers.walkBoundDeclChildren;\n            this.childrenWalkers[NodeType.ArgDecl] = ChildrenWalkers.walkBoundDeclChildren;\n            this.childrenWalkers[NodeType.Return] = ChildrenWalkers.walkReturnStatementChildren;\n            this.childrenWalkers[NodeType.Break] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Continue] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Throw] = ChildrenWalkers.walkUnaryExpressionChildren;\n            this.childrenWalkers[NodeType.For] = ChildrenWalkers.walkForStatementChildren;\n            this.childrenWalkers[NodeType.ForIn] = ChildrenWalkers.walkForInStatementChildren;\n            this.childrenWalkers[NodeType.If] = ChildrenWalkers.walkIfStatementChildren;\n            this.childrenWalkers[NodeType.While] = ChildrenWalkers.walkWhileStatementChildren;\n            this.childrenWalkers[NodeType.DoWhile] = ChildrenWalkers.walkDoWhileStatementChildren;\n            this.childrenWalkers[NodeType.Block] = ChildrenWalkers.walkBlockChildren;\n            this.childrenWalkers[NodeType.Case] = ChildrenWalkers.walkCaseStatementChildren;\n            this.childrenWalkers[NodeType.Switch] = ChildrenWalkers.walkSwitchStatementChildren;\n            this.childrenWalkers[NodeType.Try] = ChildrenWalkers.walkTryChildren;\n            this.childrenWalkers[NodeType.TryCatch] = ChildrenWalkers.walkTryCatchChildren;\n            this.childrenWalkers[NodeType.TryFinally] = ChildrenWalkers.walkTryFinallyChildren;\n            this.childrenWalkers[NodeType.Finally] = ChildrenWalkers.walkFinallyChildren;\n            this.childrenWalkers[NodeType.Catch] = ChildrenWalkers.walkCatchChildren;\n            this.childrenWalkers[NodeType.List] = ChildrenWalkers.walkListChildren;\n            this.childrenWalkers[NodeType.Script] = ChildrenWalkers.walkScriptChildren;\n            this.childrenWalkers[NodeType.ClassDeclaration] = ChildrenWalkers.walkClassDeclChildren;\n            this.childrenWalkers[NodeType.InterfaceDeclaration] = ChildrenWalkers.walkTypeDeclChildren;\n            this.childrenWalkers[NodeType.ModuleDeclaration] = ChildrenWalkers.walkModuleDeclChildren;\n            this.childrenWalkers[NodeType.ImportDeclaration] = ChildrenWalkers.walkImportDeclChildren;\n            this.childrenWalkers[NodeType.With] = ChildrenWalkers.walkWithStatementChildren;\n            this.childrenWalkers[NodeType.Label] = ChildrenWalkers.walkLabelChildren;\n            this.childrenWalkers[NodeType.LabeledStatement] = ChildrenWalkers.walkLabeledStatementChildren;\n            this.childrenWalkers[NodeType.EBStart] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.GotoEB] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.EndCode] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Error] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Comment] = ChildrenWalkers.walkNone;\n            this.childrenWalkers[NodeType.Debugger] = ChildrenWalkers.walkNone;\n\n            // Verify the code is up to date with the enum\n            for (var e in (<any>NodeType)._map) {\n                if ((<any>this.childrenWalkers)[e] === undefined) {\n                    throw new Error("initWalkers function is not up to date with enum content!");\n                }\n            }\n        }\n    }\n\n    var globalAstWalkerFactory: AstWalkerFactory;\n\n    export function getAstWalkerFactory(): AstWalkerFactory {\n        if (!globalAstWalkerFactory) {\n            globalAstWalkerFactory = new AstWalkerFactory();\n        }\n        return globalAstWalkerFactory;\n    }\n\n    module ChildrenWalkers {\n        export function walkNone(preAst: ASTList, parent: AST, walker: IAstWalker): void {\n            // Nothing to do\n        }\n\n        export function walkListChildren(preAst: ASTList, parent: AST, walker: IAstWalker): void {\n            var len = preAst.members.length;\n            if (walker.options.reverseSiblings) {\n                for (var i = len - 1; i >= 0; i--) {\n                    if (walker.options.goNextSibling) {\n                        preAst.m';
var v27660 = v27661 + "embers[i] = walker.walk(preAst.members[i], preAst);\n                    }\n                }\n            }\n            else {\n                for (var i = 0; i < len; i++) {\n                    if (walker.options.goNextSibling) {\n                        preAst.members[i] = walker.walk(preAst.members[i], preAst);\n                    }\n                }\n            }\n        }\n\n        export function walkUnaryExpressionChildren(preAst: UnaryExpression, parent: AST, walker: IAstWalker): void {\n            if (preAst.castTerm) {\n                preAst.castTerm = walker.walk(preAst.castTerm, preAst);\n            }\n            if (preAst.operand) {\n                preAst.operand = walker.walk(preAst.operand, preAst);\n            }\n        }\n\n        export function walkBinaryExpressionChildren(preAst: BinaryExpression, parent: AST, walker: IAstWalker): void {\n            if (walker.options.reverseSiblings) {\n                if (preAst.operand2) {\n                    preAst.operand2 = walker.walk(preAst.operand2, preAst);\n                }\n                if ((preAst.operand1) && (walker.options.goNextSibling)) {\n                    preAst.operand1 = walker.walk(preAst.operand1, preAst);\n                }\n            } else {\n                if (preAst.operand1) {\n                    preAst.operand1 = walker.walk(preAst.operand1, preAst);\n                }\n                if ((preAst.operand2) && (walker.options.goNextSibling)) {\n                    preAst.operand2 = walker.walk(preAst.operand2, preAst);\n                }\n            }\n        }\n\n        export function walkTypeReferenceChildren(preAst: TypeReference, parent: AST, walker: IAstWalker): void {\n            if (preAst.term) {\n                preAst.term = walker.walk(preAst.term, preAst);\n            }\n        }\n\n        export function walkCallExpressionChildren(preAst: CallExpression, parent: AST, walker: IAstWalker): void {\n            if (!walker.options.reverseSiblings) {\n                preAst.target = walker.walk(preAst.target, preAst);\n            }\n            if (preAst.arguments && (walker.options.goNextSibling)) {\n                preAst.arguments = <ASTList> walker.walk(preAst.arguments, preAst);\n            }\n            if ((walker.options.reverseSiblings) && (walker.options.goNextSibling)) {\n                preAst.target = walker.walk(preAst.target, preAst);\n            }\n        }\n\n        export function walkTrinaryExpressionChildren(preAst: ConditionalExpression, parent: AST, walker: IAstWalker): void {\n            if (preAst.operand1) {\n                preAst.operand1 = walker.walk(preAst.operand1, preAst);\n            }\n            if (preAst.operand2 && (walker.options.goNextSibling)) {\n                preAst.operand2 = walker.walk(preAst.operand2, preAst);\n            }\n            if (preAst.operand3 && (walker.options.goNextSibling)) {\n                preAst.operand3 = walker.walk(preAst.operand3, preAst);\n            }\n        }\n\n        export function walkFuncDeclChildren(preAst: FuncDecl, parent: AST, walker: IAstWalker): void {\n            if (preAst.name) {\n                preAst.name = <Identifier>walker.walk(preAst.name, preAst);\n            }\n            if (preAst.arguments && (preAst.arguments.members.length > 0) && (walker.options.goNextSibling)) {\n                preAst.arguments = <ASTList>walker.walk(preAst.arguments, preAst);\n            }\n            if (preAst.returnTypeAnnotation && (walker.options.goNextSibling)) {\n                preAst.returnTypeAnnotation = walker.walk(preAst.returnTypeAnnotation, preAst);\n            }\n            if (preAst.bod && (preAst.bod.members.length > 0) && (walker.options.goNextSibling)) {\n                preAst.bod = <ASTList>walker.walk(preAst.bod, preAst);\n            }\n        }\n\n        export function walkBoundDeclChildren(preAst: BoundDecl, parent: AST, walker: IAstWalker): void {\n            if (preAst.id) {\n                preAst.id = <Identifier>walker.walk(preAst.id, preAst);\n            }\n            if (preAst.init) {\n                preAst.init = walker.walk(preAst.init, preAst);\n            }\n            if ((preAst.typeExpr) && (walker.options.goNextSibling)) {\n                preAst.typeExpr = walker.walk(preAst.typeExpr, preAst);\n            }\n        }\n\n        export function walkReturnStatementChildren(preAst: ReturnStatement, parent: AST, walker: IAstWalker): void {\n            if (preAst.returnExpression) {\n                preAst.returnExpression = walker.walk(preAst.returnExpression, preAst);\n            }\n        }\n\n        export function walkForStatementChildren(preAst: ForStatement, parent: AST, walker: IAstWalker): void {\n            if (preAst.init) {\n                preAst.init = walker.walk(preAst.init, preAst);\n            }\n\n            if (preAst.cond && walker.options.goNextSibling) {\n                preAst.cond = walker.walk(preAst.cond, preAst);\n            }\n\n            if (preAst.incr && walker.options.goNextSibling) {\n                pr";
var v27659 = v27660 + "eAst.incr = walker.walk(preAst.incr, preAst);\n            }\n\n            if (preAst.body && walker.options.goNextSibling) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkForInStatementChildren(preAst: ForInStatement, parent: AST, walker: IAstWalker): void {\n            preAst.lval = walker.walk(preAst.lval, preAst);\n            if (walker.options.goNextSibling) {\n                preAst.obj = walker.walk(preAst.obj, preAst);\n            }\n            if (preAst.body && (walker.options.goNextSibling)) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkIfStatementChildren(preAst: IfStatement, parent: AST, walker: IAstWalker): void {\n            preAst.cond = walker.walk(preAst.cond, preAst);\n            if (preAst.thenBod && (walker.options.goNextSibling)) {\n                preAst.thenBod = walker.walk(preAst.thenBod, preAst);\n            }\n            if (preAst.elseBod && (walker.options.goNextSibling)) {\n                preAst.elseBod = walker.walk(preAst.elseBod, preAst);\n            }\n        }\n\n        export function walkWhileStatementChildren(preAst: WhileStatement, parent: AST, walker: IAstWalker): void {\n            preAst.cond = walker.walk(preAst.cond, preAst);\n            if (preAst.body && (walker.options.goNextSibling)) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkDoWhileStatementChildren(preAst: DoWhileStatement, parent: AST, walker: IAstWalker): void {\n            preAst.cond = walker.walk(preAst.cond, preAst);\n            if (preAst.body && (walker.options.goNextSibling)) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkBlockChildren(preAst: Block, parent: AST, walker: IAstWalker): void {\n            if (preAst.statements) {\n                preAst.statements = <ASTList>walker.walk(preAst.statements, preAst);\n            }\n        }\n\n        export function walkCaseStatementChildren(preAst: CaseStatement, parent: AST, walker: IAstWalker): void {\n            if (preAst.expr) {\n                preAst.expr = walker.walk(preAst.expr, preAst);\n            }\n\n            if (preAst.body && walker.options.goNextSibling) {\n                preAst.body = <ASTList>walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkSwitchStatementChildren(preAst: SwitchStatement, parent: AST, walker: IAstWalker): void {\n            if (preAst.val) {\n                preAst.val = walker.walk(preAst.val, preAst);\n            }\n\n            if ((preAst.caseList) && walker.options.goNextSibling) {\n                preAst.caseList = <ASTList>walker.walk(preAst.caseList, preAst);\n            }\n        }\n\n        export function walkTryChildren(preAst: Try, parent: AST, walker: IAstWalker): void {\n            if (preAst.body) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkTryCatchChildren(preAst: TryCatch, parent: AST, walker: IAstWalker): void {\n            if (preAst.tryNode) {\n                preAst.tryNode = <Try>walker.walk(preAst.tryNode, preAst);\n            }\n\n            if ((preAst.catchNode) && walker.options.goNextSibling) {\n                preAst.catchNode = <Catch>walker.walk(preAst.catchNode, preAst);\n            }\n        }\n\n        export function walkTryFinallyChildren(preAst: TryFinally, parent: AST, walker: IAstWalker): void {\n            if (preAst.tryNode) {\n                preAst.tryNode = walker.walk(preAst.tryNode, preAst);\n            }\n\n            if (preAst.finallyNode && walker.options.goNextSibling) {\n                preAst.finallyNode = <Finally>walker.walk(preAst.finallyNode, preAst);\n            }\n        }\n\n        export function walkFinallyChildren(preAst: Finally, parent: AST, walker: IAstWalker): void {\n            if (preAst.body) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkCatchChildren(preAst: Catch, parent: AST, walker: IAstWalker): void {\n            if (preAst.param) {\n                preAst.param = <VarDecl>walker.walk(preAst.param, preAst);\n            }\n\n            if ((preAst.body) && walker.options.goNextSibling) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkRecordChildren(preAst: NamedDeclaration, parent: AST, walker: IAstWalker): void {\n            preAst.name = <Identifier>walker.walk(preAst.name, preAst);\n            if (walker.options.goNextSibling && preAst.members) {\n                preAst.members = <ASTList>walker.walk(preAst.members, preAst);\n            }\n\n        }\n\n        export function walkNamedTypeChildren(preAst: TypeDeclaration, parent: AST, walker: IAstWalker): void {\n            walkRecordChildren(preAst, parent, walker);\n        }\n";
var v27658 = v27659 + '\n        export function walkClassDeclChildren(preAst: ClassDeclaration, parent: AST, walker: IAstWalker): void {\n            walkNamedTypeChildren(preAst, parent, walker);\n\n            if (walker.options.goNextSibling && preAst.extendsList) {\n                preAst.extendsList = <ASTList>walker.walk(preAst.extendsList, preAst);\n            }\n\n            if (walker.options.goNextSibling && preAst.implementsList) {\n                preAst.implementsList = <ASTList>walker.walk(preAst.implementsList, preAst);\n            }\n        }\n\n        export function walkScriptChildren(preAst: Script, parent: AST, walker: IAstWalker): void {\n            if (preAst.bod) {\n                preAst.bod = <ASTList>walker.walk(preAst.bod, preAst);\n            }\n        }\n\n        export function walkTypeDeclChildren(preAst: InterfaceDeclaration, parent: AST, walker: IAstWalker): void {\n            walkNamedTypeChildren(preAst, parent, walker);\n\n            // walked arguments as part of members\n            if (walker.options.goNextSibling && preAst.extendsList) {\n                preAst.extendsList = <ASTList>walker.walk(preAst.extendsList, preAst);\n            }\n\n            if (walker.options.goNextSibling && preAst.implementsList) {\n                preAst.implementsList = <ASTList>walker.walk(preAst.implementsList, preAst);\n            }\n        }\n\n        export function walkModuleDeclChildren(preAst: ModuleDeclaration, parent: AST, walker: IAstWalker): void {\n            walkRecordChildren(preAst, parent, walker);\n        }\n\n        export function walkImportDeclChildren(preAst: ImportDeclaration, parent: AST, walker: IAstWalker): void {\n            if (preAst.id) {\n                preAst.id = <Identifier>walker.walk(preAst.id, preAst);\n            }\n            if (preAst.alias) {\n                preAst.alias = walker.walk(preAst.alias, preAst);\n            }\n        }\n\n        export function walkWithStatementChildren(preAst: WithStatement, parent: AST, walker: IAstWalker): void {\n            if (preAst.expr) {\n                preAst.expr = walker.walk(preAst.expr, preAst);\n            }\n\n            if (preAst.body && walker.options.goNextSibling) {\n                preAst.body = walker.walk(preAst.body, preAst);\n            }\n        }\n\n        export function walkLabelChildren(preAst: Label, parent: AST, walker: IAstWalker): void {\n            //TODO: Walk "id"?\n        }\n\n        export function walkLabeledStatementChildren(preAst: LabeledStatement, parent: AST, walker: IAstWalker): void {\n            preAst.labels = <ASTList>walker.walk(preAst.labels, preAst);\n            if (walker.options.goNextSibling) {\n                preAst.stmt = walker.walk(preAst.stmt, preAst);\n            }\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nmodule TypeScript {\n    class Base64Format {\n        static encodedValues = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\';\n        static encode(inValue: number) {\n            if (inValue < 64) {\n                return encodedValues.charAt(inValue);\n            }\n            throw TypeError(inValue + ": not a 64 based value");\n        }\n\n        static decodeChar(inChar: string) {\n            if (inChar.length === 1) {\n                return encodedValues.indexOf(inChar);\n            } else {\n                throw TypeError(\'"\' + inChar + \'" must have length 1\');\n            }\n        }\n    }\n\n    export class Base64VLQFormat {\n        static encode(inValue: number) {\n            // Add a new least significant bit that has the sign of the value.\n            // if negative number the least significant bit that gets added to the number has value 1\n            // else least significant bit value that gets added is 0\n            // eg. -1 changes to binary : 01 [1] => 3\n            //     +1 changes to binary : 01 [0] => 2\n            if (inValue < 0) {\n                inValue = ((-inValue) << 1) + 1;\n            }\n            else {\n                inValue = inValue << 1;\n            }\n\n            // Encode 5 bits at a time starting from least significant bits\n            var encodedStr = "";\n            do {\n                var currentDigit = inValue & 31; // 11111\n                inValue = inValue >> 5;\n                if (inValue > 0) {\n                    // There are still more digits to decode, set the msb (6th bit)\n                    currentDigit = currentDigit | 32; \n               ';
var v27657 = v27658 + ' }\n                encodedStr = encodedStr + Base64Format.encode(currentDigit);\n            } while (inValue > 0);\n\n            return encodedStr;\n        }\n\n        static decode(inString: string) {\n            var result = 0;\n            var negative = false;\n\n            var shift = 0;\n            for (var i = 0; i < inString.length; i++) {\n                var byte = Base64Format.decodeChar(inString[i]);\n                if (i === 0) {\n                    // Sign bit appears in the LSBit of the first value\n                    if ((byte & 1) === 1) {\n                        negative = true;\n                    }\n                    result = (byte >> 1) & 15; // 1111x\n                } else {\n                    result = result | ((byte & 31) << shift); // 11111\n                }\n\n                shift += (i == 0) ? 4 : 5;\n\n                if ((byte & 32) === 32) {\n                    // Continue\n                } else {\n                    return { value: negative ? -(result) : result, rest: inString.substr(i + 1) };\n                }\n            }\n\n            throw new Error(\'Base64 value "\' + inString + \'" finished with a continuation bit\');\n        }\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class Binder {\n        constructor(public checker: TypeChecker) { }\n        \n        public resolveBaseTypeLinks(typeLinks: TypeLink[], scope: SymbolScope) {\n            var extendsList: Type[] = null;\n            if (typeLinks) {\n                extendsList = new Type[];\n                for (var i = 0, len = typeLinks.length; i < len; i++) {\n                    extendsList[i] = this.checker.resolveBaseTypeLink(typeLinks[i], scope);\n                }\n            }\n            return extendsList;\n        }\n\n        public resolveBases(scope: SymbolScope, type: Type) {\n            type.extendsList = this.resolveBaseTypeLinks(type.extendsTypeLinks, scope);\n\n            var i = 0, len = type.extendsList.length;\n            var derivedIsClass = type.isClassInstance();\n            for (; i < len; i++) {\n                var baseIsClass = type.extendsList[i].isClassInstance();\n                if (type.extendsList[i] != this.checker.anyType) {\n                    var baseRef = type.extendsTypeLinks[i].ast;\n                    if (derivedIsClass) {\n                        if (!baseIsClass) {\n                            this.checker.errorReporter.simpleError(baseRef,\n                                                                     "A class may only extend other classes, " + type.extendsList[i].symbol.fullName() + " is not a class.");\n                        }\n                    }\n                    else {\n                        if (baseIsClass) {\n                            this.checker.errorReporter.simpleError(baseRef,\n                                                                     "An interface may only extend other interfaces, " + type.extendsList[i].symbol.fullName() + " is a class.");\n                        }\n                    }\n                }\n            }\n\n            type.implementsList = this.resolveBaseTypeLinks(type.implementsTypeLinks, scope);\n\n            if (type.implementsList) {\n                for (i = 0, len = type.implementsList.length; i < len; i++) {\n                    var iface = type.implementsList[i];\n                    var baseRef = type.implementsTypeLinks[i].ast;\n                    if (iface.isClassInstance()) {\n                        if (derivedIsClass) {\n                            this.checker.errorReporter.simpleError(baseRef,\n                                                                     "A class may only implement an interface; " + iface.symbol.fullName() + " is a class.");\n                        }\n                    }\n                }\n            }\n        }\n\n        public resolveSignatureGroup(signatureGroup: SignatureGroup, scope: SymbolScope, instanceType: Type) {\n            var supplyVar = !(signatureGroup.hasImplementation);\n            for (var i = 0, len = signatureGroup.signatures.length; i < len; i++) {\n                var signature = signatureGroup.signatures[i];\n                if (instanceType) {\n                    signature.returnType.type = instanceType;\n                }\n                else {\n                    this.checker.resolveTypeLink(scope, signature.returnType, supplyVar);\n               ';
var v27656 = v27657 + ' }\n                var paramLen = signature.parameters.length;\n                for (var j = 0; j < paramLen; j++) {\n                    this.bindSymbol(scope, signature.parameters[j]);\n                }\n                if (signature.hasVariableArgList) {\n                    // check that last parameter has an array type\n                    var lastParam = <ParameterSymbol>signature.parameters[paramLen - 1];\n                    lastParam.argsOffset = paramLen - 1;\n                    if (!lastParam.getType().isArray()) {\n                        this.checker.errorReporter.simpleErrorFromSym(lastParam,\n                                                                 "... parameter must have array type");\n                        lastParam.parameter.typeLink.type = this.checker.makeArrayType(lastParam.parameter.typeLink.type);\n                    }\n                }\n            }\n        }\n\n        public bindType(scope: SymbolScope, type: Type, instanceType: Type): void {\n            if (instanceType) {\n                this.bindType(scope, instanceType, null);\n            }\n            if (type.hasMembers()) {\n                var members = type.members;\n                var ambientMembers = type.ambientMembers;\n                var typeMembers = type.getAllEnclosedTypes(); // REVIEW: Should only be getting exported types?\n                var ambientTypeMembers = type.getAllAmbientEnclosedTypes(); // REVIEW: Should only be getting exported types?\n                var memberScope = new SymbolTableScope(members, ambientMembers, typeMembers, ambientTypeMembers, type.symbol);\n                var agg = new SymbolAggregateScope(type.symbol);\n                var prevCurrentModDecl = this.checker.currentModDecl;\n                var prevBindStatus = this.checker.inBind;\n                agg.addParentScope(memberScope);\n                agg.addParentScope(scope);\n                if (type.isModuleType()) {\n                    this.checker.currentModDecl = <ModuleDeclaration>type.symbol.declAST;\n                    this.checker.inBind = true;\n                }\n                if (members) {\n                    this.bind(agg, type.members.allMembers); // REVIEW: Should only be getting exported types?\n                }\n                if (typeMembers) {\n                    this.bind(agg, typeMembers.allMembers);\n                }\n                if (ambientMembers) {\n                    this.bind(agg, ambientMembers.allMembers);\n                }\n                if (ambientTypeMembers) {\n                    this.bind(agg, ambientTypeMembers.allMembers);\n                }\n                this.checker.currentModDecl = prevCurrentModDecl;\n                this.checker.inBind = prevBindStatus;\n            }\n            if (type.extendsTypeLinks) {\n                this.resolveBases(scope, type);\n            }\n            if (type.construct) {\n                this.resolveSignatureGroup(type.construct, scope, instanceType);\n            }\n            if (type.call) {\n                this.resolveSignatureGroup(type.call, scope, null);\n            }\n            if (type.index) {\n                this.resolveSignatureGroup(type.index, scope, null);\n            }\n            if (type.elementType) {\n                this.bindType(scope, type.elementType, null);\n            }\n        }\n\n        public bindSymbol(scope: SymbolScope, symbol: Symbol) {\n            if (!symbol.bound) {\n                var prevLocationInfo = this.checker.locationInfo;\n                if ((this.checker.units) && (symbol.unitIndex >= 0) && (symbol.unitIndex < this.checker.units.length)) {\n                    this.checker.locationInfo = this.checker.units[symbol.unitIndex];\n                }\n                switch (symbol.kind()) {\n                    case SymbolKind.Type:\n\n                        if (symbol.flags & SymbolFlags.Bound) {\n                            break;\n                        }\n\n                        var typeSymbol = <TypeSymbol>symbol;\n                        typeSymbol.flags |= SymbolFlags.Bound;\n\n                        // Since type collection happens out of order, a dynamic module referenced by an import statement\n                        // may not yet be in scope when the import symbol is created.  In that case, we need to search\n                        // out the module symbol now\n                        // Note that we\'ll also want to do this in resolveTypeMembers, in case the symbol is set outside the\n                        // context of a given module  (E.g., an outer import statement)\n                        if (typeSymbol.aliasLink && !typeSymbol.type && typeSymbol.aliasLink.alias.nodeType == NodeType.Name) {\n                            var modPath = (<Identifier>typeSymbol.aliasLink.alias).text;\n                            var modSym = this.checker.findSymbolForDynamicModule(modPath, this.checker.locationInfo.filename, (id) => scope.find(id, false, true));\n                            if (modSym) {\n                                typeSymb';
var v27655 = v27656 + 'ol.type = modSym.getType();\n                            }\n                        }\n\n                        if (typeSymbol.type && typeSymbol.type != this.checker.gloModType) {\n                            this.bindType(scope, typeSymbol.type, typeSymbol.instanceType);\n\n                            // bind expansions on the parent type symbol\n                            if (typeSymbol.type.isModuleType()) {\n                                for (var i = 0; i < typeSymbol.expansions.length; i++) {\n                                    this.bindType(scope, typeSymbol.expansions[i], typeSymbol.instanceType);\n                                }\n                            }\n                        }\n                        break;\n                    case SymbolKind.Field:\n                        this.checker.resolveTypeLink(scope, (<FieldSymbol>symbol).field.typeLink,\n                                                false);\n                        break;\n                    case SymbolKind.Parameter:\n                        this.checker.resolveTypeLink(scope,\n                                                (<ParameterSymbol>symbol).parameter.typeLink,\n                                                true);\n                        break;\n                }\n                this.checker.locationInfo = prevLocationInfo;\n            }\n            symbol.bound = true;\n        }\n\n        public bind(scope: SymbolScope, table: IHashTable) {\n            table.map(\n                (key, sym, binder) => {\n                    binder.bindSymbol(scope, sym);\n                },\n                this);\n        }\n    }\n\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class DeclFileWriter {\n        public onNewLine = true;\n        constructor(private declFile: ITextWriter) {\n        }\n\n        public Write(s: string) {\n            this.declFile.Write(s);\n            this.onNewLine = false;\n        }\n\n        public WriteLine(s: string) {\n            this.declFile.WriteLine(s);\n            this.onNewLine = true;\n        }\n\n        public Close() {\n            this.declFile.Close();\n        }\n    }\n\n    export class DeclarationEmitter implements AstWalkerWithDetailCallback.AstWalkerDetailCallback {\n        private declFile: DeclFileWriter = null;\n        private indenter = new Indenter();\n        private declarationContainerStack: AST[] = [];\n        private isDottedModuleName: bool[] = [];\n        private dottedModuleEmit: string;\n        private ignoreCallbackAst: AST = null;\n        private singleDeclFile: DeclFileWriter = null;\n        private varListCount: number = 0;\n\n        private getAstDeclarationContainer() {\n            return this.declarationContainerStack[this.declarationContainerStack.length - 1];\n        }\n\n        private emitDottedModuleName() {\n            return (this.isDottedModuleName.length == 0) ? false : this.isDottedModuleName[this.isDottedModuleName.length - 1];\n        }\n\n        constructor (public checker: TypeChecker, public emitOptions: EmitOptions, public errorReporter: ErrorReporter) {\n        }\n\n        public setDeclarationFile(file: ITextWriter) {\n            this.declFile = new DeclFileWriter(file);\n        }\n\n        public Close() {\n            try {\n                // Closing files could result in exceptions, report them if they occur\n                this.declFile.Close();\n            } catch (ex) {\n                this.errorReporter.emitterError(null, ex.message);\n            }\n        }\n\n        public emitDeclarations(script: TypeScript.Script): void {\n            AstWalkerWithDetailCallback.walk(script, this);\n        }\n\n        private getIndentString(declIndent? = false) {\n            if (this.emitOptions.minWhitespace) {\n                return "";\n            }\n            else {\n                return this.indenter.getIndent();\n            }\n        }\n\n        private emitIndent() {\n            this.declFile.Write(this.getIndentString());\n        }\n\n        private canEmitSignature(declFlags: DeclFlags, canEmitGlobalAmbientDecl?: bool = true, useDeclarationContainerTop?: bool = true) {\n            var container: AST;\n            if (useDeclarationContainerTop) {\n                container = this.getAstDeclarationContainer();\n            } else {\n                container = this.declarationContainerStack[this.declarationContainerStack.length - 2];\n            }\n';
var v27654 = v27655 + '\n            if (container.nodeType == NodeType.ModuleDeclaration && !hasFlag(declFlags, DeclFlags.Exported)) {\n                return false;\n            }\n\n            if (!canEmitGlobalAmbientDecl && container.nodeType == NodeType.Script && hasFlag(declFlags, DeclFlags.Ambient)) {\n                return false;\n            }\n\n            return true;\n        }\n\n        private canEmitPrePostAstSignature(declFlags: DeclFlags, astWithPrePostCallback: AST, preCallback: bool) {\n            if (this.ignoreCallbackAst) {\n                CompilerDiagnostics.assert(this.ignoreCallbackAst != astWithPrePostCallback, "Ignore Callback AST mismatch");\n                this.ignoreCallbackAst = null;\n                return false;\n            } else if (preCallback &&\n                !this.canEmitSignature(declFlags, true, preCallback)) {\n                this.ignoreCallbackAst = astWithPrePostCallback;\n                return false;\n            }\n\n            return true;\n        }\n\n        private getDeclFlagsString(declFlags: DeclFlags, typeString: string) {\n            var result = this.getIndentString();\n\n            // Accessor strings\n            var accessorString = "";\n            if (hasFlag(declFlags, DeclFlags.GetAccessor)) {\n                accessorString = "get ";\n            }\n            else if (hasFlag(declFlags, DeclFlags.SetAccessor)) {\n                accessorString = "set ";\n            }\n\n            // Emit export only for global export statements. The container for this would be dynamic module which is whole file\n            var container = this.getAstDeclarationContainer();\n            if (container.nodeType == NodeType.ModuleDeclaration &&\n                hasFlag((<ModuleDeclaration>container).modFlags, ModuleFlags.IsWholeFile) &&\n                hasFlag(declFlags, DeclFlags.Exported)) {\n                result += "export ";\n            }\n\n            // Static/public/private/global declare\n            if (hasFlag(declFlags, DeclFlags.LocalStatic) || hasFlag(declFlags, DeclFlags.Static)) {\n                result += "static " + accessorString;\n            }\n            else {\n                if (hasFlag(declFlags, DeclFlags.Private)) {\n                    result += "private " + accessorString;\n                }\n                else if (hasFlag(declFlags, DeclFlags.Public)) {\n                    result += "public " + accessorString;\n                }\n                else {\n                    if (accessorString == "") {\n                        result += typeString + " ";\n                    } else {\n                        result += accessorString;\n                    }\n                }\n            }\n\n            return result;\n        }\n\n        private emitDeclFlags(declFlags: DeclFlags, typeString: string) {\n            this.declFile.Write(this.getDeclFlagsString(declFlags, typeString));\n        }\n\n        private canEmitTypeAnnotationSignature(declFlag: DeclFlags = DeclFlags.None) {\n            // Private declaration, shouldnt emit type any time.\n            return !hasFlag(declFlag, DeclFlags.Private);\n        }\n\n        private pushDeclarationContainer(ast: AST) {\n            this.declarationContainerStack.push(ast);\n        }\n\n        private popDeclarationContainer(ast: AST) {\n            CompilerDiagnostics.assert(ast != this.getAstDeclarationContainer(), \'Declaration container mismatch\');\n            this.declarationContainerStack.pop();\n        }\n\n        private emitTypeNamesMember(memberName: MemberName, emitIndent? : bool = false) {\n            if (memberName.prefix == "{ ") {\n                if (emitIndent) {\n                    this.emitIndent();\n                }\n                this.declFile.WriteLine("{");\n                this.indenter.increaseIndent();\n                emitIndent = true;\n            } else if (memberName.prefix != "") {\n                if (emitIndent) {\n                    this.emitIndent();\n                }\n                this.declFile.Write(memberName.prefix);\n                emitIndent = false;\n            }\n\n            if (memberName.isString()) {\n                if (emitIndent) {\n                    this.emitIndent();\n                }\n                this.declFile.Write((<MemberNameString>memberName).text);\n            } else {\n                var ar = <MemberNameArray>memberName;\n                for (var index = 0; index < ar.entries.length; index++) {\n                    this.emitTypeNamesMember(ar.entries[index], emitIndent);\n                    if (ar.delim == "; ") {\n                        this.declFile.WriteLine(";");\n                    }\n                }\n            }\n\n            if (memberName.suffix == "}") {\n                this.indenter.decreaseIndent();\n                this.emitIndent();\n                this.declFile.Write(memberName.suffix);\n            } else {\n                this.declFile.Write(memberName.suffix);\n            }\n        }\n\n        private emitTypeSignature(type: Type) {\n            var containingScope: SymbolScope = null';
var v27653 = v27654 + ';\n            var declarationContainerAst = this.getAstDeclarationContainer();\n            switch (declarationContainerAst.nodeType) {\n                case NodeType.ModuleDeclaration:\n                case NodeType.InterfaceDeclaration:\n                case NodeType.FuncDecl:\n                    if (declarationContainerAst.type) {\n                        containingScope = declarationContainerAst.type.containedScope;\n                    }\n                    break;\n\n                case NodeType.Script:\n                    var script = <Script>declarationContainerAst;\n                    if (script.bod) {\n                        containingScope = script.bod.enclosingScope;\n                    }\n                    break;\n\n                case NodeType.ClassDeclaration:\n                    if (declarationContainerAst.type) {\n                        containingScope = declarationContainerAst.type.instanceType.containedScope;\n                    }\n                    break;\n\n                default:\n                    CompilerDiagnostics.debugPrint("Unknown containing scope");\n            }\n\n            var typeNameMembers = type.getScopedTypeNameEx(containingScope);\n            this.emitTypeNamesMember(typeNameMembers);\n        }\n\n        private emitComment(comment: Comment) {\n            var text = comment.getText();\n            if (this.declFile.onNewLine) {\n                this.emitIndent();\n            } else if (!comment.isBlockComment) {\n                this.declFile.WriteLine("");\n                this.emitIndent();\n            }\n            \n            this.declFile.Write(text[0]);\n\n            for (var i = 1; i < text.length; i++) {\n                this.declFile.WriteLine("");\n                this.emitIndent();\n                this.declFile.Write(text[i]);\n            }\n\n            if (comment.endsLine || !comment.isBlockComment) {\n                this.declFile.WriteLine("");\n            } else {\n                this.declFile.Write(" ");\n            }\n        }\n\n        private emitDeclarationComments(ast: AST, endLine?: bool);\n        private emitDeclarationComments(symbol: Symbol, endLine?: bool);\n        private emitDeclarationComments(astOrSymbol, endLine = true) {\n            if (!this.emitOptions.emitComments) {\n                return;\n            }\n\n            var declComments = <Comment[]>astOrSymbol.getDocComments();\n            if (declComments.length > 0) {\n                for (var i = 0; i < declComments.length; i++) {\n                    this.emitComment(declComments[i]);\n                }\n\n                if (endLine) {\n                    if (!this.declFile.onNewLine) {\n                        this.declFile.WriteLine("");\n                    }\n                } else {\n                    if (this.declFile.onNewLine) {\n                        this.emitIndent();\n                    }\n                }\n            }\n        }\n\n        public VarDeclCallback(pre: bool, varDecl: VarDecl): bool {\n            if (pre && this.canEmitSignature(ToDeclFlags(varDecl.varFlags), false)) {\n                var interfaceMember = (this.getAstDeclarationContainer().nodeType == NodeType.InterfaceDeclaration);\n                this.emitDeclarationComments(varDecl);\n                if (!interfaceMember) {\n                    // If it is var list of form var a, b, c = emit it only if count > 0 - which will be when emitting first var\n                    // If it is var list of form  var a = varList count will be 0\n                    if (this.varListCount >= 0) {\n                        this.emitDeclFlags(ToDeclFlags(varDecl.varFlags), "var");\n                        this.varListCount = -this.varListCount;\n                    }\n                    this.declFile.Write(varDecl.id.text);\n                } else {\n                    this.emitIndent();\n                    this.declFile.Write(varDecl.id.text);\n                    if (hasFlag(varDecl.id.flags, ASTFlags.OptionalName)) {\n                        this.declFile.Write("?");\n                    }\n                }\n\n                var type: Type = null;\n                if (varDecl.typeExpr && varDecl.typeExpr.type) {\n                    type = varDecl.typeExpr.type;\n                }\n                else if (varDecl.sym) {\n                    type = (<FieldSymbol>varDecl.sym).getType();\n                    // Dont emit inferred any\n                    if (type == this.checker.anyType) {\n                        type = null;\n                    }\n                }\n\n                if (type && this.canEmitTypeAnnotationSignature(ToDeclFlags(varDecl.varFlags))) {\n                    this.declFile.Write(": ");\n                    this.emitTypeSignature(type);\n                }\n               \n                // emitted one var decl\n                if (this.varListCount > 0) { this.varListCount--; } else if (this.varListCount < 0) { this.varListCount++; }\n\n                // Write ; or ,\n                if (this.varListCount < 0) {\n                    this.declF';
var v27652 = v27653 + 'ile.Write(", ");\n                } else {\n                    this.declFile.WriteLine(";");\n                }\n            }\n            return false;\n        }\n\n        public BlockCallback(pre: bool, block: Block): bool {\n            if (!block.isStatementBlock) {\n                if (pre) {\n                    this.varListCount = block.statements.members.length;\n                } else {\n                    this.varListCount = 0;\n                }\n                return true;\n            }\n            return false;\n        }\n\n        private emitArgDecl(argDecl: ArgDecl, funcDecl: FuncDecl) {\n            this.emitDeclarationComments(argDecl, false);\n            this.declFile.Write(argDecl.id.text);\n            if (argDecl.isOptionalArg()) {\n                this.declFile.Write("?");\n            }\n            if ((argDecl.typeExpr || argDecl.type != this.checker.anyType) &&\n                this.canEmitTypeAnnotationSignature(ToDeclFlags(funcDecl.fncFlags))) {\n                this.declFile.Write(": ");\n                this.emitTypeSignature(argDecl.type);\n            }\n        }\n\n        public FuncDeclCallback(pre: bool, funcDecl: FuncDecl): bool {\n            if (!pre) {\n                return false;\n            }\n\n            if (funcDecl.isAccessor()) {\n                return this.emitPropertyAccessorSignature(funcDecl);\n            }\n\n            var isInterfaceMember = (this.getAstDeclarationContainer().nodeType == NodeType.InterfaceDeclaration);\n            if (funcDecl.bod) {\n                if (funcDecl.isConstructor) {\n                    if (funcDecl.type.construct && funcDecl.type.construct.signatures.length > 1) {\n                        return false;\n                    }\n                } else {\n                    if (funcDecl.type.call && funcDecl.type.call.signatures.length > 1) {\n                        // This means its implementation of overload signature. do not emit\n                        return false;\n                    }\n                }\n            } else if (!isInterfaceMember && hasFlag(funcDecl.fncFlags, FncFlags.Private) && funcDecl.type.call && funcDecl.type.call.signatures.length > 1) {\n                // Print only first overload of private function\n                var signatures = funcDecl.type.call.signatures;\n                var firstSignature = signatures[0].declAST;\n                if (firstSignature.bod) {\n                    // Its a implementation, use next one\n                    firstSignature = signatures[1].declAST;\n                }\n\n                if (firstSignature != funcDecl) {\n                    return false;\n                }\n            }\n\n            if (!this.canEmitSignature(ToDeclFlags(funcDecl.fncFlags), false)) {\n                return false;\n            }\n\n            this.emitDeclarationComments(funcDecl);\n            if (funcDecl.isConstructor) {\n                this.emitIndent();\n                this.declFile.Write("constructor");\n            }\n            else {\n                var id = funcDecl.getNameText();\n                if (!isInterfaceMember) {\n                    this.emitDeclFlags(ToDeclFlags(funcDecl.fncFlags), "function");\n                    this.declFile.Write(id);\n                } else {\n                    this.emitIndent();\n                    if (funcDecl.isConstructMember()) {\n                        this.declFile.Write("new");\n                    } else if (!funcDecl.isCallMember() && !funcDecl.isIndexerMember()) {\n                        this.declFile.Write(id);\n                        if (hasFlag(funcDecl.name.flags, ASTFlags.OptionalName)) {\n                            this.declFile.Write("? ");\n                        }\n                    }\n                }\n            }\n\n            if (!funcDecl.isIndexerMember()) {\n                this.declFile.Write("(");\n            } else {\n                this.declFile.Write("[");\n            }\n\n            this.indenter.increaseIndent();\n\n            if (funcDecl.arguments) {\n                var argsLen = funcDecl.arguments.members.length;\n                if (funcDecl.variableArgList) {\n                    argsLen--;\n                }\n                for (var i = 0; i < argsLen; i++) {\n                    var argDecl = <ArgDecl>funcDecl.arguments.members[i];\n                    this.emitArgDecl(argDecl, funcDecl);\n                    if (i < (argsLen - 1)) {\n                        this.declFile.Write(", ");\n                    }\n                }\n            }\n\n            if (funcDecl.variableArgList) {\n                var lastArg = <ArgDecl>funcDecl.arguments.members[funcDecl.arguments.members.length - 1];\n                if (funcDecl.arguments.members.length > 1) {\n                    this.declFile.Write(", ...");\n                }\n                else {\n                    this.declFile.Write("...");\n                }\n                this.emitArgDecl(lastArg, funcDecl);\n            }\n\n            this.indenter.decreaseIndent();\n\n            if (!funcDecl.isIndexerMember(';
var v27651 = v27652 + ')) {\n                this.declFile.Write(")");\n            } else {\n                this.declFile.Write("]");\n            }\n\n            if (!funcDecl.isConstructor &&\n                (funcDecl.returnTypeAnnotation || funcDecl.signature.returnType.type != this.checker.anyType) &&\n                this.canEmitTypeAnnotationSignature(ToDeclFlags(funcDecl.fncFlags))) {\n                this.declFile.Write(": ");\n                this.emitTypeSignature(funcDecl.signature.returnType.type);\n            }\n\n            this.declFile.WriteLine(";");\n\n            return false;\n        }\n\n        private emitBaseList(bases: ASTList, qual: string) {\n            if (bases && (bases.members.length > 0)) {\n                this.declFile.Write(" " + qual + " ");\n                var basesLen = bases.members.length;\n                for (var i = 0; i < basesLen; i++) {\n                    var baseExpr = bases.members[i];\n                    var baseSymbol = baseExpr.type.symbol;\n                    var baseType = baseExpr.type;\n                    if (i > 0) {\n                        this.declFile.Write(", ");\n                    }\n                    this.emitTypeSignature(baseType);\n                }\n            }\n        }\n\n        private emitPropertyAccessorSignature(funcDecl: FuncDecl) {\n            var accessorSymbol = <FieldSymbol>funcDecl.accessorSymbol;\n            if (accessorSymbol.getter && accessorSymbol.getter.declAST != funcDecl) {\n                // Setter is being used to emit the type info. \n                return false;\n            }\n\n            this.emitDeclarationComments(accessorSymbol);\n            this.emitDeclFlags(ToDeclFlags(accessorSymbol.flags), "var");\n            this.declFile.Write(funcDecl.name.text);\n            var propertyType = accessorSymbol.getType();\n            if (this.canEmitTypeAnnotationSignature(ToDeclFlags(accessorSymbol.flags))) {\n                this.declFile.Write(" : ");\n                this.emitTypeSignature(propertyType);\n            }\n            this.declFile.WriteLine(";");\n\n            return false;\n        }\n\n        private emitClassMembersFromConstructorDefinition(funcDecl: FuncDecl) {\n            if (funcDecl.arguments) {\n                var argsLen = funcDecl.arguments.members.length; if (funcDecl.variableArgList) { argsLen--; }\n\n                for (var i = 0; i < argsLen; i++) {\n                    var argDecl = <ArgDecl>funcDecl.arguments.members[i];\n                    if (hasFlag(argDecl.varFlags, VarFlags.Property)) {\n                        this.emitDeclarationComments(argDecl);\n                        this.emitDeclFlags(ToDeclFlags(argDecl.varFlags), "var");\n                        this.declFile.Write(argDecl.id.text);\n\n                        if (argDecl.typeExpr && this.canEmitTypeAnnotationSignature(ToDeclFlags(argDecl.varFlags))) {\n                            this.declFile.Write(": ");\n                            this.emitTypeSignature(argDecl.type);\n                        }\n                        this.declFile.WriteLine(";");\n                    }\n                }\n            }\n        }\n\n        public ClassDeclarationCallback(pre: bool, classDecl: ClassDeclaration): bool {\n            if (!this.canEmitPrePostAstSignature(ToDeclFlags(classDecl.varFlags), classDecl, pre)) {\n                return false;\n            }\n\n            if (pre) {\n                var className = classDecl.name.text;\n                this.emitDeclarationComments(classDecl);\n                this.emitDeclFlags(ToDeclFlags(classDecl.varFlags), "class");\n                this.declFile.Write(className);\n                this.emitBaseList(classDecl.extendsList, "extends");\n                this.emitBaseList(classDecl.implementsList, "implements");\n                this.declFile.WriteLine(" {");\n\n                this.pushDeclarationContainer(classDecl);\n                this.indenter.increaseIndent();\n                if (classDecl.constructorDecl) {\n                    this.emitClassMembersFromConstructorDefinition(classDecl.constructorDecl);\n                }\n            } else {\n                this.indenter.decreaseIndent();\n                this.popDeclarationContainer(classDecl);\n\n                this.emitIndent();\n                this.declFile.WriteLine("}");\n            }\n\n            return true;\n        }\n\n        public InterfaceDeclarationCallback(pre: bool, interfaceDecl: InterfaceDeclaration): bool {\n            if (!this.canEmitPrePostAstSignature(ToDeclFlags(interfaceDecl.varFlags), interfaceDecl, pre)) {\n                return false;\n            }\n\n            if (pre) {\n                var interfaceName = interfaceDecl.name.text;\n                this.emitDeclarationComments(interfaceDecl);\n                this.emitDeclFlags(ToDeclFlags(interfaceDecl.varFlags), "interface");\n                this.declFile.Write(interfaceName);\n                this.emitBaseList(interfaceDecl.extendsList, "extends");\n                this.declFile.WriteLine(" {");\n\n                this.indenter';
var v27650 = v27651 + '.increaseIndent();\n                this.pushDeclarationContainer(interfaceDecl);\n            } else {\n                this.indenter.decreaseIndent();\n                this.popDeclarationContainer(interfaceDecl);\n\n                this.emitIndent();\n                this.declFile.WriteLine("}");\n            }\n\n            return true;\n        }\n\n        public ImportDeclarationCallback(pre: bool, importDecl: ImportDeclaration): bool {\n            if (pre) {\n                if ((<Script>this.declarationContainerStack[0]).isExternallyVisibleSymbol(importDecl.id.sym)) {\n                    this.emitDeclarationComments(importDecl);\n                    this.emitIndent();\n                    this.declFile.Write("import ");\n\n                    this.declFile.Write(importDecl.id.text + " = ");\n                    if (importDecl.isDynamicImport) {\n                        this.declFile.WriteLine("module (" + importDecl.getAliasName() + ");");\n                    } else {\n                        this.declFile.WriteLine(importDecl.getAliasName() + ";");\n                    }\n                }\n            }\n\n            return false;\n        }\n\n        private emitEnumSignature(moduleDecl: ModuleDeclaration) {\n            if (!this.canEmitSignature(ToDeclFlags(moduleDecl.modFlags))) {\n                return false;\n            }\n\n            this.emitDeclarationComments(moduleDecl);\n            this.emitDeclFlags(ToDeclFlags(moduleDecl.modFlags), "enum");\n            this.declFile.WriteLine(moduleDecl.name.text + " {");\n\n            this.indenter.increaseIndent();\n            var membersLen = moduleDecl.members.members.length;\n            for (var j = 1; j < membersLen; j++) {\n                var memberDecl: AST = moduleDecl.members.members[j];\n                if (memberDecl.nodeType == NodeType.VarDecl) {\n                    this.emitDeclarationComments(memberDecl);\n                    this.emitIndent();\n                    this.declFile.WriteLine((<VarDecl>memberDecl).id.text + ",");\n                } else {\n                    CompilerDiagnostics.assert(memberDecl.nodeType != NodeType.Asg, "We want to catch this");\n                }\n            }\n            this.indenter.decreaseIndent();\n\n            this.emitIndent();\n            this.declFile.WriteLine("}");\n\n            return false;\n        }\n\n        public ModuleDeclarationCallback(pre: bool, moduleDecl: ModuleDeclaration): bool {\n            if (hasFlag(moduleDecl.modFlags, ModuleFlags.IsWholeFile)) {\n                // This is dynamic modules and we are going to outputing single file, \n                // we need to change the declFile because dynamic modules are always emitted to their corresponding .d.ts\n                if (hasFlag(moduleDecl.modFlags, ModuleFlags.IsDynamic)) {\n                    if (pre) {\n                        if (!this.emitOptions.outputMany) {\n                            this.singleDeclFile = this.declFile;\n                            CompilerDiagnostics.assert(this.indenter.indentAmt == 0, "Indent has to be 0 when outputing new file");\n                            // Create new file\n                            var declareFileName = this.emitOptions.mapOutputFileName(stripQuotes(moduleDecl.name.sym.name), TypeScriptCompiler.mapToDTSFileName);\n                            var useUTF8InOutputfile = moduleDecl.containsUnicodeChar || (this.emitOptions.emitComments && moduleDecl.containsUnicodeCharInComment);\n                            try {\n                                // Creating files can cause exceptions, report them.   \n                                this.declFile = new DeclFileWriter(this.emitOptions.ioHost.createFile(declareFileName, useUTF8InOutputfile));\n                            } catch (ex) {\n                                this.errorReporter.emitterError(null, ex.message);\n                            }\n                        }\n                        this.pushDeclarationContainer(moduleDecl);\n                    } else {\n                        if (!this.emitOptions.outputMany) {\n                            CompilerDiagnostics.assert(this.singleDeclFile != this.declFile, "singleDeclFile cannot be null as we are going to revert back to it");\n                            CompilerDiagnostics.assert(this.indenter.indentAmt == 0, "Indent has to be 0 when outputing new file");\n                            try {\n                                // Closing files could result in exceptions, report them if they occur\n                                this.declFile.Close();\n                            } catch (ex) {\n                                this.errorReporter.emitterError(null, ex.message);\n                            }\n                            this.declFile = this.singleDeclFile;\n                        }\n                        this.popDeclarationContainer(moduleDecl);\n                    }\n                }\n\n                return true;\n            }\n\n            if (moduleDecl.isEnum()) {\n                if (pre) {\n           ';
var v27649 = v27650 + '         this.emitEnumSignature(moduleDecl);\n                }\n                return false;\n            }\n\n            if (!this.canEmitPrePostAstSignature(ToDeclFlags(moduleDecl.modFlags), moduleDecl, pre)) {\n                return false;\n            }\n\n            if (pre) {\n                if (this.emitDottedModuleName()) {\n                    this.dottedModuleEmit += ".";\n                } else {\n                    this.dottedModuleEmit = this.getDeclFlagsString(ToDeclFlags(moduleDecl.modFlags), "module");\n                }\n                this.dottedModuleEmit += moduleDecl.name.text;\n\n                var isCurrentModuleDotted = (moduleDecl.members.members.length == 1 &&\n                    moduleDecl.members.members[0].nodeType == NodeType.ModuleDeclaration &&\n                    !(<ModuleDeclaration>moduleDecl.members.members[0]).isEnum() &&\n                    hasFlag((<ModuleDeclaration>moduleDecl.members.members[0]).modFlags, ModuleFlags.Exported));\n\n                // Module is dotted only if it does not have doc comments for it\n                var moduleDeclComments = moduleDecl.getDocComments();\n                isCurrentModuleDotted = isCurrentModuleDotted && (moduleDeclComments == null || moduleDeclComments.length == 0);\n\n                this.isDottedModuleName.push(isCurrentModuleDotted);\n                this.pushDeclarationContainer(moduleDecl);\n\n                if (!isCurrentModuleDotted) {\n                    this.emitDeclarationComments(moduleDecl);\n                    this.declFile.Write(this.dottedModuleEmit);\n                    this.declFile.WriteLine(" {");\n                    this.indenter.increaseIndent();\n                }\n            } else {\n                if (!this.emitDottedModuleName()) {\n                    this.indenter.decreaseIndent();\n                    this.emitIndent();\n                    this.declFile.WriteLine("}");\n                }\n                this.popDeclarationContainer(moduleDecl);\n                this.isDottedModuleName.pop();\n            }\n\n            return true;\n        }\n\n        public ScriptCallback(pre: bool, script: Script): bool {\n            if (pre) {\n                if (this.emitOptions.outputMany) {\n                    for (var i = 0; i < script.referencedFiles.length; i++) {\n                        var referencePath = script.referencedFiles[i].path;\n                        var declareFileName: string;\n                        if (isRooted(referencePath)) {\n                            declareFileName = this.emitOptions.mapOutputFileName(referencePath, TypeScriptCompiler.mapToDTSFileName)\n                        } else {\n                            declareFileName = getDeclareFilePath(script.referencedFiles[i].path);\n                        }\n                        this.declFile.WriteLine(\'/// <reference path="\' + declareFileName + \'" />\');\n                    }\n                }\n                this.pushDeclarationContainer(script);\n            }\n            else {\n                this.popDeclarationContainer(script);\n            }\n            return true;\n        }\n\n        public DefaultCallback(pre: bool, ast: AST): bool {\n            return !hasFlag(ast.flags, ASTFlags.IsStatement);\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export module CompilerDiagnostics {\n        export var debug = false;\n        export interface IDiagnosticWriter {\n            Alert(output: string): void;\n        }\n\n        export var diagnosticWriter: IDiagnosticWriter = null;\n\n        export var analysisPass: number = 0;\n\n        export function Alert(output: string) {\n            if (diagnosticWriter) {\n                diagnosticWriter.Alert(output);\n            }\n        }\n\n        export function debugPrint(s: string) {\n            if (debug) {\n                Alert(s);\n            }\n        }\n\n        export function assert(condition: bool, s: string) {\n            if (debug) {\n                if (!condition) {\n                    Alert(s);\n                }\n            }\n        }\n\n    }\n\n    export interface ILogger {\n        information(): bool;\n        debug(): bool;\n        warning(): bool;\n        error(): bool;\n        fatal(): bool;\n        log(s: string): void;\n    }\n\n    export class NullLogger implements ILogger {\n        public information(): bool { return false; }\n        public debug(): bool { r';
var v27648 = v27649 + 'eturn false; }\n        public warning(): bool { return false; }\n        public error(): bool { return false; }\n        public fatal(): bool { return false; }\n        public log(s: string): void {\n        }\n    }\n\n    export class LoggerAdapter implements ILogger {\n        private _information: bool;\n        private _debug: bool;\n        private _warning: bool;\n        private _error: bool;\n        private _fatal: bool;\n\n        constructor (public logger: ILogger) { \n            this._information = this.logger.information();\n            this._debug = this.logger.debug();\n            this._warning = this.logger.warning();\n            this._error = this.logger.error();\n            this._fatal = this.logger.fatal();\n        }\n\n\n        public information(): bool { return this._information; }\n        public debug(): bool { return this._debug; }\n        public warning(): bool { return this._warning; }\n        public error(): bool { return this._error; }\n        public fatal(): bool { return this._fatal; }\n        public log(s: string): void {\n            this.logger.log(s);\n        }\n    }\n\n    export class BufferedLogger implements ILogger {\n        public logContents = [];\n\n        public information(): bool { return false; }\n        public debug(): bool { return false; }\n        public warning(): bool { return false; }\n        public error(): bool { return false; }\n        public fatal(): bool { return false; }\n        public log(s: string): void {\n            this.logContents.push(s);\n        }\n    }\n\n    export function timeFunction(logger: ILogger, funcDescription: string, func: () =>any): any {\n        var start = +new Date();\n        var result = func();\n        var end = +new Date();\n        logger.log(funcDescription + " completed in " + (end - start) + " msec");\n        return result;\n    }\n\n    export function stringToLiteral(value: string, length: number): string {\n        var result = "";\n\n        var addChar = (index: number) => {\n            var ch = value.charCodeAt(index);\n            switch (ch) {\n                case 0x09: // tab\n                    result += "\\\\t";\n                    break;\n                case 0x0a: // line feed\n                    result += "\\\\n";\n                    break;\n                case 0x0b: // vertical tab\n                    result += "\\\\v";\n                    break;\n                case 0x0c: // form feed\n                    result += "\\\\f";\n                    break;\n                case 0x0d: // carriage return\n                    result += "\\\\r";\n                    break;\n                case 0x22:  // double quote\n                    result += "\\\\\\"";\n                    break;\n                case 0x27: // single quote\n                    result += "\\\\\\\'";\n                    break;\n                case 0x5c: // Backslash\n                    result += "\\\\";\n                    break;\n                default:\n                    result += value.charAt(index);\n            }\n        }\n\n        var tooLong = (value.length > length);\n        if (tooLong) {\n            var mid = length >> 1;\n            for (var i = 0; i < mid; i++) addChar(i);\n            result += "(...)";\n            for (var i = value.length - mid; i < value.length; i++) addChar(i);\n        }\n        else {\n            length = value.length;\n            for (var i = 0; i < length; i++) addChar(i);\n        }\n        return result;\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export enum EmitContainer {\n        Prog,\n        Module,\n        DynamicModule,\n        Class,\n        Constructor,\n        Function,\n        Args,\n        Interface,\n    }\n\n    export class EmitState {\n        public column: number;\n        public line: number;\n        public pretty: bool;\n        public inObjectLiteral: bool;\n        public container: EmitContainer;\n\n        constructor () {\n            this.column = 0;\n            this.line = 0;\n            this.pretty = false;\n            this.inObjectLiteral = false;\n            this.container = EmitContainer.Prog;\n        }\n    }\n\n    export class EmitOptions {\n        public minWhitespace: bool;\n        public propagateConstants: bool;\n        public emitComments: bool;\n        public outputOption: string;\n        public ioHost: EmitterIOHost = null;\n        public outputMany: bool = true;\n        public commonDirectoryPath';
var v27647 = v27648 + ' = "";\n\n        constructor(settings: CompilationSettings) {\n            this.minWhitespace = settings.minWhitespace;\n            this.propagateConstants = settings.propagateConstants;\n            this.emitComments = settings.emitComments;\n            this.outputOption = settings.outputOption;\n        }\n\n        public mapOutputFileName(fileName: string, extensionChanger: (fname: string, wholeFileNameReplaced: bool) => string) {\n            if (this.outputMany) {\n                var updatedFileName = fileName;\n                if (this.outputOption != "") {\n                    // Replace the common directory path with the option specified\n                    updatedFileName = fileName.replace(this.commonDirectoryPath, "");\n                    updatedFileName = this.outputOption + updatedFileName;\n                }\n                return extensionChanger(updatedFileName, false);\n            } else {\n                return extensionChanger(this.outputOption, true);\n            }\n        }\n    }\n\n    export class Indenter {\n        static indentStep : number = 4;\n        static indentStepString : string = "    ";\n        static indentStrings: string[] = [];\n        public indentAmt: number = 0;\n\n        public increaseIndent() {\n            this.indentAmt += Indenter.indentStep;\n        }\n\n        public decreaseIndent() {\n            this.indentAmt -= Indenter.indentStep;\n        }\n\n        public getIndent() {\n            var indentString = Indenter.indentStrings[this.indentAmt];\n            if (indentString === undefined) {\n                indentString = "";\n                for (var i = 0; i < this.indentAmt; i = i + Indenter.indentStep) {\n                    indentString += Indenter.indentStepString;\n                }\n                Indenter.indentStrings[this.indentAmt] = indentString;\n            }\n            return indentString;\n        }\n    }\n\n    export class Emitter {\n        public prologueEmitted = false;\n        public thisClassNode: TypeDeclaration = null;\n        public thisFnc: FuncDecl = null;\n        public moduleDeclList: ModuleDeclaration[] = [];\n        public moduleName = "";\n        public emitState = new EmitState();\n        public indenter = new Indenter();\n        public ambientModule = false;\n        public modAliasId: string = null;\n        public firstModAlias: string = null;\n        public allSourceMappers: SourceMapper[] = [];\n        public sourceMapper: SourceMapper = null;\n        public captureThisStmtString = "var _this = this;";\n        private varListCountStack: number[] = [0]; \n\n        constructor(public checker: TypeChecker, public emittingFileName: string, public outfile: ITextWriter, public emitOptions: EmitOptions, public errorReporter: ErrorReporter) {\n        }\n\n        public setSourceMappings(mapper: SourceMapper) {\n            this.allSourceMappers.push(mapper);\n            this.sourceMapper = mapper;\n        }\n\n        public writeToOutput(s: string) {\n            this.outfile.Write(s);\n            // TODO: check s for newline\n            this.emitState.column += s.length;\n        }\n\n        public writeToOutputTrimmable(s: string) {\n            if (this.emitOptions.minWhitespace) {\n                s = s.replace(/[\\s]*/g, \'\');\n            }\n            this.writeToOutput(s);\n        }\n\n        public writeLineToOutput(s: string) {\n            if (this.emitOptions.minWhitespace) {\n                this.writeToOutput(s);\n                var c = s.charCodeAt(s.length - 1);\n                if (!((c == LexCodeSpace) || (c == LexCodeSMC) || (c == LexCodeLBR))) {\n                    this.writeToOutput(\' \');\n                }\n            }\n            else {\n                this.outfile.WriteLine(s);\n                this.emitState.column = 0\n                this.emitState.line++;\n            }\n        }\n\n        public writeCaptureThisStatement(ast: AST) {\n            this.emitIndent();\n            this.recordSourceMappingStart(ast);\n            this.writeToOutput(this.captureThisStmtString);\n            this.recordSourceMappingEnd(ast);\n            this.writeLineToOutput("");\n        }\n\n        public setInVarBlock(count: number) {\n            this.varListCountStack[this.varListCountStack.length - 1] = count;\n        }\n\n        public setInObjectLiteral(val: bool): bool {\n            var temp = this.emitState.inObjectLiteral;\n            this.emitState.inObjectLiteral = val;\n            return temp;\n        }\n\n        public setContainer(c: number): number {\n            var temp = this.emitState.container;\n            this.emitState.container = c;\n            return temp;\n        }\n\n        private getIndentString() {\n            if (this.emitOptions.minWhitespace) {\n                return "";\n            }\n            else {\n                return this.indenter.getIndent();\n            }\n        }\n\n        public emitIndent() {\n            this.writeToOutput(this.getIndentString());\n        }\n\n        public emitCommentInPlace(comment: Comment) {\n            var tex';
var v27646 = v27647 + 't = comment.getText();\n            var hadNewLine = false;\n\n            if (comment.isBlockComment) {\n                if (this.emitState.column == 0) {\n                    this.emitIndent();\n                }\n                this.recordSourceMappingStart(comment);\n                this.writeToOutput(text[0]);\n\n                if (text.length > 1 || comment.endsLine) {\n                    for (var i = 1; i < text.length; i++) {\n                        this.writeLineToOutput("");\n                        this.emitIndent();\n                        this.writeToOutput(text[i]);\n                    }\n                    this.recordSourceMappingEnd(comment);\n                    this.writeLineToOutput("");\n                    hadNewLine = true;\n                } else {\n                    this.recordSourceMappingEnd(comment);\n                }\n            }\n            else {\n                if (this.emitState.column == 0) {\n                    this.emitIndent();\n                }\n                this.recordSourceMappingStart(comment);\n                this.writeToOutput(text[0]);\n                this.recordSourceMappingEnd(comment);\n                this.writeLineToOutput("");\n                hadNewLine = true;\n            }\n\n            if (hadNewLine) {\n                this.emitIndent();\n            }\n            else {\n                this.writeToOutput(" ");\n            }\n        }\n\n        public emitParensAndCommentsInPlace(ast: AST, pre: bool) {\n            var comments = pre ? ast.preComments : ast.postComments;\n\n            // comments should be printed before the LParen, but after the RParen\n            if (ast.isParenthesized && !pre) {\n                this.writeToOutput(")");\n            }\n            if (this.emitOptions.emitComments && comments && comments.length != 0) {\n                for (var i = 0; i < comments.length; i++) {\n                    this.emitCommentInPlace(comments[i]);\n                }\n            }\n            if (ast.isParenthesized && pre) {\n                this.writeToOutput("(");\n            }\n        }\n\n        // TODO: emit accessor pattern\n        public emitObjectLiteral(content: ASTList) {\n            this.writeLineToOutput("{");\n            this.indenter.increaseIndent();\n            var inObjectLiteral = this.setInObjectLiteral(true);\n            this.emitJavascriptList(content, ",", TokenID.Comma, true, false, false);\n            this.setInObjectLiteral(inObjectLiteral);\n            this.indenter.decreaseIndent();\n            this.emitIndent();\n            this.writeToOutput("}");\n        }\n\n        public emitArrayLiteral(content: ASTList) {\n            this.writeToOutput("[");\n            if (content) {\n                this.writeLineToOutput("");\n                this.indenter.increaseIndent();\n                this.emitJavascriptList(content, ", ", TokenID.Comma, true, false, false);\n                this.indenter.decreaseIndent();\n                this.emitIndent();\n            }\n            this.writeToOutput("]");\n        }\n\n        public emitNew(target: AST, args: ASTList) {\n            this.writeToOutput("new ");\n            if (target.nodeType == NodeType.TypeRef) {\n                var typeRef = <TypeReference>target;\n                if (typeRef.arrayCount) {\n                    this.writeToOutput("Array()");\n                }\n                else {\n                    this.emitJavascript(typeRef.term, TokenID.Tilde, false);\n                    this.writeToOutput("()");\n                }\n            }\n            else {\n                this.emitJavascript(target, TokenID.Tilde, false);\n                this.recordSourceMappingStart(args);\n                this.writeToOutput("(");\n                this.emitJavascriptList(args, ", ", TokenID.Comma, false, false, false);\n                this.writeToOutput(")");\n                this.recordSourceMappingEnd(args);\n            }\n        }\n\n        public tryEmitConstant(dotExpr: BinaryExpression) {\n            if (!this.emitOptions.propagateConstants) {\n                return false;\n            }\n            var propertyName = <Identifier>dotExpr.operand2;\n            if (propertyName && propertyName.sym && propertyName.sym.isVariable()) {\n                if (hasFlag(propertyName.sym.flags, SymbolFlags.Constant)) {\n                    if (propertyName.sym.declAST) {\n                        var boundDecl = <BoundDecl>propertyName.sym.declAST;\n                        if (boundDecl.init && (boundDecl.init.nodeType == NodeType.NumberLit)) {\n                            var numLit = <NumberLiteral>boundDecl.init;\n                            this.writeToOutput(numLit.value.toString());\n                            var comment = " /* ";\n                            comment += propertyName.actualText;\n                            comment += " */ ";\n                            this.writeToOutput(comment);\n                            return true;\n                        }\n                    }\n                }\n            }\n            ret';
var v27645 = v27646 + 'urn false;\n        }\n\n        public emitCall(callNode: CallExpression, target: AST, args: ASTList) {\n            if (!this.emitSuperCall(callNode)) {\n                if (!hasFlag(callNode.flags, ASTFlags.ClassBaseConstructorCall)) {\n                    if (target.nodeType == NodeType.FuncDecl && !target.isParenthesized) {\n                        this.writeToOutput("(");\n                    }\n                    if (callNode.target.nodeType == NodeType.Super && this.emitState.container == EmitContainer.Constructor) {\n                        this.writeToOutput("_super.call");\n                    }\n                    else {\n                        this.emitJavascript(target, TokenID.OpenParen, false);\n                    }\n                    if (target.nodeType == NodeType.FuncDecl && !target.isParenthesized) {\n                        this.writeToOutput(")");\n                    }\n                    this.recordSourceMappingStart(args);\n                    this.writeToOutput("(");\n                    if (callNode.target.nodeType == NodeType.Super && this.emitState.container == EmitContainer.Constructor) {\n                        this.writeToOutput("this");\n                        if (args && args.members.length) {\n                            this.writeToOutput(", ");\n                        }\n                    }\n                    this.emitJavascriptList(args, ", ", TokenID.Comma, false, false, false);\n                    this.writeToOutput(")");\n                    this.recordSourceMappingEnd(args);\n                }\n                else {\n                    this.indenter.decreaseIndent();\n                    this.indenter.decreaseIndent();\n                    var constructorCall = new ASTList();\n                    constructorCall.members[0] = callNode;\n                    this.emitConstructorCalls(constructorCall, this.thisClassNode);\n                    this.indenter.increaseIndent();\n                    this.indenter.increaseIndent();\n                }\n            }\n        }\n\n        public emitConstructorCalls(bases: ASTList, classDecl: TypeDeclaration) {\n            if (bases == null) {\n                return;\n            }\n            var basesLen = bases.members.length;\n            this.recordSourceMappingStart(classDecl);\n            for (var i = 0; i < basesLen; i++) {\n                var baseExpr = bases.members[i];\n                var baseSymbol: Symbol = null;\n                if (baseExpr.nodeType == NodeType.Call) {\n                    baseSymbol = (<CallExpression>baseExpr).target.type.symbol;\n                }\n                else {\n                    baseSymbol = baseExpr.type.symbol;\n                }\n                var baseName = baseSymbol.name;\n                if (baseSymbol.declModule != classDecl.type.symbol.declModule) {\n                    baseName = baseSymbol.fullName();\n                }\n                if (baseExpr.nodeType == NodeType.Call) {\n                    this.emitIndent();\n                    this.writeToOutput("_super.call(this");\n                    var args = (<CallExpression>baseExpr).arguments;\n                    if (args && (args.members.length > 0)) {\n                        this.writeToOutput(", ");\n                        this.emitJavascriptList(args, ", ", TokenID.Comma, false, false, false);\n                    }\n                    this.writeToOutput(")");\n                }\n                else {\n                    if (baseExpr.type && (baseExpr.type.isClassInstance())) {\n                        // parameterless constructor call;\n                        this.emitIndent();\n                        this.writeToOutput(classDecl.name.actualText + "._super.constructor");\n                        //emitJavascript(baseExpr,TokenID.LParen,false);\n                        this.writeToOutput(".call(this)");\n                    }\n                }\n            }\n            this.recordSourceMappingEnd(classDecl);\n        }\n\n        public emitInnerFunction(funcDecl: FuncDecl, printName: bool, isMember: bool,\n            bases: ASTList, hasSelfRef: bool, classDecl: TypeDeclaration) {\n            /// REVIEW: The code below causes functions to get pushed to a newline in cases where they shouldn\'t\n            /// such as: \n            ///     Foo.prototype.bar = \n            ///         function() {\n            ///         };\n            /// Once we start emitting comments, we should pull this code out to place on the outer context where the function\n            /// is used.\n            //if (funcDecl.preComments!=null && funcDecl.preComments.length>0) {\n            //    this.writeLineToOutput("");\n            //    this.increaseIndent();\n            //    emitIndent();\n            //}\n\n            var isClassConstructor = funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod);\n            var hasNonObjectBaseType = isClassConstructor && hasFlag(this.thisClassNode.type.instanceType.typeFlags, TypeFlags.HasBaseType) && !hasFlag(this.thisClassNode.';
var v27644 = v27645 + 'type.instanceType.typeFlags, TypeFlags.HasBaseTypeOfObject);\n            var classPropertiesMustComeAfterSuperCall = hasNonObjectBaseType && hasFlag((<ClassDeclaration>this.thisClassNode).varFlags, VarFlags.ClassSuperMustBeFirstCallInConstructor);\n\n            // We have no way of knowing if the current function is used as an expression or a statement, so as to enusre that the emitted\n            // JavaScript is always valid, add an extra parentheses for unparenthesized function expressions\n            var shouldParenthesize = hasFlag(funcDecl.fncFlags, FncFlags.IsFunctionExpression) && !funcDecl.isParenthesized && !funcDecl.isAccessor() && (hasFlag(funcDecl.flags, ASTFlags.ExplicitSemicolon) || hasFlag(funcDecl.flags, ASTFlags.AutomaticSemicolon));\n\n            this.emitParensAndCommentsInPlace(funcDecl, true);\n            if (shouldParenthesize) {\n                this.writeToOutput("(");\n            }\n            this.recordSourceMappingStart(funcDecl);\n            if (!(funcDecl.isAccessor() && (<FieldSymbol>funcDecl.accessorSymbol).isObjectLitField)) {\n                this.writeToOutput("function ");\n            }\n            if (printName) {\n                var id = funcDecl.getNameText();\n                if (id && !funcDecl.isAccessor()) {\n                    if (funcDecl.name) {\n                        this.recordSourceMappingStart(funcDecl.name);\n                    }\n                    this.writeToOutput(id);\n                    if (funcDecl.name) {\n                        this.recordSourceMappingEnd(funcDecl.name);\n                    }\n                }\n            }\n\n            this.writeToOutput("(");\n            var argsLen = 0;\n            var i = 0;\n            var arg: ArgDecl;\n            var defaultArgs: ArgDecl[] = [];\n            if (funcDecl.arguments) {\n                var tempContainer = this.setContainer(EmitContainer.Args);\n                argsLen = funcDecl.arguments.members.length;\n                var printLen = argsLen;\n                if (funcDecl.variableArgList) {\n                    printLen--;\n                }\n                for (i = 0; i < printLen; i++) {\n                    arg = <ArgDecl>funcDecl.arguments.members[i];\n                    if (arg.init) {\n                        defaultArgs.push(arg);\n                    }\n                    this.emitJavascript(arg, TokenID.OpenParen, false);\n                    if (i < (printLen - 1)) {\n                        this.writeToOutput(", ");\n                    }\n                }\n                this.setContainer(tempContainer);\n            }\n            this.writeLineToOutput(") {");\n\n            if (funcDecl.isConstructor) {\n                this.recordSourceMappingNameStart("constructor");\n            } else if (funcDecl.isGetAccessor()) {\n                this.recordSourceMappingNameStart("get_" + funcDecl.getNameText());\n            } else if (funcDecl.isSetAccessor()) {\n                this.recordSourceMappingNameStart("set_" + funcDecl.getNameText());\n            } else {\n                this.recordSourceMappingNameStart(funcDecl.getNameText());\n            }\n            this.indenter.increaseIndent();\n\n            // set default args first\n            for (i = 0; i < defaultArgs.length; i++) {\n                var arg = defaultArgs[i];\n                this.emitIndent();\n                this.recordSourceMappingStart(arg);\n                this.writeToOutput("if (typeof " + arg.id.actualText + " === \\"undefined\\") { ");//\n                this.recordSourceMappingStart(arg.id);\n                this.writeToOutput(arg.id.actualText);\n                this.recordSourceMappingEnd(arg.id);\n                this.writeToOutput(" = ");\n                this.emitJavascript(arg.init, TokenID.OpenParen, false);\n                this.writeLineToOutput("; }")\n                this.recordSourceMappingEnd(arg);\n            }\n\n            if (funcDecl.isConstructor && ((<ClassDeclaration>funcDecl.classDecl).varFlags & VarFlags.MustCaptureThis)) {\n                this.writeCaptureThisStatement(funcDecl);\n            }\n\n            if (funcDecl.isConstructor && !classPropertiesMustComeAfterSuperCall) {\n                if (funcDecl.arguments) {\n                    argsLen = funcDecl.arguments.members.length;\n                    for (i = 0; i < argsLen; i++) {\n                        arg = <ArgDecl>funcDecl.arguments.members[i];\n                        if ((arg.varFlags & VarFlags.Property) != VarFlags.None) {\n                            this.emitIndent();\n                            this.recordSourceMappingStart(arg);\n                            this.recordSourceMappingStart(arg.id);\n                            this.writeToOutput("this." + arg.id.actualText);\n                            this.recordSourceMappingEnd(arg.id);\n                            this.writeToOutput(" = ");\n                            this.recordSourceMappingStart(arg.id);\n                            this.writeToOutput(arg.id.actualText);\n                            this.re';
var v27643 = v27644 + 'cordSourceMappingEnd(arg.id);\n                            this.writeLineToOutput(";");\n                            this.recordSourceMappingEnd(arg);\n                        }\n                    }\n                }\n\n                // For classes, the constructor needs to be explicitly called\n                if (!hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {\n                    this.emitConstructorCalls(bases, classDecl);\n                }\n            }\n            if (hasSelfRef) {\n                this.writeCaptureThisStatement(funcDecl);\n            }\n            if (funcDecl.variableArgList) {\n                argsLen = funcDecl.arguments.members.length;\n                var lastArg = <ArgDecl>funcDecl.arguments.members[argsLen - 1];\n                this.emitIndent();\n                this.recordSourceMappingStart(lastArg);\n                this.writeToOutput("var ");\n                this.recordSourceMappingStart(lastArg.id);\n                this.writeToOutput(lastArg.id.actualText);\n                this.recordSourceMappingEnd(lastArg.id);\n                this.writeLineToOutput(" = [];");\n                this.recordSourceMappingEnd(lastArg);\n                this.emitIndent();\n                this.writeToOutput("for (")\n                this.recordSourceMappingStart(lastArg);\n                this.writeToOutput("var _i = 0;");\n                this.recordSourceMappingEnd(lastArg);\n                this.writeToOutput(" ");\n                this.recordSourceMappingStart(lastArg);\n                this.writeToOutput("_i < (arguments.length - " + (argsLen - 1) + ")");\n                this.recordSourceMappingEnd(lastArg);\n                this.writeToOutput("; ");\n                this.recordSourceMappingStart(lastArg);\n                this.writeToOutput("_i++");\n                this.recordSourceMappingEnd(lastArg);\n                this.writeLineToOutput(") {");\n                this.indenter.increaseIndent();\n                this.emitIndent();\n\n                this.recordSourceMappingStart(lastArg);\n                this.writeToOutput(lastArg.id.actualText + "[_i] = arguments[_i + " + (argsLen - 1) + "];");\n                this.recordSourceMappingEnd(lastArg);\n                this.writeLineToOutput("");\n                this.indenter.decreaseIndent();\n                this.emitIndent();\n                this.writeLineToOutput("}");\n            }\n\n            // if it\'s a class, emit the uninitializedMembers, first emit the non-proto class body members\n            if (funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod) && !classPropertiesMustComeAfterSuperCall) {\n\n                var nProps = (<ASTList>this.thisClassNode.members).members.length;\n\n                for (var i = 0; i < nProps; i++) {\n                    if ((<ASTList>this.thisClassNode.members).members[i].nodeType == NodeType.VarDecl) {\n                        var varDecl = <VarDecl>(<ASTList>this.thisClassNode.members).members[i];\n                        if (!hasFlag(varDecl.varFlags, VarFlags.Static) && varDecl.init) {\n                            this.emitIndent();\n                            this.emitJavascriptVarDecl(varDecl, TokenID.Tilde);\n                            this.writeLineToOutput("");\n                        }\n                    }\n                }\n                //this.writeLineToOutput("");\n            }\n\n            this.emitBareJavascriptStatements(funcDecl.bod, classPropertiesMustComeAfterSuperCall);\n\n            this.indenter.decreaseIndent();\n            this.emitIndent();\n            this.recordSourceMappingStart(funcDecl.endingToken);\n            this.writeToOutput("}");\n\n            this.recordSourceMappingNameEnd();\n            this.recordSourceMappingEnd(funcDecl.endingToken);\n            this.recordSourceMappingEnd(funcDecl);\n\n            if (shouldParenthesize) {\n                this.writeToOutput(")");\n            }\n\n            // The extra call is to make sure the caller\'s funcDecl end is recorded, since caller wont be able to record it\n            this.recordSourceMappingEnd(funcDecl);\n\n            this.emitParensAndCommentsInPlace(funcDecl, false);\n\n            if (!isMember &&\n                //funcDecl.name != null &&\n                !hasFlag(funcDecl.fncFlags, FncFlags.IsFunctionExpression) &&\n                (hasFlag(funcDecl.fncFlags, FncFlags.Definition) || funcDecl.isConstructor)) {\n                this.writeLineToOutput("");\n            } else if (hasFlag(funcDecl.fncFlags, FncFlags.IsFunctionExpression)) {\n                if (hasFlag(funcDecl.flags, ASTFlags.ExplicitSemicolon) || hasFlag(funcDecl.flags, ASTFlags.AutomaticSemicolon)) {\n                    // If either of these two flags are set, then the function expression is a statement. Terminate it.\n                    this.writeLineToOutput(";");\n                }\n            }\n            /// TODO: See the other part of this at the beginning of function\n            //if (funcDecl.preComments!=null && funcDecl.preComments.length>0) {\n  ';
var v27642 = v27643 + '          //    this.decreaseIndent();\n            //}           \n        }\n\n        public emitJavascriptModule(moduleDecl: ModuleDeclaration) {\n            var modName = moduleDecl.name.actualText;\n            if (isTSFile(modName)) {\n                moduleDecl.name.setText(modName.substring(0, modName.length - 3));\n            }\n            else if (isSTRFile(modName)) {\n                moduleDecl.name.setText(modName.substring(0, modName.length - 4));\n            }\n\n            if (!hasFlag(moduleDecl.modFlags, ModuleFlags.Ambient)) {\n                var isDynamicMod = hasFlag(moduleDecl.modFlags, ModuleFlags.IsDynamic);\n                var prevOutFile = this.outfile;\n                var prevOutFileName = this.emittingFileName;\n                var prevAllSourceMappers = this.allSourceMappers;\n                var prevSourceMapper = this.sourceMapper;\n                var prevColumn = this.emitState.column;\n                var prevLine = this.emitState.line;\n                var temp = this.setContainer(EmitContainer.Module);\n                var svModuleName = this.moduleName;\n                var isExported = hasFlag(moduleDecl.modFlags, ModuleFlags.Exported);\n                this.moduleDeclList[this.moduleDeclList.length] = moduleDecl;\n                var isWholeFile = hasFlag(moduleDecl.modFlags, ModuleFlags.IsWholeFile);\n                this.moduleName = moduleDecl.name.actualText;\n\n                // prologue\n                if (isDynamicMod) {\n                    // create the new outfile for this module\n                    var tsModFileName = stripQuotes(moduleDecl.name.actualText);\n                    var modFilePath = trimModName(tsModFileName) + ".js";\n                    modFilePath = this.emitOptions.mapOutputFileName(modFilePath, TypeScriptCompiler.mapToJSFileName);\n\n                    if (this.emitOptions.ioHost) {\n                        // Ensure that the slashes are normalized so that the comparison is fair\n                        // REVIEW: Note that modFilePath is normalized to forward slashes in Parser.parse, so the \n                        // first call to switchToForwardSlashes is technically a no-op, but it will prevent us from\n                        // regressing if the parser changes\n                        if (switchToForwardSlashes(modFilePath) != switchToForwardSlashes(this.emittingFileName)) {\n                            this.emittingFileName = modFilePath;\n                            var useUTF8InOutputfile = moduleDecl.containsUnicodeChar || (this.emitOptions.emitComments && moduleDecl.containsUnicodeCharInComment);\n                            this.outfile = this.createFile(this.emittingFileName, useUTF8InOutputfile);\n                            if (prevSourceMapper != null) {\n                                this.allSourceMappers = [];\n                                var sourceMappingFile = this.createFile(this.emittingFileName + SourceMapper.MapFileExtension, false);\n                                this.setSourceMappings(new TypeScript.SourceMapper(tsModFileName, this.emittingFileName, this.outfile, sourceMappingFile, this.errorReporter));\n                                this.emitState.column = 0;\n                                this.emitState.line = 0;\n                            }\n                        } else {\n                            CompilerDiagnostics.assert(this.emitOptions.outputMany, "Cannot have dynamic modules compiling into single file");\n                        }\n                    }\n\n                    this.setContainer(EmitContainer.DynamicModule); // discard the previous \'Module\' container\n\n                    this.recordSourceMappingStart(moduleDecl);\n                    if (moduleGenTarget == ModuleGenTarget.Asynchronous) { // AMD\n                        var dependencyList = "[\\"require\\", \\"exports\\"";\n                        var importList = "require, exports";\n                        var importStatement: ImportDeclaration = null;\n\n                        // all dependencies are quoted\n                        for (var i = 0; i < (<ModuleType>moduleDecl.mod).importedModules.length; i++) {\n                            importStatement = (<ModuleType>moduleDecl.mod).importedModules[i]\n\n                            // if the imported module is only used in a type position, do not add it as a requirement\n                            if (importStatement.id.sym &&\n                                !(<TypeSymbol>importStatement.id.sym).onlyReferencedAsTypeRef) {\n                                if (i <= (<ModuleType>moduleDecl.mod).importedModules.length - 1) {\n                                    dependencyList += ", ";\n                                    importList += ", ";\n                                }\n\n                                importList += "__" + importStatement.id.actualText + "__";\n                                dependencyList += importStatement.firstAliasedModToString();\n                            }\n                        }\n\n                 ';
var v27641 = v27642 + '       // emit any potential amd dependencies\n                        for (var i = 0; i < moduleDecl.amdDependencies.length; i++) {\n                            dependencyList += ", \\"" + moduleDecl.amdDependencies[i] + "\\"";\n                        }\n\n                        dependencyList += "]";\n\n                        this.writeLineToOutput("define(" + dependencyList + "," + " function(" + importList + ") {");\n                    }\n                    else { // Node\n\n                    }\n                }\n                else {\n\n                    if (!isExported) {\n                        this.recordSourceMappingStart(moduleDecl);\n                        this.writeToOutput("var ");\n                        this.recordSourceMappingStart(moduleDecl.name);\n                        this.writeToOutput(this.moduleName);\n                        this.recordSourceMappingEnd(moduleDecl.name);\n                        this.writeLineToOutput(";");\n                        this.recordSourceMappingEnd(moduleDecl);\n                        this.emitIndent();\n                    }\n\n                    this.writeToOutput("(");\n                    this.recordSourceMappingStart(moduleDecl);\n                    this.writeToOutput("function (");\n                    this.recordSourceMappingStart(moduleDecl.name);\n                    this.writeToOutput(this.moduleName);\n                    this.recordSourceMappingEnd(moduleDecl.name);\n                    this.writeLineToOutput(") {");\n                }\n\n                if (!isWholeFile) {\n                    this.recordSourceMappingNameStart(this.moduleName);\n                }\n\n                // body - don\'t indent for Node\n                if (!isDynamicMod || moduleGenTarget == ModuleGenTarget.Asynchronous) {\n                    this.indenter.increaseIndent();\n                }\n\n                if (moduleDecl.modFlags & ModuleFlags.MustCaptureThis) {\n                    this.writeCaptureThisStatement(moduleDecl);\n                }\n\n                this.emitJavascriptList(moduleDecl.members, null, TokenID.Semicolon, true, false, false);\n                if (!isDynamicMod || moduleGenTarget == ModuleGenTarget.Asynchronous) {\n                    this.indenter.decreaseIndent();\n                }\n                this.emitIndent();\n\n                // epilogue\n                if (isDynamicMod) {\n                    if (moduleGenTarget == ModuleGenTarget.Asynchronous) { // AMD\n                        this.writeLineToOutput("})");\n                    }\n                    else { // Node\n                    }\n                    if (!isWholeFile) {\n                        this.recordSourceMappingNameEnd();\n                    }\n                    this.recordSourceMappingEnd(moduleDecl);\n\n                    // close the module outfile, and restore the old one\n                    if (this.outfile != prevOutFile) {\n                        this.Close();\n                        if (prevSourceMapper != null) {\n                            this.allSourceMappers = prevAllSourceMappers;\n                            this.sourceMapper = prevSourceMapper;\n                            this.emitState.column = prevColumn;\n                            this.emitState.line = prevLine;\n                        }\n                        this.outfile = prevOutFile;\n                        this.emittingFileName = prevOutFileName;\n                    }\n                }\n                else {\n                    var containingMod: ModuleDeclaration = null;\n                    if (moduleDecl.type && moduleDecl.type.symbol.container && moduleDecl.type.symbol.container.declAST) {\n                        containingMod = <ModuleDeclaration>moduleDecl.type.symbol.container.declAST;\n                    }\n                    var parentIsDynamic = containingMod && hasFlag(containingMod.modFlags, ModuleFlags.IsDynamic);\n\n                    this.recordSourceMappingStart(moduleDecl.endingToken);\n                    if (temp == EmitContainer.Prog && isExported) {\n                        this.writeToOutput("}");\n                        if (!isWholeFile) {\n                            this.recordSourceMappingNameEnd();\n                        }\n                        this.recordSourceMappingEnd(moduleDecl.endingToken);\n                        this.writeToOutput(")(this." + this.moduleName + " || (this." + this.moduleName + " = {}));");\n                    }\n                    else if (isExported || temp == EmitContainer.Prog) {\n                        var dotMod = svModuleName != "" ? (parentIsDynamic ? "exports" : svModuleName) + "." : svModuleName;\n                        this.writeToOutput("}");\n                        if (!isWholeFile) {\n                            this.recordSourceMappingNameEnd();\n                        }\n                        this.recordSourceMappingEnd(moduleDecl.endingToken);\n                        this.writeToOutput(")(" + dotMod + this.moduleName + " || (" + dotMod + this.moduleName + " = {})';
var v27640 = v27641 + ');");\n                    }\n                    else if (!isExported && temp != EmitContainer.Prog) {\n                        this.writeToOutput("}");\n                        if (!isWholeFile) {\n                            this.recordSourceMappingNameEnd();\n                        }\n                        this.recordSourceMappingEnd(moduleDecl.endingToken);\n                        this.writeToOutput(")(" + this.moduleName + " || (" + this.moduleName + " = {}));");\n                    }\n                    else {\n                        this.writeToOutput("}");\n                        if (!isWholeFile) {\n                            this.recordSourceMappingNameEnd();\n                        }\n                        this.recordSourceMappingEnd(moduleDecl.endingToken);\n                        this.writeToOutput(")();");\n                    }\n                    this.recordSourceMappingEnd(moduleDecl);\n                    this.writeLineToOutput("");\n                    if (temp != EmitContainer.Prog && isExported) {\n                        this.emitIndent();\n                        this.recordSourceMappingStart(moduleDecl);\n                        if (parentIsDynamic) {\n                            this.writeLineToOutput("var " + this.moduleName + " = exports." + this.moduleName + ";");\n                        } else {\n                            this.writeLineToOutput("var " + this.moduleName + " = " + svModuleName + "." + this.moduleName + ";");\n                        }\n                        this.recordSourceMappingEnd(moduleDecl);\n                    }\n                }\n\n                this.setContainer(temp);\n                this.moduleName = svModuleName;\n                this.moduleDeclList.length--;\n            }\n        }\n\n        public emitIndex(operand1: AST, operand2: AST) {\n            var temp = this.setInObjectLiteral(false);\n            this.emitJavascript(operand1, TokenID.Tilde, false);\n            this.writeToOutput("[");\n            this.emitJavascriptList(operand2, ", ", TokenID.Comma, false, false, false);\n            this.writeToOutput("]");\n            this.setInObjectLiteral(temp);\n        }\n\n        public emitStringLiteral(text: string) {\n            // should preserve escape etc.\n            // TODO: simplify object literal simple name\n            this.writeToOutput(text);\n        }\n\n        public emitJavascriptFunction(funcDecl: FuncDecl) {\n            if (hasFlag(funcDecl.fncFlags, FncFlags.Signature) || funcDecl.isOverload) {\n                return;\n            }\n            var temp: number;\n            var tempFnc = this.thisFnc;\n            this.thisFnc = funcDecl;\n\n            if (funcDecl.isConstructor) {\n                temp = this.setContainer(EmitContainer.Constructor);\n            }\n            else {\n                temp = this.setContainer(EmitContainer.Function);\n            }\n\n            var bases: ASTList = null;\n            var hasSelfRef = false;\n            var funcName = funcDecl.getNameText();\n\n            if ((this.emitState.inObjectLiteral || !funcDecl.isAccessor()) &&\n                ((temp != EmitContainer.Constructor) ||\n                ((funcDecl.fncFlags & FncFlags.Method) == FncFlags.None))) {\n                var tempLit = this.setInObjectLiteral(false);\n                if (this.thisClassNode) {\n                    bases = this.thisClassNode.extendsList;\n                }\n                hasSelfRef = Emitter.shouldCaptureThis(funcDecl);\n                this.recordSourceMappingStart(funcDecl);\n                if (hasFlag(funcDecl.fncFlags, FncFlags.Exported | FncFlags.ClassPropertyMethodExported) && funcDecl.type.symbol.container == this.checker.gloMod && !funcDecl.isConstructor) {\n                    this.writeToOutput("this." + funcName + " = ");\n                    this.emitInnerFunction(funcDecl, false, false, bases, hasSelfRef, this.thisClassNode);\n                }\n                else {\n                    this.emitInnerFunction(funcDecl, (funcDecl.name && !funcDecl.name.isMissing()), false, bases, hasSelfRef, this.thisClassNode);\n                }\n                this.setInObjectLiteral(tempLit);\n            }\n            this.setContainer(temp);\n            this.thisFnc = tempFnc;\n\n            if (hasFlag(funcDecl.fncFlags, FncFlags.Definition)) {\n                if (hasFlag(funcDecl.fncFlags, FncFlags.Static)) {\n                    if (this.thisClassNode) {\n                        if (funcDecl.isAccessor()) {\n                            this.emitPropertyAccessor(funcDecl, this.thisClassNode.name.actualText, false);\n                        }\n                        else {\n                            this.emitIndent();\n                            this.recordSourceMappingStart(funcDecl);\n                            this.writeLineToOutput(this.thisClassNode.name.actualText + "." + funcName +\n                                          " = " + funcName + ";");\n                            this.recordSourceMappingEnd(funcDecl);\n                     ';
var v27639 = v27640 + '   }\n                    }\n                }\n                else if ((this.emitState.container == EmitContainer.Module || this.emitState.container == EmitContainer.DynamicModule) && hasFlag(funcDecl.fncFlags, FncFlags.Exported | FncFlags.ClassPropertyMethodExported)) {\n                    this.emitIndent();\n                    var modName = this.emitState.container == EmitContainer.Module ? this.moduleName : "exports";\n                    this.recordSourceMappingStart(funcDecl);\n                    this.writeLineToOutput(modName + "." + funcName +\n                                      " = " + funcName + ";");\n                    this.recordSourceMappingEnd(funcDecl);\n                }\n            }\n        }\n\n        public emitAmbientVarDecl(varDecl: VarDecl) {\n            if (varDecl.init) {\n                this.emitParensAndCommentsInPlace(varDecl, true);\n                this.recordSourceMappingStart(varDecl);\n                this.recordSourceMappingStart(varDecl.id);\n                this.writeToOutput(varDecl.id.actualText);\n                this.recordSourceMappingEnd(varDecl.id);\n                this.writeToOutput(" = ");\n                this.emitJavascript(varDecl.init, TokenID.Comma, false);\n                this.recordSourceMappingEnd(varDecl);\n                this.writeToOutput(";");\n                this.emitParensAndCommentsInPlace(varDecl, false);\n            }\n        }\n\n        private varListCount(): number {\n            return this.varListCountStack[this.varListCountStack.length - 1];\n        }\n\n        // Emits "var " if it is allowed\n        private emitVarDeclVar() {\n            // If it is var list of form var a, b, c = emit it only if count > 0 - which will be when emitting first var\n            // If it is var list of form  var a = varList count will be 0\n            if (this.varListCount() >= 0) {\n                this.writeToOutput("var ");\n                this.setInVarBlock(-this.varListCount());\n            }\n            return true;\n        }\n\n        private onEmitVar() {\n            if (this.varListCount() > 0) {\n                this.setInVarBlock(this.varListCount() - 1);\n            }\n            else if (this.varListCount() < 0) {\n                this.setInVarBlock(this.varListCount() + 1);\n            }\n        }\n\n        public emitJavascriptVarDecl(varDecl: VarDecl, tokenId: TokenID) {\n            if ((varDecl.varFlags & VarFlags.Ambient) == VarFlags.Ambient) {\n                this.emitAmbientVarDecl(varDecl);\n                this.onEmitVar();\n            }\n            else {\n                var sym = varDecl.sym;\n                var hasInitializer = (varDecl.init != null);\n                this.emitParensAndCommentsInPlace(varDecl, true);\n                this.recordSourceMappingStart(varDecl);\n                if (sym && sym.isMember() && sym.container &&\n                    (sym.container.kind() == SymbolKind.Type)) {\n                    var type = (<TypeSymbol>sym.container).type;\n                    if (type.isClass() && (!hasFlag(sym.flags, SymbolFlags.ModuleMember))) {\n                        // class\n                        if (this.emitState.container != EmitContainer.Args) {\n                            if (hasFlag(sym.flags, SymbolFlags.Static)) {\n                                this.writeToOutput(sym.container.name + ".");\n                            }\n                            else {\n                                this.writeToOutput("this.");\n                            }\n                        }\n                    }\n                    else if (type.hasImplementation()) {\n                        // module\n                        if (!hasFlag(sym.flags, SymbolFlags.Exported) && (sym.container == this.checker.gloMod || !hasFlag(sym.flags, SymbolFlags.Property))) {\n                            this.emitVarDeclVar();\n                        }\n                        else if (hasFlag(varDecl.varFlags, VarFlags.LocalStatic)) {\n                            this.writeToOutput(".");\n                        }\n                        else {\n                            if (this.emitState.container == EmitContainer.DynamicModule) {\n                                this.writeToOutput("exports.");\n                            }\n                            else {\n                                this.writeToOutput(this.moduleName + ".");\n                            }\n                        }\n                    }\n                    else {\n                        // function, constructor, method etc.\n                        if (tokenId != TokenID.OpenParen) {\n                            if (hasFlag(sym.flags, SymbolFlags.Exported) && sym.container == this.checker.gloMod) {\n                                this.writeToOutput("this.");\n                            }\n                            else {\n                                this.emitVarDeclVar();\n                            }\n                        }\n                    }\n                }\n                else {\n            ';
var v27638 = v27639 + '        if (tokenId != TokenID.OpenParen) {\n                        this.emitVarDeclVar();\n                    }\n                }\n                this.recordSourceMappingStart(varDecl.id);\n                this.writeToOutput(varDecl.id.actualText);\n                this.recordSourceMappingEnd(varDecl.id);\n                if (hasInitializer) {\n                    this.writeToOutputTrimmable(" = ");\n\n                    // Ensure we have a fresh var list count when recursing into the variable \n                    // initializer.  We don\'t want our current list of variables to affect how we\n                    // emit nested variable lists.\n                    this.varListCountStack.push(0);\n                    this.emitJavascript(varDecl.init, TokenID.Comma, false);\n                    this.varListCountStack.pop();\n                }\n                this.onEmitVar();\n                if ((tokenId != TokenID.OpenParen)) {\n                    if (this.varListCount() < 0) {\n                        this.writeToOutput(", ");\n                    } else if (tokenId != TokenID.For) {\n                        this.writeToOutputTrimmable(";");\n                    }\n                }\n                this.recordSourceMappingEnd(varDecl);\n                this.emitParensAndCommentsInPlace(varDecl, false);\n            }\n        }\n\n        public declEnclosed(moduleDecl: ModuleDeclaration): bool {\n            if (moduleDecl == null) {\n                return true;\n            }\n            for (var i = 0, len = this.moduleDeclList.length; i < len; i++) {\n                if (this.moduleDeclList[i] == moduleDecl) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        public emitJavascriptName(name: Identifier, addThis: bool) {\n            var sym = name.sym;\n            this.emitParensAndCommentsInPlace(name, true);\n            this.recordSourceMappingStart(name);\n            if (!name.isMissing()) {\n                if (addThis && (this.emitState.container != EmitContainer.Args) && sym) {\n                    // TODO: flag global module with marker other than string name\n                    if (sym.container && (sym.container.name != globalId)) {\n                        if (hasFlag(sym.flags, SymbolFlags.Static) && (hasFlag(sym.flags, SymbolFlags.Property))) {\n                            if (sym.declModule && hasFlag(sym.declModule.modFlags, ModuleFlags.IsDynamic)) {\n                                this.writeToOutput("exports.");\n                            }\n                            else {\n                                this.writeToOutput(sym.container.name + ".");\n                            }\n                        }\n                        else if (sym.kind() == SymbolKind.Field) {\n                            var fieldSym = <FieldSymbol>sym;\n                            if (hasFlag(fieldSym.flags, SymbolFlags.ModuleMember)) {\n                                if ((sym.container != this.checker.gloMod) && ((hasFlag(sym.flags, SymbolFlags.Property)) || hasFlag(sym.flags, SymbolFlags.Exported))) {\n                                    if (hasFlag(sym.declModule.modFlags, ModuleFlags.IsDynamic)) {\n                                        this.writeToOutput("exports.");\n                                    }\n                                    else {\n                                        this.writeToOutput(sym.container.name + ".");\n                                    }\n                                }\n                            }\n                            else {\n                                if (sym.isInstanceProperty()) {\n                                    this.emitThis();\n                                    this.writeToOutput(".");\n                                }\n                            }\n                        }\n                        else if (sym.kind() == SymbolKind.Type) {\n                            if (sym.isInstanceProperty()) {\n                                var typeSym = <TypeSymbol>sym;\n                                var type = typeSym.type;\n                                if (type.call && !hasFlag(sym.flags, SymbolFlags.ModuleMember)) {\n                                    this.emitThis();\n                                    this.writeToOutput(".");\n                                }\n                            }\n                            else if ((sym.unitIndex != this.checker.locationInfo.unitIndex) || (!this.declEnclosed(sym.declModule))) {\n                                this.writeToOutput(sym.container.name + ".")\n                            }\n                        }\n                    }\n                    else if (sym.container == this.checker.gloMod &&\n                                hasFlag(sym.flags, SymbolFlags.Exported) &&\n                                !hasFlag(sym.flags, SymbolFlags.Ambient) &&\n                                // check that it\'s a not a member of an ambient module...\n                                !((sym.isType()';
var v27637 = v27638 + ' || sym.isMember()) &&\n                                    sym.declModule &&\n                                    hasFlag(sym.declModule.modFlags, ModuleFlags.Ambient)) &&\n                                this.emitState.container == EmitContainer.Prog &&\n                                sym.declAST.nodeType != NodeType.FuncDecl) {\n                        this.writeToOutput("this.");\n                    }\n                }\n\n                // If it\'s a dynamic module, we need to print the "require" invocation\n                if (sym &&\n                    sym.declAST &&\n                    sym.declAST.nodeType == NodeType.ModuleDeclaration &&\n                    (hasFlag((<ModuleDeclaration>sym.declAST).modFlags, ModuleFlags.IsDynamic))) {\n                    var moduleDecl: ModuleDeclaration = <ModuleDeclaration>sym.declAST;\n\n                    if (moduleGenTarget == ModuleGenTarget.Asynchronous) {\n                        this.writeLineToOutput("__" + this.modAliasId + "__;");\n                    }\n                    else {\n                        var modPath = name.actualText;//(<ModuleDecl>moduleDecl.mod.symbol.declAST).name.actualText;\n                        var isAmbient = moduleDecl.mod.symbol.declAST && hasFlag((<ModuleDeclaration>moduleDecl.mod.symbol.declAST).modFlags, ModuleFlags.Ambient);\n                        modPath = isAmbient ? modPath : this.firstModAlias ? this.firstModAlias : quoteBaseName(modPath);\n                        modPath = isAmbient ? modPath : (!isRelative(stripQuotes(modPath)) ? quoteStr("./" + stripQuotes(modPath)) : modPath);\n                        this.writeToOutput("require(" + modPath + ")");\n                    }\n                }\n                else {\n                    this.writeToOutput(name.actualText);\n                }\n            }\n            this.recordSourceMappingEnd(name);\n            this.emitParensAndCommentsInPlace(name, false);\n        }\n\n        public emitJavascriptStatements(stmts: AST, emitEmptyBod: bool) {\n            if (stmts) {\n                if (stmts.nodeType != NodeType.Block) {\n                    var hasContents = (stmts && (stmts.nodeType != NodeType.List || ((<ASTList>stmts).members.length > 0)));\n                    if (emitEmptyBod || hasContents) {\n                        var hasOnlyBlockStatement = ((stmts.nodeType == NodeType.Block) ||\n                            ((stmts.nodeType == NodeType.List) && ((<ASTList>stmts).members.length == 1) && ((<ASTList>stmts).members[0].nodeType == NodeType.Block)));\n\n                        this.recordSourceMappingStart(stmts);\n                        if (!hasOnlyBlockStatement) {\n                            this.writeLineToOutput(" {");\n                            this.indenter.increaseIndent();\n                        }\n                        this.emitJavascriptList(stmts, null, TokenID.Semicolon, true, false, false);\n                        if (!hasOnlyBlockStatement) {\n                            this.writeLineToOutput("");\n                            this.indenter.decreaseIndent();\n                            this.emitIndent();\n                            this.writeToOutput("}");\n                        }\n                        this.recordSourceMappingEnd(stmts);\n                    }\n                }\n                else {\n                    this.emitJavascript(stmts, TokenID.Semicolon, true);\n                }\n            }\n            else if (emitEmptyBod) {\n                this.writeToOutput("{ }");\n            }\n        }\n\n        public emitBareJavascriptStatements(stmts: AST, emitClassPropertiesAfterSuperCall: bool = false) {\n            // just the statements without enclosing curly braces\n            if (stmts.nodeType != NodeType.Block) {\n                if (stmts.nodeType == NodeType.List) {\n                    var stmtList = <ASTList>stmts;\n                    if ((stmtList.members.length == 2) &&\n                        (stmtList.members[0].nodeType == NodeType.Block) &&\n                        (stmtList.members[1].nodeType == NodeType.EndCode)) {\n                        this.emitJavascript(stmtList.members[0], TokenID.Semicolon, true);\n                        this.writeLineToOutput("");\n                    }\n                    else {\n                        this.emitJavascriptList(stmts, null, TokenID.Semicolon, true, false, emitClassPropertiesAfterSuperCall);\n                    }\n                }\n                else {\n                    this.emitJavascript(stmts, TokenID.Semicolon, true);\n                }\n            }\n            else {\n                this.emitJavascript(stmts, TokenID.Semicolon, true);\n            }\n        }\n\n        public recordSourceMappingNameStart(name: string) {\n            if (this.sourceMapper) {\n                var finalName = name;\n                if (!name) {\n                    finalName = "";\n                } else if (this.sourceMapper.currentNameIndex.length > 0) {\n                    finalName = this.sourceMapper.names[this.source';
var v27636 = v27637 + "Mapper.currentNameIndex.length - 1] + \".\" + name;\n                }\n\n                // We are currently not looking for duplicate but that is possible.\n                this.sourceMapper.names.push(finalName);\n                this.sourceMapper.currentNameIndex.push(this.sourceMapper.names.length - 1);\n            }\n        }\n\n        public recordSourceMappingNameEnd() {\n            if (this.sourceMapper) {\n                this.sourceMapper.currentNameIndex.pop();\n            }\n        }\n\n        public recordSourceMappingStart(ast: ASTSpan) {\n            if (this.sourceMapper && isValidAstNode(ast)) {\n                var lineCol = { line: -1, col: -1 };\n                var sourceMapping = new SourceMapping();\n                sourceMapping.start.emittedColumn = this.emitState.column;\n                sourceMapping.start.emittedLine = this.emitState.line;\n                // REVIEW: check time consumed by this binary search (about two per leaf statement)\n                getSourceLineColFromMap(lineCol, ast.minChar, this.checker.locationInfo.lineMap);\n                sourceMapping.start.sourceColumn = lineCol.col;\n                sourceMapping.start.sourceLine = lineCol.line;\n                getSourceLineColFromMap(lineCol, ast.limChar, this.checker.locationInfo.lineMap);\n                sourceMapping.end.sourceColumn = lineCol.col;\n                sourceMapping.end.sourceLine = lineCol.line;\n                if (this.sourceMapper.currentNameIndex.length > 0) {\n                    sourceMapping.nameIndex = this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length - 1];\n                }\n                // Set parent and child relationship\n                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];\n                siblings.push(sourceMapping);\n                this.sourceMapper.currentMappings.push(sourceMapping.childMappings);\n            }\n        }\n\n        public recordSourceMappingEnd(ast: ASTSpan) {\n            if (this.sourceMapper && isValidAstNode(ast)) {\n                // Pop source mapping childs\n                this.sourceMapper.currentMappings.pop();\n\n                // Get the last source mapping from sibling list = which is the one we are recording end for\n                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];\n                var sourceMapping = siblings[siblings.length - 1];\n\n                sourceMapping.end.emittedColumn = this.emitState.column;\n                sourceMapping.end.emittedLine = this.emitState.line;\n            }\n        }\n\n        public Close() {\n            if (this.sourceMapper != null) {\n                SourceMapper.EmitSourceMapping(this.allSourceMappers);\n            }\n            try {\n                // Closing files could result in exceptions, report them if they occur\n                this.outfile.Close();\n            } catch (ex) {\n                this.errorReporter.emitterError(null, ex.message);\n            }\n        }\n\n        public emitJavascriptList(ast: AST, delimiter: string, tokenId: TokenID, startLine: bool, onlyStatics: bool, emitClassPropertiesAfterSuperCall: bool = false, emitPrologue? = false, requiresExtendsBlock?: bool) {\n            if (ast == null) {\n                return;\n            }\n            else if (ast.nodeType != NodeType.List) {\n                this.emitPrologue(emitPrologue);\n                this.emitJavascript(ast, tokenId, startLine);\n            }\n            else {\n                var list = <ASTList>ast;\n                if (list.members.length == 0) {\n                    return;\n                }\n\n                this.emitParensAndCommentsInPlace(ast, true);\n                var len = list.members.length;\n                for (var i = 0; i < len; i++) {\n                    if (emitPrologue) {\n                        // If the list has Strict mode flags, emit prologue after first statement\n                        // otherwise emit before first statement\n                        if (i == 1 || !hasFlag(list.flags, ASTFlags.StrictMode)) {\n                            this.emitPrologue(requiresExtendsBlock);\n                            emitPrologue = false;\n                        }\n                    }\n\n                    // In some circumstances, class property initializers must be emitted immediately after the 'super' constructor\n                    // call which, in these cases, must be the first statement in the constructor body\n                    if (i == 1 && emitClassPropertiesAfterSuperCall) {\n\n                        // emit any parameter properties first\n                        var constructorDecl = (<ClassDeclaration>this.thisClassNode).constructorDecl;\n\n                        if (constructorDecl && constructorDecl.arguments) {\n                            var argsLen = constructorDecl.arguments.members.length;\n                            for (var iArg = 0; iArg < argsLen; iArg++) {\n                     ";
var v27635 = v27636 + '           var arg = <BoundDecl>constructorDecl.arguments.members[iArg];\n                                if ((arg.varFlags & VarFlags.Property) != VarFlags.None) {\n                                    this.emitIndent();\n                                    this.recordSourceMappingStart(arg);\n                                    this.recordSourceMappingStart(arg.id);\n                                    this.writeToOutput("this." + arg.id.actualText);\n                                    this.recordSourceMappingEnd(arg.id);\n                                    this.writeToOutput(" = ");\n                                    this.recordSourceMappingStart(arg.id);\n                                    this.writeToOutput(arg.id.actualText);\n                                    this.recordSourceMappingEnd(arg.id);\n                                    this.writeLineToOutput(";");\n                                    this.recordSourceMappingEnd(arg);\n                                }\n                            }\n                        }\n\n                        var nProps = (<ASTList>this.thisClassNode.members).members.length;\n\n                        for (var iMember = 0; iMember < nProps; iMember++) {\n                            if ((<ASTList>this.thisClassNode.members).members[iMember].nodeType == NodeType.VarDecl) {\n                                var varDecl = <VarDecl>(<ASTList>this.thisClassNode.members).members[iMember];\n                                if (!hasFlag(varDecl.varFlags, VarFlags.Static) && varDecl.init) {\n                                    this.emitIndent();\n                                    this.emitJavascriptVarDecl(varDecl, TokenID.Tilde);\n                                    this.writeLineToOutput("");\n                                }\n                            }\n                        }\n                    }\n\n                    var emitNode = list.members[i];\n\n                    var isStaticDecl =\n                                (emitNode.nodeType == NodeType.FuncDecl && hasFlag((<FuncDecl>emitNode).fncFlags, FncFlags.Static)) ||\n                                (emitNode.nodeType == NodeType.VarDecl && hasFlag((<VarDecl>emitNode).varFlags, VarFlags.Static))\n\n                    if (onlyStatics ? !isStaticDecl : isStaticDecl) {\n                        continue;\n                    }\n                    this.emitJavascript(emitNode, tokenId, startLine);\n\n                    if (delimiter && (i < (len - 1))) {\n                        if (startLine) {\n                            this.writeLineToOutput(delimiter);\n                        }\n                        else {\n                            this.writeToOutput(delimiter);\n                        }\n                    }\n                    else if (startLine &&\n                             (emitNode.nodeType != NodeType.ModuleDeclaration) &&\n                             (emitNode.nodeType != NodeType.InterfaceDeclaration) &&\n                             (!((emitNode.nodeType == NodeType.VarDecl) &&\n                                ((((<VarDecl>emitNode).varFlags) & VarFlags.Ambient) == VarFlags.Ambient) &&\n                                (((<VarDecl>emitNode).init) == null)) && this.varListCount() >= 0) &&\n                             (emitNode.nodeType != NodeType.Block || (<Block>emitNode).isStatementBlock) &&\n                             (emitNode.nodeType != NodeType.EndCode) &&\n                             (emitNode.nodeType != NodeType.FuncDecl)) {\n                        this.writeLineToOutput("");\n                    }\n                }\n                this.emitParensAndCommentsInPlace(ast, false);\n            }\n        }\n\n        // tokenId is the id the preceding token\n        public emitJavascript(ast: AST, tokenId: TokenID, startLine: bool) {\n            if (ast == null) {\n                return;\n            }\n\n            // REVIEW: simplify rules for indenting\n            if (startLine && (this.indenter.indentAmt > 0) && (ast.nodeType != NodeType.List) &&\n                (ast.nodeType != NodeType.Block)) {\n                if ((ast.nodeType != NodeType.InterfaceDeclaration) &&\n                    (!((ast.nodeType == NodeType.VarDecl) &&\n                       ((((<VarDecl>ast).varFlags) & VarFlags.Ambient) == VarFlags.Ambient) &&\n                       (((<VarDecl>ast).init) == null)) && this.varListCount() >= 0) &&\n                    (ast.nodeType != NodeType.EndCode) &&\n                    ((ast.nodeType != NodeType.FuncDecl) ||\n                     (this.emitState.container != EmitContainer.Constructor))) {\n                    this.emitIndent();\n                }\n            }\n\n            ast.emit(this, tokenId, startLine);\n\n            if ((tokenId == TokenID.Semicolon) && (ast.nodeType < NodeType.GeneralNode)) {\n                this.writeToOutput(";");\n            }\n        }\n\n        public emitPropertyAccessor(funcDecl: FuncDecl, className: string, isProto: bool) {\n            if (!(<FieldSymbol>funcDecl.accessorSymbol).h';
var v27634 = v27635 + 'asBeenEmitted) {\n                var accessorSymbol = <FieldSymbol>funcDecl.accessorSymbol;\n                this.emitIndent();\n                this.recordSourceMappingStart(funcDecl);\n                this.writeLineToOutput("Object.defineProperty(" + className + (isProto ? ".prototype, \\"" : ", \\"") + funcDecl.name.actualText + "\\"" + ", {");\n                this.indenter.increaseIndent();\n\n                if (accessorSymbol.getter) {\n                    var getter: FuncDecl = <FuncDecl>accessorSymbol.getter.declAST;\n\n                    this.emitIndent();\n                    this.recordSourceMappingStart(getter);\n                    this.writeToOutput("get: ");\n                    this.emitInnerFunction(getter, false, isProto, null, Emitter.shouldCaptureThis(getter), null);\n                    this.writeLineToOutput(",");\n                }\n\n                if (accessorSymbol.setter) {\n                    var setter: FuncDecl = <FuncDecl>accessorSymbol.setter.declAST;\n\n                    this.emitIndent();\n                    this.recordSourceMappingStart(setter);\n                    this.writeToOutput("set: ");\n                    this.emitInnerFunction(setter, false, isProto, null, Emitter.shouldCaptureThis(setter), null);\n                    this.writeLineToOutput(",");\n                }\n\n                this.emitIndent();\n                this.writeLineToOutput("enumerable: true,");\n                this.emitIndent();\n                this.writeLineToOutput("configurable: true");\n                this.indenter.decreaseIndent();\n                this.emitIndent();\n                this.writeLineToOutput("});");\n                this.recordSourceMappingEnd(funcDecl);\n\n                accessorSymbol.hasBeenEmitted = true;\n            }\n        }\n\n        public emitPrototypeMember(member: AST, className: string) {\n            if (member.nodeType == NodeType.FuncDecl) {\n                var funcDecl = <FuncDecl>member;\n                if (funcDecl.isAccessor()) {\n                    this.emitPropertyAccessor(funcDecl, className, true);\n                }\n                else {\n                    this.emitIndent();\n                    this.recordSourceMappingStart(funcDecl);\n                    this.writeToOutput(className + ".prototype." + funcDecl.getNameText() + " = ");\n                    this.emitInnerFunction(funcDecl, false, true, null, Emitter.shouldCaptureThis(funcDecl), null);\n                    this.writeLineToOutput(";");\n                }\n            }\n            else if (member.nodeType == NodeType.VarDecl) {\n                var varDecl = <VarDecl>member;\n\n                if (varDecl.init) {\n                    this.emitIndent();\n                    this.recordSourceMappingStart(varDecl);\n                    this.recordSourceMappingStart(varDecl.id);\n                    this.writeToOutput(className + ".prototype." + varDecl.id.actualText);\n                    this.recordSourceMappingEnd(varDecl.id);\n                    this.writeToOutput(" = ");\n                    this.emitJavascript(varDecl.init, TokenID.Equals, false);\n                    this.recordSourceMappingEnd(varDecl);\n                    this.writeLineToOutput(";");\n                }\n            }\n        }\n\n        public emitAddBaseMethods(className: string, base: Type, classDecl: TypeDeclaration): void {\n            if (base.members) {\n                var baseSymbol = base.symbol;\n                var baseName = baseSymbol.name;\n                if (baseSymbol.declModule != classDecl.type.symbol.declModule) {\n                    baseName = baseSymbol.fullName();\n                }\n                base.members.allMembers.map(function(key, s, c) {\n                    var sym = <Symbol>s;\n                    if ((sym.kind() == SymbolKind.Type) && (<TypeSymbol>sym).type.call) {\n                        this.recordSourceMappingStart(sym.declAST);\n                        this.writeLineToOutput(className + ".prototype." + sym.name + " = " +\n                                          baseName + ".prototype." + sym.name + ";");\n                        this.recordSourceMappingEnd(sym.declAST);\n                    }\n                }, null);\n            }\n            if (base.extendsList) {\n                for (var i = 0, len = base.extendsList.length; i < len; i++) {\n                    this.emitAddBaseMethods(className, base.extendsList[i], classDecl);\n                }\n            }\n        }\n\n        public emitJavascriptClass(classDecl: ClassDeclaration) {\n            if (!hasFlag(classDecl.varFlags, VarFlags.Ambient)) {\n                var svClassNode = this.thisClassNode;\n                var i = 0;\n                this.thisClassNode = classDecl;\n                var className = classDecl.name.actualText;\n                this.emitParensAndCommentsInPlace(classDecl, true);\n                var temp = this.setContainer(EmitContainer.Class);\n\n                this.recordSourceMappingStart(classDecl);\n                if (hasFlag(classDecl.varFlags, VarF';
var v27633 = v27634 + 'lags.Exported) && classDecl.type.symbol.container == this.checker.gloMod) {\n                    this.writeToOutput("this." + className);\n                }\n                else {\n                    this.writeToOutput("var " + className);\n                }\n\n                //if (hasFlag(classDecl.varFlags, VarFlags.Exported) && (temp == EmitContainer.Module || temp == EmitContainer.DynamicModule)) {\n                //    var modName = temp == EmitContainer.Module ? this.moduleName : "exports";\n                //    this.writeToOutput(" = " + modName + "." + className);\n                //}\n\n                var hasBaseClass = classDecl.extendsList && classDecl.extendsList.members.length;\n                var baseNameDecl: AST = null;\n                var baseName: AST = null;\n\n                if (hasBaseClass) {\n                    this.writeLineToOutput(" = (function (_super) {");\n                } else {\n                    this.writeLineToOutput(" = (function () {");\n                }\n\n                this.recordSourceMappingNameStart(className);\n                this.indenter.increaseIndent();\n\n                if (hasBaseClass) {\n                    baseNameDecl = classDecl.extendsList.members[0];\n                    baseName = baseNameDecl.nodeType == NodeType.Call ? (<CallExpression>baseNameDecl).target : baseNameDecl;\n                    this.emitIndent();\n                    this.writeLineToOutput("__extends(" + className + ", _super);");\n                }\n\n                this.emitIndent();\n\n                var constrDecl = classDecl.constructorDecl;\n\n                // output constructor\n                if (constrDecl) {\n                    // declared constructor\n                    this.emitJavascript(classDecl.constructorDecl, TokenID.OpenParen, false);\n\n                }\n                else {\n                    var wroteProps = 0;\n\n                    this.recordSourceMappingStart(classDecl);\n                    // default constructor\n                    this.indenter.increaseIndent();\n                    this.writeToOutput("function " + classDecl.name.actualText + "() {");\n                    this.recordSourceMappingNameStart("constructor");\n                    if (hasBaseClass) {\n                        this.writeLineToOutput("");\n                        this.emitIndent();\n                        this.writeLineToOutput("_super.apply(this, arguments);");\n                        wroteProps++;\n                    }\n\n                    if (classDecl.varFlags & VarFlags.MustCaptureThis) {\n                        this.writeCaptureThisStatement(classDecl);\n                    }\n\n                    var members = (<ASTList>this.thisClassNode.members).members\n\n                    // output initialized properties\n                    for (var i = 0; i < members.length; i++) {\n                        if (members[i].nodeType == NodeType.VarDecl) {\n                            var varDecl = <VarDecl>members[i];\n                            if (!hasFlag(varDecl.varFlags, VarFlags.Static) && varDecl.init) {\n                                this.writeLineToOutput("");\n                                this.emitIndent();\n                                this.emitJavascriptVarDecl(varDecl, TokenID.Tilde);\n                                wroteProps++;\n                            }\n                        }\n                    }\n                    if (wroteProps) {\n                        this.writeLineToOutput("");\n                        this.indenter.decreaseIndent();\n                        this.emitIndent();\n                        this.writeLineToOutput("}");\n                    }\n                    else {\n                        this.writeLineToOutput(" }");\n                        this.indenter.decreaseIndent();\n                    }\n                    this.recordSourceMappingNameEnd();\n                    this.recordSourceMappingEnd(classDecl);\n                }\n\n                var membersLen = classDecl.members.members.length;\n                for (var j = 0; j < membersLen; j++) {\n\n                    var memberDecl: AST = classDecl.members.members[j];\n\n                    if (memberDecl.nodeType == NodeType.FuncDecl) {\n                        var fn = <FuncDecl>memberDecl;\n\n                        if (hasFlag(fn.fncFlags, FncFlags.Method) && !fn.isSignature()) {\n                            if (!hasFlag(fn.fncFlags, FncFlags.Static)) {\n                                this.emitPrototypeMember(fn, className);\n                            }\n                            else { // static functions\n                                if (fn.isAccessor()) {\n                                    this.emitPropertyAccessor(fn, this.thisClassNode.name.actualText, false);\n                                }\n                                else {\n                                    this.emitIndent();\n                                    this.recordSourceMappingStart(fn)\n                                    this.writeToOutput(classD';
var v27632 = v27633 + 'ecl.name.actualText + "." + fn.name.actualText + " = ");\n                                    this.emitInnerFunction(fn, (fn.name && !fn.name.isMissing()), true,\n                                            null, Emitter.shouldCaptureThis(fn), null);\n                                    this.writeLineToOutput(";");\n                                }\n                            }\n                        }\n                    }\n                    else if (memberDecl.nodeType == NodeType.VarDecl) {\n                        var varDecl = <VarDecl>memberDecl;\n                        if (hasFlag(varDecl.varFlags, VarFlags.Static)) {\n\n                            if (varDecl.init) {\n                                // EMITREVIEW\n                                this.emitIndent();\n                                this.recordSourceMappingStart(varDecl);\n                                this.writeToOutput(classDecl.name.actualText + "." + varDecl.id.actualText + " = ");\n                                this.emitJavascript(varDecl.init, TokenID.Equals, false);\n                                // EMITREVIEW\n\n                                this.writeLineToOutput(";");\n                                this.recordSourceMappingEnd(varDecl);\n                            }\n                        }\n                    }\n                    else {\n                        throw Error("We want to catch this");\n                    }\n                }\n\n                this.emitIndent();\n                this.recordSourceMappingStart(classDecl.endingToken);\n                this.writeLineToOutput("return " + className + ";");\n                this.recordSourceMappingEnd(classDecl.endingToken);\n                this.indenter.decreaseIndent();\n                this.emitIndent();\n                this.recordSourceMappingStart(classDecl.endingToken);\n                this.writeToOutput("}");\n                this.recordSourceMappingNameEnd();\n                this.recordSourceMappingEnd(classDecl.endingToken);\n                this.recordSourceMappingStart(classDecl);\n                this.writeToOutput(")(");\n                if (hasBaseClass)\n                    this.emitJavascript(baseName, TokenID.Tilde, false);\n                this.writeToOutput(");");\n                this.recordSourceMappingEnd(classDecl);\n\n                if ((temp == EmitContainer.Module || temp == EmitContainer.DynamicModule) && hasFlag(classDecl.varFlags, VarFlags.Exported)) {\n                    this.writeLineToOutput("");\n                    this.emitIndent();\n                    var modName = temp == EmitContainer.Module ? this.moduleName : "exports";\n                    this.recordSourceMappingStart(classDecl);\n                    this.writeToOutput(modName + "." + className + " = " + className + ";");\n                    this.recordSourceMappingEnd(classDecl);\n                }\n\n                this.emitIndent();\n                this.recordSourceMappingEnd(classDecl);\n                this.emitParensAndCommentsInPlace(classDecl, false);\n                this.setContainer(temp);\n                this.thisClassNode = svClassNode;\n            }\n        }\n\n        public emitPrologue(reqInherits: bool) {\n            if (!this.prologueEmitted) {\n                if (reqInherits) {\n                    this.prologueEmitted = true;\n                    this.writeLineToOutput("var __extends = this.__extends || function (d, b) {");\n                    this.writeLineToOutput("    function __() { this.constructor = d; }");\n                    this.writeLineToOutput("    __.prototype = b.prototype;");\n                    this.writeLineToOutput("    d.prototype = new __();");\n                    this.writeLineToOutput("};");\n                }\n                if (this.checker.mustCaptureGlobalThis) {\n                    this.prologueEmitted = true;\n                    this.writeLineToOutput(this.captureThisStmtString);\n                }\n            }\n        }\n\n        public emitSuperReference() {\n            this.writeToOutput("_super.prototype");\n        }\n\n        public emitSuperCall(callEx: CallExpression): bool {\n            if (callEx.target.nodeType == NodeType.Dot) {\n                var dotNode = <BinaryExpression>callEx.target;\n                if (dotNode.operand1.nodeType == NodeType.Super) {\n                    this.emitJavascript(dotNode, TokenID.OpenParen, false);\n                    this.writeToOutput(".call(");\n                    this.emitThis();\n                    if (callEx.arguments && callEx.arguments.members.length > 0) {\n                        this.writeToOutput(", ");\n                        this.emitJavascriptList(callEx.arguments, ", ", TokenID.Comma, false, false, false);\n                    }\n                    this.writeToOutput(")");\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        public emitThis() {\n            if (this.thisFnc && !this.thisFnc.isMethod() && (!this.thisFnc.isConstructor)) {\n          ';
var v27631 = v27632 + '      this.writeToOutput("_this");\n            }\n            else {\n                this.writeToOutput("this");\n            }\n        }\n\n        private static shouldCaptureThis(func: FuncDecl): bool {\n            // Super calls use \'this\' reference. If super call is in a lambda, \'this\' value needs to be captured in the parent.\n            return func.hasSelfReference() || func.hasSuperReferenceInFatArrowFunction();\n        }\n\n        private createFile(fileName: string, useUTF8: bool): ITextWriter {\n            try {\n                return this.emitOptions.ioHost.createFile(fileName, useUTF8);\n            } catch (ex) {\n                this.errorReporter.emitterError(null, ex.message);\n            }\n        }\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export interface ILineCol {\n        line: number;\n        col: number;\n    }\n\n    export class ErrorReporter {\n        public parser: Parser = null;\n        public checker: TypeChecker = null;\n        public lineCol = { line: 0, col: 0 };\n        public emitAsComments = true;\n        public hasErrors = false;\n        public pushToErrorSink = false;\n        public errorSink: string[] = [];\n\n        constructor (public outfile: ITextWriter) { }\n\n        public getCapturedErrors() { return this.errorSink; }\n        public freeCapturedErrors() { this.errorSink = []; }\n        public captureError(emsg: string) { this.errorSink[this.errorSink.length] = emsg; }\n\n        public setErrOut(outerr) {\n            this.outfile = outerr;\n            this.emitAsComments = false;\n        }\n\n        public emitPrefix() {\n            if (this.emitAsComments) {\n                this.outfile.Write("// ");\n            }\n            this.outfile.Write(this.checker.locationInfo.filename + "(" + this.lineCol.line + "," + this.lineCol.col + "): ");\n        }\n\n        public writePrefix(ast: AST): void {\n            if (ast) {\n                this.setError(ast);\n            }\n            else {\n                this.lineCol.line = 0;\n                this.lineCol.col = 0;\n            }\n            this.emitPrefix();\n        }\n\n        public writePrefixFromSym(symbol: Symbol): void {\n            if (symbol && this.checker.locationInfo.lineMap) {\n                getSourceLineColFromMap(this.lineCol, symbol.location,\n                                        this.checker.locationInfo.lineMap);\n            }\n            else {\n                this.lineCol.line = -1;\n                this.lineCol.col = -1;\n            }\n            this.emitPrefix();\n        }\n\n        public setError(ast: AST) {\n            if (ast) {\n                ast.flags |= ASTFlags.Error;\n                if (this.checker.locationInfo.lineMap) {\n                    getSourceLineColFromMap(this.lineCol, ast.minChar, this.checker.locationInfo.lineMap);\n                }\n            }\n        }\n\n        public reportError(ast: AST, message: string) {\n            if (this.pushToErrorSink) {\n                this.captureError(message);\n                return;\n            }\n\n            this.hasErrors = true;\n            if (ast && this.parser.errorRecovery && this.parser.errorCallback) {\n                var len = (ast.limChar - ast.minChar);\n                this.parser.errorCallback(ast.minChar, len, message, this.checker.locationInfo.unitIndex);\n            }\n            else {\n                this.writePrefix(ast);\n                this.outfile.WriteLine(message); // Right after the semi-colon\n            }\n        }\n\n        public reportErrorFromSym(symbol: Symbol, message: string) {\n            if (this.pushToErrorSink) {\n                this.captureError(message);\n                return;\n            }\n\n            this.hasErrors = true;\n            if (this.parser.errorRecovery && this.parser.errorCallback) {\n                this.parser.errorCallback(symbol.location, symbol.length, message, this.checker.locationInfo.unitIndex);\n            }\n            else {\n                this.writePrefixFromSym(symbol);\n                this.outfile.WriteLine(message);\n            }\n        }\n\n        public emitterError(ast: AST, message: string) {\n            this.reportError(ast, message);\n            // Emitter errors are not recoverable, stop immediately\n            throw Error("EmitError");\n        }\n\n        public duplicateIdentifier(ast: AST, name: string) {\n            this.reportError(';
var v27630 = v27631 + 'ast, "Duplicate identifier \'" + name + "\'");\n        }\n\n        public showRef(ast: AST, text: string, symbol: Symbol) {\n            var defLineCol = { line: -1, col: -1 };\n            // TODO: multiple def locations\n            this.parser.getSourceLineCol(defLineCol, symbol.location);\n            this.reportError(ast, "symbol " + text + " defined at (" + defLineCol.line + "," +\n                              defLineCol.col + ")");\n        }\n\n        public unresolvedSymbol(ast: AST, name: string) {\n            this.reportError(ast, "The name \'" + name + "\' does not exist in the current scope");\n        }\n\n        public symbolDoesNotReferToAValue(ast: AST, name: string): void {\n            this.reportError(ast, "The name \'" + name + "\' does not refer to a value");\n        }\n\n        public styleError(ast: AST, msg: string): void {\n            var bkThrow = this.pushToErrorSink;\n            this.pushToErrorSink = false;\n            this.reportError(ast, "STYLE: " + msg);\n            this.pushToErrorSink = bkThrow;\n        }\n\n        public simpleError(ast: AST, msg: string): void {\n            this.reportError(ast, msg);\n        }\n\n        public simpleErrorFromSym(sym: Symbol, msg: string): void {\n            this.reportErrorFromSym(sym, msg);\n        }\n\n        public invalidSuperReference(ast: AST) {\n            this.simpleError(ast, "Keyword \'super\' can only be used inside a class instance method");\n        }\n\n        public valueCannotBeModified(ast: AST) {\n            this.simpleError(ast, "The left-hand side of an assignment expression must be a variable, property or indexer");\n        }\n\n        public invalidCall(ast: CallExpression, nodeType: number, scope: SymbolScope): void {\n            var targetType = ast.target.type;\n            var typeName = targetType.getScopedTypeName(scope);\n            if (targetType.construct && (nodeType == NodeType.Call)) {\n                this.reportError(ast, "Value of type \'" + typeName + "\' is not callable.  Did you mean to include \'new\'?");\n            } else {\n                var catString = (nodeType == NodeType.Call) ? "callable" : "newable";\n\n                this.reportError(ast, "Value of type \'" + typeName + "\' is not " + catString);\n            }\n        }\n\n        public indexLHS(ast: BinaryExpression, scope: SymbolScope): void {\n            var targetType = ast.operand1.type.getScopedTypeName(scope);\n            var indexType = ast.operand2.type.getScopedTypeName(scope);\n            this.simpleError(ast, "Value of type \'" + targetType + "\' is not indexable by type \'" + indexType + "\'");\n        }\n\n        public incompatibleTypes(ast: AST, t1: Type, t2: Type, op: string, scope: SymbolScope, comparisonInfo?:TypeComparisonInfo) {\n            if (!t1) {\n                t1 = this.checker.anyType;\n            }\n            if (!t2) {\n                t2 = this.checker.anyType;\n            }\n\n            var reason = comparisonInfo ? comparisonInfo.message : "";\n            if (op) {\n                this.reportError(ast, "Operator \'" + op + "\' cannot be applied to types \'" + t1.getScopedTypeName(scope) +\n                                  "\' and \'" + t2.getScopedTypeName(scope) + "\'" + (reason ? ": " + reason : ""));\n            }\n            else {\n                this.reportError(ast, "Cannot convert \'" + t1.getScopedTypeName(scope) +\n                                  "\' to \'" + t2.getScopedTypeName(scope) + "\'" + (reason ? ": " + reason : ""));\n            }\n        }\n\n        public expectedClassOrInterface(ast: AST): void {\n            this.simpleError(ast, "Expected var, class, interface, or module");\n        }\n\n        public unaryOperatorTypeError(ast: AST, op: string, type: Type) {\n            this.reportError(ast, "Operator \'" + op + "\' cannot be applied to type \'" + type.getTypeName() + "\'");\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export function hasFlag(val: number, flag: number) {\n        return (val & flag) != 0;\n    }\n\n    export enum ErrorRecoverySet {\n        None = 0,\n        Comma = 1, // Comma\n        SColon = 1 << 1, // SColon\n        Asg = 1 << 2, // Asg\n        BinOp = 1 << 3, // Lsh, Rsh, Rs2, Le, Ge, INSTANCEOF, EQ, NE, Eqv, NEqv, LogAnd, LogOr, AsgMul, AsgDiv\n        // AsgMod, AsgAdd, AsgSub, AsgLsh, AsgRsh, AsgRs2, AsgAnd, AsgXor, AsgOr, QMark, Mult, Div, \n        // Pct, GT, LT, ';
var v27629 = v27630 + "And, Xor, Or\n        RBrack = 1 << 4, // RBrack\n        RCurly = 1 << 5, // RCurly\n        RParen = 1 << 6, // RParen\n        Dot = 1 << 7, // Dot\n        Colon = 1 << 8, // Colon\n        PrimType = 1 << 9, // number, string, bool\n        AddOp = 1 << 10, // Add, Sub\n        LCurly = 1 << 11, // LCurly\n        PreOp = 1 << 12, // Tilde, Bang, Inc, Dec\n        RegExp = 1 << 13, // RegExp\n        LParen = 1 << 14, // LParen\n        LBrack = 1 << 15, // LBrack\n        Scope = 1 << 16, // Scope\n        In = 1 << 17, // IN\n        SCase = 1 << 18, // CASE, DEFAULT\n        Else = 1 << 19, // ELSE\n        Catch = 1 << 20, // CATCH, FINALLY\n        Var = 1 << 21, // \n        Stmt = 1 << 22, // BREAK, RETURN, THROW, DEBUGGER, FOR, SWITCH, DO, IF, TRY, WITH\n        While = 1 << 23, // WHILE\n        ID = 1 << 24, // ID\n        Prefix = 1 << 25, // VOID, DELETE, TYPEOF, AWAIT\n        Literal = 1 << 26, // IntCon, FltCon, StrCon\n        RLit = 1 << 27, // THIS, TRUE, FALSE, NULL\n        Func = 1 << 28, // FUNCTION\n        EOF = 1 << 29, // EOF\n\n        // REVIEW: Name this something clearer.\n        TypeScriptS = 1 << 30, // PROPERTY, PRIVATE, STATIC, INTERFACE, CLASS, MODULE, EXPORT, IMPORT\n        ExprStart = SColon | AddOp | LCurly | PreOp | RegExp | LParen | LBrack | ID | Prefix | RLit | Func | Literal,\n        StmtStart = ExprStart | SColon | Var | Stmt | While | TypeScriptS,\n        Postfix = Dot | LParen | LBrack,\n    }\n\n    export enum AllowedElements {\n        None = 0,\n        ModuleDeclarations = 1 << 2,\n        ClassDeclarations = 1 << 3,\n        InterfaceDeclarations = 1 << 4,\n        AmbientDeclarations = 1 << 10,\n        Properties = 1 << 11,\n\n        Global = ModuleDeclarations | ClassDeclarations | InterfaceDeclarations | AmbientDeclarations,\n        QuickParse = Global | Properties,\n    }\n\n    export enum Modifiers {\n        None = 0,\n        Private = 1,\n        Public = 1 << 1,\n        Readonly = 1 << 2,\n        Ambient = 1 << 3,\n        Exported = 1 << 4,\n        Getter = 1 << 5,\n        Setter = 1 << 6,\n        Static = 1 << 7,\n    }\n\n    export enum ASTFlags {\n        None = 0,\n        ExplicitSemicolon = 1, // statment terminated by an explicit semicolon\n        AutomaticSemicolon = 1 << 1, // statment terminated by an automatic semicolon\n        Writeable = 1 << 2,  // node is lhs that can be modified\n        Error = 1 << 3, // node has an error\n        DotLHSPartial = 1 << 4, // node is the lhs of an incomplete dot expr at cursor\n        DotLHS = 1 << 5, // node is the lhs of a dot expr\n        IsStatement = 1 << 6, // node is a statement\n        StrictMode = 1 << 7, // node is in the strict mode environment\n        PossibleOptionalParameter = 1 << 8,\n        ClassBaseConstructorCall = 1 << 9,\n        OptionalName = 1 << 10,\n        // REVIEW: This flag is to mark lambda nodes to note that the LParen of an expression has already been matched in the lambda header.\n        //         The flag is used to communicate this piece of information to the calling parseTerm, which intern will remove it.\n        //         Once we have a better way to associate information with nodes, this flag should not be used.\n        SkipNextRParen = 1 << 11, \n    }\n\n    export enum DeclFlags {\n        None = 0,\n        Exported = 1,\n        Private = 1 << 1,\n        Public = 1 << 2,\n        Ambient = 1 << 3,\n        Static = 1 << 4,\n        LocalStatic = 1 << 5,\n        GetAccessor = 1 << 6,\n        SetAccessor = 1 << 7,\n    }\n\n    export enum ModuleFlags {\n        None = 0,\n        Exported = 1,\n        Private = 1 << 1,\n        Public = 1 << 2,\n        Ambient = 1 << 3,\n        Static = 1 << 4,\n        LocalStatic = 1 << 5,\n        GetAccessor = 1 << 6,\n        SetAccessor = 1 << 7,\n        IsEnum = 1 << 8,\n        ShouldEmitModuleDecl = 1 << 9,\n        IsWholeFile = 1 << 10,\n        IsDynamic = 1 << 11,\n        MustCaptureThis = 1 << 12,\n    }\n\n    export enum SymbolFlags {\n        None = 0,\n        Exported = 1,\n        Private = 1 << 1,\n        Public = 1 << 2,\n        Ambient = 1 << 3,\n        Static = 1 << 4,\n        LocalStatic = 1 << 5,\n        GetAccessor = 1 << 6,\n        SetAccessor = 1 << 7,\n        Property = 1 << 8,\n        Readonly = 1 << 9,\n        ModuleMember = 1 << 10,\n        InterfaceMember = 1 << 11,\n        ClassMember = 1 << 12,\n        BuiltIn = 1 << 13,\n        TypeSetDuringScopeAssignment = 1 << 14,\n        Constant = 1 << 15,\n        Optional = 1 << 16,\n        RecursivelyReferenced = 1 << 17,\n        Bound = 1 << 18,\n        CompilerGenerated = 1 << 19,\n    }\n\n    export enum VarFlags {\n        None = 0,\n        Exported = 1,\n        Private = 1 << 1,\n        Public = 1 << 2,\n        Ambient = 1 << 3,\n        Static = 1 << 4,\n        LocalStatic = 1 << 5,\n        GetAccessor = 1 << 6,\n        SetAccessor = 1 << 7,\n        AutoInit = 1 << 8,\n        Property = 1 << 9,\n        Readonly = 1 << 10,\n        Class = 1 << 11,\n        ClassProperty = 1 << 12,\n        ClassBodyProperty = 1 << 13,";
var v27628 = v27629 + '\n        ClassConstructorProperty = 1 << 14,\n        ClassSuperMustBeFirstCallInConstructor = 1 << 15,\n        Constant = 1 << 16,\n        MustCaptureThis = 1 << 17,\n    }\n\n    export enum FncFlags {\n        None = 0,\n        Exported = 1,\n        Private = 1 << 1,\n        Public = 1 << 2,\n        Ambient = 1 << 3,\n        Static = 1 << 4,\n        LocalStatic = 1 << 5,\n        GetAccessor = 1 << 6,\n        SetAccessor = 1 << 7,\n        Definition = 1 << 8,\n        Signature = 1 << 9,\n        Method = 1 << 10,\n        HasReturnExpression = 1 << 11,\n        CallMember = 1 << 12,\n        ConstructMember = 1 << 13,\n        HasSelfReference = 1 << 14,\n        IsFatArrowFunction = 1 << 15,\n        IndexerMember = 1 << 16,\n        IsFunctionExpression = 1 << 17,\n        ClassMethod = 1 << 18,\n        ClassPropertyMethodExported = 1 << 19,\n        HasSuperReferenceInFatArrowFunction = 1 << 20,\n        IsPropertyBound = 1 << 21,\n    }\n\n    export enum SignatureFlags {\n        None = 0,\n        IsIndexer = 1,\n        IsStringIndexer = 1 << 1,\n        IsNumberIndexer = 1 << 2,\n    }\n\n    export function ToDeclFlags(fncFlags: FncFlags) : DeclFlags;\n    export function ToDeclFlags(varFlags: VarFlags) : DeclFlags;\n    export function ToDeclFlags(symFlags: SymbolFlags): DeclFlags;\n    export function ToDeclFlags(moduleFlags: ModuleFlags): DeclFlags;\n    export function ToDeclFlags(fncOrVarOrSymbolOrModuleFlags: any) {\n        return <DeclFlags>fncOrVarOrSymbolOrModuleFlags;\n    }\n\n    export enum TypeFlags {\n        None = 0,\n        HasImplementation = 1,\n        HasSelfReference = 1 << 1,\n        MergeResult = 1 << 2,\n        IsEnum = 1 << 3,\n        BuildingName = 1 << 4,\n        HasBaseType = 1 << 5,\n        HasBaseTypeOfObject = 1 << 6,\n        IsClass = 1 << 7,\n    }\n\n    export enum TypeRelationshipFlags {\n        SuccessfulComparison = 0,\n        SourceIsNullTargetIsVoidOrUndefined = 1,\n        RequiredPropertyIsMissing = 1 << 1,\n        IncompatibleSignatures = 1 << 2,\n        SourceSignatureHasTooManyParameters = 3,\n        IncompatibleReturnTypes = 1 << 4,\n        IncompatiblePropertyTypes = 1 << 5,\n        IncompatibleParameterTypes = 1 << 6,\n    }\n\n    export enum CodeGenTarget {\n        ES3 = 0,\n        ES5 = 1,\n    }\n\n    export enum ModuleGenTarget {\n        Synchronous = 0,\n        Asynchronous = 1,\n        Local = 1 << 1,\n    }\n\n    // Compiler defaults to generating ES5-compliant code for\n    //  - getters and setters\n    export var codeGenTarget: CodeGenTarget = CodeGenTarget.ES3;\n\n    export var moduleGenTarget: ModuleGenTarget = ModuleGenTarget.Synchronous;\n\n    export var optimizeModuleCodeGen = true;\n\n    export function flagsToString(e, flags: number): string {\n        var builder = "";\n        for (var i = 1; i < (1 << 31) ; i = i << 1) {\n            if ((flags & i) != 0) {\n                for (var k in e) {\n                    if (e[k] == i) {\n                        if (builder.length > 0) {\n                            builder += "|";\n                        }\n                        builder += k;\n                        break;\n                    }\n                }\n            }\n        }\n        return builder;\n    }\n\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export class BlockIntrinsics {\n        public prototype = undefined;\n        public toString = undefined;\n        public toLocaleString = undefined;\n        public valueOf = undefined;\n        public hasOwnProperty = undefined;\n        public propertyIsEnumerable = undefined;\n        public isPrototypeOf = undefined;\n\n        constructor () {\n            // initialize the \'constructor\' field\n            this["constructor"] = undefined;\n        }\n    }\n\n    export interface IHashTable {\n        getAllKeys(): string[];\n        add(key: string, data): bool;\n        addOrUpdate(key: string, data): bool;\n        map(fn: (k: string, v, c) => void , context): void;\n        every(fn: (k: string, v, c) => bool, context): bool;\n        some(fn: (k: string, v, c) => bool, context): bool;\n        count(): number;\n        lookup(key: string): any;\n    }\n\n    export class StringHashTable implements IHashTable {\n        public itemCount = 0;\n        public table = <any>(<any> new BlockIntrinsics());\n\n        public getAllKeys(): string[]{\n            var result: string[] = [];\n            for (var k in this.table) {\n ';
var v27627 = v27628 + "               if (this.table[k] != undefined) {\n                    result[result.length] = k;\n                }\n            }\n            return result;\n        }\n\n        public add(key: string, data): bool {\n            if (this.table[key] != undefined) {\n                return false;\n            }\n            this.table[key] = data;\n            this.itemCount++;\n            return true;\n        }\n\n        public addOrUpdate(key: string, data): bool {\n            if (this.table[key] != undefined) {\n                this.table[key] = data;\n                return false;\n            }\n            this.table[key] = data;\n            this.itemCount++;\n            return true;\n        }\n\n        public map(fn: (k: string, v, c) => void , context) {\n            for (var k in this.table) {\n                var data = this.table[k];\n                if (data != undefined) {\n                    fn(k, this.table[k], context);\n                }\n            }\n        }\n\n        public every(fn: (k: string, v, c) => bool, context) {\n            for (var k in this.table) {\n                var data = this.table[k];\n                if (data != undefined) {\n                    if (!fn(k, this.table[k], context)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n\n        public some(fn: (k: string, v, c) => bool, context) {\n            for (var k in this.table) {\n                var data = this.table[k];\n                if (data != undefined) {\n                    if (fn(k, this.table[k], context)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        public count(): number { return this.itemCount; }\n\n        public lookup(key: string) {\n            var data = this.table[key];\n            if (data != undefined) {\n                return data;\n            }\n            else {\n                return (null);\n            }\n        }\n    }\n\n    // The resident table is expected to reference the same table object, whereas the \n    // transientTable may reference different objects over time\n    // REVIEW:  WARNING:  For performance reasons, neither the primary nor secondary table may be null\n    export class DualStringHashTable implements IHashTable {\n\n        public insertPrimary = true;\n\n        constructor (public primaryTable: IHashTable,\n                                        public secondaryTable: IHashTable) { }\n\n        public getAllKeys(): string[]{\n            return this.primaryTable.getAllKeys().concat(this.secondaryTable.getAllKeys());\n        }\n\n        public add(key: string, data): bool {\n            if (this.insertPrimary) {\n                return this.primaryTable.add(key, data);\n            }\n            else {\n                return this.secondaryTable.add(key, data);\n            }\n        }\n\n        public addOrUpdate(key: string, data): bool {\n            if (this.insertPrimary) {\n                return this.primaryTable.addOrUpdate(key, data);\n            }\n            else {\n                return this.secondaryTable.addOrUpdate(key, data);\n            }\n        }\n\n        public map(fn: (k: string, v, c) => void , context) {\n            this.primaryTable.map(fn, context);\n            this.secondaryTable.map(fn, context);\n        }\n\n        public every(fn: (k: string, v, c) => bool, context) {\n            return this.primaryTable.every(fn, context) && this.secondaryTable.every(fn, context);\n        }\n\n        public some(fn: (k: string, v, c) => bool, context) {\n            return this.primaryTable.some(fn, context) || this.secondaryTable.some(fn, context);\n        }\n\n        public count() {\n            return this.primaryTable.count() + this.secondaryTable.count();\n        }\n\n        public lookup(key: string) {\n            var data = this.primaryTable.lookup(key);\n            if (data != undefined) {\n                return data;\n            }\n            else {\n                return this.secondaryTable.lookup(key);\n            }\n        }\n    }\n\n    export function numberHashFn(key: number): number {\n        var c2 = 0x27d4eb2d; // a prime or an odd constant\n        key = (key ^ 61) ^ (key >>> 16);\n        key = key + (key << 3);\n        key = key ^ (key >>> 4);\n        key = key * c2;\n        key = key ^ (key >>> 15);\n        return key;\n    }\n\n    export function combineHashes(key1: number, key2: number) {\n        return key2 ^ ((key1 >> 5) + key1);\n    }\n\n    export class HashEntry {\n        public next: HashEntry;\n\n        constructor (public key, public data) { }\n    }\n\n    export class HashTable {\n        public itemCount: number = 0;\n        public table = new HashEntry[];\n\n        constructor (public size: number, public hashFn: (key) =>number,\n                    public equalsFn: (key1, key2) =>bool) {\n            for (var i: number = 0; i < this.size; i++) {\n                this.table[i] = null;\n            }\n        }\n\n        publi";
var v27626 = v27627 + 'c add(key, data): bool {\n            var current: HashEntry;\n            var entry: HashEntry = new HashEntry(key, data);\n            var val: number = this.hashFn(key);\n            val = val % this.size;\n\n            for (current = this.table[val]; current != null ; current = current.next) {\n                if (this.equalsFn(key, current.key)) {\n                    return false;\n                }\n            }\n            entry.next = this.table[val];\n            this.table[val] = entry;\n            this.itemCount++;\n            return true;\n        }\n\n        public remove(key) {\n            var current: HashEntry;\n            var val: number = this.hashFn(key);\n            val = val % this.size;\n            var result = null;\n            var prevEntry: HashEntry = null;\n\n            for (current = this.table[val]; current != null ; current = current.next) {\n                if (this.equalsFn(key, current.key)) {\n                    result = current.data;\n                    this.itemCount--;\n                    if (prevEntry) {\n                        prevEntry.next = current.next;\n                    }\n                    else {\n                        this.table[val] = current.next;\n                    }\n                    break;\n                }\n                prevEntry = current;\n            }\n            return result;\n        }\n\n        public count(): number { return this.itemCount; }\n\n        public lookup(key) {\n            var current: HashEntry;\n            var val: number = this.hashFn(key);\n            val = val % this.size;\n            for (current = this.table[val]; current != null ; current = current.next) {\n                if (this.equalsFn(key, current.key)) {\n                    return (current.data);\n                }\n            }\n            return (null);\n        }\n    }\n\n    // Simple Hash table with list of keys and values matching each other at the given index\n    export class SimpleHashTable {\n        private keys = [];\n        private values = [];\n\n        public lookup(key, findValue?: bool) {\n            var searchArray = this.keys;\n            if (findValue) {\n                searchArray = this.values;\n            }\n\n            for (var i = 0; i < searchArray.length; i++) {\n                if (searchArray[i] == key) {\n                    return {\n                        key: this.keys[i],\n                        data: this.values[i],\n                    };\n                }\n            }\n            return null;\n        }\n\n        public add(key, data): bool {\n            var lookupData = this.lookup(key);\n            if (lookupData) {\n                return false;\n            }\n\n            this.keys[this.keys.length] = key;\n            this.values[this.values.length] = data;\n\n            return true;\n        }\n    }\n\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export class IncrementalParser {\n        \n        private astLogger: AstLogger;\n\n        constructor (private logger: TypeScript.ILogger) {\n            this.astLogger = new AstLogger(this.logger);\n        }\n\n        //\n        // Return "null" if "editRange" cannot be safely determined to be inside a single scope.\n        //\n        public getEnclosingScopeContextIfSingleScopeEdit(previousScript: Script, scriptId: string, newSourceText: ISourceText, editRange: ScriptEditRange): EnclosingScopeContext {\n            this.logger.log("checkEditsInsideSingleScope(\\"" + scriptId + "\\")");\n\n            if (editRange === null) {\n                throw new Error("editRange should be valid");\n            }\n\n            if (editRange.isUnknown()) {\n                this.logger.log("  Bailing out because edit range is unknown");\n                return null;\n            }\n\n            var scope1 = TypeScript.findEnclosingScopeAt(this.logger, previousScript, newSourceText, editRange.minChar, false/*isMemberCompletion*/);\n            var scope2 = TypeScript.findEnclosingScopeAt(this.logger, previousScript, newSourceText, editRange.limChar, false/*isMemberCompletion*/);\n            if (scope1 == null || scope2 == null) {\n                this.logger.log("  Bailing out because containing scopes cannot be determined");\n                return null;\n            }\n\n            // We only support changes within a single containing scope\n            if (scope1.scopeStartAST !== scope2.scopeStartAST) {\n      ';
var v27625 = v27626 + '          this.logger.log("  Bailing out because edit overlaps 2 disctint scopes");\n                return null;\n            }\n\n            var newScopeLength = scope1.scopeStartAST.limChar - scope1.scopeStartAST.minChar + editRange.delta;\n            if (newScopeLength <= 0) {\n                this.logger.log("  Bailing out because scope has been entirely removed from new source text");\n                return null;\n            }\n\n            return scope1;\n        }\n\n        public attemptIncrementalUpdateUnit(previousScript: Script, scriptId: string, newSourceText: ISourceText, editRange: ScriptEditRange): UpdateUnitResult {\n            this.logger.log("attemptIncrementalUpdateUnit(\\"" + scriptId + "\\")");\n\n            if (editRange === null) {\n                throw new Error("editRange should be valid");\n            }\n\n            var scope1 = this.getEnclosingScopeContextIfSingleScopeEdit(previousScript, scriptId, newSourceText, editRange);\n            if (scope1 === null) {\n                return null;\n            }\n\n            var newScopeLength = scope1.scopeStartAST.limChar - scope1.scopeStartAST.minChar + editRange.delta;\n\n            // Heuristic: if the range to reparse is too big, bail out. \n            // This is because a full parse will be faster than an incremental parse followed by all the necessary fix-ups \n            if (newScopeLength >= newSourceText.getLength() / 2) {\n                this.logger.log("  Bailing out because range of scope to reparse (" + newScopeLength + " characters) is greater than half the size of the source text");\n                return null;\n            }\n\n            // Capture parsing errors so that they are part of "updateResult"\n            var parseErrors: TypeScript.ErrorEntry[] = [];\n            var errorCapture = function(minChar: number, charLen: number, message: string, unitIndex: number): void {\n                parseErrors.push(new TypeScript.ErrorEntry(unitIndex, minChar, minChar + charLen, message));\n            };\n\n            var quickParseResult = TypeScript.quickParse(this.logger, scope1.scopeStartAST, newSourceText, scope1.scopeStartAST.minChar, scope1.scopeStartAST.minChar + newScopeLength, errorCapture);\n            if (quickParseResult.endLexState != TypeScript.LexState.Start) {\n                this.logger.log("  Bailing out because scope contains unterminated comment");\n                return null;\n            }\n\n            var scriptFragment = quickParseResult.Script;\n            if (scriptFragment.vars.members.length !== 0) {\n                this.logger.log("  Bailing out because new source text defines variables");\n                return null;\n            }\n\n            //if (scriptFragment.scopes.members.length !== 1) {\n            //    logger.log("  Bailing out because new source text defines more than one scope (or none)");\n            //    return null;\n            //}\n\n            // This detects adding close curlies, since they have the side effect of having the parser \n            // parse more members in the scope range.\n            if (scriptFragment.bod.members.length !== 1) {\n                this.logger.log("  Bailing out because new source text defines more than one scope (or none)");\n                return null;\n            }\n\n            var oldScope = scope1.scopeStartAST;\n            var newScope = scriptFragment.bod.members[0];\n\n            if (oldScope.nodeType != newScope.nodeType) {\n                this.logger.log("  Bailing out because new source text does not define the same scope type as the existing scope");\n                return null;\n            }\n\n            if (!(<any>oldScope).leftCurlyCount || !(<any>oldScope).rightCurlyCount) {\n                this.logger.log("  Bailing out because sopce doesn\'t have left/right curly count");\n                return null;\n            }\n\n            if ((<any>oldScope).leftCurlyCount !== (<any>newScope).leftCurlyCount) {\n                this.logger.log("  Bailing out because new source text contains more (or fewer) left curly braces");\n                return null;\n            }\n\n            if ((<any>oldScope).rightCurlyCount !== (<any>newScope).rightCurlyCount) {\n                this.logger.log("  Bailing out because new source text contains more (or fewer) right curly braces");\n                return null;\n            }\n\n            if (newScope.minChar !== 0) {\n                this.logger.log("  Bailing out because new function declaration does not start at position 0");\n                return null;\n            }\n\n            if (newScope.limChar !== newScopeLength) {\n                this.logger.log("  Bailing out because new function declaration does not end at the new end position");\n                return null;\n            }\n\n            return TypeScript.UpdateUnitResult.singleScopeEdits(previousScript, scriptFragment, oldScope, newScope, editRange, parseErrors);\n        }\n\n        public mergeTrees(updateResult: UpdateUnitResult): void {\n            TypeScript.timeF';
var v27624 = v27625 + 'unction(this.logger, "mergeTrees()", () => {\n                var editRange = new ScriptEditRange(updateResult.scope1.minChar, updateResult.scope1.limChar, updateResult.editRange.delta);\n                // Update positions in current ast\n                this.applyDeltaPosition(updateResult.script1, editRange.limChar, editRange.delta);\n                // Update positions in new (partial) ast\n                this.applyDeltaPosition(updateResult.script2, 0, editRange.minChar);\n                // Merge linemaps\n                this.mergeLocationInfo(updateResult.script1, updateResult.script2, editRange);\n                //  Replace old AST for scope with new one\n                this.replaceAST(updateResult.script1, updateResult.scope1, updateResult.scope2);\n            });\n        }\n\n        private replaceAST(script: TypeScript.AST, oldAst: TypeScript.AST, newAst: TypeScript.AST) {\n            var pre = (cur: TypeScript.AST, parent: TypeScript.AST, walker: TypeScript.IAstWalker) => {\n                if (cur === oldAst) {\n                    // Transfer comments ownership to new AST. We need this because when "quick parsing" the\n                    // new AST, we don\'t take into account the text before and after the "minChar/limChar" pair\n                    // of the scope, which don\'t include pre/post-comments.\n                    newAst.preComments = cur.preComments;\n                    newAst.postComments = cur.postComments;\n\n                    this.logger.log("replaced old AST node with new one in script AST");\n                    walker.options.stopWalk();\n                    return newAst;\n                }\n\n                // Avoid visiting sub-trees outside of the edit range\n                if (TypeScript.isValidAstNode(cur)) {\n                    if (cur.limChar < oldAst.minChar || cur.minChar > oldAst.limChar) {\n                        walker.options.goChildren = false;\n                    }\n                }\n                return cur;\n            }\n\n            TypeScript.getAstWalkerFactory().walk(script, pre);\n        }\n\n        private mergeLocationInfo(script: TypeScript.Script, partial: TypeScript.Script, editRange: ScriptEditRange) {\n            // Don\'t merger these fields, as the original script has the right values\n            //script.locationInfo.unitIndex = partial.locationInfo.unitIndex;\n            //script.locationInfo.filename = partial.locationInfo.filename;\n\n            var lineMap1 = script.locationInfo.lineMap;\n            var lineMap2 = partial.locationInfo.lineMap;\n\n            if (this.logger.information()) {\n                this.logger.log("lineMap1 (before):");\n                this.astLogger.logLinemap(lineMap1);\n                this.logger.log("lineMap2 (quick parse):");\n                this.astLogger.logLinemap(lineMap2);\n                this.logger.log("EditRange=" + editRange);\n            }\n\n            // Skip entries < minChar\n            var i1 = 2; // lineMap[0] is always undefined, lineMap[1] is always 0.\n            var i2 = 2; // lineMap[0] is always undefined, lineMap[1] is always 0.\n            var len1 = lineMap1.length;\n            var len2 = lineMap2.length;\n            while (i1 < len1) {\n                if (lineMap1[i1] <= editRange.minChar) {\n                    // Nothing to do for this entry, since it\'s before the range of the change\n                    i1++;\n                } else if (lineMap1[i1] >= editRange.limChar) {\n                    // Apply delta to this entry, since it\'s outside the range of the change\n                    lineMap1[i1] += editRange.delta;\n                    i1++;\n                }\n                else {\n                    if (i2 < len2) {\n                        // Add a new entry to lineMap1 corresponding to lineMap2 in new range\n                        lineMap1.splice(i1, 0, lineMap2[i2] + editRange.minChar);\n                        i1++;\n                        len1++;\n                        i2++;\n                    }\n                    else { /* i2 >= len 2 */\n                        // Remove this entry, since there is no corresponding entry in the new map\n                        lineMap1.splice(i1, 1);\n                        len1--;\n                    }\n                }\n            }\n            // Merge the remaining entries in lineMap2 while maintaing the constraint that a lineMap is sorted\n            if (i2 < len2) {\n                // i1 >= len1 && i2 < len2 \n                if (lineMap1[len1 - 1] >= (lineMap2[i2] + editRange.minChar)) {\n                    // lineMap2 needs to be merged within lineMap1\n                    i1 = 2;\n                    while (i1 < len1 && i2 < len2) {\n                        if (lineMap1[i1] < (lineMap2[i2] + editRange.minChar)) {\n                            i1++;\n                        }\n                        else {\n                            lineMap1.splice(i1, 0, lineMap2[i2] + editRange.minChar);\n                            i1++;\n                            len1++;\n  ';
var v27623 = v27624 + '                          i2++;\n                        }\n                    }\n                }\n\n                // Append all the remaining entries in lineMap2 to the end of lineMap1\n                for (; i2 < len2; i2++) {\n                    lineMap1.push(lineMap2[i2] + editRange.minChar);\n                }\n            }\n\n            if (this.logger.information()) {\n                this.logger.log("lineMap1 (after merge):");\n                this.astLogger.logLinemap(lineMap1);\n            }\n        }\n\n        private applyDeltaPosition(ast: TypeScript.AST, start: number, delta: number) {\n            var applyDelta = (ast: TypeScript.AST) => {\n                if (ast.minChar !== -1 && ast.minChar >= start) {\n                    ast.minChar += delta;\n                }\n                if (ast.limChar !== -1 && ast.limChar >= start) {\n                    ast.limChar += delta;\n                }\n            }\n\n            var applyDeltaToComments = (comments: TypeScript.Comment[]) => {\n                if (comments && comments.length > 0) {\n                    for (var i = 0; i < comments.length; i++) {\n                        applyDelta(comments[i]);\n                    }\n                }\n            }\n\n            var pre = function(cur: TypeScript.AST, parent: TypeScript.AST, walker: TypeScript.IAstWalker) {\n                // *Before* applying delta to this, check if we need to go to children\n                if (cur.limChar !== -1 && cur.limChar < start) {\n                    walker.options.goChildren = false; // Done with applying Delta for this sub-tree\n                }\n\n                // Apply delta to this node\n                applyDelta(cur);\n                applyDeltaToComments(cur.preComments);\n                applyDeltaToComments(cur.postComments);\n\n                return cur;\n            }\n\n            TypeScript.getAstWalkerFactory().walk(ast, pre);\n        }\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\ninterface IResolvedFile {\n    content: string;\n    path: string;\n}\n\ninterface IFileWatcher {\n    close(): void;\n}\n\ninterface IIO {\n    readFile(path: string): string;\n    writeFile(path: string, contents: string): void;\n    createFile(path: string, useUTF8?: bool): ITextWriter;\n    deleteFile(path: string): void;\n    dir(path: string, re?: RegExp, options?: { recursive?: bool; }): string[];\n    fileExists(path: string): bool;\n    directoryExists(path: string): bool;\n    createDirectory(path: string): void;\n    resolvePath(path: string): string;\n    dirName(path: string): string;\n    findFile(rootPath: string, partialFilePath: string): IResolvedFile;\n    print(str: string): void;\n    printLine(str: string): void;\n    arguments: string[];\n    stderr: ITextWriter;\n    stdout: ITextWriter;\n    watchFile(filename: string, callback: (string) => void ): IFileWatcher;\n    run(source: string, filename: string): void;\n    getExecutingFilePath(): string;\n    quit(exitCode?: number);\n}\n\nmodule IOUtils {\n    // Creates the directory including its parent if not already present\n    function createDirectoryStructure(ioHost: IIO, dirName: string) {\n        if (ioHost.directoryExists(dirName)) {\n            return;\n        }\n\n        var parentDirectory = ioHost.dirName(dirName);\n        if (parentDirectory != "") {\n            createDirectoryStructure(ioHost, parentDirectory);\n        }\n        ioHost.createDirectory(dirName);\n    }\n\n    // Creates a file including its directory structure if not already present\n    export function createFileAndFolderStructure(ioHost: IIO, fileName: string, useUTF8?: bool) {\n        var path = ioHost.resolvePath(fileName);\n        var dirName = ioHost.dirName(path);\n        createDirectoryStructure(ioHost, dirName);\n        return ioHost.createFile(path, useUTF8);\n    }\n\n    export function throwIOError(message: string, error: Error) {\n        var errorMessage = message;\n        if (error && error.message) {\n            errorMessage += (" " + error.message);\n        }\n        throw new Error(errorMessage);\n    }\n}\n\n// Declare dependencies needed for all supported hosts\ndeclare class Enumerator {\n    public atEnd(): bool;\n    public moveNext();\n    public item(): any;\n    constructor (o: any);\n}\ndeclare function setTimeout(callback: () =>void , ms?: number);\ndeclare var require: any;\ndeclare module process {\n    export var argv: string[];\n    export var platform: string;\n    export function on(event: st';
var v27622 = v27623 + 'ring, handler: (any) => void ): void;\n    export module stdout {\n        export function write(str: string);\n    }\n    export module stderr {\n        export function write(str: string);\n    }\n    export module mainModule {\n        export var filename: string;\n    }\n    export function exit(exitCode?: number);\n}\n\nvar IO = (function() {\n\n    // Create an IO object for use inside WindowsScriptHost hosts\n    // Depends on WSCript and FileSystemObject\n    function getWindowsScriptHostIO(): IIO {\n        var fso = new ActiveXObject("Scripting.FileSystemObject");\n        var streamObjectPool = [];\n\n        function getStreamObject(): any { \n            if (streamObjectPool.length > 0) {\n                return streamObjectPool.pop();\n            }  else {\n                return new ActiveXObject("ADODB.Stream");\n            }\n        }\n\n        function releaseStreamObject(obj: any) { \n            streamObjectPool.push(obj);\n        }\n\n        var args = [];\n        for (var i = 0; i < WScript.Arguments.length; i++) {\n            args[i] = WScript.Arguments.Item(i);\n        }\n\n        return {\n            readFile: function(path) {\n                try {\n                    var streamObj = getStreamObject();\n                    streamObj.Open();\n                    streamObj.Type = 2; // Text data\n                    streamObj.Charset = \'x-ansi\'; // Assume we are reading ansi text\n                    streamObj.LoadFromFile(path);\n                    var bomChar = streamObj.ReadText(2); // Read the BOM char\n                    streamObj.Position = 0; // Position has to be at 0 before changing the encoding\n                    if ((bomChar.charCodeAt(0) == 0xFE && bomChar.charCodeAt(1) == 0xFF)\n                        || (bomChar.charCodeAt(0) == 0xFF && bomChar.charCodeAt(1) == 0xFE)) {\n                        streamObj.Charset = \'unicode\';\n                    } else if (bomChar.charCodeAt(0) == 0xEF && bomChar.charCodeAt(1) == 0xBB) {\n                        streamObj.Charset = \'utf-8\'; \n                    }\n\n                    // Read the whole file\n                    var str = streamObj.ReadText(-1 /* read from the current position to EOS */);\n                    streamObj.Close();\n                    releaseStreamObject(streamObj);\n                    return <string>str;\n                }\n                catch (err) {\n                    IOUtils.throwIOError("Error reading file \\"" + path + "\\".", err);\n                }\n            },\n\n            writeFile: function(path, contents) {\n                var file = this.createFile(path);\n                file.Write(contents);\n                file.Close();\n            },\n\n            fileExists: function(path: string): bool {\n                return fso.FileExists(path);\n            },\n\n            resolvePath: function(path: string): string {\n                return fso.GetAbsolutePathName(path);\n            },\n\n            dirName: function(path: string): string {\n                return fso.GetParentFolderName(path);\n            },\n\n            findFile: function(rootPath: string, partialFilePath: string): IResolvedFile {\n                var path = fso.GetAbsolutePathName(rootPath) + "/" + partialFilePath;\n\n                while (true) {\n                    if (fso.FileExists(path)) {\n                        try {\n                            var content = this.readFile(path);\n                            return { content: content, path: path };\n                        }\n                        catch (err) {\n                            //Tools.CompilerDiagnostics.debugPrint("Could not find " + path + ", trying parent");\n                        }\n                    }\n                    else {\n                        rootPath = fso.GetParentFolderName(fso.GetAbsolutePathName(rootPath));\n\n                        if (rootPath == "") {\n                            return null;\n                        }\n                        else {\n                            path = fso.BuildPath(rootPath, partialFilePath);\n                        }\n                    }\n                }\n            },\n\n            deleteFile: function(path: string): void {\n                try {\n                    if (fso.FileExists(path)) {\n                        fso.DeleteFile(path, true); // true: delete read-only files\n                    }\n                } catch (e) {\n                    IOUtils.throwIOError("Couldn\'t delete file \'" + path + "\'.", e);\n                }\n            },\n\n            createFile: function (path, useUTF8?) {\n                try {\n                    var streamObj = getStreamObject();\n                    streamObj.Charset = useUTF8 ? \'utf-8\' : \'x-ansi\';\n                    streamObj.Open();\n                    return {\n                        Write: function (str) { streamObj.WriteText(str, 0); },\n                        WriteLine: function (str) { streamObj.WriteText(str, 1); },\n                        Close: function() {\n                            try {\n            ';
var v27621 = v27622 + '                    streamObj.SaveToFile(path, 2);\n                            } catch (saveError) {\n                                IOUtils.throwIOError("Couldn\'t write to file \'" + path + "\'.", saveError);\n                            }\n                            finally {\n                                if (streamObj.State != 0 /*adStateClosed*/) {\n                                    streamObj.Close();\n                                }\n                                releaseStreamObject(streamObj);\n                            }\n                        }\n                    };\n                } catch (creationError) {\n                    IOUtils.throwIOError("Couldn\'t write to file \'" + path + "\'.", creationError);\n                }\n            },\n\n            directoryExists: function(path) {\n                return <bool>fso.FolderExists(path);\n            },\n\n            createDirectory: function(path) {\n                try {\n                    if (!this.directoryExists(path)) {\n                        fso.CreateFolder(path);\n                    }\n                } catch (e) {\n                    IOUtils.throwIOError("Couldn\'t create directory \'" + path + "\'.", e);\n                }\n            },\n\n            dir: function(path, spec?, options?) {\n                options = options || <{ recursive?: bool; }>{};\n                function filesInFolder(folder, root): string[]{\n                    var paths = [];\n                    var fc: Enumerator;\n\n                    if (options.recursive) {\n                        fc = new Enumerator(folder.subfolders);\n\n                        for (; !fc.atEnd() ; fc.moveNext()) {\n                            paths = paths.concat(filesInFolder(fc.item(), root + "/" + fc.item().Name));\n                        }\n                    }\n\n                    fc = new Enumerator(folder.files);\n\n                    for (; !fc.atEnd() ; fc.moveNext()) {\n                        if (!spec || fc.item().Name.match(spec)) {\n                            paths.push(root + "/" + fc.item().Name);\n                        }\n                    }\n\n                    return paths;\n                }\n\n                var folder = fso.GetFolder(path);\n                var paths = [];\n\n                return filesInFolder(folder, path);\n            },\n\n            print: function(str) {\n                WScript.StdOut.Write(str);\n            },\n\n            printLine: function(str) {\n                WScript.Echo(str);\n            },\n\n            arguments: <string[]>args,\n            stderr: WScript.StdErr,\n            stdout: WScript.StdOut,\n            watchFile: null,\n            run: function(source, filename) {\n                try {\n                    eval(source);\n                } catch (e) {\n                    IOUtils.throwIOError("Error while executing file \'" + filename + "\'.", e);\n                }\n            },\n            getExecutingFilePath: function () {\n                return WScript.ScriptFullName;\n            },\n            quit: function (exitCode? : number = 0) {\n                try {\n                    WScript.Quit(exitCode);\n                } catch (e) {\n                }\n            }\n        }\n\n    };\n\n    // Create an IO object for use inside Node.js hosts\n    // Depends on \'fs\' and \'path\' modules\n    function getNodeIO(): IIO {\n\n        var _fs = require(\'fs\');\n        var _path = require(\'path\');\n        var _module = require(\'module\');\n\n        return {\n            readFile: function(file) {\n                try {\n                    var buffer = _fs.readFileSync(file);\n                    switch (buffer[0]) {\n                        case 0xFE:\n                            if (buffer[1] == 0xFF) {\n                                // utf16-be. Reading the buffer as big endian is not supported, so convert it to \n                                // Little Endian first\n                                var i = 0;\n                                while ((i + 1) < buffer.length) {\n                                    var temp = buffer[i]\n                                    buffer[i] = buffer[i + 1];\n                                    buffer[i + 1] = temp;\n                                    i += 2;\n                                }\n                                return buffer.toString("ucs2", 2);\n                            }\n                            break;\n                        case 0xFF:\n                            if (buffer[1] == 0xFE) {\n                                // utf16-le \n                                return buffer.toString("ucs2", 2);\n                            }\n                            break;\n                        case 0xEF:\n                            if (buffer[1] == 0xBB) {\n                                // utf-8\n                                return buffer.toString("utf8", 3);\n                            }\n                    }\n                    // Default behaviour\n                    return buffer.toString();\n                } catch ';
var v27620 = v27621 + '(e) {\n                    IOUtils.throwIOError("Error reading file \\"" + file + "\\".", e);\n                }\n            },\n            writeFile: <(path: string, contents: string) => void >_fs.writeFileSync,\n            deleteFile: function(path) {\n                try {\n                    _fs.unlinkSync(path);\n                } catch (e) {\n                    IOUtils.throwIOError("Couldn\'t delete file \'" + path + "\'.", e);\n                }\n            },\n            fileExists: function(path): bool {\n                return _fs.existsSync(path);\n            },\n            createFile: function(path, useUTF8?) {\n                function mkdirRecursiveSync(path) {\n                    var stats = _fs.statSync(path);\n                    if (stats.isFile()) {\n                        IOUtils.throwIOError("\\"" + path + "\\" exists but isn\'t a directory.", null);\n                    } else if (stats.isDirectory()) {\n                        return;\n                    } else {\n                        mkdirRecursiveSync(_path.dirname(path));\n                        _fs.mkdirSync(path, 0775);\n                    }\n                }\n\n                mkdirRecursiveSync(_path.dirname(path));\n\n                try {\n                    var fd = _fs.openSync(path, \'w\');\n                } catch (e) {\n                    IOUtils.throwIOError("Couldn\'t write to file \'" + path + "\'.", e);\n                }\n                return {\n                    Write: function(str) { _fs.writeSync(fd, str); },\n                    WriteLine: function(str) { _fs.writeSync(fd, str + \'\\r\\n\'); },\n                    Close: function() { _fs.closeSync(fd); fd = null; }\n                };\n            },\n            dir: function dir(path, spec?, options?) {\n                options = options || <{ recursive?: bool; }>{};\n\n                function filesInFolder(folder: string): string[]{\n                    var paths = [];\n\n                    var files = _fs.readdirSync(folder);\n                    for (var i = 0; i < files.length; i++) {\n                        var stat = _fs.statSync(folder + "/" + files[i]);\n                        if (options.recursive && stat.isDirectory()) {\n                            paths = paths.concat(filesInFolder(folder + "/" + files[i]));\n                        } else if (stat.isFile() && (!spec || files[i].match(spec))) {\n                            paths.push(folder + "/" + files[i]);\n                        }\n                    }\n\n                    return paths;\n                }\n\n                return filesInFolder(path);\n            },\n            createDirectory: function(path: string): void {\n                try {\n                    if (!this.directoryExists(path)) {\n                        _fs.mkdirSync(path);\n                    }\n                } catch (e) {\n                    IOUtils.throwIOError("Couldn\'t create directory \'" + path + "\'.", e);\n                }\n            },\n\n            directoryExists: function(path: string): bool {\n                return _fs.existsSync(path) && _fs.lstatSync(path).isDirectory();\n            },\n            resolvePath: function(path: string): string {\n                return _path.resolve(path);\n            },\n            dirName: function(path: string): string {\n                return _path.dirname(path);\n            },\n            findFile: function(rootPath: string, partialFilePath): IResolvedFile {\n                var path = rootPath + "/" + partialFilePath;\n\n                while (true) {\n                    if (_fs.existsSync(path)) {\n                        try {\n                            var content = this.readFile(path);\n                            return { content: content, path: path };\n                        } catch (err) {\n                            //Tools.CompilerDiagnostics.debugPrint(("Could not find " + path) + ", trying parent");\n                        }\n                    }\n                    else {\n                        var parentPath = _path.resolve(rootPath, "..");\n\n                        // Node will just continue to repeat the root path, rather than return null\n                        if (rootPath === parentPath) {\n                            return null;\n                        }\n                        else {\n                            rootPath = parentPath;\n                            path = _path.resolve(rootPath, partialFilePath);\n                        }\n                    }\n                }\n            },\n            print: function(str) { process.stdout.write(str) },\n            printLine: function(str) { process.stdout.write(str + \'\\n\') },\n            arguments: process.argv.slice(2),\n            stderr: {\n                Write: function(str) { process.stderr.write(str); },\n                WriteLine: function(str) { process.stderr.write(str + \'\\n\'); },\n                Close: function() { }\n            },\n            stdout: {\n                Write: function(str) { process.stdout.write(str); },\n                Write';
var v27619 = v27620 + 'Line: function(str) { process.stdout.write(str + \'\\n\'); },\n                Close: function() { }\n            },\n            watchFile: function(filename: string, callback: (string) => void ): IFileWatcher {\n                var firstRun = true;\n                var processingChange = false;\n\n                var fileChanged: any = function(curr, prev) {\n                    if (!firstRun) {\n                        if (curr.mtime < prev.mtime) {\n                            return;\n                        }\n\n                        _fs.unwatchFile(filename, fileChanged);\n                        if (!processingChange) {\n                            processingChange = true;\n                            callback(filename);\n                            setTimeout(function() { processingChange = false; }, 100);\n                        }\n                    }\n                    firstRun = false;\n                    _fs.watchFile(filename, { persistent: true, interval: 500 }, fileChanged);\n                };\n\n                fileChanged();\n                return {\n                    filename: filename,\n                    close: function() {\n                        _fs.unwatchFile(filename, fileChanged);\n                    }\n                };\n            },\n            run: function(source, filename) {\n                require.main.filename = filename;\n                require.main.paths = _module._nodeModulePaths(_path.dirname(_fs.realpathSync(filename)));\n                require.main._compile(source, filename);\n            }, \n            getExecutingFilePath: function () {\n                return process.mainModule.filename;\n            },\n            quit: process.exit\n        }\n    };\n\n    if (typeof ActiveXObject === "function")\n        return getWindowsScriptHostIO();\n    else if (typeof require === "function")\n        return getNodeIO();\n    else\n        return null; // Unsupported host\n})();\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    // Note: Any addition to the NodeType should also be supported with addition to AstWalkerDetailCallback\n    export enum NodeType {\n        None,\n        Empty,\n        EmptyExpr,\n        True,\n        False,\n        This,\n        Super,\n        QString,\n        Regex,\n        Null,\n        ArrayLit,\n        ObjectLit,\n        Void,\n        Comma,\n        Pos,\n        Neg,\n        Delete,\n        Await,\n        In,\n        Dot,\n        From,\n        Is,\n        InstOf,\n        Typeof,\n        NumberLit,\n        Name,\n        TypeRef,\n        Index,\n        Call,\n        New,\n        Asg,\n        AsgAdd,\n        AsgSub,\n        AsgDiv,\n        AsgMul,\n        AsgMod,\n        AsgAnd,\n        AsgXor,\n        AsgOr,\n        AsgLsh,\n        AsgRsh,\n        AsgRs2,\n        ConditionalExpression,\n        LogOr,\n        LogAnd,\n        Or,\n        Xor,\n        And,\n        Eq,\n        Ne,\n        Eqv,\n        NEqv,\n        Lt,\n        Le,\n        Gt,\n        Ge,\n        Add,\n        Sub,\n        Mul,\n        Div,\n        Mod,\n        Lsh,\n        Rsh,\n        Rs2,\n        Not,\n        LogNot,\n        IncPre,\n        DecPre,\n        IncPost,\n        DecPost,\n        TypeAssertion,\n        FuncDecl,\n        Member,\n        VarDecl,\n        ArgDecl,\n        Return,\n        Break,\n        Continue,\n        Throw,\n        For,\n        ForIn,\n        If,\n        While,\n        DoWhile,\n        Block,\n        Case,\n        Switch,\n        Try,\n        TryCatch,\n        TryFinally,\n        Finally,\n        Catch,\n        List,\n        Script,\n        ClassDeclaration,\n        InterfaceDeclaration,\n        ModuleDeclaration,\n        ImportDeclaration,\n        With,\n        Label,\n        LabeledStatement,\n        EBStart,\n        GotoEB,\n        EndCode,\n        Error,\n        Comment,\n        Debugger,\n        GeneralNode = FuncDecl,\n        LastAsg = AsgRs2,\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.';
var v27618 = v27619 + '\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path="io.ts" />\n\ninterface IOptions {\n    name?: string;\n    flag?: bool;\n    short?: string;\n    usage?: string;\n    set?: (s: string) => void;\n    type?: string;\n    experimental?: bool;\n}\n\nclass OptionsParser {\n    private DEFAULT_SHORT_FLAG = "-";\n    private DEFAULT_LONG_FLAG = "--";\n\n    // Find the option record for the given string. Returns null if not found.\n    private findOption(arg: string) {\n\n        for (var i = 0; i < this.options.length; i++) {\n\n            if (arg === this.options[i].short || arg === this.options[i].name) {\n                return this.options[i];\n            }\n        }\n\n        return null;\n    }\n\n    public unnamed: string[] = [];\n\n    public options: IOptions[] = [];\n\n    constructor (public host: IIO) {\n    }\n\n    public printUsage() {\n        this.host.printLine("Syntax:   tsc [options] [file ..]");\n        this.host.printLine("");\n        this.host.printLine("Examples: tsc hello.ts");\n        this.host.printLine("          tsc --out foo.js foo.ts");\n        this.host.printLine("          tsc @args.txt");\n        this.host.printLine("");\n        this.host.printLine("Options:");\n\n        var output = [];\n        var maxLength = 0;\n\n        this.options = this.options.sort(function(a, b) {\n            var aName = a.name.toLowerCase();\n            var bName = b.name.toLowerCase();\n\n            if (aName > bName) {\n                return 1;\n            } else if (aName < bName) {\n                return -1;\n            } else {\n                return 0;\n            }\n        });\n\n        // Build up output array\n        for (var i = 0; i < this.options.length; i++) {\n            var option = this.options[i];\n\n            if (option.experimental) {\n                continue;\n            }\n\n            if (!option.usage) {\n                break;\n            }\n\n            var usageString = "  ";\n            var type = option.type ? " " + option.type.toUpperCase() : "";\n\n            if (option.short) {\n                usageString += this.DEFAULT_SHORT_FLAG + option.short + type + ", ";\n            }\n\n            usageString += this.DEFAULT_LONG_FLAG + option.name + type;\n\n            output.push([usageString, option.usage]);\n\n            if (usageString.length > maxLength) {\n                maxLength = usageString.length;\n            }\n        }\n\n        output.push(["  @<file>", "Insert command line options and files from a file."]);\n\n        // Print padded output\n        for (var i = 0; i < output.length; i++) {\n            this.host.printLine(output[i][0] + (new Array(maxLength - output[i][0].length + 3)).join(" ") + output[i][1]);\n        }\n    }\n\n    public option(name: string, config: IOptions, short?: string) {\n        if (!config) {\n            config = <any>short;\n            short = null;\n        }\n\n        config.name = name;\n        config.short = short;\n        config.flag = false;\n\n        this.options.push(config);\n    }\n\n    public flag(name: string, config: IOptions, short?: string) {\n        if (!config) {\n            config = <any>short;\n            short = null;\n        }\n\n        config.name = name;\n        config.short = short;\n        config.flag = true\n\n        this.options.push(config);\n    }\n\n    // Parse an arguments string\n    public parseString(argString: string) {\n        var position = 0;\n        var tokens = argString.match(/\\s+|"|[^\\s"]+/g);\n\n        function peek() {\n            return tokens[position];\n        }\n\n        function consume() {\n            return tokens[position++];\n        }\n\n        function consumeQuotedString() {\n            var value = \'\';\n            consume(); // skip opening quote.\n\n            var token = peek();\n\n            while (token && token !== \'"\') {\n                consume();\n\n                value += token;\n\n                token = peek();\n            }\n\n            consume(); // skip ending quote;\n\n            return value;\n        }\n\n        var args: string[] = [];\n        var currentArg = \'\';\n\n        while (position < tokens.length) {\n            var token = peek();\n\n            if (token === \'"\') {\n                currentArg += consumeQuotedString();\n            } else if (token.match(/\\s/)) {\n                if (currentArg.length > 0) {\n                    args.push(currentArg);\n                    currentArg = \'\';\n                }\n\n                consume();\n            } else {\n                consume();\n                currentArg += token;\n            }\n        }\n\n        if (currentArg.length > 0) {\n            args.push(currentArg);\n        }\n\n        this.parse(args);\n    }\n\n    // Parse arguments as they come from the platform: split into arguments.\n    public parse(args: string[]) {\n        var position = 0;\n\n        function consume() {\n            return args[position++];\n        }\n\n        while (position < args.length) {\n            var current = consume();\n           ';
var v27617 = v27618 + ' var match = current.match(/^(--?|@)(.*)/);\n            var value = null;\n\n            if (match) {\n                if (match[1] === \'@\') {\n                    this.parseString(this.host.readFile(match[2]));\n                } else {\n                    var arg = match[2];\n                    var option = this.findOption(arg);\n\n                    if (option === null) {\n                        this.host.printLine("Unknown option \'" + arg +"\'");\n                        this.host.printLine("Use the \'--help\' flag to see options");\n                    } else {\n                        if (!option.flag)\n                            value = consume();\n\n                        option.set(value);\n                    }\n                }\n            } else {\n                this.unnamed.push(current);\n            }\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export enum TypeContext {\n        NoTypes = 0,\n        ArraySuffix = 1,\n        Primitive = 2,\n        Named = 4,\n        AllSimpleTypes = Primitive | Named,\n        AllTypes = Primitive | Named | ArraySuffix,\n    }\n\n    export enum ParseState {\n        None,\n        StartScript,\n        StartStatementList,\n        StartStatement,\n        StartFncDecl,\n        FncDeclName,\n        FncDeclArgs,\n        FncDeclReturnType,\n        ForInit,\n        ForInitAfterVar,\n        ForCondStart,\n        EndStmtList,\n        EndScript,\n    }\n\n    export interface IStatementInfo {\n        stmt: Statement;\n        labels: ASTList;\n    }\n\n    export interface ILambdaArgumentContext {\n        preProcessedLambdaArgs: AST;\n    }\n\n    export class QuickParseResult {\n        constructor (public Script: Script, public endLexState: LexState) { }\n    }\n\n    export class Parser {\n        private varLists: ASTList[] = [];\n        private scopeLists: ASTList[] = [];\n        private staticsLists: ASTList[] = [];\n\n        private scanner: IScanner = new Scanner();\n        private currentToken: Token = null;\n\n        private needTerminator = false;\n\n        // TODO: consolidate these\n        private inFunction = false;\n        private inInterfaceDecl = false;\n        public currentClassDecl: NamedDeclaration = null;\n\n        private inFncDecl = false;  // this is only for FuncDecls - not constructors, like inFnc\n        private anonId = new Identifier("_anonymous");\n        public style_requireSemi = false;\n        public style_funcInLoop = true;\n        private incremental = false;\n        public errorRecovery = false;\n        public outfile: ITextWriter = undefined;\n        public errorCallback: (minChar: number, charLen: number, message: string, unit: number) =>void = null;\n        private state: ParseState = ParseState.StartStatementList;\n        private ambientModule = false;\n        private ambientClass = false;\n        private topLevel = true;\n        private allowImportDeclaration = true;\n        private currentUnitIndex = (-1);\n        private prevIDTok: Token = null;\n        private statementInfoStack: IStatementInfo[] = new IStatementInfo[];\n        private hasTopLevelImportOrExport = false; // for imports, only true if it\'s a dynamic module\n        private strictMode = false;\n        private nestingLevel = 0;\n        private prevExpr: AST = null;\n        private currentClassDefinition: ClassDeclaration = null;\n        private parsingClassConstructorDefinition = false;\n        private parsingDeclareFile = false;\n        private amdDependencies: string[] = [];\n        public inferPropertiesFromThisAssignment = false;\n        public requiresExtendsBlock = false;\n\n        private resetStmtStack() {\n            this.statementInfoStack = new IStatementInfo[];\n        }\n\n        private inLoop() {\n            for (var j = this.statementInfoStack.length - 1; j >= 0; j--) {\n                if (this.statementInfoStack[j].stmt.isLoop()) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private pushStmt(stmt: Statement, labels: ASTList) {\n            // allocate here to avoid always storing this information in statements\n            var info = { stmt: stmt, labels: labels };\n            this.statementInfoStack.push(info);\n        }\n\n        private popStmt(): IStatementInfo {\n            return this.statementInfoStack.pop();\n        }\n\n        private resolveJumpTarget(jump: Jump): void {';
var v27616 = v27617 + '\n            var resolvedTarget = AST.getResolvedIdentifierName(jump.target);\n            var len = this.statementInfoStack.length;\n            for (var i = len - 1; i >= 0; i--) {\n                var info = this.statementInfoStack[i];\n                if (jump.target) {\n                    if (info.labels && (info.labels.members.length > 0)) {\n                        for (var j = 0, labLen = info.labels.members.length; j < labLen; j++) {\n                            var label = <Label>info.labels.members[j];\n                            if (label.id.text == resolvedTarget) {\n                                jump.setResolvedTarget(this, info.stmt);\n                                return;\n                            }\n                        }\n                    }\n                }\n                else {\n                    if (info.stmt.isLoop()) {\n                        jump.setResolvedTarget(this, info.stmt);\n                        return;\n                    }\n                    else if ((info.stmt.nodeType == NodeType.Switch) && (jump.nodeType == NodeType.Break)) {\n                        jump.setResolvedTarget(this, info.stmt);\n                        return;\n                    }\n                }\n            }\n            // no luck\n            if (jump.target) {\n                this.reportParseError("could not find enclosing statement with label " + jump.target);\n            }\n            else {\n                if (jump.nodeType == NodeType.Break) {\n                    this.reportParseError("break statement requires enclosing loop or switch");\n                }\n                else {\n                    this.reportParseError("continue statement requires enclosing loop");\n                }\n            }\n        }\n\n        public setErrorRecovery(outfile: ITextWriter) {\n            this.outfile = outfile;\n            this.errorRecovery = true;\n        }\n\n        public getSourceLineCol(lineCol: ILineCol, minChar: number): void {\n            getSourceLineColFromMap(lineCol, minChar, this.scanner.lineMap);\n        }\n\n        private createRef(text: string, hasEscapeSequence: bool, minChar: number): Identifier {\n            var id = new Identifier(text, hasEscapeSequence);\n            id.minChar = minChar;\n            return id;\n        }\n\n        private reportParseStyleError(message: string) {\n            this.reportParseError("STYLE: " + message);\n        }\n\n        public reportParseError(message: string, startPos = this.scanner.startPos, pos = this.scanner.pos) {\n            var len = Math.max(1, pos - startPos);\n            if (this.errorCallback) {\n                this.errorCallback(startPos, len, message, this.currentUnitIndex);\n            }\n            else if (this.errorRecovery) {\n                var lineCol = { line: -1, col: -1 };\n                this.getSourceLineCol(lineCol, startPos);\n                if (this.outfile) {\n                    this.outfile.WriteLine("// " + this.fname + " (" + lineCol.line + "," + lineCol.col + "): " + message);\n                }\n            }\n            else {\n                throw new SyntaxError(this.fname + " (" + this.scanner.line + "," + this.scanner.col + "): " + message);\n            }\n        }\n\n        private checkNextToken(tokenId: TokenID, errorRecoverySet: ErrorRecoverySet, errorText: string = null): void {\n            this.currentToken = this.scanner.scan();\n            this.checkCurrentToken(tokenId, errorRecoverySet, errorText);\n        }\n\n        private skip(errorRecoverySet: ErrorRecoverySet) {\n            errorRecoverySet |= ErrorRecoverySet.EOF;\n            var ersTok = ErrorRecoverySet.None;\n            var tokenInfo = lookupToken(this.currentToken.tokenId);\n            if (tokenInfo != undefined) {\n                ersTok = tokenInfo.ers;\n            }\n            var pendingRightCurlies = 0;\n            while (((ersTok & errorRecoverySet) == ErrorRecoverySet.None) ||\n                   (this.currentToken.tokenId == TokenID.CloseBrace) && (pendingRightCurlies > 0)) {\n                if (this.currentToken.tokenId == TokenID.OpenBrace) {\n                    pendingRightCurlies++;\n                }\n                else if (this.currentToken.tokenId == TokenID.CloseBrace) {\n                    pendingRightCurlies--;\n                }\n                this.currentToken = this.scanner.scan();\n                ersTok = ErrorRecoverySet.None;\n                tokenInfo = lookupToken(this.currentToken.tokenId);\n                if (tokenInfo != undefined) {\n                    ersTok = tokenInfo.ers;\n                }\n                // TODO: regex rescan \n            }\n        }\n\n        private checkCurrentToken(tokenId: TokenID, errorRecoverySet: ErrorRecoverySet, errorText: string = null): void {\n            if (this.currentToken.tokenId != tokenId) {\n                errorText = errorText == null ? ("Expected \'" + tokenTable[tokenId].text + "\'") : errorText;\n                this.reportParseError(errorText);\n                if (this.errorRecove';
var v27615 = v27616 + 'ry) {\n                    this.skip(errorRecoverySet);\n                }\n            }\n            else {\n                this.currentToken = this.scanner.scan();\n            }\n        }\n\n        private pushDeclLists() {\n            this.staticsLists.push(new ASTList());\n            this.varLists.push(new ASTList());\n            this.scopeLists.push(new ASTList());\n        }\n\n        private popDeclLists() {\n            this.staticsLists.pop();\n            this.varLists.pop();\n            this.scopeLists.pop();\n        }\n\n        private topVarList() {\n            return this.varLists[this.varLists.length - 1];\n        }\n\n        private topScopeList() {\n            return this.scopeLists[this.scopeLists.length - 1];\n        }\n\n        private topStaticsList() {\n            return this.staticsLists[this.staticsLists.length - 1];\n        }\n\n        private parseComment(comment: CommentToken) {\n            if (comment) {\n                var c: Comment = new Comment(comment.value, comment.isBlock, comment.endsLine);\n                c.minChar = comment.startPos;\n                c.limChar = comment.startPos + comment.value.length;\n                var lineCol = { line: -1, col: -1 };\n                this.getSourceLineCol(lineCol, c.minChar);\n                c.minLine = lineCol.line;\n                this.getSourceLineCol(lineCol, c.limChar);\n                c.limLine = lineCol.line;\n\n                if (!comment.isBlock && comment.value.length > 3 && comment.value.substring(0, 3) == "///") {\n                    var dependencyPath = getAdditionalDependencyPath(comment.value);\n\n                    if (dependencyPath) {\n                        this.amdDependencies.push(dependencyPath);\n                    }\n\n                    if (getImplicitImport(comment.value)) {\n                        this.hasTopLevelImportOrExport = true;\n                    }\n                }\n\n                return c;\n            }\n            else {\n                return null;\n            }\n        }\n\n        private parseCommentsInner(comments: CommentToken[]) {\n            if (comments) {\n                var commentASTs: Comment[] = new Comment[];\n                for (var i = 0; i < comments.length; i++) {\n                    commentASTs.push(this.parseComment(comments[i]));\n                }\n                return commentASTs;\n            } else {\n                return null;\n            }\n        }\n\n        private parseComments() {\n            var comments = this.scanner.getComments();\n            return this.parseCommentsInner(comments);\n        }\n\n        private parseCommentsForLine(line: number) {\n            var comments = this.scanner.getCommentsForLine(line);\n\n            return this.parseCommentsInner(comments);\n        }\n\n        private combineComments(comment1: Comment[], comment2: Comment[]) {\n            if (comment1 == null) {\n                return comment2;\n            }\n            else if (comment2 == null) {\n                return comment1;\n            }\n            else {\n                return comment1.concat(comment2);\n            }\n        }\n\n        private parseEnumDecl(errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers): ModuleDeclaration {\n            var leftCurlyCount = this.scanner.leftCurlyCount;\n            var rightCurlyCount = this.scanner.rightCurlyCount;\n\n            var name: Identifier = null;\n            if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                name = Identifier.fromToken(this.currentToken);\n                name.minChar = this.scanner.startPos;\n                name.limChar = this.scanner.pos;\n                this.currentToken = this.scanner.scan();\n            }\n            else {\n                this.reportParseError("Enum declaration requires identifier");\n                if (this.errorRecovery) {\n                    name = new MissingIdentifier();\n                    name.minChar = this.scanner.startPos;\n                    name.limChar = this.scanner.startPos;\n                    name.flags |= ASTFlags.Error;\n                }\n            }\n\n            var membersMinChar = this.scanner.startPos;\n            this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet | ErrorRecoverySet.ID);\n            this.pushDeclLists();\n            var members = new ASTList();\n            members.minChar = membersMinChar;\n            var mapDecl = new VarDecl(new Identifier("_map"), 0);\n            mapDecl.varFlags |= VarFlags.Exported;\n            mapDecl.varFlags |= VarFlags.Private;\n\n            // REVIEW: Is this still necessary?\n            mapDecl.varFlags |= (VarFlags.Property | VarFlags.Public);\n            mapDecl.init = new UnaryExpression(NodeType.ArrayLit, null);\n            members.append(mapDecl);\n            var lastValue: NumberLiteral = null;\n            for (; ;) {\n                var minChar = this.scanner.startPos;\n                var limChar;\n                var memberName: Identifier = null;\n';
var v27614 = v27615 + '                var memberValue: AST = null;\n                var preComments = null;\n                var postComments = null;\n\n                if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToIDName(this.currentToken)) {\n                    memberName = Identifier.fromToken(this.currentToken);\n                    memberName.minChar = this.scanner.startPos;\n                    memberName.limChar = this.scanner.pos;\n                }\n                else if (this.currentToken.tokenId == TokenID.CloseBrace) {\n                    break;\n                }\n                else {\n                    this.reportParseError("Expected identifer of enum member");\n                    if (this.errorRecovery) {\n                        memberName = new MissingIdentifier();\n                        memberName.minChar = this.scanner.startPos;\n                        memberName.limChar = this.scanner.startPos;\n                        memberName.flags |= ASTFlags.Error;\n                    }\n                }\n\n                limChar = this.scanner.pos;\n                preComments = this.parseComments();\n                this.currentToken = this.scanner.scan();\n                postComments = this.parseComments();\n\n                if (this.currentToken.tokenId == TokenID.Equals) {\n                    this.currentToken = this.scanner.scan();\n                    memberValue = this.parseExpr(errorRecoverySet, OperatorPrecedence.Comma, true,\n                                          TypeContext.NoTypes);\n                    lastValue = <NumberLiteral>memberValue;\n                    limChar = memberValue.limChar;\n                }\n                else {\n                    if (lastValue == null) {\n                        memberValue = new NumberLiteral(0);\n                        lastValue = <NumberLiteral>memberValue;\n                    }\n                    else {\n                        memberValue = new NumberLiteral(lastValue.value + 1);\n                        lastValue = <NumberLiteral>memberValue;\n                    }\n                    var map: BinaryExpression =\n                        new BinaryExpression(NodeType.Asg,\n                                             new BinaryExpression(NodeType.Index,\n                                                                  new Identifier("_map"),\n                                                                  memberValue),\n                                             new StringLiteral(\'"\' + memberName.actualText + \'"\'));\n                    members.append(map);\n                }\n                var member = new VarDecl(memberName, this.nestingLevel);\n                member.minChar = minChar;\n                member.limChar = limChar;\n                member.init = memberValue;\n                // Note: Leave minChar, limChar as "-1" on typeExpr as this is a parsing artifact.\n                member.typeExpr = new TypeReference(this.createRef(name.actualText, name.hasEscapeSequence, -1), 0);\n                member.varFlags |= (VarFlags.Readonly | VarFlags.Property);\n                if (memberValue.nodeType == NodeType.NumberLit) {\n                    member.varFlags |= VarFlags.Constant;\n                }\n                member.preComments = preComments;\n                members.append(member);\n                member.postComments = postComments;\n                // all enum members are exported\n                member.varFlags |= VarFlags.Exported;\n\n                if (this.currentToken.tokenId == TokenID.Comma) {\n                    this.currentToken = this.scanner.scan();\n                    member.postComments = this.combineComments(member.postComments, this.parseCommentsForLine(this.scanner.prevLine));\n                    if ((this.currentToken.tokenId == TokenID.Identifier) || (convertTokToIDName(this.currentToken))) {\n                        continue;\n                    }\n                }\n                break;\n            }\n            var endingToken = new ASTSpan();\n            endingToken.minChar = this.scanner.startPos;\n            endingToken.limChar = this.scanner.pos;\n\n            this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n            members.limChar = this.scanner.lastTokenLimChar();\n            var modDecl = new ModuleDeclaration(name, members, this.topVarList(), this.topScopeList(), endingToken);\n            modDecl.modFlags |= ModuleFlags.IsEnum;\n            this.popDeclLists();\n\n            modDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n            modDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n            return modDecl;\n        }\n\n        private parseDottedName(enclosedList: AST[]): void {\n            this.currentToken = this.scanner.scan();\n            if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                var id = Identifier.fromToken(this.currentToken);\n                id.preComments = this.parseCom';
var v27613 = v27614 + "ments();\n                enclosedList[enclosedList.length] = id;\n                id.minChar = this.scanner.startPos;\n                id.limChar = this.scanner.pos;\n                this.currentToken = this.scanner.scan();\n                if (this.currentToken.tokenId == TokenID.Dot) {\n                    this.parseDottedName(enclosedList);\n                }\n            }\n            else {\n                this.reportParseError(\"need identifier after '.'\");\n            }\n        }\n\n        // REVIEW: This is much more lenient than the spec - we're basically just checking to see if the\n        // path is rooted or contains an extension, not if it could potentially be a bogus file path\n        private isValidImportPath(importPath: string) {\n            importPath = stripQuotes(importPath);\n\n            if (!importPath ||\n                importPath.indexOf(':') != -1 || \n                importPath.indexOf('\\\\') != -1 ||\n                //(importPath.indexOf('.') != -1 && importPath.charAt(0) != '.') ||\n                importPath.charAt(0) == '/') {\n                return false;\n            }\n            return true;\n        }\n\n        private parseImportDeclaration(errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers): ImportDeclaration {\n\n            var name: Identifier = null;\n            var alias: AST = null;\n            var importDecl: ImportDeclaration = null;\n            var minChar = this.scanner.startPos;\n            var isDynamicImport = false;\n\n            this.currentToken = this.scanner.scan();\n\n            if (this.currentToken.tokenId == TokenID.Identifier || convertTokToID(this.currentToken, this.strictMode)) {\n                name = Identifier.fromToken(this.currentToken);\n            }\n            else {\n                this.reportParseError(\"Expected identifer after 'import'\");\n                name = new MissingIdentifier();\n            }\n\n            name.minChar = this.scanner.startPos;\n            name.limChar = this.scanner.pos;\n\n            this.currentToken = this.scanner.scan();\n\n            this.checkCurrentToken(TokenID.Equals, errorRecoverySet | ErrorRecoverySet.ID);\n\n            var aliasPreComments = this.parseComments();\n\n            var limChar;\n            if (this.currentToken.tokenId == TokenID.Identifier || convertTokToID(this.currentToken, this.strictMode)) {\n\n                if (this.currentToken.tokenId == TokenID.Module) {\n                    limChar = this.scanner.pos;\n                    this.currentToken = this.scanner.scan();\n                    if (this.currentToken.tokenId == TokenID.OpenParen) {\n                        this.currentToken = this.scanner.scan();\n\n                        if (this.currentToken.tokenId == TokenID.StringLiteral || this.currentToken.tokenId == TokenID.Identifier || convertTokToID(this.currentToken, this.strictMode)) {\n\n                            if (this.currentToken.tokenId == TokenID.StringLiteral) {\n\n                                if (this.topLevel) {\n                                    this.hasTopLevelImportOrExport = true;\n                                } else if (!this.allowImportDeclaration) {\n                                    this.reportParseError(\"Import declaration of external module is permitted only in global or top level dynamic modules\");\n                                }\n\n                                var aliasText = this.currentToken.getText();\n                                alias = Identifier.fromToken(this.currentToken);\n                                alias.minChar = this.scanner.startPos;\n                                alias.limChar = this.scanner.pos;\n\n                                if (!this.isValidImportPath((<Identifier>alias).text)) {\n                                    this.reportParseError(\"Invalid import path\");\n                                }\n\n                                isDynamicImport = true;\n                                this.currentToken = this.scanner.scan();\n                                    \n                                alias.preComments = aliasPreComments;\n                            }\n                            else {\n                                alias = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon,\n                                            OperatorPrecedence.Assignment, true,\n                                            TypeContext.NoTypes);\n                                    \n                                alias.preComments = aliasPreComments;\n                            }\n                        }\n\n                        limChar = this.scanner.pos;\n                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.ID);\n\n                        if (alias) {\n                            alias.postComments = this.parseComments();\n                        }\n                    }\n                }\n                else {\n                    alias = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon,\n                 ";
var v27612 = v27613 + '                           OperatorPrecedence.Assignment, true,\n                                            TypeContext.NoTypes);\n                    limChar = this.scanner.pos; // Include semicolon if needed\n                }\n            }\n            else {\n                this.reportParseError("Expected module name");\n                alias = new MissingIdentifier();\n                alias.minChar = this.scanner.startPos;\n                if (this.currentToken.tokenId == TokenID.Semicolon) {\n                    alias.limChar = this.scanner.startPos;\n                } else {\n                    alias.limChar = this.scanner.pos;\n                    this.currentToken = this.scanner.scan();\n                }\n                alias.flags |= ASTFlags.Error;\n                limChar = alias.limChar;\n            }\n\n            importDecl = new ImportDeclaration(name, alias);\n            importDecl.isDynamicImport = isDynamicImport;\n\n            importDecl.minChar = minChar;\n            importDecl.limChar = limChar;\n\n            return importDecl;\n        }\n\n        private parseModuleDecl(errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers, preComments: Comment[]): ModuleDeclaration {\n            var leftCurlyCount = this.scanner.leftCurlyCount;\n            var rightCurlyCount = this.scanner.rightCurlyCount;\n\n            var svAmbient = this.ambientModule;\n            var svTopLevel = this.topLevel;\n            this.topLevel = false;\n            if (this.parsingDeclareFile || svAmbient || hasFlag(modifiers, Modifiers.Ambient)) {\n                this.ambientModule = true;\n            }\n\n            this.currentToken = this.scanner.scan();\n            var name: AST = null;\n            var enclosedList: AST[] = null;\n            this.pushDeclLists();\n            var minChar = this.scanner.startPos;\n            var isDynamicMod = false;\n\n            if ((this.currentToken.tokenId == TokenID.Identifier) || (this.currentToken.tokenId == TokenID.StringLiteral) || (!isPrimitiveTypeToken(this.currentToken) && convertTokToID(this.currentToken, this.strictMode))) {\n                var nameText = this.currentToken.getText();\n\n                if (this.currentToken.tokenId == TokenID.StringLiteral) {\n                    isDynamicMod = true;\n                    if (!this.ambientModule) {\n                        this.reportParseError("Only ambient dynamic modules may have string literal names");\n                    }\n\n                    if (!svTopLevel) {\n                        this.reportParseError("Dynamic modules may not be nested within other modules");\n                    }\n                }\n\n                name = Identifier.fromToken(this.currentToken);\n                name.minChar = this.scanner.startPos;\n                name.limChar = this.scanner.pos;\n\n                this.currentToken = this.scanner.scan();\n            }\n            else if (this.currentToken.tokenId == TokenID.OpenBrace) {\n                this.reportParseError("Module name missing");\n                name = new Identifier("");\n                // "fake" position of where the ID would be\n                name.minChar = minChar;\n                name.limChar = minChar;\n            }\n\n            if (this.currentToken.tokenId == TokenID.Dot) {\n                enclosedList = new AST[];\n                this.parseDottedName(enclosedList);\n            }\n\n            if (name == null) {\n                name = new MissingIdentifier();\n            }\n\n            var moduleBody = new ASTList();\n            var bodyMinChar = this.scanner.startPos;\n            this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet | ErrorRecoverySet.ID);\n\n            if (svTopLevel && isDynamicMod) {\n                this.allowImportDeclaration = true;\n            } else {\n                this.allowImportDeclaration = false;\n            }\n            this.parseStatementList(\n                errorRecoverySet | ErrorRecoverySet.RCurly, moduleBody,\n                /*sourceElements:*/ true, /*noLeadingCase:*/ true, AllowedElements.Global, modifiers);\n            moduleBody.minChar = bodyMinChar;\n            moduleBody.limChar = this.scanner.pos;\n\n            var endingToken = new ASTSpan();\n            endingToken.minChar = this.scanner.startPos;\n            endingToken.limChar = this.scanner.pos;\n            this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n\n            var limChar = this.scanner.lastTokenLimChar();\n            var moduleDecl: ModuleDeclaration;\n\n            this.allowImportDeclaration = svTopLevel;\n\n            if (enclosedList && (enclosedList.length > 0)) {\n                var len = enclosedList.length;\n                var innerName = <Identifier>enclosedList[len - 1];\n                var innerDecl = new ModuleDeclaration(innerName, moduleBody, this.topVarList(),\n                                                this.topScopeList(), endingToken);\n                innerDecl.preComments = preComments;\n\n                if (this.parsingDeclareFile || hasFl';
var v27611 = v27612 + 'ag(modifiers, Modifiers.Ambient)) {\n                    innerDecl.modFlags |= ModuleFlags.Ambient;\n                }\n\n                innerDecl.modFlags |= ModuleFlags.Exported;\n\n                // REVIEW: will also possibly need to re-parent comments as well\n                innerDecl.minChar = minChar;\n                innerDecl.limChar = limChar;\n\n                this.popDeclLists();\n                var outerModBod: ASTList;\n                for (var i = len - 2; i >= 0; i--) {\n                    outerModBod = new ASTList();\n                    outerModBod.append(innerDecl);\n                    innerName = <Identifier>enclosedList[i];\n                    innerDecl = new ModuleDeclaration(innerName, outerModBod, new ASTList(),\n                                                new ASTList(), endingToken);\n                    outerModBod.minChar = innerDecl.minChar = minChar;\n                    outerModBod.limChar = innerDecl.limChar = limChar;\n\n                    if (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)) {\n                        innerDecl.modFlags |= ModuleFlags.Ambient;\n                    }\n\n                    innerDecl.modFlags |= ModuleFlags.Exported;\n                }\n                outerModBod = new ASTList();\n                outerModBod.append(innerDecl);\n                outerModBod.minChar = minChar;\n                outerModBod.limChar = limChar;\n                moduleDecl = new ModuleDeclaration(<Identifier>name, outerModBod, new ASTList(),\n                                            new ASTList(), endingToken);\n            }\n            else {\n                moduleDecl = new ModuleDeclaration(<Identifier>name, moduleBody, this.topVarList(), this.topScopeList(), endingToken);\n                moduleDecl.preComments = preComments;\n                this.popDeclLists();\n            }\n\n            if (this.parsingDeclareFile || svAmbient || hasFlag(modifiers, Modifiers.Ambient)) {\n                moduleDecl.modFlags |= ModuleFlags.Ambient;\n            }\n            if (svAmbient || hasFlag(modifiers, Modifiers.Exported)) {\n                moduleDecl.modFlags |= ModuleFlags.Exported;\n            }\n            if (isDynamicMod) {\n                moduleDecl.modFlags |= ModuleFlags.IsDynamic;\n            }\n\n            this.ambientModule = svAmbient;\n\n            this.topLevel = svTopLevel;\n            moduleDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n            moduleDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n            moduleDecl.limChar = moduleBody.limChar;\n            return moduleDecl;\n        }\n\n        private parseTypeReferenceTail(errorRecoverySet: ErrorRecoverySet, minChar: number, term: AST): TypeReference {\n            var result = new TypeReference(term, 0);\n            result.minChar = minChar;\n            while (this.currentToken.tokenId == TokenID.OpenBracket) {\n                this.currentToken = this.scanner.scan();\n                result.arrayCount++;\n                this.checkCurrentToken(TokenID.CloseBracket, errorRecoverySet | ErrorRecoverySet.LBrack);\n            }\n            result.limChar = this.scanner.lastTokenLimChar();\n            return result;\n        }\n\n        // REVIEW: Consider renaming to parseTypeName.\n        private parseNamedType(errorRecoverySet: ErrorRecoverySet, minChar: number, term: AST, tail: bool): AST {\n            this.currentToken = this.scanner.scan();\n            if (this.currentToken.tokenId == TokenID.Dot) {\n                var curpos = this.scanner.pos;\n                this.currentToken = this.scanner.scan();\n                // Don\'t allow reserved words if immediately after a new line and error recovery is enabled\n                if ((this.currentToken.tokenId == TokenID.Identifier) || ((!this.errorRecovery || !this.scanner.lastTokenHadNewline()) && convertTokToID(this.currentToken, this.strictMode))) {\n                    var op2 = Identifier.fromToken(this.currentToken);\n                    op2.minChar = this.scanner.startPos;\n                    op2.limChar = this.scanner.pos;\n                    var dotNode = new BinaryExpression(NodeType.Dot, term, op2);\n                    dotNode.minChar = term.minChar;\n                    dotNode.limChar = op2.limChar;\n                    return this.parseNamedType(errorRecoverySet, minChar,\n                                            dotNode, tail);\n                }\n                else {\n                    this.reportParseError("need identifier after \'.\'");\n                    if (this.errorRecovery) {\n                        term.flags |= ASTFlags.DotLHS;\n                        // We set "limChar" to be slightly innacurate for completion list behavior\n                        // (last AST node from "quickParse" will match DotLHS and be at end of file position)\n                        // This is to match the behavior of TokenId.Dot processing in parsePostfixOperators.\n                        term.limChar = this.scanner.las';
var v27610 = v27611 + 'tTokenLimChar();\n                        return term;\n                    }\n                    else {\n                        var eop2 = new MissingIdentifier();\n                        eop2.minChar = this.scanner.pos;\n                        eop2.limChar = this.scanner.pos;\n                        var edotNode = new BinaryExpression(NodeType.Dot, term, eop2);\n                        edotNode.flags |= ASTFlags.Error;\n                        edotNode.minChar = term.minChar;\n                        edotNode.limChar = eop2.limChar;\n                        return this.parseNamedType(errorRecoverySet, minChar,\n                                                edotNode, tail);\n                    }\n                }\n            }\n            else {\n                if (tail) {\n                    return this.parseTypeReferenceTail(errorRecoverySet, minChar, term);\n                }\n                else {\n                    return term;\n                }\n            }\n        }\n\n        // REVIEW: Reconsider renaming this to parseType to match the grammar.\n        private parseTypeReference(errorRecoverySet: ErrorRecoverySet, allowVoid: bool): AST {\n            var minChar = this.scanner.startPos;\n            var isConstructorMember = false;\n\n            switch (this.currentToken.tokenId) {\n                case TokenID.Void:\n                    if (!allowVoid) {\n                        this.reportParseError("void not a valid type in this context");\n                    }\n                // Intentional fall-through\n                case TokenID.Any:\n                case TokenID.Number:\n                case TokenID.Bool:\n                case TokenID.String: {\n                    var text = tokenTable[this.currentToken.tokenId].text;\n                    var predefinedIdentifier = new Identifier(text);\n                    predefinedIdentifier.minChar = minChar;\n                    predefinedIdentifier.limChar = this.scanner.pos;\n                    this.currentToken = this.scanner.scan();\n                    return this.parseTypeReferenceTail(errorRecoverySet, minChar, predefinedIdentifier);\n                }\n\n                case TokenID.Identifier:\n                    var ident = this.createRef(this.currentToken.getText(), (<IdentifierToken>this.currentToken).hasEscapeSequence, minChar);\n                    ident.limChar = this.scanner.pos;\n                    return this.parseNamedType(errorRecoverySet, minChar, ident, true);\n\n                case TokenID.OpenBrace:\n                    return this.parseObjectType(minChar, errorRecoverySet);\n\n                case TokenID.New:\n                    this.currentToken = this.scanner.scan();\n                    // can\'t use chkCurrentTok, since we don\'t want to advance the token\n                    if (this.currentToken.tokenId != TokenID.OpenParen) {\n                        this.reportParseError("Expected \'(\'");\n                    }\n                    else {\n                        isConstructorMember = true;\n                        // fall through...\n                    }\n\n                case TokenID.OpenParen: {\n                    // ( formals ) => type\n                    var formals = new ASTList();\n                    var variableArgList =\n                        this.parseFormalParameterList(errorRecoverySet | ErrorRecoverySet.RParen,\n                                            formals, false, true, false, false, false, false, null, true);\n                    this.checkCurrentToken(TokenID.EqualsGreaterThan, errorRecoverySet);\n                    var returnType = this.parseTypeReference(errorRecoverySet, true);\n                    var funcDecl = new FuncDecl(null, null, false, formals, null, null, null,\n                                                NodeType.FuncDecl);\n                    funcDecl.returnTypeAnnotation = returnType;\n                    funcDecl.variableArgList = variableArgList;\n                    funcDecl.fncFlags |= FncFlags.Signature;\n\n                    if (isConstructorMember) {\n                        funcDecl.fncFlags |= FncFlags.ConstructMember;\n                        funcDecl.hint = "_construct";\n                        funcDecl.classDecl = null;\n                    }\n                    funcDecl.minChar = minChar;\n                    return this.parseTypeReferenceTail(errorRecoverySet, minChar, funcDecl);\n                }\n\n                default:\n                    this.reportParseError("Expected type name");\n                    var etr = new TypeReference(null, 0);\n                    etr.flags |= ASTFlags.Error;\n                    etr.minChar = this.scanner.pos;\n                    etr.limChar = this.scanner.pos;\n                    return etr;\n            }\n        }\n\n        private parseObjectType(minChar: number, errorRecoverySet: ErrorRecoverySet): TypeReference {\n            this.currentToken = this.scanner.scan();\n\n            var members = new ASTList();\n            members.minChar = minChar;\n\n            var prevInInter';
var v27609 = v27610 + 'faceDecl = this.inInterfaceDecl;\n            this.inInterfaceDecl = true;\n            this.parseTypeMemberList(errorRecoverySet | ErrorRecoverySet.RCurly, members);\n            this.inInterfaceDecl = prevInInterfaceDecl;\n\n            this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n\n            // REVIEW: We\'re parsing an ObjectType, but we give a NodeType of Interface here.\n            var interfaceDecl = new InterfaceDeclaration(\n                this.anonId, members, /*extends:*/ null, /*implementsL*/ null);\n\n            interfaceDecl.minChar = minChar;\n            interfaceDecl.limChar = members.limChar;    // "}"\n\n            return this.parseTypeReferenceTail(errorRecoverySet, minChar, interfaceDecl);\n        }\n\n        private parseFunctionBlock(errorRecoverySet: ErrorRecoverySet,\n                                   allowedElements: AllowedElements,\n                                   parentModifiers: Modifiers,\n                                   bod: ASTList,\n                                   bodMinChar: number): void {\n            this.state = ParseState.StartStatementList;\n            this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet | ErrorRecoverySet.StmtStart);\n            var savedInFunction = this.inFunction;\n            this.inFunction = true;\n            this.parseStatementList(\n                errorRecoverySet | ErrorRecoverySet.RCurly | ErrorRecoverySet.StmtStart,\n                bod, /*sourceElements:*/ true, /*noLeadingCase:*/ false, allowedElements, parentModifiers);\n            bod.minChar = bodMinChar;\n            bod.limChar = this.scanner.pos;\n            this.inFunction = savedInFunction;\n            var ec = new EndCode();\n            ec.minChar = bod.limChar;\n            ec.limChar = ec.minChar;\n            bod.append(ec);\n        }\n\n        private parseFunctionStatements(errorRecoverySet: ErrorRecoverySet,\n                                        name: Identifier,\n                                        isConstructor: bool,\n                                        isMethod: bool,\n                                        args: ASTList,\n                                        allowedElements: AllowedElements,\n                                        minChar: number,\n                                        requiresSignature: bool,\n                                        parentModifiers: Modifiers) {\n\n            this.pushDeclLists();\n            // start new statement stack\n            var svStmtStack = this.statementInfoStack;\n            this.resetStmtStack();\n\n            var bod: ASTList = null;\n            var wasShorthand = false;\n            var isAnonLambda = false;\n            var limChar: number;\n\n            if (requiresSignature) {\n                // If we require a signature, but they provided a block, then give an error, but\n                // still consume the block.\n                limChar = this.scanner.pos;\n                if (this.currentToken.tokenId === TokenID.OpenBrace) {\n                    this.reportParseError("Function declarations are not permitted within interfaces, ambient modules or classes")\n                    bod = new ASTList();\n                    var bodMinChar = this.scanner.startPos;\n\n                    this.parseFunctionBlock(errorRecoverySet, allowedElements, parentModifiers, bod, bodMinChar);\n                    this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n\n                    // If there\'s also a semicolon, then just skip over it.  We don\'t want to report an \n                    // additional error here.\n                    if (this.currentToken.tokenId === TokenID.Semicolon) {\n                        this.currentToken = this.scanner.scan();\n                    }\n                }\n                else {\n                    this.checkCurrentToken(TokenID.Semicolon, errorRecoverySet, "Expected \';\'");\n                }\n            }\n            else {\n                bod = new ASTList();\n                var bodMinChar = this.scanner.startPos;\n                if (this.currentToken.tokenId == TokenID.EqualsGreaterThan) {\n                    if (isMethod) {\n                        this.reportParseError("\'=>\' may not be used for class methods");\n                    }\n                    wasShorthand = true;\n                    this.currentToken = this.scanner.scan();\n                }\n\n                if (wasShorthand && this.currentToken.tokenId != TokenID.OpenBrace) {\n                    var retExpr = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon,\n                                            OperatorPrecedence.Assignment, true,\n                                            TypeContext.NoTypes);\n                    var retStmt = new ReturnStatement();\n                    retStmt.returnExpression = retExpr;\n                    retStmt.minChar = retExpr.minChar;\n                    retStmt.limChar = retExpr.limChar;\n                    bod.minChar = bodMinChar;\n                    bod.append(retStmt);\n ';
var v27608 = v27609 + '               }\n                else {\n                    isAnonLambda = wasShorthand;\n                    this.parseFunctionBlock(errorRecoverySet, allowedElements, parentModifiers, bod, bodMinChar);\n                }\n\n                limChar = this.scanner.pos;\n            }\n\n            var funcDecl = new FuncDecl(name, bod, isConstructor, args, this.topVarList(),\n                                        this.topScopeList(), this.topStaticsList(), NodeType.FuncDecl);\n            this.popDeclLists();\n            var scopeList = this.topScopeList();\n            scopeList.append(funcDecl);\n            var staticFuncDecl = false;\n\n            if (!requiresSignature) {\n                if (!wasShorthand || isAnonLambda) {\n                    funcDecl.endingToken = new ASTSpan();\n                    funcDecl.endingToken.minChar = this.scanner.startPos;\n                    funcDecl.endingToken.limChar = this.scanner.pos;\n                    this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n\n                    if (isAnonLambda) {\n                        funcDecl.fncFlags |= FncFlags.IsFatArrowFunction;\n                    }\n                }\n                else {\n                    funcDecl.fncFlags |= FncFlags.IsFatArrowFunction;\n                    funcDecl.endingToken = new ASTSpan();\n\n                    funcDecl.endingToken.minChar = bod.members[0].minChar;\n                    funcDecl.endingToken.limChar = bod.members[0].limChar;\n                }\n            }\n            funcDecl.minChar = minChar;\n            funcDecl.limChar = limChar;\n\n            if (!requiresSignature) {\n                funcDecl.fncFlags |= FncFlags.Definition;\n            }\n\n            this.statementInfoStack = svStmtStack;\n            return funcDecl;\n        }\n\n        private transformAnonymousArgsIntoFormals(formals: ASTList, argList: AST) : bool {\n\n            var translateBinExOperand = (operand: AST) : bool => {\n                if (operand.nodeType == NodeType.Comma) {\n                    return this.transformAnonymousArgsIntoFormals(formals, operand);\n                }\n                else if (operand.nodeType == NodeType.Name || operand.nodeType == NodeType.Asg) {\n                    var opArg = operand.nodeType == NodeType.Asg ? (<BinaryExpression>operand).operand1 : operand;\n\n                    var arg = new ArgDecl(<Identifier>opArg);\n                    arg.preComments = opArg.preComments;\n                    arg.postComments = opArg.postComments;\n                    arg.minChar = operand.minChar;\n                    arg.limChar = operand.limChar;\n\n                    if (hasFlag(opArg.flags, ASTFlags.PossibleOptionalParameter)) {\n                        arg.isOptional = true;\n                    }\n\n                    if (operand.nodeType == NodeType.Asg) {\n                        arg.init = (<BinaryExpression>operand).operand2;\n                    }\n\n                    formals.append(arg);\n\n                    return arg.isOptional || arg.init;\n                }\n                else {\n                    this.reportParseError("Invalid lambda argument");\n                }\n                return false;\n            }\n\n            if (argList) {\n                if (argList.nodeType == NodeType.Comma) {\n                    var commaList = <BinaryExpression> argList;\n                    if (commaList.operand1.isParenthesized) { \n                        this.reportParseError("Invalid lambda argument", commaList.operand1.minChar, commaList.operand1.limChar);\n                    }\n                    if (commaList.operand2.isParenthesized) { \n                        this.reportParseError("Invalid lambda argument", commaList.operand2.minChar, commaList.operand2.limChar);\n                    }\n                    var isOptional = translateBinExOperand(commaList.operand1);\n                    isOptional = translateBinExOperand(commaList.operand2) || isOptional;\n                    return isOptional;\n                }\n                else {\n                    return translateBinExOperand(argList);\n                }\n            }\n        }\n\n        private parseFormalParameterList(errorRecoverySet: ErrorRecoverySet,\n                                            formals: ASTList,\n                                            isClassConstr: bool,\n                                            isSig: bool,\n                                            isIndexer: bool,\n                                            isGetter: bool,\n                                            isSetter: bool,\n                                            isLambda: bool,\n                                            preProcessedLambdaArgs: AST,\n                                            expectClosingRParen: bool): bool \n        {\n\n            formals.minChar = this.scanner.startPos; // \'(\' or \'[\'\n            if (isIndexer) {\n                this.currentToken = this.scanner.scan();\n            }\n            else if (!isLambda) {\n                this.ch';
var v27607 = v27608 + 'eckCurrentToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.RParen);\n            }\n            var sawEllipsis = false;\n            var firstArg = true;\n            var hasOptional = false;\n            var haveFirstArgID = false;\n\n            // if preProcessedLambdaArgs is "true", we either have a typeless argument list, or we have\n            // a single identifier node and the current token is the \':\' before a typereference\n            if (isLambda && preProcessedLambdaArgs && preProcessedLambdaArgs.nodeType != NodeType.EmptyExpr) {\n                hasOptional = this.transformAnonymousArgsIntoFormals(formals, preProcessedLambdaArgs);\n                haveFirstArgID = true;\n            }\n\n            while (true) {\n                var munchedArg = false;\n                var argFlags = VarFlags.None;\n                var argMinChar = this.scanner.startPos;\n\n                if (this.inferPropertiesFromThisAssignment && this.currentToken.tokenId == TokenID.This) {\n                    if (!isClassConstr) {\n                        this.reportParseError("Instance property declarations using \'this\' may only be used in class constructors");\n                    }\n                    this.currentToken = this.scanner.scan(); // consume the \'.\'\n\n                    argFlags |= (VarFlags.Public | VarFlags.Property);\n                    if (this.currentClassDefinition) {\n                        this.currentClassDefinition.varFlags |= VarFlags.ClassSuperMustBeFirstCallInConstructor;\n                    }\n                }\n                if (this.currentToken.tokenId == TokenID.Public) {\n                    argFlags |= (VarFlags.Public | VarFlags.Property);\n\n                    if (this.currentClassDefinition) {\n                        this.currentClassDefinition.varFlags |= VarFlags.ClassSuperMustBeFirstCallInConstructor;\n                    }\n                }\n                else if (this.currentToken.tokenId == TokenID.Private) {\n                    argFlags |= (VarFlags.Private | VarFlags.Property);\n\n                    if (this.currentClassDefinition) {\n                        this.currentClassDefinition.varFlags |= VarFlags.ClassSuperMustBeFirstCallInConstructor;\n                    }\n                }\n                else if (this.currentToken.tokenId == TokenID.Static && isClassConstr) {\n                    this.reportParseError("Static properties can not be declared as parameter properties");\n                    this.currentToken = this.scanner.scan();\n                }\n\n                if (argFlags != VarFlags.None) {\n                    if (!isClassConstr) {\n                        this.reportParseError("only constructor parameters can be properties");\n                    }\n                    this.currentToken = this.scanner.scan();\n\n                    if (isModifier(this.currentToken)) { \n                        this.reportParseError("Multiple modifiers may not be applied to parameters");\n                        this.currentToken = this.scanner.scan();\n                    }\n\n                    if (this.inferPropertiesFromThisAssignment && this.currentToken.tokenId == TokenID.This) {\n                        if (!isClassConstr) {\n                            this.reportParseError("Instance property declarations using \'this\' may only be used in class constructors");\n                        }\n                        this.currentToken = this.scanner.scan(); // consume the \'.\'\n                        this.currentToken = this.scanner.scan();\n                    }\n                }\n                else if (this.currentToken.tokenId == TokenID.DotDotDot) {\n                    sawEllipsis = true;\n                    this.currentToken = this.scanner.scan();\n\n                    if (!(this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                        this.reportParseError("\'...\' parameters require both a parameter name and an array type annotation to be specified");\n                        sawEllipsis = false; // Do not treat this parameter as vararg\n                    }\n                }\n\n                var argId: Identifier = null;\n\n                if (!haveFirstArgID && (this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                    argId = Identifier.fromToken(this.currentToken);\n                    argId.minChar = this.scanner.startPos;\n                    argId.limChar = this.scanner.pos;\n                }\n\n                if (haveFirstArgID || argId) {\n                    munchedArg = true;\n                    var type: AST = null;\n                    var arg: ArgDecl = null;\n\n                    if (haveFirstArgID && formals.members.length) {\n                        arg = <ArgDecl>formals.members[formals.members.length - 1];\n\n                        if (arg.isOptional) {\n                            hasOptional = true;\n                        }\n                    }\n         ';
var v27606 = v27607 + '           else {\n                        arg = new ArgDecl(argId);\n\n                        if (isGetter) {\n                            this.reportParseError("Property getters may not take any arguments");\n                        }\n\n                        if (isSetter && !firstArg) {\n                            this.reportParseError("Property setters may only take one argument");\n                        }\n\n                        arg.minChar = argMinChar;\n                        arg.preComments = this.parseComments();\n                        this.currentToken = this.scanner.scan();\n                    }\n\n                    if (this.currentToken.tokenId == TokenID.Question) {\n                        arg.isOptional = true;\n                        hasOptional = true;\n                        this.currentToken = this.scanner.scan();\n                    }\n\n                    if (this.currentToken.tokenId == TokenID.Colon) {\n                        this.currentToken = this.scanner.scan();\n                        type = this.parseTypeReference(errorRecoverySet, false);\n                    }\n\n                    // check for default parameter\n                    // REVIEW: In the case of a typed reference, assume that parseTypeReference or one\n                    // of its children in the call graph advanced tok\n                    if (this.currentToken.tokenId == TokenID.Equals) {\n                        if (isSig) {\n                            this.reportParseError("Arguments in signatures may not have default values");\n                        }\n\n                        hasOptional = true;\n                        this.currentToken = this.scanner.scan();\n                        arg.init = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                            OperatorPrecedence.Comma, false,\n                                            TypeContext.NoTypes);\n\n                    }\n\n                    if (hasOptional && !arg.isOptionalArg() && !sawEllipsis) {\n                        this.reportParseError("Optional parameters may only be followed by other optional parameters");\n                    }\n\n                    if (sawEllipsis && arg.isOptionalArg()) {\n                        this.reportParseError("Varargs may not be optional or have default parameters");\n                    }\n\n                    if (sawEllipsis && !type) {\n                        // Ellipsis is missing a type definition\n                        this.reportParseError("\'...\' parameters require both a parameter name and an array type annotation to be specified");\n                    }\n\n                    // REVIEW: Ok for lambdas?\n                    arg.postComments = this.parseComments();\n                    arg.typeExpr = type;\n                    arg.limChar = this.scanner.lastTokenLimChar();\n                    arg.varFlags |= argFlags;\n                    if (!haveFirstArgID) {\n                        formals.append(arg);\n                    }\n                    else {\n                        haveFirstArgID = false;\n                    }\n                }\n                firstArg = false;\n                if (this.currentToken.tokenId == TokenID.Comma) {\n                    if ((munchedArg) && (!sawEllipsis)) {\n                        this.currentToken = this.scanner.scan();\n                        continue;\n                    }\n                    else {\n                        this.reportParseError("Unexpected \',\' in argument list");\n                        if (this.errorRecovery) {\n                            this.currentToken = this.scanner.scan();\n                            continue;\n                        }\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n\n            if (isIndexer) {\n                this.checkCurrentToken(TokenID.CloseBracket, errorRecoverySet | ErrorRecoverySet.LCurly | ErrorRecoverySet.SColon);\n            }\n            else if (expectClosingRParen) {\n                this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.LCurly | ErrorRecoverySet.SColon);\n            }\n            formals.limChar = this.scanner.lastTokenLimChar(); // \')\' or \']\'\n            return sawEllipsis;\n        }\n\n        private parseFncDecl(errorRecoverySet: ErrorRecoverySet,\n                             isDecl: bool,\n                             requiresSignature: bool,\n                             isMethod: bool,\n                             methodName: Identifier,\n                             indexer: bool,\n                             isStatic: bool,\n                             markedAsAmbient: bool,\n                             modifiers: Modifiers,\n                             lambdaArgContext: ILambdaArgumentContext,\n                             expectClosingRParen: bool): AST {\n\n            var leftCurlyCount = this.scanner.leftCurlyCount;\n            var rightCurlyCount = this.scanner.rightCurlyC';
var v27605 = v27606 + 'ount;\n\n            var prevInConstr = this.parsingClassConstructorDefinition;\n            this.parsingClassConstructorDefinition = false;\n\n            var name: Identifier = null;\n            var fnMin = this.scanner.startPos;\n            var minChar = this.scanner.pos;\n            var prevNestingLevel = this.nestingLevel;\n            var preComments = this.parseComments();\n            var isLambda = !!lambdaArgContext;\n            this.nestingLevel = 0;\n            if ((!this.style_funcInLoop) && this.inLoop()) {\n                this.reportParseStyleError("function declaration in loop");\n            }\n            if (!isMethod && !isStatic && !indexer && !lambdaArgContext) {\n                // past function keyword\n                this.currentToken = this.scanner.scan();\n                this.state = ParseState.StartFncDecl;\n                if ((this.currentToken.tokenId != TokenID.Identifier) && (!convertTokToID(this.currentToken, this.strictMode))) {\n                    if (isDecl) {\n                        this.reportParseError("Function declaration must include identifier");\n\n                        this.nestingLevel = prevNestingLevel;\n                        return new IncompleteAST(fnMin, this.scanner.pos);\n                    }\n                }\n                else {\n                    name = Identifier.fromToken(this.currentToken);\n                    name.minChar = this.scanner.startPos;\n                    name.limChar = this.scanner.pos;\n                    this.currentToken = this.scanner.scan();\n                }\n            }\n            else {\n                if (methodName) {\n                    name = methodName;\n                }\n            }\n\n            this.state = ParseState.FncDeclName;\n            var args: ASTList = new ASTList();\n            var variableArgList = false;\n            var isOverload = false;\n            var isGetter = hasFlag(modifiers, Modifiers.Getter);\n            var isSetter = hasFlag(modifiers, Modifiers.Setter);\n            if ((this.currentToken.tokenId == TokenID.OpenParen) || (indexer && (this.currentToken.tokenId == TokenID.OpenBracket)) || (lambdaArgContext && (lambdaArgContext.preProcessedLambdaArgs || this.currentToken.tokenId == TokenID.DotDotDot))) {\n                // arg list\n                variableArgList = this.parseFormalParameterList(errorRecoverySet, args, false, requiresSignature, indexer, isGetter, isSetter, isLambda, lambdaArgContext ? lambdaArgContext.preProcessedLambdaArgs : null, expectClosingRParen);\n            }\n            this.state = ParseState.FncDeclArgs;\n            var returnType: AST = null;\n            if (this.currentToken.tokenId == TokenID.Colon) {\n                this.currentToken = this.scanner.scan();\n                if (hasFlag(modifiers, Modifiers.Setter)) {\n                    this.reportParseError("Property setters may not declare a return type");\n                }\n                returnType = this.parseTypeReference(errorRecoverySet, true);\n            }\n\n            if (indexer && args.members.length == 0) {\n                this.reportParseError("Index signatures require a parameter type to be specified");\n            }\n            this.state = ParseState.FncDeclReturnType;\n\n            if (isLambda && this.currentToken.tokenId != TokenID.EqualsGreaterThan) {\n                this.reportParseError("Expected \'=>\'");\n            }\n\n            // REVIEW:\n            // Currently, it\'s imperative that ambient functions *not* be marked as overloads.  At some point, we may\n            // want to unify the two concepts internally\n            if (isDecl && !(this.parsingDeclareFile || markedAsAmbient) && (!isMethod || !(this.ambientModule || this.ambientClass || this.inInterfaceDecl)) && this.currentToken.tokenId == TokenID.Semicolon) {\n                isOverload = true;\n                isDecl = false;\n                requiresSignature = true;\n            }\n            var svInFncDecl = this.inFncDecl;\n            this.inFncDecl = true;\n            var funcDecl: FuncDecl =\n                this.parseFunctionStatements(\n                errorRecoverySet | ErrorRecoverySet.RCurly,\n                name, /*isConstructor:*/ false, isMethod, args, AllowedElements.None,\n                minChar, requiresSignature, Modifiers.None);\n\n            this.inFncDecl = svInFncDecl;\n            funcDecl.variableArgList = variableArgList;\n            funcDecl.isOverload = isOverload;\n\n            if (!requiresSignature) { // REVIEW: What\'s the point of this?  Why not just use \'Signature\' instead of \'Definition\'?\n                funcDecl.fncFlags |= FncFlags.Definition;\n            }\n\n            if (isStatic) {\n                funcDecl.fncFlags |= FncFlags.Static;\n            }\n\n            if (requiresSignature) {\n                funcDecl.fncFlags |= FncFlags.Signature;\n            }\n            if (indexer) {\n                funcDecl.fncFlags |= FncFlags.IndexerMember;\n            }\n            funcDecl.returnTypeAnnotation = returnType;';
var v27604 = v27605 + '\n            if (isMethod) {\n                funcDecl.fncFlags |= FncFlags.Method;\n                // all class property methods are currently exported\n                funcDecl.fncFlags |= FncFlags.ClassPropertyMethodExported;\n            }\n            funcDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n            funcDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n\n            this.nestingLevel = prevNestingLevel;\n            this.parsingClassConstructorDefinition = prevInConstr;\n            funcDecl.preComments = preComments;\n            return funcDecl;\n        }\n\n        private convertToTypeReference(ast: AST): TypeReference {\n            var result: TypeReference;\n            switch (ast.nodeType) {\n                case NodeType.TypeRef:\n                    return <TypeReference>ast;\n                case NodeType.Name:\n                    result = new TypeReference(ast, 0);\n                    result.minChar = ast.minChar;\n                    result.limChar = ast.limChar;\n                    return result;\n                case NodeType.Index: {\n                    var expr = <BinaryExpression>ast;\n                    result = this.convertToTypeReference(expr.operand1);\n                    if (result) {\n                        result.arrayCount++;\n                        result.minChar = expr.minChar;\n                        result.limChar = expr.limChar;\n                        return result;\n                    }\n                    else {\n                        var etr = <TypeReference>new AST(NodeType.Error);\n                        return etr;\n                    }\n                }\n            }\n            return null;\n        }\n\n        private parseArgList(errorRecoverySet: ErrorRecoverySet): ASTList {\n            var args: ASTList = new ASTList();\n            args.minChar = this.scanner.startPos;\n\n            // skip left paren\n            this.currentToken = this.scanner.scan();\n\n            if (this.currentToken.tokenId !== TokenID.CloseParen) {\n                while (true) {\n                    if (args.members.length > 0xffff) {\n                        this.reportParseError("max number of args exceeded");\n                        break;\n                    }\n\n                    var arg = this.parseExpr(\n                        ErrorRecoverySet.Comma | errorRecoverySet,\n                        OperatorPrecedence.Comma, \n                        /*allowIn:*/ true,\n                        TypeContext.NoTypes);\n\n                    args.append(arg);\n                    if (this.currentToken.tokenId != TokenID.Comma) {\n                        break;\n                    }\n\n                    this.currentToken = this.scanner.scan();\n                }\n            }\n\n            args.limChar = this.scanner.pos;\n            return args;\n        }\n\n        private parseBaseList(extendsList: ASTList,\n                              implementsList: ASTList,\n                              errorRecoverySet: ErrorRecoverySet,\n                              isClass: bool): void {\n            var keyword = true;\n            var currentList = extendsList;\n            for (; ;) {\n                if (keyword) {\n                    if (this.currentToken.tokenId === TokenID.Implements) {\n                        currentList = implementsList;\n                    }\n                    else if (this.currentToken.tokenId == TokenID.Extends && !this.requiresExtendsBlock) {\n                        this.requiresExtendsBlock = isClass;\n                    }\n                    this.currentToken = this.scanner.scan();\n                    keyword = false;\n                }\n                var baseName: Identifier = null;\n                if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                    var minChar = this.scanner.startPos;\n                    baseName = Identifier.fromToken(this.currentToken);\n                    baseName.minChar = minChar;\n                    baseName.limChar = this.scanner.pos;\n                    baseName = <Identifier>this.parseNamedType(errorRecoverySet | ErrorRecoverySet.LCurly,\n                                            minChar, baseName, false);\n                }\n                else {\n                    this.reportParseError("Expected base name");\n                    if (this.errorRecovery) {\n                        baseName = new MissingIdentifier();\n                        baseName.minChar = this.scanner.pos;\n                        baseName.limChar = this.scanner.pos;\n                        baseName.flags |= ASTFlags.Error;\n                    }\n                }\n                if (this.currentToken.tokenId == TokenID.OpenParen) {\n                    if (isClass) {\n                        this.reportParseError("Base classes may only be initialized via a \'super\' call within the constructor body");\n                    }\n                    else {\n                        th';
var v27603 = v27604 + 'is.reportParseError("Interfaces may not be extended with a call expression");\n                    }\n                }\n                else {\n                    currentList.append(baseName);\n                }\n\n                if (isClass && currentList == extendsList && extendsList.members.length > 1) {\n                    this.reportParseError("A class may only extend one other class");\n                }\n\n                if (this.currentToken.tokenId == TokenID.Comma) {\n                    this.currentToken = this.scanner.scan();\n                    continue;\n                }\n\n                else if ((this.currentToken.tokenId == TokenID.Extends) ||\n                         (this.currentToken.tokenId == TokenID.Implements)) {\n\n                    if (this.currentToken.tokenId == TokenID.Extends && !this.requiresExtendsBlock) {\n                        this.requiresExtendsBlock = isClass;\n                    }\n\n                    currentList = extendsList;\n                    keyword = true;\n                    continue;\n                }\n\n                break;\n            }\n        }\n\n        private parseClassDecl(errorRecoverySet: ErrorRecoverySet, minChar: number, modifiers: Modifiers): ClassDeclaration {\n            var leftCurlyCount = this.scanner.leftCurlyCount;\n            var rightCurlyCount = this.scanner.rightCurlyCount;\n\n            if ((modifiers & Modifiers.Readonly) != Modifiers.None) {\n                this.reportParseError("const modifier is implicit for class");\n            }\n\n            // mark the class as ambient, as necessary\n            if (this.parsingDeclareFile || this.ambientModule) {\n                modifiers |= Modifiers.Ambient;\n                modifiers |= Modifiers.Exported;\n            }\n            var classIsMarkedAsAmbient = this.parsingDeclareFile || (modifiers & Modifiers.Ambient) != Modifiers.None;\n            var svAmbientClass = this.ambientClass;\n            this.ambientClass = classIsMarkedAsAmbient;\n\n            // grab the class\'s name\n            this.currentToken = this.scanner.scan();\n            var name: Identifier = null;\n            if ((this.currentToken.tokenId == TokenID.Identifier) || (!isPrimitiveTypeToken(this.currentToken) && convertTokToID(this.currentToken, this.strictMode)) ) {\n                name = Identifier.fromToken(this.currentToken);\n                name.minChar = this.scanner.startPos;\n                name.limChar = this.scanner.pos;\n                this.currentToken = this.scanner.scan();\n            }\n            else {\n                this.reportParseError("class missing name");\n                if (this.errorRecovery) {\n                    name = new MissingIdentifier();\n                    name.minChar = this.scanner.pos;\n                    name.limChar = this.scanner.pos;\n                    name.flags |= ASTFlags.Error;\n                }\n            }\n\n            var extendsList: ASTList = null;\n            var implementsList: ASTList = null;\n            var requiresSignature = false;\n\n            if ((this.currentToken.tokenId == TokenID.Extends) ||\n                (this.currentToken.tokenId == TokenID.Implements)) {\n                extendsList = new ASTList();\n                implementsList = new ASTList();\n                this.parseBaseList(extendsList, implementsList, errorRecoverySet, /*isClass:*/ true);\n            }\n\n            // REVIEW: Note that we don\'t set this as the current class decl\n            var classDecl = new ClassDeclaration(name, new ASTList(), extendsList, implementsList);\n\n            this.currentClassDefinition = classDecl;\n\n            // parse the classes members\n            this.parseClassElements(classDecl, errorRecoverySet, modifiers);\n\n            if (this.ambientModule || this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Exported)) {\n                classDecl.varFlags |= VarFlags.Exported;\n            }\n\n            if (this.ambientModule || hasFlag(modifiers, Modifiers.Ambient)) {\n                classDecl.varFlags |= VarFlags.Ambient;\n            }\n\n            classDecl.varFlags |= VarFlags.Class;\n\n            this.ambientClass = svAmbientClass;\n            classDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n            classDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n            return classDecl;\n        }\n\n        private parseClassElements(classDecl: ClassDeclaration, errorRecoverySet: ErrorRecoverySet, parentModifiers: Modifiers) {\n            var modifiers = parentModifiers;\n            var resetModifiers = false;\n\n            var membersMinChar = this.scanner.startPos;\n            this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet);\n\n            this.nestingLevel++;\n\n            var currentMemberMinChar = this.scanner.startPos;\n            var wasGetOrSetId = false;\n\n            while (!(this.currentToken.tokenId == TokenID.CloseBrace || this.currentToken.tokenId == TokenID.EndOfFile)) {\n                var scanNext = true;';
var v27602 = v27603 + '\n                var publicOrPrivateFlags = Modifiers.Public | Modifiers.Private;\n\n                // modifiers\n                if (this.currentToken.tokenId == TokenID.Get) {\n                    if (modifiers & Modifiers.Getter) {\n                        this.reportParseError("Duplicate \'get\' declaration in class body");\n                    }\n                    if (modifiers & Modifiers.Setter) {\n                        this.reportParseError("Getter already marked as a setter");\n                    }\n                    modifiers |= Modifiers.Getter;\n                }\n                else if (this.currentToken.tokenId == TokenID.Set) {\n                    if (modifiers & Modifiers.Setter) {\n                        this.reportParseError("Duplicate \'set\' declaration in class body");\n                    }\n                    if (modifiers & Modifiers.Getter) {\n                        this.reportParseError("Setter already marked as a getter");\n                    }\n                    modifiers |= Modifiers.Setter;\n\n                }\n                else if (this.currentToken.tokenId == TokenID.Private) {\n                    if (modifiers & publicOrPrivateFlags) {\n                        this.reportParseError("Multiple modifiers may not be applied to class members");\n                    }\n                    modifiers |= Modifiers.Private;\n                }\n                else if (this.currentToken.tokenId == TokenID.Public) {\n                    if (modifiers & publicOrPrivateFlags) {\n                        this.reportParseError("Multiple modifiers may not be applied to class members");\n                    }\n                    modifiers |= Modifiers.Public;\n                }\n                else if (this.currentToken.tokenId == TokenID.Static) {\n                    if (modifiers & Modifiers.Static) { // only check for double instances of static\n                        this.reportParseError("Multiple modifiers may not be applied to class members");\n                    }\n                    modifiers |= Modifiers.Static;\n                }  // constructors\n                else if (this.currentToken.tokenId == TokenID.Constructor) {\n\n                    if (modifiers != parentModifiers) {\n                        this.reportParseError("Constructors may not have modifiers");\n                    }\n\n                    this.parseClassConstructorDeclaration(currentMemberMinChar, errorRecoverySet, modifiers);\n                    scanNext = false; // parsing functions advances the token for us\n                    resetModifiers = true;\n                }  // member declarations\n                else if (wasGetOrSetId || this.currentToken.tokenId == TokenID.Identifier || convertTokToIDName(this.currentToken)) {\n\n                    var idText = wasGetOrSetId ? ((modifiers & Modifiers.Getter) ? "get" : "set") : this.currentToken.getText();\n                    var id = wasGetOrSetId ? new Identifier(idText) : Identifier.fromToken(this.currentToken);\n                    id.minChar = this.scanner.startPos;\n                    id.limChar = this.scanner.pos;\n\n                    // unset the get/set bit, if we\'re using it for an id\n                    if (wasGetOrSetId) {\n                        modifiers = modifiers ^ ((modifiers & Modifiers.Getter) ? Modifiers.Getter : Modifiers.Setter);\n                        wasGetOrSetId = false;\n                    }\n                    else {\n                        this.currentToken = this.scanner.scan();\n                    }\n\n                    if (this.currentToken.tokenId == TokenID.OpenParen) {\n                        this.parseClassMemberFunctionDeclaration(id, currentMemberMinChar, errorRecoverySet, modifiers);\n                        scanNext = false; // parsing functions advances the token for us\n                    }\n                    else {\n                        if (modifiers & Modifiers.Getter || modifiers & Modifiers.Setter) {\n                            this.reportParseError("Property accessors must be functions");\n                        }\n\n                        var varDecl = this.parseClassMemberVariableDeclaration(id, currentMemberMinChar, false, errorRecoverySet, modifiers);\n\n                        if (varDecl.init && varDecl.init.nodeType == NodeType.FuncDecl) {\n                            if (this.currentToken.tokenId == TokenID.CloseBrace) {\n                                scanNext = false;\n                            }\n                        }\n                        else if (varDecl.init && varDecl.init.nodeType == NodeType.ObjectLit && this.currentToken.tokenId != TokenID.Semicolon) {\n                            scanNext = false;\n                            varDecl.init.flags |= ASTFlags.AutomaticSemicolon;\n                        }\n                        else if (this.currentToken.tokenId != TokenID.Semicolon) {\n                            this.reportParseError("Expected \';\'");\n                            scanNext = false;\n                        }';
var v27601 = v27602 + "\n                    }\n\n                    resetModifiers = true;\n                } // catch errant uses of 'super'\n                else if (this.currentToken.tokenId == TokenID.Super) {\n                    this.reportParseError(\"Base class initializers must be the first statement in a class definition\");\n                }\n                else if (!wasGetOrSetId && ((modifiers & Modifiers.Getter) || (modifiers & Modifiers.Setter)) &&\n                         ((this.currentToken.tokenId == TokenID.OpenParen) || (this.currentToken.tokenId == TokenID.Equals) ||\n                          (this.currentToken.tokenId == TokenID.Colon) || (this.currentToken.tokenId == TokenID.Semicolon))) {\n                             // catch a 'get' or 'set' used as an identifier\n                    wasGetOrSetId = true;\n                    scanNext = false;\n\n                }  // mark anything else as an error\n                else if (this.currentToken.tokenId != TokenID.Semicolon) { // jettison semicolons\n                    this.reportParseError(\"Unexpected '\" + this.currentToken.getText() + \"' in class definition\");\n                    resetModifiers = true;\n                }\n\n                if (scanNext) {\n                    this.currentToken = this.scanner.scan();\n                }\n\n                if (resetModifiers) {\n                    modifiers = parentModifiers;\n                    currentMemberMinChar = this.scanner.startPos;\n                    resetModifiers = false;\n                }\n            }\n\n            var membersLimChar = this.scanner.pos;\n            if (this.currentToken.tokenId == TokenID.CloseBrace) {\n                classDecl.endingToken = new ASTSpan();\n                classDecl.endingToken.minChar = this.scanner.startPos;\n                classDecl.endingToken.limChar = this.scanner.pos;\n\n                // for a class with an empty body, consume any 'dangling' inner comments\n                if (!this.currentClassDefinition.members.members.length) {\n                    this.currentClassDefinition.preComments = this.parseComments();\n                }\n\n                this.currentToken = this.scanner.scan();\n            }\n\n            this.nestingLevel--;\n\n            this.currentClassDefinition.members.minChar = membersMinChar;\n            this.currentClassDefinition.members.limChar = membersLimChar;\n            this.currentClassDefinition.limChar = membersLimChar;\n            this.currentClassDefinition = null;\n        }\n\n        private parseClassConstructorDeclaration(minChar: number, errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers) {\n            this.parsingClassConstructorDefinition = true;\n\n            var isAmbient = this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient);\n\n            var args: ASTList = new ASTList();\n            var variableArgList = false;\n            var preComments = this.parseComments();\n\n            this.currentToken = this.scanner.scan(); // scan past the 'constructor' token\n\n            if (this.currentToken.tokenId == TokenID.OpenParen) {\n                variableArgList = this.parseFormalParameterList(errorRecoverySet, args, true, isAmbient, false, false, false, false, null, true);\n                if (args.members.length > 0) {\n                    var lastArg = args.members[args.members.length - 1];\n                }\n            }\n\n            var requiresSignature = isAmbient || this.currentToken.tokenId == TokenID.Semicolon;\n\n\n            if (requiresSignature) {\n                for (var i = 0; i < args.members.length; i++) {\n                    var arg = <ArgDecl> args.members[i];\n                    if (hasFlag(arg.varFlags, VarFlags.Property)) {\n                        this.reportParseError(\"Overload or ambient signatures may not specify parameter properties\", arg.minChar, arg.limChar);\n                    }\n                }\n            }\n\n            if (!requiresSignature) {\n                this.currentClassDefinition.constructorNestingLevel = this.nestingLevel + 1;\n            }\n\n            var constructorFuncDecl = this.parseFunctionStatements(\n                errorRecoverySet | ErrorRecoverySet.RCurly, this.currentClassDefinition.name, \n                /*isConstructor:*/ true, /*isMethod:*/ false, args, AllowedElements.Properties, \n                minChar, requiresSignature, modifiers);\n\n            constructorFuncDecl.preComments = preComments;\n\n            if (requiresSignature && !isAmbient) {\n                constructorFuncDecl.isOverload = true;\n            }\n\n            constructorFuncDecl.variableArgList = variableArgList;\n            this.currentClassDecl = null;\n            constructorFuncDecl.returnTypeAnnotation = this.convertToTypeReference(this.currentClassDefinition.name);\n            constructorFuncDecl.classDecl = this.currentClassDefinition;\n\n            if (isAmbient) {\n                constructorFuncDecl.fncFlags |= FncFlags.Ambient;\n            }\n\n            if (requiresSignature) {\n                constructorF";
var v27600 = v27601 + 'uncDecl.fncFlags |= FncFlags.Signature;\n            }\n\n            if (this.ambientModule || hasFlag(modifiers, Modifiers.Exported)) {\n                constructorFuncDecl.fncFlags |= FncFlags.Exported;\n            }\n\n\n            if (this.currentClassDefinition.constructorDecl) {\n                if (!isAmbient && !this.currentClassDefinition.constructorDecl.isSignature() && !constructorFuncDecl.isSignature()) {\n                    this.reportParseError("Duplicate constructor definition");\n                }\n            }\n\n            if (isAmbient || !constructorFuncDecl.isSignature()) {\n                this.currentClassDefinition.constructorDecl = constructorFuncDecl;\n            }\n\n            // REVIEW: Should we have a separate flag for class constructors?  (Constructors are not methods)\n            constructorFuncDecl.fncFlags |= FncFlags.ClassMethod;\n\n            this.currentClassDefinition.members.members[this.currentClassDefinition.members.members.length] = constructorFuncDecl;\n\n            this.parsingClassConstructorDefinition = false;\n\n            return constructorFuncDecl;\n        }\n\n        private parseClassMemberVariableDeclaration(text: Identifier, minChar: number, isDeclaredInConstructor: bool, errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers) {\n\n            var varDecl = new VarDecl(text, this.nestingLevel);\n            varDecl.minChar = minChar;\n            var isStatic = false;\n            varDecl.preComments = this.parseComments();\n\n            if (this.currentToken.tokenId == TokenID.Colon) {\n                this.currentToken = this.scanner.scan();\n                varDecl.typeExpr =\n                    this.parseTypeReference(errorRecoverySet | ErrorRecoverySet.Asg | ErrorRecoverySet.Comma, false);\n                if (varDecl.typeExpr && varDecl.typeExpr.nodeType == NodeType.TypeRef) {\n                    var typeExpr = (<TypeReference>varDecl.typeExpr);\n                    if (typeExpr.term && typeExpr.term.nodeType == NodeType.FuncDecl) {\n                        typeExpr.term.preComments = varDecl.preComments;\n                    }\n                }\n            }\n\n            if (this.currentToken.tokenId == TokenID.Equals) {\n                if (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)) {\n                    this.reportParseError("context does not permit variable initializer");\n                    if (this.errorRecovery) {\n                        this.skip(errorRecoverySet);\n                        varDecl.flags |= ASTFlags.Error;\n                        varDecl.limChar = this.scanner.lastTokenLimChar();\n                        return varDecl;\n                    }\n                }\n\n                // TODO: note assignment for language service\n                this.currentToken = this.scanner.scan();\n\n                varDecl.init = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                        OperatorPrecedence.Comma, true, TypeContext.NoTypes);\n\n                varDecl.limChar = varDecl.init.limChar;\n\n                // member initializers on instance properties require that super be invoked as the first call within the constructor\n                if (!(modifiers & Modifiers.Static)) {\n                    this.currentClassDefinition.varFlags |= VarFlags.ClassSuperMustBeFirstCallInConstructor;\n                }\n            }\n            else {\n                varDecl.limChar = this.scanner.pos;\n            }\n\n            if (modifiers & Modifiers.Static) {\n                varDecl.varFlags |= VarFlags.Static;\n                isStatic = true;\n            }\n\n            if ((modifiers & Modifiers.Private) != Modifiers.None) {\n                varDecl.varFlags |= VarFlags.Private;\n            }\n            else {\n                varDecl.varFlags |= VarFlags.Public;\n            }\n\n            varDecl.varFlags |= VarFlags.Property;\n\n            if (isDeclaredInConstructor) {\n                varDecl.varFlags |= VarFlags.ClassConstructorProperty;\n            }\n\n            if (!isDeclaredInConstructor && !isStatic) {\n                varDecl.varFlags |= VarFlags.ClassBodyProperty;\n            }\n\n            this.currentClassDefinition.knownMemberNames[text.actualText] = true;\n\n            if (!isDeclaredInConstructor) {\n                this.currentClassDefinition.members.members[this.currentClassDefinition.members.members.length] = varDecl;\n            }\n\n            varDecl.postComments = this.parseComments();\n            return varDecl;\n        }\n\n        private parseClassMemberFunctionDeclaration(methodName: Identifier, minChar: number, errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers) {\n            var wasAccessorID = this.prevIDTok != null;\n            var isAccessor = hasFlag(modifiers, Modifiers.Getter) || hasFlag(modifiers, Modifiers.Setter);\n            var isStatic = hasFlag(modifiers, Modifiers.Static);\n\n            var isAmbient = this.ambientModule || hasFlag(modifiers, Modifiers.Ambient);\n\n            er';
var v27599 = v27600 + 'rorRecoverySet |= ErrorRecoverySet.RParen;\n\n            if (isAccessor && (modifiers & Modifiers.Ambient)) {\n                this.reportParseError("Property accessors may not be declared in ambient classes");\n            }\n\n            // REVIEW: Why bother passing in isAmbient for both requiresSignature and isAmbient?  Shouldn\'t just saying its ambient suffice?\n            var ast: AST = this.parseFncDecl(errorRecoverySet, true, isAmbient, true, methodName, false, isStatic, isAmbient, modifiers, null, true);\n            if (ast.nodeType == NodeType.Error) {\n                return ast;\n            }\n\n            var funcDecl = <FuncDecl>ast;\n\n            funcDecl.minChar = minChar;\n            if (funcDecl.bod !== null)\n                funcDecl.limChar = funcDecl.bod.limChar;\n\n            if (modifiers & Modifiers.Private) {\n                funcDecl.fncFlags |= FncFlags.Private;\n            }\n            else {\n                funcDecl.fncFlags |= FncFlags.Public;\n            }\n\n            if (isStatic) {\n                funcDecl.fncFlags |= FncFlags.Static;\n            }\n\n            if (isAccessor) {\n                // REVIEW: verify return-type annotations and arguments\n                if (hasFlag(modifiers, Modifiers.Getter)) {\n                    funcDecl.fncFlags |= FncFlags.GetAccessor;\n                    funcDecl.hint = "get" + funcDecl.name.actualText;\n                }\n                else {\n                    funcDecl.fncFlags |= FncFlags.SetAccessor;\n                    funcDecl.hint = "set" + funcDecl.name.actualText;\n                }\n                funcDecl.fncFlags |= FncFlags.IsFunctionExpression;\n                if (codeGenTarget < CodeGenTarget.ES5) {\n                    this.reportParseError("Property accessors are only available when targeting ES5 or greater", funcDecl.minChar, funcDecl.limChar);\n                }\n            }\n\n            funcDecl.fncFlags |= FncFlags.ClassMethod;\n\n            this.currentClassDefinition.knownMemberNames[methodName.actualText] = true;\n\n            this.currentClassDefinition.members.members[this.currentClassDefinition.members.members.length] = funcDecl;\n\n            return funcDecl;\n        }\n\n        private parseTypeMember(errorRecoverySet: ErrorRecoverySet): AST {\n            var minChar = this.scanner.startPos;\n\n            var propertyDecl = this.parsePropertyDeclaration(\n                errorRecoverySet, Modifiers.Public, /*requireSignature:*/ true, /*isStatic:*/ false);\n\n            if (propertyDecl) {\n                propertyDecl.minChar = minChar;\n\n                if (propertyDecl.nodeType == NodeType.VarDecl) {\n                     this.checkCurrentToken(TokenID.Semicolon, errorRecoverySet);\n                }\n            }\n\n            return propertyDecl;\n        }\n\n        private parseTypeMemberList(errorRecoverySet: ErrorRecoverySet, members: ASTList) {\n            errorRecoverySet |= ErrorRecoverySet.TypeScriptS;\n            while (true) {\n                switch (this.currentToken.tokenId) {\n                    case TokenID.CloseBrace:\n                    case TokenID.EndOfFile:\n                        members.limChar = this.scanner.pos;\n                        return;\n                }\n\n                // REVIEW: This code looks suspect.  If parseTypeMember returns null, then \n                // won\'t we just infinite loop?\n                var element = this.parseTypeMember(errorRecoverySet);\n                if (element) {\n                    members.append(element);\n                }\n            }\n        }\n\n        private parseInterfaceDecl(errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers): InterfaceDeclaration {\n            var leftCurlyCount = this.scanner.leftCurlyCount;\n            var rightCurlyCount = this.scanner.rightCurlyCount;\n\n            this.currentToken = this.scanner.scan();\n            var minChar = this.scanner.pos;\n            var name: Identifier = null;\n            if ((this.currentToken.tokenId == TokenID.Identifier) || (!isPrimitiveTypeToken(this.currentToken) && convertTokToID(this.currentToken, this.strictMode))) {\n                name = Identifier.fromToken(this.currentToken);\n                name.minChar = this.scanner.startPos;\n                name.limChar = this.scanner.pos;\n                this.currentToken = this.scanner.scan();\n            }\n            else {\n                this.reportParseError("interface missing name");\n                if (this.errorRecovery) {\n                    name = new MissingIdentifier();\n                    name.minChar = this.scanner.pos;\n                    name.limChar = this.scanner.pos;\n                    name.flags |= ASTFlags.Error;\n                }\n            }\n\n            var extendsList: ASTList = null;\n            var implementsList: ASTList = null;\n            if (this.currentToken.tokenId === TokenID.Extends || this.currentToken.tokenId === TokenID.Implements) {\n                if (this.currentToken.tokenId === TokenID.Implements) {\n            ';
var v27598 = v27599 + '        this.reportParseError("Expected \'extends\'");\n                }\n\n                extendsList = new ASTList();\n                implementsList = new ASTList();\n                extendsList.minChar = this.scanner.startPos;\n                this.parseBaseList(extendsList, implementsList, errorRecoverySet, /*isClass:*/ false);\n            }\n\n            var membersMinChar = this.scanner.startPos;\n            this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet | ErrorRecoverySet.TypeScriptS);\n            var members = new ASTList();\n            members.minChar = membersMinChar;\n            var prevInInterfaceDecl = this.inInterfaceDecl;\n            this.inInterfaceDecl = true;\n            this.parseTypeMemberList(errorRecoverySet | ErrorRecoverySet.RCurly, members);\n            this.inInterfaceDecl = prevInInterfaceDecl;\n            this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n\n            // REVIEW: According to the grammar, an interface declaration should actually just\n            // have an \'ObjectType\' and not a list of members.  We may want to consider making that\n            // change.  Note: it would mean breaking aparat TypeDecl into InterfaceDeclaration and \n            // ClassDeclaration.\n            var interfaceDecl = new InterfaceDeclaration(name, members, extendsList, null);\n            if (hasFlag(modifiers, Modifiers.Private)) {\n                interfaceDecl.varFlags |= VarFlags.Private;\n            }\n            if (hasFlag(modifiers, Modifiers.Public)) {\n                interfaceDecl.varFlags |= VarFlags.Public;\n            }\n            if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Exported)) {\n                interfaceDecl.varFlags |= VarFlags.Exported;\n            }\n\n            interfaceDecl.limChar = members.limChar;\n            interfaceDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n            interfaceDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n            return interfaceDecl;\n        }\n\n        private makeVarDecl(id: Identifier, nest: number): VarDecl {\n            var varDecl = new VarDecl(id, nest);\n            var currentVarList = this.topVarList();\n            if (currentVarList) {\n                currentVarList.append(varDecl);\n            }\n            return varDecl;\n        }\n\n        private parsePropertyDeclaration(\n            errorRecoverySet: ErrorRecoverySet,\n            modifiers: Modifiers,\n            requireSignature: bool,\n            isStatic: bool): AST {\n\n            var text: Identifier = null;\n            var minChar = this.scanner.startPos;\n            var nameLimChar = minChar;\n            var isNew = false;\n            var isIndexer = false;\n            var wasAccessorID = this.prevIDTok != null;\n            var isAccessor = hasFlag(modifiers, Modifiers.Getter) || hasFlag(modifiers, Modifiers.Setter);\n\n            if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Ambient)) {\n                requireSignature = true;\n            }\n\n            if (this.currentToken.tokenId == TokenID.OpenParen && !wasAccessorID) {\n                if (!requireSignature && !isStatic) {\n                    this.reportParseError("Expected identifier in property declaration");\n                    if (this.errorRecovery) {\n                        this.skip(errorRecoverySet);\n                        //REVIEW: Use something else than "Identifier"?\n                        text = new MissingIdentifier();\n                    }\n                }\n            }\n            else if (this.currentToken.tokenId == TokenID.New) {\n                if (requireSignature) {\n                    this.currentToken = this.scanner.scan();\n                    if (this.currentToken.tokenId == TokenID.OpenParen) {\n                        isNew = true;\n                    }\n                }\n\n                if (!isNew) {\n                    // is identifier\n                    if (!requireSignature) {\n                        this.currentToken = this.scanner.scan();\n                    }\n                    text = new Identifier("new");\n                    text.minChar = this.scanner.pos - 3;\n                    text.limChar = this.scanner.pos;\n                    nameLimChar = this.scanner.pos;\n                }\n            }\n            else if ((this.currentToken.tokenId == TokenID.OpenBracket) && requireSignature) {\n                // indexer signature\n                isIndexer = true;\n                //REVIEW: Should we use a special "compiler reserved" identifier node?\n                text = new Identifier("__item");\n            }\n            else if ((this.currentToken.tokenId != TokenID.Identifier) && (!convertTokToIDName(this.currentToken)) && !wasAccessorID) {\n                this.reportParseError("Expected identifier in property declaration");\n                if (this.errorRecovery) {\n                    var eminChar = this.scanner.startPos;\n             ';
var v27597 = v27598 + '       var curpos = this.scanner.pos;\n                    this.skip(errorRecoverySet & (~ErrorRecoverySet.Comma));\n                    if (this.scanner.pos == curpos) {\n                        // ensure progress\n                        this.currentToken = this.scanner.scan();\n                    }\n\n                    var epd = new VarDecl(new MissingIdentifier(), this.nestingLevel);\n                    epd.flags |= ASTFlags.Error;\n                    epd.minChar = eminChar;\n                    epd.limChar = this.scanner.lastTokenLimChar();\n                    return epd;\n                }\n            }\n            else {\n                if (wasAccessorID) {\n                    text = Identifier.fromToken(this.prevIDTok);\n                    text.minChar = this.scanner.lastTokenLimChar() - 3;\n                    text.limChar = this.scanner.lastTokenLimChar();\n                    nameLimChar = text.limChar;\n\n                    if (codeGenTarget < CodeGenTarget.ES5) {\n                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                    }\n\n                    // this block guards against \'get\' and \'set\' tokens that\n                    // were coerced into identifiers\n                    if (this.currentToken.getText() == text.actualText && this.currentToken != this.prevIDTok) {\n                        this.currentToken = this.scanner.scan();\n                    } // Otherwise, don\'t update the token - we\'re already at \'(\'\n\n                    // reset the previous ID Token\n                    this.prevIDTok = null;\n                }\n                else {\n                    text = Identifier.fromToken(this.currentToken);\n                    text.minChar = this.scanner.startPos;\n                    text.limChar = this.scanner.pos;\n                    nameLimChar = this.scanner.pos;\n                    this.currentToken = this.scanner.scan();\n                }\n            }\n\n            if (this.currentToken.tokenId == TokenID.Question) {\n                if (this.inInterfaceDecl && text) {\n                    text.flags |= ASTFlags.OptionalName;\n                }\n                else {\n                    this.reportParseError("Optional properties may only be declared on interface or object types");\n                }\n                this.currentToken = this.scanner.scan();\n            }\n\n            if ((this.currentToken.tokenId == TokenID.OpenParen) ||\n                (isIndexer && (this.currentToken.tokenId == TokenID.OpenBracket))) {\n                var ers = errorRecoverySet | ErrorRecoverySet.RParen;\n                if (isIndexer) {\n                    ers = errorRecoverySet | ErrorRecoverySet.RBrack;\n                }\n                var ast = this.parseFncDecl(ers, true, requireSignature,\n                                       !this.inFncDecl, text, isIndexer, isStatic, (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)), modifiers, null, true);\n                var funcDecl: FuncDecl;\n                if (ast.nodeType == NodeType.Error) {\n                    return ast;\n                }\n                else {\n                    funcDecl = <FuncDecl>ast;\n                }\n                if (funcDecl.name) {\n                    funcDecl.name.minChar = minChar;\n                    funcDecl.name.limChar = nameLimChar;\n                }\n                if ((modifiers & Modifiers.Public) != Modifiers.None) {\n                    funcDecl.fncFlags |= FncFlags.Public;\n                }\n                if ((modifiers & Modifiers.Private) != Modifiers.None) {\n                    funcDecl.fncFlags |= FncFlags.Private;\n                }\n                if (isStatic) {\n                    funcDecl.fncFlags |= FncFlags.Static;\n                }\n                if (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)) {\n                    funcDecl.fncFlags |= FncFlags.Ambient;\n                }\n                if (isAccessor) {\n                    // REVIEW: verify return-type annotations and arguments\n                    if (hasFlag(modifiers, Modifiers.Getter)) {\n                        funcDecl.fncFlags |= FncFlags.GetAccessor;\n                        funcDecl.hint = "get" + funcDecl.name.actualText;\n                    }\n                    else {\n                        funcDecl.fncFlags |= FncFlags.SetAccessor;\n                        funcDecl.hint = "set" + funcDecl.name.actualText;\n                    }\n                    funcDecl.fncFlags |= FncFlags.IsFunctionExpression;\n\n                    if (modifiers & Modifiers.Ambient) {\n                        this.reportParseError("Property accessors may not be declared in ambient types");\n                    }\n                }\n\n                if (text == null) {\n                    if (isNew) {\n                        funcDecl.fncFlags |= FncFlags.ConstructMember;\n                        funcDecl.hint = "_construct";\n                        funcDecl.classDecl = thi';
var v27596 = v27597 + 's.currentClassDecl;\n                    }\n                    else {\n                        funcDecl.hint = "_call";\n                        funcDecl.fncFlags |= FncFlags.CallMember;\n                    }\n                }\n                return funcDecl;\n            }\n            else {\n                var varDecl = new VarDecl(text, this.nestingLevel);\n                varDecl.preComments = this.parseComments();\n                varDecl.minChar = minChar;\n                if (this.currentToken.tokenId == TokenID.Colon) {\n                    this.currentToken = this.scanner.scan();\n                    varDecl.typeExpr =\n                        this.parseTypeReference(errorRecoverySet | ErrorRecoverySet.Asg |\n                                           ErrorRecoverySet.Comma, false);\n                    if (varDecl.typeExpr && varDecl.typeExpr.nodeType == NodeType.TypeRef) {\n                        var typeExpr = (<TypeReference>varDecl.typeExpr);\n                        if (typeExpr.term && typeExpr.term.nodeType == NodeType.FuncDecl) {\n                            typeExpr.term.preComments = varDecl.preComments;\n                        }\n                    }\n                }\n                if (this.currentToken.tokenId == TokenID.Equals) {\n                    if (requireSignature) {\n                        this.reportParseError("context does not permit variable initializer");\n                        if (this.errorRecovery) {\n                            this.skip(errorRecoverySet);\n                            varDecl.flags |= ASTFlags.Error;\n                            varDecl.limChar = this.scanner.lastTokenLimChar();\n                            return varDecl;\n                        }\n                    }\n                    // TODO: note assignment for language service\n                    this.currentToken = this.scanner.scan();\n                    varDecl.init = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                           OperatorPrecedence.Comma, true, TypeContext.NoTypes);\n                    varDecl.limChar = varDecl.init.limChar;\n                    if (varDecl.init.nodeType == NodeType.FuncDecl) {\n                        var funcDecl = <FuncDecl>varDecl.init;\n                        funcDecl.hint = varDecl.id.text;\n                        funcDecl.boundToProperty = varDecl;\n                    }\n                    else if (isAccessor) {\n                        this.reportParseError("Accessors may only be functions");\n                    }\n                }\n                else {\n                    varDecl.limChar = this.scanner.pos;\n                }\n                if ((modifiers & Modifiers.Readonly) != Modifiers.None) {\n                    varDecl.varFlags |= VarFlags.Readonly;\n                }\n                if (isStatic) {\n                    varDecl.varFlags |= VarFlags.Static;\n                }\n                if ((modifiers & Modifiers.Public) != Modifiers.None) {\n                    varDecl.varFlags |= VarFlags.Public;\n                }\n                if ((modifiers & Modifiers.Private) != Modifiers.None) {\n                    varDecl.varFlags |= VarFlags.Private;\n                }\n                varDecl.varFlags |= VarFlags.Property;\n                return varDecl;\n            }\n        }\n\n        private parseVariableDeclaration(\n            errorRecoverySet: ErrorRecoverySet,\n            modifiers: Modifiers,\n            allowIn: bool,\n            isStatic: bool): AST {\n\n            var isConst = hasFlag(modifiers, Modifiers.Readonly);\n            var minChar = this.scanner.startPos;\n            var varDecl: VarDecl = null;\n            var declList: ASTList = null;\n            var multivar = false;\n\n            this.currentToken = this.scanner.scan();\n            var varDeclPreComments = this.parseComments();\n\n            while (true) {\n                if ((this.currentToken.tokenId != TokenID.Identifier) && (!convertTokToID(this.currentToken, this.strictMode))) {\n                    this.reportParseError("Expected identifier in variable declaration");\n\n                    if (this.errorRecovery) {\n                        varDecl = new VarDecl(new MissingIdentifier(), this.nestingLevel);\n                        varDecl.minChar = minChar;\n                        this.skip(errorRecoverySet);\n                        varDecl.flags |= ASTFlags.Error;\n                        varDecl.limChar = this.scanner.lastTokenLimChar();\n                        return varDecl;\n                    }\n                }\n\n                var varDeclName = Identifier.fromToken(this.currentToken)\n                if (this.strictMode && (varDeclName.text == "eval")) {\n                    this.reportParseError("\'eval\' may not name a variable in strict mode");\n                }\n\n                varDecl = this.makeVarDecl(varDeclName, this.nestingLevel);\n                varDecl.id.minChar = this.scanner.startPos;\n                varDecl.id.limChar = this.scanner.pos;\n  ';
var v27595 = v27596 + '              varDecl.preComments = varDeclPreComments;\n\n                if (isStatic) {\n                    varDecl.varFlags |= VarFlags.Static;\n                }\n                if (hasFlag(modifiers, Modifiers.Readonly)) {\n                    varDecl.varFlags |= VarFlags.Readonly;\n                }\n                if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Ambient)) {\n                    varDecl.varFlags |= VarFlags.Ambient;\n                }\n                if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Exported)) {\n                    varDecl.varFlags |= VarFlags.Exported;\n                }\n                varDecl.minChar = minChar;\n                if (declList) {\n                    declList.append(varDecl);\n                }\n\n                // move past ID; with error recovery need a test \n                this.currentToken = this.scanner.scan();\n                if (this.currentToken.tokenId == TokenID.Colon) {\n                    this.currentToken = this.scanner.scan();\n                    var prevInFncDecl = this.inFncDecl;\n                    this.inFncDecl = false;\n                    varDecl.typeExpr = this.parseTypeReference(\n                        errorRecoverySet | ErrorRecoverySet.Asg | ErrorRecoverySet.Comma, /*allowVoid:*/ false);\n                    this.inFncDecl = prevInFncDecl;\n                }\n\n                if (this.currentToken.tokenId == TokenID.Equals) {\n                    if (hasFlag(varDecl.varFlags, VarFlags.Ambient)) {\n                        this.reportParseError("Ambient variable can not have an initializer");\n                    }\n                    // TODO: note assignment for language service\n                    this.currentToken = this.scanner.scan();\n                    varDecl.init = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                           OperatorPrecedence.Comma, allowIn,\n                                           TypeContext.NoTypes);\n                    varDecl.limChar = varDecl.init.limChar;\n                    if (varDecl.init.nodeType == NodeType.FuncDecl) {\n                        // TODO: use \'as\' operator when can bootstrap\n                        var funcDecl = <FuncDecl>varDecl.init;\n                        funcDecl.hint = varDecl.id.actualText;\n                    }\n                }\n                else {\n                    if (isConst) {\n                        this.reportParseError("const declaration requires initializer");\n                    }\n                    varDecl.limChar = this.scanner.pos;\n                }\n                varDecl.postComments = this.parseCommentsForLine(this.scanner.line);\n\n                if (this.currentToken.tokenId != TokenID.Comma) {\n                    if (declList) {\n                        declList.limChar = varDecl.limChar;\n                        return declList;\n                    }\n                    else {\n                        return varDecl;\n                    }\n                }\n\n                if (!multivar) {\n                    declList = new ASTList();\n                    declList.minChar = varDecl.minChar;\n                    declList.append(varDecl);\n                    multivar = true;\n                }\n\n                this.currentToken = this.scanner.scan();\n                minChar = this.scanner.startPos;\n            }\n        }\n\n        private parseMemberList(errorRecoverySet: ErrorRecoverySet): ASTList {\n            var elements = new ASTList();\n            if (this.currentToken.tokenId == TokenID.CloseBrace) {\n                return elements;\n            }\n\n            var idHint: string = null;\n            var memberName: AST = null;\n            var memberExpr: AST = null;\n            var member: BinaryExpression = null;\n            var minChar = this.scanner.startPos;\n            var isSet = false;\n            var skippedTokenForGetSetId = false;\n            var getSetTok: Token = null;\n            var getSetStartPos = 0;\n            var getSetPos = 0;\n\n            for (; ;) {\n                var accessorPattern = false;\n                if (this.currentToken.tokenId == TokenID.Get || this.currentToken.tokenId == TokenID.Set) {\n                    isSet = this.currentToken.tokenId == TokenID.Set;\n                    getSetTok = this.currentToken;\n                    getSetStartPos = this.scanner.startPos;\n                    getSetPos = this.scanner.pos;\n\n                    this.currentToken = this.scanner.scan();\n\n                    if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToIDName(this.currentToken)) {\n                        idHint = isSet ? "set" : "get";\n                        idHint = idHint + this.currentToken.getText();\n                        memberName = Identifier.fromToken(this.currentToken);\n                        memberName.minChar = this.scanner.startPos;\n                        accessorPattern = true;\n                   ';
var v27594 = v27595 + '     if (codeGenTarget < CodeGenTarget.ES5) {\n                            this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                        }\n                    }\n                    else if (this.currentToken.tokenId != TokenID.Colon) {\n                        this.reportParseError("Expected identifier, string or number as accessor name");\n                    }\n                    else {\n                        skippedTokenForGetSetId = true;\n                        memberName = Identifier.fromToken(getSetTok);\n                        memberName.minChar = getSetStartPos;\n                        memberName.limChar = getSetPos;\n                    }\n                }\n                else if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToIDName(this.currentToken)) {\n                    idHint = this.currentToken.getText();\n                    memberName = Identifier.fromToken(this.currentToken);\n                    memberName.minChar = this.scanner.startPos;\n                    memberName.limChar = this.scanner.pos;\n                }\n                else if (this.currentToken.tokenId == TokenID.StringLiteral) {\n                    idHint = this.currentToken.getText();\n                    memberName = new StringLiteral(idHint);\n                    memberName.minChar = this.scanner.startPos;\n                    memberName.limChar = this.scanner.pos;\n                }\n                    // TODO: allow reserved words\n                else if (this.currentToken.tokenId == TokenID.NumberLiteral) {\n                    var ntok = <NumberLiteralToken>this.currentToken;\n                    idHint = ntok.value.toString();\n                    memberName = new StringLiteral(idHint);\n                    memberName.minChar = this.scanner.startPos;\n                    memberName.limChar = this.scanner.pos;\n                }\n                else {\n                    this.reportParseError("Expected identifier, string or number as member name");\n                    if (this.errorRecovery) {\n                        memberName = new MissingIdentifier();\n                        memberName.minChar = this.scanner.startPos;\n                        memberName.flags |= ASTFlags.Error;\n                        this.skip(errorRecoverySet | ErrorRecoverySet.Comma);\n                        memberName.limChar = this.scanner.lastTokenLimChar();\n                    }\n                }\n\n                if (!skippedTokenForGetSetId) {\n                    this.currentToken = this.scanner.scan();\n                }\n                else {\n                    skippedTokenForGetSetId = false;\n                }\n\n                if (this.currentToken.tokenId == TokenID.Question) {\n                    memberName.flags |= ASTFlags.OptionalName;\n                    this.currentToken = this.scanner.scan();\n                }\n\n                if (accessorPattern) {\n                    var args = new ASTList();\n                    this.parseFormalParameterList(errorRecoverySet | ErrorRecoverySet.RParen,\n                                      args, false, true, false, !isSet, isSet, false, null, true);\n\n                    var funcDecl: FuncDecl =\n                        this.parseFunctionStatements(errorRecoverySet | ErrorRecoverySet.RCurly,\n                                                <Identifier>memberName, false, true, args,\n                                                AllowedElements.None,\n                                                this.scanner.startPos, false, Modifiers.None);\n\n                    if (isSet && funcDecl.returnTypeAnnotation) {\n                        this.reportParseError("Property setters may not declare a return type");\n                    }\n\n                    funcDecl.fncFlags |= isSet ? FncFlags.SetAccessor : FncFlags.GetAccessor;\n                    funcDecl.fncFlags |= FncFlags.IsFunctionExpression;\n                    funcDecl.hint = idHint;\n                    memberExpr = funcDecl;\n                    member = new BinaryExpression(NodeType.Member, memberName, memberExpr);\n                    member.minChar = memberName.minChar;\n                    if (memberExpr.nodeType == NodeType.FuncDecl) {\n                        var funcDecl = <FuncDecl>memberExpr;\n                        funcDecl.hint = idHint;\n                    }\n                }\n                else if (this.currentToken.tokenId == TokenID.Colon) {\n                    this.currentToken = this.scanner.scan();\n                    memberExpr = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                         OperatorPrecedence.Comma, true, TypeContext.NoTypes);\n                    // If the memberExpr is a type reference, we can be certain that it was an\n                    // array type declaraion that lacked a "new".  We can realistically only\n                    // expect call and name ASTs to be the result of this call to parseExpr.\n                   ';
var v27593 = v27594 + " // If it's a constructor without a \"new\", we'll flag it as an invalid\n                    // call site later on.\n                    if (memberExpr.nodeType == NodeType.TypeRef) {\n                        this.reportParseError(\"Expected 'new' on array declaration in member definition\")\n                    }\n                    member = new BinaryExpression(NodeType.Member, memberName, memberExpr);\n                    member.minChar = memberName.minChar;\n                    if (memberExpr.nodeType == NodeType.FuncDecl) {\n                        var funcDecl = <FuncDecl>memberExpr;\n                        funcDecl.hint = idHint;\n                    }\n                }\n                else {\n                    this.reportParseError(\"Expected ':' in member definition\");\n                    if (this.errorRecovery) {\n                        this.skip(errorRecoverySet);\n                        elements.flags |= ASTFlags.Error;\n                        elements.minChar = minChar;\n                        elements.limChar = this.scanner.lastTokenLimChar();\n                        return elements;\n                    }\n                }\n                idHint = null;\n                elements.append(member);\n                member.limChar = this.scanner.lastTokenLimChar();\n                if (this.currentToken.tokenId != TokenID.Comma) {\n                    break;\n                }\n                else {\n                    // munch comma\n                    this.currentToken = this.scanner.scan();\n                }\n\n                // trailing comma allowed\n                if (this.currentToken.tokenId == TokenID.CloseBrace) {\n                    break;\n                }\n            }\n\n            if (member) {\n                elements.limChar = member.limChar;\n            }\n            elements.minChar = minChar;\n            return elements;\n        }\n\n        private parseArrayList(errorRecoverySet: ErrorRecoverySet): ASTList {\n            var elements: ASTList = null;\n            if (this.currentToken.tokenId == TokenID.CloseBracket) {\n                return elements;\n            }\n            else {\n                elements = new ASTList();\n                elements.minChar = this.scanner.startPos;\n            }\n\n            var arg: AST;\n\n            for (; ;) {\n                if ((this.currentToken.tokenId == TokenID.Comma) ||\n                    (this.currentToken.tokenId == TokenID.CloseBracket)) {\n                    arg = new AST(NodeType.EmptyExpr);\n                }\n                else {\n                    arg = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,\n                                  OperatorPrecedence.Comma, true, TypeContext.NoTypes);\n                }\n                elements.append(arg);\n                if (this.currentToken.tokenId != TokenID.Comma) {\n                    break;\n                }\n                this.currentToken = this.scanner.scan();\n            }\n            elements.limChar = this.scanner.lastTokenLimChar();\n            return elements;\n        }\n\n        private parseArrayLiteral(errorRecoverySet: ErrorRecoverySet): UnaryExpression {\n            var arrayLiteral: UnaryExpression = null;\n            arrayLiteral = new UnaryExpression(NodeType.ArrayLit,\n                                             this.parseArrayList(errorRecoverySet));\n            return arrayLiteral;\n        }\n\n        private parseTerm(errorRecoverySet: ErrorRecoverySet, allowCall: bool, typeContext: TypeContext, inCast: bool): AST {\n            var ast: AST = null;\n            var sawId = false;\n            var inNew = false;\n            var minChar = this.scanner.startPos;\n            var limChar = this.scanner.pos;\n            var parseAsLambda = false;\n            var expectlambdaRParen = false;\n\n            // keywords first\n            switch (this.currentToken.tokenId) {\n                case TokenID.Number:\n                case TokenID.Bool:\n                case TokenID.Any:\n                case TokenID.String:\n                    var tid = new Identifier(tokenTable[this.currentToken.tokenId].text);\n                    if (hasFlag(typeContext, TypeContext.Primitive)) {\n                        ast = new TypeReference(tid, 0);\n                        sawId = true;\n                    }\n                    else {\n                        ast = tid;\n                        sawId = true;\n                    }\n                    ast.minChar = minChar;\n                    this.currentToken = this.scanner.scan();\n                    limChar = this.scanner.lastTokenLimChar();\n                    break;\n                case TokenID.This:\n                    ast = new AST(NodeType.This);\n                    ast.minChar = minChar;\n                    this.currentToken = this.scanner.scan();\n                    limChar = this.scanner.lastTokenLimChar();\n                    break;\n                case TokenID.Super:\n                    ast = new AST(NodeType.Super);\n                    ast.minChar =";
var v27592 = v27593 + " minChar;\n                    this.currentToken = this.scanner.scan();\n                    limChar = this.scanner.lastTokenLimChar();\n                    break;\n                case TokenID.True:\n                    ast = new AST(NodeType.True);\n                    this.currentToken = this.scanner.scan();\n                    ast.minChar = minChar;\n                    break;\n                case TokenID.False:\n                    ast = new AST(NodeType.False);\n                    this.currentToken = this.scanner.scan();\n                    ast.minChar = minChar;\n                    break;\n                case TokenID.Null:\n                    ast = new AST(NodeType.Null);\n                    this.currentToken = this.scanner.scan();\n                    ast.minChar = minChar;\n                    break;\n                case TokenID.New:\n                    minChar = this.scanner.pos;\n                    this.currentToken = this.scanner.scan();\n                    var target = this.parseTerm(errorRecoverySet, false, TypeContext.AllSimpleTypes, inCast);\n\n                    if (target.nodeType == NodeType.Error || (target.nodeType == NodeType.Index && (<BinaryExpression>target).operand1.nodeType == NodeType.TypeRef)) {\n                        this.reportParseError(\"Cannot invoke 'new' on this expression\");\n                    } else {\n                        ast = new CallExpression(NodeType.New, target, null);\n                        ast.minChar = minChar;\n                        limChar = this.scanner.lastTokenLimChar();\n                        inNew = true;\n                    }\n                    break;\n                case TokenID.Function:\n                    minChar = this.scanner.pos;\n                    ast = this.parseFncDecl(errorRecoverySet, false, false, false, null, false, false, false, Modifiers.None, null, true);\n                    (<FuncDecl>ast).fncFlags |= FncFlags.IsFunctionExpression;\n                    ast.minChar = minChar;\n                    limChar = this.scanner.lastTokenLimChar();\n                    ast.limChar = limChar;\n                    break;\n            }\n\n            if (ast == null) {\n                if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n\n                    var idText = this.currentToken.getText();\n                    ast = this.createRef(idText, (<IdentifierToken>this.currentToken).hasEscapeSequence, minChar);\n                    sawId = true;\n \n                    ast.minChar = minChar;\n                    this.currentToken = this.scanner.scan();\n\n                    if (this.currentToken.tokenId == TokenID.Question) {\n                        ast.flags |= ASTFlags.PossibleOptionalParameter;\n                    }\n\n                    limChar = this.scanner.lastTokenLimChar();\n                }\n            }\n\n            if (inCast) {\n                this.checkCurrentToken(TokenID.GreaterThan, errorRecoverySet);\n            }\n\n            if (ast == null) {\n                switch (this.currentToken.tokenId) {\n                    case TokenID.OpenParen:\n                        minChar = this.scanner.pos;\n                        var prevTokId = this.scanner.previousToken().tokenId;\n                        this.currentToken = this.scanner.scan();\n\n                        var couldBeLambda = prevTokId == TokenID.OpenParen || // foo(()=>{});\n                                            prevTokId == TokenID.Comma || // foo(x,()=>{});\n                                            prevTokId == TokenID.EqualsEquals || // var foo = ()=>{};\n                                            prevTokId == TokenID.Colon;    // var x = { foo: ()=> {} };\n\n\n                        if (couldBeLambda && this.currentToken.tokenId == TokenID.CloseParen) {\n                            parseAsLambda = true;\n                            expectlambdaRParen = false;\n                            this.currentToken = this.scanner.scan();\n                        }\n                        else if (couldBeLambda && this.currentToken.tokenId == TokenID.DotDotDot) {\n                            parseAsLambda = true;\n                            expectlambdaRParen = true;\n                        }\n                        else {\n                            ast = this.parseExpr(errorRecoverySet | ErrorRecoverySet.RParen,\n                                          OperatorPrecedence.None, true, TypeContext.NoTypes, couldBeLambda);\n                            limChar = this.scanner.lastTokenLimChar();\n                            parseAsLambda = couldBeLambda && (ast.nodeType == NodeType.Name || ast.nodeType == NodeType.Comma) &&\n                                            (this.currentToken.tokenId == TokenID.Colon || this.currentToken.tokenId == TokenID.Question);\n                            expectlambdaRParen = true;\n                        }\n\n                        // Check for the RParen if it's not an anonymous '=>' function\n                       ";
var v27591 = v27592 + " if ((ast && !parseAsLambda)) {\n                            if (hasFlag(ast.flags, ASTFlags.SkipNextRParen)) {\n                                // REVIEW: parseExpr resulted in a lambda node, the LParen scanned earlier, is the beginning of that node, and not of a parenthesized expression;\n                                //         do not look for a matching RParen for this node, but make sure to remove the flag, so that any enclosing parenthesis are matched correctly.\n                                ast.flags = ast.flags & (~(ASTFlags.SkipNextRParen)); \n                                break;\n                            }\n                            this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet);\n                            ast.isParenthesized = true;\n                        }\n\n                        break;\n                    case TokenID.NumberLiteral: {\n                        var numTok = <NumberLiteralToken>this.currentToken;\n                        this.currentToken = this.scanner.scan();\n                        ast = new NumberLiteral(numTok.value, numTok.hasEmptyFraction);\n                        ast.minChar = minChar;\n                        limChar = this.scanner.lastTokenLimChar();\n                        break;\n                    }\n                    case TokenID.StringLiteral:\n                        ast = new StringLiteral(this.currentToken.getText());\n                        this.currentToken = this.scanner.scan();\n                        ast.minChar = minChar;\n                        limChar = this.scanner.lastTokenLimChar();\n                        break;\n                    case TokenID.RegularExpressionLiteral: {\n                        var rtok = <RegularExpressionLiteralToken>this.currentToken;\n                        ast = new RegexLiteral(rtok.regex);\n                        this.currentToken = this.scanner.scan();\n                        ast.minChar = minChar;\n                        limChar = this.scanner.lastTokenLimChar();\n                        break;\n                    }\n                    case TokenID.OpenBracket:\n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        ast = this.parseArrayLiteral(ErrorRecoverySet.RBrack | errorRecoverySet);\n                        ast.minChar = minChar;\n                        limChar = this.scanner.pos; // ']'\n                        this.checkCurrentToken(TokenID.CloseBracket, errorRecoverySet);\n                        break;\n                    // TODO: rescan regex for TokenID.Div and AsgDiv\n                        case TokenID.OpenBrace:\n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        var members = this.parseMemberList(ErrorRecoverySet.RCurly | errorRecoverySet)\n                        this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n                        ast = new UnaryExpression(NodeType.ObjectLit, members);\n                        ast.minChar = minChar;\n                        limChar = this.scanner.lastTokenLimChar();\n                        members.minChar = minChar;\n                        members.limChar = limChar;\n                        break;\n\n                    case TokenID.LessThan:\n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        var term: AST = this.parseTypeReference(ErrorRecoverySet.BinOp, false);\n                        this.checkCurrentToken(TokenID.GreaterThan, errorRecoverySet);\n                        ast = new UnaryExpression(NodeType.TypeAssertion, this.parseExpr(errorRecoverySet, OperatorPrecedence.Unary, false, TypeContext.NoTypes));\n                        (<UnaryExpression>ast).castTerm = term;\n                        break;\n\n                    default:\n                        if (this.prevExpr && hasFlag(this.prevExpr.flags, ASTFlags.PossibleOptionalParameter)) {\n                            parseAsLambda = true;\n                            ast = this.prevExpr;\n                        }\n                        else {\n                            this.reportParseError(\"Check format of expression term\");\n                            if (this.errorRecovery) {\n                                var ident = new MissingIdentifier();\n                                ident.minChar = minChar;\n                                ident.flags |= ASTFlags.Error;\n                                this.skip(errorRecoverySet | ErrorRecoverySet.Postfix);\n                                if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                                    ident.setText(this.currentToken.getText(), (<IdentifierToken>this.currentToken).hasEscapeSequence);\n                                    this.currentToken = this.scanner.scan();\n                       ";
var v27590 = v27591 + '             limChar = this.scanner.lastTokenLimChar();\n                                }\n                                else {\n                                    limChar = this.scanner.lastTokenLimChar();\n                                    //tok=scanner.scan();\n                                }\n\n                                // REVIEW: set sawId\n                                ast = ident;\n                            }\n                        }\n                }\n            }\n\n            if (parseAsLambda) {\n                // If the next token is an fat arrow or a colon, we either have a parameter list, or can rightly assume\n                // that we have a typed formal, so we proceed with the lambda parse\n                if (\n                    this.currentToken.tokenId == TokenID.Colon ||\n                    this.currentToken.tokenId == TokenID.Comma ||\n                    this.currentToken.tokenId == TokenID.CloseParen ||\n                    this.currentToken.tokenId == TokenID.DotDotDot) {\n\n                        // We won\'t scan in the \':\' case, since keeping the \':\' simplifies argument handling in parseFormalParameterList\n                        // Note that we don\'t set the minchar in this case\n                    ast = this.parseLambdaExpr(errorRecoverySet, ast, true /* skipNextRParen */, expectlambdaRParen);\n                    ast.minChar = minChar;\n                    limChar = this.scanner.lastTokenLimChar();\n                    ast.limChar = limChar;\n                }\n                else if (ast) {\n                    ast.isParenthesized = true;\n                }\n            }\n\n            if (sawId && (typeContext != TypeContext.NoTypes)) {\n                typeContext |= TypeContext.ArraySuffix;\n            }\n\n            var postFix = this.parsePostfixOperators(errorRecoverySet, ast, allowCall, inNew, typeContext, minChar, limChar);\n\n            // Defensive error check...\n            if (postFix) {\n                if (sawId && (postFix.nodeType == NodeType.Index)) {\n                    var binExpr = <BinaryExpression>postFix;\n                    if (binExpr.operand2 == null) {\n                        postFix = this.convertToTypeReference(postFix);\n                    }\n                }\n\n                ///////////////////////////////////////////////////////////\n                //TODO: Eventually, we want to remove "minChar" and "limChar" assignments here,\n                //      as they are sometimes not specific enough for each expression kind.\n                postFix.minChar = minChar;\n                // Only update "limChar" if it is not better than "lastTokenLimChar()"\n                postFix.limChar = max(postFix.limChar, this.scanner.lastTokenLimChar());\n                //\n                ///////////////////////////////////////////////////////////\n                return postFix;\n            }\n            else {\n                return new AST(NodeType.Error);\n            }\n\n        }\n\n        private parseLambdaExpr(errorRecoverySet: ErrorRecoverySet, lambdaArgs: AST, skipNextRParen: bool, expectClosingRParen: bool): AST {\n            // REVIEW: Parse the remainder of a lambda expression. The opening paren has been read already, if it existed. \n            //         skipNextRParen sets a flag on the resulting lambda node to tell the calling parseTerm that the LParen it scanned has been matched as part of parsing the formal parameter list\n            //         expectClosingRParen indicates that a closing RParen is expected, in the cases with optional parameter or more than one parameter.\n            var ast = this.parseFncDecl(errorRecoverySet, false, false, false, null, false, false, false, Modifiers.None, { preProcessedLambdaArgs: lambdaArgs }, expectClosingRParen);\n            (<FuncDecl>ast).fncFlags |= FncFlags.IsFunctionExpression;\n            (<FuncDecl>ast).fncFlags |= FncFlags.IsFatArrowFunction;\n            if (!skipNextRParen) {\n                ast.flags |= ASTFlags.SkipNextRParen;\n            }\n            ast.limChar = this.scanner.lastTokenLimChar();;\n            return ast;\n        }\n\n        private parseExpr(errorRecoverySet: ErrorRecoverySet, minPrecedence: number, allowIn: bool,\n            typeContext: TypeContext, possiblyInLambda: bool = false): AST {\n            var ast: AST = null;\n            var tokenInfo = lookupToken(this.currentToken.tokenId);\n            var canAssign: bool = true;\n            var idHint: string = null;\n            var minChar = this.scanner.startPos;\n            var preComments = this.parseComments();\n            var exprIsAnonLambda = false;\n\n            if ((tokenInfo != undefined) && (tokenInfo.unopNodeType != NodeType.None)) {\n                canAssign = false;\n                this.currentToken = this.scanner.scan();\n                var tempExpr = this.parseExpr(ErrorRecoverySet.BinOp | errorRecoverySet,\n                                       tokenInfo.unopPrecedence, allowIn,\n                                       TypeCo';
var v27589 = v27590 + 'ntext.NoTypes);\n\n                // fold unary +- into constants\n                if ((tokenInfo.unopNodeType == NodeType.Pos) &&\n                    (tempExpr.nodeType == NodeType.NumberLit)) {\n                    ast = tempExpr;\n                }\n                else if ((tokenInfo.unopNodeType == NodeType.Neg) &&\n                         (tempExpr.nodeType == NodeType.NumberLit)) {\n                    var numLit = <NumberLiteral>tempExpr;\n                    numLit.value = (-numLit.value);\n                    if (numLit.value == 0) {\n                        numLit.isNegativeZero = true;\n                    }\n                    ast = tempExpr;\n                }\n                else {\n                    ast = new UnaryExpression(tokenInfo.unopNodeType, tempExpr);\n                    ast.limChar = tempExpr.limChar;\n                }\n                ast.minChar = minChar;\n            }\n            else {\n                ast = this.parseTerm(ErrorRecoverySet.BinOp | ErrorRecoverySet.AddOp |\n                              errorRecoverySet, true, typeContext, false);\n                var id: Identifier;\n                var temp: AST;\n                if (ast.nodeType == NodeType.Name) {\n                    id = <Identifier>ast;\n                    idHint = id.actualText;\n                }\n                else if (ast.nodeType == NodeType.Dot) {\n\n                    // If this is within a class declaration, and the circumstances are right, we need to\n                    // transform the dotted expression into a member declaration\n                    var subsumedExpr = false;\n\n                    if (this.inferPropertiesFromThisAssignment && \n                        (this.currentToken.tokenId == TokenID.Colon || this.currentToken.tokenId == TokenID.Equals) &&\n                         this.parsingClassConstructorDefinition &&\n                         this.nestingLevel == this.currentClassDefinition.constructorNestingLevel && // this nesting level means we\'re at the top-level in the constructor\n                         (<BinaryExpression>ast).operand1.nodeType == NodeType.This) {\n\n                        if ((<BinaryExpression>ast).operand2.nodeType == NodeType.Name) {\n                            var op2ID: Identifier = (<Identifier>(<BinaryExpression>ast).operand2);\n\n                            if (!this.currentClassDefinition.knownMemberNames[op2ID.actualText]) {\n                                ast = this.parseClassMemberVariableDeclaration(op2ID, ast.minChar, true, errorRecoverySet, Modifiers.Public);\n                                subsumedExpr = true;\n                            }\n                        }\n                    }\n\n                    if (!subsumedExpr) {\n                        temp = ast;\n                        while (temp.nodeType == NodeType.Dot) {\n                            var binExpr = <BinaryExpression>temp;\n                            temp = binExpr.operand2;\n                        }\n                        if (temp.nodeType == NodeType.Name) {\n                             id = <Identifier>temp;\n                            idHint = id.actualText;\n                        }\n                    }\n                }\n                if ((!this.scanner.lastTokenHadNewline()) &&\n                    ((this.currentToken.tokenId == TokenID.PlusPlus) || (this.currentToken.tokenId == TokenID.MinusMinus))) {\n                    canAssign = false;\n                    var operand = ast;\n                    ast = new UnaryExpression((this.currentToken.tokenId == TokenID.PlusPlus) ? NodeType.IncPost : NodeType.DecPost, operand);\n                    ast.limChar = this.scanner.pos;\n                    ast.minChar = operand.minChar;\n                    this.currentToken = this.scanner.scan();\n                }\n            }\n            for (; ;) {\n                tokenInfo = lookupToken(this.currentToken.tokenId);\n                if ((tokenInfo == undefined) || (tokenInfo.binopNodeType == NodeType.None)) {\n                    break;\n                }\n                if ((!allowIn) && (tokenInfo.binopNodeType == NodeType.In)) {\n                    break;\n                }\n                if (tokenInfo.binopPrecedence == OperatorPrecedence.Assignment) {\n                    if (tokenInfo.binopPrecedence < minPrecedence) {\n                        break;\n                    }\n                    if (!canAssign) {\n                        this.reportParseError("illegal assignment");\n                    }\n                }\n                else if (tokenInfo.binopPrecedence <= minPrecedence) {\n                    break;\n                }\n\n                if (possiblyInLambda && this.currentToken.tokenId == TokenID.Comma && this.scanner.getLookAheadToken().tokenId == TokenID.DotDotDot) {\n                    // The ellipsis can only exist in the formal list of a lambda expression, so do not attempt to parse the comma token as the comma binary operator\n                    // instead parse it as a lambda\n               ';
var v27588 = v27589 + '     exprIsAnonLambda = true;\n                    canAssign = false;\n                    ast = this.parseLambdaExpr(errorRecoverySet, ast, false, true);\n                    break;\n                }\n\n                // Precedence is high enough. Consume the operator token.\n                this.currentToken = this.scanner.scan();\n                canAssign = false;\n                if (tokenInfo.binopNodeType == NodeType.ConditionalExpression) {\n                    if (possiblyInLambda && \n                        ( this.currentToken.tokenId == TokenID.Equals || this.currentToken.tokenId == TokenID.Colon || this.currentToken.tokenId == TokenID.CloseParen || this.currentToken.tokenId == TokenID.Comma)) {\n                        // The QMark is not a ternary expression, it is a marker for optional parameter in a lambda expression.\n                        exprIsAnonLambda = true;\n                        canAssign = true;\n                    }\n                    else {\n                        this.prevExpr = ast;\n                        var whenTrue = this.parseExpr(\n                            errorRecoverySet | ErrorRecoverySet.Colon, OperatorPrecedence.Assignment, allowIn, TypeContext.NoTypes);\n\n                        // Do not hold onto the prevExpr handle\n                        this.prevExpr = null;\n                        this.checkCurrentToken(TokenID.Colon, errorRecoverySet | ErrorRecoverySet.ExprStart);\n\n                        var whenFalse = this.parseExpr(\n                            errorRecoverySet | ErrorRecoverySet.BinOp, OperatorPrecedence.Assignment, allowIn, TypeContext.NoTypes)\n                        ast = new ConditionalExpression(ast, whenTrue, whenFalse);\n                    }\n                }\n                else {\n                    var tc = TypeContext.NoTypes;\n                    var binExpr2: BinaryExpression;\n\n                    binExpr2 = new BinaryExpression(tokenInfo.binopNodeType, ast,\n                                                    this.parseExpr(errorRecoverySet |\n                                                            ErrorRecoverySet.BinOp,\n                                                            tokenInfo.binopPrecedence,\n                                                            allowIn, TypeContext.NoTypes, possiblyInLambda));\n                    if (binExpr2.operand2.nodeType == NodeType.FuncDecl) {\n                        var funcDecl = <FuncDecl>binExpr2.operand2;\n                        funcDecl.hint = idHint;\n                    }\n\n                    binExpr2.minChar = ast.minChar;\n                    binExpr2.limChar = this.scanner.lastTokenLimChar();\n                    idHint = null;\n                    ast = binExpr2;\n                }\n            }\n            if (canAssign) {\n                ast.flags |= ASTFlags.Writeable;\n            }\n            if (!exprIsAnonLambda) {\n                ///////////////////////////////////////////////////////////\n                //TODO: Eventually, we want to remove "minChar" and "limChar" assignments here,\n                //      as they are sometimes not specific enough for each statement kind.\n                ast.minChar = minChar;\n                // Only update "limChar" if it is not better than "lastTokenLimChar()"\n                ast.limChar = max(ast.limChar, this.scanner.lastTokenLimChar());\n                //\n                ///////////////////////////////////////////////////////////\n                ast.preComments = preComments;\n                ast.postComments = this.parseCommentsForLine(this.scanner.line);\n            }\n            return ast;\n        }\n\n        private parsePostfixOperators(errorRecoverySet: ErrorRecoverySet, ast: AST, allowCall: bool, inNew: bool,\n            typeContext: TypeContext, lhsMinChar: number, lhsLimChar: number): AST {\n            var count = 0;\n\n            if (!ast) {\n                ast = new AST(NodeType.EmptyExpr);\n                ast.isParenthesized = true;\n            }\n\n            ast.minChar = lhsMinChar;\n            ast.limChar = lhsLimChar;\n\n            for (; ;) {\n                switch (this.currentToken.tokenId) {\n                    case TokenID.OpenParen:\n                        if (inNew) {\n                            var callExpr = <CallExpression>ast;\n                            callExpr.arguments = this.parseArgList(errorRecoverySet);\n                            inNew = false;\n                        }\n                        else {\n                            if (!allowCall) {\n                                return ast;\n                            }\n                            ast = new CallExpression(NodeType.Call, ast,\n                                                   this.parseArgList(errorRecoverySet));\n                            ast.minChar = lhsMinChar;\n                        }\n                        ast.limChar = this.scanner.pos; // \')\'\n                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet);\n              ';
var v27587 = v27588 + "          break;\n                    case TokenID.OpenBracket:\n                        this.currentToken = this.scanner.scan();\n                        if (this.currentToken.tokenId == TokenID.CloseBracket) {\n                            if (hasFlag(typeContext, TypeContext.ArraySuffix)) {\n                                this.currentToken = this.scanner.scan();\n                                if (ast.nodeType == NodeType.TypeRef) {\n                                    var typeRef = <TypeReference>ast;\n                                    typeRef.arrayCount++;\n                                }\n                                else {\n                                    ast = new BinaryExpression(NodeType.Index, ast, null);\n                                }\n                                ast.limChar = this.scanner.pos;\n                                break; // note early exit from case\n                            }\n                        }\n\n                        ast = new BinaryExpression(NodeType.Index, ast,\n                                                 this.parseExpr(errorRecoverySet | ErrorRecoverySet.RBrack,\n                                                           OperatorPrecedence.None, true,\n                                                           TypeContext.NoTypes));\n                        ast.minChar = lhsMinChar;\n                        ast.limChar = this.scanner.pos; // ']'\n                        this.checkCurrentToken(TokenID.CloseBracket, errorRecoverySet);\n                        break;\n                    case TokenID.Dot: {\n                        var name: Identifier = null;\n                        var curpos = this.scanner.pos;\n                        this.currentToken = this.scanner.scan();\n                        // Don't allow reserved words if immediately after a new line and error recovery is enabled\n                        if ((this.currentToken.tokenId == TokenID.Identifier) || ((!this.errorRecovery || !this.scanner.lastTokenHadNewline()) && convertTokToIDName(this.currentToken))) {\n                            ast.flags |= ASTFlags.DotLHS;\n                            name = this.createRef(this.currentToken.getText(), (<IdentifierToken>this.currentToken).hasEscapeSequence, this.scanner.startPos);\n                            name.limChar = this.scanner.pos;\n                            this.currentToken = this.scanner.scan();\n                        }\n                        else {\n                            this.reportParseError(\"Expected identifier following dot\");\n                            if (this.errorRecovery) {\n                                this.skip(errorRecoverySet);\n                                ast.flags |= (ASTFlags.Error | ASTFlags.DotLHS);\n                                return ast;\n                            }\n                            else {\n                                name = new MissingIdentifier();\n                            }\n                        }\n                        ast = new BinaryExpression(NodeType.Dot, ast, name);\n                        ast.minChar = lhsMinChar;\n                        ast.limChar = this.scanner.lastTokenLimChar();\n                        break;\n                    }\n                    case TokenID.EqualsGreaterThan:\n                        ast = this.parseFncDecl(errorRecoverySet, false, false, false, null, false, false, false, Modifiers.None, { preProcessedLambdaArgs: ast }, false);\n                        (<FuncDecl>ast).fncFlags |= FncFlags.IsFunctionExpression;\n                        ast.minChar = lhsMinChar;\n                        ast.limChar = this.scanner.lastTokenLimChar();\n                        break;\n                    default:\n                        return ast;\n\n                }\n            }\n        }\n\n        private parseTry(tryNode: Try, errorRecoverySet: ErrorRecoverySet, parentModifiers: Modifiers): Try {\n            var minChar = this.scanner.startPos;\n            var preComments = this.parseComments();\n            this.currentToken = this.scanner.scan();\n            if (this.currentToken.tokenId != TokenID.OpenBrace) {\n                this.reportParseError(\"Expected '{'\");\n                if (this.errorRecovery) {\n                    var etryNode = tryNode;\n                    etryNode.minChar = minChar;\n                    etryNode.limChar = this.scanner.lastTokenLimChar();\n                    etryNode.flags |= ASTFlags.Error;\n                    return etryNode;\n                }\n            }\n            tryNode.body = this.parseStatement(errorRecoverySet, AllowedElements.None, parentModifiers);\n            tryNode.minChar = minChar;\n            tryNode.limChar = tryNode.body.limChar;\n            tryNode.preComments = preComments;\n            tryNode.postComments = this.parseComments();\n            return tryNode;\n        }\n\n        private parseCatch(errorRecoverySet: ErrorRecoverySet, parentModifiers: Modifiers): Catch {\n            var catchMinChar = this.scanner.startPos;\n       ";
var v27586 = v27587 + '     var preComments = this.parseComments();\n            this.currentToken = this.scanner.scan();\n            this.checkCurrentToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart);\n            if ((this.currentToken.tokenId != TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                this.reportParseError("Expected identifier in catch header");\n                if (this.errorRecovery) {\n                    this.skip(errorRecoverySet);\n\n                    var ecatch = new Catch(new VarDecl(new MissingIdentifier(), this.nestingLevel),\n                                            new Statement(NodeType.Empty));\n                    ecatch.statement.minChar = catchMinChar;\n                    ecatch.statement.limChar = this.scanner.pos;\n                    ecatch.minChar = this.scanner.startPos;\n                    ecatch.limChar = this.scanner.pos;\n                    ecatch.flags |= ASTFlags.Error;\n                    return ecatch;\n                }\n            }\n            var param = new VarDecl(Identifier.fromToken(this.currentToken), this.nestingLevel);\n            param.id.minChar = this.scanner.startPos;\n            param.id.limChar = this.scanner.pos;\n            param.minChar = param.id.minChar;\n            param.limChar = param.id.limChar;\n            this.currentToken = this.scanner.scan();\n            var statementPos = this.scanner.pos;\n            this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.StmtStart);\n            if (this.currentToken.tokenId != TokenID.OpenBrace) {\n                this.reportParseError("Expected \'{\' to start catch body");\n                if (this.errorRecovery) {\n                    this.skip(errorRecoverySet);\n\n                    var ecatch = new Catch(new VarDecl(new MissingIdentifier(), this.nestingLevel),\n                                            new Statement(NodeType.Empty));\n                    ecatch.statement.minChar = catchMinChar;\n                    ecatch.statement.limChar = statementPos;\n                    ecatch.minChar = this.scanner.startPos;\n                    ecatch.limChar = this.scanner.pos;\n                    ecatch.flags |= ASTFlags.Error;\n                    return ecatch;\n                }\n            }\n\n            var catchStmt = this.parseStatement(errorRecoverySet, AllowedElements.None, parentModifiers);\n            var catchNode = new Catch(param, catchStmt);\n            catchNode.statement.minChar = catchMinChar;\n            catchNode.statement.limChar = statementPos;\n            catchNode.minChar = catchMinChar;\n            catchNode.limChar = catchStmt.limChar;\n            catchNode.preComments = preComments;\n            catchNode.postComments = this.parseComments();\n            return catchNode;\n        }\n\n        private parseFinally(errorRecoverySet: ErrorRecoverySet, parentModifiers: Modifiers): Finally {\n            var finMinChar = this.scanner.startPos;\n            var preComments = this.parseComments();\n            this.currentToken = this.scanner.scan();\n            if (this.currentToken.tokenId != TokenID.OpenBrace) {\n                this.reportParseError("Expected \'{\' to start body of finally statement");\n                if (this.errorRecovery) {\n                    this.skip(errorRecoverySet);\n                    var efin = new Finally(new Statement(NodeType.Empty));\n                    efin.flags |= ASTFlags.Error;\n                    efin.minChar = this.scanner.startPos;\n                    efin.limChar = this.scanner.pos;\n                    return efin;\n                }\n            }\n\n            var finBody = this.parseStatement(errorRecoverySet, AllowedElements.None, parentModifiers)\n            var fin = new Finally(finBody);\n            fin.minChar = finMinChar;\n            fin.limChar = fin.body.limChar;\n            fin.preComments = preComments;\n            fin.postComments = this.parseComments();\n            return fin;\n        }\n\n        private parseTryCatchFinally(errorRecoverySet: ErrorRecoverySet, parentModifiers: Modifiers, labelList: ASTList): AST {\n            var tryPart: AST = new Try(null);\n            var tryMinChar = this.scanner.startPos;\n            this.pushStmt(<Statement>tryPart, labelList);\n            this.parseTry(<Try>tryPart, errorRecoverySet | ErrorRecoverySet.Catch, parentModifiers);\n            this.popStmt();\n            var tc: TryCatch = null;\n            var tf: TryFinally = null;\n\n            if (this.currentToken.tokenId == TokenID.Catch) {\n                var catchPart = this.parseCatch(errorRecoverySet | ErrorRecoverySet.Catch, parentModifiers);\n                tc = new TryCatch(<Try>tryPart, catchPart);\n                tc.minChar = tryPart.minChar;\n                tc.limChar = catchPart.limChar;\n            }\n\n            if (this.currentToken.tokenId != TokenID.Finally) {\n                if (tc == null) {\n                    this.reportParseError("try with neither catch nor finally");\n        ';
var v27585 = v27586 + '            if (this.errorRecovery) {\n                        var etf = new TryFinally(tryPart, new Finally(new AST(NodeType.Empty)));\n                        etf.flags |= ASTFlags.Error;\n                        etf.minChar = this.scanner.startPos;\n                        etf.limChar = this.scanner.pos;\n                        return etf;\n                    }\n                    return new TryFinally(tryPart, new Finally(new AST(NodeType.Empty)));\n                }\n                else {\n                    return tc;\n                }\n            }\n            else {\n                if (tc) {\n                    tryPart = tc;\n                }\n                var finallyPart = this.parseFinally(errorRecoverySet, parentModifiers)\n                tf = new TryFinally(tryPart, finallyPart);\n                tf.minChar = tryMinChar;\n                tf.limChar = finallyPart.limChar;\n                return tf;\n            }\n        }\n\n        private parseStatement(errorRecoverySet: ErrorRecoverySet, allowedElements: AllowedElements, parentModifiers: Modifiers): AST {\n            var ast: AST = null;\n            var labelList: ASTList = null;\n            var astList: ASTList = null;\n            var temp: AST;\n            var modifiers = Modifiers.None;\n            var minChar = this.scanner.startPos;\n            var forInOk = false;\n            var needTerminator = false;\n            var fnOrVar: AST = null;\n            var preComments = this.parseComments();\n            this.state = ParseState.StartStatement;\n\n            function isAmbient() {\n                return hasFlag(modifiers, Modifiers.Ambient) || hasFlag(parentModifiers, Modifiers.Ambient);\n            }\n\n            function mayNotBeExported() {\n                if (hasFlag(modifiers, Modifiers.Exported)) {\n                    this.reportError("Statement may not be exported");\n                }\n            }\n\n            for (; ;) {\n                switch (this.currentToken.tokenId) {\n                    case TokenID.EndOfFile:\n                        ast = new AST(NodeType.Error);\n                        ast.minChar = minChar;\n                        ast.limChar = this.scanner.pos;\n                        break;\n                    case TokenID.Function:\n                        if (this.parsingDeclareFile || isAmbient() || this.ambientModule) {\n                            this.currentToken = this.scanner.scan();\n                            fnOrVar = this.parsePropertyDeclaration(errorRecoverySet | ErrorRecoverySet.SColon,\n                                                      modifiers, true, false);\n                            if (fnOrVar.nodeType == NodeType.VarDecl) {\n                                this.reportParseError("function keyword can only introduce function declaration");\n                            }\n                            else if ((fnOrVar.nodeType == NodeType.FuncDecl) && ((<FuncDecl>fnOrVar).fncFlags, FncFlags.IsFatArrowFunction)) {\n                                needTerminator = true;\n                            }\n                            ast = fnOrVar;\n                            if (this.parsingDeclareFile || this.ambientModule && ast.nodeType == NodeType.FuncDecl) {\n                                (<FuncDecl>ast).fncFlags |= FncFlags.Exported;\n                            }\n                        }\n                        else {\n                            ast = this.parseFncDecl(errorRecoverySet, true, false, false, null, false, false, isAmbient(), modifiers, null, true);\n                            if (hasFlag((<FuncDecl>ast).fncFlags, FncFlags.IsFatArrowFunction)) {\n                                needTerminator = true;\n                            }\n                            if (this.ambientModule) {\n                                this.reportParseError("function declaration not permitted within ambient module");\n                            }\n                            if (hasFlag(modifiers, Modifiers.Exported)) {\n                                (<FuncDecl>ast).fncFlags |= FncFlags.Exported;\n                            }\n                        }\n                        break;\n                    case TokenID.Module:\n                        if ((allowedElements & AllowedElements.ModuleDeclarations) == AllowedElements.None) {\n                            this.reportParseError("module not allowed in this context");\n                            this.currentToken = this.scanner.scan();\n                            ast = new AST(NodeType.Error);\n                            ast.minChar = minChar;\n                            ast.limChar = this.scanner.lastTokenLimChar();\n                        }\n                        else {\n                            ast = this.parseModuleDecl(errorRecoverySet, modifiers, preComments);\n                            preComments = null;\n                        }\n                        break;\n                    case TokenID.Import:\n                        if ((allowedElements & AllowedElement';
var v27584 = v27585 + 's.ModuleDeclarations) == AllowedElements.None) {\n                            this.reportParseError("module not allowed in this context");\n                            this.currentToken = this.scanner.scan();\n                            ast = new AST(NodeType.Error);\n                            ast.minChar = minChar;\n                            ast.limChar = this.scanner.lastTokenLimChar();\n                        }\n                        else {\n                            if (hasFlag(modifiers, Modifiers.Exported)) {\n                                this.reportParseError("export keyword not permitted on import declaration");\n                            }\n                            ast = this.parseImportDeclaration(errorRecoverySet, modifiers);\n                            needTerminator = true;\n                        }\n                        break;\n                    case TokenID.Export:\n                        if ((allowedElements & AllowedElements.ModuleDeclarations) == AllowedElements.None) {\n                            this.reportParseError("\'export\' statements are only allowed at the global and module levels");\n                            this.currentToken = this.scanner.scan();\n                            ast = new AST(NodeType.Error);\n                            ast.minChar = minChar;\n                            ast.limChar = this.scanner.lastTokenLimChar();\n                        }\n                        if (this.topLevel) {\n                            this.hasTopLevelImportOrExport = true;\n                        }\n                        modifiers |= Modifiers.Exported;\n                        this.currentToken = this.scanner.scan();\n                        break;\n                    case TokenID.Private:\n                        modifiers |= Modifiers.Private;\n\n                        this.currentToken = this.scanner.scan();\n\n                        if (this.parsingClassConstructorDefinition) {\n\n                            if (!this.inferPropertiesFromThisAssignment) {\n                                this.reportParseError("Property declarations are not permitted within constructor bodies");\n                            }\n\n                            minChar = this.scanner.pos;\n                            if (this.inferPropertiesFromThisAssignment && (this.currentToken.tokenId != TokenID.This || (this.currentToken = this.scanner.scan()).tokenId != TokenID.Dot)) {\n                                this.reportParseError("Expected \'this.\' for property declaration");\n                                this.currentToken = this.scanner.scan();\n                                ast = new AST(NodeType.Error);\n                                ast.minChar = minChar;\n                                ast.limChar = this.scanner.lastTokenLimChar();\n                            }\n                            else {\n                                this.currentToken = this.scanner.scan();\n\n                                var id = Identifier.fromToken(this.currentToken);\n                                id.minChar = this.scanner.startPos;\n                                id.limChar = this.scanner.pos;\n\n                                this.currentToken = this.scanner.scan();\n                                ast = this.parseClassMemberVariableDeclaration(id, minChar, this.parsingClassConstructorDefinition, errorRecoverySet, modifiers);\n                            }\n                        }\n                        else {\n                            if (this.currentToken.tokenId != TokenID.Interface) {\n                                if (this.currentToken.tokenId == TokenID.Get) {\n                                    this.prevIDTok = this.currentToken;\n                                    this.currentToken = this.scanner.scan();\n                                    if (codeGenTarget < CodeGenTarget.ES5) {\n                                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                                    }\n                                    if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                                        modifiers |= Modifiers.Getter;\n                                        this.prevIDTok = null;\n                                    }\n                                }\n                                else if (this.currentToken.tokenId == TokenID.Set) {\n                                    this.prevIDTok = this.currentToken;\n                                    this.currentToken = this.scanner.scan();\n                                    if (codeGenTarget < CodeGenTarget.ES5) {\n                                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                                    }\n                                    if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMod';
var v27583 = v27584 + 'e)) {\n                                        modifiers |= Modifiers.Setter;\n                                        this.prevIDTok = null;\n                                    }\n                                }\n                                fnOrVar = this.parsePropertyDeclaration(errorRecoverySet | ErrorRecoverySet.SColon,\n                                                          modifiers, isAmbient(), false);\n                                if ((fnOrVar.nodeType == NodeType.VarDecl) ||\n                                    ((fnOrVar.nodeType == NodeType.FuncDecl) && (hasFlag((<FuncDecl>fnOrVar).fncFlags, FncFlags.IsFatArrowFunction)))) {\n                                    needTerminator = true;\n                                }\n                                ast = fnOrVar;\n                            }\n                        }\n                        break;\n                    case TokenID.Public:\n                        if (this.parsingClassConstructorDefinition) {\n\n                            if (!this.inferPropertiesFromThisAssignment) {\n                                this.reportParseError("Property declarations are not permitted within constructor bodies");\n                            }\n\n                            this.currentToken = this.scanner.scan(); \n                            minChar = this.scanner.pos;\n                            modifiers |= Modifiers.Public;\n                            if (this.inferPropertiesFromThisAssignment && (this.currentToken.tokenId != TokenID.This || (this.currentToken = this.scanner.scan()).tokenId != TokenID.Dot)) {\n                                this.reportParseError("Expected \'this.\' for property declaration");\n                                this.currentToken = this.scanner.scan();\n                                ast = new AST(NodeType.Error);\n                                ast.minChar = minChar;\n                                ast.limChar = this.scanner.lastTokenLimChar();\n                            }\n                            else {\n                                this.currentToken = this.scanner.scan();\n\n                                var id = Identifier.fromToken(this.currentToken);\n                                id.minChar = this.scanner.startPos;\n                                id.limChar = this.scanner.pos;\n\n                                this.currentToken = this.scanner.scan();\n                                ast = this.parseClassMemberVariableDeclaration(id, minChar, this.parsingClassConstructorDefinition, errorRecoverySet, modifiers);\n                            }\n                        }\n                        else {\n                            if ((allowedElements & AllowedElements.Properties) == AllowedElements.None) {\n                                this.reportParseError("\'property\' statements are only allowed within classes");\n                                this.currentToken = this.scanner.scan();\n                                ast = new AST(NodeType.Error);\n                                ast.minChar = minChar;\n                                ast.limChar = this.scanner.lastTokenLimChar();\n                            }\n                            else {\n                                modifiers |= Modifiers.Public;\n                                this.currentToken = this.scanner.scan();\n                                if (this.currentToken.tokenId == TokenID.Get) {\n                                    this.prevIDTok = this.currentToken;\n                                    this.currentToken = this.scanner.scan();\n                                    if (codeGenTarget < CodeGenTarget.ES5) {\n                                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                                    }\n                                    if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                                        modifiers |= Modifiers.Getter;\n                                        this.prevIDTok = null;\n                                    }\n                                }\n                                else if (this.currentToken.tokenId == TokenID.Set) {\n                                    this.prevIDTok = this.currentToken;\n                                    this.currentToken = this.scanner.scan();\n                                    if (codeGenTarget < CodeGenTarget.ES5) {\n                                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                                    }\n                                    if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                                        modifiers |= Modifiers.Setter;\n                                        this.prevIDTok = null;\n                                    }\n                                }\n       ';
var v27582 = v27583 + '                         fnOrVar = this.parsePropertyDeclaration(errorRecoverySet | ErrorRecoverySet.SColon,\n                                                            modifiers, isAmbient(), false);\n                                if ((fnOrVar.nodeType == NodeType.VarDecl) ||\n                                    ((fnOrVar.nodeType == NodeType.FuncDecl) && hasFlag((<FuncDecl>fnOrVar).fncFlags, FncFlags.IsFatArrowFunction))) {\n                                    needTerminator = true;\n                                }\n                                ast = fnOrVar;\n                            }\n                        }\n                        break;\n                    case TokenID.Declare:\n                        if (!(allowedElements & AllowedElements.AmbientDeclarations)) {\n                            this.reportParseError("Ambient declarations are only allowed at the top-level or module scopes")\n                        }\n                        if (!this.parsingDeclareFile && hasFlag(parentModifiers, Modifiers.Ambient)) {\n                            this.reportParseError("Duplicate ambient declaration in this context. (Is the enclosing module or class already ambient?)")\n                        }\n                        modifiers |= Modifiers.Ambient;\n                        this.currentToken = this.scanner.scan();\n                        break;\n                    case TokenID.Class:\n                        if ((allowedElements & AllowedElements.ClassDeclarations) == AllowedElements.None) {\n                            this.reportParseError("class not allowed in this context");\n                            this.currentToken = this.scanner.scan();\n                            ast = new AST(NodeType.Error);\n                            ast.minChar = minChar;\n                            ast.limChar = this.scanner.lastTokenLimChar();\n                        }\n                        else {\n                            ast = this.parseClassDecl(errorRecoverySet, minChar, modifiers);\n                        }\n                        break;\n                    case TokenID.Interface:\n                        if ((allowedElements & AllowedElements.InterfaceDeclarations) == AllowedElements.None) {\n                            this.reportParseError("interface not allowed in this context");\n                            this.currentToken = this.scanner.scan();\n                            ast = new AST(NodeType.Error);\n                            ast.minChar = minChar;\n                            ast.limChar = this.scanner.lastTokenLimChar();\n                        }\n                        else {\n                            ast = this.parseInterfaceDecl(errorRecoverySet, modifiers);\n                        }\n                        break;\n                    case TokenID.Var:\n                        var declAst: AST = this.parseVariableDeclaration(errorRecoverySet | ErrorRecoverySet.StmtStart, modifiers,\n                                                     true, false);\n                        if (declAst.nodeType == NodeType.VarDecl) {\n                            ast = declAst;\n                        }\n                        else {\n                            ast = new Block(<ASTList>declAst, false);\n                        }\n                        needTerminator = true;\n                        break;\n                    case TokenID.Static:\n\n                        if (this.currentClassDecl == null) {\n                            this.reportParseError("Statics may only be class members");\n                        }\n\n                        mayNotBeExported();\n                        modifiers |= Modifiers.Public;\n                        this.currentToken = this.scanner.scan();\n                        if (this.currentToken.tokenId == TokenID.Get) {\n                            this.prevIDTok = this.currentToken;\n                            this.currentToken = this.scanner.scan();\n                            if (codeGenTarget < CodeGenTarget.ES5) {\n                                this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                            }\n                            if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n                                modifiers |= Modifiers.Getter;\n                                this.prevIDTok = null;\n                            }\n                        }\n                        else if (this.currentToken.tokenId == TokenID.Set) {\n                            this.currentToken = this.scanner.scan();\n                            if (codeGenTarget < CodeGenTarget.ES5) {\n                                this.reportParseError("Property accessors are only available when targeting ES5 or greater");\n                            }\n                            if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {\n             ';
var v27581 = v27582 + '                   modifiers |= Modifiers.Setter;\n                            }\n                        }\n                        if (isAmbient()) {\n                            modifiers |= Modifiers.Ambient;\n                        }\n                        fnOrVar = this.parsePropertyDeclaration(errorRecoverySet | ErrorRecoverySet.SColon,\n                                                  modifiers, this.parsingDeclareFile || (modifiers & Modifiers.Ambient) != Modifiers.None, true);\n\n                        var staticsList = this.topStaticsList();\n                        if (staticsList && fnOrVar.nodeType == NodeType.VarDecl) {\n                            staticsList.append(fnOrVar);\n                        }\n\n                        if (fnOrVar.nodeType == NodeType.VarDecl || ((fnOrVar.nodeType == NodeType.FuncDecl) && hasFlag((<FuncDecl>fnOrVar).fncFlags, FncFlags.IsFatArrowFunction))) {\n                            needTerminator = true;\n                        }\n\n                        ast = fnOrVar;\n                        break;\n                    case TokenID.For:\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("syntax error: for statement does not take modifiers");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.checkNextToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart | ErrorRecoverySet.Var);\n                        this.state = ParseState.ForInit;\n                        forInOk = true;\n                        switch (this.currentToken.tokenId) {\n                            case TokenID.Var:\n                                temp = this.parseVariableDeclaration(errorRecoverySet | ErrorRecoverySet.SColon |\n                                                  ErrorRecoverySet.In, Modifiers.None, false, false);\n                                break;\n                            case TokenID.Semicolon:\n                                temp = null;\n                                this.state = ParseState.ForCondStart;\n                                break;\n                            default:\n                                temp = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon |\n                                               ErrorRecoverySet.In, OperatorPrecedence.None, false,\n                                               TypeContext.NoTypes);\n                                break;\n                        }\n                        this.state = ParseState.ForInitAfterVar;\n                        if (this.currentToken.tokenId == TokenID.In) {\n                            if ((temp == null) || (!forInOk)) {\n                                this.reportParseError("malformed for statement");\n                                if (this.errorRecovery) {\n                                    this.skip(errorRecoverySet | ErrorRecoverySet.StmtStart);\n                                    ast = new AST(NodeType.Empty);\n                                    ast.flags |= ASTFlags.Error;\n                                }\n                            }\n                            else {\n                                this.currentToken = this.scanner.scan();\n                                var forInStmt = new ForInStatement(temp,\n                                                                 this.parseExpr(ErrorRecoverySet.RParen |\n                                                                           errorRecoverySet,\n                                                                           OperatorPrecedence.Comma,\n                                                                           false,\n                                                                           TypeContext.NoTypes));\n\n                                forInStmt.limChar = this.scanner.pos;\n                                forInStmt.statement.minChar = minChar;\n                                forInStmt.statement.limChar = this.scanner.pos;\n                                this.checkCurrentToken(TokenID.CloseParen, ErrorRecoverySet.StmtStart | errorRecoverySet);\n                                this.pushStmt(forInStmt, labelList);\n                                forInStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\n                                this.popStmt();\n                                forInStmt.minChar = minChar;\n                                ast = forInStmt;\n                            }\n                        }\n                        else {\n                            var forStmt: ForStatement = new ForStatement(temp);\n                            forStmt.minChar = minChar;\n                            this.checkCurrentToken(TokenID.Semicolon, errorRecoverySet);\n                            if (this.currentToken.tokenId == TokenID.Semicolon) {\n                                forStmt.cond = null;\n                 ';
var v27580 = v27581 + "           }\n                            else {\n                                forStmt.cond = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon |\n                                                       ErrorRecoverySet.RParen,\n                                                       OperatorPrecedence.None, true,\n                                                       TypeContext.NoTypes);\n                                if (this.currentToken.tokenId != TokenID.Semicolon) {\n                                    this.skip(errorRecoverySet | ErrorRecoverySet.StmtStart);\n                                    ast = forStmt;\n                                    ast.flags |= ASTFlags.Error;\n                                }\n                            }\n                            this.currentToken = this.scanner.scan();\n                            if (this.currentToken.tokenId == TokenID.CloseParen) {\n                                forStmt.incr = null;\n                            }\n                            else {\n                                forStmt.incr = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon |\n                                                       ErrorRecoverySet.RParen,\n                                                       OperatorPrecedence.None, true,\n                                                       TypeContext.NoTypes);\n                            }\n                            this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.LCurly);\n                            this.pushStmt(forStmt, labelList);\n                            forStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\n                            this.popStmt();\n                            forStmt.limChar = forStmt.body.limChar;\n                            ast = forStmt;\n                        }\n                        break;\n                    case TokenID.With: {\n                        if (codeGenTarget < CodeGenTarget.ES5) {\n                            this.reportParseError(\"'with' statements are only available in ES5 codegen mode or better\");\n                        }\n\n                        if (this.strictMode) {\n                            this.reportParseError(\"'with' statements are not available in strict mode\");\n                        }\n\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError(\"'with' statement does not take modifiers\");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.checkNextToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart | ErrorRecoverySet.Var);\n\n                        var expr = this.parseExpr(errorRecoverySet | ErrorRecoverySet.Colon,\n                                                            OperatorPrecedence.None, true,\n                                                            TypeContext.NoTypes);\n                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.LCurly);\n\n                        var withStmt = new WithStatement(expr);\n                        withStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\n                        withStmt.minChar = minChar;\n                        withStmt.limChar = withStmt.body.limChar;\n                        ast = withStmt;\n                    }\n                        break;\n                    case TokenID.Switch: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError(\"'switch' statement does not take modifiers\");\n                        }\n                        this.checkNextToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart);\n\n                        var switchStmt = new SwitchStatement(this.parseExpr(errorRecoverySet |\n                                                                     ErrorRecoverySet.RParen,\n                                                                     OperatorPrecedence.None,\n                                                                     true,\n                                                                     TypeContext.NoTypes));\n                        switchStmt.statement.minChar = minChar;\n                        switchStmt.statement.limChar = this.scanner.pos;\n                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.LCurly);\n                        var caseListMinChar = this.scanner.startPos;\n                         this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet | ErrorRecoverySet.SCase);\n                        switchStmt.defaultCase = null;\n                        switchStmt.caseList = new ASTList();\n                        var caseStmt: CaseStatement = null;\n                        this.push";
var v27579 = v27580 + 'Stmt(switchStmt, labelList);\n                        for (; ;) {\n                            if ((this.currentToken.tokenId == TokenID.Case) ||\n                                (this.currentToken.tokenId == TokenID.Default)) {\n                                var isDefault = (this.currentToken.tokenId == TokenID.Default);\n                                caseStmt = new CaseStatement();\n                                caseStmt.minChar = this.scanner.startPos;\n                                this.currentToken = this.scanner.scan();\n                                if (isDefault) {\n                                    switchStmt.defaultCase = caseStmt;\n                                }\n                                else {\n                                    caseStmt.expr = this.parseExpr(errorRecoverySet | ErrorRecoverySet.Colon,\n                                                            OperatorPrecedence.None, true,\n                                                            TypeContext.NoTypes);\n                                }\n                                this.checkCurrentToken(TokenID.Colon, errorRecoverySet | ErrorRecoverySet.StmtStart);\n                                caseStmt.body = new ASTList();\n                                this.parseStatementList(errorRecoverySet | ErrorRecoverySet.RCurly,\n                                              caseStmt.body, false, true, allowedElements, modifiers);\n                                caseStmt.limChar = caseStmt.body.limChar;\n                                switchStmt.caseList.append(caseStmt);\n                            }\n                            else {\n                                break;\n                            }\n                        }\n                        // end of switch statement\n                        switchStmt.caseList.minChar = caseListMinChar;\n                        switchStmt.caseList.limChar = this.scanner.pos;\n                        switchStmt.limChar = switchStmt.caseList.limChar;\n                        this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n                        this.popStmt();\n                        ast = switchStmt;\n                        break;\n                    }\n                    case TokenID.While: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("\'while\' statement does not take modifiers");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.checkNextToken(TokenID.OpenParen, ErrorRecoverySet.ExprStart |\n                                  errorRecoverySet);\n                        var whileStmt = new WhileStatement(this.parseExpr(errorRecoverySet |\n                                                                   ErrorRecoverySet.RParen,\n                                                                   OperatorPrecedence.None,\n                                                                   true, TypeContext.NoTypes));\n                        whileStmt.minChar = minChar;\n                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet |\n                                  ErrorRecoverySet.StmtStart);\n                        this.pushStmt(whileStmt, labelList);\n                        whileStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\n                        whileStmt.limChar = whileStmt.body.limChar;\n                        this.popStmt();\n                        ast = whileStmt;\n                        break;\n                    }\n                    case TokenID.Do: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("\'do\' statement does not take modifiers");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        var doStmt = new DoWhileStatement();\n                        doStmt.minChar = minChar;\n                        this.pushStmt(doStmt, labelList);\n                        doStmt.body = this.parseStatement(errorRecoverySet | ErrorRecoverySet.While,\n                                                   allowedElements, parentModifiers);\n                        this.popStmt();\n                        doStmt.whileAST = new Identifier("while");\n                        doStmt.whileAST.minChar = this.scanner.startPos;\n                        this.checkCurrentToken(TokenID.While, errorRecoverySet | ErrorRecoverySet.LParen);\n                        doStmt.whileAST.limChar = doStmt.whileAST.minChar + 5;\n                        this.checkCurrentToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart);\n                        doStmt.cond = this.parseExpr(errorRecoverySet | ErrorRecoverySet.RParen,\n                                           ';
var v27578 = v27579 + '   OperatorPrecedence.None, true, TypeContext.NoTypes);\n                        doStmt.limChar = this.scanner.pos;\n                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet);\n                        ast = doStmt;\n                        // compatibility; more strict would be to require the \';\'\n                        if (this.currentToken.tokenId == TokenID.Semicolon) {\n                            this.currentToken = this.scanner.scan();\n                        }\n                        break;\n                    }\n                    case TokenID.If: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("if statement does not take modifiers");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.checkNextToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart);\n                        var ifStmt = new IfStatement(this.parseExpr(errorRecoverySet |\n                                                             ErrorRecoverySet.LParen,\n                                                             OperatorPrecedence.None, true,\n                                                             TypeContext.NoTypes));\n                        ifStmt.minChar = minChar;\n                        ifStmt.statement.minChar = minChar;\n                        ifStmt.statement.limChar = this.scanner.pos;\n                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.StmtStart);\n                        this.pushStmt(ifStmt, labelList);\n                        ifStmt.thenBod = this.parseStatement(ErrorRecoverySet.Else | errorRecoverySet,\n                                                      allowedElements, parentModifiers);\n                        ifStmt.limChar = ifStmt.thenBod.limChar;\n                        if (this.currentToken.tokenId == TokenID.Else) {\n                            this.currentToken = this.scanner.scan();\n                            ifStmt.elseBod = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\n                            ifStmt.limChar = ifStmt.elseBod.limChar;\n                        }\n                        this.popStmt();\n                        ast = ifStmt;\n                        break;\n                    }\n                    case TokenID.Try: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("try statement does not take modifiers");\n                        }\n                        minChar = this.scanner.startPos;\n                        ast = this.parseTryCatchFinally(errorRecoverySet, parentModifiers, labelList);\n                        break;\n                    }\n                    case TokenID.OpenBrace: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("block does not take modifiers");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        var block = new Block(new ASTList(), true);\n                        this.pushStmt(block, labelList);\n                        this.parseStatementList(\n                            errorRecoverySet | ErrorRecoverySet.RCurly, block.statements,\n                            /*sourceElements:*/ false, /*noLeadingCase:*/ false, AllowedElements.None, modifiers);\n                        this.popStmt();\n                        block.statements.minChar = minChar;\n                        block.statements.limChar = this.scanner.pos;\n                        block.minChar = block.statements.minChar;\n                        block.limChar = block.statements.limChar;\n                        this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);\n                        ast = block;\n                        break;\n                    }\n                    case TokenID.Semicolon:\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("modifier can not appear here");\n                        }\n                        ast = new AST(NodeType.Empty);\n                        this.currentToken = this.scanner.scan();\n                        break;\n                    case TokenID.Break:\n                    case TokenID.Continue: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("modifiers can not appear before jump statement");\n                        }\n                        var jump =\n                            new Jump((this.currentToken.tokenId == TokenID.Break) ? NodeType.Break : NodeType.Cont';
var v27577 = v27578 + 'inue);\n                        this.currentToken = this.scanner.scan();\n                        if ((this.currentToken.tokenId == TokenID.Identifier) && (!this.scanner.lastTokenHadNewline())) {\n                            // Labeled break or continue.\n                            jump.target = this.currentToken.getText();\n                            this.currentToken = this.scanner.scan();\n                        }\n                        this.resolveJumpTarget(jump);\n                        ast = jump;\n                        needTerminator = true;\n                        break;\n                    }\n                    case TokenID.Return: {\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("modifiers can not appear before return statement");\n                        }\n                        if (!this.inFunction) {\n                            this.reportParseError("return statement outside of function body");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        var retStmt = new ReturnStatement();\n                        retStmt.minChar = minChar;\n                        if ((this.currentToken.tokenId != TokenID.Semicolon) &&\n                            (this.currentToken.tokenId != TokenID.CloseBrace) &&\n                            (!(this.scanner.lastTokenHadNewline()))) {\n                            retStmt.returnExpression = this.parseExpr(errorRecoverySet |\n                                                               ErrorRecoverySet.SColon,\n                                                               OperatorPrecedence.None,\n                                                               true, TypeContext.NoTypes);\n                        }\n                        needTerminator = true;\n                        retStmt.limChar = this.scanner.lastTokenLimChar();\n                        ast = retStmt;\n                        break;\n                    }\n                    case TokenID.Throw:\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("modifiers can not appear before a throw statement");\n                        }\n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        if ((this.currentToken.tokenId != TokenID.Semicolon) &&\n                            (this.currentToken.tokenId != TokenID.CloseBrace) &&\n                            (!(this.scanner.lastTokenHadNewline()))) {\n                            temp = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon,\n                                           OperatorPrecedence.None, true, TypeContext.NoTypes);\n                        }\n                        else {\n                            this.reportParseError("throw with no target");\n                            temp = null;\n                        }\n                        ast = new UnaryExpression(NodeType.Throw, temp);\n                        ast.limChar = this.scanner.lastTokenLimChar();\n                        needTerminator = true;\n                        break;\n                    case TokenID.Enum:\n                        // TODO: check module allowed here\n                        //minChar=scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        ast = this.parseEnumDecl(errorRecoverySet, modifiers);\n                        ast.minChar = minChar;\n                        ast.limChar = this.scanner.lastTokenLimChar();\n                        if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Ambient)) {\n                            (<ModuleDeclaration>ast).modFlags |= ModuleFlags.Ambient;\n                        }\n                        if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Exported)) {\n                            (<ModuleDeclaration>ast).modFlags |= ModuleFlags.Exported;\n                        }\n                        break;\n                    case TokenID.Debugger:\n                        mayNotBeExported();\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("modifiers can not appear before debugger statement");\n                        }\n                        \n                        minChar = this.scanner.startPos;\n                        this.currentToken = this.scanner.scan();\n                        var debuggerStmt = new DebuggerStatement();\n                        debuggerStmt.minChar = minChar;\n                        needTerminator = true;\n                        debuggerStmt.limChar = this.scanner.lastTokenLimChar();\n                        ast = debuggerStmt;\n                       ';
var v27576 = v27577 + ' break;\n                    default:\n                        if (modifiers != Modifiers.None) {\n                            this.reportParseError("modifiers can not appear before an expression statement or label");\n                        }\n                        minChar = this.scanner.startPos;\n                        var svPos = this.scanner.pos;\n                        temp = this.parseExpr(ErrorRecoverySet.Colon | ErrorRecoverySet.StmtStart |\n                                       errorRecoverySet, OperatorPrecedence.None, true,\n                                       TypeContext.NoTypes);\n                        if (this.scanner.pos == svPos) {\n                            // no progress\n                            this.currentToken = this.scanner.scan();\n                            ast = temp;\n                        }\n                        else if ((this.currentToken.tokenId == TokenID.Colon) && (!this.scanner.lastTokenHadNewline()) &&\n                                        temp && (temp.nodeType == NodeType.Name)) {\n                                            // It\'s a label\n                            if (labelList == null) {\n                                labelList = new ASTList();\n                            }\n                            labelList.append(new Label(<Identifier>temp));\n                            this.currentToken = this.scanner.scan();\n                        }\n                        else {\n                            // expression statement\n                            ast = temp;\n                            needTerminator = true;\n                        }\n                }\n                if (ast) {\n                    break;\n                }\n            }\n            if (needTerminator) {\n                switch (this.currentToken.tokenId) {\n                    case TokenID.Semicolon:\n                        this.currentToken = this.scanner.scan();\n                        ast.flags |= ASTFlags.ExplicitSemicolon;\n                        break;\n                    case TokenID.EndOfFile:\n                        // Extend any incomplete statements to include EOF token. This makes sure that this node is in the path \n                        // when completion or parameter help is requested.\n                        ast.limChar = this.scanner.pos;\n                        // IntentionaCloseBracethrough\n                    case TokenID.CloseBrace:\n                        ast.flags |= ASTFlags.AutomaticSemicolon;\n                        if (this.style_requireSemi) {\n                            this.reportParseStyleError("no automatic semicolon");\n                        }\n                        break;\n                    default:\n                        if (!this.scanner.lastTokenHadNewline()) {\n                            this.reportParseError("Expected \';\'");\n                        }\n                        else {\n                            ast.flags |= ASTFlags.AutomaticSemicolon;\n                            if (this.style_requireSemi) {\n                                this.reportParseStyleError("no automatic semicolon");\n                            }\n                        }\n                        break;\n                }\n            }\n            if (labelList) {\n                ast = new LabeledStatement(labelList, ast);\n            }\n\n            ///////////////////////////////////////////////////////////\n            //TODO: Eventually, we want to remove "minChar" and "limChar" assignments here,\n            //      as they are sometimes not specific enough for each statement kind.\n            ast.minChar = minChar;\n            // Only update "limChar" if it is not better than "lastTokenLimChar()"\n            ast.limChar = max(ast.limChar, this.scanner.lastTokenLimChar());\n            //\n            ///////////////////////////////////////////////////////////\n\n            if (preComments) {\n                ast.preComments = preComments;\n            }\n            if (this.ambientModule && (!this.okAmbientModuleMember(ast))) {\n                this.reportParseError("statement not permitted within ambient module");\n            }\n            ast.flags |= ASTFlags.IsStatement;\n            return ast;\n        }\n\n        private okAmbientModuleMember(ast: AST) {\n            var nt = ast.nodeType;\n            return (nt == NodeType.ClassDeclaration) || (nt == NodeType.ImportDeclaration) || (nt == NodeType.InterfaceDeclaration) || (nt == NodeType.ModuleDeclaration) ||\n                (nt == NodeType.Empty) || (nt == NodeType.VarDecl) || \n                ((nt == NodeType.Block) && !(<Block>ast).isStatementBlock) ||\n                ((nt == NodeType.FuncDecl) && ((<FuncDecl>ast).isMethod()));\n        }\n\n        private parseStatementList(errorRecoverySet: ErrorRecoverySet,\n                                   statements: ASTList,\n                                   sourceElms: bool,\n                                   noLeadingCase: bool,\n                                   allowedElements: A';
var v27575 = v27576 + 'llowedElements,\n                                   parentModifiers: Modifiers): void {\n            var directivePrologue = sourceElms;\n            statements.minChar = this.scanner.startPos;\n            var limChar = this.scanner.pos;\n            var innerStmts = (allowedElements & AllowedElements.ModuleDeclarations) == AllowedElements.None;\n            var classNope = (allowedElements & AllowedElements.ClassDeclarations) == AllowedElements.None;\n\n            errorRecoverySet |= ErrorRecoverySet.TypeScriptS | ErrorRecoverySet.RCurly;\n\n            this.state = ParseState.StartStatementList;\n            var oldStrictMode = this.strictMode;\n            this.nestingLevel++;\n            for (; ;) {\n                if ((this.currentToken.tokenId == TokenID.CloseBrace) ||\n                    (noLeadingCase && ((this.currentToken.tokenId == TokenID.Case) || (this.currentToken.tokenId == TokenID.Default))) ||\n                    (innerStmts && (this.currentToken.tokenId == TokenID.Export)) ||\n                    (classNope && (this.currentToken.tokenId == TokenID.Class)) ||\n                    (this.currentToken.tokenId == TokenID.EndOfFile)) {\n                    this.state = ParseState.EndStmtList;\n                    statements.limChar = limChar;\n                    if (statements.members.length == 0) {\n                        statements.preComments = this.parseComments();\n                    }\n                    else {\n                        statements.postComments = this.parseComments();\n                    }\n                    this.strictMode = oldStrictMode;\n                    this.nestingLevel--;\n                    return;\n                }\n\n                var stmt = this.parseStatement(errorRecoverySet &\n                                        (~(ErrorRecoverySet.Else | ErrorRecoverySet.RParen |\n                                           ErrorRecoverySet.Catch | ErrorRecoverySet.Colon)),\n                                        allowedElements, parentModifiers);\n\n\n                if (stmt) {\n                    stmt.postComments = this.combineComments(stmt.postComments, this.parseCommentsForLine(this.scanner.prevLine));\n                    statements.append(stmt);\n                    limChar = stmt.limChar;\n                    if (directivePrologue) {\n                        if (stmt.nodeType == NodeType.QString) {\n                            var qstring = <StringLiteral>stmt;\n                            if (qstring.text == "\\"use strict\\"") {\n                                statements.flags |= ASTFlags.StrictMode;\n                                this.strictMode = true;\n                            }\n                            else {\n                                directivePrologue = false;\n                            }\n                        }\n                        else {\n                            directivePrologue = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        private fname = "";\n\n        public quickParse(sourceText: ISourceText, filename: string, unitIndex: number): QuickParseResult {\n            //TODO: REVIEW: We set this to avoid adding a "module" decl in the resulting script (see parse() method)\n            var svGenTarget = TypeScript.moduleGenTarget;\n            try {\n                TypeScript.moduleGenTarget = TypeScript.ModuleGenTarget.Local;\n                var script = this.parse(sourceText, filename, unitIndex, AllowedElements.QuickParse);\n                return new QuickParseResult(script, this.scanner.lexState);\n            }\n            finally {\n                TypeScript.moduleGenTarget = svGenTarget;\n            }\n        }\n\n        public parse(sourceText: ISourceText, filename: string, unitIndex: number, allowedElements = AllowedElements.Global): Script {\n            // Reset all parser state here.  This allows us to be resilient to reentrancy if an \n            // exception is thrown.\n            this.fname = filename;\n            this.currentUnitIndex = unitIndex;\n\n            this.currentToken = null;\n            this.needTerminator = false;\n            this.inFunction = false;\n            this.inInterfaceDecl = false;\n            this.inFncDecl = false;\n            this.state = ParseState.StartStatementList;\n            this.ambientModule = false;\n            this.ambientClass = false;\n            this.topLevel = true;\n            this.allowImportDeclaration = true;\n            this.prevIDTok = null;\n            this.statementInfoStack = new IStatementInfo[];\n            this.hasTopLevelImportOrExport = false;\n            this.strictMode = false;\n            this.nestingLevel = 0;\n            this.prevExpr = null;\n            this.currentClassDefinition = null;\n            this.parsingClassConstructorDefinition = false;\n            this.parsingDeclareFile = false;\n            this.amdDependencies = [];\n            this.inferPropertiesFromThisAssignment = false;\n            this.requiresExtendsBlock = false;\n\n';
var v27574 = v27575 + '            this.scanner.resetComments();\n            this.scanner.setErrorHandler((message) =>this.reportParseError(message));\n            this.scanner.setSourceText(sourceText, LexMode.File);\n\n            var leftCurlyCount = this.scanner.leftCurlyCount;\n            var rightCurlyCount = this.scanner.rightCurlyCount;\n\n            var minChar = this.scanner.pos;\n            this.currentToken = this.scanner.scan();\n            this.pushDeclLists();\n            var bod = new ASTList();\n            bod.minChar = minChar;\n\n            this.state = ParseState.StartScript;\n            this.parsingDeclareFile = isDSTRFile(filename) || isDTSFile(filename);\n\n            while (true) {\n                this.parseStatementList(\n                    ErrorRecoverySet.EOF | ErrorRecoverySet.Func,\n                    bod, /*sourceElements:*/ true, /*noLeadingCase:*/ false,\n                    allowedElements, Modifiers.None);\n\n                if (this.currentToken.tokenId === TokenID.EndOfFile) {\n                    break;\n                }\n\n                // Still have remaining tokens in the file.  Report error for this unexpected token,\n                // skip it, and continue trying to parse statements until we\'re done. \n                var badToken = tokenTable[this.currentToken.tokenId];\n                this.reportParseError("Unexpected statement block terminator \'" + badToken.text + "\'");\n\n                this.currentToken = this.scanner.scan();\n            }\n\n            this.state = ParseState.EndScript;\n\n            bod.limChar = this.scanner.pos;\n\n            var topLevelMod: ModuleDeclaration = null;\n            if (moduleGenTarget != ModuleGenTarget.Local && this.hasTopLevelImportOrExport) {\n                var correctedFileName = switchToForwardSlashes(filename);\n                var id: Identifier = new Identifier(correctedFileName);\n                topLevelMod = new ModuleDeclaration(id, bod, this.topVarList(), this.topScopeList(), null);\n\n                topLevelMod.modFlags |= ModuleFlags.IsDynamic;\n                topLevelMod.modFlags |= ModuleFlags.IsWholeFile;\n                topLevelMod.modFlags |= ModuleFlags.Exported;\n\n                if (this.parsingDeclareFile) {\n                    topLevelMod.modFlags |= ModuleFlags.Ambient;\n                }\n\n                topLevelMod.minChar = minChar;\n                topLevelMod.limChar = this.scanner.pos;\n                topLevelMod.prettyName = getPrettyName(correctedFileName);\n                topLevelMod.containsUnicodeChar = this.scanner.seenUnicodeChar;\n                topLevelMod.containsUnicodeCharInComment = this.scanner.seenUnicodeCharInComment;\n\n                topLevelMod.amdDependencies = this.amdDependencies;\n\n                bod = new ASTList();\n                bod.minChar = topLevelMod.minChar;\n                bod.limChar = topLevelMod.limChar;\n                bod.append(topLevelMod);\n            }\n\n            var script = new Script(this.topVarList(), this.topScopeList());\n            script.bod = bod;\n            this.popDeclLists();\n            script.minChar = minChar;\n            script.limChar = this.scanner.pos;\n            script.locationInfo = new LocationInfo(filename, this.scanner.lineMap, unitIndex);\n            script.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\n            script.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\n            script.isDeclareFile = this.parsingDeclareFile;\n            script.topLevelMod = topLevelMod;\n            script.containsUnicodeChar = this.scanner.seenUnicodeChar;\n            script.containsUnicodeCharInComment = this.scanner.seenUnicodeCharInComment;\n            script.requiresExtendsBlock = this.requiresExtendsBlock;\n            return script;\n        }\n    }\n\n    export function quickParse(logger: TypeScript.ILogger, scopeStartAST: AST, sourceText: ISourceText, minChar: number, limChar: number,\n        errorCapture: (minChar: number, charLen: number, message: string, unitIndex: number) => void ): QuickParseResult {\n\n        var fragment = sourceText.getText(minChar, limChar);\n        logger.log("Quick parse range (" + minChar + "," + limChar + "): \\"" + TypeScript.stringToLiteral(fragment, 100) + "\\"");\n\n        var quickParser = new Parser();\n        quickParser.setErrorRecovery(null);\n        quickParser.errorCallback = errorCapture;\n\n        // REVIEW: use enclosing scope to determine this\n        // REVIEW: Why even use class here?\n        var quickClassDecl = new ClassDeclaration(null, null, null, null);\n        quickParser.currentClassDecl = quickClassDecl;\n\n        var result = quickParser.quickParse(new StringSourceText(fragment), "", 0);\n        return result;\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/license';
var v27573 = v27574 + 's/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    // We need to catch both left and right quotes\n    // (depending on your editor\'s font, this may not be clear...)    \n    export function stripQuotes(str: string) {\n        return str.replace("\\"", "").replace("\'", "").replace("\'", "").replace("\\"", "")\n    }\n\n    export function isQuoted(str: string) {\n        return str.indexOf("\\"") != -1 || str.indexOf("\'") != -1 || str.indexOf("\'") != -1 || str.indexOf("\\"") != -1;\n    }\n\n    export function quoteStr(str: string) {\n        return "\\"" + str + "\\"";\n    }\n\n    export function swapQuotes(str: string) {\n\n        if (str.indexOf("\\"") != -1) {\n            str = str.replace("\\"", "\'");\n            str = str.replace("\\"", "\'");\n        }\n        else {\n            str = str.replace("\'", "\\"");\n            str = str.replace("\'", "\\"");\n        }\n\n        return str;\n    }\n\n    export function switchToForwardSlashes(path: string) {\n        return path.replace(/\\\\/g, "/");\n    }\n\n    export function trimModName(modName: string) {\n        // in case\'s it\'s a declare file...\n        if (modName.length > 6 && modName.substring(modName.length - 6, modName.length) == ".d.str") {\n            return modName.substring(0, modName.length - 6);\n        }\n        if (modName.length > 4 && modName.substring(modName.length - 4, modName.length) == ".str") {\n            return modName.substring(0, modName.length - 4);\n        }\n        if (modName.length > 5 && modName.substring(modName.length - 5, modName.length) == ".d.ts") {\n            return modName.substring(0, modName.length - 5);\n        }\n        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) == ".ts") {\n            return modName.substring(0, modName.length - 3);\n        }\n        // in case\'s it\'s a .js file\n        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) == ".js") {\n            return modName.substring(0, modName.length - 3);\n        }\n\n        return modName;\n    }\n\n    export function getDeclareFilePath(fname: string) {\n        return isSTRFile(fname) ? changePathToDSTR(fname) : isTSFile(fname) ? changePathToDTS(fname) : changePathToDTS(fname);\n    }\n\n    function isFileOfExtension(fname: string, ext: string) {\n        var invariantFname = fname.toLocaleUpperCase();\n        var invariantExt = ext.toLocaleUpperCase();\n        var extLength = invariantExt.length;\n        return invariantFname.length > extLength && invariantFname.substring(invariantFname.length - extLength, invariantFname.length) == invariantExt;\n    }\n\n    export function isJSFile(fname: string) {\n        return isFileOfExtension(fname, ".js");\n    }\n\n    export function isSTRFile(fname: string) {\n        return isFileOfExtension(fname, ".str");\n    }\n\n    export function isTSFile(fname: string) {\n        return isFileOfExtension(fname, ".ts");\n    }\n\n    export function isDSTRFile(fname: string) {\n        return isFileOfExtension(fname, ".d.str");\n    }\n\n    export function isDTSFile(fname: string) {\n        return isFileOfExtension(fname, ".d.ts");\n    }\n\n    export function getPrettyName(modPath: string, quote?=true, treatAsFileName?=false) { \n        var modName = treatAsFileName ? switchToForwardSlashes(modPath) : trimModName(stripQuotes(modPath));\n        var components = this.getPathComponents(modName);\n        return components.length ? (quote ? quoteStr(components[components.length - 1]) : components[components.length - 1]) : modPath;\n    }\n\n    export function getPathComponents(path: string) {\n        return path.split("/");\n    }\n\n    export function getRelativePathToFixedPath(fixedModFilePath: string, absoluteModPath: string) {\n        absoluteModPath = switchToForwardSlashes(absoluteModPath);\n\n        var modComponents = this.getPathComponents(absoluteModPath);\n        var fixedModComponents = this.getPathComponents(fixedModFilePath);\n\n        // Find the component that differs\n        var joinStartIndex = 0;\n        for (; joinStartIndex < modComponents.length && joinStartIndex < fixedModComponents.length ; joinStartIndex++) {\n            if (fixedModComponents[joinStartIndex] != modComponents[joinStartIndex]) {\n                break;\n            }\n        }\n\n        // Get the relative path\n        if (joinStartIndex != 0) {\n            var relativePath = "";\n            var relativePathComponents = modComponents.slice(joinStartIndex, modComponents.length);\n            for (; joinStartIndex < fixedModComponents.length; joinStartIndex++) {\n                if (fixedModComponents[joinStartIndex] != "") {\n                    relativePath = relativePath + "../";\n      ';
var v27572 = v27573 + '          }\n            }\n\n            return relativePath + relativePathComponents.join("/");\n        }\n\n        return absoluteModPath;\n    }\n\n    export function quoteBaseName(modPath: string) {\n        var modName = trimModName(stripQuotes(modPath));\n        var path = getRootFilePath(modName);\n        if (path == "") {\n            return modPath;\n        }\n        else {\n            var components = modName.split(path);\n            var fileIndex = components.length > 1 ? 1 : 0;\n            return quoteStr(components[fileIndex]);\n        }\n    }\n\n    export function changePathToSTR(modPath: string) {\n        return trimModName(stripQuotes(modPath)) + ".str";\n    }\n\n    export function changePathToDSTR(modPath: string) {\n        return trimModName(stripQuotes(modPath)) + ".d.str";\n    }\n\n    export function changePathToTS(modPath: string) {\n        return trimModName(stripQuotes(modPath)) + ".ts";\n    }\n\n    export function changePathToDTS(modPath: string) {\n        return trimModName(stripQuotes(modPath)) + ".d.ts";\n    }\n\n    export function isRelative(path: string) {\n        return path.charAt(0) == ".";\n    }\n    export function isRooted(path: string) {\n        return path.charAt(0) == "\\\\" || path.charAt(0) == "/" || (path.indexOf(":\\\\") != -1) || (path.indexOf(":/") != -1);\n    }\n\n    export function getRootFilePath(outFname: string) {\n        if (outFname == "") {\n            return outFname;\n        }\n        else {\n            var isPath = outFname.indexOf("/") != -1;\n            return isPath ? filePath(outFname) : "";\n        }\n    }\n\n    export function filePathComponents(fullPath: string) {\n        fullPath = switchToForwardSlashes(fullPath);\n        var components = getPathComponents(fullPath);\n        return components.slice(0, components.length - 1);\n    }\n\n    export function filePath(fullPath: string) {\n        var path = filePathComponents(fullPath);\n        return path.join("/") + "/";\n    }\n\n    export function normalizeURL(url: string): string {\n        var hostDomainAndPortRegex = /^(https?:\\/\\/[\\-\\w\\.]+(:\\d+)?\\/)(.*)$/i;\n        var matches = hostDomainAndPortRegex.exec(url);\n        if (matches) {\n            var hostDomainAndPort = matches[1];\n            var actualPath = matches[3];\n            return hostDomainAndPort + normalizePath(actualPath);\n        }\n        return normalizePath(url);\n    }\n\n    export var pathNormalizeRegExp = /\\//g;\n\n    export function normalizePath(path: string): string {\n        path = switchToForwardSlashes(path);\n        var startedWithSep = path.charAt(0) === "/";\n        var parts = this.getPathComponents(path);\n        for (var i = 0; i < parts.length; i++) {\n            if (parts[i] === "." || parts[i] === "") {\n                parts.splice(i, 1);\n                i--;\n            }\n            if (i > 0 && parts[i] === ".." && parts[i - 1] !== "..") {\n                parts.splice(i - 1, 2);\n                i -= 2;\n            }\n        }\n        return (startedWithSep ? "/" : "") + parts.join("/");\n    }\n\n    export function normalizeImportPath(path: string): string {\n        return normalizePath(path);\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    /// Compiler settings\n\n    export class StyleSettings {\n        // bitwise operations not permitted\n        public bitwise = false;  \n        // disallow non-block statements as bodies of compound statements\n        public blockInCompoundStmt = false;\n        // disallow == and !=\n        public eqeqeq = false;\n        // require body of for in loop to start with a filter\n        public forin = false;\n        // empty blocks permitted\n        public emptyBlocks = true;\n        // require result of new expression to be used (no new just for side-effects)\n        public newMustBeUsed = false;\n        // require semicolons to terminate statements\n        public requireSemi = false;\n        // no top-level assignment in conditionals if (a=b) { ...\n        public assignmentInCond = false;\n        // no == null or != null\n        public eqnull = false;\n        // permit eval\n        public evalOK = true;\n        // permit var use if decl in inner scope as in if (c) { var v=10; } v=11;\n        public innerScopeDeclEscape = true;\n        // permit functions in loops\n        public funcInLoop = true;\n        // permit re-declaration of local variable \n        public reDecl';
var v27571 = v27572 + 'areLocal = true;\n        // permit obj[\'x\'] in addition to obj.x\n        public literalSubscript = true;\n        // flag implicit \'any\'\n        public implicitAny = false;\n\n        public setOption(opt: string, val: bool): bool {\n            var optExists = this[opt];\n            if (optExists !== undefined) {\n                this[opt] = val;\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n        \n        public parseOptions(str: string) {\n            var opts=str.split(";");\n            for (var i = 0, len = opts.length; i < len; i++) {\n                var opt = opts[i];\n                var val = true;\n                var colonIndex=opt.lastIndexOf(":");\n                if (colonIndex >= 0) {\n                    var valStr = opt.substring(colonIndex+1);\n                    opt = opt.substring(0, colonIndex);\n                    if (valStr == "off") {\n                        val = false;\n                    }\n                }\n                if (!this.setOption(opt, val)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    \n    export class CompilationSettings {\n        public styleSettings = new StyleSettings();\n        public propagateConstants = false;\n        public minWhitespace = false;\n        public parseOnly = false;\n        public errorRecovery = false;\n        public emitComments = false;\n        public watch = false;\n        public exec = false;\n        public resolve = true;\n        public controlFlow = false;\n        public printControlFlow = false;\n        public controlFlowUseDef = false;\n        public errorOnWith = true;\n        public preprocess = true;\n        public canCallDefinitionSignature = false;\n\n        public inferPropertiesFromThisAssignment = false;\n        public useDefaultLib = true;\n\n        public codeGenTarget = CodeGenTarget.ES3;\n        public moduleGenTarget = ModuleGenTarget.Synchronous;\n        // --out option passed. \n        // Default is the "" which leads to multiple files generated next to the.ts files\n        public outputOption: string = "";\n        public mapSourceFiles = false;\n        public generateDeclarationFiles = false;\n\n        public useCaseSensitiveFileResolution = false;\n\n        public setStyleOptions(str: string) {\n            this.styleSettings.parseOptions(str);\n        }\n    }\n\n    ///\n    /// Preprocessing\n    ///\n    export interface IPreProcessedFileInfo {\n        settings: CompilationSettings;\n        referencedFiles: IFileReference[];\n        importedFiles: IFileReference[];\n        isLibFile: bool;\n    }\n\n    function getFileReferenceFromReferencePath(comment: string): IFileReference {\n        var referencesRegEx = /^(\\/\\/\\/\\s*<reference\\s+path=)(\'|")(.+?)\\2\\s*(static=(\'|")(.+?)\\2\\s*)*\\/>/gim;\n        var match = referencesRegEx.exec(comment);\n\n        if (match) {\n            var path: string = normalizePath(match[3]);\n            var adjustedPath = normalizePath(path);\n    \n            var isResident = match.length >= 7 && match[6] == "true";\n            if (isResident) {\n                CompilerDiagnostics.debugPrint(path + " is resident");\n            }\n            return { minChar: 0, limChar: 0, path: switchToForwardSlashes(adjustedPath), isResident: isResident };\n        }\n        else {\n            return null;\n        }\n    }\n\n    // used in the parser, but kept here in case we want to reintegrate it with preprocessing\n    export function getAdditionalDependencyPath(comment: string): string {\n        var amdDependencyRegEx = /^(\\/\\/\\/\\s*<amd-dependency\\s+path=)(\'|")(.+?)\\2\\s*(static=(\'|")(.+?)\\2\\s*)*\\/>/gim;\n        var match = amdDependencyRegEx.exec(comment);\n\n        if (match) {\n            var path: string = match[3];\n            return path;\n        }\n        else {\n            return null;\n        }\n    }\n\n    export function getImplicitImport(comment: string): bool {\n        var implicitImportRegEx = /^(\\/\\/\\/\\s*<implicit-import\\s*)*\\/>/gim;\n        var match = implicitImportRegEx.exec(comment);\n\n        if (match) {\n            return true;\n        }\n        \n        return false;\n    }\n\n    export function getStyleSettings(comment: string, styleSettings: StyleSettings) {\n        var styleRegEx = /^(\\/\\/\\/\\s*<style\\s+)(([a-zA-Z])+=(\'|").+(\'|"))\\s*\\/>/gim;\n\n        var settings = styleRegEx.exec(comment);\n\n        if (settings) {\n            var settingsRegEx = /^([a-zA-Z]+=[\'"]on[\'|"])/gim;\n            settings = settingsRegEx.exec(settings[2]);\n                \n            if (settings) {\n                for (var i = 0; i < settings.length; i++) {\n                    var setting = (<string>settings[i]).split("=");\n                    var on = "\\"on\\"";\n\n                    switch (setting[0]) {\n                        case "blockInCompoundStmt": styleSettings.blockInCompoundStmt = setting[1] == on; break;\n                        case "eqeqeq": styleSettings.eqeqeq = setting[1] == on; break;';
var v27570 = v27571 + '\n                        case "forin": styleSettings.forin = setting[1] == on; break;\n                        case "emptyBlocks": styleSettings.emptyBlocks = setting[1] == on; break;\n                        case "newMustBeUsed": styleSettings.newMustBeUsed = setting[1] == on; break;\n                        case "requireSemi": styleSettings.requireSemi = setting[1] == on; break;\n                        case "assignmentInCond": styleSettings.assignmentInCond = setting[1] == on; break;\n                        case "eqnull": styleSettings.eqnull = setting[1] == on; break;\n                        case "evalOK": styleSettings.evalOK = setting[1] == on; break;\n                        case "innerScopeDeclEscape": styleSettings.innerScopeDeclEscape = setting[1] == on; break;\n                        case "funcInLoop": styleSettings.funcInLoop = setting[1] == on; break;\n                        case "reDeclareLocal": styleSettings.reDeclareLocal = setting[1] == on; break;\n                        case "literalSubscript": styleSettings.literalSubscript = setting[1] == on; break;\n                        case "implicitAny": styleSettings.implicitAny = setting[1] == on; break;                               \n                    }\n                }\n            }\n        }\n    }\n\n    export function getReferencedFiles(sourceText: ISourceText): IFileReference[] {\n        var preProcessInfo = preProcessFile(sourceText, null, false);\n        return preProcessInfo.referencedFiles;\n    }\n\n    export function preProcessFile(sourceText: ISourceText, options=new CompilationSettings(), readImportFiles? = true): IPreProcessedFileInfo {\n        var scanner = new Scanner();\n        scanner.resetComments();\n        scanner.setSourceText(sourceText, LexMode.File);\n\n        var tok: Token = scanner.scan();\n        var comments: CommentToken[] = [];\n        var comment: CommentToken = null;\n        var leftCurlies: Token[] = [];\n\n        var settings: CompilationSettings = options;\n        var referencedFiles: IFileReference[] = [];\n        var importedFiles: IFileReference[] = [];\n        var isLibFile: bool = false;\n\n        // only search out dynamic mods\n        // if you find a dynamic mod, ignore every other mod inside, until you balance rcurlies\n\n        while (tok.tokenId != TokenID.EndOfFile) {\n\n            if (readImportFiles && tok.tokenId == TokenID.Import) {\n\n                tok = scanner.scan();\n\n                if (tok.tokenId == TokenID.Identifier || convertTokToID(tok, false)) {\n                    tok = scanner.scan();\n\n                    if (tok.tokenId == TokenID.Equals) {\n                        tok = scanner.scan();\n\n                        if (tok.tokenId == TokenID.Module) {\n                            tok = scanner.scan();\n                            if (tok.tokenId == TokenID.OpenParen) {\n                                tok = scanner.scan();\n\n                                // import foo = module("foo")\n                                if (tok.tokenId == TokenID.StringLiteral) {\n                                    var ref = { minChar: scanner.startPos, limChar: scanner.pos, path: stripQuotes(switchToForwardSlashes(tok.getText())), isResident: false };\n                                    importedFiles.push(ref);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (tok.tokenId == TokenID.OpenBrace) {\n                leftCurlies.push(tok);\n            }\n\n            if (tok.tokenId == TokenID.CloseBrace) {\n                leftCurlies.pop();\n            }\n\n            tok = scanner.scan();\n        }\n\n        // deal with comment references, amd dependencies and style settings\n        // REVIEW: We could potentially do this inline with the above, if we\n        // set Scanner::scanComments to \'true\'\n        comments = scanner.getComments();\n\n        for (var iComment = 0; iComment < comments.length; iComment++) {\n            comment = comments[iComment];\n            \n            if (!comment.isBlock) {\n                var referencedCode = getFileReferenceFromReferencePath(comment.getText());\n                if (referencedCode) {\n                    referencedCode.minChar = comment.startPos;\n                    referencedCode.limChar = referencedCode.minChar + comment.value.length;\n                    referencedFiles.push(referencedCode);\n                }\n\n                if (settings) {\n                    getStyleSettings(comment.getText(), settings.styleSettings);\n\n                    // is it a lib file?\n                    var isNoLibRegex = /^(\\/\\/\\/\\s*<reference\\s+no-default-lib=)(\'|")(.+?)\\2\\s*\\/>/gim;\n                    var isNoLibMatch: any = isNoLibRegex.exec(comment.getText());\n                    if (isNoLibMatch) {\n                        isLibFile = (isNoLibMatch[3] == "true");\n                    }\n                }\n            }\n        }\n\n        return { settings: settings, referencedFiles: refere';
var v27569 = v27570 + 'ncedFiles, importedFiles: importedFiles, isLibFile: isLibFile };\n    }\n\n} // Tools//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    // TODO: refactor indent logic for use in emit\n    export class PrintContext {\n        public builder = "";\n        public indent1 = "  ";\n        public indentStrings: string[] = [];\n        public indentAmt = 0;\n\n        constructor (public outfile: ITextWriter, public parser: Parser) {\n        }\n\n        public increaseIndent() {\n            this.indentAmt++;\n        }\n\n        public decreaseIndent() {\n            this.indentAmt--;\n        }\n\n        public startLine() {\n            if (this.builder.length > 0) {\n                CompilerDiagnostics.Alert(this.builder);\n            }\n            var indentString = this.indentStrings[this.indentAmt];\n            if (indentString === undefined) {\n                indentString = "";\n                for (var i = 0; i < this.indentAmt; i++) {\n                    indentString += this.indent1;\n                }\n                this.indentStrings[this.indentAmt] = indentString;\n            }\n            this.builder += indentString;\n        }\n\n        public write(s) {\n            this.builder += s;\n        }\n\n        public writeLine(s) {\n            this.builder += s;\n            this.outfile.WriteLine(this.builder);\n            this.builder = "";\n        }\n\n    }\n\n    export function prePrintAST(ast: AST, parent: AST, walker: IAstWalker) {\n        var pc: PrintContext = <PrintContext>walker.state;\n\n        ast.print(pc);\n        pc.increaseIndent();\n        return ast;\n    }\n\n\n    export function postPrintAST(ast: AST, parent: AST, walker: IAstWalker) {\n        var pc: PrintContext = <PrintContext>walker.state;\n        pc.decreaseIndent();\n        return ast;\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export interface IResolvedFile {\n        content: string;\n        path: string;\n    }\n\n    /// This class acts as a convenience class to store path and content information in places\n    /// where we need an ISourceText object\n    export class SourceUnit implements ISourceText, IResolvedFile {\n        public referencedFiles: IFileReference[] = null;\n        constructor(public path: string, public content: string) {\n        }\n\n        public getText(start: number, end: number): string { return this.content.substring(start, end); }\n        public getLength(): number { return this.content.length; }\n    }\n\n    export interface IFileReference {\n        minChar: number;\n        limChar: number;\n        path: string;\n        isResident: bool;\n    }\n\n    /// Limited API for file system manipulation\n    export interface IFileSystemObject {\n        resolvePath(path: string): string;\n        readFile(path: string): string;\n        findFile(rootPath: string, partialFilePath: string): IResolvedFile;\n        dirName(path: string): string;\n    }\n\n    export class CompilationEnvironment {\n        constructor (public compilationSettings: CompilationSettings, public ioHost: IFileSystemObject) { }\n        public residentCode: SourceUnit[] = [];\n        public code: SourceUnit[] = [];\n    }\n\n    export interface IResolutionDispatcher {\n        postResolutionError(errorFile: string, errorMessage: string, errorObject: any): void;\n        postResolution(path: string, source: ISourceText): void;\n    }\n\n    export interface ICodeResolver {\n        resolveCode(referencePath: string, rootPath: string, performSearch:bool, state: IResolutionDispatcher): void;\n    }\n\n    export interface IResolverHost {\n        resolveCompilationEnvironment(preEnvironment: CompilationEnvironment, resolver: ICodeResolver, traceDependencies: bool): CompilationEnvironment;\n    }\n\n    export class CodeResolver implements T';
var v27568 = v27569 + 'ypeScript.ICodeResolver {\n        public visited: any = { };\n\n        constructor (public environment: CompilationEnvironment) { }\n\n        public resolveCode(referencePath: string, parentPath: string, performSearch: bool, resolutionDispatcher: TypeScript.IResolutionDispatcher): void {\n            \n            var resolvedFile: IResolvedFile = { content: null, path: referencePath };\n            \n            var ioHost = this.environment.ioHost;\n            \n            // If the path is relative, normalize it, based on the root\n            var isRelativePath = TypeScript.isRelative(referencePath);\n            var isRootedPath = isRelativePath ? false : isRooted(referencePath);\n            var normalizedPath: string = \n                isRelativePath ? ioHost.resolvePath(parentPath + "/" + referencePath) : \n                // we only follow the second clause if the path is a non-rooted triple-slash reference path\n                (isRootedPath || !parentPath || performSearch ? referencePath : parentPath + "/" + referencePath);\n\n            // We use +=.ts to make sure we don\'t accidentally pick up ".js" files or the like\n            if (!isSTRFile(normalizedPath) && !isTSFile(normalizedPath)) {\n                normalizedPath += ".ts";  //changePathToSTR(normalizedPath);\n            }\n\n            normalizedPath = switchToForwardSlashes(stripQuotes(normalizedPath));\n            var absoluteModuleID = this.environment.compilationSettings.useCaseSensitiveFileResolution ? normalizedPath : normalizedPath.toLocaleUpperCase();\n            // read the file contents - if it doesn\'t exist, trigger a resolution error\n            if (!this.visited[absoluteModuleID]) {\n\n                // if the path is relative, or came from a reference tag, we don\'t perform a search\n                if (isRelativePath || isRootedPath || !performSearch) {\n                    try {\n                        CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);\n                            \n                        // Look for the .ts file first - if not present, use the .ts, the .d.str and the .d.ts\n                        try {\n                            resolvedFile.content = ioHost.readFile(normalizedPath);\n                        }\n                        catch (err) {\n                            try {\n                                if (isSTRFile(normalizedPath)) {\n                                    normalizedPath = changePathToTS(normalizedPath);\n                                }\n                                else if (isTSFile(normalizedPath)) {\n                                    normalizedPath = changePathToSTR(normalizedPath);\n                                }\n                                CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);\n                                resolvedFile.content = ioHost.readFile(normalizedPath);\n                            }\n                            catch (err) {\n                                normalizedPath = changePathToDSTR(normalizedPath);\n                                CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);\n\n                                try {\n                                    resolvedFile.content = ioHost.readFile(normalizedPath);\n                                }\n                                catch (err) {\n                                    normalizedPath = changePathToDTS(normalizedPath);\n                                    CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);\n                                    resolvedFile.content = ioHost.readFile(normalizedPath);\n                                }\n                            }\n                        }\n                        CompilerDiagnostics.debugPrint("   Found code at " + normalizedPath);\n\n                        resolvedFile.path = normalizedPath;\n                        this.visited[absoluteModuleID] = true;\n                    }\n                    catch (err) {\n                        CompilerDiagnostics.debugPrint("   Did not find code for " + referencePath);\n                    }\n                }\n                else {\n\n                    // if the path is non-relative, we should attempt to search on the relative path\n                    resolvedFile = ioHost.findFile(parentPath, normalizedPath);\n\n                    if (!resolvedFile) {\n                        if (isSTRFile(normalizedPath)) {\n                            normalizedPath = changePathToTS(normalizedPath);\n                        }\n                        else if (isTSFile(normalizedPath)) {\n                            normalizedPath = changePathToSTR(normalizedPath);\n                        }\n                        resolvedFile = ioHost.findFile(parentPath, normalizedPath);\n                    }\n\n                    if (!resolvedFile) {\n                        normalizedPath = changePathToDTS(normalizedPath);\n                        resolvedFile = ioHo';
var v27567 = v27568 + "st.findFile(parentPath, normalizedPath);\n                        if (!resolvedFile) {\n                            normalizedPath = changePathToDSTR(normalizedPath);\n                            resolvedFile = ioHost.findFile(parentPath, normalizedPath);\n                        }\n                    }\n\n                    if (resolvedFile) {\n                        resolvedFile.path = switchToForwardSlashes(TypeScript.stripQuotes(resolvedFile.path));\n                        CompilerDiagnostics.debugPrint(referencePath + \" resolved to: \" + resolvedFile.path);\n                        resolvedFile.content = resolvedFile.content;\n                        this.visited[absoluteModuleID] = true;\n                    }\n                    else {\n                        CompilerDiagnostics.debugPrint(\"Could not find \" + referencePath);\n                    }\n                }\n\n                if (resolvedFile && resolvedFile.content != null) {\n                    // preprocess the file, to gather dependencies\n                    var rootDir = ioHost.dirName(resolvedFile.path);\n                    var sourceUnit = new SourceUnit(resolvedFile.path, resolvedFile.content);\n                    var preProcessedFileInfo = preProcessFile(sourceUnit, this.environment.compilationSettings);\n                    sourceUnit.referencedFiles = preProcessedFileInfo.referencedFiles;\n\n                    // resolve explicit references\n                    for (var i = 0; i < preProcessedFileInfo.referencedFiles.length; i++) {\n                        var referencedFile = preProcessedFileInfo.referencedFiles[i];\n                        var normalizedPath = isRooted(referencedFile.path) ? referencedFile.path : rootDir + \"/\" + referencedFile.path;\n                        normalizedPath = ioHost.resolvePath(normalizedPath);\n                        if (referencePath == normalizedPath) {\n                            resolutionDispatcher.postResolutionError(normalizedPath, \"File contains reference to itself\", null);\n                            continue;\n                        }\n                        this.resolveCode(referencedFile.path, rootDir, false, resolutionDispatcher);\n                    }\n                    \n                    // resolve imports\n                    for (var i = 0; i < preProcessedFileInfo.importedFiles.length; i++) {\n                        this.resolveCode(preProcessedFileInfo.importedFiles[i].path, rootDir, true, resolutionDispatcher);\n                    }\n\n                    // add the file to the appropriate code list\n                    resolutionDispatcher.postResolution(sourceUnit.path, sourceUnit);\n                }\n            }\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path='typescript.ts' />\n\nmodule TypeScript {\n\n    export var LexEOF = (-1);\n\n    export var LexCodeNWL = 0x0A;\n    export var LexCodeRET = 0x0D;\n    export var LexCodeLS =  0x2028;\n    export var LexCodePS =  0x2029;\n    export var LexCodeTAB = 0x09;\n    export var LexCodeVTAB = 0x0B;\n    export var LexCode_e = 'e'.charCodeAt(0);\n    export var LexCode_E = 'E'.charCodeAt(0);\n    export var LexCode_x = 'x'.charCodeAt(0);\n    export var LexCode_X = 'X'.charCodeAt(0);\n    export var LexCode_a = 'a'.charCodeAt(0);\n    export var LexCode_A = 'A'.charCodeAt(0);\n    export var LexCode_f = 'f'.charCodeAt(0);\n    export var LexCode_F = 'F'.charCodeAt(0);\n\n    export var LexCode_g = 'g'.charCodeAt(0);\n    export var LexCode_m = 'm'.charCodeAt(0);\n    export var LexCode_i = 'i'.charCodeAt(0);\n\n    export var LexCode_u = 'u'.charCodeAt(0);\n\n    export var LexCode_0 = '0'.charCodeAt(0);\n    export var LexCode_9 = '9'.charCodeAt(0);\n    export var LexCode_8 = '8'.charCodeAt(0);\n    export var LexCode_7 = '7'.charCodeAt(0);\n\n    export var LexCodeBSL = '\\\\'.charCodeAt(0);\n    export var LexCodeSHP = '#'.charCodeAt(0);\n    export var LexCodeBNG = '!'.charCodeAt(0);\n    export var LexCodeQUO = '\"'.charCodeAt(0);\n    export var LexCodeAPO = '\\''.charCodeAt(0);\n    export var LexCodePCT = '%'.charCodeAt(0);\n    export var LexCodeAMP = '&'.charCodeAt(0);\n    export var LexCodeLPR = '('.charCodeAt(0);\n    export var LexCodeRPR = ')'.charCodeAt(0);\n    export var LexCodePLS = '+'.charCodeAt(0);\n    export var LexCodeMIN = '-'.charCodeAt(0);\n    export var LexCodeMUL = '*'.charCodeAt(0);\n    export var LexCodeSLH = '/'.charCodeAt(0);\n    export var LexCodeXOR = '^'.";
var v27566 = v27567 + "charCodeAt(0);\n    export var LexCodeCMA = ','.charCodeAt(0);\n    export var LexCodeDOT = '.'.charCodeAt(0);\n    export var LexCodeLT = '<'.charCodeAt(0);\n    export var LexCodeEQ = '='.charCodeAt(0);\n    export var LexCodeGT = '>'.charCodeAt(0);\n    export var LexCodeQUE = '?'.charCodeAt(0);\n    export var LexCodeLBR = '['.charCodeAt(0);\n    export var LexCodeRBR = ']'.charCodeAt(0);\n    export var LexCodeUSC = '_'.charCodeAt(0);\n    export var LexCodeLC = '{'.charCodeAt(0);\n    export var LexCodeRC = '}'.charCodeAt(0);\n    export var LexCodeBAR = '|'.charCodeAt(0);\n    export var LexCodeTIL = '~'.charCodeAt(0);\n    export var LexCodeCOL = ':'.charCodeAt(0);\n    export var LexCodeSMC = ';'.charCodeAt(0);\n    export var LexCodeUnderscore = '_'.charCodeAt(0);\n    export var LexCodeDollar = '$'.charCodeAt(0);\n    export var LexCodeSpace = 32;\n    export var LexCodeAtSign = '@'.charCodeAt(0);\n    export var LexCodeASCIIChars = 128;\n\n    export var LexKeywordTable = undefined;\n    // TODO: use new Token[128];\n    var autoToken: Token[] = new Array(LexCodeASCIIChars);\n    var lexIdStartTable: bool[] = new Array(LexCodeASCIIChars);\n\n    // Unicode range maps\n    // REVIEW: These range maps have been extracted from the Unicode specifications, they might be missing values, and/or include \n    //         incorrect ranges. but for the most they seem to be correct. A more accurate and thorough review is needed.\n\n    /*\n        As per ECMAScript Language Specification 3th Edition, Section 7.6: Identifiers\n        IdentifierStart :: Can contain Unicode 3.0.0  categories Uppercase letter (Lu), Lowercase letter (Ll), Titlecase letter (Lt), Modifier letter (Lm), Other letter (Lo), or Letter number (Nl).\n        IdentifierPart :: Can contain IdentifierStart + Unicode 3.0.0  categories Non-spacing mark (Mn), Combining spacing mark (Mc), Decimal number (Nd), or Connector punctuation (Pc).\n                    \n        Codepoint ranges for ES3 Identifiers are extracted from the Unicode 3.0.0 specification at:\n        http://www.unicode.org/Public/3.0-Update/UnicodeData-3.0.0.txt\n    */\n    var unicodeES3IdStart = [\n\t\t170, 170,181, 181,186, 186,192, 214,216, 246,248, 543,546, 563,592, 685,688, 696,699, 705,720, 721,736, 740,750, 750,890, 890,902, 902,904, 906,908, 908,910, 929,931, 974,976, 983,986, 1011,1024, 1153,1164, 1220,1223, 1224,1227, 1228,1232, 1269,1272, 1273,1329, 1366,1369, 1369,1377, 1415,1488, 1514,\n\t\t1520, 1522,1569, 1594,1600, 1610,1649, 1747,1749, 1749,1765, 1766,1786, 1788,1808, 1808,1810, 1836,1920, 1957,2309, 2361,2365, 2365,2384, 2384,2392, 2401,2437, 2444,2447, 2448,2451, 2472,2474, 2480,2482, 2482,2486, 2489,2524, 2525,2527, 2529,2544, 2545,2565, 2570,2575, 2576,2579, 2600,2602, 2608,2610, 2611,\n\t\t2613, 2614,2616, 2617,2649, 2652,2654, 2654,2674, 2676,2693, 2699,2701, 2701,2703, 2705,2707, 2728,2730, 2736,2738, 2739,2741, 2745,2749, 2749,2768, 2768,2784, 2784,2821, 2828,2831, 2832,2835, 2856,2858, 2864,2866, 2867,2870, 2873,2877, 2877,2908, 2909,2911, 2913,2949, 2954,2958, 2960,2962, 2965,2969, 2970,\n\t\t2972, 2972,2974, 2975,2979, 2980,2984, 2986,2990, 2997,2999, 3001,3077, 3084,3086, 3088,3090, 3112,3114, 3123,3125, 3129,3168, 3169,3205, 3212,3214, 3216,3218, 3240,3242, 3251,3253, 3257,3294, 3294,3296, 3297,3333, 3340,3342, 3344,3346, 3368,3370, 3385,3424, 3425,3461, 3478,3482, 3505,3507, 3515,3517, 3517,\n\t\t3520, 3526,3585, 3632,3634, 3635,3648, 3654,3713, 3714,3716, 3716,3719, 3720,3722, 3722,3725, 3725,3732, 3735,3737, 3743,3745, 3747,3749, 3749,3751, 3751,3754, 3755,3757, 3760,3762, 3763,3773, 3773,3776, 3780,3782, 3782,3804, 3805,3840, 3840,3904, 3911,3913, 3946,3976, 3979,4096, 4129,4131, 4135,4137, 4138,\n\t\t4176, 4181,4256, 4293,4304, 4342,4352, 4441,4447, 4514,4520, 4601,4608, 4614,4616, 4678,4680, 4680,4682, 4685,4688, 4694,4696, 4696,4698, 4701,4704, 4742,4744, 4744,4746, 4749,4752, 4782,4784, 4784,4786, 4789,4792, 4798,4800, 4800,4802, 4805,4808, 4814,4816, 4822,4824, 4846,4848, 4878,4880, 4880,4882, 4885,\n\t\t4888, 4894,4896, 4934,4936, 4954,5024, 5108,5121, 5740,5743, 5750,5761, 5786,5792, 5866,6016, 6067,6176, 6263,6272, 6312,7680, 7835,7840, 7929,7936, 7957,7960, 7965,7968, 8005,8008, 8013,8016, 8023,8025, 8025,8027, 8027,8029, 8029,8031, 8061,8064, 8116,8118, 8124,8126, 8126,8130, 8132,8134, 8140,8144, 8147,\n\t\t8150, 8155,8160, 8172,8178, 8180,8182, 8188,8319, 8319,8450, 8450,8455, 8455,8458, 8467,8469, 8469,8473, 8477,8484, 8484,8486, 8486,8488, 8488,8490, 8493,8495, 8497,8499, 8505,8544, 8579,12293, 12295,12321, 12329,12337, 12341,12344, 12346,12353, 12436,12445, 12446,12449, 12538,12540, 12542,12549, 12588,\n\t\t12593, 12686,12704, 12727,13312, 13312,19893, 19893,19968, 19968,40869, 40869,40960, 42124,44032, 44032,55203, 55203,63744, 64045,64256, 64262,64275, 64279,64285, 64285,64287, 64296,64298, 64310,64312, 64316,64318, 64318,64320, 64321,64323, 64324,64326, 64433,64467, 64829,64848, 64911,64914, 64967,\n\t\t65008, 65019,65136, 65138,65140, 65140,65142, 65276,65313, 65338,65345, 65370,65382, 654";
var v27565 = v27566 + "70,65474, 65479,65482, 65487,65490, 65495,65498, 65500\n\t];\n\n\tvar unicodeES3IdCont = [\n\t\t768, 846,864, 866,1155, 1158,1425, 1441,1443, 1465,1467, 1469,1471, 1471,1473, 1474,1476, 1476,1611, 1621,1632, 1641,1648, 1648,1750, 1756,1759, 1764,1767, 1768,1770, 1773,1776, 1785,1809, 1809,1840, 1866,1958, 1968,2305, 2307,2364, 2364,2366, 2381,2385, 2388,2402, 2403,2406, 2415,2433, 2435,2492, 2492,\n\t\t2494, 2500,2503, 2504,2507, 2509,2519, 2519,2530, 2531,2534, 2543,2562, 2562,2620, 2620,2622, 2626,2631, 2632,2635, 2637,2662, 2673,2689, 2691,2748, 2748,2750, 2757,2759, 2761,2763, 2765,2790, 2799,2817, 2819,2876, 2876,2878, 2883,2887, 2888,2891, 2893,2902, 2903,2918, 2927,2946, 2947,3006, 3010,3014, 3016,\n\t\t3018, 3021,3031, 3031,3047, 3055,3073, 3075,3134, 3140,3142, 3144,3146, 3149,3157, 3158,3174, 3183,3202, 3203,3262, 3268,3270, 3272,3274, 3277,3285, 3286,3302, 3311,3330, 3331,3390, 3395,3398, 3400,3402, 3405,3415, 3415,3430, 3439,3458, 3459,3530, 3530,3535, 3540,3542, 3542,3544, 3551,3570, 3571,3633, 3633,\n\t\t3636, 3642,3655, 3662,3664, 3673,3761, 3761,3764, 3769,3771, 3772,3784, 3789,3792, 3801,3864, 3865,3872, 3881,3893, 3893,3895, 3895,3897, 3897,3902, 3903,3953, 3972,3974, 3975,3984, 3991,3993, 4028,4038, 4038,4140, 4146,4150, 4153,4160, 4169,4182, 4185,4969, 4977,6068, 6099,6112, 6121,6160, 6169,6313, 6313,\n\t\t8255, 8256,8400, 8412,8417, 8417,12330, 12335,12441, 12442,12539, 12539,64286, 64286,65056, 65059,65075, 65076,65101, 65103,65296, 65305,65343, 65343,65381, 65381\n\t];\n\n\n    /*\n        As per ECMAScript Language Specification 5th Edition, Section 7.6: Identifier Names and Identifiers\n        IdentifierStart :: Can contain Unicode 6.2  categories Uppercase letter (Lu), Lowercase letter (Ll), Titlecase letter (Lt), Modifier letter (Lm), Other letter (Lo), or Letter number (Nl).\n        IdentifierPart :: Can contain IdentifierStart + Unicode 6.2  categories Non-spacing mark (Mn), Combining spacing mark (Mc), Decimal number (Nd), Connector punctuation (Pc), <ZWNJ>, or <ZWJ>.\n                    \n        Codepoint ranges for ES5 Identifiers are extracted from the Unicode 6.2 specification at:\n        http://www.unicode.org/Public/6.2.0/ucd/UnicodeData.txt\n    */\n\tvar unicodeES5IdStart = [\n\t\t170, 170,181, 181,186, 186,192, 214,216, 246,248, 705,710, 721,736, 740,748, 748,750, 750,880, 884,886, 887,890, 893,902, 902,904, 906,908, 908,910, 929,931, 1013,1015, 1153,1162, 1319,1329, 1366,1369, 1369,1377, 1415,1488, 1514,1520, 1522,1568, 1610,1646, 1647,1649, 1747,1749, 1749,1765, 1766,1774, 1775,\n\t\t1786, 1788,1791, 1791,1808, 1808,1810, 1839,1869, 1957,1969, 1969,1994, 2026,2036, 2037,2042, 2042,2048, 2069,2074, 2074,2084, 2084,2088, 2088,2112, 2136,2208, 2208,2210, 2220,2308, 2361,2365, 2365,2384, 2384,2392, 2401,2417, 2423,2425, 2431,2437, 2444,2447, 2448,2451, 2472,2474, 2480,2482, 2482,2486, 2489,\n\t\t2493, 2493,2510, 2510,2524, 2525,2527, 2529,2544, 2545,2565, 2570,2575, 2576,2579, 2600,2602, 2608,2610, 2611,2613, 2614,2616, 2617,2649, 2652,2654, 2654,2674, 2676,2693, 2701,2703, 2705,2707, 2728,2730, 2736,2738, 2739,2741, 2745,2749, 2749,2768, 2768,2784, 2785,2821, 2828,2831, 2832,2835, 2856,2858, 2864,\n\t\t2866, 2867,2869, 2873,2877, 2877,2908, 2909,2911, 2913,2929, 2929,2947, 2947,2949, 2954,2958, 2960,2962, 2965,2969, 2970,2972, 2972,2974, 2975,2979, 2980,2984, 2986,2990, 3001,3024, 3024,3077, 3084,3086, 3088,3090, 3112,3114, 3123,3125, 3129,3133, 3133,3160, 3161,3168, 3169,3205, 3212,3214, 3216,3218, 3240,\n\t\t3242, 3251,3253, 3257,3261, 3261,3294, 3294,3296, 3297,3313, 3314,3333, 3340,3342, 3344,3346, 3386,3389, 3389,3406, 3406,3424, 3425,3450, 3455,3461, 3478,3482, 3505,3507, 3515,3517, 3517,3520, 3526,3585, 3632,3634, 3635,3648, 3654,3713, 3714,3716, 3716,3719, 3720,3722, 3722,3725, 3725,3732, 3735,3737, 3743,\n\t\t3745, 3747,3749, 3749,3751, 3751,3754, 3755,3757, 3760,3762, 3763,3773, 3773,3776, 3780,3782, 3782,3804, 3807,3840, 3840,3904, 3911,3913, 3948,3976, 3980,4096, 4138,4159, 4159,4176, 4181,4186, 4189,4193, 4193,4197, 4198,4206, 4208,4213, 4225,4238, 4238,4256, 4293,4295, 4295,4301, 4301,4304, 4346,4348, 4680,\n\t\t4682, 4685,4688, 4694,4696, 4696,4698, 4701,4704, 4744,4746, 4749,4752, 4784,4786, 4789,4792, 4798,4800, 4800,4802, 4805,4808, 4822,4824, 4880,4882, 4885,4888, 4954,4992, 5007,5024, 5108,5121, 5740,5743, 5759,5761, 5786,5792, 5866,5870, 5872,5888, 5900,5902, 5905,5920, 5937,5952, 5969,5984, 5996,5998, 6000,\n\t\t6016, 6067,6103, 6103,6108, 6108,6176, 6263,6272, 6312,6314, 6314,6320, 6389,6400, 6428,6480, 6509,6512, 6516,6528, 6571,6593, 6599,6656, 6678,6688, 6740,6823, 6823,6917, 6963,6981, 6987,7043, 7072,7086, 7087,7098, 7141,7168, 7203,7245, 7247,7258, 7293,7401, 7404,7406, 7409,7413, 7414,7424, 7615,7680, 7957,\n\t\t7960, 7965,7968, 8005,8008, 8013,8016, 8023,8025, 8025,8027, 8027,8029, 8029,8031, 8061,8064, 8116,8118, 8124,8126, 8126,8130, 8132,8134, 8140,8144, 8147,8150, 8155,8160, 8172,8178, 8180,8182, 8188,8305, 8305,8319, 8319,8336, 8348,8450, 8450,8455, 8455,8458, 8467,8469, 8469,8473, 8477,84";
var v27564 = v27565 + "84, 8484,8486, 8486,\n\t\t8488, 8488,8490, 8493,8495, 8505,8508, 8511,8517, 8521,8526, 8526,8544, 8584,11264, 11310,11312, 11358,11360, 11492,11499, 11502,11506, 11507,11520, 11557,11559, 11559,11565, 11565,11568, 11623,11631, 11631,11648, 11670,11680, 11686,11688, 11694,11696, 11702,11704, 11710,11712, 11718,11720, 11726,\n\t\t11728, 11734,11736, 11742,11823, 11823,12293, 12295,12321, 12329,12337, 12341,12344, 12348,12353, 12438,12445, 12447,12449, 12538,12540, 12543,12549, 12589,12593, 12686,12704, 12730,12784, 12799,13312, 13312,19893, 19893,19968, 19968,40908, 40908,40960, 42124,42192, 42237,42240, 42508,42512, 42527,\n\t\t42538, 42539,42560, 42606,42623, 42647,42656, 42735,42775, 42783,42786, 42888,42891, 42894,42896, 42899,42912, 42922,43000, 43009,43011, 43013,43015, 43018,43020, 43042,43072, 43123,43138, 43187,43250, 43255,43259, 43259,43274, 43301,43312, 43334,43360, 43388,43396, 43442,43471, 43471,43520, 43560,\n\t\t43584, 43586,43588, 43595,43616, 43638,43642, 43642,43648, 43695,43697, 43697,43701, 43702,43705, 43709,43712, 43712,43714, 43714,43739, 43741,43744, 43754,43762, 43764,43777, 43782,43785, 43790,43793, 43798,43808, 43814,43816, 43822,43968, 44002,44032, 44032,55203, 55203,55216, 55238,55243, 55291,\n\t\t63744, 64109,64112, 64217,64256, 64262,64275, 64279,64285, 64285,64287, 64296,64298, 64310,64312, 64316,64318, 64318,64320, 64321,64323, 64324,64326, 64433,64467, 64829,64848, 64911,64914, 64967,65008, 65019,65136, 65140,65142, 65276,65313, 65338,65345, 65370,65382, 65470,65474, 65479,65482, 65487,\n\t\t65490, 65495,65498, 65500\n\t];\n\n\tvar unicodeES5IdCont = [\n\t\t768, 879,1155, 1159,1425, 1469,1471, 1471,1473, 1474,1476, 1477,1479, 1479,1552, 1562,1611, 1641,1648, 1648,1750, 1756,1759, 1764,1767, 1768,1770, 1773,1776, 1785,1809, 1809,1840, 1866,1958, 1968,1984, 1993,2027, 2035,2070, 2073,2075, 2083,2085, 2087,2089, 2093,2137, 2139,2276, 2302,2304, 2307,2362, 2364,\n\t\t2366, 2383,2385, 2391,2402, 2403,2406, 2415,2433, 2435,2492, 2492,2494, 2500,2503, 2504,2507, 2509,2519, 2519,2530, 2531,2534, 2543,2561, 2563,2620, 2620,2622, 2626,2631, 2632,2635, 2637,2641, 2641,2662, 2673,2677, 2677,2689, 2691,2748, 2748,2750, 2757,2759, 2761,2763, 2765,2786, 2787,2790, 2799,2817, 2819,\n\t\t2876, 2876,2878, 2884,2887, 2888,2891, 2893,2902, 2903,2914, 2915,2918, 2927,2946, 2946,3006, 3010,3014, 3016,3018, 3021,3031, 3031,3046, 3055,3073, 3075,3134, 3140,3142, 3144,3146, 3149,3157, 3158,3170, 3171,3174, 3183,3202, 3203,3260, 3260,3262, 3268,3270, 3272,3274, 3277,3285, 3286,3298, 3299,3302, 3311,\n\t\t3330, 3331,3390, 3396,3398, 3400,3402, 3405,3415, 3415,3426, 3427,3430, 3439,3458, 3459,3530, 3530,3535, 3540,3542, 3542,3544, 3551,3570, 3571,3633, 3633,3636, 3642,3655, 3662,3664, 3673,3761, 3761,3764, 3769,3771, 3772,3784, 3789,3792, 3801,3864, 3865,3872, 3881,3893, 3893,3895, 3895,3897, 3897,3902, 3903,\n\t\t3953, 3972,3974, 3975,3981, 3991,3993, 4028,4038, 4038,4139, 4158,4160, 4169,4182, 4185,4190, 4192,4194, 4196,4199, 4205,4209, 4212,4226, 4237,4239, 4253,4957, 4959,5906, 5908,5938, 5940,5970, 5971,6002, 6003,6068, 6099,6109, 6109,6112, 6121,6155, 6157,6160, 6169,6313, 6313,6432, 6443,6448, 6459,6470, 6479,\n\t\t6576, 6592,6600, 6601,6608, 6617,6679, 6683,6741, 6750,6752, 6780,6783, 6793,6800, 6809,6912, 6916,6964, 6980,6992, 7001,7019, 7027,7040, 7042,7073, 7085,7088, 7097,7142, 7155,7204, 7223,7232, 7241,7248, 7257,7376, 7378,7380, 7400,7405, 7405,7410, 7412,7616, 7654,7676, 7679,8204, 8205,8255, 8256,8276, 8276,\n\t\t8400, 8412,8417, 8417,8421, 8432,11503, 11505,11647, 11647,11744, 11775,12330, 12335,12441, 12442,42528, 42537,42607, 42607,42612, 42621,42655, 42655,42736, 42737,43010, 43010,43014, 43014,43019, 43019,43043, 43047,43136, 43137,43188, 43204,43216, 43225,43232, 43249,43264, 43273,43302, 43309,43335, 43347,\n\t\t43392, 43395,43443, 43456,43472, 43481,43561, 43574,43587, 43587,43596, 43597,43600, 43609,43643, 43643,43696, 43696,43698, 43700,43703, 43704,43710, 43711,43713, 43713,43755, 43759,43765, 43766,44003, 44010,44012, 44013,44016, 44025,64286, 64286,65024, 65039,65056, 65062,65075, 65076,65101, 65103,\n\t\t65296, 65305,65343, 65343\n\t];\n\n    export function LexLookUpUnicodeMap(code: number, map: number[]) : bool {\n        // Perform binary search in one of the unicode range maps\n        var lo: number = 0;\n        var hi: number = map.length;\n        var mid: number;\n\n        while (lo + 1 < hi)\n        {\n            mid = lo + (hi - lo) / 2;\n            // mid has to be even to catch a range's beginning\n            mid -= mid % 2;\n            if (map[mid] <= code && code <= map[mid + 1])\n                return true;\n            if (code < map[mid])\n                hi = mid;\n            else\n                lo = mid + 2;\n        }\n        return false;\n    }\n\n    export function LexIsUnicodeDigit(code: number): bool {\n        if (codeGenTarget == CodeGenTarget.ES3) {\n            return LexLookUpUnicodeMap(code, unicodeES3IdCont);\n        } else {\n            return LexLookUpUnicodeMap(code, unicodeES5IdCont);\n        }\n    ";
var v27563 = v27564 + "}\n\n    export function LexIsUnicodeIdStart(code: number): bool {\n        if (codeGenTarget == CodeGenTarget.ES3) {\n            return LexLookUpUnicodeMap(code, unicodeES3IdStart);\n        } else {\n            return LexLookUpUnicodeMap(code, unicodeES5IdStart);\n        }\n    }\n    export function LexInitialize() {\n        initializeStaticTokens();\n        autoToken[LexCodeLPR] = staticTokens[TokenID.OpenParen];\n        autoToken[LexCodeRPR] = staticTokens[TokenID.CloseParen];\n        autoToken[LexCodeCMA] = staticTokens[TokenID.Comma];\n        autoToken[LexCodeSMC] = staticTokens[TokenID.Semicolon];\n        autoToken[LexCodeLBR] = staticTokens[TokenID.OpenBracket];\n        autoToken[LexCodeRBR] = staticTokens[TokenID.CloseBracket];\n        autoToken[LexCodeTIL] = staticTokens[TokenID.Tilde];\n        autoToken[LexCodeQUE] = staticTokens[TokenID.Question];\n        autoToken[LexCodeLC] = staticTokens[TokenID.OpenBrace];\n        autoToken[LexCodeRC] = staticTokens[TokenID.CloseBrace];\n        autoToken[LexCodeCOL] = staticTokens[TokenID.Colon];\n        LexKeywordTable = new StringHashTable();\n        for (var i in (<any>TokenID)._map) {\n            if ((<number><any>i) <= TokenID.LimKeyword) {\n                LexKeywordTable.add((<any>TokenID)._map[i].toLowerCase(), i);\n            }\n        }\n        for (var j = 0; j < LexCodeASCIIChars; j++) {\n            if (LexIsIdentifierStartChar(j)) {\n                lexIdStartTable[j] = true;\n            }\n            else {\n                lexIdStartTable[j] = false;\n            }\n        }\n    }\n\n    export function LexAdjustIndent(code, indentAmt) {\n        if ((code == LexCodeLBR) || (code == LexCodeLC) || (code == LexCodeLPR)) {\n            return indentAmt + 1;\n        }\n        else if ((code == LexCodeRBR) || (code == LexCodeRC) || (code == LexCodeRPR)) {\n            return indentAmt - 1;\n        }\n        else return indentAmt;\n    }\n\n    export function LexIsIdentifierStartChar(code): bool {\n        return (((code >= 97) && (code <= 122)) ||\n                ((code >= 65) && (code <= 90)) ||\n                (code == LexCodeDollar) ||\n                (code == LexCodeUnderscore));\n    }\n\n    export function LexIsDigit(code): bool {\n        return ((code >= 48) && (code <= 57));\n    }\n\n    export function LexIsIdentifierChar(code:number) {\n        return lexIdStartTable[code] || LexIsDigit(code);\n    }\n\n    export function LexMatchingOpen(code) {\n        if (code == LexCodeRBR)\n            return LexCodeLBR;\n        else if (code == LexCodeRC)\n            return LexCodeLC;\n        else if (code == LexCodeRPR)\n            return LexCodeLPR;\n        else return 0;\n    }\n\n    export enum NumberScanState {\n        Start,\n        InFraction,\n        InEmptyFraction,\n        InExponent\n    }\n\n    export enum LexState {\n        Start,\n        InMultilineComment,\n        InMultilineSingleQuoteString,\n        InMultilineDoubleQuoteString,\n    }\n\n    export enum LexMode {\n        Line,\n        File,\n    }\n\n    export enum CommentStyle {\n        Line,\n        Block\n    }\n\n    // Represent a piece of source code which can be read in multiple segments\n    export interface ISourceText {\n        getText(start: number, end: number): string;\n        getLength(): number;\n    }\n\n    // Implementation on top of a contiguous string\n    export class StringSourceText implements ISourceText {\n        constructor (public text: string) {\n        }\n\n        public getText(start: number, end: number): string {\n            return this.text.substring(start, end);\n        }\n\n        public getLength(): number {\n            return this.text.length;\n        }\n    }\n\n    export class SourceTextSegment implements ISourceTextSegment {\n        constructor (public segmentStart: number,\n                    public segmentEnd: number,\n                    public segment: string) {\n        }\n\n        charCodeAt(index: number): number {\n            return this.segment.charCodeAt(index - this.segmentStart);\n        }\n\n        substring(start: number, end: number): string {\n            return this.segment.substring(start - this.segmentStart, end - this.segmentStart);\n        }\n    }\n\n    export class AggerateSourceTextSegment implements ISourceTextSegment {\n\n        constructor (public seg1: SourceTextSegment, public seg2: SourceTextSegment) { }\n\n        public charCodeAt(index: number): number {\n            if (this.seg1.segmentStart <= index && index < this.seg1.segmentEnd)\n                return this.seg1.segment.charCodeAt(index - this.seg1.segmentStart);\n\n            return this.seg2.segment.charCodeAt(index - this.seg2.segmentStart);\n        }\n\n        public substring(start: number, end: number): string {\n            if (this.seg1.segmentStart <= start && end <= this.seg1.segmentEnd)\n                return this.seg1.segment.substring(start - this.seg1.segmentStart, end - this.seg1.segmentStart);\n\n            return this.seg2.segment.substring(start - this.seg2.segmentStart) + this.seg1.segment.substri";
var v27562 = v27563 + 'ng(0, end - this.seg1.segmentStart);\n        }\n    }\n\n    export interface ISourceTextSegment {\n        charCodeAt(index: number): number;\n        substring(start: number, end: number): string;\n    }\n\n    export class ScannerTextStream {\n        static emptySegment = new SourceTextSegment(0, 0, "");\n        public agg: AggerateSourceTextSegment;\n        public len: number;\n\n        constructor (public sourceText: ISourceText) {\n            this.agg = new AggerateSourceTextSegment(ScannerTextStream.emptySegment, ScannerTextStream.emptySegment);\n            this.len = this.sourceText.getLength();\n        }\n\n        public max(a: number, b: number): number {\n            return a >= b ? a : b;\n        }\n\n        public min(a: number, b: number): number {\n            return a <= b ? a : b;\n        }\n\n        public fetchSegment(start: number, end: number): ISourceTextSegment {\n            // Common case\n            if (this.agg.seg1.segmentStart <= start && end <= this.agg.seg1.segmentEnd)\n                return this.agg.seg1;\n\n            // Common overlap case\n            if (this.agg.seg2.segmentStart <= start && end <= this.agg.seg1.segmentEnd)\n                return this.agg;\n\n            // if overlapping outside of fetched segment(s), fetch a new segment\n            var prev = this.agg.seg1;\n\n            var s = prev.segmentEnd;\n            var e = max(s + 512, end); // ensure we move forward at least 512 characters or "end"\n            e = min(e, this.len);    // but don\'t go past the end of the source text\n\n            var src = this.sourceText.getText(s, e);\n            var newSeg = new SourceTextSegment(s, e, src);\n            this.agg.seg2 = prev;\n            this.agg.seg1 = newSeg;\n            return this.agg;\n        }\n\n        public charCodeAt(index: number): number {\n            return this.fetchSegment(index, index + 1).charCodeAt(index);\n        }\n\n        public substring(start: number, end: number) {\n            return this.fetchSegment(start, end).substring(start, end);\n        }\n    }\n\n    export interface IScanner {\n        startPos: number;\n        pos: number;\n        scan(): Token;\n        previousToken(): Token;\n        prevLine: number;\n        line: number;\n        col: number;\n        leftCurlyCount: number;\n        rightCurlyCount: number;\n        lastTokenLimChar(): number;\n        lastTokenHadNewline(): bool;\n        lexState: number;\n        getComments(): CommentToken[];\n        getCommentsForLine(line: number): CommentToken[];\n        resetComments(): void;\n        lineMap: number[];\n        setSourceText(newSrc: ISourceText, textMode: number): void;\n        setErrorHandler(reportError: (message: string) => void): void;\n        seenUnicodeChar: bool;\n        seenUnicodeCharInComment: bool;\n        getLookAheadToken(): Token;\n    }\n\n    export class SavedTokens implements IScanner {\n        public prevToken: Token = null;\n        public curSavedToken: SavedToken = null;\n        public prevSavedToken: SavedToken = null;\n        public currentTokenIndex: number;\n        public currentTokens: SavedToken[];\n        public tokensByLine: SavedToken[][];\n        public lexStateByLine: LexState[];\n        private prevToken: SavedToken = null;\n        public previousToken(): Token { return this.prevToken; }\n        public currentToken = 0;\n        public tokens = new SavedToken[];\n        public startPos: number;\n        public pos: number;\n        public seenUnicodeChar: bool = false;\n        seenUnicodeCharInComment: bool = false;\n\n        public close() {\n            this.currentToken = 0;\n        }\n\n        public addToken(tok: Token, scanner: IScanner) {\n            this.tokens[this.currentToken++] = new SavedToken(tok, scanner.startPos, scanner.pos);\n        }\n\n        public scan(): Token {\n            // TODO: curly count\n            this.startLine = this.line;\n            this.startPos = this.col;\n            if (this.currentTokenIndex == this.currentTokens.length) {\n                if (this.line < this.lineMap.length) {\n                    this.line++;\n                    this.col = 0;\n                    this.currentTokenIndex = 0;\n                    this.currentTokens = this.tokensByLine[this.line];\n                }\n                else {\n                    return staticTokens[TokenID.EndOfFile];\n                }\n            }\n            if (this.currentTokenIndex < this.currentTokens.length) {\n                this.prevToken = this.curSavedToken.tok;\n                this.prevSavedToken = this.curSavedToken;\n                this.curSavedToken = this.currentTokens[this.currentTokenIndex++];\n                var curToken = this.curSavedToken.tok;\n                this.pos = this.curSavedToken.limChar;\n                this.col += (this.curSavedToken.limChar - this.curSavedToken.minChar);\n                this.startPos = this.curSavedToken.minChar;\n                this.prevLine = this.line;\n                return curToken;\n            }\n            else {\n                retur';
var v27561 = v27562 + 'n staticTokens[TokenID.EndOfFile];\n            }\n        }\n        public startLine: number;\n        public prevLine = 1;\n        public line = 1;\n        public col = 0;\n        public leftCurlyCount: number;\n        public rightCurlyCount: number;\n\n        public syncToTok(offset: number): number {\n            this.line = getLineNumberFromPosition(this.lineMap, offset);\n            this.currentTokenIndex = 0;\n            var tmpCol = offset - this.lineMap[this.line];\n            while ((this.lexStateByLine[this.line] == LexState.InMultilineComment) && (this.line > 0)) {\n                this.line--;\n                tmpCol = 0;\n            }\n            var lenMin1 = this.lineMap.length - 1;\n            this.currentTokens = this.tokensByLine[this.line];\n            while ((this.currentTokens.length == 0) && (this.line < lenMin1)) {\n                this.line++;\n                this.currentTokens = this.tokensByLine[this.line];\n                tmpCol = 0;\n            }\n            if (this.line <= lenMin1) {\n                while ((this.currentTokenIndex < this.currentTokens.length) &&\n                       (tmpCol > this.currentTokens[this.currentTokenIndex].limChar)) {\n                    this.currentTokenIndex++;\n                }\n                if (this.currentTokenIndex < this.currentTokens.length) {\n                    this.col = this.currentTokens[this.currentTokenIndex].minChar;\n                    return this.col + this.lineMap[this.line];\n                }\n            }\n            return -1;\n        }\n\n        public lastTokenLimChar(): number {\n            if (this.prevSavedToken !== null) {\n                return this.prevSavedToken.limChar;\n            }\n            else {\n                return 0;\n            }\n        }\n\n        public lastTokenHadNewline(): bool {\n            return this.prevLine != this.startLine;\n        }\n\n        public lexState = LexState.Start;\n\n        public commentStack: CommentToken[] = new CommentToken[];\n\n        public pushComment(comment: CommentToken) {\n            this.commentStack.push(comment);\n        }\n\n        public getComments() {\n            var stack = this.commentStack;\n            this.commentStack = [];\n            return stack;\n        }\n\n        public getCommentsForLine(line: number) {\n            var comments: CommentToken[] = null;\n            while ((this.commentStack.length > 0) && (this.commentStack[0].line == line)) {\n                if (comments == null) {\n                    comments = [this.commentStack.shift()];\n                }\n                else {\n                    comments = comments.concat([this.commentStack.shift()]);\n                }\n\n            }\n            return comments;\n        }\n\n        public resetComments() {\n            this.commentStack = [];\n        }\n\n        public lineMap: number[] = [];\n        public setSourceText(newSrc: ISourceText, textMode: number) {\n        }\n        public setErrorHandler(reportError: (message: string) => void ) { \n        }\n        public getLookAheadToken(): Token {\n            throw new Error("Invalid operation.");\n        }\n    }\n\n    export class Scanner implements IScanner {\n        // REVIEW: When adding new variables make sure to handle storing them in getLookAheadToken. \n        //         The method works by storing the state before scanning and restoring it later on, missing a member variable \n        //         could result in an inconsistent state.\n        public prevLine = 1;\n        public line = 1;\n        public col = 0;\n        public pos = 0;\n        public startPos = 0;\n        public startCol: number;\n        public startLine: number;\n        public src: string;\n        public len = 0;\n        public lineMap: number[] = [];\n        \n        public ch = LexEOF;\n        public lexState = LexState.Start;\n        public mode = LexMode.File;\n        public scanComments: bool = true;\n        public interveningWhitespace = false; // Was there a whitespace token between the last token and the current one?\n        private interveningWhitespacePos = 0; //  If yes, this contains the start position of the whitespace\n        public leftCurlyCount = 0;\n        public rightCurlyCount = 0;\n        public commentStack: CommentToken[] = new CommentToken[];\n        public saveScan: SavedTokens = null;\n        public seenUnicodeChar: bool = false;\n        seenUnicodeCharInComment: bool = false;\n\n        private reportError: (message: string) =>void;\n\n        constructor () {\n            this.startCol = this.col;\n            this.startLine = this.line;            \n            this.lineMap[1] = 0;\n            \n            if (!LexKeywordTable) {\n                LexInitialize();\n            }            \n        }\n\n        private prevTok = staticTokens[TokenID.EndOfFile];\n        public previousToken() { return this.prevTok; }\n\n        public setSourceText(newSrc: ISourceText, textMode: number) {\n            this.mode = textMode;\n            this.scanComments = (this.mode === LexMo';
var v27560 = v27561 + "de.Line);\n            this.pos = 0;\n            this.interveningWhitespacePos = 0;\n            this.startPos = 0;\n            this.line = 1;\n            this.col = 0;\n            this.startCol = this.col;\n            this.startLine = this.line;\n            this.len = 0;\n            this.src = newSrc.getText(0, newSrc.getLength());\n            this.len = this.src.length;\n            this.lineMap = [];\n            this.lineMap[1] = 0;\n            this.commentStack = [];\n            this.leftCurlyCount = 0;\n            this.rightCurlyCount = 0;\n            this.seenUnicodeChar = false;\n            this.seenUnicodeCharInComment = false;\n        }\n\n        public setErrorHandler(reportError: (message: string) => void ) { \n            this.reportError = reportError;\n        }\n\n        public setSaveScan(savedTokens: SavedTokens) {\n            this.saveScan = savedTokens;\n        }\n\n        public setText(newSrc: string, textMode: number) {\n            this.setSourceText(new StringSourceText(newSrc), textMode);\n        }\n\n        public setScanComments(value: bool) {\n            this.scanComments = value;\n        }\n\n        public getLexState(): number {\n            return this.lexState;\n        }\n\n        public tokenStart() {\n            this.startPos = this.pos;\n            this.startLine = this.line;\n            this.startCol = this.col;\n            this.interveningWhitespace = false;\n        }\n\n        public peekChar(): number {\n            if (this.pos < this.len) {\n                return this.src.charCodeAt(this.pos);\n            }\n            else {\n                return LexEOF;\n            }\n        }\n\n        public peekCharAt(index: number): number {\n            if (index < this.len) {\n                return this.src.charCodeAt(index);\n            }\n            else {\n                return LexEOF;\n            }\n        }\n\n        public IsHexDigit(c: number) {\n            return ((c >= LexCode_0) && (c <= LexCode_9)) || ((c >= LexCode_A) && (c <= LexCode_F)) ||\n                ((c >= LexCode_a) && (c <= LexCode_f));\n        }\n\n        public IsOctalDigit(c: number) {\n            return ((c >= LexCode_0) && (c <= LexCode_7)) ||\n                ((c >= LexCode_a) && (c <= LexCode_f));\n        }\n\n        public scanHexDigits(): Token {\n            var atLeastOneDigit = false;\n            for (; ;) {\n                if (this.IsHexDigit(this.ch)) {\n                    this.nextChar();\n                    atLeastOneDigit = true;\n                }\n                else {\n                    if (atLeastOneDigit) {\n                        return new NumberLiteralToken(parseInt(this.src.substring(this.startPos, this.pos)));\n                    }\n                    else {\n                        return null;\n                    }\n                }\n            }\n\n        }\n\n        public scanOctalDigits(): Token {\n            var atLeastOneDigit = false;\n            for (; ;) {\n                if (this.IsOctalDigit(this.ch)) {\n                    this.nextChar();\n                    atLeastOneDigit = true;\n                }\n                else {\n                    if (atLeastOneDigit) {\n                        return new NumberLiteralToken(parseInt(this.src.substring(this.startPos, this.pos)));\n                    }\n                    else {\n                        return null;\n                    }\n                }\n            }\n\n        }\n\n        public scanDecimalNumber(state: number): Token {\n            var atLeastOneDigit = false;\n            var svPos = this.pos;\n            var svCol = this.col;\n            for (; ;) {\n                if (LexIsDigit(this.ch)) {\n                    atLeastOneDigit = true;\n                    if (this.ch != LexCode_0 && state == NumberScanState.InEmptyFraction) {\n                        state = NumberScanState.InFraction;\n                    }\n                    this.nextChar();\n                }\n                else if (this.ch == LexCodeDOT) {\n                    if (state == NumberScanState.Start) {\n                        // DecimalDigit* .\n                        this.nextChar();\n                        state = NumberScanState.InEmptyFraction;\n                    }\n                    else {\n                        // dot not part of number\n                        if (atLeastOneDigit) {\n                            // DecimalDigit* . DecimalDigit+\n                            return new NumberLiteralToken(parseFloat(this.src.substring(this.startPos, this.pos)), state == NumberScanState.InEmptyFraction);\n                        }\n                        else {\n                            this.pos = svPos;\n                            this.col = svCol;\n                            return null;\n                        }\n                    }\n                } else if ((this.ch == LexCode_e) || (this.ch == LexCode_E)) {\n                    if (state == NumberScanState.Start) {\n                        if (atLeastOneDigit) {\n                            // DecimalDigit+ (.";
var v27559 = v27560 + " DecimalDigit*) [eE] [+-]DecimalDigit+\n                            atLeastOneDigit = false;\n                            this.nextChar();\n                            state = NumberScanState.InExponent;\n                        }\n                        else {\n                            this.pos = svPos;\n                            this.col = svCol;\n                            return null;\n                        }\n                    }\n                    else if (state == NumberScanState.InFraction || state == NumberScanState.InEmptyFraction) {\n                        // DecimalDigit+ . DecimalDigit* [eE]\n                        this.nextChar();\n                        state = NumberScanState.InExponent;\n                        atLeastOneDigit = false;\n                    }\n                    else {\n                        // DecimalDigit+ . DecimalDigit* [eE] DecimalDigit+\n                        if (atLeastOneDigit) {\n                            return new NumberLiteralToken(parseFloat(this.src.substring(this.startPos, this.pos)));\n                        }\n                        else {\n                            this.pos = svPos;\n                            this.col = svCol;\n                            return null;\n                        }\n                    }\n                }\n                else if ((this.ch == LexCodePLS) || (this.ch == LexCodeMIN)) {\n                    if (state == NumberScanState.InExponent) {\n                        if (!atLeastOneDigit) {\n                            this.nextChar();\n                        }\n                        else {\n                            this.pos = svPos;\n                            this.col = svCol;\n                            return null;\n                        }\n                    }\n                    else if (state == NumberScanState.InEmptyFraction || state == NumberScanState.InFraction) {\n                        // This case will not generate bad javascript if we miss the fractional part, but we just want to be consistent with the dot case\n                        return new NumberLiteralToken(parseFloat(this.src.substring(this.startPos, this.pos)), state == NumberScanState.InEmptyFraction);\n                    }\n                    else {\n                        if (!atLeastOneDigit) {\n                            this.pos = svPos;\n                            this.col = svCol;\n                            return null;\n                        }\n                        else {\n                            return new NumberLiteralToken(parseFloat(this.src.substring(this.startPos, this.pos)));\n                        }\n                    }\n                }\n                else {\n                    if (!atLeastOneDigit) {\n                        this.pos = svPos;\n                        this.col = svCol;\n                        return null;\n                    }\n                    else {\n                        return new NumberLiteralToken(parseFloat(this.src.substring(this.startPos, this.pos)), state == NumberScanState.InEmptyFraction);\n                    }\n                }\n            }\n        }\n\n        // 0 [xX] hexDigits\n        // 0 octalDigits\n        // 0 [89] decimalDigits\n        // decimalDigits? fraction? exponent?\n\n        public scanNumber(): Token {\n            if (this.peekChar() == LexCode_0) {\n                switch (this.peekCharAt(this.pos + 1)) {\n                    case LexCode_x:\n                    case LexCode_X:\n                        // Hex\n                        this.advanceChar(2);\n                        return this.scanHexDigits();\n                    case LexCode_8:\n                    case LexCode_9:\n                    case LexCodeDOT:\n                        return this.scanDecimalNumber(NumberScanState.Start);\n                    default:\n                        // Octal\n                        return this.scanOctalDigits();\n                }\n            }\n            else {\n                return this.scanDecimalNumber(NumberScanState.Start);\n            }\n        }\n\n        public scanFraction(): Token {\n            return this.scanDecimalNumber(NumberScanState.InFraction);\n        }\n\n        public newLine() {\n            this.col = 0;\n            if (this.mode == LexMode.File) {\n                this.line++;\n                this.lineMap[this.line] = this.pos + 1;\n            }\n        }\n\n        public finishMultilineComment(): bool {\n            var ch2: number;\n            this.lexState = LexState.InMultilineComment;\n            while (this.pos < this.len) {\n                if (this.ch == LexCodeMUL) {\n                    ch2 = this.peekCharAt(this.pos + 1);\n                    if (ch2 == LexCodeSLH) {\n                        this.advanceChar(2);\n                        if (this.mode == LexMode.File) {\n                            this.tokenStart();\n                        }\n                        this.lexState = LexState.Start;\n                        return true;\n                    }\n        ";
var v27558 = v27559 + "        }\n                else if (this.ch == LexCodeNWL) {\n                    this.newLine();\n                    if (this.mode == LexMode.Line) {\n                        this.nextChar();\n                        return false;\n                    }\n                } \n                else if (this.ch >= LexCodeASCIIChars) { \n                    this.seenUnicodeCharInComment = true;\n                }\n                this.nextChar();\n            }\n            return false;\n        }\n\n        public pushComment(comment: CommentToken) {\n            this.commentStack.push(comment);\n        }\n\n        public getComments() {\n            var stack = this.commentStack;\n            this.commentStack = [];\n            return stack;\n        }\n\n        public getCommentsForLine(line: number) {\n            var comments: CommentToken[] = null;\n            while ((this.commentStack.length > 0) && (this.commentStack[0].line == line)) {\n                if (comments == null) {\n                    comments = [this.commentStack.shift()];\n                }\n                else {\n                    comments = comments.concat([this.commentStack.shift()]);\n                }\n\n            }\n            return comments;\n        }\n\n        public resetComments() {\n            this.commentStack = [];\n        }\n\n        public endsLine(c: number) {\n            return (c == LexCodeNWL) || (c == LexCodeRET) || (c == LexCodeLS) || (c == LexCodePS);\n        }\n\n        public finishSinglelineComment() {\n            while (this.pos < this.len) {\n                if (this.endsLine(this.ch))\n                    break;\n                if (this.ch >= LexCodeASCIIChars) { \n                    this.seenUnicodeCharInComment = true;\n                }\n                this.nextChar();\n            }\n\n            if (this.mode == LexMode.File) {\n                this.tokenStart();\n            }\n        }\n\n        public tokenText(): string {\n            return this.src.substring(this.startPos, this.pos);\n        }\n\n        public findClosingSLH() {\n            var index = this.pos;\n            var ch2 = this.src.charCodeAt(index);\n            var prevCh = 0;\n            var liveEsc = false;\n            while (!this.endsLine(ch2) && (index < this.len)) {\n                if ((ch2 == LexCodeSLH) && (!liveEsc)) {\n                    return index;\n                }\n                prevCh = ch2;\n                index++;\n                if (liveEsc) {\n                    liveEsc = false;\n                }\n                else {\n                    liveEsc = (prevCh == LexCodeBSL);\n                }\n\n                ch2 = this.src.charCodeAt(index);\n            }\n            return -1;\n        }\n\n        public speculateRegex(): Token {\n            if (noRegexTable[this.prevTok.tokenId] != undefined) {\n                return null;\n            }\n            var svPos = this.pos;\n            var svCol = this.col;\n            // first char is '/' and has been skipped\n            var index = this.findClosingSLH();\n            if (index > 0) {\n                // found closing /\n                var pattern = this.src.substring(svPos, index);\n                var flags = \"\";\n                this.pos = index + 1;\n                this.ch = this.peekChar();\n                var flagsStart = this.pos;\n                // TODO: check for duplicate flags\n                while ((this.ch == LexCode_i) || (this.ch == LexCode_g) || (this.ch == LexCode_m)) {\n                    this.nextChar();\n                }\n                if ((this.pos - flagsStart) > 3) {\n                    return null;\n                }\n                else {\n                    flags = this.src.substring(flagsStart, this.pos);\n                }\n                var regex = undefined;\n                try {\n                    regex = new RegExp(pattern, flags);\n                }\n                catch (regexException) {\n                }\n                if (regex) {\n                    // no line boundary in regex string\n                    this.col = svCol + (this.pos - this.startPos);\n                    return new RegularExpressionLiteralToken(regex);\n                }\n            }\n            this.pos = svPos;\n            this.col = svCol;\n            return null;\n        }\n\n        public lastTokenHadNewline() {\n            return this.prevLine != this.startLine;\n        }\n\n        public lastTokenLimChar() {\n            return this.interveningWhitespace ? this.interveningWhitespacePos : this.startPos;\n        }\n\n        // use only when known not to skip line terminators\n        public advanceChar(amt: number) {\n            this.pos += amt;\n            this.col += amt;\n            this.ch = this.peekChar();\n        }\n\n        public nextChar() {\n            this.pos++;\n            this.col++;\n            this.ch = this.peekChar();\n        }\n\n        public getLookAheadToken(): Token {\n            // REVIEW: This method is only used for parsing varargs in lambda expressions. If this functionality is neede";
var v27557 = v27558 + 'd for more common cases, \n            //         it needs to be designed. \n            //         Look-ahead token needs to be integrated in the scanner design to allow for an efficient lookup.\n\n            // Store the scanner state\n            var prevLine = this.prevLine;\n            var line = this.line;\n            var col = this.col;\n            var pos = this.pos;\n            var startPos = this.startPos;\n            var startCol = this.startCol;\n            var startLine = this.startLine;\n            var ch = this.ch;\n            var prevTok = this.prevTok;\n            var lexState = this.lexState;\n            var interveningWhitespace = this.interveningWhitespace;\n            var interveningWhitespacePos = this.interveningWhitespacePos;\n            var leftCurlyCount = this.leftCurlyCount;\n            var rightCurlyCount = this.rightCurlyCount;\n            var seenUnicodeChar = this.seenUnicodeChar;\n            var seenUnicodeCharInComment = this.seenUnicodeCharInComment;\n            var commentStackLength = this.commentStack.length;\n\n            var lookAheadToken = this.scan();\n\n            // Restore state\n            this.prevLine = prevLine;\n            this.line = line;\n            this.col = col;\n            this.pos = pos;\n            this.startPos = startPos;\n            this.startCol = startCol;\n            this.startLine = startLine;\n            this.ch = ch;\n            this.prevTok = prevTok;\n            this.lexState = lexState;\n            this.interveningWhitespace = interveningWhitespace;\n            this.interveningWhitespacePos = interveningWhitespacePos;\n            this.leftCurlyCount = leftCurlyCount;\n            this.rightCurlyCount = rightCurlyCount;\n            this.seenUnicodeChar = seenUnicodeChar;\n            this.seenUnicodeCharInComment = seenUnicodeCharInComment;\n            this.commentStack.length = commentStackLength;\n\n            return lookAheadToken;\n        }\n\n        public scanInLine(): Token {\n            if ((this.lexState == LexState.InMultilineComment) && (this.scanComments)) {\n                this.ch = this.peekChar();\n                var commentLine = this.line;\n                this.finishMultilineComment();\n                if (this.startPos < this.pos) {\n                    var commentText = this.src.substring(this.startPos, this.pos);\n                    this.tokenStart();\n                    return new CommentToken(TokenID.Comment, commentText,/*isBlock*/true, this.startPos, commentLine,/*endsLine*/true);\n                }\n                else {\n                    return staticTokens[TokenID.EndOfFile];\n                }\n            } \n            else if (this.lexState == LexState.InMultilineSingleQuoteString && this.pos < this.len) { \n                this.ch = LexCodeAPO;\n                this.lexState = LexState.Start;\n                return this.scanStringConstant();\n            }\n            else if (this.lexState == LexState.InMultilineDoubleQuoteString && this.pos < this.len) { \n                this.ch = LexCodeQUO;\n                this.lexState = LexState.Start;\n                return this.scanStringConstant();\n            }\n            this.prevLine = this.line;\n            var prevTok = this.innerScan();\n\n            // Ingore white spaces\n            if (prevTok.tokenId != TokenID.Whitespace) {\n                this.prevTok = prevTok;\n            }\n            return prevTok;\n        }\n\n        public scan(): Token {\n            this.prevLine = this.line;\n            this.prevTok = this.innerScan();\n            if (this.saveScan) {\n                this.saveScan.addToken(this.prevTok, this);\n            }\n            return this.prevTok;\n        }\n\n        private isValidUnicodeIdentifierChar(): bool {\n            var valid = LexIsUnicodeIdStart(this.ch) || LexIsUnicodeDigit(this.ch);\n            this.seenUnicodeChar = this.seenUnicodeChar || valid;\n            return valid;\n        }\n\n        private scanStringConstant(): Token {\n            var endCode = this.ch;\n            \n            // Skip the first quote\n            this.nextChar();\n            \n            // Accumulate with escape characters\n            scanStringConstantLoop:\n            for (;;) {\n                switch (this.ch) {\n                    case LexEOF:\n                        // Unexpected end of file\n                        this.reportScannerError("Unterminated string constant");\n                        break scanStringConstantLoop;\n\n                    case LexCodeLS:\n                    case LexCodePS:\n                        this.seenUnicodeChar = true;\n                    // Intentional fall through\n                    case LexCodeRET:\n                    case LexCodeNWL:\n                        this.reportScannerError("Unterminated string constant");\n                        break scanStringConstantLoop;\n\n                    case LexCodeAPO:\n                    case LexCodeQUO:\n                        if (this.ch == endCode) {\n                            // Foun';
var v27556 = v27557 + 'd string terminator. Skip past end code.\n                            this.nextChar();\n                            break scanStringConstantLoop;\n                        }\n                        break;\n\n                    case LexCodeBSL:\n                        // Consume the current slash\n                        this.nextChar();\n\n                        switch (this.ch) {\n                            case LexCodeAPO:\n                            case LexCodeQUO:\n                            case LexCodeBSL:\n                                // Valid escape sequences\n                                this.nextChar();\n                                continue scanStringConstantLoop;\n\n                            case LexCodeLS:\n                            case LexCodePS:\n                                this.seenUnicodeChar = true;\n                            // Intentional fall through\n                            case LexCodeRET:\n                            case LexCodeNWL:\n                                // Skip /r in a /r/n sequence\n                                if (this.ch == LexCodeRET && this.peekCharAt(this.pos + 1) == LexCodeNWL) {\n                                    this.nextChar();\n                                }\n\n                                // Consume the new line char\n                                this.nextChar();\n\n                                // Record new line\n                                this.newLine();\n\n                                if (this.mode == LexMode.Line) {\n                                    this.lexState = endCode == LexCodeAPO ? LexState.InMultilineSingleQuoteString : LexState.InMultilineDoubleQuoteString;\n                                    break scanStringConstantLoop;\n                                }\n                                break;\n\n                            case LexCode_x:\n                            case LexCode_u:\n                                var expectedHexDigits = this.ch == LexCode_x ? 2 : 4;\n                                this.nextChar();\n                                for (var i = 0; i < expectedHexDigits; i++) {\n                                    if (this.IsHexDigit(this.ch)) {\n                                        this.nextChar();\n                                    }\n                                    else {\n                                        this.reportScannerError("Invalid Unicode escape sequence");\n                                        break;\n                                    }\n                                }\n                                continue scanStringConstantLoop;\n                        }\n                        break;\n                }\n\n                // Record seeing a Unicode char\n                if (this.ch >= LexCodeASCIIChars) {\n                    this.seenUnicodeChar = true;\n                }\n\n                this.nextChar();\n            }\n\n            return new StringLiteralToken(this.src.substring(this.startPos, this.pos));\n        }\n\n        private scanIdentifier(): Token {\n            var hasEscape = false;\n            var isFirstChar = (this.ch == LexCodeBSL);\n            var hasUnicode: any = false;\n\n            for (; ;) {\n                while (lexIdStartTable[this.ch] || LexIsDigit(this.ch) || \n                      (this.ch >= LexCodeASCIIChars && this.isValidUnicodeIdentifierChar())) {\n                    this.nextChar();\n                }\n                if (this.ch == LexCodeBSL) {\n                    this.nextChar();\n                    if (this.ch == LexCode_u) {\n                        // 4 hex digits\n                        this.nextChar();\n                        for (var h = 0; h < 4 ; h++) {\n                            if (this.IsHexDigit(this.ch)) {\n                                this.nextChar();\n                            }\n                            else {\n                                this.reportScannerError("Invalid Unicode escape sequence");\n                                return staticTokens[TokenID.Error];\n                            }\n                        }\n                        var hexChar = parseInt(this.src.substring(this.pos - 4, this.pos), 16);\n\n                        // Verify is valid ID char \n                        if (lexIdStartTable[hexChar] || (!isFirstChar && LexIsDigit(hexChar)) ||\n                            (hexChar >= LexCodeASCIIChars && (LexIsUnicodeIdStart(hexChar) || (!isFirstChar && LexIsUnicodeDigit(hexChar))))) {\n                        }\n                        else { \n                            this.reportScannerError("Invalid identifier character");\n                            return staticTokens[TokenID.Error];\n                        }\n\n                        hasEscape = true;\n                        isFirstChar = false;\n                        continue;\n                    }\n\n                    this.reportScannerError("Invalid Unicode escape sequence");\n                    return staticTokens[TokenID.Error];\n                }\n        ';
var v27555 = v27556 + '        break;\n            }\n\n            var id: number;\n            var text = this.src.substring(this.startPos, this.pos);\n            if (!hasEscape && (id = LexKeywordTable.lookup(text)) != null) {\n                return staticTokens[id];\n            }\n            else {\n                return new IdentifierToken(text, hasEscape);\n            }\n        }\n\n        public innerScan(): Token {\n            var rtok;\n            this.tokenStart();\n            this.ch = this.peekChar();\n\n            start: while (this.pos < this.len) {\n                 if (lexIdStartTable[this.ch] || this.ch == LexCodeBSL || (this.ch >= LexCodeASCIIChars && LexIsUnicodeIdStart(this.ch))) {\n                    // identifier or keyword\n                    return this.scanIdentifier();\n                }\n                else if (this.ch == LexCodeSpace) {\n                    if (!this.interveningWhitespace) {\n                        this.interveningWhitespacePos = this.pos;\n                    }\n                    do {\n                        this.nextChar();\n                    } while (this.ch == LexCodeSpace);\n                    if (this.mode == LexMode.Line) {\n                        var whitespaceText = this.src.substring(this.startPos, this.pos);\n                        return new WhitespaceToken(TokenID.Whitespace, whitespaceText);\n                    }\n                    else {\n                        this.tokenStart();\n                        this.interveningWhitespace = true;\n                    }\n                }\n                else if (this.ch == LexCodeSLH) {\n                    this.nextChar();\n                    var commentText;\n                    if (this.ch == LexCodeSLH) {\n                        if (!this.interveningWhitespace) {\n                            this.interveningWhitespacePos = this.pos - 1;\n                        }\n                        var commentStartPos = this.pos - 1;\n                        var commentStartLine = this.line;\n                        this.finishSinglelineComment();\n                        var commentText = this.src.substring(commentStartPos, this.pos);\n                        var commentToken = new CommentToken(TokenID.Comment, commentText,/*isBlock*/false, commentStartPos, commentStartLine,/*endsLine*/false);\n                        if (this.scanComments) {\n                            // respect scanner contract: when returning a token, startPos is the start position of the token\n                            this.startPos = commentStartPos;\n                            return commentToken;\n                        }\n                        else {\n                            this.pushComment(commentToken);\n                        }\n\n                        this.interveningWhitespace = true;\n                    }\n                    else if (this.ch == LexCodeMUL) {\n                        if (!this.interveningWhitespace) {\n                            this.interveningWhitespacePos = this.pos - 1;\n                        }\n                        var commentStartPos = this.pos - 1;\n                        var commentStartLine = this.line;\n                        this.nextChar();  // Skip the "*"\n                        this.finishMultilineComment();\n                        var commentText = this.src.substring(commentStartPos, this.pos);\n                        var endsLine = this.endsLine(this.peekChar());\n                        var commentToken = new CommentToken(TokenID.Comment, commentText,/*isBlock*/true, commentStartPos, commentStartLine, endsLine);\n                        if (this.scanComments) {\n                            // respect scanner contract: when returning a token, startPos is the start position of the token\n                            this.startPos = commentStartPos;\n                            return commentToken;\n                        }\n                        else {\n                            this.pushComment(commentToken);\n                        }\n                        this.interveningWhitespace = true;\n                    }\n                    else {\n                        var regexTok = this.speculateRegex();\n                        if (regexTok) {\n                            return regexTok;\n                        }\n                        else {\n                            if (this.peekCharAt(this.pos) == LexCodeEQ) {\n                                this.nextChar();\n                                return staticTokens[TokenID.SlashEquals];\n                            }\n                            else {\n                                return staticTokens[TokenID.Slash];\n                            }\n                        }\n                    }\n                }\n                else if (this.ch == LexCodeSMC) {\n                    this.nextChar();\n                    return staticTokens[TokenID.Semicolon];\n                }\n                else if ((this.ch == LexCodeAPO) || (this.ch == LexCodeQUO)) {\n                    return this.scanSt';
var v27554 = v27555 + "ringConstant();\n                }\n                else if (autoToken[this.ch]) {\n                    var atok = autoToken[this.ch];\n                    if (atok.tokenId == TokenID.OpenBrace) {\n                        this.leftCurlyCount++;\n                    }\n                    else if (atok.tokenId == TokenID.CloseBrace) {\n                        this.rightCurlyCount++;\n                    }\n                    this.nextChar();\n                    return atok;\n                }\n                else if ((this.ch >= LexCode_0) && (this.ch <= LexCode_9)) {\n                    rtok = this.scanNumber();\n                    if (rtok) {\n                        return rtok;\n                    }\n                    else {\n                        this.nextChar();\n                        return staticTokens[TokenID.Error];\n                    }\n                }\n                else switch (this.ch) {\n                    // TAB\n                    case LexCodeTAB:\n                    case LexCodeVTAB:\n                        if (!this.interveningWhitespace) {\n                            this.interveningWhitespacePos = this.pos;\n                        }\n                        if (this.mode == LexMode.Line) {\n                            do {\n                                this.nextChar();\n                            } while ((this.ch == LexCodeSpace) || (this.ch == 9));\n                            var wsText = this.src.substring(this.startPos, this.pos);\n                            return new WhitespaceToken(TokenID.Whitespace, wsText);\n                        }\n                        else {\n                            this.interveningWhitespace = true;\n                        }\n                     // Newlines and BOM\n                    case 0xFF: // UTF16 SEQUENCE\n                    case 0xFE:\n                    case 0xEF:    // UTF8 SEQUENCE\n                    case 0xBB:\n                    case 0xBF:\n                    case LexCodeLS:\n                    case LexCodePS:\n                    case LexCodeNWL:\n                    case LexCodeRET:\n                        if (this.ch == LexCodeNWL) {\n                            this.newLine();\n                            if (this.mode == LexMode.Line) {\n                                return staticTokens[TokenID.EndOfFile];\n                            }\n                        }\n                        if (!this.interveningWhitespace) {\n                            this.interveningWhitespacePos = this.pos;\n                        }\n                        this.nextChar();\n                        this.tokenStart();\n                        this.interveningWhitespace = true;\n                        break;\n                    case LexCodeDOT: {\n                        if (this.peekCharAt(this.pos + 1) == LexCodeDOT) {\n                            if (this.peekCharAt(this.pos + 2) == LexCodeDOT) {\n                                this.advanceChar(3);\n                                return staticTokens[TokenID.DotDotDot];\n                            }\n                            else {\n                                this.nextChar();\n                                return staticTokens[TokenID.Dot];\n                            }\n                        }\n                        else {\n                            this.nextChar();\n                            rtok = this.scanFraction();\n                            if (rtok) {\n                                return rtok;\n                            }\n                            else {\n                                return staticTokens[TokenID.Dot];\n                            }\n                        }\n                        // break;\n                    }\n                    case LexCodeEQ:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            if (this.peekCharAt(this.pos + 2) == LexCodeEQ) {\n                                this.advanceChar(3);\n                                return staticTokens[TokenID.EqualsEqualsEquals];\n                            }\n                            else {\n                                this.advanceChar(2);\n                                return staticTokens[TokenID.EqualsEquals];\n                            }\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodeGT) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.EqualsGreaterThan];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Equals];\n                        }\n                    // break;\n                    case LexCodeBNG:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            if (this.peekCharAt(this.pos + 2) == LexCodeEQ) {\n                                this.advanceChar(3);\n                                return staticTo";
var v27553 = v27554 + "kens[TokenID.ExclamationEqualsEquals];\n                            }\n                            else {\n                                this.advanceChar(2);\n                                return staticTokens[TokenID.ExclamationEquals];\n                            }\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Exclamation];\n                        }\n                    // break;\n                    case LexCodePLS:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.PlusEquals];\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodePLS) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.PlusPlus];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Plus];\n                        }\n                    // break;\n                    case LexCodeMIN:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.MinusEquals];\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodeMIN) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.MinusMinus];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Minus];\n                        }\n                    // break;\n                    case LexCodeMUL:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.AsteriskEquals];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Asterisk];\n                        }\n                    // break;\n                    case LexCodePCT:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.PercentEquals];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Percent];\n                        }\n                    // break;\n                    case LexCodeLT:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeLT) {\n                            if (this.peekCharAt(this.pos + 2) == LexCodeEQ) {\n                                this.advanceChar(3);\n                                return staticTokens[TokenID.LessThanLessThanEquals];\n                            }\n                            else {\n                                this.advanceChar(2);\n                                return staticTokens[TokenID.LessThanLessThan];\n                            }\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.LessThanEquals];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.LessThan];\n                        }\n                    //  break;\n                    case LexCodeGT:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeGT) {\n                            if (this.peekCharAt(this.pos + 2) == LexCodeEQ) {\n                                this.advanceChar(3);\n                                return staticTokens[TokenID.GreaterThanGreaterThanEquals];\n                            }\n                            else if (this.peekCharAt(this.pos + 2) == LexCodeGT) {\n                                if (this.peekCharAt(this.pos + 3) == LexCodeEQ) {\n                                    this.advanceChar(4);\n                                    return staticTokens[TokenID.GreaterThanGreaterThanGreaterThanEquals];\n                                }\n                                else {\n                                    this.advanceChar(3);\n                                    return staticTokens[TokenID.GreaterThanGreaterThanGreaterThan];\n                                }\n                            }\n                            else {\n                                this.advanceChar(2);\n                                return staticTokens[TokenID.GreaterThanGreaterThan];\n                            }\n                        }\n                        ";
var v27552 = v27553 + 'else if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.GreaterThanEquals];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.GreaterThan];\n                        }\n                    // break;\n                    case LexCodeXOR:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.CaretEquals];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Caret];\n                        }\n                    //  break;\n                    case LexCodeBAR:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.BarEquals];\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodeBAR) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.BarBar];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.Bar];\n                        }\n                    //  break;\n                    case LexCodeAMP:\n                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.AmpersandEquals];\n                        }\n                        else if (this.peekCharAt(this.pos + 1) == LexCodeAMP) {\n                            this.advanceChar(2);\n                            return staticTokens[TokenID.AmpersandAmpersand];\n                        }\n                        else {\n                            this.nextChar();\n                            return staticTokens[TokenID.And];\n                        }\n                    //  break;\n                    default:\n                        // Report error\n                        this.reportScannerError("Invalid character");\n                        this.nextChar();\n\n                        continue start;\n                }\n            }\n            return staticTokens[TokenID.EndOfFile];\n        }\n\n        private reportScannerError(message: string) { \n            if (this.reportError) { \n                this.reportError(message);\n            }\n        }\n    }\n\n    // Reseverved words only apply to Identifiers, not IdentifierNames\n    export function convertTokToIDName(tok: Token): bool {\n        return convertTokToIDBase(tok, true, false);\n    }\n\n    export function convertTokToID(tok: Token, strictMode: bool): bool {\n        return convertTokToIDBase(tok, false, strictMode);\n    }\n\n    function convertTokToIDBase(tok: Token, identifierName: bool, strictMode: bool): bool {\n        if (tok.tokenId <= TokenID.LimKeyword) {\n            var tokInfo = lookupToken(tok.tokenId);\n            if (tokInfo != undefined) {\n                var resFlags = Reservation.Javascript | Reservation.JavascriptFuture;\n                if (strictMode) {\n                    resFlags |= Reservation.JavascriptFutureStrict;\n                }\n                if (identifierName || !hasFlag(tokInfo.reservation, resFlags)) {\n                    return true;\n                }\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n\n    // Return the (1-based) line number from a character offset using the provided linemap.\n    export function getLineNumberFromPosition(lineMap: number[], position: number): number {\n        if (position === -1)\n            return 0;\n\n        // Binary search\n        var min = 0;\n        var max = lineMap.length - 1;\n        while (min < max) {\n            var med = (min + max) >> 1;\n            if (position < lineMap[med]) {\n                max = med - 1;\n            }\n            else if (position < lineMap[med + 1]) {\n                min = max = med; // found it\n            }\n            else {\n                min = med + 1;\n            }\n        }\n\n        return min;\n    }\n\n    /// Return the [line, column] data for a given offset and a lineMap.\n    /// Note that the returned line is 1-based, while the column is 0-based.\n    export function getSourceLineColFromMap(lineCol: ILineCol, minChar: number, lineMap: number[]): void {\n        var line = getLineNumberFromPosition(lineMap, minChar);\n\n        if (line > 0) {\n            lineCol.line = line;\n            lineCol.col = (minChar - lineMap[line]);\n        }\n    }\n\n    // Return the [line, column] (both 1 based) corresponding to a given position in a given script.\n    export funct';
var v27551 = v27552 + 'ion getLineColumnFromPosition(script: TypeScript.Script, position: number): ILineCol {\n        var result = { line: -1, col: -1 };\n        getSourceLineColFromMap(result, position, script.locationInfo.lineMap);\n        if (result.col >= 0) {\n            result.col++;   // Make it 1-based\n        }\n        return result;\n    }\n\n    //\n    // Return the position (offset) corresponding to a given [line, column] (both 1-based) in a given script.\n    //\n    export function getPositionFromLineColumn(script: TypeScript.Script, line: number, column: number): number {\n        return script.locationInfo.lineMap[line] + (column - 1);\n    }\n    \n    // Return true if the token is a primitive type\n    export function isPrimitiveTypeToken(token: Token) {\n        switch (token.tokenId) {\n            case TokenID.Any:\n            case TokenID.Bool:\n            case TokenID.Number:\n            case TokenID.String:\n                return true;\n        }\n        return false;\n    }\n\n    // Return true if the token is a primitive type\n    export function isModifier(token: Token) {\n        switch (token.tokenId) {\n            case TokenID.Public:\n            case TokenID.Private:\n            case TokenID.Static:\n                return true;\n        }\n        return false;\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export class AssignScopeContext {\n        constructor (public scopeChain: ScopeChain,\n                     public typeFlow: TypeFlow,\n                     public modDeclChain: ModuleDeclaration[]) {\n        }\n    }\n\n    export function pushAssignScope(scope: SymbolScope,\n        context: AssignScopeContext,\n        type: Type,\n        classType: Type,\n        fnc: FuncDecl) {\n\n        var chain = new ScopeChain(null, context.scopeChain, scope);\n        chain.thisType = type;\n        chain.classType = classType;\n        chain.fnc = fnc;\n        context.scopeChain = chain;\n    }\n\n    export function popAssignScope(context: AssignScopeContext) {\n        context.scopeChain = context.scopeChain.previous;\n    }\n\n    export function instanceCompare(a: Symbol, b: Symbol) {\n        if (((a == null) || (!a.isInstanceProperty()))) {\n            return b;\n        }\n        else {\n            return a;\n        }\n    }\n\n    export function instanceFilterStop(s: Symbol) {\n        return s.isInstanceProperty();\n    }\n\n    export class ScopeSearchFilter {\n\n        constructor (public select: (a: Symbol, b: Symbol) =>Symbol,\n                            public stop: (s: Symbol) =>bool) { }\n\n        public result: Symbol = null;\n\n        public reset() {\n            this.result = null;\n        }\n\n        public update(b: Symbol): bool {\n            this.result = this.select(this.result, b);\n            if (this.result) {\n                return this.stop(this.result);\n            }\n            else {\n                return false;\n            }\n        }\n    }\n\n    export var instanceFilter = new ScopeSearchFilter(instanceCompare, instanceFilterStop);\n\n    export function preAssignModuleScopes(ast: AST, context: AssignScopeContext) {\n        var moduleDecl = <ModuleDeclaration>ast;\n        var memberScope: SymbolTableScope = null;\n        var aggScope: SymbolAggregateScope = null;\n\n        if (moduleDecl.name && moduleDecl.mod) {\n            moduleDecl.name.sym = moduleDecl.mod.symbol;\n        }\n\n        var mod = moduleDecl.mod;\n\n        // We\'re likely here because of error recovery\n        if (!mod) {\n            return;\n        }\n\n        memberScope = new SymbolTableScope(mod.members, mod.ambientMembers, mod.enclosedTypes, mod.ambientEnclosedTypes, mod.symbol);\n        mod.memberScope = memberScope;\n        context.modDeclChain.push(moduleDecl);\n        context.typeFlow.checker.currentModDecl = moduleDecl;\n        aggScope = new SymbolAggregateScope(mod.symbol);\n        aggScope.addParentScope(memberScope);\n        aggScope.addParentScope(context.scopeChain.scope);\n        pushAssignScope(aggScope, context, null, null, null);\n        mod.containedScope = aggScope;\n        if (mod.symbol) {\n            context.typeFlow.addLocalsFromScope(mod.containedScope, mod.symbol, moduleDecl.vars, mod.members.privateMembers, true);\n        }\n    }\n\n    export function preAssignClassScopes(ast: AST, context: AssignScopeContext) {\n        var classDecl = <InterfaceDeclaration>ast;\n        var memberScope: Symb';
var v27550 = v27551 + "olTableScope = null;\n        var aggScope: SymbolAggregateScope = null;\n\n        if (classDecl.name && classDecl.type) {\n            classDecl.name.sym = classDecl.type.symbol;\n        }\n\n        var classType = ast.type;\n\n        if (classType) {\n            var classSym = classType.symbol;\n            memberScope = <SymbolTableScope>context.typeFlow.checker.scopeOf(classType);\n\n            aggScope = new SymbolAggregateScope(classType.symbol);\n            aggScope.addParentScope(memberScope);\n            aggScope.addParentScope(context.scopeChain.scope);\n\n            classType.containedScope = aggScope;\n            classType.memberScope = memberScope;\n\n            var instanceType = classType.instanceType;\n            memberScope = <SymbolTableScope>context.typeFlow.checker.scopeOf(instanceType);\n            instanceType.memberScope = memberScope;\n\n            aggScope = new SymbolAggregateScope(instanceType.symbol);\n            aggScope.addParentScope(context.scopeChain.scope);\n\n            pushAssignScope(aggScope, context, instanceType, classType, null);\n            instanceType.containedScope = aggScope;\n        }\n        else {\n            ast.type = context.typeFlow.anyType;\n        }\n    }\n\n    export function preAssignInterfaceScopes(ast: AST, context: AssignScopeContext) {\n        var interfaceDecl = <InterfaceDeclaration>ast;\n        var memberScope: SymbolTableScope = null;\n        var aggScope: SymbolAggregateScope = null;\n\n        if (interfaceDecl.name && interfaceDecl.type) {\n            interfaceDecl.name.sym = interfaceDecl.type.symbol;\n        }\n\n        var interfaceType = ast.type;\n        memberScope = <SymbolTableScope>context.typeFlow.checker.scopeOf(interfaceType);\n        interfaceType.memberScope = memberScope;\n        aggScope = new SymbolAggregateScope(interfaceType.symbol);\n        aggScope.addParentScope(memberScope);\n        aggScope.addParentScope(context.scopeChain.scope);\n        pushAssignScope(aggScope, context, null, null, null);\n        interfaceType.containedScope = aggScope;\n    }\n\n    export function preAssignWithScopes(ast: AST, context: AssignScopeContext) {\n        var withStmt = <WithStatement>ast;\n        var withType = withStmt.type;\n\n        var members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n        var ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n\n        var withType = new Type();\n        var withSymbol = new WithSymbol(withStmt.minChar, context.typeFlow.checker.locationInfo.unitIndex, withType);\n        withType.members = members;\n        withType.ambientMembers = ambientMembers;\n        withType.symbol = withSymbol;\n        withType.setHasImplementation();\n        withStmt.type = withType;\n\n        var withScope = new TypeScript.SymbolScopeBuilder(withType.members, withType.ambientMembers, null, null, context.scopeChain.scope, withType.symbol);\n\n        pushAssignScope(withScope, context, null, null, null);\n        withType.containedScope = withScope;\n    }\n\n    export function preAssignFuncDeclScopes(ast: AST, context: AssignScopeContext) {\n        var funcDecl = <FuncDecl>ast;\n\n        var container: Symbol = null;\n        var localContainer: Symbol = null;\n        if (funcDecl.type) {\n            localContainer = ast.type.symbol;\n        }\n\n        var isStatic = hasFlag(funcDecl.fncFlags, FncFlags.Static);\n        var isInnerStatic = isStatic && context.scopeChain.fnc != null;\n        // for inner static functions, use the parent's member scope, so local vars cannot be captured\n        var parentScope = isInnerStatic ? context.scopeChain.fnc.type.memberScope : context.scopeChain.scope;\n\n        // if this is not a method, but enclosed by class, use constructor as\n        // the enclosing scope\n        // REVIEW: Some twisted logic here - this needs to be cleaned up once old classes are removed\n        //  - if it's a new class, always use the contained scope, since we initialize the constructor scope below\n        if (context.scopeChain.thisType &&\n            (!funcDecl.isConstructor || hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod))) {\n            var instType = context.scopeChain.thisType;\n\n            if (!(instType.typeFlags & TypeFlags.IsClass) && !hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {\n                if (!funcDecl.isMethod() || isStatic) {\n                    parentScope = instType.constructorScope;\n                }\n                else {\n                    // use constructor scope if a method as well\n                    parentScope = instType.containedScope;\n                }\n            }\n            else {\n                if (context.scopeChain.previous.scope.container &&\n                    context.scopeChain.previous.scope.container.declAST &&\n                    context.scopeChain.previous.scope.container.declAST.nodeType == NodeType.FuncDecl &&\n                    (<FuncDecl>context.scopeChain.previous.sco";
var v27549 = v27550 + "pe.container.declAST).isConstructor) {\n\n                        // if the parent is the class constructor, use the constructor scope\n                    parentScope = instType.constructorScope;\n                }\n                else if (isStatic && context.scopeChain.classType) {\n                    parentScope = context.scopeChain.classType.containedScope;\n                }\n                else {\n                    // else, use the contained scope\n                    parentScope = instType.containedScope;\n                }\n            }\n            container = instType.symbol;\n        }\n        else if (funcDecl.isConstructor && context.scopeChain.thisType) {\n            // sets the container to the class type's symbol (which is shared by the instance type)\n            container = context.scopeChain.thisType.symbol;\n        }\n\n        if (funcDecl.type == null || hasFlag(funcDecl.type.symbol.flags, SymbolFlags.TypeSetDuringScopeAssignment)) {\n            if (context.scopeChain.fnc && context.scopeChain.fnc.type) {\n                container = context.scopeChain.fnc.type.symbol;\n            }\n\n            var funcScope = null;\n            var outerFnc: FuncDecl = context.scopeChain.fnc;\n            var nameText = funcDecl.name ? funcDecl.name.actualText : null;\n            var fgSym: TypeSymbol = null;\n\n            if (isStatic) {\n                // In the case of function-nested statics, no member list will have bee initialized for the function, so we need\n                // to copy it over.  We don't set this by default because having a non-null member list will throw off assignment\n                // compatibility tests\n                if (outerFnc.type.members == null && container.getType().memberScope) {\n                    outerFnc.type.members = (<SymbolScopeBuilder>(<TypeSymbol>container).type.memberScope).valueMembers;\n                }\n                funcScope = context.scopeChain.fnc.type.memberScope;\n                outerFnc.innerStaticFuncs[outerFnc.innerStaticFuncs.length] = funcDecl;\n            }\n            else {\n                funcScope = context.scopeChain.scope;\n            }\n\n            // REVIEW: We don't search for another sym for accessors to prevent us from\n            // accidentally coalescing function signatures with the same name (E.g., a function\n            // 'f' the outer scope and a setter 'f' in an object literal within that scope)\n            if (nameText && nameText != \"__missing\" && !funcDecl.isAccessor()) {\n                if (isStatic) {\n                    fgSym = funcScope.findLocal(nameText, false, false);\n                }\n                else {\n                    // REVIEW: This logic should be symmetric with preCollectClassTypes\n                    fgSym = funcScope.findLocal(nameText, false, false);\n                }\n            }\n\n            context.typeFlow.checker.createFunctionSignature(funcDecl, container,\n                                                            funcScope, fgSym, fgSym == null);\n\n            // it's a getter or setter for a class property                     \n            if (!funcDecl.accessorSymbol && \n                (funcDecl.fncFlags & FncFlags.ClassMethod) &&\n                container && \n                ((!fgSym || fgSym.declAST.nodeType != NodeType.FuncDecl) && funcDecl.isAccessor()) || \n                    (fgSym && fgSym.isAccessor())) \n            {\n                funcDecl.accessorSymbol = context.typeFlow.checker.createAccessorSymbol(funcDecl, fgSym, container.getType(), (funcDecl.isMethod() && isStatic), true, funcScope, container);\n            }\n\n            funcDecl.type.symbol.flags |= SymbolFlags.TypeSetDuringScopeAssignment;\n        }\n\n        // Set the symbol for functions and their overloads\n        if (funcDecl.name && funcDecl.type) {\n            funcDecl.name.sym = funcDecl.type.symbol;\n        }\n\n        // Keep track of the original scope type, because target typing might override\n        // the \"type\" member. We need the original \"Scope type\" for completion list, etc.\n        funcDecl.scopeType = funcDecl.type;\n\n        // Overloads have no scope, so bail here\n        if (funcDecl.isOverload) {\n            return;\n        }\n\n        var funcTable = new StringHashTable();\n        var funcMembers = new ScopedMembers(new DualStringHashTable(funcTable, new StringHashTable()));\n        var ambientFuncTable = new StringHashTable();\n        var ambientFuncMembers = new ScopedMembers(new DualStringHashTable(ambientFuncTable, new StringHashTable()));\n        var funcStaticTable = new StringHashTable();\n        var funcStaticMembers = new ScopedMembers(new DualStringHashTable(funcStaticTable, new StringHashTable()));\n        var ambientFuncStaticTable = new StringHashTable();\n        var ambientFuncStaticMembers = new ScopedMembers(new DualStringHashTable(ambientFuncStaticTable, new StringHashTable()));\n\n        // REVIEW: Is it a problem that this is being set twice for properties and constructors?\n        funcDe";
var v27548 = v27549 + "cl.unitIndex = context.typeFlow.checker.locationInfo.unitIndex;\n\n        var locals = new SymbolScopeBuilder(funcMembers, ambientFuncMembers, null, null, parentScope, localContainer);\n        var statics = new SymbolScopeBuilder(funcStaticMembers, ambientFuncStaticMembers, null, null, parentScope, null);\n\n        if (funcDecl.isConstructor && context.scopeChain.thisType) {\n            context.scopeChain.thisType.constructorScope = locals;\n        }\n\n        // basically, there are two problems\n        // - Above, for new classes, we were overwriting the constructor scope with the containing scope.  This caused constructor params to be\n        // in scope everywhere\n        // - Below, we're setting the contained scope table to the same table we were overwriting the constructor scope with, which we need to\n        // fish lambda params, etc, out (see funcTable below)\n        //\n        // A good first approach to solving this would be to change addLocalsFromScope to take a scope instead of a table, and add to the\n        // constructor scope as appropriate\n\n        funcDecl.symbols = funcTable;\n\n        if (!funcDecl.isSpecialFn()) {\n            var group = funcDecl.type;\n            var signature = funcDecl.signature;\n\n            if (!funcDecl.isConstructor) {\n                group.containedScope = locals;\n                locals.container = group.symbol;\n\n                group.memberScope = statics;\n                statics.container = group.symbol;\n            }\n            funcDecl.enclosingFnc = context.scopeChain.fnc;\n            group.enclosingType = isStatic ? context.scopeChain.classType : context.scopeChain.thisType;\n            // for mapping when type checking\n            var fgSym = <TypeSymbol>ast.type.symbol;\n            if (((funcDecl.fncFlags & FncFlags.Signature) == FncFlags.None) && funcDecl.vars) {\n                context.typeFlow.addLocalsFromScope(locals, fgSym, funcDecl.vars,\n                                                    funcTable, false);\n                context.typeFlow.addLocalsFromScope(statics, fgSym, funcDecl.statics,\n                                                    funcStaticTable, false);\n            }\n            if (signature.parameters) {\n                var len = signature.parameters.length;\n                for (var i = 0; i < len; i++) {\n                    var paramSym: ParameterSymbol = signature.parameters[i];\n                    context.typeFlow.checker.resolveTypeLink(locals,\n                                                                paramSym.parameter.typeLink, true);\n                }\n            }\n            context.typeFlow.checker.resolveTypeLink(locals, signature.returnType,\n                                                        funcDecl.isSignature());\n        }\n\n        if (!funcDecl.isConstructor || hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {\n            var thisType = (funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) ? context.scopeChain.thisType : null;\n            pushAssignScope(locals, context, thisType, null, funcDecl);\n        }\n\n        if (funcDecl.name && hasFlag(funcDecl.fncFlags, FncFlags.IsFunctionExpression)) {\n            // If the function is an expression, the name will not be visible in the enclosing scope.\n            // Add the function symbol under its name to the local scope to allow for recursive calls.\n            if (funcDecl.name.sym) {\n                funcTable.add(funcDecl.name.actualText, funcDecl.name.sym);\n            }\n        }\n    }\n\n    export function preAssignCatchScopes(ast: AST, context: AssignScopeContext) {\n        var catchBlock = <Catch>ast;\n        if (catchBlock.param) {\n            var catchTable = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable())); // REVIEW: Should we be allocating a public table instead of a private one?\n            var catchLocals = new SymbolScopeBuilder(catchTable, null, null, null, context.scopeChain.scope,\n                                                   context.scopeChain.scope.container);\n            catchBlock.containedScope = catchLocals;\n            pushAssignScope(catchLocals, context, context.scopeChain.thisType, context.scopeChain.classType, context.scopeChain.fnc);\n        }\n    }\n\n    export function preAssignScopes(ast: AST, parent: AST, walker: IAstWalker) {\n        var context:AssignScopeContext = walker.state;\n        var go = true;\n\n        if (ast) {\n            if (ast.nodeType == NodeType.List) {\n                var list = <ASTList>ast;\n                list.enclosingScope = context.scopeChain.scope;\n            }\n            else if (ast.nodeType == NodeType.ModuleDeclaration) {\n                preAssignModuleScopes(ast, context);\n            }\n            else if (ast.nodeType == NodeType.ClassDeclaration) {\n                preAssignClassScopes(ast, context);\n            }\n            else if (ast.nodeType == NodeType.InterfaceDeclaration) {\n                preAssignInterfaceScopes(";
var v27547 = v27548 + 'ast, context);\n            }\n            else if (ast.nodeType == NodeType.With) {\n                preAssignWithScopes(ast, context);\n            }\n            else if (ast.nodeType == NodeType.FuncDecl) {\n                preAssignFuncDeclScopes(ast, context);\n            }\n            else if (ast.nodeType == NodeType.Catch) {\n                preAssignCatchScopes(ast, context);\n            }\n            else if (ast.nodeType == NodeType.TypeRef) {\n                go = false;\n            }\n        }\n        walker.options.goChildren = go;\n        return ast;\n    }\n\n    export function postAssignScopes(ast: AST, parent: AST, walker: IAstWalker) {\n        var context:AssignScopeContext = walker.state;\n        var go = true;\n        if (ast) {\n            if (ast.nodeType == NodeType.ModuleDeclaration) {\n                var prevModDecl = <ModuleDeclaration>ast;\n\n                popAssignScope(context);\n\n                context.modDeclChain.pop();\n                if (context.modDeclChain.length >= 1) {\n                    context.typeFlow.checker.currentModDecl = context.modDeclChain[context.modDeclChain.length - 1];\n                }\n            }\n            else if (ast.nodeType == NodeType.ClassDeclaration) {\n                popAssignScope(context);\n            }\n            else if (ast.nodeType == NodeType.InterfaceDeclaration) {\n                popAssignScope(context);\n            }\n            else if (ast.nodeType == NodeType.With) {\n                popAssignScope(context);\n            }\n            else if (ast.nodeType == NodeType.FuncDecl) {\n                var funcDecl = <FuncDecl>ast;\n                if ((!funcDecl.isConstructor || hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) && !funcDecl.isOverload) {\n                    popAssignScope(context);\n                }\n            }\n            else if (ast.nodeType == NodeType.Catch) {\n                var catchBlock = <Catch>ast;\n                if (catchBlock.param) {\n                    popAssignScope(context);\n                }\n            }\n            else {\n                go = false;\n            }\n        }\n        walker.options.goChildren = go;\n        return ast;\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class TypeCollectionContext {\n        public script: Script = null;\n\n        constructor (public scopeChain: ScopeChain, public checker: TypeChecker) {\n        }\n    }\n\n    export class MemberScopeContext {\n        public type: Type = null;\n        public ast: AST = null;\n        public scope: SymbolScope;\n        public options = new AstWalkOptions();\n\n        constructor (public flow: TypeFlow, public pos: number, public matchFlag: ASTFlags) {\n        }\n    }\n\n    export class EnclosingScopeContext {\n\n        public scopeGetter: () => SymbolScope = null;\n        public objectLiteralScopeGetter: () => SymbolScope = null;\n        public scopeStartAST: AST = null;\n        public skipNextFuncDeclForClass = false;\n        public deepestModuleDecl: ModuleDeclaration = null;\n        public enclosingClassDecl: TypeDeclaration = null;\n        public enclosingObjectLit: UnaryExpression = null;\n        public publicsOnly = true;\n        public useFullAst = false;\n        private scriptFragment: Script;\n\n        constructor (public logger: ILogger,\n                    public script: Script,\n                    public text: ISourceText,\n                    public pos: number,\n                    public isMemberCompletion: bool) {\n        }\n\n        public getScope(): SymbolScope {\n            return this.scopeGetter();\n        }\n\n        public getObjectLiteralScope(): SymbolScope {\n            return this.objectLiteralScopeGetter();\n        }\n\n        public getScopeAST() {\n            return this.scopeStartAST;\n        }\n\n        public getScopePosition() {\n            return this.scopeStartAST.minChar;\n        }\n\n        public getScriptFragmentStartAST(): AST {\n            return this.scopeStartAST;\n        }\n\n        public getScriptFragmentPosition(): number {\n            return this.getScriptFragmentStartAST().minChar;\n        }\n\n        public getScriptFragment(): Script {\n            if (this.scriptFragment == null) {\n                var ast = this.getScriptFragmentStartAST();\n                var minChar = ast.minChar;\n                var limChar = (this.isMemberCompletion ? this.pos : this.po';
var v27546 = v27547 + "s + 1);\n                this.scriptFragment = TypeScript.quickParse(this.logger, ast, this.text, minChar, limChar, null/*errorCapture*/).Script;\n            }\n            return this.scriptFragment;\n        }\n    }\n\n    export function preFindMemberScope(ast: AST, parent: AST, walker: IAstWalker) {\n        var memScope: MemberScopeContext = walker.state;\n        if (hasFlag(ast.flags, memScope.matchFlag) && ((memScope.pos < 0) || (memScope.pos == ast.limChar))) {\n            memScope.ast = ast;\n            if ((ast.type == null) && (memScope.pos >= 0)) {\n                memScope.flow.inScopeTypeCheck(ast, memScope.scope);\n            }\n            memScope.type = ast.type;\n            memScope.options.stopWalk();\n        }\n        return ast;\n    }\n\n    export function pushTypeCollectionScope(container: Symbol,\n        valueMembers: ScopedMembers,\n        ambientValueMembers: ScopedMembers,\n        enclosedTypes: ScopedMembers,\n        ambientEnclosedTypes: ScopedMembers,\n        context: TypeCollectionContext,\n        thisType: Type,\n        classType: Type,\n        moduleDecl: ModuleDeclaration) {\n        var builder = new SymbolScopeBuilder(valueMembers, ambientValueMembers, enclosedTypes, ambientEnclosedTypes, null, container);\n        var chain: ScopeChain = new ScopeChain(container, context.scopeChain, builder);\n        chain.thisType = thisType;\n        chain.classType = classType;\n        chain.moduleDecl = moduleDecl;\n        context.scopeChain = chain;\n    }\n\n    export function popTypeCollectionScope(context: TypeCollectionContext) {\n        context.scopeChain = context.scopeChain.previous;\n    }\n\n    export function preFindEnclosingScope(ast: AST, parent: AST, walker: IAstWalker) {\n        var context: EnclosingScopeContext = walker.state;\n        var minChar = ast.minChar;\n        var limChar = ast.limChar;\n\n        // Account for the fact completion list may be called at the end of a file which\n        // is has not been fully re-parsed yet.\n        if (ast.nodeType == NodeType.Script && context.pos > limChar)\n            limChar = context.pos;\n\n        if ((minChar <= context.pos) &&\n            (limChar >= context.pos)) {\n            switch (ast.nodeType) {\n                case NodeType.Script:\n                    var script = <Script>ast;\n                    context.scopeGetter = function () {\n                        return script.bod === null ? null : script.bod.enclosingScope;\n                    };\n                    context.scopeStartAST = script;\n                    break;\n\n                case NodeType.ClassDeclaration:\n                    context.scopeGetter = function () {\n                        return (ast.type === null || ast.type.instanceType.containedScope === null) ? null : ast.type.instanceType.containedScope;\n                    };\n                    context.scopeStartAST = ast;\n                    context.enclosingClassDecl = <TypeDeclaration>ast;\n                    break;\n\n                case NodeType.ObjectLit:\n                    var objectLit = <UnaryExpression>ast;\n                    // Only consider target-typed object literals\n                    if (objectLit.targetType) {\n                        context.scopeGetter = function () {\n                            return objectLit.targetType.containedScope;\n                        };\n                        context.objectLiteralScopeGetter = function () {\n                            return objectLit.targetType.memberScope;\n                        }\n                        context.enclosingObjectLit = objectLit;\n                    }\n                    break;\n\n                case NodeType.ModuleDeclaration:\n                    context.deepestModuleDecl = <ModuleDeclaration>ast;\n                    context.scopeGetter = function () {\n                        return ast.type === null ? null : ast.type.containedScope;\n                    };\n                    context.scopeStartAST = ast;\n                    break;\n\n                case NodeType.InterfaceDeclaration:\n                    context.scopeGetter = function () {\n                        return (ast.type === null) ? null : ast.type.containedScope;\n                    };\n                    context.scopeStartAST = ast;\n                    break;\n\n                case NodeType.FuncDecl: {\n                    var funcDecl = <FuncDecl>ast;\n                    if (context.skipNextFuncDeclForClass) {\n                        context.skipNextFuncDeclForClass = false;\n                    }\n                    else {\n                        context.scopeGetter = function () {\n                            // The scope of a class constructor is hidden somewhere we don't expect :-S\n                            if (funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {\n                                if (ast.type && ast.type.enclosingType) {\n                                    return ast.type.enclosingType.constructorScope;\n                              ";
var v27545 = v27546 + '  }\n                            }\n\n                            if (funcDecl.scopeType) {\n                                return funcDecl.scopeType.containedScope;\n                            }\n\n                            if (funcDecl.type) {\n                                return funcDecl.type.containedScope;\n                            }\n                            return null;\n                        };\n                        context.scopeStartAST = ast;\n                    }\n                }\n                    break;\n            }\n            walker.options.goChildren = true;\n        }\n        else {\n            walker.options.goChildren = false;\n        }\n        return ast;\n    }\n\n    //\n    // Find the enclosing scope context from a position inside a script AST.\n    // The "scopeStartAST" of the returned scope is always valid.\n    // Return "null" if the enclosing scope can\'t be found.\n    //\n    export function findEnclosingScopeAt(logger: ILogger, script: Script, text: ISourceText, pos: number, isMemberCompletion: bool): EnclosingScopeContext {\n        var context = new EnclosingScopeContext(logger, script, text, pos, isMemberCompletion);\n\n        TypeScript.getAstWalkerFactory().walk(script, preFindEnclosingScope, null, null, context);\n\n        if (context.scopeStartAST === null)\n            return null;\n        return context;\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class Signature {\n        public hasVariableArgList = false;\n        public returnType: TypeLink;\n        public parameters: ParameterSymbol[] = null;\n        public declAST: FuncDecl = null;\n        public typeCheckStatus = TypeCheckStatus.NotStarted;\n        public nonOptionalParameterCount = 0;\n\n        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Signature {\n            var result = new Signature();\n            if (this.hasVariableArgList) {\n                result.hasVariableArgList = true;\n            }\n            result.returnType = new TypeLink();\n            if (this.returnType.type) {\n                result.returnType.type =\n                    this.returnType.type.specializeType(pattern, replacement, checker, false);\n            }\n            else {\n                result.returnType.type = checker.anyType;\n            }\n\n            if (this.parameters) {\n                result.parameters = [];\n                for (var i = 0, len = this.parameters.length; i < len; i++) {\n                    var oldSym:ParameterSymbol = this.parameters[i];\n                    var paramDef = new ValueLocation();\n                    var paramSym = new ParameterSymbol(oldSym.name, oldSym.location,\n                                                     checker.locationInfo.unitIndex,\n                                                     paramDef);\n\n                    paramSym.declAST = this.declAST;\n                    paramDef.symbol = paramSym;\n                    paramDef.typeLink = new TypeLink();\n                    result.parameters[i] = paramSym;\n                    var oldType = oldSym.getType();\n                    if (oldType) {\n                        paramDef.typeLink.type = oldType.specializeType(pattern, replacement, checker, false);\n                        paramSym.declAST.type = paramDef.typeLink.type;\n                    }\n                    else {\n                        paramDef.typeLink.type = checker.anyType;\n                    }\n                }\n            }\n            result.nonOptionalParameterCount = this.nonOptionalParameterCount;\n            result.declAST = this.declAST;\n\n            return result;\n        }\n\n        public toString() {\n            return this.toStringHelper(false, false, null);\n        }\n\n        public toStringHelper(shortform: bool, brackets: bool, scope: SymbolScope) {\n            return this.toStringHelperEx(shortform, brackets, scope).toString();\n        }\n\n        public toStringHelperEx(shortform: bool, brackets: bool, scope: SymbolScope, prefix? : string = "") : MemberName {\n            var builder = new MemberNameArray();\n            if (brackets) {\n                builder.prefix =  prefix + "[";\n            }\n            else {\n                builder.prefix = prefix + "(";\n            }\n\n            var paramLen = this.parameters.length;\n            var len = this.hasVariableArgList ? paramLen - 1 : par';
var v27544 = v27545 + 'amLen;\n            for (var i = 0; i < len; i++) {\n                builder.add(MemberName.create(this.parameters[i].name + (this.parameters[i].isOptional() ? "?" : "") + ": "));\n                builder.add(this.parameters[i].getType().getScopedTypeNameEx(scope));\n                if (i < paramLen - 1) {\n                    builder.add(MemberName.create(", "));\n                }\n            }\n\n            if (this.hasVariableArgList) {\n                builder.add(MemberName.create("..." + this.parameters[i].name + ": "));\n                builder.add(this.parameters[i].getType().getScopedTypeNameEx(scope));\n            }\n\n            if (shortform) {\n                if (brackets) {\n                    builder.add(MemberName.create("] => "));\n                }\n                else {\n                    builder.add(MemberName.create(") => "));\n                }\n            }\n            else {\n                if (brackets) {\n                    builder.add(MemberName.create("]: "));\n                }\n                else {\n                    builder.add(MemberName.create("): "));\n                }\n            }\n\n            if (this.returnType.type) {\n                 builder.add(this.returnType.type.getScopedTypeNameEx(scope));\n            }\n            else {\n                builder.add(MemberName.create("any"));\n            }\n            return builder;\n        }\n    }\n\n    export class SignatureGroup {\n        public signatures: Signature[] = [];\n        public hasImplementation = true;\n        public definitionSignature: Signature = null;\n        public hasBeenTypechecked = false;\n        public flags: SignatureFlags = SignatureFlags.None;\n        public addSignature(signature: Signature) {\n            if (this.signatures == null) {\n                this.signatures = new Signature[];\n            }\n            this.signatures[this.signatures.length] = signature;\n            \n            // REVIEW: duplicates should be found within createFunctionSignature,\n            // so we won\'t check for them here\n            if (signature.declAST &&\n                !signature.declAST.isOverload &&\n                !signature.declAST.isSignature() && \n                !hasFlag(signature.declAST.fncFlags, FncFlags.Ambient) &&\n                hasFlag(signature.declAST.fncFlags, FncFlags.Definition)) {\n                this.definitionSignature = signature;\n            }\n        }\n\n        public toString() { return this.signatures.toString(); }\n        public toStrings(prefix: string, shortform: bool, scope: SymbolScope) {\n            var result : MemberName[] = [];  \n            var len = this.signatures.length;\n            if (len > 1) {\n                shortform = false;\n            }\n            for (var i = 0; i < len; i++) {\n                // the definition signature shouldn\'t be printed if there are overloads\n                if (len > 1 && this.signatures[i] == this.definitionSignature) {\n                    continue;\n                }\n                if (this.flags & SignatureFlags.IsIndexer) {\n                    result.push(this.signatures[i].toStringHelperEx(shortform, true, scope));\n                }\n                else {\n                    result.push(this.signatures[i].toStringHelperEx(shortform, false, scope, prefix));\n                }\n            }\n            \n            return result;\n        }\n\n        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): SignatureGroup {\n            var result = new SignatureGroup();\n            if (this.signatures) {\n                for (var i = 0, len = this.signatures.length; i < len; i++) {\n                    result.addSignature(this.signatures[i].specializeType(pattern, replacement, checker));\n                }\n            }\n            return result;\n        }\n\n        // verifies that signatures are\n        //  - unique within a given group\n        //  - compatible with the declaration signature\n        public verifySignatures(checker: TypeChecker) {\n\n            var len = 0;\n            \n            // TODO: verify no signature pair with identical parameters\n            if (this.signatures && ((len = this.signatures.length) > 0)) {\n                \n                for (var i = 0; i < len; i++) {\n                    \n                    for (var j = i + 1; j < len; j++) {\n                        // next check for equivalence between overloads - no two can be exactly the same                     \n                        if (this.signatures[i].declAST && this.signatures[j].declAST &&\n                            (!hasFlag(this.signatures[i].declAST.fncFlags, FncFlags.Definition) && !hasFlag(this.signatures[j].declAST.fncFlags, FncFlags.Definition)) &&\n                            checker.signaturesAreIdentical(this.signatures[i], this.signatures[j])) {\n                            checker.errorReporter.simpleError(this.signatures[i].declAST, (this.signatures[i].declAST && this.signatures[i].declAST.name) ? "Signature for \'" + this.signatures';
var v27543 = v27544 + '[i].declAST.name.actualText + "\' is duplicated" :"Signature is duplicated");\n                        }\n                    }\n                    \n                    // finally, ensure that the definition is assignable to each signature\n                    if (this.definitionSignature) {\n                        if (!checker.signatureIsAssignableToTarget(this.definitionSignature, this.signatures[i])) {\n                            checker.errorReporter.simpleError(this.signatures[i].declAST, "Overload signature is not compatible with function definition");\n                        }\n                    }\n                }\n            }\n        }\n\n        public typeCheck(checker: TypeChecker, ast: AST, hasConstruct:bool) {\n            \n            if (this.hasBeenTypechecked) {\n                return;\n            }\n            \n            // set here to prevent us from recursively invoking typeCheck again\n            this.hasBeenTypechecked = true;\n            \n            var len = 0;\n            \n            if (this.signatures && ((len = this.signatures.length) > 0)) {\n                \n                // first, typecheck each signature\n                for (var i = 0; i < len; i++) {\n\n                    if (!hasConstruct && !this.definitionSignature && this.signatures[i].declAST && this.signatures[i].declAST.isOverload && !hasFlag(this.signatures[i].declAST.fncFlags, FncFlags.Ambient)) {\n                        checker.errorReporter.simpleError(this.signatures[i].declAST, "Overload declaration lacks definition");\n                    }\n\n                    // If we\'re typechecking a constructor via one of its overloads, ensure that the outer class is typechecked, since we need to validate its inheritance properties\n                    // to properly check that \'super\' is being used correctly\n                    if (this.signatures[i].declAST && this.signatures[i].declAST.isConstructor && this.signatures[i].declAST.classDecl && this.signatures[i].declAST.classDecl.type.symbol.typeCheckStatus == TypeCheckStatus.NotStarted) {\n                        checker.typeFlow.typeCheck(this.signatures[i].declAST.classDecl);\n                    }\n\n                    checker.typeFlow.typeCheck(this.signatures[i].declAST);\n                }\n\n                this.verifySignatures(checker);\n            }\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n///<reference path=\'..\\harness\\external\\json2.ts\' />\n\nmodule TypeScript {\n    export class SourceMapPosition {\n        public sourceLine: number;\n        public sourceColumn: number;\n        public emittedLine: number;\n        public emittedColumn: number;\n    }\n\n    export class SourceMapping {\n        public start = new SourceMapPosition();\n        public end = new SourceMapPosition();\n        public nameIndex: number = -1;\n        public childMappings: SourceMapping[] = [];\n    }\n\n    export class SourceMapper {\n        static MapFileExtension = ".map";\n        \n        public sourceMappings: SourceMapping[] = [];\n        public currentMappings: SourceMapping[][] = [];\n\n        public names: string[] = [];\n        public currentNameIndex: number[] = [];\n\n        public jsFileName: string;\n        public tsFileName: string;\n\n        constructor(tsFileName: string, jsFileName: string, public jsFile: ITextWriter, public sourceMapOut: ITextWriter, public errorReporter: ErrorReporter) {\n            this.currentMappings.push(this.sourceMappings);\n\n            jsFileName = switchToForwardSlashes(jsFileName);\n            this.jsFileName = TypeScript.getPrettyName(jsFileName, false, true);\n\n            var removalIndex = jsFileName.lastIndexOf(this.jsFileName);\n            var fixedPath = jsFileName.substring(0, removalIndex);\n\n            this.tsFileName = TypeScript.getRelativePathToFixedPath(fixedPath, tsFileName);\n        }\n        \n        // Generate source mapping\n        static EmitSourceMapping(allSourceMappers: SourceMapper[]) {\n            // At this point we know that there is at least one source mapper present.\n            // If there are multiple source mappers, all will correspond to same map file but different sources\n\n            // Output map file name into the js file\n            var sourceMapper = allSourceMappers[0];\n            sourceMapper.jsFile.WriteLine("//@ sourceMappingURL=" + sourceMapper.jsFileName + SourceMapper.MapFileExtension);\n\n  ';
var v27542 = v27543 + '          // Now output map file\n            var sourceMapOut = sourceMapper.sourceMapOut;\n            var mappingsString = "";\n            var tsFiles: string[] = [];\n\n            var prevEmittedColumn = 0;\n            var prevEmittedLine = 0;\n            var prevSourceColumn = 0;\n            var prevSourceLine = 0;\n            var prevSourceIndex = 0;\n            var prevNameIndex = 0;\n            var namesList: string[] = [];\n            var namesCount = 0;\n            var emitComma = false;\n\n            var recordedPosition: SourceMapPosition = null;\n            for (var sourceMapperIndex = 0; sourceMapperIndex < allSourceMappers.length; sourceMapperIndex++) {\n                sourceMapper = allSourceMappers[sourceMapperIndex];\n\n                // If there are any mappings generated\n                var currentSourceIndex = tsFiles.length;\n                tsFiles.push(sourceMapper.tsFileName);\n\n                // Join namelist\n                if (sourceMapper.names.length > 0) {\n                    namesList.push.apply(namesList, sourceMapper.names);\n                }\n\n                var recordSourceMapping = (mappedPosition: SourceMapPosition, nameIndex: number) => {\n                    if (recordedPosition != null &&\n                        recordedPosition.emittedColumn == mappedPosition.emittedColumn &&\n                        recordedPosition.emittedLine == mappedPosition.emittedLine) {\n                        // This position is already recorded\n                        return;\n                    }\n\n                    // Record this position\n                    if (prevEmittedLine !== mappedPosition.emittedLine) {\n                        while (prevEmittedLine < mappedPosition.emittedLine) {\n                            prevEmittedColumn = 0;\n                            mappingsString = mappingsString + ";";\n                            prevEmittedLine++;\n                        }\n                        emitComma = false;\n                    }\n                    else if (emitComma) {\n                        mappingsString = mappingsString + ",";\n                    }\n\n                    // 1. Relative Column\n                    mappingsString = mappingsString + Base64VLQFormat.encode(mappedPosition.emittedColumn - prevEmittedColumn);\n                    prevEmittedColumn = mappedPosition.emittedColumn;\n\n                    // 2. Relative sourceIndex \n                    mappingsString = mappingsString + Base64VLQFormat.encode(currentSourceIndex - prevSourceIndex);\n                    prevSourceIndex = currentSourceIndex;\n\n                    // 3. Relative sourceLine 0 based\n                    mappingsString = mappingsString + Base64VLQFormat.encode(mappedPosition.sourceLine - 1 - prevSourceLine);\n                    prevSourceLine = mappedPosition.sourceLine - 1;\n\n                    // 4. Relative sourceColumn 0 based \n                    mappingsString = mappingsString + Base64VLQFormat.encode(mappedPosition.sourceColumn - prevSourceColumn);\n                    prevSourceColumn = mappedPosition.sourceColumn;\n\n                    // 5. Relative namePosition 0 based\n                    if (nameIndex >= 0) {\n                        mappingsString = mappingsString + Base64VLQFormat.encode(namesCount + nameIndex - prevNameIndex);\n                        prevNameIndex = namesCount + nameIndex;\n                    }\n\n                    emitComma = true;\n                    recordedPosition = mappedPosition;\n                }\n\n                // Record starting spans\n                var recordSourceMappingSiblings = (sourceMappings: SourceMapping[]) => {\n                    for (var i = 0; i < sourceMappings.length; i++) {\n                        var sourceMapping = sourceMappings[i];\n                        recordSourceMapping(sourceMapping.start, sourceMapping.nameIndex);\n                        recordSourceMappingSiblings(sourceMapping.childMappings);\n                        recordSourceMapping(sourceMapping.end, sourceMapping.nameIndex);\n                    }\n                }\n\n                recordSourceMappingSiblings(sourceMapper.sourceMappings, -1);\n                namesCount = namesCount + sourceMapper.names.length;\n            }\n\n            // Write the actual map file\n            if (mappingsString != "") {\n                sourceMapOut.Write(JSON2.stringify({\n                    version: 3,\n                    file: sourceMapper.jsFileName,\n                    sources: tsFiles,\n                    names: namesList,\n                    mappings: mappingsString\n                }));\n            }\n\n            // Done, close the file\n            try {\n                // Closing files could result in exceptions, report them if they occur\n                sourceMapOut.Close();\n            } catch (ex) {\n                sourceMapper.errorReporter.emitterError(null, ex.message);\n            }\n        }\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under';
var v27541 = v27542 + ' the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    // private members are private to the scope\n    // public members are public to the scope\n    export class ScopedMembers {\n\n        public allMembers: IHashTable;\n        public publicMembers: IHashTable;\n        public privateMembers: IHashTable;\n\n        constructor (public dualMembers: DualStringHashTable) { \n            this.allMembers = this.dualMembers;\n            this.publicMembers = this.dualMembers.primaryTable;\n            this.privateMembers = this.dualMembers.secondaryTable;\n        }\n\n        // add a public member\n        public addPublicMember(key: string, data) { return this.dualMembers.primaryTable.add(key, data); }\n\n        // add a private member \n        public addPrivateMember(key: string, data) { return this.dualMembers.secondaryTable.add(key, data); }\n    }\n\n    export enum SymbolKind {\n        None,\n        Type,\n        Field,\n        Parameter,\n        Variable,\n    }\n\n    export class SymbolScope {\n        constructor (public container: Symbol) { }\n        public printLabel() { return "base"; }\n        public getAllSymbolNames(members: bool): string[]{\n            return ["please", "implement", "in", "derived", "classes"];\n        }\n        public getAllTypeSymbolNames(members: bool): string[]{\n            return ["please", "implement", "in", "derived", "classes"];\n        }\n        public getAllValueSymbolNames(members: bool): string[]{\n            return ["please", "implement", "in", "derived", "classes"];\n        }\n        // advanced search using a filter\n        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool): Symbol { return null; }\n        // find in this immediate scope\n        public findLocal(name: string, publicOnly: bool, typespace: bool): Symbol { return null; }\n        // find in value namespace \n        public find(name: string, publicOnly: bool, typespace: bool): Symbol { return null; }\n        // find symbol that supplies an implementation\n        public findImplementation(name: string, publicOnly: bool, typespace: bool): Symbol { return null; }\n        // restrict the search to ambient values\n        public findAmbient(name: string, publicOnly: bool, typespace: bool): Symbol { return null; }\n        public print(outfile: ITextWriter) {\n            if (this.container) {\n                outfile.WriteLine(this.printLabel() + " scope with container: " + this.container.name + "...");\n            }\n            else {\n                outfile.WriteLine(this.printLabel() + " scope...");\n            }\n        }\n\n        public enter(container: Symbol, ast: AST, symbol: Symbol, errorReporter: ErrorReporter, publicOnly: bool,\n            typespace: bool, ambient: bool): void {\n            throw new Error("please implement in derived class");\n        }\n\n        public getTable(): IHashTable {\n            throw new Error("please implement in derived class");\n        }\n    }\n\n    function symbolCanBeUsed(sym: Symbol, publicOnly) {\n        return publicOnly ? !(hasFlag(sym.flags, SymbolFlags.Private) ||\n                            (sym.declAST && sym.declAST.nodeType == NodeType.FuncDecl && hasFlag((<FuncDecl>sym.declAST).fncFlags, FncFlags.Private)))\n                          : true;\n    }\n\n    export class SymbolAggregateScope extends SymbolScope {\n        public printLabel() { return "agg"; }\n        public valueCache: IHashTable = null;\n        public valueImplCache: IHashTable = null;\n        public valueAmbientCache: IHashTable = null;\n        public typeCache: IHashTable = null;\n        public typeImplCache: IHashTable = null;\n        public typeAmbientCache: IHashTable = null;\n        public parents: SymbolScope[] = null;\n        public container: Symbol;\n\n        constructor (container: Symbol) {\n            super(container);\n            this.container = container;\n        }\n\n        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool) {\n            if (this.parents) {\n                for (var i = 0; i < this.parents.length; i++) {\n                    var sym = this.parents[i].search(filter, name, publicOnly, typespace);\n                    if (sym) {\n                        if (filter.update(sym)) {\n                            return sym;\n                        }\n                    }\n                }\n            }\n            return filter.result;\n        }\n\n        public getAllSymbolNames(members';
var v27540 = v27541 + ": bool): string[]{\n            var result: string[] = [];\n            if (this.parents) {\n                for (var i = 0; i < this.parents.length; i++) {\n                    var parentResult = this.parents[i].getAllSymbolNames(members);\n                    if (parentResult) {\n                        result = result.concat(parentResult);\n                    }\n                }\n            }\n            return result;\n        }\n\n        public getAllTypeSymbolNames(members: bool): string[]{\n            var result: string[] = [];\n            if (this.parents) {\n                for (var i = 0; i < this.parents.length; i++) {\n                    var parentResult = this.parents[i].getAllTypeSymbolNames(members);\n                    if (parentResult) {\n                        result = result.concat(parentResult);\n                    }\n                }\n            }\n            return result;\n        }\n\n        public getAllValueSymbolNames(members: bool): string[]{\n            var result: string[] = [];\n            if (this.parents) {\n                for (var i = 0; i < this.parents.length; i++) {\n                    var parentResult = this.parents[i].getAllValueSymbolNames(members);\n                    if (parentResult) {\n                        result = result.concat(parentResult);\n                    }\n                }\n            }\n            return result;\n        }\n\n        public print(outfile: ITextWriter) {\n            super.print(outfile);\n            if (this.parents) {\n                for (var i = 0; i < this.parents.length; i++) {\n                    this.parents[i].print(outfile);\n                }\n            }\n        }\n\n        public findImplementation(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var i = 0;\n            var implCache = this.valueImplCache;\n\n            if (typespace) {\n                implCache = this.typeImplCache;\n            }\n            if (implCache &&\n                ((sym = implCache.lookup(name)) != null) &&\n                (publicOnly ? !(hasFlag(sym.flags, SymbolFlags.Private) ||\n                                        (sym.declAST && sym.declAST.nodeType == NodeType.FuncDecl && hasFlag((<FuncDecl>sym.declAST).fncFlags, FncFlags.Private)))\n                                        : true)) {\n                return sym;\n            }\n            if (this.parents) {\n                for (i = 0; i < this.parents.length; i++) {\n                    sym = this.parents[i].findImplementation(name, publicOnly, typespace);\n                    if (sym) {\n                        break;\n                    }\n                }\n            }\n            if (implCache) {\n                if (typespace) {\n                    this.typeImplCache = new StringHashTable();\n                    implCache = this.typeImplCache;\n                }\n                else {\n                    this.valueImplCache = new StringHashTable();\n                    implCache = this.valueImplCache;\n                }\n            }\n            implCache.add(name, sym);\n            return sym;\n        }\n\n        public find(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var i = 0;\n            var cache = this.valueCache;\n\n            if (typespace) {\n                cache = this.typeCache;\n            }\n            if (cache &&\n                ((sym = cache.lookup(name)) != null) &&\n                (publicOnly ? !(hasFlag(sym.flags, SymbolFlags.Private) ||\n                                        (sym.declAST && sym.declAST.nodeType == NodeType.FuncDecl && hasFlag((<FuncDecl>sym.declAST).fncFlags, FncFlags.Private)))\n                                        : true)) {\n                return sym;\n            }\n            if (this.parents) {\n                for (i = 0; i < this.parents.length; i++) {\n                    sym = this.parents[i].find(name, publicOnly, typespace);\n                    if (sym) {\n                        break;\n                    }\n                }\n            }\n            if (cache == null) {\n                if (typespace) {\n                    this.typeCache = new StringHashTable();\n                    cache = this.typeCache;\n                }\n                else {\n                    this.valueCache = new StringHashTable();\n                    cache = this.valueCache;\n                }\n            }\n            cache.add(name, sym);\n            return sym;\n        }\n\n        public findAmbient(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var i = 0;\n            var cache = this.valueAmbientCache;\n            if (typespace) {\n                cache = this.typeAmbientCache;\n            }\n            if (cache && ((sym = cache.lookup(name)) != null)) {\n                return sym;\n            }\n            if (this.parents) {\n                for (i = 0; i < this.parents.length; i++) {\n                    sym =";
var v27539 = v27540 + ' this.parents[i].findAmbient(name, publicOnly, typespace);\n                    if (sym) {\n                        break;\n                    }\n                }\n            }\n            if (cache == null) {\n                if (typespace) {\n                    this.typeAmbientCache = new StringHashTable();\n                    cache = this.typeAmbientCache;\n                }\n                else {\n                    this.valueAmbientCache = new StringHashTable();\n                    cache = this.valueAmbientCache;\n                }\n            }\n            cache.add(name, sym);\n            return sym;\n        }\n\n        public addParentScope(parent: SymbolScope): void {\n            if (this.parents == null) {\n                this.parents = new SymbolScope[];\n            }\n            this.parents[this.parents.length] = parent;\n        }\n    }\n\n    export class SymbolTableScope extends SymbolScope {\n        public container: Symbol;\n\n        constructor(public valueMembers: ScopedMembers,\n                            public ambientValueMembers: ScopedMembers,\n                            public enclosedTypes: ScopedMembers,\n                            public ambientEnclosedTypes: ScopedMembers,\n                            container: Symbol)\n        {\n            super(container);\n            this.container = container;\n        }\n\n        public printLabel() { return "table"; }\n\n        public getAllSymbolNames(members: bool): string[]{\n            var result = this.getAllTypeSymbolNames(members);\n\n            return result.concat(this.getAllValueSymbolNames(members));\n        }\n\n        public getAllTypeSymbolNames(members: bool): string[]{\n            var result = [];\n            if (this.ambientEnclosedTypes) {\n                result = result.concat(this.ambientEnclosedTypes.allMembers.getAllKeys());\n            }\n            if (this.enclosedTypes) {\n                result = result.concat(this.enclosedTypes.allMembers.getAllKeys());\n            }\n            return result;\n        }\n\n        public getAllValueSymbolNames(members: bool): string[]{\n            var result = [];\n            if (this.ambientValueMembers) {\n                result = result.concat(this.ambientValueMembers.allMembers.getAllKeys());\n            }\n            if (this.valueMembers) {\n                result = result.concat(this.valueMembers.allMembers.getAllKeys());\n            }\n            return result;\n        }\n\n        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool) {\n            var sym = this.find(name, publicOnly, typespace);\n            filter.update(sym);\n            return filter.result;\n        }\n\n        public find(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var table: IHashTable = null;\n            var ambientTable: IHashTable = null;\n\n            if (typespace) {\n                table = (this.enclosedTypes == null) ? null :\n                            publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            else {\n                table = (this.valueMembers == null) ? null :\n                                publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;\n                ambientTable = (this.ambientValueMembers == null) ? null :\n                                    publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            }\n            if (ambientTable) {\n                var s = ambientTable.lookup(name);\n                if (s) { return s; }\n            }\n            if (table) {\n                var s = table.lookup(name);\n                if (s) { return s; }\n            }\n\n            return null;\n        }\n\n        public findAmbient(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var ambientTable = (this.ambientValueMembers == null) ? null :\n                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            if (typespace) {\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            if (ambientTable) {\n                var s = ambientTable.lookup(name);\n                if (s) { return s; }\n            }\n\n            return null;\n        }\n\n        public print(outfile: ITextWriter) {\n            super.print(outfile);\n            if (this.ambientValueMembers) {\n                this.ambientValueMembers.allMembers.map(function (key, sym, context) {\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n            if (this.valueMembers) {\n   ';
var v27538 = v27539 + '             this.valueMembers.allMembers.map(function (key, sym, context) {\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n            if (this.ambientEnclosedTypes) {\n                this.ambientEnclosedTypes.allMembers.map(function (key, sym, context) {\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n            if (this.enclosedTypes) {\n                this.enclosedTypes.allMembers.map(function (key, sym, context) {\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n        }\n\n        public findImplementation(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym = this.find(name, publicOnly, typespace);\n            if (sym) {\n                if (sym.kind() == SymbolKind.Type) {\n                    var typeSym = <TypeSymbol>sym;\n                    if (!typeSym.type.hasImplementation()) {\n                        sym = null;\n                    }\n                }\n                else if (sym.container) {\n                    if (sym.container.kind() == SymbolKind.Type) {\n                        var ctypeSym = <TypeSymbol>sym.container;\n                        if (!ctypeSym.type.hasImplementation()) {\n                            sym = null;\n                        }\n                    }\n                }\n            }\n            return sym;\n        }\n\n        public getTable() {\n            return this.valueMembers.publicMembers;\n        }\n    }\n\n    export class SymbolScopeBuilder extends SymbolScope {\n        public container: Symbol;\n        \n        constructor (public valueMembers: ScopedMembers,\n                    public ambientValueMembers: ScopedMembers,\n                    public enclosedTypes: ScopedMembers,\n                    public ambientEnclosedTypes: ScopedMembers,\n                    public parent: SymbolScope,\n                    container: Symbol)\n        {\n            super(container);\n            this.container = container;\n        }\n\n        public printLabel() { return "builder"; }\n        public getAllSymbolNames(members: bool): string[]{\n            var result: string[] = this.getAllTypeSymbolNames(members);\n            return result.concat(this.getAllValueSymbolNames(members));\n        }\n\n        public getAllTypeSymbolNames(members: bool): string[]{\n            var result: string[] = [];\n            if (this.ambientEnclosedTypes) {\n                result = result.concat(this.ambientEnclosedTypes.allMembers.getAllKeys());\n            }\n            if (this.enclosedTypes) {\n                result = result.concat(this.enclosedTypes.allMembers.getAllKeys());\n            }\n            if (!members && this.parent) {\n                var parentResult = this.parent.getAllTypeSymbolNames(members);\n                if (parentResult) {\n                    result = result.concat(parentResult);\n                }\n            }\n            return result;\n        }\n\n        public getAllValueSymbolNames(members: bool): string[]{\n            var result: string[] = [];\n            if (this.ambientValueMembers) {\n                result = result.concat(this.ambientValueMembers.allMembers.getAllKeys());\n            }\n            if (this.valueMembers) {\n                result = result.concat(this.valueMembers.allMembers.getAllKeys());\n            }\n            if (!members && this.parent) {\n                var parentResult = this.parent.getAllValueSymbolNames(members);\n                if (parentResult) {\n                    result = result.concat(parentResult);\n                }\n            }\n            return result;\n        }\n\n        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool) {\n            var sym: Symbol = null;\n            var table = (this.valueMembers == null) ? null :\n                            publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;\n            var ambientTable = (this.ambientValueMembers == null) ? null :\n                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            if (typespace) {\n                table = (this.enclosedTypes == null) ? null :\n                            publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            if (ambientTable) {\n                if ((sym = ambientTable.lookup(name)) != null) {\n                    if (filter.update(sym)) {\n                        return sym;\n                    }\n                }\n            }\n            if (table) {\n                if ((sym = table.lookup(name)) != null) {\n                    if (filter.update(sym)) {\n                        return sym;\n                    }\n        ';
var v27537 = v27538 + '        }\n            }\n            if (this.parent) {\n                sym = this.parent.search(filter, name, publicOnly, typespace);\n                if (sym) {\n                    if (filter.update(sym)) {\n                        return sym;\n                    }\n                }\n            }\n            return filter.result;\n        }\n\n        public print(outfile: ITextWriter) {\n            super.print(outfile);\n            if (this.ambientValueMembers) {\n                this.ambientValueMembers.allMembers.map(function (key, s, context) {\n                    var sym = <Symbol>s;\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n            if (this.valueMembers) {\n                this.valueMembers.allMembers.map(function (key, s, context) {\n                    var sym = <Symbol>s;\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n            if (this.ambientEnclosedTypes) {\n                this.ambientEnclosedTypes.allMembers.map(function (key, s, context) {\n                    var sym = <Symbol>s;\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n            if (this.enclosedTypes) {\n                this.enclosedTypes.allMembers.map(function (key, s, context) {\n                    var sym = <Symbol>s;\n                    outfile.WriteLine("  " + key);\n                }, null);\n            }\n            if (this.parent) {\n                this.parent.print(outfile);\n            }\n        }\n\n        public find(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var table = (this.valueMembers == null) ? null :\n                            publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;\n            var ambientTable = (this.ambientValueMembers == null) ? null :\n                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            if (typespace) {\n                table = (this.enclosedTypes == null) ? null :\n                            publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            if (ambientTable && ((sym = ambientTable.lookup(name)) != null)) {\n                return sym;\n            }\n            if (table && ((sym = table.lookup(name)) != null)) {\n                return sym;\n            }\n            if (this.parent) {\n                return this.parent.find(name, publicOnly, typespace);\n            }\n            return null;\n        }\n\n        public findAmbient(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var ambientTable = (this.ambientValueMembers == null) ? null :\n                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            if (typespace) {\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            if (ambientTable && ((sym = ambientTable.lookup(name)) != null)) {\n                return sym;\n            }\n            if (this.parent) {\n                return this.parent.findAmbient(name, publicOnly, typespace);\n            }\n            return null;\n        }\n\n        public findLocal(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym: Symbol = null;\n            var table = (this.valueMembers == null) ? null :\n                            publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;\n            var ambientTable = (this.ambientValueMembers == null) ? null :\n                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\n            if (typespace) {\n                table = (this.enclosedTypes == null) ? null :\n                            publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;\n                ambientTable = (this.ambientEnclosedTypes == null) ? null :\n                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\n            }\n            if (table) {\n                if ((sym = table.lookup(name)) != null) {\n                    if (sym) { return sym; }\n                }\n            }\n            if (ambientTable) {\n                if ((sym = ambientTable.lookup(name)) != null) {\n                    if (sym) { return sym; }\n                }\n            }\n            return null;\n        }\n\n        public enter(container: Symbol, ast: AST, symbol: Symbol, ';
var v27536 = v27537 + 'errorReporter: ErrorReporter, insertAsPublic: bool, typespace: bool, ambient: bool): void {\n            var table = null;\n\n            if (ambient) {\n                if (typespace) {\n                    table = (this.ambientEnclosedTypes == null) ? null :\n                                    insertAsPublic ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.privateMembers;\n                }\n                else {\n                    table = (this.ambientValueMembers == null) ? null :\n                                insertAsPublic ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.privateMembers;\n                }\n            }\n            else {\n                if (typespace) {\n                    table = (this.enclosedTypes == null) ? null :\n                                insertAsPublic ? this.enclosedTypes.publicMembers : this.enclosedTypes.privateMembers;\n                }\n                else {\n                    table = (this.valueMembers == null) ? null :\n                                insertAsPublic ? this.valueMembers.publicMembers : this.valueMembers.privateMembers;\n                }\n            }\n\n            if (table) {\n                if (!table.add(symbol.name, symbol)) {\n                    errorReporter.duplicateIdentifier(ast, symbol.name);\n                }\n            }\n            else {\n                CompilerDiagnostics.Alert("YYYYY");  // REVIEW: Surely we can do better than this...\n            }\n            symbol.container = container;\n        }\n\n        public getTable() { return this.valueMembers.allMembers; }\n    }\n\n    export class FilteredSymbolScope extends SymbolScope {\n        constructor (public scope: SymbolScope, container: Symbol, public filter: ScopeSearchFilter) {\n            super(container);\n        }\n        public print(outfile: ITextWriter) {\n            this.scope.print(outfile);\n        }\n\n        public find(name: string, publicOnly: bool, typespace: bool) {\n            this.filter.reset();\n            return this.scope.search(this.filter, name, publicOnly, typespace);\n        }\n        public findLocal(name: string, publicOnly: bool, typespace: bool) { return this.scope.findLocal(name, publicOnly, typespace); }\n    }\n\n    export class FilteredSymbolScopeBuilder extends SymbolScopeBuilder {\n        constructor (valueMembers: ScopedMembers, parent: SymbolScope, container: Symbol, public filter: (sym: Symbol) =>bool) {\n            super(valueMembers, null, null, null, parent, container);\n        }\n        public findLocal(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym = super.findLocal(name, publicOnly, typespace);\n            if (sym) {\n                if (!this.filter(sym)) {\n                    return null;\n                }\n            }\n            return sym;\n        }\n\n        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool):Symbol {\n            throw new Error("please implement");\n        }\n\n        public find(name: string, publicOnly: bool, typespace: bool): Symbol {\n            var sym = super.findLocal(name, publicOnly, typespace);\n            if (sym) {\n                if (!this.filter(sym)) {\n                    return null;\n                }\n            }\n            return super.find(name, publicOnly, typespace);\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export enum TypeCheckStatus {\n        NotStarted,\n        Started,\n        Finished,\n    }\n\n    // For lexically-scoped constructs\n    export function aLexicallyEnclosesB(a: Symbol, b: Symbol) {\n        if (a.declAST && b && b.declAST && a.declAST.nodeType == NodeType.FuncDecl) {\n            return a.declAST.minChar <= b.declAST.minChar && a.declAST.limChar >= b.declAST.limChar;\n        }\n        else {\n            return false;\n        }\n    }\n\n    export function aEnclosesB(a: Symbol, b: Symbol) {\n        while (a.container) {\n            if (a == b || aLexicallyEnclosesB(a.container, b)) {\n                return true;\n            }\n            a = a.container;\n        }\n        return false;\n    }\n\n    export interface PhasedTypecheckObject {\n        typeCheckStatus: TypeCheckStatus;\n    }\n\n    export class Symbol {\n        public bound = false;\n        public container: Symbol;\n        public instanceScope(): SymbolScope { return null;';
var v27535 = v27536 + ' }\n        public isVariable() { return false; }\n        public isMember() { return false; }\n        public isInferenceSymbol() { return false; }\n        public isWith() { return false; }\n        public writeable() { return false; }\n        public isType(): bool { return false; }\n        public getType(): Type { return null; }\n        public flags: SymbolFlags = SymbolFlags.None;\n        public refs: Identifier[];\n        public isAccessor() { return false; }\n        public isObjectLitField = false;\n\n        public declAST: AST = null;\n        public declModule: ModuleDeclaration = null;  // if child of module, this is the module that declared it\n\n        public passSymbolCreated: number = CompilerDiagnostics.analysisPass;\n\n        constructor(public name: string, public location: number, public length: number,\n                 public unitIndex: number) { }\n\n        public isInstanceProperty() {\n            return hasFlag(this.flags, SymbolFlags.Property) && (!hasFlag(this.flags, SymbolFlags.ModuleMember));\n        }\n\n        public getTypeName(scope: SymbolScope): string {\n            return this.getTypeNameEx(scope).toString();\n        }\n        \n        public getTypeNameEx(scope: SymbolScope): MemberName {\n            return MemberName.create(this.toString());\n        }\n\n        public getOptionalNameString() {\n            return hasFlag(this.flags, SymbolFlags.Optional) ? "?" : "";\n        }\n\n        public pathToRoot() {\n            var path = new Symbol[];\n            var node = this;\n            while (node && (node.name != globalId)) {\n                path[path.length] = node;\n                node = node.container;\n            }\n            return path;\n        }\n\n        public findCommonAncestorPath(b: Symbol) {\n            if (this.container == null) {\n                return new Symbol[];\n            }\n            var aPath = this.container.pathToRoot();\n            var bPath: Symbol[];\n            if (b) {\n                bPath = b.pathToRoot();\n            }\n            else {\n                bPath = new Symbol[];\n            }\n            var commonNodeIndex = -1;\n            for (var i = 0, aLen = aPath.length; i < aLen; i++) {\n                var aNode = aPath[i];\n                for (var j = 0, bLen = bPath.length; j < bLen; j++) {\n                    var bNode = bPath[j];\n                    if (aNode == bNode) {\n                        commonNodeIndex = i;\n                        break;\n                    }\n                }\n                if (commonNodeIndex >= 0) {\n                    break;\n                }\n            }\n            if (commonNodeIndex >= 0) {\n                return aPath.slice(0, commonNodeIndex);\n            }\n            else {\n                return aPath;\n            }\n        }\n\n        // Gets the pretty Name for the symbol withing the scope\n        public getPrettyName(scopeSymbol: Symbol) {\n            return this.name;\n        }\n\n        public scopeRelativeName(scope: SymbolScope): string {\n            if (scope == null) {\n                return this.getPrettyName(null) + this.getOptionalNameString();\n            }\n            var lca = this.findCommonAncestorPath(scope.container);\n            var builder = "";\n            for (var i = 0, len = lca.length; i < len; i++) {\n                var prettyName = lca[i].getPrettyName(i == len - 1 ? scope.container : lca[i + 1]);\n                builder = prettyName + "." + builder;\n            }\n            builder += this.getPrettyName(len == 0 ? scope.container : lca[0]) + this.getOptionalNameString();\n            return builder;\n        }\n\n        public fullName(): string {\n            var builder = this.name;\n            var ancestor = this.container;\n            while (ancestor && (ancestor.name != globalId)) {\n                builder = ancestor.name + "." + builder;\n                ancestor = ancestor.container;\n            }\n            return builder;\n        }\n\n        public isExternallyVisible(checker: TypeChecker) {\n            // Global module is not hidden\n            if (this == checker.gloMod) {\n                return true;\n            }\n\n            // private symbol\n            if (hasFlag(this.flags, SymbolFlags.Private)) {\n                return false;\n            }\n\n            // If the current container is not exported\n            // If its in global - it is visible, otherwise it isn\'t\n            if (!hasFlag(this.flags, SymbolFlags.Exported)) {\n                return this.container == checker.gloMod;\n            }\n\n            // It is visible if its container is visible too\n            return this.container.isExternallyVisible(checker);\n        }\n\n        public visible(scope: SymbolScope, checker: TypeChecker) {\n            if (checker == null || this.container == checker.gloMod) {\n                return true;\n            }\n\n            if (hasFlag(this.flags, SymbolFlags.ModuleMember)) {\n\n                if (hasFlag(this.flags, SymbolFlags.Exported)) {\n                    if (!hasFlag';
var v27534 = v27535 + '(this.flags, SymbolFlags.Private)) {\n                        return true;\n                    }\n                    else {\n                        return aEnclosesB(this, scope.container);\n                    }\n                }\n                else {\n                    // REVIEW:\n                    // Note that in the scope-assignment and binding phases,\n                    // currentModDecl will point to the "master" module decl,\n                    // and not necessarily the one that the symbol in question\n                    // was declared in.\n                    // That\'s ok - there\'s no harm done in attributing the symbol\n                    // to the master mod decl in either of those phases, so long\n                    // as we reference the actual module fragment of declaration\n                    // during typecheck.  Doing this also prevents us from printing\n                    // multiple error messages if the symbol is not visible.\n                    return checker && (checker.currentModDecl == this.declModule) ||\n                                                (checker.currentModDecl &&\n                                                    checker.currentModDecl.mod &&\n                                                    checker.currentModDecl.mod.symbol &&\n                                                    this.declModule &&\n                                                    this.declModule.mod &&\n                                                    this.declModule.mod.symbol &&\n                                                    aEnclosesB(checker.currentModDecl.mod.symbol, this.declModule.mod.symbol));\n                }\n            }\n            else {\n                // field or method\n                var isFunction = this.declAST && this.declAST.nodeType == NodeType.FuncDecl;\n                var isMethod = isFunction && (<FuncDecl>this.declAST).isMethod();\n                var isStaticFunction = isFunction && hasFlag((<FuncDecl>this.declAST).fncFlags, FncFlags.Static)\n                var isPrivateMethod = isMethod && hasFlag((<FuncDecl>this.declAST).fncFlags, FncFlags.Private);\n                var isAlias = this.isType() && (<TypeSymbol>this).aliasLink;\n\n                if (this.isMember() || isMethod || isStaticFunction || isAlias) {\n                    if (hasFlag(this.flags, SymbolFlags.Private) || isPrivateMethod) {\n                        if (scope.container == null && this.container != scope.container) {\n                            return false; // it\'s an inner member being accessed by the global scope\n                        }\n                        else {\n                            return this.container == null ? true : aEnclosesB(scope.container, this.container);\n                        }\n                    }\n                    else {\n                        return true;\n                    }\n                }\n                else if (this.container) {\n                    return aEnclosesB(this, scope.container);\n                }\n                else {\n                    return true;\n                }\n            }\n        }\n\n        public addRef(identifier: Identifier) {\n            if (!this.refs) {\n                this.refs = [];\n            }\n            this.refs[this.refs.length] = identifier;\n        }\n\n        public toString() {\n            if (this.name) {\n                return this.name;\n            }\n            else {\n                return "_anonymous";\n            }\n        }\n\n        public print(outfile) {\n            outfile.Write(this.toString());\n        }\n\n        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Symbol {\n            throw new Error("please implement in derived class");\n        }\n\n        public setType(type: Type) {\n            throw new Error("please implement in derived class");\n        }\n\n        public kind(): SymbolKind {\n            throw new Error("please implement in derived class");\n        }\n\n        public getInterfaceDeclFromSymbol(checker: TypeChecker) {\n            if (this.declAST != null) {\n                if (this.declAST.nodeType == NodeType.InterfaceDeclaration) {\n                    return <InterfaceDeclaration>this.declAST;\n                } else if (this.container != null && this.container != checker.gloMod && this.container.declAST.nodeType == NodeType.InterfaceDeclaration) {\n                    return <InterfaceDeclaration>this.container.declAST;\n                }\n            }\n\n            return null;\n        }\n\n        public getVarDeclFromSymbol() {\n            if (this.declAST != null && this.declAST.nodeType == NodeType.VarDecl) {\n                return <VarDecl>this.declAST;\n            }\n\n            return null;\n        }\n\n        public getDocComments() : Comment[] {\n            if (this.declAST != null) {\n                return this.declAST.getDocComments();\n            }\n\n            return [];\n        }\n\n        public isStatic() {\n            return hasFlag(this.fla';
var v27533 = v27534 + 'gs, SymbolFlags.Static);\n        }\n    }\n\n    export class ValueLocation {\n        public symbol: Symbol;\n        public typeLink: TypeLink;\n    }\n\n    export class InferenceSymbol extends Symbol {\n        constructor (name: string, location: number, length: number, unitIndex: number) {\n            super(name, location, length, unitIndex);\n        }\n\n        public typeCheckStatus = TypeCheckStatus.NotStarted;\n        public isInferenceSymbol() { return true; }\n        public transferVarFlags(varFlags: VarFlags) {\n            if (hasFlag(varFlags, VarFlags.Ambient)) {\n                this.flags |= SymbolFlags.Ambient;\n            }\n            if (hasFlag(varFlags, VarFlags.Constant)) {\n                this.flags |= SymbolFlags.Constant;\n            }\n            if (hasFlag(varFlags, VarFlags.Static)) {\n                this.flags |= SymbolFlags.Static;\n            }\n            if (hasFlag(varFlags, VarFlags.Property)) {\n                this.flags |= SymbolFlags.Property;\n            }\n            if (hasFlag(varFlags, VarFlags.Private)) {\n                this.flags |= SymbolFlags.Private;\n            }\n            if (hasFlag(varFlags, VarFlags.Public)) {\n                this.flags |= SymbolFlags.Public;\n            }\n            if (hasFlag(varFlags, VarFlags.Readonly)) {\n                this.flags |= SymbolFlags.Readonly;\n            }\n            if (hasFlag(varFlags, VarFlags.Exported)) {\n                this.flags |= SymbolFlags.Exported;\n            }\n        }\n    }\n\n    export class TypeSymbol extends InferenceSymbol {\n        public additionalLocations: number[];\n        public expansions: Type[] = []; // For types that may be "split", keep track of the subsequent definitions\n        public expansionsDeclAST: AST[] = [];\n        public isDynamic = false;\n\n        constructor (locName: string, location: number, length: number, unitIndex: number, public type: Type) {\n            super(locName, location, length, unitIndex);\n            this.prettyName = this.name;\n        }\n\n        public addLocation(loc: number) {\n            if (this.additionalLocations == null) {\n                this.additionalLocations = [];\n            }\n            this.additionalLocations[this.additionalLocations.length] = loc;\n        }\n        public isMethod = false;\n        public aliasLink:ImportDeclaration = null;\n        public kind() { return SymbolKind.Type; }\n        public isType(): bool { return true; }\n        public getType() { return this.type; }\n        public prettyName: string;\n        public onlyReferencedAsTypeRef = optimizeModuleCodeGen;\n\n        public getTypeNameEx(scope: SymbolScope) {\n            return this.type.getMemberTypeNameEx(this.name ? this.name + this.getOptionalNameString() : "", false, false, scope);\n        }\n\n        public instanceScope(): SymbolScope {\n            // Don\'t use the constructor scope for a class body or methods - use the contained scope\n            if (!(this.type.typeFlags & TypeFlags.IsClass) && this.type.isClass()) {\n                return this.type.instanceType.constructorScope;\n            }\n            else {\n                return this.type.containedScope;\n            }\n        }\n        // corresponding instance type if this is a class\n        public instanceType: Type;\n\n        public toString() {\n            var result = this.type.getTypeName();\n            if (this.name) {\n                result = this.name + ":" + result;\n            }\n            return result;\n        }\n\n        public isClass() { return this.instanceType != null; }\n        public isFunction() { return this.declAST != null && this.declAST.nodeType == NodeType.FuncDecl; }\n\n        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Symbol {\n            if (this.type == pattern) {\n                return replacement.symbol;\n            }\n            else {\n                var replType = this.type.specializeType(pattern, replacement, checker, false);\n                if (replType != this.type) {\n                    var result = new TypeSymbol(this.name, -1, 0, -1, replType);\n                    return result;\n                }\n                else {\n                    return this;\n                }\n            }\n        }\n\n        // Gets the pretty name of the symbol with respect to symbol of the scope (scopeSymbol)\n        // searchTillRoot specifies if the name need to searched in the root path of the scope\n        public getPrettyName(scopeSymbol: Symbol) {\n            if (!!scopeSymbol && isQuoted(this.prettyName) && this.type.isModuleType()) {\n                // Its a dynamic module - and need to be specialized with the scope\n                // Check in exported module members in each scope\n                var symbolPath = scopeSymbol.pathToRoot();\n                var prettyName = this.getPrettyNameOfDynamicModule(symbolPath);\n                if (prettyName != null) {\n                    return prettyName.name;\n                }\n            }\n\n            retur';
var v27532 = v27533 + 'n this.prettyName;\n        }\n\n        public getPrettyNameOfDynamicModule(scopeSymbolPath: Symbol[]) {\n            var scopeSymbolPathLength = scopeSymbolPath.length;\n            var externalSymbol: { name: string; symbol: Symbol; } = null;\n            if (scopeSymbolPath.length > 0 &&\n                scopeSymbolPath[scopeSymbolPathLength - 1].getType().isModuleType() &&\n                (<TypeSymbol>scopeSymbolPath[scopeSymbolPathLength - 1]).isDynamic) {\n\n                // Check if submodule is dynamic\n                if (scopeSymbolPathLength > 1 &&\n                    scopeSymbolPath[scopeSymbolPathLength - 2].getType().isModuleType() &&\n                    (<TypeSymbol>scopeSymbolPath[scopeSymbolPathLength - 2]).isDynamic) {\n                    var moduleType = <ModuleType>scopeSymbolPath[scopeSymbolPathLength - 2].getType();\n                    externalSymbol = moduleType.findDynamicModuleName(this.type);\n\n                }\n\n                if (externalSymbol == null) {\n                    // Check in this module\n                    var moduleType = <ModuleType>scopeSymbolPath[scopeSymbolPathLength - 1].getType();\n                    externalSymbol = moduleType.findDynamicModuleName(this.type);\n                }\n            }\n\n            return externalSymbol;\n        }\n\n        public getDocComments(): Comment[]{\n            var comments : Comment[] = [];\n            if (this.declAST != null) {\n                comments = comments.concat(this.declAST.getDocComments());\n            }\n\n            for (var i = 0; i < this.expansionsDeclAST.length; i++) {\n                comments = comments.concat(this.expansionsDeclAST[i].getDocComments());\n            }\n\n            return comments;\n        }\n    }\n\n    export class WithSymbol extends TypeSymbol {\n        constructor (location: number, unitIndex: number, withType: Type) {\n            super("with", location, 4, unitIndex, withType);\n        }\n        public isWith() { return true; }\n    }\n\n    export class FieldSymbol extends InferenceSymbol {\n        public name: string;\n        public location: number;\n\n        constructor (name: string, location: number, unitIndex: number, public canWrite: bool,\n                      public field: ValueLocation) {\n\n            super(name, location, name.length, unitIndex);\n            this.name = name;\n            this.location = location;\n        }\n        public kind() { return SymbolKind.Field; }\n        public writeable() { return this.isAccessor() ? this.setter != null : this.canWrite; }\n        public getType() { return this.field.typeLink.type; }\n        public getTypeNameEx(scope: SymbolScope) {\n            return MemberName.create(this.field.typeLink.type.getScopedTypeNameEx(scope), this.name + this.getOptionalNameString() + ": ", "");\n        }\n\n        public isMember() { return true; }\n        public setType(type: Type) {\n            this.field.typeLink.type = type;\n        }\n\n        public getter: TypeSymbol = null;\n        public setter: TypeSymbol = null;\n        public hasBeenEmitted = false; // since getters and setters are emitted together, need to track if one has been emitted\n\n        public isAccessor() { return this.getter != null || this.setter != null; }\n\n        public isVariable() { return true; }\n        public toString() { return this.getTypeNameEx(null).toString(); }\n        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Symbol {\n            var rType = this.field.typeLink.type.specializeType(pattern, replacement, checker, false);\n            if (rType != this.field.typeLink.type) {\n                var fieldDef = new ValueLocation();\n                var result = new FieldSymbol(this.name, 0, checker.locationInfo.unitIndex,\n                                           this.canWrite, fieldDef);\n                result.flags = this.flags;\n                fieldDef.symbol = result;\n                fieldDef.typeLink = new TypeLink();\n                result.setType(rType);\n                result.typeCheckStatus = TypeCheckStatus.Finished;\n                return result;\n            }\n            else {\n                return this;\n            }\n        }\n\n        public getDocComments(): Comment[] {\n            if (this.getter != null || this.setter != null) {\n                var comments : Comment[] = [];\n                if (this.getter != null) {\n                    comments = comments.concat(this.getter.getDocComments());\n                }\n                if (this.setter != null) {\n                    comments = comments.concat(this.setter.getDocComments());\n                }\n                return comments;\n            }\n            else if (this.declAST != null) {\n                return this.declAST.getDocComments();\n            }\n\n            return [];\n        }\n\n    }\n\n    export class ParameterSymbol extends InferenceSymbol {\n        public name: string;\n        public location: number;\n        private paramDocComment: string = null;\n        public funcDecl';
var v27531 = v27532 + ': AST = null;\n        \n        constructor (name: string, location: number, unitIndex: number,\n                          public parameter: ValueLocation) {\n            super(name, location, name.length, unitIndex);\n\n            this.name = name;\n            this.location = location;\n        }\n        public kind() { return SymbolKind.Parameter; }\n        public writeable() { return true; }\n        public getType() { return this.parameter.typeLink.type; }\n        public setType(type: Type) {\n            this.parameter.typeLink.type = type;\n        }\n        public isVariable() { return true; }\n        public argsOffset = (-1);\n        public isOptional() {\n            if (this.parameter && this.parameter.symbol && this.parameter.symbol.declAST) {\n                return (<ArgDecl>this.parameter.symbol.declAST).isOptional;\n            }\n            else {\n                return false;\n            }\n        }\n\n        public getTypeNameEx(scope: SymbolScope) {\n            return MemberName.create(this.getType().getScopedTypeNameEx(scope), this.name + (this.isOptional() ? "?" : "") + ": ", "");\n        }\n\n        public toString() { return this.getTypeNameEx(null).toString(); }\n\n        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Symbol {\n            var rType = this.parameter.typeLink.type.specializeType(pattern, replacement, checker, false);\n            if (this.parameter.typeLink.type != rType) {\n                var paramDef = new ValueLocation();\n                var result = new ParameterSymbol(this.name, 0, checker.locationInfo.unitIndex,\n                                               paramDef);\n                paramDef.symbol = result;\n                result.setType(rType);\n                return result;\n            }\n            else {\n                return this;\n            }\n        }\n\n        public getParameterDocComments() {\n            if (!this.paramDocComment) {\n                var parameterComments: string[] = [];\n                if (this.funcDecl) {\n                    var fncDocComments = this.funcDecl.getDocComments();\n                    var paramComment = Comment.getParameterDocCommentText(this.name, fncDocComments);\n                    if (paramComment != "") {\n                        parameterComments.push(paramComment);\n                    }\n                }\n                var docComments = TypeScript.Comment.getDocCommentText(this.getDocComments());\n                if (docComments != "") {\n                    parameterComments.push(docComments);\n                }\n                \n                this.paramDocComment = parameterComments.join("\\n");\n            }\n\n            return this.paramDocComment;\n        }\n    }\n\n    export class VariableSymbol extends InferenceSymbol {\n\n        constructor (name: string, location: number, unitIndex: number, public variable: ValueLocation) {\n            super(name, location, name.length, unitIndex);\n        }\n        public kind() { return SymbolKind.Variable; }\n        public writeable() { return true; }\n        public getType() { return this.variable.typeLink.type; }\n        public getTypeNameEx(scope: SymbolScope) {\n            return MemberName.create(this.getType().getScopedTypeNameEx(scope), this.name + ": ", "");\n        }\n\n        public setType(type: Type) {\n            this.variable.typeLink.type = type;\n        }\n        public isVariable() { return true; }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export enum TokenID {\n        // Keywords\n        Any,\n        Bool,\n        Break,\n        Case,\n        Catch,\n        Class,\n        Const,\n        Continue,\n        Debugger,\n        Default,\n        Delete,\n        Do,\n        Else,\n        Enum,\n        Export,\n        Extends,\n        Declare,\n        False,\n        Finally,\n        For,\n        Function,\n        Constructor,\n        Get,\n        If,\n        Implements,\n        Import,\n        In,\n        InstanceOf,\n        Interface,\n        Let,\n        Module,\n        New,\n        Number,\n        Null,\n        Package,\n        Private,\n        Protected,\n        Public,\n        Return,\n        Set,\n        Static,\n        String,\n        Super,\n        Switch,\n        This,\n        Throw,\n        True,\n        Try,\n        TypeOf,\n        Var,\n        Void,\n        With,\n        While,\n        Yield,\n      ';
var v27530 = v27531 + '  // Punctuation\n        Semicolon,\n        OpenParen,\n        CloseParen,\n        OpenBracket,\n        CloseBracket,\n        OpenBrace,\n        CloseBrace,\n        Comma,\n        Equals,\n        PlusEquals,\n        MinusEquals,\n        AsteriskEquals,\n        SlashEquals,\n        PercentEquals,\n        AmpersandEquals,\n        CaretEquals,\n        BarEquals,\n        LessThanLessThanEquals,\n        GreaterThanGreaterThanEquals,\n        GreaterThanGreaterThanGreaterThanEquals,\n        Question,\n        Colon,\n        BarBar,\n        AmpersandAmpersand,\n        Bar,\n        Caret,\n        And,\n        EqualsEquals,\n        ExclamationEquals,\n        EqualsEqualsEquals,\n        ExclamationEqualsEquals,\n        LessThan,\n        LessThanEquals,\n        GreaterThan,\n        GreaterThanEquals,\n        LessThanLessThan,\n        GreaterThanGreaterThan,\n        GreaterThanGreaterThanGreaterThan,\n        Plus,\n        Minus,\n        Asterisk,\n        Slash,\n        Percent,\n        Tilde,\n        Exclamation,\n        PlusPlus,\n        MinusMinus,\n        Dot,\n        DotDotDot,\n        Error,\n        EndOfFile,\n        EqualsGreaterThan,\n        Identifier,\n        StringLiteral,\n        RegularExpressionLiteral,\n        NumberLiteral,\n        Whitespace,\n        Comment,\n        Lim,\n        LimFixed = EqualsGreaterThan,\n        LimKeyword = Yield,\n    }\n\n    export var tokenTable = new TokenInfo[];\n    export var nodeTypeTable = new string[];\n    export var nodeTypeToTokTable = new number[];\n    export var noRegexTable = new bool[];\n\n    noRegexTable[TokenID.Identifier] = true;\n    noRegexTable[TokenID.StringLiteral] = true;\n    noRegexTable[TokenID.NumberLiteral] = true;\n    noRegexTable[TokenID.RegularExpressionLiteral] = true;\n    noRegexTable[TokenID.This] = true;\n    noRegexTable[TokenID.PlusPlus] = true;\n    noRegexTable[TokenID.MinusMinus] = true;\n    noRegexTable[TokenID.CloseParen] = true;\n    noRegexTable[TokenID.CloseBracket] = true;\n    noRegexTable[TokenID.CloseBrace] = true;\n    noRegexTable[TokenID.True] = true;\n    noRegexTable[TokenID.False] = true;\n\n    export enum OperatorPrecedence {\n        None,\n        Comma,\n        Assignment,\n        Conditional,\n        LogicalOr,\n        LogicalAnd,\n        BitwiseOr,\n        BitwiseExclusiveOr,\n        BitwiseAnd,\n        Equality,\n        Relational,\n        Shift,\n        Additive,\n        Multiplicative,\n        Unary,\n        Lim\n    }\n\n    export enum Reservation {\n        None = 0,\n        Javascript = 1,\n        JavascriptFuture = 2,\n        TypeScript = 4,\n        JavascriptFutureStrict = 8,\n        TypeScriptAndJS = Javascript | TypeScript,\n        TypeScriptAndJSFuture = JavascriptFuture | TypeScript,\n        TypeScriptAndJSFutureStrict = JavascriptFutureStrict | TypeScript,\n    }\n\n    export class TokenInfo {\n        constructor (public tokenId: TokenID, public reservation: Reservation,\n                    public binopPrecedence: number, public binopNodeType: number,\n                    public unopPrecedence: number, public unopNodeType: number,\n                    public text: string, public ers: ErrorRecoverySet) { }\n    }\n\n    function setTokenInfo(tokenId: TokenID, reservation: number, binopPrecedence: number,\n        binopNodeType: number, unopPrecedence: number, unopNodeType: number,\n        text: string, ers: ErrorRecoverySet) {\n        if (tokenId !== undefined) {\n            tokenTable[tokenId] = new TokenInfo(tokenId, reservation, binopPrecedence,\n                                              binopNodeType, unopPrecedence, unopNodeType, text, ers);\n            if (binopNodeType != NodeType.None) {\n                nodeTypeTable[binopNodeType] = text;\n                nodeTypeToTokTable[binopNodeType] = tokenId;\n            }\n            if (unopNodeType != NodeType.None) {\n                nodeTypeTable[unopNodeType] = text;\n            }\n        }\n    }\n\n    setTokenInfo(TokenID.Any, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "any", ErrorRecoverySet.PrimType);\n    setTokenInfo(TokenID.Bool, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "bool", ErrorRecoverySet.PrimType);\n    setTokenInfo(TokenID.Break, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "break", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.Case, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "case", ErrorRecoverySet.SCase);\n    setTokenInfo(TokenID.Catch, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "catch", ErrorRecoverySet.Catch);\n    setTokenInfo(TokenID.Class, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "class", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.Const, Reservation.TypeScri';
var v27529 = v27530 + 'ptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "const", ErrorRecoverySet.Var);\n    setTokenInfo(TokenID.Continue, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "continue", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.Debugger, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.Debugger, "debugger", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.Default, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "default", ErrorRecoverySet.SCase);\n    setTokenInfo(TokenID.Delete, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.Delete, "delete", ErrorRecoverySet.Prefix);\n    setTokenInfo(TokenID.Do, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "do", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.Else, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "else", ErrorRecoverySet.Else);\n    setTokenInfo(TokenID.Enum, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "enum", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.Export, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "export", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.Extends, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "extends", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.Declare, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "declare", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.False, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "false", ErrorRecoverySet.RLit);\n    setTokenInfo(TokenID.Finally, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "finally", ErrorRecoverySet.Catch);\n    setTokenInfo(TokenID.For, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "for", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.Function, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "function", ErrorRecoverySet.Func);\n    setTokenInfo(TokenID.Constructor, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "constructor", ErrorRecoverySet.Func);\n    setTokenInfo(TokenID.Get, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "get", ErrorRecoverySet.Func);\n    setTokenInfo(TokenID.Set, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "set", ErrorRecoverySet.Func);\n    setTokenInfo(TokenID.If, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "if", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.Implements, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "implements", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.Import, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "import", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.In, Reservation.TypeScriptAndJS, OperatorPrecedence.Relational, NodeType.In, OperatorPrecedence.None, NodeType.None, "in", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.InstanceOf, Reservation.TypeScriptAndJS, OperatorPrecedence.Relational, NodeType.InstOf, OperatorPrecedence.None, NodeType.None, "instanceof", ErrorRecoverySet.BinOp);\n    setTokenInfo(TokenID.Interface, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "interface", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.Let, Reservation.JavascriptFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "let", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.Module, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "module", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.New, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "new", ErrorRecoverySet.PreOp);\n    setTokenInfo(TokenID.Number, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "number", ErrorRecoverySet.PrimType);\n    setTokenInfo(TokenID.Nu';
var v27528 = v27529 + 'll, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "null", ErrorRecoverySet.RLit);\n    setTokenInfo(TokenID.Package, Reservation.JavascriptFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "package", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.Private, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "private", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.Protected, Reservation.JavascriptFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "protected", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.Public, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "public", ErrorRecoverySet.TypeScriptS);\n    setTokenInfo(TokenID.Return, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "return", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.Static, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "static", ErrorRecoverySet.None);\n    setTokenInfo(TokenID.String, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "string", ErrorRecoverySet.PrimType);\n    setTokenInfo(TokenID.Super, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "super", ErrorRecoverySet.RLit);\n    setTokenInfo(TokenID.Switch, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "switch", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.This, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "this", ErrorRecoverySet.RLit);\n    setTokenInfo(TokenID.Throw, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "throw", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.True, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "true", ErrorRecoverySet.RLit);\n    setTokenInfo(TokenID.Try, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "try", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.TypeOf, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.Typeof, "typeof", ErrorRecoverySet.Prefix);\n    setTokenInfo(TokenID.Var, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "var", ErrorRecoverySet.Var);\n    setTokenInfo(TokenID.Void, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.Void, "void", ErrorRecoverySet.Prefix);\n    setTokenInfo(TokenID.With, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.With, "with", ErrorRecoverySet.Stmt);\n    setTokenInfo(TokenID.While, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "while", ErrorRecoverySet.While);\n    setTokenInfo(TokenID.Yield, Reservation.JavascriptFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "yield", ErrorRecoverySet.None);\n\n    setTokenInfo(TokenID.Identifier, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "identifier", ErrorRecoverySet.ID);\n    setTokenInfo(TokenID.NumberLiteral, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "numberLiteral", ErrorRecoverySet.Literal);\n    setTokenInfo(TokenID.RegularExpressionLiteral, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "regex", ErrorRecoverySet.RegExp);\n    setTokenInfo(TokenID.StringLiteral, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "qstring", ErrorRecoverySet.Literal);\n\n    // Non-operator non-identifier tokens\n    setTokenInfo(TokenID.Semicolon, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, ";", ErrorRecoverySet.SColon); // ;\n    setTokenInfo(TokenID.CloseParen, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, ")", ErrorRecoverySet.RParen); // )\n    setTokenInfo(TokenID.CloseBracket, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "]", ErrorRecoverySet.RBrack); // ]\n    setTokenInfo(TokenID.OpenBrace, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "{", ErrorRecoverySet.LCurly); // {\n    setToken';
var v27527 = v27528 + 'Info(TokenID.CloseBrace, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "}", ErrorRecoverySet.RCurly); // }\n    setTokenInfo(TokenID.DotDotDot, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "...", ErrorRecoverySet.None); // ...\n\n    // Operator non-identifier tokens\n    setTokenInfo(TokenID.Comma, Reservation.None, OperatorPrecedence.Comma, NodeType.Comma, OperatorPrecedence.None, NodeType.None, ",", ErrorRecoverySet.Comma); // ,\n    setTokenInfo(TokenID.Equals, Reservation.None, OperatorPrecedence.Assignment, NodeType.Asg, OperatorPrecedence.None, NodeType.None, "=", ErrorRecoverySet.Asg); // =\n    setTokenInfo(TokenID.PlusEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgAdd, OperatorPrecedence.None, NodeType.None, "+=", ErrorRecoverySet.BinOp); // +=\n    setTokenInfo(TokenID.MinusEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgSub, OperatorPrecedence.None, NodeType.None, "-=", ErrorRecoverySet.BinOp); // -=\n    setTokenInfo(TokenID.AsteriskEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgMul, OperatorPrecedence.None, NodeType.None, "*=", ErrorRecoverySet.BinOp); // *=\n\n    setTokenInfo(TokenID.SlashEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgDiv, OperatorPrecedence.None, NodeType.None, "/=", ErrorRecoverySet.BinOp); // /=\n    setTokenInfo(TokenID.PercentEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgMod, OperatorPrecedence.None, NodeType.None, "%=", ErrorRecoverySet.BinOp); // %=\n    setTokenInfo(TokenID.AmpersandEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgAnd, OperatorPrecedence.None, NodeType.None, "&=", ErrorRecoverySet.BinOp); // &=\n    setTokenInfo(TokenID.CaretEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgXor, OperatorPrecedence.None, NodeType.None, "^=", ErrorRecoverySet.BinOp); // ^=\n    setTokenInfo(TokenID.BarEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgOr, OperatorPrecedence.None, NodeType.None, "|=", ErrorRecoverySet.BinOp); // |=\n    setTokenInfo(TokenID.LessThanLessThanEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgLsh, OperatorPrecedence.None, NodeType.None, "<<=", ErrorRecoverySet.BinOp); // <<=\n    setTokenInfo(TokenID.GreaterThanGreaterThanEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgRsh, OperatorPrecedence.None, NodeType.None, ">>=", ErrorRecoverySet.BinOp); // >>=\n    setTokenInfo(TokenID.GreaterThanGreaterThanGreaterThanEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgRs2, OperatorPrecedence.None, NodeType.None, ">>>=", ErrorRecoverySet.BinOp); // >>>=\n    setTokenInfo(TokenID.Question, Reservation.None, OperatorPrecedence.Conditional, NodeType.ConditionalExpression, OperatorPrecedence.None, NodeType.None, "?", ErrorRecoverySet.BinOp); // ?\n    setTokenInfo(TokenID.Colon, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, ":", ErrorRecoverySet.Colon); // :\n    setTokenInfo(TokenID.BarBar, Reservation.None, OperatorPrecedence.LogicalOr, NodeType.LogOr, OperatorPrecedence.None, NodeType.None, "||", ErrorRecoverySet.BinOp); // ||\n    setTokenInfo(TokenID.AmpersandAmpersand, Reservation.None, OperatorPrecedence.LogicalAnd, NodeType.LogAnd, OperatorPrecedence.None, NodeType.None, "&&", ErrorRecoverySet.BinOp); // &&\n    setTokenInfo(TokenID.Bar, Reservation.None, OperatorPrecedence.BitwiseOr, NodeType.Or, OperatorPrecedence.None, NodeType.None, "|", ErrorRecoverySet.BinOp); // |\n    setTokenInfo(TokenID.Caret, Reservation.None, OperatorPrecedence.BitwiseExclusiveOr, NodeType.Xor, OperatorPrecedence.None, NodeType.None, "^", ErrorRecoverySet.BinOp); // ^\n    setTokenInfo(TokenID.And, Reservation.None, OperatorPrecedence.BitwiseAnd, NodeType.And, OperatorPrecedence.None, NodeType.None, "&", ErrorRecoverySet.BinOp); // &\n    setTokenInfo(TokenID.EqualsEquals, Reservation.None, OperatorPrecedence.Equality, NodeType.Eq, OperatorPrecedence.None, NodeType.None, "==", ErrorRecoverySet.BinOp); // ==\n    setTokenInfo(TokenID.ExclamationEquals, Reservation.None, OperatorPrecedence.Equality, NodeType.Ne, OperatorPrecedence.None, NodeType.None, "!=", ErrorRecoverySet.BinOp); // !=\n    setTokenInfo(TokenID.EqualsEqualsEquals, Reservation.None, OperatorPrecedence.Equality, NodeType.Eqv, OperatorPrecedence.None, NodeType.None, "===", ErrorRecoverySet.BinOp); // ===\n    setTokenInfo(TokenID.ExclamationEqualsEquals, Reservation.None, OperatorPrecedence.Equality, NodeType.NEqv, OperatorPrecedence.None, NodeType.None, "!==", ErrorRecoverySet.BinOp); // !==\n    setTokenInfo(TokenID.LessThan, Reservation.None, OperatorPrecedence.Relational, NodeType.Lt, OperatorPrecedence.None, NodeType.None, "<", ErrorRecoverySet.BinOp); // <\n    setTokenInfo(TokenID.LessThanEquals, Reservation.None, OperatorPrecedence.Relational, NodeTyp';
var v27526 = v27527 + 'e.Le, OperatorPrecedence.None, NodeType.None, "<=", ErrorRecoverySet.BinOp); // <=\n    setTokenInfo(TokenID.GreaterThan, Reservation.None, OperatorPrecedence.Relational, NodeType.Gt, OperatorPrecedence.None, NodeType.None, ">", ErrorRecoverySet.BinOp); // >\n    setTokenInfo(TokenID.GreaterThanEquals, Reservation.None, OperatorPrecedence.Relational, NodeType.Ge, OperatorPrecedence.None, NodeType.None, ">=", ErrorRecoverySet.BinOp); // >=\n    setTokenInfo(TokenID.LessThanLessThan, Reservation.None, OperatorPrecedence.Shift, NodeType.Lsh, OperatorPrecedence.None, NodeType.None, "<<", ErrorRecoverySet.BinOp); // <<\n    setTokenInfo(TokenID.GreaterThanGreaterThan, Reservation.None, OperatorPrecedence.Shift, NodeType.Rsh, OperatorPrecedence.None, NodeType.None, ">>", ErrorRecoverySet.BinOp); // >>\n    setTokenInfo(TokenID.GreaterThanGreaterThanGreaterThan, Reservation.None, OperatorPrecedence.Shift, NodeType.Rs2, OperatorPrecedence.None, NodeType.None, ">>>", ErrorRecoverySet.BinOp); // >>>\n    setTokenInfo(TokenID.Plus, Reservation.None, OperatorPrecedence.Additive, NodeType.Add, OperatorPrecedence.Unary, NodeType.Pos, "+", ErrorRecoverySet.AddOp); // +\n    setTokenInfo(TokenID.Minus, Reservation.None, OperatorPrecedence.Additive, NodeType.Sub, OperatorPrecedence.Unary, NodeType.Neg, "-", ErrorRecoverySet.AddOp); // -\n    setTokenInfo(TokenID.Asterisk, Reservation.None, OperatorPrecedence.Multiplicative, NodeType.Mul, OperatorPrecedence.None, NodeType.None, "*", ErrorRecoverySet.BinOp); // *\n    setTokenInfo(TokenID.Slash, Reservation.None, OperatorPrecedence.Multiplicative, NodeType.Div, OperatorPrecedence.None, NodeType.None, "/", ErrorRecoverySet.BinOp); // /\n    setTokenInfo(TokenID.Percent, Reservation.None, OperatorPrecedence.Multiplicative, NodeType.Mod, OperatorPrecedence.None, NodeType.None, "%", ErrorRecoverySet.BinOp); // %\n    setTokenInfo(TokenID.Tilde, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.Not, "~", ErrorRecoverySet.PreOp); // ~\n    setTokenInfo(TokenID.Exclamation, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.LogNot, "!", ErrorRecoverySet.PreOp); // !\n    setTokenInfo(TokenID.PlusPlus, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.IncPre, "++", ErrorRecoverySet.PreOp); // ++\n    setTokenInfo(TokenID.MinusMinus, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.DecPre, "--", ErrorRecoverySet.PreOp); // --\n    setTokenInfo(TokenID.OpenParen, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "(", ErrorRecoverySet.LParen); // (\n    setTokenInfo(TokenID.OpenBracket, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "[", ErrorRecoverySet.LBrack); // [\n    setTokenInfo(TokenID.Dot, Reservation.None, OperatorPrecedence.Unary, NodeType.None, OperatorPrecedence.None, NodeType.None, ".", ErrorRecoverySet.Dot); // .\n    setTokenInfo(TokenID.EndOfFile, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "<EOF>", ErrorRecoverySet.EOF); // EOF\n    setTokenInfo(TokenID.EqualsGreaterThan, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "=>", ErrorRecoverySet.None); // =>\n\n    export function lookupToken(tokenId: TokenID): TokenInfo {\n        return tokenTable[tokenId];\n    }\n\n    export enum TokenClass {\n        Punctuation,\n        Keyword,\n        Operator,\n        Comment,\n        Whitespace,\n        Identifier,\n        NumberLiteral,\n        StringLiteral,\n        RegExpLiteral,\n    }\n\n    export class SavedToken {\n        constructor (public tok: Token, public minChar: number, public limChar: number) { }\n    }\n\n    export class Token {\n        constructor (public tokenId: TokenID) {\n        }\n\n        public toString() {\n            return "token: " + this.tokenId + " " + this.getText() + " (" + (<any>TokenID)._map[this.tokenId] + ")";\n        }\n\n        public print(line: number, outfile) {\n            outfile.WriteLine(this.toString() + ",on line" + line);\n        }\n\n        public getText(): string {\n            return tokenTable[this.tokenId].text;\n        }\n\n        public classification(): TokenClass {\n            if (this.tokenId <= TokenID.LimKeyword) {\n                return TokenClass.Keyword;\n            }\n            else {\n                var tokenInfo = lookupToken(this.tokenId);\n                if (tokenInfo != undefined) {\n                    if ((tokenInfo.unopNodeType != NodeType.None) ||\n                        (tokenInfo.binopNodeType != NodeType.None)) {\n                        return TokenClass.Operator;\n                    }\n                }\n            }\n\n            return TokenClass.Punctuation;\n        }\n    }\n\n    export class NumberLiteralToken extends Token {\n        constructor (public value: number,';
var v27525 = v27526 + ' public hasEmptyFraction?: bool) {\n            super(TokenID.NumberLiteral);\n        }\n\n        public getText(): string {\n            return this.hasEmptyFraction ? this.value.toString() + ".0" : this.value.toString();\n        }\n\n        public classification(): TokenClass {\n            return TokenClass.NumberLiteral;\n        }\n    }\n\n    export class StringLiteralToken extends Token {\n        constructor (public value: string) {\n            super(TokenID.StringLiteral);\n        }\n\n        public getText(): string {\n            return this.value;\n        }\n\n        public classification(): TokenClass {\n            return TokenClass.StringLiteral;\n        }\n    }\n\n    export class IdentifierToken extends Token {\n        constructor (public value: string, public hasEscapeSequence : bool) {\n            super(TokenID.Identifier);\n        }\n        public getText(): string {\n            return this.value;\n        }\n        public classification(): TokenClass {\n            return TokenClass.Identifier;\n        }\n    }\n\n    export class WhitespaceToken extends Token {\n        constructor (tokenId: TokenID, public value: string) {\n            super(tokenId);\n        }\n\n        public getText(): string {\n            return this.value;\n        }\n\n        public classification(): TokenClass {\n            return TokenClass.Whitespace;\n        }\n    }\n\n    export class CommentToken extends Token {\n        constructor (tokenID: TokenID, public value: string, public isBlock: bool, public startPos: number, public line: number, public endsLine: bool) {\n            super(tokenID);\n        }\n\n        public getText(): string {\n            return this.value;\n        }\n\n        public classification(): TokenClass {\n            return TokenClass.Comment;\n        }\n    }\n\n    export class RegularExpressionLiteralToken extends Token {\n        constructor(public regex) {\n            super(TokenID.RegularExpressionLiteral);\n        }\n\n        public getText(): string {\n            return this.regex.toString();\n        }\n\n        public classification(): TokenClass {\n            return TokenClass.RegExpLiteral;\n        }\n    }\n\n    // TODO: new with length TokenID.LimFixed\n    export var staticTokens = new Token[];\n    export function initializeStaticTokens() {\n        for (var i = 0; i <= TokenID.LimFixed; i++) {\n            staticTokens[i] = new Token(i);\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\'/>\n///<reference path=\'io.ts\'/>\n///<reference path=\'optionsParser.ts\'/>\n\nclass CommandLineHost implements TypeScript.IResolverHost {\n\n    public pathMap: any = {};\n    public resolvedPaths: any = {};\n\n    constructor(public compilationSettings: TypeScript.CompilationSettings) { \n    }\n\n    public getPathIdentifier(path: string) { \n        return this.compilationSettings.useCaseSensitiveFileResolution ? path : path.toLocaleUpperCase();\n    }\n\n    public isResolved(path: string) {\n        return this.resolvedPaths[this.getPathIdentifier(this.pathMap[path])] != undefined;\n    }\n\n    public resolveCompilationEnvironment(preEnv: TypeScript.CompilationEnvironment,\n        resolver: TypeScript.ICodeResolver,\n        traceDependencies: bool): TypeScript.CompilationEnvironment {\n        var resolvedEnv = new TypeScript.CompilationEnvironment(preEnv.compilationSettings, preEnv.ioHost);\n\n        var nCode = preEnv.code.length;\n        var path = "";\n\n        var postResolutionError = \n            (errorFile: string, errorMessage: string) => {\n                TypeScript.CompilerDiagnostics.debugPrint("Could not resolve file \'" + errorFile + "\'" + (errorMessage == "" ? "" : ": " + errorMessage));\n            }\n\n        var resolutionDispatcher: TypeScript.IResolutionDispatcher = {\n            postResolutionError: postResolutionError,\n            postResolution: (path: string, code: TypeScript.ISourceText) => {\n                var pathId = this.getPathIdentifier(path);\n                if (!this.resolvedPaths[pathId]) {\n                    resolvedEnv.code.push(<TypeScript.SourceUnit>code);\n                    this.resolvedPaths[pathId] = true;\n                }\n            }\n        };\n\n        for (var i = 0; i < nCode; i++) {\n            path = TypeScript.switchToForwardSlashes(preEnv.ioHost.resolvePath(preEnv.code[i].path));\n            this.pathMap[preEnv.code[i].path] = path;\n            resolver.resolveCode(path, "", false, r';
var v27524 = v27525 + 'esolutionDispatcher);\n        }\n\n        return resolvedEnv;\n    }\n}\nclass BatchCompiler {\n    public compilationSettings: TypeScript.CompilationSettings;\n    public compilationEnvironment: TypeScript.CompilationEnvironment;\n    public resolvedEnvironment: TypeScript.CompilationEnvironment = null;\n    public hasResolveErrors: bool = false;\n    public compilerVersion = "0.8.2.0";\n    public printedVersion = false;\n\n    constructor (public ioHost: IIO) { \n        this.compilationSettings = new TypeScript.CompilationSettings();\n        this.compilationEnvironment = new TypeScript.CompilationEnvironment(this.compilationSettings, this.ioHost);\n    }\n\n    public resolve() {\n        var resolver = new TypeScript.CodeResolver(this.compilationEnvironment);\n        var commandLineHost = new CommandLineHost(this.compilationSettings);\n        var ret = commandLineHost.resolveCompilationEnvironment(this.compilationEnvironment, resolver, true);\n\n        // Reset resolve error status\n        this.hasResolveErrors = false;\n\n        for (var i = 0; i < this.compilationEnvironment.code.length; i++) {\n            if (!commandLineHost.isResolved(this.compilationEnvironment.code[i].path)) {\n                this.hasResolveErrors = true;\n                var path = this.compilationEnvironment.code[i].path;\n                if (!TypeScript.isSTRFile(path) && !TypeScript.isDSTRFile(path) && !TypeScript.isTSFile(path) && !TypeScript.isDTSFile(path)) {\n                    this.ioHost.stderr.WriteLine("Unknown extension for file: \\""+path+"\\". Only .ts and .d.ts extensions are allowed.");\n                }\n                else {\n                    this.ioHost.stderr.WriteLine("Error reading file \\"" + path + "\\": File not found");\n                }\n            }\n        }\n\n        return ret;\n    }\n    \n    /// Do the actual compilation reading from input files and\n    /// writing to output file(s).\n    public compile(): bool {\n        var compiler: TypeScript.TypeScriptCompiler;\n\n        compiler = new TypeScript.TypeScriptCompiler(this.ioHost.stderr, new TypeScript.NullLogger(), this.compilationSettings);\n        compiler.setErrorOutput(this.ioHost.stderr);\n        compiler.setErrorCallback(\n            (minChar, charLen, message, unitIndex) => {\n                compiler.errorReporter.hasErrors = true;\n                var fname = this.resolvedEnvironment.code[unitIndex].path;\n                var lineCol = { line: -1, col: -1 };\n                compiler.parser.getSourceLineCol(lineCol, minChar);\n                // line is 1-base, col, however, is 0-base. add 1 to the col before printing the message\n                var msg = fname + " (" + lineCol.line + "," + (lineCol.col + 1) + "): " + message;\n                if (this.compilationSettings.errorRecovery) {\n                    this.ioHost.stderr.WriteLine(msg);\n                } else {\n                    throw new SyntaxError(msg);\n                }\n            });\n\n        if (this.compilationSettings.emitComments) {\n            compiler.emitCommentsToOutput();\n        }\n\n        var consumeUnit = (code: TypeScript.SourceUnit, addAsResident: bool) => {\n            try {\n                // if file resolving is disabled, the file\'s content will not yet be loaded\n\n                if (!this.compilationSettings.resolve) {\n                    code.content = this.ioHost.readFile(code.path);\n                    // If declaration files are going to be emitted, \n                    // preprocess the file contents and add in referenced files as well\n                    if (this.compilationSettings.generateDeclarationFiles) {\n                        TypeScript.CompilerDiagnostics.assert(code.referencedFiles == null, "With no resolve option, referenced files need to null");\n                        code.referencedFiles = TypeScript.getReferencedFiles(code);\n                    }\n                }\n\n                if (code.content != null) {\n                    if (this.compilationSettings.parseOnly) {\n                        compiler.parseUnit(code.content, code.path);\n                    }\n                    else {\n                        if (this.compilationSettings.errorRecovery) {\n                            compiler.parser.setErrorRecovery(this.ioHost.stderr);\n                        }\n                        compiler.addUnit(code.content, code.path, addAsResident, code.referencedFiles);\n                    }\n                }\n            }\n            catch (err) {\n                compiler.errorReporter.hasErrors = true;\n                // This includes syntax errors thrown from error callback if not in recovery mode\n                this.ioHost.stderr.WriteLine(err.message);\n            }\n\n        }\n\n        for (var iCode = 0 ; iCode < this.resolvedEnvironment.code.length; iCode++) {\n            if (!this.compilationSettings.parseOnly || (iCode > 0)) {\n                consumeUnit(this.resolvedEnvironment.code[iCode], false);\n            }\n        }\n\n        var emitterIOHost = {\n          ';
var v27523 = v27524 + "  createFile: (fileName: string, useUTF8?: bool) => IOUtils.createFileAndFolderStructure(this.ioHost, fileName, useUTF8),\n            directoryExists: this.ioHost.directoryExists,\n            fileExists: this.ioHost.fileExists,\n            resolvePath: this.ioHost.resolvePath\n        };\n\n        try {\n            if (!this.compilationSettings.parseOnly) {\n                compiler.typeCheck();\n                compiler.emit(emitterIOHost);\n                compiler.emitDeclarations();\n            }\n            else {\n                compiler.emitAST(emitterIOHost);\n            }\n        } catch (err) {\n            compiler.errorReporter.hasErrors = true;\n            // Catch emitter exceptions\n            if (err.message != \"EmitError\") {\n                throw err;\n            }\n        }\n\n        return compiler.errorReporter.hasErrors;\n    }\n\n    // Execute the provided inputs\n    public run() {\n        for (var i = 0; i < this.compilationEnvironment.code.length; i++) {\n            var unit = this.compilationEnvironment.code[i];\n            \n            var outputFileName: string = unit.path;\n            if (TypeScript.isTSFile(outputFileName)) {\n                outputFileName = outputFileName.replace(/\\.ts$/, \".js\");\n            } else if (TypeScript.isSTRFile(outputFileName)) {\n                outputFileName = outputFileName.replace(/\\.str$/, \".js\");\n            }\n            if (this.ioHost.fileExists(outputFileName)) {\n                var unitRes = this.ioHost.readFile(outputFileName)\n                this.ioHost.run(unitRes, outputFileName);\n            }\n        }\n    }\n\n    /// Begin batch compilation\n    public batchCompile() {\n        TypeScript.CompilerDiagnostics.diagnosticWriter = { Alert: (s: string) => { this.ioHost.printLine(s); } }\n\n        var code: TypeScript.SourceUnit;\n\n        var opts = new OptionsParser(this.ioHost);\n\n        opts.option('out', {\n            usage: 'Concatenate and emit output to single file | Redirect output structure to the directory',\n            type: 'file|directory',\n            set: (str) => {\n                this.compilationSettings.outputOption = str;\n            }\n        });\n\n        opts.option('style', {\n            usage: 'Select style checking options (examples --style requireSemi:off or --style \"eqeqeq;bitwise:off\")',\n            experimental: true,\n            set: (str) => {\n                this.compilationSettings.setStyleOptions(str);\n            }\n        });\n\n        opts.flag('sourcemap', {\n            usage: 'Generates corresponding .map file',\n            set: () => {\n                this.compilationSettings.mapSourceFiles = true;\n            }\n        });\n\n        opts.flag('declaration', {\n            usage: 'Generates corresponding .d.ts file',\n            set: () => {\n                this.compilationSettings.generateDeclarationFiles = true;\n            }\n        });\n\n        if (this.ioHost.watchFile) {\n            opts.flag('watch', {\n                usage: 'Watch output files',\n                set: () => {\n                    this.compilationSettings.watch = true;\n                }\n            }, 'w');\n        }\n\n        opts.flag('exec', {\n            usage: 'Execute the script after compilation',\n            set: () => {\n                this.compilationSettings.exec = true;\n            }\n        }, 'e');\n\n        opts.flag('parse', {\n            usage: 'Parse only',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.parseOnly = true;\n            }\n        });\n\n        opts.flag('minw', {\n            usage: 'Minimize whitespace',\n            experimental: true,\n            set: () => { this.compilationSettings.minWhitespace = true; }\n        }, 'mw');\n\n        opts.flag('const', {\n            usage: 'Propagate constants to emitted code',\n            experimental: true,\n            set: () => { this.compilationSettings.propagateConstants = true; }\n        });\n\n        opts.flag('errorrecovery', {\n            usage: 'Enable error recovery',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.errorRecovery = true;\n            }\n        }, 'er');\n\n        opts.flag('comments', {\n            usage: 'Emit comments to output',\n            set: () => {\n                this.compilationSettings.emitComments = true;\n            }\n        }, 'c');\n\n        opts.flag('cflow', {\n            usage: 'Control flow',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.controlFlow = true;\n            }\n        });\n\n        opts.flag('cflowp', {\n            usage: 'Print control flow',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.controlFlow = true;\n                this.compilationSettings.printControlFlow = true;\n            }\n        });\n\n        opts.flag('cflowu', {\n            usage: 'Print Use Def control flow',\n            experimental: true,\n            set: () ";
var v27522 = v27523 + "=> {\n                this.compilationSettings.controlFlow = true;\n                this.compilationSettings.controlFlowUseDef = true;\n            }\n        });\n\n        opts.flag('noerroronwith', {\n            usage: 'Allow with statements',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.errorOnWith = false;\n            }\n        });\n\n        opts.flag('noresolve', {\n            usage: 'Skip resolution and preprocessing',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.resolve = false;\n                this.compilationSettings.preprocess = false;\n            }\n        });\n\n        opts.flag('debug', {\n            usage: 'Print debug output',\n            experimental: true,\n            set: () => {\n                TypeScript.CompilerDiagnostics.debug = true;\n            }\n        });\n\n        opts.flag('canCallDefinitionSignature', {\n            usage: 'Allows you to call the definition signature of an overload group',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.canCallDefinitionSignature = true;\n            }\n        });\n\n        opts.flag('nooptimizemodules', {\n            usage: 'Do not optimize module codegen',\n            experimental: true,\n            set: () => {\n                TypeScript.optimizeModuleCodeGen = false;\n            }\n        });\n\n        opts.flag('nolib', {\n            usage: 'Do not include a default lib.d.ts with global declarations',\n            set: () => {\n                this.compilationSettings.useDefaultLib = false;\n            }\n        });\n\n\n        opts.flag('inferProperties', {\n            usage: 'Infer class properties from top-level assignments to \\'this\\'',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.inferPropertiesFromThisAssignment = true;\n            }\n        });\n\n        opts.option('target', {\n            usage: 'Specify ECMAScript target version: \"ES3\" (default), or \"ES5\"',\n            type: 'VER',\n            set: (type) => {\n                type = type.toLowerCase();\n\n                if (type === 'es3') {\n                    this.compilationSettings.codeGenTarget = TypeScript.CodeGenTarget.ES3;\n                } else if (type === 'es5') {\n                    this.compilationSettings.codeGenTarget = TypeScript.CodeGenTarget.ES5;\n                }\n                else {\n                    this.ioHost.printLine(\"ECMAScript target version '\" + type + \"' not supported.  Using default 'ES3' code generation\");\n                }\n            }\n        });\n\n        opts.option('module', {\n            usage: 'Specify module code generation: \"commonjs\" (default) or \"amd\"',\n            type: 'kind',\n            set: (type) => {\n                type = type.toLowerCase();\n\n                if (type === 'commonjs' || type === 'node') {\n                    TypeScript.moduleGenTarget = TypeScript.ModuleGenTarget.Synchronous;\n                } else if (type === 'amd') {\n                    TypeScript.moduleGenTarget = TypeScript.ModuleGenTarget.Asynchronous;\n                } else {\n                    this.ioHost.printLine(\"Module code generation '\" + type + \"' not supported.  Using default 'commonjs' code generation\");\n                }\n            }\n        });\n\n        var printedUsage = false;\n\n        opts.flag('help', {\n            usage: 'Print this message',\n            set: () => {\n                this.printVersion();\n                opts.printUsage();\n                printedUsage = true;\n            }\n        }, 'h');\n\n        opts.flag('useCaseSensitiveFileResolution', {\n            usage: 'Force file resolution to be case sensitive',\n            experimental: true,\n            set: () => {\n                this.compilationSettings.useCaseSensitiveFileResolution = true;\n            }\n        });\n\n        opts.flag('version', {\n            usage: 'Print the compiler\\'s version: ' + this.compilerVersion,\n            set: () => {\n                this.printVersion();\n            }\n        }, 'v');\n\n        opts.parse(this.ioHost.arguments);\n        \n        if (this.compilationSettings.useDefaultLib) {\n            var compilerFilePath = this.ioHost.getExecutingFilePath()\n            var binDirPath = this.ioHost.dirName(compilerFilePath);\n            var libStrPath = this.ioHost.resolvePath(binDirPath + \"/lib.d.ts\");\n            code = new TypeScript.SourceUnit(libStrPath, null);\n            this.compilationEnvironment.code.push(code);\n        }\n\n        for (var i = 0; i < opts.unnamed.length; i++) {\n            code = new TypeScript.SourceUnit(opts.unnamed[i], null);\n            this.compilationEnvironment.code.push(code);\n        }\n\n        // If no source files provided to compiler - print usage information\n        if (this.compilationEnvironment.code.length == (this.compilationSettings.useDefaultLib ? 1 : 0)) {\n            if (!printedUsage && !this.printedVersion";
var v27521 = v27522 + ') {\n                this.printVersion();\n                opts.printUsage();\n                this.ioHost.quit(1);\n            }\n            return;\n        }\n\n        var sourceFiles: TypeScript.SourceUnit[] = [];\n        if (this.compilationSettings.watch) {\n            // Capture the state before calling resolve\n            sourceFiles = this.compilationEnvironment.code.slice(0);\n        }\n\n        // Resolve file dependencies, if requested\n        this.resolvedEnvironment = this.compilationSettings.resolve ? this.resolve() : this.compilationEnvironment;\n\n        var hasCompileErrors = this.compile();\n\n        var hasErrors = hasCompileErrors || this.hasResolveErrors;\n        if (!hasErrors) {\n            if (this.compilationSettings.exec) {\n                this.run();\n            }\n        }\n\n        if (this.compilationSettings.watch) {\n            // Watch will cause the program to stick around as long as the files exist\n            this.watchFiles(sourceFiles);\n        }\n        else {  \n            // Exit with the appropriate error code\n            this.ioHost.quit(hasErrors ? 1 : 0);\n        }\n    }\n\n    public printVersion() {\n        if (!this.printedVersion) {\n            this.ioHost.printLine("Version " + this.compilerVersion);\n            this.printedVersion = true;\n        }\n    }\n\n    public watchFiles(soruceFiles: TypeScript.SourceUnit[]) {\n        if (!this.ioHost.watchFile) {\n            this.ioHost.printLine("Error: Current host does not support -w[atch] option");\n            return;\n        }\n\n        var resolvedFiles: string[] = []\n        var watchers: { [x: string]: IFileWatcher; } = {};\n\n        var addWatcher = (filename: string) => {\n            if (!watchers[filename]) {\n                var watcher = this.ioHost.watchFile(filename, onWatchedFileChange);\n                watchers[filename] = watcher;\n            }\n            else {\n                throw new Error("Cannot watch file, it is already watched.");\n            }\n        };\n\n        var removeWatcher = (filename: string) => {\n            if (watchers[filename]) {\n                watchers[filename].close();\n                delete watchers[filename];\n            }\n            else {\n                throw new Error("Cannot stop watching file, it is not being watched.");\n            }\n        };\n\n        var onWatchedFileChange = () => {\n            // Reset the state\n            this.compilationEnvironment.code = soruceFiles;\n\n            // Resolve file dependencies, if requested\n            this.resolvedEnvironment = this.compilationSettings.resolve ? this.resolve() : this.compilationEnvironment;\n\n            // Check if any new files were added to the environment as a result of the file change\n            var oldFiles = resolvedFiles;\n            var newFiles: string[] = [];\n            this.resolvedEnvironment.code.forEach((sf) => newFiles.push(sf.path));\n            newFiles = newFiles.sort();\n\n            var i = 0, j = 0;\n            while (i < oldFiles.length && j < newFiles.length) {\n\n                var compareResult = oldFiles[i].localeCompare(newFiles[j]);\n                if (compareResult == 0) {\n                    // No change here\n                    i++;\n                    j++;\n                }\n                else if (compareResult < 0) {\n                    // Entry in old list does not exist in the new one, it was removed\n                    removeWatcher(oldFiles[i]);\n                    i++;\n                }\n                else {\n                    // Entry in new list does exist in the new one, it was added\n                    addWatcher(newFiles[j]);\n                    j++;\n                }\n            }\n\n            // All remaining unmatched items in the old list have been removed\n            for (var k = i; k < oldFiles.length; k++) {\n                removeWatcher(oldFiles[k]);\n            }\n\n            // All remaing unmatched items in the new list have been added\n            for (var k = j; k < newFiles.length; k++) {\n                addWatcher(newFiles[k]);\n            }\n\n            // Update the state\n            resolvedFiles = newFiles;;\n\n            // Print header\n            this.ioHost.printLine("");\n            this.ioHost.printLine("Recompiling (" + new Date() + "): ");\n            resolvedFiles.forEach((f) => this.ioHost.printLine("    " + f));\n\n            // Trigger a new compilation\n            var hasCompileErrors = this.compile();\n\n            var hasErrors = hasCompileErrors || this.hasResolveErrors;\n            if (!hasErrors) {\n                if (this.compilationSettings.exec) {\n                    this.run();\n                }\n            }\n        };\n\n        // Switch to using stdout for all error messages\n        this.ioHost.stderr = this.ioHost.stdout;\n\n        // Initialize the initial list of resolved files, and add watches to them\n        this.resolvedEnvironment.code.forEach((sf) => {\n            resolvedFiles.push(sf.path);\n            addWatcher(sf.path);\n ';
var v27520 = v27521 + '       });\n        resolvedFiles.sort();\n    }\n}\n\n// Start the batch compilation using the current hosts IO\nvar batch = new BatchCompiler(IO);\nbatch.batchCompile();\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class ArrayCache {\n        public arrayType: Type;\n        public arrayBase: Type = null;\n\n        public specialize(arrInstType: Type, checker: TypeChecker): Type {\n            if (this.arrayBase == null) {\n                this.arrayBase = arrInstType.specializeType(checker.wildElm.type, this.arrayType.elementType,\n                                                   checker, true);\n            }\n            return this.arrayBase;\n        }\n    }\n\n    export class TypeComparisonInfo {\n        public onlyCaptureFirstError = false;\n        public flags: TypeRelationshipFlags = TypeRelationshipFlags.SuccessfulComparison;\n        public message = "";\n\n        public addMessageToFront(message) {\n            if (!this.onlyCaptureFirstError) {\n                this.message = this.message ? message + ":\\n\\t" + this.message : message;\n            }\n            else {\n                this.setMessage(message);\n            }\n        }\n\n        public setMessage(message) {\n            this.message = message;\n        }\n    }\n\n    export interface SignatureData {\n        parameters: ParameterSymbol[];\n        nonOptionalParameterCount: number;\n    }\n\n    export interface ApplicableSignature {\n        signature: Signature;\n        hadProvisionalErrors: bool;\n    }\n\n    export enum TypeCheckCollectionMode {\n        Resident,\n        Transient\n    }\n\n    export class PersistentGlobalTypeState {\n        public importedGlobalsTable = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n        public importedGlobalsTypeTable = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n\n        public importedGlobals: SymbolScopeBuilder;\n\n        // transient state\n        public globals: IHashTable = null;\n        public globalTypes: IHashTable = null;\n        public ambientGlobals: IHashTable = null;\n        public ambientGlobalTypes: IHashTable = null;\n\n        // resident state\n        public residentGlobalValues = new StringHashTable();\n        public residentGlobalTypes = new StringHashTable();\n        public residentGlobalAmbientValues = new StringHashTable();\n        public residentGlobalAmbientTypes = new StringHashTable();\n\n        // dual resident/transient state\n\n        // REVIEW: We shouldn\'t need to allocate private hash tables for these, since there\'s no private global scope\n        // REVIEW: In general, we should audit each instance of DualStringHashTable to ensure that both the primary\n        // and secondary tables are necessary.  If it\'s not necessary, we should sub in a constant sentinel value.\n        public dualGlobalValues: DualStringHashTable;\n        public dualGlobalTypes: DualStringHashTable;\n        public dualAmbientGlobalValues: DualStringHashTable;\n        public dualAmbientGlobalTypes: DualStringHashTable;\n\n        public globalScope: SymbolScope;\n\n        public voidType: Type;\n        public booleanType: Type;\n        public doubleType: Type;\n\n        public stringType: Type;\n        public anyType: Type;\n        public nullType: Type;\n        public undefinedType: Type;\n\n        // Use this flag to turn resident checking on and off\n        public residentTypeCheck: bool = true;\n\n        public mod: ModuleType = null;\n        public gloMod: TypeSymbol = null;\n\n        public wildElm: TypeSymbol = null;\n\n        constructor (public errorReporter: ErrorReporter) {\n            this.importedGlobals = new SymbolScopeBuilder(null, this.importedGlobalsTable, null, this.importedGlobalsTypeTable, null, null);\n\n            this.dualGlobalValues = new DualStringHashTable(this.residentGlobalValues, new StringHashTable());\n            this.dualGlobalTypes = new DualStringHashTable(this.residentGlobalTypes, new StringHashTable());\n            this.dualAmbientGlobalValues = new DualStringHashTable(this.residentGlobalAmbientValues, new StringHashTable());\n            this.dualAmbientGlobalTypes = new DualStringHashTable(this.residentGlobalAmbientTypes, new StringHashTable());\n\n            var dualGlobalScopedMembers = new ScopedMembers(new DualStringHashTable(this.dualGlobalValues, new StringHashTable';
var v27519 = v27520 + '()));\n            var dualGlobalScopedAmbientMembers = new ScopedMembers(new DualStringHashTable(this.dualAmbientGlobalValues, new StringHashTable()));\n            var dualGlobalScopedEnclosedTypes = new ScopedMembers(new DualStringHashTable(this.dualGlobalTypes, new StringHashTable()));\n            var dualGlobalScopedAmbientEnclosedTypes = new ScopedMembers(new DualStringHashTable(this.dualAmbientGlobalTypes, new StringHashTable()));\n\n            this.globalScope = new SymbolScopeBuilder(dualGlobalScopedMembers, dualGlobalScopedAmbientMembers, dualGlobalScopedEnclosedTypes, dualGlobalScopedAmbientEnclosedTypes, this.importedGlobals, null);\n\n            this.voidType = this.enterPrimitive(Primitive.Void, "void");\n            this.booleanType = this.enterPrimitive(Primitive.Boolean, "bool");\n            this.doubleType = this.enterPrimitive(Primitive.Double, "number");\n            this.importedGlobals.ambientEnclosedTypes.addPublicMember("number", this.doubleType.symbol);\n\n            this.stringType = this.enterPrimitive(Primitive.String, "string");\n            this.anyType = this.enterPrimitive(Primitive.Any, "any");\n            this.nullType = this.enterPrimitive(Primitive.Null, "null");\n            this.undefinedType = this.enterPrimitive(Primitive.Undefined, "undefined");\n\n            // shared global state is resident\n            this.setCollectionMode(TypeCheckCollectionMode.Resident);\n\n            this.wildElm = new TypeSymbol("_element", -1, 0, -1, new Type());\n            this.importedGlobalsTypeTable.addPublicMember(this.wildElm.name, this.wildElm);\n\n            this.mod = new ModuleType(dualGlobalScopedEnclosedTypes, dualGlobalScopedAmbientEnclosedTypes);\n            this.mod.members = dualGlobalScopedMembers;\n            this.mod.ambientMembers = dualGlobalScopedAmbientMembers;\n            this.mod.containedScope = this.globalScope;\n\n            this.gloMod = new TypeSymbol(globalId, -1, 0, -1, this.mod);\n            this.mod.members.addPublicMember(this.gloMod.name, this.gloMod);\n\n            this.defineGlobalValue("undefined", this.undefinedType);\n        }\n\n\n        public enterPrimitive(flags: number, name: string) {\n            var primitive = new Type();\n            primitive.primitiveTypeClass = flags;\n            var symbol = new TypeSymbol(name, -1, name.length, -1, primitive);\n            symbol.typeCheckStatus = TypeCheckStatus.Finished;\n            primitive.symbol = symbol;\n            this.importedGlobals.enter(null, null, symbol, this.errorReporter, true, true, true);\n            return primitive;\n        }\n\n        public setCollectionMode(mode: TypeCheckCollectionMode) {\n            this.residentTypeCheck =\n                this.dualGlobalValues.insertPrimary =\n                    this.dualGlobalTypes.insertPrimary =\n                        this.dualAmbientGlobalValues.insertPrimary =\n                            this.dualAmbientGlobalTypes.insertPrimary = mode == TypeCheckCollectionMode.Resident;\n        }\n\n        public refreshPersistentState() {\n            this.globals = new StringHashTable();\n            this.globalTypes = new StringHashTable();\n            this.ambientGlobals = new StringHashTable();\n            this.ambientGlobalTypes = new StringHashTable();\n\n            // add global types to the global scope\n            this.globalTypes.add(this.voidType.symbol.name, this.voidType.symbol);\n            this.globalTypes.add(this.booleanType.symbol.name, this.booleanType.symbol);\n            this.globalTypes.add(this.doubleType.symbol.name, this.doubleType.symbol);\n            this.globalTypes.add("number", this.doubleType.symbol);\n            this.globalTypes.add(this.stringType.symbol.name, this.stringType.symbol);\n            this.globalTypes.add(this.anyType.symbol.name, this.anyType.symbol);\n            this.globalTypes.add(this.nullType.symbol.name, this.nullType.symbol);\n            this.globalTypes.add(this.undefinedType.symbol.name, this.undefinedType.symbol);\n\n            this.dualGlobalValues.secondaryTable = this.globals;\n            this.dualGlobalTypes.secondaryTable = this.globalTypes;\n            this.dualAmbientGlobalValues.secondaryTable = this.ambientGlobals;\n            this.dualAmbientGlobalTypes.secondaryTable = this.ambientGlobalTypes;\n        }\n\n        public defineGlobalValue(name: string, type: Type) {\n            var valueLocation = new ValueLocation();\n            valueLocation.typeLink = new TypeLink();\n            var sym = new VariableSymbol(name, 0, -1, valueLocation);\n            sym.setType(type);\n            sym.typeCheckStatus = TypeCheckStatus.Finished;\n            sym.container = this.gloMod;\n            this.importedGlobalsTable.addPublicMember(name, sym);\n        }\n    }\n\n    export class ContextualTypeContext {\n        public targetSig: Signature = null;\n        public targetThis: Type = null;\n        public targetAccessorType: Type = null;\n\n        constructor (public contextualType: Type,\n            public provisional: bool, pu';
var v27518 = v27519 + 'blic contextID: number) { }\n    }\n\n    export class ContextualTypingContextStack {\n        private contextStack: ContextualTypeContext[] = [];\n        static contextID = TypeCheckStatus.Finished + 1;\n        public pushContextualType(type: Type, provisional: bool) { this.contextStack.push(new ContextualTypeContext(type, provisional, ContextualTypingContextStack.contextID++)); this.checker.errorReporter.pushToErrorSink = provisional; }\n        public hadProvisionalErrors = false; // somewhere in the chain a provisional typecheck error was thrown\n        public popContextualType() {\n            var tc = this.contextStack.pop();\n            this.checker.errorReporter.pushToErrorSink = this.isProvisional();\n            this.hadProvisionalErrors = this.hadProvisionalErrors || (tc.provisional && (this.checker.errorReporter.getCapturedErrors().length));\n            this.checker.errorReporter.freeCapturedErrors();\n            return tc;\n        }\n        public getContextualType(): ContextualTypeContext { return (!this.contextStack.length ? null : this.contextStack[this.contextStack.length - 1]); }\n        public getContextID() { return (!this.contextStack.length ? TypeCheckStatus.Finished : this.contextStack[this.contextStack.length - 1].contextID); }\n        public isProvisional() { return (!this.contextStack.length ? false : this.contextStack[this.contextStack.length - 1].provisional); }\n\n        constructor (public checker: TypeChecker) { }\n    }\n\n    export class TypeChecker {\n        public errorReporter: ErrorReporter = null;\n        public globalScope: SymbolScope;\n\n        public checkControlFlow = false;\n        public printControlFlowGraph = false;\n        public checkControlFlowUseDef = false;\n        public styleSettings: StyleSettings = null;\n\n        public units: LocationInfo[] = null;\n\n        public voidType: Type;\n        public booleanType: Type;\n        public numberType: Type;\n        public stringType: Type;\n        public anyType: Type;\n        public nullType: Type;\n        public undefinedType: Type;\n\n        public anon = "_anonymous";\n\n        public globals: DualStringHashTable;\n        public globalTypes: DualStringHashTable;\n        public ambientGlobals: DualStringHashTable;\n        public ambientGlobalTypes: DualStringHashTable;\n        public gloModType: ModuleType;\n        public gloMod: TypeSymbol;\n        public wildElm: TypeSymbol;\n\n        public locationInfo: LocationInfo = null;\n        public typeFlow: TypeFlow = null;\n\n        public currentCompareA: Symbol = null;\n        public currentCompareB: Symbol = null;\n\n        public currentModDecl: ModuleDeclaration = null;\n\n        public inBind = false;\n        public inWith = false;\n        public errorsOnWith = true;\n\n        public typingContextStack: ContextualTypingContextStack;\n        public currentContextualTypeContext: ContextualTypeContext = null;\n\n        public resolvingBases = false;\n\n        public canCallDefinitionSignature = false;\n\n        public assignableCache: any[] = <any>{};\n        public subtypeCache: any[] = <any>{};\n        public identicalCache: any[] = <any>{};\n\n        public provisionalStartedTypecheckObjects: PhasedTypecheckObject[] = [];\n\n        public mustCaptureGlobalThis = false;\n\n        constructor (public persistentState: PersistentGlobalTypeState) {\n            this.voidType = this.persistentState.voidType;\n            this.booleanType = this.persistentState.booleanType;\n            this.numberType = this.persistentState.doubleType;\n            this.stringType = this.persistentState.stringType;\n            this.anyType = this.persistentState.anyType;\n            this.nullType = this.persistentState.nullType;\n            this.undefinedType = this.persistentState.undefinedType;\n\n            this.globals = this.persistentState.dualGlobalValues;\n            this.globalTypes = this.persistentState.dualGlobalTypes;\n            this.ambientGlobals = this.persistentState.dualAmbientGlobalValues;\n            this.ambientGlobalTypes = this.persistentState.dualAmbientGlobalTypes;\n            this.gloModType = this.persistentState.mod;\n            this.gloMod = this.persistentState.gloMod;\n            this.wildElm = this.persistentState.wildElm;\n\n            this.globalScope = this.persistentState.globalScope;\n\n            this.typingContextStack = new ContextualTypingContextStack(this);\n        }\n\n        public setStyleOptions(style: StyleSettings) {\n            this.styleSettings = style;\n        }\n\n        // Contextual typing\n        public setContextualType(type: Type, provisional: bool) {\n            this.typingContextStack.pushContextualType(type, provisional);\n            this.currentContextualTypeContext = this.typingContextStack.getContextualType();\n        }\n\n        public unsetContextualType() {\n            var lastTC = this.typingContextStack.popContextualType();\n            this.currentContextualTypeContext = this.typingContextStack.getContextualType();\n            return lastTC;\n   ';
var v27517 = v27518 + '     }\n\n        public hadProvisionalErrors() {\n            return this.typingContextStack.hadProvisionalErrors;\n        }\n        public resetProvisionalErrors() {\n            if (!this.typingContextStack.getContextualType()) {\n                this.typingContextStack.hadProvisionalErrors = false;\n            }\n        }\n\n        public typeCheckWithContextualType(contextType: Type, provisional: bool, condition: bool, ast: AST) {\n            if (condition) {\n                this.setContextualType(contextType, this.typingContextStack.isProvisional() || provisional);\n            }\n            this.typeFlow.typeCheck(ast);\n            if (condition) {\n                this.unsetContextualType();\n            }\n        }\n\n        public resetTargetType() {\n            this.currentContextualTypeContext = this.typingContextStack.getContextualType();\n        }\n\n        // Unset the current contextual type without disturbing the stack, effectively "killing" the contextual typing process\n        public killCurrentContextualType() { this.currentContextualTypeContext = null; this.errorReporter.pushToErrorSink = false; }\n        public hasTargetType() { return this.currentContextualTypeContext && this.currentContextualTypeContext.contextualType; }\n        public getTargetTypeContext() { return this.currentContextualTypeContext; }\n\n        public inProvisionalTypecheckMode() {\n            return this.typingContextStack.isProvisional();\n        }\n\n        public getTypeCheckFinishedStatus() {\n            if (this.inProvisionalTypecheckMode()) {\n                return this.typingContextStack.getContextID();\n            }\n            return TypeCheckStatus.Finished;\n        }\n\n        public typeStatusIsFinished(status: TypeCheckStatus) {\n\n            return status == TypeCheckStatus.Finished ||\n                   (this.inProvisionalTypecheckMode() && status == this.typingContextStack.getContextID());\n        }\n\n        public addStartedPTO(pto: PhasedTypecheckObject) {\n            if (this.inProvisionalTypecheckMode()) {\n                this.provisionalStartedTypecheckObjects[this.provisionalStartedTypecheckObjects.length] = pto;\n            }\n        }\n\n        public cleanStartedPTO() {\n            for (var i = 0; i < this.provisionalStartedTypecheckObjects.length; i++) {\n                if (this.provisionalStartedTypecheckObjects[i].typeCheckStatus >= this.typingContextStack.getContextID()) {\n                    this.provisionalStartedTypecheckObjects[i].typeCheckStatus = TypeCheckStatus.NotStarted;\n                }\n            }\n            this.provisionalStartedTypecheckObjects = [];\n        }\n\n        // type collection      \n        public collectTypes(ast: AST): void {\n            if (ast.nodeType == NodeType.Script) {\n                var script = <Script>ast;\n                this.locationInfo = script.locationInfo;\n            }\n            var globalChain = new ScopeChain(this.gloMod, null, this.globalScope);\n            var context = new TypeCollectionContext(globalChain, this);\n            getAstWalkerFactory().walk(ast, preCollectTypes, postCollectTypes, null, context);\n        }\n\n        public makeArrayType(type: Type): Type {\n            if (type.arrayCache == null) {\n                type.arrayCache = new ArrayCache();\n                type.arrayCache.arrayType = new Type();\n                type.arrayCache.arrayType.elementType = type;\n                type.arrayCache.arrayType.symbol = type.symbol;\n            }\n            return type.arrayCache.arrayType;\n        }\n\n        public getParameterList(funcDecl: FuncDecl, container: Symbol): SignatureData {\n            var args = funcDecl.arguments;\n            var parameterTable = null;\n            var parameterBuilder = null;\n            var len = args.members.length;\n            var nonOptionalParams = 0;\n            var result: ParameterSymbol[] = [];\n\n            if (len > 0) {\n                parameterTable = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                parameterBuilder = new SymbolScopeBuilder(parameterTable, null, null, null, null, container);\n\n                for (var i = 0; i < len; i++) {\n                    var parameter = <ArgDecl>args.members[i];\n                    var paramDef = new ValueLocation();\n                    var parameterSymbol = new ParameterSymbol(parameter.id.text, parameter.minChar,\n                                                            this.locationInfo.unitIndex, paramDef);\n                    parameterSymbol.declAST = parameter;\n                    parameterSymbol.funcDecl = funcDecl;\n                    parameter.id.sym = parameterSymbol;\n                    parameter.sym = parameterSymbol;\n                    paramDef.symbol = parameterSymbol;\n                    paramDef.typeLink = getTypeLink(parameter.typeExpr, this, false);\n                    parameterBuilder.enter(null, parameter, parameterSymbol, this.errorReporter, true, false, false); // REVIEW: Shoul';
var v27516 = v27517 + "d this be entered into the private scope?\n                    result[result.length] = parameterSymbol;\n                    if (!parameter.isOptionalArg()) {\n                        nonOptionalParams++;\n                    }\n                }\n            }\n            return { parameters: result, nonOptionalParameterCount: nonOptionalParams };\n        }\n\n        // Create a signature for a function definition\n        //  (E.g., has a function body - function declarations, property declarations, lambdas)\n        public createFunctionSignature(funcDecl: FuncDecl, container: Symbol, scope: SymbolScope, overloadGroupSym: Symbol, addToScope: bool): Signature {\n\n            var isExported = hasFlag(funcDecl.fncFlags, FncFlags.Exported | FncFlags.ClassPropertyMethodExported) || container == this.gloMod;\n            var isStatic = hasFlag(funcDecl.fncFlags, FncFlags.Static);\n            var isPrivate = hasFlag(funcDecl.fncFlags, FncFlags.Private);\n            var isDefinition = hasFlag(funcDecl.fncFlags, FncFlags.Definition);\n            var isAmbient = hasFlag(funcDecl.fncFlags, FncFlags.Ambient);\n            var isConstructor = funcDecl.isConstructMember() || funcDecl.isConstructor;\n            var isGlobal = container == this.gloMod;\n\n            var signature: Signature = new Signature();\n            var isLambda = funcDecl.fncFlags & FncFlags.IsFunctionExpression;\n\n            // If a return type has been declared for the signature, set the type link.\n            // Otherwise:\n            //  if it's a signature, its type will be 'any'\n            //  if it's a definition, the return type will be inferred  \n            if (funcDecl.returnTypeAnnotation || isDefinition) {\n                signature.returnType = getTypeLink(funcDecl.returnTypeAnnotation, this, false);\n            }\n            else {\n                signature.returnType = new TypeLink();\n                signature.returnType.type = this.anyType;\n            }\n\n            signature.hasVariableArgList = funcDecl.variableArgList;\n\n            var sigData = this.getParameterList(funcDecl, container);\n\n            signature.parameters = sigData.parameters;\n            signature.nonOptionalParameterCount = sigData.nonOptionalParameterCount;\n\n            funcDecl.signature = signature;\n            signature.declAST = funcDecl;\n\n            var useOverloadGroupSym =\n                overloadGroupSym &&\n                overloadGroupSym.getType() &&\n                !overloadGroupSym.isAccessor() &&\n                (funcDecl.isSignature() || (isAmbient == hasFlag(overloadGroupSym.flags, SymbolFlags.Ambient)));\n\n            if (useOverloadGroupSym && isPrivate != hasFlag(overloadGroupSym.flags, SymbolFlags.Private)) {\n                this.errorReporter.simpleError(funcDecl, \"Public/Private visibility of overloads does not agree\");\n            }\n\n            var groupType = useOverloadGroupSym ? overloadGroupSym.getType() : new Type();\n\n            if (isConstructor) {\n                if (groupType.construct == null) {\n                    groupType.construct = new SignatureGroup();\n                }\n                groupType.construct.addSignature(signature);\n                groupType.construct.hasImplementation = !(funcDecl.isSignature());\n                if (groupType.construct.hasImplementation) {\n                    groupType.setHasImplementation();\n                }\n            }\n            else if (funcDecl.isIndexerMember()) {\n                if (groupType.index == null) {\n                    groupType.index = new SignatureGroup();\n                    groupType.index.flags |= SignatureFlags.IsIndexer;\n                }\n\n                groupType.index.addSignature(signature);\n                groupType.index.hasImplementation = !(funcDecl.isSignature());\n                if (groupType.index.hasImplementation) {\n                    groupType.setHasImplementation();\n                }\n            }\n            else {\n                if (groupType.call == null) {\n                    groupType.call = new SignatureGroup();\n                }\n                groupType.call.addSignature(signature);\n\n                groupType.call.hasImplementation = !(funcDecl.isSignature());\n                if (groupType.call.hasImplementation) {\n                    groupType.setHasImplementation();\n                }\n            }\n\n            var instanceType = groupType.instanceType;\n\n            // Ensure that the function's symbol is properly configured\n            // (If there were overloads, we'll already have a symbol, otherwise we need to create one)\n            var funcName: string = null;\n\n            // Set the function's name:\n            //  In the case of anonymous or functions resulting from error\n            //  correction in the parser (isMissing() == true), we do not\n            //  want to set a function name, since they shouldn't be inserted\n            //  into the enclosing scope\n\n            // usedHint prevents functions bound to object literal fields from";
var v27515 = v27516 + " being added to the\n            // enclosing scope\n            var usedHint = false;\n            if (funcDecl.name && !funcDecl.name.isMissing()) {\n                funcName = funcDecl.name.text;\n            }\n            else if (funcDecl.hint) {\n                funcName = funcDecl.hint;\n                usedHint = true;\n            }\n\n            if (groupType.symbol == null) {\n                groupType.symbol =\n                    new TypeSymbol(funcName ? funcName : this.anon,\n                                    funcDecl.minChar, funcDecl.limChar - funcDecl.minChar,\n                                    this.locationInfo.unitIndex,\n                                    groupType);\n                if (!useOverloadGroupSym) {\n                    groupType.symbol.declAST = funcDecl;\n                }\n            }\n\n            // REVIEW: Are we missing any other flags?\n            if (isStatic) {\n                groupType.symbol.flags |= SymbolFlags.Static;\n            }\n\n            if (isAmbient) {\n                groupType.symbol.flags |= SymbolFlags.Ambient;\n            }\n\n            if (isPrivate) {\n                groupType.symbol.flags |= SymbolFlags.Private;\n            }\n\n            groupType.symbol.isMethod = funcDecl.isMethod();\n            if (groupType.symbol.isMethod) {\n                groupType.symbol.flags |= SymbolFlags.Property;\n            }\n\n            funcDecl.type = groupType;\n\n            // Add the function symbol to the appropriate scope\n            // if the funcDecl is a constructor, it will be added to the enclosing scope as a class\n            if (!isConstructor) {\n                // Add the function's symbol to its enclosing scope\n                if (funcName && !isLambda && !funcDecl.isAccessor() && !usedHint) {\n\n                    // REVIEW: We're not setting the isDecl flags for fuctions bound to object literal properties\n                    // so removing the isDefiniton clause would break object literals\n                    if (addToScope) {  // REVIEW: If we combine this with createFunctionDeclarationSignature, we'll need to broaden this for both decls and defs                      \n                        // if it's a static method, enter directly into the container's scope\n                        if (funcDecl.isMethod() && isStatic) {\n\n                            // REVIEW: What about private statics?\n                            if (!(<TypeSymbol>container).type.members.publicMembers.add(funcName, groupType.symbol)) {\n                                this.errorReporter.duplicateIdentifier(funcDecl, funcName);\n                            }\n\n                            groupType.symbol.container = container;\n                        } // REVIEW: Another check for overloads...\n                        else if (overloadGroupSym == null || (overloadGroupSym.declAST && !(<FuncDecl>overloadGroupSym.declAST).isOverload && (container.isType()))) {\n                            scope.enter(container, funcDecl, groupType.symbol, this.errorReporter, !isPrivate && (isExported || isStatic || isGlobal), false, isAmbient);\n                        }\n                    }\n                    else if (!funcDecl.isSpecialFn()) {\n                        groupType.symbol.container = container; // REVIEW: Set container for overloads or anonymous?\n                    }\n                }\n                else if (!funcDecl.isSpecialFn()) {\n                    groupType.symbol.container = container; // REVIEW: Set container for lambdas and accessors?\n                }\n            }\n\n            // If, say, a call signature overload was declared before the class type was, we want to reuse\n            // the type that's already been instantiated for the class type, rather than allocate a new one\n            if (useOverloadGroupSym) {\n                var overloadGroupType = overloadGroupSym ? overloadGroupSym.getType() : null;\n                var classType = groupType;\n\n                if (classType != overloadGroupType) {\n                    if (classType.construct == null) {\n                        if (overloadGroupType && overloadGroupType.construct) {\n                            classType.construct = overloadGroupType.construct;\n                        }\n                        else {\n                            classType.construct = new SignatureGroup();\n                        }\n                    }\n                    else if (overloadGroupType) {\n                        if (overloadGroupType.construct) {\n                            classType.construct.signatures.concat(overloadGroupType.construct.signatures);\n                        }\n                    }\n\n                    // sync call and index signatures as well, but don't allocate should they not\n                    // already exist\n                    if (overloadGroupType) {\n                        if (classType.call == null) {\n                            classType.call = overloadGroupType.call;\n                        }\n                ";
var v27514 = v27515 + '        else if (overloadGroupType.call) {\n                            classType.call.signatures.concat(overloadGroupType.call.signatures);\n                        }\n\n                        // if the function is not static, we need to add any call overloads onto the\n                        // instance type\'s call signature list\n                        if (!isStatic) {\n\n                            if (classType.instanceType == null) {\n                                classType.instanceType = overloadGroupType.instanceType;\n                            }\n\n                            var instanceType = classType.instanceType;\n\n                            if (instanceType) {\n                                if (instanceType.call == null) {\n                                    instanceType.call = overloadGroupType.call;\n                                }\n                                else if (overloadGroupType.call) {\n                                    instanceType.call.signatures.concat(overloadGroupType.call.signatures);\n                                }\n                            }\n                        }\n\n                        if (classType.index == null) {\n                            classType.index = overloadGroupType.index;\n                        }\n                        else if (overloadGroupType.index) {\n                            classType.index.signatures.concat(overloadGroupType.index.signatures);\n                        }\n                    }\n                }\n            }\n\n            return signature;\n        }\n\n        // Creates a new symbol for an accessor property\n        // Note that funcDecl.type.symbol and fgSym may not be the same (E.g., in the case of type collection)\n        public createAccessorSymbol(funcDecl: FuncDecl, fgSym: Symbol, enclosingClass: Type, addToMembers: bool, isClassProperty: bool, scope: SymbolScope, container: Symbol) {\n            var accessorSym: FieldSymbol = null\n            var sig = funcDecl.signature;\n            var nameText = funcDecl.name.text;\n            var isStatic = hasFlag(funcDecl.fncFlags, FncFlags.Static);\n            var isPrivate = hasFlag(funcDecl.fncFlags, FncFlags.Private);\n\n            if (fgSym == null) {\n                var field = new ValueLocation();\n                accessorSym = new FieldSymbol(nameText, funcDecl.minChar, this.locationInfo.unitIndex, false, field);\n                field.symbol = accessorSym;\n                accessorSym.declAST = funcDecl; // REVIEW: need to reset for getters and setters\n\n                if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {\n                    if (accessorSym.getter) {\n                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property getter");\n                    }\n                    accessorSym.getter = <TypeSymbol>sig.declAST.type.symbol;\n                }\n                else {\n                    if (accessorSym.setter) {\n                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property setter");\n                    }\n                    accessorSym.setter = <TypeSymbol>sig.declAST.type.symbol;\n                }\n\n                field.typeLink = getTypeLink(null, this, false);\n\n                // if it\'s static, enter it into the class\'s member list directly\n                if (addToMembers) {\n                    if (enclosingClass) {\n                        if (!enclosingClass.members.publicMembers.add(nameText, accessorSym)) {\n                            this.errorReporter.duplicateIdentifier(funcDecl, accessorSym.name);\n                        }\n                        accessorSym.container = enclosingClass.symbol;\n                    }\n                    else {\n                        this.errorReporter.simpleError(funcDecl, "Accessor property may not be added in this context");\n                    }\n                }\n                else {\n                    scope.enter(container, funcDecl, accessorSym, this.errorReporter, !isPrivate || isStatic, false, false);\n                }\n\n                // We set the flags here, instead of below, because the accessor symbol does not yet have a type\n                if (isClassProperty) {\n                    accessorSym.flags |= SymbolFlags.Property;\n                }\n                if (isStatic) {\n                    accessorSym.flags |= SymbolFlags.Static;\n                }\n\n                if (isPrivate) {\n                    accessorSym.flags |= SymbolFlags.Private;\n                }\n                else {\n                    accessorSym.flags |= SymbolFlags.Public;\n                }\n            }\n            else {\n                accessorSym = <FieldSymbol>(<any>fgSym);\n\n                if (isPrivate != hasFlag(accessorSym.flags, SymbolFlags.Private)) {\n                    this.errorReporter.simpleError(funcDecl, "Getter and setter accessors do not agree in visibility");\n                }\n\n                if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {\n       ';
var v27513 = v27514 + '             if (accessorSym.getter) {\n                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property getter");\n                    }\n                    accessorSym.getter = <TypeSymbol>funcDecl.type.symbol;\n                }\n                else {\n                    if (accessorSym.setter) {\n                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property setter");\n                    }\n                    accessorSym.setter = <TypeSymbol>funcDecl.type.symbol;\n                }\n            }\n\n            return accessorSym;\n        }\n\n        public addBases(resultScope: SymbolAggregateScope, type: Type, baseContext: { base: string; baseId: number; }): void {\n            resultScope.addParentScope(new SymbolTableScope(type.members, type.ambientMembers, type.getAllEnclosedTypes(), type.getAllAmbientEnclosedTypes(), type.symbol));\n            var i = 0;\n            var parent: Type;\n            if (type.extendsList) {\n                for (var len = type.extendsList.length; i < len; i++) {\n                    parent = type.extendsList[i];\n                    if (baseContext.baseId == parent.typeID) {\n                        this.errorReporter.reportErrorFromSym(parent.symbol, "Type \'" + baseContext.base + "\' is recursively referenced as a base class of itself");\n                        parent.symbol.flags |= SymbolFlags.RecursivelyReferenced;\n                        break;\n                    }\n                    this.addBases(resultScope, parent, baseContext);\n                }\n            }\n        }\n\n        public scopeOf(type: Type): SymbolScope {\n            var resultScope = new SymbolAggregateScope(type.symbol);\n            var baseContext = { base: type.symbol && type.symbol.name ? type.symbol.name : "{}", baseId: type.typeID };\n            this.addBases(resultScope, type, baseContext);\n            return resultScope;\n        }\n\n        public lookupMemberTypeSymbol(containingType: Type, name: string): Symbol {\n            var symbol: Symbol = null;\n            if (containingType.containedScope) {\n                symbol = containingType.containedScope.find(name, false, true);\n            }\n            else if (containingType.members) {\n                symbol = containingType.members.allMembers.lookup(name);\n\n                if (symbol == null && containingType.ambientMembers) {\n                    symbol = containingType.ambientMembers.allMembers.lookup(name);\n                }\n            }\n            if (symbol == null) {\n                var typeMembers = containingType.getAllEnclosedTypes();\n                var ambientTypeMembers = containingType.getAllAmbientEnclosedTypes();\n                if (typeMembers) {\n                    symbol = typeMembers.allMembers.lookup(name);\n\n                    if (symbol == null && ambientTypeMembers) {\n                        symbol = ambientTypeMembers.allMembers.lookup(name);\n                    }\n\n                }\n            }\n            if (symbol && symbol.isType()) {\n                return symbol;\n            }\n            else {\n                return null;\n            }\n        }\n\n        public findSymbolForDynamicModule(idText: string, currentFileName: string, search: (id: string) =>Symbol): Symbol {\n            var originalIdText = idText;\n            var symbol = search(idText);\n           \n            if (symbol == null) {\n                // perhaps it\'s a dynamic module?\n                if (!symbol) {\n                    idText = swapQuotes(originalIdText);\n                    symbol = search(idText);\n                }\n\n                // Check the literal path first\n                if (!symbol) {\n                    idText = stripQuotes(originalIdText) + ".ts";\n                    symbol = search(idText);\n                }\n\n                if (!symbol) {\n                    idText = stripQuotes(originalIdText) + ".str";\n                    symbol = search(idText);\n                }\n\n                // Check check for .d.str\n                if (!symbol) {\n                    idText = stripQuotes(originalIdText) + ".d.ts";\n                    symbol = search(idText);\n                }\n\n                if (!symbol) {\n                    idText = stripQuotes(originalIdText) + ".d.str";\n                    symbol = search(idText);\n                }\n\n                // If the literal path doesn\'t work, begin the search\n                if (!symbol && !isRelative(originalIdText)) {\n                    // check the full path first, as this is the most likely scenario\n                    idText = originalIdText;\n\n                    var strippedIdText = stripQuotes(idText);\n\n                    // REVIEW: Technically, we shouldn\'t have to normalize here - we should normalize in addUnit.\n                    // Still, normalizing here alows any language services to be free of assumptions\n                    var path = getRootFilePath(switchToForwardSlashes(currentFileName));\n\n                    ';
var v27512 = v27513 + 'while (symbol == null && path != "") {\n                        idText = normalizePath(path + strippedIdText + ".ts");\n                        symbol = search(idText);\n\n                        // check for .str\n                        if (symbol == null) {\n                            idText = changePathToSTR(idText);\n                            symbol = search(idText);\n                        }\n\n                        // check for .d.ts\n                        if (symbol == null) {\n                            idText = changePathToDTS(idText);\n                            symbol = search(idText);\n                        }\n\n                        // check for .d.str\n                        if (symbol == null) {\n                            idText = changePathToDSTR(idText);\n                            symbol = search(idText);\n                        }\n\n                        if (symbol == null) {\n\t\t\t\t\t\t\tif(path === \'/\') {\n\t\t\t\t\t\t\t\tpath = \'\';\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpath = normalizePath(path + "..");\n\t\t\t\t\t\t\t\tpath = path && path != \'/\' ? path + \'/\' : path;\n\t\t\t\t\t\t\t}\n                        }\n                    }\n                }\n            }\n\n            return symbol;\n        }\n\n        public resolveTypeMember(scope: SymbolScope, dotNode: BinaryExpression): Type {\n            var lhs = dotNode.operand1;\n            var rhs = dotNode.operand2;\n            var resultType = this.anyType;\n            var lhsType = this.anyType;\n\n            if (lhs && rhs && (rhs.nodeType == NodeType.Name)) {\n                if (lhs.nodeType == NodeType.Dot) {\n                    lhsType = this.resolveTypeMember(scope, <BinaryExpression>lhs);\n                }\n                else if (lhs.nodeType == NodeType.Name) {\n                    var identifier = <Identifier>lhs;\n                    var symbol = scope.find(identifier.text, false, true);\n                    if (symbol == null) {\n                        this.errorReporter.unresolvedSymbol(identifier, identifier.actualText);\n                    }\n                    else if (symbol.isType()) {\n\n                        var typeSymbol = <TypeSymbol> symbol;\n\n                        if (typeSymbol.aliasLink && !typeSymbol.type && typeSymbol.aliasLink.alias.nodeType == NodeType.Name) {\n                            var modPath = (<Identifier>typeSymbol.aliasLink.alias).text;\n                            var modSym = this.findSymbolForDynamicModule(modPath, this.locationInfo.filename, (id) => scope.find(id, false, true));\n                            if (modSym) {\n                                typeSymbol.type = modSym.getType();\n                            }\n                        }\n\n                        if (optimizeModuleCodeGen && symbol) {\n                            var symType = symbol.getType();\n                            // Once the type has been referenced outside of a type ref position, there\'s\n                            // no going back                        \n                            if (symType && typeSymbol.aliasLink && typeSymbol.onlyReferencedAsTypeRef) {\n\n                                var modDecl = <ModuleDeclaration>symType.symbol.declAST;\n                                if (modDecl && hasFlag(modDecl.modFlags, ModuleFlags.IsDynamic)) {\n                                    typeSymbol.onlyReferencedAsTypeRef = !this.resolvingBases;\n                                }\n                            }\n                        }\n                        if (!symbol.visible(scope, this)) {\n                            this.errorReporter.simpleError(lhs, "The symbol \'" + identifier.actualText + "\' is not visible at this point");\n                        }\n                        lhsType = symbol.getType();\n\n                        identifier.sym = symbol;\n                    }\n                    else {\n                        this.errorReporter.simpleError(lhs, "Expected type");\n                    }\n\n                }\n\n                // if the LHS type is a module alias, we won\'t be able to resolve it until\n                // typecheck type.  If this is called during binding, lhsType will be null\n                if (!lhsType) {\n                    lhsType = this.anyType;\n                }\n\n                if (lhsType != this.anyType) {\n                    var rhsIdentifier = <Identifier>rhs;\n                    var resultSymbol = this.lookupMemberTypeSymbol(lhsType, rhsIdentifier.text);\n                    if (resultSymbol == null) {\n                        resultType = this.anyType;\n                        this.errorReporter.simpleError(dotNode, "Expected type");\n                    }\n                    else {\n                        resultType = resultSymbol.getType();\n                        if (!resultSymbol.visible(scope, this)) {\n                            this.errorReporter.simpleError(lhs, "The symbol \'" + (<Identifier>rhs).actualText + "\' is not visible at this point");\n                        }\n                    }\n                    rhsIdentifier.sym =';
var v27511 = v27512 + ' resultType.symbol;\n                }\n            }\n            if (resultType.isClass()) {\n                resultType = resultType.instanceType;\n            }\n            return resultType;\n        }\n\n        public resolveFuncDecl(funcDecl: FuncDecl, scope: SymbolScope,\n            fgSym: TypeSymbol): Symbol {\n            var functionGroupSymbol = this.createFunctionSignature(funcDecl, scope.container, scope, fgSym, false).declAST.type.symbol;\n            var signatures: Signature[];\n            if (funcDecl.isConstructMember()) {\n                signatures = functionGroupSymbol.type.construct.signatures;\n            }\n            else if (funcDecl.isIndexerMember()) {\n                signatures = functionGroupSymbol.type.getInstanceType().index.signatures;\n            }\n            else {\n                signatures = functionGroupSymbol.type.call.signatures;\n            }\n\n            var signature = signatures[signatures.length - 1];\n            var len = signature.parameters.length;\n            for (var i = 0; i < len; i++) {\n                var paramSym: ParameterSymbol = signature.parameters[i];\n                this.resolveTypeLink(scope, paramSym.parameter.typeLink, true);\n            }\n\n            // If a vararg list is present, check that the type is an array type\n            if (len && funcDecl.variableArgList) {\n                if (!signature.parameters[len - 1].parameter.typeLink.type.elementType) {\n                    this.errorReporter.simpleErrorFromSym(signature.parameters[len - 1].parameter.symbol, "... parameter must have array type");\n                    signature.parameters[len - 1].parameter.typeLink.type = this.makeArrayType(signature.parameters[len - 1].parameter.typeLink.type);\n                }\n            }\n            this.resolveTypeLink(scope, signature.returnType,\n                            funcDecl.isSignature());\n            return functionGroupSymbol;\n        }\n\n        public resolveVarDecl(varDecl: VarDecl, scope: SymbolScope): Symbol {\n            var field = new ValueLocation();\n            var fieldSymbol =\n                new FieldSymbol(varDecl.id.text, varDecl.minChar, this.locationInfo.unitIndex,\n                                (varDecl.varFlags & VarFlags.Readonly) == VarFlags.None,\n                                field);\n            fieldSymbol.transferVarFlags(varDecl.varFlags);\n            field.symbol = fieldSymbol;\n            fieldSymbol.declAST = varDecl;\n            field.typeLink = getTypeLink(varDecl.typeExpr, this, varDecl.init == null);\n            this.resolveTypeLink(scope, field.typeLink, true);\n            varDecl.sym = fieldSymbol;\n            varDecl.type = field.typeLink.type;\n            return fieldSymbol;\n        }\n\n        public resolveTypeLink(scope: SymbolScope, typeLink: TypeLink, supplyVar: bool): void {\n            var arrayCount = 0;\n            if (typeLink.type == null) {\n                var ast: AST = typeLink.ast;\n                if (ast) {\n                    while (typeLink.type == null) {\n                        switch (ast.nodeType) {\n                            case NodeType.Name:\n                                var identifier = <Identifier>ast;\n                                var symbol = scope.find(identifier.text, false, true);\n                                if (symbol == null) {\n                                    typeLink.type = this.anyType;\n                                    this.errorReporter.unresolvedSymbol(identifier, identifier.actualText);\n                                }\n                                else if (symbol.isType()) {\n                                    if (!symbol.visible(scope, this)) {\n                                        this.errorReporter.simpleError(ast, "The symbol \'" + identifier.actualText + "\' is not visible at this point");\n                                    }\n                                    identifier.sym = symbol;\n                                    typeLink.type = symbol.getType();\n                                    if (typeLink.type) {\n                                        if (typeLink.type.isClass()) {\n                                            typeLink.type = typeLink.type.instanceType;\n                                        }\n                                    }\n                                    else {\n                                        typeLink.type = this.anyType;\n                                    }\n                                }\n                                else {\n                                    typeLink.type = this.anyType;\n                                    this.errorReporter.simpleError(ast, "Expected type");\n                                }\n                                break;\n                            case NodeType.Dot:\n                                typeLink.type = this.resolveTypeMember(scope, <BinaryExpression>ast);\n                                break;\n                            case NodeType.TypeRef:\n                       ';
var v27510 = v27511 + '         var typeRef = <TypeReference>ast;\n                                arrayCount = typeRef.arrayCount;\n                                ast = typeRef.term;\n                                if (ast == null) {\n                                    typeLink.type = this.anyType;\n                                }\n                                break;\n                            case NodeType.InterfaceDeclaration:\n                                var interfaceDecl = <InterfaceDeclaration>ast;\n                                var interfaceType = new Type();\n                                var interfaceSymbol = new TypeSymbol((<Identifier>interfaceDecl.name).text,\n                                                                   ast.minChar,\n                                                                   ast.limChar - ast.minChar,\n                                                                   this.locationInfo.unitIndex,\n                                                                   interfaceType);\n                                interfaceType.symbol = interfaceSymbol;\n                                interfaceType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n\n                                interfaceType.containedScope =\n                                    new SymbolTableScope(interfaceType.members, null, null, null,\n                                                         interfaceSymbol);\n\n                                interfaceType.containedScope.container = interfaceSymbol;\n                                interfaceType.memberScope = interfaceType.containedScope;\n\n                                var memberList = <ASTList>interfaceDecl.members;\n                                var props: AST[] = memberList.members;\n                                var propsLen = props.length;\n\n                                for (var j = 0; j < propsLen; j++) {\n                                    var propDecl = props[j];\n                                    var propSym: Symbol = null;\n                                    var addMember = true;\n                                    var id: Identifier = null;\n                                    if (propDecl.nodeType == NodeType.FuncDecl) {\n                                        var funcDecl = <FuncDecl>propDecl;\n                                        id = funcDecl.name;\n                                        propSym = interfaceType.members.allMembers.lookup(funcDecl.getNameText());\n                                        addMember = (propSym == null);\n                                        if (funcDecl.isSpecialFn()) {\n                                            addMember = false;\n                                            propSym = this.resolveFuncDecl(funcDecl, scope, interfaceSymbol);\n                                        }\n                                        else {\n                                            propSym = this.resolveFuncDecl(funcDecl, scope, <TypeSymbol>propSym);\n                                        }\n                                        funcDecl.type = (<TypeSymbol>propSym).type;\n                                    }\n                                    else {\n                                        id = (<VarDecl>propDecl).id;\n                                        propSym = this.resolveVarDecl(<VarDecl>propDecl, scope);\n\n                                        // Don\'t add the member if it was missing a name.  This \n                                        // generally just leads to cascading errors that make things\n                                        // more confusing for the user.\n                                        addMember = !id.isMissing();\n                                    }\n\n                                    if (addMember) {\n                                        if (id && hasFlag(id.flags, ASTFlags.OptionalName)) {\n                                            propSym.flags |= SymbolFlags.Optional;\n                                        }\n                                        if (!interfaceType.members.allMembers.add(propSym.name, propSym)) {\n                                            this.errorReporter.duplicateIdentifier(ast, propSym.name);\n                                        }\n                                    }\n                                }\n\n                                ast.type = interfaceType;\n                                typeLink.type = interfaceType;\n\n                                break;\n                            case NodeType.FuncDecl:\n                                var tsym = <TypeSymbol>this.resolveFuncDecl(<FuncDecl>ast, scope, null);\n                                typeLink.type = tsym.type;\n                                break;\n                            default:\n                                typeLink.type = this.anyType;\n                                this.errorReporter.simpleError(ast, "Expected type");\n                ';
var v27509 = v27510 + '                break;\n                        }\n                    }\n                }\n                for (var count = arrayCount; count > 0; count--) {\n                    typeLink.type = this.makeArrayType(typeLink.type);\n                }\n                if (supplyVar && (typeLink.type == null)) {\n                    typeLink.type = this.anyType;\n                }\n                if (typeLink.ast) {\n                    typeLink.ast.type = typeLink.type;\n                }\n            }\n            // else wait for type inference\n        }\n\n        public resolveBaseTypeLink(typeLink: TypeLink, scope: SymbolScope) {\n            this.resolvingBases = true;\n            this.resolveTypeLink(scope, typeLink, true);\n            this.resolvingBases = false;\n            var extendsType: Type = null;\n            if (typeLink.type.isClass()) {\n                extendsType = typeLink.type.instanceType;\n            }\n            else {\n                extendsType = typeLink.type;\n            }\n\n            return extendsType;\n        }\n\n        public findMostApplicableSignature(signatures: ApplicableSignature[], args: ASTList): { sig: Signature; ambiguous: bool; } {\n\n            if (signatures.length == 1) {\n                return { sig: signatures[0].signature, ambiguous: false };\n            }\n\n            var best: ApplicableSignature = signatures[0];\n            var Q: ApplicableSignature = null;\n            var AType: Type = null;\n            var PType: Type = null;\n            var QType: Type = null;\n            var ambiguous = false;\n\n            for (var qSig = 1; qSig < signatures.length; qSig++) {\n                Q = signatures[qSig];\n                var i = 0;\n                // find the better conversion\n                for (i = 0; args && i < args.members.length; i++) {\n                    AType = args.members[i].type;\n                    PType = i < best.signature.parameters.length ? best.signature.parameters[i].getType() : best.signature.parameters[best.signature.parameters.length - 1].getType().elementType;\n                    QType = i < Q.signature.parameters.length ? Q.signature.parameters[i].getType() : Q.signature.parameters[Q.signature.parameters.length - 1].getType().elementType;\n\n                    if (this.typesAreIdentical(PType, QType)) {\n                        continue;\n                    }\n                    else if (this.typesAreIdentical(AType, PType)) {\n                        break;\n                    }\n                    else if (this.typesAreIdentical(AType, QType)) {\n                        best = Q;\n                        break;\n                    }\n                    else if (this.sourceIsSubtypeOfTarget(PType, QType)) {\n                        break;\n                    }\n                    else if (this.sourceIsSubtypeOfTarget(QType, PType)) {\n                        best = Q;\n                        break;\n                    }\n                    else if (Q.hadProvisionalErrors) {\n                        break;\n                    }\n                    else if (best.hadProvisionalErrors) {\n                        best = Q;\n                        break;\n                    }\n                }\n\n                if (!args || i == args.members.length) {\n                    var collection: ITypeCollection = {\n                        getLength: () => { return 2; },\n                        setTypeAtIndex: (index: number, type: Type) => { }, // no contextual typing here, so no need to do anything\n                        getTypeAtIndex: (index: number) => { return index ? Q.signature.returnType.type : best.signature.returnType.type; } // we only want the "second" type - the "first" is skipped\n                    }\n                    var bct = this.findBestCommonType(best.signature.returnType.type, null, collection, true);\n                    ambiguous = !bct;\n                }\n                else {\n                    ambiguous = false;\n                }\n            }\n\n            return { sig: best.signature, ambiguous: ambiguous };\n        }\n\n        public getApplicableSignatures(signatures: Signature[], args: ASTList, comparisonInfo: TypeComparisonInfo): ApplicableSignature[] {\n\n            var applicableSigs: ApplicableSignature[] = [];\n            var memberType: Type = null;\n            var miss = false;\n            var cxt: ContextualTypeContext = null;\n            var hadProvisionalErrors = false;\n\n            for (var i = 0; i < signatures.length; i++) {\n                miss = false;\n\n                for (var j = 0; j < args.members.length; j++) {\n\n                    if (j >= signatures[i].parameters.length) {\n                        continue;\n                    }\n                    memberType = signatures[i].parameters[j].getType();\n\n                    // account for varargs\n                    if (signatures[i].declAST.variableArgList && (j >= signatures[i].nonOptionalParameterCount - 1) && memberType.isArray()) {\n                        memberType = mem';
var v27508 = v27509 + 'berType.elementType;\n                    }\n\n                    if (memberType == this.anyType) {\n                        continue;\n                    }\n                    else if (args.members[j].nodeType == NodeType.FuncDecl) {\n                        if (this.typeFlow.functionInterfaceType && memberType == this.typeFlow.functionInterfaceType) {\n                            continue;\n                        }\n                        if (!this.canContextuallyTypeFunction(memberType, <FuncDecl>args.members[j], true)) {\n                            // if it\'s just annotations that are blocking us, typecheck the function and add it to the list\n                            if (this.canContextuallyTypeFunction(memberType, <FuncDecl>args.members[j], false)) {\n                                this.typeFlow.typeCheck(args.members[j]);\n                                if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {\n                                    break;\n                                }\n                            }\n                            else {\n                                break;\n                            }\n                        }\n                        else { // if it can be contextually typed, try it out...\n\n                            this.typeCheckWithContextualType(memberType, true, true, args.members[j]);\n                            this.cleanStartedPTO();\n                            hadProvisionalErrors = this.hadProvisionalErrors();\n\n                            if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {\n                                if (comparisonInfo) {\n                                    comparisonInfo.setMessage("Could not apply type \'" + memberType.getTypeName() + "\' to argument " + (j + 1) + ", which is of type \'" + args.members[j].type.getTypeName() + "\'");\n                                }\n                                miss = true;\n                            }\n\n                            // clean the type\n                            //if (hadProvisionalErrors) {\n                            //    cxt = this.currentContextualTypeContext;\n                            //    this.typeCheckWithContextualType(null, true, true, args.members[j]);\n                            //    if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType)) {\n                            //        miss = true;\n                            //    }\n                            //    this.cleanStartedPTO();\n                            //}\n\n                            this.resetProvisionalErrors();\n                            if (miss) {\n                                break;\n                            }\n                        }\n                    }\n                    else if (args.members[j].nodeType == NodeType.ObjectLit) {\n                        // now actually attempt to typecheck as the contextual type\n                        if (this.typeFlow.objectInterfaceType && memberType == this.typeFlow.objectInterfaceType) {\n                            continue;\n                        }\n\n                        this.typeCheckWithContextualType(memberType, true, true, args.members[j]);\n                        this.cleanStartedPTO();\n                        hadProvisionalErrors = this.hadProvisionalErrors(); \n\n                        if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {\n                            if (comparisonInfo) {\n                                comparisonInfo.setMessage("Could not apply type \'" + memberType.getTypeName() + "\' to argument " + (j + 1) + ", which is of type \'" + args.members[j].type.getTypeName() + "\'");\n                            }\n                            miss = true;\n                        }\n\n                        // clean the type\n                        //if (hadProvisionalErrors) {\n                        //    this.typeCheckWithContextualType(null, true, true, args.members[j]);\n\n                        //    // is the "cleaned" type even assignable?\n                        //    if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType)) {\n                        //        miss = true;\n                        //    }\n\n                        //    this.cleanStartedPTO();\n                        //}\n\n                        this.resetProvisionalErrors();\n                        if (miss) {\n                            break;\n                        }\n                    }\n                    else if (args.members[j].nodeType == NodeType.ArrayLit) {\n                        // attempt to contextually type the array literal\n                        if (this.typeFlow.arrayInterfaceType && memberType == this.typeFlow.arrayInterfaceType) {\n                            continue;\n                        }\n\n                        this.typeCheckWithContextualType(memberType, true, true, args.members[j]);\n                        thi';
var v27507 = v27508 + 's.cleanStartedPTO();\n                        hadProvisionalErrors = this.hadProvisionalErrors(); \n\n                        if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {\n                            if (comparisonInfo) {\n                                comparisonInfo.setMessage("Could not apply type \'" + memberType.getTypeName() + "\' to argument " + (j + 1) + ", which is of type \'" + args.members[j].type.getTypeName() + "\'");\n                            }\n                            break;\n                        }\n\n                        // clean the type\n                        //if (hadProvisionalErrors) {\n                        //    this.typeCheckWithContextualType(null, true, true, args.members[j]);\n                        //    if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType)) {\n                        //        miss = true;\n                        //    }\n\n                        //    this.cleanStartedPTO();\n                        //}\n\n                        this.resetProvisionalErrors();\n                        if (miss) {\n                            break;\n                        }\n                    }\n                }\n\n                if (j == args.members.length) {\n                    applicableSigs[applicableSigs.length] = { signature: signatures[i], hadProvisionalErrors: hadProvisionalErrors };\n                }\n                hadProvisionalErrors = false;\n            }\n\n            return applicableSigs;\n        }\n\n        public canContextuallyTypeFunction(candidateType: Type, funcDecl: FuncDecl, beStringent: bool): bool {\n\n            // in these cases, we do not attempt to apply a contextual type\n            //  RE: isInlineCallLiteral - if the call target is a function literal, we don\'t want to apply the target type\n            //  to its body - instead, it should be applied to its return type\n            if (funcDecl.isParenthesized ||\n                funcDecl.isMethod() ||\n                beStringent && funcDecl.returnTypeAnnotation ||\n                funcDecl.isInlineCallLiteral) {\n                return false;\n            }\n\n            beStringent = beStringent || (this.typeFlow.functionInterfaceType == candidateType);\n\n            // At this point, if we\'re not being stringent, there\'s no need to check for multiple call sigs\n            // or count parameters - we just want to unblock typecheck\n            if (!beStringent) {\n                return true;\n            }\n\n            // If we\'re coming from an in-scope typecheck, lambdas may not have had function signatures created for them\n            // REVIEW: Should we search out the overload group here?\n            if (!funcDecl.signature) {\n                this.createFunctionSignature(funcDecl, this.typeFlow.scope.container, this.typeFlow.scope, null, null);\n                this.typeFlow.typeCheck(funcDecl);\n            }\n\n            var signature = funcDecl.signature;\n            var paramLen = signature.parameters.length;\n\n            // Check that the argument declarations have no type annotations\n            for (var i = 0; i < paramLen; i++) {\n                var param = signature.parameters[i];\n                var symbol = <ParameterSymbol>param;\n                var argDecl = <ArgDecl>symbol.declAST;\n\n                // REVIEW: a valid typeExpr is a requirement for varargs,\n                // so we may want to revise our invariant\n                if (beStringent && argDecl.typeExpr) {\n                    return false;\n                }\n            }\n\n            if (candidateType.construct && candidateType.call) {\n                return false;\n            }\n\n            var candidateSigs = candidateType.construct ? candidateType.construct : candidateType.call;\n\n            if (!candidateSigs || candidateSigs.signatures.length > 1) {\n                return false;\n            }\n\n            // if we\'re here, the contextual type can be applied to the function\n            return true;\n        }\n\n        public canContextuallyTypeObjectLiteral(targetType: Type, objectLit: UnaryExpression): bool {\n\n            if (targetType == this.typeFlow.objectInterfaceType) {\n                return true;\n            }\n\n            var memberDecls = <ASTList>objectLit.operand;\n\n            if (!(memberDecls && targetType.memberScope)) {\n                return false;\n            }\n\n            var id: AST = null;\n            var targetMember: Symbol = null;\n            var text = "";\n            var foundSyms = {};\n\n            // Check that each property in the object literal is present in the target\n            // type\n            for (var i = 0; i < memberDecls.members.length; i++) {\n                id = (<BinaryExpression>memberDecls.members[i]).operand1;\n\n                if (id.nodeType == NodeType.Name) {\n                    text = (<Identifier>id).text;\n                }\n                else if (id.nodeType == NodeType.QString) {\n                    // TODO: set te';
var v27506 = v27507 + "xt to unescaped string\n                    var idText = (<StringLiteral>id).text;\n                    text = idText.substring(1, idText.length - 1);\n                }\n                else {\n                    return false;\n                }\n\n                targetMember = targetType.memberScope.find(text, true, false);\n\n                if (!targetMember) {\n                    return false;\n                }\n\n                foundSyms[text] = true;\n            }\n\n            // Check that all members in the target type are present in the object literal\n            var targetMembers = targetType.memberScope.getAllValueSymbolNames(true);\n\n            for (var i = 0; i < targetMembers.length; i++) {\n                var memberName = targetMembers[i];\n                var memberSym = targetType.memberScope.find(memberName, true, false);\n\n                if (!foundSyms[targetMembers[i]] &&\n                    !hasFlag(memberSym.flags, SymbolFlags.Optional)) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        public widenType(t: Type) {\n            if (t == this.undefinedType || t == this.nullType) { // REVIEW: not isNullOrUndefinedType for perf reasons\n                return this.anyType;\n            }\n\n            return t;\n        }\n\n        public isNullOrUndefinedType(t: Type) {\n            return t == this.undefinedType || t == this.nullType;\n        }\n\n        public findBestCommonType(initialType: Type, targetType: Type, collection: ITypeCollection, acceptVoid:bool, comparisonInfo?: TypeComparisonInfo) {\n            var i = 0;\n            var len = collection.getLength();\n            var nlastChecked = 0;\n            var bestCommonType = initialType;\n\n            if (targetType) {\n                bestCommonType = bestCommonType ? bestCommonType.mergeOrdered(targetType, this, acceptVoid) : targetType;\n            }\n\n            // it's important that we set the convergence type here, and not in the loop,\n            // since the first element considered may be the contextual type\n            var convergenceType: Type = bestCommonType;\n\n            while (nlastChecked < len) {\n\n                for (i = 0; i < len; i++) {\n\n                    // no use in comparing a type against itself\n                    if (i == nlastChecked) {\n                        continue;\n                    }\n\n                    if (convergenceType && (bestCommonType = convergenceType.mergeOrdered(collection.getTypeAtIndex(i), this, acceptVoid, comparisonInfo))) {\n                        convergenceType = bestCommonType;\n                    }\n\n                    if (bestCommonType == this.anyType || bestCommonType == null) {\n                        break;\n                    }\n                    else if (targetType) { // set the element type to the target type\n                        collection.setTypeAtIndex(i, targetType);\n                    }\n                }\n\n                // use the type if we've agreed upon it\n                if (convergenceType && bestCommonType) {\n                    break;\n                }\n\n                nlastChecked++;\n                if (nlastChecked < len) {\n                    convergenceType = collection.getTypeAtIndex(nlastChecked);\n                }\n            }\n\n            return acceptVoid ? bestCommonType : (bestCommonType == this.voidType ? null : bestCommonType);\n        }\n\n        // Type Identity\n\n        public typesAreIdentical(t1: Type, t2: Type) {\n\n            // This clause will cover both primitive types (since the type objects are shared),\n            // as well as shared brands\n            if (t1 == t2) {\n                return true;\n            }\n\n            if (!t1 || !t2) {\n                return false;\n            }\n\n            if (t1.isClass() || t1.isClassInstance()) {\n                return false;\n            }\n\n            var comboId = (t2.typeID << 16) | t1.typeID;\n\n            if (this.identicalCache[comboId]) {\n                return true;\n            }\n\n            // If one is an enum, and they're not the same type, they're not identical\n            if ((t1.typeFlags & TypeFlags.IsEnum) || (t2.typeFlags & TypeFlags.IsEnum)) {\n                return false;\n            }\n\n            if (t1.isArray() || t2.isArray()) {\n                if (!(t1.isArray() && t2.isArray())) {\n                    return false;\n                }\n                this.identicalCache[comboId] = false;\n                var ret = this.typesAreIdentical(t1.elementType, t2.elementType);\n                if (ret) {\n                    this.subtypeCache[comboId] = true;\n                }\n                else {\n                    this.subtypeCache[comboId] = undefined;\n                }\n\n                return ret;\n            }\n\n            if (t1.primitiveTypeClass != t2.primitiveTypeClass) {\n                return false;\n            }\n\n            this.identicalCache[comboId] = false;\n\n            // properties are identical in na";
var v27505 = v27506 + "me, optionality, and type\n            // REVIEW: TypeChanges - The compiler does not currently check against the members of parent types!\n            // REVIEW: TypeChanges - What about ambientMembers?\n            if (t1.memberScope && t2.memberScope) {\n                var t1MemberKeys = t1.memberScope.getAllValueSymbolNames(true).sort();\n                var t2MemberKeys = t2.memberScope.getAllValueSymbolNames(true).sort();\n\n                if (t1MemberKeys.length != t2MemberKeys.length) {\n                    this.identicalCache[comboId] = undefined;\n                    return false;\n                }\n\n                var t1MemberSymbol: Symbol = null;\n                var t2MemberSymbol: Symbol = null;\n\n                var t1MemberType: Type = null;\n                var t2MemberType: Type = null;\n\n                for (var iMember = 0; iMember < t1MemberKeys.length; iMember++) {\n                    if (t1MemberKeys[iMember] != t2MemberKeys[iMember]) {\n                        this.identicalCache[comboId] = undefined;\n                        return false;\n                    }\n\n                    t1MemberSymbol = <Symbol>t1.memberScope.find(t1MemberKeys[iMember], false, false);\n                    t2MemberSymbol = <Symbol>t2.memberScope.find(t2MemberKeys[iMember], false, false);\n\n                    if ((t1MemberSymbol.flags & SymbolFlags.Optional) != (t2MemberSymbol.flags & SymbolFlags.Optional)) {\n                        this.identicalCache[comboId] = undefined;\n                        return false;\n                    }\n\n                    t1MemberType = t1MemberSymbol.getType();\n                    t2MemberType = t2MemberSymbol.getType();\n\n                    // catch the mutually recursive or cached cases\n                    if (t1MemberType && t2MemberType && (this.identicalCache[(t2MemberType.typeID << 16) | t1MemberType.typeID] != undefined)) {\n                        continue;\n                    }\n\n                    if (!this.typesAreIdentical(t1MemberType, t2MemberType)) {\n                        this.identicalCache[comboId] = undefined;\n                        return false;\n                    }\n                }\n            }\n            else if (t1.memberScope || t2.memberScope) {\n                this.identicalCache[comboId] = undefined;\n                return false;\n            }\n\n            if (!this.signatureGroupsAreIdentical(t1.call, t2.call)) {\n                this.identicalCache[comboId] = undefined;\n                return false;\n            }\n\n            if (!this.signatureGroupsAreIdentical(t1.construct, t2.construct)) {\n                this.identicalCache[comboId] = undefined;\n                return false;\n            }\n\n            if (!this.signatureGroupsAreIdentical(t1.index, t2.index)) {\n                this.identicalCache[comboId] = undefined;\n                return false;\n            }\n\n            this.identicalCache[comboId] = true;\n            return true;\n        }\n\n        public signatureGroupsAreIdentical(sg1: SignatureGroup, sg2: SignatureGroup) {\n\n            // covers the null case\n            if (sg1 == sg2) {\n                return true;\n            }\n\n            // covers the mixed-null case\n            if (!sg1 || !sg2) {\n                return false;\n            }\n\n            if (sg1.signatures.length != sg2.signatures.length) {\n                return false;\n            }\n\n            var sig1: Signature = null;\n            var sig2: Signature = null;\n            var sigsMatch = false;\n\n            // The signatures in the signature group may not be ordered...\n            // REVIEW: Should definition signatures be required to be identical as well?\n            for (var iSig1 = 0; iSig1 < sg1.signatures.length; iSig1++) {\n                sig1 = sg1.signatures[iSig1];\n\n                for (var iSig2 = 0; iSig2 < sg2.signatures.length; iSig2++) {\n                    sig2 = sg2.signatures[iSig2];\n\n                    if (this.signaturesAreIdentical(sig1, sig2)) {\n                        sigsMatch = true;\n                        break;\n                    }\n                }\n\n                if (sigsMatch) {\n                    sigsMatch = false;\n                    continue;\n                }\n\n                // no match found for a specific signature\n                return false;\n            }\n\n            return true;\n        }\n\n        public signaturesAreIdentical(s1: Signature, s2: Signature) {\n\n            if (s1.hasVariableArgList != s2.hasVariableArgList) {\n                return false;\n            }\n\n            if (s1.nonOptionalParameterCount != s2.nonOptionalParameterCount) {\n                return false;\n            }\n\n            if (s1.parameters.length != s2.parameters.length) {\n                return false;\n            }\n\n            if (!this.typesAreIdentical(s1.returnType.type, s2.returnType.type)) {\n                return false;\n            }\n\n            for (var iParam = 0; iParam < s1.parameters.length; iParam++) {\n                if (!thi";
var v27504 = v27505 + "s.typesAreIdentical(s1.parameters[iParam].parameter.typeLink.type, s2.parameters[iParam].parameter.typeLink.type)) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        // Subtyping and Assignment compatibility\n\n        public sourceIsSubtypeOfTarget(source: Type, target: Type, comparisonInfo?: TypeComparisonInfo) { return this.sourceIsRelatableToTarget(source, target, false, this.subtypeCache, comparisonInfo); }\n        public signatureGroupIsSubtypeOfTarget(sg1: SignatureGroup, sg2: SignatureGroup, comparisonInfo?: TypeComparisonInfo) { return this.signatureGroupIsRelatableToTarget(sg1, sg2, false, this.subtypeCache, comparisonInfo); }\n        public signatureIsSubtypeOfTarget(s1: Signature, s2: Signature, comparisonInfo?: TypeComparisonInfo) { return this.signatureIsRelatableToTarget(s1, s2, false, this.subtypeCache, comparisonInfo); }\n\n        public sourceIsAssignableToTarget(source: Type, target: Type, comparisonInfo?: TypeComparisonInfo) { return this.sourceIsRelatableToTarget(source, target, true, this.assignableCache, comparisonInfo); }\n        public signatureGroupIsAssignableToTarget(sg1: SignatureGroup, sg2: SignatureGroup, comparisonInfo?: TypeComparisonInfo) { return this.signatureGroupIsRelatableToTarget(sg1, sg2, true, this.assignableCache, comparisonInfo); }\n        public signatureIsAssignableToTarget(s1: Signature, s2: Signature, comparisonInfo?: TypeComparisonInfo) { return this.signatureIsRelatableToTarget(s1, s2, true, this.assignableCache, comparisonInfo); }\n\n        public sourceIsRelatableToTarget(source: Type, target: Type, assignableTo: bool, comparisonCache: any, comparisonInfo: TypeComparisonInfo) {\n\n            // REVIEW: Does this check even matter?\n            //if (this.typesAreIdentical(source, target)) {\n            //    return true;\n            //}\n            if (source == target) {\n                return true;\n            }\n\n            // An error has already been reported in this case\n            if (!(source && target)) {\n                return true;\n            }\n\n            var comboId = (source.typeID << 16) | target.typeID;\n\n            // In the case of a 'false', we want to short-circuit a recursive typecheck\n            if (comparisonCache[comboId] != undefined) {\n                return true;\n            }\n\n            // this is one difference between subtyping and assignment compatibility\n            if (assignableTo) {\n                if (source == this.anyType || target == this.anyType) {\n                    return true;\n                }\n            }\n            else {\n                // This is one difference between assignment compatibility and subtyping\n                if (target == this.anyType) {\n                    return true;\n                }\n            }\n\n            if (source == this.undefinedType) {\n                return true;\n            }\n\n            if ((source == this.nullType) && (target != this.undefinedType && target != this.voidType)) {\n                return true;\n            }\n\n            // REVIEW: enum types aren't explicitly covered in the spec\n            if (target == this.numberType && (source.typeFlags & TypeFlags.IsEnum)) {\n                return true;\n            }\n            if (source == this.numberType && (target.typeFlags & TypeFlags.IsEnum)) {\n                return true;\n            }\n            if ((source.typeFlags & TypeFlags.IsEnum) || (target.typeFlags & TypeFlags.IsEnum)) {\n                return false;\n            }\n\n            if (source.isArray() || target.isArray()) {\n                if (!(source.isArray() && target.isArray())) {\n                    return false;\n                }\n                comparisonCache[comboId] = false;\n                var ret = this.sourceIsRelatableToTarget(source.elementType, target.elementType, assignableTo, comparisonCache, comparisonInfo);\n                if (ret) {\n                    comparisonCache[comboId] = true;\n                }\n                else {\n                    comparisonCache[comboId] = undefined;\n                }\n\n                return ret;\n            }\n\n            // this check ensures that we only operate on object types from this point forward,\n            // since the checks involving primitives occurred above\n            if (source.primitiveTypeClass != target.primitiveTypeClass) {\n\n                if (target.primitiveTypeClass == Primitive.None) {\n                    if (source == this.numberType && this.typeFlow.numberInterfaceType) {\n                        source = this.typeFlow.numberInterfaceType;\n                    }\n                    else if (source == this.stringType && this.typeFlow.stringInterfaceType) {\n                        source = this.typeFlow.stringInterfaceType;\n                    }\n                    else if (source == this.booleanType && this.typeFlow.booleanInterfaceType) {\n                        source = this.typeFlow.booleanInterfaceType;\n           ";
var v27503 = v27504 + '         }\n                    else {\n                        return false;\n                    }\n                }\n                else {\n                    return false;\n                }\n            }\n\n            comparisonCache[comboId] = false;\n\n            if (source.hasBase(target)) {\n                comparisonCache[comboId] = true;\n                return true;\n            }\n\n            if (this.typeFlow.objectInterfaceType && target == this.typeFlow.objectInterfaceType) {\n                return true;\n            }\n\n            if (this.typeFlow.functionInterfaceType && (source.call || source.construct) && target == this.typeFlow.functionInterfaceType) {\n                return true;\n            }\n\n            // REVIEW: We should perhaps do this, though it wouldn\'t be quite right without generics support\n            //if (this.typeFlow.arrayInterfaceType && (source.index) && target == this.typeFlow.arrayInterfaceType) {\n            //    return true;\n            //}\n\n            // At this point, if the target is a class, but not the source or a parent of the source, bail\n            if (target.isClass() || target.isClassInstance()) {\n                comparisonCache[comboId] = undefined;\n                return false;\n            }\n\n            if (target.memberScope && source.memberScope) {\n                var mPropKeys = target.memberScope.getAllValueSymbolNames(true);\n                var mProp: Symbol = null;\n                var nProp: Symbol = null;\n                var mPropType: Type = null;\n                var nPropType: Type = null;\n                var inferenceSymbol: InferenceSymbol = null;\n\n                for (var iMProp = 0; iMProp < mPropKeys.length; iMProp++) {\n                    mProp = target.memberScope.find(mPropKeys[iMProp], false, false);\n                    nProp = source.memberScope.find(mPropKeys[iMProp], false, false);\n\n                    // methods do not have the "arguments" field\n                    if (mProp.name == "arguments" &&\n                        this.typeFlow.iargumentsInterfaceType &&\n                        (this.typeFlow.iargumentsInterfaceType.symbol.flags & SymbolFlags.CompilerGenerated) &&\n                        mProp.kind() == SymbolKind.Variable &&\n                        (<VariableSymbol>mProp).variable.typeLink.type == this.typeFlow.iargumentsInterfaceType) {\n                        continue;\n                    }\n\n                    if (mProp.isInferenceSymbol()) {\n                        inferenceSymbol = <InferenceSymbol>mProp;\n                        if (inferenceSymbol.typeCheckStatus == TypeCheckStatus.NotStarted) {\n                            // REVIEW: TypeChanges: Does this ever really happen?  Maybe for out-of-order typecheck?\n                            this.typeFlow.typeCheck(mProp.declAST);\n                        }\n                    }\n                    mPropType = mProp.getType();\n\n                    if (!nProp) {\n                        // If it\'s not present on the type in question, look for the property on \'Object\'\n                        if (this.typeFlow.objectInterfaceType) {\n                            nProp = this.typeFlow.objectInterfaceType.memberScope.find(mPropKeys[iMProp], false, false);\n                        }\n\n                        if (!nProp) {\n                            // Now, the property was not found on Object, but the type in question is a function, look\n                            // for it on function\n                            if (this.typeFlow.functionInterfaceType && (mPropType.call || mPropType.construct)) {\n                                nProp = this.typeFlow.functionInterfaceType.memberScope.find(mPropKeys[iMProp], false, false);\n                            }\n\n                            // finally, check to see if the property is optional\n                            if (!nProp) {\n                                if (!(mProp.flags & SymbolFlags.Optional)) {\n                                    comparisonCache[comboId] = undefined;\n                                    if (comparisonInfo) { // only surface the first error\n                                        comparisonInfo.flags |= TypeRelationshipFlags.RequiredPropertyIsMissing;\n                                        comparisonInfo.addMessageToFront("Type \'" + source.getTypeName() + "\' is missing property \'" + mPropKeys[iMProp] + "\' from type \'" + target.getTypeName() + "\'");\n                                    }\n                                    return false;\n                                }\n                                else {\n                                    continue;\n                                }\n                            }\n                        }\n                    }\n\n                    if (nProp.isInferenceSymbol()) {\n                        inferenceSymbol = <InferenceSymbol>nProp;\n                        if (inferenceSymbol.typeCheckStatus == TypeCheckStatus.NotStarted) {\n                            this.typeFlow.type';
var v27502 = v27503 + 'Check(nProp.declAST);\n                        }\n                    }\n\n\n                    nPropType = nProp.getType();\n\n                    // catch the mutually recursive or cached cases\n                    if (mPropType && nPropType && (comparisonCache[(nPropType.typeID << 16) | mPropType.typeID] != undefined)) {\n                        continue;\n                    }\n\n                    if (!this.sourceIsRelatableToTarget(nPropType, mPropType, assignableTo, comparisonCache, comparisonInfo)) {\n                        comparisonCache[comboId] = undefined;\n                        if (comparisonInfo) { // only surface the first error\n                            comparisonInfo.flags |= TypeRelationshipFlags.IncompatiblePropertyTypes;\n                            comparisonInfo.addMessageToFront("Types of property \'" + mProp.name + "\' of types \'" + source.getTypeName() + "\' and \'" + target.getTypeName() + "\' are incompatible");\n                        }\n                        return false;\n                    }\n                }\n            }\n\n            // check signature groups\n            if (source.call || target.call) {\n                if (!this.signatureGroupIsRelatableToTarget(source.call, target.call, assignableTo, comparisonCache, comparisonInfo)) {\n                    if (comparisonInfo) {\n                        if (source.call && target.call) {\n                            comparisonInfo.addMessageToFront("Call signatures of types \'" + source.getTypeName() + "\' and \'" + target.getTypeName() + "\' are incompatible");\n                        }\n                        else {\n                            var hasSig = target.call ? target.getTypeName() : source.getTypeName();\n                            var lacksSig = !target.call ? target.getTypeName() : source.getTypeName();\n                            comparisonInfo.setMessage("Type \'" + hasSig + "\' requires a call signature, but Type \'" + lacksSig + "\' lacks one");\n                        }\n                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleSignatures;\n                    }\n                    comparisonCache[comboId] = undefined;\n                    return false;\n                }\n            }\n\n            if (source.construct || target.construct) {\n                if (!this.signatureGroupIsRelatableToTarget(source.construct, target.construct, assignableTo, comparisonCache, comparisonInfo)) {\n                    if (comparisonInfo) {\n                        if (source.construct && target.construct) {\n                            comparisonInfo.addMessageToFront("Construct signatures of types \'" + source.getTypeName() + "\' and \'" + target.getTypeName() + "\' are incompatible");\n                        }\n                        else {\n                            var hasSig = target.construct ? target.getTypeName() : source.getTypeName();\n                            var lacksSig = !target.construct ? target.getTypeName() : source.getTypeName();\n                            comparisonInfo.setMessage("Type \'" + hasSig + "\' requires a construct signature, but Type \'" + lacksSig + "\' lacks one");\n                        }\n                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleSignatures;\n                    }\n                    comparisonCache[comboId] = undefined;\n                    return false;\n                }\n            }\n\n            if (target.index) {\n                var targetIndex = !target.index && this.typeFlow.objectInterfaceType ? this.typeFlow.objectInterfaceType.index : target.index;\n                var sourceIndex = !source.index && this.typeFlow.objectInterfaceType ? this.typeFlow.objectInterfaceType.index : source.index;\n\n                if (!this.signatureGroupIsRelatableToTarget(sourceIndex, targetIndex, assignableTo, comparisonCache, comparisonInfo)) {\n                    if (comparisonInfo) {\n                        comparisonInfo.addMessageToFront("Index signatures of types \'" + source.getTypeName() + "\' and \'" + target.getTypeName() + "\' are incompatible");\n                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleSignatures;\n                    }\n                    comparisonCache[comboId] = undefined;\n                    return false;\n                }\n            }\n\n            comparisonCache[comboId] = true;\n            return true;\n        }\n\n        // REVIEW: TypeChanges: Return an error context object so the user can get better diagnostic info\n        public signatureGroupIsRelatableToTarget(sourceSG: SignatureGroup, targetSG: SignatureGroup, assignableTo: bool, comparisonCache: any, comparisonInfo?: TypeComparisonInfo) {\n            if (sourceSG == targetSG) {\n                return true;\n            }\n\n            if (!(sourceSG && targetSG)) {\n                return false;\n            }\n\n            var mSig: Signature = null;\n            var nSig: Signature = null;\n            var foundMatch = false;\n\n            for (var iMSig = 0; ';
var v27501 = v27502 + 'iMSig < targetSG.signatures.length; iMSig++) {\n                mSig = targetSG.signatures[iMSig];\n\n                for (var iNSig = 0; iNSig < sourceSG.signatures.length; iNSig++) {\n                    nSig = sourceSG.signatures[iNSig];\n                    if (this.signatureIsRelatableToTarget(nSig, mSig, assignableTo, comparisonCache, comparisonInfo)) {\n                        foundMatch = true;\n                        break;\n                    }\n                }\n\n                if (foundMatch) {\n                    foundMatch = false;\n                    continue;\n                }\n                return false;\n            }\n\n            return true;\n        }\n\n        public signatureIsRelatableToTarget(sourceSig: Signature, targetSig: Signature, assignableTo: bool, comparisonCache: any, comparisonInfo?: TypeComparisonInfo) {\n\n            if (!sourceSig.parameters || !targetSig.parameters) {\n                return false;\n            }\n\n            var targetVarArgCount = targetSig.hasVariableArgList ? targetSig.nonOptionalParameterCount - 1 : targetSig.nonOptionalParameterCount;\n            var sourceVarArgCount = sourceSig.hasVariableArgList ? sourceSig.nonOptionalParameterCount - 1 : sourceSig.nonOptionalParameterCount;\n\n            if (sourceVarArgCount > targetVarArgCount && !targetSig.hasVariableArgList) {\n                if (comparisonInfo) {\n                    comparisonInfo.flags |= TypeRelationshipFlags.SourceSignatureHasTooManyParameters;\n                    comparisonInfo.addMessageToFront("Call signature expects " + targetVarArgCount + " or fewer parameters");\n                }\n                return false;\n            }\n\n            var sourceReturnType = sourceSig.returnType.type;\n            var targetReturnType = targetSig.returnType.type;\n\n            if (targetReturnType != this.voidType) {\n                if (!this.sourceIsRelatableToTarget(sourceReturnType, targetReturnType, assignableTo, comparisonCache, comparisonInfo)) {\n                    if (comparisonInfo) {\n                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleReturnTypes;\n                        // No need to print this one here - it\'s printed as part of the signature error in sourceIsRelatableToTarget\n                        //comparisonInfo.addMessageToFront("Incompatible return types: \'" + sourceReturnType.getTypeName() + "\' and \'" + targetReturnType.getTypeName() + "\'");\n                    }\n                    return false;\n                }\n            }\n\n            var len = (sourceVarArgCount < targetVarArgCount && sourceSig.hasVariableArgList) ? targetVarArgCount : sourceVarArgCount;\n            var sourceParamType: Type = null;\n            var targetParamType: Type = null;\n            var sourceParamName = "";\n            var targetParamName = "";\n\n            for (var iSource = 0, iTarget = 0; iSource < len; iSource++, iTarget++) {\n\n                if (!sourceSig.hasVariableArgList || iSource < sourceVarArgCount) {\n                    sourceParamType = (<ParameterSymbol>sourceSig.parameters[iSource]).parameter.typeLink.type;\n                    sourceParamName = (<ParameterSymbol>sourceSig.parameters[iSource]).parameter.symbol.name;\n                }\n                else if (iSource == sourceVarArgCount) {\n                    sourceParamType = (<ParameterSymbol>sourceSig.parameters[iSource]).parameter.typeLink.type;\n                    if (sourceParamType.elementType) {\n                        sourceParamType = sourceParamType.elementType;\n                    }\n                    sourceParamName = (<ParameterSymbol>sourceSig.parameters[iSource]).parameter.symbol.name;\n                }\n\n                if (iTarget < targetSig.parameters.length && iTarget < targetVarArgCount) {\n                    targetParamType = (<ParameterSymbol>targetSig.parameters[iTarget]).parameter.typeLink.type;\n                    targetParamName = (<ParameterSymbol>targetSig.parameters[iTarget]).parameter.symbol.name;\n                }\n                else if (targetSig.hasVariableArgList && iTarget == targetVarArgCount) {\n                    targetParamType = (<ParameterSymbol>targetSig.parameters[iTarget]).parameter.typeLink.type;\n                    if (targetParamType.elementType) {\n                        targetParamType = targetParamType.elementType;\n                    }\n                    targetParamName = (<ParameterSymbol>targetSig.parameters[iTarget]).parameter.symbol.name;\n                }\n\n                if (!(this.sourceIsRelatableToTarget(sourceParamType, targetParamType, assignableTo, comparisonCache, comparisonInfo) ||\n                        this.sourceIsRelatableToTarget(targetParamType, sourceParamType, assignableTo, comparisonCache, comparisonInfo))) {\n\n                    if (comparisonInfo) {\n                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleParameterTypes;\n                    }\n                    return false;\n                }\n            }\n   ';
var v27500 = v27501 + '         return true;\n        }\n    }\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class Continuation {\n        public exceptionBlock = -1;\n        constructor (public normalBlock: number) { }\n    }\n\n    function getBaseTypeLinks(bases: ASTList, baseTypeLinks: TypeLink[]) {\n        if (bases) {\n            var len = bases.members.length;\n            if (baseTypeLinks == null) {\n                baseTypeLinks = new TypeLink[];\n            }\n            for (var i = 0; i < len; i++) {\n                var baseExpr = bases.members[i];\n                var name = baseExpr;\n                var typeLink = new TypeLink();\n                typeLink.ast = name;\n                baseTypeLinks[baseTypeLinks.length] = typeLink;\n            }\n        }\n        return baseTypeLinks;\n    }\n\n    function getBases(type: Type, typeDecl: TypeDeclaration) {\n        type.extendsTypeLinks = getBaseTypeLinks(typeDecl.extendsList, type.extendsTypeLinks);\n        type.implementsTypeLinks = getBaseTypeLinks(typeDecl.implementsList, type.implementsTypeLinks);\n    }\n\n    function addPrototypeField(classType: Type, ast: AST, context: TypeCollectionContext) {\n        var field = new ValueLocation();\n        field.typeLink = new TypeLink();\n        field.typeLink.ast = ast;\n        field.typeLink.type = classType.instanceType;\n\n        var fieldSymbol =\n            new FieldSymbol("prototype", ast.minChar,\n                            context.checker.locationInfo.unitIndex, true, field);\n        fieldSymbol.flags |= (SymbolFlags.Property | SymbolFlags.BuiltIn);\n        field.symbol = fieldSymbol;\n        fieldSymbol.declAST = ast;\n        classType.members.addPublicMember("prototype", fieldSymbol);\n    }\n\n    export function createNewConstructGroupForType(type: Type) {\n        var signature = new Signature();\n        signature.returnType = new TypeLink();\n        signature.returnType.type = type.instanceType;\n        signature.parameters = [];\n\n        type.construct = new SignatureGroup();\n        type.construct.addSignature(signature);     \n    }\n\n    export function cloneParentConstructGroupForChildType(child: Type, parent: Type) {\n        child.construct = new SignatureGroup();\n        var sig: Signature = null;\n\n        if (!parent.construct) {\n            createNewConstructGroupForType(parent);\n        }\n\n        for (var i = 0; i < parent.construct.signatures.length; i++) { \n            sig = new Signature();\n            sig.parameters = parent.construct.signatures[i].parameters;\n            sig.nonOptionalParameterCount = parent.construct.signatures[i].nonOptionalParameterCount;\n            sig.typeCheckStatus = parent.construct.signatures[i].typeCheckStatus;\n            sig.declAST = parent.construct.signatures[i].declAST;\n            sig.returnType = new TypeLink();\n            sig.returnType.type = child.instanceType;\n            child.construct.addSignature(sig);\n        }\n\n    }\n\n    export var globalId = "__GLO";\n\n    export interface IAliasScopeContext {\n        topLevelScope: ScopeChain;\n        members: IHashTable;\n        tcContext: TypeCollectionContext;\n    }\n\n    function findTypeSymbolInScopeChain(name: string, scopeChain: ScopeChain): Symbol {\n        var symbol = scopeChain.scope.find(name, false, true);\n\n        if (symbol == null && scopeChain.previous) {\n            symbol = findTypeSymbolInScopeChain(name, scopeChain.previous);\n        }\n\n        return symbol;\n    }\n\n    function findSymbolFromAlias(alias: AST, context: IAliasScopeContext): Symbol {\n        var symbol: Symbol = null;\n        switch (alias.nodeType) {\n            case NodeType.Name:\n                var name = (<Identifier>alias).text;\n                var isDynamic = isQuoted(name);\n\n                var findSym = (id: string) => {\n                    if (context.members) {\n                        return context.members.lookup(name);\n                    }\n                    else {\n                        return findTypeSymbolInScopeChain(name, context.topLevelScope);\n                    }\n                }\n\n                if (isDynamic) {\n                    symbol = context.tcContext.checker.findSymbolForDynamicModule(name, context.tcContext.script.locationInfo.filename, findSym);\n                }\n                else {\n                    symbol = findSym(name);\n                }\n\n                break;\n\n     ';
var v27499 = v27500 + "       case NodeType.Dot:\n                var dottedExpr = <BinaryExpression>alias;\n                var op1Sym = findSymbolFromAlias(dottedExpr.operand1, context);\n\n                if (op1Sym && op1Sym.getType()) {\n                    symbol = findSymbolFromAlias(dottedExpr.operand2, context);\n                }\n\n                break;\n\n            default:\n                break;\n        }\n\n        if (symbol) {\n            var symType = symbol.getType();\n            if (symType) {\n                var members = symType.members;\n                if (members) {\n                    context.members = members.publicMembers;\n                }\n            }\n        }\n\n        return symbol;\n    }\n\n    export function preCollectImportTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n        var typeSymbol: TypeSymbol = null;\n        var modType: ModuleType = null;\n        var importDecl = <ImportDeclaration>ast;\n\n        // REVIEW: technically, this call isn't strictly necessary, since we'll find the type during the call to resolveTypeMembers\n        var aliasedModSymbol = findSymbolFromAlias(importDecl.alias, { topLevelScope: scopeChain, members: null, tcContext: context });\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\n\n        if (aliasedModSymbol) {\n            var aliasedModType = aliasedModSymbol.getType();\n\n            if (aliasedModType) {\n                modType = <ModuleType>aliasedModType;\n            }\n        }\n\n        typeSymbol = new TypeSymbol(importDecl.id.text, importDecl.id.minChar, importDecl.limChar - importDecl.minChar,\n                                    context.checker.locationInfo.unitIndex, modType);\n\n        typeSymbol.aliasLink = importDecl;\n\n        if (context.scopeChain.moduleDecl) {\n            typeSymbol.flags |= SymbolFlags.ModuleMember;\n            typeSymbol.declModule = context.scopeChain.moduleDecl;\n        }\n\n        typeSymbol.declAST = importDecl;\n        importDecl.id.sym = typeSymbol;\n        scopeChain.scope.enter(scopeChain.container, ast, typeSymbol,\n                                context.checker.errorReporter, isGlobal, true, false);\n        scopeChain.scope.enter(scopeChain.container, ast, typeSymbol,\n                                context.checker.errorReporter, isGlobal, false, false);\n        return true;\n    }\n\n    export function preCollectModuleTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n\n        var moduleDecl: ModuleDeclaration = <ModuleDeclaration>ast;\n\n        var isAmbient = hasFlag(moduleDecl.modFlags, ModuleFlags.Ambient);\n        var isEnum = hasFlag(moduleDecl.modFlags, ModuleFlags.IsEnum);\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\n        var isExported = hasFlag(moduleDecl.modFlags, ModuleFlags.Exported);\n        var modName = (<Identifier>moduleDecl.name).text;\n\n        var isDynamic = isQuoted(modName);\n\n        var symbol = scopeChain.scope.findLocal(modName, false, false);\n        var typeSymbol: TypeSymbol = null;\n        var modType: ModuleType = null;\n        if ((symbol == null) || (symbol.kind() != SymbolKind.Type)) {\n\n            if (modType == null) {\n                var enclosedTypes = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                var ambientEnclosedTypes = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                modType = new ModuleType(enclosedTypes, ambientEnclosedTypes);\n                if (isEnum) {\n                    modType.typeFlags |= TypeFlags.IsEnum;\n                }\n                modType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                modType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                modType.setHasImplementation();\n            }\n\n            typeSymbol = new TypeSymbol(modName, moduleDecl.name.minChar, modName.length,\n                                        context.checker.locationInfo.unitIndex, modType);\n            typeSymbol.isDynamic = isQuoted(moduleDecl.prettyName);\n\n            if (context.scopeChain.moduleDecl) {\n                typeSymbol.declModule = context.scopeChain.moduleDecl;\n            }\n            typeSymbol.declAST = moduleDecl;\n            typeSymbol.prettyName = moduleDecl.prettyName;\n            scopeChain.scope.enter(scopeChain.container, ast, typeSymbol,\n                                    context.checker.errorReporter, isExported || isGlobal, true, isAmbient);\n            scopeChain.scope.enter(scopeChain.container, ast, typeSymbol,\n                                    context.checker.errorReporter, isExported || isGlobal, false, isAmbient);\n            modType.symbol = typeSymbol;\n        }\n        else {\n            if (symbol && symbol.declAST && symbol.";
var v27498 = v27499 + "declAST.nodeType != NodeType.ModuleDeclaration) {\n                context.checker.errorReporter.simpleError(moduleDecl, \"Conflicting symbol name for module '\" + modName + \"'\");\n            }\n            typeSymbol = <TypeSymbol>symbol;\n\n            // initialize new private scope for the type\n            var publicEnclosedTypes = typeSymbol.type.getAllEnclosedTypes().publicMembers;\n            var publicEnclosedTypesTable = (publicEnclosedTypes == null) ? new StringHashTable() : publicEnclosedTypes;\n            var enclosedTypes = new ScopedMembers(new DualStringHashTable(publicEnclosedTypesTable, new StringHashTable()));\n\n            var publicEnclosedAmbientTypes = typeSymbol.type.getAllAmbientEnclosedTypes().publicMembers;\n            var publicAmbientEnclosedTypesTable = (publicEnclosedAmbientTypes == null) ? new StringHashTable() : publicEnclosedAmbientTypes;\n            var ambientEnclosedTypes = new ScopedMembers(new DualStringHashTable(publicAmbientEnclosedTypesTable, new StringHashTable()));\n\n            var publicMembers = typeSymbol.type.members.publicMembers;\n            var publicMembersTable = (publicMembers == null) ? new StringHashTable() : publicMembers;\n            var members = new ScopedMembers(new DualStringHashTable(publicMembersTable, new StringHashTable()));\n\n            var publicAmbientMembers = typeSymbol.type.ambientMembers.publicMembers;\n            var publicAmbientMembersTable = (publicAmbientMembers == null) ? new StringHashTable() : publicAmbientMembers;\n            var ambientMembers = new ScopedMembers(new DualStringHashTable(publicAmbientMembersTable, new StringHashTable()));\n\n            modType = new ModuleType(enclosedTypes, ambientEnclosedTypes);\n            if (isEnum) {\n                modType.typeFlags |= TypeFlags.IsEnum;\n            }\n            modType.members = members;\n            modType.ambientMembers = ambientMembers;\n            modType.setHasImplementation();\n            modType.symbol = typeSymbol;\n\n            typeSymbol.addLocation(moduleDecl.minChar);\n            typeSymbol.expansions.push(modType);\n            typeSymbol.expansionsDeclAST.push(moduleDecl);\n\n        }\n        if (context.scopeChain.moduleDecl) {\n            context.scopeChain.moduleDecl.recordNonInterface();\n        }\n        // REVIEW: If multiple disparate module decls for the same module don't agree\n        // in export privileges, how should we handle it?\n        if (isExported) {\n            typeSymbol.flags |= SymbolFlags.Exported;\n        }\n        if ((context.scopeChain.moduleDecl) ||\n            (context.scopeChain.container == context.checker.gloMod)) {\n            typeSymbol.flags |= SymbolFlags.ModuleMember;\n        }\n\n        moduleDecl.mod = modType;\n        pushTypeCollectionScope(typeSymbol, modType.members,\n                                modType.ambientMembers,\n                                modType.enclosedTypes,\n                                modType.ambientEnclosedTypes,\n                                context, null, null, moduleDecl);\n\n        return true;\n    }\n\n    export function preCollectClassTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n        var classDecl = <ClassDeclaration>ast;\n\n        var classType: Type;\n        var instanceType: Type;\n        var typeSymbol: TypeSymbol = null;\n        var className = (<Identifier>classDecl.name).text;\n        var alreadyInScope = false;\n        var isAmbient = hasFlag(classDecl.varFlags, VarFlags.Ambient);\n        var isExported = hasFlag(classDecl.varFlags, VarFlags.Exported);\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\n        var containerMod = <TypeSymbol>scopeChain.container;\n        var foundValSymbol = false;\n\n        typeSymbol = <TypeSymbol>scopeChain.scope.findLocal(className, false, true);\n        \n        // check the value space, since an override may have been declared with the type's name\n        // REVIEW-CLASSES\n        if (!typeSymbol) {\n            var valTypeSymbol = scopeChain.scope.findLocal(className, false, false);\n            \n            if (valTypeSymbol &&\n                valTypeSymbol.isType() &&\n                valTypeSymbol.declAST &&\n                valTypeSymbol.declAST.nodeType == NodeType.FuncDecl &&\n                (<FuncDecl>valTypeSymbol.declAST).isSignature()) {\n                \n                typeSymbol = <TypeSymbol>valTypeSymbol;\n                foundValSymbol = true;\n                \n                if (isExported) {\n                    typeSymbol.flags |= SymbolFlags.Exported;\n                }\n            \n                if (isAmbient) {\n                    typeSymbol.flags |= SymbolFlags.Ambient;\n                }                \n                \n                // the class was never entered into type space, so add it\n                context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol,\n                                            context.checke";
var v27497 = v27498 + "r.errorReporter, isExported || isGlobal, true, isAmbient);                \n            }\n        }\n        \n        if (typeSymbol && !foundValSymbol && (typeSymbol.declAST != classDecl)) {\n            typeSymbol = null;\n        }\n\n        if (typeSymbol == null) {\n            var valueSymbol = scopeChain.scope.findLocal(className, false, false);\n            classType = new Type();\n            classType.setHasImplementation();\n            instanceType = new Type();\n            instanceType.setHasImplementation();\n            classType.instanceType = instanceType;\n            classType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            classType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            addPrototypeField(classType, classDecl, context);\n            instanceType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            instanceType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            typeSymbol = new TypeSymbol(className, classDecl.name.minChar, className.length,\n                                        context.checker.locationInfo.unitIndex, classType);\n            typeSymbol.declAST = classDecl;\n            typeSymbol.instanceType = instanceType;\n            classType.symbol = typeSymbol;\n            instanceType.symbol = typeSymbol;\n\n            if (context.scopeChain.moduleDecl) {\n                context.scopeChain.moduleDecl.recordNonInterface();\n                typeSymbol.declModule = context.scopeChain.moduleDecl;\n                typeSymbol.flags |= SymbolFlags.ModuleMember;\n            }\n\n            if (isExported) {\n                typeSymbol.flags |= SymbolFlags.Exported;\n            }\n            \n            if (isAmbient) {\n                typeSymbol.flags |= SymbolFlags.Ambient;\n            }\n\n            ast.type = classType;\n\n            // class in both name spaces (type for instance type; constructor representative in value space)\n            context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol,\n                                            context.checker.errorReporter, isExported || isGlobal, true, isAmbient);\n\n            if (valueSymbol == null) {\n                context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol,\n                                            context.checker.errorReporter, isExported || isGlobal, false, isAmbient);\n            }\n        }\n        else {                            \n            classType = typeSymbol.type;\n            \n            // If the instance type is null, a call overload was likely declared before the class constructor\n            if (classType.instanceType == null) {\n                classType.instanceType = new Type();\n                classType.instanceType.setHasImplementation();\n                classType.instanceType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                classType.instanceType.symbol = classType.symbol;\n                classType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                classType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            }\n            \n            instanceType = classType.instanceType;\n            ast.type = classType;\n        }\n        \n        // if the class has no declared constructor, either create a default signature or adapt \n        // it's base class's signature group\n        if (!classDecl.constructorDecl) {\n\n            if (typeSymbol && typeSymbol.declAST && typeSymbol.declAST.type && typeSymbol.declAST.type.call && !(<FuncDecl>typeSymbol.declAST).isOverload) {\n                context.checker.errorReporter.duplicateIdentifier(typeSymbol.declAST, typeSymbol.name);\n            }\n\n            createNewConstructGroupForType(classDecl.type);\n        }\n\n        classType.typeFlags |= TypeFlags.IsClass;\n        instanceType.typeFlags |= TypeFlags.IsClass;\n\n        getBases(instanceType, classDecl);\n        pushTypeCollectionScope(typeSymbol, instanceType.members, instanceType.ambientMembers, null, null,\n                                context, instanceType, classType, null);\n        return true;\n    }\n\n    export function preCollectInterfaceTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n        var interfaceDecl = <InterfaceDeclaration>ast;\n        var interfaceSymbol: TypeSymbol = null;\n        var interfaceType: Type = null;\n        var isExported = hasFlag(interfaceDecl.varFlags, VarFlags.Exported);\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\n        var alreadyInScope = true;\n\n        alreadyInScope = false;\n        var ";
var v27496 = v27497 + 'interfaceName = (<Identifier>interfaceDecl.name).text;\n        interfaceSymbol = <TypeSymbol>scopeChain.scope.findLocal(interfaceName, false, true);\n        if (interfaceSymbol == null) {\n            interfaceType = new Type();\n            interfaceSymbol = new TypeSymbol(interfaceName,\n                                        interfaceDecl.name.minChar,\n                                        interfaceName.length,\n                                        context.checker.locationInfo.unitIndex,\n                                        interfaceType);\n            interfaceType.symbol = interfaceSymbol;\n            // REVIEW: Shouldn\'t allocate another table for interface privates\n            interfaceType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            interfaceType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            interfaceSymbol.declAST = interfaceDecl;\n            interfaceSymbol.declModule = context.scopeChain.moduleDecl;\n        }\n        else {\n            alreadyInScope = true;\n            interfaceType = interfaceSymbol.type;\n        }\n\n        if (!interfaceType) {\n            interfaceType = context.checker.anyType;\n        }\n\n        ast.type = interfaceType;\n        getBases(interfaceType, interfaceDecl);\n\n        if (isExported) {\n            interfaceSymbol.flags |= SymbolFlags.Exported;\n        }\n\n        if (context.scopeChain.moduleDecl) {\n            interfaceSymbol.flags |= SymbolFlags.ModuleMember;\n        }\n\n        if (!alreadyInScope) {\n            context.scopeChain.scope.enter(context.scopeChain.container, ast,\n                                            interfaceSymbol, context.checker.errorReporter, isGlobal || isExported, true, false); // REVIEW: Technically, interfaces should be ambient\n        }\n        pushTypeCollectionScope(interfaceSymbol, interfaceType.members, interfaceType.ambientMembers, null, null,\n                                context, interfaceType, null, null);\n        return true;\n    }\n\n    export function preCollectArgDeclTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n        var argDecl = <ArgDecl>ast;\n        if (hasFlag(argDecl.varFlags, VarFlags.Public | VarFlags.Private)) {\n            var field = new ValueLocation();\n            var isPrivate = hasFlag(argDecl.varFlags, VarFlags.Private);\n            var fieldSymbol =\n                new FieldSymbol(argDecl.id.text, argDecl.id.minChar,\n                                context.checker.locationInfo.unitIndex,\n                                !hasFlag(argDecl.varFlags, VarFlags.Readonly),\n                                field);\n            fieldSymbol.transferVarFlags(argDecl.varFlags);\n            field.symbol = fieldSymbol;\n            fieldSymbol.declAST = ast;\n            argDecl.parameterPropertySym = fieldSymbol;\n\n            context.scopeChain.scope.enter(context.scopeChain.container, ast,\n                                            fieldSymbol, context.checker.errorReporter, !isPrivate, false, false);\n\n            field.typeLink = getTypeLink(argDecl.typeExpr, context.checker, argDecl.init == null);\n            argDecl.sym = fieldSymbol;\n        }\n        return false;\n    }\n\n    export function preCollectVarDeclTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n        var varDecl = <VarDecl>ast;\n        var isAmbient = hasFlag(varDecl.varFlags, VarFlags.Ambient);\n        var isExported = hasFlag(varDecl.varFlags, VarFlags.Exported);\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\n        var isProperty = hasFlag(varDecl.varFlags, VarFlags.Property);\n        var isStatic = hasFlag(varDecl.varFlags, VarFlags.Static);\n        var isPrivate = hasFlag(varDecl.varFlags, VarFlags.Private);\n        var isOptional = hasFlag(varDecl.id.flags, ASTFlags.OptionalName);\n\n        if (context.scopeChain.moduleDecl) {\n            context.scopeChain.moduleDecl.recordNonInterface();\n        }\n        if (isProperty ||\n            isExported ||\n            (context.scopeChain.container == context.checker.gloMod) ||\n            context.scopeChain.moduleDecl) {\n            if (isAmbient) {\n                var existingSym =\n                    <FieldSymbol>scopeChain.scope.findLocal(varDecl.id.text, false, false);\n                if (existingSym) {\n                    varDecl.sym = existingSym;\n                    return false;\n                }\n            }\n\n            // Defensive error detection...\n            if (varDecl.id == null) {\n                context.checker.errorReporter.simpleError(varDecl, "Expected variable identifier at this location");\n                return false;\n            }\n\n            var field = new ValueLocation();\n            var fieldSymbol =\n                new FieldSymbol(varDecl.id.text, varDecl.id.minChar,\n         ';
var v27495 = v27496 + '                       context.checker.locationInfo.unitIndex,\n                                (varDecl.varFlags & VarFlags.Readonly) == VarFlags.None,\n                                field);\n            fieldSymbol.transferVarFlags(varDecl.varFlags);\n            if (isOptional) {\n                fieldSymbol.flags |= SymbolFlags.Optional;\n            }\n            field.symbol = fieldSymbol;\n            fieldSymbol.declAST = ast;\n            if ((context.scopeChain.moduleDecl) ||\n                (context.scopeChain.container == context.checker.gloMod)) {\n                fieldSymbol.flags |= SymbolFlags.ModuleMember;\n                fieldSymbol.declModule = context.scopeChain.moduleDecl;\n            }\n\n            // if it\'s static, enter it into the class\'s member list directly\n            if (hasFlag(varDecl.varFlags, VarFlags.Property) && isStatic && context.scopeChain.classType) {\n                if (!context.scopeChain.classType.members.publicMembers.add(varDecl.id.text, fieldSymbol)) {\n                    context.checker.errorReporter.duplicateIdentifier(ast, fieldSymbol.name);\n                }\n                fieldSymbol.container = context.scopeChain.classType.symbol;\n            }\n            else {\n                context.scopeChain.scope.enter(context.scopeChain.container,\n                                                ast,\n                                                fieldSymbol,\n                                                context.checker.errorReporter,\n                                                !isPrivate && (isProperty || isExported || isGlobal || isStatic),\n                                                false,\n                                                isAmbient);\n            }\n\n            if (hasFlag(varDecl.varFlags, VarFlags.Exported)) {\n                fieldSymbol.flags |= SymbolFlags.Exported;\n            }\n\n            field.typeLink = getTypeLink(varDecl.typeExpr, context.checker,\n                                        varDecl.init == null);\n            varDecl.sym = fieldSymbol;\n        }\n        return false;\n    }\n\n    export function preCollectFuncDeclTypes(ast: AST, parent: AST, context: TypeCollectionContext) {\n        var scopeChain = context.scopeChain;\n\n        // REVIEW: This will have to change when we move to "export"\n        if (context.scopeChain.moduleDecl) {\n            context.scopeChain.moduleDecl.recordNonInterface();\n        }\n\n        var funcDecl = <FuncDecl>ast;\n        var fgSym: TypeSymbol = null;\n        var nameText = funcDecl.getNameText();\n        var isExported = hasFlag(funcDecl.fncFlags, FncFlags.Exported | FncFlags.ClassPropertyMethodExported);\n        var isStatic = hasFlag(funcDecl.fncFlags, FncFlags.Static);\n        var isPrivate = hasFlag(funcDecl.fncFlags, FncFlags.Private);\n        var isConstructor = funcDecl.isConstructMember() || funcDecl.isConstructor;\n        var containerSym:TypeSymbol = <TypeSymbol> (((funcDecl.isMethod() && isStatic) || funcDecl.isAccessor()) && context.scopeChain.classType ? context.scopeChain.classType.symbol : context.scopeChain.container);\n        var containerScope: SymbolScope = context.scopeChain.scope;\n        var isGlobal = containerSym == context.checker.gloMod;\n        var isOptional = funcDecl.name && hasFlag(funcDecl.name.flags, ASTFlags.OptionalName);\n        var go = false;\n        var foundSymbol = false; \n\n        // If this is a class constructor, the "container" is actually the class declaration\n        if (isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {\n            containerSym = <TypeSymbol>containerSym.container;\n            containerScope = scopeChain.previous.scope;\n        }\n\n        funcDecl.unitIndex = context.checker.locationInfo.unitIndex;\n        \n        // If the parent is the constructor, and this isn\'t an instance method, skip it.\n        // That way, we\'ll set the type during scope assignment, and can be sure that the\n        // function will be placed in the constructor-local scope\n        if (!funcDecl.isConstructor &&\n            containerSym &&\n            containerSym.declAST &&\n            containerSym.declAST.nodeType == NodeType.FuncDecl &&\n            (<FuncDecl>containerSym.declAST).isConstructor &&\n            !funcDecl.isMethod()) {\n            return go;\n        }        \n\n        // Interfaces and overloads\n        if (hasFlag(funcDecl.fncFlags, FncFlags.Signature)) {\n            var instType = context.scopeChain.thisType;                       \n\n            // If the function is static, search in the class type\'s\n            if (nameText && nameText != "__missing") {\n                if (isStatic) {\n                    fgSym = containerSym.type.members.allMembers.lookup(nameText);\n                }\n                else {\n                    // REVIEW: This logic should be symmetric with preCollectClassTypes\n                    fgSym = <TypeSymbol>containerScope.findLocal(nameText, false, false);\n                    \n                 ';
var v27494 = v27495 + "   // If we could not find the function symbol in the value context, look\n                    // in the type context.\n                    // This would be the case, for example, if a class constructor override\n                    // were declared before a call override for a given class\n                    if (fgSym == null) {\n                        fgSym = <TypeSymbol>containerScope.findLocal(nameText, false, true);\n                    }\n                }\n                \n                if (fgSym) {\n                    foundSymbol = true;\n                    \n                    // We'll combine ambient and non-ambient funcdecls during typecheck (for contextual typing).,\n                    // So, if they don't agree, don't use the symbol we've found                    \n                    if (!funcDecl.isSignature() && (hasFlag(funcDecl.fncFlags, FncFlags.Ambient) != hasFlag(fgSym.flags, SymbolFlags.Ambient))) {\n                       fgSym = null;\n                    }\n                }                \n            }\n            \n            // a function with this symbol has not yet been declared in this scope\n            // REVIEW: In the code below, we need to ensure that only function overloads are considered\n            //  (E.g., if a vardecl has the same id as a function or class, we may use the vardecl symbol\n            //  as the overload.)  Defensively, however, the vardecl won't have a type yet, so it should\n            //  suffice to just check for a null type when considering the overload symbol in\n            //  createFunctionSignature\n            if (fgSym == null) {\n                if (!(funcDecl.isSpecialFn())) {                    \n                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, null, !foundSymbol).declAST.type.symbol;\n                }\n                else {\n                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, containerSym, false).declAST.type.symbol;                                                                         \n                }\n                \n                // set the symbol's declAST, which will point back to the first declaration (symbol or otherwise)\n                // related to this symbol\n                if (fgSym.declAST == null || !funcDecl.isSpecialFn()) {\n                    fgSym.declAST = ast;\n                }\n            }\n            else { // there exists a symbol with this name\n                \n                if ((fgSym.kind() == SymbolKind.Type)) {\n\n                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, fgSym, false).declAST.type.symbol;\n                }\n                else {\n                    context.checker.errorReporter.simpleError(funcDecl, \"Function or method '\" + funcDecl.name.actualText + \"' already declared as a property\");\n                }\n            }\n         \n            if (funcDecl.isSpecialFn() && !isStatic) {\n                funcDecl.type = instType ? instType : fgSym.type; \n            }\n            else {\n                funcDecl.type = fgSym.type;\n            }            \n        }\n        else {\n            // declarations\n            \n            if (nameText) {\n                if (isStatic) {\n                    fgSym = containerSym.type.members.allMembers.lookup(nameText);\n                }\n                else {\n                    // in the constructor case, we want to check the parent scope for overloads\n                    if (funcDecl.isConstructor && context.scopeChain.previous) {\n                        fgSym = <TypeSymbol>context.scopeChain.previous.scope.findLocal(nameText, false, false);\n                    }\n                    \n                    if (fgSym == null) {\n                        fgSym = <TypeSymbol>containerScope.findLocal(nameText, false, false);\n                    }\n                }\n                if (fgSym) {\n                    foundSymbol = true;\n                    \n                    if (!isConstructor && fgSym.declAST.nodeType == NodeType.FuncDecl && !(<FuncDecl>fgSym.declAST).isAccessor() && !(<FuncDecl>fgSym.declAST).isSignature()) {\n                        fgSym = null;\n                        foundSymbol = false;\n                    }\n                }                \n            }\n\n            // REVIEW: Move this check into the typecheck phase?  It's only being run over properties...\n            if (fgSym &&\n                !fgSym.isAccessor() &&\n                fgSym.type &&\n                fgSym.type.construct &&\n                fgSym.type.construct.signatures != [] &&\n                (fgSym.type.construct.signatures[0].declAST == null ||\n                    !hasFlag(fgSym.type.construct.signatures[0].declAST.fncFlags, FncFlags.Ambient)) &&\n                !funcDecl.isConstructor) {\n                context.checker.errorReporter.simpleError(funcDecl, \"Functions may not have class overloads\");\n            }\n\n   ";
var v27493 = v27494 + '         if (fgSym && !(fgSym.kind() == SymbolKind.Type) && funcDecl.isMethod() && !funcDecl.isAccessor() && !funcDecl.isConstructor) {\n                context.checker.errorReporter.simpleError(funcDecl, "Function or method \'" + funcDecl.name.actualText + "\' already declared as a property");\n                fgSym.type = context.checker.anyType;\n            }\n            var sig = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, fgSym, !foundSymbol);\n\n            // it\'s a getter or setter function                                   \n            if (((!fgSym || fgSym.declAST.nodeType != NodeType.FuncDecl) && funcDecl.isAccessor()) || (fgSym && fgSym.isAccessor())) {\n                funcDecl.accessorSymbol = context.checker.createAccessorSymbol(funcDecl, fgSym, containerSym.type, (funcDecl.isMethod() && isStatic), true, containerScope, containerSym);\n            }\n\n            funcDecl.type.symbol.declAST = ast;\n            if (funcDecl.isConstructor) { // REVIEW: Remove when classes completely replace oldclass\n                go = true;\n            };\n        }\n        if (isExported) {\n            if (funcDecl.type.call) {\n                funcDecl.type.symbol.flags |= SymbolFlags.Exported;\n            }\n            \n            // Accessors are set to \'exported\' above\n            if (fgSym && !fgSym.isAccessor() && fgSym.kind() == SymbolKind.Type && fgSym.type.call) {\n                fgSym.flags |= SymbolFlags.Exported;\n            }\n        }\n        if (context.scopeChain.moduleDecl && !funcDecl.isSpecialFn()) {\n            funcDecl.type.symbol.flags |= SymbolFlags.ModuleMember;\n            funcDecl.type.symbol.declModule = context.scopeChain.moduleDecl;\n        }\n\n        if (fgSym && isOptional) {\n            fgSym.flags |= SymbolFlags.Optional;\n        }\n\n        return go;\n    }\n\n    export function preCollectTypes(ast: AST, parent: AST, walker: IAstWalker) {\n        var context: TypeCollectionContext = walker.state;\n        var go = false;\n        var scopeChain = context.scopeChain;\n\n        if (ast.nodeType == NodeType.Script) {\n            var script: Script = <Script>ast;\n            context.script = script;\n            go = true;\n        }\n        else if (ast.nodeType == NodeType.List) {\n            go = true;\n        }\n        else if (ast.nodeType == NodeType.ImportDeclaration) {\n            go = preCollectImportTypes(ast, parent, context);\n        }\n        else if (ast.nodeType == NodeType.With) {\n            go = false;\n        }\n        else if (ast.nodeType == NodeType.ModuleDeclaration) {\n            go = preCollectModuleTypes(ast, parent, context);\n        }\n        else if (ast.nodeType == NodeType.ClassDeclaration) {\n            go = preCollectClassTypes(ast, parent, context);\n        }\n        else if (ast.nodeType == NodeType.Block) {\n            go = true;\n        }\n        else if (ast.nodeType == NodeType.InterfaceDeclaration) {\n            go = preCollectInterfaceTypes(ast, parent, context);\n        }\n        // This will be a constructor arg because this pass only traverses\n        // constructor arg lists\n        else if (ast.nodeType == NodeType.ArgDecl) {\n            go = preCollectArgDeclTypes(ast, parent, context);\n        }\n        else if (ast.nodeType == NodeType.VarDecl) {\n            go = preCollectVarDeclTypes(ast, parent, context);\n        }\n        else if (ast.nodeType == NodeType.FuncDecl) {\n            go = preCollectFuncDeclTypes(ast, parent, context);\n        }\n        else {\n            if (ast.isStatementOrExpression() && context.scopeChain.moduleDecl) {\n                context.scopeChain.moduleDecl.recordNonInterface();\n            }\n        }\n        walker.options.goChildren = go;\n        return ast;\n    }\n\n    export function postCollectTypes(ast: AST, parent: AST, walker: IAstWalker) {\n        var context: TypeCollectionContext = walker.state;\n\n        if (ast.nodeType == NodeType.ModuleDeclaration) {\n            popTypeCollectionScope(context);\n        }\n        else if (ast.nodeType == NodeType.ClassDeclaration) {\n            popTypeCollectionScope(context);\n        }\n        else if (ast.nodeType == NodeType.InterfaceDeclaration) {\n            popTypeCollectionScope(context);\n        }\n        return ast;\n    }\n\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n    export class ScopeChain {\n        ';
var v27492 = v27493 + "public thisType: Type;\n        public classType: Type;\n        public fnc: FuncDecl;\n        public moduleDecl: ModuleDeclaration;\n\n        constructor (public container: Symbol, public previous: ScopeChain,\n                     public scope: SymbolScope) { }\n    }\n\n    export class BBUseDefInfo {\n        public defsBySymbol = new bool[];\n        public gen: BitVector;\n        public kill: BitVector;\n        public top: BitVector;\n        // use lists by symbol \n        public useIndexBySymbol = new number[][];\n\n        constructor (public bb: BasicBlock) { }\n\n        public updateTop() {\n            var temp = new BitVector(this.top.bitCount);\n            for (var i = 0, succLen = this.bb.successors.length; i < succLen; i++) {\n                var succ = this.bb.successors[i];\n                if (succ.useDef) {\n                    temp.union(succ.useDef.top);\n                }\n            }\n            temp.difference(this.kill);\n            temp.union(this.gen);\n            var changed = temp.notEq(this.top);\n            this.top = temp;\n            return changed;\n        }\n\n\n        public initialize(useDefContext: UseDefContext) {\n            var defSym = (sym: Symbol, context: UseDefContext) => {\n                if (context.isLocalSym(sym)) {\n                    var index = context.getSymbolIndex(sym);\n                    // clear pending uses\n                    this.useIndexBySymbol[index] = new number[];\n                    this.defsBySymbol[index] = true;\n                }\n            }\n\n            var useSym = (sym: Symbol, context: UseDefContext, ast: AST) => {\n                if (context.isLocalSym(sym)) {\n                    var symIndex = context.getSymbolIndex(sym);\n                    if (this.useIndexBySymbol[symIndex] == undefined) {\n                        this.useIndexBySymbol[symIndex] = new number[];\n                    }\n                    var symUses = this.useIndexBySymbol[symIndex];\n                    var astIndex = context.getUseIndex(ast);\n                    context.addUse(symIndex, astIndex);\n                    symUses.push(astIndex);\n                }\n            }\n\n            function initUseDefPre(cur: AST, parent: AST, walker: IAstWalker) {\n                var context: UseDefContext = walker.state;\n                if (cur == null) {\n                    cur = null;\n                }\n                if (cur.nodeType == NodeType.VarDecl) {\n                    var varDecl = <BoundDecl>cur;\n                    if (varDecl.init || hasFlag(varDecl.varFlags, VarFlags.AutoInit)) {\n                        defSym(varDecl.sym, context);\n                    }\n                }\n                else if (cur.nodeType == NodeType.Name) {\n                    // use\n                    if (parent) {\n                        if (parent.nodeType == NodeType.Asg) {\n                            var asg = <BinaryExpression>parent;\n                            if (asg.operand1 == cur) {\n                                return cur;\n                            }\n                        }\n                        else if (parent.nodeType == NodeType.VarDecl) {\n                            var parentDecl = <BoundDecl>parent;\n                            if (parentDecl.id == cur) {\n                                return cur;\n                            }\n                        }\n                    }\n                    var id = <Identifier>cur;\n                    useSym(id.sym, context, cur);\n                }\n                else if ((cur.nodeType >= NodeType.Asg) && (cur.nodeType <= NodeType.LastAsg)) {\n                    // def\n                    var asg = <BinaryExpression>cur;\n                    if (asg.operand1 && (asg.operand1.nodeType == NodeType.Name)) {\n                        var id = <Identifier>asg.operand1;\n                        defSym(id.sym, context);\n                    }\n                }\n                else if (cur.nodeType == NodeType.FuncDecl) {\n                    walker.options.goChildren = false;\n                }\n\n                return cur;\n            }\n\n            var options = new AstWalkOptions();\n            // traverse ASTs in reverse order of execution (to match uses with preceding defs)\n            options.reverseSiblings = true;\n\n            getAstWalkerFactory().walk(this.bb.content, initUseDefPre, null, options, useDefContext);\n        }\n\n        public initializeGen(useDefContext: UseDefContext) {\n            var symbolLen = this.useIndexBySymbol.length;\n            var bitCount = useDefContext.uses.length;\n            this.gen = new BitVector(bitCount);\n            for (var s = 0; s < symbolLen; s++) {\n                var symUses = this.useIndexBySymbol[s];\n                if ((symUses != undefined) && (symUses.length > 0)) {\n                    for (var u = 0, uLen = symUses.length; u < uLen; u++) {\n                        this.gen.set(symUses[u], true);\n                    }\n                }\n            }\n            this.top = this.gen;\n        }\n\n     ";
var v27491 = v27492 + "   public initializeKill(useDefContext: UseDefContext) {\n            this.kill = new BitVector(this.gen.bitCount);\n            for (var s = 0, symbolLen = this.defsBySymbol.length; s < symbolLen; s++) {\n                if (this.defsBySymbol[s]) {\n                    var globalSymUses = useDefContext.useIndexBySymbol[s];\n                    if (globalSymUses) {\n                        for (var u = 0, useLen = globalSymUses.length; u < useLen; u++) {\n                            this.kill.set(globalSymUses[u], true);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    export class UseDefContext {\n        // global use lists by symbol\n        public useIndexBySymbol = new number[][];\n        // global list of uses (flat)\n        public uses = new AST[];\n        public symbols = new VariableSymbol[];\n        public symbolMap = new StringHashTable();\n        public symbolCount = 0;\n        public func: Symbol;\n\n        constructor () {\n        }\n\n        public getSymbolIndex(sym: Symbol) {\n            var name = sym.name;\n            var index = <number>(this.symbolMap.lookup(name));\n            if (index == null) {\n                index = this.symbolCount++;\n                this.symbols[index] = <VariableSymbol>sym;\n                this.symbolMap.add(name, index);\n            }\n            return index;\n        }\n\n        public addUse(symIndex: number, astIndex: number) {\n            var useBySym = this.useIndexBySymbol[symIndex];\n            if (useBySym == undefined) {\n                useBySym = new number[];\n                this.useIndexBySymbol[symIndex] = useBySym;\n            }\n            useBySym[useBySym.length] = astIndex;\n        }\n\n        public getUseIndex(ast: AST) {\n            this.uses[this.uses.length] = ast;\n            return this.uses.length - 1;\n        }\n\n        public isLocalSym(sym: Symbol) { return (sym && (sym.container == this.func) && (sym.kind() == SymbolKind.Variable)); }\n\n        public killSymbol(sym: VariableSymbol, bbUses: BitVector) {\n            var index: number = this.symbolMap.lookup(sym.name);\n            var usesOfSym = this.useIndexBySymbol[index];\n            for (var k = 0, len = usesOfSym.length; k < len; k++) {\n                bbUses.set(usesOfSym[k], true);\n            }\n        }\n    }\n\n    export class BitVector {\n        static packBits = 30;\n        public firstBits = 0;\n        public restOfBits: number[] = null;\n\n        constructor (public bitCount: number) {\n            if (this.bitCount > BitVector.packBits) {\n                this.restOfBits = new number[];\n                var len = Math.floor(this.bitCount / BitVector.packBits);\n                for (var i = 0; i < len; i++) {\n                    this.restOfBits[i] = 0;\n                }\n            }\n        }\n\n        public set(bitIndex: number, value: bool) {\n            if (bitIndex < BitVector.packBits) {\n                if (value) {\n                    this.firstBits |= (1 << bitIndex);\n                }\n                else {\n                    this.firstBits &= (~(1 << bitIndex));\n                }\n            }\n            else {\n                var offset = Math.floor(bitIndex / BitVector.packBits) - 1;\n                var localIndex = bitIndex % BitVector.packBits;\n                if (value) {\n                    this.restOfBits[offset] |= (1 << localIndex);\n                }\n                else {\n                    this.restOfBits[offset] &= (~(1 << localIndex));\n                }\n            }\n        }\n\n        public map(fn: (index: number) =>any) {\n            var k: number;\n            for (k = 0; k < BitVector.packBits; k++) {\n                if (k == this.bitCount) {\n                    return;\n                }\n                if (((1 << k) & this.firstBits) != 0) {\n                    fn(k);\n                }\n            }\n            if (this.restOfBits) {\n                var len: number;\n                var cumu = BitVector.packBits;\n                for (k = 0, len = this.restOfBits.length; k < len; k++) {\n                    var myBits = this.restOfBits[k];\n                    for (var j = 0; j < BitVector.packBits; j++) {\n                        if (((1 << j) & myBits) != 0) {\n                            fn(cumu);\n                        }\n                        cumu++;\n                        if (cumu == this.bitCount) {\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n\n        // assume conforming sizes\n        public union(b: BitVector) {\n            this.firstBits |= b.firstBits;\n            if (this.restOfBits) {\n                for (var k = 0, len = this.restOfBits.length; k < len; k++) {\n                    var myBits = this.restOfBits[k];\n                    var bBits = b.restOfBits[k];\n                    this.restOfBits[k] = myBits | bBits;\n                }\n            }\n        }\n\n        // assume conforming sizes\n        public interse";
var v27490 = v27491 + 'ction(b: BitVector) {\n            this.firstBits &= b.firstBits;\n            if (this.restOfBits) {\n                for (var k = 0, len = this.restOfBits.length; k < len; k++) {\n                    var myBits = this.restOfBits[k];\n                    var bBits = b.restOfBits[k];\n                    this.restOfBits[k] = myBits & bBits;\n                }\n            }\n        }\n\n        // assume conforming sizes\n        public notEq(b: BitVector) {\n            if (this.firstBits != b.firstBits) {\n                return true;\n            }\n            if (this.restOfBits) {\n                for (var k = 0, len = this.restOfBits.length; k < len; k++) {\n                    var myBits = this.restOfBits[k];\n                    var bBits = b.restOfBits[k];\n                    if (myBits != bBits) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        public difference(b: BitVector) {\n            var oldFirstBits = this.firstBits;\n            this.firstBits &= (~b.firstBits);\n            if (this.restOfBits) {\n                for (var k = 0, len = this.restOfBits.length; k < len; k++) {\n                    var myBits = this.restOfBits[k];\n                    var bBits = b.restOfBits[k];\n                    this.restOfBits[k] &= (~bBits);\n                }\n            }\n        }\n    }\n\n    export class BasicBlock {\n        // blocks that branch to the block after this one\n        public predecessors = new BasicBlock[];\n        public index = -1;\n        public markValue = 0;\n        public marked(markBase: number) { return this.markValue > markBase; }\n        public mark() {\n            this.markValue++;\n        }\n        public successors = new BasicBlock[];\n        public useDef: BBUseDefInfo = null;\n        public content = new ASTList();\n        public addSuccessor(successor: BasicBlock): void {\n            this.successors[this.successors.length] = successor;\n            successor.predecessors[successor.predecessors.length] = this;\n        }\n    }\n\n    export interface ITargetInfo {\n        stmt: AST;\n        continueBB: BasicBlock;\n        breakBB: BasicBlock;\n    }\n\n    export class ControlFlowContext {\n        public entry = null;\n        // first unreachable ast for each unreachable code segment\n        public unreachable: AST[] = null;\n        public noContinuation = false;\n        // statements enclosing the current statement\n        public statementStack = new ITargetInfo[];\n        public currentSwitch = new BasicBlock[];\n        public walker: IAstWalker;\n\n        constructor (public current: BasicBlock,\n                     public exit: BasicBlock) {\n            this.entry = this.current;\n        }\n\n        public walk(ast: AST, parent: AST) {\n            return this.walker.walk(ast, parent);\n        }\n\n        public pushSwitch(bb: BasicBlock) {\n            this.currentSwitch.push(bb);\n        }\n\n        public popSwitch() {\n            return this.currentSwitch.pop();\n        }\n\n        public reportUnreachable(er: ErrorReporter) {\n            if (this.unreachable && (this.unreachable.length > 0)) {\n                var len = this.unreachable.length;\n                for (var i = 0; i < len; i++) {\n                    var unreachableAST = this.unreachable[i];\n                    if (unreachableAST.nodeType != NodeType.EndCode) {\n                        er.simpleError(unreachableAST, "unreachable code");\n                    }\n                }\n            }\n        }\n\n        private printAST(ast: AST, outfile: ITextWriter) {\n            var printContext = new PrintContext(outfile, null);\n\n            printContext.increaseIndent();\n            //ast.walk(prePrintAST, postPrintAST, null, printContext);\n            getAstWalkerFactory().walk(ast, prePrintAST, postPrintAST, null, printContext);\n\n            printContext.decreaseIndent();\n        }\n\n        private printBlockContent(bb: BasicBlock, outfile: ITextWriter) {\n            var content = bb.content;\n            for (var i = 0, len = content.members.length; i < len; i++) {\n                var ast = content.members[i];\n                this.printAST(ast, outfile);\n            }\n        }\n\n        public markBase = 0;\n\n        public bfs(nodeFunc: (bb: BasicBlock) =>void , edgeFunc: (node1: BasicBlock, node2: BasicBlock) =>void ,\n            preEdges: () =>void , postEdges: () =>void ) {\n            var markValue = this.markBase++;\n            var q = new BasicBlock[];\n            q[q.length] = this.entry;\n\n            while (q.length > 0) {\n                var bb = q.pop();\n                if (!(bb.marked(markValue))) {\n                    bb.mark();\n                    if (nodeFunc) {\n                        nodeFunc(bb);\n                    }\n                    var succLen = bb.successors.length;\n                    if (succLen > 0) {\n                        if (preEdges) {\n                            preEdges();\n                        }\n                        for';
var v27489 = v27490 + ' (var j = succLen - 1; j >= 0; j--) {\n                            var successor = bb.successors[j];\n                            if (!(successor.marked(this.markBase))) {\n                                if (edgeFunc) {\n                                    edgeFunc(bb, successor);\n                                }\n                                q[q.length] = successor;\n                            }\n                        }\n                        if (postEdges) {\n                            postEdges();\n                        }\n                    }\n                }\n            }\n        }\n\n        public linearBBs = new BasicBlock[];\n\n        public useDef(er: ErrorReporter, funcSym: Symbol) {\n            var useDefContext = new UseDefContext();\n            useDefContext.func = funcSym;\n            var useDefInit = (bb: BasicBlock) => {\n                bb.useDef = new BBUseDefInfo(bb);\n                bb.useDef.initialize(useDefContext);\n                this.linearBBs[this.linearBBs.length] = bb;\n            }\n            this.bfs(useDefInit, null, null, null);\n            var i: number, bbLen: number;\n            for (i = 0, bbLen = this.linearBBs.length; i < bbLen; i++) {\n                this.linearBBs[i].useDef.initializeGen(useDefContext);\n                this.linearBBs[i].useDef.initializeKill(useDefContext);\n            }\n            var changed = true;\n\n            while (changed) {\n                changed = false;\n                for (i = 0; i < bbLen; i++) {\n                    changed = this.linearBBs[i].useDef.updateTop() || changed;\n                }\n            }\n\n            var top = this.entry.useDef.top;\n            top.map((index) => {\n                var ast = <Identifier>useDefContext.uses[<number>index];\n                er.simpleError(ast, "use of variable \'" + ast.actualText + "\' that is not definitely assigned");\n            });\n        }\n\n        public print(outfile: ITextWriter) {\n            var index = 0;\n            var node = (bb: BasicBlock) => {\n                if (bb.index < 0) {\n                    bb.index = index++;\n                }\n                if (bb == this.exit) {\n                    outfile.WriteLine("Exit block with index " + bb.index);\n                }\n                else {\n                    outfile.WriteLine("Basic block with index " + bb.index);\n                    this.printBlockContent(bb, outfile);\n                }\n            }\n\n            function preEdges() {\n                outfile.Write("  Branches to ");\n            }\n\n            function postEdges() {\n                outfile.WriteLine("");\n            }\n\n            function edge(node1: BasicBlock, node2: BasicBlock) {\n                if (node2.index < 0) {\n                    node2.index = index++;\n                }\n                outfile.Write(node2.index + " ");\n            }\n\n            this.bfs(node, edge, preEdges, postEdges);\n            if (this.unreachable != null) {\n                for (var i = 0, len = this.unreachable.length; i < len; i++) {\n                    outfile.WriteLine("Unreachable basic block ...");\n                    this.printAST(this.unreachable[i], outfile);\n                }\n            }\n        }\n\n        public pushStatement(stmt: Statement, continueBB: BasicBlock, breakBB: BasicBlock) {\n            this.statementStack.push({ stmt: stmt, continueBB: continueBB, breakBB: breakBB });\n        }\n\n        public popStatement() { return this.statementStack.pop(); }\n\n        public returnStmt() {\n            // TODO: make successor finally block if return stmt inside of try/finally \n            this.current.addSuccessor(this.exit);\n            this.setUnreachable();\n        }\n\n        public setUnreachable() {\n            this.current = null;\n            this.noContinuation = true;\n        }\n\n        public addUnreachable(ast: AST) {\n            if (this.unreachable === null) {\n                this.unreachable = new AST[];\n            }\n            this.unreachable[this.unreachable.length] = ast;\n        }\n\n        public unconditionalBranch(target: AST, isContinue: bool) {\n            var targetBB = null;\n            for (var i = 0, len = this.statementStack.length; i < len; i++) {\n                var targetInfo = this.statementStack[i];\n                if (targetInfo.stmt == target) {\n                    if (isContinue) {\n                        targetBB = targetInfo.continueBB;\n                    }\n                    else {\n                        targetBB = targetInfo.breakBB;\n                    }\n                    break;\n                }\n            }\n            if (targetBB) {\n                this.current.addSuccessor(targetBB);\n            }\n            this.setUnreachable();\n        }\n\n        public addContent(ast: AST): void {\n            if (this.current) {\n                this.current.content.append(ast);\n            }\n        }\n    }\n\n    export interface IResolutionData {\n        actuals: Type[];\n        exactCandidates: Signature[];\n        c';
var v27488 = v27489 + 'onversionCandidates: Signature[];\n        id: number;\n    }\n\n    export class ResolutionDataCache {\n        public cacheSize = 16;\n        public rdCache: IResolutionData[] = [];\n        public nextUp: number = 0;\n\n        constructor () {\n            for (var i = 0; i < this.cacheSize; i++) {\n                this.rdCache[i] = {\n                    actuals: new Type[],\n                    exactCandidates: new Signature[],\n                    conversionCandidates: new Signature[],\n                    id: i\n                };\n            }\n        }\n\n        public getResolutionData(): IResolutionData {\n            var rd: IResolutionData = null;\n\n            if (this.nextUp < this.cacheSize) {\n                rd = this.rdCache[this.nextUp];\n            }\n\n            if (rd == null) {\n                this.cacheSize++;\n                rd = {\n                    actuals: new Type[],\n                    exactCandidates: new Signature[],\n                    conversionCandidates: new Signature[],\n                    id: this.cacheSize\n                };\n                this.rdCache[this.cacheSize] = rd;\n            }\n\n            // cache operates as a stack - RD is always served up in-order\n            this.nextUp++;\n\n            return rd;\n        }\n\n        public returnResolutionData(rd: IResolutionData) {\n            // Pop to save on array allocations, which are a bottleneck\n            // REVIEW: On some VMs, Array.pop doesn\'t always pop the last value in the array\n            rd.actuals.length = 0;\n            rd.exactCandidates.length = 0;\n            rd.conversionCandidates.length = 0;\n\n            this.nextUp = rd.id;\n        }\n    }\n\n    export class TypeFlow {\n        public scope: SymbolScope;\n        public globalScope: SymbolScope;\n\n        public thisType: Type;\n        public thisFnc: FuncDecl = null;\n        public thisClassNode: TypeDeclaration = null;\n        public enclosingFncIsMethod = false;\n\n        // REVIEW: Prune in favor of typechecker fields\n        public doubleType: Type;\n        public booleanType: Type;\n        public stringType: Type;\n        public anyType: Type;\n        public regexType: Type;\n        public nullType: Type;\n        public voidType: Type;\n        public arrayAnyType: Type;\n\n        public arrayInterfaceType: Type = null;\n        public stringInterfaceType: Type = null;\n        public objectInterfaceType: Type = null;\n        public functionInterfaceType: Type = null;\n        public numberInterfaceType: Type = null;\n        public booleanInterfaceType: Type = null;\n        public iargumentsInterfaceType: Type = null;\n\n        public currentScript: Script = null;\n\n        public inImportTypeCheck = false;\n        public inTypeRefTypeCheck = false;\n        public inArrayElementTypeCheck = false;\n        public resolutionDataCache = new ResolutionDataCache();\n        public nestingLevel = 0;\n        public inSuperCall = false;\n\n        constructor (public logger: ILogger, public initScope: SymbolScope, public parser: Parser,\n                   public checker: TypeChecker) {\n            this.checker.typeFlow = this;\n            this.scope = this.initScope;\n            this.globalScope = this.initScope;\n            this.doubleType = this.checker.numberType;\n            this.booleanType = this.checker.booleanType;\n            this.stringType = this.checker.stringType;\n            this.anyType = this.checker.anyType;\n            this.regexType = this.anyType;\n            this.nullType = this.checker.nullType;\n            this.voidType = this.checker.voidType;\n            this.arrayAnyType = this.checker.makeArrayType(this.anyType);\n        }\n\n        public initLibs() {\n            var arraySym = this.globalScope.find("Array", false, true);\n            if (arraySym && (arraySym.kind() == SymbolKind.Type)) {\n                this.arrayInterfaceType = (<TypeSymbol>arraySym).type;\n            }\n            var stringSym = this.globalScope.find("String", false, true);\n            if (stringSym && (stringSym.kind() == SymbolKind.Type)) {\n                this.stringInterfaceType = (<TypeSymbol>stringSym).type;\n            }\n            var objectSym = this.globalScope.find("Object", false, true);\n            if (objectSym && (objectSym.kind() == SymbolKind.Type)) {\n                this.objectInterfaceType = (<TypeSymbol>objectSym).type;\n            }\n            var fnSym = this.globalScope.find("Function", false, true);\n            if (fnSym && (fnSym.kind() == SymbolKind.Type)) {\n                this.functionInterfaceType = (<TypeSymbol>fnSym).type;\n            }\n            var numberSym = this.globalScope.find("Number", false, true);\n            if (numberSym && (numberSym.kind() == SymbolKind.Type)) {\n                this.numberInterfaceType = (<TypeSymbol>numberSym).type;\n            }\n            var booleanSym = this.globalScope.find("Boolean", false, true);\n            if (booleanSym && (booleanSym.kind() == SymbolKind.Type)) {\n                this.booleanInterfaceT';
var v27487 = v27488 + 'ype = (<TypeSymbol>booleanSym).type;\n            }\n            var regexSym = this.globalScope.find("RegExp", false, true);\n            if (regexSym && (regexSym.kind() == SymbolKind.Type)) {\n                this.regexType = (<TypeSymbol>regexSym).type;\n            }\n        }\n\n        public cast(ast: AST, type: Type): AST {\n            return this.castWithCoercion(ast, type, true, false);\n        }\n\n        public castWithCoercion(ast: AST, type: Type, applyCoercion: bool, typeAssertion: bool): AST {\n            var comparisonInfo = new TypeComparisonInfo();\n            if (this.checker.sourceIsAssignableToTarget(ast.type, type, comparisonInfo) || (typeAssertion && this.checker.sourceIsAssignableToTarget(type, ast.type, comparisonInfo))) {\n                if (applyCoercion) {\n                    if (type == null) {\n                        ast.type = this.anyType;\n                    }\n                    else if (type.isClass()) {\n                        ast.type = type.instanceType;\n                    }\n                    else {\n                        ast.type = type;\n                    }\n                }\n                return ast;\n            }\n            else {\n                this.checker.errorReporter.incompatibleTypes(ast, ast.type, type, null, this.scope, comparisonInfo);\n                return ast;\n            }\n        }\n\n        public inScopeTypeCheck(ast: AST, enclosingScope: SymbolScope): AST {\n            var prevScope = this.scope;\n            this.scope = enclosingScope;\n            var svThisFnc = this.thisFnc;\n            var svThisType = this.thisType;\n            var svThisClassNode = this.thisClassNode;\n            var svCurrentModDecl = this.checker.currentModDecl;\n            var prevMethodStatus = this.enclosingFncIsMethod;\n            var container = this.scope.container;\n            var fnc: FuncDecl = null;\n            while (container) {\n                if (container.kind() == SymbolKind.Type) {\n                    var typeSym = <TypeSymbol>container;\n                    var type = typeSym.type;\n                    if (type.call) {\n                        if (fnc == null) {\n                            // use innermost function\n                            this.enclosingFncIsMethod = typeSym.isMethod;\n                            fnc = <FuncDecl>container.declAST;\n                        }\n                    }\n                    if (type.isClass()) {\n                        this.thisType = type.instanceType;\n                        if (typeSym.declAST &&\n                            (typeSym.declAST.nodeType == NodeType.ClassDeclaration)) {\n                            this.thisClassNode = <TypeDeclaration>typeSym.declAST;\n                        }\n                        // use innermost class\n                        break;\n                    }\n                    if (type.isModuleType()) {\n                        this.checker.currentModDecl = <ModuleDeclaration>typeSym.declAST;\n                        // use innermost module\n                        break;\n                    }\n                }\n                container = container.container;\n            }\n            this.thisFnc = fnc;\n\n            var updated = this.typeCheck(ast);\n\n            this.thisFnc = svThisFnc;\n            this.thisType = svThisType;\n            this.thisClassNode = svThisClassNode;\n            this.checker.currentModDecl = svCurrentModDecl;\n            this.enclosingFncIsMethod = prevMethodStatus;\n            this.scope = prevScope;\n            return updated;\n        }\n\n        public typeCheck(ast: AST): AST {\n            if (ast) {\n                return ast.typeCheck(this);\n            }\n            else {\n                return null;\n            }\n        }\n\n        public inScopeTypeCheckDecl(ast: AST) {\n            if (ast.nodeType == NodeType.VarDecl || ast.nodeType == NodeType.ArgDecl) {\n                this.inScopeTypeCheckBoundDecl(<BoundDecl>ast);\n            }\n            else if (ast.nodeType == NodeType.FuncDecl) {\n\n                var funcDecl = <FuncDecl>ast;\n\n                if (funcDecl.isAccessor()) {\n                    this.typeCheckFunction(funcDecl);\n                }\n            }\n        }\n\n        public inScopeTypeCheckBoundDecl(varDecl: BoundDecl) {\n            var sym = varDecl.sym;\n            var svThisFnc = this.thisFnc;\n            var svThisType = this.thisType;\n            var prevMethodStatus = this.enclosingFncIsMethod;\n            var prevLocationInfo = this.checker.locationInfo;\n            if (sym && sym.container) {\n                var instanceScope = hasFlag(varDecl.varFlags, VarFlags.ClassConstructorProperty) ? sym.container.getType().constructorScope : sym.container.instanceScope();\n                if (hasFlag(varDecl.varFlags, VarFlags.Property) && sym.container.declAST.nodeType == NodeType.FuncDecl) {\n                    this.thisFnc = <FuncDecl>sym.container.declAST;\n                }\n                if (instanceScope) {\n                    var';
var v27486 = v27487 + " prevScope = this.scope;\n                    this.scope = instanceScope;\n                    var container = sym.container;\n                    var svCurrentModDecl = this.checker.currentModDecl;\n                    if (this.checker.units &&\n                        (sym.unitIndex >= 0) &&\n                        (sym.unitIndex < this.checker.units.length)) {\n                        this.checker.locationInfo = this.checker.units[sym.unitIndex];\n                    }\n                    else {\n                        this.checker.locationInfo = unknownLocationInfo;\n                    }\n                    // REVIEW: container linkage for function expressions\n                    while (container) {\n                        if (container.kind() == SymbolKind.Type) {\n                            var typeSym = <TypeSymbol>container;\n                            var type = typeSym.type;\n                            if (type.call) {\n                                this.enclosingFncIsMethod = typeSym.isMethod;\n                            }\n                            if (type.isClass()) {\n                                this.thisType = type.instanceType;\n                            }\n                            if (type.isModuleType()) {\n                                this.checker.currentModDecl = <ModuleDeclaration>container.declAST;\n                                break;\n                            }\n                        }\n                        container = container.container;\n                    }\n\n                    this.typeCheckBoundDecl(varDecl);\n                    this.checker.currentModDecl = svCurrentModDecl;\n                    this.scope = prevScope;\n                }\n            }\n            this.thisFnc = svThisFnc;\n            this.thisType = svThisType;\n            this.checker.locationInfo = prevLocationInfo;\n            this.enclosingFncIsMethod = prevMethodStatus;\n        }\n\n        public resolveBoundDecl(varDecl: BoundDecl) {\n            if (varDecl.typeExpr) {\n                if (varDecl.typeExpr.type == null ||\n                    (varDecl.typeExpr.type && varDecl.typeExpr.type == this.anyType && this.scope) ||\n                    varDecl.typeExpr.type.symbol == null ||\n                    !this.checker.typeStatusIsFinished(varDecl.typeExpr.type.symbol.typeCheckStatus)) {\n                    this.typeCheck(varDecl.typeExpr);\n                }\n                varDecl.type = varDecl.typeExpr.type;\n                if (varDecl.sym) {\n                    varDecl.sym.setType(varDecl.type);\n                }\n            }\n            else if (varDecl.init == null) {\n                if (this.checker.styleSettings.implicitAny) {\n                    this.checker.errorReporter.styleError(varDecl, \"type implicitly set to 'any'\");\n                }\n                varDecl.type = this.anyType;\n                if (varDecl.sym) {\n                    if (varDecl.sym.isType()) {\n                        var tsym = <TypeSymbol>varDecl.sym;\n                        if (tsym.isMethod) {\n                            this.checker.errorReporter.simpleError(varDecl, \"Cannot bind method group to variable.  (Did you mean to use 'declare function' instead of 'declare var'?)\");\n                            return;\n                        }\n                        else {\n                            this.checker.errorReporter.simpleError(varDecl, \"Cannot bind type to variable\");\n                            return;\n                        }\n                    }\n                    varDecl.sym.setType(varDecl.type);\n                }\n            }\n        }\n\n        public typeCheckBoundDecl(varDecl: BoundDecl): VarDecl {\n            // symbol has already been added to the scope\n            var infSym = <InferenceSymbol>varDecl.sym;\n            if (infSym == null) {\n                if (varDecl.init) {\n                    varDecl.init = this.typeCheck(varDecl.init);\n                    varDecl.type = this.checker.widenType(varDecl.init.type);\n                }\n                else {\n                    if (this.checker.styleSettings.implicitAny) {\n                        this.checker.errorReporter.styleError(varDecl, \"type implicitly set to 'any'\");\n                    }\n                    varDecl.type = this.anyType;\n                }\n            }\n            else {\n                if (infSym.typeCheckStatus == TypeCheckStatus.Started) {\n                    if (this.checker.styleSettings.implicitAny) {\n                        this.checker.errorReporter.styleError(varDecl, \"type implicitly set to 'any'\");\n                    }\n                    varDecl.type = this.anyType;\n                    infSym.setType(this.anyType);\n                }\n                else if (infSym.typeCheckStatus == TypeCheckStatus.NotStarted) {\n                    infSym.typeCheckStatus = TypeCheckStatus.Started;\n                    this.checker.addStartedPTO(infSym);\n                    var resolved = false;\n                    if (varDecl.type";
var v27485 = v27486 + " == null) {\n                        // propagate declared type\n                        if (varDecl.typeExpr) {\n                            this.resolveBoundDecl(varDecl);\n                            resolved = true;\n                            varDecl.type = varDecl.typeExpr.type;\n                            infSym.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();\n                        }\n                    }\n\n                    if (varDecl.init) {\n                        // if the bound decl is a function-local static, we need to set the\n                        // encapsulating scope to the function's member scope\n                        var isLocalStatic = hasFlag(varDecl.varFlags, VarFlags.LocalStatic);\n                        var prevScope = this.scope;\n                        var applyTargetType = !varDecl.init.isParenthesized;\n                        if (isLocalStatic) {\n                            this.scope = varDecl.sym.container.getType().memberScope;\n                        }\n\n                        // Mark Lambda expressions with IsPropertyBound flag\n                        if (hasFlag(varDecl.varFlags, VarFlags.Property) && this.thisClassNode) {\n                            getAstWalkerFactory().walk(varDecl.init, (ast: AST, parent: AST, walker: IAstWalker) => {\n                                if (ast && ast.nodeType == NodeType.FuncDecl) {\n                                    if (hasFlag((<FuncDecl>ast).fncFlags, FncFlags.IsFatArrowFunction)) {\n                                        // Found a Lambda, mark it\n                                        (<FuncDecl>ast).fncFlags |= FncFlags.IsPropertyBound;\n                                    }\n                                    // Only mark the top level functions\n                                    walker.options.goChildren = false;\n                                }\n                                return ast;\n                            });\n                        }\n\n                        this.checker.typeCheckWithContextualType(varDecl.type, this.checker.inProvisionalTypecheckMode(), applyTargetType, varDecl.init);\n\n                        this.scope = prevScope;\n                        if (varDecl.type) {\n                            // If the cast is to a target type, in the case of a funcdecl,\n                            // we may overwrite the init's type with one generated from a signature.\n                            // In that case, we need to preserve the contained scope of the actual decl\n                            var preserveScope = false;\n                            var preservedContainedScope = null;\n\n                            if (varDecl.init.type) {\n                                preservedContainedScope = varDecl.init.type.containedScope;\n                                preserveScope = true;\n                                if (varDecl.init.type == this.voidType) {\n                                    this.checker.errorReporter.simpleError(varDecl, \"Cannot assign type 'void' to variable '\" + varDecl.id.actualText + \"'\");\n                                }\n                            }\n\n                            varDecl.init = this.castWithCoercion(varDecl.init, varDecl.type, applyTargetType && !this.checker.inProvisionalTypecheckMode(), false);\n\n                            if (preserveScope && varDecl.init.type.containedScope == null) {\n                                varDecl.init.type.containedScope = preservedContainedScope;\n                            }\n                        }\n                        else {\n                            varDecl.type = this.checker.widenType(varDecl.init.type);\n                            if (varDecl.type == this.voidType) {\n                                this.checker.errorReporter.simpleError(varDecl, \"Cannot assign type 'void' to variable '\" + varDecl.id.actualText + \"'\");\n                                varDecl.type = this.anyType;\n                            }\n                        }\n                        infSym.setType(varDecl.type);\n                    }\n                    else {\n                        if (!resolved) {\n                            this.resolveBoundDecl(varDecl);\n                        }\n                    }\n                    infSym.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();\n                }\n                else if (this.checker.typeStatusIsFinished(infSym.typeCheckStatus) &&\n                         (infSym.declAST != varDecl)) {\n                    if (varDecl.init) {\n                        varDecl.init = this.typeCheck(varDecl.init);\n                        varDecl.type = infSym.getType();\n                        varDecl.init = this.cast(varDecl.init, varDecl.type);\n                    }\n                }\n            }\n            if (varDecl.id && varDecl.sym) {\n                varDecl.id.sym = varDecl.sym;\n            }\n\n            // Check if variable satisfies type privacy\n            if (varDecl.sym && varDecl.sym.con";
var v27484 = v27485 + 'tainer) {\n                this.checkTypePrivacy(varDecl.sym.getType(), varDecl.sym, (typeName: string, isModuleName: bool) => this.varPrivacyErrorReporter(varDecl, typeName, isModuleName));\n            }\n            return <VarDecl>varDecl;\n        }\n\n        private varPrivacyErrorReporter(varDecl: BoundDecl, typeName: string, isModuleName: bool) {\n            var typestring = "";\n            if (isModuleName) {\n                var quotestring = "";\n                if (!isQuoted(typeName)) {\n                    quotestring = "\'";\n                }\n                typestring = " is using inaccessible module " + quotestring + typeName + quotestring;\n            } else {\n                typestring = " has or is using private type \'" + typeName + "\'";\n            }\n\n            if (hasFlag(varDecl.varFlags, VarFlags.Public)) {\n                if (varDecl.sym.container.declAST.nodeType == NodeType.InterfaceDeclaration) {\n                    this.checker.errorReporter.simpleError(varDecl, "property \'" + varDecl.sym.name + "\' of exported interface" + typestring);\n                } else {\n                    this.checker.errorReporter.simpleError(varDecl, "public member \'" + varDecl.sym.name + "\' of exported class" + typestring);\n                }\n            } else {\n                this.checker.errorReporter.simpleError(varDecl, "exported variable \'" + varDecl.sym.name + "\'" + typestring);\n            }\n        }\n\n        public typeCheckSuper(ast: AST): AST {\n            if (this.thisType && (this.enclosingFncIsMethod && !this.thisFnc.isStatic()) && this.thisType.baseClass()) {\n                ast.type = this.thisType.baseClass();\n            }\n            else {\n                // redirect \'super\' used within lambdas\n                if (!this.enclosingFncIsMethod &&\n                    this.thisType && this.thisType.baseClass() &&\n                    this.thisFnc && hasFlag(this.thisFnc.fncFlags, FncFlags.IsFatArrowFunction)) {\n                    // Find the closest non lambda function\n                    var enclosingFnc = this.thisFnc.enclosingFnc;\n                    while (hasFlag(enclosingFnc.fncFlags, FncFlags.IsFatArrowFunction)) {\n                        enclosingFnc = enclosingFnc.enclosingFnc;\n                    }\n\n                    // If the lambda is enclosed is a valid member, use the base type\n                    if (enclosingFnc && (enclosingFnc.isMethod() || enclosingFnc.isConstructor) && !enclosingFnc.isStatic()) {\n                        ast.type = this.thisType.baseClass();\n                        enclosingFnc.setHasSuperReferenceInFatArrowFunction();\n                        return ast;\n                    }\n                }\n\n                ast.type = this.anyType;\n                this.checker.errorReporter.invalidSuperReference(ast);\n            }\n            return ast;\n        }\n\n        public typeCheckThis(ast: AST): AST {\n           ast.type = this.anyType;\n            var illegalThisRef = false;\n            if (this.thisFnc == null) {\n                // \'this\' in class bodies should bind to \'any\'\n                if (this.thisType) {\n                    if (this.thisClassNode && this.thisClassNode.nodeType == NodeType.ClassDeclaration) {\n                        illegalThisRef = true;\n                    }\n                    else {\n                        ast.type = this.thisType;\n                    }\n                }\n                else if (this.checker.currentModDecl) {\n                    this.checker.errorReporter.simpleError(ast, "\'this\' may not be referenced within module bodies");\n                }\n            }\n            else {\n                if (this.thisClassNode && (hasFlag(this.thisFnc.fncFlags, FncFlags.IsPropertyBound) || (this.inSuperCall && hasFlag((<ClassDeclaration>this.thisClassNode).varFlags, VarFlags.ClassSuperMustBeFirstCallInConstructor)))) {\n                    illegalThisRef = true;\n                }\n                if (this.thisFnc.isMethod() || this.thisFnc.isConstructor || this.thisFnc.isTargetTypedAsMethod) {\n                    if (this.thisType && !(this.thisFnc.fncFlags & FncFlags.Static)) {\n                        ast.type = this.thisType;\n                    }\n                }\n            }\n\n            // redirect \'this\' used within lambdas\n            if (!this.enclosingFncIsMethod &&\n                this.thisFnc &&\n                hasFlag(this.thisFnc.fncFlags, FncFlags.IsFatArrowFunction)) {\n\n                    // if the enclosing function was bound to a property,\n                    // checkInitSelf would not have been able to mark the \n                    // function for a self init\n                if (this.thisFnc.boundToProperty) {\n                    var container = this.thisFnc.boundToProperty.sym.container;\n                    if (container.declAST.nodeType == NodeType.FuncDecl) {\n                        (<FuncDecl>container.declAST).setHasSelfReference();\n                    }\n                }\n                else {\n         ';
var v27483 = v27484 + '           var encFnc = this.thisFnc.enclosingFnc;\n                    var firstEncFnc = encFnc;\n\n                    while (encFnc) {\n                        if (this.thisClassNode && hasFlag(encFnc.fncFlags, FncFlags.IsPropertyBound)) {\n                            illegalThisRef = true;\n                        }\n\n                        if (!hasFlag(encFnc.fncFlags, FncFlags.IsFatArrowFunction) || encFnc.hasSelfReference()) {\n                            encFnc.setHasSelfReference();\n                            break;\n                        }\n\n                        encFnc = encFnc.enclosingFnc;\n                    }\n\n                    if (!encFnc && firstEncFnc) {\n                        encFnc = firstEncFnc;\n                        encFnc.setHasSelfReference();\n                    }\n                    else if (!encFnc) { // the lambda is bound at the top-level...\n                        if (this.thisClassNode) {\n                            (<ClassDeclaration>this.thisClassNode).varFlags |= VarFlags.MustCaptureThis;\n                        }\n                        else if (this.checker.currentModDecl) {\n                            this.checker.currentModDecl.modFlags |= ModuleFlags.MustCaptureThis;\n                        }\n                        else {\n                            this.checker.mustCaptureGlobalThis = true;\n                        }\n                    }\n\n                    if (encFnc && (encFnc.isMethod() || encFnc.isConstructor) && this.thisType && !hasFlag(encFnc.fncFlags, FncFlags.Static)) {\n                        ast.type = this.thisType;\n                    }\n                }\n            }\n\n            if (illegalThisRef) {\n                this.checker.errorReporter.simpleError(ast, "Keyword \'this\' cannot be referenced in initializers in a class body, or in super constructor calls");\n            }\n            return ast;\n        }\n\n        public setTypeFromSymbol(ast: AST, symbol: Symbol): void {\n            if (symbol.isVariable()) {\n                if (symbol.isInferenceSymbol()) {\n                    var infSym = <InferenceSymbol>symbol;\n                    if (infSym.declAST &&\n                        !this.checker.typeStatusIsFinished(infSym.typeCheckStatus)) {\n                        this.inScopeTypeCheckDecl(infSym.declAST);\n                    }\n                    if (!this.checker.styleSettings.innerScopeDeclEscape) {\n                        if (infSym.declAST && (infSym.declAST.nodeType == NodeType.VarDecl)) {\n                            if (this.nestingLevel < (<VarDecl>infSym.declAST).nestingLevel) {\n                                this.checker.errorReporter.styleError(ast, "Illegal reference to a variable defined in more nested scope");\n                            }\n                        }\n                    }\n                }\n                ast.type = symbol.getType();\n                if (!symbol.writeable()) {\n                    ast.flags = ast.flags & (~(ASTFlags.Writeable));\n                }\n            }\n            else if (symbol.isType()) {\n                ast.type = symbol.getType();\n                ast.flags = ast.flags & (~(ASTFlags.Writeable));\n            }\n            else {\n                ast.type = this.anyType;\n                this.checker.errorReporter.symbolDoesNotReferToAValue(ast, symbol.name);\n            }\n        }\n\n        public typeCheckName(ast: AST): AST {\n            var identifier = <Identifier>ast;\n\n            if (this.checker.inWith) {\n                identifier.type = this.anyType;\n            }\n            else {\n                var typespace = this.inTypeRefTypeCheck;\n                var idText = identifier.text;\n                var originalIdText = idText;\n                var isDynamicModuleName = isQuoted(identifier.text);\n\n                var symbol = this.scope.find(idText, false, typespace);\n\n                if (symbol == null && isDynamicModuleName) {\n                    symbol = this.checker.findSymbolForDynamicModule(idText, this.currentScript.locationInfo.filename, (id) => this.scope.find(id, false, typespace));\n                }\n\n                if (!symbol) {\n                    if (!identifier.isMissing()) {\n                        this.checker.errorReporter.unresolvedSymbol(identifier, identifier.text);\n                    }\n                    identifier.type = this.anyType;\n                }\n                else {\n                    if (optimizeModuleCodeGen && symbol && symbol.isType()) {\n                        var symType = symbol.getType();\n                        // Once the type has been referenced outside of a type ref position, there\'s\n                        // no going back                        \n                        if (symType && (<TypeSymbol>symbol).aliasLink && (<TypeSymbol>symbol).onlyReferencedAsTypeRef) {\n\n                            var modDecl = <ModuleDeclaration>symType.symbol.declAST;\n                            if (modDecl && hasFlag(modDecl.modFlags, ModuleFlags.IsDynamic';
var v27482 = v27483 + ")) {\n                                (<TypeSymbol>symbol).onlyReferencedAsTypeRef = this.inTypeRefTypeCheck;\n                            }\n                        }\n                    }\n\n                    if (symbol.declAST &&\n                        symbol.declAST.nodeType == NodeType.FuncDecl &&\n                        !(<FuncDecl>symbol.declAST).returnTypeAnnotation &&\n                        (<FuncDecl>symbol.declAST).signature.typeCheckStatus == TypeCheckStatus.Started) {\n                        (<FuncDecl>symbol.declAST).type.symbol.flags |= SymbolFlags.RecursivelyReferenced;\n                        (<FuncDecl>symbol.declAST).signature.returnType.type = this.anyType;\n                    }\n\n                    this.setTypeFromSymbol(ast, symbol);\n                    identifier.sym = symbol;\n                    if (this.thisFnc) {\n                        if (this.thisFnc.type && symbol.container != this.thisFnc.type.symbol) {\n                            this.thisFnc.freeVariables[this.thisFnc.freeVariables.length] = symbol;\n                        }\n                    }\n                }\n            }\n            return ast;\n        }\n\n        public typeCheckScript(script: Script): Script {\n            this.checker.locationInfo = script.locationInfo;\n            this.scope = this.checker.globalScope;\n\n            // if it's a top-level module, the globals have already been added to the implicit\n            // module decl\n            if (!script.topLevelMod) {\n                this.addLocalsFromScope(this.scope, this.checker.gloMod,\n                                   script.vars, this.checker.globals, true);\n            }\n\n            this.currentScript = script;\n            script.bod = <ASTList>this.typeCheck(script.bod);\n            this.currentScript = null;\n            return script;\n        }\n\n        public typeCheckBitNot(ast: AST): AST {\n            var unex = <UnaryExpression>ast;\n            unex.operand = this.typeCheck(unex.operand);\n            unex.type = this.doubleType;\n            return unex;\n        }\n\n        public typeCheckUnaryNumberOperator(ast: AST): AST {\n            var unex = <UnaryExpression>ast;\n            unex.operand = this.typeCheck(unex.operand);\n            unex.type = this.doubleType;\n            return ast;\n        }\n\n        public typeCheckLogNot(ast: AST): AST {\n            var unex = <UnaryExpression>ast;\n            unex.operand = this.typeCheck(unex.operand);\n            unex.type = this.booleanType;\n            return unex;\n        }\n\n        public astIsWriteable(ast: AST): bool {\n            return hasFlag(ast.flags, ASTFlags.Writeable);\n        }\n\n        public typeCheckIncOrDec(ast: AST): AST {\n            var unex = <UnaryExpression>ast;\n            var lval = unex.operand;\n            if (!this.astIsWriteable(unex)) {\n                this.checker.errorReporter.valueCannotBeModified(unex);\n                unex.type = this.doubleType;\n            }\n            else {\n                unex = <UnaryExpression> this.typeCheckUnaryNumberOperator(ast);\n                if (unex.operand.type != this.checker.numberType && unex.operand.type != this.checker.anyType && !(unex.operand.type.typeFlags & TypeFlags.IsEnum)) {\n                    this.checker.errorReporter.simpleError(ast, \"'++' and '--' may only be applied to operands of type 'number' or 'any'\");\n                }\n            }\n            return unex;\n        }\n\n        public typeCheckBitwiseOperator(ast: AST, assignment: bool): AST {\n            var binex = <BinaryExpression>ast;\n            var resultType: Type = null;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            var leftType = binex.operand1.type;\n            var rightType = binex.operand2.type;\n\n            if (assignment && (!this.astIsWriteable(binex))) {\n                this.checker.errorReporter.valueCannotBeModified(binex);\n            }\n\n            if (this.checker.styleSettings.bitwise) {\n                this.checker.errorReporter.styleError(ast, \"use of \" + nodeTypeTable[binex.nodeType]);\n            }\n\n            if (this.checker.sourceIsSubtypeOfTarget(leftType, this.doubleType) && (this.checker.sourceIsSubtypeOfTarget(rightType, this.doubleType))) {\n                resultType = this.doubleType;\n            }\n            else if ((leftType == this.booleanType) &&\n                     (rightType == this.booleanType)) {\n                resultType = this.booleanType;\n            }\n            else if (leftType == this.anyType) {\n                if ((rightType == this.anyType) ||\n                    (rightType == this.doubleType) ||\n                    (rightType == this.booleanType)) {\n                    resultType = this.anyType;\n                }\n            }\n            else if (rightType == this.anyType) {\n                if ((leftType == this.anyType) ||\n                    (leftType == this.doubleType) ||\n                    (leftType == th";
var v27481 = v27482 + 'is.booleanType)) {\n                    resultType = this.anyType;\n                }\n            }\n            if (resultType == null) {\n                resultType = this.anyType;\n                this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType,\n                                                        binex.printLabel(), this.scope);\n            }\n            binex.type = resultType;\n            return binex;\n        }\n\n        public typeCheckArithmeticOperator(ast: AST, assignment: bool): AST {\n            var binex = <BinaryExpression>ast;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            var leftType = binex.operand1.type;\n            var rightType = binex.operand2.type;\n\n            if (assignment && (!this.astIsWriteable(binex.operand1))) {\n                this.checker.errorReporter.valueCannotBeModified(binex);\n            }\n\n            if (this.checker.styleSettings.bitwise &&\n                ((binex.nodeType == NodeType.And) ||\n                (binex.nodeType == NodeType.Or) ||\n                (binex.nodeType == NodeType.AsgAnd) ||\n                (binex.nodeType == NodeType.AsgOr))) {\n                this.checker.errorReporter.styleError(ast, "use of " + nodeTypeTable[binex.nodeType]);\n            }\n\n            if (leftType == null || rightType == null) {\n                this.checker.errorReporter.simpleError(binex, "Could not typecheck arithmetic operation.  Possible recursive typecheck error?");\n                binex.type = this.anyType;\n                return binex;\n            }\n            var nodeType = binex.nodeType;\n\n            if (this.checker.isNullOrUndefinedType(leftType)) {\n                leftType = rightType;\n            }\n            if (this.checker.isNullOrUndefinedType(rightType)) {\n                rightType = leftType;\n            }\n            leftType = this.checker.widenType(leftType);\n            rightType = this.checker.widenType(rightType);\n\n            if (nodeType == NodeType.Add || nodeType == NodeType.AsgAdd) {\n\n                if (leftType == this.checker.stringType || rightType == this.checker.stringType) {\n                    binex.type = this.checker.stringType;\n                }\n                else if (leftType == this.checker.numberType && rightType == this.checker.numberType) {\n                    binex.type = this.checker.numberType;\n                }\n                else if (this.checker.sourceIsSubtypeOfTarget(leftType, this.checker.numberType) && this.checker.sourceIsSubtypeOfTarget(rightType, this.checker.numberType)) {\n                    binex.type = this.checker.numberType;\n                }\n                else if (leftType == this.checker.anyType || rightType == this.checker.anyType) {\n                    binex.type = this.checker.anyType;\n                }\n                else {\n                    binex.type = this.anyType;\n                    this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType,\n                                                            binex.printLabel(), this.scope);\n                }\n            }\n            else {\n                if (leftType == this.checker.numberType && rightType == this.checker.numberType) {\n                    binex.type = this.checker.numberType;\n                }\n                else if (this.checker.sourceIsSubtypeOfTarget(leftType, this.checker.numberType) && this.checker.sourceIsSubtypeOfTarget(rightType, this.checker.numberType)) {\n                    binex.type = this.checker.numberType;\n                }\n                else if (leftType == this.checker.anyType || rightType == this.checker.anyType) {\n                    binex.type = this.checker.numberType;\n                }\n                else {\n                    binex.type = this.anyType;\n                    this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType,\n                                                            binex.printLabel(), this.scope);\n                }\n            }\n\n            return binex;\n        }\n\n        public typeCheckDotOperator(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            var leftIsFnc = false;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            var leftType = binex.operand1.type;\n            var leftScope: SymbolScope = null;\n            // REVIEW: replace with get member scope\n            if (leftType) {\n                if (leftType == this.anyType) {\n                    binex.type = this.anyType;\n                    return binex;\n                }\n                else if (leftType == this.stringType) {\n                    if (this.stringInterfaceType) {\n                        leftScope = this.stringInterfaceType.memberScope;\n                    }\n                    else {\n                        binex.type = this.anyType;\n                        return binex;\n                    }\n                }\n              ';
var v27480 = v27481 + "  else if (leftType == this.doubleType) {\n                    if (this.numberInterfaceType) {\n                        leftScope = this.numberInterfaceType.memberScope;\n                    }\n                    else {\n                        binex.type = this.anyType;\n                        return binex;\n                    }\n                }\n                else if (leftType == this.booleanType) {\n                    if (this.booleanInterfaceType) {\n                        leftScope = this.booleanInterfaceType.memberScope;\n                    }\n                    else {\n                        binex.type = this.anyType;\n                        return binex;\n                    }\n                }\n                else if ((leftType.call || leftType.construct) && leftType.members == null) {\n                    if (this.functionInterfaceType) {\n                        leftScope = this.functionInterfaceType.memberScope;\n                    }\n                    else {\n                        binex.type = this.anyType;\n                        return binex;\n                    }\n                }\n                else if (leftType.elementType) {\n                    if (this.arrayInterfaceType) {\n                        var arrInstType = leftType.elementType.getArrayBase(this.arrayInterfaceType, this.checker);\n                        leftScope = arrInstType.memberScope;\n                    }\n                    else {\n                        binex.type = this.anyType;\n                        return binex;\n                    }\n                }\n                else {\n                    leftScope = leftType.memberScope;\n                }\n            }\n            if (leftScope == null) {\n                this.checker.errorReporter.expectedClassOrInterface(binex);\n                binex.type = this.anyType;\n            }\n            else {\n                var propertyName = <Identifier>binex.operand2;\n                var lhsIsEnclosingType = (this.thisClassNode && binex.operand1.type == this.thisClassNode.type.instanceType) || this.inTypeRefTypeCheck;\n                var symbol = leftScope.find(propertyName.text, !lhsIsEnclosingType, this.inTypeRefTypeCheck); // only search the public members, unless the rhs is a 'this' pointer\n\n                // If the symbol wasn't found, delegate to the appropriate 'virtual' parent type\n                if (!symbol) {\n                    if (this.objectInterfaceType && leftType) {\n                        // check 'Object' for the symbol\n                        if (leftType.isReferenceType()) {\n                            symbol = this.objectInterfaceType.memberScope.find(propertyName.text, false, this.inTypeRefTypeCheck);\n                        }\n                        if (!symbol) {\n                            // check 'Function', if appropriate\n                            if (this.functionInterfaceType && (leftType.call || leftType.construct)) {\n                                symbol = this.functionInterfaceType.memberScope.find(propertyName.text, false, this.inTypeRefTypeCheck);\n                            }\n                        }\n                    }\n                }\n\n                if (!symbol || (!symbol.visible(leftScope, this.checker))) {\n                    binex.type = this.anyType;\n\n                    if (symbol == null) {\n                        this.checker.errorReporter.simpleError(propertyName, \"The property '\" + propertyName.actualText + \"' does not exist on value of type '\" + leftType.getScopedTypeName(this.scope) + \"'\");\n                    }\n                    else if (!this.inTypeRefTypeCheck) {  // if it's a dotted type reference, we'll catch the visibility error during binding\n                        this.checker.errorReporter.simpleError(binex, \"The property '\" + propertyName.actualText + \" on type '\" + leftType.getScopedTypeName(this.scope) + \"' is not visible\");\n                    }\n                }\n                else {\n                    if (symbol.isVariable()) {\n                        if (symbol.isInferenceSymbol()) {\n                            var infSym = <InferenceSymbol>symbol;\n                            if (infSym.declAST && !this.checker.typeStatusIsFinished(infSym.typeCheckStatus)) {\n                                this.inScopeTypeCheckDecl(infSym.declAST);\n                            }\n                        }\n                    }\n                    propertyName.sym = symbol;\n                    binex.type = symbol.getType();\n                }\n            }\n            if (binex.type == null) {\n                binex.type = this.anyType;\n            }\n\n            return binex;\n        }\n\n        public typeCheckBooleanOperator(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            var leftType = binex.operand1.type;\n            var rightType = binex.operand2.type;\n            if ((!";
var v27479 = v27480 + '(this.checker.sourceIsAssignableToTarget(leftType, rightType))) &&\n                (!(this.checker.sourceIsAssignableToTarget(rightType, leftType)))) {\n                this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType, binex.printLabel(), this.scope);\n            }\n            binex.type = this.booleanType;\n            return binex;\n        }\n\n        public typeCheckAsgOperator(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            var applyTargetType = !binex.operand2.isParenthesized;\n            binex.operand1 = this.typeCheck(binex.operand1);\n\n            this.checker.typeCheckWithContextualType(binex.operand1.type, this.checker.inProvisionalTypecheckMode(), applyTargetType, binex.operand2);\n\n            var leftType = binex.operand1.type;\n            var rightType = binex.operand2.type;\n\n            if (!(this.astIsWriteable(binex.operand1))) {\n                this.checker.errorReporter.valueCannotBeModified(binex);\n            }\n            if (binex.operand1.nodeType == NodeType.Call) {\n                var callEx = <CallExpression>binex.operand1;\n            }\n            var preserveScope = false;\n            var preservedContainedScope = null;\n            if (binex.operand2.type) {\n                preservedContainedScope = binex.operand2.type.containedScope;\n                preserveScope = true;\n            }\n            // Do not re-write the AST in provisional typecheck mode\n            binex.operand2 = this.castWithCoercion(binex.operand2, leftType, applyTargetType && !this.checker.inProvisionalTypecheckMode(), false);\n            if (preserveScope && binex.operand2.type.containedScope == null) {\n                binex.operand2.type.containedScope = preservedContainedScope;\n            }\n            binex.type = rightType;\n            return binex;\n        }\n\n        public typeCheckIndex(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            binex.operand1 = this.typeCheck(binex.operand1); // ObjExpr\n            binex.operand2 = this.typeCheck(binex.operand2); // IndexExpr\n\n            if (!this.checker.styleSettings.literalSubscript) {\n                if (binex.operand2.nodeType == NodeType.QString) {\n                    this.checker.errorReporter.styleError(ast, "use literal subscript (\'.\') notation instead)");\n                }\n            }\n\n            var objExprType = binex.operand1.type;\n            var indexExprType = binex.operand2.type;\n\n            if (objExprType.elementType) { // arrays\n                if (indexExprType == this.checker.anyType || indexExprType == this.checker.numberType || hasFlag(indexExprType.typeFlags, TypeFlags.IsEnum)) {\n                    binex.type = objExprType.elementType;\n                }\n                else if (indexExprType == this.checker.stringType) {\n                    binex.type = this.checker.anyType;\n                }\n                else {\n                    this.checker.errorReporter.simpleError(binex, "Illegal property access");\n                    binex.type = this.checker.anyType;\n                }\n            }\n            else if (objExprType.index) { // types with index sigs\n\n                if (indexExprType == this.checker.anyType ||\n                    !((objExprType.index.flags & SignatureFlags.IsStringIndexer) || (objExprType.index.flags & SignatureFlags.IsNumberIndexer)) || // REVIEW: unvalidated type expression\n                    ((objExprType.index.flags & SignatureFlags.IsStringIndexer) && indexExprType == this.checker.stringType) ||\n                    ((objExprType.index.flags & SignatureFlags.IsNumberIndexer) && (indexExprType == this.checker.numberType || hasFlag(indexExprType.typeFlags, TypeFlags.IsEnum)))) {\n                    var sig = this.resolveOverload(ast, objExprType.index);\n                    if (sig) {\n                        binex.type = sig.returnType.type;//objExprType.index.signatures[0].returnType.type;\n                    }\n                    else {\n                        binex.type = this.checker.anyType;\n                    }\n                }\n                else if (indexExprType == this.checker.stringType) {\n                    binex.type = this.checker.anyType;\n                }\n                else {\n                    this.checker.errorReporter.simpleError(binex, "Illegal property access");\n                    binex.type = this.checker.anyType;\n                }\n            }\n            else if ((objExprType == this.checker.anyType ||\n                     objExprType == this.checker.stringType ||\n                     objExprType == this.checker.numberType ||\n                     objExprType == this.checker.booleanType ||\n                     objExprType.isReferenceType()) &&\n                     (indexExprType == this.checker.anyType ||\n                      indexExprType == this.checker.stringType ||\n                      (indexExprType == this.checker.numberType || hasFlag(indexExprType.typeFlags, TypeFlags.IsEnum)))) { // RE';
var v27478 = v27479 + 'VIEW: Do we want to allow indexes of type \'number\'?\n                binex.type = this.checker.anyType;\n            }\n            else {\n                this.checker.errorReporter.simpleError(binex, "Illegal property access");\n                binex.type = this.checker.anyType;\n            }\n\n            return binex;\n        }\n\n        public typeCheckInOperator(binex: BinaryExpression): BinaryExpression {\n            binex.operand1 = this.cast(this.typeCheck(binex.operand1), this.stringType);\n            binex.operand2 = this.typeCheck(binex.operand2);\n\n            if (!((binex.operand1.type == this.checker.anyType || binex.operand1.type == this.checker.stringType) &&\n                    (binex.operand2.type == this.anyType || this.checker.sourceIsSubtypeOfTarget(binex.operand2.type, this.objectInterfaceType)))) {\n                this.checker.errorReporter.simpleError(binex, "The in operator requires the left operand to be of type Any or the String primitive type, and the right operand to be of type Any or an object type");\n            }\n\n            binex.type = this.booleanType;\n            return binex;\n        }\n\n        public typeCheckShift(binex: BinaryExpression, assignment: bool): BinaryExpression {\n            binex.operand1 = this.cast(this.typeCheck(binex.operand1), this.doubleType);\n            binex.operand2 = this.cast(this.typeCheck(binex.operand2), this.doubleType);\n            if (assignment && (!(this.astIsWriteable(binex.operand1)))) {\n                this.checker.errorReporter.valueCannotBeModified(binex);\n            }\n            binex.type = this.doubleType;\n            return binex;\n        }\n\n        public typeCheckQMark(trinex: ConditionalExpression): ConditionalExpression {\n            trinex.operand1 = this.typeCheck(trinex.operand1);\n            trinex.operand2 = this.typeCheck(trinex.operand2);\n            trinex.operand3 = this.typeCheck(trinex.operand3);\n            var leftType = trinex.operand2.type;\n            var rightType = trinex.operand3.type;\n\n            if (leftType == rightType) {\n                trinex.type = leftType;\n            }\n            else {\n                if (this.checker.sourceIsSubtypeOfTarget(leftType, rightType)) {\n                    trinex.type = rightType;\n                }\n                else if (this.checker.sourceIsSubtypeOfTarget(rightType, leftType)) {\n                    trinex.type = leftType;\n                }\n                else {\n                    trinex.type = this.anyType;\n                    this.checker.errorReporter.incompatibleTypes(trinex, leftType, rightType, trinex.printLabel(), this.scope);\n                }\n            }\n\n            return trinex;\n        }\n\n        public addFormals(container: Symbol, signature: Signature,\n            table: IHashTable) {\n            var len = signature.parameters.length;\n            for (var i = 0; i < len; i++) {\n                var symbol = <ParameterSymbol>signature.parameters[i];\n                symbol.container = container;\n                table.add(symbol.name, symbol);\n            }\n        }\n\n        // REVIEW: We use isModContainer instead of container.getType().isModuleType because container.type may be null at this\n        // juncture\n        public addLocalsFromScope(scope: SymbolScope, container: Symbol, vars: ASTList, table: IHashTable, isModContainer: bool) {\n            var len = vars.members.length;\n            var hasArgsDef = false;\n            for (var i = 0; i < len; i++) {\n                var local = <VarDecl>vars.members[i];\n                if (((local.sym == null) || (local.sym.kind() != SymbolKind.Field))) {\n                    var result: Symbol = null;\n                    if ((result = table.lookup(local.id.text)) == null) {\n                        var localVar: ValueLocation = new ValueLocation();\n                        localVar.typeLink = new TypeLink();\n                        var varSym = null;\n\n                        if (hasFlag(local.varFlags, VarFlags.Static)) {\n                            local.varFlags |= VarFlags.LocalStatic;\n                            varSym = new FieldSymbol(local.id.text, local.minChar,\n                                                      this.checker.locationInfo.unitIndex,\n                                                      true, localVar);\n                        }\n                        else {\n                            varSym = new VariableSymbol(local.id.text, local.minChar,\n                                                      this.checker.locationInfo.unitIndex,\n                                                      localVar);\n                        }\n                        varSym.transferVarFlags(local.varFlags);\n                        localVar.symbol = varSym;\n                        varSym.declAST = local;\n                        localVar.typeLink.ast = local.typeExpr;\n                        this.checker.resolveTypeLink(scope, localVar.typeLink, false);\n                        if ((local.type == null) &&';
var v27477 = v27478 + ' (local.init == null)) {\n                            local.type = this.anyType;\n                        }\n                        localVar.typeLink.type = local.type;\n                        localVar.symbol.container = container;\n                        local.sym = localVar.symbol;\n                        table.add(local.id.text, varSym);\n                        if (local.id.text == "arguments") {\n                            hasArgsDef = true;\n                        }\n                    }\n                    else {\n                        local.type = result.getType();\n                        local.sym = result;\n                    }\n                }\n            }\n            if (!isModContainer) {\n                if (!hasArgsDef) {\n                    var argLoc = new ValueLocation();\n                    argLoc.typeLink = new TypeLink();\n                    var theArgSym = new VariableSymbol("arguments", vars.minChar,\n                                                     this.checker.locationInfo.unitIndex,\n                                                     argLoc);\n\n                    // if the user is using a custom lib.d.ts where IArguments has not been defined\n                    // (or they\'re compiling with the --nolib option), use \'any\' as the argument type\n                    if (!this.iargumentsInterfaceType) {\n                        var argumentsSym = scope.find("IArguments", false, true);\n\n                        if (argumentsSym) {\n                            argumentsSym.flags |= SymbolFlags.CompilerGenerated;\n                            this.iargumentsInterfaceType = argumentsSym.getType();\n                        }\n                        else {\n                            this.iargumentsInterfaceType = this.anyType;\n                        }\n                    }\n                    argLoc.typeLink.type = this.iargumentsInterfaceType;\n                    table.add("arguments", theArgSym);\n                }\n            }\n        }\n\n        // REVIEW: isClass param may now be redundant\n        public addConstructorLocalArgs(container: Symbol, args: ASTList, table: IHashTable, isClass: bool): void {\n            if (args) {\n                var len = args.members.length;\n                for (var i = 0; i < len; i++) {\n                    var local = <ArgDecl>args.members[i];\n                    if ((local.sym == null) ||\n                        (isClass || (local.sym.kind() != SymbolKind.Field))) {\n                        var result: Symbol = null;\n                        if ((result = table.lookup(local.id.text)) == null) {\n                            this.resolveBoundDecl(local);\n                            var localVar: ValueLocation = new ValueLocation();\n                            localVar.typeLink = new TypeLink();\n                            var varSym = new ParameterSymbol(local.id.text, local.minChar,\n                                                                   this.checker.locationInfo.unitIndex,\n                                                                   localVar);\n                            varSym.declAST = local;\n                            localVar.symbol = varSym;\n                            localVar.typeLink.type = local.type;\n                            localVar.symbol.container = container;\n                            local.sym = localVar.symbol;\n                            table.add(local.id.text, varSym);\n                        }\n                        else {\n                            local.type = result.getType();\n                            local.sym = result;\n                        }\n                    }\n                }\n            }\n        }\n\n        public checkInitSelf(funcDecl: FuncDecl): bool {\n            if (!funcDecl.isMethod()) {\n                var freeVars = funcDecl.freeVariables;\n                for (var k = 0, len = freeVars.length; k < len; k++) {\n                    var sym = freeVars[k];\n                    if (sym.isInstanceProperty()) {\n                        return true;\n                    }\n                }\n            }\n            var fns = funcDecl.scopes;\n            var fnsLen = fns.members.length;\n\n            for (var j = 0; j < fnsLen; j++) {\n                var fn = <FuncDecl>fns.members[j];\n                if (this.checkInitSelf(fn)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        public checkPromoteFreeVars(funcDecl: FuncDecl, constructorSym: Symbol): void {\n            var freeVars = funcDecl.freeVariables;\n            for (var k = 0, len = freeVars.length; k < len; k++) {\n                var sym = freeVars[k];\n                if ((!sym.isInstanceProperty()) && (sym.container == constructorSym)) {\n                    instanceFilter.reset();\n                    if (this.scope.search(instanceFilter, sym.name, false, false)) {\n                        this.checker.errorReporter.simpleError(funcDecl, "Constructor-local variable shadows class property';
var v27476 = v27477 + ' \'" + sym.name + "\'. To access the class property, use \'self." + sym.name + "\'");\n                    }\n\n                    this.checker.errorReporter.simpleError(funcDecl, "Constructor-local variables may not be accessed from instance method bodies. Consider changing local variable \'" + sym.name + "\' to a class property")\n                }\n            }\n        }\n\n        public allReturnsAreVoid(funcDecl: FuncDecl) {\n            // in the case of a function or method with no declared return type, walk the body to \n            // pre-emptively determine if the function has a return type of void\n            //\n            // REVIEW: Eventually, we\'ll want to perform exit graph analysis to determine\n            // if the function ever "escapes" without a return expression\n            // This would require moving some of this logic into the function\'s typecheck-proper,\n            // which would slow things down a fair bit, but would open up more analysis opportunities\n            var allReturnsAreVoid = true;\n\n            if (funcDecl.signature.returnType.type == null) {\n                var preFindReturnExpressionTypes = function (ast: AST, parent: AST, walker: IAstWalker) {\n                    var go = true;\n                    switch (ast.nodeType) {\n                        case NodeType.FuncDecl:\n                            // don\'t recurse into a function decl - we don\'t want to confuse a nested\n                            // return type with the top-level function\'s return type\n                            go = false;\n                            break;\n                        case NodeType.Return:\n                            var returnStmt: ReturnStatement = <ReturnStatement>ast;\n\n                            if (returnStmt.returnExpression) {\n                                allReturnsAreVoid = false;\n                                go = false;\n                            }\n\n                        default:\n                            break;\n                    }\n                    walker.options.goChildren = go;\n                    walker.options.goNextSibling = go;\n                    return ast;\n                }\n\n                getAstWalkerFactory().walk(funcDecl.bod, preFindReturnExpressionTypes);\n            }\n\n            return allReturnsAreVoid;\n        }\n\n        public classConstructorHasSuperCall(funcDecl: FuncDecl) {\n            var foundSuper = false;\n\n            var preFindSuperCall = function (ast: AST, parent: AST, walker: IAstWalker) {\n\n                var go = true;\n\n                switch (ast.nodeType) {\n                    case NodeType.FuncDecl:\n                        go = false;\n                        break;\n                    case NodeType.Call:\n                        var call = <CallExpression>ast;\n\n                        if (call.target.nodeType == NodeType.Super) {\n                            go = false;\n                            foundSuper = true;\n                            break;\n                        }\n                        break;\n                    default:\n                        break;\n                }\n                walker.options.goChildren = go;\n                return ast;\n            }\n\n            getAstWalkerFactory().walk(funcDecl.bod, preFindSuperCall);\n\n            return foundSuper;\n        }\n\n        private baseListPrivacyErrorReporter(bases: ASTList, i: number, declSymbol: Symbol, extendsList: bool, typeName: string, isModuleName: bool) {\n            var baseSymbol = bases.members[i].type.symbol;\n            var declTypeString = (declSymbol.declAST.nodeType == NodeType.InterfaceDeclaration) ? "interface" : "class";\n            var baseListTypeString = extendsList ? "extends" : "implements";\n            var baseTypeString = (baseSymbol.declAST.nodeType == NodeType.InterfaceDeclaration) ? "interface" : "class";\n            var typestring = "";\n            if (isModuleName) {\n                var quotestring = "";\n                if (!isQuoted(typeName)) {\n                    quotestring = "\'";\n                }\n                typestring = " is using inaccessible module ";\n                baseTypeString = " " + baseTypeString + " from private module " + quotestring + typeName + quotestring;\n            } else {\n                baseTypeString = " private " + baseTypeString + " \'" + typeName + "\'";\n            }\n            this.checker.errorReporter.simpleError(bases.members[i], "exported " + declTypeString + " \'" + declSymbol.name + "\' " + baseListTypeString + baseTypeString);\n        }\n\n        // Check if declSymbol can satisfy baselist privacy\n        private typeCheckBaseListPrivacy(bases: ASTList, declSymbol: Symbol, extendsList: bool) {\n            if (bases) {\n                var basesLen = bases.members.length;\n                for (var i = 0; i < basesLen; i++) {\n                    if (!bases.members[i].type || bases.members[i].type == this.checker.anyType) {\n                        // This type is coming from external module so it ha';
var v27475 = v27476 + "s to be exported, or we're recovering from an\n                        // error condition\n                        continue;\n                    }\n\n                    this.checkSymbolPrivacy(bases.members[i].type.symbol, declSymbol, (typeName: string, isModuleName: bool) => this.baseListPrivacyErrorReporter(bases, i, declSymbol, extendsList, typeName, isModuleName));\n                }\n            }\n        }\n\n        // Checks if the privacy is satisfied by typeSymbol that is used in the declaration inside container\n        private checkSymbolPrivacy(typeSymbol: TypeSymbol, declSymbol: Symbol, errorCallback: (typeName: string, isModuleName: bool) => void ) {\n            var externalModuleSymbol: TypeSymbol = null;\n            var declSymbolPath: Symbol[] = null;\n\n            // Type is visible type, so this can be used by anyone.\n            if (typeSymbol.isExternallyVisible(this.checker)) {\n                // Symbol could be from external module, go ahead and find the external module\n                var typeSymbolPath = typeSymbol.pathToRoot();\n                declSymbolPath = declSymbol.pathToRoot();\n                var typeSymbolLength = typeSymbolPath.length;\n                var declSymbolPathLength = declSymbolPath.length;\n\n                if (typeSymbolLength > 0) {\n                    if (typeSymbolPath[typeSymbolLength - 1].getType().isModuleType() &&\n                        (<TypeSymbol>typeSymbolPath[typeSymbolLength - 1]).isDynamic &&\n                        typeSymbolPath[typeSymbolLength - 1] != declSymbolPath[declSymbolPathLength - 1]) {\n                        // Symbol from external module that was imported using one of the import statement\n                        externalModuleSymbol = <TypeSymbol>typeSymbolPath[typeSymbolLength - 1];\n                    } else if (typeSymbolLength > 1) {\n                        // Is symbol from declared quoted module\n                        if (typeSymbolPath[typeSymbolLength - 2].getType().isModuleType() &&\n                            (<TypeSymbol>typeSymbolPath[typeSymbolLength - 2]).isDynamic &&\n                            (declSymbolPathLength == 1 || typeSymbolPath[typeSymbolLength - 2] != declSymbolPath[declSymbolPathLength - 2])) {\n                            // From quoted module name\n                            externalModuleSymbol = <TypeSymbol>typeSymbolPath[typeSymbolLength - 2];\n                        }\n                    }\n                }\n\n                if (externalModuleSymbol == null) {\n                    return;\n                }\n            }\n\n            // Interface symbol doesn't reflect correct Exported state so use AST instead\n            var interfaceDecl: InterfaceDeclaration = declSymbol.getInterfaceDeclFromSymbol(this.checker);\n            if (interfaceDecl && !hasFlag(interfaceDecl.varFlags, VarFlags.Exported)) {\n                return;\n            }\n\n            var checkVisibilitySymbol = declSymbol;\n            // Var decl symbol doesnt reflect correct exported state so use AST instead\n            var varDecl = declSymbol.getVarDeclFromSymbol();\n            if (varDecl) {\n                if (hasFlag(varDecl.varFlags, VarFlags.Private)) {\n                    return;\n                } else if (hasFlag(varDecl.varFlags, VarFlags.Public)) {\n                    // Its a member from class so check visibility of its container\n                    checkVisibilitySymbol = declSymbol.container;\n                }\n            }\n\n            // If the container is visible from global scrope it is error\n            if (checkVisibilitySymbol.isExternallyVisible(this.checker)) {\n                var privateSymbolName = typeSymbol.name;\n\n                // If imported typeSymbol mark it as visible externally and verify that the symbol it imports is visible externally\n                if (externalModuleSymbol != null) {\n                    var prettyName = externalModuleSymbol.getPrettyNameOfDynamicModule(declSymbolPath);\n                    if (prettyName != null) {\n                        this.currentScript.AddExternallyVisibleImportedSymbol(prettyName.symbol, this.checker);\n                        return;\n                    } else {\n                        privateSymbolName = externalModuleSymbol.prettyName;\n                    }\n                }\n\n                // Visible declaration using non visible type.\n                errorCallback(privateSymbolName, typeSymbol.name != privateSymbolName);\n            }\n        }\n\n        // Checks if the privacy is satisfied by type that is used in the declaration inside container\n        private checkTypePrivacy(type: Type, declSymbol: Symbol, errorCallback: (typeName: string, isModuleName : bool) =>void ) {\n            // Primitive types\n            if (!(type && type.primitiveTypeClass == Primitive.None)) {\n                return;\n            }\n\n\n            // If type is array, check element type\n            if (type.isArray()) {\n                return this.checkTypePrivacy(type.elementTyp";
var v27474 = v27475 + 'e, declSymbol, errorCallback);\n            }\n\n            // Going to be printing symbol name, verify if symbol can be emitted\n            if (type.symbol && type.symbol.name && type.symbol.name != "_anonymous" &&\n                        (((type.call == null) && (type.construct == null) && (type.index == null)) ||\n                        (type.members && (!type.isClass())))) {\n                return this.checkSymbolPrivacy(<TypeSymbol>type.symbol, declSymbol, errorCallback);\n            }\n\n            if (type.members) {\n                // Verify symbols for members\n                type.members.allMembers.map((key, s, unused) => {\n                    var sym = <Symbol>s;\n                    if (!hasFlag(sym.flags, SymbolFlags.BuiltIn)) {\n                        this.checkTypePrivacy(sym.getType(), declSymbol, errorCallback);\n                    }\n                }, null);\n            }\n\n            this.checkSignatureGroupPrivacy(type.call, declSymbol, errorCallback);\n            this.checkSignatureGroupPrivacy(type.construct, declSymbol, errorCallback);\n            this.checkSignatureGroupPrivacy(type.index, declSymbol, errorCallback);\n        }\n\n        // Checks if the privacy is satisfied by typeSymbol that is used in the declaration inside container\n        private checkSignatureGroupPrivacy(sgroup: SignatureGroup, declSymbol: Symbol, errorCallback: (typeName: string, isModuleName : bool) =>void ) {\n            if (sgroup) {\n                var len = sgroup.signatures.length;\n                for (var i = 0; i < sgroup.signatures.length; i++) {\n                    var signature = sgroup.signatures[i];\n                    if (len > 1 && signature == sgroup.definitionSignature) {\n                        // In case of overloads don\'t look up for overload defintion types.\n                        continue;\n                    }\n\n                    if (signature.returnType) {\n                        this.checkTypePrivacy(signature.returnType.type, declSymbol, errorCallback);\n                    }\n\n                    var paramLen = signature.parameters.length;\n                    for (var j = 0; j < paramLen; j++) {\n                        var param = signature.parameters[j];\n                        this.checkTypePrivacy(param.getType(), declSymbol, errorCallback);\n                    }\n                }\n            }\n        }\n\n        private functionArgumentPrivacyErrorReporter(funcDecl: FuncDecl, p: number, paramSymbol: Symbol, typeName: string, isModuleName: bool) {\n            var isGetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor);\n            var isSetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.SetAccessor);\n            var isPublicFunc = hasFlag(funcDecl.fncFlags, FncFlags.Public);\n            var isContainerInterface = funcDecl.type.symbol.getInterfaceDeclFromSymbol(this.checker) != null;\n            var typestring = "";\n            if (isModuleName) {\n                var quotestring = "";\n                if (!isQuoted(typeName)) {\n                    quotestring = "\'";\n                }\n                typestring = " is using inaccessible module " + quotestring + typeName + quotestring;\n            } else {\n                typestring = " has or is using private type \'" + typeName + "\'";\n            }\n\n            if (!isContainerInterface) {\n                if (funcDecl.isConstructor) {\n                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported class\'s constructor parameter \'" + paramSymbol.name + "\'" + typestring);\n                } else if (isSetter) {\n                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], (isPublicFunc ? "public" : "exported") + " setter parameter \'" + paramSymbol.name + "\'" + typestring);\n                } else if (!isGetter) {\n                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], (isPublicFunc ? "public" : "exported") + " function parameter \'" + paramSymbol.name + "\'" + typestring);\n                }\n            } else {\n                if (funcDecl.isConstructMember()) {\n                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported interface\'s constructor parameter \'" + paramSymbol.name + "\'" + typestring);\n                } else if (funcDecl.isCallMember()) {\n                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported interface\'s call parameter \'" + paramSymbol.name + "\'" + typestring);\n                } else if (!funcDecl.isIndexerMember()) {\n                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported interface\'s function parameter \'" + paramSymbol.name + "\'" + typestring);\n                }\n            }\n        }\n\n        private returnTypePrivacyError(astError: AST, funcDecl: FuncDecl, typeName: string, isModuleName: bool) {\n            var isGetter = funcDecl.isAccessor() && hasFlag(funcD';
var v27473 = v27474 + 'ecl.fncFlags, FncFlags.GetAccessor);\n            var isSetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.SetAccessor);\n            var isPublicFunc = hasFlag(funcDecl.fncFlags, FncFlags.Public);\n            var isContainerInterface = funcDecl.type.symbol.getInterfaceDeclFromSymbol(this.checker) != null;\n            var typestring = "";\n            if (isModuleName) {\n                var quotestring = "";\n                if (!isQuoted(typeName)) {\n                    quotestring = "\'";\n                }\n                typestring = " is using inaccessible module " + quotestring + typeName + quotestring;\n            } else {\n                typestring = " has or is using private type \'" + typeName + "\'";\n            }\n            if (!isContainerInterface) {\n                if (isGetter) {\n                    this.checker.errorReporter.simpleError(astError, (isPublicFunc ? "public" : "exported") + " getter return type" + typestring);\n                } else if (!isSetter) {\n                    this.checker.errorReporter.simpleError(astError, (isPublicFunc ? "public" : "exported") + " function return type" + typestring);\n                }\n            } else {\n                if (funcDecl.isConstructMember()) {\n                    this.checker.errorReporter.simpleError(astError, "exported interface\'s constructor return type" + typestring);\n                } else if (funcDecl.isCallMember()) {\n                    this.checker.errorReporter.simpleError(astError, "exported interface\'s call return type" + typestring);\n                } else if (funcDecl.isIndexerMember()) {\n                    this.checker.errorReporter.simpleError(astError, "exported interface\'s indexer return type" + typestring);\n                } else {\n                    this.checker.errorReporter.simpleError(astError, "exported interface\'s function return type" + typestring);\n                }\n            }\n        }\n\n        private functionReturnTypePrivacyErrorReporter(funcDecl: FuncDecl, signature: Signature, typeName: string, isModuleName: bool) {\n            var reportOnFuncDecl = false;\n\n            // Error coming from return annotation\n            if (funcDecl.returnTypeAnnotation != null &&\n                funcDecl.returnTypeAnnotation.type == signature.returnType.type) {\n                this.returnTypePrivacyError(funcDecl.returnTypeAnnotation, funcDecl, typeName, isModuleName);\n            }\n\n            // Check if return statement\'s type matches the one that we concluded\n            for (var i = 0; i < funcDecl.returnStatementsWithExpressions.length; i++) {\n                if (funcDecl.returnStatementsWithExpressions[i].type == signature.returnType.type) {\n                    this.returnTypePrivacyError(funcDecl.returnStatementsWithExpressions[i], funcDecl, typeName, isModuleName);\n                } else {\n                    reportOnFuncDecl = true;\n                }\n            }\n\n            if (reportOnFuncDecl) {\n                // Show on function decl\n                this.returnTypePrivacyError(funcDecl, funcDecl, typeName, isModuleName);\n            }\n        }\n\n        public typeCheckFunction(funcDecl: FuncDecl): FuncDecl {\n            this.nestingLevel = 0;\n            var fnType = funcDecl.type;\n\n            var fgSym = fnType.symbol;\n            var signature = funcDecl.signature;\n\n            if (this.checker.typeStatusIsFinished(signature.typeCheckStatus)) {\n                return funcDecl;\n            }\n            else if (signature.typeCheckStatus == TypeCheckStatus.Started) {\n                if (!funcDecl.returnTypeAnnotation &&\n                    funcDecl.bod &&\n                       !funcDecl.isSignature() &&\n                       !(funcDecl.isConstructor) &&\n                       this.allReturnsAreVoid(funcDecl)) {\n\n                    signature.returnType.type = this.voidType;\n                    return funcDecl;\n                }\n                else {\n                    if (funcDecl.returnTypeAnnotation == null) {\n                        if (this.checker.styleSettings.implicitAny) {\n                            this.checker.errorReporter.styleError(funcDecl, "type implicitly set to \'any\'");\n                        }\n                        signature.returnType.type = this.anyType;\n                        fgSym.flags |= SymbolFlags.RecursivelyReferenced;\n                    }\n                    return funcDecl;\n                }\n            }\n\n            signature.typeCheckStatus = TypeCheckStatus.Started;\n            this.checker.addStartedPTO(signature);\n            var prevScope = this.scope;\n            var prevFnc = this.thisFnc;\n            var prevMethodStatus = this.enclosingFncIsMethod;\n            var prevClassNode = this.thisClassNode;\n            this.enclosingFncIsMethod = funcDecl.isMethod() || funcDecl.isConstructor;\n            this.thisFnc = funcDecl;\n            var container = funcDecl.type.symbol;\n            var prevThisType = this.thisType;\n            var pr';
var v27472 = v27473 + "evLocationInfo = this.checker.locationInfo;\n            var funcTable: IHashTable = null;\n            var acceptedContextualType = false;\n            var targetParams: ParameterSymbol[] = null;\n            var targetReturnType: Type = null;\n            var isGetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor);\n            var isSetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.SetAccessor);\n            var accessorType: Type = (isGetter || isSetter) && funcDecl.accessorSymbol ? funcDecl.accessorSymbol.getType() : null;\n            var prevModDecl = this.checker.currentModDecl;\n\n            if (funcDecl.isConstructor && !funcDecl.isOverload) {\n                if (fnType.instanceType == null) {\n                    this.checker.errorReporter.simpleError(funcDecl, \"Malformed function body (is this a class named the same as an existing interface?)\");\n                    return funcDecl;\n                }\n\n                this.scope = fnType.instanceType.constructorScope;\n                var ssb = <SymbolScopeBuilder>this.scope;\n                funcTable = ssb.valueMembers.allMembers;\n            }\n            else if ((funcDecl.isSpecialFn() && !(funcDecl.fncFlags & FncFlags.Signature)) || funcDecl.isOverload) {\n                funcTable = funcDecl.symbols;\n                // if the function is static, we just want to use the \n                // current scope\n                if (!hasFlag(funcDecl.fncFlags, FncFlags.Static) && fnType.containedScope) {\n                    this.scope = fnType.containedScope;\n                }\n            }\n            else {\n                if (funcDecl.bod) {\n                    this.scope = fnType.containedScope;\n                }\n                var ssb = <SymbolScopeBuilder>this.scope;\n\n                // If it is null, it's an ambient declaration with no body, so it doesn't strictly matter\n                // if funcTable is not set\n                if (ssb && ssb.valueMembers) {\n                    funcTable = ssb.valueMembers.allMembers;\n                }\n            }\n\n            // If it's a class constructor, we need to check for the presence (or absense) of calls\n            // to the 'super' constructor\n            //\n            // A super constructor call must exist if:\n            //  - the class has a base class\n            //\n            // A super constructor call must be the first statement in the function body if:\n            //  - the constructor has parameter properties or\n            //  - the class body has initialized property decls\n            //\n            // A super constructor call may not exist if:\n            //  - The class has no base type, or inherits directly from 'Object'\n            if (funcDecl.isConstructor && funcDecl.bod && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {\n\n                var hasBaseType = hasFlag(funcDecl.classDecl.type.instanceType.typeFlags, TypeFlags.HasBaseType);\n                var noSuperCallAllowed = !hasBaseType || hasFlag(funcDecl.classDecl.type.instanceType.typeFlags, TypeFlags.HasBaseTypeOfObject);\n                var superCallMustBeFirst = hasFlag((<ClassDeclaration>funcDecl.classDecl).varFlags, VarFlags.ClassSuperMustBeFirstCallInConstructor);\n\n                if (noSuperCallAllowed && this.classConstructorHasSuperCall(funcDecl)) {\n                    this.checker.errorReporter.simpleError(funcDecl, \"Calls to 'super' constructor are not allowed in classes that either inherit directly from 'Object' or have no base class\");\n                }\n                else if (hasBaseType) {\n                    if (superCallMustBeFirst) {\n                        if (!funcDecl.bod ||\n                            !funcDecl.bod.members.length ||\n                            !((funcDecl.bod.members[0].nodeType == NodeType.Call && (<CallExpression>funcDecl.bod.members[0]).target.nodeType == NodeType.Super) ||\n                            (hasFlag(funcDecl.bod.flags, ASTFlags.StrictMode) && funcDecl.bod.members.length > 1 &&\n                             funcDecl.bod.members[1].nodeType == NodeType.Call && (<CallExpression>funcDecl.bod.members[1]).target.nodeType == NodeType.Super))) {\n                            this.checker.errorReporter.simpleError(funcDecl, \"If a derived class contains initialized properties or constructor parameter properties, the first statement in the constructor body must be a call to the super constructor\");\n                        }\n                    }\n                    else if (!this.classConstructorHasSuperCall(funcDecl)) {\n                        this.checker.errorReporter.simpleError(funcDecl, \"Constructors for derived classes must contain a call to the class's 'super' constructor\");\n                    }\n                }\n            }\n\n            // If we've typechecked this method \"out of order\" (not by walking the class, but through a method call somewhere else),\n            // we need to reset the current class node in question, so that vis";
var v27471 = v27472 + "ibility checks on class members don't fail\n            if (funcDecl.isMethod() && funcDecl.type.enclosingType) {\n\n                var enclosingClassNode: TypeDeclaration = null;\n\n                if (funcDecl.type.enclosingType.symbol.declAST.nodeType == NodeType.FuncDecl) {\n                    enclosingClassNode = <TypeDeclaration>(<FuncDecl>funcDecl.type.enclosingType.symbol.declAST).classDecl;\n                }\n                else if (funcDecl.type.enclosingType.symbol.declAST.nodeType == NodeType.ClassDeclaration) {\n                    enclosingClassNode = <TypeDeclaration>funcDecl.type.enclosingType.symbol.declAST;\n                }\n\n                if (enclosingClassNode) {\n                    this.thisClassNode = enclosingClassNode;\n                }\n            }\n\n            // if this function is contained in a module, we may be in the midst of a recursive typecheck operation\n            // should that be the case, we need to properly set the current module (for visibility tests)\n            if (fnType.enclosingType) {;\n                var enclosingSym = fnType.symbol.container;\n\n                // if the enclosing type is a class, grab the parent module\n                if (enclosingSym && enclosingSym.isType() && enclosingSym.getType().isClass()) {\n                    enclosingSym = enclosingSym.container;\n                }\n\n                if (enclosingSym && enclosingSym.declAST && enclosingSym.declAST.nodeType == NodeType.ModuleDeclaration) {\n                    this.checker.currentModDecl = <ModuleDeclaration>enclosingSym.declAST;\n                }\n            }\n\n            if (funcDecl.unitIndex > 0) {\n                if (this.checker.units &&\n                    (funcDecl.unitIndex < this.checker.units.length)) {\n                    this.checker.locationInfo = this.checker.units[funcDecl.unitIndex];\n                }\n                else {\n                    this.checker.locationInfo = unknownLocationInfo;\n                }\n            }\n\n            if (fnType.enclosingType) {\n                this.thisType = fnType.enclosingType;\n            }\n            else {\n                this.thisType = prevThisType;\n            }\n\n            var paramLen = signature.parameters.length;\n\n            if (!funcDecl.isConstructor && funcDecl.bod && !funcDecl.isSignature()) {\n                var tmpParamScope = this.scope;\n                var ssb = <SymbolScopeBuilder>this.scope;\n\n                // Attempt to contextually type the function declaration             \n                if (!funcDecl.isMethod() && funcDecl.returnTypeAnnotation == null) {\n\n                    // the funcDecl may be a candidate for contextual typing                 \n                    // REVIEW: prevScope will only be null in the case of an upstream error\n                    if (prevScope && funcDecl.name && !funcDecl.name.isMissing()) {\n                        // Go ahead and check for an ambient symbol\n                        var considerSym: Symbol = prevScope.findAmbient(funcDecl.name.text, false, false);\n\n                        if (considerSym && considerSym.declAST && considerSym.declAST.type) {\n                            // REVIEW: Ambients beget signatures, and signatures don't need to be typechecked\n                            //typeCheck(considerSym.declAST);\n                            this.checker.setContextualType(considerSym.declAST.type, false);\n                        }\n                    }\n\n                    if (this.checker.hasTargetType()) {\n                        var candidateTypeContext = this.checker.getTargetTypeContext();\n                        var candidateType = candidateTypeContext.contextualType;\n\n                        if (this.checker.canContextuallyTypeFunction(candidateType, funcDecl, true)) {\n\n                            // Safe to do this, since the indices and fields are guaranteed to be\n                            // non-null and valid by the above call to canContextuallyTypeFunction\n                            var candidateSigs = candidateType.construct ? candidateType.construct : candidateType.call;\n                            candidateTypeContext.targetSig = candidateSigs.signatures[0];\n                            var candidateParams = candidateTypeContext.targetSig.parameters;\n\n                            // the target type has been accepted\n                            targetParams = candidateParams;\n                            targetReturnType = candidateTypeContext.targetSig.returnType.type;\n\n                            // Set \"this\" if applicable\n                            if (candidateTypeContext.targetSig.declAST) {\n                                if (candidateTypeContext.targetSig.declAST.isConstructor) {\n                                    //candidateTypeContext.targetThis=candidateType.instanceType;\n                                    //this.thisType = candidateType.instanceType;\n                                    funcDecl.isTargetTypedAsMethod = true;\n               ";
var v27470 = v27471 + "                 }\n                                else if (candidateTypeContext.targetSig.declAST.isMethod()) {\n                                    //candidateTypeContext.targetThis=candidateTypeContext.targetSig.declAST.type.enclosingType;\n                                    //this.thisType = candidateTypeContext.targetSig.declAST.type.enclosingType;\n                                    funcDecl.isTargetTypedAsMethod = true;\n                                }\n                            }\n                            fgSym.type = candidateTypeContext.contextualType;\n                            acceptedContextualType = true;\n                        }\n                        else if (candidateType && funcDecl.isAccessor()) {\n                            accessorType = candidateType;\n                            candidateTypeContext.targetAccessorType = accessorType;\n                        }\n                        else {\n                            this.checker.killCurrentContextualType();\n                        }\n                    }\n                }\n\n                // typecheck parameters\n                // Add parameter symbols to current scope for typechecking (in case default params reference each other)\n                // Order matters here - default parameters can reference previously defined parameters\n                var paramTable = ssb.valueMembers;\n                this.scope = new SymbolScopeBuilder(paramTable, null, null, null, prevScope, container);\n\n                for (var p = 0; p < paramLen; p++) {\n                    var symbol = signature.parameters[p];\n                    var ast = <ArgDecl>symbol.declAST\n\n                    if (this.checker.hasTargetType() && (targetParams && (this.checker.getTargetTypeContext().targetSig.hasVariableArgList || p < targetParams.length))) {\n                        var candidateTypeContext = this.checker.getTargetTypeContext();\n                        var hasVarArgList = candidateTypeContext.targetSig.hasVariableArgList;\n                        ast.type = hasVarArgList && p >= targetParams.length - 1 ? targetParams[targetParams.length - 1].getType().elementType : targetParams[p].getType();\n                        ast.sym.setType(ast.type);\n                        (<InferenceSymbol>ast.sym).typeCheckStatus = this.checker.getTypeCheckFinishedStatus();\n                    }\n                    else {\n                        this.typeCheck(ast);\n                    }\n\n                    // infer the setter type, if necessary\n                    if (isSetter && accessorType) {\n                        ast = <ArgDecl>this.cast(ast, accessorType);\n                    }\n\n                    symbol.container = container;\n                    // Verify the parameter for the privacy\n                    this.checkTypePrivacy(symbol.getType(), container, (typeName: string, isModuleName: bool) => this.functionArgumentPrivacyErrorReporter(funcDecl, p, symbol, typeName, isModuleName));\n                    paramTable.publicMembers.add(symbol.name, symbol);\n                }\n                this.scope = tmpParamScope;\n            }\n            else {\n                this.typeCheck(funcDecl.arguments)\n\n                // Because some terms were not yet type-checkable during binding, ensure that\n                // param symbols are updated with the proper argument types\n                for (var p = 0; p < paramLen; p++) {\n                    signature.parameters[p].parameter.typeLink.type = funcDecl.arguments.members[p].type;\n                    // Verify the parameter for the privacy\n                    this.checkTypePrivacy(signature.parameters[p].getType(), container, (typeName: string, isModuleName: bool) => this.functionArgumentPrivacyErrorReporter(funcDecl, p, signature.parameters[p], typeName, isModuleName));\n                    if ((<ArgDecl>funcDecl.arguments.members[p]).parameterPropertySym) {\n                        (<ArgDecl>funcDecl.arguments.members[p]).parameterPropertySym.setType(funcDecl.arguments.members[p].type);\n                    }\n                }\n\n                if ((funcDecl.fncFlags & FncFlags.IndexerMember)) {\n                    if (!paramLen || paramLen > 1) {\n                        this.checker.errorReporter.simpleError(funcDecl, \"Index signatures may take one and only one parameter\");\n                    }\n                    else if (funcDecl.arguments.members[0].type == this.checker.numberType) {\n                        fnType.index.flags |= SignatureFlags.IsNumberIndexer;\n                    }\n                    else if (funcDecl.arguments.members[0].type == this.checker.stringType) {\n                        fnType.index.flags |= SignatureFlags.IsStringIndexer;\n                    }\n                    else {\n                        this.checker.errorReporter.simpleError(funcDecl.arguments.members[0], \"Index signatures may only take 'string' or 'number' as their parameter\");\n                    }\n\n                }\n            }\n\n       ";
var v27469 = v27470 + "     // typecheck body\n            if (funcDecl.bod && (!funcDecl.isSignature())) {\n                if (!(funcDecl.isConstructor)) {\n                    this.addFormals(container, signature, funcTable);\n                }\n                else {\n                    this.addConstructorLocalArgs(funcDecl.type.symbol, funcDecl.arguments, funcTable, hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod));\n\n                    if (this.thisClassNode && this.thisClassNode.extendsList) {\n                        var tmpScope = this.scope;\n                        var funcMembers = new ScopedMembers(<DualStringHashTable>funcTable);\n                        this.scope = new FilteredSymbolScopeBuilder(funcMembers, prevScope, funcDecl.type.symbol,\n                                                             function (sym) {\n                                                                 return sym.kind() == SymbolKind.Parameter;\n                                                             });\n                        this.typeCheckBaseCalls(this.thisClassNode.extendsList);\n                        this.scope = tmpScope;\n                    }\n                }\n\n                // Because this function may have been typechecked in a different visiblity context as its caller (e.g., this\n                // function is being typechecked as a result of a call, before the declaration could be typechecked), we need\n                // to set the enclosing module\n                var prevMod = this.checker.currentModDecl;\n                if (funcDecl.type &&\n                    funcDecl.type.symbol &&\n                    !funcDecl.isMethod() &&\n                    funcDecl.type.symbol.declModule) {\n                    this.checker.currentModDecl = funcDecl.type.symbol.declModule;\n                }\n\n\n                // unset the contextual type before typechecking the function body\n                if (acceptedContextualType) {\n                    this.checker.setContextualType(null, this.checker.inProvisionalTypecheckMode());\n                }\n\n                this.typeCheck(funcDecl.bod);\n\n                if (acceptedContextualType) {\n                    this.checker.unsetContextualType();\n                }\n\n                this.checker.currentModDecl = prevMod;\n\n                if (this.checker.checkControlFlow) {\n                    var cfg = funcDecl.buildControlFlow();\n                    if (this.checker.printControlFlowGraph) {\n                        cfg.print(this.checker.errorReporter.outfile);\n                    }\n                    cfg.reportUnreachable(this.checker.errorReporter);\n                    if (this.checker.checkControlFlowUseDef) {\n                        cfg.useDef(this.checker.errorReporter, funcDecl.type.symbol);\n                    }\n                }\n\n                if (funcDecl.isConstructor) {\n                    var fns: ASTList = funcDecl.scopes;\n                    var fnsLen = fns.members.length;\n                    var freeVars: Symbol[];\n                    var sym: Symbol;\n                    var j = 0;\n                    for (; j < fnsLen; j++) {\n                        var fn = <FuncDecl>fns.members[j];\n                        if (!fn.isSignature()) {\n                            if (hasFlag(fn.fncFlags, FncFlags.Method) && (!hasFlag(fn.fncFlags, FncFlags.Static))) {\n                                this.checkPromoteFreeVars(fn, funcDecl.type.symbol);\n                            }\n                        }\n                    }\n                }\n            }\n\n            this.scope = prevScope;\n            this.thisFnc = prevFnc;\n            this.thisClassNode = prevClassNode;\n            this.enclosingFncIsMethod = prevMethodStatus;\n            this.thisType = prevThisType;\n            this.checker.locationInfo = prevLocationInfo;\n            this.checker.currentModDecl = prevModDecl;\n\n            signature.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();\n\n            // set the return type\n            if (funcDecl.returnTypeAnnotation) {\n                this.checkForVoidConstructor(funcDecl.returnTypeAnnotation.type, funcDecl.returnTypeAnnotation);\n\n                if (signature.returnType.type == null) {\n                    this.checker.resolveTypeLink(this.scope, signature.returnType, false);\n                }\n            }\n            else if (targetReturnType) {\n                signature.returnType.type = targetReturnType;\n            }\n\n            // If no return type annotation has been applied to the function declaration\n            // unify the return types from the given return statements\n\n            if (!(fgSym.flags & SymbolFlags.RecursivelyReferenced) && funcDecl.returnStatementsWithExpressions.length > 0) {\n                var collection: ITypeCollection = {\n                    getLength: () => { return funcDecl.returnStatementsWithExpressions.length; },\n                    setTypeAtIndex: (index: number, type: Type) => { funcDecl.returnStatementsWithExpressions[index].t";
var v27468 = v27469 + 'ype = type; },\n                    getTypeAtIndex: (index: number) => { return funcDecl.returnStatementsWithExpressions[index].type; }\n                }\n\n                var bestCommonReturnType = funcDecl.returnStatementsWithExpressions[0].type;\n                bestCommonReturnType = this.checker.findBestCommonType(bestCommonReturnType, null, collection, true);\n\n                if (bestCommonReturnType) {\n                    signature.returnType.type = this.checker.widenType(bestCommonReturnType);\n                }\n                else {\n                    for (var i = 0; i < funcDecl.returnStatementsWithExpressions.length; i++) {\n                        this.checker.errorReporter.simpleError(funcDecl.returnStatementsWithExpressions[i], "Incompatible return type");\n                    }\n                    signature.returnType.type = this.anyType;\n                }\n            }\n\n            var onlyHasThrow = false;\n\n            if (signature.returnType.type == null) {\n                if (hasFlag(funcDecl.fncFlags, FncFlags.HasReturnExpression)) {\n                    if (this.checker.styleSettings.implicitAny) {\n                        this.checker.errorReporter.styleError(funcDecl, "type implicitly set to \'any\'");\n                    }\n                    signature.returnType.type = this.anyType;\n                }\n                else {\n                    signature.returnType.type = this.voidType;\n                }\n            }\n            else if (signature.returnType.type == this.nullType || signature.returnType.type == this.checker.undefinedType) {\n                signature.returnType.type = this.anyType;\n            }\n            else if ((signature.returnType.type != this.voidType && signature.returnType.type != this.checker.undefinedType && signature.returnType.type != this.anyType)) {\n                // the signature declared a non-void type, but there\'s no return statement\n                if (!funcDecl.isSignature() &&\n                    !funcDecl.isConstructor &&\n                    !hasFlag(funcDecl.fncFlags, FncFlags.HasReturnExpression) &&\n                    !hasFlag(funcDecl.fncFlags, FncFlags.IsFatArrowFunction)) {\n                        // relax the restriction if the method only contains a single "throw" statement\n                    onlyHasThrow = (funcDecl.bod.members.length > 0) && (funcDecl.bod.members[0].nodeType == NodeType.Throw)\n\n                    if (!onlyHasThrow) {\n                        this.checker.errorReporter.simpleError(funcDecl.returnTypeAnnotation || funcDecl,\n                             "Function declared a non-void return type, but has no return expression");\n                    }\n                }\n\n                // Type check for return type Privacy\n                this.checkTypePrivacy(signature.returnType.type, container, (typeName: string, isModuleName: bool) => this.functionReturnTypePrivacyErrorReporter(funcDecl, signature, typeName, isModuleName));\n            }\n\n            // if the function declaration is a getter or a setter, set the type of the associated getter/setter symbol\n            if (funcDecl.accessorSymbol) {\n                var accessorType = funcDecl.accessorSymbol.getType();\n                if (!onlyHasThrow && hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor) && !hasFlag(funcDecl.fncFlags, FncFlags.HasReturnExpression)) {\n                    this.checker.errorReporter.simpleError(funcDecl, "Getters must return a value");\n                }\n                if (accessorType) {\n                    if ((hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor) && accessorType != signature.returnType.type) ||\n                        (funcDecl.arguments.members.length > 0 && accessorType != funcDecl.arguments.members[0].type)) {\n                        this.checker.errorReporter.simpleError(funcDecl, "Getter and setter types do not agree");\n                    }\n                }\n                else {\n                    if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {\n                        funcDecl.accessorSymbol.setType(signature.returnType.type);\n                    }\n                    else {\n                        if (funcDecl.arguments.members.length != 1) {\n                            this.checker.errorReporter.simpleError(funcDecl, "Setters may have one and only one argument");\n                        }\n                        else {\n                            funcDecl.accessorSymbol.setType(funcDecl.arguments.members[0].type);\n                        }\n                    }\n                }\n            }\n\n            this.typeCheckOverloadSignatures(fnType, funcDecl);\n            return funcDecl;\n        }\n\n        public typeCheckBases(type: Type) {\n            var seenInterface = false;\n            var bases = type.extendsList;\n            var baseLinks = type.extendsTypeLinks;\n            if (bases) {\n                var len = bases.length;\n\n                if (len > 0) {\n                    type.typeFlags |= TypeFlags.Has';
var v27467 = v27468 + 'BaseType;\n                }\n\n                for (var i = 0; i < len; i++) {\n                    if (bases[i] == this.checker.anyType) {\n                        // This may be the type from imported module and hence the type was not really resolved to the correct one.\n                        // Try resolving it again\n                        baseLinks[i].type = null;\n                        // There are no contextual errors when trying to verify the base class\n                        var oldErrors = this.checker.errorReporter.getCapturedErrors();\n                        CompilerDiagnostics.assert(oldErrors.length == 0, "There shouldnt be any contextual errors when typechecking base type names");\n                        this.checker.errorReporter.pushToErrorSink = true;\n                        bases[i] = this.checker.resolveBaseTypeLink(baseLinks[i], type.containedScope);\n                        this.checker.errorReporter.pushToErrorSink = false;\n                        this.checker.errorReporter.freeCapturedErrors();\n                    }\n\n                    var base = bases[i];\n                    var baseRef = baseLinks[i].ast;\n\n                    // make sure it\'s the global \'Object\' and not some alias\n                    var baseTypeOfObject = base.symbol && base.symbol.name == "Object" && base.symbol.container == this.checker.gloMod;\n\n                    if (baseTypeOfObject) {\n                        type.typeFlags |= TypeFlags.HasBaseTypeOfObject;\n                    }\n\n                    if (base.isClassInstance()) {\n                        if (!(type.isClassInstance())) {\n                            this.checker.errorReporter.simpleError(baseRef, "Interface base type must be interface");\n                        }\n                        else {\n                            if (seenInterface) {\n                                this.checker.errorReporter.simpleError(baseRef, "Class may not follow interface as base type");\n                            }\n                        }\n                    }\n                    else if (base.isModuleType()) {\n                        this.checker.errorReporter.simpleError(baseRef, "Types may not be derived from module types");\n                    }\n                    else if (base.members) {\n                        if (!seenInterface) {\n                            seenInterface = true;\n                        }\n                    }\n                    else {\n                        if (!(type.isClassInstance())) {\n                            this.checker.errorReporter.simpleError(baseRef,\n                                                                     "Interface base type must be interface");\n                        }\n                        else {\n                            this.checker.errorReporter.simpleError(baseRef,\n                                                                     "Base type must be interface or class");\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n\n        public checkMembersImplementInterfaces(implementingType: Type) {\n            var instanceType = implementingType.getInstanceType();\n            if (instanceType.implementsList) {\n                var len = instanceType.implementsList.length;\n\n                for (var i = 0; i < len; i++) {\n                    var interfaceType = instanceType.implementsList[i];\n                    var comparisonInfo = new TypeComparisonInfo();\n                    if (!this.checker.sourceIsSubtypeOfTarget(instanceType, interfaceType, comparisonInfo)) {\n                        var emsg = "Class \'" + instanceType.getTypeName() +\n                              "\' declares interface \'" + interfaceType.getTypeName() +\n                              "\' but does not implement it";\n                        if (!comparisonInfo.message) {\n                            this.checker.errorReporter.simpleErrorFromSym(instanceType.symbol, emsg);\n                        }\n                        else {\n                            this.checker.errorReporter.simpleErrorFromSym(instanceType.symbol, emsg + ": " + comparisonInfo.message);\n                        }\n                    }\n                }\n            }\n        }\n\n        public typeCheckBaseCalls(bases: ASTList) {\n            if (bases == null) {\n                return;\n            }\n            var basesLen = bases.members.length;\n            for (var i = 0; i < basesLen; i++) {\n                var baseExpr = bases.members[i];\n                var baseSymbol: Symbol = null;\n                if (baseExpr.nodeType == NodeType.Call) {\n                    this.typeCheckNew(baseExpr);\n                }\n            }\n        }\n\n        public assertUniqueNamesInBaseTypes(names: IHashTable, type: Type, classDecl: InterfaceDeclaration, checkUnique: bool): void {\n            if (type) {\n                if (type.members) {\n                    type.members.publicMembers.map((key, s, c) => {\n  ';
var v27466 = v27467 + '                      var sym = <Symbol>s;\n                        var dup = names.lookup(sym.name);\n                        if (dup) {\n                            if (checkUnique) {\n                                this.checker.errorReporter.simpleError(classDecl,\n                                                                  "duplicate member name in bases for " + classDecl.name.actualText + ": " + type.symbol.name + " and " + dup.container.name + " both contain member with name " + sym.name);\n                            }\n                        }\n                        else {\n                            names.add(sym.name, sym);\n                        }\n                    }, null);\n                }\n                if (type.extendsList) {\n                    var len = type.extendsList.length;\n                    for (var i = 0; i < len; i++) {\n                        if (!(type.extendsList[i].symbol.flags & SymbolFlags.RecursivelyReferenced)) {\n                            this.assertUniqueNamesInBaseTypes(names, type.extendsList[i], classDecl, checkUnique);\n                        }\n                    }\n                }\n            }\n        }\n\n        public checkBaseTypeMemberInheritance(derivedType: Type, derivedTypeDecl: AST): void {\n            var instanceType = derivedType.getInstanceType();\n            if (instanceType.extendsList == null) {\n                return;\n            }\n\n            var len = instanceType.extendsList.length;\n            if (len > 0) {\n                var names = new StringHashTable();\n                if (instanceType.isClassInstance()) {\n                    for (var i = 0; i < len; i++) {\n                        this.assertUniqueNamesInBaseTypes(names, instanceType.extendsList[i], <InterfaceDeclaration>derivedTypeDecl, i > 0);\n                    }\n                }\n\n                if (instanceType.members) {\n                    instanceType.members.publicMembers.map((key, s, c) => {\n                        var sym = <Symbol>s;\n                        for (var j = 0; j < len; j++) {\n                            var base = instanceType.extendsList[j];\n                            if (base.memberScope == null) {\n                                this.checker.errorReporter.simpleError(derivedTypeDecl, "Base type \'" + base.symbol.name + "\' lacks an implementation.")\n                            }\n                            else {\n                                var bSym = base.memberScope.find(sym.name, false, false);\n                                if (bSym) {\n                                    var aType = sym.getType();\n                                    var bType = bSym.getType();\n                                    if (!(this.checker.sourceIsSubtypeOfTarget(aType, bType))) {\n                                        this.checker.errorReporter.simpleErrorFromSym(sym,\n                                                                          "Type of overridden member \'" + sym.name + "\' is not subtype of original member defined by type \'" + bSym.container.name + "\'");\n                                    }\n                                    else if ((sym.kind() == SymbolKind.Type) &&\n                                             (bSym.kind() == SymbolKind.Field)) {\n                                        this.checker.errorReporter.simpleErrorFromSym(sym,\n                                                                          "Cannot override field \'" + sym.name + "\' with method");\n                                    }\n                                }\n                            }\n                        }\n                    }, null);\n                }\n            }\n        }\n\n        public typeCheckClass(classDecl: ClassDeclaration): ClassDeclaration {\n            var typeSymbol = <TypeSymbol>classDecl.type.symbol;\n\n            if (typeSymbol.typeCheckStatus == TypeCheckStatus.Finished) {\n                return classDecl;\n            }\n            else if (typeSymbol.typeCheckStatus == TypeCheckStatus.Started) {\n                // REVIEW: report this recursion\n                //checker.errorReporter.recursionRequiresTypeAnnotation(classDecl);\n                return classDecl;\n            }\n            else {\n                typeSymbol.typeCheckStatus = TypeCheckStatus.Started;\n                this.checker.addStartedPTO(typeSymbol);\n            }\n\n            var prevScope = this.scope;\n            var svClassNode = this.thisClassNode;\n            this.thisClassNode = classDecl;\n            var classType = classDecl.type;\n            this.typeCheckBases(classType.instanceType);\n\n            this.typeCheckBaseListPrivacy(classDecl.extendsList, typeSymbol, true);\n            this.typeCheckBaseListPrivacy(classDecl.implementsList, typeSymbol, false);\n\n            var prevThisType = this.thisType;\n            this.thisType = classType.instanceType;\n            this.scope = classType.instanceType.containedScope;\n\n            // Add the constructor locals, if necessary\n  ';
var v27465 = v27466 + '          if (classDecl.constructorDecl) {\n                this.scope = classType.instanceType.constructorScope;\n                var ssb = <SymbolScopeBuilder>this.scope;\n                var funcTable = ssb.valueMembers.allMembers;\n\n                this.addConstructorLocalArgs(classDecl.constructorDecl.type.symbol, classDecl.constructorDecl.arguments, funcTable, true);\n            }\n\n            this.typeCheck(classDecl.members);\n            typeSymbol.typeCheckStatus = TypeCheckStatus.Finished;\n            this.checkBaseTypeMemberInheritance(classType, classDecl);\n            this.checkMembersImplementInterfaces(classType);\n\n            this.typeCheckOverloadSignatures(classType, classDecl);\n            this.typeCheckOverloadSignatures(classType.instanceType, classDecl);\n\n            // if the class has no declared constructor, adapt its base class\'s signature group, if necessary\n            if (!classDecl.constructorDecl) {\n                if (classDecl.extendsList &&\n                    classDecl.extendsList.members.length &&\n                    classDecl.extendsList.members[0].type &&\n                    classDecl.extendsList.members[0].type.symbol.type.isClass()) {\n                    cloneParentConstructGroupForChildType(classDecl.type, classDecl.extendsList.members[0].type.symbol.type);\n                }\n            }\n\n            this.thisType = prevThisType;\n            this.thisClassNode = svClassNode;\n            this.scope = prevScope;\n            return classDecl;\n        }\n\n        public typeCheckOverloadSignatures(type: Type, ast: AST) {\n            if (type.call) {\n                type.call.typeCheck(this.checker, ast, type.construct != null);\n            }\n            if (type.construct) {\n                type.construct.typeCheck(this.checker, ast, false);\n            }\n            if (type.index) {\n                type.index.typeCheck(this.checker, ast, false);\n            }\n        }\n\n        public typeCheckInterface(interfaceDecl: InterfaceDeclaration): InterfaceDeclaration {\n            // overloads will be typechecked inline by the members\n            //this.typeCheckOverloadSignatures(interfaceDecl.type, interfaceDecl);\n            this.typeCheckBases(interfaceDecl.type);\n            this.typeCheckBaseListPrivacy(interfaceDecl.extendsList, interfaceDecl.type.symbol, true);\n            this.typeCheck(interfaceDecl.members);\n            this.checkBaseTypeMemberInheritance(interfaceDecl.type, interfaceDecl);\n\n            // propagate base type signatures\n            if (interfaceDecl.extendsList) {\n                for (var i = 0; i < interfaceDecl.extendsList.members.length; i++) {\n                    if (interfaceDecl.extendsList.members[i].type.call) {\n                        if (interfaceDecl.type.call) {\n                            interfaceDecl.type.call.signatures = interfaceDecl.type.call.signatures.concat(interfaceDecl.extendsList.members[i].type.call.signatures);\n                        }\n                        else {\n                            interfaceDecl.type.call = interfaceDecl.extendsList.members[i].type.call;\n                        }\n                    }\n                    if (interfaceDecl.extendsList.members[i].type.construct) {\n                        if (interfaceDecl.type.construct) {\n                            interfaceDecl.type.construct.signatures = interfaceDecl.type.construct.signatures.concat(interfaceDecl.extendsList.members[i].type.construct.signatures);\n                        }\n                        else {\n                            interfaceDecl.type.construct = interfaceDecl.extendsList.members[i].type.construct;\n                        }\n                    }\n                    if (interfaceDecl.extendsList.members[i].type.index) {\n                        if (interfaceDecl.type.index) {\n                            interfaceDecl.type.index.signatures = interfaceDecl.type.index.signatures.concat(interfaceDecl.extendsList.members[i].type.index.signatures);\n                        }\n                        else {\n                            interfaceDecl.type.index = interfaceDecl.extendsList.members[i].type.index;\n                        }\n                    }\n                }\n            }\n\n            return interfaceDecl;\n        }\n\n        public typeCheckImportDecl(importDecl: ImportDeclaration) {\n            var mod: ModuleType = <ModuleType>importDecl.alias.type;\n            var sym: TypeSymbol = null;\n            var prevInImportTC = this.inImportTypeCheck;\n            this.inImportTypeCheck = true;\n\n            this.typeCheck(importDecl.alias);\n            mod = <ModuleType>importDecl.alias.type;\n\n            if (mod == null) {\n                this.checker.errorReporter.simpleError(importDecl.alias, "Could not resolve module alias \'" + importDecl.id.actualText + "\'");\n                mod = <ModuleType>this.checker.anyType;\n                (<TypeSymbol>importDecl.id.sym).type = mod;\n            }\n\n            importDecl.id.type = mod;';
var v27464 = v27465 + '\n            sym = mod.symbol;\n\n            if (!mod.isModuleType()) {\n                this.checker.errorReporter.simpleError(importDecl.alias, "A module cannot be aliased to a non-module type");\n            }\n            else {\n                sym.type = mod;\n                \n                // Add the imported module to the AMD dependency list\n                if (this.checker.typeFlow.currentScript && \n                    this.checker.typeFlow.currentScript.topLevelMod && \n                    this.checker.typeFlow.currentScript.topLevelMod.mod) \n                {\n                    this.checker.typeFlow.currentScript.topLevelMod.mod.importedModules.push(importDecl);\n                }\n\n                (<TypeSymbol>importDecl.id.sym).type = mod;\n\n                if (mod.symbol && mod.symbol.declAST) {\n                    (<ModuleDeclaration>mod.symbol.declAST).modFlags &= ~ModuleFlags.ShouldEmitModuleDecl;\n                }\n\n                //importDecl.id.sym = sym;\n                // REVIEW: Uncomment when you can toggle module codegen targets from the language service\n                //else if (typeFlow.checker.currentModDecl == null && \n                //            hasFlag((<ModuleDecl>sym.declAST).modFlags,ModuleFlags.IsDynamic) &&\n                //            moduleGenTarget == ModuleGenTarget.Asynchronous) \n                //{\n                //    typeFlow.checker.errorReporter.simpleError(alias, "In AMD codegen mode, dynamic modules may not be referenced from global scope.  (Wrap the file in a module declaration.)");\n                //}\n            }\n            this.inImportTypeCheck = prevInImportTC;\n            return importDecl;\n        }\n\n        public typeCheckModule(moduleDecl: ModuleDeclaration): ModuleDeclaration {\n\n            // In some really nasty cases of error recovery, we may not have a type\n            if (!moduleDecl.mod) {\n                return moduleDecl;\n            }\n\n            if (this.currentScript) {\n                this.currentScript.requiresGlobal = true;\n            }\n            var mod = moduleDecl.mod;\n            var sym: TypeSymbol = null;\n\n            var prevScope = this.scope;\n            var prevThisType = this.thisType;\n            var prevCurrentModDecl = this.checker.currentModDecl;\n            this.checker.currentModDecl = moduleDecl;\n\n            this.thisType = null;\n            this.scope = mod.containedScope;\n            this.typeCheck(moduleDecl.members);\n            sym = mod.symbol;\n\n            this.checker.currentModDecl = prevCurrentModDecl;\n            this.thisType = prevThisType;\n            this.scope = prevScope;\n\n            moduleDecl.type = mod;\n\n            if (sym) {\n                sym.typeCheckStatus = TypeCheckStatus.Finished;\n            }\n            return moduleDecl;\n        }\n\n        public typeCheckFor(forStmt: ForStatement): ForStatement {\n            forStmt.init = this.typeCheck(forStmt.init);\n            this.nestingLevel++;\n            forStmt.cond = this.typeCheck(forStmt.cond);\n            this.typeCheckCondExpr(forStmt.cond);\n            forStmt.incr = this.typeCheck(forStmt.incr);\n            this.nestingLevel--;\n            forStmt.body = this.typeCheck(forStmt.body);\n            this.typeCheckCompoundStmtBlock(forStmt.body, "for statement");\n            forStmt.type = this.voidType;\n            return forStmt;\n        }\n\n        public typeCheckWith(withStmt: WithStatement): WithStatement {\n            if (this.checker.errorsOnWith) {\n                this.checker.errorReporter.simpleError(withStmt.expr, "All symbols within a \'with\' block will be typed as \'any\'");\n            }\n            withStmt.expr = this.typeCheck(withStmt.expr);\n            this.checker.inWith = true;\n            withStmt.body = this.typeCheck(withStmt.body);\n            this.typeCheckCompoundStmtBlock(withStmt.body, "with statement");\n            this.checker.inWith = false;\n            return withStmt;\n        }\n\n        public typeCheckForIn(forInStmt: ForInStatement): ForInStatement {\n            forInStmt.obj = this.typeCheck(forInStmt.obj);\n            forInStmt.lval = this.cast(this.typeCheck(forInStmt.lval), this.checker.stringType);\n            if (forInStmt.lval.nodeType == NodeType.VarDecl) {\n\n                var varDecl = <VarDecl>forInStmt.lval;\n                if (varDecl.typeExpr) {\n                    this.checker.errorReporter.simpleError(varDecl, "Variable declarations for for/in expressions may not contain a type annotation");\n                }\n\n                if (varDecl.sym) {\n                    varDecl.sym.setType(this.checker.stringType);\n                }\n            }\n            forInStmt.body = this.typeCheck(forInStmt.body);\n            this.typeCheckCompoundStmtBlock(forInStmt.body, "for in statement");\n            return forInStmt;\n        }\n\n        public typeCheckWhile(whileStmt: WhileStatement): WhileStatement {\n            whileStmt.cond = this.typeCheck(whileStmt.cond);\n            this.typeCheckCondE';
var v27463 = v27464 + 'xpr(whileStmt.cond);\n            whileStmt.body = this.typeCheck(whileStmt.body);\n            this.typeCheckCompoundStmtBlock(whileStmt.body, "while statement");\n            whileStmt.type = this.voidType;\n            return whileStmt;\n        }\n\n        public typeCheckDoWhile(doWhileStmt: DoWhileStatement): DoWhileStatement {\n            doWhileStmt.cond = this.typeCheck(doWhileStmt.cond);\n            this.typeCheckCondExpr(doWhileStmt.cond);\n            doWhileStmt.body = this.typeCheck(doWhileStmt.body);\n            this.typeCheckCompoundStmtBlock(doWhileStmt.body, "do while statement");\n            doWhileStmt.type = this.voidType;\n            return doWhileStmt;\n        }\n\n        public typeCheckCondExpr(cond: AST) {\n            if (this.checker.styleSettings.assignmentInCond) {\n                if ((cond !== null) &&\n                    (cond.nodeType >= NodeType.Asg) &&\n                    (cond.nodeType <= NodeType.LastAsg)) {\n                    this.checker.errorReporter.simpleError(cond, "top-level assignment statement in conditional expression");\n                }\n            }\n        }\n\n        public typeCheckCompoundStmtBlock(stmts: AST, stmtType: string) {\n            if (this.checker.styleSettings.blockInCompoundStmt && stmts) {\n                if (stmts.nodeType != NodeType.Block) {\n                    this.checker.errorReporter.styleError(stmts, stmtType + " requires a block");\n                }\n            }\n        }\n        public typeCheckIf(ifStmt: IfStatement): IfStatement {\n            ifStmt.cond = this.typeCheck(ifStmt.cond);\n            this.typeCheckCondExpr(ifStmt.cond);\n            ifStmt.thenBod = this.typeCheck(ifStmt.thenBod);\n            ifStmt.elseBod = this.typeCheck(ifStmt.elseBod);\n            this.typeCheckCompoundStmtBlock(ifStmt.thenBod, "if statement");\n            this.typeCheckCompoundStmtBlock(ifStmt.elseBod, "if statement");\n            ifStmt.type = this.voidType;\n            return ifStmt;\n        }\n\n        public typeFromAccessorFuncDecl(funcDecl: FuncDecl) {\n            if (!funcDecl.isAccessor()) {\n                return null;\n            }\n\n            if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {\n                return funcDecl.type.call.signatures[0].returnType.type;\n            }\n            else {\n                return funcDecl.type.call.signatures[0].parameters[0].getType();\n            }\n        }\n\n        public typeCheckObjectLit(objectLit: UnaryExpression): void {\n\n            var resultType = new Type();\n            resultType.symbol = new TypeSymbol(this.checker.anon, objectLit.minChar,\n                                             objectLit.limChar - objectLit.minChar,\n                                             this.checker.locationInfo.unitIndex,\n                                             resultType);\n\n            resultType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n            resultType.memberScope = new SymbolTableScope(resultType.members, null, null, null, null);\n\n            var aggScope = new SymbolAggregateScope(resultType.symbol);\n            aggScope.addParentScope(resultType.memberScope);\n            aggScope.addParentScope(this.scope);\n            resultType.containedScope = aggScope;\n            var memberDecls = <ASTList>objectLit.operand;\n            var prevThisType = this.thisType;\n            var acceptTargetType = false;\n            var targetType: Type = null;\n\n            if (this.checker.hasTargetType()) {\n                targetType = this.checker.getTargetTypeContext().contextualType;\n\n                if (targetType && targetType.symbol && !this.checker.typeStatusIsFinished(targetType.symbol.typeCheckStatus)) {\n                    if (targetType.symbol.declAST) {\n                        this.typeCheck(targetType.symbol.declAST);\n                    }\n                }\n                acceptTargetType = true;\n            }\n\n            if (memberDecls) {\n                for (var i = 0, len = memberDecls.members.length; i < len; i++) {\n\n                    var binex = <BinaryExpression>memberDecls.members[i];\n\n                    var id = binex.operand1;\n                    var text: string;\n                    var targetMember: Symbol = null;\n                    var fieldSymbol: FieldSymbol = null;\n\n                    if (id.nodeType == NodeType.Name) {\n                        text = (<Identifier>id).text;\n                    }\n                    else if (id.nodeType == NodeType.QString) {\n                        // TODO: set text to unescaped string\n                        var idText = (<StringLiteral>id).text;\n                        text = idText.substring(1, idText.length - 1);\n                    }\n                    else {\n                        this.checker.errorReporter.simpleError(objectLit,\n                                                          "malformed object literal");\n                        resultType = this.anyType;\n       ';
var v27462 = v27463 + "                 break;\n                    }\n\n                    if (acceptTargetType && targetType.memberScope) {\n                        targetMember = targetType.memberScope.find(text, false, false);\n                    }\n\n                    // before typechecking an accessor function member, we need to initialize its accessor symbol\n                    if (binex.operand2.nodeType == NodeType.FuncDecl && (<FuncDecl>binex.operand2).isAccessor()) {\n\n                        var funcDecl = <FuncDecl>binex.operand2;\n                        var accessorSym: FieldSymbol = resultType.members.publicMembers.lookup(text);\n\n                        accessorSym = this.checker.createAccessorSymbol(funcDecl, accessorSym, resultType, true, false, resultType.memberScope, null);\n                        funcDecl.accessorSymbol = accessorSym;\n                        fieldSymbol = accessorSym;\n                        if (id.nodeType == NodeType.Name) {\n                            (<Identifier>id).sym = accessorSym;\n                        }\n                    }\n\n                    this.checker.typeCheckWithContextualType(acceptTargetType && targetMember ? targetMember.getType() : null, false, acceptTargetType, binex.operand2);\n\n                    if (acceptTargetType && targetMember) {\n                        // Note that we accept 'any' in place of a valid subtype                     \n                        if ((binex.operand2.type == this.anyType || this.checker.sourceIsAssignableToTarget(binex.operand2.type, targetMember.getType())) ||\n                            (binex.operand2.nodeType == NodeType.FuncDecl &&\n                            (<FuncDecl>binex.operand2).isAccessor() &&\n                                this.typeFromAccessorFuncDecl(<FuncDecl>binex.operand2) == targetMember.getType())) {\n                                    // set the field type to the proper contextual type\n                                    // this is especially important in the 'any' case, so that\n                                    // fields typed to 'any' aren't accepted for contextual typing,\n                                    // but never properly set to the target type\n                            binex.operand1.type = targetMember.getType();\n                        }\n                    }\n                    else {\n                        // here we sub in 'any' for 'undefined' to account for field initialization to\n                        // 'undefined'  \n                        binex.operand2.type = binex.operand2.type == this.checker.undefinedType ? this.anyType : binex.operand2.type;\n                    }\n\n                    // the field symbol hasn't been set by a getter or setter\n                    if (fieldSymbol == null) {\n                        var memberType = binex.operand2.type;\n                        var field = new ValueLocation();\n                        fieldSymbol =\n                            new FieldSymbol(text, id.minChar,\n                                            this.checker.locationInfo.unitIndex,\n                                            true, field);\n                        fieldSymbol.flags |= SymbolFlags.Property;\n                        field.symbol = fieldSymbol;\n                        fieldSymbol.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();\n                        field.typeLink = new TypeLink();\n                        field.typeLink.type = memberType;\n                        resultType.members.publicMembers.add(text, fieldSymbol);\n                    }\n                    fieldSymbol.isObjectLitField = true;\n                }\n            }\n\n            this.thisType = prevThisType;\n            objectLit.type = resultType;\n            if (targetType) {\n                objectLit.targetType = targetType;\n            }\n        }\n\n        public typeCheckArrayLit(arrayLit: UnaryExpression): void {\n            var elements = <ASTList>arrayLit.operand;\n            var elementType = this.anyType;\n            var targetElementType: Type = null;\n            var comparisonInfo = new TypeComparisonInfo();\n            comparisonInfo.onlyCaptureFirstError = true;\n\n            // if the target type is an array type, extract the element type\n            if (this.checker.hasTargetType()) {\n                var targetType = this.checker.getTargetTypeContext().contextualType;\n                if (targetType.elementType) {\n                    targetElementType = targetType.elementType;\n                }\n            }\n\n            if (elements) {\n\n                var prevInArrayElemTypeCheck = this.inArrayElementTypeCheck;\n\n                this.inArrayElementTypeCheck = true;\n                this.checker.typeCheckWithContextualType(targetElementType, this.checker.inProvisionalTypecheckMode(), targetElementType != null, elements);\n                this.inArrayElementTypeCheck = prevInArrayElemTypeCheck;\n\n                elementType = elements.members[0].type;\n\n                var collection: ITypeCo";
var v27461 = v27462 + 'llection = {\n                    getLength: () => { return elements.members.length; },\n                    setTypeAtIndex: (index: number, type: Type) => { elements.members[index].type = type; },\n                    getTypeAtIndex: (index: number) => { return elements.members[index].type; }\n                }\n\n                elementType = this.checker.findBestCommonType(elementType, targetElementType, collection, false, comparisonInfo);\n\n                // if the array type is the undefined type, we should widen it to any\n                // if it\'s of the null type, only widen it if it\'s not in a nested array element, so as not to \n                // short-circuit any checks for the best common type\n                if (elementType == this.checker.undefinedType || (!prevInArrayElemTypeCheck && elementType == this.nullType)) {\n                    elementType = this.anyType;\n                }\n            }\n            if (!elementType) {\n                var emsg = "Incompatible types in array literal expression";\n                if (!comparisonInfo.message) {\n                    this.checker.errorReporter.simpleError(arrayLit, emsg);\n                }\n                else {\n                    this.checker.errorReporter.simpleError(arrayLit, emsg + ": " + comparisonInfo.message);\n                }\n                elementType = this.anyType;\n            }\n            else if (targetElementType) {\n                // for the case of zero-length \'any\' arrays, we still want to set the contextual type, if\n                // need be\n                if (this.checker.sourceIsAssignableToTarget(elementType, targetElementType)) {\n                    elementType = targetElementType;\n                }\n            }\n\n            arrayLit.type = this.checker.makeArrayType(elementType);\n\n        }\n\n        public checkForVoidConstructor(type: Type, ast: AST) {\n            if (type &&\n                type.construct &&\n                type.construct.signatures.length > 0) {\n\n                for (var i = 0; i < type.construct.signatures.length; i++) {\n                    if (type.construct.signatures[i].returnType.type == this.checker.voidType) {\n                        this.checker.errorReporter.simpleError(ast, "Constructors may not have a return type of \'void\'");\n                        break;\n                    }\n                }\n            }\n        }\n\n        // REVIEW: the code below could set the signature type of the function to the current return\n        // type, which would have a benefit of reducing the risk of a recursive typecheck scenario, but is\n        // is technically wrong - mergeOrdered will only work properly if the best common supertype\n        // comes before any sibling types.  This would mean that if a function, "color()", returned\n        // three types (in order) - "Red", "Blue", and "IColor", an "Incompatible return type" error \n        // would be triggered.  However, if "color()" returned (in order) "Red", "IColor" and "Blue"\n        // no error would be triggered, and the return type of the function would be "IColor"\n        public typeCheckReturn(returnStmt: ReturnStatement): ReturnStatement {\n\n            if (this.thisFnc) {\n                var targetType: Type = null;\n\n                // determine the target type\n                if (this.checker.hasTargetType()) {\n                    var tcContext = this.checker.getTargetTypeContext();\n                    var accessorType = tcContext.targetAccessorType;\n\n                    if (accessorType) {\n                        targetType = accessorType;\n                    }\n                    else {\n                        var targetSig = this.checker.getTargetTypeContext().targetSig;\n                        if (targetSig && targetSig.returnType.type != this.voidType) {\n                            targetType = targetSig.returnType.type;\n                        }\n                    }\n                }\n\n                if (returnStmt.returnExpression) {\n                    this.thisFnc.fncFlags |= FncFlags.HasReturnExpression;\n\n                    if (targetType == null && this.thisFnc.returnTypeAnnotation && this.thisFnc.returnTypeAnnotation.type && this.thisFnc.returnTypeAnnotation.type != this.voidType) {\n                        targetType = this.thisFnc.returnTypeAnnotation.type;\n                    }\n\n                    this.checker.typeCheckWithContextualType(targetType, this.checker.inProvisionalTypecheckMode(), targetType != null, returnStmt.returnExpression);\n\n                    var expectedReturnType: Type =\n                        (this.thisFnc.returnTypeAnnotation && this.thisFnc.returnTypeAnnotation.type) ?\n                            this.thisFnc.returnTypeAnnotation.type :\n                            targetType;\n                    if (expectedReturnType) {\n                        if (expectedReturnType == this.voidType && returnStmt.returnExpression.type != this.voidType) {\n                            this.checker.errorReporter.simp';
var v27460 = v27461 + 'leError(returnStmt,\n                                                              "Return with value expression in void function");\n\n                            // even though we\'ve raised an error, use the more specific type\n                            returnStmt.type = returnStmt.returnExpression.type;\n                        }\n                        else {\n                            returnStmt.returnExpression = this.cast(returnStmt.returnExpression, expectedReturnType);\n                            returnStmt.type = expectedReturnType;\n                        }\n                    }\n                    else {\n                        if (targetType) {\n                            if (returnStmt.returnExpression.type != this.voidType) {\n                                returnStmt.returnExpression = this.cast(returnStmt.returnExpression, targetType);\n                            }\n                            else {\n                                returnStmt.returnExpression.type = targetType;\n                            }\n                        }\n                        returnStmt.type = returnStmt.returnExpression.type;\n                    }\n                    this.thisFnc.returnStatementsWithExpressions[this.thisFnc.returnStatementsWithExpressions.length] = returnStmt;\n                }\n                else {\n                    returnStmt.type = targetType == null ? this.checker.voidType : targetType; //((this.thisFnc.returnTypeAnnotation && this.thisFnc.returnTypeAnnotation.type) ? this.thisFnc.returnTypeAnnotation.type : this.checker.voidType) : targetType;\n                }\n            }\n\n            return returnStmt;\n        }\n\n        public typeCheckInstOf(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n\n            if (!((binex.operand1.type == this.checker.anyType || this.checker.sourceIsSubtypeOfTarget(binex.operand1.type, this.objectInterfaceType)) &&\n                    (binex.operand2.type == this.anyType || this.checker.sourceIsSubtypeOfTarget(binex.operand2.type, this.functionInterfaceType)))) {\n                this.checker.errorReporter.simpleError(ast, "The instanceof operator requires the left operand to be of type Any or an object type, and the right operand to be of type Any or a subtype of the Function interface type");\n            }\n            binex.type = this.booleanType;\n            return binex;\n        }\n\n        public typeCheckCommaOperator(ast: AST): AST {\n            var binex = <BinaryExpression>ast;\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            binex.type = binex.operand2.type;\n            return binex;\n        }\n\n        public typeCheckLogOr(binex: BinaryExpression): BinaryExpression {\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            var leftType = binex.operand1.type;\n            var rightType = binex.operand2.type;\n\n            if (leftType == this.checker.anyType || rightType == this.checker.anyType) {\n                binex.type = this.checker.anyType;\n            }\n            else if (leftType == this.checker.booleanType) {\n                if (rightType == this.checker.booleanType) {\n                    binex.type = this.checker.booleanType;\n                }\n                else {\n                    binex.type = this.checker.anyType;\n                }\n            }\n            else if (leftType == this.checker.numberType) {\n                if (rightType == this.checker.numberType) {\n                    binex.type = this.checker.numberType;\n                }\n                else {\n                    binex.type = this.checker.anyType;\n                }\n            }\n            else if (leftType == this.checker.stringType) {\n                if (rightType == this.checker.stringType) {\n                    binex.type = this.checker.stringType;\n                }\n                else {\n                    binex.type = this.checker.anyType;\n                }\n            }\n            else {\n                if (this.checker.sourceIsSubtypeOfTarget(leftType, rightType)) {\n                    binex.type = rightType;\n                }\n                else if (this.checker.sourceIsSubtypeOfTarget(rightType, leftType)) {\n                    binex.type = leftType;\n                }\n                else {\n                    binex.type = this.checker.anyType;\n                }\n            }\n            return binex;\n        }\n\n        public typeCheckLogAnd(binex: BinaryExpression): BinaryExpression {\n            binex.operand1 = this.typeCheck(binex.operand1);\n            binex.operand2 = this.typeCheck(binex.operand2);\n            binex.type = binex.operand2.type;\n            return binex;\n        }\n\n        public tryAddCandidates(signature: Signature, actuals: Type[]';
var v27459 = v27460 + ", exactCandidates: Signature[], conversionCandidates: Signature[], comparisonInfo: TypeComparisonInfo): void {\n            var lowerBound = signature.nonOptionalParameterCount; // required parameters\n            var upperBound = signature.parameters.length; // required and optional parameters\n            var formalLen = lowerBound;\n            var acceptable = false;\n\n            if ((actuals.length >= lowerBound) && (signature.hasVariableArgList || actuals.length <= upperBound)) {\n                formalLen = (signature.hasVariableArgList ? signature.parameters.length : actuals.length);\n                acceptable = true;\n            }\n\n            var repeatType: Type = null;\n\n            if (acceptable || signature.hasVariableArgList) {\n                // assumed structure here is checked when signature is formed\n                if (signature.hasVariableArgList) {\n                    formalLen -= 1;\n                    repeatType = (<ParameterSymbol>signature.parameters[formalLen]).parameter.typeLink.type;\n                    repeatType = repeatType.elementType;\n                    acceptable = actuals.length >= formalLen;\n                }\n                var len = actuals.length;\n\n                var exact = acceptable;\n                var convert = acceptable;\n                for (var i = 0; i < len; i++) {\n                    var typeA: Type;\n                    if (i < formalLen) {\n                        typeA =\n                            (<ParameterSymbol>signature.parameters[i]).parameter.typeLink.type;\n                    }\n                    else {\n                        typeA = repeatType;\n                    }\n\n                    var typeB = actuals[i];\n                    if (!typeA || !typeB || !(this.checker.typesAreIdentical(typeA, typeB))) {\n                        exact = false;\n                    }\n                    // is the argument assignable to the parameter?\n                    if (!this.checker.sourceIsAssignableToTarget(typeB, typeA, comparisonInfo)) {\n                        convert = false;\n                    }\n                    if (!(exact || convert)) {\n                        break;\n                    }\n                }\n                if (exact) {\n                    exactCandidates[exactCandidates.length] = signature;\n                }\n                else if (convert && (exactCandidates.length == 0)) {\n                    conversionCandidates[conversionCandidates.length] = signature;\n                }\n\n            }\n        }\n\n        public resolveOverload(application: AST, group: SignatureGroup): Signature {\n            var rd = this.resolutionDataCache.getResolutionData();\n            var actuals = rd.actuals;\n            var exactCandidates = rd.exactCandidates;\n            var conversionCandidates = rd.conversionCandidates;\n            var candidate: Signature = null;\n            var hasOverloads = group.signatures.length > 1;\n            var comparisonInfo = new TypeComparisonInfo();\n            var args: ASTList = null;\n            var target: AST = null;\n\n            if (application.nodeType == NodeType.Call || application.nodeType == NodeType.New) {\n                var callEx = <CallExpression>application;\n                args = callEx.arguments;\n                target = callEx.target;\n                if (callEx.arguments) {\n                    var len = callEx.arguments.members.length;\n                    for (var i = 0; i < len; i++) {\n                        actuals[i] = callEx.arguments.members[i].type;\n                    }\n                }\n            }\n            else if (application.nodeType == NodeType.Index) {\n                var binExp = <BinaryExpression>application;\n                target = binExp.operand1;\n                args = new ASTList();\n                args.members[0] = binExp.operand2;\n                actuals[0] = binExp.operand2.type;\n            }\n\n            for (var j = 0, groupLen = group.signatures.length; j < groupLen; j++) {\n                var signature = group.signatures[j];\n                if (hasOverloads && signature == group.definitionSignature && !this.checker.canCallDefinitionSignature) {\n                    continue;\n                }\n                if (!signature.returnType.type && signature.declAST &&\n                    (signature.typeCheckStatus != TypeCheckStatus.Finished)) {\n                    this.typeCheckFunction(signature.declAST);\n                }\n                this.tryAddCandidates(signature, actuals, exactCandidates, conversionCandidates, comparisonInfo);\n            }\n            if (exactCandidates.length == 0) {\n\n                var applicableCandidates = this.checker.getApplicableSignatures(conversionCandidates, args, comparisonInfo);\n                if (applicableCandidates.length > 0) {\n                    var candidateInfo = this.checker.findMostApplicableSignature(applicableCandidates, args);\n                    if (candidateInfo.ambiguous) {\n                        this.checker.errorR";
var v27458 = v27459 + 'eporter.simpleError(target, "Ambiguous call expression - could not choose overload");\n                    }\n                    candidate = candidateInfo.sig;\n                }\n                else {\n                    var emsg = "Supplied parameters do not match any signature of call target";\n                    if (comparisonInfo.message) {\n                        this.checker.errorReporter.simpleError(target, emsg + ":\\n\\t" + comparisonInfo.message);\n                    }\n                    else {\n                        this.checker.errorReporter.simpleError(target, emsg);\n                    }\n                }\n            }\n            else {\n                if (exactCandidates.length > 1) {\n                    var applicableSigs: ApplicableSignature[] = [];\n                    for (var i = 0; i < exactCandidates.length; i++) {\n                        applicableSigs[i] = { signature: exactCandidates[i], hadProvisionalErrors: false };\n                    }\n                    var candidateInfo = this.checker.findMostApplicableSignature(applicableSigs, args);\n                    if (candidateInfo.ambiguous) {\n                        this.checker.errorReporter.simpleError(target, "Ambiguous call expression - could not choose overload");\n                    }\n                    candidate = candidateInfo.sig;\n                }\n                else {\n                    candidate = exactCandidates[0];\n                }\n            }\n\n            this.resolutionDataCache.returnResolutionData(rd);\n            return candidate;\n        }\n\n        public typeCheckNew(ast: AST): AST {\n            var callEx = <CallExpression>ast;\n\n            callEx.target = this.typeCheck(callEx.target);\n            var target = callEx.target;\n            if (target.type.construct || target.type.call) {\n                this.preTypeCheckCallArgs(callEx.arguments);\n            }\n            else {\n                callEx.arguments = <ASTList>this.typeCheck(callEx.arguments);\n            }\n\n            if (target.type == this.anyType) {\n                callEx.type = this.anyType;\n                callEx.arguments = <ASTList>this.typeCheck(callEx.arguments);\n            }\n            else {\n                if (target.type.construct) {\n                    var signature = this.resolveOverload(callEx, target.type.construct);\n                    if (signature == null) {\n                        callEx.type = this.anyType;\n                    }\n                    else if (signature.returnType.type == this.voidType) {\n                        callEx.type = this.anyType;\n                        callEx.signature = signature;\n                    }\n                    else {\n                        callEx.type = signature.returnType.type;\n                        callEx.signature = signature;\n                    }\n                }\n                else if (target.type.call) {\n                    var signature = this.resolveOverload(callEx, target.type.call);\n                    if (signature == null) {\n                        callEx.type = this.anyType;\n                    }\n                    else if ((signature.returnType.type == this.voidType) || (signature.returnType.type == this.anyType)) {\n                        callEx.type = this.anyType;\n                        callEx.signature = signature;\n                    }\n                    else {\n                        this.checker.errorReporter.simpleError(callEx.target,\n                           "new expression only valid on constructors");\n                    }\n                }\n                else if (target.type.elementType) {\n                    callEx.type = target.type;\n                }\n                else {\n                    this.checker.errorReporter.invalidCall(callEx, callEx.nodeType, this.scope);\n                    callEx.type = this.anyType;\n                }\n            }\n\n            this.postTypeCheckCallArgs(callEx);\n\n            return callEx;\n        }\n\n        // Typecheck all args that cannot be affected by contextual typing of overloads\n        public preTypeCheckCallArgs(args: ASTList) {\n\n            if (!args) {\n                return;\n            }\n\n            for (var i = 0; i < args.members.length; i++) {\n                switch (args.members[i].nodeType) {\n                    case NodeType.FuncDecl:\n                    case NodeType.ObjectLit:\n                    case NodeType.ArrayLit:\n                        continue;\n                    default:\n                        this.typeCheck(args.members[i]);\n                        break;\n                }\n            }\n        }\n\n        public postTypeCheckCallArgs(callEx: CallExpression) {\n\n            var acceptedTargetType = false;\n            var i = 0;\n\n            if (callEx.target &&\n                callEx.target.type &&\n                callEx.signature &&\n                callEx.arguments) {\n                var sig = callEx.signature;\n\n                if (sig && callEx.arguments.members.length >= si';
var v27457 = v27458 + 'g.nonOptionalParameterCount) {\n                    acceptedTargetType = true;\n                    var targetType: Type = null;\n                    var nonVarArgFormalParamLength = sig.hasVariableArgList ? sig.parameters.length - 1 : sig.parameters.length;\n                    var nonVarArgActualParamLength = callEx.arguments.members.length < nonVarArgFormalParamLength ? callEx.arguments.members.length : nonVarArgFormalParamLength\n\n                    for (i = 0; i < nonVarArgActualParamLength; i++) {\n                        targetType = sig.parameters[i].getType();\n                        switch (callEx.arguments.members[i].nodeType) {\n                            case NodeType.FuncDecl:\n                            case NodeType.ObjectLit:\n                            case NodeType.ArrayLit:\n                                this.checker.typeCheckWithContextualType(targetType, this.checker.inProvisionalTypecheckMode(), !sig.parameters[i].declAST.isParenthesized, callEx.arguments.members[i]);\n                                break;\n                        }\n                    }\n\n                    if (sig.hasVariableArgList) {\n                        var varArgParamIndex = sig.nonOptionalParameterCount - 1;\n                        targetType = sig.parameters[varArgParamIndex].getType();\n                        if (targetType) {\n                            targetType = targetType.elementType;\n                        }\n                        var isParenthesized = !sig.parameters[varArgParamIndex].declAST.isParenthesized;\n                        for (i = nonVarArgActualParamLength; i < callEx.arguments.members.length; i++) {\n                            switch (callEx.arguments.members[i].nodeType) {\n                                case NodeType.FuncDecl:\n                                case NodeType.ObjectLit:\n                                case NodeType.ArrayLit:\n                                    this.checker.typeCheckWithContextualType(targetType, this.checker.inProvisionalTypecheckMode(), isParenthesized, callEx.arguments.members[i]);\n                                    break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (!acceptedTargetType && callEx.arguments) {\n                this.checker.killCurrentContextualType();\n\n                for (i = 0; i < callEx.arguments.members.length; i++) {\n                    switch (callEx.arguments.members[i].nodeType) {\n                        case NodeType.FuncDecl:\n                        case NodeType.ObjectLit:\n                        case NodeType.ArrayLit:\n                            this.typeCheck(callEx.arguments.members[i]);\n                            break;\n                        default:\n                            continue;\n                    }\n                }\n            }\n        }\n\n        public typeCheckCall(ast: AST): AST {\n            var callEx = <CallExpression>ast;\n            if (this.checker.styleSettings.newMustBeUsed && (ast.nodeType == NodeType.New)) {\n                if (hasFlag(ast.flags, ASTFlags.IsStatement)) {\n                    this.checker.errorReporter.styleError(ast, "use of new expression as a statement");\n                }\n            }\n            else if ((!this.checker.styleSettings.evalOK) && (ast.nodeType == NodeType.Call)) {\n                if ((callEx.target.nodeType == NodeType.Name) && ((<Identifier>callEx.target).text == "eval")) {\n                    this.checker.errorReporter.styleError(callEx, "eval not permitted");\n                }\n            }\n\n            if (callEx.target.nodeType == NodeType.FuncDecl) {\n                (<FuncDecl>callEx.target).isInlineCallLiteral = true;\n            }\n\n            var prevInSuperCall = this.inSuperCall;\n\n            if (callEx.target.nodeType == NodeType.Super) {\n                this.inSuperCall = true;\n            }\n\n            callEx.target = this.typeCheck(callEx.target);\n            this.preTypeCheckCallArgs(callEx.arguments);\n\n            var target = callEx.target;\n\n            if ((target.type == null) || (target.type == this.anyType) || (this.functionInterfaceType && target.type == this.functionInterfaceType)) {\n                callEx.type = this.anyType;\n            }\n            else {\n                var fnType = target.type;\n                if (fnType.call) {\n                    var signature = this.resolveOverload(callEx, fnType.call);\n                    if (signature == null) {\n                        callEx.type = this.anyType;\n                    }\n                    else {\n                        callEx.type = signature.returnType.type;\n                        callEx.signature = signature;\n                    }\n                }\n                else {\n                    // track calls to class base class\n                    if (callEx.target.nodeType == NodeType.Super &&\n                        this.thisFnc &&\n                        this.thisFnc.isConstructor &&\n        ';
var v27456 = v27457 + '                hasFlag(this.thisFnc.fncFlags, FncFlags.ClassMethod)) {\n\n                            // Need to use the class type for the construct signature, not the instance type\n                        var signature = fnType.symbol.type.construct ? this.resolveOverload(callEx, fnType.symbol.type.construct) : null;\n\n                        if (signature == null) {\n                            callEx.type = this.anyType;\n                        }\n                        else {\n                            callEx.flags |= ASTFlags.ClassBaseConstructorCall;\n                            callEx.type = signature.returnType.type;\n                            callEx.signature = signature;\n                        }\n                    }\n                    else {\n                        callEx.type = this.anyType;\n                        this.checker.errorReporter.invalidCall(callEx, callEx.nodeType, this.scope);\n                    }\n                }\n            }\n            this.postTypeCheckCallArgs(callEx);\n\n            this.inSuperCall = prevInSuperCall;\n\n            return callEx;\n        }\n\n        public assignScopes(ast: AST) {\n            var script = <Script>ast;\n            this.checker.locationInfo = script.locationInfo;\n            var globalChain = new ScopeChain(this.checker.gloMod, null, this.globalScope);\n            var context = new AssignScopeContext(globalChain, this, [this.checker.currentModDecl]);\n            getAstWalkerFactory().walk(ast, preAssignScopes, postAssignScopes, null, context);\n        }\n\n        public findMemberScope(enclosingScopeContext: EnclosingScopeContext, matchFlag: ASTFlags) {\n            var enclosingScope = enclosingScopeContext.getScope();\n            var pos = enclosingScopeContext.pos - enclosingScopeContext.getScriptFragmentPosition();\n            var scriptFragment = enclosingScopeContext.getScriptFragment();\n\n            var memContext = new MemberScopeContext(this, pos, matchFlag);\n            memContext.scope = enclosingScope;\n            if (scriptFragment.nodeType == NodeType.Name) {\n                return scriptFragment.type.getMemberScope(this);\n            }\n            else {\n                getAstWalkerFactory().walk(scriptFragment, preFindMemberScope, null, null, memContext);\n                if (memContext.ast && enclosingScopeContext.enclosingClassDecl && memContext.ast.type == enclosingScopeContext.enclosingClassDecl.type.instanceType) {\n                    enclosingScopeContext.publicsOnly = false;\n                }\n                if (memContext.type) {\n                    return memContext.type.getMemberScope(this);\n                }\n                else {\n                    return null;\n                }\n            }\n        }\n\n        public findMemberScopeAt(enclosingScopeContext: EnclosingScopeContext) {\n            return this.findMemberScope(enclosingScopeContext, ASTFlags.DotLHS);\n        }\n\n        public findMemberScopeAtFullAst(enclosingScopeContext: EnclosingScopeContext) {\n            var matchFlag = ASTFlags.DotLHS;\n            var pos = enclosingScopeContext.pos;\n            var astResult: AST = null;\n\n            var preFindMemberScopeFullAst = function (ast: AST, parent: AST, walker: IAstWalker) {\n                if (isValidAstNode(ast)) {\n                    // Note: pos == ast.limChar       in case of incomplete code (e.g. "foo.")\n                    // Note: (pos - 1) == ast.limChar in case of complete code (e.g. "foo.bar")\n                    if (hasFlag(ast.flags, matchFlag) && (pos == ast.limChar || (pos - 1) == ast.limChar)) {\n                        astResult = ast;\n                        walker.options.stopWalk();\n                    }\n\n                    // Stop traversal if range does not contain position\n                    walker.options.goChildren = (ast.minChar <= pos) && (pos <= ast.limChar);\n                }\n                return ast;\n            }\n\n            var preFindMemberScopeFullAstFuzy = function (ast: AST, parent: AST, walker: IAstWalker) {\n                if (isValidAstNode(ast)) {\n                    if (hasFlag(ast.flags, matchFlag) && ((ast.minChar < pos) && (pos <= ast.limChar))) {\n                        astResult = ast;\n                    }\n\n                    // Stop traversal if range does not contain position\n                    walker.options.goChildren = (ast.minChar <= pos) && (pos <= ast.limChar);\n                }\n                return ast;\n            }\n\n            getAstWalkerFactory().walk(enclosingScopeContext.script, preFindMemberScopeFullAst);\n\n            if (astResult == null) {\n                // Perform a more "fusy" match. This is because the limChar of AST nodes is sometimes\n                // not what we expect, for example:\n                //   foo./*comment*/;\n                // In this case, limChar points to ";" instead of "." (because of the trailing comment).\n                getAstWalkerFactory().walk(enclosingScopeContext.script, preFindMemberScopeFullAstFuzy)';
var v27455 = v27456 + ";\n            }\n\n            if (astResult &&\n                enclosingScopeContext.enclosingClassDecl &&\n                astResult.type == enclosingScopeContext.enclosingClassDecl.type.instanceType) {\n                enclosingScopeContext.publicsOnly = false;\n            }\n\n            if (astResult && astResult.type) {\n                return astResult.type.getMemberScope(this);\n            }\n            else {\n                return null;\n            }\n        }\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path='diagnostics.ts' />\n///<reference path='flags.ts' />\n///<reference path='nodeTypes.ts' />\n///<reference path='hashTable.ts' />\n///<reference path='ast.ts' />\n///<reference path='astWalker.ts' />\n///<reference path='astWalkerCallback.ts' />\n///<reference path='astPath.ts' />\n///<reference path='astLogger.ts' />\n///<reference path='binder.ts' />\n///<reference path='base64.ts' />\n///<reference path='sourceMapping.ts' />\n///<reference path='emitter.ts' />\n///<reference path='errorReporter.ts' />\n///<reference path='parser.ts' />\n///<reference path='printContext.ts' />\n///<reference path='scanner.ts' />\n///<reference path='scopeAssignment.ts' />\n///<reference path='scopeWalk.ts' />\n///<reference path='signatures.ts' />\n///<reference path='symbols.ts' />\n///<reference path='symbolScope.ts' />\n///<reference path='tokens.ts' />\n///<reference path='typeChecker.ts' />\n///<reference path='typeCollection.ts' />\n///<reference path='typeFlow.ts' />\n///<reference path='types.ts' />\n///<reference path='pathUtils.ts' />\n///<reference path='referenceResolution.ts' />\n///<reference path='precompile.ts' />\n///<reference path='incrementalParser.ts' />\n///<reference path='declarationEmitter.ts' />\n\nmodule TypeScript {\n\n    export enum UpdateUnitKind {\n        Unknown,\n        NoEdits,\n        EditsInsideSingleScope,\n    }\n\n    export class ScriptEditRange {\n        constructor (public minChar: number,\n                     public limChar: number,\n                     public delta: number) { }\n\n        static unknown(): ScriptEditRange {\n            return new ScriptEditRange(-1, -1, -1);\n        }\n\n        public isUnknown() {\n            return this.minChar === -1 && this.limChar === -1 && this.delta === -1;\n        }\n\n        public containsPosition(pos: number) {\n            return (this.minChar <= pos && pos < this.limChar)\n                || (this.minChar <= pos && pos < this.limChar + this.delta);\n        }\n\n        public toString(): string {\n            return \"editRange(minChar=\" + this.minChar + \", limChar=\" + this.limChar + \", delta=\" + this.delta + \")\";\n        }\n    }\n\n    export class UpdateUnitResult {\n\n        constructor (public kind: UpdateUnitKind, public unitIndex: number, public script1: Script, public script2: Script) { }\n\n        public scope1: AST = null;\n        public scope2: AST = null;\n        public editRange: ScriptEditRange = null;\n        public parseErrors: ErrorEntry[] = [];\n\n        static noEdits(unitIndex: number) {\n            return new UpdateUnitResult(UpdateUnitKind.NoEdits, unitIndex, null, null);\n        }\n\n        static unknownEdits(script1: Script, script2: Script, parseErrors: ErrorEntry[]) {\n            var result = new UpdateUnitResult(UpdateUnitKind.Unknown, script1.locationInfo.unitIndex, script1, script2);\n            result.parseErrors = parseErrors;\n            return result;\n        }\n\n        static singleScopeEdits(script1: Script, script2: Script, scope1: AST, scope2: AST, editRange: ScriptEditRange, parseErrors: ErrorEntry[]) {\n            var result = new UpdateUnitResult(UpdateUnitKind.EditsInsideSingleScope, script1.locationInfo.unitIndex, script1, script2);\n            result.scope1 = scope1;\n            result.scope2 = scope2;\n            result.editRange = editRange;\n            result.parseErrors = parseErrors;\n            return result;\n        }\n    }\n\n    export class ErrorEntry {\n        constructor (public unitIndex: number,\n                    public minChar: number,\n                    public limChar: number,\n                    public message: string) { }\n    }\n\n    export var defaultSettings = new CompilationSettings();\n\n    export interface EmitterIOHost {\n        // function that can even create a folder structure if needed\n        createFile(path: string, useUTF8?: bool): ITextWriter;\n\n        // function to check if file exists on the disk\n        fileExi";
var v27454 = v27455 + 'sts(path: string): bool;\n\n        // Function to check if the directory exists on the disk\n        directoryExists(path: string): bool;\n\n        // Resolves the path\n        resolvePath(path: string): string;\n    }\n\n    export class TypeScriptCompiler {\n        public parser = new Parser();\n        public typeChecker: TypeChecker;\n        public typeFlow: TypeFlow = null;\n        public scripts = new ASTList();\n        public units: LocationInfo[] = new LocationInfo[];\n        public errorReporter: ErrorReporter;\n\n        public persistentTypeState: PersistentGlobalTypeState;\n\n\n        public emitSettings: EmitOptions;\n\n        constructor (public errorOutput: ITextWriter, public logger: ILogger = new NullLogger(), public settings: CompilationSettings = defaultSettings) {\n            this.errorReporter = new ErrorReporter(this.errorOutput);\n            this.persistentTypeState = new PersistentGlobalTypeState(this.errorReporter);\n            this.errorReporter.parser = this.parser;\n            this.initTypeChecker(this.errorOutput);\n\n            this.parser.style_requireSemi = this.settings.styleSettings.requireSemi;\n            this.parser.style_funcInLoop = this.settings.styleSettings.funcInLoop;\n            this.parser.inferPropertiesFromThisAssignment = this.settings.inferPropertiesFromThisAssignment;\n            this.emitSettings = new EmitOptions(this.settings);\n            codeGenTarget = settings.codeGenTarget;\n        }\n\n        public timeFunction(funcDescription: string, func: () => any): any {\n            return TypeScript.timeFunction(this.logger, funcDescription, func);\n        }\n\n        public initTypeChecker(errorOutput: ITextWriter) {\n            // The initial "refresh" initializes the persistent type state\n            this.persistentTypeState.refreshPersistentState();\n            this.typeChecker = new TypeChecker(this.persistentTypeState);\n            this.typeChecker.errorReporter = this.errorReporter;\n\n            // REVIEW: These properties should be moved out of the typeCheck object\n            // ideally, CF should be a separate pass, independent of control flow\n            this.typeChecker.checkControlFlow = this.settings.controlFlow;\n            this.typeChecker.checkControlFlowUseDef = this.settings.controlFlowUseDef;\n            this.typeChecker.printControlFlowGraph = this.settings.printControlFlow;\n\n            this.typeChecker.errorsOnWith = this.settings.errorOnWith;\n            this.typeChecker.styleSettings = this.settings.styleSettings;\n            this.typeChecker.canCallDefinitionSignature = this.settings.canCallDefinitionSignature;\n\n            this.errorReporter.checker = this.typeChecker;\n            this.setErrorOutput(this.errorOutput);\n        }\n\n        public setErrorOutput(outerr) {\n            this.errorOutput = outerr;\n            this.errorReporter.setErrOut(outerr);\n            this.parser.outfile = outerr;\n        }\n\n        public emitCommentsToOutput() {\n            this.emitSettings = new EmitOptions(this.settings);\n        }\n\n        public setErrorCallback(fn: (minChar: number, charLen: number, message: string,\n            unitIndex: number) =>void ) {\n            this.parser.errorCallback = fn;\n        }\n\n        public updateUnit(prog: string, filename: string, setRecovery: bool) {\n            return this.updateSourceUnit(new StringSourceText(prog), filename, setRecovery);\n        }\n\n        public updateSourceUnit(sourceText: ISourceText, filename: string, setRecovery: bool): bool {\n            return this.timeFunction("updateSourceUnit(" + filename + ")", () => {\n                var updateResult = this.partialUpdateUnit(sourceText, filename, setRecovery);\n                return this.applyUpdateResult(updateResult);\n            });\n        }\n\n        // Apply changes to compiler state.\n        // Return "false" if the change is empty and nothing was updated.\n        public applyUpdateResult(updateResult: UpdateUnitResult): bool {\n            switch (updateResult.kind) {\n                case UpdateUnitKind.NoEdits:\n                    return false;\n\n                case UpdateUnitKind.Unknown:\n                    this.scripts.members[updateResult.unitIndex] = updateResult.script2;\n                    this.units[updateResult.unitIndex] = updateResult.script2.locationInfo;\n                    for (var i = 0, len = updateResult.parseErrors.length; i < len; i++) {\n                        var e = updateResult.parseErrors[i];\n                        if (this.parser.errorCallback) {\n                            this.parser.errorCallback(e.minChar, e.limChar - e.minChar, e.message, e.unitIndex);\n                        }\n                    }\n                    return true;\n\n                case UpdateUnitKind.EditsInsideSingleScope:\n                    new IncrementalParser(this.logger).mergeTrees(updateResult);\n                    return true;\n            }\n        }\n\n        public partialUpdateUnit(sourceText: ISourceText, filename: string, setRecovery:';
var v27453 = v27454 + ' bool): UpdateUnitResult {\n            return this.timeFunction("partialUpdateUnit(" + filename + ")", () => {\n                for (var i = 0, len = this.units.length; i < len; i++) {\n                    if (this.units[i].filename == filename) {\n                        if ((<Script>this.scripts.members[i]).isResident) {\n                            return UpdateUnitResult.noEdits(i);\n                        }\n\n                        if (setRecovery) {\n                            this.parser.setErrorRecovery(null);\n                        }\n\n                        var updateResult: UpdateUnitResult;\n\n                        // Capture parsing errors so that they are part of "updateResult"\n                        var parseErrors: ErrorEntry[] = [];\n                        var errorCapture = (minChar: number, charLen: number, message: string, unitIndex: number): void => {\n                            parseErrors.push(new ErrorEntry(unitIndex, minChar, minChar + charLen, message));\n                        };\n                        var svErrorCallback = this.parser.errorCallback;\n                        if (svErrorCallback)\n                            this.parser.errorCallback = errorCapture;\n\n                        var oldScript = <Script>this.scripts.members[i];\n                        var newScript = this.parser.parse(sourceText, filename, i);\n\n                        if (svErrorCallback)\n                            this.parser.errorCallback = svErrorCallback;\n\n                        updateResult = UpdateUnitResult.unknownEdits(oldScript, newScript, parseErrors);\n\n                        return updateResult;\n                    }\n                }\n                throw new Error("Unknown file \\"" + filename + "\\"");\n            });\n        }\n\n        public addUnit(prog: string, filename: string, keepResident? = false, referencedFiles?: IFileReference[] = []): Script {\n            return this.addSourceUnit(new StringSourceText(prog), filename, keepResident, referencedFiles);\n        }\n\n        public addSourceUnit(sourceText: ISourceText, filename: string, keepResident:bool, referencedFiles?: IFileReference[] = []): Script {\n            return this.timeFunction("addSourceUnit(" + filename + ", " + keepResident + ")", () => {\n                var script: Script = this.parser.parse(sourceText, filename, this.units.length, AllowedElements.Global);\n                script.referencedFiles = referencedFiles;\n                script.isResident = keepResident;\n                this.persistentTypeState.setCollectionMode(keepResident ? TypeCheckCollectionMode.Resident : TypeCheckCollectionMode.Transient);\n                var index = this.units.length;\n                this.units[index] = script.locationInfo;\n                this.typeChecker.collectTypes(script);\n                this.scripts.append(script);\n                return script\n            });\n        }\n\n        public parseUnit(prog: string, filename: string) {\n            return this.parseSourceUnit(new StringSourceText(prog), filename);\n        }\n\n        public parseSourceUnit(sourceText: ISourceText, filename: string) {\n            this.parser.setErrorRecovery(this.errorOutput);\n            var script: Script = this.parser.parse(sourceText, filename, 0);\n\n            var index = this.units.length;\n            this.units[index] = script.locationInfo;\n            this.typeChecker.collectTypes(script);\n            this.scripts.append(script);\n        }\n\n        public typeCheck() {\n            return this.timeFunction("typeCheck()", () => {\n                var binder = new Binder(this.typeChecker);\n                this.typeChecker.units = this.units;\n                binder.bind(this.typeChecker.globalScope, this.typeChecker.globals);\n                binder.bind(this.typeChecker.globalScope, this.typeChecker.ambientGlobals);\n                binder.bind(this.typeChecker.globalScope, this.typeChecker.globalTypes);\n                binder.bind(this.typeChecker.globalScope, this.typeChecker.ambientGlobalTypes);\n                this.typeFlow = new TypeFlow(this.logger, this.typeChecker.globalScope, this.parser, this.typeChecker);\n                var i = 0;\n                var script: Script = null;\n                var len = this.scripts.members.length;\n\n\n                this.persistentTypeState.setCollectionMode(TypeCheckCollectionMode.Resident);\n                // first, typecheck resident "lib" scripts, if necessary\n                for (i = 0; i < len; i++) {\n                    script = <Script>this.scripts.members[i];\n                    if (!script.isResident || script.hasBeenTypeChecked) { continue; }\n\n                    this.typeFlow.assignScopes(script);\n                    this.typeFlow.initLibs();\n                }\n                for (i = 0; i < len; i++) {\n                    script = <Script>this.scripts.members[i];\n                    if (!script.isResident || script.hasBeenTypeChecked) { continue; }\n\n                    this.typeFlow.typeCheck(script);';
var v27452 = v27453 + '\n                    script.hasBeenTypeChecked = true;\n                }\n\n                // next typecheck scripts that may change\n                this.persistentTypeState.setCollectionMode(TypeCheckCollectionMode.Transient);\n                len = this.scripts.members.length;\n                for (i = 0; i < len; i++) {\n                    script = <Script>this.scripts.members[i];\n                    if (script.isResident) { continue; }\n                    this.typeFlow.assignScopes(script);\n                    this.typeFlow.initLibs();\n                }\n                for (i = 0; i < len; i++) {\n                    script = <Script>this.scripts.members[i];\n                    if (script.isResident) { continue; }\n                    this.typeFlow.typeCheck(script);\n                }\n\n                return null;\n            });\n        }\n\n        public cleanASTTypesForReTypeCheck(ast: AST) {\n            function cleanASTType(ast: AST, parent: AST): AST {\n                ast.type = null;\n                if (ast.nodeType == NodeType.VarDecl) {\n                    var vardecl = <VarDecl>ast;\n                    vardecl.sym = null;\n                }\n                else if (ast.nodeType == NodeType.ArgDecl) {\n                    var argdecl = <ArgDecl>ast;\n                    argdecl.sym = null;\n                }\n                else if (ast.nodeType == NodeType.Name) {\n                    var name = <Identifier>ast;\n                    name.sym = null;\n                }\n                else if (ast.nodeType == NodeType.FuncDecl) {\n                    var funcdecl = <FuncDecl>ast;\n                    funcdecl.signature = null;\n                    funcdecl.freeVariables = new Symbol[]\n                    funcdecl.symbols = null;\n                    funcdecl.accessorSymbol = null;\n                    funcdecl.scopeType = null;\n                }\n                else if (ast.nodeType == NodeType.ModuleDeclaration) {\n                    var modDecl = <ModuleDeclaration>ast;\n                    modDecl.mod = null;\n                }\n                else if (ast.nodeType == NodeType.With) {\n                    (<WithStatement>ast).withSym = null;\n                }\n                else if (ast.nodeType == NodeType.Catch) {\n                    (<Catch>ast).containedScope = null;\n                }\n                return ast;\n            }\n            TypeScript.getAstWalkerFactory().walk(ast, cleanASTType);\n        }\n\n        public cleanTypesForReTypeCheck() {\n            return this.timeFunction("cleanTypesForReTypeCheck()", () => {\n                for (var i = 0, len = this.scripts.members.length; i < len; i++) {\n                    var script = this.scripts.members[i];\n                    if ((<Script>script).isResident) {\n                        continue;\n                    }\n                    this.cleanASTTypesForReTypeCheck(script);\n                    this.typeChecker.collectTypes(script);\n                }\n\n                return null;\n            });\n        }\n\n        // Return "true" if the incremental typecheck was successful\n        // Return "false" if incremental typecheck failed, requiring a full typecheck\n        public attemptIncrementalTypeCheck(updateResult: TypeScript.UpdateUnitResult): bool {\n            return this.timeFunction("attemptIncrementalTypeCheck()", () => {\n                // updateResult.kind == editsInsideFunction\n                // updateResult.scope1 == old function\n                // updateResult.scope2 == new function\n                //REVIEW: What about typecheck errors? How do we replace the old ones with the new ones?\n                return false;\n            });\n        }\n\n        public reTypeCheck() {\n            return this.timeFunction("reTypeCheck()", () => {\n                CompilerDiagnostics.analysisPass++;\n                this.initTypeChecker(this.errorOutput);\n                this.persistentTypeState.setCollectionMode(TypeCheckCollectionMode.Transient);\n                this.cleanTypesForReTypeCheck();\n                return this.typeCheck();\n            });\n        }\n\n        private isDynamicModuleCompilation() {\n            for (var i = 0, len = this.scripts.members.length; i < len; i++) {\n                var script = <Script>this.scripts.members[i];\n                if (!script.isDeclareFile && script.topLevelMod != null) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private updateCommonDirectoryPath() {\n            var commonComponents: string[] = [];\n            var commonComponentsLength = -1;\n            for (var i = 0, len = this.scripts.members.length; i < len; i++) {\n                var script = <Script>this.scripts.members[i];\n                if (script.emitRequired(this.emitSettings)) {\n                    var fileName = script.locationInfo.filename;\n                    var fileComponents = filePathComponents(fileName);\n                    if (commonComponentsLength == -1) {\n            ';
var v27451 = v27452 + '            // First time at finding common path\n                        // So common path = directory of file\n                        commonComponents = fileComponents;\n                        commonComponentsLength = commonComponents.length;\n                    } else {\n                        var updatedPath = false;\n                        for (var j = 0; j < commonComponentsLength && j < fileComponents.length; j++) {\n                            if (commonComponents[j] != fileComponents[j]) {\n                                // The new components = 0 ... j -1\n                                commonComponentsLength = j;\n                                updatedPath = true;\n\n                                if (j == 0) {\n                                    // Its error to not have common path\n                                    this.errorReporter.emitterError(null, "Cannot find the common subdirectory path for the input files");\n                                    return;\n                                }\n\n                                break;\n                            }\n                        }\n\n                        // If the fileComponent path completely matched and less than already found update the length\n                        if (!updatedPath && fileComponents.length < commonComponentsLength) {\n                            commonComponentsLength = fileComponents.length;\n                        }\n                    }\n                }\n            }\n\n            this.emitSettings.commonDirectoryPath = commonComponents.slice(0, commonComponentsLength).join("/") + "/";\n            if (this.emitSettings.outputOption.charAt(this.emitSettings.outputOption.length - 1) != "/") {\n                this.emitSettings.outputOption += "/";\n            }\n        }\n\n        public parseEmitOption(ioHost: EmitterIOHost) {\n            this.emitSettings.ioHost = ioHost;\n            if (this.emitSettings.outputOption == "") {\n                this.emitSettings.outputMany = true;\n                this.emitSettings.commonDirectoryPath = "";\n                return;\n            }\n\n            this.emitSettings.outputOption = switchToForwardSlashes(this.emitSettings.ioHost.resolvePath(this.emitSettings.outputOption));\n\n            // Determine if output options is directory or file\n            if (this.emitSettings.ioHost.directoryExists(this.emitSettings.outputOption)) {\n                // Existing directory\n                this.emitSettings.outputMany = true;\n            } else if (this.emitSettings.ioHost.fileExists(this.emitSettings.outputOption)) {\n                // Existing file\n                this.emitSettings.outputMany = false;\n            }\n            else {\n                // New File/directory\n                this.emitSettings.outputMany = !isJSFile(this.emitSettings.outputOption);\n            }\n\n            // Verify if options are correct\n            if (this.isDynamicModuleCompilation() && !this.emitSettings.outputMany) {\n                this.errorReporter.emitterError(null, "Cannot compile dynamic modules when emitting into single file");\n            }\n\n            // Parse the directory structure\n            if (this.emitSettings.outputMany) {\n                this.updateCommonDirectoryPath();\n            }\n        }\n\n        public useUTF8ForFile(script: Script) {\n            if (this.emitSettings.outputMany) {\n                return this.outputScriptToUTF8(script);\n            } else {\n                return this.outputScriptsToUTF8(<Script[]>(this.scripts.members));\n            }\n        }\n\n        static mapToDTSFileName(fileName: string, wholeFileNameReplaced: bool) {\n            return getDeclareFilePath(fileName);\n        }\n\n        private canEmitDeclarations(script?: Script) {\n            if (!this.settings.generateDeclarationFiles) {\n                return false;\n            }\n\n            // If its already a declare file or is resident or does not contain body \n            if (!!script && (script.isDeclareFile || script.isResident || script.bod == null)) {\n                return false;\n            }\n\n            return true;\n        }\n\n        public emitDeclarationsUnit(script: Script, reuseEmitter?: bool, declarationEmitter?: DeclarationEmitter) {\n            if (!this.canEmitDeclarations(script)) {\n                return null;\n            }\n\n            if (!declarationEmitter) {\n                var declareFileName = this.emitSettings.mapOutputFileName(script.locationInfo.filename, TypeScriptCompiler.mapToDTSFileName);\n                var declareFile = this.createFile(declareFileName, this.useUTF8ForFile(script));\n                declarationEmitter = new DeclarationEmitter(this.typeChecker, this.emitSettings, this.errorReporter);\n                declarationEmitter.setDeclarationFile(declareFile);\n            }\n\n            declarationEmitter.emitDeclarations(script);\n\n            if (!reuseEmitter) {\n                declarationEmitter.Close();\n                return null;\n            } else {';
var v27450 = v27451 + '\n                return declarationEmitter;\n            }\n        }\n\n        public emitDeclarations() {\n            if (!this.canEmitDeclarations()) {\n                return;\n            }\n\n            if (this.errorReporter.hasErrors) {\n                // There were errors reported, do not generate declaration file\n                return;\n            }\n\n            if (this.scripts.members.length == 0) {\n                return;\n            }\n\n            var declarationEmitter: DeclarationEmitter = null;\n            for (var i = 0, len = this.scripts.members.length; i < len; i++) {\n                var script = <Script>this.scripts.members[i];\n                if (this.emitSettings.outputMany || declarationEmitter == null) {\n                    // Create or reuse file\n                    declarationEmitter = this.emitDeclarationsUnit(script, !this.emitSettings.outputMany);\n                } else {\n                    // Emit in existing emitter\n                    this.emitDeclarationsUnit(script, true, declarationEmitter);\n                }\n            }\n\n            if (declarationEmitter) {\n                declarationEmitter.Close();\n            }\n        }\n\n        static mapToFileNameExtension(extension: string, fileName: string, wholeFileNameReplaced: bool) {\n            if (wholeFileNameReplaced) {\n                // The complete output is redirected in this file so do not change extension\n                return fileName;\n            } else {\n                // Change the extension of the file\n                var splitFname = fileName.split(".");\n                splitFname.pop();\n                return splitFname.join(".") + extension;\n            }\n        }\n\n        static mapToJSFileName(fileName: string, wholeFileNameReplaced: bool) {\n            return TypeScriptCompiler.mapToFileNameExtension(".js", fileName, wholeFileNameReplaced);\n        }\n\n        public emitUnit(script: Script, reuseEmitter?: bool, emitter?: Emitter) {\n            if (!script.emitRequired(this.emitSettings)) {\n                return null;\n            }\n\n            var fname = script.locationInfo.filename;\n            if (!emitter) {\n                var outFname = this.emitSettings.mapOutputFileName(fname, TypeScriptCompiler.mapToJSFileName);\n                var outFile = this.createFile(outFname, this.useUTF8ForFile(script));\n                emitter = new Emitter(this.typeChecker, outFname, outFile, this.emitSettings, this.errorReporter);\n                if (this.settings.mapSourceFiles) {\n                    emitter.setSourceMappings(new TypeScript.SourceMapper(fname, outFname, outFile, this.createFile(outFname + SourceMapper.MapFileExtension, false), this.errorReporter));\n                }\n            } else if (this.settings.mapSourceFiles) {\n                emitter.setSourceMappings(new TypeScript.SourceMapper(fname, emitter.emittingFileName, emitter.outfile, emitter.sourceMapper.sourceMapOut, this.errorReporter));\n            }\n\n            this.typeChecker.locationInfo = script.locationInfo;\n            emitter.emitJavascript(script, TokenID.Comma, false);\n            if (!reuseEmitter) {\n                emitter.Close();\n                return null;\n            } else {\n                return emitter;\n            }\n        }\n\n        public emit(ioHost: EmitterIOHost) {\n            this.parseEmitOption(ioHost);\n\n            var emitter: Emitter = null;\n            for (var i = 0, len = this.scripts.members.length; i < len; i++) {\n                var script = <Script>this.scripts.members[i];\n                if (this.emitSettings.outputMany || emitter == null) {\n                    emitter = this.emitUnit(script, !this.emitSettings.outputMany);\n                } else {\n                    this.emitUnit(script, true, emitter);\n                }\n            }\n\n            if (emitter) {\n                emitter.Close();\n            }\n        }\n\n        public emitToOutfile(outputFile: ITextWriter) {\n            if (this.settings.mapSourceFiles) {\n                throw Error("Cannot generate source map");\n            }\n\n            if (this.settings.generateDeclarationFiles) {\n                throw Error("Cannot generate declaration files");\n            }\n\n            if (this.settings.outputOption != "") {\n                throw Error("Cannot parse output option");\n            }\n\n            var emitter: Emitter = emitter = new Emitter(this.typeChecker, "stdout", outputFile, this.emitSettings, this.errorReporter);;\n            for (var i = 0, len = this.scripts.members.length; i < len; i++) {\n                var script = <Script>this.scripts.members[i];\n                this.typeChecker.locationInfo = script.locationInfo;\n                emitter.emitJavascript(script, TokenID.Comma, false);\n            }\n        }\n\n        public emitAST(ioHost: EmitterIOHost) {\n            this.parseEmitOption(ioHost);\n\n            var outFile: ITextWriter = null;\n            var context: PrintContext = null;\n\n            for (var i = 0, ';
var v27449 = v27450 + 'len = this.scripts.members.length; i < len; i++) {\n                var script = <Script>this.scripts.members[i];\n                if (this.emitSettings.outputMany || context == null) {\n                    var fname = this.units[i].filename;\n                    var mapToTxtFileName = (fileName: string, wholeFileNameReplaced: bool) => {\n                        return TypeScriptCompiler.mapToFileNameExtension(".txt", fileName, wholeFileNameReplaced);\n                    };\n                    var outFname = this.emitSettings.mapOutputFileName(fname, mapToTxtFileName);\n                    outFile = this.createFile(outFname, this.useUTF8ForFile(script));\n                    context = new PrintContext(outFile, this.parser);\n                }\n                getAstWalkerFactory().walk(script, prePrintAST, postPrintAST, null, context);\n                if (this.emitSettings.outputMany) {\n                    try {\n                        outFile.Close();\n                    } catch (e) {\n                        this.errorReporter.emitterError(null, e.message);\n                    }\n                }\n            }\n\n            if (!this.emitSettings.outputMany) {\n                try {\n                    outFile.Close();\n                } catch (e) {\n                    this.errorReporter.emitterError(null, e.message);\n                }\n            }\n        }\n\n        private outputScriptToUTF8(script: Script): bool {\n            return script.containsUnicodeChar || (this.emitSettings.emitComments && script.containsUnicodeCharInComment);\n        }\n\n        private outputScriptsToUTF8(scripts: Script[]): bool {\n            for (var i = 0, len = scripts.length; i < len; i++) {\n                var script = scripts[i];\n                if (this.outputScriptToUTF8(script)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private createFile(fileName: string, useUTF8: bool): ITextWriter {\n            try {\n                // Creating files can cause exceptions, report them.   \n                return this.emitSettings.ioHost.createFile(fileName, useUTF8);\n            } catch (ex) {\n                this.errorReporter.emitterError(null, ex.message);\n            }\n        }\n    }\n\n    export class ScopeEntry {\n        constructor (\n            public name: string,\n            public type: string,\n            public sym: Symbol) {\n        }\n    }\n\n    export class ScopeTraversal {\n        constructor (private compiler: TypeScriptCompiler) {\n        }\n\n        public getScope(enclosingScopeContext: EnclosingScopeContext): SymbolScope {\n            if (enclosingScopeContext.enclosingObjectLit && enclosingScopeContext.isMemberCompletion) {\n                return enclosingScopeContext.getObjectLiteralScope();\n            }\n            else if (enclosingScopeContext.isMemberCompletion) {\n                if (enclosingScopeContext.useFullAst) {\n                    return this.compiler.typeFlow.findMemberScopeAtFullAst(enclosingScopeContext)\n                }\n                else {\n                    return this.compiler.typeFlow.findMemberScopeAt(enclosingScopeContext)\n                }\n            }\n            else {\n                return enclosingScopeContext.getScope();\n            }\n        }\n\n        public getScopeEntries(enclosingScopeContext: EnclosingScopeContext): ScopeEntry[] {\n            var scope = this.getScope(enclosingScopeContext);\n            if (scope == null) {\n                return [];\n            }\n\n            var inScopeNames: IHashTable = new StringHashTable();\n            var allSymbolNames: string[] = scope.getAllSymbolNames(enclosingScopeContext.isMemberCompletion);\n\n            // there may be duplicates between the type and value tables, so batch the symbols\n            // getTypeNamesForNames will prefer the entry in the value table\n            for (var i = 0; i < allSymbolNames.length; i++) {\n                var name = allSymbolNames[i];\n\n                // Skip global/internal symbols that won\'t compile in user code\n                if (name == globalId || name == "_Core" || name == "_element") {\n                    continue;\n                }\n\n                inScopeNames.add(name, "");\n            }\n\n            var svModuleDecl = this.compiler.typeChecker.currentModDecl;\n            this.compiler.typeChecker.currentModDecl = enclosingScopeContext.deepestModuleDecl;\n\n            var result = this.getTypeNamesForNames(enclosingScopeContext, inScopeNames.getAllKeys(), scope);\n\n            this.compiler.typeChecker.currentModDecl = svModuleDecl;\n            return result;\n        }\n\n        private getTypeNamesForNames(enclosingScopeContext: EnclosingScopeContext, allNames: string[], scope: SymbolScope): ScopeEntry[] {\n            var result: ScopeEntry[] = [];\n\n            var enclosingScope = enclosingScopeContext.getScope();\n            for (var i = 0; i < allNames.length; i++) {\n                var name = allNames[i];\n                //';
var v27448 = v27449 + ' Search for the id in the value space first\n                // if we don\'t find it, search in the type space.\n                // We don\'t want to search twice, because the first\n                // search may insert the name in the symbol value table\n                // if the scope is aggregate\n                var publicsOnly = enclosingScopeContext.publicsOnly && enclosingScopeContext.isMemberCompletion;\n                var symbol = scope.find(name, publicsOnly, false/*typespace*/);  // REVIEW: Should search public members only?\n                if (symbol == null) {\n                    symbol = scope.find(name, publicsOnly, true/*typespace*/);\n                }\n\n                var displayThisMember = symbol && symbol.flags & SymbolFlags.Private ? symbol.container == scope.container : true;\n\n                if (symbol) {\n                    // Do not add dynamic module names to the list, since they\'re not legal as identifiers\n                    if (displayThisMember && !isQuoted(symbol.name) && !isRelative(symbol.name)) {\n                        var typeName = symbol.getType().getScopedTypeName(enclosingScope);\n                        result.push(new ScopeEntry(name, typeName, symbol));\n                    }\n                }\n                else {\n                    // Special case for "true" and "false"\n                    // REVIEW: This may no longer be necessary?\n                    if (name == "true" || name == "false") {\n                        result.push(new ScopeEntry(name, "bool", this.compiler.typeChecker.booleanType.symbol));\n                    }\n                }\n            }\n\n            return result;\n        }\n    }\n}\n//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule TypeScript {\n\n    export enum Primitive {\n        None = 0,\n        Void = 1,\n        Double = 2,\n        String = 4,\n        Boolean = 8,\n        Any = 16,\n        Null = 32,\n        Undefined = 64,\n    }\n\n    export class MemberName {\n        public prefix: string = "";\n        public suffix: string = "";\n\n        public isString() { return false; }\n        public isArray() { return false; }\n\n        public toString(): string {\n            return MemberName.memberNameToString(this);\n        }\n\n        static memberNameToString(memberName: MemberName): string {\n            var result = memberName.prefix;\n\n            if (memberName.isString()) {\n                result += (<MemberNameString>memberName).text;\n            }\n            else {\n                var ar = <MemberNameArray>memberName;\n                for (var index = 0; index < ar.entries.length; index++) {\n                    result += memberNameToString(ar.entries[index]);\n                    result += ar.delim;\n                }\n            }\n\n            result += memberName.suffix;\n            return result;\n        }\n\n        static create(text: string): MemberName;\n        static create(entry: MemberName, prefix: string, suffix: string): MemberName;\n        static create(arg1: any, arg2?: any, arg3?: any): MemberName {\n            if (typeof arg1 == "string") {\n                return new MemberNameString(arg1);\n            }\n            else {\n                var result = new MemberNameArray();\n                if (arg2)\n                    result.prefix = arg2;\n                if (arg3)\n                    result.suffix = arg3;\n                result.entries.push(arg1);\n                return result;\n            }\n        }\n    }\n\n    export class MemberNameString extends MemberName {\n        constructor (public text: string) {\n            super()\n        }\n\n        public isString() { return true; }\n    }\n\n    export class MemberNameArray extends MemberName {\n        public delim: string = "";\n        public entries: MemberName[] = [];\n\n        public isArray() { return true; }\n\n        public add(entry: MemberName) {\n            this.entries.push(entry);\n        }\n\n        public addAll(entries: MemberName[]) {\n            for (var i = 0 ; i < entries.length; i++) {\n                this.entries.push(entries[i]);\n            }\n        }\n    }\n\n    var currentTypeID = -1;\n\n    export class Type {\n        public typeID = currentTypeID++;\n\n        public members: ScopedMembers;\n        public ambientMembers: ScopedMembers;\n\n        public construct: SignatureGroup = null;\n        public call: SignatureGroup = null;\n        public index: SignatureGroup =';
var v27447 = v27448 + ' null;\n\n        // REVIEW: for either of the below, why do we have lists of types and lists of type links?\n        // interface can only extend\n        public extendsList: Type[];\n        public extendsTypeLinks: TypeLink[];\n\n        // class can also implement\n        public implementsList: Type[];\n        public implementsTypeLinks: TypeLink[];\n\n        public passTypeCreated: number = CompilerDiagnostics.analysisPass;\n\n        public baseClass(): Type {\n            if (this.extendsList && (this.extendsList.length > 0)) {\n                return this.extendsList[0];\n            }\n            else {\n                return null;\n            }\n        }\n\n        public elementType: Type;\n\n        public getArrayBase(arrInstType: Type, checker: TypeChecker): Type {\n            return this.arrayCache.specialize(arrInstType, checker);\n        }\n\n        public primitiveTypeClass: number = Primitive.None;\n\n        // REVIEW: Prune constructorScope\n        public constructorScope: SymbolScope;\n        public containedScope: SymbolScope;\n        public memberScope: SymbolScope;\n\n        public arrayCache: ArrayCache;\n\n        public typeFlags = TypeFlags.None;\n\n        public symbol: TypeSymbol;\n\n        public enclosingType: Type;\n        public instanceType: Type;\n\n        // REVIEW: Prune\n        public isClass() { return this.instanceType != null; }\n        public isArray() { return this.elementType != null; }\n        public isClassInstance() {\n            return this.symbol && !this.elementType && (<TypeSymbol>this.symbol).type.isClass();\n        }\n\n        public getInstanceType() {\n            if (this.isClass()) {\n                return this.instanceType;\n            }\n            else {\n                return this;\n            }\n        }\n\n        public hasImplementation() { return hasFlag(this.typeFlags, TypeFlags.HasImplementation); }\n        public setHasImplementation() { this.typeFlags |= TypeFlags.HasImplementation; }\n\n        public isDouble() { return hasFlag(this.primitiveTypeClass, Primitive.Double); }\n        public isString() { return hasFlag(this.primitiveTypeClass, Primitive.String); }\n        public isBoolean() { return hasFlag(this.primitiveTypeClass, Primitive.Boolean); }\n        public isNull() { return hasFlag(this.primitiveTypeClass, Primitive.Null); }\n\n        // REVIEW: No need for this to be a method\n        public getTypeName(): string {\n            return this.getMemberTypeName("", true, false, null);\n        }\n\n        public getScopedTypeName(scope: SymbolScope) {\n            return this.getMemberTypeName("", true, false, scope);\n        }\n\n        public getScopedTypeNameEx(scope: SymbolScope) {\n            return this.getMemberTypeNameEx("", true, false, scope);\n        }\n\n        // REVIEW: No need for this to be a method\n        public callCount() {\n            var total = 0;\n            if (this.call) {\n                total += this.call.signatures.length;\n            }\n            if (this.construct) {\n                total += this.construct.signatures.length;\n            }\n            if (this.index) {\n                total += this.index.signatures.length;\n            }\n            return total;\n        }\n\n        // REVIEW: No need for this to be a method\n        public getMemberTypeName(prefix: string, topLevel: bool, isElementType: bool, scope: SymbolScope): string {\n            var memberName = this.getMemberTypeNameEx(prefix, topLevel, isElementType, scope);\n            return memberName.toString();\n        }\n\n        // REVIEW: No need for this to be a method\n        public getMemberTypeNameEx(prefix: string, topLevel: bool, isElementType: bool, scope: SymbolScope): MemberName {\n            if (this.elementType) {\n                return MemberName.create(this.elementType.getMemberTypeNameEx(prefix, false, true, scope), "", "[]");\n            }\n            else if (this.symbol && this.symbol.name && this.symbol.name != "_anonymous" &&\n                     (((this.call == null) && (this.construct == null) && (this.index == null)) ||\n                      (hasFlag(this.typeFlags, TypeFlags.BuildingName)) ||\n                      (this.members && (!this.isClass())))) {\n                var tn = this.symbol.scopeRelativeName(scope);\n                return MemberName.create(tn == "null" ? "any" : tn); // REVIEW: GROSS!!!\n            }\n            else {\n                if (this.members || this.call || this.construct) {\n                    if (hasFlag(this.typeFlags, TypeFlags.BuildingName)) {\n                        return MemberName.create("this");\n                    }\n                    this.typeFlags |= TypeFlags.BuildingName;\n                    var builder = "";\n                    var allMemberNames = new MemberNameArray();\n                    var curlies = isElementType || this.index != null;\n                    var memCount = 0;\n                    var delim = "; ";\n                    if (this.members) {\n                        this.members.allMembers.map((key, ';
var v27446 = v27447 + 's, unused) => {\n                            var sym = <Symbol>s;\n                            if (!hasFlag(sym.flags, SymbolFlags.BuiltIn)) {\n                                // Remove the delimiter character from the generated type name, since\n                                // our "allMemberNames" array takes care of storing delimiters\n                                var typeNameMember = sym.getTypeNameEx(scope);\n                                if (typeNameMember.isArray() && (<MemberNameArray>typeNameMember).delim == delim) {\n                                    allMemberNames.addAll((<MemberNameArray>typeNameMember).entries);\n                                } else {\n                                    allMemberNames.add(typeNameMember);\n                                }\n                                memCount++;\n                                curlies = true;\n                            }\n                        }, null);\n                    }\n\n                    var signatureCount = this.callCount();\n                    var j: number;\n                    var len = 0;\n                    var shortform = !curlies && signatureCount == 1 && topLevel;\n                    if (this.call) {\n                        allMemberNames.addAll(this.call.toStrings(prefix, shortform, scope));\n                    }\n\n                    if (this.construct) {\n                        allMemberNames.addAll(this.construct.toStrings("new", shortform, scope));\n                    }\n\n                    if (this.index) {\n                        allMemberNames.addAll(this.index.toStrings("", shortform, scope));\n                    }\n\n                    if ((curlies) || ((signatureCount > 1) && topLevel)) {\n                        allMemberNames.prefix = "{ ";\n                        allMemberNames.suffix = "}";\n                        allMemberNames.delim = delim;\n                    } else if (allMemberNames.entries.length > 1) {\n                        allMemberNames.delim = delim;\n                    }\n\n                    this.typeFlags &= (~TypeFlags.BuildingName);\n                    if ((signatureCount == 0) && (memCount == 0)) {\n                        return MemberName.create("{}");\n                    }\n                    else {\n                        return allMemberNames;\n                    }\n                }\n                else {\n                    return MemberName.create("{}");\n                }\n            }\n        }\n\n        public checkDecl(checker: TypeChecker) {\n            if (this.isClassInstance() || this.isClass()) {\n                if (this.symbol.declAST) {\n                    checker.typeFlow.inScopeTypeCheckDecl(this.symbol.declAST);\n                }\n            }\n        }\n\n        public getMemberScope(flow: TypeFlow) {\n            if (this == flow.anyType) {\n                return null;\n            }\n            else if (this.isDouble()) {\n                if (flow.numberInterfaceType) {\n                    return flow.numberInterfaceType.memberScope;\n                }\n                else {\n                    return null;\n                }\n            }\n            else if (this.isBoolean()) {\n                if (flow.booleanInterfaceType) {\n                    return flow.booleanInterfaceType.memberScope;\n                }\n                else {\n                    return null;\n                }\n            }\n            else if (this == flow.stringType) {\n                if (flow.stringInterfaceType) {\n                    return flow.stringInterfaceType.memberScope;\n                }\n                else {\n                    return null;\n                }\n            }\n            else if (this.elementType) {\n                if (flow.arrayInterfaceType) {\n                    var arrInstType = this.elementType.getArrayBase(flow.arrayInterfaceType, flow.checker);\n                    return arrInstType.memberScope;\n                }\n                else {\n                    return null;\n                }\n            }\n            else {\n                return this.memberScope;\n            }\n        }\n\n        public isReferenceType() {\n            return this.members || this.extendsList ||\n                this.construct || this.call || this.index ||\n                this.elementType;\n        }\n\n        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker, membersOnly: bool): Type {\n            if (pattern == this) {\n                return replacement;\n            }\n            var result = this;\n            if (membersOnly) {\n                // assume interface type without bases\n                if (this.isReferenceType()) {\n                    result = new Type();\n                    if (this.members) {\n                        result.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n\n                        this.members.publicMembers.map((key, s, unused) => {\n                            var sym = <Symbol>s;\n         ';
var v27445 = v27446 + "                   var bSym = sym.specializeType(pattern, replacement, checker);\n                            result.members.addPublicMember(bSym.name, bSym);\n                        }, null);\n\n                        this.members.privateMembers.map((key, s, unused) => {\n                            var sym = <Symbol>s;\n                            var bSym = sym.specializeType(pattern, replacement, checker);\n                            result.members.addPrivateMember(bSym.name, bSym);\n                        }, null);\n                    }\n                    if (this.ambientMembers) {\n                        result.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));\n                        this.ambientMembers.publicMembers.map((key, s, unused) => {\n                            var sym = <Symbol>s;\n                            var bSym = sym.specializeType(pattern, replacement, checker);\n                            result.ambientMembers.addPublicMember(bSym.name, bSym);\n                        }, null);\n\n                        this.ambientMembers.privateMembers.map((key, s, unused) => {\n                            var sym = <Symbol>s;\n                            var bSym = sym.specializeType(pattern, replacement, checker);\n                            result.ambientMembers.addPrivateMember(bSym.name, bSym);\n                        }, null);\n                    }\n                    result.containedScope = checker.scopeOf(result);\n                    result.memberScope = result.containedScope;\n                }\n            }\n            else {\n                if (this.elementType) {\n                    if (this.elementType == pattern) {\n                        result = checker.makeArrayType(replacement);\n                    }\n                    else {\n                        if (this.elementType.elementType == pattern) {\n                            result = checker.makeArrayType(checker.makeArrayType(replacement));\n                        }\n                    }\n                }\n                else if (this.call) {\n                    result = new Type();\n                    result.call = this.call.specializeType(pattern, replacement, checker);\n                }\n            }\n            return result;\n        }\n\n        public hasBase(baseType: Type): bool {\n            if (baseType == this) {\n                return true;\n            }\n            else {\n                if (this.extendsList) {\n                    for (var i = 0, len = this.extendsList.length; i < len; i++) {\n                        if (this.extendsList[i].hasBase(baseType)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n\n        public mergeOrdered(b: Type, checker: TypeChecker, acceptVoid: bool, comparisonInfo?: TypeComparisonInfo): Type {\n            if ((this == checker.anyType) || (b == checker.anyType)) {\n                return checker.anyType;\n            }\n            else if (this == b) {\n                return this;\n            }\n            else if ((b == checker.nullType) && this != checker.nullType) {\n                return this;\n            }\n            else if ((this == checker.nullType) && (b != checker.nullType)) {\n                return b;\n            }\n            else if (acceptVoid && (b == checker.voidType) && this != checker.voidType) {\n                return this;\n            }\n            else if (acceptVoid && (this == checker.voidType) && (b != checker.voidType)) {\n                return b;\n            }\n            else if ((b == checker.undefinedType) && this != checker.undefinedType) {\n                return this;\n            }\n            else if ((this == checker.undefinedType) && (b != checker.undefinedType)) {\n                return b;\n            }\n            else if (this.elementType && b.elementType) {\n                if (this.elementType == b.elementType) {\n                    return this;\n                }\n                else {\n                    var mergedET = this.elementType.mergeOrdered(b.elementType, checker, acceptVoid, comparisonInfo);\n                    if (mergedET == null) {\n                        return checker.makeArrayType(checker.anyType);\n                    }\n                    else {\n                        return checker.makeArrayType(mergedET);\n                    }\n                }\n            }\n            else if (checker.sourceIsSubtypeOfTarget(this, b, comparisonInfo)) {\n                return b;\n            }\n            else if (checker.sourceIsSubtypeOfTarget(b, this, comparisonInfo)) {\n                return this;\n            }\n            else {\n                return null;\n            }\n        }\n\n        public isModuleType() { return false; }\n        public hasMembers() { return this.members != null; }\n        public getAllEnclosedTypes(): ScopedMembers { return null; }\n        public getAllAmbientEnc";
var v27444 = v27445 + 'losedTypes(): ScopedMembers { return null; }\n        public getPublicEnclosedTypes(): ScopedMembers { return null; }\n        public getpublicAmbientEnclosedTypes(): ScopedMembers { return null; }\n\n        public getDocComments(): Comment[]{\n            if (this.elementType || !this.symbol) {\n                return [];\n            }\n\n            if (this.isClassInstance() || this.isClass()) {\n                if (this.symbol.declAST.nodeType == NodeType.FuncDecl) {\n                    // Its a constructor - use the class declaration instead\n                    return (<FuncDecl>this.symbol.declAST).classDecl.getDocComments();\n                } else {\n                    // Its a class without constructor\n                    return this.symbol.getDocComments();\n                }\n            }\n\n            if (this.symbol.name && this.symbol.name != "_anonymous" &&\n                (((this.call == null) && (this.construct == null) && (this.index == null))\n                  || this.members)) {\n                return this.symbol.getDocComments();\n            }\n\n            return [];\n        }\n    }\n\n    export interface ITypeCollection {\n        // returns null when types are exhausted\n        getLength(): number;\n        setTypeAtIndex(index: number, type: Type): void;\n        getTypeAtIndex(index: number): Type;\n    }\n\n    export class ModuleType extends Type {\n\n        constructor (public enclosedTypes: ScopedMembers, public ambientEnclosedTypes: ScopedMembers) {\n            super();\n        }\n\n        public isModuleType() { return true; }\n        public hasMembers() { return this.members != null || this.enclosedTypes != null; }\n        public getAllEnclosedTypes() { return this.enclosedTypes; }\n        public getAllAmbientEnclosedTypes() { return this.ambientEnclosedTypes; }\n        public getPublicEnclosedTypes(): ScopedMembers { return null; }\n        public getpublicAmbientEnclosedTypes(): ScopedMembers { return null; }\n        public importedModules: ImportDeclaration[] = [];\n\n        // Finds the dynamic module name of moduleType in the members\n        // ignoreSymbols define list of symbols already visited - to avoid recursion\n        static findDynamicModuleNameInHashTable(moduleType: Type, members: IHashTable) {\n            var moduleName: { name: string; symbol: Symbol; } = null;\n            members.map((key, s, c) => {\n                if (moduleName == null && !isQuoted(key)) {\n                    var symbol = <Symbol>s;\n                    var type = symbol.getType();\n                    if (type == moduleType) {\n                        // If this is the module type we were looking for\n                        moduleName = { name: key, symbol: symbol };\n                    }\n                }\n            }, null);\n\n            return moduleName;\n        }\n\n        // Finds the Dynamic module name of the moduleType in this moduleType\n        // onlyPublic tells if we are looking for module name in public members only\n        public findDynamicModuleName(moduleType: Type): { name: string; symbol: Symbol; } {\n            var moduleName: { name: string; symbol: Symbol; } = null;\n            // Not cached, so seach and add to the cache\n            moduleName = ModuleType.findDynamicModuleNameInHashTable(moduleType, this.members.allMembers);\n            if (moduleName == null) {\n                moduleName = ModuleType.findDynamicModuleNameInHashTable(moduleType, this.ambientMembers.allMembers);\n            }\n            return moduleName;\n        }\n    }\n\n    export class TypeLink {\n        public type: Type = null;\n        public ast: AST = null;\n    }\n\n    export function getTypeLink(ast: AST, checker: TypeChecker, autoVar: bool): TypeLink {\n        var result = new TypeLink();\n\n        result.ast = ast;\n\n        if ((ast == null) && (autoVar)) {\n            result.type = checker.anyType;\n        }\n        else {\n            result.type = null;\n        }\n\n        return result;\n    }\n\n}//\n// Copyright (c) Microsoft Corporation.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n///<reference path=\'typescript.ts\' />\n\nmodule Tools {\n    export interface IWalkContext {\n        goChildren: bool;\n        goNextSibling: bool;\n        // visit siblings in reverse execution order\n        reverseSiblings: bool;\n    }\n\n    export class BaseWalkContext implements IWalkContext {\n        public goChildren = true;\n        public goNextSibling = true;\n        public reverseSiblings = false;\n    }\n}';
var compiler_input = v27444;
var TypeScript;
var v18836 = TypeScript;
var v23037 = !v18836;
if (v23037) {
  v18836 = TypeScript = {};
}
var v12340 = v18836;
v48(v12340);
var v18837 = TypeScript;
var v23038 = !v18837;
if (v23038) {
  v18837 = TypeScript = {};
}
var v12341 = v18837;
v49(v12341);
var v18838 = TypeScript;
var v23039 = !v18838;
if (v23039) {
  v18838 = TypeScript = {};
}
var v12342 = v18838;
v78(v12342);
var v12343 = this.__extends;
var v18839 = !v12343;
if (v18839) {
  v12343 = v79;
}
var __extends = v12343;
var v18840 = TypeScript;
var v23040 = !v18840;
if (v23040) {
  v18840 = TypeScript = {};
}
var v12344 = v18840;
v322(v12344);
var v18841 = TypeScript;
var v23041 = !v18841;
if (v23041) {
  v18841 = TypeScript = {};
}
var v12345 = v18841;
v333(v12345);
var v18842 = TypeScript;
var v23042 = !v18842;
if (v23042) {
  v18842 = TypeScript = {};
}
var v12346 = v18842;
v335(v12346);
var v18843 = TypeScript;
var v23043 = !v18843;
if (v23043) {
  v18843 = TypeScript = {};
}
var v12347 = v18843;
v399(v12347);
var v18844 = TypeScript;
var v23044 = !v18844;
if (v23044) {
  v18844 = TypeScript = {};
}
var v12348 = v18844;
v407(v12348);
var v18845 = TypeScript;
var v23045 = !v18845;
if (v23045) {
  v18845 = TypeScript = {};
}
var v12349 = v18845;
v417(v12349);
var v18846 = TypeScript;
var v23046 = !v18846;
if (v23046) {
  v18846 = TypeScript = {};
}
var v12350 = v18846;
v420(v12350);
var JSON2 = {};
v427();
var v18847 = TypeScript;
var v23047 = !v18847;
if (v23047) {
  v18847 = TypeScript = {};
}
var v12351 = v18847;
v433(v12351);
var v18848 = TypeScript;
var v23048 = !v18848;
if (v23048) {
  v18848 = TypeScript = {};
}
var v12352 = v18848;
v492(v12352);
var v18849 = TypeScript;
var v23049 = !v18849;
if (v23049) {
  v18849 = TypeScript = {};
}
var v12353 = v18849;
v519(v12353);
var v18850 = TypeScript;
var v23050 = !v18850;
if (v23050) {
  v18850 = TypeScript = {};
}
var v12354 = v18850;
v592(v12354);
var v18851 = TypeScript;
var v23051 = !v18851;
if (v23051) {
  v18851 = TypeScript = {};
}
var v12355 = v18851;
v599(v12355);
var v18852 = TypeScript;
var v23052 = !v18852;
if (v23052) {
  v18852 = TypeScript = {};
}
var v12356 = v18852;
v675(v12356);
var v18853 = TypeScript;
var v23053 = !v18853;
if (v23053) {
  v18853 = TypeScript = {};
}
var v12357 = v18853;
v680(v12357);
var v18854 = TypeScript;
var v23054 = !v18854;
if (v23054) {
  v18854 = TypeScript = {};
}
var v12358 = v18854;
v698(v12358);
var v18855 = TypeScript;
var v23055 = !v18855;
if (v23055) {
  v18855 = TypeScript = {};
}
var v12359 = v18855;
v711(v12359);
var v18856 = TypeScript;
var v23056 = !v18856;
if (v23056) {
  v18856 = TypeScript = {};
}
var v12360 = v18856;
v794(v12360);
var v18857 = TypeScript;
var v23057 = !v18857;
if (v23057) {
  v18857 = TypeScript = {};
}
var v12361 = v18857;
v862(v12361);
var v18858 = TypeScript;
var v23058 = !v18858;
if (v23058) {
  v18858 = TypeScript = {};
}
var v12362 = v18858;
v892(v12362);
var v18859 = TypeScript;
var v23059 = !v18859;
if (v23059) {
  v18859 = TypeScript = {};
}
var v12363 = v18859;
v964(v12363);
var v18860 = TypeScript;
var v23060 = !v18860;
if (v23060) {
  v18860 = TypeScript = {};
}
var v12364 = v18860;
v967(v12364);
var v18861 = TypeScript;
var v23061 = !v18861;
if (v23061) {
  v18861 = TypeScript = {};
}
var v12365 = v18861;
v1113(v12365);
var v18862 = TypeScript;
var v23062 = !v18862;
if (v23062) {
  v18862 = TypeScript = {};
}
var v12366 = v18862;
v1172(v12366);
var v18863 = TypeScript;
var v23063 = !v18863;
if (v23063) {
  v18863 = TypeScript = {};
}
var v12367 = v18863;
v1173(v12367);
var v18864 = TypeScript;
var v23064 = !v18864;
if (v23064) {
  v18864 = TypeScript = {};
}
var v12368 = v18864;
v1180(v12368);
var v18865 = TypeScript;
var v23065 = !v18865;
if (v23065) {
  v18865 = TypeScript = {};
}
var v12369 = v18865;
v1186(v12369);
var v18866 = TypeScript;
var v23066 = !v18866;
if (v23066) {
  v18866 = TypeScript = {};
}
var v12370 = v18866;
v1195(v12370);
var v18867 = TypeScript;
var v23067 = !v18867;
if (v23067) {
  v18867 = TypeScript = {};
}
var v12371 = v18867;
v1233(v12371);
var v18868 = TypeScript;
var v23068 = !v18868;
if (v23068) {
  v18868 = TypeScript = {};
}
var v12372 = v18868;
v1288(v12372);
var v18869 = TypeScript;
var v23069 = !v18869;
if (v23069) {
  v18869 = TypeScript = {};
}
var v12373 = v18869;
v1311(v12373);
var IOUtils;
var v18870 = IOUtils;
var v23070 = !v18870;
if (v23070) {
  v18870 = IOUtils = {};
}
var v12374 = v18870;
v1312(v12374);
var IO = v1357();
var OptionsParser = v1365();
var CommandLineHost = v1370();
var BatchCompiler = v1409();
var completed = 0;
var benchmarks = BenchmarkSuite.CountBenchmarks();
var success = true;
var latencyBenchmarks = ["Splay", "Mandreel"];
var v12375;
var v23071 = typeof skipBenchmarks;
var v18871 = v23071 === "undefined";
if (v18871) {
  v12375 = [];
} else {
  v12375 = skipBenchmarks;
}
var skipBenchmarks = v12375

}
